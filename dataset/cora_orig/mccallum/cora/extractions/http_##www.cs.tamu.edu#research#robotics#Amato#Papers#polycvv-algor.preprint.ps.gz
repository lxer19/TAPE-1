URL: http://www.cs.tamu.edu/research/robotics/Amato/Papers/polycvv-algor.preprint.ps.gz
Refering-URL: http://www.cs.tamu.edu/faculty/amato/dsmft/publications.html
Root-URL: http://www.cs.tamu.edu
Email: email: amato@cs.uiuc.edu  
Title: Finding a Closest Visible Vertex Pair Between Two Polygons  
Author: Nancy M. Amato 
Address: 1308 W. Main St. Urbana, IL 61801  
Affiliation: Coordinated Science Laboratory and Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract: Given nonintersecting simple polygons P and Q, two vertices p 2 P and q 2 Q are said to be visible if pq does not properly intersect P or Q. We present a parallel algorithm for finding a closest pair among all visible pairs (p; q), p 2 P and q 2 Q. The algorithm runs in time O(log n) using O(n) processors on a CREW PRAM, where n = jP j + jQj. This algorithm can be implemented serially in fi(n) time, which gives a new optimal sequential solution for this problem. 
Abstract-found: 1
Intro-found: 1
Reference: [ACG + 88] <author> A. Aggarwal, B. Chazelle, L. Guibas, C. O'Dunlaing, and C. Yap. </author> <title> Parallel computational geometry. </title> <journal> Algorithmica, </journal> <volume> 3 </volume> <pages> 293-327, </pages> <year> 1988. </year>
Reference-contexts: (log n) time and O (n) processors on a CREW PRAM. (Alternatively, these pruning operations can be performed by modified versions of parallel planar convex hull algorithms; appropriate choices are the optimal O (log n) time CREW PRAM algorithm independently due to Atallah and Goodrich [AG86] and Aggarwal et al. <ref> [ACG + 88] </ref>, and the optimal O (log n) time EREW PRAM algorithm of Miller and Stout [MS88].) Ray shooting queries also prove useful in Step 2 when constructing the regions R (p) and R (q), 8p 2 P; q 2 Q.
Reference: [AG86] <author> M. J. Atallah and M. T. Goodrich. </author> <title> Efficient parallel solutions to some geometric problems. </title> <journal> J. Parallel Distrib. Comput., </journal> <volume> 3 </volume> <pages> 492-507, </pages> <year> 1986. </year>
Reference-contexts: Thus, Step 1 requires O (log n) time and O (n) processors on a CREW PRAM. (Alternatively, these pruning operations can be performed by modified versions of parallel planar convex hull algorithms; appropriate choices are the optimal O (log n) time CREW PRAM algorithm independently due to Atallah and Goodrich <ref> [AG86] </ref> and Aggarwal et al. [ACG + 88], and the optimal O (log n) time EREW PRAM algorithm of Miller and Stout [MS88].) Ray shooting queries also prove useful in Step 2 when constructing the regions R (p) and R (q), 8p 2 P; q 2 Q.
Reference: [AG88] <author> M. J. Atallah and M. T. Goodrich. </author> <title> Parallel algorithms for some functions of two convex polygons. </title> <journal> Algorithmica, </journal> <volume> 3 </volume> <pages> 535-548, </pages> <year> 1988. </year>
Reference-contexts: We describe a parallel algorithm for computing cvv (P; Q) that runs in time O (log n) using O (n) processors on a CREW PRAM. Although it is not work-optimal, our algorithm is time-optimal, as shown by Atallah and Goodrich <ref> [AG88] </ref>. Actually, they show that any parallel algorithm for the separation problem requires (log n) time on an exclusive write PRAM (i.e., an EREW or a CREW PRAM) with a polynomial number of processors; however, their argument can easily be applied to the CVV problem as well. <p> This improves over the best previous sequential time bound of O (n log n) which was based on generalized Voronoi diagrams [Kir79, For87, Yap87]. The parallel complexity of the separation problem had not been previously studied except in the special case in which both polygons are convex <ref> [AG88, DK87] </ref>; however, a solution of the general case can be found in O (log 2 n) time using O (n) processors on a CREW PRAM since generalized Voronoi diagrams can be computed within these resource bounds [G OY93]. 2 Nonintersecting Simple Polygons In this section we decompose the problem of <p> Although it is time-optimal (as established by Atallah and Goodrich <ref> [AG88] </ref>), our parallel algorithm is not work-optimal, i.e., the processor-time product is O (n log n).
Reference: [AK91] <author> M. J. Atallah and S. R. Kosaraju. </author> <title> An efficient parallel algorithm for the row minima of a totally monotone matrix. </title> <booktitle> In Proc. 2nd ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 394-403, </pages> <year> 1991. </year>
Reference-contexts: Atallah and Kosaraju <ref> [AK91] </ref> show that if every entry of a totally monotone matrix can be computed in constant time, then a minimum entry in every row can be found in O (log m + log n) time using O (m+n) processors on a CREW PRAM. <p> Once the u + i and u i points are known, the regions R (p i ), 81 i n, can be computed in constant time using one CREW PRAM processor for each p i 2 P . In Step 3, we use the algorithm of Atallah and Kosaraju <ref> [AK91] </ref> to find a minimum entry in each row of the totally monotone matrix in time O (log n) using O (n) processors on a CREW PRAM; a minimum entry in M , and thus cvv (P; Q), can then be found within these same resource bounds by finding the minimum
Reference: [AKM + 86] <author> A. Aggarwal, M. M. Klawe, S. Moran, P. Shor, and R. Wilber. </author> <title> Geometric applications of a matrix searching algorithm. </title> <booktitle> In Proc. 2nd Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 285-292, </pages> <year> 1986. </year>
Reference-contexts: A minimum entry in the totally monotone matrix M can then be found in O (n) time using the algorithm of of Aggarwal et al. <ref> [AKM + 86] </ref>.
Reference: [Ama92] <author> N. M. Amato. </author> <title> Computing the minimum visible vertex distance between two nonintersecting simple polygons. </title> <booktitle> In Proc. 1992 Conf. Inform. Sci. Systems, </booktitle> <volume> volume II, </volume> <pages> pages 800-805, </pages> <address> Princeton, NJ, </address> <year> 1992. </year>
Reference-contexts: If exactly one of P or Q is convex, then cvv (P; Q) can also be computed sequentially in time fi (n) [CSW85, Wan83]. Several sequential CVV algorithms have been proposed fl This paper appeared in preliminary form as <ref> [Ama92] </ref> y This work was supported in part by an AT&T Bell Laboratories Graduate Fellowship, the Joint Services Electronics Program (U.S. Army, U.S. Navy, U.S.
Reference: [Ama93] <author> N. M. Amato. </author> <title> An optimal algorithm for finding the separation of simple polygons. </title> <booktitle> In Proc. 3rd Workshop Algorithms Data Struct., volume 709 of Lecture Notes in Computer Science, </booktitle> <pages> pages 48-59. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> (To appear in International Journal of Computational Geometry & Applications as: Determining the Separation of Simple Polygons.) </note>
Reference-contexts: In particular, we show in <ref> [Ama93] </ref> that the CVV algorithm presented here can be modified to find the separation of two simple polygons; the parallel separation algorithm uses O (log n) time and O (n) processors on a CREW PRAM, and its sequential version runs fi (n) time.
Reference: [AMSS89] <author> A. Aggarwal, S. Moran, P. W. Shor, and S. Suri. </author> <title> Computing the minimum visible vertex distance between two polygons. </title> <booktitle> In Proc. 1st Workshop Algorithms Data Struct., volume 382 of Lecture Notes in Computer Science, </booktitle> <pages> pages 115-134. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Force) under contract N00014-90-J-1270, and NSF Grant CCR-89-22008. 1 distance is realized by the pair (p c ; q c ). when neither P nor Q is convex: Wang and Chan [WC86] have given an algorithm for computing cvv (P; Q) in time O (n log n), Aggarwal et al. <ref> [AMSS89] </ref> proposed an optimal fi (n) algorithm for this problem, and recently Hershberger and Suri [HS93] have given a general technique which can be used to solve several problems dealing with shortest paths in simple polygons, including the CVV problem, in O (n) time. <p> The sequential algorithms of Wang and Chan [WC86], and Aggarwal et al. <ref> [AMSS89] </ref>, and the parallel algorithm of Hsu et al. [HCL92] all have this same general strategy. We give a new decomposition technique that is much simpler than the corresponding methods used in the above mentioned CVV algorithms [WC86, AMSS89, HCL92]. <p> The sequential algorithms of Wang and Chan [WC86], and Aggarwal et al. [AMSS89], and the parallel algorithm of Hsu et al. [HCL92] all have this same general strategy. We give a new decomposition technique that is much simpler than the corresponding methods used in the above mentioned CVV algorithms <ref> [WC86, AMSS89, HCL92] </ref>. Our solution of the linearly separable subproblems is a modification of the sequential technique of Aggarwal et al., which includes some new ideas and some concepts first introduced in the sequential algorithm of Wang and Chan. <p> However, we must modify the technique of Aggarwal et al. for solving the subproblems since, as is discussed in Section 3.2, the technique, as presented in <ref> [AMSS89] </ref>, does not always correctly determine cvv (P 0 ; Q 0 ); since this portion of the parallel algorithm of Hsu et al. is a direct parallelization of the method of Aggarwal et al., their algorithm suffers this shortcoming as well. <p> Although similar decomposition takes place in the parallel algorithm of Hsu et al. [HCL92], and in the sequential algorithms of Wang and Chan [WC86] and Aggarwal et al. <ref> [AMSS89] </ref>, the methods used in these algorithms to find an appropriate set of separating line segments and to construct the subproblems are quite involved. <p> We present an algorithm for this special case that determines cvv (P; Q) in O (log n) time using O (n) processors on a CREW PRAM. As mentioned before, the CVV algorithms of Wang and Chan [WC86], Aggarwal et al. <ref> [AMSS89] </ref>, and Hsu et al. [HCL92] also define and solve subproblems of this type when solving a general instance of the CVV problem. <p> is easy to see that the pruning required in Step 1, and the computation of the feasible regions R () in Step 2 can accomplished sequentially by performing O (1) linear scans of P and Q; this linear scanning technique was used by the sequential CVV algorithms of [WC86] and <ref> [AMSS89] </ref>, and is similar to the process of finding the convex hull of a simple polygon [BE84] or of triangulating a polygon monotonic with respect to a line [GJPT78]. <p> They solve the subproblems by a divide-and-conquer process requiring O (n log n) time. The algorithm of Aggarwal et al. <ref> [AMSS89] </ref> builds upon the general paradigm proposed by Wang and Chan: they solve the general problem by solving subproblems involving linearly separable subchains. They begin by pruning the chains so that they are monotone with respect to the separating line l. <p> Thus, their algorithm also suffers from the first problem (but not the second) noted above for the algorithm of Aggarwal et al.. In summary, our algorithm introduces the requirement of perpendicular visibility, and incorporates techniques from both the sequential algorithms of Wang and Chan [WC86] and Aggarwal et al. <ref> [AMSS89] </ref>. Wang and Chan proposed the requirement that all candidate vertices must have visible angles of at least 90 ffi . <p> This algorithm consists of two distinct phases: the first phase decomposes the original problem into a collection of restricted subproblems which are solved independently in the second phase. This same general strategy was used in the sequential algorithms of Wang and Chan [WC86] and Ag-garwal et al. <ref> [AMSS89] </ref>, and in the parallel algorithm of Hsu et al. [HCL92]. We provide a new decomposition technique that is much simpler than those used in these other CVV algorithms [WC86, AMSS89, HCL92]. <p> This same general strategy was used in the sequential algorithms of Wang and Chan [WC86] and Ag-garwal et al. [AMSS89], and in the parallel algorithm of Hsu et al. [HCL92]. We provide a new decomposition technique that is much simpler than those used in these other CVV algorithms <ref> [WC86, AMSS89, HCL92] </ref>. In addition, a serial version of our algorithm can be implemented in fi (n) time and thus provides a new optimal sequential algorithm that is simpler than that of Aggarwal et al..
Reference: [BE84] <author> B. K. Bhattacharya and H. ElGindy. </author> <title> A new linear convex hull algorithm for simple polygons. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> IT-30:85-88, </volume> <year> 1984. </year>
Reference-contexts: feasible regions R () in Step 2 can accomplished sequentially by performing O (1) linear scans of P and Q; this linear scanning technique was used by the sequential CVV algorithms of [WC86] and [AMSS89], and is similar to the process of finding the convex hull of a simple polygon <ref> [BE84] </ref> or of triangulating a polygon monotonic with respect to a line [GJPT78]. A minimum entry in the totally monotone matrix M can then be found in O (n) time using the algorithm of of Aggarwal et al. [AKM + 86].
Reference: [Cha91] <author> B. Chazelle. </author> <title> Triangulating a simple polygon in linear time. </title> <journal> Discrete Comput. Geom., </journal> <volume> 6 </volume> <pages> 485-524, </pages> <year> 1991. </year>
Reference-contexts: The shortest path can be found in O (n) time using the technique of Guibas and Hershberger [GH89]; this requires that the polygon first be triangulated which Chazelle has shown can be done in linear time <ref> [Cha91] </ref>. It is a simple matter to verify that the extension of the endpoints in Step 1 (c) and the pruning of the subchains in Step 2 (b) can be accomplished by linear scans of the simple polygon R, i.e., in O (n) time.
Reference: [Che90] <author> D. Z. Chen. </author> <title> Efficient geometric algorithms in the EREW-PRAM. </title> <booktitle> In Proc. 28th Allerton Conf. Commun. Control Comput., </booktitle> <pages> pages 818-827, </pages> <year> 1990. </year>
Reference-contexts: we compute the convex hulls of P , Q, and P [ Q, and then test whether CH (P [ Q) is identical to CH (P ) or CH (Q); the former can be accomplished in O (log n) time using O (n= log n) processors on an EREW PRAM <ref> [Che90, DK90] </ref>, and the latter can be done in constant time using O (n) processors.
Reference: [CSW85] <author> F. Chin, J. Sampson, and C. A. Wang. </author> <title> A unifying approach for a class of problems in the computational geometry of polygons. </title> <journal> Visual Comput., </journal> <volume> 1 </volume> <pages> 124-132, </pages> <year> 1985. </year>
Reference-contexts: Let jP j + jQj = n. The CVV problem has been addressed sequentially in various cases. When both P and Q are convex, cvv (P; Q) can be computed sequentially in time fi (n) <ref> [MT85, Tou84, CSW85] </ref>. If exactly one of P or Q is convex, then cvv (P; Q) can also be computed sequentially in time fi (n) [CSW85, Wan83]. <p> When both P and Q are convex, cvv (P; Q) can be computed sequentially in time fi (n) [MT85, Tou84, CSW85]. If exactly one of P or Q is convex, then cvv (P; Q) can also be computed sequentially in time fi (n) <ref> [CSW85, Wan83] </ref>. Several sequential CVV algorithms have been proposed fl This paper appeared in preliminary form as [Ama92] y This work was supported in part by an AT&T Bell Laboratories Graduate Fellowship, the Joint Services Electronics Program (U.S. Army, U.S. Navy, U.S.
Reference: [DK87] <author> N. Dadoun and D. Kirkpatrick. </author> <title> Optimal parallel algorithms for convex polygon separation. </title> <type> Report 89-21, </type> <institution> Dept. Comput. Sci., Univ. British Columbia, Vancouver, British Columbia, Canada, </institution> <year> 1987. </year>
Reference-contexts: This improves over the best previous sequential time bound of O (n log n) which was based on generalized Voronoi diagrams [Kir79, For87, Yap87]. The parallel complexity of the separation problem had not been previously studied except in the special case in which both polygons are convex <ref> [AG88, DK87] </ref>; however, a solution of the general case can be found in O (log 2 n) time using O (n) processors on a CREW PRAM since generalized Voronoi diagrams can be computed within these resource bounds [G OY93]. 2 Nonintersecting Simple Polygons In this section we decompose the problem of
Reference: [DK90] <author> D. P. Dobkin and D. G. Kirkpatrick. </author> <title> Determining the separation of preprocessed polyhedra a unified approach. </title> <booktitle> In Proc. 17th Internat. Colloq. Automata Lang. Program., volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 400-413. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The former variant is known as the separation problem <ref> [DK90] </ref>, and we will refer to the latter variant as the closest visible vertex or the CVV problem (see Fig. 1). The Euclidean distance between a pair of points realizing the closest visible vertex distance between P and Q is denoted by cvv (P; Q). <p> we compute the convex hulls of P , Q, and P [ Q, and then test whether CH (P [ Q) is identical to CH (P ) or CH (Q); the former can be accomplished in O (log n) time using O (n= log n) processors on an EREW PRAM <ref> [Che90, DK90] </ref>, and the latter can be done in constant time using O (n) processors. <p> In the non-containing case the simple polygon R is completed by segments belonging to the two common supporting lines of CH (P ) and CH (Q) (see Fig. 2 (a)); these supporting lines can be found by the O (log n) sequential technique of Dobkin and Kirkpatrick <ref> [DK90] </ref> when merging CH (P ) and CH (Q) to form CH (P [ Q). The construction of R in the containing case is nearly as simple.
Reference: [For87] <author> S. J. Fortune. </author> <title> A sweepline algorithm for Voronoi diagrams. </title> <journal> Algorithmica, </journal> <volume> 2 </volume> <pages> 153-174, </pages> <year> 1987. </year>
Reference-contexts: This improves over the best previous sequential time bound of O (n log n) which was based on generalized Voronoi diagrams <ref> [Kir79, For87, Yap87] </ref>.
Reference: [GH89] <author> L. J. Guibas and J. Hershberger. </author> <title> Optimal shortest path queries in a simple polygon. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 39 </volume> <pages> 126-152, </pages> <year> 1989. </year>
Reference-contexts: The only portions of the above description that require more than O (n) work are the shortest path computation and the ray shooting queries. The shortest path can be found in O (n) time using the technique of Guibas and Hershberger <ref> [GH89] </ref>; this requires that the polygon first be triangulated which Chazelle has shown can be done in linear time [Cha91].
Reference: [GJPT78] <author> M. R. Garey, D. S. Johnson, F. P. Preparata, and R. E. Tarjan. </author> <title> Triangulating a simple polygon. </title> <journal> Inform. Process. Lett., </journal> <volume> 7 </volume> <pages> 175-179, </pages> <year> 1978. </year>
Reference-contexts: O (1) linear scans of P and Q; this linear scanning technique was used by the sequential CVV algorithms of [WC86] and [AMSS89], and is similar to the process of finding the convex hull of a simple polygon [BE84] or of triangulating a polygon monotonic with respect to a line <ref> [GJPT78] </ref>. A minimum entry in the totally monotone matrix M can then be found in O (n) time using the algorithm of of Aggarwal et al. [AKM + 86].
Reference: [Goo89] <author> M. T. Goodrich. </author> <title> Triangulating a polygon in parallel. </title> <journal> J. Algorithms, </journal> <volume> 10 </volume> <pages> 327-351, </pages> <year> 1989. </year>
Reference-contexts: The shortest path in Step 1 (b) can be computed in O (log n) time using O (n= log n) processors by the technique of Goodrich et al. [GSG90]; this technique requires that R be triangulated which can be done in O (log n) time using O (n) processors <ref> [Goo89] </ref>. <p> Since P and Q are separated by l, an appropriate simple polygon can be found and triangulated in O (log n) time using O (n) processors <ref> [Goo89] </ref>.
Reference: [G OY93] <author> M. T. Goodrich, C. O'Dunlaing, and C. Yap. </author> <title> Constructing the Voronoi diagram of a set of line segments in par all el. </title> <journal> Algorithmica, </journal> <volume> 9 </volume> <pages> 128-141, </pages> <year> 1993. </year>
Reference-contexts: previously studied except in the special case in which both polygons are convex [AG88, DK87]; however, a solution of the general case can be found in O (log 2 n) time using O (n) processors on a CREW PRAM since generalized Voronoi diagrams can be computed within these resource bounds <ref> [G OY93] </ref>. 2 Nonintersecting Simple Polygons In this section we decompose the problem of computing cvv (P; Q) into a collection of restricted subproblems.
Reference: [GSG90] <author> M. T. Goodrich, S. B. Shauck, and S. Guha. </author> <title> Parallel methods for visibility and shortest path problems in simple polygons. </title> <booktitle> In Proc. 6th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 73-82, </pages> <year> 1990. </year>
Reference-contexts: The shortest path in Step 1 (b) can be computed in O (log n) time using O (n= log n) processors by the technique of Goodrich et al. <ref> [GSG90] </ref>; this technique requires that R be triangulated which can be done in O (log n) time using O (n) processors [Goo89]. <p> The extension of the endpoints of the shortest path in Step 1 (c) can be done by ray shooting queries (i.e., given a simple polygon R and a query ray r, what is the first edge of R that is hit by r); the technique of Goodrich et al. <ref> [GSG90] </ref> answers such queries in O (log n) time with a single processor. The removal of the redundant segments from SP (P; Q) in Step 1 (d) can be performed by a list ranking process in O (log n) time using O (n= log n) processors. <p> The construction of the subproblems in Step 2 is straightforward once S (P; Q) is found. Each subproblem can be defined in O (1) time, and, if necessary, the pruning of the subchains can be accomplished in O (log n) time with O (n) processors using ray shooting queries <ref> [GSG90] </ref>. Thus, Step 2 requires O (log n) time and O (n) processors. A CREW PRAM is needed for Steps 1 and 2 since the ray query data structure may be involved in O (n) simultaneous queries, i.e., concurrent accesses. <p> Further note that the wedge W (p) is identified by the first edges on 12 the shortest paths from p to p 1 and p n p , respectively. We recall that Goodrich et al. <ref> [GSG90] </ref> give techniques, requiring preprocessing of O (log n) time and O (n) processors, for a triangulated simple polygon that can answer ray shooting queries and can identify the first edge of a shortest path in O (log n) time using a single processor.
Reference: [HCL92] <author> F. R. Hsu, R. C. Chang, and R. C. T. Lee. </author> <title> Parallel algorithms for computing the closest visible vertex pair between two polygons. </title> <journal> Internat. J. Comput. Geom. Appl., </journal> <volume> 2(2) </volume> <pages> 135-162, </pages> <year> 1992. </year>
Reference-contexts: In parallel, the CVV problem has been addressed for the case in which neither polygon is convex by Hsu et al. <ref> [HCL92] </ref>. Their O (log n) time and O (n) processor algorithm is patterned after the sequential algorithm of Aggarwal et al.. <p> The sequential algorithms of Wang and Chan [WC86], and Aggarwal et al. [AMSS89], and the parallel algorithm of Hsu et al. <ref> [HCL92] </ref> all have this same general strategy. We give a new decomposition technique that is much simpler than the corresponding methods used in the above mentioned CVV algorithms [WC86, AMSS89, HCL92]. <p> The sequential algorithms of Wang and Chan [WC86], and Aggarwal et al. [AMSS89], and the parallel algorithm of Hsu et al. [HCL92] all have this same general strategy. We give a new decomposition technique that is much simpler than the corresponding methods used in the above mentioned CVV algorithms <ref> [WC86, AMSS89, HCL92] </ref>. Our solution of the linearly separable subproblems is a modification of the sequential technique of Aggarwal et al., which includes some new ideas and some concepts first introduced in the sequential algorithm of Wang and Chan. <p> Although similar decomposition takes place in the parallel algorithm of Hsu et al. <ref> [HCL92] </ref>, and in the sequential algorithms of Wang and Chan [WC86] and Aggarwal et al. [AMSS89], the methods used in these algorithms to find an appropriate set of separating line segments and to construct the subproblems are quite involved. <p> We present an algorithm for this special case that determines cvv (P; Q) in O (log n) time using O (n) processors on a CREW PRAM. As mentioned before, the CVV algorithms of Wang and Chan [WC86], Aggarwal et al. [AMSS89], and Hsu et al. <ref> [HCL92] </ref> also define and solve subproblems of this type when solving a general instance of the CVV problem. <p> It is not clear that this claim can be established if vertices with visible angles less than 90 ffi are retained in the candidate pool. The parallel algorithm for the linearly separable subproblems of Hsu et al. <ref> [HCL92] </ref> is a direct parallelization of the technique of Aggarwal et al. An exception is that they prune vertices from the subchains that have visible angles less than 90 ffi . <p> This same general strategy was used in the sequential algorithms of Wang and Chan [WC86] and Ag-garwal et al. [AMSS89], and in the parallel algorithm of Hsu et al. <ref> [HCL92] </ref>. We provide a new decomposition technique that is much simpler than those used in these other CVV algorithms [WC86, AMSS89, HCL92]. <p> This same general strategy was used in the sequential algorithms of Wang and Chan [WC86] and Ag-garwal et al. [AMSS89], and in the parallel algorithm of Hsu et al. [HCL92]. We provide a new decomposition technique that is much simpler than those used in these other CVV algorithms <ref> [WC86, AMSS89, HCL92] </ref>. In addition, a serial version of our algorithm can be implemented in fi (n) time and thus provides a new optimal sequential algorithm that is simpler than that of Aggarwal et al..
Reference: [HS93] <author> J. Hershberger and S. Suri. </author> <title> Matrix searching with the shortest path metric. </title> <booktitle> In Proc. 25th Annu. ACM Sympos. Theory Comput. (STOC 93), </booktitle> <pages> pages 485-494, </pages> <year> 1993. </year>
Reference-contexts: (p c ; q c ). when neither P nor Q is convex: Wang and Chan [WC86] have given an algorithm for computing cvv (P; Q) in time O (n log n), Aggarwal et al. [AMSS89] proposed an optimal fi (n) algorithm for this problem, and recently Hershberger and Suri <ref> [HS93] </ref> have given a general technique which can be used to solve several problems dealing with shortest paths in simple polygons, including the CVV problem, in O (n) time. <p> Due to its generality, the sequential CVV algorithm resulting from the new technique of Hershberger and Suri <ref> [HS93] </ref> is somewhat more complicated than our sequential algorithm; briefly, whereas we need only a single shortest path in a certain simple polygon, their technique builds (during preprocessing) a powerful data structure that implicitly contains every shortest path between two sets of vertices in the simple polygon. <p> In addition, a serial version of our algorithm can be implemented in fi (n) time and thus provides a new optimal sequential algorithm that is simpler than that of Aggarwal et al.. Recently, Hershberger and Suri <ref> [HS93] </ref> have proposed an algorithm for computing row-wise minima or maxima of an implicit, totally-monotone matrix whose entries represent shortest-path distances between pairs of vertices in a simple polygon; this technique requires a linear amount of preprocessing to build a shortest path tree and is quite general in that it can
Reference: [Kir79] <author> D. G. Kirkpatrick. </author> <title> Efficient computation of continuous skeletons. </title> <booktitle> In Proc. 20th Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 18-27, </pages> <year> 1979. </year>
Reference-contexts: This improves over the best previous sequential time bound of O (n log n) which was based on generalized Voronoi diagrams <ref> [Kir79, For87, Yap87] </ref>.
Reference: [KR90] <author> R. M. Karp and V. Ramachandran. </author> <title> Parallel algorithms for shared memory machines. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 869-941. </pages> <publisher> Elsevier/The MIT Press, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: The model of parallel computation used by Hsu et al. is the CREW PRAM, which is a shared memory machine that supports concurrent reads from (but not writes to) a common shared memory location in unit time; for details of the various PRAM models consult <ref> [KR90] </ref>. In this paper we study the problem of determining cvv (P; Q) in the most general case, i.e., when P and Q are any two nonintersecting simple polygons. <p> All of the above computations can be carried out by standard parallel techniques in O (log n) time using O (n= log n) processors on an EREW PRAM <ref> [KR90] </ref>. If CH (P [ Q) = CH (Q), but P is not contained in Q, then the edge of CH (Q) needed to separate R from the unbounded region can be found by a list ranking process within these same resource bounds.
Reference: [MS88] <author> R. Miller and Q. F. Stout. </author> <title> Efficient parallel convex hull algorithms. </title> <journal> IEEE Trans. Comput., </journal> <volume> C-37(12):1605-1618, </volume> <year> 1988. </year> <month> 17 </month>
Reference-contexts: performed by modified versions of parallel planar convex hull algorithms; appropriate choices are the optimal O (log n) time CREW PRAM algorithm independently due to Atallah and Goodrich [AG86] and Aggarwal et al. [ACG + 88], and the optimal O (log n) time EREW PRAM algorithm of Miller and Stout <ref> [MS88] </ref>.) Ray shooting queries also prove useful in Step 2 when constructing the regions R (p) and R (q), 8p 2 P; q 2 Q.
Reference: [MT85] <author> M. McKenna and G. T. Toussaint. </author> <title> Finding the minimum vertex distance between two disjoint convex polygons in linear time. </title> <journal> Comput. Math. Appl., </journal> <volume> 11 </volume> <pages> 1227-1242, </pages> <year> 1985. </year>
Reference-contexts: Let jP j + jQj = n. The CVV problem has been addressed sequentially in various cases. When both P and Q are convex, cvv (P; Q) can be computed sequentially in time fi (n) <ref> [MT85, Tou84, CSW85] </ref>. If exactly one of P or Q is convex, then cvv (P; Q) can also be computed sequentially in time fi (n) [CSW85, Wan83].
Reference: [Sur87] <author> S. Suri. </author> <title> Minimum link paths in polygons and related problems. </title> <type> Ph.D. thesis, </type> <institution> Dept. Comput. Sci., Johns Hopkins Univ., Baltimore, MD, </institution> <year> 1987. </year>
Reference-contexts: In particular, the decomposition proceeds in our algorithm by performing some simple modifications to a shortest path in a simple polygon, whereas the algorithm of Aggarwal et al. uses the complicated window tree data structure <ref> [Sur87] </ref>. <p> The sequential decomposition technique of Aggarwal et al. is built upon the window tree data structure <ref> [Sur87] </ref>, (parallelization of this technique would require the nontrivial parallelization of the window tree data structure). The decomposition step of the sequential algorithm of Wang and Chan requires O (n log n) time (this technique uses an inherently sequential greedy scanning process).
Reference: [Tou84] <author> G. T. Toussaint. </author> <title> An optimal algorithm for computing the minimum vertex distance between two crossing convex polygons. </title> <journal> Computing, </journal> <volume> 32 </volume> <pages> 357-364, </pages> <year> 1984. </year>
Reference-contexts: Let jP j + jQj = n. The CVV problem has been addressed sequentially in various cases. When both P and Q are convex, cvv (P; Q) can be computed sequentially in time fi (n) <ref> [MT85, Tou84, CSW85] </ref>. If exactly one of P or Q is convex, then cvv (P; Q) can also be computed sequentially in time fi (n) [CSW85, Wan83].
Reference: [Wan83] <author> C. Wang. </author> <title> Intersection and minimum distance problems for planar polygons. M.Sc. </title> <type> thesis, </type> <institution> Dept. Comput. Sci., Univ. Alberta, Edmonton, Alberta, Canada, </institution> <year> 1983. </year>
Reference-contexts: When both P and Q are convex, cvv (P; Q) can be computed sequentially in time fi (n) [MT85, Tou84, CSW85]. If exactly one of P or Q is convex, then cvv (P; Q) can also be computed sequentially in time fi (n) <ref> [CSW85, Wan83] </ref>. Several sequential CVV algorithms have been proposed fl This paper appeared in preliminary form as [Ama92] y This work was supported in part by an AT&T Bell Laboratories Graduate Fellowship, the Joint Services Electronics Program (U.S. Army, U.S. Navy, U.S.
Reference: [WC86] <author> C. A. Wang and E. P. F. Chan. </author> <title> Finding the minimum visible vertex distance between two nonintersecting simple polygons. </title> <booktitle> In Proc. 2nd Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 34-42, </pages> <year> 1986. </year>
Reference-contexts: Army, U.S. Navy, U.S. Air Force) under contract N00014-90-J-1270, and NSF Grant CCR-89-22008. 1 distance is realized by the pair (p c ; q c ). when neither P nor Q is convex: Wang and Chan <ref> [WC86] </ref> have given an algorithm for computing cvv (P; Q) in time O (n log n), Aggarwal et al. [AMSS89] proposed an optimal fi (n) algorithm for this problem, and recently Hershberger and Suri [HS93] have given a general technique which can be used to solve several problems dealing with shortest <p> Our CVV algorithm consists of two phases: (i) first the problem of computing cvv (P; Q) is decomposed into a collection of linearly separable subproblems, and then (ii) the subproblems are solved independently, and the subproblem realizing cvv (P; Q) is identified. The sequential algorithms of Wang and Chan <ref> [WC86] </ref>, and Aggarwal et al. [AMSS89], and the parallel algorithm of Hsu et al. [HCL92] all have this same general strategy. We give a new decomposition technique that is much simpler than the corresponding methods used in the above mentioned CVV algorithms [WC86, AMSS89, HCL92]. <p> The sequential algorithms of Wang and Chan [WC86], and Aggarwal et al. [AMSS89], and the parallel algorithm of Hsu et al. [HCL92] all have this same general strategy. We give a new decomposition technique that is much simpler than the corresponding methods used in the above mentioned CVV algorithms <ref> [WC86, AMSS89, HCL92] </ref>. Our solution of the linearly separable subproblems is a modification of the sequential technique of Aggarwal et al., which includes some new ideas and some concepts first introduced in the sequential algorithm of Wang and Chan. <p> Although similar decomposition takes place in the parallel algorithm of Hsu et al. [HCL92], and in the sequential algorithms of Wang and Chan <ref> [WC86] </ref> and Aggarwal et al. [AMSS89], the methods used in these algorithms to find an appropriate set of separating line segments and to construct the subproblems are quite involved. <p> We present an algorithm for this special case that determines cvv (P; Q) in O (log n) time using O (n) processors on a CREW PRAM. As mentioned before, the CVV algorithms of Wang and Chan <ref> [WC86] </ref>, Aggarwal et al. [AMSS89], and Hsu et al. [HCL92] also define and solve subproblems of this type when solving a general instance of the CVV problem. <p> It is easy to see that the pruning required in Step 1, and the computation of the feasible regions R () in Step 2 can accomplished sequentially by performing O (1) linear scans of P and Q; this linear scanning technique was used by the sequential CVV algorithms of <ref> [WC86] </ref> and [AMSS89], and is similar to the process of finding the convex hull of a simple polygon [BE84] or of triangulating a polygon monotonic with respect to a line [GJPT78]. <p> Wang and Chan <ref> [WC86] </ref> were the first to propose the general method of decomposing a general instance of the CVV problem into a collection of linearly separable subproblems. <p> Thus, their algorithm also suffers from the first problem (but not the second) noted above for the algorithm of Aggarwal et al.. In summary, our algorithm introduces the requirement of perpendicular visibility, and incorporates techniques from both the sequential algorithms of Wang and Chan <ref> [WC86] </ref> and Aggarwal et al. [AMSS89]. Wang and Chan proposed the requirement that all candidate vertices must have visible angles of at least 90 ffi . <p> This algorithm consists of two distinct phases: the first phase decomposes the original problem into a collection of restricted subproblems which are solved independently in the second phase. This same general strategy was used in the sequential algorithms of Wang and Chan <ref> [WC86] </ref> and Ag-garwal et al. [AMSS89], and in the parallel algorithm of Hsu et al. [HCL92]. We provide a new decomposition technique that is much simpler than those used in these other CVV algorithms [WC86, AMSS89, HCL92]. <p> This same general strategy was used in the sequential algorithms of Wang and Chan [WC86] and Ag-garwal et al. [AMSS89], and in the parallel algorithm of Hsu et al. [HCL92]. We provide a new decomposition technique that is much simpler than those used in these other CVV algorithms <ref> [WC86, AMSS89, HCL92] </ref>. In addition, a serial version of our algorithm can be implemented in fi (n) time and thus provides a new optimal sequential algorithm that is simpler than that of Aggarwal et al..
Reference: [Yap87] <author> C. K. Yap. </author> <title> An O(n log n) algorithm for the Voronoi diagram of a set of simple curve segments. </title> <journal> Discrete Comput. Geom., </journal> <volume> 2 </volume> <pages> 365-393, </pages> <year> 1987. </year> <month> 18 </month>
Reference-contexts: This improves over the best previous sequential time bound of O (n log n) which was based on generalized Voronoi diagrams <ref> [Kir79, For87, Yap87] </ref>.
References-found: 31

