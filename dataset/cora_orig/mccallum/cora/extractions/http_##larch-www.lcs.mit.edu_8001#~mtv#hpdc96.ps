URL: http://larch-www.lcs.mit.edu:8001/~mtv/hpdc96.ps
Refering-URL: http://larch-www.lcs.mit.edu:8001/~mtv/
Root-URL: 
Title: Parallel User Interfaces for Parallel Applications  
Author: Mark T. Vandevoorde and Deepak Kapur 
Keyword: Parallelism, User Interfaces, Speculative Parallelism, And Parallelism, Or Parallelism, Interactive Applications, Interactive Theorem Proving.  
Abstract: Many parallel applications are designed to conceal parallelism from the user. In this paper, we investigate a different approach where the user controls many tasks running in parallel. The idea is to let a user accomplish his goal more quickly by trying competing alternatives in parallel (or-parallelism) and by working on subgoals in parallel (and-parallelism). To help the user manage a large number of parallel tasks, the application must provide features to generate many tasks easily, to summarize the state of all tasks, to broadcast commands to related tasks, and to abort tasks that are no longer needed. A parallel interface to an application thus becomes crucial to enhance the user's productivity. We demonstrate this approach using DLP, a parallel, distributed version of the Larch Prover, an interactive theorem prover. DLP supports explicit parallelism and runs on a network of workstations. Users control DLP through a multi-window interface on a bit-map color-display. Many theorem proving problems that would otherwise take considerable user effort to solve have been done with relative ease using DLP. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Ballantyne and W. Bledsoe. </author> <title> On generating and using examples in proof discovery. </title> <journal> Machine Intelligence, </journal> <volume> 10 </volume> <pages> 3-39, </pages> <year> 1982. </year>
Reference-contexts: This came as a pleasant surprise to one of the coauthors of [10], who said they had spent considerable effort trying to find short proofs. The intermediate value theorem is considered a challenge for theorem provers <ref> [1, 8] </ref>. Without using specialized inference methods for transitive relations, this problem is difficult to prove. For instance, in [8], Nie and Plaisted had to combine many heuristics including interpretations, case analysis, and semantic deletion, to prove two lemmas from which the theorem follows.
Reference: [2] <author> G. Eisenhauer, W. Gu, K. Schwan, and N. Mallavvarupu. </author> <title> Falcon toward interactive parallel programs: The on-line steering of a molecular dynamics application. </title> <booktitle> In Proceedings of the Third International Symposium on High-Performance Distributed Computing, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: The program may have a parallel implementation, but it need not [11]. Typically, the role of user guidance is to improve the performance of the program, e.g., by redistributing data to improve locality [12] or by migrating work to improve load balancing <ref> [2] </ref>. Our work, in contrast, is not intended to expose aspects of an implementation that are normally hidden from the user, but rather to help the user create and manage many high-level tasks for the implementation to execute.
Reference: [3] <author> S. Garland and J. Guttag. </author> <title> A guide to LP, The Larch Prover. </title> <type> TR 82, </type> <institution> DEC Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: Thus, the parallel interface of the application becomes crucial to enhance a user's productivity, and a parallel implementation becomes crucial for delivering adequate performance. This approach is illustrated by discussing the design of DLP, a distributed version of the LP <ref> [3] </ref>, an interactive theorem prover. DLP supports explicit parallelism and runs on a network of workstations. Our primary objective in building DLP has been to design a parallel interface that lets users be more productive when using LP. Constructing a parallel implementation of LP was a secondary objective. <p> We chose to extend the Larch Prover <ref> [3] </ref> (LP version 3.1) for several reasons. First, LP is a real-life application used around the world to reason about circuits, concurrent algorithms, hardware, and software.
Reference: [4] <author> W. Gu, J. Vetter, and K. Schwan. </author> <title> An annotated bibliography of interactive program steering. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(9) </volume> <pages> 140-148, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Our primary objective in building DLP has been to design a parallel interface that lets users be more productive when using LP. Constructing a parallel implementation of LP was a secondary objective. Our work is perhaps most closely related to work on interactive program steering <ref> [4] </ref>. Program steering is a technique for interactively monitoring and guiding a long-running program. The program may have a parallel implementation, but it need not [11].
Reference: [5] <author> J. Guttag. </author> <type> Personal communication. </type> <month> September </month> <year> 1995. </year>
Reference-contexts: After trying DLP, Guttag reported that he believed he was able to prove properties of double-ended queues faster using DLP than he would have using LP <ref> [5] </ref>. The flexibility in DLP of proving many properties in parallel was particularly useful. spec found many of the proofs automatically, whereas other proof attempts got stuck. In that case, properties already proved could be asserted via Use-proved and those not yet proved could be retried. <p> DLP was used on a series of examples ranging in difficulty. The parallel interface and implementation of DLP were found to be more effective to use than LP's, even by one of the co-developers of LP <ref> [5] </ref>. However, when no task finds a proof, DLP could use better facilities for analyzing the output of tasks, e.g., sorting competing proof attempts by some metric indicating how easy it would be to complete the proof. We believe parallel interfaces could be developed to improve many other applications.
Reference: [6] <author> D. Kapur and H. Zhang. </author> <title> An overview of Rewrite Rule Laboratory (RRL). </title> <journal> Journal of Computer and Mathematics with Applications, </journal> <volume> 29(2) </volume> <pages> 91-114, </pages> <year> 1995. </year> <month> 14 </month>
Reference-contexts: We believe parallel interfaces could be developed to improve many other applications. For other theorem provers, e.g., RRL <ref> [6] </ref>, many of the features of DLP could be applied directly. For other kinds of applications, such as web search, library search, CAD tools and simulation tools, the general framework presented could work.
Reference: [7] <author> J. McCarthy. </author> <title> The mutilated checkerboard in set theory. </title> <booktitle> Pre--sented at the 2nd QED Workshop, </booktitle> <address> Warsaw, Poland. </address> <note> Available as http://www-formal.stanford.edu/jmc/checkerboard1.dvi, July 1995. </note>
Reference-contexts: From the two lemmas, it is obvious how to prove the main conjecture with LP in one step, so we did not need to use spec. The third example is that of showing the impossibility of covering a checkerboard missing two opposite corners by dominos of size 2. McCarthy <ref> [7] </ref> recently posed a specific version of this problem (with checkerboard of size 8 x 8) as a challenge to be proved automatically for automatic theorem provers [7]. <p> McCarthy <ref> [7] </ref> recently posed a specific version of this problem (with checkerboard of size 8 x 8) as a challenge to be proved automatically for automatic theorem provers [7]. Whereas we cannot hope for an interactive prover like DLP to meet McCarthy's challenge to automatically generate a proof, we decided to attempt a general version of this problem by proving the theorem for boards of any size using DLP.
Reference: [8] <author> X. Nie and D. Plaisted. </author> <title> A semantic backward chaining proof system. </title> <journal> Artificial Intelligence, </journal> <volume> 55 </volume> <pages> 109-128, </pages> <year> 1992. </year>
Reference-contexts: This came as a pleasant surprise to one of the coauthors of [10], who said they had spent considerable effort trying to find short proofs. The intermediate value theorem is considered a challenge for theorem provers <ref> [1, 8] </ref>. Without using specialized inference methods for transitive relations, this problem is difficult to prove. For instance, in [8], Nie and Plaisted had to combine many heuristics including interpretations, case analysis, and semantic deletion, to prove two lemmas from which the theorem follows. <p> The intermediate value theorem is considered a challenge for theorem provers [1, 8]. Without using specialized inference methods for transitive relations, this problem is difficult to prove. For instance, in <ref> [8] </ref>, Nie and Plaisted had to combine many heuristics including interpretations, case analysis, and semantic deletion, to prove two lemmas from which the theorem follows. We began by trying to prove the first lemma in [8]. <p> For instance, in <ref> [8] </ref>, Nie and Plaisted had to combine many heuristics including interpretations, case analysis, and semantic deletion, to prove two lemmas from which the theorem follows. We began by trying to prove the first lemma in [8]. The default proof strategy of spec generated a single proof attempt by contradiction which did not succeed automatically. We proceeded by trying variations of the find-instantiations command and by experimenting with a different proof strategy for spec that spawns proofs-by-cases based on the axioms rather than the conjecture.
Reference: [9] <author> Polymer User Guide, </author> <title> version 6.0, </title> <booktitle> volume 1. </booktitle> <address> San Diego: Biosym Technologies, </address> <year> 1993. </year>
Reference-contexts: Another kind of task would be to perform a search of one library's catalog, which might return a list of items found. Thus, the user could spawn a keyword search at each libary. As another example, consider a simulator like Polymer <ref> [9] </ref> for predicting various properties of polymers using different mathematical models. This application is commonly used to to design polymers whose properties satisfy a set of constraints (e.g., solubility in water 5%, forms micelles in solution, micelles have the capacity to absorb chloroform).
Reference: [10] <author> J. B. Saxe, J. V. Guttag, J. J. Horning, and S. J. </author> <title> Garland. Using transformations and verification in circuit design. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 3(3) </volume> <pages> 181-209, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Next, we report an evaluation of DLP by one of the co-developers of LP. Finally, we provide some data on the performance of DLP's implementation. 4.1 A Survey of Three Different Examples The pipeline processor example <ref> [10] </ref> is an LP proof that a pipelined implementation of a small processor is equivalent to a simpler, non-pipelined implementation. <p> We believe that finding proofs by hand would have taken considerably longer since we probably would have needed to study the axioms. For three of the conjectures, DLP generated the same proofs as those done with LP in <ref> [10] </ref> under user guidance. For the other two conjectures, DLP generated longer proofs because spec's heuristic for choosing cases for case proofs did not always make the best choice. While experimenting with spec by telling it to use different proof strategies, we ended up finding a shorter proof than in [10] <p> <ref> [10] </ref> under user guidance. For the other two conjectures, DLP generated longer proofs because spec's heuristic for choosing cases for case proofs did not always make the best choice. While experimenting with spec by telling it to use different proof strategies, we ended up finding a shorter proof than in [10] for one of the conjectures. This came as a pleasant surprise to one of the coauthors of [10], who said they had spent considerable effort trying to find short proofs. The intermediate value theorem is considered a challenge for theorem provers [1, 8]. <p> While experimenting with spec by telling it to use different proof strategies, we ended up finding a shorter proof than in <ref> [10] </ref> for one of the conjectures. This came as a pleasant surprise to one of the coauthors of [10], who said they had spent considerable effort trying to find short proofs. The intermediate value theorem is considered a challenge for theorem provers [1, 8]. Without using specialized inference methods for transitive relations, this problem is difficult to prove.
Reference: [11] <author> R. Sosic. Dynascope: </author> <title> A tool for program directing. </title> <booktitle> In Proceedings of the 1992 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 12-21. </pages> <publisher> ACM, </publisher> <month> July </month> <year> 1992. </year>
Reference-contexts: Constructing a parallel implementation of LP was a secondary objective. Our work is perhaps most closely related to work on interactive program steering [4]. Program steering is a technique for interactively monitoring and guiding a long-running program. The program may have a parallel implementation, but it need not <ref> [11] </ref>. Typically, the role of user guidance is to improve the performance of the program, e.g., by redistributing data to improve locality [12] or by migrating work to improve load balancing [2].
Reference: [12] <author> S. Wheater and S. Shrivastava. </author> <title> Exercising application specific run-time control over clustering of objects. </title> <booktitle> In Proceedings of the Second International Workshop on Configurable Distributed Systems, </booktitle> <pages> pages 25-35, </pages> <month> March </month> <year> 1994. </year> <month> 15 </month>
Reference-contexts: Program steering is a technique for interactively monitoring and guiding a long-running program. The program may have a parallel implementation, but it need not [11]. Typically, the role of user guidance is to improve the performance of the program, e.g., by redistributing data to improve locality <ref> [12] </ref> or by migrating work to improve load balancing [2]. Our work, in contrast, is not intended to expose aspects of an implementation that are normally hidden from the user, but rather to help the user create and manage many high-level tasks for the implementation to execute.
References-found: 12

