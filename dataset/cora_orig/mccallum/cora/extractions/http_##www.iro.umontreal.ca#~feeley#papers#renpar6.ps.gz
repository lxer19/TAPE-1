URL: http://www.iro.umontreal.ca/~feeley/papers/renpar6.ps.gz
Refering-URL: http://www.iro.umontreal.ca/~feeley/
Root-URL: http://www.iro.umontreal.ca
Email: fboucherd,feeleyg@iro.umontreal.ca  
Title: Construction parallele de l'automate LR(0) Une application de Multilisp a la compilation  
Author: Dominique Boucher et Marc Feeley Departement d'Informatique et R. O. 
Address: Montreal  
Affiliation: Universite de  
Abstract-found: 0
Intro-found: 1
Reference: [Aho, Sethi et Ullman, 1986] <author> A. V. Aho, R. Sethi et J. D. Ullman. </author> <booktitle> Compilers. Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: La construction de tels analyseurs requiere habituellement trois phases distinctes <ref> [Aho, Sethi et Ullman, 1986] </ref> : 1. la construction de l'automate LR (0), 2. le calcul des contextes de reductions, aussi appeles ensembles de prevision, et 3. la construction des tables d'analyse. Un algorithme parallele permettant d'effectuer le calcul des deux dernieres phases est decrit dans [Bermudez et al., 1990]. <p> L'etat d'arrivee d'une transition sur X dont l'etat de depart est I se calcule en prenant la fermeture LR (0) de I 0 = fA ! ffX fi j A ! ff Xfi 2 Ig. L'algorithme sequentiel standard <ref> [Aho, Sethi et Ullman, 1986] </ref> pour le calcul de cet automate procede etat par etat, en examinant une liste ne contenant initialement que l'etat initial. Pour chaque etat I de la liste, on determine les transitions possibles qui partent de I et les etats d'arrivee de ces transitions.
Reference: [BBN, 1989] <institution> BBN Advanced Computers Inc., Cambridge, MA. Inside de GP1000 Computer, </institution> <year> 1989. </year>
Reference-contexts: Le tableau suivant donne les temps de calcul (en secondes) des trois phases pour 3 grammaires, telles que calculees sequentiellement par Bison sur un seul processeur du multiprocesseur a memoire partagee BBN GP1000 <ref> [BBN, 1989] </ref> : Grammaire Phase 1 (en sec.) Phases 2 et 3 (en sec.) % Phase 1 Ada 2.25 2.67 45.7 C++ 6.18 16.54 27.2 Dans Bison, la phase 1 est calculee d'une maniere standard (decrite plus bas) et les phases 2 et 3 sont calculees suivant la methode decrite dans
Reference: [Bermudez et al., 1990] <author> M. E. Bermudez, R. Newman-Wolfe et G. Logothetis. </author> <title> Parallel Construction of SLR(1) and LALR(1) Parsers. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 19(3) </volume> <pages> 163-184, </pages> <year> 1990. </year>
Reference-contexts: Un algorithme parallele permettant d'effectuer le calcul des deux dernieres phases est decrit dans <ref> [Bermudez et al., 1990] </ref>. Le facteur d'acceleration theorique de cet algorithme est de min (N; T ), ou T est le nombre de terminaux de la grammaire et N est le nombre de pro-cesseurs.
Reference: [DeRemer et Pennello, 1982] <author> F. DeRemer et T. Pennello. </author> <title> Efficient Computation of LALR(1) Look-Ahead Sets. </title> <journal> ACM TOPLAS, </journal> <volume> 4(4) </volume> <pages> 615-649, </pages> <month> Octobre </month> <year> 1982. </year>
Reference-contexts: 1989] : Grammaire Phase 1 (en sec.) Phases 2 et 3 (en sec.) % Phase 1 Ada 2.25 2.67 45.7 C++ 6.18 16.54 27.2 Dans Bison, la phase 1 est calculee d'une maniere standard (decrite plus bas) et les phases 2 et 3 sont calculees suivant la methode decrite dans <ref> [DeRemer et Pennello, 1982] </ref>. C'est donc dire qu'une partie importante de la generation des tables LALR est susceptible d'^etre acceleree par une implantation parallele efficace. Notre travail montre que l'automate LR (0) peut ^etre construit efficacement en parallele.
Reference: [Feeley, 1993a] <author> M. Feeley. </author> <title> An Efficient and General Implementation of Futures on Large Scale Shared-Memory Multiprocessors. </title> <type> These de PhD, </type> <institution> Brandeis University Departement of Computer Science, </institution> <year> 1993. </year>
Reference-contexts: Le compilateur Multilisp opti-misant Gambit <ref> [Feeley, 1993a] </ref> a ete utilise a cette fin. Nous avons tout d'abord realise une version sequentielle en Scheme a partir du programme Bison (ecrit en C).
Reference: [Feeley, 1993b] <author> M. Feeley. </author> <title> A Message Passing Implementation of Lazy Task Creation. Dans Parallel Symbolic Computing: </title> <journal> Languages, Systems, and Applications, </journal> <volume> LNCS 748, </volume> <editor> edite par R. Halstead et T. Ito, </editor> <month> novembre </month> <year> 1993, </year> <pages> 14 pages. </pages>
Reference-contexts: Future permet de creer une nouvelle t^ache tandis que touch permet de synchroniser les t^aches demarrees avec future. Avec Gambit, le placement des t^aches se fait automatiquement en fonction de la charge gr^ace au mecanisme de "Lazy Task Creation" <ref> [Feeley, 1993b] </ref>. * Il n'y a plus de liste globale contenant les etats deja crees. 2 De plus, quelques variables globales ont ete remplacees par des variables locales passees en parametre aux fonctions appelees.
Reference: [Halstead, 1985] <author> R. Halstead. </author> <title> Multilisp : A language for concurrent symbolic computation. </title> <journal> Dans ACM Trans. on Prog. Languages and Systems, </journal> <pages> pages 501-538, </pages> <month> Octobre </month> <year> 1985. </year> <month> 4 </month>
Reference-contexts: 1 Introduction Nous nous interessons ici a la parallelisation des generateurs d'analyseurs syntaxiques LALR (1), tels YACC et Bison, et a leur implantation en Multilisp <ref> [Halstead, 1985] </ref>, un dialecte parallele de Scheme, dont le choix est motive par la nature symbolique du probleme.
References-found: 7

