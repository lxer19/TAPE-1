URL: http://www.first.gmd.de/persons/Neustupny.Thomas/papers/zum97.ps.gz
Refering-URL: http://www.first.gmd.de/~espress/gesamt_public.html
Root-URL: 
Email: j santeng@first.gmd.de  
Title: Automating Test Case Generation from Z Specifications with Isabelle  
Author: Steffen Helke, Thomas Neustupny, Thomas Santen email:fsteffen j thomas 
Address: FIRST Rudower Chaussee 5, D-12489 Berlin, Germany  
Affiliation: GMD  
Abstract: We use a structure preserving encoding of Z in the higher-order logic instance of the generic theorem prover Isabelle to derive test cases from Z specifications. This work shows how advanced theorem provers can be used with little effort to provide tool support for Z beyond mere type-checking. Experience with a non-trivial example shows that modular reasoning according to the structure of a specification is crucial to keep the proof-load manageable in practical applications. Support for modular reasoning can be based on higher-order equational reasoning as implemented in Isabelle.
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> J. P. Bowen and J. A. Hall, editors. </editor> <booktitle> Z User Workshop, Workshops in Computing. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference: [2] <editor> J. P. Bowen and M. G. Hinchey, editors. ZUM'95: </editor> <title> The Z Formal Specification Notation, </title> <publisher> LNCS 967. Springer Verlag, </publisher> <year> 1995. </year>
Reference: [3] <author> R. Bussow and M. Weber. </author> <title> A Steam-Boiler Control Specification using Stat-echarts and Z. </title> <editor> In J. R. Abrial, editor, </editor> <title> Formal methods for industrial applications: specifying and programming the Steam Boiler Control, </title> <publisher> LNCS 1165. Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: It consists of an informal description of control software for a steam boiler. We illustrate test case generation with the Z specification of Bussow and Weber <ref> [3] </ref> for Abrial's problem. The steam boiler is a physical unit for producing steam by boiling water (cf. Fig. 1). The boiler is constantly heated while new water is pumped into the boiler by four pumps. Other components of the steam boiler need not be considered here. <p> Second, Isabelle allows substituting a schema reference S in arbitrary context using a higher-order equation like (5). 5 Empirical Results We have used our test case generation tactic in several case studies. The largest is the steam boiler specification of Bussow and Weber <ref> [3] </ref>. From this specification, which uses a combined notation of Z and Statecharts, we have extracted a pure Z specification consisting of 37 schemas totaling 600 lines of Z. The operation SteamBoilerWaiting specifies a part of the initialization phase before heating of the boiler has begun.
Reference: [4] <editor> E. Cusack and G. H. B. Rafsanjani. ZEST. In S. Stepney, R. Barden, and D. Cooper, editors, </editor> <booktitle> Object-Orientation in Z, Workshops in Computing. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: This suggests combining theorem proving and compiling schemas to evaluate test results to ensure sound transformations and to deal with non-executable specifications. Stepney [16] advocates to systematically build abstractions of operation specifications for testing. This approach is based on ZEST <ref> [4] </ref>, an object-oriented extension of Z. A tool to support these activities leaves the deduction steps of simplification and weakening of predicates to the person setting up the tests. It just uses a structured editor to support this process.
Reference: [5] <author> J. Dick and A. Faivre. </author> <title> Automating the generation and sequencing of test cases from model-based specifications. </title> <booktitle> In Woodcock and Larsen [17], </booktitle> <pages> pages 268-284. </pages>
Reference-contexts: Today, considering cost-effectiveness, a formal proof of correctness can only be the exception rather than the rule. Recently, more pragmatic approaches to support verification and validation (V&V), in particular testing, based on formal specifications have been proposed <ref> [5, 6, 8, 16] </ref>. These approaches also acknowledge that testing will always be necessary because even a formal proof of correctness cannot ensure that the actual code executed on the target platform exhibits the desired behavior. <p> We put our work into context in Section 6 before drawing some conclusions in Section 7. 2 Testing Based on Z We first give a short presentation of the general approach to testing underlying our work. For more information on testing based on formal methods we refer to <ref> [5] </ref>, [8] and [6]. As an example throughout the paper we use a medium-sized Z specification based on a problem originally posed by Abrial. <p> WaterTolerable ^ TolerableDefects) (st = running _ PumpsOpen) ) ValveClosed These schemas serve us to illustrate test case generation in the following. 2.3 Test case generation with the DNF method For extracting test cases from a Z specification we choose the disjunctive normal form (DNF) approach of Dick and Faivre <ref> [5] </ref>. We generate DNFs for single operations only. How these results can be used to construct a separation of the whole specification state space into test cases is described in [5]. <p> For extracting test cases from a Z specification we choose the disjunctive normal form (DNF) approach of Dick and Faivre <ref> [5] </ref>. We generate DNFs for single operations only. How these results can be used to construct a separation of the whole specification state space into test cases is described in [5]. The schema predicate of the operation to be tested is transformed into a disjunctive normal form, where each disjunction represents one test case. During this step all predicates of the operation are transformed into ^, _ and : combinations. <p> This is achieved by the usual algorithm that first transforms implications and equivalences to disjunctions, then builds a negation normal form, and finally distributes conjunctions over disjunctions. We transform implications and equivalences using the rules proposed by Dick and Faivre <ref> [5] </ref>, which lead to mutually exclusive disjuncts. A ) B = : A _ (A ^ B ) Isabelle's simplifier makes it very easy to implement the three-step transformation to DNF. <p> Their simplification takes approximately 22 hours. 6 Related Work The generation of disjunctive normal forms from operation specifications described in Sect. 2 is part of a more encompassing approach to testing against model-based specifications proposed by Dick and Faivre <ref> [5] </ref>. They use DNFs to generate a finite state automaton from a VDM specification, and derive test sequences from this automaton. They also suggest to consider case distinctions derived from data structures and quantifications during test case generation. <p> To date, we have considered test case generation for single operations only. We plan to extend the tool to generate test sequences and incorporate information from behavioral specifications. Interestingly, test sequencing as described in <ref> [5] </ref> involves precondition analyses of operations. A tactic supporting these could also be used in validation activities not directly related to testing. We believe that the present work can serve as a basis for a tool-kit supporting a broad range of verification and validation activities based on Z specifications. Acknowledgments.
Reference: [6] <author> M.-C. </author> <title> Gaudel. Testing can be formal, too. </title> <editor> In P. D. Mosses, M. Nielsen, and M. I. Schwartzbach, editors, </editor> <booktitle> TAPSOFT '95: Theory and Practice of Software Development, </booktitle> <volume> LNCS 915, </volume> <pages> pages 82-96. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Today, considering cost-effectiveness, a formal proof of correctness can only be the exception rather than the rule. Recently, more pragmatic approaches to support verification and validation (V&V), in particular testing, based on formal specifications have been proposed <ref> [5, 6, 8, 16] </ref>. These approaches also acknowledge that testing will always be necessary because even a formal proof of correctness cannot ensure that the actual code executed on the target platform exhibits the desired behavior. <p> For more information on testing based on formal methods we refer to [5], [8] and <ref> [6] </ref>. As an example throughout the paper we use a medium-sized Z specification based on a problem originally posed by Abrial. <p> It just uses a structured editor to support this process. A tool similar to ours could be used to increase the degree of automation of these steps. A theory of testing based on algebraic specifications has been proposed by Gaudel <ref> [6] </ref>. She in particular defines notions such as exhaustive testing, testability, validity and unbias. The counterpart of DNF generation in the algebraic context is unfolding of axioms. Applications of the approach use specially de-signed axioms to define data types in order to support testing well.
Reference: [7] <author> M. J. C. Gordon and T. M. Melham. </author> <title> Introduction to HOL: A theorem proving environment for higher order logics. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: Our work on Z is based on Isabelle's higher-order logic (Isabelle/HOL) which is similar to the one implemented in the HOL system <ref> [7] </ref>. Logical rules like P Q (conjI) P ^ Q (conjunct1) are represented in Isabelle by meta-implications [[?P ; ?Q]] =)?P ^?Q ?P ^?Q =)?P The variables prefixed by a question mark are so called meta-variables.
Reference: [8] <author> H.-M. Horcher. </author> <title> Improving software tests using Z specifications. </title> <booktitle> In Bowen and Hinchey [2], </booktitle> <pages> pages 152-166. </pages>
Reference-contexts: Today, considering cost-effectiveness, a formal proof of correctness can only be the exception rather than the rule. Recently, more pragmatic approaches to support verification and validation (V&V), in particular testing, based on formal specifications have been proposed <ref> [5, 6, 8, 16] </ref>. These approaches also acknowledge that testing will always be necessary because even a formal proof of correctness cannot ensure that the actual code executed on the target platform exhibits the desired behavior. <p> We put our work into context in Section 6 before drawing some conclusions in Section 7. 2 Testing Based on Z We first give a short presentation of the general approach to testing underlying our work. For more information on testing based on formal methods we refer to [5], <ref> [8] </ref> and [6]. As an example throughout the paper we use a medium-sized Z specification based on a problem originally posed by Abrial. <p> We agree with the latter point but believe that such a tool must be easily and safely extensible. All rules used in our implementation are proven correct in Isabelle giving us confidence that all of our transformations are sound. Horcher <ref> [8] </ref> gives an overview of testing based on Z. He also proposes transforming operation schemas to DNF to generate test cases, but emphasizes the need to automate test evaluation because of the vast amount of data that has to be processed.
Reference: [9] <author> Kolyang, T. Santen, and B. Wolff. </author> <title> A structure preserving encoding of Z in Isabelle/HOL. </title> <editor> In J. von Wright, J. Grundy, and J. Harrison, editors, </editor> <title> Theorem Proving in Higher-Order Logics, </title> <publisher> LNCS 1125, </publisher> <pages> pages 283-298. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: We first give a brief introduction to Isabelle, and describe the key aspects of our encoding of Z afterwards. A detailed description of that encoding and a justification why it conforms to the Z draft standard [11] is given elsewhere <ref> [9] </ref>. 3.1 Isabelle Logical frameworks implement a calculus for a simple meta-logic that is nevertheless expressive enough to encode many other logics, so called object logics, in it. The meta-logic of Isabelle only consists of equality ==, implication =), universal quantification V , and functional abstraction . <p> The proven theorem is the concrete, meta-variable free equation 3 fl (2 + 5) = 21. 3.2 Z in Isabelle/HOL Let us now briefly explain how Z can be encoded in the implementation of higher-order logic in Isabelle. This encoding is described in detail elsewhere <ref> [9] </ref>. <p> The counterpart of DNF generation in the algebraic context is unfolding of axioms. Applications of the approach use specially de-signed axioms to define data types in order to support testing well. For an overview over theorem proving support for Z, we refer to <ref> [9] </ref>. 7 Conclusions We have described an implementation of an approach to generate test cases from Z specifications. The implementation is based on an encoding of Z in Isabelle/HOL and heavily relies on the theorem proving techniques supplied by that prover.
Reference: [10] <author> E. Mikk. </author> <title> Compilation of Z specifications into C for automatic test result evaluation. </title> <booktitle> In Bowen and Hinchey [2], </booktitle> <pages> pages 167-180. </pages>
Reference-contexts: He also proposes transforming operation schemas to DNF to generate test cases, but emphasizes the need to automate test evaluation because of the vast amount of data that has to be processed. A test evaluation tool to support this process is described by Mikk <ref> [10] </ref>. It transforms predicates of schemas into "executable" forms which are then compiled to Boolean-valued C functions. These serve to evaluate test data. Similar to eliminating unsatisfiable cases, the set of transformation rules needs to be extensible to compensate for incompleteness.
Reference: [11] <author> J. </author> <title> Nicholls. Z Notation version 1.2. Draft ISO standard, </title> <year> 1995. </year>
Reference-contexts: We first give a brief introduction to Isabelle, and describe the key aspects of our encoding of Z afterwards. A detailed description of that encoding and a justification why it conforms to the Z draft standard <ref> [11] </ref> is given elsewhere [9]. 3.1 Isabelle Logical frameworks implement a calculus for a simple meta-logic that is nevertheless expressive enough to encode many other logics, so called object logics, in it. <p> Thus, it is easy to define the constants of the mathematical toolkit in HOL. To date, we have proven most of the theorems about the tool-kit mentioned in [15] and <ref> [11] </ref> which gives us confidence that our definitions conform to the Z standard.
Reference: [12] <author> L. C. Paulson. </author> <title> Isabelle A Generic Theorem Prover. </title> <publisher> LNCS 828. Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The contribution of this paper is to show how modern theorem proving technology can support V&V activities based on Z specifications. We argue that advanced logical frameworks like the generic theorem prover Isabelle <ref> [12] </ref> can be adapted with little effort to support Z in a way that is trustworthy, flexible, easily maintainable, and able to support non-trivial, medium-sized specifications. <p> In this section, we show how proof support for Z can be obtained by semantically embedding the language into an implementation of higher-order logic that is provided by the generic prover Isabelle <ref> [12] </ref>. We first give a brief introduction to Isabelle, and describe the key aspects of our encoding of Z afterwards.
Reference: [13] <author> H. Singh, M. Conrad, G. Egger, and S. Sadeghipour. </author> <title> Tool-supported test case design based on Z and the classification-tree method, 1996. Proc. Second Workshop on Systems for Computer-Aided Specification, Development and Verification, </title> <note> to appear. </note>
Reference-contexts: One approach to this problem is to combine DNF generation with methods from classical testing theory, and have the users supply information on important case distinctions, as is proposed in <ref> [13] </ref>. To date, we have considered test case generation for single operations only. We plan to extend the tool to generate test sequences and incorporate information from behavioral specifications. Interestingly, test sequencing as described in [5] involves precondition analyses of operations.
Reference: [14] <author> J. M. Spivey. </author> <title> The fuzz manual. </title> <booktitle> Computing Science Consultancy, </booktitle> <address> Oxford, UK, </address> <year> 1992. </year>
Reference-contexts: These approaches also acknowledge that testing will always be necessary because even a formal proof of correctness cannot ensure that the actual code executed on the target platform exhibits the desired behavior. While type checkers like f uzz <ref> [14] </ref> are useful to validate specifications at the level of language, more powerful tools are needed to support working with specifications at the level of semantics. Since Z specifications are not "executable", this kind of support in general leads to logical deduction problems.
Reference: [15] <author> J. M. Spivey. </author> <title> The Z Notation A Reference Manual. </title> <publisher> Prentice Hall, </publisher> <address> 2nd edition, </address> <year> 1992. </year>
Reference-contexts: Thus, it is easy to define the constants of the mathematical toolkit in HOL. To date, we have proven most of the theorems about the tool-kit mentioned in <ref> [15] </ref> and [11] which gives us confidence that our definitions conform to the Z standard.
Reference: [16] <author> S. Stepney. </author> <title> Testing as abstraction. </title> <booktitle> In Bowen and Hinchey [2], </booktitle> <pages> pages 137-151. </pages>
Reference-contexts: Today, considering cost-effectiveness, a formal proof of correctness can only be the exception rather than the rule. Recently, more pragmatic approaches to support verification and validation (V&V), in particular testing, based on formal specifications have been proposed <ref> [5, 6, 8, 16] </ref>. These approaches also acknowledge that testing will always be necessary because even a formal proof of correctness cannot ensure that the actual code executed on the target platform exhibits the desired behavior. <p> In addition, predicates of Z operations are in general not executable. This suggests combining theorem proving and compiling schemas to evaluate test results to ensure sound transformations and to deal with non-executable specifications. Stepney <ref> [16] </ref> advocates to systematically build abstractions of operation specifications for testing. This approach is based on ZEST [4], an object-oriented extension of Z. A tool to support these activities leaves the deduction steps of simplification and weakening of predicates to the person setting up the tests.
Reference: [17] <author> J. C. P. Woodcock and P. G. Larsen, </author> <title> editors. FME '93: Industrial-Strength Formal Methods, </title> <publisher> LNCS 670. Springer Verlag, </publisher> <year> 1993. </year>
References-found: 17

