URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1994/tr-94-037.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1994.html
Root-URL: http://www.icsi.berkeley.edu
Email: E-mail: wilkerso@math.berkeley.edu  
Title: Faster Computation On Directed Networks of Automata  
Author: Rafail Ostrovsky Daniel Wilkerson 
Address: Department.  
Affiliation: U.C. Berkeley Mathematics  
Date: August 1994  
Pubnum: TR-94-037  
Abstract: We show how an arbitrary strongly-connected directed network of synchronous finite-state automata (with bounded in- and out-degree) can accomplish a number of basic distributed network tasks in O(ND) time, where D is the diameter of the network and N is the number of processors. The tasks include (among others) the Firing Synchronization Problem; Network Search and Traversal; building outgoing and incoming Spanning Trees; Wake-up and Report When Done; and simulating a step of an undirected network protocol for the underlying graph of the directed network. Our approach compares favorably to the best previously known O(N 2 ) algorithms of Even, Litman and Winkler [ELW-90] for all these problems. fl U.C. Berkeley Computer Science Division and ICSI. Supported by an NSF Postdoctoral Fellowship and ICSI. E-mail: rafail@ICSI.Berkeley.EDU
Abstract-found: 1
Intro-found: 1
Reference: [AG-93] <author> Y. Afek and E. </author> <title> Gafni Distributed algorithms for Unidirectional networks. </title> <type> manuscript. </type>
Reference-contexts: Our tokens are of constant-size (and can carry constant-size messages with them.) Our algorithm must work for arbitrary strongly-connected networks of automata. This problem is also known as the "Chinese postman problem", where one must completely explore an unknown city which has many one-way streets <ref> [AG-93] </ref>. In undirected networks, a simple DFS will suffice to traverse the network. However, in directed networks, one-way edges may prevent a token from going "back" on a directed edge, and a "detour" must be found instead. <p> A DFS may then be performed using this procedure to traverse edges in the reverse direction <ref> [GA-84, Kut88, ELW-90, AG-93] </ref>. <p> Previously, (in the setting of strongly-connected bounded degree directed networks of synchronous automata) <ref> [GA-84, AG-93] </ref> exhibited a O (N 2 D) solution for the traversal problem, and [ELW-90] showed a O (N 2 ) solution. <p> The token may now travel backward again on some other edge without interference from the previous backwards communication process. This is the key point of our algorithm, which allows us to avoid a costly "down-tree" <ref> [GA-84, AG-93, ELW-90] </ref> construction, which was the bottleneck of the previous solutions. The Algorithm: Consider a setting where B has a token M that it would like to communicate to A, and A has an edge to B, as above.
Reference: [ELW-90] <author> S. Even, A. Litman and P. </author> <title> Winkler Computing with Snakes in Directed Networks of Automata. </title> <booktitle> FOCS 1990. </booktitle>
Reference-contexts: The goal is to minimize this synchronization time t. In addition to large body of work for undirected networks (see [M-86]), FSP problem was considered for directed networks of automata in <ref> [K-78, HN-81, ELW-90] </ref>, where O (N 2 ) was the best previously known running time [ELW-90]. <p> The goal is to minimize this synchronization time t. In addition to large body of work for undirected networks (see [M-86]), FSP problem was considered for directed networks of automata in [K-78, HN-81, ELW-90], where O (N 2 ) was the best previously known running time <ref> [ELW-90] </ref>. In this paper, we show how to solve FSP in O (N D) steps, where D is the diameter of the network and N the the number of processors: Theorem 1 There exists an O (N D) firing synchronization algorithm for strongly-connected directed networks of automata. <p> A DFS may then be performed using this procedure to traverse edges in the reverse direction <ref> [GA-84, Kut88, ELW-90, AG-93] </ref>. <p> A DFS may then be performed using this procedure to traverse edges in the reverse direction [GA-84, Kut88, ELW-90, AG-93]. In this paper we show how a single token can go "backwards" on an edge in an unknown graph (i.e. without any pre-processing, such as the down-tree of <ref> [ELW-90] </ref>.) We call such such an algorithm a backwards communication algorithm since the token can carry a constant-size message with it: Theorem 2 There exists an O (D) backwards communication algorithm for strongly-connected directed networks of synchronous automata. <p> We remark that our theorem is actually stronger than stated, and, in fact, is optimal: we can achieve backwards communication in time proportional to the length of the smallest directed cycle that includes the edge in question 1 . (Our solution should be compared to the best previous <ref> [ELW-90] </ref> solution for this task which takes O (N 2 ) time.) We use backward communication algorithm as a building block our traversal algorithm. <p> Previously, (in the setting of strongly-connected bounded degree directed networks of synchronous automata) [GA-84, AG-93] exhibited a O (N 2 D) solution for the traversal problem, and <ref> [ELW-90] </ref> showed a O (N 2 ) solution. Using backwards communication, in this paper we further reduce this time to O (N D): Theorem 3 There exists an O (DN ) network traversal algorithm for strongly-connected directed networks of synchronous automata. <p> It should be pointed out that our solution to the traversal problem extends and builds upon the best previously known solution of <ref> [ELW-90] </ref> for this problem. 1.4 Other Tasks The traversal and backwards communication algorithms play a central role in the design of many other protocols for unidirectional networks, which we describe below. 1 for further details, see remark 2 of section 4. 3 "Wake-up and report when done" is a task requiring <p> Previously all these tasks required O (N 2 ) time <ref> [ELW-90] </ref>. (Regarding "long circuit | slow clock" we mean that it takes O (N D) time to setup and then O (D) time for each cycle of the slow clock.) 1.5 Organization of the rest of the paper In section 2 we describe an O (N D) algorithm for the Firing <p> In fact, for directed rings a solution already exists: Lemma 1 [K-78, HN-81]: There exists an O (D) FSP algorithm for the directed ring. For the actual proof the reader is referred to [K-78, HN-81] and for an informal description of their algorithm to <ref> [ELW-90] </ref>. Here we describe the idea for rings whose diameter is a power of two (the algorithm can be easily extended to non-power-of-two diameter rings as well, see [K-78, HN-81]). <p> Definition 2 For any ring-of-trees, let D 0 denote the diameter of the ring. Lemma 2 [K-78, HN-81]: There exists an O (D 0 ) FSP algorithm for any ring-of-trees. 5 The proof is an extension of the solution to the ring (see, <ref> [K-78, HN-81, ELW-90] </ref>). The idea of the algorithm is that every processor executes the same ring algorithm, independent of whether it is on the ring or in one of the trees, sending its output to all output ports. <p> This is accomplished by the Backwards Communication algorithm. The types of messages employed by this algorithm, their uses, and their rules of propagation are detailed below. After that follows a top-down description of the algorithm itself. We employ the idea of snakes (and their propagation), introduced in <ref> [ELW-90] </ref>. A snake is a message consisting of many characters that follow each other through the graph. Many types of snakes can be constructed. We use two particular kinds, growing snakes and dying snakes. <p> B can do this by simultaneously outputting the character g i through out-port i, for each out-port, and on the next time-step simultaneously outputting the tail character, t, through each out-port. Growing snakes propagate as follows <ref> [ELW-90] </ref>: Upon receiving its first growing snake character, (Ties are broken by choosing the in-port of least index.) a quiescent processor changes to the tree state, setting its parent pointer (used in the next section) to the in-port by which the character was received. <p> All snakes other than the very first to arrive are ignored and thus vanish. Abort messages To eliminate the growing snakes when they are no longer needed, we introduce a new kind of message which was not present in <ref> [ELW-90] </ref>: abort messages. That is, at some point we no longer need the growing snakes moving through the network, or the tree structure of parent pointers they have made. To do that, B releases abort messages. <p> For use of the timing message below, the dying snake leaves its path marked as it passes. Also, since the snake is getting shorter and shorter, there is a (unique) node where the snake vanishes completely. The Timing message We will also need a timing signal (not used by <ref> [ELW-90] </ref>). As we will see below, with the natural timing of the release of messages in the algorithm, the dying snake arrives at A and delivers its token before the abort messages are done cleaning up the graph. <p> The propagation of growing snakes and abort messages occurs within the first level, whereas dying snakes and the timing message propagate in the second. Messages do not interact across the two levels. The following lemma about growing and dying snakes was used in <ref> [ELW-90] </ref>: Lemma 3 [ELW-90]: If a growing snake happens to return to its point of origin and is than mutated into a dying snake, it will retrace its path again. <p> The propagation of growing snakes and abort messages occurs within the first level, whereas dying snakes and the timing message propagate in the second. Messages do not interact across the two levels. The following lemma about growing and dying snakes was used in <ref> [ELW-90] </ref>: Lemma 3 [ELW-90]: If a growing snake happens to return to its point of origin and is than mutated into a dying snake, it will retrace its path again. <p> The token may now travel backward again on some other edge without interference from the previous backwards communication process. This is the key point of our algorithm, which allows us to avoid a costly "down-tree" <ref> [GA-84, AG-93, ELW-90] </ref> construction, which was the bottleneck of the previous solutions. The Algorithm: Consider a setting where B has a token M that it would like to communicate to A, and A has an edge to B, as above.
Reference: [GA-84] <author> E. Gafni and Y. </author> <title> Afek Election and Traversal in Unidirectional Networks PODC 1984. </title> <type> 12 </type>
Reference-contexts: A DFS may then be performed using this procedure to traverse edges in the reverse direction <ref> [GA-84, Kut88, ELW-90, AG-93] </ref>. <p> Previously, (in the setting of strongly-connected bounded degree directed networks of synchronous automata) <ref> [GA-84, AG-93] </ref> exhibited a O (N 2 D) solution for the traversal problem, and [ELW-90] showed a O (N 2 ) solution. <p> The token may now travel backward again on some other edge without interference from the previous backwards communication process. This is the key point of our algorithm, which allows us to avoid a costly "down-tree" <ref> [GA-84, AG-93, ELW-90] </ref> construction, which was the bottleneck of the previous solutions. The Algorithm: Consider a setting where B has a token M that it would like to communicate to A, and A has an edge to B, as above.
Reference: [HN-81] <author> N. Honda and Y. </author> <title> Nishitani The Firing Squad Synchronization Problem for Graphs Theoretical Computer Sciences Vol 14. </title> <year> 1981. </year>
Reference-contexts: The goal is to minimize this synchronization time t. In addition to large body of work for undirected networks (see [M-86]), FSP problem was considered for directed networks of automata in <ref> [K-78, HN-81, ELW-90] </ref>, where O (N 2 ) was the best previously known running time [ELW-90]. <p> In fact, for directed rings a solution already exists: Lemma 1 <ref> [K-78, HN-81] </ref>: There exists an O (D) FSP algorithm for the directed ring. For the actual proof the reader is referred to [K-78, HN-81] and for an informal description of their algorithm to [ELW-90]. <p> In fact, for directed rings a solution already exists: Lemma 1 <ref> [K-78, HN-81] </ref>: There exists an O (D) FSP algorithm for the directed ring. For the actual proof the reader is referred to [K-78, HN-81] and for an informal description of their algorithm to [ELW-90]. Here we describe the idea for rings whose diameter is a power of two (the algorithm can be easily extended to non-power-of-two diameter rings as well, see [K-78, HN-81]). <p> For the actual proof the reader is referred to <ref> [K-78, HN-81] </ref> and for an informal description of their algorithm to [ELW-90]. Here we describe the idea for rings whose diameter is a power of two (the algorithm can be easily extended to non-power-of-two diameter rings as well, see [K-78, HN-81]). First note that the network can simulate a finite number of messages that travel at different speeds relative to one another. <p> Further, a path from the initiator node to any leaf of any of the trees is shorter than the path from the initiator node to itself around the ring. Definition 2 For any ring-of-trees, let D 0 denote the diameter of the ring. Lemma 2 <ref> [K-78, HN-81] </ref>: There exists an O (D 0 ) FSP algorithm for any ring-of-trees. 5 The proof is an extension of the solution to the ring (see, [K-78, HN-81, ELW-90]). <p> Definition 2 For any ring-of-trees, let D 0 denote the diameter of the ring. Lemma 2 [K-78, HN-81]: There exists an O (D 0 ) FSP algorithm for any ring-of-trees. 5 The proof is an extension of the solution to the ring (see, <ref> [K-78, HN-81, ELW-90] </ref>). The idea of the algorithm is that every processor executes the same ring algorithm, independent of whether it is on the ring or in one of the trees, sending its output to all output ports.
Reference: [K-78] <author> K. </author> <title> Kobayashi The firing squad synchronization problem for a class of polyautomata networks. </title> <journal> Journal of Computer and System Science 17 </journal> <pages> 300-318, </pages> <year> 1978. </year>
Reference-contexts: The goal is to minimize this synchronization time t. In addition to large body of work for undirected networks (see [M-86]), FSP problem was considered for directed networks of automata in <ref> [K-78, HN-81, ELW-90] </ref>, where O (N 2 ) was the best previously known running time [ELW-90]. <p> In fact, for directed rings a solution already exists: Lemma 1 <ref> [K-78, HN-81] </ref>: There exists an O (D) FSP algorithm for the directed ring. For the actual proof the reader is referred to [K-78, HN-81] and for an informal description of their algorithm to [ELW-90]. <p> In fact, for directed rings a solution already exists: Lemma 1 <ref> [K-78, HN-81] </ref>: There exists an O (D) FSP algorithm for the directed ring. For the actual proof the reader is referred to [K-78, HN-81] and for an informal description of their algorithm to [ELW-90]. Here we describe the idea for rings whose diameter is a power of two (the algorithm can be easily extended to non-power-of-two diameter rings as well, see [K-78, HN-81]). <p> For the actual proof the reader is referred to <ref> [K-78, HN-81] </ref> and for an informal description of their algorithm to [ELW-90]. Here we describe the idea for rings whose diameter is a power of two (the algorithm can be easily extended to non-power-of-two diameter rings as well, see [K-78, HN-81]). First note that the network can simulate a finite number of messages that travel at different speeds relative to one another. <p> Further, a path from the initiator node to any leaf of any of the trees is shorter than the path from the initiator node to itself around the ring. Definition 2 For any ring-of-trees, let D 0 denote the diameter of the ring. Lemma 2 <ref> [K-78, HN-81] </ref>: There exists an O (D 0 ) FSP algorithm for any ring-of-trees. 5 The proof is an extension of the solution to the ring (see, [K-78, HN-81, ELW-90]). <p> Definition 2 For any ring-of-trees, let D 0 denote the diameter of the ring. Lemma 2 [K-78, HN-81]: There exists an O (D 0 ) FSP algorithm for any ring-of-trees. 5 The proof is an extension of the solution to the ring (see, <ref> [K-78, HN-81, ELW-90] </ref>). The idea of the algorithm is that every processor executes the same ring algorithm, independent of whether it is on the ring or in one of the trees, sending its output to all output ports.
Reference: [Kut88] <author> S. </author> <title> Kutten Stepwise construction of an efficient distributed traversing algorithm for general strongly-connected networks. </title> <booktitle> Proceedings of the 9'th International Conference on Computer Communication pp.446-452, </booktitle> <month> Octo-ber </month> <year> 1988. </year>
Reference-contexts: A DFS may then be performed using this procedure to traverse edges in the reverse direction <ref> [GA-84, Kut88, ELW-90, AG-93] </ref>.
Reference: [M-86] <author> J. </author> <title> Mazoyer An overview on the Firing Squad Synchronization Problem. </title> <publisher> in Automata Networks Springer Verlag LNCS 316, </publisher> <year> 1986. </year>
Reference-contexts: Of course, the objective is to minimize the time (from 1 the initial "start" signal) to perform these tasks. 1.2 The Firing Synchronization Problem The classic Firing Synchronization Problem (FSP) has a rich and colorful history (see, for example, overview of <ref> [M-86] </ref>). In essence, it is the problem of achieving micro-synchronization, given macro-synchronization. <p> The goal is to minimize this synchronization time t. In addition to large body of work for undirected networks (see <ref> [M-86] </ref>), FSP problem was considered for directed networks of automata in [K-78, HN-81, ELW-90], where O (N 2 ) was the best previously known running time [ELW-90].
Reference: [MOOY92] <author> A. Mayer, Y. Ofek, R. Ostrovsky, and M. </author> <note> Yung Self-Stabilizing Symmetry Breaking in Constant-Space STOC 1992. 13 </note>
Reference-contexts: In this paper we are also concerned with reducing the amount of memory required per each processor. The current technological trend is to implement network protocols in hardware, minimizing the amount of required memory (for further discussion, see <ref> [MOOY92] </ref>). In this paper, we model processors as identical deterministic finite-state machines (i.e. chips) of a constant size (that is, independent of the size of the network) with a constant number of input and output ports. A finite alphabet if signals is used.
References-found: 8

