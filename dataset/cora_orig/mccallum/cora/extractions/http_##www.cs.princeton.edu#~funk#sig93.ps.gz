URL: http://www.cs.princeton.edu/~funk/sig93.ps.gz
Refering-URL: http://www.cs.princeton.edu/~funk/
Root-URL: http://www.cs.princeton.edu
Title: Adaptive Display Algorithm for Interactive Frame Rates During Visualization of Complex Virtual Environments  
Author: Thomas A. Funkhouser and Carlo H. Sequin 
Keyword: CR Categories and Subject Descriptors: [Computer Graphics]: I.3.3 Picture/Image Generation viewing algorithms; I.3.5 Computational Geometry and Object Modeling geometric algorithms, object hierarchies; I.3.7 Three-Dimensional Graphics and Realism virtual reality.  
Address: Berkeley  
Affiliation: University of California at  
Abstract: We describe an adaptive display algorithm for interactive frame rates during visualization of very complex virtual environments. The algorithm relies upon a hierarchical model representation in which objects are described at multiple levels of detail and can be drawn with various rendering algorithms. The idea behind the algorithm is to adjust image quality adaptively to maintain a uniform, user-specified target frame rate. We perform a constrained optimization to choose a level of detail and rendering algorithm for each potentially visible object in order to generate the best image possible within the target frame time. Tests show that the algorithm generates more uniform frame rates than other previously described detail elision algorithms with little noticeable difference in image quality during visualization of complex models. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Airey, John M., Rohlf, John H., and Brooks, Jr., Frederick P. </author> <title> Towards Image Realism with Interactive Update Rates in Complex Virtual Building Environments. </title> <booktitle> ACM SIGGRAPH Special Issue on 1990 Symposium on Interactive 3D Graphics, </booktitle> <volume> 24, 2 (1990), </volume> <pages> 41-50. </pages>
Reference-contexts: In contrast to previous culling techniques, this algorithm guarantees a uniform, bounded frame rate, even during visualization of very large, complex models. 2 Previous Work 2.1 Visibility Determination In previous work, visibility algorithms have been described that compute the portion of a model potentially visible from a given observer viewpoint <ref> [1, 11] </ref>. These algorithms cull away large portions of a model that are occluded from the observer's viewpoint, and thereby improve frame rates significantly. However, in very detailed models, often more polygons are visible from certain observer viewpoints than can be rendered in an interactive frame time.
Reference: [2] <author> Blake, Edwin H. </author> <title> A Metric for Computing Adaptive Detail in Animated Scenes using Object-Oriented Programming. Euro-graphics `87. </title> <editor> G. Marechal (Ed.), </editor> <publisher> Elsivier Science Publishers, B.V. (North-Holland), </publisher> <year> 1987. </year>
Reference-contexts: transitions between levels of detail are barely noticeable during visualization. 241 Polygons 44 Polygons Previously described techniques for choosing a level of detail at which to render each visible object use static heuristics, most often based on a threshold regarding the size or distance of an object to the observer <ref> [2, 8, 9, 13] </ref>, or the number of pixels covered by an average polygon [5]. These simple heuristics can be very effective at improving frame rates in cases where most visible objects are far away from the observer and map to very few pixels on the workstation screen.
Reference: [3] <author> Brooks, Jr., Frederick P. </author> <title> Walkthrough ADynamic Graphics System for Simulating Virtual Buildings. </title> <booktitle> Proceedings of the 1986 Workshop on Interactive 3D Graphics. </booktitle>
Reference-contexts: If frame rates are too slow, or too jerky, the interactive feel of the system is greatly diminished <ref> [3] </ref>. However, realistic-looking models may contain millions of polygons far more than currently available workstations can render at interactive frame rates. Furthermore, the complexity of the portion of the model visible to the observer can be highly variable.
Reference: [4] <author> Clark, James H. </author> <title> Hierarchical Geometric Models for Visible Surface Algorithms. </title> <journal> Communications of the ACM, </journal> <volume> 19, 10 (Oc-tober 1976), </volume> <pages> 547-554. </pages>
Reference-contexts: This technique was first described by Clark <ref> [4] </ref>, and has been used by numerous commercial visualization systems [9].
Reference: [5] <author> Funkhouser, Thomas A., Sequin, Carlo H., and Teller, Seth J. </author> <title> Management of Large Amounts of Data in Interactive Building Walkthroughs. </title> <booktitle> ACM SIGGRAPH Special Issue on 1992 Symposium on Interactive 3D Graphics, </booktitle> <pages> 11-20. </pages>
Reference-contexts: Programs that simply render all potentially visible polygons with some predetermined quality may generate frames at highly variable rates, with no guaranteed upper bound on any single frame time. Using the UC Berkeley Building Walkthrough System <ref> [5] </ref> and a model of Soda Hall, the future Computer Science Building at UC Berkeley, as a test case, we have developed an adaptive algorithm for interactive visualization that guarantees a user-specified target frame rate. <p> Previously described techniques for choosing a level of detail at which to render each visible object use static heuristics, most often based on a threshold regarding the size or distance of an object to the observer [2, 8, 9, 13], or the number of pixels covered by an average polygon <ref> [5] </ref>. These simple heuristics can be very effective at improving frame rates in cases where most visible objects are far away from the observer and map to very few pixels on the workstation screen.
Reference: [6] <author> Garey, Michael R., and Johnson, David S. </author> <title> Computers and Intractibility: A Guide to the Theory of NP-Completeness. W.H. </title> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Unfortunately, this constrained optimization problem is NP-complete. It is the Continuous Multiple Choice Knapsack Problem <ref> [6, 7] </ref>, a version of the well-known Knapsack Problem in which elements are partitioned into candidate sets, and at most one element from each candidate set may be placed in the knapsack at once. <p> It is easy to show that a simple implementation of this greedy approach runs in O (n log n) time for n potentially visible objects, and produces a solution that is at least half as good as the optimal solution <ref> [6] </ref>.
Reference: [7] <author> Ibaraki, T., Hasegawa, T., Teranaka, K., and Iwase J. </author> <title> The Multiple Choice Knapsack Problem. </title> <institution> J. Oper. Res. Soc. </institution> <address> Japan 21, </address> <year> 1978, </year> <pages> 59-94. </pages>
Reference-contexts: Unfortunately, this constrained optimization problem is NP-complete. It is the Continuous Multiple Choice Knapsack Problem <ref> [6, 7] </ref>, a version of the well-known Knapsack Problem in which elements are partitioned into candidate sets, and at most one element from each candidate set may be placed in the knapsack at once.
Reference: [8] <author> Rossignac, Jarek, and Borrel, Paul. </author> <title> Multi-resolution 3D approximations for rendering complex scenes. </title> <booktitle> IFIP TC 5.WG 5.10 II Conference on Geometric Modeling in Computer Graphics, </booktitle> <address> Genova, Italy, </address> <year> 1993. </year> <note> Also available as IBM Research Report RC 17697, </note> <institution> Yorktown Heights, </institution> <address> NY 10598. </address>
Reference-contexts: transitions between levels of detail are barely noticeable during visualization. 241 Polygons 44 Polygons Previously described techniques for choosing a level of detail at which to render each visible object use static heuristics, most often based on a threshold regarding the size or distance of an object to the observer <ref> [2, 8, 9, 13] </ref>, or the number of pixels covered by an average polygon [5]. These simple heuristics can be very effective at improving frame rates in cases where most visible objects are far away from the observer and map to very few pixels on the workstation screen.
Reference: [9] <author> Schachter, Bruce J. (Ed.). </author> <title> Computer Image Generation. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, NY, </address> <year> 1983. </year>
Reference-contexts: This technique was first described by Clark [4], and has been used by numerous commercial visualization systems <ref> [9] </ref>. <p> transitions between levels of detail are barely noticeable during visualization. 241 Polygons 44 Polygons Previously described techniques for choosing a level of detail at which to render each visible object use static heuristics, most often based on a threshold regarding the size or distance of an object to the observer <ref> [2, 8, 9, 13] </ref>, or the number of pixels covered by an average polygon [5]. These simple heuristics can be very effective at improving frame rates in cases where most visible objects are far away from the observer and map to very few pixels on the workstation screen. <p> complexity in order to produce uniform, bounded frame rates. 2.3 Adaptive Detail Elision In an effort to maintain a specified target frame rate, some commercial flight simulators use an adaptive algorithm that adjusts the size threshold for LOD selection based on feedback regarding the time required to render previous frames <ref> [9] </ref>. If the previous frame took longer than the target frame time, the size threshold for LOD selection is increased so that future frames can be rendered more quickly.
Reference: [10] <institution> Graphics Library Programming Tools and Techniques, Document #007-1489-01, Silicon Graphics, Inc., </institution> <year> 1992. </year>
Reference-contexts: Our model, which is derived from the Graphics Library Programming Tools and Techniques document from Silicon Graphics, Inc. <ref> [10] </ref>, represents the rendering system as a pipeline with the two functional stages shown in Figure 2: * Per Primitive: coordinate transformations, lighting calcula tions, clipping, etc. * Per Pixel: rasterization, z-buffering, alpha blending, texture mapping, etc.
Reference: [11] <author> Teller, Seth J., and Sequin, Carlo H. </author> <title> Visibility Preprocessing for Interactive Walkthroughs. </title> <booktitle> Proceedings of SIGGRAPH `91. In Computer Graphics 25, </booktitle> <month> 4 (August </month> <year> 1991), </year> <pages> 61-69. </pages>
Reference-contexts: In contrast to previous culling techniques, this algorithm guarantees a uniform, bounded frame rate, even during visualization of very large, complex models. 2 Previous Work 2.1 Visibility Determination In previous work, visibility algorithms have been described that compute the portion of a model potentially visible from a given observer viewpoint <ref> [1, 11] </ref>. These algorithms cull away large portions of a model that are occluded from the observer's viewpoint, and thereby improve frame rates significantly. However, in very detailed models, often more polygons are visible from certain observer viewpoints than can be rendered in an interactive frame time.
Reference: [12] <author> Teller, Seth J. </author> <title> Visibility Computations in Densely Occluded Polyhedral Environments. </title> <type> Ph.D. thesis, </type> <institution> Computer Science Division (EECS), University of California, Berkeley, </institution> <year> 1992. </year> <note> Also available as UC Berkeley technical report UCB/CSD-92-708. </note>
Reference-contexts: All tests were performed on a Silicon Graphics VGX 320 workstation with two 33MHz MIPS R3000 processors and 64MB of memory. We used an eye-to-object visibility algorithm described in <ref> [12] </ref> to determine a set of potentially visible objects to be rendered in each frame. The application was configured as a two-stage pipeline with one processor for visibility and LOD selection computations and another separate processor for rendering. Timing statistics were gathered using a 16s timer.

References-found: 12

