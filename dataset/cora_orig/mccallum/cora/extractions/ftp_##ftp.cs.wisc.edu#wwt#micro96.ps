URL: ftp://ftp.cs.wisc.edu/wwt/micro96.ps
Refering-URL: http://www.cs.wisc.edu/~larus/Talks/path_talk/tsld042.htm
Root-URL: 
Email: tball@research.bell-labs.com larus@cs.wisc.edu  
Title: Efficient Path Profiling Example in which edge profiling does not identify the most frequently executed
Author: Thomas Ball James R. Larus 
Note: Figure 1.  
Affiliation: Bell Laboratories Dept. of Computer Sciences Lucent Technologies University of Wisconsin-Madison  
Abstract: A path profile determines how many times each acyclic path in a routine executes. This type of profiling subsumes the more common basic block and edge profiling, which only approximate path frequencies. Path profiles have many potential uses in program performance tuning, profile-directed compilation, and software test coverage. This paper describes a new algorithm for path profiling. This simple, fast algorithm selects and places profile instrumentation to minimize run-time overhead. Instrumented programs run with overhead comparable to the best previous profiling techniques. On the SPEC95 benchmarks, path profiling overhead averaged 31%, as compared to 16% for efficient edge profiling. Path profiling also identifies longer paths than a previous technique, which predicted paths from edge profiles (average of 88, versus 34 instructions). Moreover, profiling shows that the SPEC95 train input datasets covered most of the paths executed in the ref datasets. fl This research supported by: Wright Laboratory Avionics Directorate, Air Force Material Command, USAF, under grant #F33615-94-1-1525 and ARPA order no. B550; NSF NYI Award CCR-9357779, with support from Hewlett Packard, Sun Microsystems, and PGI; NSF Grant MIP-9225097; and DOE Grant DE-FG02-93ER25176. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the Wright Laboratory Avionics Directorate or the U. S. Government. Copyright 1996 IEEE. Published in the Proceedings of MICRO-29, December 2-4, 1996, in Paris, France. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works, must be obtained from the IEEE. Contact: Manager, Copyrights and Permissions / IEEE Service Center / 445 Hoes Lane / P.O. Box 1331 / Piscataway, NJ 08855-1331, USA. Telephone: + Intl. 908-562-3966. 
Abstract-found: 1
Intro-found: 1
Reference: [Bal94] <author> Thomas Ball. </author> <title> Efficiently counting program events with support for on-line queries. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1399-1410, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: The algorithm uses previous results on efficient profiling and tracing [BL94] and efficient event counting <ref> [Bal94] </ref> to determine which edges to instrument. The contribution of this paper is combine these algorithms, apply them to a new problem, and develop a new algorithm to compute an update constant for each instrumented edge. The algorithm ensures that each distinct path generates a unique value. <p> However, placements from this step may have sub-optimal run-time overhead, as above. In the next step, another algorithm <ref> [Bal94] </ref> improves this computation, by finding an equivalent computation that uses a minimal number of additions along DAG edges that are not in the DAG's spanning tree. In each graph in Figure 4, the uninstrumented edges (those without squares along them) form a spanning tree. <p> This step of the algorithm finds a maximal cost spanning tree of the graph (to find a minimal cost set of chord edges), 5 termine chord increments. and applies an efficient event counting technique <ref> [Bal94] </ref> to determine the increment Inc (c) for each chord c in a spanning tree. The event counting algorithm ensures that the sum of I nc values for any path P from EN T RY to EXI T is identical to the sum of V al values for P . <p> This information consists of the address of unterminated calls and flow graph of Figure 1. can easily be obtained from a program's stack at an unexpected event. The event counting algorithm provides a way to correctly update the counters in these routines <ref> [Bal94] </ref>. 4 Path Profiling of Arbitrary Control-Flow This section extends path profiling to arbitrary control-flow graphs that contain cycles (including irreducible loops). Any cycle in a control-flow graph must contain a backedge (as identified by a depth-first search of the graph).
Reference: [Bal96] <author> Vasanth Bala. </author> <title> Low overhead path profiling. </title> <type> Technical report, </type> <institution> Hewlett Packard Labs, </institution> <year> 1996. </year>
Reference-contexts: Unlike path profiling, this technique need not distinguish cyclic from acyclic paths since it truncates both at the FIFO boundary. Bit tracing is another approach to path profiling. Bit tracing associates a 1-bit value with the outcome of each two-way branch <ref> [BL94, Bal96] </ref>. When a branch executes, instrumentation code appends a bit to a trace buffer that records branch outcomes. By recording multiple bits, the approach can be extended to multi-way branches. The contents of the buffer form an index into an array or as a hash value.
Reference: [BL93] <author> Thomas Ball and James R. Larus. </author> <title> Branch prediction for free. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 300-313, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: In part, this result reflects the simple behavior of the SPEC95 benchmarks, which execute an average of 7.7 (2.6-60.0) paths in each routine. It is also consistent with previous work in dynamic and static branch prediction <ref> [FF92, BL93] </ref>, which found that branches in a program typically follow one direction with very high probability, and this high-probability direction generally remains the same for different inputs. Table 3 compares paths executed with the SPEC95 train and ref input datasets. <p> This result is again consistent with earlier work that found program behavior to be independent of program data <ref> [FF92, BL93] </ref>. These measurements suggest that path profiles could greatly improve peak SPEC95 performance by providing an inexpensive and accurate basis for profile-driven compilation. 7 Summary This paper describes a new algorithm for path profiling. A path profile records the execution frequencies of acyclic paths in a routine.
Reference: [BL94] <author> Thomas Ball and James R. Larus. </author> <title> Optimally profiling and tracing programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(4) </volume> <pages> 1319-1360, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: A minor change to the path profiling code could increment a path's counter by the change in a counter over the path. 1.3 Paper Overview The path profiling algorithm instruments a program to record paths with low run-time overhead. The algorithm uses previous results on efficient profiling and tracing <ref> [BL94] </ref> and efficient event counting [Bal94] to determine which edges to instrument. The contribution of this paper is combine these algorithms, apply them to a new problem, and develop a new algorithm to compute an update constant for each instrumented edge. <p> We implemented the algorithms presented here in a profiling tool, PP, which uses the EEL library [LS95] to insert instrumentation into executable binaries (Section 5). This paper compares PP against QPT2, another profiling tool built with EEL, which uses an efficient edge profiling algorithm <ref> [BL94] </ref>. QPT2 usually incurred less overhead, but the two system were roughly comparable. Profiling the SPEC95 benchmarks, PP's overhead averaged 31% (6-97%) while QPT2's overhead averaged 16% (-2.6-53%) (Section 6). <p> path profiling shows that the paths executed with the SPEC95 train dataset cover most of the dynamically executed instructions in the ref dataset, which suggests that path profiles could help improve SPEC95 peak numbers. 2 Related Work The path profiling algorithm, like previous work on efficient profiling and tracing techniques <ref> [BL94, Gol91] </ref>, uses a spanning tree to determine a minimal, low-cost set of edges to instrument. For example, Figure 3 shows the control-flow graph from Figure 2 instrumented for edge profiling (the uninstrumented edges form a spanning tree). The same set of edges are instrumented in both cases. <p> Unlike path profiling, this technique need not distinguish cyclic from acyclic paths since it truncates both at the FIFO boundary. Bit tracing is another approach to path profiling. Bit tracing associates a 1-bit value with the outcome of each two-way branch <ref> [BL94, Bal96] </ref>. When a branch executes, instrumentation code appends a bit to a trace buffer that records branch outcomes. By recording multiple bits, the approach can be extended to multi-way branches. The contents of the buffer form an index into an array or as a hash value. <p> A maximum spanning tree of the graph, with respect to that weighting, maximizes the weight (execution frequency) of the uninstru-mented edges. PP uses the same previously published, effective algorithm for statically computing a weighting as QPT <ref> [BL94] </ref>. 4 foreach vertex v in reverse topological order - if v is a leaf vertex - NumPaths (v) = 1; else NumPaths (v) = 0; for each edge e = v-&gt;w - Val (e) = NumPaths (v); NumPaths (v) = NumPaths (v) + NumPaths (w); - - DAG. <p> At vertex D, R still has a value of 1, so the path traverses edge D ! E, followed by E ! F . The resulting regenerated path is ABCDEF , which is the path that generates the path sum 3. 3.6 Early Termination Like other efficient profiling algorithms <ref> [BL94] </ref>, path profiling requires extra information to derive correct profiles for routines that terminate unexpectedly because of exceptions, unrecognized non-local gotos, or calls to exit. <p> Larger (64 bit) words would alleviate, though probably not eliminate, the need to truncate paths. 6 Experimental Results This section uses the SPEC95 benchmarks to compare path profiling (PP) against edge profiling (QPT2), which has the lowest overhead of conventional profiling techniques <ref> [BL94] </ref>. The programs ran stand-alone on a Sun Ultra-server E5000-167Mhz UltraSPARC processors and 2GB of memory-running Solaris 2.5.1 with a local file system.
Reference: [Cha88] <author> Pohua P. Chang. </author> <title> Trace selection for compiling large C application programs to microcode. </title> <booktitle> In 21th Annual Workshop on Microprogramming and Microarchitecture (MICRO 21), </booktitle> <pages> pages 21-29, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: Recently, fine-grain profilesof basic blocks and control-flow edgeshave become the basis for profile-driven compilation, which uses measured frequencies to guide compilation and optimization. One use of profile information is to identify heavily executed paths (or traces) in a program <ref> [Fis81, Ell85, Cha88, YS94] </ref>. Unfortunately, basic block and edge profiles, although inexpensive and widely available, do not always correctly predict frequencies of overlapping paths. Consider, for example, the control-flow graph (CFG) in Figure 1. <p> A commonly used heuristic to select a heavily executed path follows the most frequently executed edge out of a basic block <ref> [Cha88] </ref>, 1 which identifies path ACDEF . However, in path profile P rof 1, this path executed only 60 times, as compared to 90 times for path ACDF and 100 times for path ABCDEF .
Reference: [Ell85] <author> John R. Ellis. Bulldog: </author> <title> A compiler for VLIW architectures. </title> <type> Technical Report YALEU/DCS/RR-364, </type> <institution> Yale University, Department of Computer Science, </institution> <month> February </month> <year> 1985. </year>
Reference-contexts: Recently, fine-grain profilesof basic blocks and control-flow edgeshave become the basis for profile-driven compilation, which uses measured frequencies to guide compilation and optimization. One use of profile information is to identify heavily executed paths (or traces) in a program <ref> [Fis81, Ell85, Cha88, YS94] </ref>. Unfortunately, basic block and edge profiles, although inexpensive and widely available, do not always correctly predict frequencies of overlapping paths. Consider, for example, the control-flow graph (CFG) in Figure 1.
Reference: [FF92] <author> Joseph A. Fisher and Stefan M. Freudenberger. </author> <title> Predicting conditional branch directions from previous runs of a program. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS V), </booktitle> <pages> pages 85-95, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In part, this result reflects the simple behavior of the SPEC95 benchmarks, which execute an average of 7.7 (2.6-60.0) paths in each routine. It is also consistent with previous work in dynamic and static branch prediction <ref> [FF92, BL93] </ref>, which found that branches in a program typically follow one direction with very high probability, and this high-probability direction generally remains the same for different inputs. Table 3 compares paths executed with the SPEC95 train and ref input datasets. <p> This result is again consistent with earlier work that found program behavior to be independent of program data <ref> [FF92, BL93] </ref>. These measurements suggest that path profiles could greatly improve peak SPEC95 performance by providing an inexpensive and accurate basis for profile-driven compilation. 7 Summary This paper describes a new algorithm for path profiling. A path profile records the execution frequencies of acyclic paths in a routine.
Reference: [Fis81] <author> Joseph A. Fisher. </author> <title> Trace scheduling: A technique for global microcode compaction. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-30(7):478-490, </volume> <month> July </month> <year> 1981. </year>
Reference-contexts: Recently, fine-grain profilesof basic blocks and control-flow edgeshave become the basis for profile-driven compilation, which uses measured frequencies to guide compilation and optimization. One use of profile information is to identify heavily executed paths (or traces) in a program <ref> [Fis81, Ell85, Cha88, YS94] </ref>. Unfortunately, basic block and edge profiles, although inexpensive and widely available, do not always correctly predict frequencies of overlapping paths. Consider, for example, the control-flow graph (CFG) in Figure 1.
Reference: [Gol91] <author> Aaron Goldberg. </author> <title> Reducing overhead in counter-based execution profiling. </title> <type> Technical Report CSL-TR-91-495, </type> <institution> Computer System Laboratory, Stanford University, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: path profiling shows that the paths executed with the SPEC95 train dataset cover most of the dynamically executed instructions in the ref dataset, which suggests that path profiles could help improve SPEC95 peak numbers. 2 Related Work The path profiling algorithm, like previous work on efficient profiling and tracing techniques <ref> [BL94, Gol91] </ref>, uses a spanning tree to determine a minimal, low-cost set of edges to instrument. For example, Figure 3 shows the control-flow graph from Figure 2 instrumented for edge profiling (the uninstrumented edges form a spanning tree). The same set of edges are instrumented in both cases.
Reference: [LS95] <author> James R. Larus and Eric Schnarr. EEL: </author> <title> Machine-independent executable editing. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 291-300, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The relatively high cost of hashing accounts for the higher overhead of path profiling, as compared to edge profiling. We implemented the algorithms presented here in a profiling tool, PP, which uses the EEL library <ref> [LS95] </ref> to insert instrumentation into executable binaries (Section 5). This paper compares PP against QPT2, another profiling tool built with EEL, which uses an efficient edge profiling algorithm [BL94]. QPT2 usually incurred less overhead, but the two system were roughly comparable. <p> PP is built on EEL (Executable Editing Library), which is a C++ library that hides much of the complexity and system-specific detail of editing executables <ref> [LS95] </ref>.
Reference: [YS94] <author> Cliff Young and Michael D. Smith. </author> <title> Improving the accuracy of static branch prediction using branch correlation. </title> <booktitle> In Proceedings of the Sixth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS VI), </booktitle> <pages> pages 232-241, </pages> <month> October </month> <year> 1994. </year> <month> 12 </month>
Reference-contexts: Recently, fine-grain profilesof basic blocks and control-flow edgeshave become the basis for profile-driven compilation, which uses measured frequencies to guide compilation and optimization. One use of profile information is to identify heavily executed paths (or traces) in a program <ref> [Fis81, Ell85, Cha88, YS94] </ref>. Unfortunately, basic block and edge profiles, although inexpensive and widely available, do not always correctly predict frequencies of overlapping paths. Consider, for example, the control-flow graph (CFG) in Figure 1. <p> However, there are procedures that have so many potential paths that a hash table must be used to store the profile. Young and Smith used a limited form of program tracing to record paths for their branch correlation studies <ref> [YS94] </ref>. In a FIFO buffer, they recorded the last n branches, each of which consists of a basic block number and branch outcome. 3 for the control-flow graph from Figure 1.
References-found: 11

