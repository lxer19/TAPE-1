URL: http://http.cs.berkeley.edu/~manuel/papers/afl-pldi95.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~manuel/publications.html
Root-URL: 
Title: Better Static Memory Management: Improving Region-Based Analysis of Higher-Order Languages (Extended Abstract)  
Author: Alexander Aiken Manuel F ahndrich Raph Levien 
Address: Berkeley  
Affiliation: Computer Science Division University of California,  
Abstract: Static memory management replaces runtime garbage collection with compile-time annotations that make all memory allocation and deallocation explicit in a program. We improve upon the Tofte/Talpin region-based scheme for compile-time memory management [TT94]. In the Tofte/Talpin approach, all values, including closures, are stored in regions. Region lifetimes coincide with lexical scope, thus forming a runtime stack of regions and eliminating the need for garbage collection. We relax the requirement that region lifetimes be lexical. Rather, regions are allocated late and deallocated as early as possible by explicit memory operations. The placement of allocation and deallocation annotations is determined by solving a system of constraints that expresses all possible annotations. Experiments show that our approach reduces memory requirements significantly, in some cases asymptotically. 
Abstract-found: 1
Intro-found: 1
Reference: [AFL95] <author> Alexander Aiken, Manuel Fahndrich, and Raph Levien. </author> <title> Better static memory management: Improving region-based analysis of higher-order languages. </title> <type> Technical Report CSD-95-866, </type> <institution> UC Berkeley, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: The set of possible closures in an application of a given region environment is computed by the extended closure analysis. For brevity, we do not describe the handling of quantified effect variables (for details see <ref> [AFL95] </ref>). 4.3 Constraint Resolution In general, the constraint system has multiple solutions. For example, the state of a region after the last use is unspecified. We may place the point of deallocation of such a region anywhere after its last use, but obviously we prefer the first possible program point. <p> n ` e ! a; s 0 s; r; n sat R; [[ ]] e;R ; ' o we conclude s 0 ; a sat V e;R ; ' o The proof is by induction on the structure of e and is included in the full version of the paper <ref> [AFL95] </ref>. 6 Implementation and Experiments We have implemented our algorithm in Standard ML [MTH90]. Our system is built on top of an implementation of the system described in [TT93, TT94], generously provided to us by Mads Tofte.
Reference: [App92] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Instead, we present representative examples of three typical patterns of behavior we have identified. A number of programs show asymptotic improvement over the Tofte/Talpin system. One example given in their paper (due to Appel <ref> [App92] </ref>), has O (n 2 ) space complexity. Our completion of this program exhibits O (n) space complexity (Figure 5). In this program, our analysis is able to deallocate a recursive function's parameter before function evaluation completes.
Reference: [Deu90] <author> Alain Deutsch. </author> <title> On determining lifetime and alias ing of dynamically allocated data in higher-order functional specifications. </title> <booktitle> In Proc. of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 157-168, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Our results do not resolve this question, but we do show that static memory management can be significantly better than previously demonstrated. Much previous work has focussed on reducing, rather than eliminating, garbage collection <ref> [HJ90, Deu90] </ref>. The primary motivation for static memory management put forth in [TT94] is to reduce the amount of memory required to run general functional programs efficiently. Two other applications interest us. First, the pauses in execution caused by garbage collection pose a difficulty for programs with real-time constraints.
Reference: [DLM + 78] <author> Edsger W. Dijkstra, Leslie Lamport, A.J. Mar tin, C.S. Scholten, and E.F.M. Steffens. </author> <title> On-the-fly garbage collection: An exercise in cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-975, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: Two other applications interest us. First, the pauses in execution caused by garbage collection pose a difficulty for programs with real-time constraints. While there has been substantial work on real-time garbage collection <ref> [DLM + 78, NO93] </ref>, we find the simpler model of having no garbage collector at all appealing and worth investigation. Second, most programs written today are not written in garbage-collected applicative languages, but rather in procedural languages with programmer-specified memory management.
Reference: [Hen92] <author> Fritz Henglein. </author> <title> Global tagging optimization by type inference. </title> <booktitle> In Proc. of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 205-215, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: If c p = true the region state prior to the allocation point is U and afterwards A, i.e. allocation. If c p = false, then the state prior is equal to the state after, i.e. no allocation. This approach is similar in spirit to the coercions of <ref> [Hen92] </ref>.
Reference: [HJ90] <author> Geoff W. Hamilton and Simon B. Jones. </author> <title> Compile time garbage collection by necessity analysis. </title> <booktitle> In Proc. of the 1990 Glasgow Workshop on Functional Programming, </booktitle> <pages> pages 66-70, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Our results do not resolve this question, but we do show that static memory management can be significantly better than previously demonstrated. Much previous work has focussed on reducing, rather than eliminating, garbage collection <ref> [HJ90, Deu90] </ref>. The primary motivation for static memory management put forth in [TT94] is to reduce the amount of memory required to run general functional programs efficiently. Two other applications interest us. First, the pauses in execution caused by garbage collection pose a difficulty for programs with real-time constraints.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: We present the example informally; the formal presentation begins in Section 2. Consider the following simple program, taken from [TT94]: (let x = (2,3) in y:(fst x; y) end) 5 The source language is a conventional typed, call-by-value lambda calculus; it is essentially the applicative subset of ML <ref> [MTH90] </ref>. The annotated program produced by the Tofte/Talpin system is: Example 1.1 letregion 4 ; 5 in letregion 6 in let x = (2@ 2 ,3@ 6 )@ 4 in end end There are two kinds of annotations: letregion in e binds a new region to the region variable . <p> ]] e;R ; ' o we conclude s 0 ; a sat V e;R ; ' o The proof is by induction on the structure of e and is included in the full version of the paper [AFL95]. 6 Implementation and Experiments We have implemented our algorithm in Standard ML <ref> [MTH90] </ref>. Our system is built on top of an implementation of the system described in [TT93, TT94], generously provided to us by Mads Tofte. The implementation is extended with numbers, pairs, lists, and conditionals, so that nontrivial programs can be tested.
Reference: [NO93] <author> Scott Nettles and James O'Toole. </author> <title> Real-time repli cation garbage collection. </title> <booktitle> In Proc. SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 217-226, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Two other applications interest us. First, the pauses in execution caused by garbage collection pose a difficulty for programs with real-time constraints. While there has been substantial work on real-time garbage collection <ref> [DLM + 78, NO93] </ref>, we find the simpler model of having no garbage collector at all appealing and worth investigation. Second, most programs written today are not written in garbage-collected applicative languages, but rather in procedural languages with programmer-specified memory management.
Reference: [PS92] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Safety analysis versus type inference. </title> <journal> Information Processing Letters, </journal> <volume> 43(4) </volume> <pages> 175-180, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Thus, an abstract region environment preserves the region aliasing structure of the underlying region environment. The extended closure analysis is given in Figure 3. Following <ref> [PS92] </ref>, the analysis is presented as a system of constraints; any solution of the constraints is sound. We assume that program variables are renamed as necessary so that each variable is identified with a unique binding.
Reference: [RM88] <author> Cristina Ruggieri and Thomas P. Murtagh. </author> <title> Lifetime analysis of dynamically allocated objects. </title> <booktitle> In Proc. of the 15th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 285-293, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: In their scheme, runtime memory is partitioned into regions. Every computed value is stored in some region. Regions themselves are allocated and deallocated according to a stack discipline akin to the standard implementation of activation records in procedural languages and similar to that of <ref> [RM88] </ref>.
Reference: [Ses92] <author> Peter Sestoft. </author> <title> Analysis and Efficient Implementa tion of Functional Programs. </title> <type> PhD dissertation, </type> <institution> University of Copenhagen, Department of Computer Science, </institution> <year> 1992. </year>
Reference-contexts: Thus, the constraints are defined over the program's control flow. However, because of higher order functions, inferring control flow from the syntactic form of the program is difficult. A well-known solution to this problem is closure analysis <ref> [Ses92] </ref>, which gives a useful approximation to the set of possible closures at every application. Our algorithm consists of two phases. We begin with the Tofte/Talpin annotation of a program. <p> Closure analysis approximates execution order in higher-order programs <ref> [Shi88, Ses92] </ref>. However, closure analysis alone is not sufficient for our purposes, because of problems with state polymorphism and region aliasing (see below). Imprecision in state polymorphism gives poor completions, but failure to detect aliasing may result in unsound completions. Consider again the program in Example 2.1.
Reference: [Shi88] <author> Olin Shivers. </author> <title> Control flow analysis in Scheme. </title> <booktitle> In Proc. SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 164-174, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Closure analysis approximates execution order in higher-order programs <ref> [Shi88, Ses92] </ref>. However, closure analysis alone is not sufficient for our purposes, because of problems with state polymorphism and region aliasing (see below). Imprecision in state polymorphism gives poor completions, but failure to detect aliasing may result in unsound completions. Consider again the program in Example 2.1.
Reference: [Tof94] <author> Mads Tofte. </author> <title> Storage mode analysis. </title> <type> Personal com munication, </type> <month> October </month> <year> 1994. </year>
Reference-contexts: The constraints are solved and the solution is used to complete the source program, transforming selected choice points into allocation/deallocation operations, and removing the rest. Our annotations are orthogonal to the storage mode analysis mentioned in [TT94] and described in more detail in <ref> [Tof94] </ref>. Thus, the target programs contain both storage mode annotations and the allocation annotations described in this paper. On the other hand, our analysis subsumes the optimization described in Appendix B of [TT94], so that optimization is disabled in our system. Summary performance measures are in Table 2.
Reference: [TT93] <author> Mads Tofte and Jean-Pierre Talpin. </author> <title> A theory of stack allocation in polymorphically typed languages. </title> <type> Technical Report 93/15, </type> <institution> Department of Computer Science, University of Copenhagen, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Our system is built on top of an implementation of the system described in <ref> [TT93, TT94] </ref>, generously provided to us by Mads Tofte. The implementation is extended with numbers, pairs, lists, and conditionals, so that nontrivial programs can be tested. For each source program, we first use the Tofte/Talpin system to region annotate the program. We then compute the extended closure analysis (Section 3).
Reference: [TT94] <author> Mads Tofte and Jean-Pierre Talpin. </author> <title> Implementation of the typed call-by-value -calculus using a stack of regions. </title> <booktitle> In Proc. of the 21st Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 188-201, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: 1 Introduction In a recent paper, Tofte and Talpin propose a novel method for memory management in typed, higher-order languages <ref> [TT94] </ref>. In their scheme, runtime memory is partitioned into regions. Every computed value is stored in some region. Regions themselves are allocated and deallocated according to a stack discipline akin to the standard implementation of activation records in procedural languages and similar to that of [RM88]. <p> Email: faiken,manuel,raphg@cs.berkeley.edu URL: http://kiwi.cs.berkeley.edu/nogc operations for managing regions. Thus, there is no need for a garbage collectorall memory allocation and deallocation is statically specified in the program. The system in <ref> [TT94] </ref> makes surprisingly economical use of memory. However, it is usually possible to do significantly better and in some cases dramatically better than the Tofte/Talpin algorithm. <p> Our results do not resolve this question, but we do show that static memory management can be significantly better than previously demonstrated. Much previous work has focussed on reducing, rather than eliminating, garbage collection [HJ90, Deu90]. The primary motivation for static memory management put forth in <ref> [TT94] </ref> is to reduce the amount of memory required to run general functional programs efficiently. Two other applications interest us. First, the pauses in execution caused by garbage collection pose a difficulty for programs with real-time constraints. <p> Our approach to static memory management is best illustrated with an example. We present the example informally; the formal presentation begins in Section 2. Consider the following simple program, taken from <ref> [TT94] </ref>: (let x = (2,3) in y:(fst x; y) end) 5 The source language is a conventional typed, call-by-value lambda calculus; it is essentially the applicative subset of ML [MTH90]. <p> The language includes region polymorphic functionsfunctions that take regions as arguments. Region polymorphism allows each invocation of a recursive function to operate on different regions, which is important for achieving good separation of region lifetimes <ref> [TT94] </ref>. The Tofte/Talpin annotations are derived using a nonstandard type system. A type is a pair (t; ), where t indicates the kind of value (integer, function, etc.) and refers to the region where values of the type are stored. <p> Our system is built on top of an implementation of the system described in <ref> [TT93, TT94] </ref>, generously provided to us by Mads Tofte. The implementation is extended with numbers, pairs, lists, and conditionals, so that nontrivial programs can be tested. For each source program, we first use the Tofte/Talpin system to region annotate the program. We then compute the extended closure analysis (Section 3). <p> The constraints are solved and the solution is used to complete the source program, transforming selected choice points into allocation/deallocation operations, and removing the rest. Our annotations are orthogonal to the storage mode analysis mentioned in <ref> [TT94] </ref> and described in more detail in [Tof94]. Thus, the target programs contain both storage mode annotations and the allocation annotations described in this paper. On the other hand, our analysis subsumes the optimization described in Appendix B of [TT94], so that optimization is disabled in our system. <p> Our annotations are orthogonal to the storage mode analysis mentioned in <ref> [TT94] </ref> and described in more detail in [Tof94]. Thus, the target programs contain both storage mode annotations and the allocation annotations described in this paper. On the other hand, our analysis subsumes the optimization described in Appendix B of [TT94], so that optimization is disabled in our system. Summary performance measures are in Table 2. We have not measured carefully the time required to compute our analysis, but our method appears to scale as well as the Tofte/Talpin system. <p> The evaluation stack is not counted, a measurement methodology consistent with <ref> [TT94] </ref>. Quicksort is not unusual in this behavior. The program recursively traverses its input list, stores the contents on the evaluation stack, frees the list cells when it reaches the end, and builds up the output list upon return.
References-found: 15

