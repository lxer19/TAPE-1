URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/transaction.logic/pods99.ps
Refering-URL: http://www.cs.toronto.edu/~bonner/papers.html
Root-URL: http://www.cs.toronto.edu
Email: email: bonner@db.toronto.edu  
Phone: phone: (416) 978-7441 fax: (416) 978-4765  
Title: Workflows, Transactions, and Datalog  
Author: Anthony J. Bonner 
Date: November 26, 1998  
Web: web: www.cs.toronto.edu/~bonner  
Address: Toronto, Ontario, Canada M5S 1A4  
Affiliation: University of Toronto Department of Computer Science  
Abstract: Transaction Datalog (abbreviated T D) is a concurrent programming language that provides process modeling, database access, and advanced transactions. This paper illustrates the use of T D for specifying and simulating workflows, with examples based on the needs of a high-throughput genome laboratory. In addition to database support, these needs include concurrent access to shared resources, synchronization of work, and networks of cooperating workflows. We also use T D to explore the computational complexity of workflows in data-intensive applications. We show, for instance, that workflows can be vastly more complex than database transactions, largely because concurrent processes can interact and communicate via the database (i:e:, one process can read what another one writes). We then investigate the sources of this complexity, focusing on features for data modeling and process modeling. We show that by carefully controlling these features, the complexity of workflows can be reduced substantially. Finally, we develop a sublanguage called fully bounded T D that provides a practical blend of modeling features while minimizing complexity. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul. </author> <title> Updates, a new frontier. </title> <booktitle> In Int'l Conference on Database Theory, </booktitle> <pages> pages 1-18, </pages> <year> 1988. </year>
Reference-contexts: Section 3 gives examples of both. The complexity of database transactions has been defined in the same way <ref> [3, 1] </ref>. However, workflows can be much more complex than traditional transactions. For instance, Section 4.1 shows that T D can simulate an arbitrary Turing machine, even though it has none of the features that normally lead to this kind of power in a database language. <p> Specifically, T D does not expand the data domain or the database schema during program execution. Transaction languages with this property are said to be safe, and typically their data complexity is complete for PSPACE <ref> [2, 3, 1, 25] </ref>. In contrast, the data complexity T D is complete for RE. This dramatic increase in complexity, from PSPACE to RE, is due entirely to interactions between processes. Section 4 studies the sources of this complexity in more detail by developing a family of syntactic restrictions. <p> In contrast, T D achieves RE-completeness with a fixed data domain, and a fixed database schema, and thus with databases of polynomial size. This demonstrates a fundamental difference between T D and other safe transaction languages, which are typically PSPACE-complete <ref> [2, 3, 1, 25] </ref>. Our proof of Theorem 4.3 bears some resemblance to the simulation of Turing machines in process algebras such as CCS [65]. <p> Concurrency is essential to the power of T D. As Theorem 4.5 shows, when concurrent composition is removed, the data complexity of T D plummets from RE to EXPTIME. This version of the language, which we call sequential T D, is comparable to safe transaction languages <ref> [2, 3, 1, 25] </ref>. 7 This is a common phenomenon in logical languages. <p> Also, as usual in expressibility results of this kind, we assume that the constant symbols are uninterpreted. Formally, this means extending the notion of genericity from queries to transactions, as in <ref> [3, 1] </ref>. Details are given in the long version of this paper [14]. 4 DATA COMPLEXITY 10 The main difference is that such languages are typically complete for PSPACE, not EXPTIME. The extra power of sequential T D comes froms an ability to simulate alternating PSPACE machines [26].
Reference: [2] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural languages for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 41 </volume> <pages> 181-229, </pages> <year> 1990. </year>
Reference-contexts: Specifically, T D does not expand the data domain or the database schema during program execution. Transaction languages with this property are said to be safe, and typically their data complexity is complete for PSPACE <ref> [2, 3, 1, 25] </ref>. In contrast, the data complexity T D is complete for RE. This dramatic increase in complexity, from PSPACE to RE, is due entirely to interactions between processes. Section 4 studies the sources of this complexity in more detail by developing a family of syntactic restrictions. <p> In particular, it is a safe language that does not generate an unbounded number of tuples during transaction 4 DATA COMPLEXITY 9 execution. In contrast, other transaction languages achieve RE-completeness by expanding the data domain during transaction execution <ref> [2, 3, 19] </ref>, or by expanding the database schema [24]. Typically, the proof of RE-completeness involves encoding the tape of a Turing machine in the database. In such approaches, the database grows to arbitrary size during transaction execution, since it encodes a machine tape that grows to arbitrary length. <p> In contrast, T D achieves RE-completeness with a fixed data domain, and a fixed database schema, and thus with databases of polynomial size. This demonstrates a fundamental difference between T D and other safe transaction languages, which are typically PSPACE-complete <ref> [2, 3, 1, 25] </ref>. Our proof of Theorem 4.3 bears some resemblance to the simulation of Turing machines in process algebras such as CCS [65]. <p> Concurrency is essential to the power of T D. As Theorem 4.5 shows, when concurrent composition is removed, the data complexity of T D plummets from RE to EXPTIME. This version of the language, which we call sequential T D, is comparable to safe transaction languages <ref> [2, 3, 1, 25] </ref>. 7 This is a common phenomenon in logical languages.
Reference: [3] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43 </volume> <pages> 62-124, </pages> <year> 1991. </year>
Reference-contexts: Section 3 gives examples of both. The complexity of database transactions has been defined in the same way <ref> [3, 1] </ref>. However, workflows can be much more complex than traditional transactions. For instance, Section 4.1 shows that T D can simulate an arbitrary Turing machine, even though it has none of the features that normally lead to this kind of power in a database language. <p> Specifically, T D does not expand the data domain or the database schema during program execution. Transaction languages with this property are said to be safe, and typically their data complexity is complete for PSPACE <ref> [2, 3, 1, 25] </ref>. In contrast, the data complexity T D is complete for RE. This dramatic increase in complexity, from PSPACE to RE, is due entirely to interactions between processes. Section 4 studies the sources of this complexity in more detail by developing a family of syntactic restrictions. <p> Our results are based on a number of standard definitions, adapted from <ref> [3, 24] </ref>. A database schema is a finite set of base predicate symbols (with associated arities). A database with schema S is a finite set of ground atoms constructed from the predicate symbols in S. <p> In particular, it is a safe language that does not generate an unbounded number of tuples during transaction 4 DATA COMPLEXITY 9 execution. In contrast, other transaction languages achieve RE-completeness by expanding the data domain during transaction execution <ref> [2, 3, 19] </ref>, or by expanding the database schema [24]. Typically, the proof of RE-completeness involves encoding the tape of a Turing machine in the database. In such approaches, the database grows to arbitrary size during transaction execution, since it encodes a machine tape that grows to arbitrary length. <p> In contrast, T D achieves RE-completeness with a fixed data domain, and a fixed database schema, and thus with databases of polynomial size. This demonstrates a fundamental difference between T D and other safe transaction languages, which are typically PSPACE-complete <ref> [2, 3, 1, 25] </ref>. Our proof of Theorem 4.3 bears some resemblance to the simulation of Turing machines in process algebras such as CCS [65]. <p> Concurrency is essential to the power of T D. As Theorem 4.5 shows, when concurrent composition is removed, the data complexity of T D plummets from RE to EXPTIME. This version of the language, which we call sequential T D, is comparable to safe transaction languages <ref> [2, 3, 1, 25] </ref>. 7 This is a common phenomenon in logical languages. <p> Also, as usual in expressibility results of this kind, we assume that the constant symbols are uninterpreted. Formally, this means extending the notion of genericity from queries to transactions, as in <ref> [3, 1] </ref>. Details are given in the long version of this paper [14]. 4 DATA COMPLEXITY 10 The main difference is that such languages are typically complete for PSPACE, not EXPTIME. The extra power of sequential T D comes froms an ability to simulate alternating PSPACE machines [26].
Reference: [4] <author> S. Abiteboul, V. Vianu, B. Fordham, and Y. Yesha. </author> <title> Relational transducers for electronic commerce. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 179-187, </pages> <address> Seattle, Washington, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: To deal with this problem, some database researchers have chosen to restrict the process model instead of the data model <ref> [4, 30, 66] </ref>. Unfortunately, the result, once again, is that many realistic workflows are not considered. In this paper, we take a different approach and address a different set of questions.
Reference: [5] <author> N. Adam, V. Atluri, and W. Huang. </author> <title> Modeling and analysis of workflows using Petri nets. </title> <journal> Journal of Intelligent Information Systems, </journal> <volume> 10(2) </volume> <pages> 131-158, </pages> <month> March </month> <year> 1998. </year>
Reference: [6] <institution> Standard Guide for Laboratory Information Management Systems (LIMS). American Society for Testing and Materials, </institution> <address> 1916 Race St., Philadelphia PA 19103, U.S.A, </address> <year> 1993. </year>
Reference-contexts: As such, well-known optimization techniques (such as magic sets or tabling) can be applied. Suppose we augment tuple testing with tuple insertion (but not deletion). This is a natural set of operations for many scientific workflows, where workflow activities are laboratory experiments that gather, store and analyze information <ref> [6] </ref>. This is certainly the case for workflows at the Whitehead Institute/MIT Center for Genome Research [21, 64], where experimental results are accumulated in the database, and queried by analysis programs, but never deleted or altered.
Reference: [7] <author> P. Attie, M. Singh, A. Sheth, and M. Rusinkiewicz. </author> <title> Specifying and enforcing intertask dependencies. </title> <booktitle> In Int'l Conference on Very Large Data Bases, </booktitle> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference: [8] <author> J.C.M. Baeten and W.P. Weijland. </author> <title> Process Algebra. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference: [9] <author> T. Baker, J. Gill, and R. Soloway. </author> <title> Relativiza tions of the P ? = NP question. </title> <journal> SIAM Journal of Computing, </journal> <volume> 4 </volume> <pages> 431-442, </pages> <year> 1975. </year>
Reference-contexts: Likewise, the rule r (X; Z) p (X; Y ) j q (Y; Z) expresses the projection of this join onto two attributes. Any classical Datalog query can be expressed in this fashion. 3 Another approach would be to prove relativized complexity results <ref> [59, 9] </ref> with elementary operations modeled by a variation of oracle Turing machines. All of the results in this paper can be relativized in this way, although additional formal machinery is required.
Reference: [10] <author> J. Balcazar, J. Gabarro, and M. Santha. </author> <title> Deciding bisimilarity is P-complete. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4(6) </volume> <pages> 638-648, </pages> <year> 1992. </year>
Reference: [11] <author> J.A. Bergstra and J.W. Klop. </author> <title> Algebra of communicating processes with abstraction. </title> <journal> Theoretical Computer Science, </journal> <volume> 37(1) </volume> <pages> 77-121, </pages> <year> 1985. </year>
Reference: [12] <author> P.A. Bernstein, V. Hadzilacos, and N. Good-man. </author> <title> Concurrency Control and Recovery in Databases. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Isolation is a fundamental property of database transactions <ref> [12, 38] </ref>, and is closely related to serializabil-ity. For instance, if t 1 , t 2 , ..., t n are database programs, then the goal fit 1 j fit 2 j j fit n executes them serializably.
Reference: [13] <author> A.J. Bonner. </author> <title> Concurrent transaction logic. </title> <booktitle> Presented at the Dagstuhl Seminar on Transactional Workflows, </booktitle> <month> July 15-19 </month> <year> 1996, </year> <booktitle> International Conference and Research Center for Computer Science, </booktitle> <address> Schloss Dagstuhl, Wadern, Germany. </address>
Reference-contexts: 1 INTRODUCTION 2 Our vehicle for this investigation is Transaction Datalog (abbreviated T D), a concurrent programming language that provides both process modeling and database support <ref> [15, 17, 13] </ref>. T D has many of the features of process algebras. These include concurrent access to shared resources, communication between sequential processes, and the ability to isolate (or hide) the inner workings of a group of processes from the outside world. <p> Additional comparison with related work can be found in the long version of this paper on the Web [14]. 2 Overview of Transaction Datalog Transaction Datalog is a fragment of Concurrent Transaction Logic (abbreviated CT R), which we developed in previous work <ref> [17, 13] </ref>. CT R is an extension of classical logic that seamlessly integrates concurrency and communication with queries and updates. It has a purely logical semantics, including a natural model theory and a sound-and-complete proof theory.
Reference: [14] <author> A.J. Bonner. </author> <title> Workflow, </title> <journal> transactions, and datalog. </journal> <note> Submitted to PODS'99. Long version available at http://www.cs.toronto.edu/ ~bonner/papers.html#transaction-logic. </note>
Reference-contexts: In this light, our syntactic restrictions are very effective at keeping complexity down. Additional comparison with related work can be found in the long version of this paper on the Web <ref> [14] </ref>. 2 Overview of Transaction Datalog Transaction Datalog is a fragment of Concurrent Transaction Logic (abbreviated CT R), which we developed in previous work [17, 13]. CT R is an extension of classical logic that seamlessly integrates concurrency and communication with queries and updates. <p> These have been published in detail elsewhere [15, 17, 16], and are reviewed in a long version of this paper, which is available on the Web <ref> [14] </ref>. This section illustrates the procedural interpretation through a series of examples. 4 Each example has been tested on our prototype implementation [49, 63], and performs exactly as described below. The examples focus on so-called production workflow, which forms the core of a business or enterprise [37, 54]. <p> del.a del.b and q ins.c ins.d, then P; fabg f g j= p P; f g fcdg j= q P; fabg fcdg j= p j q The formal semantics of these expressions is given in [15, 17], and is reviewed in the long version of this paper on the Web <ref> [14] </ref>. Our results are based on a number of standard definitions, adapted from [3, 24]. A database schema is a finite set of base predicate symbols (with associated arities). A database with schema S is a finite set of ground atoms constructed from the predicate symbols in S. <p> Due to space limitations, no proofs are given in this abstract. However, detailed proofs of some theorems can be found in the long version of this paper on the Web <ref> [14] </ref>. 4 DATA COMPLEXITY 8 4.1 Data-Oriented Features Recall that the version of T D considered in this paper has four kinds of elementary database operation: tuple testing, p (x); tuple insertion, ins.p (x); tuple deletion, del.p (x); and emptiness testing, p.empty. <p> Also, as usual in expressibility results of this kind, we assume that the constant symbols are uninterpreted. Formally, this means extending the notion of genericity from queries to transactions, as in [3, 1]. Details are given in the long version of this paper <ref> [14] </ref>. 4 DATA COMPLEXITY 10 The main difference is that such languages are typically complete for PSPACE, not EXPTIME. The extra power of sequential T D comes froms an ability to simulate alternating PSPACE machines [26]. As shown in the long version of this paper [14], the ability to alternate comes <p> long version of this paper <ref> [14] </ref>. 4 DATA COMPLEXITY 10 The main difference is that such languages are typically complete for PSPACE, not EXPTIME. The extra power of sequential T D comes froms an ability to simulate alternating PSPACE machines [26]. As shown in the long version of this paper [14], the ability to alternate comes from the combination of recursive subroutines and sequential compostion. Other transaction languages typically have one of these features, but not both. Theorem 4.5 Sequential T D is data complete for EXPTIME. It takes only a little concurrency to achieve RE-completeness. <p> Theorem 4.5 Sequential T D is data complete for EXPTIME. It takes only a little concurrency to achieve RE-completeness. For instance, recursion through concurrency is not needed. Nor is it necessary to spawn new processes at runtime. In fact, examining the proof of Theorem 4.3 in <ref> [14] </ref> shows that there need not be any concurrency in the rulebase at all! Concurrency is needed only in the goal. (Recall that a T D program consists of two parts: a rulebase, P, and a goal, OE.) More specifically, it is enough for the goal to have the form OE <p> This means that RE-completeness can be achieved by three sequential processes executing concurrently. In the proof, these three processes are used to simulate a 2-stack machine [46], where two of the processes encode the stacks, and the third process encodes the finite control <ref> [14] </ref>. We therefore have the following result. Corollary 4.6 T D programs with sequential rulebases are data complete for RE. Restrictions on recursive processes also have a dramatic effect on data complexity. <p> Due to space limitations, we can only give a brief and informal description of the restriction here. A formal development is available in the long version of this paper on the Web <ref> [14] </ref>. An example based on genome laboratory workflow is given in the appendix of this paper. Full boundedness is based on two ideas. First, each recursive call to a predicate must remove a tuple from a base relation.
Reference: [15] <author> A.J. Bonner. </author> <title> Transaction Datalog: a compositional language for transaction programming. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, number 1369 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1998. </year> <title> Workshop held in Estes Park, </title> <address> Col-orado, </address> <month> August </month> <year> 1997. </year>
Reference-contexts: 1 INTRODUCTION 2 Our vehicle for this investigation is Transaction Datalog (abbreviated T D), a concurrent programming language that provides both process modeling and database support <ref> [15, 17, 13] </ref>. T D has many of the features of process algebras. These include concurrent access to shared resources, communication between sequential processes, and the ability to isolate (or hide) the inner workings of a group of processes from the outside world. <p> However, unlike process algebras, T D also provides high-level support for database functions. These include declarative queries, bulk updates, views, and serializability [18, 16, 17]. T D also has many features of advanced transaction models, including subtransaction hierarchies, relaxed ACID requirements, and fine-grained control over abort and rollback <ref> [15] </ref>. This integration of process modeling and database functionality is reflected in the formal semantics of T D, which is based on both database states and events, while the semantics of process algebras is based entirely on events. <p> T D is based on the Horn fragment of CT R, just as classical Datalog is based on the Horn fragment of classical logic. This section reviews the syntax of T D and its procedural interpretation, summarizing material from <ref> [15] </ref>. We adopt much of the terminology of deductive databases. T D provides three operators for combining simple programs into more complex ones: sequential composition, denoted ; concurrent composition, denoted j; and a modality of isolation, denoted fi. <p> The formal semantics of these formulas is given in <ref> [17, 15] </ref>. Intuitively, the first two formulas are yes/no queries, and the last two formulas are updates. <p> For instance, the rule r (X) p (X) del.p (X) ins.q (X) defines a subroutine with name r and parameter X. Using b as the parameter value, r (b) commits if p (b) is in the database just before the updates occur. Advanced Transactions. As shown in <ref> [15] </ref>, T D accounts for many basic properties of "advanced" transaction models [35], including nested transactions. These properties include subtrans-action hierarchies, non-vital subtransactions, relative commit, and partial rollback. <p> Due to space limitations, we do not develop this approach here. 3 EXAMPLES 5 3 Examples Like classical logic programs, T D has both a declarative semantics and a procedural interpretation. These have been published in detail elsewhere <ref> [15, 17, 16] </ref>, and are reviewed in a long version of this paper, which is available on the Web [14]. This section illustrates the procedural interpretation through a series of examples. 4 Each example has been tested on our prototype implementation [49, 63], and performs exactly as described below. <p> fcdg j= (del.a del.b) j (ins.c ins.d) Likewise, if P contains the two rules p del.a del.b and q ins.c ins.d, then P; fabg f g j= p P; f g fcdg j= q P; fabg fcdg j= p j q The formal semantics of these expressions is given in <ref> [15, 17] </ref>, and is reviewed in the long version of this paper on the Web [14]. Our results are based on a number of standard definitions, adapted from [3, 24]. A database schema is a finite set of base predicate symbols (with associated arities).
Reference: [16] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming. </title> <booktitle> In Int'l Conference on Logic Programming, </booktitle> <pages> pages 257-282, </pages> <address> Budapest, Hungary, June 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: It is therefore possible to specify so-called multi-level processes [31], even when the number of levels is determined at runtime. However, unlike process algebras, T D also provides high-level support for database functions. These include declarative queries, bulk updates, views, and serializability <ref> [18, 16, 17] </ref>. T D also has many features of advanced transaction models, including subtransaction hierarchies, relaxed ACID requirements, and fine-grained control over abort and rollback [15]. <p> Due to space limitations, we do not develop this approach here. 3 EXAMPLES 5 3 Examples Like classical logic programs, T D has both a declarative semantics and a procedural interpretation. These have been published in detail elsewhere <ref> [15, 17, 16] </ref>, and are reviewed in a long version of this paper, which is available on the Web [14]. This section illustrates the procedural interpretation through a series of examples. 4 Each example has been tested on our prototype implementation [49, 63], and performs exactly as described below.
Reference: [17] <author> A.J. Bonner and M. Kifer. </author> <title> Concurrency and communication in transaction logic. </title> <booktitle> In Joint Int'l Conference and Symposium on Logic Programming, </booktitle> <pages> pages 142-156, </pages> <address> Bonn, Germany, September 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: 1 INTRODUCTION 2 Our vehicle for this investigation is Transaction Datalog (abbreviated T D), a concurrent programming language that provides both process modeling and database support <ref> [15, 17, 13] </ref>. T D has many of the features of process algebras. These include concurrent access to shared resources, communication between sequential processes, and the ability to isolate (or hide) the inner workings of a group of processes from the outside world. <p> It is therefore possible to specify so-called multi-level processes [31], even when the number of levels is determined at runtime. However, unlike process algebras, T D also provides high-level support for database functions. These include declarative queries, bulk updates, views, and serializability <ref> [18, 16, 17] </ref>. T D also has many features of advanced transaction models, including subtransaction hierarchies, relaxed ACID requirements, and fine-grained control over abort and rollback [15]. <p> Additional comparison with related work can be found in the long version of this paper on the Web [14]. 2 Overview of Transaction Datalog Transaction Datalog is a fragment of Concurrent Transaction Logic (abbreviated CT R), which we developed in previous work <ref> [17, 13] </ref>. CT R is an extension of classical logic that seamlessly integrates concurrency and communication with queries and updates. It has a purely logical semantics, including a natural model theory and a sound-and-complete proof theory. <p> In general, an elementary operation can be any activity that accesses a database, including activities that require human intervention (as in many workflows). Examples include simple database updates, complex application programs, and legacy systems. Semantically, an elementary operation is treated as a black box. This idea is formalized in <ref> [17] </ref>. In general, the complexity of a T D program depends on its elementary operations. However, we would like to factor out these operations in order to focus on the complexity of T D itself. For this reason, we base our complexity analysis on a small set of simple operations. <p> The formal semantics of these formulas is given in <ref> [17, 15] </ref>. Intuitively, the first two formulas are yes/no queries, and the last two formulas are updates. <p> Due to space limitations, we do not develop this approach here. 3 EXAMPLES 5 3 Examples Like classical logic programs, T D has both a declarative semantics and a procedural interpretation. These have been published in detail elsewhere <ref> [15, 17, 16] </ref>, and are reviewed in a long version of this paper, which is available on the Web [14]. This section illustrates the procedural interpretation through a series of examples. 4 Each example has been tested on our prototype implementation [49, 63], and performs exactly as described below. <p> We assume that a record identifying each work item is initially stored in a database relation called item, which acts as an 4 A version of Example 3.4 originally appeared in <ref> [17] </ref>. With this one exception, none of the examples in this paper have been published before. 5 If both tests are true, then the sub-workflow chooses one series of tasks non-deterministically. <p> fcdg j= (del.a del.b) j (ins.c ins.d) Likewise, if P contains the two rules p del.a del.b and q ins.c ins.d, then P; fabg f g j= p P; f g fcdg j= q P; fabg fcdg j= p j q The formal semantics of these expressions is given in <ref> [15, 17] </ref>, and is reviewed in the long version of this paper on the Web [14]. Our results are based on a number of standard definitions, adapted from [3, 24]. A database schema is a finite set of base predicate symbols (with associated arities).
Reference: [18] <author> A.J. Bonner, M. Kifer, and M. Consens. </author> <title> Database programming in transaction logic. </title> <editor> In A. Ohori C. Beeri and D.E. Shasha, editors, </editor> <booktitle> Proceedings of the International Workshop on Database Programming Languages, Workshops in Computing, </booktitle> <pages> pages 309-337. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1994. </year> <booktitle> Workshop held on Aug 30-Sept 1, 1993, </booktitle> <address> New York City, NY. </address>
Reference-contexts: It is therefore possible to specify so-called multi-level processes [31], even when the number of levels is determined at runtime. However, unlike process algebras, T D also provides high-level support for database functions. These include declarative queries, bulk updates, views, and serializability <ref> [18, 16, 17] </ref>. T D also has many features of advanced transaction models, including subtransaction hierarchies, relaxed ACID requirements, and fine-grained control over abort and rollback [15].
Reference: [19] <author> A.J. Bonner, L.T. McCarty, and K. Vadaparty. </author> <title> Expressing Database Queries with Intuitionistic Logic. </title> <booktitle> In North American Conference on Logic Programming, </booktitle> <pages> pages 831-850, </pages> <address> Cleveland, Ohio, October 16-20 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: In particular, it is a safe language that does not generate an unbounded number of tuples during transaction 4 DATA COMPLEXITY 9 execution. In contrast, other transaction languages achieve RE-completeness by expanding the data domain during transaction execution <ref> [2, 3, 19] </ref>, or by expanding the database schema [24]. Typically, the proof of RE-completeness involves encoding the tape of a Turing machine in the database. In such approaches, the database grows to arbitrary size during transaction execution, since it encodes a machine tape that grows to arbitrary length.
Reference: [20] <author> A.J. Bonner, A. Shrufi, and S. Rozen. </author> <title> Bench-marking object-oriented DBMSs for workflow management. In OOPSLA Workshop on Object Database Behavior, Benchmarks, and Performance, </title> <address> Austin, TX, </address> <month> October 15 </month> <year> 1995. </year>
Reference-contexts: The workflows at the Genome Center are data intensive. In fact, as laboratory automation increased, database performance became a bottleneck in workflow throughput, and we had to develop a workflow/database benchmark to evaluate new storage managers for their laboratory information system <ref> [22, 20, 21] </ref>. To make the examples in this paper more concrete, we shall sometimes describe them in terms of genome laboratory workflow. Example 3.1 (Workflow Specification) The rules below define a simple workflow made up of a collection of tasks and a sub-workflow.
Reference: [21] <author> A.J. Bonner, A. Shrufi, and S. Rozen. </author> <title> Database requirements for workflow management in a high-throughput genome laboratory. </title> <booktitle> In NSF Workshop on Workflow and Process Automation in Information Systems: State-of-the-Art and Future Directions, </booktitle> <pages> pages 119-125, </pages> <address> Athens, GA, </address> <month> May 8-10 </month> <year> 1996. </year>
Reference-contexts: Examples of work items include insurance claims, loan applications, and laboratory samples. Because they process large numbers of work items, production workflows are often data intensive. A concrete example is the laboratory workflows used at the Whitehead Institute/MIT Center for Genome Research <ref> [21, 22, 64] </ref>, which is engaged in several large-scale genome mapping and sequencing projects [29]. Each project involves the completion of tens of millions of experiments, organized into a network of factory-like production lines. <p> Coordinating the flow of materials through the production lines, and recording and querying the history of experimental steps and the results they produce are the main data and workflow management requirements <ref> [21] </ref>. The workflows at the Genome Center are data intensive. In fact, as laboratory automation increased, database performance became a bottleneck in workflow throughput, and we had to develop a workflow/database benchmark to evaluate new storage managers for their laboratory information system [22, 20, 21]. <p> The workflows at the Genome Center are data intensive. In fact, as laboratory automation increased, database performance became a bottleneck in workflow throughput, and we had to develop a workflow/database benchmark to evaluate new storage managers for their laboratory information system <ref> [22, 20, 21] </ref>. To make the examples in this paper more concrete, we shall sometimes describe them in terms of genome laboratory workflow. Example 3.1 (Workflow Specification) The rules below define a simple workflow made up of a collection of tasks and a sub-workflow. <p> This is a natural set of operations for many scientific workflows, where workflow activities are laboratory experiments that gather, store and analyze information [6]. This is certainly the case for workflows at the Whitehead Institute/MIT Center for Genome Research <ref> [21, 64] </ref>, where experimental results are accumulated in the database, and queried by analysis programs, but never deleted or altered.
Reference: [22] <author> A.J. Bonner, A. Shrufi, and S. Rozen. LabFlow-1: </author> <title> a database benchmark for high-throughput workflow management. </title> <booktitle> In Int'l Conference REFERENCES IV on Extending Database Technology, number 1057 in LNCS, </booktitle> <pages> pages 463-478, </pages> <address> Avignon, France, </address> <month> March 25-29 </month> <year> 1996. </year> <note> Springer-Verlag. Full technical report available at http:// www-genome.wi.mit.edu/informatics/ informatics papers/bibliography.html. </note>
Reference-contexts: Examples of work items include insurance claims, loan applications, and laboratory samples. Because they process large numbers of work items, production workflows are often data intensive. A concrete example is the laboratory workflows used at the Whitehead Institute/MIT Center for Genome Research <ref> [21, 22, 64] </ref>, which is engaged in several large-scale genome mapping and sequencing projects [29]. Each project involves the completion of tens of millions of experiments, organized into a network of factory-like production lines. <p> The workflows at the Genome Center are data intensive. In fact, as laboratory automation increased, database performance became a bottleneck in workflow throughput, and we had to develop a workflow/database benchmark to evaluate new storage managers for their laboratory information system <ref> [22, 20, 21] </ref>. To make the examples in this paper more concrete, we shall sometimes describe them in terms of genome laboratory workflow. Example 3.1 (Workflow Specification) The rules below define a simple workflow made up of a collection of tasks and a sub-workflow. <p> The next example shows one way of doing this. The example also suggests how to keep track of work that has been performed. This allows for monitoring, tracking and querying the status of workflow activities, another important aspect of workflow management <ref> [32, 37, 22] </ref>. Example 3.3 (Shared Resources) The rules below refine the predicate task i (W ) used in Example 3.1 to account for the resources needed to execute the task. In this case, the resources are qualified agents. <p> Since the parts are related, the workflows may have dependencies between them. Typically, one workflow needs information produced by another workflow, and may have to wait for this information to become available before it can continue. This is the case, for instance, in the workflow described in <ref> [22] </ref>, in which the work items are DNA samples, and the purpose of the workflow is to construct a physical genome map. 6 6 This particular workflow consists of two concurrent sub-workflows that synchronize themselves at several points. <p> Tail recursion allows these workflows to be iterated. That is, they can be executed over-and-over again until some condition is satisfied. For instance, in a scientific laboratory, an experimental protocol may be repeated until a conclusive result is achieved. This is the case for the genome workflow described in <ref> [22] </ref>. Note that sequential tail recursion allows processes to be created and destroyed at runtime, but only inside . In particular, the number of processes does not grow with each recursive call, as in the simulation of Example 3.2.
Reference: [23] <author> O. Bukhres and E. Kueshn, Eds. </author> <title> Special issue on software support for workflow management. </title> <journal> Distributed and Parallel Databases|An International Journal, </journal> <volume> 3(2), </volume> <month> April </month> <year> 1995. </year>
Reference: [24] <author> A.K. Chandra and D. Harel. </author> <title> Computable queries for relational databases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: Our results are based on a number of standard definitions, adapted from <ref> [3, 24] </ref>. A database schema is a finite set of base predicate symbols (with associated arities). A database with schema S is a finite set of ground atoms constructed from the predicate symbols in S. <p> In particular, it is a safe language that does not generate an unbounded number of tuples during transaction 4 DATA COMPLEXITY 9 execution. In contrast, other transaction languages achieve RE-completeness by expanding the data domain during transaction execution [2, 3, 19], or by expanding the database schema <ref> [24] </ref>. Typically, the proof of RE-completeness involves encoding the tape of a Turing machine in the database. In such approaches, the database grows to arbitrary size during transaction execution, since it encodes a machine tape that grows to arbitrary length.
Reference: [25] <author> A.K. Chandra and D. Harel. </author> <title> Structure and complexity of relational queries. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(1) </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: Specifically, T D does not expand the data domain or the database schema during program execution. Transaction languages with this property are said to be safe, and typically their data complexity is complete for PSPACE <ref> [2, 3, 1, 25] </ref>. In contrast, the data complexity T D is complete for RE. This dramatic increase in complexity, from PSPACE to RE, is due entirely to interactions between processes. Section 4 studies the sources of this complexity in more detail by developing a family of syntactic restrictions. <p> In contrast, T D achieves RE-completeness with a fixed data domain, and a fixed database schema, and thus with databases of polynomial size. This demonstrates a fundamental difference between T D and other safe transaction languages, which are typically PSPACE-complete <ref> [2, 3, 1, 25] </ref>. Our proof of Theorem 4.3 bears some resemblance to the simulation of Turing machines in process algebras such as CCS [65]. <p> Concurrency is essential to the power of T D. As Theorem 4.5 shows, when concurrent composition is removed, the data complexity of T D plummets from RE to EXPTIME. This version of the language, which we call sequential T D, is comparable to safe transaction languages <ref> [2, 3, 1, 25] </ref>. 7 This is a common phenomenon in logical languages.
Reference: [26] <author> A.K. Chandra, D. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of ACM, </journal> <volume> 28 </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference-contexts: Details are given in the long version of this paper [14]. 4 DATA COMPLEXITY 10 The main difference is that such languages are typically complete for PSPACE, not EXPTIME. The extra power of sequential T D comes froms an ability to simulate alternating PSPACE machines <ref> [26] </ref>. As shown in the long version of this paper [14], the ability to alternate comes from the combination of recursive subroutines and sequential compostion. Other transaction languages typically have one of these features, but not both. Theorem 4.5 Sequential T D is data complete for EXPTIME.
Reference: [27] <author> S. Christensen, Y. Hirshfeld, and F. Moller. </author> <title> Decidable subsets of CCS. </title> <journal> The Computer Journal, </journal> <volume> 37(4) </volume> <pages> 233-242, </pages> <year> 1994. </year> <note> Special issue on process algebra. </note>
Reference-contexts: Our proof of Theorem 4.3 bears some resemblance to the simulation of Turing machines in process algebras such as CCS [65]. However, in CCS, the simulation relies heavily on the restriction operator <ref> [65, 27] </ref>, which allows a CCS program to create an unbounded number of new (private) communication channels during execution. Since T D is built around databases, not communication channels, restriction is not a primitive operation in T D.
Reference: [28] <author> Edmund M. Clarke, E. Allen Emerson, and A. Prasad Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> In ACM Transactions on Programming Languages and Systems (TOPLAS), </journal> <pages> pages 244-263, </pages> <year> 1986. </year>
Reference: [29] <institution> Communications of ACM, </institution> <month> 34(11), November </month> <year> 1991. </year> <title> Special issue on the Human Genome Project. </title>
Reference-contexts: Because they process large numbers of work items, production workflows are often data intensive. A concrete example is the laboratory workflows used at the Whitehead Institute/MIT Center for Genome Research [21, 22, 64], which is engaged in several large-scale genome mapping and sequencing projects <ref> [29] </ref>. Each project involves the completion of tens of millions of experiments, organized into a network of factory-like production lines.
Reference: [30] <author> H. Davulcu, M. Kifer, C.R. Ramakrishnan, and I.V. Ramakrishnan. </author> <title> Logic based modeling and analysis of workflows. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 25-33, </pages> <address> Seattle, Washington, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: To deal with this problem, some database researchers have chosen to restrict the process model instead of the data model <ref> [4, 30, 66] </ref>. Unfortunately, the result, once again, is that many realistic workflows are not considered. In this paper, we take a different approach and address a different set of questions.
Reference: [31] <author> U. Dayal and Q. Chen. </author> <title> From database programming to business process programming. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <address> Gubbio, Umbria, Italy, </address> <month> September </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: Like all process algebras, T D is compositional, so processes can be defined recursively in terms of subprocesses. It is therefore possible to specify so-called multi-level processes <ref> [31] </ref>, even when the number of levels is determined at runtime. However, unlike process algebras, T D also provides high-level support for database functions. These include declarative queries, bulk updates, views, and serializability [18, 16, 17].
Reference: [32] <author> U. Dayal, H. Garcia-Molina, M. Hsu, B. Kao, and M.-C. Shan. </author> <title> Third generation TP monitors: A database challenge. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 393-397, </pages> <address> Washington, DD, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The next example shows one way of doing this. The example also suggests how to keep track of work that has been performed. This allows for monitoring, tracking and querying the status of workflow activities, another important aspect of workflow management <ref> [32, 37, 22] </ref>. Example 3.3 (Shared Resources) The rules below refine the predicate task i (W ) used in Example 3.1 to account for the resources needed to execute the task. In this case, the resources are qualified agents.
Reference: [33] <author> J. Desel. </author> <title> Free Choice Petri Nets. </title> <publisher> Cambridge University Press, </publisher> <year> 1995. </year>
Reference: [34] <author> D. Drusinsky and D. Harel. </author> <title> On the power of bounded concurrency i: Finite automata. </title> <journal> Journal of ACM, </journal> <volume> 41(3) </volume> <pages> 517-539, </pages> <year> 1994. </year>
Reference-contexts: Isolation also plays an important role in defining sub-transaction hierarchies, as described below. 2 In cooperative concurrency, processes can communicate, synchronize, or otherwise cooperate [40]. It is the dominant form of concurrency in distributed systems and process modeling <ref> [34, 44, 55] </ref>, and is form of concurrency considered in this paper. In contrast, the massive parallelism that is possible in evaluating some database queries is non-cooperative. 2 OVERVIEW OF TRANSACTION DATALOG 4 Using the four operators above, a T D programmer combines elementary operations into complex processes.
Reference: [35] <editor> A.K. Elmagarmid, editor. </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan-Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference-contexts: Using b as the parameter value, r (b) commits if p (b) is in the database just before the updates occur. Advanced Transactions. As shown in [15], T D accounts for many basic properties of "advanced" transaction models <ref> [35] </ref>, including nested transactions. These properties include subtrans-action hierarchies, non-vital subtransactions, relative commit, and partial rollback.
Reference: [36] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <booktitle> In Handbook of Theoretical Computer Science, </booktitle> <pages> pages 997-1072. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference: [37] <author> D. Georgakopoulos, M. Hornick, and A. Sheth. </author> <title> An overview of workflow management: From process modeling to infrastructure for automation. </title> <journal> Journal on Distributed and Parallel Database Systems, </journal> <volume> 3(2) </volume> <pages> 119-153, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: This section illustrates the procedural interpretation through a series of examples. 4 Each example has been tested on our prototype implementation [49, 63], and performs exactly as described below. The examples focus on so-called production workflow, which forms the core of a business or enterprise <ref> [37, 54] </ref>. Production workflows are typically complex, well defined, high volume, and mission critical. Many production workflows are organized around work items of some kind, which the workflow activities operate on. Examples of work items include insurance claims, loan applications, and laboratory samples. <p> Typically, each task in a workflow is performed by an "agent," (e:g:, a machine or a person), only a fixed number of agents is available, and only qualified agents can be assigned to each task <ref> [37] </ref>. In effect, the agents are resources that must be shared by the various workflow instances, thus limiting the number of instances that can be active at one time. For this reason, an important part of workflow specification is assigning agents to tasks [37]. <p> agents can be assigned to each task <ref> [37] </ref>. In effect, the agents are resources that must be shared by the various workflow instances, thus limiting the number of instances that can be active at one time. For this reason, an important part of workflow specification is assigning agents to tasks [37]. This is easily accomplished in a language like T D that integrates databases and processes, since we can record the status of agents in the database, and update them as the workflow progresses. The next example shows one way of doing this. <p> The next example shows one way of doing this. The example also suggests how to keep track of work that has been performed. This allows for monitoring, tracking and querying the status of workflow activities, another important aspect of workflow management <ref> [32, 37, 22] </ref>. Example 3.3 (Shared Resources) The rules below refine the predicate task i (W ) used in Example 3.1 to account for the resources needed to execute the task. In this case, the resources are qualified agents.
Reference: [38] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: Isolation is a fundamental property of database transactions <ref> [12, 38] </ref>, and is closely related to serializabil-ity. For instance, if t 1 , t 2 , ..., t n are database programs, then the goal fit 1 j fit 2 j j fit n executes them serializably.
Reference: [39] <author> D. Harel. "StateCharts: </author> <title> A Visual Formalism for Complex Systems". </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference: [40] <author> D. Harel. </author> <title> A thesis for bounded concurrency. </title> <booktitle> In Proceedings of the 14th Symposium on Mathematical Foundations of Computer Science, number 379 in Lecture Notes in Computer Science, </booktitle> <pages> pages 35-48. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: For instance, like T D, most process algebras can simulate arbitrary Turing machines [65]. Moreover, Harel has shown that cooperative concurrency increases the complexity of many problems by an exponential, even when the number of processes is carefully bounded <ref> [41, 42, 40] </ref>. Thus, since safe transaction languages are typically PSPACE-complete, one might expect that adding a bounded number of concurrent processes would increase their complexity to EXPSPACE. In this light, our syntactic restrictions are very effective at keeping complexity down. <p> Isolation also plays an important role in defining sub-transaction hierarchies, as described below. 2 In cooperative concurrency, processes can communicate, synchronize, or otherwise cooperate <ref> [40] </ref>. It is the dominant form of concurrency in distributed systems and process modeling [34, 44, 55], and is form of concurrency considered in this paper.
Reference: [41] <author> D. Harel, O. Kupferman, and M.Y. Vardi. </author> <title> On the complexity of verifying concurrent transition systems. </title> <type> Technical Report CS97-01, </type> <institution> Faculty of Mathematical Sciences, The Weizmann Institute of Science, Rehovot, Israel, </institution> <year> 1997. </year>
Reference-contexts: For instance, like T D, most process algebras can simulate arbitrary Turing machines [65]. Moreover, Harel has shown that cooperative concurrency increases the complexity of many problems by an exponential, even when the number of processes is carefully bounded <ref> [41, 42, 40] </ref>. Thus, since safe transaction languages are typically PSPACE-complete, one might expect that adding a bounded number of concurrent processes would increase their complexity to EXPSPACE. In this light, our syntactic restrictions are very effective at keeping complexity down.
Reference: [42] <author> D. Harel, R. Rosner, and M. Vardi. </author> <title> On the power of bounded concurrency iii: Reasoning about programs. </title> <booktitle> In Int'l Symposium on Logic in Computer Science, </booktitle> <pages> pages 478-488. </pages> <publisher> IEEE Press, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: For instance, like T D, most process algebras can simulate arbitrary Turing machines [65]. Moreover, Harel has shown that cooperative concurrency increases the complexity of many problems by an exponential, even when the number of processes is carefully bounded <ref> [41, 42, 40] </ref>. Thus, since safe transaction languages are typically PSPACE-complete, one might expect that adding a bounded number of concurrent processes would increase their complexity to EXPSPACE. In this light, our syntactic restrictions are very effective at keeping complexity down.
Reference: [43] <author> M. Hennessy. </author> <title> An Algebraic Theory of Processes. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1988. </year>
Reference: [44] <author> T. Hirst and D. Harel. </author> <title> On the power of bounded concurrency ii: Pushdown automata. </title> <journal> Journal of ACM, </journal> <volume> 41(3) </volume> <pages> 540-554, </pages> <year> 1994. </year>
Reference-contexts: Isolation also plays an important role in defining sub-transaction hierarchies, as described below. 2 In cooperative concurrency, processes can communicate, synchronize, or otherwise cooperate [40]. It is the dominant form of concurrency in distributed systems and process modeling <ref> [34, 44, 55] </ref>, and is form of concurrency considered in this paper. In contrast, the massive parallelism that is possible in evaluating some database queries is non-cooperative. 2 OVERVIEW OF TRANSACTION DATALOG 4 Using the four operators above, a T D programmer combines elementary operations into complex processes.
Reference: [45] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1985. </year>
Reference: [46] <author> J.E. Hopcroft and J.D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1979. </year>
Reference-contexts: This means that RE-completeness can be achieved by three sequential processes executing concurrently. In the proof, these three processes are used to simulate a 2-stack machine <ref> [46] </ref>, where two of the processes encode the stacks, and the third process encodes the finite control [14]. We therefore have the following result. Corollary 4.6 T D programs with sequential rulebases are data complete for RE. Restrictions on recursive processes also have a dramatic effect on data complexity.
Reference: [47] <institution> Special issue on workflow and extended transac-tion systems. Bulletin of the Technical Committee on Data Engineering (IEEE Computer Society), </institution> <month> 16(2), June </month> <year> 1993. </year>
Reference: [48] <institution> Special issue on workflow systems. Bulletin of the Technical Committee on Data Engineering (IEEE Computer Society), </institution> <month> 18(1), March </month> <year> 1995. </year>
Reference: [49] <author> Samuel Y.K. Hung. </author> <title> Implementation and Performance of Transaction Logic in Prolog. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1996. </year>
Reference-contexts: These have been published in detail elsewhere [15, 17, 16], and are reviewed in a long version of this paper, which is available on the Web [14]. This section illustrates the procedural interpretation through a series of examples. 4 Each example has been tested on our prototype implementation <ref> [49, 63] </ref>, and performs exactly as described below. The examples focus on so-called production workflow, which forms the core of a business or enterprise [37, 54]. Production workflows are typically complex, well defined, high volume, and mission critical.
Reference: [50] <editor> S. Jajodia and L. Kerschberg, editors. </editor> <title> Advanced Transaction Models and Architectures. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1997. </year>
Reference: [51] <author> K. Jensen. </author> <title> Colored Petri Nets. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1996. </year>
Reference: [52] <author> K. Jensen and G. Rozenberg, </author> <title> editors. High Level Petri Nets. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference: [53] <author> N.D. Jones, L.H. Landweber, and Y.E. Lien. </author> <title> Complexity of some problems in Petri nets. </title> <journal> Theoretical Computer Science, </journal> <volume> 4 </volume> <pages> 277-299, </pages> <year> 1977. </year>
Reference: [54] <author> Setrag Khoshafian and Marek Buckiewicz. </author> <title> Introduction to Groupware, Workflow, and Workgroup Computing. </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1995. </year>
Reference-contexts: This section illustrates the procedural interpretation through a series of examples. 4 Each example has been tested on our prototype implementation [49, 63], and performs exactly as described below. The examples focus on so-called production workflow, which forms the core of a business or enterprise <ref> [37, 54] </ref>. Production workflows are typically complex, well defined, high volume, and mission critical. Many production workflows are organized around work items of some kind, which the workflow activities operate on. Examples of work items include insurance claims, loan applications, and laboratory samples.
Reference: [55] <author> R.P. Kurshan. </author> <title> Computer Aided Verification of Coordinating Processes. </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference-contexts: Isolation also plays an important role in defining sub-transaction hierarchies, as described below. 2 In cooperative concurrency, processes can communicate, synchronize, or otherwise cooperate [40]. It is the dominant form of concurrency in distributed systems and process modeling <ref> [34, 44, 55] </ref>, and is form of concurrency considered in this paper. In contrast, the massive parallelism that is possible in evaluating some database queries is non-cooperative. 2 OVERVIEW OF TRANSACTION DATALOG 4 Using the four operators above, a T D programmer combines elementary operations into complex processes.
Reference: [56] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference: [57] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes, I. </title> <journal> Information and Computation, </journal> <volume> 100(1) </volume> <pages> 1-40, </pages> <month> September </month> <year> 1992. </year>
Reference: [58] <author> W.F. Ogden, W.E. Riddle, and W.C. </author> <title> Rounds. Complexity of expressions allowing concurrency. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 185-194, </pages> <year> 1978. </year>
Reference: [59] <author> C.H. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Likewise, the rule r (X; Z) p (X; Y ) j q (Y; Z) expresses the projection of this join onto two attributes. Any classical Datalog query can be expressed in this fashion. 3 Another approach would be to prove relativized complexity results <ref> [59, 9] </ref> with elementary operations modeled by a variation of oracle Turing machines. All of the results in this paper can be relativized in this way, although additional formal machinery is required.
Reference: [60] <author> W. Reisig. </author> <title> Petri Nets: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference: [61] <author> M. Rusinkiewicz and A. Sheth. </author> <title> Specification and execution of transactional workflows. </title> <editor> In W. Kim, editor, </editor> <title> Modern Database Systems: The Object Model, Interoperability, and Beyond. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference: [62] <author> E. Shapiro. </author> <title> A family of concurrent logic programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3), </volume> <year> 1989. </year>
Reference: [63] <author> Amalia Sleghel. </author> <title> Implementation of Concurrent Transaction Logic. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Toronto. </institution> <note> In preparation. </note>
Reference-contexts: These have been published in detail elsewhere [15, 17, 16], and are reviewed in a long version of this paper, which is available on the Web [14]. This section illustrates the procedural interpretation through a series of examples. 4 Each example has been tested on our prototype implementation <ref> [49, 63] </ref>, and performs exactly as described below. The examples focus on so-called production workflow, which forms the core of a business or enterprise [37, 54]. Production workflows are typically complex, well defined, high volume, and mission critical.
Reference: [64] <author> L. Stein, S. Rozen, and N. Goodman. </author> <title> Managing laboratory workflow with LabBase. </title> <booktitle> In Proceedings of the 1994 Conference on Computers in Medicine (CompMed94). </booktitle> <publisher> World Scientific Publishing Company, </publisher> <year> 1995. </year>
Reference-contexts: Examples of work items include insurance claims, loan applications, and laboratory samples. Because they process large numbers of work items, production workflows are often data intensive. A concrete example is the laboratory workflows used at the Whitehead Institute/MIT Center for Genome Research <ref> [21, 22, 64] </ref>, which is engaged in several large-scale genome mapping and sequencing projects [29]. Each project involves the completion of tens of millions of experiments, organized into a network of factory-like production lines. <p> This is a natural set of operations for many scientific workflows, where workflow activities are laboratory experiments that gather, store and analyze information [6]. This is certainly the case for workflows at the Whitehead Institute/MIT Center for Genome Research <ref> [21, 64] </ref>, where experimental results are accumulated in the database, and queried by analysis programs, but never deleted or altered.
Reference: [65] <author> D. Taubner. </author> <title> Finite Representations of CCS and TCSP Programs by Automata and Petri Nets. </title> <booktitle> Number 369 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: In general, our complexity results are in line with and improve upon related work in the literature. For instance, like T D, most process algebras can simulate arbitrary Turing machines <ref> [65] </ref>. Moreover, Harel has shown that cooperative concurrency increases the complexity of many problems by an exponential, even when the number of processes is carefully bounded [41, 42, 40]. <p> This demonstrates a fundamental difference between T D and other safe transaction languages, which are typically PSPACE-complete [2, 3, 1, 25]. Our proof of Theorem 4.3 bears some resemblance to the simulation of Turing machines in process algebras such as CCS <ref> [65] </ref>. However, in CCS, the simulation relies heavily on the restriction operator [65, 27], which allows a CCS program to create an unbounded number of new (private) communication channels during execution. Since T D is built around databases, not communication channels, restriction is not a primitive operation in T D. <p> Our proof of Theorem 4.3 bears some resemblance to the simulation of Turing machines in process algebras such as CCS [65]. However, in CCS, the simulation relies heavily on the restriction operator <ref> [65, 27] </ref>, which allows a CCS program to create an unbounded number of new (private) communication channels during execution. Since T D is built around databases, not communication channels, restriction is not a primitive operation in T D.
Reference: [66] <author> Dirk Wodtke and Gerhard Weikum. </author> <title> A formal foundation for distributed workflow execution based on state charts. </title> <booktitle> In Int'l Conference on Database Theory, </booktitle> <pages> pages 230-246, </pages> <year> 1997. </year>
Reference-contexts: To deal with this problem, some database researchers have chosen to restrict the process model instead of the data model <ref> [4, 30, 66] </ref>. Unfortunately, the result, once again, is that many realistic workflows are not considered. In this paper, we take a different approach and address a different set of questions.
Reference: [67] <author> D. Worah and A. Sheth. </author> <title> Transactions in transactional workflows. </title> <booktitle> In [50], chapter 1, </booktitle> <pages> pages 3-45. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1997. </year>
References-found: 67

