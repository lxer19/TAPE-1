URL: http://www.cs.virginia.edu/~son/publications/jsa.ps
Refering-URL: http://www.cs.virginia.edu/~son/publications.html
Root-URL: http://www.cs.virginia.edu
Email: (Young.Kim@delab.sintef.no) (son@virginia.edu)  
Title: Software Architecture for a Firm Real-Time Database System  
Author: Young-Kuk Kim Matthew R. Lehr Sang H. Son 
Address: N-7034 Trondheim, Norway  Charlottesville, VA 22903  
Affiliation: SINTEF DELAB Department of Computer Science  University of Virginia  
Abstract: An actual development of a real-time database management system (RT-DBMS) must confront many new and practical problems which have been often ignored in previous work based on simulation. In addition to transaction scheduling, an RT-DBMS must deal with resource and data contention and enforce timing constraints. This paper discusses how current real-time technology has been applied to architect an RT-DBMS on a real-time microkernel operating system and how the problems have been addressed. We present the current software architecture of our StarBase RT-DBMS and address how it can be extended to support both guaranteed and non-guaranteed transaction processing.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Abbott and H. Garcia-Molina. </author> <title> Scheduling Real-Time Transactions: A Performance Evaluation. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(3) </volume> <pages> 513-560, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: StarBase uses no a priori information about transaction workload and discards tardy transactions at their deadline points. In order to realize many of these goals, StarBase is constructed on top of RT-Mach, a real-time operating system developed at Carnegie Mellon University [17]. StarBase differs from previous RT-DBMS work <ref> [1, 5] </ref> in that a) it relies on a real-time operating system which provides priority-based scheduling and time-based synchronization, and b) it deals explicitly with data contention and deadline handling in addition to transaction scheduling, the traditional focus of simulation studies.
Reference: [2] <author> N. C. Audsley, A. Burns, M. F. Richardson, and A. J. Wellings. </author> <title> Hard Real-Time Scheduling: The Deadline Monotonic Approach. </title> <booktitle> In Proceedings of the 8th IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <address> Atlanta, GA, </address> <month> May </month> <year> 1991. </year> <month> 24 </month>
Reference-contexts: For example, it is feasible to provide total guarantee on a set of periodic hard real-time transactions with the complete knowledge on their data and computation time requirements under a fixed-priority preemptive scheduling framework <ref> [11, 2] </ref>. Non-guaranteed Transactions. The transactions in this group are supposed to have unknown arrival patterns, random data access behaviors, and unknown resource requirements so that the system cannot guarantee on their timing constraints but must provide a best-effort scheduling for the transactions, depending on the application sementics.
Reference: [3] <author> R. I. Davis. </author> <title> Approximate Slack Stealing Algorithms for Fixed Priority Preemptive Systems. </title> <type> Technical Report YCS217, </type> <institution> Department of Computer Science, University of York, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Our approach to scheduling non-guaranteed transactions without affecting guaranteed transactions is based on slack stealing approach <ref> [10, 4, 3] </ref>. To implement such an algorithm, one special real-time thread is required: a slack stealer. It maintains a slack table for every priority level either statically or dynamically, depending on the 22 slack stealing algorithm used. <p> To implement such an algorithm, one special real-time thread is required: a slack stealer. It maintains a slack table for every priority level either statically or dynamically, depending on the 22 slack stealing algorithm used. For example, if the HASS algorithm <ref> [3] </ref> is employed, a periodic real-time thread is invoked with a specified interval, generates a slack stealing transaction, and places it at the front of the aperiodic transaction queue (i.e., it has the highest priority among the non-guaranteed transactions).
Reference: [4] <author> R. I. Davis, K. W. Tindell, and A. Burns. </author> <title> Scheduling Slack Time in Fixed Priority Pre-emptive Systems. </title> <booktitle> In Proceedings of the 14th Real-Time Systems Symposium, </booktitle> <pages> pages 222-231, </pages> <address> Raleigh-Durham, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Our approach to scheduling non-guaranteed transactions without affecting guaranteed transactions is based on slack stealing approach <ref> [10, 4, 3] </ref>. To implement such an algorithm, one special real-time thread is required: a slack stealer. It maintains a slack table for every priority level either statically or dynamically, depending on the 22 slack stealing algorithm used.
Reference: [5] <author> J. R. Haritsa. </author> <title> Transaction Scheduling in Firm Real-Time Database Systems. </title> <type> PhD thesis, </type> <institution> University of Wisconsin-Madison, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: StarBase uses no a priori information about transaction workload and discards tardy transactions at their deadline points. In order to realize many of these goals, StarBase is constructed on top of RT-Mach, a real-time operating system developed at Carnegie Mellon University [17]. StarBase differs from previous RT-DBMS work <ref> [1, 5] </ref> in that a) it relies on a real-time operating system which provides priority-based scheduling and time-based synchronization, and b) it deals explicitly with data contention and deadline handling in addition to transaction scheduling, the traditional focus of simulation studies. <p> To resolve data conflicts, StarBase uses a concurrency control implementation which draws heavily from the work of two research groups. First, Haritsa reasoned that optimistic concurrency control can outperform lock-based algorithms in a firm real-time setting <ref> [5] </ref>. He then developed a 7 real-time optimistic concurrency control method, WAIT-X (S), which he found empirically superior, over a wide range of resource availability and system workload levels, to a previously proposed real-time lock-based concurrency control method called 2PL-HP [5]. <p> control can outperform lock-based algorithms in a firm real-time setting <ref> [5] </ref>. He then developed a 7 real-time optimistic concurrency control method, WAIT-X (S), which he found empirically superior, over a wide range of resource availability and system workload levels, to a previously proposed real-time lock-based concurrency control method called 2PL-HP [5]. Second, Lee and Son devised an improvement to the conflict detection of optimistic concurrency control in general, which StarBase integrates with Haritsa's WAIT-X (S) [8]. 4.1 WAIT-X (S) WAIT-X is optimistic, using prospective conflict detection and priority-based conflict resolution.
Reference: [6] <author> Young-Kuk Kim. </author> <title> Predictability and Consistency in Real-Time Transaction Processing. </title> <type> PhD thesis, </type> <institution> Computer Science Department, University of Virginia, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: Execution time estimates and off-line analysis can be used to increase DBMS-wide predictability. Future work includes the investigation of more efficient data access methods, the implementation of the integrated transaction scheduling and semantic concurrency control scheme proposed in <ref> [6] </ref>. Temporal consistency [12], where data used to derive new data must be consistent within a certain validity interval, is also a matter to be explored.
Reference: [7] <author> T. Kitayama, T. Nakajima, and H. Tokuda. RT-IPC: </author> <title> An IPC Extension for Real-Time Mach. </title> <type> Technical report, </type> <institution> Carnegie-Mellon University, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: The timing and priority information is then used as input to the RT-Mach scheduler. RT-Mach also has striven to implement priority-based resource scheduling through its interprocess communication (RT-IPC) <ref> [7] </ref> and thread synchronization (RT-Sync) [16] facilities. RT-Mach implements BPI itself as a combination of priority queuing and priority inheritance. <p> Transaction manager priorities are not specified explicitly by StarBase, however. Each obtains the correct priority assignment automatically upon receipt of a new transaction via RT-IPC's priority handoff mechanism <ref> [7] </ref>. 6 3.3 Memory Manager Transactions, depending on the nature of their operations, require some dynamic allocation of memory during their execution. StarBase maintains a Small Memory Manager to allocate and manage dynamic memory.
Reference: [8] <author> J. Lee and S. H. Son. </author> <title> Using Dynamic Adjustment of Serialization Order for Real-Time Database Systems. </title> <booktitle> In Proceedings of the 14th Real-Time Systems Symposium, </booktitle> <pages> pages 66-75, </pages> <address> Raleigh-Durham, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Second, Lee and Son devised an improvement to the conflict detection of optimistic concurrency control in general, which StarBase integrates with Haritsa's WAIT-X (S) <ref> [8] </ref>. 4.1 WAIT-X (S) WAIT-X is optimistic, using prospective conflict detection and priority-based conflict resolution. WAIT-X's conflict detection is prospective in the sense that it looks for conflicts between the validator and transactions which may commit sometime in the future (i.e., running transactions). <p> transactions in the wait queue are retried individually in priority order and if the CCMgr decides that one in particular commits or aborts, it signals the corresponding waiting condition variable, unblocking the formerly suspended transaction manager. 11 4.3 Precise Serialization Precise serialization is a conflict-detection scheme for optimistic concurrency control <ref> [8] </ref>. The goal of precise serialization is to identify transaction conflicts which strict prospective conflict detection considers irreconcilable but can actually be resolved without aborting the transactions involved.
Reference: [9] <author> S. J. Le*er, M. K. McKusick, M. J. Karels, and J. S. Quarterman. </author> <title> The Design and Implementation of the 4.3BSD UNIX Operating System. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: It demands precise performance monitoring software which typical operating systems do not provide. Operating systems usually accumulate usage statistics for each process by sampling during regular clock interrupts <ref> [9] </ref>, but this information is not very precise over short intervals. Furthermore, the execution behavior of the monitored program must be independent of the sampling period. A more precise mechanism would measure durations between context switches and would account for interrupt processing time and other "system overhead". <p> Even if the system can accurately measure capacity consumption on a per-process basis, other problems arise. Usage statistics in traditional operating systems consist of system-level usage time and user-level time for each process <ref> [9] </ref>. For monolithic operating systems, this approach is sufficient, but for microkernel systems where operating system services are offered by different user-level servers, the usage statistics of an activity cannot be found in the usage statistics of a single process.
Reference: [10] <author> J. P. Lehoczky and S. Ramos-Thuel. </author> <title> An Optimal Algorithm for Scheduling Soft-Aperiodic Tasks in Fixed-Priority Preemptive Systems. </title> <booktitle> In Proceedings of the 13th Real-Time Systems Symposium, </booktitle> <pages> pages 110-123, </pages> <address> Phoenix, AZ, </address> <month> December </month> <year> 1992. </year>
Reference-contexts: Our approach to scheduling non-guaranteed transactions without affecting guaranteed transactions is based on slack stealing approach <ref> [10, 4, 3] </ref>. To implement such an algorithm, one special real-time thread is required: a slack stealer. It maintains a slack table for every priority level either statically or dynamically, depending on the 22 slack stealing algorithm used.
Reference: [11] <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling Algorithms for Multiprogramming in a Hard Real-Time Environment. </title> <journal> Journal of the ACM, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <year> 1973. </year>
Reference-contexts: RT-Mach's services in turn are based on two major ideas (among others) which have been developed to ensure the allocation of resources to more important tasks in real-time systems. Those ideas are priority-based CPU scheduling <ref> [11] </ref> and the Basic Priority Inheritance Protocol (BPI) [14] for non-preemptible resources. With both ideas, tasks to be performed are ranked by their relative priorities (a function of their criticality and/or feasibility), and the highest priority tasks are granted 4 access to the resource in question. <p> For example, it is feasible to provide total guarantee on a set of periodic hard real-time transactions with the complete knowledge on their data and computation time requirements under a fixed-priority preemptive scheduling framework <ref> [11, 2] </ref>. Non-guaranteed Transactions. The transactions in this group are supposed to have unknown arrival patterns, random data access behaviors, and unknown resource requirements so that the system cannot guarantee on their timing constraints but must provide a best-effort scheduling for the transactions, depending on the application sementics.
Reference: [12] <author> Krithi Ramamritham. </author> <title> Real-Time Databases. </title> <journal> International Journal of Distributed and Parallel Databases, </journal> <volume> 1(2), </volume> <year> 1993. </year>
Reference-contexts: Execution time estimates and off-line analysis can be used to increase DBMS-wide predictability. Future work includes the investigation of more efficient data access methods, the implementation of the integrated transaction scheduling and semantic concurrency control scheme proposed in [6]. Temporal consistency <ref> [12] </ref>, where data used to derive new data must be consistent within a certain validity interval, is also a matter to be explored. To increase the portability, we plan to identify which real-time operating system features are essential to support StarBase and describe them using the Real-Time POSIX standards.
Reference: [13] <author> S. Savage and H. Tokuda. </author> <title> Real-Time Mach Timers: Exporting Time to the User. </title> <booktitle> In Proceedings of the Third USENIX Mach Symposium, </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: The deadline handler thread then uses a real-time timer to block the thread until the deadline expires. A real-time timer is an RT-Mach abstraction which allows real-time threads to synchronize with particular points in time as measured by real-time clock hardware devices <ref> [13] </ref>. RT-Mach provides a default deadline handler constructed from the building blocks discussed above, but it is inadequate for StarBase's purposes. First, the default deadline handler supports only threads with uniform deadlines.
Reference: [14] <author> L. Sha, R. Rajkumar, S. H. Son, and C. Chang. </author> <title> A Real-Time Locking Protocol. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40(7), </volume> <month> July </month> <year> 1991. </year>
Reference-contexts: RT-Mach's services in turn are based on two major ideas (among others) which have been developed to ensure the allocation of resources to more important tasks in real-time systems. Those ideas are priority-based CPU scheduling [11] and the Basic Priority Inheritance Protocol (BPI) <ref> [14] </ref> for non-preemptible resources. With both ideas, tasks to be performed are ranked by their relative priorities (a function of their criticality and/or feasibility), and the highest priority tasks are granted 4 access to the resource in question.
Reference: [15] <author> Stuart Shih, Young-Kuk Kim, and Sang H. Son. </author> <title> Performance Evaluation of a Firm Real-Time DataBase System. </title> <booktitle> In Proceedings of the 2nd International Workshop on Real-Time Computing Systems and Applications, </booktitle> <address> Tokyo, Japan, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Issues of deadline-handling are dealt with by constructing deadline handlers which synchronize with the start and end of a transaction and which do not interfere with its execution until the deadline expires. The performance of the current StarBase system has been evaluated and reported in <ref> [15] </ref>. The current StarBase architecture can be extended to support the situation in which transaction characteristics can be specified beforehand. With prior knowledge, an RT-DBMS can preallocate resources and arrange transaction schedules to minimize conflicts, resulting in more predictable and guaranteed services.
Reference: [16] <author> H. Tokuda and T. Nakajima. </author> <title> Evaluation of Real-Time Synchronization in Real-Time Mach. </title> <booktitle> In Proceedings of the Second USENIX Mach Workshop, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: The timing and priority information is then used as input to the RT-Mach scheduler. RT-Mach also has striven to implement priority-based resource scheduling through its interprocess communication (RT-IPC) [7] and thread synchronization (RT-Sync) <ref> [16] </ref> facilities. RT-Mach implements BPI itself as a combination of priority queuing and priority inheritance.
Reference: [17] <author> H. Tokuda, T. Nakajima, and P. Rao. </author> <title> Real-Time Mach: Towards Predictable Real-Time Systems. </title> <booktitle> In Proceedings of the USENIX 1990 Mach Workshop, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: StarBase uses no a priori information about transaction workload and discards tardy transactions at their deadline points. In order to realize many of these goals, StarBase is constructed on top of RT-Mach, a real-time operating system developed at Carnegie Mellon University <ref> [17] </ref>. StarBase differs from previous RT-DBMS work [1, 5] in that a) it relies on a real-time operating system which provides priority-based scheduling and time-based synchronization, and b) it deals explicitly with data contention and deadline handling in addition to transaction scheduling, the traditional focus of simulation studies. <p> RT-Mach provides several priority-based scheduling regimes, including Fixed Priority, Earliest Deadline First, Rate Monotonic, and Deadline Monotonic. RT-Mach's real-time thread model <ref> [17] </ref> distinguishes real-time threads of execution from ordinary ones, requiring the explicit specification of timing constraints and criticality on a per-thread basis. The timing and priority information is then used as input to the RT-Mach scheduler.
Reference: [18] <author> P. Yu, K. Wu, K. Lin, and S. H. Son. </author> <title> On Real-Time Databases: </title> <journal> Concurrency Control and Scheduling. Proceedings of IEEE, Special Issue on Real-Time Systems, </journal> <volume> 82(1) </volume> <pages> 140-157, </pages> <month> January </month> <year> 1994. </year> <month> 25 </month>
Reference-contexts: A real-time database management system (RT-DBMS), however, must adopt goals which are consistent with any real-time system: providing the best service to the most critical transactions and ensuring some 1 degree of predictability in transaction processing <ref> [18] </ref>. The StarBase RT-DBMS is an attempt to merge conventional DBMS functionality with real-time technology. StarBase supports the relational database model and understands a simple SQL-like query language. The DBMS maintains a centralized server to which local or remote clients submit transactions.
References-found: 18

