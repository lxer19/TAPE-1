URL: ftp://claude.ifi.unizh.ch/pub/techreports/TR-94/ifi-94.14.ps.gz
Refering-URL: http://www.cs.gatech.edu/people/home/jmankoff/collab-immers-env.html
Root-URL: 
Email: -geppert dittrich-@ifi.unizh.ch  
Title: Page 1 Specification and Implementation of Consistency Constraints in Object-Oriented Database Systems: Applying Programming-by-Contract  
Author: Andreas Geppert, Klaus R. Dittrich 
Keyword: object-oriented database systems, consistency constraints, active database systems  
Address: Switzerland  
Affiliation: Institut fuer Informatik, Universitaet Zuerich,  
Abstract: We describe an approach to the specification and implementation of consistency constraints in object-oriented database systems, adopting the programming-by-contract paradigm developed for object-oriented programming. We also investigate how consistency constraints specified in programming-by-contract can be transformed into production rules of an active, object-oriented database system.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Aiken, J. Widom, J.M. Hellerstein: </author> <title> Behaviour of Database Production Rules: Termination, Conuence, and Observable Determinism. </title> <booktitle> Proc. ACM-SIGMOD Intl. Conf. on Management of Data, </booktitle> <address> San Diego, </address> <month> June , </month> <year> 1992. </year>
Reference-contexts: One part of our future work will therefore focus on defining nice properties of rule sets in object-oriented aDBSs and on developing methods how to analyze rules with respect to these properties (comparable to <ref> [1] </ref> for the relational case). Page 15 Acknowledgements We gratefully acknowledge the comments of our colleagues Stella Gatziu, Stefan Scherrer, and Dimitris Tombros on an earlier version of this paper.
Reference: 2. <author> M. Atkinson, F. Bancilhon, D.J. DeWitt, K.R. Dittrich, D. Maier, S.B. Zdonik: </author> <title> The Object-Oriented Database System Manifesto (a Political Pamphlet). </title> <booktitle> Proc. 1 st Intl. Conf. on Deductive and Object-Oriented Databases, </booktitle> <year> 1989. </year>
Reference-contexts: We then introduce Programming by Contract for Databases (PbC-DB) and describe how consistency constraints can be specified using this paradigm. 3.1 The Object Model We require an object model as provided by most current ooDBSs <ref> [2] </ref>. In particular, we assume that the definition of classes comprises a unique name, a type, a list of supertypes, and a set of method signatures. Each method signature defines a method name, a list of typed formal parameters, and possibly a return value.
Reference: 3. <author> C. Bauzer-Medeiros, P. Pfeffer: </author> <title> Object Integrity Using Rules. </title> <booktitle> Proc. European Conference on Object-Oriented Programming, </booktitle> <address> Geneva, Switzerland. </address> <publisher> LNCS 512, Springer 1991 </publisher>
Reference-contexts: This is the case whenever the actions of one or more rules cyclically satisfy each others condition (i.e., the repairs violate each others constraint). This is a general problem of systems providing nested rule execution <ref> [e.g., 3, 4] </ref>. Although we would prefer a compile-time analysis of ECA-rules (which would then, e.g., determine whether termination is guaranteed), such an analysis tool is not yet available for SAMOS. <p> Second, it is still open how to determine termination and other 4. In the O 2 prototype, rules are deactivated during rule execution in order to prevent cycles <ref> [3] </ref>. Since the effects of rule execution are much harder to comprehend in this way, we do not follow this approach. update (a) update (b) update (a) Page 13 properties of ECA-rule executions in object-oriented aDBSs. <p> A logic-based constraint definition language for non-standard applications and structurally ooDBS is proposed in [12]. Similar to Starburst [4], constraints are transformed into trigger definitions. In this work, constraints are not related to class or ADT definitions. Another constraint maintenance mechanism has been proposed for the O 2 prototype <ref> [3] </ref>. In this approach, constraints can be specified as predicates. Repairs are written in the database programming language of O 2 . Constraints are implemented by the (active) rule management subsystem of O 2 . Predicates are mapped into queries of the O 2 query language.
Reference: 4. <author> S. Ceri, J. Widom: </author> <title> Deriving Production Rules for Constraint Maintenance. </title> <booktitle> Proc. of the 16 th Intl. Conf. on Very Large Data Bases, </booktitle> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: If then one condition is still violated, the method is aborted. In our approach, however, constraint violations at the end of repairs lead to nested execution of repairs. Similarly, Starburst <ref> [4] </ref> allows multiple iterations, at the price of considering termination of multiple rules, whose repair actions may violate each others formula. The same procedure for constraint checking and enforcement applies to postconditions and invariants. <p> This leads to the third level of consistency: application consistency. Note that application consistency subsumes extension consistency (and therefore also object consistency). 4 Implementation of Consistency Constraints and Consistency Enforcement This section investigates how consistency maintenance in PbC-DB can be implemented. Similar to other authors <ref> [e.g., 4] </ref>, we follow the approach to use an active DBMS. An aDBMS is able to detect events (and situations) in the database and beyond and to react accordingly. For consistency maintenance, the situations to be detected are the potential consistency violations. <p> This is the case whenever the actions of one or more rules cyclically satisfy each others condition (i.e., the repairs violate each others constraint). This is a general problem of systems providing nested rule execution <ref> [e.g., 3, 4] </ref>. Although we would prefer a compile-time analysis of ECA-rules (which would then, e.g., determine whether termination is guaranteed), such an analysis tool is not yet available for SAMOS. <p> needs of the application purpose (such as in ODE [10]), then a general-purpose active object-oriented database system needs tools to analyze sets of rules. 5 Related Work The first approach that investigates a declarative language for the specification of constraints and production rules for implementation has been developed for Starburst <ref> [4] </ref>. A constraint specification defines a table list (the relations that are affected by the constraint) and an SQL predicate. <p> Special attention is needed to keep the set of invalidating operations (triggering events) small in order to trigger rules only if necessary. Repairs can be defined by users. A logic-based constraint definition language for non-standard applications and structurally ooDBS is proposed in [12]. Similar to Starburst <ref> [4] </ref>, constraints are transformed into trigger definitions. In this work, constraints are not related to class or ADT definitions. Another constraint maintenance mechanism has been proposed for the O 2 prototype [3]. In this approach, constraints can be specified as predicates. <p> Constraints in Chimera are deductive, set-oriented rules; they can be defined for single or multiple classes. Similar to PbC-DB, a restricted set of transitions can be constrained through referring to old states. Constraints are translated into production rules. Similar to Starburst <ref> [4] </ref>, events of production rules are the potentially invalidating operations, i.e., database update op Page 14 erations. It is unclear from [5] how constraints (pre- and postconditions) can be related to methods as in PbC-DB or Ode.
Reference: 5. <author> S. Ceri, P. Fraternali, S. Paraboschi: </author> <title> Constraint Management in Chimera. </title> <journal> Bulletin of the IEEE Technical Committee on Data Engineering 17:2, </journal> <month> June </month> <year> 1994. </year>
Reference-contexts: Hence, the unit of consistency is a rather coarse one, and the notion of method is not very well integrated with the consistency mechanism. Chimera is a database language that supports the declarative specification of constraints <ref> [5] </ref>. Constraints in Chimera are deductive, set-oriented rules; they can be defined for single or multiple classes. Similar to PbC-DB, a restricted set of transitions can be constrained through referring to old states. Constraints are translated into production rules. <p> Similar to PbC-DB, a restricted set of transitions can be constrained through referring to old states. Constraints are translated into production rules. Similar to Starburst [4], events of production rules are the potentially invalidating operations, i.e., database update op Page 14 erations. It is unclear from <ref> [5] </ref> how constraints (pre- and postconditions) can be related to methods as in PbC-DB or Ode. Finally, while all approaches surveyed so far allow only two-state transitions, [14] allows to constrain general state transitions.
Reference: 6. <author> C. Collet, T. Coupaye, T. Svensen: NAOS: </author> <title> Efficient and Modular Reactive Capabilities in an Object-Oriented Database System. </title> <booktitle> Proc. of the 20 th Intl. Conf. on Very Large Data Bases, </booktitle> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: The condition checks whether the invariant I is violated, and the action eventually executes Is repair. ECA-Rules for State-Transition Constraints In PbC-DB, postconditions can refer to the state of the receiver as of the beginning of the method execution. Some systems such as Starburst or NAOS <ref> [6] </ref> support deltas (i.e., old and current states of objects), which are not provided by SAMOS. Therefore, old states have to be recorded by the generated implementation of condition evaluation functions. During the compilation of a postcondition, it is checked whether the postcondition refers to the old state.
Reference: 7. <author> O. </author> <title> Deux: The O2 System. </title> <journal> Communications of the ACM 34:10, </journal> <year> 1991. </year>
Reference-contexts: Internal CCs are those that are known to and can be enforced by the DBS, while external CCs have to be expressed, checked, and enforced within application programs. Internal CCs can be subdivided into the following three types <ref> [7] </ref>: inherent consistency constraints: they are fixed for a given data model and therefore do not have to be specified (e.g., absence of cycles in inheritance relationships), implicit consistency constraints: they can be specified in the schema using specific constructs (keywords) of the data definition language (DDL), e.g., the identification of <p> As an example, consider the typical consistency constraint that employ ees may not earn more than their manager. Another classification of consistency constraints is based on whether only single database states or even database state transitions can be constrained <ref> [7] </ref>: static consistency constraints consider only single states of a database, dynamic CCs allow to constrain state transitions, i.e., they specify which transformations of database states into new ones are allowed. In the general case, dynamic CCs constrain arbitrary sequences of state transitions. Two-state transitions are a special case. <p> Note that in this way the database system controls the consistency of applications, in addition to the consistency of database states. The types of constraints play the following role for databases and applications: 3. This is similar to the notions of application and application program in O 2 <ref> [7] </ref>.
Reference: 8. <author> R. Elmasri, </author> <title> S.B. Navathe: Fundamentals of Database Systems. </title> <publisher> Benjamin/Cummings Publishing, </publisher> <year> 1989. </year>
Reference-contexts: This approach will support implicit, dynamic (two-state transition) and a restricted form of behavioral consistency constraints. We investigate the implementation of constraint violation detection and consistency enforcement on top of the active object-oriented database management system (aDBMS) SA-MOS <ref> [8] </ref>. Since SAMOS is intended as a general platform for various functionalities that benefit from an active mechanism, it is also an interesting issue how well PbC can be implemented on top of SAMOS, or where potential limitations may be encountered. The remainder of this paper is structured as follows. <p> An aDBMS is able to detect events (and situations) in the database and beyond and to react accordingly. For consistency maintenance, the situations to be detected are the potential consistency violations. We use the aDBMS SAMOS <ref> [8] </ref> for implementing PbC-DB. For the sake of comprehensiveness, we give a short survey of the active mechanism of SAMOS before we describe the transformation process of constraints into production rules (ECA-rules). 4.1 The Active Database System SAMOS SAMOS [8] supports an active mechanism in addition to the usual features of <p> We use the aDBMS SAMOS <ref> [8] </ref> for implementing PbC-DB. For the sake of comprehensiveness, we give a short survey of the active mechanism of SAMOS before we describe the transformation process of constraints into production rules (ECA-rules). 4.1 The Active Database System SAMOS SAMOS [8] supports an active mechanism in addition to the usual features of an object-oriented database system. Active behavior is specified in terms of production rules. Each production rule consists of an event, a condition, and an action part.
Reference: 9. <author> S. Gatziu, A. Geppert, K.R. Dittrich: </author> <title> Integrating Active Mechanisms into an Object-Oriented Database System. </title> <booktitle> Proc. of the 3 rd Intl. Workshop on Database Programming Languages (DBPL), </booktitle> <address> Nafplion, Greece, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: Active behavior is specified in terms of production rules. Each production rule consists of an event, a condition, and an action part. Events can be primitive (method events, value events, time events, transaction events) or complex (sequence, disjunction, negation and so forth) <ref> [9] </ref>. Method events can refer to the point of time before the method execution starts (expressed through the keyword BEFORE), or to the point in time after the method execution (AFTER). Transaction programs can be named, and the name can be referred to in transaction events. <p> Optimization Given the above translation, SAMOS would possibly execute the same rule multiple times for invariants. In fact, SAMOS would trigger one production rule for each modification of the instance variable iv within a method execution. A better solution using the event definition facilities of SAMOS <ref> [9] </ref> specifies that each invariant has to be checked only once during each method execution. Concretely, let iv 1 through iv n be the instance variables referred to in one invariant constraint.
Reference: 10. <author> S. Gatziu, K.R. Dittrich: </author> <title> Events in an Active Object-Oriented Database System. </title> <editor> In N.W. Paton, H.W. Williams (eds): </editor> <booktitle> Proc. Workshop on Rules in Database Systems, </booktitle> <address> Edinburgh, UK, </address> <note> September 1993 (Workshops in Computing, Springer-Verlag, </note> <year> 1994). </year>
Reference-contexts: In general, we assume that each method body is implemented as a transaction, so aborting the method means to abort the corresponding transaction. If all formulas evaluating to false have repairs defined, these repairs are executed after the condition check. An alternative approach is taken in ODE <ref> [10] </ref>, which allows two checking phases: after repairs have been executed, the constraints are checked again. If then one condition is still violated, the method is aborted. In our approach, however, constraint violations at the end of repairs lead to nested execution of repairs. <p> If rule execution (say, for constraint maintenance) is not tailored to the needs of the application purpose (such as in ODE <ref> [10] </ref>), then a general-purpose active object-oriented database system needs tools to analyze sets of rules. 5 Related Work The first approach that investigates a declarative language for the specification of constraints and production rules for implementation has been developed for Starburst [4]. <p> As in Starburst, triggering events (which are method events in O 2 ) have to be determined during this transformation. Since the rule mechanism does not provide for value events, invariants are hard to implement efficiently. The active ooDBS Ode also supports the specification of constraints <ref> [10] </ref>. Similar to our approach, they attach constraints to classes. Hard constraints have the same meaning as postcon-ditions in PbC-DB. Furthermore, our approach is similar to Ode in that both allow the specification of repairs.
Reference: 11. <author> N. Gehani, H.V. Jagadish: </author> <title> Ode as an Active Database: Constraints and Triggers. </title> <booktitle> Proc. 17 th Intl. Conf. on Very Large Data Bases, </booktitle> <address> Barcelona, Spain, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: Ode does neither support preconditions nor invariants, and also cannot monitor state transitions of objects. The TM data model supports the specification of constraints on three levels <ref> [11] </ref>: the object level, the class level (extension in our terminology), and the database object level. Constraints are specified as logic formulas over the states of objects.
Reference: 12. <author> P.W.P.J. Grefen, R.A. </author> <title> de By, P.M.G. Apers: Integrity Control in Advanced Database Systems. </title> <journal> Bulletin IEEE Technical Committee on Data Engineering 17:2, </journal> <month> June </month> <year> 1994. </year>
Reference-contexts: Furthermore, since the active mechanism can also be used for further purposes, implementing constraints through ECA-rules contributes to the minimality of concepts needed in the DBMS <ref> [12] </ref>. Nevertheless, we have also recognized some possible deficiencies while developing the transformation process. First, an aDBMS useful for implementing (even simple) dynamic constraints should provide for deltas, while in SAMOS they must be implemented by the consistency constraint compiler. <p> Special attention is needed to keep the set of invalidating operations (triggering events) small in order to trigger rules only if necessary. Repairs can be defined by users. A logic-based constraint definition language for non-standard applications and structurally ooDBS is proposed in <ref> [12] </ref>. Similar to Starburst [4], constraints are transformed into trigger definitions. In this work, constraints are not related to class or ADT definitions. Another constraint maintenance mechanism has been proposed for the O 2 prototype [3]. In this approach, constraints can be specified as predicates.
Reference: 13. <author> A.M. Kotz: </author> <note> Triggermechanismen in Datenbanksystemen. IFB 201, Springer 1989. </note>
Reference-contexts: They can only be defined by the class-implementor, not by any arbitrary user. Class-external rules have to respect encapsulation, and are therefore not permitted to read or modify instance variables directly. The execution model is realized on top of the object-oriented database system ObjectStore <ref> [13] </ref> and uses the nested transaction model [17] of ObjectStore. The coupling mode for each rule defines when the rule is executed with respect to the triggering event: immediately (directly after the triggering event has been detected), deferred (before the triggering transaction commits), or decoupled (in a separate transaction).
Reference: 14. <author> C. Lamb, G. Landis, J. Orenstein, D. Weinreb: </author> <title> The ObjectStore Database System. </title> <journal> Special Issue on Next-Generation Database Systems. CACM 34:10, </journal> <year> 1991. </year>
Reference-contexts: It is unclear from [5] how constraints (pre- and postconditions) can be related to methods as in PbC-DB or Ode. Finally, while all approaches surveyed so far allow only two-state transitions, <ref> [14] </ref> allows to constrain general state transitions. To do so, the underlying logic is enhanced with special operators for referring to states (i.e., the current state and the next state), and temporal quantifiers (e.g., always, sometimes).
Reference: 15. <author> U.W. Lipeck, M. Gertz, G. Saake: </author> <title> Transitional Monitoring of Dynamic Integrity Constraints. </title> <journal> Bull. IEEE Technical Committee on Data Engineering 17:2, </journal> <month> June </month> <year> 1994. </year>
Reference-contexts: In this paper, we adopt the Programming-by-Contract paradigm (PbC) <ref> [15] </ref> developed for object-oriented programming languages for consistency maintenance in object-oriented database Accepted for GI-Conf. Datenbanksysteme in Bro, Technik und Wissenschaft (BTW), Dres den (Germany), March 1994 Page 2 systems. This approach will support implicit, dynamic (two-state transition) and a restricted form of behavioral consistency constraints. <p> Note that the last two classification dimensions are orthogonal to each other. 2.2 Programming by Contract PbC <ref> [15, 16] </ref> is an approach to achieve correct and robust object-oriented, modular programs. In addition to the usual parts of class definitions, preconditions, postconditions, and class invariants are specified. In PbC, preconditions define the conditions that must be fulfilled in order to execute a method correctly.
Reference: 16. <author> B. Meyer: </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Note that the last two classification dimensions are orthogonal to each other. 2.2 Programming by Contract PbC <ref> [15, 16] </ref> is an approach to achieve correct and robust object-oriented, modular programs. In addition to the usual parts of class definitions, preconditions, postconditions, and class invariants are specified. In PbC, preconditions define the conditions that must be fulfilled in order to execute a method correctly.
Reference: 17. <author> B. Meyer: </author> <title> Applying "Design by Contract". </title> <journal> IEEE Computer 25:10, </journal> <year> 1992. </year>
Reference-contexts: Class-external rules have to respect encapsulation, and are therefore not permitted to read or modify instance variables directly. The execution model is realized on top of the object-oriented database system ObjectStore [13] and uses the nested transaction model <ref> [17] </ref> of ObjectStore. The coupling mode for each rule defines when the rule is executed with respect to the triggering event: immediately (directly after the triggering event has been detected), deferred (before the triggering transaction commits), or decoupled (in a separate transaction).
Reference: 18. <author> J.E.B. Moss: </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference: 19. <author> T. Sheard, D. Stemple: </author> <title> Automatic Verification of Database Transaction Safety. </title> <journal> ACM Trans. on Database Systems 14:3, </journal> <year> 1989. </year> <pages> Page 16 </pages>
References-found: 19

