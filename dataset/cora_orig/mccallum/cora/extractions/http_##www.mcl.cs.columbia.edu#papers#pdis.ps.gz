URL: http://www.mcl.cs.columbia.edu/papers/pdis.ps.gz
Refering-URL: http://www-ccs.cs.umass.edu/mobile/os.html
Root-URL: 
Email: tait@cs.columbia.edu, djd@cs.columbia.edu  
Title: Service Interface and Replica Management Algorithm for Mobile File System Clients  
Author: Carl D. Tait and Dan Duchamp 
Address: New York, NY 10027  
Affiliation: Computer Science Department Columbia University  
Abstract: Portable computers are now common, a fact that raises the possibility that file service clients might move on a regular basis. This new development requires rethinking some features of distributed file system design. We argue that existing approaches to file replica management would not cope well with the likely behavior of mobile clients, and we present our solution: a lazy "server-based" update operation. This operation facilitates fast, scalable, and highly fault-tolerant implementations of both read and write operations in the usual case. To cope with the weak semantics of the update operation, we propose a new file system service interface that allows applications to opt for "UNIX semantics" by use of a slower, less fault-tolerant read operation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Siegel, K. Birman, and K. Marzullo. Deceit: </author> <title> A Flexible Distributed File System. </title> <booktitle> In Proc. 1990 Summer USENIX Technical Conf., </booktitle> <pages> pages 51-62. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction This work investigates how to maintain replicas in a distributed file system, especially one supporting mobile clients. While the topic of replica management within file systems has received so much attention that one might think there is no design point left unconsidered <ref> [3, 16, 14, 2, 9, 18, 1, 10, 4] </ref>, the notion of mobile clients is a new development that alters operating circumstances and therefore suggests new designs. The idea of mobile file service clients stems from the exploding popularity of portable computers. <p> However, the list of PCWs for a file must be replicated at each server storing a copy of that file. This requirement is necessary to continue operations during crashes and partitions. Note that a currency token is not analogous to a "write token" used by other systems <ref> [18, 1] </ref>. Instead, it is a hint [19] that substantially improves performance in an environment with little sharing. 2.5 Further Details 2.5.1 Interference Between Strict and Loose Reads It is the responsibility of clients to use strict reads when a file is expected to be shared. <p> conflicting goals of quick update propagation and overhead reduction due to caching can be well satisfied with a wide range of pickup intervals, starting at approximately 3 seconds. 3.3 Comparison with Existing Systems For purposes of comparison, we have chosen three well-known and quite different working implementations: Coda [9], Deceit <ref> [1] </ref>, and Echo [18]. Of the three, Echo enforces the strictest controls and provides the cleanest semantics (1SR). Its antithesis is Coda, a system that reads from and writes to whichever servers are available; version vectors are used to detect conflicts created by making multiple uncoordinated updates.
Reference: [2] <author> L. F. Cabrera and J. Wyllie. </author> <title> Quicksilver Distributed File Services: An Architecture for Horizontal Growth. </title> <type> Technical Report RJ5578, </type> <institution> IBM Almaden Research Center, </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: 1 Introduction This work investigates how to maintain replicas in a distributed file system, especially one supporting mobile clients. While the topic of replica management within file systems has received so much attention that one might think there is no design point left unconsidered <ref> [3, 16, 14, 2, 9, 18, 1, 10, 4] </ref>, the notion of mobile clients is a new development that alters operating circumstances and therefore suggests new designs. The idea of mobile file service clients stems from the exploding popularity of portable computers.
Reference: [3] <author> C. A. Ellis and R. A. Floyd. </author> <title> The Roe File System. </title> <booktitle> In Proc. Third Symp. on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 175-181, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: 1 Introduction This work investigates how to maintain replicas in a distributed file system, especially one supporting mobile clients. While the topic of replica management within file systems has received so much attention that one might think there is no design point left unconsidered <ref> [3, 16, 14, 2, 9, 18, 1, 10, 4] </ref>, the notion of mobile clients is a new development that alters operating circumstances and therefore suggests new designs. The idea of mobile file service clients stems from the exploding popularity of portable computers.
Reference: [4] <author> B. Liskov et al. </author> <title> A Replicated Unix File System. </title> <journal> Operating Systems Review, </journal> <volume> 25(1) </volume> <pages> 60-64, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: 1 Introduction This work investigates how to maintain replicas in a distributed file system, especially one supporting mobile clients. While the topic of replica management within file systems has received so much attention that one might think there is no design point left unconsidered <ref> [3, 16, 14, 2, 9, 18, 1, 10, 4] </ref>, the notion of mobile clients is a new development that alters operating circumstances and therefore suggests new designs. The idea of mobile file service clients stems from the exploding popularity of portable computers. <p> Exclusive use of strict read and write ensures "one-copy UNIX serializability" (1USR), which duplicates the behavior that one would observe in a centralized UNIX system. This semantics is the one most commonly sought by research efforts in replicated file systems (e.g., <ref> [4] </ref>). 1USR is distinguished from true one-copy serializability (1SR) in that, because of caching, it is possible for 1USR clients to make irreconcilable updates to a file without any knowledge that they are doing so.
Reference: [5] <author> D. S. Parker et al. </author> <title> Detection of Mutual Inconsistency in Distributed Systems. </title> <journal> IEEE Trans. Sofwtare Engineering, </journal> <volume> SE-9(3):240-246, </volume> <month> May </month> <year> 1983. </year>
Reference-contexts: Furthermore, each PCW holding the file must be contacted to ensure that no cached consistent updates are overlooked. Files are tagged with version vectors <ref> [5] </ref> so that the copies at different replicas can be compared for re-cency. The primary compares the version vectors and gives the client the most recent copy of the file plus an indication of whether it has a CT.
Reference: [6] <author> J. H. Howard et al. </author> <title> Scale and Performance in a Distributed File System. </title> <journal> ACM Trans. Computer Systems, </journal> <volume> 6(1) </volume> <pages> 51-81, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Previous work on file caching <ref> [13, 6, 8] </ref> has shown that having clients lazily write back updates substantially improves scalability. 2.2 Interface Lazy operation is unsuitable for applications that share a file simultaneously or that perform write-read sharing with the read closely following the write.
Reference: [7] <author> J. Ousterhout et al. </author> <title> A Trace-driven Analysis of the UNIX 4.2 BSD File System. </title> <booktitle> In Proc. Tenth ACM Symp. on Operating System Principles, </booktitle> <pages> pages 15-24, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: Due to the limitations of our trace data, it was difficult to estimate the amount of update activity performed by a user. Ousterhout's 1985 study <ref> [7] </ref> found that each user read or wrote an average of 300 to 600 bytes of file data per second. This study was conducted on Vax/11-780s and is now outdated. Our own experiments, conducted on a Sun-3, suggest a higher figure|perhaps 1000 bytes per second. <p> Furthermore, a file may be updated several times between pickups, but only a single version need be maintained in the cache. This further reduces the actual amount of client cache space required to store updates between pickups. File Lifetimes. Several studies have already been performed on file lifetimes <ref> [7, 11, 17] </ref>, and our own data confirms one of the earlier results: if a file is short-lived, it is usually very short-lived. The majority of files that were both created and destroyed during our traces have a lifetime of less than five minutes.
Reference: [8] <author> M. Baker et al. </author> <title> Measurements of a Distributed File System. </title> <booktitle> In Proc. Thirteenth ACM Symp. on Operating System Principles, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: Previous work on file caching <ref> [13, 6, 8] </ref> has shown that having clients lazily write back updates substantially improves scalability. 2.2 Interface Lazy operation is unsuitable for applications that share a file simultaneously or that perform write-read sharing with the read closely following the write.
Reference: [9] <author> M. Satyanarayanan et al. Coda: </author> <title> A Highly Available File System for a Distributed Workstation Environment. </title> <journal> IEEE Trans. Computers, </journal> <volume> 39(4) </volume> <pages> 447-459, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: 1 Introduction This work investigates how to maintain replicas in a distributed file system, especially one supporting mobile clients. While the topic of replica management within file systems has received so much attention that one might think there is no design point left unconsidered <ref> [3, 16, 14, 2, 9, 18, 1, 10, 4] </ref>, the notion of mobile clients is a new development that alters operating circumstances and therefore suggests new designs. The idea of mobile file service clients stems from the exploding popularity of portable computers. <p> Examples are Coda's close operation, which contacts all reachable servers <ref> [9] </ref>, or Echo's write operation, which must contact a majority of servers. 2 Approach 2.1 Server-Based Writes To eliminate global communication we take two steps. First, we use a primary-secondary replication scheme; the client communicates only with its primary. <p> The conflicting goals of quick update propagation and overhead reduction due to caching can be well satisfied with a wide range of pickup intervals, starting at approximately 3 seconds. 3.3 Comparison with Existing Systems For purposes of comparison, we have chosen three well-known and quite different working implementations: Coda <ref> [9] </ref>, Deceit [1], and Echo [18]. Of the three, Echo enforces the strictest controls and provides the cleanest semantics (1SR). Its antithesis is Coda, a system that reads from and writes to whichever servers are available; version vectors are used to detect conflicts created by making multiple uncoordinated updates.
Reference: [10] <author> R. G. Guy et al. </author> <title> Implementation of the Ficus Replicated File System. </title> <booktitle> In Conf. Proc. 1990 Summer USENIX Technical Conf., </booktitle> <pages> pages 63-72. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction This work investigates how to maintain replicas in a distributed file system, especially one supporting mobile clients. While the topic of replica management within file systems has received so much attention that one might think there is no design point left unconsidered <ref> [3, 16, 14, 2, 9, 18, 1, 10, 4] </ref>, the notion of mobile clients is a new development that alters operating circumstances and therefore suggests new designs. The idea of mobile file service clients stems from the exploding popularity of portable computers.
Reference: [11] <author> R. A. Floyd and C. S. Ellis. </author> <title> Directory Reference Patterns in Hierarchical File Systems. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 1(2) </volume> <pages> 238-247, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Furthermore, a file may be updated several times between pickups, but only a single version need be maintained in the cache. This further reduces the actual amount of client cache space required to store updates between pickups. File Lifetimes. Several studies have already been performed on file lifetimes <ref> [7, 11, 17] </ref>, and our own data confirms one of the earlier results: if a file is short-lived, it is usually very short-lived. The majority of files that were both created and destroyed during our traces have a lifetime of less than five minutes.
Reference: [12] <author> H. Garcia-Molina. </author> <title> Elections in a Distributed Computing System. </title> <journal> IEEE Trans. Computers, </journal> <volume> C-31(1):48-59, </volume> <month> January </month> <year> 1982. </year>
Reference-contexts: Once a secondary has decided the primary is gone, it starts an election <ref> [12] </ref> to choose a new primary. The only requirement on the election is that few than N servers are unreachable, where N is the number of replicas that must be propagated to secondaries before a purge notice can be issued.
Reference: [13] <author> M. N. Nelson, B. B. Welch, and J. K. Ousterhout. </author> <title> Caching in the Sprite Network File System. </title> <journal> ACM Trans. Computer Systems, </journal> <volume> 6(1) </volume> <pages> 134-154, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Previous work on file caching <ref> [13, 6, 8] </ref> has shown that having clients lazily write back updates substantially improves scalability. 2.2 Interface Lazy operation is unsuitable for applications that share a file simultaneously or that perform write-read sharing with the read closely following the write.
Reference: [14] <author> K. Marzullo and F. Schmuck. </author> <title> Supplying High Availability with a Standard Network File System. </title> <booktitle> In Proc. Eighth Intl. Conf. on Distributed Computing Systems, </booktitle> <pages> pages 447-453, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: 1 Introduction This work investigates how to maintain replicas in a distributed file system, especially one supporting mobile clients. While the topic of replica management within file systems has received so much attention that one might think there is no design point left unconsidered <ref> [3, 16, 14, 2, 9, 18, 1, 10, 4] </ref>, the notion of mobile clients is a new development that alters operating circumstances and therefore suggests new designs. The idea of mobile file service clients stems from the exploding popularity of portable computers.
Reference: [15] <author> J. Ousterhout and F. Douglis. </author> <title> Beating the I/O Bottleneck: A Case for Log-structured File Systems. </title> <journal> Operating Systems Review, </journal> <volume> 23(1) </volume> <pages> 11-28, </pages> <month> Jan-uary </month> <year> 1989. </year>
Reference-contexts: When a client moves away from some or all of its current set of servers, file service operations implemented with global communication will be slow. 1 Here we are referring to Ousterhout's division of file access patterns into three classes <ref> [15] </ref>: (a) Scientific jobs|large data sets read and written sequentially. (b) Transaction processing|frequent sharing, with the require ment of one-copy serializability. (c) Engineering/office applications|many applications using many small files, with little concurrent sharing. 2 We define a global communication as a synchronous operation in which more than one server must be
Reference: [16] <author> G. J. Popek and B. J. Walker. </author> <title> The LOCUS Distributed System Architecture. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: 1 Introduction This work investigates how to maintain replicas in a distributed file system, especially one supporting mobile clients. While the topic of replica management within file systems has received so much attention that one might think there is no design point left unconsidered <ref> [3, 16, 14, 2, 9, 18, 1, 10, 4] </ref>, the notion of mobile clients is a new development that alters operating circumstances and therefore suggests new designs. The idea of mobile file service clients stems from the exploding popularity of portable computers.
Reference: [17] <author> M. Satyanarayanan. </author> <title> A Study of File Sizes and Functional Lifetimes. </title> <booktitle> In Proc. Eighth Symp. on Operating System Principles, </booktitle> <pages> pages 96-108. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1981. </year>
Reference-contexts: Furthermore, a file may be updated several times between pickups, but only a single version need be maintained in the cache. This further reduces the actual amount of client cache space required to store updates between pickups. File Lifetimes. Several studies have already been performed on file lifetimes <ref> [7, 11, 17] </ref>, and our own data confirms one of the earlier results: if a file is short-lived, it is usually very short-lived. The majority of files that were both created and destroyed during our traces have a lifetime of less than five minutes.
Reference: [18] <author> T. Mann, A. Hisgen, and G. Swart. </author> <title> An Algorithm for Data Replication. </title> <type> Technical Report 46, </type> <institution> Digital Systems Research Center, </institution> <month> June </month> <year> 1989. </year>
Reference-contexts: 1 Introduction This work investigates how to maintain replicas in a distributed file system, especially one supporting mobile clients. While the topic of replica management within file systems has received so much attention that one might think there is no design point left unconsidered <ref> [3, 16, 14, 2, 9, 18, 1, 10, 4] </ref>, the notion of mobile clients is a new development that alters operating circumstances and therefore suggests new designs. The idea of mobile file service clients stems from the exploding popularity of portable computers. <p> For example, two clients may both strictly read a file and then make conflicting updates into their caches. 1SR is not attainable using our design (or most others); Echo <ref> [18] </ref> is an experiment in providing 1SR via a file system. Division of read into loose read and strict read ensures that the entire cost of establishing 1USR consistency is charged to the process (reader) that demands the consistent value. <p> However, the list of PCWs for a file must be replicated at each server storing a copy of that file. This requirement is necessary to continue operations during crashes and partitions. Note that a currency token is not analogous to a "write token" used by other systems <ref> [18, 1] </ref>. Instead, it is a hint [19] that substantially improves performance in an environment with little sharing. 2.5 Further Details 2.5.1 Interference Between Strict and Loose Reads It is the responsibility of clients to use strict reads when a file is expected to be shared. <p> quick update propagation and overhead reduction due to caching can be well satisfied with a wide range of pickup intervals, starting at approximately 3 seconds. 3.3 Comparison with Existing Systems For purposes of comparison, we have chosen three well-known and quite different working implementations: Coda [9], Deceit [1], and Echo <ref> [18] </ref>. Of the three, Echo enforces the strictest controls and provides the cleanest semantics (1SR). Its antithesis is Coda, a system that reads from and writes to whichever servers are available; version vectors are used to detect conflicts created by making multiple uncoordinated updates.
Reference: [19] <author> D. B. Terry. </author> <title> Caching Hints in Distributed Systems. </title> <journal> IEEE. Trans. Software Engineering, </journal> <volume> SE-13(1):48-54, </volume> <month> January </month> <year> 1987. </year> <month> 8 </month>
Reference-contexts: This requirement is necessary to continue operations during crashes and partitions. Note that a currency token is not analogous to a "write token" used by other systems [18, 1]. Instead, it is a hint <ref> [19] </ref> that substantially improves performance in an environment with little sharing. 2.5 Further Details 2.5.1 Interference Between Strict and Loose Reads It is the responsibility of clients to use strict reads when a file is expected to be shared.
References-found: 19

