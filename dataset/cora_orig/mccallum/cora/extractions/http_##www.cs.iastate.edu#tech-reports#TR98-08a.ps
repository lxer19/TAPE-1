URL: http://www.cs.iastate.edu/tech-reports/TR98-08a.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: ACL Eliminating Parameter Aliasing with Dynamic Dispatch  
Author: Gary T. Leavens and Olga Antropova TR #-a Gary T. Leavens and Olga Antropova. 
Degree: All rights reserved.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: Submitted for publication. Copyright c 1998, 1999 by  
Date: July 1998, revised February 1999  
Abstract: Keywords: reference parameter aliasing, global variable aliasing, multi-body procedures, dynamic dispatch, static dispatch, program verification, ACL language, alias-free programs, compiler optimizations, call-by-value and call-by-result patterns. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. Sethi A. V. Aho and J. D. Ullman. </author> <booktitle> Compilers. Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Note that there are, in general, an exponential number of such combinations. Some compiler optimizations become impossible in the presence of aliasing <ref> [1, p. 648] </ref>. The main reason for this is that static analyses tend to lose precision in the presence of aliasing; again this is because of the exponential number of potential aliasing combinations. Loss of precision in static analysis results in slower executable code. <p> For example, in Figure 1 the formal parameter names a and b in are aliases within size's body, as the type "&int" indicates that the parameter b is passed by reference. var size: int = 10; array x: int [10] = <ref> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] </ref>; proc sum (a: &int [], b: &int) imports (size) - var i: int = 1; while (i &lt; size + 1) - b := b + a [i]; - call sum (x, size) Fig. 1. Aliasing of a global variable. <p> However, Euclid does have call-by-reference. The approach taken to eliminating aliases resulting from reference parameters is to prohibit procedure calls when the actual parameters overlap. This includes structured data passed along with a component (e.g., an array a and its element a <ref> [1] </ref>). When array elements a [i] and a [j] are passed as parameters, the requirement is that i 6= j. Often i and j are computed by expressions and it is not possible to determine statically whether these expressions yield distinct results.
Reference: 2. <author> American National Standards Institute. </author> <title> Reference Manual for the Ada Programming Language, </title> <month> February </month> <year> 1983. </year> <note> ANSI/MIL-STD 1815A. Also published by Springer-Verlag as LNCS 155. </note>
Reference-contexts: For example, in Figure 1 the formal parameter names a and b in are aliases within size's body, as the type "&int" indicates that the parameter b is passed by reference. var size: int = 10; array x: int [10] = <ref> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] </ref>; proc sum (a: &int [], b: &int) imports (size) - var i: int = 1; while (i &lt; size + 1) - b := b + a [i]; - call sum (x, size) Fig. 1. Aliasing of a global variable. <p> Collections "are explicit program variables that act like the `implicit arrays' indexed by pointers" ([27], p. 14). Thus the key ideas all relate to how to eliminate aliasing for arrays. Arrays in Euclid use the "direct model" [10, Chapter 6], like Pascal and Ada <ref> [2, 5, 17] </ref>, and thus distinct declarations of arrays do not overlap. However, Euclid does have call-by-reference. The approach taken to eliminating aliases resulting from reference parameters is to prohibit procedure calls when the actual parameters overlap.
Reference: 3. <author> Olga Antropova. </author> <title> Acl | eliminating parameter aliasing with dynamic dispatch. </title> <type> Technical Report 98-07, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, July </month> <year> 1998. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: For example, in Figure 1 the formal parameter names a and b in are aliases within size's body, as the type "&int" indicates that the parameter b is passed by reference. var size: int = 10; array x: int [10] = <ref> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] </ref>; proc sum (a: &int [], b: &int) imports (size) - var i: int = 1; while (i &lt; size + 1) - b := b + a [i]; - call sum (x, size) Fig. 1. Aliasing of a global variable. <p> The ability to have programmers write non-parttern cases is an advantage of our approach over having various parameter mode annotations that would always automatically generate the appropriate code. 3 Implementation Issues An earlier version of ACL has been implemented as a semantic interpreter by the second author <ref> [3] </ref>. It is written in the purely functional language Haskell [16], which allows the interpreter to closely resemble a denotational semantic definition of the language. <p> These type inference rules were proved to satisfy a subject-reduction property <ref> [3] </ref>.
Reference: 4. <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <note> second edition, </note> <year> 1998. </year>
Reference-contexts: For example, in Figure 1 the formal parameter names a and b in are aliases within size's body, as the type "&int" indicates that the parameter b is passed by reference. var size: int = 10; array x: int [10] = <ref> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] </ref>; proc sum (a: &int [], b: &int) imports (size) - var i: int = 1; while (i &lt; size + 1) - b := b + a [i]; - call sum (x, size) Fig. 1. Aliasing of a global variable. <p> However, the result of a procedure call may depend on the procedure implementation and combination of aliases at run-time. In many contemporary programming languages parameter aliases are common. For example, C++ [29] has call-by-reference. Other object-oriented languages such as Smalltalk [11] and Java <ref> [4] </ref>, and even mostly-functional languages such as ML [21] and Scheme [28], manipulate objects indirectly, through implicit 3 references. In such languages assignment as well as parameter passing may cause aliasing. 1.2 Related Work and Treatment of Pointers In this paper we take a language design approach to eliminating aliasing.
Reference: 5. <author> John Barnes, Ben Brosgol, et al. </author> <title> Ada 95 rationale. the language. the standard libraries. </title> <type> Technical report, </type> <institution> Itemetrics Inc., </institution> <address> 733 Concord Av, Cambridge, MA 02138, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: For example, in Figure 1 the formal parameter names a and b in are aliases within size's body, as the type "&int" indicates that the parameter b is passed by reference. var size: int = 10; array x: int [10] = <ref> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] </ref>; proc sum (a: &int [], b: &int) imports (size) - var i: int = 1; while (i &lt; size + 1) - b := b + a [i]; - call sum (x, size) Fig. 1. Aliasing of a global variable. <p> Collections "are explicit program variables that act like the `implicit arrays' indexed by pointers" ([27], p. 14). Thus the key ideas all relate to how to eliminate aliasing for arrays. Arrays in Euclid use the "direct model" [10, Chapter 6], like Pascal and Ada <ref> [2, 5, 17] </ref>, and thus distinct declarations of arrays do not overlap. However, Euclid does have call-by-reference. The approach taken to eliminating aliases resulting from reference parameters is to prohibit procedure calls when the actual parameters overlap.
Reference: 6. <author> Daniel G. Bobrow, Kenneth Kahn, George Kiczales, Larry Masinter, Mark Stefik, and Frank Zdybel. Commonloops: </author> <title> Merging lisp and object-oriented programming. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 17-29, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: For example, in Figure 1 the formal parameter names a and b in are aliases within size's body, as the type "&int" indicates that the parameter b is passed by reference. var size: int = 10; array x: int [10] = <ref> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] </ref>; proc sum (a: &int [], b: &int) imports (size) - var i: int = 1; while (i &lt; size + 1) - b := b + a [i]; - call sum (x, size) Fig. 1. Aliasing of a global variable. <p> In particular it eliminates the aliasing due to reference parameters. It is different from the related work discussed above in that it automates calling an appropriate procedure body based on the aliasing combination that occurs dynamically. It does this using a variant of multimethod dispatch <ref> [6] </ref> [7] [22]. (Languages that use multimethod dispatch include CLOS [26] and Cecil [8].) 2.1 Our Approach: Dispatch Based on Aliasing Patterns To allow for dynamic dispatch to different procedure bodies, programmers can write multiple alternative bodies for a procedure|up to one for each possible combination of aliases among the parameters
Reference: 7. <author> Giuseppe Castagna. </author> <title> Object-Oriented Programming: A Unified Foundation. </title> <booktitle> Progress in Theoretical Computer Science. </booktitle> <publisher> Birkhauser, </publisher> <address> Boston, </address> <year> 1997. </year>
Reference-contexts: For example, in Figure 1 the formal parameter names a and b in are aliases within size's body, as the type "&int" indicates that the parameter b is passed by reference. var size: int = 10; array x: int [10] = <ref> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] </ref>; proc sum (a: &int [], b: &int) imports (size) - var i: int = 1; while (i &lt; size + 1) - b := b + a [i]; - call sum (x, size) Fig. 1. Aliasing of a global variable. <p> In particular it eliminates the aliasing due to reference parameters. It is different from the related work discussed above in that it automates calling an appropriate procedure body based on the aliasing combination that occurs dynamically. It does this using a variant of multimethod dispatch [6] <ref> [7] </ref> [22]. (Languages that use multimethod dispatch include CLOS [26] and Cecil [8].) 2.1 Our Approach: Dispatch Based on Aliasing Patterns To allow for dynamic dispatch to different procedure bodies, programmers can write multiple alternative bodies for a procedure|up to one for each possible combination of aliases among the parameters and
Reference: 8. <author> Craig Chambers. </author> <title> Object-oriented multi-methods in Cecil. </title> <editor> In Ole Lehrmann Mad-sen, editor, </editor> <booktitle> ECOOP '92, European Conference on Object-Oriented Programming, Utrecht, The Netherlands, volume 615 of Lecture Notes in Computer Science, </booktitle> <pages> pages 33-56. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: For example, in Figure 1 the formal parameter names a and b in are aliases within size's body, as the type "&int" indicates that the parameter b is passed by reference. var size: int = 10; array x: int [10] = <ref> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] </ref>; proc sum (a: &int [], b: &int) imports (size) - var i: int = 1; while (i &lt; size + 1) - b := b + a [i]; - call sum (x, size) Fig. 1. Aliasing of a global variable. <p> It is different from the related work discussed above in that it automates calling an appropriate procedure body based on the aliasing combination that occurs dynamically. It does this using a variant of multimethod dispatch [6] [7] [22]. (Languages that use multimethod dispatch include CLOS [26] and Cecil <ref> [8] </ref>.) 2.1 Our Approach: Dispatch Based on Aliasing Patterns To allow for dynamic dispatch to different procedure bodies, programmers can write multiple alternative bodies for a procedure|up to one for each possible combination of aliases among the parameters and global variables.
Reference: 9. <author> David G. Clarke, John M. Potter, and James Noble. </author> <title> Ownership types for flexible alias protection. </title> <booktitle> In OOPSLA '98 Conference Proceedings, volume 33(10) of ACM SIGPLAN Notices, </booktitle> <pages> pages 48-64. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1998. </year>
Reference-contexts: For example, in Figure 1 the formal parameter names a and b in are aliases within size's body, as the type "&int" indicates that the parameter b is passed by reference. var size: int = 10; array x: int [10] = <ref> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] </ref>; proc sum (a: &int [], b: &int) imports (size) - var i: int = 1; while (i &lt; size + 1) - b := b + a [i]; - call sum (x, size) Fig. 1. Aliasing of a global variable. <p> It would be interesting to study how the idea would apply to languages that operate on more complex objects, as occur in object-oriented languages. Recently several designs for object-oriented languages that deal with aliasing have appeared <ref> [9, 14, 15, 25, 30] </ref>. Since these works concentrate on other kinds of aliasing, as opposed to parameter aliasing, it would be interesting to combine our ideas with theirs in a single language. 16 Acknowledgements Thanks to Mark Utting for discussions about aliasing.
Reference: 10. <author> Daniel P. Friedman, Mitchell Wand, and Christopher T. Haynes. </author> <title> Essentials of Programming Languages. </title> <publisher> McGraw-Hill Book Co., </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: For example, in Figure 1 the formal parameter names a and b in are aliases within size's body, as the type "&int" indicates that the parameter b is passed by reference. var size: int = 10; array x: int <ref> [10] </ref> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; proc sum (a: &int [], b: &int) imports (size) - var i: int = 1; while (i &lt; size + 1) - b := b + a [i]; - call sum (x, size) Fig. 1. <p> For example, in Figure 1 the formal parameter names a and b in are aliases within size's body, as the type "&int" indicates that the parameter b is passed by reference. var size: int = 10; array x: int [10] = <ref> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] </ref>; proc sum (a: &int [], b: &int) imports (size) - var i: int = 1; while (i &lt; size + 1) - b := b + a [i]; - call sum (x, size) Fig. 1. Aliasing of a global variable. <p> Collections "are explicit program variables that act like the `implicit arrays' indexed by pointers" ([27], p. 14). Thus the key ideas all relate to how to eliminate aliasing for arrays. Arrays in Euclid use the "direct model" <ref> [10, Chapter 6] </ref>, like Pascal and Ada [2, 5, 17], and thus distinct declarations of arrays do not overlap. However, Euclid does have call-by-reference. The approach taken to eliminating aliases resulting from reference parameters is to prohibit procedure calls when the actual parameters overlap.
Reference: 11. <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80, The Language and its Implementation. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1983. </year>
Reference-contexts: However, the result of a procedure call may depend on the procedure implementation and combination of aliases at run-time. In many contemporary programming languages parameter aliases are common. For example, C++ [29] has call-by-reference. Other object-oriented languages such as Smalltalk <ref> [11] </ref> and Java [4], and even mostly-functional languages such as ML [21] and Scheme [28], manipulate objects indirectly, through implicit 3 references.
Reference: 12. <author> D. Gries and G. Levin. </author> <title> Assignment and the procedure call proof rules. </title> <journal> TOPLAS, </journal> <volume> 2(4) </volume> <pages> 564-579, </pages> <year> 1980. </year>
Reference-contexts: The main problem is that verification of procedure correctness when aliasing is possible involves separate proofs for all possible aliasing combinations among formal parameters, and among formal parameters and global variables <ref> [12] </ref>. Note that there are, in general, an exponential number of such combinations. Some compiler optimizations become impossible in the presence of aliasing [1, p. 648].
Reference: 13. <author> C. A. R. Hoare and N. Wirth. </author> <title> An axiomatic definition of the programming language pascal. </title> <journal> Acta Informatica, </journal> <volume> 2(4) </volume> <pages> 335-355, </pages> <year> 1973. </year> <month> 17 </month>
Reference-contexts: In this paper we concentrate on aliases generated by reference parameters. (We discuss how other kinds of aliasing are treated in the related work section below.) Aliases and mutation make writing programs and reasoning about their correctness more difficult <ref> [13, 23] </ref>. The main problem is that verification of procedure correctness when aliasing is possible involves separate proofs for all possible aliasing combinations among formal parameters, and among formal parameters and global variables [12]. Note that there are, in general, an exponential number of such combinations. <p> In such languages assignment as well as parameter passing may cause aliasing. 1.2 Related Work and Treatment of Pointers In this paper we take a language design approach to eliminating aliasing. This follows the design of Euclid [18, 20, 27, 32], which is a variant of Pascal <ref> [13, 19, 31] </ref> designed to aid program verification. Eliminating aliasing was an important design goal of Euclid. According to its authors, Euclid "... demonstrated that it is possible to completely eliminate aliasing in a practical programming language" [27, p. 16].
Reference: 14. <author> John Hogg. </author> <title> Islands: Aliasing protection in object-oriented languages. </title> <booktitle> In Proceed--ings of the OOPSLA '91 Conference on Object-oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 271-285, </pages> <month> November </month> <year> 1991. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 26, number 11. </volume>
Reference-contexts: It would be interesting to study how the idea would apply to languages that operate on more complex objects, as occur in object-oriented languages. Recently several designs for object-oriented languages that deal with aliasing have appeared <ref> [9, 14, 15, 25, 30] </ref>. Since these works concentrate on other kinds of aliasing, as opposed to parameter aliasing, it would be interesting to combine our ideas with theirs in a single language. 16 Acknowledgements Thanks to Mark Utting for discussions about aliasing.
Reference: 15. <author> John Hogg, Doug Lea, Alan Wills, Dennis deChampeaux, and Richard Holt. </author> <title> The Geneva Convention on the treatment of object aliasing. </title> <journal> OOPS Messenger, </journal> <volume> 3(2) </volume> <pages> 11-16, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: It would be interesting to study how the idea would apply to languages that operate on more complex objects, as occur in object-oriented languages. Recently several designs for object-oriented languages that deal with aliasing have appeared <ref> [9, 14, 15, 25, 30] </ref>. Since these works concentrate on other kinds of aliasing, as opposed to parameter aliasing, it would be interesting to combine our ideas with theirs in a single language. 16 Acknowledgements Thanks to Mark Utting for discussions about aliasing.
Reference: 16. <editor> Paul Hudak, Simon Peyton Jones, Philip Wadler, et al. </editor> <title> Report on the programming language Haskell: A non-strict, purely functional language, version 1.2. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: It is written in the purely functional language Haskell <ref> [16] </ref>, which allows the interpreter to closely resemble a denotational semantic definition of the language. That version of ACL did not include defined indexes, constant references, or the automatic generation of bodies for omitted aliasing combinations (either for constant reference overlap or error cases).
Reference: 17. <author> International Organization for Standardization. </author> <title> Ada 95 Reference Manual. The Language. The Standard Libraries, </title> <month> January </month> <year> 1995. ANSI/ISO/IEC-8652:1995. </year>
Reference-contexts: Collections "are explicit program variables that act like the `implicit arrays' indexed by pointers" ([27], p. 14). Thus the key ideas all relate to how to eliminate aliasing for arrays. Arrays in Euclid use the "direct model" [10, Chapter 6], like Pascal and Ada <ref> [2, 5, 17] </ref>, and thus distinct declarations of arrays do not overlap. However, Euclid does have call-by-reference. The approach taken to eliminating aliases resulting from reference parameters is to prohibit procedure calls when the actual parameters overlap.
Reference: 18. <author> Butler W. Lampson, James L. Horning, Ralph L. London, James G. Mitchell, and Gerald J. Popek. </author> <title> Report on the programming language euclid. </title> <type> Technical Report CSL-81-12, </type> <institution> Xerox Palo Alto Research Centers, </institution> <month> October </month> <year> 1981. </year> <journal> Also SIGPLAN Notices, </journal> <volume> 12(2), </volume> <month> February, </month> <year> 1977. </year>
Reference-contexts: In such languages assignment as well as parameter passing may cause aliasing. 1.2 Related Work and Treatment of Pointers In this paper we take a language design approach to eliminating aliasing. This follows the design of Euclid <ref> [18, 20, 27, 32] </ref>, which is a variant of Pascal [13, 19, 31] designed to aid program verification. Eliminating aliasing was an important design goal of Euclid. According to its authors, Euclid "... demonstrated that it is possible to completely eliminate aliasing in a practical programming language" [27, p. 16].
Reference: 19. <author> Henry Ledgard. </author> <title> The American Pascal Standard: with Annotations. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1984. </year> <note> Contains ANSI/IEEE 770X3.97-1983. </note>
Reference-contexts: In such languages assignment as well as parameter passing may cause aliasing. 1.2 Related Work and Treatment of Pointers In this paper we take a language design approach to eliminating aliasing. This follows the design of Euclid [18, 20, 27, 32], which is a variant of Pascal <ref> [13, 19, 31] </ref> designed to aid program verification. Eliminating aliasing was an important design goal of Euclid. According to its authors, Euclid "... demonstrated that it is possible to completely eliminate aliasing in a practical programming language" [27, p. 16].
Reference: 20. <author> R. L. London, J. V. Guttag, J. J. Horning, B. W. Lampson, J. G. Mitchell, and G. J. Popek. </author> <title> Proof rules for the programming language euclid. </title> <journal> Acta Informatica, </journal> <volume> 10(1) </volume> <pages> 1-26, </pages> <year> 1978. </year>
Reference-contexts: In such languages assignment as well as parameter passing may cause aliasing. 1.2 Related Work and Treatment of Pointers In this paper we take a language design approach to eliminating aliasing. This follows the design of Euclid <ref> [18, 20, 27, 32] </ref>, which is a variant of Pascal [13, 19, 31] designed to aid program verification. Eliminating aliasing was an important design goal of Euclid. According to its authors, Euclid "... demonstrated that it is possible to completely eliminate aliasing in a practical programming language" [27, p. 16].
Reference: 21. <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: In many contemporary programming languages parameter aliases are common. For example, C++ [29] has call-by-reference. Other object-oriented languages such as Smalltalk [11] and Java [4], and even mostly-functional languages such as ML <ref> [21] </ref> and Scheme [28], manipulate objects indirectly, through implicit 3 references. In such languages assignment as well as parameter passing may cause aliasing. 1.2 Related Work and Treatment of Pointers In this paper we take a language design approach to eliminating aliasing.
Reference: 22. <author> David A. Moon. </author> <title> Object-oriented programming with Flavors. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 1-8, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: In particular it eliminates the aliasing due to reference parameters. It is different from the related work discussed above in that it automates calling an appropriate procedure body based on the aliasing combination that occurs dynamically. It does this using a variant of multimethod dispatch [6] [7] <ref> [22] </ref>. (Languages that use multimethod dispatch include CLOS [26] and Cecil [8].) 2.1 Our Approach: Dispatch Based on Aliasing Patterns To allow for dynamic dispatch to different procedure bodies, programmers can write multiple alternative bodies for a procedure|up to one for each possible combination of aliases among the parameters and global
Reference: 23. <author> Caroll Morgan. </author> <title> Procedures, parameters and abstraction: separate concerns. </title> <publisher> In Morgan and Vickers [24], </publisher> <pages> pages 47-58. </pages>
Reference-contexts: In this paper we concentrate on aliases generated by reference parameters. (We discuss how other kinds of aliasing are treated in the related work section below.) Aliases and mutation make writing programs and reasoning about their correctness more difficult <ref> [13, 23] </ref>. The main problem is that verification of procedure correctness when aliasing is possible involves separate proofs for all possible aliasing combinations among formal parameters, and among formal parameters and global variables [12]. Note that there are, in general, an exponential number of such combinations. <p> Because of this, proof rules for languages with value-result and result parameters "usually" consider passing the same location to multiple result parameters to be "invalid" <ref> [23, p. 57] </ref>. That is, the actual parameters passed by value-result or result must not overlap, because copying back the results will not work in a verifiable way unless the actuals do not overlap.
Reference: 24. <author> Carroll Morgan and Trevor Vickers, </author> <title> editors. </title> <booktitle> On the refinement calculus. Formal approaches of computing and information technology series. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference: 25. <author> James Noble, Jan Vitek, and John Potter. </author> <title> Flexible alias protection. </title> <editor> In Eric Jul, editor, </editor> <booktitle> ECOOP '98 - Object-Oriented Programming, 12th European Conference, </booktitle> <address> Brussels, Belgium, </address> <booktitle> volume 1445 of Lecture Notes in Computer Science, </booktitle> <pages> pages 158-185. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1998. </year>
Reference-contexts: It would be interesting to study how the idea would apply to languages that operate on more complex objects, as occur in object-oriented languages. Recently several designs for object-oriented languages that deal with aliasing have appeared <ref> [9, 14, 15, 25, 30] </ref>. Since these works concentrate on other kinds of aliasing, as opposed to parameter aliasing, it would be interesting to combine our ideas with theirs in a single language. 16 Acknowledgements Thanks to Mark Utting for discussions about aliasing.
Reference: 26. <author> Andreas Paepcke. </author> <title> Object-Oriented Programming: The CLOS Perspective. </title> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: It is different from the related work discussed above in that it automates calling an appropriate procedure body based on the aliasing combination that occurs dynamically. It does this using a variant of multimethod dispatch [6] [7] [22]. (Languages that use multimethod dispatch include CLOS <ref> [26] </ref> and Cecil [8].) 2.1 Our Approach: Dispatch Based on Aliasing Patterns To allow for dynamic dispatch to different procedure bodies, programmers can write multiple alternative bodies for a procedure|up to one for each possible combination of aliases among the parameters and global variables.
Reference: 27. <author> G. J. Popek, J. J. Horning, B. W. Lampson, J. G. Mitchell, and R. L. </author> <title> London. Notes on the design of euclid. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 12(3) </volume> <pages> 11-18, </pages> <month> March </month> <year> 1977. </year> <booktitle> Proceedings of an ACM Conference on Language Design for Reliable Software, </booktitle> <address> Raliegh, North Carolina, </address> <month> March, </month> <year> 1977. </year>
Reference-contexts: In such languages assignment as well as parameter passing may cause aliasing. 1.2 Related Work and Treatment of Pointers In this paper we take a language design approach to eliminating aliasing. This follows the design of Euclid <ref> [18, 20, 27, 32] </ref>, which is a variant of Pascal [13, 19, 31] designed to aid program verification. Eliminating aliasing was an important design goal of Euclid. According to its authors, Euclid "... demonstrated that it is possible to completely eliminate aliasing in a practical programming language" [27, p. 16]. <p> Eliminating aliasing was an important design goal of Euclid. According to its authors, Euclid "... demonstrated that it is possible to completely eliminate aliasing in a practical programming language" <ref> [27, p. 16] </ref>. Pointer variables and pointer assignments are allowed in Euclid, but pointers are considered to be indexes into a "collection" of objects of the same type. Collections "are explicit program variables that act like the `implicit arrays' indexed by pointers" ([27], p. 14). <p> Often i and j are computed by expressions and it is not possible to determine statically whether these expressions yield distinct results. So Euclid requires the compiler "to generate a legality assertion to guarantee their distinctness" <ref> [27, p. 14] </ref>. This legality assertion is checked at run-time. For global variables, Euclid requires explicit importation of those that are used by a procedure. Like parameters, imported globals should not overlap with the actual parameters. <p> To avoid unnecessary alias combinations with global variables, we adopt Eu-clid's idea of explicitly importing global variables in procedures <ref> [27] </ref>. (Functions and procedure names are implicitly available in procedure bodies since they cannot be aliased to variables in the language that we study.) In general, dynamic dispatch must be used to find the appropriate procedure body to execute since the concrete alias combination among the parameters often cannot be determined <p> We claim, however, that ACL programs need be no slower in the worst case than equivalent Euclid programs <ref> [27] </ref>. This claim is true despite the fact that in Euclid's procedure calls always statically dispatch to exactly one body. <p> Our approach allows freedom from aliasing without making it much more difficult to use procedures and without sacrificing the efficiency of call-by-reference. In essence, ACL makes the Euclid <ref> [27] </ref> approach to avoiding parameter aliasing practical by taking the responsibility for alias analysis away from procedure clients and giving it to the procedure's implementor. This makes the work of a procedure's clients easier. Yet, like Euclid, ACL retains both call-by-reference and the benefits of eliminating aliasing. <p> This makes the work of a procedure's clients easier. Yet, like Euclid, ACL retains both call-by-reference and the benefits of eliminating aliasing. Euclid also had pointers and pointer variables, but these could be treated in a similar way in ACL <ref> [27, 30] </ref>. It may be that the most important benefit is the greatly increased opportunity for code optimization that the lack of aliasing allows. However, whether this is true in practice remains to be seen.
Reference: 28. <author> Jonathan Rees, William Clinger, H. Abelson, N. I. Adams IV, D. H. Bartley, G. Brooks, R. K. Dybvig, D. P. Friedman, R. Halstead, C. Hanson, C. T. Haynes, E. Kohlbecker, D. Oxley, K. M. Pitman, G. J. Rozas, G. J. Sussman, and M. Wand. </author> <title> Revised 3 report on the algorithmic language scheme. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(12) </volume> <pages> 37-79, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: In many contemporary programming languages parameter aliases are common. For example, C++ [29] has call-by-reference. Other object-oriented languages such as Smalltalk [11] and Java [4], and even mostly-functional languages such as ML [21] and Scheme <ref> [28] </ref>, manipulate objects indirectly, through implicit 3 references. In such languages assignment as well as parameter passing may cause aliasing. 1.2 Related Work and Treatment of Pointers In this paper we take a language design approach to eliminating aliasing.
Reference: 29. <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language: Third Edition. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1997. </year>
Reference-contexts: However, the result of a procedure call may depend on the procedure implementation and combination of aliases at run-time. In many contemporary programming languages parameter aliases are common. For example, C++ <ref> [29] </ref> has call-by-reference. Other object-oriented languages such as Smalltalk [11] and Java [4], and even mostly-functional languages such as ML [21] and Scheme [28], manipulate objects indirectly, through implicit 3 references.
Reference: 30. <author> Mark Utting. </author> <title> Reasoning about aliasing. </title> <booktitle> In Proceedings of the Fourth Australasian Refinement Workshop (ARW-95), </booktitle> <pages> pages 195-211. </pages> <institution> School of Computer Science and 18 Engineering, The University of New South Wales, </institution> <month> April </month> <year> 1995. </year> <note> Available from http://www.cs.waikato.ac.nz/~marku </note>
Reference-contexts: This legality assertion is checked at run-time. For global variables, Euclid requires explicit importation of those that are used by a procedure. Like parameters, imported globals should not overlap with the actual parameters. Recent work on eliminating aliasing in object-oriented languages by Utting extends Euclid's idea of collections <ref> [30] </ref>. In Utting's work, complex objects (possibly sharing memory locations) are viewed as a set of disjoint collections (local stores) of homogeneous objects. Local stores are treated as arrays and pointers as indexes. <p> This makes the work of a procedure's clients easier. Yet, like Euclid, ACL retains both call-by-reference and the benefits of eliminating aliasing. Euclid also had pointers and pointer variables, but these could be treated in a similar way in ACL <ref> [27, 30] </ref>. It may be that the most important benefit is the greatly increased opportunity for code optimization that the lack of aliasing allows. However, whether this is true in practice remains to be seen. <p> It would be interesting to study how the idea would apply to languages that operate on more complex objects, as occur in object-oriented languages. Recently several designs for object-oriented languages that deal with aliasing have appeared <ref> [9, 14, 15, 25, 30] </ref>. Since these works concentrate on other kinds of aliasing, as opposed to parameter aliasing, it would be interesting to combine our ideas with theirs in a single language. 16 Acknowledgements Thanks to Mark Utting for discussions about aliasing.
Reference: 31. <author> N. Wirth. </author> <title> The programming language pascal. </title> <journal> Acta Informatica, </journal> <volume> 1(1) </volume> <pages> 35-63, </pages> <year> 1971. </year>
Reference-contexts: In such languages assignment as well as parameter passing may cause aliasing. 1.2 Related Work and Treatment of Pointers In this paper we take a language design approach to eliminating aliasing. This follows the design of Euclid [18, 20, 27, 32], which is a variant of Pascal <ref> [13, 19, 31] </ref> designed to aid program verification. Eliminating aliasing was an important design goal of Euclid. According to its authors, Euclid "... demonstrated that it is possible to completely eliminate aliasing in a practical programming language" [27, p. 16].
Reference: 32. <author> D. B. Wortman and J. R. Curdy. </author> <title> Early experience with euclid. </title> <booktitle> In Fifth International Conference on Software Engineering. IEEE, </booktitle> <year> 1980. </year> <month> 19 </month>
Reference-contexts: In such languages assignment as well as parameter passing may cause aliasing. 1.2 Related Work and Treatment of Pointers In this paper we take a language design approach to eliminating aliasing. This follows the design of Euclid <ref> [18, 20, 27, 32] </ref>, which is a variant of Pascal [13, 19, 31] designed to aid program verification. Eliminating aliasing was an important design goal of Euclid. According to its authors, Euclid "... demonstrated that it is possible to completely eliminate aliasing in a practical programming language" [27, p. 16].
References-found: 32

