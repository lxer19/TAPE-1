URL: http://seclab.cs.ucdavis.edu/~samorodi/papers/USENIX/technical97/banerji.ps
Refering-URL: http://seclab.cs.ucdavis.edu/~samorodi/papers/USENIX/technical97/
Root-URL: http://www.cs.ucdavis.edu
Email: Email: office@usenix.org  
Title: Protected Shared Libraries A New Approach to Modularity and Sharing  
Phone: 1. Phone: 510 528-8649 2. FAX: 510 548-5738 3.  4.  
Author: Arindam Banerji, John Michael Tracey, David L. Cohn 
Affiliation: Hewlett-Packard Laboratories, IBM T.J. Watson Research Center,University of Notre Dame  
Web: WWW URL: http://www.usenix.org  
Date: January 6-10, 1997  
Note: The following paper was originally published in the Proceedings of the USENIX 1997 Annual Technical Conference Anaheim, California,  For more information about USENIX Association contact:  
Abstract-found: 0
Intro-found: 1
Reference: [Acetta et al. 86] <author> Acetta, M., Baron, R., Golub, D., Rashid, R., Tevanian, A. and Young, M. </author> <title> Mach: A New Kernel Foundation for UNIX Development. </title> <booktitle> In Proceedings of the Summer 1986 USENIX Conference (Atlanta, </booktitle> <address> GA. </address> <month> July). </month> <booktitle> The USENIX Association, </booktitle> <address> Berke-ley, CA, </address> <year> 1986, </year> <pages> pp. 93-112. </pages>
Reference-contexts: Protection can be enforced through a variety of means including separate address spaces <ref> [Acetta et al. 86] </ref>, language support [Nelson 91], and post-processing of binary code [Wahbe 93]. Each of these approaches has been used to increase modularity and security and to facilitate debugging of large software systems. <p> Partial address space switches were implemented quite carefully in the prototype to minimize overhead and maximize performance. Page table entries that must be switched during a domain transition are preallocated. These entries are maintained in software using a sparse representation technique <ref> [Acetta et al. 86] </ref>, so a large number of pages can be represented using a small number of entries. The trampoline code only switches a couple of pointers to incorporate these new entries into the software maintained page tables.
Reference: [Banerji et al. 94] <editor> Banerji, A. et al. </editor> <title> Shared Objects and vtbl Placement - Revisited. </title> <journal> Journal of C Language Translation, </journal> <month> September </month> <year> 1994, </year> <pages> pp. </pages> <month> 31-46.. </month>
Reference-contexts: Sharing is also indicated by structural considerations. Cross-domain sharing has been used to improve structure in various parallel programming models [Scott et al. 90], and to support persistent databases [Bogle 94] [Chase 94] and shared object frameworks [Campbell et al. 93] <ref> [Banerji et al. 94] </ref>. Sharing enables cooperation between domains with limited trust [Chase 94]. Thus, sharing can be used to support a variety of interactions including producer-consumer, non-intrusive monitoring, asynchronous service providers [Bogle 94], shared pipes, stateless servers with client maintained state, and shared objects exported by servers [IBM 93]. <p> There is a third reason for sharing across protection domains. Most implementations of cross-domain object interactions include a fair amount of overhead for the locally distributed case [IBM 93] [Janssen 95]. Thus, sharing object instances <ref> [Banerji et al. 94] </ref> and passing enclosures between protection domains on the same machine are usually inefficient. Most of these problems may be solved by judicious sharing of data and addresses between interacting protection domains. <p> First, the ability to share pointer-rich data across domains is attractive. This ability has been found to be useful for persistent stores [Chase 94], shared C++ objects <ref> [Banerji et al. 94] </ref>, distributed shared data and system software. The obvious argument against uniform sharing is the need to reserve portions of an address space. <p> One possible use of Domain CSLs is for sharing of C++ objects that contain pointers to virtual function tables (vtbls). In this case, the vtbl must be located at the same address in every domain, but its contents must be unique per domain <ref> [Banerji et al. 94] </ref>. Thus, the address of a function table can be shared while ensuring the contents of the table are unique per domain. 3.4 Potential Uses of PSLs Protected Shared LIbraries are a valuable tool for structuring systems.
Reference: [Banerji et al. 94a] <author> Banerji, A., Kulkarni, D. and Cohn, D. </author> <title> A Framework for Building Extensible Class Libraries., </title> <booktitle> In Proceedings of the 1994 USENIX C++ Conference, </booktitle> <year> 1994, </year> <pages> pp. 26-41. </pages>
Reference-contexts: CSLs allow programmers to share information in libraries and control the exact nature of sharing. This opens up possibilities for easily creating UNIX u_block [Goodheart & Cox 92] implementations, sharing I/O buffers across protection domains [Khalidi & Nelson 93] and sharing closures and objects across protection boundaries <ref> [Banerji et al. 94a] </ref>. The remainder of this paper proceeds as follows. The next section presents the motivation for Protected Shared Libraries, both to improve modularity and to facilitate sharing. After that, PSL semantics are described. Implementation issues are discussed in Section 4. <p> Our focus on using passive abstractions to represent protection domains is based both on the experience of others [Carter et al. 93] as well as our own <ref> [Banerji et al. 94a] </ref> that clearly demonstrate the advantages of passive modularity.
Reference: [Banerji 96] <editor> Banerji, A. et al. </editor> <title> Quantitative Analysis of Protection Options. </title> <type> Technical Report (unnumbered), </type> <institution> University of Notre Dame, Notre Dame, IN, </institution> <year> 1996. </year>
Reference-contexts: The next subsection begins with a comparison of null-RPC times. This is followed by a comparison of PSLs with other competitive protection schemes. Finally, the section ends with a breakdown of PSL call costs. A more thorough analysis of PSL performance can be found in <ref> [Banerji 96] </ref>. 5.1 Null-RPC Benchmark Table 2 shows the null RPC times for several RPC implementations in AIX 3.2.5 on an RS/6000 Model 530 with a relatively slow 25 Mhz POWER processor. The first two numbers are for classic user-level IPC; the third is for hand-off scheduling [Black 89].
Reference: [Batlivala et al. 92] <author> Batlivala, N., Gleeson, B., Hamrick, J., Lurndal, S., Price, D., Soddy, J. and Abrossimov, V. </author> <title> Experience with SVR4 Over CHORUS. </title> <booktitle> In Proceedings of the USENIX Workshop on Micro-Kernels and Other Kernel Architectures (Seattle, </booktitle> <address> WA. </address> <month> April 27, </month> <title> 28). </title> <booktitle> The USENIX Association, </booktitle> <address> Berkeley, CA, </address> <year> 1992, </year> <pages> pp. 223-241. </pages>
Reference-contexts: This approach has been applied to a number of commercial operating systems <ref> [Batlivala et al. 92] </ref> [Bor-gendale at al. 94] [Golub et al. 90] [Golub et al. 93] [Malan et al. 90] [Phelan et al. 93] [Weicek et al. 93]. The second approach is to design an entirely new operating system emphasizing exibility using object-oriented technology which generally includes language support.
Reference: [Bershad, 90] <author> Bershad, B. </author> <title> Lightweight Remote Procedure Call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> *(1), </volume> <month> February, </month> <year> 1990. </year>
Reference: [Bershad et al. 95] <author> Bershad, B. N., Saveag, A., Par-dyak, P., Sirer, E. G., Fiuczynski, M. E., Becker, D., Chambers, C. and Eggers, S. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating System Principles (Copper Mountain Resort, </booktitle> <publisher> CO. </publisher> <month> Dec. </month> <pages> 3-6. </pages> <publisher> ACM Press, </publisher> <address> NY, </address> <year> 1995, </year> <pages> pp. 267-284. </pages> <note> (http:// www.cs.washington.edu/research/projects/spin) </note>
Reference-contexts: The second approach is to design an entirely new operating system emphasizing exibility using object-oriented technology which generally includes language support. The second approach has primarily been relegated to academic and research environments <ref> [Bershad et al. 95] </ref> [Campbell et al. 93] [Yokote 92]. 1. David Cohn is currently on sabbatical at the IBM Corporation, Sommers, NY. This work was supported by a grant form the IBM Corporation. Neither of these approaches features adequate exi-bility, efficiency, and ease of use.
Reference: [Black 89] <author> Black, D. </author> <title> Scheduling support for Con-currency and Parallelism in the Mach Operating System. </title> <note> Unpublished. </note>
Reference-contexts: Most work regarding enforcement of protection boundaries in current operating system software, both user-level and kernel-level, has been focussed on improving the efficiency of cross-domain invocations. Invocation times have been significantly reduced by handoff scheduling <ref> [Black 89] </ref> and thread migration [Bershad 90] [Lepreau et al. 94] [Hamilton & Kou-giouris 93]. These protection domains, however, have typically been associated with processes. <p> The first two numbers are for classic user-level IPC; the third is for hand-off scheduling <ref> [Black 89] </ref>. The fourth number indicates thread migration is a bit slower than a PSL call due to resource handling overhead.
Reference: [Black et al. 92] <editor> Black, D. et al. </editor> <booktitle> Microkernel Operating System Architecture and Mach. In Proceedings of the USENIX Workshop on Micro-Kernels and Other Kernel Architectures (Seattle, </booktitle> <address> WA. </address> <month> April 27, </month> <title> 28). </title> <booktitle> The USENIX Association, </booktitle> <address> Berkeley, CA, </address> <year> 1992, </year> <pages> pp. 11-30. </pages>
Reference-contexts: The first is to separate an existing operating system kernel into a microkernel that provides a basic set of fundamental constructs and one or more user-level server tasks which run on top of the microkernel and provide operating system services <ref> [Black et al. 92] </ref> [Rosier at al. 92]. This approach has been applied to a number of commercial operating systems [Batlivala et al. 92] [Bor-gendale at al. 94] [Golub et al. 90] [Golub et al. 93] [Malan et al. 90] [Phelan et al. 93] [Weicek et al. 93].
Reference: [Bogle 94] <author> Bogle, P., and Liskov, B. </author> <title> Reducing Cross Domain Call Overhead Using Batched Futures. </title> <booktitle> In Proceedings of OOPSLA 94, ACM, </booktitle> <year> 1994. </year>
Reference-contexts: Discussion of these observations continues in the next subsection. Following that, the overall PSL design approach is described. 2.1 Shared Libraries as Protection Domains Enforced protection boundaries have been found to be a very effective software structuring tool especially for large systems [Nelson 91] <ref> [Bogle 94] </ref> [Khalidi & Nelson 93] [Chase 94]. Protection can be enforced through a variety of means including separate address spaces [Acetta et al. 86], language support [Nelson 91], and post-processing of binary code [Wahbe 93]. <p> Efficiency concerns, therefore, make a compelling case for sharing. Sharing is also indicated by structural considerations. Cross-domain sharing has been used to improve structure in various parallel programming models [Scott et al. 90], and to support persistent databases <ref> [Bogle 94] </ref> [Chase 94] and shared object frameworks [Campbell et al. 93] [Banerji et al. 94]. Sharing enables cooperation between domains with limited trust [Chase 94]. Thus, sharing can be used to support a variety of interactions including producer-consumer, non-intrusive monitoring, asynchronous service providers [Bogle 94], shared pipes, stateless servers with <p> 90], and to support persistent databases <ref> [Bogle 94] </ref> [Chase 94] and shared object frameworks [Campbell et al. 93] [Banerji et al. 94]. Sharing enables cooperation between domains with limited trust [Chase 94]. Thus, sharing can be used to support a variety of interactions including producer-consumer, non-intrusive monitoring, asynchronous service providers [Bogle 94], shared pipes, stateless servers with client maintained state, and shared objects exported by servers [IBM 93]. There is a third reason for sharing across protection domains. Most implementations of cross-domain object interactions include a fair amount of overhead for the locally distributed case [IBM 93] [Janssen 95].
Reference: [Borgendale et al. 94] <author> Borgendale, K., Bramnick, A. and Holland, I. M. </author> <title> Workplace OS: What is the OS/2 Personality? March 24, </title> <year> 1994. </year>
Reference: [Campbell et al. 93] <author> Campbell, R. et al. </author> <title> Designing and Implementing Choices: An Object-Oriented System in C++. </title> <journal> Communications of the ACM, </journal> <volume> 36(9), </volume> <year> 1993, </year> <pages> pp. 117-126. </pages>
Reference-contexts: The second approach is to design an entirely new operating system emphasizing exibility using object-oriented technology which generally includes language support. The second approach has primarily been relegated to academic and research environments [Bershad et al. 95] <ref> [Campbell et al. 93] </ref> [Yokote 92]. 1. David Cohn is currently on sabbatical at the IBM Corporation, Sommers, NY. This work was supported by a grant form the IBM Corporation. Neither of these approaches features adequate exi-bility, efficiency, and ease of use. <p> Efficiency concerns, therefore, make a compelling case for sharing. Sharing is also indicated by structural considerations. Cross-domain sharing has been used to improve structure in various parallel programming models [Scott et al. 90], and to support persistent databases [Bogle 94] [Chase 94] and shared object frameworks <ref> [Campbell et al. 93] </ref> [Banerji et al. 94]. Sharing enables cooperation between domains with limited trust [Chase 94].
Reference: [Carter et al. 93] <author> Carter, J. et al. </author> <title> FLEX: A Tool for Building Efficient and Flexible Systems. </title> <booktitle> In Proceedings of the Fourth Workshop on Workstation Operating Systems (Napa, </booktitle> <address> CA. Oct. 14, 15). </address> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1993, </year> <pages> pp. 198-202. </pages>
Reference-contexts: Our focus on using passive abstractions to represent protection domains is based both on the experience of others <ref> [Carter et al. 93] </ref> as well as our own [Banerji et al. 94a] that clearly demonstrate the advantages of passive modularity. <p> The most important advantages of passive protection domains are their ability to better represent the common case of synchronous communication, their documented ability to support optimized implementations [Druschel 92] [Chase 94] <ref> [Carter et al. 93] </ref>, and the ease with which they can be managed in user-level client code.
Reference: [Chase 94] <author> Chase, J., et al. </author> <title> Sharing and Protection in a Single Address Space Operating System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 12(4), </volume> <month> Novem-ber </month> <year> 1994, </year> <pages> pp. 271-307. </pages>
Reference-contexts: Following that, the overall PSL design approach is described. 2.1 Shared Libraries as Protection Domains Enforced protection boundaries have been found to be a very effective software structuring tool especially for large systems [Nelson 91] [Bogle 94] [Khalidi & Nelson 93] <ref> [Chase 94] </ref>. Protection can be enforced through a variety of means including separate address spaces [Acetta et al. 86], language support [Nelson 91], and post-processing of binary code [Wahbe 93]. Each of these approaches has been used to increase modularity and security and to facilitate debugging of large software systems. <p> The most important advantages of passive protection domains are their ability to better represent the common case of synchronous communication, their documented ability to support optimized implementations [Druschel 92] <ref> [Chase 94] </ref> [Carter et al. 93], and the ease with which they can be managed in user-level client code. <p> Efficiency concerns, therefore, make a compelling case for sharing. Sharing is also indicated by structural considerations. Cross-domain sharing has been used to improve structure in various parallel programming models [Scott et al. 90], and to support persistent databases [Bogle 94] <ref> [Chase 94] </ref> and shared object frameworks [Campbell et al. 93] [Banerji et al. 94]. Sharing enables cooperation between domains with limited trust [Chase 94]. <p> Cross-domain sharing has been used to improve structure in various parallel programming models [Scott et al. 90], and to support persistent databases [Bogle 94] <ref> [Chase 94] </ref> and shared object frameworks [Campbell et al. 93] [Banerji et al. 94]. Sharing enables cooperation between domains with limited trust [Chase 94]. Thus, sharing can be used to support a variety of interactions including producer-consumer, non-intrusive monitoring, asynchronous service providers [Bogle 94], shared pipes, stateless servers with client maintained state, and shared objects exported by servers [IBM 93]. There is a third reason for sharing across protection domains. <p> First, the ability to share pointer-rich data across domains is attractive. This ability has been found to be useful for persistent stores <ref> [Chase 94] </ref>, shared C++ objects [Banerji et al. 94], distributed shared data and system software. The obvious argument against uniform sharing is the need to reserve portions of an address space.
Reference: [Condict et al. 93] <author> Condict, M., Mitchell, D. and Reynolds, F. </author> <title> Optimizing Performance of Mach-based Systems By Server Co-Location: A Detailed Design. </title> <month> August 10, </month> <year> 1993. </year>
Reference-contexts: Finer-grained decomposition of both the kernel-level and user-level portions remains an issue. Also, decomposition of the user-level portion into multiple user-level server tasks may be inefficient due to overhead associated with task-based protection <ref> [Condict et al. 93] </ref> [Ford & Lepreau 94] [Lepreau et al. 93] [Maeda & Bershad 93]. The language based object-oriented approach is generally applicable only to new systems. An alternate approach to modularity which provides sufficient exibility, efficiency, and is easily applicable to operating systems is needed. <p> Cross-domain interactions usually take the form of fast RPC mechanisms that circumvent much of the traditional in-kernel RPC code-path. [Bershad 90] [Hamilton & Kougiouris 93] <ref> [Condict et al. 93] </ref> Efficiency of fast RPC mechanisms has been improved through use of shared message buffers [Bershad 90]. Some optimized implementations, such as the Fbufs approach [Druschel & Peterson 93], improve throughput by two orders of magnitude. Efficiency concerns, therefore, make a compelling case for sharing.
Reference: [Deitel & Kogan 92] <author> Deitel, H. M. and Kogan, M. S. </author> <booktitle> The Design of OS/2. </booktitle> <address> New York: </address> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: In Multics all object modules were effectively shared libraries. library gets its own copy of library data. This copy gets mapped into the process private data segment and is, therefore, equally accessible by client and library code. Some systems such as OS/2 <ref> [Deitel & Kogan 92] </ref> and Windows [King 94] allow shared or dynamically linked libraries (DLLs) to contain shared data as well as code, but offer little or no protection. Each client task accessing a DLL has equal access to the DLLs data.
Reference: [Druschel 92] <author> P. Druschel et. al. </author> <title> Beyond Microker-nel Design: Decoupling Modularity and Protection in Lipto. </title> <booktitle> In Proceedings of the 12th International Conf. on Distributed Computing Systems, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, CA, </publisher> <pages> pp. 512-520. </pages>
Reference-contexts: The most important advantages of passive protection domains are their ability to better represent the common case of synchronous communication, their documented ability to support optimized implementations <ref> [Druschel 92] </ref> [Chase 94] [Carter et al. 93], and the ease with which they can be managed in user-level client code.
Reference: [Druschel & Peterson 93] <author> Druschel, P. and Peter-son, L. L. Fbufs: </author> <title> A High-Bandwidth Cross-Domain Transfer Facility. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles (Asheville, </booktitle> <address> NC. December 5-8). </address> <publisher> ACM Press, </publisher> <address> New York, NY, </address> <year> 1993, </year> <pages> pp. 189-202. </pages>
Reference-contexts: Some optimized implementations, such as the Fbufs approach <ref> [Druschel & Peterson 93] </ref>, improve throughput by two orders of magnitude. Efficiency concerns, therefore, make a compelling case for sharing. Sharing is also indicated by structural considerations. <p> Context Specific Libraries represent modules of code and data that may be shared in various forms between different protection domains. They represent a communication channel between protection domains and thus augment traditional RPC mechanisms. CSLs extend the notion of cross-domain data and address sharing as found in Fbufs <ref> [Druschel & Peterson 93] </ref>, the zero-copy I/O framework and most implementation of the UNIX u-block [Lefer et al. 89].
Reference: [Enbody 88] <author> Enbody, R. and Du, H. </author> <title> Dynamic Hashing Schemes. </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 20, No. 2, </volume> <year> 1988, </year> <pages> pp. 85-113. </pages>
Reference-contexts: This is a slight modification of the sdbm library released by Ozan Yigit [Yigit 92], and is based on the 1978 dynamic hashing algorithm by Paul Larson <ref> [Enbody 88] </ref>. Changes were made to avoid unnecessary copying and remove file dependencies. The tests involve insertion of N words from an extended version of /usr/dict/words, random fetch of N/2 words, and deletion of N/2 words. Nullc, a custom benchmark that is essentially a null call.
Reference: [Engler 95] <editor> Engler D., et al. Exokernel: </editor> <booktitle> An Operating System Architecture for Application-Level Resource Management In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles (Copper Mountain Resort, </booktitle> <publisher> CO. </publisher> <month> Dec. </month> <pages> 3-6), </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: Thus, PSLs may provide safe ways of extending existing operating system kernels. Second, one important research area in operating systems is the design of low-level nanokernels or exokernels <ref> [Engler 95] </ref>. These kernels provide low-level protected inter Misc user User stalls Misc system Alias faults Kernel transition faces to the hardware with most operating system func-tionality implemented in library routines. PSLs are an attractive approach to protecting such operating systems from application code.
Reference: [Ford & Lepreau 94] <author> Ford, B. and Lepreau, J. </author> <title> Evolving Mach 3.0 to a Migrating Thread Model. </title> <booktitle> In Proceedings of the Winter 1994 USENIX Technical Conference (San Francisco, </booktitle> <address> CA. </address> <month> Jan. </month> <pages> 17-21). </pages> <publisher> USENIX Association, </publisher> <address> Berkeley, CA, </address> <year> 1994, </year> <pages> pp. 97-114. </pages>
Reference-contexts: Finer-grained decomposition of both the kernel-level and user-level portions remains an issue. Also, decomposition of the user-level portion into multiple user-level server tasks may be inefficient due to overhead associated with task-based protection [Condict et al. 93] <ref> [Ford & Lepreau 94] </ref> [Lepreau et al. 93] [Maeda & Bershad 93]. The language based object-oriented approach is generally applicable only to new systems. An alternate approach to modularity which provides sufficient exibility, efficiency, and is easily applicable to operating systems is needed.
Reference: [Garrett et al. 93] <author> Garrett, W. E., et al. </author> <title> Linking Shared Segments. </title> <booktitle> In Proceddings of the Winter 1993 USENIX Conference (San Diego, </booktitle> <address> CA, </address> <month> January 25-29), </month> <booktitle> The USENIX Association, </booktitle> <address> Berkeley, CA, </address> <year> 1993, </year> <pages> pp. 13-27. </pages>
Reference-contexts: This facility can easily be extended to shared data, by involving the linker or loader in the manipulation of shared information. This approach can be seen in the shared libraries of systems as diverse as Multics, OS/2 and Hemlock <ref> [Garrett et al. 93] </ref>. Clearly, with a little system support uniform addressing and naming, can be integrated into relocate-able object modules, as has been done with shared libraries in Multics, Hemlock and OS/2. In current implementations, however, the available sharing mechanisms provide limited exibility.
Reference: [Golub et al. 90] <author> Golub, D., Dean, R., Florin, A. and Rashid, R. </author> <title> Unix as an Application Program. </title> <booktitle> In Proceedings of the Summer 1990 USENIX Conference (Anaheim, </booktitle> <address> CA. June 11-15). </address> <booktitle> The USENIX Association, </booktitle> <address> Berkeley, CA, </address> <year> 1990, </year> <pages> pp. 87-95. </pages>
Reference-contexts: This approach has been applied to a number of commercial operating systems [Batlivala et al. 92] [Bor-gendale at al. 94] <ref> [Golub et al. 90] </ref> [Golub et al. 93] [Malan et al. 90] [Phelan et al. 93] [Weicek et al. 93]. The second approach is to design an entirely new operating system emphasizing exibility using object-oriented technology which generally includes language support.
Reference: [Golub et al. 93] <author> Golub, D. B., Manikundalam, R. and Rawson, F. L. III. </author> <title> MVM - An Environment for Running Multiple Dos, Windows and DPMI Programs on the Microkernel. </title> <booktitle> In Proceedings of the Third USENIX Mach Symposium (Santa Fe, </booktitle> <address> NM. April 19-21). </address> <publisher> USENIX Association, </publisher> <address> Berkeley, CA, </address> <year> 1993, </year> <pages> pp. 173-190. </pages>
Reference-contexts: This approach has been applied to a number of commercial operating systems [Batlivala et al. 92] [Bor-gendale at al. 94] [Golub et al. 90] <ref> [Golub et al. 93] </ref> [Malan et al. 90] [Phelan et al. 93] [Weicek et al. 93]. The second approach is to design an entirely new operating system emphasizing exibility using object-oriented technology which generally includes language support.
Reference: [Goodheart & Cox 93] <author> Goodheart, B. and Cox, J. </author> <title> The Magic Garden Explained. </title> <address> New York: </address> <publisher> Prentice Hall, </publisher> <year> 1993. </year> <note> (ISBN 0-13-098138-9) </note>
Reference-contexts: This is a reection on resource handling in UNIX kernels, not on PSL semantics. Over the last decade or so, kernel code in most UNIX implementations has become quite structured. The vnode [Kleiman 86], HAT layer <ref> [Goodheart & Cox 93] </ref> and the emerging UDI interfaces [UDI 96] ensure the file-system, low-level virtual memory management services and I/O system are accessed through well-defined interfaces. This provides some degree of encapsulation and isolates clients of these interfaces from implementation changes.
Reference: [Hamilton & Kougiouris 93] <author> Hamilton, G. and Kougiouris, P. </author> <title> The Spring Nucleus: A Microkernel for Objects. </title> <booktitle> In Proceedings of the Summer 1993 USENIX Conference (Cincinnati, </booktitle> <address> OH, </address> <month> June). </month> <booktitle> The USENIX Association, </booktitle> <address> Berkeley, CA, </address> <year> 1993. </year>
Reference-contexts: Cross-domain interactions usually take the form of fast RPC mechanisms that circumvent much of the traditional in-kernel RPC code-path. [Bershad 90] <ref> [Hamilton & Kougiouris 93] </ref> [Condict et al. 93] Efficiency of fast RPC mechanisms has been improved through use of shared message buffers [Bershad 90]. Some optimized implementations, such as the Fbufs approach [Druschel & Peterson 93], improve throughput by two orders of magnitude. <p> A thread is the primary unit of execution and can traverse protection domains. As in most multi-threaded process models, each thread owns a small set of per-thread resources such as scheduling and accounting information. These resources, usually encapsulated in a shuttle <ref> [Hamilton & Kougiouris 93] </ref>, belong to the thread and remain associated with the thread as it traverses protection domains. Most resources a thread accesses belong to the domain in which it is currently executing. All threads within a domain have equal access to the domains resources. <p> These are approximately 210 instructions per transition, or about 275 cycles including kernel trap and return. This cost approaches those for highly optimized cross-domain transfer mechanisms <ref> [Hamilton & Kougiouris 93] </ref>. Without aliasing, the hardware cost of the kernel trap and return is significant, 57 cycles for the POWER2. Library-based protection traps twice for every service invocation, thus 114 of the remaining 275 overhead cycles are due to the trap and return.
Reference: [Heidemann 95] <author> Heidemann, J. S. </author> <title> Stackable Design of File Systems. </title> <type> Ph.D. Dissertation, </type> <institution> University of Cali-fornia, </institution> <address> Los Angeles, </address> <year> 1995. </year>
Reference-contexts: This provides some degree of encapsulation and isolates clients of these interfaces from implementation changes. Furthermore, indirections such as those postulated by the stackable file systems standard <ref> [Heidemann 95] </ref> can be easily implemented. This tends to make subsystem implementations more exible and easier to maintain. Unfortunately the same cannot be said for process and resource management.
Reference: [IBM 93] <institution> SOMObjects Developer Toolkit Users Guide, </institution> <note> Version 2.0, </note> <month> June </month> <year> 1993, </year> <institution> IBM, Austin, TX. </institution>
Reference-contexts: Sharing enables cooperation between domains with limited trust [Chase 94]. Thus, sharing can be used to support a variety of interactions including producer-consumer, non-intrusive monitoring, asynchronous service providers [Bogle 94], shared pipes, stateless servers with client maintained state, and shared objects exported by servers <ref> [IBM 93] </ref>. There is a third reason for sharing across protection domains. Most implementations of cross-domain object interactions include a fair amount of overhead for the locally distributed case [IBM 93] [Janssen 95]. <p> non-intrusive monitoring, asynchronous service providers [Bogle 94], shared pipes, stateless servers with client maintained state, and shared objects exported by servers <ref> [IBM 93] </ref>. There is a third reason for sharing across protection domains. Most implementations of cross-domain object interactions include a fair amount of overhead for the locally distributed case [IBM 93] [Janssen 95]. Thus, sharing object instances [Banerji et al. 94] and passing enclosures between protection domains on the same machine are usually inefficient. Most of these problems may be solved by judicious sharing of data and addresses between interacting protection domains.
Reference: [Janssen 95] <author> Janssen, B., et al., </author> <title> ILU 1.7 Reference Manual, </title> <institution> Xerox Corporation, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: There is a third reason for sharing across protection domains. Most implementations of cross-domain object interactions include a fair amount of overhead for the locally distributed case [IBM 93] <ref> [Janssen 95] </ref>. Thus, sharing object instances [Banerji et al. 94] and passing enclosures between protection domains on the same machine are usually inefficient. Most of these problems may be solved by judicious sharing of data and addresses between interacting protection domains.
Reference: [Khalidi & Nelson 93] <author> Khalidi, Y. A., and Nelson, M. N. </author> <title> An Implementation of Unix on an Object-Oriented Operating System. </title> <booktitle> In Proceedings of the Winter 1993 USENIX Conference. The USENIX Association, </booktitle> <address> Berkeley, CA, </address> <year> 1993, </year> <pages> pp. 469-479. </pages>
Reference-contexts: CSLs allow programmers to share information in libraries and control the exact nature of sharing. This opens up possibilities for easily creating UNIX u_block [Goodheart & Cox 92] implementations, sharing I/O buffers across protection domains <ref> [Khalidi & Nelson 93] </ref> and sharing closures and objects across protection boundaries [Banerji et al. 94a]. The remainder of this paper proceeds as follows. The next section presents the motivation for Protected Shared Libraries, both to improve modularity and to facilitate sharing. After that, PSL semantics are described. <p> Discussion of these observations continues in the next subsection. Following that, the overall PSL design approach is described. 2.1 Shared Libraries as Protection Domains Enforced protection boundaries have been found to be a very effective software structuring tool especially for large systems [Nelson 91] [Bogle 94] <ref> [Khalidi & Nelson 93] </ref> [Chase 94]. Protection can be enforced through a variety of means including separate address spaces [Acetta et al. 86], language support [Nelson 91], and post-processing of binary code [Wahbe 93]. <p> Each of these approaches has been used to increase modularity and security and to facilitate debugging of large software systems. Protection has also been used to ease modification or replacement of software components [Pu 95] <ref> [Khalidi & Nelson 93] </ref> [Orr 92]. Most work regarding enforcement of protection boundaries in current operating system software, both user-level and kernel-level, has been focussed on improving the efficiency of cross-domain invocations.
Reference: [King 94] <author> King, A. </author> <title> Inside Windows 95. </title> <address> Redmond, WA: </address> <publisher> Microsoft Press, </publisher> <year> 1994. </year>
Reference-contexts: In Multics all object modules were effectively shared libraries. library gets its own copy of library data. This copy gets mapped into the process private data segment and is, therefore, equally accessible by client and library code. Some systems such as OS/2 [Deitel & Kogan 92] and Windows <ref> [King 94] </ref> allow shared or dynamically linked libraries (DLLs) to contain shared data as well as code, but offer little or no protection. Each client task accessing a DLL has equal access to the DLLs data. Malicious or errant clients can, therefore, corrupt shared data and adversely impact other clients.
Reference: [Kleiman 86] <author> Kleiman S. Vnodes: </author> <title> An Architecture for Multiple File System Types in Sun UNIX. </title> <booktitle> In Proceedings of the Summer 1986 USENIX Conference, </booktitle> <month> June </month> <year> 1986, </year> <pages> pp. 238-247. </pages>
Reference-contexts: A complete implementation of the PSL resource handling semantics would require significant modifications of the UNIX kernel. This is a reection on resource handling in UNIX kernels, not on PSL semantics. Over the last decade or so, kernel code in most UNIX implementations has become quite structured. The vnode <ref> [Kleiman 86] </ref>, HAT layer [Goodheart & Cox 93] and the emerging UDI interfaces [UDI 96] ensure the file-system, low-level virtual memory management services and I/O system are accessed through well-defined interfaces. This provides some degree of encapsulation and isolates clients of these interfaces from implementation changes.
Reference: [Lefer at al. 89] <author> Lefer, S., McKusick, M. K., Karels, M. J. and Quarterman, J. S. </author> <title> The Design and Implementation of the 4.3 BSD UNIX Operating System. </title> <address> New York: </address> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1989. </year> <note> (ISBN 0-201-06196-1) </note>
Reference: [Lepreau et al. 93] <editor> Lepreau, J. et al. </editor> <booktitle> In_Kernel Servers on Mach 3.0: Implementation and Performance. In Proceedings of the Third USENIX Mach Symposium (Santa Fe, </booktitle> <address> NM. April 19-21). </address> <publisher> USENIX Association, </publisher> <address> Berkeley, CA, </address> <year> 1993, </year> <pages> pp. 39-55. </pages>
Reference-contexts: Finer-grained decomposition of both the kernel-level and user-level portions remains an issue. Also, decomposition of the user-level portion into multiple user-level server tasks may be inefficient due to overhead associated with task-based protection [Condict et al. 93] [Ford & Lepreau 94] <ref> [Lepreau et al. 93] </ref> [Maeda & Bershad 93]. The language based object-oriented approach is generally applicable only to new systems. An alternate approach to modularity which provides sufficient exibility, efficiency, and is easily applicable to operating systems is needed. Protected Shared Libraries (PSLs) are just such an approach.
Reference: [Lepreau et al. 94] <author> Lepreau, J., et. al. </author> <title> The Flux Operating System Project. </title> <address> http://www.cs.utah.edu/ projects/exmach. </address>
Reference-contexts: Most work regarding enforcement of protection boundaries in current operating system software, both user-level and kernel-level, has been focussed on improving the efficiency of cross-domain invocations. Invocation times have been significantly reduced by handoff scheduling [Black 89] and thread migration [Bershad 90] <ref> [Lepreau et al. 94] </ref> [Hamilton & Kou-giouris 93]. These protection domains, however, have typically been associated with processes. Counter examples exist [Organick 72] [Scott et al. 90] [Wulf et al. 81], but have generally been limited to research efforts encompassing entirely new operating systems. <p> Counter examples exist [Organick 72] [Scott et al. 90] [Wulf et al. 81], but have generally been limited to research efforts encompassing entirely new operating systems. The only system known to use passive protection domains effectively in a commercial operating system is Mach 4.0 <ref> [Lepreau et al. 94] </ref>, but even that implementation is closely tied to the notion of processes.
Reference: [Liedtke 95] <editor> Liedtke, J. </editor> <booktitle> On m-Kernel Construction. In Proceedings of the Fifteenth ACM Symposium on Operating System Principles (Copper Mountain Resort, </booktitle> <publisher> CO. </publisher> <month> Dec. </month> <pages> 3-6). </pages> <publisher> ACM Press, </publisher> <address> New York, NY, </address> <year> 1995, </year> <pages> pp. 237-250. </pages>
Reference-contexts: This prevents user-level threads from generating illegal addresses, while allowing for verify fast switches. Variations of this architecture-specific technique has been used on other architectures as well <ref> [Liedtke 95] </ref>. 4.3.3 Protected Shared Library Linker The Protected Shared Library linker subsumes the functionality of /bin/ld, the normal AIX linker. For binaries that are not and do not use PSLs, the PSL linker simply calls /bin/ld.
Reference: [Maeda & Bershad 93] <author> Maeda, C. and Bershad, B. N. </author> <title> Services without Servers. </title> <booktitle> In Proceedings of the Fourth Workshop on Workstation Operating Systems (Napa, </booktitle> <address> CA. Oct. 14, 15). </address> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1994, </year> <pages> pp. 170-176. </pages>
Reference-contexts: Finer-grained decomposition of both the kernel-level and user-level portions remains an issue. Also, decomposition of the user-level portion into multiple user-level server tasks may be inefficient due to overhead associated with task-based protection [Condict et al. 93] [Ford & Lepreau 94] [Lepreau et al. 93] <ref> [Maeda & Bershad 93] </ref>. The language based object-oriented approach is generally applicable only to new systems. An alternate approach to modularity which provides sufficient exibility, efficiency, and is easily applicable to operating systems is needed. Protected Shared Libraries (PSLs) are just such an approach.
Reference: [Malan et al. 90] <author> Malan, G., Rashid, R., Golub, D., and Baron, R. </author> <title> DOS as a Mach 3.0 Application. </title> <booktitle> In Proceedings of the USENIX Mach Workshop (Burling-ton, VT. Oct.). The USENIX Association, </booktitle> <address> Berkeley, CA, </address> <year> 1990, </year> <pages> pp. 27-40. </pages>
Reference-contexts: This approach has been applied to a number of commercial operating systems [Batlivala et al. 92] [Bor-gendale at al. 94] [Golub et al. 90] [Golub et al. 93] <ref> [Malan et al. 90] </ref> [Phelan et al. 93] [Weicek et al. 93]. The second approach is to design an entirely new operating system emphasizing exibility using object-oriented technology which generally includes language support.
Reference: [Nelson, 91] <author> Nelson, G., </author> <title> Systems Programming with Modula-3. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference: [Orr 92] <author> Orr, D. and Mecklenburg, R. W. </author> <title> OMOS - An Object Server for Program Execution. </title> <booktitle> In Proceedings of the International Workshop on Object Oriented Operating Systems, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1992, </year> <pages> pp. 200-209. </pages>
Reference-contexts: Each of these approaches has been used to increase modularity and security and to facilitate debugging of large software systems. Protection has also been used to ease modification or replacement of software components [Pu 95] [Khalidi & Nelson 93] <ref> [Orr 92] </ref>. Most work regarding enforcement of protection boundaries in current operating system software, both user-level and kernel-level, has been focussed on improving the efficiency of cross-domain invocations.
Reference: [Organick 72] <author> Organick E., </author> <title> The Multics System: An Examination of its Structure, </title> <publisher> Cambridge: The MIT Press, </publisher> <year> 1972. </year>
Reference-contexts: Invocation times have been significantly reduced by handoff scheduling [Black 89] and thread migration [Bershad 90] [Lepreau et al. 94] [Hamilton & Kou-giouris 93]. These protection domains, however, have typically been associated with processes. Counter examples exist <ref> [Organick 72] </ref> [Scott et al. 90] [Wulf et al. 81], but have generally been limited to research efforts encompassing entirely new operating systems. <p> Previously, other approaches to protection based on active entities such as processes have been used to improve modularity. Protected libraries investigate the alternative of using dynamically loadable passive shared libraries to enforce protection. This idea is based on efforts such as Psyche [Scott et al. 90] and Multics <ref> [Organick 72] </ref> both of which supported protected dynamically loadable object modules. Context Specific Libraries represent modules of code and data that may be shared in various forms between different protection domains. They represent a communication channel between protection domains and thus augment traditional RPC mechanisms.
Reference: [Phelan et al. 93] <author> Phelan, J. M., Arendt, J. W., and Ormsby, G. R. </author> <title> An OS/2 Personality on Mach. </title> <booktitle> In Proceedings of the Third USENIX Mach Symposium (Santa Fe, </booktitle> <address> NM. </address> <month> April 19-21). </month> <booktitle> The USENIX Association, </booktitle> <address> Ber-keley, CA, </address> <year> 1993, </year> <pages> pp. 191-201. </pages>
Reference-contexts: This approach has been applied to a number of commercial operating systems [Batlivala et al. 92] [Bor-gendale at al. 94] [Golub et al. 90] [Golub et al. 93] [Malan et al. 90] <ref> [Phelan et al. 93] </ref> [Weicek et al. 93]. The second approach is to design an entirely new operating system emphasizing exibility using object-oriented technology which generally includes language support.
Reference: [Pu 95] <author> Pu, C., et al. </author> <title> Optimistic Incremental Specialization: Streamlining a Commercial Operating System. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating System Principles (Copper Mountain Resort, </booktitle> <publisher> CO. </publisher> <month> Dec. </month> <pages> 3-6). </pages> <publisher> ACM Press, </publisher> <address> New York, NY, </address> <year> 1995. </year>
Reference-contexts: Each of these approaches has been used to increase modularity and security and to facilitate debugging of large software systems. Protection has also been used to ease modification or replacement of software components <ref> [Pu 95] </ref> [Khalidi & Nelson 93] [Orr 92]. Most work regarding enforcement of protection boundaries in current operating system software, both user-level and kernel-level, has been focussed on improving the efficiency of cross-domain invocations.
Reference: [Radia 95] <author> Radia S., et al, </author> <title> The Spring Object Model, </title> <booktitle> Proceedings of the Conference on Object Technologies and Systems, </booktitle> <month> July </month> <year> 1995. </year>
Reference-contexts: Most marshalling/unmarshalling and method table pointer manipulations are unnecessary in distributed object implementations that do not cross machine boundaries. However, most implementations do not use shared memory to implement distributed objects efficiently in the local case <ref> [Radia 95] </ref>. Client CSLs and domain CSLs can be used to avoid marshalling/unmar-shalling or method table pointer initialization int the local case. CSL with a method table in a domain CSL. The instance data gets mapped into the called domain when a locally distributed object is invoked.
Reference: [Rivest 92] <author> Rivest, R. </author> <title> The MD5 Message-Digest Algorithm, </title> <booktitle> Network Working Group RCF 1321, </booktitle> <year> 1992. </year> <note> [RSA 93] http://www.rsa.com/pub/md5.txt </note>
Reference-contexts: Figure 8 shows how each invocation has to cross from client code to service code, and indicates where we start and stop our data gathering. The benchmarks used were: MD5, a secure one-way hash function developed to reliably identify long byte strings <ref> [Rivest 92] </ref>. The implementation used is based on code made available by RSA [RSA 93]. The input byte string is partitioned into fixed-length substrings, and the algorithm operates on the substrings in succession. Nsieve, a well-known benchmark that computes prime numbers.
Reference: [Rosier et al. 92] <author> Rosier, M., Abrossimov, F., Armand, F., Boule, I., Gien, M., Guillemont, M., Her-rman, F., Kaiser, C., Langlois, S., Lonard, P., and Neu-hauser, W. </author> <title> Overview of the Chorus Distributed Operating System. </title> <booktitle> In Proceedings of the USENIX Workshop on Micro-Kernels and Other Kernel Architectures (Seattle, </booktitle> <address> WA. </address> <month> April 27, </month> <title> 28). </title> <booktitle> The USENIX Association, </booktitle> <address> Berkeley, CA, </address> <year> 1992, </year> <pages> pp. 39-69. </pages>
Reference: [Scott et al. 90] <author> Scott, M. L., LeBlanc, T. J., and Marsh, B. D. </author> <booktitle> Multi-Model Parallel Programming in Psyche In Proceedings of the Second ACM Symposium on Principles and Practice of Parallel Programming (Seattle, </booktitle> <address> WA, March 14-16), </address> <year> 1990, </year> <pages> pp. 70-78. </pages>
Reference-contexts: Invocation times have been significantly reduced by handoff scheduling [Black 89] and thread migration [Bershad 90] [Lepreau et al. 94] [Hamilton & Kou-giouris 93]. These protection domains, however, have typically been associated with processes. Counter examples exist [Organick 72] <ref> [Scott et al. 90] </ref> [Wulf et al. 81], but have generally been limited to research efforts encompassing entirely new operating systems. <p> Some optimized implementations, such as the Fbufs approach [Druschel & Peterson 93], improve throughput by two orders of magnitude. Efficiency concerns, therefore, make a compelling case for sharing. Sharing is also indicated by structural considerations. Cross-domain sharing has been used to improve structure in various parallel programming models <ref> [Scott et al. 90] </ref>, and to support persistent databases [Bogle 94] [Chase 94] and shared object frameworks [Campbell et al. 93] [Banerji et al. 94]. Sharing enables cooperation between domains with limited trust [Chase 94]. <p> Previously, other approaches to protection based on active entities such as processes have been used to improve modularity. Protected libraries investigate the alternative of using dynamically loadable passive shared libraries to enforce protection. This idea is based on efforts such as Psyche <ref> [Scott et al. 90] </ref> and Multics [Organick 72] both of which supported protected dynamically loadable object modules. Context Specific Libraries represent modules of code and data that may be shared in various forms between different protection domains.
Reference: [UDI 96] <institution> Uniform Driver Interface, ftp://tel-ford.nsa.hp.com/pub/hp_stds/udi/home.html </institution>
Reference-contexts: This is a reection on resource handling in UNIX kernels, not on PSL semantics. Over the last decade or so, kernel code in most UNIX implementations has become quite structured. The vnode [Kleiman 86], HAT layer [Goodheart & Cox 93] and the emerging UDI interfaces <ref> [UDI 96] </ref> ensure the file-system, low-level virtual memory management services and I/O system are accessed through well-defined interfaces. This provides some degree of encapsulation and isolates clients of these interfaces from implementation changes.
Reference: [Wahbe 93] <author> Wahbe, R., et. al. </author> <title> Efficient Software-based Fault Isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1993, </year> <pages> pp. 203-216. </pages>
Reference-contexts: Protection can be enforced through a variety of means including separate address spaces [Acetta et al. 86], language support [Nelson 91], and post-processing of binary code <ref> [Wahbe 93] </ref>. Each of these approaches has been used to increase modularity and security and to facilitate debugging of large software systems. Protection has also been used to ease modification or replacement of software components [Pu 95] [Khalidi & Nelson 93] [Orr 92]. <p> Three are hardware based and depend upon the kernel protection boundary. The other two are software-based approaches. The protection schemes are null-protection which is used as a baseline, traditional kernel-based system calls, process-based protection with thread migration, library-based PSLs, a language-based safe-subset of Modula 3 and software-fault-isolation <ref> [Wahbe 93] </ref>. 5.2.2 Methodology Measurements were taken on an IBM RS/6000 Model 390 with a single 66-MHz POWER2 processor. [Weiss 94]. For each benchmark, the granularity of the protection domain was varied, and the number of machine cycles needed to perform the service was recorded.
Reference: [Weiss 94] <author> Weiss, S., Smith, J., </author> <title> POWER and Pow-erPC, </title> <address> San Francisco: </address> <publisher> Morgan Kauffman Publishers, Inc., </publisher> <year> 1994. </year>
Reference-contexts: The obvious argument against uniform sharing is the need to reserve portions of an address space. This concern is decreasing with the increasing popularity of large effective address spaces such as the 52-bit global address space and 64-bit non-segmented address space in the POWER <ref> [Weiss 94] </ref> and Alpha architectures respectively. The advantages in efficiency of avoiding pointer transformations in various applications and system software, as well as pro grammer convenience are significant. Second, the ability to treat shared data through symbolic names that maintain meanings across domains is attractive. <p> The protection schemes are null-protection which is used as a baseline, traditional kernel-based system calls, process-based protection with thread migration, library-based PSLs, a language-based safe-subset of Modula 3 and software-fault-isolation [Wahbe 93]. 5.2.2 Methodology Measurements were taken on an IBM RS/6000 Model 390 with a single 66-MHz POWER2 processor. <ref> [Weiss 94] </ref>. For each benchmark, the granularity of the protection domain was varied, and the number of machine cycles needed to perform the service was recorded. Only plots for md5 and tdbm_d are shown here.
Reference: [Wiecek et al. 93] <author> Wiecek, C. A., Kaler, C. G., Fiorelli, S., Davenport, W. C. Jr., and Chen, R. C. </author> <title> A Model and Prototype of VMS Using the Mach 3.0 Kernel. </title> <booktitle> In Proceedings of the USENIX Symposium on Microkernels and Other Kernel Architectures (Seattle, </booktitle> <address> WA. </address> <month> April 27, </month> <title> 28). </title> <booktitle> The USENIX Association, </booktitle> <address> Berkeley, CA, </address> <year> 1992, </year> <pages> pp. 187-203. </pages>
Reference: [Wulf et al. 81] <author> Wulf, W. A., Levin, R. and Harbi-son, S. P. Hydra/C.mmp: </author> <title> An Experimental Computer System, </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1981. </year>
Reference-contexts: Invocation times have been significantly reduced by handoff scheduling [Black 89] and thread migration [Bershad 90] [Lepreau et al. 94] [Hamilton & Kou-giouris 93]. These protection domains, however, have typically been associated with processes. Counter examples exist [Organick 72] [Scott et al. 90] <ref> [Wulf et al. 81] </ref>, but have generally been limited to research efforts encompassing entirely new operating systems. <p> The sum of resources model only affects Protected Shared Library (secondary) domains and not the root or primary domain which is represented by a regular process context. This follows the Hydra <ref> [Wulf et al. 81] </ref> model of resource management which allows certain sets of resources to be passed essentially as parameters into a domain along with a call to the domain.
Reference: [Yigit 92] <author> Yigit, O. </author> <month> ftp://ftp.x.org/contrib/util/sdbm </month>
Reference-contexts: This is a slight modification of the sdbm library released by Ozan Yigit <ref> [Yigit 92] </ref>, and is based on the 1978 dynamic hashing algorithm by Paul Larson [Enbody 88]. Changes were made to avoid unnecessary copying and remove file dependencies. The tests involve insertion of N words from an extended version of /usr/dict/words, random fetch of N/2 words, and deletion of N/2 words.
Reference: [Yokote 92] <author> Yokote, Y. </author> <title> The Apertos Reective Operating System: The Concept and its Implementation. </title> <booktitle> In Proceedings of the Seventh Annual Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA `92), </booktitle> <publisher> ACM Press, </publisher> <address> NY, </address> <year> 1992, </year> <pages> pp. 414-434. </pages>
Reference-contexts: The second approach is to design an entirely new operating system emphasizing exibility using object-oriented technology which generally includes language support. The second approach has primarily been relegated to academic and research environments [Bershad et al. 95] [Campbell et al. 93] <ref> [Yokote 92] </ref>. 1. David Cohn is currently on sabbatical at the IBM Corporation, Sommers, NY. This work was supported by a grant form the IBM Corporation. Neither of these approaches features adequate exi-bility, efficiency, and ease of use.
Reference: [Zajcew et al. 93] <author> Zajcew, R. et al. </author> <title> An OSF/1 UNIX for Massively Parallel Multicomputers. </title> <booktitle> In Proceedings of the 1993 Winter USENIX Conference, The USENIX Association, </booktitle> <address> Berkeley, CA, </address> <year> 1993, </year> <pages> pp. 449-468. </pages>
Reference-contexts: Such direct access prevents any degree of encapsulation and makes it very difficult to build indirections or change UNIX resource handling. The need for encapsulation of resource handling in UNIX kernels has been previously recognized <ref> [Zajcew et al. 93] </ref>.
References-found: 55

