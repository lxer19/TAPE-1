URL: http://www.cs.washington.edu/homes/tian/ISMM98/ISMM98.ps
Refering-URL: http://www.cs.washington.edu/homes/tian/ISMM98/
Root-URL: http://www.cs.washington.edu
Email: tian,pardy,bershad-@cs.washington.edu  
Title: A Memory-Efficient Real-Time Non-Copying Garbage Collector  
Author: Tian F. Lim Przemysaw Pardyak Brian N. Bershad 
Address: Seattle, WA, USA  
Affiliation: Department of Computer Science and Engineering University of Washington,  
Abstract: 1. ABSTRACT 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Java, </author> <note> http://java.sun.com/, 1996. </note>
Reference-contexts: INTRODUCTION Garbage collection is gaining mainstream acceptance and is entering new domains of systems software. For example , it is used to manage memory in Java <ref> [1] </ref>, in embedded systems such as Inferno [2] and PersonalJava [3], and in extensible operating systems such as SPIN [4]. These systems are demanding environments, in which a wide variety of workloads, including interactive and soft real-time applications, must perform well with limited resources.
Reference: [2] <author> Inferno, </author> <note> http://inferno.lucent.com/, 1996. </note>
Reference-contexts: INTRODUCTION Garbage collection is gaining mainstream acceptance and is entering new domains of systems software. For example , it is used to manage memory in Java [1], in embedded systems such as Inferno <ref> [2] </ref> and PersonalJava [3], and in extensible operating systems such as SPIN [4]. These systems are demanding environments, in which a wide variety of workloads, including interactive and soft real-time applications, must perform well with limited resources.
Reference: [3] <author> PersonalJava, </author> <note> http://java.sun.com/, 1997. </note>
Reference-contexts: INTRODUCTION Garbage collection is gaining mainstream acceptance and is entering new domains of systems software. For example , it is used to manage memory in Java [1], in embedded systems such as Inferno [2] and PersonalJava <ref> [3] </ref>, and in extensible operating systems such as SPIN [4]. These systems are demanding environments, in which a wide variety of workloads, including interactive and soft real-time applications, must perform well with limited resources. Consequently, their GC implementations must balance good end-to-end performance with short pauses and low memory consumption.
Reference: [4] <author> B. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. Fiuczynski, D. Becker, S. Eggers, and C. Chambers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System, </title> <booktitle> In Proceedings of the Fifteenth Symposium on Operating Systems Principles, </booktitle> <year> 1995. </year>
Reference-contexts: INTRODUCTION Garbage collection is gaining mainstream acceptance and is entering new domains of systems software. For example , it is used to manage memory in Java [1], in embedded systems such as Inferno [2] and PersonalJava [3], and in extensible operating systems such as SPIN <ref> [4] </ref>. These systems are demanding environments, in which a wide variety of workloads, including interactive and soft real-time applications, must perform well with limited resources. Consequently, their GC implementations must balance good end-to-end performance with short pauses and low memory consumption.
Reference: [5] <author> H. G. Baker. </author> <title> The Treadmill: Real-time Garbage Collection without Motion Sickness. </title> <journal> SIGPLAN, ACM, </journal> <volume> 27(3), </volume> <year> 1992. </year>
Reference-contexts: Many existing collectors are geared towards userspace programs and make tradeoffs, such as sacrificing space for time, that make them inadequate for systems software. In this paper, we present a new garbage collector based on the Treadmill real-time collector <ref> [5] </ref> that is optimized for both time and space. It provides excellent performance for the SPIN operating system kernel and regular user-space Modula-3 [6] programs. <p> The collector is based on Bakers Treadmill real-time non-copying collector <ref> [5] </ref>, which allocates and deallocates in constant time by sacrificing memory utilization. Obvious improvements to memory utilization, such as compaction or a buddy allocator, would compromise its low overhead or real-time latencies. <p> Further optimizations that avoid unnecessary external fragmentation (FLS-PF2) bring the wastage down to about 3-4%. In summary, although our user-level workloads exhibit more header wastage, internal fragmentation and sub-page external fragmentation than the kernel workloads, each can be addressed with a simple solution. 8. RELATED WORK Treadmill <ref> [5] </ref> is a non-copying version of Bakers real-time collector [17]. Wilsons improvements [9] reduce overhead and support bounded allocations for objects of any size but they do not address memory utilization. Johnstone and Wilson [18] also confirm fragmentation problems when multiple segregated lists are used.
Reference: [6] <author> G. Nelson, ed. </author> <title> Systems Programming in Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: In this paper, we present a new garbage collector based on the Treadmill real-time collector [5] that is optimized for both time and space. It provides excellent performance for the SPIN operating system kernel and regular user-space Modula-3 <ref> [6] </ref> programs. <p> The kernel is protected by a type-safe language, Modula-3 <ref> [6] </ref>, that uses garbage collection to manage its heap, allowing untrusted extensions to share memory safely. One of the goals of the SPIN project was to achieve performance comparable to commercial operating systems such as Digital Unix or Windows NT.
Reference: [7] <author> E. W. Dijkstra, L. Lamport, A.J. Martin, C. S. Scholten, E. F. M. Steffens. </author> <title> On-The-Fly Garbage Collection: An Exercise in Cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21 (11): 965975, </volume> <month> November </month> <year> 1978. </year>
Reference-contexts: The performance of a garbage collector can be measured by its latency, overhead, and memory utilization. It is relatively easy to optimize a collector for any one of these metrics, but usually by trading off the others. For instance, incremental collection can yield real-time latencies, but increases overhead <ref> [7] </ref>; compaction improves memory utilization by increasing overhead [8]. Most collectors trade memory utilization for lower latency or overhead. This is reasonable when memory is ample, as is the case for most user-level applications.
Reference: [8] <author> R. A. Saunders. </author> <title> The LISP system for the Q32 computer. </title> <editor> In E. C. Berkeley, D. G. Bobrow (ed.), </editor> <booktitle> The Programming Language LISP, </booktitle> <year> 1964 </year>
Reference-contexts: It is relatively easy to optimize a collector for any one of these metrics, but usually by trading off the others. For instance, incremental collection can yield real-time latencies, but increases overhead [7]; compaction improves memory utilization by increasing overhead <ref> [8] </ref>. Most collectors trade memory utilization for lower latency or overhead. This is reasonable when memory is ample, as is the case for most user-level applications. In this paper, we observe that memory utilization is as important as latency and overhead for operating system workloads.
Reference: [9] <author> P. R. Wilson and M. S. Johnstone. </author> <title> Truly Real-Time Non-Copying Garbage Collection. </title> <editor> In E. Moss, P. R. Wilson, B. Zorn, editors, </editor> <booktitle> Proceedings of OOPSLA/ECOOP93 Workshop on Garbage Collection in ObjectOriented Systems, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: The reclamation is implicit, i.e., none of the reclaimed objects are touched. Allocation time is constant because all objects are the same size, thus avoiding the need to search for a free object large enough. Wilson <ref> [9] </ref> relaxes this restriction by using segregated free lists for differently sized objects, with sizes increasing in powers of two. Each list is managed separately by the Treadmill algorithm. Allocation requests are rounded up to the nearest power of two and sent to the appropriate list. <p> In summary, although our user-level workloads exhibit more header wastage, internal fragmentation and sub-page external fragmentation than the kernel workloads, each can be addressed with a simple solution. 8. RELATED WORK Treadmill [5] is a non-copying version of Bakers real-time collector [17]. Wilsons improvements <ref> [9] </ref> reduce overhead and support bounded allocations for objects of any size but they do not address memory utilization. Johnstone and Wilson [18] also confirm fragmentation problems when multiple segregated lists are used.
Reference: [10] <author> D. S. Wise. </author> <title> The Double Buddy System. </title> <type> TR 79, </type> <institution> CS Dept. Indiana University, </institution> <month> December </month> <year> 1978. </year>
Reference-contexts: External fragmentation arises because memory committed to a free list of a given size cannot be used for allocations from a different list. There are two reasons why coalescing memory and reducing wasted space is hard in Treadmill. First, typical smart allocation <ref> [10] </ref> and coalescing techniques incur unbounded time and may increase overhead, which is unacceptable for real-time applications. Second, implicit collection makes identifying free objects difficult. Thus, it is hard to compute global decisions that could decrease fragmentation, such as locating objects that can be coalesced.
Reference: [11] <author> S. K. Card, T. P. Moran, and A. Newell. </author> <title> The Psychology of Human-Computer Interaction, </title> <publisher> Lawrence Erlbaum Associates, </publisher> <address> Hillsdale, NJ, </address> <year> 1983. </year>
Reference-contexts: This arbitrary choice was based on the observation that smoothly tracking a mouse in an interactive application requires pauses of 50ms or less <ref> [11] </ref>. Since enforcing strict real-time bounds on every operation is hard, we establish the conditions under which real-time latencies are maintained and we describe these conditions below. Collectstart The amount of time spent in this phase is proportional to the number of global pointers.
Reference: [12] <author> J. Bartlett. </author> <title> Compacting Garbage Collection with Ambiguous Roots. </title> <type> Technical Report, </type> <address> DEC WRL 88/2, </address> <month> February </month> <year> 1988. </year>
Reference-contexts: TM PM TM BL with BOL and page migration. TM RM TM PM with page remapping enabled. TM RT the real-time, incremental version of TM RM . For comparison, we use: CP an improved SRC Modula-3 VM-based mostly-copying collector <ref> [12] </ref>. It is configured to run incrementally but without generations 2 For our user-level experiments, we use the following collectors: FLS the TM RM collector, which uses fixed list sizes. FLS-PH FLS with packed headers. ALS FLS with arbitrary list sizes. ALS-PH ALS with packed headers.
Reference: [13] <author> M. Satyanarayanan, H. Mashburn, P. Kumar, D. Steere and J. Kistler. </author> <title> Lightweight Recoverable Virtual Memory. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12(1): 3357, </volume> <year> 1994. </year>
Reference-contexts: The page size is 8kB and the heap size is 22.7MB unless otherwise specified. Four OS benchmarks are used to evaluate the performance of our techniques in the SPIN kernel: TRANS the RVMbench <ref> [13] </ref> benchmark exercises SPIN's inkernel transaction services. HTTPD SPINs web tree (65 files, 5MB) is copied 14 times by 10 concurrent, scalable web clients [14] via the SPIN inkernel web server.
Reference: [14] <author> G. Banga and P. Druschel. </author> <title> Measuring the Capacity of a Web Server. </title> <booktitle> In Proceedings of the USENIX Symposium on Internet Technologies and Systems, </booktitle> <month> December </month> <year> 1997. </year>
Reference-contexts: Four OS benchmarks are used to evaluate the performance of our techniques in the SPIN kernel: TRANS the RVMbench [13] benchmark exercises SPIN's inkernel transaction services. HTTPD SPINs web tree (65 files, 5MB) is copied 14 times by 10 concurrent, scalable web clients <ref> [14] </ref> via the SPIN inkernel web server. LFS a subset of the Andrew file system benchmark [15] is run on the SPIN log structured file system [16].
Reference: [15] <author> J. H. Howard, M. L. Kazar, S. G. Menees, D. A. Nichols, M. Satyanarayanan, R. N. Sidebotham, and M. J. West. </author> <title> Scale and Performance in a Distributed File System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1), </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: HTTPD SPINs web tree (65 files, 5MB) is copied 14 times by 10 concurrent, scalable web clients [14] via the SPIN inkernel web server. LFS a subset of the Andrew file system benchmark <ref> [15] </ref> is run on the SPIN log structured file system [16]. BLUR a 2.5MB image is blurred while maintaining copies of modified pixels, similar to the way a paint program would operate. 2 We find that generational collection improves collection overheads.
Reference: [16] <author> M. Rosemblum and J.K. Ousterhout. </author> <title> The Design and Implementation of a LogStructured File System. </title> <booktitle> In Proceedings of the Thirteenth Symposium on Operating Systems Principles, </booktitle> <year> 1991. </year>
Reference-contexts: HTTPD SPINs web tree (65 files, 5MB) is copied 14 times by 10 concurrent, scalable web clients [14] via the SPIN inkernel web server. LFS a subset of the Andrew file system benchmark [15] is run on the SPIN log structured file system <ref> [16] </ref>. BLUR a 2.5MB image is blurred while maintaining copies of modified pixels, similar to the way a paint program would operate. 2 We find that generational collection improves collection overheads.
Reference: [17] <author> H. G. Baker. </author> <title> List Processing in Real-Time on a Serial Computer. </title> <journal> Communications of ACM, </journal> <volume> 21(4), </volume> <pages> pp. 28094, </pages> <year> 1978. </year>
Reference-contexts: In summary, although our user-level workloads exhibit more header wastage, internal fragmentation and sub-page external fragmentation than the kernel workloads, each can be addressed with a simple solution. 8. RELATED WORK Treadmill [5] is a non-copying version of Bakers real-time collector <ref> [17] </ref>. Wilsons improvements [9] reduce overhead and support bounded allocations for objects of any size but they do not address memory utilization. Johnstone and Wilson [18] also confirm fragmentation problems when multiple segregated lists are used.
Reference: [18] <author> M. S. Johnstone and P. R. Wilson. </author> <title> The Memory Fragmentation Problem: Solved?. </title> <booktitle> In Proceedings of OOPSLA97 Workshop on Garbage Collection in ObjectOriented Systems, </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: RELATED WORK Treadmill [5] is a non-copying version of Bakers real-time collector [17]. Wilsons improvements [9] reduce overhead and support bounded allocations for objects of any size but they do not address memory utilization. Johnstone and Wilson <ref> [18] </ref> also confirm fragmentation problems when multiple segregated lists are used. Page migration has been implemented before [19], but has typically relied on per-page object counts to reclaim pages. Since Treadmill deallocates objects implicitly, we 0 40 80 120 m3pp 5 15 25 m3 bar denotes application activity.
Reference: [19] <author> C. Weinstock. </author> <title> Dynamic Storage Allocation Techniques. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> April </month> <year> 1976. </year>
Reference-contexts: Wilsons improvements [9] reduce overhead and support bounded allocations for objects of any size but they do not address memory utilization. Johnstone and Wilson [18] also confirm fragmentation problems when multiple segregated lists are used. Page migration has been implemented before <ref> [19] </ref>, but has typically relied on per-page object counts to reclaim pages. Since Treadmill deallocates objects implicitly, we 0 40 80 120 m3pp 5 15 25 m3 bar denotes application activity.
Reference: [20] <author> P. T. Withington. </author> <title> How Real is Real Time' Garbage Collection?. </title> <booktitle> In Proceedings of OOPSLA91 Workshop on Garbage Collection in Object-Oriented Systems, </booktitle> <year> 1991. </year>
Reference-contexts: In addition, we have extended the idea of migration with remapping to further reduce external fragmentation. Virtual memory remapping has been used to reallocate mapped memory (Doug Lea's allocator) or to remap large objects instead of copying them <ref> [20] </ref>. We use remapping to create contiguous free regions, instead of moving live objects.
Reference: [21] <author> B. Baker, E. G. Coffman, and D. E. Willard. </author> <title> Algorithms for Resolving Conflicts in Dynamic Storage Allocation. </title> <journal> JACM, </journal> <volume> 32(2), </volume> <pages> pp. 327343, </pages> <month> April </month> <year> 1985. </year>
Reference: [22] <author> J. L. White. </author> <title> Address/Memory Management for a Gigantic Lisp Environment, or, GC Considered Harmful. </title> <booktitle> In Conference Record of the 1980 Lisp Conference, </booktitle> <address> Redwood Estates, CA, </address> <pages> pp. 119127, </pages> <month> August </month> <year> 1980. </year>
Reference: [23] <author> M. Spertus and G. Rodriguez-Rivera. </author> <title> A Non-Fragmenting, Non-Copying, Garbage Collector, </title> <note> submitted for publication, </note> <year> 1998. </year>
Reference-contexts: We have focussed on simplifying memory management by managing pages which is simpler and faster than buddy schemes, and has the advantage of enabling memory remapping. Some of our techniques have been independently developed for the Great Circle collector by Geodesic Systems <ref> [23] </ref>. Both collectors use a large object area to reduce fragmentation, and remap free memory into contiguous extents. The Great Circle collector uses deallocation and allocation to relocate memory. This is a viable technique for OS-es that do not export an interface to remap virtual pages.
References-found: 23

