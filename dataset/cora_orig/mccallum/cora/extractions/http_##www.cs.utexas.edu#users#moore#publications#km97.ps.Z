URL: http://www.cs.utexas.edu/users/moore/publications/km97.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/moore/best-ideas/acl2/index.html
Root-URL: 
Title: An Industrial Strength Theorem Prover for a Logic Based on Common Lisp for creating new
Author: Matt Kaufmann and J Strother Moore 
Keyword: Index termsformal verification, automatic theorem proving, computational logic, partial functions, total functions, type checking, microcode verification, floating point division, digital signal processing  
Date: 1  
Note: Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or  resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.  
Abstract: ACL2 is a re-implemented extended version of Boyer and Moore's Nqthm and Kaufmann's Pc-Nqthm, intended for large scale verification projects. This paper deals primarily with how we scaled up Nqthm's logic to an industrial strength programming language namely, a large applicative subset of Common Lisp while preserving the use of total functions within the logic. This makes it possible to run formal models efficiently while keeping the logic simple. We enumerate many other important features of ACL2 and we briefly summarize two industrial applications: a model of the Motorola CAP digital signal processing chip and the proof of the correctness of the kernel of the floating point division algorithm on the AMD5 K 86 microprocessor by Advanced Micro Devices, Inc. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. L. Akers. </author> <title> Strong Static Type Checking for Functional Common Lisp. </title> <type> Ph.D. Thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1993. </year> <note> Also available as Technical Report 96, Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703. URL http://www.cli.com/. </address>
Reference-contexts: Gold functions are well-typed. However, guards are much more expressive than conventional types, because they can be arbitrary terms in the logic. Of course, ACL2 type checking is not decidable for this same reason. For some related work, see <ref> [1] </ref>. If one attaches restrictive guards to one's functions and then proves the functions are gold, one obtains assurance that the functions are being exercised only on their intended domains.
Reference: [2] <author> K. Albin. </author> <title> 68020 Model Validation Testing, </title> <note> CLI Note 280, </note> <month> August </month> <year> 1993. </year>
Reference-contexts: The fact that the Nqthm logic is executable is also an important asset when using it to model hardware and software systems: the models can be executed as a means of corroborating their accuracy. Consider for example <ref> [2] </ref> where an Nqthm model of the MC68020 is corroborated against a fabricated chip by running 30,000 test vectors through the Nqthm model. Some of the largest formal verification projects done so far have been carried out with Nqthm.
Reference: [3] <author> D. Basin and M. Kaufmann, </author> <title> The Boyer-Moore Prover and Nuprl: An Experimental Comparison. </title> <booktitle> In: Proceedings of the First Workshop on Logical Frameworks, Antibes, </booktitle> <address> France, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: Bill Young's paper [42] in this Special Issue compares PVS and ACL2 on a particular example. ACL2's ancestral system, Nqthm, is compared to NuPRL in <ref> [3] </ref>. It is extremely difficult to compare two general-purpose theorem provers at least in part because experienced users can dramatically affect system behavior by proper formulation of the problems. That said, other systems cited above support logics more powerful than that of ACL2.
Reference: [4] <author> W. R. Bevier, W. A. Hunt, J S. Moore, and W.D. Young. </author> <title> Special Issue on System Verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4), </volume> <pages> 409-530, </pages> <year> 1989. </year>
Reference-contexts: History ACL2 is a direct descendant of the Boyer-Moore system, Nqthm [8, 9], and its interactive enhancement, Pc-Nqthm [23]. See [7] for an introduction to the two ancestral systems, including a reasonably large set of references for accomplishments using the systems. A few particular successes are described in <ref> [4, 5, 10, 22, 32, 26, 36, 38] </ref>. A tutorial introduction to the systems may be found in [24]. Like Nqthm, ACL2 supports a Lisp-like, first-order, quantifier-free mathematical logic based on recursively defined total functions. <p> Consider for example [2] where an Nqthm model of the MC68020 is corroborated against a fabricated chip by running 30,000 test vectors through the Nqthm model. Some of the largest formal verification projects done so far have been carried out with Nqthm. We cite explicitly the CLI short stack <ref> [4] </ref>, the design and fabrication of the FM9001 microprocessor [22], and the verification of the Berkeley C string library on top of the MC68020 microprocessor [10]. The formal models in these projects are collectively several hundred pages long and involve many functions.
Reference: [5] <author> W. R. Bevier and W. D. Young. </author> <title> Machine Checked Proofs of the Design of a Fault-Tolerant Circuit, </title> <journal> Formal Aspects of Computing, </journal> <volume> Vol. 4, </volume> <pages> pp. 755-775, </pages> <year> 1992. </year> <note> Also available as Technical Report 62, Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703, </address> <month> August, </month> <note> 1990 (URL http://www.cli.com/), and as NASA CR-182099, </note> <month> November, </month> <year> 1990. </year>
Reference-contexts: History ACL2 is a direct descendant of the Boyer-Moore system, Nqthm [8, 9], and its interactive enhancement, Pc-Nqthm [23]. See [7] for an introduction to the two ancestral systems, including a reasonably large set of references for accomplishments using the systems. A few particular successes are described in <ref> [4, 5, 10, 22, 32, 26, 36, 38] </ref>. A tutorial introduction to the systems may be found in [24]. Like Nqthm, ACL2 supports a Lisp-like, first-order, quantifier-free mathematical logic based on recursively defined total functions.
Reference: [6] <author> R. S. Boyer, D. Goldschlag, M. Kaufmann, and J S. Moore. </author> <title> Functional Instantiation in First Order Logic. </title> <booktitle> In Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <publisher> Academic Press, </publisher> <year> 1991, </year> <pages> pp. 7-26. </pages>
Reference-contexts: Theorems can then be proved about the constrained functions and these theorems can be instantiated in a higher-order way to derive analogous results about any functions satisfying the constraints. This is made possible by a derived rule of inference called functional instantiation <ref> [6] </ref>. The name encapsulation stems from the way the principle is implemented. An encapsulation command is essentially a wrapper around an admissible sequence of definitions and theorems. The wrapper allows one to mark certain of the definitions and theorems as local.
Reference: [7] <author> Robert S. Boyer, Matt Kaufmann, and J Strother Moore. </author> <title> The Boyer-Moore Theorem Prover and Its Interactive Enhancement. </title> <journal> Computers and Mathematics with Applications, </journal> <volume> 29(2), </volume> <year> 1995, </year> <pages> pp. 27-62. </pages>
Reference-contexts: History ACL2 is a direct descendant of the Boyer-Moore system, Nqthm [8, 9], and its interactive enhancement, Pc-Nqthm [23]. See <ref> [7] </ref> for an introduction to the two ancestral systems, including a reasonably large set of references for accomplishments using the systems. A few particular successes are described in [4, 5, 10, 22, 32, 26, 36, 38]. A tutorial introduction to the systems may be found in [24].
Reference: [8] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic, </title> <publisher> Academic Press: </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: See the URL http://www-formal.stanford.edu/clt/ARS/- ars-db.html for a data base of automated reasoning systems, including brief descriptions and links to the home pages of the systems mentioned and many more. 2. History ACL2 is a direct descendant of the Boyer-Moore system, Nqthm <ref> [8, 9] </ref>, and its interactive enhancement, Pc-Nqthm [23]. See [7] for an introduction to the two ancestral systems, including a reasonably large set of references for accomplishments using the systems. A few particular successes are described in [4, 5, 10, 22, 32, 26, 36, 38]. <p> See Section 6. The definitional principle ensures consistency by requiring a proof that each defined function terminates. This is done, as in Nqthm, by the identification of some ordinal measure of the formals that decreases in recursion. In <ref> [8] </ref> we show (for Nqthm) that this ensures that one and only one set-theoretic function satisfies the recursive definition, and that proof carries over to the ACL2 case, with appropriate treatment of the non-uniqueness of any constrained functions used in the definition.
Reference: [9] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook, </title> <publisher> Academic Press: </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: See the URL http://www-formal.stanford.edu/clt/ARS/- ars-db.html for a data base of automated reasoning systems, including brief descriptions and links to the home pages of the systems mentioned and many more. 2. History ACL2 is a direct descendant of the Boyer-Moore system, Nqthm <ref> [8, 9] </ref>, and its interactive enhancement, Pc-Nqthm [23]. See [7] for an introduction to the two ancestral systems, including a reasonably large set of references for accomplishments using the systems. A few particular successes are described in [4, 5, 10, 22, 32, 26, 36, 38].
Reference: [10] <author> R. S. Boyer and Y. Yu, </author> <title> Automated Correctness Proofs of Machine Code Programs for a Commercial Microprocessor. </title> <editor> In D. Kapur, editor, </editor> <booktitle> Automated Deduction - CADE-11, Lecture Notes in Computer Science 607, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> 416-430, </pages> <year> 1992. </year>
Reference-contexts: History ACL2 is a direct descendant of the Boyer-Moore system, Nqthm [8, 9], and its interactive enhancement, Pc-Nqthm [23]. See [7] for an introduction to the two ancestral systems, including a reasonably large set of references for accomplishments using the systems. A few particular successes are described in <ref> [4, 5, 10, 22, 32, 26, 36, 38] </ref>. A tutorial introduction to the systems may be found in [24]. Like Nqthm, ACL2 supports a Lisp-like, first-order, quantifier-free mathematical logic based on recursively defined total functions. <p> Some of the largest formal verification projects done so far have been carried out with Nqthm. We cite explicitly the CLI short stack [4], the design and fabrication of the FM9001 microprocessor [22], and the verification of the Berkeley C string library on top of the MC68020 microprocessor <ref> [10] </ref>. The formal models in these projects are collectively several hundred pages long and involve many functions. Despite such successes, Nqthm was not designed for these kinds of large-scale projects and it has several inadequacies. <p> Every well-defined behavior of the CAP is modeled, including the pipeline, I/O, interrupts, breakpoints and traps (but excluding the hard and soft reset sequences). The CAP is much more complex than other processors recently subjected to formal modeling, namely the FM90001 [22], MC68020 <ref> [10] </ref>, and AAMP5 [30]. In principle, a CAP single instruction can simultaneously modify well over 100 registers. Brock's ACL2 model of the CAP is bit-accurate and cycle-accurate but runs faster than Motorola's SPW model. Furthermore, ACL2 can be used to reason about the CAP model. <p> This work is discussed further in [12]. Following the same approach used with Nqthm for the MC68020 in <ref> [10] </ref>, Brock configured ACL2 so as to make it easy to symbolically execute a CAP microcode program on symbolic data. He then specified and mechanically proved the total correctness of the microcode programs he considered.
Reference: [11] <author> R. K. Brayton, G. D. Hachtel, A. Sangiovanni-Vincentelli, F. Somenzi, A. Aziz, S.-T. Cheng, S. Ed-wards, S. Khatri, Y. Kukimoto, A. Pardo, S. Qadeer, R. K. Ranjan, S. Sarwary, T. R. Shiple, G. Swamy, T. Villa. </author> <title> VIS: A system for Verification and Synthesis. </title> <booktitle> 8th Intl. Conf. on Computer-Aided Verification, </booktitle> <month> July, </month> <year> 1996. </year>
Reference-contexts: Active research continues in automated reasoning in a number of areas. Here is an incomplete list. In each case we give one or two representative systems. Certainly the areas below contain considerable overlap. * Provers providing strong support for specification of computing systems (see below) * CTL model checkers <ref> [29, 11] </ref> * Geometry provers [13] * First-order provers [28] * Classical Mathematics [21], [41] * Constructive Mathematics [15, 16] * Provers with symbolic computation engines [14] * Meta-theoretic systems [34] Provers in the first category are distinguished by the convenience they offer for specifying computing systems.
Reference: [12] <author> B. Brock, M. Kaufmann and J S. Moore. </author> <title> ACL2 Theorems about Commercial Microprocessors. </title> <editor> In M. Srivas and A. Camilleri, editors, </editor> <booktitle> Formal Methods in Computer-Aided Design (FMCAD'96), </booktitle> <publisher> Springer-Verlag, </publisher> <month> November </month> <year> 1996 </year> <month> (to appear). </month>
Reference-contexts: The first two important applications of ACL2 support our claims that it is up to the task. These applications, summarized below, are discussed in more detail in <ref> [12] </ref> and [31], where we also detail the time and manpower resources spent on the component tasks. 7.1. <p> Brock used ACL2 to verify the microcode produced by Motorola's assembler for several CAP application programs, including a FIR filter and a peak finding algorithm that uses the adder array as a chain of comparators. This work is discussed further in <ref> [12] </ref>. Following the same approach used with Nqthm for the MC68020 in [10], Brock configured ACL2 so as to make it easy to symbolically execute a CAP microcode program on symbolic data. He then specified and mechanically proved the total correctness of the microcode programs he considered.
Reference: [13] <author> S.-C. Chou, </author> <title> Mechanical Geometry Theorem Proving, </title> <address> D. </address> <publisher> Reidel Publishing Co., Dordrecht, Holland, </publisher> <year> 1988. </year>
Reference-contexts: Here is an incomplete list. In each case we give one or two representative systems. Certainly the areas below contain considerable overlap. * Provers providing strong support for specification of computing systems (see below) * CTL model checkers [29, 11] * Geometry provers <ref> [13] </ref> * First-order provers [28] * Classical Mathematics [21], [41] * Constructive Mathematics [15, 16] * Provers with symbolic computation engines [14] * Meta-theoretic systems [34] Provers in the first category are distinguished by the convenience they offer for specifying computing systems.
Reference: [14] <author> E. M. Clarke and X. Zhao. </author> <title> Analytica: A theorem prover for Mathematica. </title> <journal> The Journal of Mathemat-ica, </journal> <volume> 3(1), </volume> <pages> pp. </pages> <month> 56-71,Winter </month> <year> 1993. </year>
Reference-contexts: Certainly the areas below contain considerable overlap. * Provers providing strong support for specification of computing systems (see below) * CTL model checkers [29, 11] * Geometry provers [13] * First-order provers [28] * Classical Mathematics [21], [41] * Constructive Mathematics [15, 16] * Provers with symbolic computation engines <ref> [14] </ref> * Meta-theoretic systems [34] Provers in the first category are distinguished by the convenience they offer for specifying computing systems.
Reference: [15] <author> R. L. Constable, et al., </author> <title> Implementing Mathematics with the Nuprl Proof Development System, </title> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: Certainly the areas below contain considerable overlap. * Provers providing strong support for specification of computing systems (see below) * CTL model checkers [29, 11] * Geometry provers [13] * First-order provers [28] * Classical Mathematics [21], [41] * Constructive Mathematics <ref> [15, 16] </ref> * Provers with symbolic computation engines [14] * Meta-theoretic systems [34] Provers in the first category are distinguished by the convenience they offer for specifying computing systems.
Reference: [16] <author> C. Cornes, J. Courant, J.-C. Filliatre, G. Huet, P. Manoury, et al. </author> <title> The Coq Proof Assistant, Reference Manual, </title> <type> Version 5.10. </type> <institution> RT-0177, INRIA, </institution> <address> B.P. 105, 78153 Le Chesnay Cedex, France. </address>
Reference-contexts: Certainly the areas below contain considerable overlap. * Provers providing strong support for specification of computing systems (see below) * CTL model checkers [29, 11] * Geometry provers [13] * First-order provers [28] * Classical Mathematics [21], [41] * Constructive Mathematics <ref> [15, 16] </ref> * Provers with symbolic computation engines [14] * Meta-theoretic systems [34] Provers in the first category are distinguished by the convenience they offer for specifying computing systems.
Reference: [17] <author> D. Craigen, S. Kromodimoeljo, I. Meisels, B. Pase, M. Saaltink. </author> <title> EVES: An Overview. </title> <note> Odyssey Research Center, ORA Conference Paper CP-91-5402-43, </note> <month> March, </month> <year> 1991. </year>
Reference-contexts: The first category may be subdivided as follows. * Higher-order tactic-based provers, e.g., HOL [20] * Higher-order heavily-automated provers, e.g., PVS [18] * First-order heavily-automated provers, e.g., ACL2 and Nqthm * Provers integrated into program verification systems, e.g., Never/EVES <ref> [17] </ref> Again, space does not permit detailed comparisons here. Bill Young's paper [42] in this Special Issue compares PVS and ACL2 on a particular example. ACL2's ancestral system, Nqthm, is compared to NuPRL in [3].
Reference: [18] <author> J. Crow, S. Owre, J. Rushby, N. Shankar, and M. Sri-vas. </author> <title> A Tutorial Introduction to PVS, presented at Workshop on Industrial-Strength Formal Specification Techniques, </title> <address> Boca Raton, FL, </address> <note> April 1995 (see http://www.csl.sri.com/pvs.html). </note>
Reference-contexts: The first category may be subdivided as follows. * Higher-order tactic-based provers, e.g., HOL [20] * Higher-order heavily-automated provers, e.g., PVS <ref> [18] </ref> * First-order heavily-automated provers, e.g., ACL2 and Nqthm * Provers integrated into program verification systems, e.g., Never/EVES [17] Again, space does not permit detailed comparisons here. Bill Young's paper [42] in this Special Issue compares PVS and ACL2 on a particular example.
Reference: [19] <author> S. Gilfeather, J. Gehman, and C. Harrison. </author> <title> Architecture of a Complex Arithmetic Processor for Communication Signal Processing. </title> <booktitle> In SPIE Proceedings, International Symposium on Optics, Imaging, and Instrumentation, 2296 Advanced Signal Processing: Algorithms, Architectures, and Implementations V, </booktitle> <pages> 624-625, </pages> <month> July, </month> <year> 1994. </year>
Reference-contexts: Motorola CAP Digital Signal Processor Bishop Brock of CLI, working in collaboration with Mo-torola, Inc., produced an executable formal ACL2 specification of the Motorola CAP <ref> [19] </ref>, a digital signal processor designed by Motorola to execute a 1024 point complex FFT in 131 microseconds. Every well-defined behavior of the CAP is modeled, including the pipeline, I/O, interrupts, breakpoints and traps (but excluding the hard and soft reset sequences).
Reference: [20] <author> M. J. C. Gordon and T. F. </author> <title> Melham (editors). Introduction to HOL: A Theorem Proving Environment for Higher-Order Logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: Cases could be made that each prover in the first category has capabilities in most of the other categories; conversely, some provers in the other categories could be placed in this one. The first category may be subdivided as follows. * Higher-order tactic-based provers, e.g., HOL <ref> [20] </ref> * Higher-order heavily-automated provers, e.g., PVS [18] * First-order heavily-automated provers, e.g., ACL2 and Nqthm * Provers integrated into program verification systems, e.g., Never/EVES [17] Again, space does not permit detailed comparisons here. Bill Young's paper [42] in this Special Issue compares PVS and ACL2 on a particular example.
Reference: [21] <author> W. M. Farmer, J. D. Guttman, and F. J. Thayer. IMPS: </author> <title> An Interactive Mathematical Proof System. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 11(2), </volume> <pages> 213-248, </pages> <year> 1993. </year>
Reference-contexts: In each case we give one or two representative systems. Certainly the areas below contain considerable overlap. * Provers providing strong support for specification of computing systems (see below) * CTL model checkers [29, 11] * Geometry provers [13] * First-order provers [28] * Classical Mathematics <ref> [21] </ref>, [41] * Constructive Mathematics [15, 16] * Provers with symbolic computation engines [14] * Meta-theoretic systems [34] Provers in the first category are distinguished by the convenience they offer for specifying computing systems.
Reference: [22] <author> W. A. Hunt, Jr. and B. Brock. </author> <title> A Formal HDL and its use in the FM9001 Verification. </title> <journal> Proceedings of the Royal Society, </journal> <year> 1992. </year>
Reference-contexts: History ACL2 is a direct descendant of the Boyer-Moore system, Nqthm [8, 9], and its interactive enhancement, Pc-Nqthm [23]. See [7] for an introduction to the two ancestral systems, including a reasonably large set of references for accomplishments using the systems. A few particular successes are described in <ref> [4, 5, 10, 22, 32, 26, 36, 38] </ref>. A tutorial introduction to the systems may be found in [24]. Like Nqthm, ACL2 supports a Lisp-like, first-order, quantifier-free mathematical logic based on recursively defined total functions. <p> Some of the largest formal verification projects done so far have been carried out with Nqthm. We cite explicitly the CLI short stack [4], the design and fabrication of the FM9001 microprocessor <ref> [22] </ref>, and the verification of the Berkeley C string library on top of the MC68020 microprocessor [10]. The formal models in these projects are collectively several hundred pages long and involve many functions. <p> Every well-defined behavior of the CAP is modeled, including the pipeline, I/O, interrupts, breakpoints and traps (but excluding the hard and soft reset sequences). The CAP is much more complex than other processors recently subjected to formal modeling, namely the FM90001 <ref> [22] </ref>, MC68020 [10], and AAMP5 [30]. In principle, a CAP single instruction can simultaneously modify well over 100 registers. Brock's ACL2 model of the CAP is bit-accurate and cycle-accurate but runs faster than Motorola's SPW model. Furthermore, ACL2 can be used to reason about the CAP model.
Reference: [23] <author> M. Kaufmann. </author> <title> A User's Manual for an Interactive Enhancement to the Boyer-Moore Theorem Prover, </title> <type> Technical report 19, </type> <institution> Computational Logic, Inc., </institution> <month> May, </month> <year> 1988. </year> <note> URL http://www.cli.com/. </note>
Reference-contexts: See the URL http://www-formal.stanford.edu/clt/ARS/- ars-db.html for a data base of automated reasoning systems, including brief descriptions and links to the home pages of the systems mentioned and many more. 2. History ACL2 is a direct descendant of the Boyer-Moore system, Nqthm [8, 9], and its interactive enhancement, Pc-Nqthm <ref> [23] </ref>. See [7] for an introduction to the two ancestral systems, including a reasonably large set of references for accomplishments using the systems. A few particular successes are described in [4, 5, 10, 22, 32, 26, 36, 38]. A tutorial introduction to the systems may be found in [24].
Reference: [24] <author> M. Kaufmann and P. Pecchiari. </author> <title> Interaction with the Boyer-Moore Theorem Prover: A Tutorial Study Using the Arithmetic-Geometric Mean Theorem. </title> <journal> Journal of Automated Reasoning 16, </journal> <volume> no. </volume> <month> 1-2 </month> <year> (1996) </year> <month> 181-222. </month>
Reference-contexts: See [7] for an introduction to the two ancestral systems, including a reasonably large set of references for accomplishments using the systems. A few particular successes are described in [4, 5, 10, 22, 32, 26, 36, 38]. A tutorial introduction to the systems may be found in <ref> [24] </ref>. Like Nqthm, ACL2 supports a Lisp-like, first-order, quantifier-free mathematical logic based on recursively defined total functions. Experience with the earlier systems supports the claim that such a logic is sufficiently expressive to permit one to address deep mathematical problems and realistic verification projects.
Reference: [25] <author> M. Kaufmann and J S. Moore, </author> <title> High-Level Correctness of ACL2: A Story (DRAFT), </title> <address> URL ftp://ftp.cli.com/pub/acl2/v1-8/acl2-sources/- reports/story.txt, </address> <month> September, </month> <year> 1995. </year> <note> Revision in preparation. </note>
Reference-contexts: Extension Principles Finally, ACL2 has two extension principles: definition and encapsulation. Both preserve the consistency of the extended logic <ref> [25] </ref>.
Reference: [26] <author> K. Kunen. </author> <title> A Ramsey Theorem in Boyer-Moore Logic, </title> <journal> Journal of Automated Reasoning, </journal> <volume> 15(2) Oc-tober, </volume> <year> 1995. </year>
Reference-contexts: History ACL2 is a direct descendant of the Boyer-Moore system, Nqthm [8, 9], and its interactive enhancement, Pc-Nqthm [23]. See [7] for an introduction to the two ancestral systems, including a reasonably large set of references for accomplishments using the systems. A few particular successes are described in <ref> [4, 5, 10, 22, 32, 26, 36, 38] </ref>. A tutorial introduction to the systems may be found in [24]. Like Nqthm, ACL2 supports a Lisp-like, first-order, quantifier-free mathematical logic based on recursively defined total functions.
Reference: [27] <author> L. Lamport, </author> <title> Types are Not Harmless, </title> <address> http://www.- research.digital.com/SRC/tla/tla.html, </address> <month> July, </month> <year> 1995. </year>
Reference-contexts: Some of these same points are made in <ref> [27] </ref>. The decision that guards will not affect the definitional axioms thus has a far reaching effect.
Reference: [28] <author> W. McCune. </author> <title> Otter 3.0 Reference Manual and Guide. </title> <type> Report ANl-94/6, </type> <institution> Argonne National Laboratory (1994). </institution>
Reference-contexts: Here is an incomplete list. In each case we give one or two representative systems. Certainly the areas below contain considerable overlap. * Provers providing strong support for specification of computing systems (see below) * CTL model checkers [29, 11] * Geometry provers [13] * First-order provers <ref> [28] </ref> * Classical Mathematics [21], [41] * Constructive Mathematics [15, 16] * Provers with symbolic computation engines [14] * Meta-theoretic systems [34] Provers in the first category are distinguished by the convenience they offer for specifying computing systems.
Reference: [29] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Active research continues in automated reasoning in a number of areas. Here is an incomplete list. In each case we give one or two representative systems. Certainly the areas below contain considerable overlap. * Provers providing strong support for specification of computing systems (see below) * CTL model checkers <ref> [29, 11] </ref> * Geometry provers [13] * First-order provers [28] * Classical Mathematics [21], [41] * Constructive Mathematics [15, 16] * Provers with symbolic computation engines [14] * Meta-theoretic systems [34] Provers in the first category are distinguished by the convenience they offer for specifying computing systems.
Reference: [30] <author> S. P. Miller and M. Srivas. </author> <title> Formal Verification of the AAMP5 Microprocessor: A Case Study in the Industrial Use of Formal Methods, </title> <booktitle> in Proceedings of WIFT '95: Workshop on Industrial-Strength Formal Specification Techniques, </booktitle> <address> IEEECS, </address> <month> April, </month> <year> 1995, </year> <pages> pp. 2-16. </pages>
Reference-contexts: Every well-defined behavior of the CAP is modeled, including the pipeline, I/O, interrupts, breakpoints and traps (but excluding the hard and soft reset sequences). The CAP is much more complex than other processors recently subjected to formal modeling, namely the FM90001 [22], MC68020 [10], and AAMP5 <ref> [30] </ref>. In principle, a CAP single instruction can simultaneously modify well over 100 registers. Brock's ACL2 model of the CAP is bit-accurate and cycle-accurate but runs faster than Motorola's SPW model. Furthermore, ACL2 can be used to reason about the CAP model.
Reference: [31] <author> J S. Moore, T. Lynch, and M. Kaufmann. </author> <title> A Mechanically Checked Proof of the Correctness of the Kernel of the AMD5 K 86 Floating Point Division Algorithm, </title> <month> March, </month> <note> 1996 (submitted). URL http://- devil.ece.utexas.edu:80/~lynch/divide/divide.html. </note>
Reference-contexts: The first two important applications of ACL2 support our claims that it is up to the task. These applications, summarized below, are discussed in more detail in [12] and <ref> [31] </ref>, where we also detail the time and manpower resources spent on the component tasks. 7.1. <p> In particular, in <ref> [31] </ref> we prove that when p and d are double extended precision floating-point numbers (d 6= 0) and mode is a rounding mode specifying a rounding style and target format of precision n 64, then the result of the algorithm is p=d rounded according to mode. <p> As explained in detail in <ref> [31] </ref>, the algorithm uses a table to obtain an 8-bit approximation to the reciprocal of d. Then two iterations of an efficiently computed variation of the Newton-Raphson iteration are used to refine this approximation so that the relative error is less than 2 28 .
Reference: [32] <author> J S. Moore. </author> <title> A Formal Model of Asynchronous Communication and Its Use in Mechanically Verifying a Biphase Mark Protocol, </title> <booktitle> Formal Aspects of Computing 6(1), </booktitle> <pages> 60-91, </pages> <year> 1994. </year>
Reference-contexts: History ACL2 is a direct descendant of the Boyer-Moore system, Nqthm [8, 9], and its interactive enhancement, Pc-Nqthm [23]. See [7] for an introduction to the two ancestral systems, including a reasonably large set of references for accomplishments using the systems. A few particular successes are described in <ref> [4, 5, 10, 22, 32, 26, 36, 38] </ref>. A tutorial introduction to the systems may be found in [24]. Like Nqthm, ACL2 supports a Lisp-like, first-order, quantifier-free mathematical logic based on recursively defined total functions.
Reference: [33] <author> J S. Moore. </author> <title> Introduction to the OBDD Algorithm for the ATP Community, </title> <journal> Journal of Automated Reasoning 12, </journal> <pages> 33-45, </pages> <year> 1994. </year>
Reference-contexts: The most important inadequacy of Nqthm is its lack of theorem proving power: if it would quickly settle every question put to it, one could proceed more efficiently. While we are always looking for better proof techniques (e.g., <ref> [33] </ref>), we do not know how to build a significantly more powerful and automatic theorem prover for Nqthm's logic. 2 Therefore, to scale up Nqthm we focused on engineering issues.
Reference: [34] <author> L. C. Paulson, </author> <title> Isabelle: A Generic Theorem Prover, </title> <publisher> Springer-Verlag LNCS 828, </publisher> <year> 1994. </year>
Reference-contexts: below contain considerable overlap. * Provers providing strong support for specification of computing systems (see below) * CTL model checkers [29, 11] * Geometry provers [13] * First-order provers [28] * Classical Mathematics [21], [41] * Constructive Mathematics [15, 16] * Provers with symbolic computation engines [14] * Meta-theoretic systems <ref> [34] </ref> Provers in the first category are distinguished by the convenience they offer for specifying computing systems. Cases could be made that each prover in the first category has capabilities in most of the other categories; conversely, some provers in the other categories could be placed in this one.
Reference: [35] <author> K. M. Pitman et al. </author> <title> draft proposed American National Standard for Information Systems Programming Language Common Lisp; X3J13/93-102. Global Engineering Documents, </title> <publisher> Inc., </publisher> <year> 1994. </year>
Reference-contexts: We released the first public version of ACL2 in September, 1995. See the URL http://www.cli.com. 3. The ACL2 Logic The definition of Common Lisp used in our work has been [39, 40]. We have also closely studied <ref> [35] </ref>. The ACL2 logic is a first-order, quantifier-free logic of total recursive functions providing mathematical induction on the ordinals up to * 0 and two extension principles: one for recursive definition and one for encapsulation. We sketch the logic here. 3.1.
Reference: [36] <author> D. M. Russinoff. </author> <title> A Mechanical Proof of Quadratic Reciprocity. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 8(1), </volume> <pages> 3-21, </pages> <year> 1992. </year>
Reference-contexts: History ACL2 is a direct descendant of the Boyer-Moore system, Nqthm [8, 9], and its interactive enhancement, Pc-Nqthm [23]. See [7] for an introduction to the two ancestral systems, including a reasonably large set of references for accomplishments using the systems. A few particular successes are described in <ref> [4, 5, 10, 22, 32, 26, 36, 38] </ref>. A tutorial introduction to the systems may be found in [24]. Like Nqthm, ACL2 supports a Lisp-like, first-order, quantifier-free mathematical logic based on recursively defined total functions.
Reference: [37] <author> D. Russinoff, </author> <title> A Mechanically Checked Proof of Correctness of the AMD5 K 86 Floating-Point Square Root Microcode, </title> <address> http://www.onr.com/user/- russ/david/fsqrt.html, </address> <month> February, </month> <year> 1997. </year>
Reference-contexts: Subsequent to our proof of the floating-point division microcode, David Russinoff used ACL2 to prove the correctness of the AMD5 K 86 's floating-point square root microcode <ref> [37] </ref>. 8. Conclusion ACL2 is a re-implemented extended version of Boyer and Moore's Nqthm and Kaufmann's Pc-Nqthm, intended for large scale verification projects.
Reference: [38] <author> N. Shankar. </author> <title> Metamathematics, Machines, and G odel's Proof, </title> <publisher> Cambridge University press, </publisher> <year> 1994. </year>
Reference-contexts: History ACL2 is a direct descendant of the Boyer-Moore system, Nqthm [8, 9], and its interactive enhancement, Pc-Nqthm [23]. See [7] for an introduction to the two ancestral systems, including a reasonably large set of references for accomplishments using the systems. A few particular successes are described in <ref> [4, 5, 10, 22, 32, 26, 36, 38] </ref>. A tutorial introduction to the systems may be found in [24]. Like Nqthm, ACL2 supports a Lisp-like, first-order, quantifier-free mathematical logic based on recursively defined total functions.
Reference: [39] <author> G. L. Steele Jr. </author> <title> Common LISP: The Language, </title> <publisher> Digital Press: </publisher> <address> Bedford, MA, </address> <year> 1984. </year>
Reference-contexts: ACL2 has been used in modeling and verification projects within Computational Logic, Inc. (CLI), for several years. We released the first public version of ACL2 in September, 1995. See the URL http://www.cli.com. 3. The ACL2 Logic The definition of Common Lisp used in our work has been <ref> [39, 40] </ref>. We have also closely studied [35]. The ACL2 logic is a first-order, quantifier-free logic of total recursive functions providing mathematical induction on the ordinals up to * 0 and two extension principles: one for recursive definition and one for encapsulation. We sketch the logic here. 3.1. <p> Axioms Defining Other Primitive Function Symbols Essentially all of the Common Lisp functions on the above data types are axiomatized or defined as functions or macros in ACL2. By Common Lisp functions here we mean the programs specified in <ref> [39] </ref> or [40] that are (i) applicative, (ii) not dependent on state, implicit parameters, or data types other than those in ACL2, and (iii) completely specified, unambiguously, in a host-independent manner. Approximately 170 such functions are axiomatized. Common Lisp functions are partial; they are not defined for all possible inputs.
Reference: [40] <author> G. L. Steele, Jr. </author> <title> Common Lisp The Language, Second Edition. </title> <publisher> Digital Press, </publisher> <address> 30 North Avenue, Burlington, MA 01803, </address> <year> 1990. </year>
Reference-contexts: ACL2 has been used in modeling and verification projects within Computational Logic, Inc. (CLI), for several years. We released the first public version of ACL2 in September, 1995. See the URL http://www.cli.com. 3. The ACL2 Logic The definition of Common Lisp used in our work has been <ref> [39, 40] </ref>. We have also closely studied [35]. The ACL2 logic is a first-order, quantifier-free logic of total recursive functions providing mathematical induction on the ordinals up to * 0 and two extension principles: one for recursive definition and one for encapsulation. We sketch the logic here. 3.1. <p> Axioms Defining Other Primitive Function Symbols Essentially all of the Common Lisp functions on the above data types are axiomatized or defined as functions or macros in ACL2. By Common Lisp functions here we mean the programs specified in [39] or <ref> [40] </ref> that are (i) applicative, (ii) not dependent on state, implicit parameters, or data types other than those in ACL2, and (iii) completely specified, unambiguously, in a host-independent manner. Approximately 170 such functions are axiomatized. Common Lisp functions are partial; they are not defined for all possible inputs. <p> Exceptional execution efficiency on a wide variety of platforms, combined with clear applicative semantics when used properly, was one of the great attractions of basing the ACL2 logic on Common Lisp. Consider for example the primitive function car. Page 411 of <ref> [40] </ref> says that the argument to car must be a cons or nil. On page 6 we learn In places where it is stated that so-and-so `must' or `must not' or `may not' be the case, then it `is an error' if the stated requirement is not met. <p> Consider any Common Lisp compliant to <ref> [40] </ref> into which the ACL2 kernel has been loaded. Load the book into that Lisp. Let x be a Common Lisp object that is also an object of ACL2.
Reference: [41] <author> A. Trybulec. </author> <title> Built-in Concepts. </title> <journal> Journal of Formalized Mathematics, </journal> <volume> Axiomatics, </volume> <year> 1989. </year>
Reference-contexts: In each case we give one or two representative systems. Certainly the areas below contain considerable overlap. * Provers providing strong support for specification of computing systems (see below) * CTL model checkers [29, 11] * Geometry provers [13] * First-order provers [28] * Classical Mathematics [21], <ref> [41] </ref> * Constructive Mathematics [15, 16] * Provers with symbolic computation engines [14] * Meta-theoretic systems [34] Provers in the first category are distinguished by the convenience they offer for specifying computing systems.

References-found: 41

