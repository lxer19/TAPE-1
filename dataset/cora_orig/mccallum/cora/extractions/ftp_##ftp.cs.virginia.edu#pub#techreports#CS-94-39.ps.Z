URL: ftp://ftp.cs.virginia.edu/pub/techreports/CS-94-39.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: A Formal Model and Specification Language for Procedure Calling Conventions  
Author: Mark W. Bailey Jack W. Davidson 
Abstract: Computer Science Report No. CS-94-39 October 21, 1994 
Abstract-found: 1
Intro-found: 1
Reference: [B AIL 93] <author> Bailey, M.W. and Davidson, J.W. </author> <title> A Formal Specification for Procedure Calling Conventions . Technical Report CS-93-59. </title> <institution> University of Virginia, </institution> <year> 1993. </year>
Reference: [B AIL 94] <author> Bailey, M.W. and Davidson, J.W. </author> <title> A Formal Model for Procedure Calling Conventions . Technical Report CS-94-57. </title> <institution> University of Virginia, </institution> <year> 1994. </year>
Reference: [B ENI 88] <author> Benitez, M.E. and Davidson, J.W. </author> <title> A Portable Global Optimizer and Linker. </title> <booktitle> In Proceedings of the SIGPLAN 88 Conference on Programming Language Design and Implementation , Atlanta, </booktitle> <address> Georgia, </address> <month> June, </month> <year> 1988, </year> <pages> 329-338. </pages>
Reference-contexts: This code is replaced by the P-FSA tables and a simple automaton interpreter. 6.2 Realizing the Calling Sequence In this section, we present how the information from our CCL descriptions can be used to generate calling sequences for the vpcc/ vpo optimizing compiler <ref> [B ENI 88] </ref>[B ENI 94]. In our compiler, the code for the procedure bodies is generated without knowledge of the calling convention. For a callee, the optimizer treats formal parameters as local variables.
Reference: [B ENI 94] <author> Benitez, M.E. and Davidson, J.W. </author> <title> The Advantages of MachineDependent Global Optimization. </title> <booktitle> In Proceedings of the 1994 Conference on Programming Languages and Systems Architectures , Zurich, </booktitle> <address> Switzerland, </address> <month> March </month> <year> 1994, </year> <pages> 105-124. </pages>
Reference: [D AVI 91] <author> Davidson, J.W. and Whalley, </author> <title> D.B. Methods for Saving and Restoring Register Values across Function Calls. </title> <note> SoftwarePractice and Experience 21(2):149165 February 1991. </note>
Reference-contexts: However, the convention makes many choices that directly affect the efficiency of calling procedures. We therefore feel that it is important to experiment with different conventions on each to tune the convention to the machine. Davidson and Whalley have performed a limited experiment in investigating different calling conventions <ref> [D AVI 91] </ref>. However, due to the enormous amount of work required to change their compiler from one calling convention to another, their experiment was limited to several different methods of saving and restoring registers. 1.3 Contributions This paper makes several contributions. <p> For example, Johnson and Richie discuss some rules of thumb for designing and implementing a calling sequence for the C programming language [J OHNSON ]. Davidson and Whalley experimentally evaluated several different C calling conventions <ref> [D AVI 91] </ref>. No attempts have been made to formally analyze calling conventions. On the other hand, the use of FSA for modeling parts of a compiler, and as an implementation tool has a long and successful history.
Reference: [DEC78] <institution> Digital Equipment Corporation. VAX Architecture Handbook . Digital Equipment Corporation, </institution> <year> 1978. </year>
Reference: [DEC93] <institution> Digital Equipment Corporation. Calling Standard for AXP Systems . Digital Equipment Corporation, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Furthermore, the convention, once understood, is difficult to implement. For example, the GNU ANSI C compiler fails on an example listed in the manual. Digital, in recognizing the problem, has published a calling standard document for their new Alpha series processors <ref> [DEC93] </ref> that exceeds 100 pages 4 .
Reference: [F RAS 93] <author> Fraser, C.W. </author> <type> Personal Communication, </type> <month> November, </month> <year> 1993. </year>
Reference-contexts: For example, in the MIPS programmers manual [K ANE 92] the English description is so difficult to understand that the authors provide fifteen examples, several of which are contradictory <ref> [F RAS 93] </ref>and this is the second edition. Furthermore, the convention, once understood, is difficult to implement. For example, the GNU ANSI C compiler fails on an example listed in the manual.
Reference: [G RIS 90] <author> Griswold, R.E. and Griswold, </author> <title> M.T. The Icon Programming Language , 2nd edition, </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: By doing so, we prevent external inconsistencies by requiring the caller and callee use the same implementation for the placement mapping. 6 The Implementation 6.1 The Interpreter We have implemented an interpreter for the CCL specification language. The interpreters source is approximately 2500 lines of Icon code <ref> [G RIS 90] </ref>. The interpreter takes as input the CCL description of a procedure calling convention, a procedures signature, and some additional information about the target architecture, and produces locations of the values to be transmitted, in terms of both the callee and the callers frame of reference.
Reference: [H OPC 79] <author> Hopcroft, J.E. and Ullman, J.D. </author> <title> Introduction to Automata Theory, Languages, </title> <publisher> and Computation . Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: This can easily be extended to model more than one infinite resource. 2. In this paper, we use the notation of Hopcroft and Ullman for finite state automata and regular expressions <ref> [H OPC 79] </ref>. We use letters early in the alphabet ( a , b , c ) to denote single symbols. <p> We also define : Q S * fi Q and : Q S * fi D * which are just string versions (defined by Hopcroft and Ullman <ref> [H OPC 79] </ref>) of d and l, respectively.
Reference: [J OHNSON ] <author> Johnson, S.C. and Ritchie, </author> <title> D.M. The C Language Calling Sequence . Bell Labs. </title>
Reference-contexts: Science University of Virginia Charlottesville, VA 22903, U.S.A. 1 This is a fake footnote To appear in The 22nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages , POPL 95, San Francisco, CA, January 1995. 2 viding an efficient calling sequence after one has already defined a calling convention <ref> [J OHNSON ] </ref>. However, the convention makes many choices that directly affect the efficiency of calling procedures. We therefore feel that it is important to experiment with different conventions on each to tune the convention to the machine. <p> In the C language, the mechanism used is varargs which is more a convention than a language feature. Johnson and Ritchie spend considerable time explaining the ramifications that varargs has on the calling sequence <ref> [J OHNSON ] </ref>. In fact, providing support for C s varargs frequently has profound influence on the calling convention. However, in C , procedures that receive variable numbers of arguments still adhere to the defined calling convention. <p> For example, Johnson and Richie discuss some rules of thumb for designing and implementing a calling sequence for the C programming language <ref> [J OHNSON ] </ref>. Davidson and Whalley experimentally evaluated several different C calling conventions [D AVI 91]. No attempts have been made to formally analyze calling conventions.
Reference: [J OHN 68] <author> Johnson, W.L., J.H. Porter, S.I. Ackley, and D.T. Ross. </author> <title> Automatic generation of efficient lexical processors using finite state techniques, </title> <journal> Communications of the ACM , 11:(12), </journal> <volume> 805813. </volume>
Reference-contexts: No attempts have been made to formally analyze calling conventions. On the other hand, the use of FSA for modeling parts of a compiler, and as an implementation tool has a long and successful history. For example, Johnson et al. <ref> [J OHN 68] </ref> describe the use of FSAs to implement lexical analyzers.
Reference: [K ANE 92] <author> Kane, G. and Heinrich, J. </author> <title> MIPS RISC Architecture . Prentice Hall, </title> <year> 1992. </year>
Reference-contexts: The called procedure is known as the callee . equally problematical. As with much of the information in the programmers manual, the description is likely to be written in English and is liable to be ambiguous, or inaccurate. For example, in the MIPS programmers manual <ref> [K ANE 92] </ref> the English description is so difficult to understand that the authors provide fifteen examples, several of which are contradictory [F RAS 93]and this is the second edition. Furthermore, the convention, once understood, is difficult to implement.
Reference: [K ERN 78] <author> Kernighan, B.W. and Ritchie, </author> <title> D.M. </title> <booktitle> The C Programming Language . Prentice-Hall, </booktitle> <year> 1978. </year>
Reference-contexts: All other variables whose values are provided by the outer environment are declared using the external statement. A CCL description is typically language dependent as well. This is, in part, because the language definition influences the calling convention. For example, the C language <ref> [K ERN 78] </ref> defines a slightly different calling convention than its successor ANSI C 5 [K ERN 88]. One difference is that C always promotes arguments of type float to type double, while ANSI C does not.
Reference: [K ERN 88] <author> Kernighan, B.W. and Ritchie, </author> <title> D.M. The C Programming Language , 2nd edition. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: A CCL description is typically language dependent as well. This is, in part, because the language definition influences the calling convention. For example, the C language [K ERN 78] defines a slightly different calling convention than its successor ANSI C 5 <ref> [K ERN 88] </ref>. One difference is that C always promotes arguments of type float to type double, while ANSI C does not. These differences are part of the calling convention, and are, therefore, present in the resulting CCL descriptions.
Reference: [M EAL 55] <author> Mealy, </author> <title> G.H. A method for synthesizing sequential circuits, </title> <journal> Bell System Technical Journal , 34(5):1045 1079, </journal> <year> 1955. </year>
Reference-contexts: We now formalize our definition of a P-FSA for modeling placement. Since the P-FSA produces output on transitions, we have a Mealy machine <ref> [M EAL 55] </ref>.
Reference: [M ULL 93] <author> Muller, T. </author> <title> Employing Finite Automata for Resource Scheduling. </title> <booktitle> In Proceedings of the 26th Annual International Symposium on Microarchitecture , 1993, </booktitle> <volume> 12 20. </volume>
Reference-contexts: For example, Johnson et al. [J OHN 68] describe the use of FSAs to implement lexical analyzers. More recently, Proebsting and Fraser [P ROE 94], and Muller <ref> [M ULL 93] </ref> have used finite state automata to model and detect structural hazards in pipelines for instruction scheduling. 8 Summary Current methods of procedure call specification are frequently imprecise, incomplete, contradictory or inconsistent. This comes from the lack of a formal model, or specification language that guarantee these properties.
Reference: [P ROE 94] <author> Proebsting, T.A. and Fraser, C.W. </author> <title> Detecting Pipeline Structural Hazards Quickly. </title> <booktitle> In Proceedings 21st ACM SIGPLAN-SIGACT Symposium on the Principles of Programming Languages , 1994, </booktitle> <volume> 280286. </volume> <pages> 12 </pages>
Reference-contexts: On the other hand, the use of FSA for modeling parts of a compiler, and as an implementation tool has a long and successful history. For example, Johnson et al. [J OHN 68] describe the use of FSAs to implement lexical analyzers. More recently, Proebsting and Fraser <ref> [P ROE 94] </ref>, and Muller [M ULL 93] have used finite state automata to model and detect structural hazards in pipelines for instruction scheduling. 8 Summary Current methods of procedure call specification are frequently imprecise, incomplete, contradictory or inconsistent.
References-found: 18

