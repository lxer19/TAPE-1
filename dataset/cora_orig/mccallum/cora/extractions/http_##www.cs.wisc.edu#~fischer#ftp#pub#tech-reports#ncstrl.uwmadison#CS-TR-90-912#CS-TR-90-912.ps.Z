URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-90-912/CS-TR-90-912.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-90-912/
Root-URL: http://www.cs.wisc.edu
Title: Abstract Execution: A Technique for Efficiently Tracing Programs 1  
Author: James R. Larus 
Note: 1 This is a revised version  The body of the text will appear in Software  
Address: 1210 West Dayton Street Madison, WI 53706 USA  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  of University of Wisconsin Computer Sciences  
Pubnum: Technical Report  
Email: larus@cs.wisc.edu  
Date: May 22, 1990  #912 (February 1990).  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Annat Agarwal, Richard L. Sites, and Mark Horwitz. ATUM: </author> <title> A New Technique for Capturing Address Traces Using Microcode. </title> <booktitle> In Proceedings of the 13th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 119-127, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: A faster approach modified the VAX's microcode to record the addresses that it produced. The ATUM system still slowed programs by a factor of 20 <ref> [1] </ref>. However, it did not require program modifications or recompilation and could trace all processes running on a computer. The TRAPEDS system modifies a program's assembly language files to insert calls on a profiling routine in every basic block [12].
Reference: [2] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: Therefore, basic block information is unavailable for programs compiled without the -0 flag. AE avoids both problems by recomputing the program's control-flow graph. Reaching definitions analysis identifies the assignments to a register whose values reach a use of the register <ref> [2] </ref>. This analysis determines which instructions produce a value used in a memory address calculation. AE works backwards from a load or store instruction to find other instructions 12 that contributed to the memory address. Assume that AE wants to deter-mine the value in R1. <p> AE uses a more refined analysis technique to identify control-flow edges that enter a loop, exit a loop, and begin a new iteration of a loop in a three step process <ref> [2] </ref>. The first step identifies loop backedges and the blocks that head a loop by finding the control-flow edges whose destination dominates their source. It then uses a greedy algorithm to find all blocks within the loop.
Reference: [3] <author> Anita Borg, R. E. Kessler, and David W. Wall. </author> <title> Generation and Analysis of Very Long Address Traces. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <month> page ?, May </month> <year> 1990. </year>
Reference-contexts: These profiling routines are similar to the regeneration code produced by AE. The overhead of this process (without writing files) is roughly 30 times the pro 21 gram's execution cost. Borg's system for tracing programs on the DEC Titan inspired this effort <ref> [3] </ref>. This system uses a modified linker to insert tracing code in a compiled program. This code records the execution of a basic block, the number of instructions in the block, and the address of referenced memory locations.
Reference: [4] <author> Susan J. Eggers, David R. Keppel, Eric J. Koldinger, and Henry M. Levy. </author> <title> Techniques for Efficient Inline Tracing on a Shared-Memory Multiprocessor. </title> <booktitle> In Proceedings of the 1990 ACM SIGMETRICS Conference on Measuring and Modeling of Computer Systems, </booktitle> <pages> pages 37-47, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Because of extensive operation system modifications, this system can trace all processes and the kernel running on a machine. Independently, but slightly earlier than this work, the MPtrace system developed some of the same ideas as AE <ref> [4] </ref>. It, like AE, does not chose the extreme alternatives of storing a full trace or rerunning the fully-traced program to regenerate the trace.
Reference: [5] <author> Susan L. Graham, Peter B. Kessler, and Marshall K. McKusick. </author> <title> An Execution Profiler for Modular Programs. </title> <journal> Software Practice & Experience, </journal> <volume> 13 </volume> <pages> 671-685, </pages> <year> 1983. </year>
Reference-contexts: The compiled program is linked with startup code (aecrt0.o). When the program runs, it produces a trace file (ae.out) that contains the significant events. The process is similar to the Unix prof or gprof profiling systems <ref> [5] </ref>. To produce a full trace from the significant events, AE translates the program's schema into a C program that interprets the significant event trace file to generate a full trace. The schema compiler (aec) translates schema files into a C program.
Reference: [6] <author> Susan Horwitz, Thomas Reps, and David Binkley. </author> <title> Interprocedural Slicing Using Dependence Graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: In fact, AE only recalculates the instructions in the program slice for each event of interest. A program slice with respect to an instruction I is the set of instructions in the program that directly or indirectly affect the value produced by I <ref> [6, 13] </ref>. For example, to produce an address trace, we are only interested in instructions that contribute to addresses used in load or store instructions and can ignore the other instructions that produce or utilize the values that are loaded and stored.
Reference: [7] <author> James R. Larus. </author> <title> Estimating the Potential Parallelism in Programs. </title> <booktitle> Submitted to Workshop on Languages and Compilers for Parallel Computing, </booktitle> <month> April </month> <year> 1990. </year>
Reference-contexts: A few obvious examples include: cache memory simulation, which requires a list of memory locations accessed by a program [10]; performance analysis, which requires a count of each basic block's execution frequency [8]; and program parallelism analysis, which requires a trace of addresses and notification upon loop entry and iteration <ref> [7] </ref>. Traditionally, collecting this information is expensive. The mechanism that records events severely slows a program's execution. This slowdown not only makes large, long-running programs difficult to characterize, but it also affects the behavior and measurements of real-time and parallel programs. <p> Section 6 demonstrates that AE can greatly exceed this compression. The additional compaction enables longer (and hence more realistic) traces to be analyzed, stored, and exchanged. Another application is a parallelism analyzer, which examines the executions of program loops to find the possibility of parallel overlap <ref> [7] </ref>. This system, called pp, uses a full address trace in addition to events to indicate the beginning, end, and iteration of a loop. pp records the last read and modification of most memory locations. It uses this information to detect loop-carried data dependences.
Reference: [8] <institution> MIPS Computer Systems, Inc. </institution> <note> RISCompiler Languages Programmer's Guide, De-cember 1988. </note>
Reference-contexts: A few obvious examples include: cache memory simulation, which requires a list of memory locations accessed by a program [10]; performance analysis, which requires a count of each basic block's execution frequency <ref> [8] </ref>; and program parallelism analysis, which requires a trace of addresses and notification upon loop entry and iteration [7]. Traditionally, collecting this information is expensive. The mechanism that records events severely slows a program's execution.
Reference: [9] <author> A. Dain Samples. Mache: </author> <title> No-Loss Trace Compaction. </title> <booktitle> In Proceedings of the International Conference on Measurment and Modeling of Computer Systems, </booktitle> <pages> pages 89-97, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: Equally serious is the cost of storing and manipulating huge trace files. A 10 million instructions per second (MIPS) computer produces 40-60 megabytes of trace data in a second of execution. Clever compression schemes can reduce the volume of data by an order of magnitude <ref> [9] </ref>, but the size of trace files is a major limitation on measuring long-running programs. This report describes a new technique called Abstract Execution that greatly alleviates both problems. The technique|which has been implemented in a system called AE|records a small subset of the events produced by a program. <p> AE's main advantage in this application is the large compression of the trace file. Previously, memory address traces were compressed by computing the difference between successively-accessed addresses|which uncovers underlying regularity in access patterns|and 17 feeding the result to a compression program such as the Unix compress utility <ref> [9] </ref>. This process typically reduces the volume of a full address trace by a factor of 10 and an instruction trace by a factor of 200. Section 6 demonstrates that AE can greatly exceed this compression.
Reference: [10] <author> Alan J. Smith. </author> <title> Cache Memories. </title> <journal> ACM Computing Surveys, </journal> <volume> 14(3) </volume> <pages> 473-530, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction Many areas of computer performance analysis require detailed traces of events that occur during a program's execution. A few obvious examples include: cache memory simulation, which requires a list of memory locations accessed by a program <ref> [10] </ref>; performance analysis, which requires a count of each basic block's execution frequency [8]; and program parallelism analysis, which requires a trace of addresses and notification upon loop entry and iteration [7]. Traditionally, collecting this information is expensive. The mechanism that records events severely slows a program's execution.
Reference: [11] <author> Richard M. Stallman. </author> <title> Using and Porting GNU CC. Free Software Foundation, </title> <month> September </month> <year> 1989. </year>
Reference-contexts: We will also show that other types of events can easily be incorporated into the framework. 4 Details of AE part is a modified version of gcc|the GNU C compiler <ref> [11] </ref>. In addition to compiling a program (foo.c), this version of the compiler produces a schema file (foo.sma) and inserts code into the executable program to record significant events. The compiled program is linked with startup code (aecrt0.o).
Reference: [12] <author> Craig B. Stunkel and W. Kent Fuchs. TRAPEDS: </author> <title> Producing Traces for Multicom-puters Via Execution Driven Simulation. </title> <booktitle> In Proceedings of the 1989 ACM SIGMET-RICS Conference on Measuring and Modeling of Computer Systems, </booktitle> <pages> pages 70-78, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: However, it did not require program modifications or recompilation and could trace all processes running on a computer. The TRAPEDS system modifies a program's assembly language files to insert calls on a profiling routine in every basic block <ref> [12] </ref>. The profiling routine for a block computes the instruction and data address for the block and passes them directly to the address trace-consuming program. These profiling routines are similar to the regeneration code produced by AE.
Reference: [13] <author> Mark Weiser. </author> <title> Program Slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year> <month> 24 </month>
Reference-contexts: In fact, AE only recalculates the instructions in the program slice for each event of interest. A program slice with respect to an instruction I is the set of instructions in the program that directly or indirectly affect the value produced by I <ref> [6, 13] </ref>. For example, to produce an address trace, we are only interested in instructions that contribute to addresses used in load or store instructions and can ignore the other instructions that produce or utilize the values that are loaded and stored.
References-found: 13

