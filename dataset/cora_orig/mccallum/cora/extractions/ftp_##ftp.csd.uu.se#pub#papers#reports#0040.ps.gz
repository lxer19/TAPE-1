URL: ftp://ftp.csd.uu.se/pub/papers/reports/0040.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Phone: +46-18-18 25 00  
Title: Hash Tables in Logic Programming different aspects of hash tables as a data structure in
Author: Jonas Barklund H-akan Millroth P. O. 
Note: The paper discusses  Hash  The research reported herein was supported by the National Swedish Board for Technical Development (STU).  
Address: Box 520, S-751 20 UPPSALA, Sweden  
Affiliation: Uppsala Programming Methodology and Artificial Intelligence Laboratory Computing Science Dept., Uppsala University  
Abstract: UPMAIL Technical Report No. 40 Abstract Hash tables are a new concept in Prolog since they can not be efficiently implemented in the language itself. We give informal semantics for hash tables as partial functions on logical terms. We are careful to ensure that we can represent the hash tables as logical terms in order to make the ordinary syntactic unification apply. The implementation is a generalisation of the method suggested by Eriksson and Rayner. Their "mutable arrays" are a special case of our multiple version hash tables. The implementation has been used in Tricia, an implementation of Prolog developed at Uppsala University. An earlier version of this paper was presented at the 4th International Conference on Logic Programming. 
Abstract-found: 1
Intro-found: 1
Reference: [Baker 78] <author> H. G. Baker, </author> <title> Shallow Binding in Lisp 1.5, </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. 7, </volume> <pages> pp. 565-569, </pages> <month> July </month> <year> 1978. </year> <note> [Barklund et al. 86] J. </note> <author> Barklund, L. Oestreicher, A. Hugosson, M. Nylen, </author> <title> Tricia User's Guide, </title> <institution> Computing Science Dept., Uppsala University, </institution> <month> Sept. </month> <note> 1986. </note> <author> [Barklund & Millroth A] J. Barklund, H. Millroth, </author> <title> Code Generation and Runtime System for Tricia, </title> <type> UPMAIL Technical Report 36, </type> <institution> Uppsala, </institution> <note> in preparation. </note> <author> [Barklund & Millroth B] J. Barklund, H. Millroth, </author> <title> Integrating Complex Data Structures in Prolog, </title> <publisher> forthcoming. </publisher>
Reference-contexts: This favors searches in (and updates to) the most recent version and we are convinced that this is optimal in almost any real application. This is similar to the idea of shallow variable binding in functional and logic programming languages <ref> [Baker 78; Miyazaki 85] </ref> and we have indeed used MVHT to implement interpreters for functional languages very comfortably. <p> The idea of a predicate which makes some version of a hash table the most efficient to use is due to Baker who uses a shallow primitive to give fast access to an old variable binding environment <ref> [Baker 78] </ref>. Our algorithm for doing this was inspired by his. In general, many of his ideas are similar to ours although he only considers having one physical table and has no direct counterpart to our primitives for updating tables.
Reference: [Bowen 85] <author> K. </author> <title> A Bowen, Meta-Level Programming and Knowledge Representation, New Generation Computing 3, 1985. </title> <editor> [Bowen & Kowalski 82] K. A. Bowen, R. A. Kowalski, </editor> <title> Amalgamating Language and Metalanguage in Logic Programming in K. </title> <editor> L. Clark, S. A. Tarnlund, </editor> <booktitle> Logic Programming, </booktitle> <address> London, </address> <year> 1982. </year>
Reference-contexts: Having logical theories as data structures makes it possible to reference them explicitly when reasoning about knowledge. Almost regardless of other issues in meta-logical reasoning, efficiently implemented logical theories will be an important part of a system with meta-reasoning capabilities <ref> [Weyhrauch 80; Bowen & Kowalski 82; Bowen 85] </ref>. We also think that logical theories and meta-reasoning may play an important part in formalizing the concept of frames, commonly used in knowledge representation [Hayes 79].
Reference: [Carlsson 84] <author> M. Carlsson, </author> <title> LM-Prolog | the Language and Its Implementation, </title> <type> UPMAIL Technical Report 30, </type> <institution> Uppsala, </institution> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: However, less attention has been directed to other MVDS [Cohen 84; Pereira 85]. Most proposals for implementation of multiple version arrays can claim superiority over the others at some point. We think that the scheme given in [Eriksson & Rayner 84] for LM-Prolog <ref> [Kahn 83; Carlsson 84] </ref> is the one with the best performance for average programs, besides being reasonably easy to implement. The idea is to implement arrays in terms of physical arrays and virtual arrays.
Reference: [Carlsson 86] <author> M. Carlsson, </author> <title> Compilation for Tricia and its Abstract Machine, </title> <type> UPMAIL Technical Report 35, </type> <institution> Uppsala, </institution> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: Table must be instantiated but Key may be uninstantiated. If Key is not ground, all Key-Value pairs will be tried. An alternative would be to freeze the call [Naish 85] until Key is ground but this can be programmed using other primitives <ref> [Carlsson 86] </ref>. gethash (ht (K,V,_),K,V). gethash (ht (_,_,T),K,V) :- gethash (T,K,V). addhash (Table 1,Key,Value,Table 2) This is true if Table_1 and Table_2 are identical except that Table_1 contains no value for Key but Table_2 maps Key to Value. This is used to add or remove items from the table.
Reference: [Cohen 84] <author> S. Cohen, </author> <title> Multi-Version Structures in Prolog, </title> <booktitle> The International Conference of Fifth Generation Computer Systems, </booktitle> <address> Tokyo, </address> <year> 1984. </year> <note> [Eriksson & Rayner 84] L-H. </note> <author> Eriksson, M. Rayner, </author> <title> Incorporating Mutable Arrays into Logic Programming, </title> <booktitle> Second International Logic Programming Conference, </booktitle> <address> Uppsala, </address> <month> July </month> <year> 1984. </year>
Reference-contexts: Defining such update predicates is of course possible for all logical terms, but to emphasize the data structures where such predicates are implemented efficiently we call them multiple version data structures (MVDS). There have been several proposals, e.g., <ref> [Warren 83b; Cohen 84; Eriksson & Rayner 84] </ref>, how to incorporate multiple version arrays into Prolog. However, less attention has been directed to other MVDS [Cohen 84; Pereira 85]. Most proposals for implementation of multiple version arrays can claim superiority over the others at some point. <p> There have been several proposals, e.g., [Warren 83b; Cohen 84; Eriksson & Rayner 84], how to incorporate multiple version arrays into Prolog. However, less attention has been directed to other MVDS <ref> [Cohen 84; Pereira 85] </ref>. Most proposals for implementation of multiple version arrays can claim superiority over the others at some point.
Reference: [Hayes 79] <author> P. Hayes, </author> <title> The Logic of Frames in D. Metzing, Frame Conceptions and Text Understanding, </title> <address> Berlin, </address> <year> 1979. </year>
Reference-contexts: We also think that logical theories and meta-reasoning may play an important part in formalizing the concept of frames, commonly used in knowledge representation <ref> [Hayes 79] </ref>. Acknowledgements We wish to express our gratitude to our colleagues at UPMAIL for interesting discussions and nice tea breaks, particularly to Amelie Banks who has substantially improved the language of the paper. The comments from one referee were also particularly valuable.
Reference: [Kahn 83] <author> K. Kahn, </author> <title> Unique Features of LISP Machine Prolog, </title> <note> UPMAIL Technical Report 15B, 1983 (revised by M. Carlsson Feb. </note> <year> 1985). </year>
Reference-contexts: However, less attention has been directed to other MVDS [Cohen 84; Pereira 85]. Most proposals for implementation of multiple version arrays can claim superiority over the others at some point. We think that the scheme given in [Eriksson & Rayner 84] for LM-Prolog <ref> [Kahn 83; Carlsson 84] </ref> is the one with the best performance for average programs, besides being reasonably easy to implement. The idea is to implement arrays in terms of physical arrays and virtual arrays.
Reference: [Knuth 73] <author> D. E. Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> vol. </volume> <pages> 3, </pages> <address> Reading, Mass., </address> <year> 1973. </year> <month> 6 </month>
Reference-contexts: In general, many of his ideas are similar to ours although he only considers having one physical table and has no direct counterpart to our primitives for updating tables. The physical table is a hash table implemented according to one of the usual schemes <ref> [Knuth 73; Standish 80] </ref>. It is desirable that the scheme allows deletions from the physical table. The algorithms for the physical table are beyond the scope of this paper, see the references above for several useful techniques.
Reference: [Miyazaki 85] <author> T. Miyazaki, A. Takeuchi, T. Chikayama, </author> <title> A Sequential Implementation of Concurrent Pro--log based on the Shallow Binding Scheme, </title> <booktitle> 1985 Symposium on Logic Programming, </booktitle> <address> Boston, </address> <month> July </month> <year> 1985. </year>
Reference-contexts: This favors searches in (and updates to) the most recent version and we are convinced that this is optimal in almost any real application. This is similar to the idea of shallow variable binding in functional and logic programming languages <ref> [Baker 78; Miyazaki 85] </ref> and we have indeed used MVHT to implement interpreters for functional languages very comfortably.
Reference: [Naish 85] <author> L. Naish, </author> <title> Negation and Control in PROLOG, </title> <institution> Dept. of Computer Science, University of Melbourne, </institution> <year> 1985. </year>
Reference-contexts: This is used to look up items in the table. Table must be instantiated but Key may be uninstantiated. If Key is not ground, all Key-Value pairs will be tried. An alternative would be to freeze the call <ref> [Naish 85] </ref> until Key is ground but this can be programmed using other primitives [Carlsson 86]. gethash (ht (K,V,_),K,V). gethash (ht (_,_,T),K,V) :- gethash (T,K,V). addhash (Table 1,Key,Value,Table 2) This is true if Table_1 and Table_2 are identical except that Table_1 contains no value for Key but Table_2 maps Key to
Reference: [Pereira 85] <author> F. C. N. Pereira, </author> <title> A Structure-Sharing Representation for Unification-Based Grammar Formalisms, </title> <booktitle> 23rd Annual Meeting of the Association for Computational Linguistics, </booktitle> <address> Chicago, Ill., </address> <month> July </month> <year> 1985. </year>
Reference-contexts: There have been several proposals, e.g., [Warren 83b; Cohen 84; Eriksson & Rayner 84], how to incorporate multiple version arrays into Prolog. However, less attention has been directed to other MVDS <ref> [Cohen 84; Pereira 85] </ref>. Most proposals for implementation of multiple version arrays can claim superiority over the others at some point. <p> This is in accordance with the behavior of the representation of tables as sorted A-lists above. Nothing is added to the language, we only give an alternative implementation of some logical terms. In <ref> [Pereira 85] </ref> unification of a similar data structure (DAG s) is discussed and another view on unification of tables is expressed: unification of two DAGs T 1 and T 2 corresponds to taking the set union of key-value pairs in T 1 and T 2 , failing only if for some
Reference: [Standish 80] <author> T. A. Standish, </author> <title> Data Structure Techniques, </title> <address> Reading, Mass., </address> <year> 1980. </year>
Reference-contexts: In general, many of his ideas are similar to ours although he only considers having one physical table and has no direct counterpart to our primitives for updating tables. The physical table is a hash table implemented according to one of the usual schemes <ref> [Knuth 73; Standish 80] </ref>. It is desirable that the scheme allows deletions from the physical table. The algorithms for the physical table are beyond the scope of this paper, see the references above for several useful techniques.
Reference: [Steele 84] <author> G. L. Steele Jr., </author> <title> Common Lisp, </title> <booktitle> the Language, </booktitle> <address> Burlington, Mass., </address> <year> 1984. </year>
Reference-contexts: The reason for implementing MVHT was that hash tables are very powerful data structures (included in Common Lisp <ref> [Steele 84] </ref>), which are difficult, if not impossible, to implement efficiently in Prolog itself. Also MVHT are complex enough to serve as an example on how to implement non-trivial MVDS.
Reference: [Turk 86] <author> A. K. Turk, </author> <title> Compiler Optimizations for the WAM, </title> <booktitle> Third International Conference on Logic Programming, </booktitle> <pages> pp. 657-662, </pages> <address> London, </address> <month> July </month> <year> 1986. </year>
Reference-contexts: For a description of how Warren's Abstract Machine [Warren 83a] is extended to do this, see [Barklund & Millroth A] (or <ref> [Turk 86] </ref> for an alternative solution). 4.2 Computing Hash Functions One interesting problem to observe regarding the implementation of the physical hash tables, is the computation of hash functions (not to be confused with the functions in the semantics section above) for keys.
Reference: [Warren 83a] <author> D. H. D. Warren, </author> <title> An Abstract Prolog Instruction Set, </title> <type> SRI Technical Note 309, </type> <month> Oct. </month> <year> 1983. </year>
Reference-contexts: The algorithms in the Appendix assume the existence of routines to trail the old values of locations (not only unbound variables) in order to restore their old contents upon backtracking. For a description of how Warren's Abstract Machine <ref> [Warren 83a] </ref> is extended to do this, see [Barklund & Millroth A] (or [Turk 86] for an alternative solution). 4.2 Computing Hash Functions One interesting problem to observe regarding the implementation of the physical hash tables, is the computation of hash functions (not to be confused with the functions in the
Reference: [Warren 83b] <author> D. H. D. Warren, </author> <title> Logarithmic Access Arrays for Prolog, unpublished program, </title> <note> 1983. [Weyhrauch 80] R. </note> <author> W. Weyhrauch, </author> <title> Prolegomena to a Theory of Mechanized Formal Reasoning, </title> <journal> Artificial Intelligence, </journal> <volume> vol. 13, </volume> <pages> pp. 133-170, </pages> <year> 1980. </year> <month> 7 </month>
Reference-contexts: Defining such update predicates is of course possible for all logical terms, but to emphasize the data structures where such predicates are implemented efficiently we call them multiple version data structures (MVDS). There have been several proposals, e.g., <ref> [Warren 83b; Cohen 84; Eriksson & Rayner 84] </ref>, how to incorporate multiple version arrays into Prolog. However, less attention has been directed to other MVDS [Cohen 84; Pereira 85]. Most proposals for implementation of multiple version arrays can claim superiority over the others at some point.
References-found: 16

