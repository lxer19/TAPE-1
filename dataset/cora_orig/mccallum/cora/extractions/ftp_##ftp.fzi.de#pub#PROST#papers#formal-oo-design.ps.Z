URL: ftp://ftp.fzi.de/pub/PROST/papers/formal-oo-design.ps.Z
Refering-URL: http://www.fzi.de/prost/publications/overview.html
Root-URL: http://www.fzi.de
Email: e-mail: -lindner, rueping-@fzi.de  
Title: How Formal Object-Oriented Design Supports Reuse  
Author: Thomas Lindner, Andreas Rping 
Address: Haid-und-Neu-Strae 10-14 D-76131 Karlsruhe, Germany  
Affiliation: Forschungszentrum Informatik (FZI) Bereich Programmstrukturen  
Abstract: While object-oriented analysis and design methods give valuable hints on how to design a software system, little support is given for reusing components or making components reusable. This paper demonstrates how formal methods can be applied to improve the reusability of object-oriented components. We show how existing object-oriented design methods and formal methods can be integrated. Guidelines are presented for designing components formally, which indeed increases their reusability. Furthermore, several reuse mechanisms are introduced which are based on a formalization of design patterns. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Kent Beck, Ralph Johnson. </author> <title> Patterns Generate Architectures, </title> <editor> in Mario Tokoro, Remo Pareschi (Eds.), </editor> <booktitle> ECOOP 94 - European Conference on Object-Oriented Programming. Lecture Notes in Computer Science (LNCS) No. </booktitle> <volume> 821. </volume> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: However, using inheritance to express conformance is crucial to avoid objects showing unexpected behaviour. This aspect is particularly important to class libraries, whose components shall be used over and over again. 3.2 Reuse by Design Patterns Design patterns have recently been introduced in several studies (cf. <ref> [1] </ref>, [8], [9], [14], [15]). The purpose of object-oriented design patterns is to describe typical collaborations between objects or classes, and hence to document reusable object-oriented design. Although introduced originally in the field of graphical user interfaces, patterns are useful for software development in different application domains.
Reference: [2] <author> F. Belina, D. Hogrefe, A. Sarma. </author> <title> SDL with Applications from Protocol Specification. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: We combine the following methods: 1. Responsibility-Driven Design (RDD, cf. [20]) for the process model, 2. Object Modeling Technique (OMT, cf. [16]) for the static model, 3. Specification and Description Language (SDL, cf. <ref> [2] </ref>, [10]) for the dynamic model. In principle, the concepts presented in this paper can be applied to other design methods and other notations as well. Yet, the combination of methods presented here has turned out to be particularly useful, as we will see later on. <p> Also, behaviour descriptions can detect inner-class complexity. If its behaviour diagram is getting too complex or too simple, a class probably needs to be redesigned. We use SDL diagrams (cf. <ref> [2] </ref>) to describe object behaviour. This notation is similar to the one proposed in [10] for state transition graphs. SDL diagrams bring about the advantage that they are particularly useful for formalization, as we will see later on.
Reference: [3] <author> Grady Booch. </author> <title> Object-Oriented Design with Applications. </title> <publisher> Benjamin / Cummings Publishing Company, </publisher> <year> 1991. </year> <note> Thomas Lindner, Andreas Rping 15 </note>
Reference-contexts: These methodologies address all development stages, including analysis, design, and implementation. Most of the methodologies proposed in literature (cf. <ref> [3] </ref>, [10], [16], [20]) have in common that they suggest steps to be taken during the development stages, and that they introduce a graphical notation for modelling the static, dynamic, and functional aspects of the system under development. However, they also have one shortcoming in common.
Reference: [4] <author> Timothy Budd. </author> <title> An Introduction to Object-Oriented Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1991. </year>
Reference-contexts: These purposes include code sharing, reusing design, describing abstractions, and describing specializations. However, some of the usages of inheritance are not recommended (cf. <ref> [4] </ref>). Although they may be helpful for a short moment, they turn out to be an obstacle in the long term. Because of polymorphism, inheritance is normally associated with substitutability.
Reference: [5] <author> L. Cardelli, P. Wegner. </author> <title> On Understanding Types, Data Abstraction, and Polymorphism. </title> <journal> ACM Computing Surveys Vol. </journal> <volume> 17, No. 4. </volume> <publisher> ACM Press, </publisher> <month> December </month> <year> 1985. </year>
Reference-contexts: Along with formal specification, we can say precisely which requirements have to be met with respect to compatibility. A subclass conforms to its superclass if the following holds (cf. <ref> [5] </ref>): To each public method of the superclass, there must be a corresponding method in the subclass. The subclass may have additional methods, though. In the specification of a subclass method, the precondition may be weakened, thus making the method more generally applicable.
Reference: [6] <author> E. Casais, C. Lewerentz, Th. Lindner, F. Weber. </author> <title> Formal Methods and Object-Orientation. </title> <booktitle> Tutorial Notes, TOOLS 10 - Technology of Object-Oriented Languages and Systems. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1993 </year>
Reference-contexts: This paper demonstrates how formal methods can be applied to make components more reusable. As several studies have shown (cf. <ref> [6] </ref>, [11], [12]), formal methods are a valuable approach towards improving the quality of software.
Reference: [7] <author> Eduardo Casais. </author> <title> An Experiment in Framework Development - Issues and Results, in Eduardo Casais (Ed.), Architectures and Processes for Systematic Software Construction. </title> <institution> FZI-Publication, Forschungszentrum Informatik Karlsruhe, </institution> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: This design pattern is domain-specific; it is useful to a complete application domain. Control software for production cells is an example from an entirely different application domain (cf. <ref> [7] </ref>). Production cells typically consist of several collaborating devices which have to synchronize themselves. To this end, well-understood techniques to model synchronization are domain-specific design patterns.
Reference: [8] <author> Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. </author> <title> Design Patterns: Abstraction and Reuse of Object-Oriented Design, </title> <editor> in Oscar M. Nierstrasz (Ed.), </editor> <booktitle> ECOOP 93 - European Conference on Object-Oriented Programming. Lecture Notes in Computer Science (LNCS) No. </booktitle> <volume> 707. </volume> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: However, using inheritance to express conformance is crucial to avoid objects showing unexpected behaviour. This aspect is particularly important to class libraries, whose components shall be used over and over again. 3.2 Reuse by Design Patterns Design patterns have recently been introduced in several studies (cf. [1], <ref> [8] </ref>, [9], [14], [15]). The purpose of object-oriented design patterns is to describe typical collaborations between objects or classes, and hence to document reusable object-oriented design. Although introduced originally in the field of graphical user interfaces, patterns are useful for software development in different application domains.
Reference: [9] <author> Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. </author> <title> A Catalog of Object-Oriented Design Patterns. </title> <note> To appear. </note>
Reference-contexts: However, using inheritance to express conformance is crucial to avoid objects showing unexpected behaviour. This aspect is particularly important to class libraries, whose components shall be used over and over again. 3.2 Reuse by Design Patterns Design patterns have recently been introduced in several studies (cf. [1], [8], <ref> [9] </ref>, [14], [15]). The purpose of object-oriented design patterns is to describe typical collaborations between objects or classes, and hence to document reusable object-oriented design. Although introduced originally in the field of graphical user interfaces, patterns are useful for software development in different application domains. <p> Still, for design patterns to become truly reusable building blocks, it is important that they are constructed according to the following principles: Abstraction The design patterns presented in <ref> [9] </ref> and [15] make use of inheritance for several purposes. Again, we require inheritance to represent a true compatibility relationship between objects or classes. Although it depends on the particular design pattern which sort of compatibility is required, in most cases conformance must hold between classes inheriting from one another. <p> Encapsulation keeps dependencies between design patterns small when they are plugged together, in order to gain the best possible exibility for their composition. Specification A design patterns interface needs to be specified. Although <ref> [9] </ref> and [15] inform how patterns should be used, a precise interface is not provided. <p> In contrast, we suggest to view design patterns as well-encapsulated components with clearly defined interfaces. 12 How Formal Object-Oriented Design Supports Reuse We explain these requirements along with two examples taken from the Catalog of Design Patters (cf. <ref> [9] </ref>). First, we demonstrate the importance of the disciplined usage of inheritance with the design pattern Composite. The Composite pattern treats multiple, recursively composed objects as a single object.
Reference: [10] <author> I. Jacobson, M. Christerson, P. Jonsson, G. Overgaard. </author> <title> Object-Oriented Software Engineering - A Use Case Driven Approach. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: These methodologies address all development stages, including analysis, design, and implementation. Most of the methodologies proposed in literature (cf. [3], <ref> [10] </ref>, [16], [20]) have in common that they suggest steps to be taken during the development stages, and that they introduce a graphical notation for modelling the static, dynamic, and functional aspects of the system under development. However, they also have one shortcoming in common. <p> We combine the following methods: 1. Responsibility-Driven Design (RDD, cf. [20]) for the process model, 2. Object Modeling Technique (OMT, cf. [16]) for the static model, 3. Specification and Description Language (SDL, cf. [2], <ref> [10] </ref>) for the dynamic model. In principle, the concepts presented in this paper can be applied to other design methods and other notations as well. Yet, the combination of methods presented here has turned out to be particularly useful, as we will see later on. <p> Also, behaviour descriptions can detect inner-class complexity. If its behaviour diagram is getting too complex or too simple, a class probably needs to be redesigned. We use SDL diagrams (cf. [2]) to describe object behaviour. This notation is similar to the one proposed in <ref> [10] </ref> for state transition graphs. SDL diagrams bring about the advantage that they are particularly useful for formalization, as we will see later on.
Reference: [11] <author> K. Lano, H. Haughton (Eds.), </author> <title> Object-Oriented Specification Case Studies. </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: This paper demonstrates how formal methods can be applied to make components more reusable. As several studies have shown (cf. [6], <ref> [11] </ref>, [12]), formal methods are a valuable approach towards improving the quality of software.
Reference: [12] <author> Claus Lewerentz, Thomas Lindner (Eds.), </author> <title> Case Study Production Cell: A Comparative Study in Formal Software Development. </title> <type> FZI-Publication 1-94, </type> <institution> Forschungszentrum Informatik Karlsruhe, </institution> <year> 1994. </year>
Reference-contexts: This paper demonstrates how formal methods can be applied to make components more reusable. As several studies have shown (cf. [6], [11], <ref> [12] </ref>), formal methods are a valuable approach towards improving the quality of software.
Reference: [13] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Defining objects by their responsibilities is quite similar to the paradigm of programming by contract (cf. <ref> [13] </ref>) which can well be integrated with formal software development techniques since contracts can easily be formalized into specification constructs such as pre- and postconditions and invariants. The instructions presented in [20] for the development process are very comprehensive and helpful, making Responsibility-Driven Design a particularly coherent design method.
Reference: [14] <author> Wolfgang Pree. </author> <title> Meta Patterns - A Means for Capturing the Essentials of Reusable Object-Oriented Design, </title> <editor> in Mario Tokoro, Remo Pareschi (Eds.), </editor> <booktitle> ECOOP 94 - European Conference on Object-Oriented Programming. Lecture Notes in Computer Science (LNCS) No. </booktitle> <volume> 821. </volume> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: However, using inheritance to express conformance is crucial to avoid objects showing unexpected behaviour. This aspect is particularly important to class libraries, whose components shall be used over and over again. 3.2 Reuse by Design Patterns Design patterns have recently been introduced in several studies (cf. [1], [8], [9], <ref> [14] </ref>, [15]). The purpose of object-oriented design patterns is to describe typical collaborations between objects or classes, and hence to document reusable object-oriented design. Although introduced originally in the field of graphical user interfaces, patterns are useful for software development in different application domains.
Reference: [15] <author> Wolfgang Pree. </author> <title> Design Patterns for Object-Oriented Software Development, </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: This aspect is particularly important to class libraries, whose components shall be used over and over again. 3.2 Reuse by Design Patterns Design patterns have recently been introduced in several studies (cf. [1], [8], [9], [14], <ref> [15] </ref>). The purpose of object-oriented design patterns is to describe typical collaborations between objects or classes, and hence to document reusable object-oriented design. Although introduced originally in the field of graphical user interfaces, patterns are useful for software development in different application domains. <p> Still, for design patterns to become truly reusable building blocks, it is important that they are constructed according to the following principles: Abstraction The design patterns presented in [9] and <ref> [15] </ref> make use of inheritance for several purposes. Again, we require inheritance to represent a true compatibility relationship between objects or classes. Although it depends on the particular design pattern which sort of compatibility is required, in most cases conformance must hold between classes inheriting from one another. <p> Encapsulation keeps dependencies between design patterns small when they are plugged together, in order to gain the best possible exibility for their composition. Specification A design patterns interface needs to be specified. Although [9] and <ref> [15] </ref> inform how patterns should be used, a precise interface is not provided.
Reference: [16] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: These methodologies address all development stages, including analysis, design, and implementation. Most of the methodologies proposed in literature (cf. [3], [10], <ref> [16] </ref>, [20]) have in common that they suggest steps to be taken during the development stages, and that they introduce a graphical notation for modelling the static, dynamic, and functional aspects of the system under development. However, they also have one shortcoming in common. <p> In our approach, we choose those analysis and design methods that can be integrated most elegantly with the issues of formal software development. We combine the following methods: 1. Responsibility-Driven Design (RDD, cf. [20]) for the process model, 2. Object Modeling Technique (OMT, cf. <ref> [16] </ref>) for the static model, 3. Specification and Description Language (SDL, cf. [2], [10]) for the dynamic model. In principle, the concepts presented in this paper can be applied to other design methods and other notations as well. <p> Although Responsibility-Driven Design comes up with its own notation for a static model, we propose to use the notation of the OMT object model (cf. <ref> [16] </ref>) for the following reasons: The graphical OMT notation allows to include all essential relationships between objects or classes in a single diagram which is easy to understand. The graphical OMT notation does support aggregation, as opposed to the graphical notation of Responsibility-Driven Design.
Reference: [17] <author> Andreas Rping, Franz Weber, Walter Zimmer. </author> <title> Demonstrating Coherent Design - A Data Structure Catalogue, </title> <editor> in Raimund Ege, Madhu Singh, Bertrand Meyer (Eds.), </editor> <booktitle> TOOLS 11 - Technology of Object-Oriented Languages and Systems. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: This design technique, well known as conceptual abstraction, puts reuse to work: one concept needs to be designed and implemented only once, and can be inherited whenever it is needed. However, as shown in <ref> [17] </ref>, an accurate usage of inheritance is particularly important for components of a library which are designed for later reuse. As an example, Figure 6 shows the inheritance hierarchy of a library of graphical objects, such as rectangles, circles, polylines, polygons, and the like.
Reference: [18] <author> Andreas Rping. </author> <title> Modules in Object-Oriented Systems, </title> <editor> in Raimund Ege, Madhu Singh, Bertrand Meyer (Eds.), </editor> <booktitle> TOOLS 14 - Technology of Object-Oriented Languages and Systems. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: Since small dependencies make a system easier and more reliable, a method should be generally available only if its invocation falls into the responsibility of objects outside the pattern. In <ref> [18] </ref> formal criteria are presented for the encapsulation of components made of several collaborating classes (there called modules), and design patterns can be regarded as specific modules in this sense. The two examples adopted from the Design Pattern Catalog are quite typical.
Reference: [19] <author> Franz Weber. </author> <title> Getting Class Correctness and System Correctness Equivalent - How to Get Covariance Right, </title> <editor> in Raimund Ege, Madhu Singh, Bertrand Meyer (Eds.), </editor> <booktitle> TOOLS 8 - Technology of Object-Oriented Languages and Systems. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: In our example, the principle of substitutability holds. Both Standard_Account and Special_Account objects can be substituted for (abstract) Account objects. Conformance is required whenever superclass objects shall be dynamically replaced by subclass objects. Still, sometimes a weaker form of compatibility is sufficient. In <ref> [19] </ref> so-called imitation is introduced. While conformance does not allow for using selftype as a parameter type, since this would conict with contravariant typing, imitation does in fact allow for using selftype. <p> However, imitation is only sufficient in cases where all occurrences of a superclass in an entire system are consistently replaced by one and the same subclass. For the details we refer to <ref> [19] </ref>.
Reference: [20] <author> Rebecca Wirfs-Brock, Brian Wilkerson, Lauren Wiener. </author> <title> Designing Object-Oriented Software. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: These methodologies address all development stages, including analysis, design, and implementation. Most of the methodologies proposed in literature (cf. [3], [10], [16], <ref> [20] </ref>) have in common that they suggest steps to be taken during the development stages, and that they introduce a graphical notation for modelling the static, dynamic, and functional aspects of the system under development. However, they also have one shortcoming in common. <p> In our approach, we choose those analysis and design methods that can be integrated most elegantly with the issues of formal software development. We combine the following methods: 1. Responsibility-Driven Design (RDD, cf. <ref> [20] </ref>) for the process model, 2. Object Modeling Technique (OMT, cf. [16]) for the static model, 3. Specification and Description Language (SDL, cf. [2], [10]) for the dynamic model. In principle, the concepts presented in this paper can be applied to other design methods and other notations as well. <p> Thomas Lindner, Andreas Rping 3 2.1 The Process Model The process model describes how a system is developed, from the very beginning to its completion. The development stages covered by the process model include requirement analysis, specification, design, and implementation. Responsibility-Driven Design (cf. <ref> [20] </ref>) is the method of our choice. It focuses on the responsibilities of both single classes and the whole system. The responsibilities of a class include the knowledge that its instances maintain, and the actions they can perform. <p> Defining objects by their responsibilities is quite similar to the paradigm of programming by contract (cf. [13]) which can well be integrated with formal software development techniques since contracts can easily be formalized into specification constructs such as pre- and postconditions and invariants. The instructions presented in <ref> [20] </ref> for the development process are very comprehensive and helpful, making Responsibility-Driven Design a particularly coherent design method. As an example, we consider a cash dispenser. The cash dispenser communicates with the customers, reads their credit cards, and issues the desired amount of money.
References-found: 20

