URL: http://www.cs.cmu.edu/~jurgend/refinement.ps
Refering-URL: http://www.cs.cmu.edu/~jurgend/refinement-abs.html
Root-URL: 
Email: jurgend@cs.cmu.edu  
Title: A trace-based refinement calculus for shared-variable parallel programs  
Author: Jurgen Dingel 
Address: Pittsburgh, PA 15213, USA  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: We present a trace-based, syntax-directed refinement calculus for shared-variable parallel programs. It supports compositional reasoning, local variables, and fairness and allows for reasoning about liveness properties like termination or eventual entry. A detailed exam ple is given and related work is reviewed.
Abstract-found: 1
Intro-found: 1
Reference: [AS85] <author> G.R. Andrews and F.B. Schneider. </author> <title> Concepts for concurrent programming. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> ESPRIT/LPC Advanced School on Current Trends in Concurrency (1985, </booktitle> <address> Noordwijkerhout, Netherlands), </address> <publisher> volume 224 of LNCS. Springer Ver-lag, </publisher> <year> 1985. </year>
Reference: [Bac89] <author> R.J.R. </author> <title> Back. Refinement Calculus, Part II: Parallel and Reactive Programs. </title> <booktitle> In REX Workshop on Stepwise Refinement of Distributed Systems, </booktitle> <volume> LNCS 430, </volume> <pages> pages 67-93. </pages> <publisher> Springer Verlag, </publisher> <month> June </month> <year> 1989. </year>
Reference: [BDD + 92] <author> M. Broy, F. Dederichs, C. Dendorfer, M. Fuchs, T.F. Gritzner, and R. Weber. </author> <title> The design of distributed systems | an introduction to FOCUS. </title> <type> Technical Report TUM-I9202, </type> <institution> Technische Universitat Munchen, </institution> <month> Januar </month> <year> 1992. </year>
Reference: [Bro96] <author> S.D. Brookes. </author> <title> Full abstraction for a shared-variable parallel language. </title> <journal> Information and Computation, </journal> <volume> 127(2) </volume> <pages> 145-163, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: It is based on Brookes' transition trace semantics <ref> [Bro96] </ref> from which it inherits the support for local variables and fairness. In the calculus, specifications and programs are neither syntactically nor semantically distinguished. Moreover, it allows for reasoning about both safety and liveness properties like termination and eventual entry.
Reference: [BS89] <author> R.J.R. Back and K. Sere. </author> <title> Stepwise refinement of action systems. In Mathematics of Program Construction. </title> <publisher> Springer Verlag, </publisher> <year> 1989. </year> <note> LNCS 375. </note>
Reference-contexts: However, whereas Jones employs logical formulas to specify the behaviour of the program and its environment, Stirling uses sets of predicates (invariants) like we do. The work in [QJ91] augments Jones' work with an explicit notion of refinement. Back's refinement calculus for Action systems <ref> [BS89] </ref> also models refinement explicitly. However, his calculus is not syntax-directed but rather a more or less arbitrary collection of program transformation rules. All of the above mentioned approaches differ from ours at least in that they lack support for fairness and liveness properties like eventual entry. 13
Reference: [CM88] <author> K.M. Chandy and J. Misra. </author> <title> Parallel program design: a foundation. </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference: [Col94] <author> P. Collette. </author> <title> Design of Compositional Proof Systems Based on Assumption-Commitment Specifications | Application to UNITY. </title> <type> PhD thesis, </type> <institution> Uni-versite Catholique de Louvain, Belgium, </institution> <month> June </month> <year> 1994. </year>
Reference: [dBKPR91] <author> F.S. de Boer, J.N. Kok, C. Palamidessi, and J.J.M.M. Rutten. </author> <title> The failure of failures in a paradigm of asynchronous communication. </title> <booktitle> In CONCUR '91, </booktitle> <pages> pages 111-126. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference: [Din96] <author> J. Dingel. </author> <title> Modular verification for shared-variable concurrent programs. </title> <editor> In U. Montanari and V. Sassone, editors, </editor> <volume> CONCUR '96, LNCS 1119, </volume> <pages> pages 703-718. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference: [Din98] <author> J. Dingel. </author> <title> The development and verification of n-process mutual exclusion algorithms using invariants and refinement. </title> <type> Draft, </type> <year> 1998. </year>
Reference-contexts: Moreover, it allows for reasoning about both safety and liveness properties like termination and eventual entry. The calculus has been used for a completely rigorous verification of a class of n-process mutual exclusion algorithms which includes the tie-breaker, the bakery and the ticket algorithm <ref> [Din98] </ref>. Eventual entry was proved using a slight variant of Lemma 13. Our approach also is applicable to a distributed, message-passing setting in which channels are modeled as variables ranging over infinite queues with asynchronous (non-blocking) send and synchronous (blocking) receive.
Reference: [Jon81] <author> C.B. Jones. </author> <title> Development Methods for Computer Programs Including a Notion of Interference. </title> <type> PhD thesis, </type> <institution> Oxford University, </institution> <year> 1981. </year>
Reference: [Lam80] <author> L. Lamport. </author> <title> The `Hoare logic' of concurrent programs. </title> <journal> Acta Informatica, </journal> <volume> 14 </volume> <pages> 21-37, </pages> <year> 1980. </year>
Reference: [Mor89] <author> C. Morgan. </author> <title> The specification statement. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3), </volume> <month> January </month> <year> 1989. </year>
Reference: [OG76] <author> S.S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference: [Old91] <author> E.-R. Olderog. </author> <title> Nets, terms and formulas. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science 23. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference: [Par79] <author> D. Park. </author> <title> On the semantics of fair parallelism. </title> <editor> In D. Bjtrner, editor, </editor> <title> Abstract Software Specifications, </title> <publisher> LNCS 86, </publisher> <pages> pages 504-526. </pages> <publisher> Springer Verlag, </publisher> <year> 1979. </year>
Reference: [QJ91] <author> X. Qiwen and H. Jifeng. </author> <title> A theory of state-based parallel programming: Part I. </title> <editor> In J. Morris, editor, </editor> <booktitle> 4th BCS-FACS Refinement Workshop, </booktitle> <year> 1991. </year>
Reference-contexts: The proof systems in [Jon81,Sti88] both use rely-guarantee (assumption-commitment) reasoning to achieve compositionality. However, whereas Jones employs logical formulas to specify the behaviour of the program and its environment, Stirling uses sets of predicates (invariants) like we do. The work in <ref> [QJ91] </ref> augments Jones' work with an explicit notion of refinement. Back's refinement calculus for Action systems [BS89] also models refinement explicitly. However, his calculus is not syntax-directed but rather a more or less arbitrary collection of program transformation rules.
Reference: [Sti88] <author> C. Stirling. </author> <title> A generalization of Owicki-Gries' Hoare logic for a concurrent while language. </title> <journal> Theoretical Computer Science, </journal> <volume> 89 </volume> <pages> 347-359, </pages> <year> 1988. </year> <month> 14 </month>
Reference-contexts: The refinement of C 1 depends on which guarantees C 2 can make under which assumptions without itself being refined. The statement fP; g C fQ; g, which abbreviates C Q; C, will be convenient in these situations. Note that in his generalization of Owicki and Gries' Hoare logic <ref> [Sti88] </ref>, Stirling employs a statement with almost precisely the same meaning. Refinement with respect to an environment that preserves all predicates, and thus cannot change any state, implies execution inclusion (and vice versa). Moreover, trace inclusion implies refinement. Lemma 9. 1.
References-found: 18

