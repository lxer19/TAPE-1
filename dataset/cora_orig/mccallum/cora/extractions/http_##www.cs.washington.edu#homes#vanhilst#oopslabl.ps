URL: http://www.cs.washington.edu/homes/vanhilst/oopslabl.ps
Refering-URL: http://www.cs.washington.edu/homes/vanhilst/research.html
Root-URL: 
Email: fvanhilst,notking@cs.washington.edu  
Title: Using Role Components to Implement Collaboration-Based Designs  
Author: Michael VanHilst and David Notkin 
Address: PO Box 352350 Seattle, Washington 98195-2350 USA  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: In this paper we present a method of code implementation that works in conjunction with collaboration and responsibility based analysis modeling techniques to achieve better code reuse and resilience to change. Our approach maintains a closer mapping from responsibilities in the analysis model to entities in the implementation. In so doing, it leverages the features of flexible design and design reuse found in collaboration-based design models to provide similar adaptability and reuse in the implementation. Our approach requires no special development tools and uses only standard features available in the C++ language. In an earlier paper we described the basic mechanisms used by our approach and discussed its advantages in comparison to the framework approach. In this paper we show how our approach combines code and design reuse, describing specific techniques that can be used in the development of larger applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F.S. Aliee and B.C. Warboys. </author> <title> Roles represent patterns. </title> <booktitle> In Proceedings of the Workshop on Pattern Languages of Object-Oriented Programs at ECOOP'95, </booktitle> <year> 1995. </year>
Reference-contexts: The control flow can be modeled informally by drawing on a copy of the roles/responsibilities matrix, or more formally using state-transition diagrams or petri nets, as shown by Aliee and Warboys <ref> [1] </ref>. The Adding Item role in the ReceiptBasis class uses a linked list. We separated the Linked List collaboration from that of Adding Item in order to reuse an existing linked list implementation.
Reference: [2] <author> K. Beck and W. Cunningham. </author> <title> A laboratory for teaching object-oriented thinking. </title> <booktitle> In Proceedings of the 1989 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 1-6, </pages> <year> 1989. </year>
Reference-contexts: Collaborations are often used to model sequences of message passing and state changes derived from use-case-like scenarios in the requirements analysis. In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal <ref> [2, 3, 11, 20] </ref>, but they have also been formalized in contracts [10], given a notation [14, 15], and associated with framework implementations [7, 13]. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern. <p> The interaction diagram used to describe the Adding Item collaboration shows the operations that each object needs to fulfill its role in that collaboration. We simply collect the operations for a particular object and determine which attributes those operations use. CRC or class cards <ref> [2, 20] </ref> Alarm S So CustomerPanel - DepositReceiver - DepositItem ReceiptPrinter + ReceiptBasis A A AU InsertedItem - A - - - - CustomerPanel DepositReceiver ReceiptBasis InsertedItem DepositItem addItem addItem (s) addItem (*item) getItem () init (*item) incr () incr () Linked List Adding Item Validate Item Item Stuck CustomerPanel addItem
Reference: [3] <author> G. Booch. </author> <title> Object Oriented Design with Applications. </title> <address> Benjamin/Cummings, </address> <year> 1991. </year>
Reference-contexts: Collaborations are often used to model sequences of message passing and state changes derived from use-case-like scenarios in the requirements analysis. In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal <ref> [2, 3, 11, 20] </ref>, but they have also been formalized in contracts [10], given a notation [14, 15], and associated with framework implementations [7, 13]. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern.
Reference: [4] <author> G. Bracha. </author> <title> The programming language JIGSAW: mixins, modularity and inheritance. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1992. </year>
Reference-contexts: Unfortunately the meaning of the term mixin is often confused with the different semantics of multiply inherited base classes in C++. Bracha's dissertation focused on semantics and language issues and did not present mixins in the context of a design methodology <ref> [4] </ref>. The C++ Standard Template Library of Stepanov and Musser uses templates extensively [12]. But STL uses templates for genericity, not composition, and it does not use inheritance. Roles can use STL data structures, but roles can also be used to implement data structures.
Reference: [5] <author> G. Bracha and W. Cooke. </author> <title> Mixin-based inheritance. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 303-311, </pages> <year> 1990. </year>
Reference-contexts: In the object-oriented database sense, an object must have a role of that name. For database roles, the main issue is the ability of objects to dynamically change roles. Bracha and Cooke demonstrated delayed inheritance using type parameters, calling the resulting components mixins <ref> [5] </ref>. The term roughly corresponds to the use of multiply inherited classes in CLOS. Unfortunately the meaning of the term mixin is often confused with the different semantics of multiply inherited base classes in C++.
Reference: [6] <author> A.M. Burkett. </author> <title> Clarifying roles and responsibilities. </title> <journal> CMA: the Management Accounting Magazine, </journal> <volume> 69(2) </volume> <pages> 26-28, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Finally, we need to determine the order in which to compose the roles. To aid in the process of answering these questions, we have found the roles/responsibilities matrix, adapted from business management <ref> [6] </ref>, to be a useful tool. Figure 3 shows a roles/responsibilities matrix for part of the recycling machine involving the Adding Item, Item Stuck, and Validate Item collaborations. 3 In the matrix, rows represent collaborations, while columns represent classes. The internal cells of the matrix represent roles.
Reference: [7] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal [2, 3, 11, 20], but they have also been formalized in contracts [10], given a notation [14, 15], and associated with framework implementations <ref> [7, 13] </ref>. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern. In this view of collaborations, a role specifies a part of a single object that participates in a particular collaboration. <p> Conversely, if we change or replace a collaboration, the roles of its participant objects in other collaborations do not change. A few approaches to object-oriented development already use collaborations and role-like decompositions to achieve better design reuse <ref> [7, 13] </ref>. Our strategy is to extend this kind of reuse to code by implementing the roles in the design directly as encapsulated source code components. Classes are then literally compositions of role components. <p> The mechanism of Harrison and Ossher requires a runtime dispatcher and special compiler tools. By comparison, ours is a lightweight approach intended for building a single application structure. The decorator pattern from the book by Gamma, et al., is also used to add responsibilities to an object <ref> [7] </ref>. The decorator has an advantage of being able to support dynamic change. But an object's decorators must conform to a fixed interface by subclassing from a common base class. Calls to that base class must be explicitly encoded in the object being decorated.
Reference: [8] <author> G. Gottlob, M. Schrefl, and B. Rock. </author> <title> Extending object-oriented systems with roles. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 14(3), </volume> <month> July </month> <year> 1996. </year>
Reference-contexts: Compared to our approach, the decorator mechanism places more restrictions on the location and type of extension that can be applied and does not address the issue of unanticipated change. The notion of role has a counterpart in object-oriented databases <ref> [8, 18] </ref>. The issue arises, for example, when an employee object may play the role of trainee at one time and manager at another, or possibly even the same, time. While both uses of role address objects playing roles in different contexts, the database usage is more concrete.
Reference: [9] <author> W. Harrison and H. Ossher. </author> <title> Subject-oriented programming (a critique of pure objects). </title> <booktitle> In Proceedings of the 1993 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 411-428, </pages> <year> 1993. </year>
Reference-contexts: libraries and frameworks of base classes. (A comparison of our approach with frameworks is the focus of our earlier work [17].) The goal of our work is similar to that of subject-oriented programming in that both approaches address the issue of composing different views on a common set of objects <ref> [9] </ref>. In subject-oriented programming, separate applications are merged by combining common objects. The mechanism of Harrison and Ossher requires a runtime dispatcher and special compiler tools. By comparison, ours is a lightweight approach intended for building a single application structure.
Reference: [10] <author> R. Helm, I.M. Holland, and D. Gangopad-hyay. </author> <title> Contracts: Specifying behavioral compositions in object-oriented systems. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 169-180, </pages> <year> 1990. </year>
Reference-contexts: In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal [2, 3, 11, 20], but they have also been formalized in contracts <ref> [10] </ref>, given a notation [14, 15], and associated with framework implementations [7, 13]. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern.
Reference: [11] <author> I. Jacobson, M. Christenson, P. Jonsson, and G. Overgaard. </author> <title> Object-Oriented Software Engineering: A Use Case Driven Approach. </title> <publisher> Addison-Wesley, </publisher> <address> 2nd edition, </address> <year> 1992. </year>
Reference-contexts: In the third section, we present the basic details of our method of implementing roles as source code components. 1 In the fourth section we describe the design of a container recycling machine similar to the one presented in Jacobson, et al. <ref> [11] </ref>. In the fifth section, we show how to implement that design using role components. <p> Collaborations are often used to model sequences of message passing and state changes derived from use-case-like scenarios in the requirements analysis. In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal <ref> [2, 3, 11, 20] </ref>, but they have also been formalized in contracts [10], given a notation [14, 15], and associated with framework implementations [7, 13]. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern. <p> Classes are then literally compositions of role components. Because we want to implement roles directly, we need a design methodology in which roles are still identifiable late in the design process. We have found this to be possible with a number of existing collaboration-based design methodologies, including use-cases <ref> [11] </ref>, responsibilities [19], and role models [13]. 3 A Method for Implementing Roles To implement the roles from a collaboration-based design, we need a mechanism that gives role components the same properties as roles in the design. <p> Section 6 discusses the ways in which these kinds of flexibility support our strategy for application development and evolution. 4 The Recycling Machine De sign To demonstrate our implementation approach, we begin with a modified version of Jacobson, et al.'s collaboration-based design for a container recycling machine <ref> [11] </ref>. This example defines a vending machine that takes empty beverage containers and issues a receipt for the deposit value of the containers. <p> When ReceiptBasis calls getNext () on the list, it wants an object of a type that includes the InsertedItem class's Adding Item role. The returned value required an unsafe type cast in the implementation in Jacobson, et al. <ref> [11] </ref>. We avoid the type cast by making the Linked List's role in the InsertedItem class more derived than Adding Item's role. This ordering is not a problem for the InsertedItem class inheritance hierarchy, since the Adding Item role does not access anything from the Linked List role. <p> In this situation, we will want to split one or both collaborations into two parts. The common part will contain most of the attributes, while the specialized part contains mostly methods. This issue is the same as that of abstract use cases described in Jacobson, et al. <ref> [11] </ref>. The order of inheritance for role composition in the five classes discussed is shown in Fig. 6. From this graphical representation, we can generate the type definition statements to compose the roles and form the application's classes. <p> The recycling machine design in Ja-cobson, et al., had an alarmist object intended to encapsulate the Item Stuck extension to the DepositReceiver class. Even then, the ideal of completely encapsulating change could not be realized: "Unfortunately, we cannot accomplish this with today's programming languages" <ref> [11, p.250] </ref>. Code in the DepositReceiver class had to be modified to support the Alarmist's extension. Our approach doesn't have the same problem because we don't encapsulate change in separate objects. We encapsulate it in roles that can become an integral part of the original object's class.
Reference: [12] <author> D.R. Musser and A.A. Stepanov. </author> <title> Algorithm-oriented generic libraries. </title> <journal> Software Practice and Experience, </journal> <volume> 24(7) </volume> <pages> 623-642, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Bracha's dissertation focused on semantics and language issues and did not present mixins in the context of a design methodology [4]. The C++ Standard Template Library of Stepanov and Musser uses templates extensively <ref> [12] </ref>. But STL uses templates for genericity, not composition, and it does not use inheritance. Roles can use STL data structures, but roles can also be used to implement data structures.
Reference: [13] <author> T. Reenskaug. </author> <title> Working With Objects: The OOram Software Engineering Method. </title> <type> Manning, </type> <year> 1995. </year>
Reference-contexts: In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal [2, 3, 11, 20], but they have also been formalized in contracts [10], given a notation [14, 15], and associated with framework implementations <ref> [7, 13] </ref>. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern. In this view of collaborations, a role specifies a part of a single object that participates in a particular collaboration. <p> Conversely, if we change or replace a collaboration, the roles of its participant objects in other collaborations do not change. A few approaches to object-oriented development already use collaborations and role-like decompositions to achieve better design reuse <ref> [7, 13] </ref>. Our strategy is to extend this kind of reuse to code by implementing the roles in the design directly as encapsulated source code components. Classes are then literally compositions of role components. <p> Because we want to implement roles directly, we need a design methodology in which roles are still identifiable late in the design process. We have found this to be possible with a number of existing collaboration-based design methodologies, including use-cases [11], responsibilities [19], and role models <ref> [13] </ref>. 3 A Method for Implementing Roles To implement the roles from a collaboration-based design, we need a mechanism that gives role components the same properties as roles in the design. <p> Finally, we don't need multiple inheritance. 7 Related Work The OOram methodology has many similarities with the work presented here, but differs in emphasis <ref> [13] </ref>. Although both approaches start with roles and collaborations, the OOram approach combines or "synthesizes" roles in the design process to improve design comprehension, while our approach subdivides roles in the design process to improve code maintainability and reuse.
Reference: [14] <author> T. Reenskaug, E.P. Anderson, A.J. Berre, A. Hurlen, A. Landmark, O.A. Lehne, E. Nordhagen, E. Ness-Ulseth, G. Oftedal, A.L. Skaar, and P. Stenslet. OORASS: </author> <title> Seamless support for the creation and maintenance of object-oriented systems. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 5(6) </volume> <pages> 27-41, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal [2, 3, 11, 20], but they have also been formalized in contracts [10], given a notation <ref> [14, 15] </ref>, and associated with framework implementations [7, 13]. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern. In this view of collaborations, a role specifies a part of a single object that participates in a particular collaboration.
Reference: [15] <author> D. Riehle. </author> <title> Describing and composing patterns using role diagrams. </title> <editor> In H. Steffen, editor, </editor> <booktitle> WOON '96, Conference Proceedings, </booktitle> <address> St. Petersburg, Russia, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal [2, 3, 11, 20], but they have also been formalized in contracts [10], given a notation <ref> [14, 15] </ref>, and associated with framework implementations [7, 13]. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern. In this view of collaborations, a role specifies a part of a single object that participates in a particular collaboration.
Reference: [16] <author> M. VanHilst and D. Notkin. </author> <title> Decoupling change from design. </title> <booktitle> In Proceedings of SIG-SOFT'96 Foundations of Software Engineering. </booktitle> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: The distinction is not significant to how they are handled in the implementation. (In another paper we discuss the value for maintenance and reuse of capturing decisions in separate submodules similar to those discussed here <ref> [16] </ref>.) Of course, we can't support every change. By mapping units of design directly into units of implementation, our goal is to make it proportionally easy to change the implementation as it is to change the design.
Reference: [17] <author> M. VanHilst and D. Notkin. </author> <title> Using C++ templates to implement role-based designs. </title> <booktitle> In Proceedings of the 2nd JSSST International Symposium on Object Technologies for Advanced Software, </booktitle> <pages> pages 22-37. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The sixth section discusses some of the differences between our implementation and 1 A lengthier discussion of the details is available in an earlier paper, in which we compared our approach to the use of frameworks <ref> [17] </ref>. the implementation presented by Jacobson, et al., with respect to possible changes. We also describe some of our experiences with a much larger application, a telescope imaging system. <p> The emptyClass (essentially a default base class) parameter simply indicates that the Father1Class is a base class. This somewhat abstract description of our implementation method will be clarified by example in Sections 5 and 6; more details also appear elsewhere <ref> [17] </ref>. By writing different template instantiations, we can define different combinations of roles without modifying the role definitions themselves. This allows us to handle various orders of inheritance, to include the same role twice, and to add additional roles before, after, or in between the roles currently defined. <p> This is an example of what we call specialization by inserting ancestors <ref> [17] </ref>. It may be helpful to model the flow of control among collaborations as well as within collaborations to analyze the complete behavior. <p> This ordering is not a problem for the InsertedItem class inheritance hierarchy, since the Adding Item role does not access anything from the Linked List role. As we explain elsewhere <ref> [17] </ref>, we often treat data structures as collaborations and make the nodes derived classes of the data. This treatment differs from the traditional approach to reusable data structures, where the common data structure parts are base classes and nodes have pointers to data. matrix for the Print Receipt collaboration. <p> Code reuse in the OOram methodology is based on object libraries and frameworks of base classes. (A comparison of our approach with frameworks is the focus of our earlier work <ref> [17] </ref>.) The goal of our work is similar to that of subject-oriented programming in that both approaches address the issue of composing different views on a common set of objects [9]. In subject-oriented programming, separate applications are merged by combining common objects.
Reference: [18] <author> R.J. Wieringa, W. de Jong, and P. Sprint. </author> <title> Roles and dynamic subclasses: a modal logic approach. </title> <booktitle> In Proceedings of the 1993 Eu-ropean Conference on Object-Oriented Programming, </booktitle> <pages> pages 32-59, </pages> <year> 1994. </year>
Reference-contexts: Compared to our approach, the decorator mechanism places more restrictions on the location and type of extension that can be applied and does not address the issue of unanticipated change. The notion of role has a counterpart in object-oriented databases <ref> [8, 18] </ref>. The issue arises, for example, when an employee object may play the role of trainee at one time and manager at another, or possibly even the same, time. While both uses of role address objects playing roles in different contexts, the database usage is more concrete.
Reference: [19] <author> R. Wirfs-Brock and B. Wilkerson. </author> <title> Object-oriented design: A responsibility-driven approach. </title> <booktitle> In Proceedings of the 1989 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 71-76, </pages> <year> 1989. </year>
Reference-contexts: Because we want to implement roles directly, we need a design methodology in which roles are still identifiable late in the design process. We have found this to be possible with a number of existing collaboration-based design methodologies, including use-cases [11], responsibilities <ref> [19] </ref>, and role models [13]. 3 A Method for Implementing Roles To implement the roles from a collaboration-based design, we need a mechanism that gives role components the same properties as roles in the design.
Reference: [20] <author> R. Wirfs-Brock, B. Wilkerson, and L. Wiener. </author> <title> Designing Object-Oriented Software. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Collaborations are often used to model sequences of message passing and state changes derived from use-case-like scenarios in the requirements analysis. In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal <ref> [2, 3, 11, 20] </ref>, but they have also been formalized in contracts [10], given a notation [14, 15], and associated with framework implementations [7, 13]. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern. <p> The interaction diagram used to describe the Adding Item collaboration shows the operations that each object needs to fulfill its role in that collaboration. We simply collect the operations for a particular object and determine which attributes those operations use. CRC or class cards <ref> [2, 20] </ref> Alarm S So CustomerPanel - DepositReceiver - DepositItem ReceiptPrinter + ReceiptBasis A A AU InsertedItem - A - - - - CustomerPanel DepositReceiver ReceiptBasis InsertedItem DepositItem addItem addItem (s) addItem (*item) getItem () init (*item) incr () incr () Linked List Adding Item Validate Item Item Stuck CustomerPanel addItem
References-found: 20

