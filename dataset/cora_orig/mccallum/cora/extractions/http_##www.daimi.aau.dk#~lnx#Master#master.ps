URL: http://www.daimi.aau.dk/~lnx/Master/master.ps
Refering-URL: http://www.daimi.aau.dk/~lnx/
Root-URL: http://www.daimi.aau.dk
Email: e-mail: flnx j apaipig@daimi.aau.dk  
Title: Theory of Language Support for Design Patterns  
Author: Ellen Agerbo Aino Cornils 
Date: December 1997  
Address: DK-8000 Aarhus C, Denmark.  
Affiliation: Computer Science Department, Aarhus University  
Abstract-found: 0
Intro-found: 1
Reference: [Alexander79] <author> Christopher Alexander (1979): </author> <title> The Timeless Way of Building. </title> <publisher> Oxford University Press. </publisher>
Reference-contexts: This leads to the question of when to accept an idea as a new Design Pattern. When evaluating a prospective Design Pattern, we believe that these fundamental guidelines should be followed: 1 <ref> [Alexander79, pp. 19 ff] </ref> 2 Introduction * A Design Pattern is domain independent. * A Design Pattern is not an application of another Design Pattern. * A Design Pattern is language independent. * A Design Pattern is not a language construct.
Reference: [Beta93] <author> O. L. Madsen, B. Moller-Pedersen, K. </author> <title> Nygaard (1993): Object-Oriented Programming in the Beta Programming Language. </title> <publisher> Addison-Wesley Publishing Company. </publisher>
Reference-contexts: The reasons for having a fragment language as explained in <ref> [Beta93] </ref> are almost identical to the part of the motivation behind the Bridge Design Pattern found in [Gamma et al. 95] that covers the compile-time choice of an implementation, and the use of fragmentation will eliminate the need of a Bridge Design Pattern in this case.
Reference: [Buschmann96] <author> Frank Buschmann et al. </author> <year> (1996): </year> <title> Pattern-Oriented Software Architecture A system of Patterns. </title> <publisher> John Wiley & Sons Ltd. </publisher>
Reference: [Chambers93] <author> Craig Chambers (1993): </author> <title> Predicate Classes. </title> <booktitle> ECOOP '93, </booktitle> <pages> pp. 268-295. </pages>
Reference-contexts: That is what the State Design Pattern describes. The structure is as shown in Figure 5.30. ConcreteStateA Handle () state -&gt; Handle () Context State Handle ConcreteStateB Handle () Request () state The implementation in Beta is shown in Appendix A.17. In programming languages supporting dynamic classification (e.g. Cecil <ref> [Chambers93] </ref>) this Design Pattern becomes redundant since it then becomes possible for an object to change its class on runtime without changing the class hierarchy; thereby changing the behaviour of a request dynamically. An analogue to dynamic classification is dynamic inheritance.
Reference: [Coplien95] <author> J.O. </author> <title> Coplien and D.C. Schmidt (1995): Pattern Languages of Program Design. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference-contexts: As mentioned in the introduction to this thesis, the concept of patterns originated from Christopher Alexander's pattern language for architecture, and the concept has since then spread to all kinds of areas. Examples of pattern languages outside of the object-oriented community can be found in respectively <ref> [Coplien95, pp. 183-237] </ref>, where a pattern language for shaping a new organisation is presented, and in [Coplien95, pp. 259-291], where a pattern language for analysing software requirements is presented. <p> Examples of pattern languages outside of the object-oriented community can be found in respectively [Coplien95, pp. 183-237], where a pattern language for shaping a new organisation is presented, and in <ref> [Coplien95, pp. 259-291] </ref>, where a pattern language for analysing software requirements is presented. Since they do not concern themselves with object-oriented design, we can not compare these with the Design Patterns of [Gamma et al. 95], and will therefore refrain from describing them further in this thesis.
Reference: [Coplien96] <author> J.O. </author> <title> Coplien and D.C. Schmidt (1996): Pattern Languages of Program Design. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference: [Dyson96] <author> Paul Dyson and Bruce Anderson (1996): </author> <title> State Patterns. </title> <address> PLoP '96. </address>
Reference: [Einarson97] <institution> Daniel Einarson (1997) : Using Inner Classes in Design Patterns. </institution> <type> Draft. </type> <institution> Dept of Computer Science, Lund University. </institution>
Reference-contexts: The nesting extension of the OMT-notation is explained in Section 4.1. BA A B Multiple inheritance nested classes simulated using Multiple inheritance For those who are interested in reading more about nested classes we refer to [Madsen95], [Rapin95] and <ref> [Einarson97] </ref>. 2.4 Virtual Classes The virtual patterns in Beta have two aspects: The virtual procedure patterns and the virtual class patterns. The virtual procedure patterns correspond to the use of virtual functions in C ++ or methods in Smalltalk. <p> one abstraction mechanism: The pattern * List of classes These features are explained in Chapter 2, where an overview of some of Beta's special constructs is presented. 4.1 Notation for Nested Classes We have in the diagram notation for nested classes to a large extent copied the notation presented in <ref> [Einarson97] </ref>. <p> In a language supporting alternating coroutines, the modelling of this becomes more intuitive as shown in Appendix A.14, where it is implemented in Beta. Daniel Einarson and Gorel Hedin proposes in <ref> [Einarson97] </ref> two additional implementation strategies which can be used when the implementation language offers the possibility for using nested classes. <p> Therefore we do not believe it desirable for class-based object-oriented languages in general to adapt the concept of dynamic classification and thus the State Design Pattern has its usefulness. In their article <ref> [Einarson97] </ref>, Daniel Einarson and Gorel Hedin proposes the use of nested classes and singular objects of locally declared anonymous subclasses in connection with the State Design Pattern.
Reference: [Gamma et al. 95] <author> Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides (1995): </author> <title> Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley Publishing Company. </publisher>
Reference-contexts: In <ref> [Gamma et al. 95] </ref> is presented a collection of well-proven Design Patterns which have been applied in several systems. In this thesis we have evaluated these Design Patterns from the above criteria, with the emphasis placed on the connection between Design Patterns and language constructs. <p> In [Gamma et al. 95] is presented a collection of well-proven Design Patterns which have been applied in several systems. In this thesis we have evaluated these Design Patterns from the above criteria, with the emphasis placed on the connection between Design Patterns and language constructs. In <ref> [Gamma et al. 95, p. 4] </ref> the authors themselves state: "The choice of programming language is important, because it influences one's point of view. Our patterns assume Smalltalk/C ++ level language features, and that choice determines what can and cannot be implemented easily. <p> If we assumed procedural languages, we might have included design patterns called "Inheritance", "Encapsulation", and "Polymorphism". Similarly, some of our patterns are supported directly by less common object-oriented languages." Thus, it is their point of view that Design Patterns do not need to be language independent. We agree with <ref> [Gamma et al. 95] </ref> so far that the Design Patterns extracted from various applications will always be dictated by the programming language used in the application; things that are easy to do will not be worth forming into a Design Pattern. But where [Gamma et al. 95] seem to believe that <p> We agree with <ref> [Gamma et al. 95] </ref> so far that the Design Patterns extracted from various applications will always be dictated by the programming language used in the application; things that are easy to do will not be worth forming into a Design Pattern. But where [Gamma et al. 95] seem to believe that Design Patterns should emerge from each programming language, we choose the opposite point of view and will only accept those ideas as Design Patterns that are not language constructs in any actual object-oriented programming language. <p> By presenting the Pattern Language we thereby enlighten the difference between domain specific patterns and Design Patterns as domain independent entities. There are certain limits to the scope of this thesis. We only evaluate the Design Patterns from <ref> [Gamma et al. 95] </ref>, where we could have chosen among the scores of Design Patterns offered in the field of object-oriented design within the last few years. We chose [Gamma et al. 95] believing that the Design Patterns presented here are the ones best known in the entire area. <p> There are certain limits to the scope of this thesis. We only evaluate the Design Patterns from <ref> [Gamma et al. 95] </ref>, where we could have chosen among the scores of Design Patterns offered in the field of object-oriented design within the last few years. We chose [Gamma et al. 95] believing that the Design Patterns presented here are the ones best known in the entire area. <p> Organisation of the Thesis The subject of this thesis is on Design Patterns and programming languages. It is assumed that the reader has a basic understanding of the concept of what a Design Pattern is and that he is acquainted with the Design Patterns of <ref> [Gamma et al. 95] </ref>. For a short introduction to Design Patterns see Chapter 1 in [Gamma et al. 95]. <p> It is assumed that the reader has a basic understanding of the concept of what a Design Pattern is and that he is acquainted with the Design Patterns of <ref> [Gamma et al. 95] </ref>. For a short introduction to Design Patterns see Chapter 1 in [Gamma et al. 95]. Furthermore, it is assumed that the reader has a sound foundation in object-oriented programming and that he has some previous knowledge of the Beta programming language, since the largest part of the language constructs evaluated in this thesis origin in Beta. <p> Chapter 4 An extention of the OMT notation is presented, that can support features from Beta not representable in the OMT-notation. 4 Introduction Part II | Analysis of The Design Patterns Chapter 5 In this chapter we go through all the Design Patterns from <ref> [Gamma et al. 95] </ref> and compare them with language constructs of actual object-oriented programming languages. The purpose of this is to prune the field of Design Patterns; if a Design Pattern is covered by a language construct, it should not be considered a Design Pattern. <p> The purpose of this is to prune the field of Design Patterns; if a Design Pattern is covered by a language construct, it should not be considered a Design Pattern. This leads to a taxonomy of the Design Patterns of <ref> [Gamma et al. 95] </ref>, in which they are categorised as either idioms or ideas. <p> Language Design", that presents another taxonomy of the Design Patterns of <ref> [Gamma et al. 95] </ref>. It is evaluated and compared with our proposed taxonomy. Part III | Libraries of Design Patterns In this part of the thesis we investigate different ways of saving the Design Patterns in libraries. <p> This is evaluated and compared to our proposal of a library of Design Patterns. Part IV | Formats of Patterns In this part of the thesis, we present two alternative proposals of formats of patterns and compare them with the format proposed by <ref> [Gamma et al. 95] </ref>. 5 Chapter 10 The Meta Patterns are introduced and analysed. Chapter 11 An example of a pattern language is presented and analysed. <p> We finish with some concluding remarks. 7 Part I Theoretical Foundation 9 Chapter 2 Special Features in Beta Our experience with object-oriented programming stems primarily from programming in Beta, therefore we have in our work with the Design Patterns from <ref> [Gamma et al. 95] </ref> mostly referred to the language constructs found in this language. To refresh the reader's knowledge of Beta, we have included a short description of the most important features of Beta in this chapter. <p> can be achieved using pattern variables these examples should be seen as an incentive for having the concept of virtual-lists in object-oriented programming languages and not for promoting pattern variables, even though these are useful in other connections. 21 Chapter 4 Notation We have chosen to follow the notation from <ref> [Gamma et al. 95] </ref>, and use OMT-based diagrams to depict the classes and their collaborations in the Design Patterns. <p> special notation for a method-pattern to cases when it is essential to stress that a method is a pattern in its own right, and not necessarily as nested into a class pattern. 27 Part II Analysis of The Design Patterns 29 Chapter 5 Design Patterns Compared with Language Constructs In <ref> [Gamma et al. 95] </ref> the authors state that one person's Design Pattern can be another person's primitive building block, because the point of view affects one's interpretation of what is and what is not a Design Pattern. And the point of view is influenced by the choice of programming language. <p> And the point of view is influenced by the choice of programming language. The Design Patterns in <ref> [Gamma et al. 95] </ref> are based on practical solutions that have been implemented in mainstream object-oriented programming languages, like Smalltalk and C ++ . But the fact that far from all designers use these programming languages leads us to make a comparison between the Design Patterns in [Gamma et al. 95] <p> Design Patterns in <ref> [Gamma et al. 95] </ref> are based on practical solutions that have been implemented in mainstream object-oriented programming languages, like Smalltalk and C ++ . But the fact that far from all designers use these programming languages leads us to make a comparison between the Design Patterns in [Gamma et al. 95] and object-oriented programming languages in general. <p> We have chosen to present the Design Patterns in the same order as they do in <ref> [Gamma et al. 95] </ref>. 5.1 Abstract Factory The purpose of Abstract Factory is the same as that of Factory Method, which we describe in Section 5.3, with the refinement that with this Design Pattern, the user is interested in grouping products, so that one at runtime can commit to a specific <p> We do not know of any language features which would make this Design Pattern superfluous, not even of any that could ease the implementation proposed in <ref> [Gamma et al. 95] </ref> further. 32 Design Patterns Compared with Language Constructs 5.3 Factory Method The purpose of this Design Pattern is to create objects whose exact classes are unknown until runtime. This is done in [Gamma et al. 95] by instantiating the objects in virtual methods that can be bound <p> Design Pattern superfluous, not even of any that could ease the implementation proposed in <ref> [Gamma et al. 95] </ref> further. 32 Design Patterns Compared with Language Constructs 5.3 Factory Method The purpose of this Design Pattern is to create objects whose exact classes are unknown until runtime. This is done in [Gamma et al. 95] by instantiating the objects in virtual methods that can be bound at runtime as shown in Figure 5.4. FactoryMethod () Operation () FactoryMethod () ConcreteCreatorB ConcreteCreatorA FactoryMethod () product = FactoryMethod ..... <p> Furthermore it is now possible to extend the interface of the AbstractProduct-class, which is not possible using the original FactoryMethod Design Pattern. As an example of this, we have implemented the motivating maze-example of <ref> [Gamma et al. 95] </ref> in Beta. This example is shown in Appendix A.3. 5.4 Prototype 33 Using virtual classes to decide what class of objects to use at runtime is in our opinion not a Design Pattern. <p> class hierarchy of factories that parallels the class hierarchy of products. p = prototype-&gt;Clone () Clone () return copy of self ConcretePrototype1 Clone () return copy of self Prototype Clone () o Operation () Client prototype ConcretePrototype2 We find the structure of the Design Pattern in Figure 5.6, taken from <ref> [Gamma et al. 95] </ref>, to some extent misleading. As we understand it the client-class holds some sort of dictionary, that stores the objects to be cloned. And it is each of these objects in the dictionary, that should be a prototypical object. <p> This means that it is not possible to meet all the requirements of the Design Pattern as described in <ref> [Gamma et al. 95] </ref>; that is, it is not possible to implement a Singleton, which is specialisable. However, if the `Applicability' section of the Singleton Design Pattern in [Gamma et al. 95] is examined, it is noted that there are two cases: 1. <p> This means that it is not possible to meet all the requirements of the Design Pattern as described in <ref> [Gamma et al. 95] </ref>; that is, it is not possible to implement a Singleton, which is specialisable. However, if the `Applicability' section of the Singleton Design Pattern in [Gamma et al. 95] is examined, it is noted that there are two cases: 1. When there must be exactly one instance of a class, and it must be accessible to clients from a well-known access point. 2. <p> The solution is to make a TextShape subclass of the Shape class to adapt the Shape objects to the TextView-interface. In <ref> [Gamma et al. 95] </ref> the authors propose two different ways of doing this; the Object Adapter (as shown in Figure 5.8) and the Class Adapter (as shown in Figure 5.9). <p> The reasons for having a fragment language as explained in [Beta93] are almost identical to the part of the motivation behind the Bridge Design Pattern found in <ref> [Gamma et al. 95] </ref> that covers the compile-time choice of an implementation, and the use of fragmentation will eliminate the need of a Bridge Design Pattern in this case. Should the choice of implementation of a given method be made at run-time, the original Design Pattern of [Gamma et al. 95] <p> Pattern found in <ref> [Gamma et al. 95] </ref> that covers the compile-time choice of an implementation, and the use of fragmentation will eliminate the need of a Bridge Design Pattern in this case. Should the choice of implementation of a given method be made at run-time, the original Design Pattern of [Gamma et al. 95] is necessary. <p> We have chosen to diverge from the version of the Design Pattern found in <ref> [Gamma et al. 95] </ref>, in that we do not declare the operations Add, Remove and GetChild in the Component-class, since it from a modelling point of view makes little sense to assume that these operations are well-defined for all kinds of Component-objects. <p> The structure of the Design Pattern is shown in Figure 5.13. Why this structure is a solution to the requirements of the Design Pattern is probably best understood by using an example. The example used in <ref> [Gamma et al. 95] </ref> is a TextView object that displays text in a window. TextView would act as a ConcreteComponent, with a Draw ()- operation. In this state it is nothing but a window displaying text. <p> The unshared part of the object is called the extrinsic state and is an external layer on the core of the object, which makes it individual. The example used in <ref> [Gamma et al. 95] </ref> is a document containing text. To be able to use an object for each character in the document without causing an explosion in the number of objects used, it is necessary to share part of each object character. <p> The simplicity of its implementation leads to peculiar solutions. Look for example at the implementation proposed for Smalltalk in the Implementation section in <ref> [Gamma et al. 95] </ref>. Here it is suggested to exploit the error-handling functionality to implement Proxy; "Smalltalk provides a hook that one can use to support automatic forwarding of requests. Smalltalk calls doesNot-Understand: aMessage when a client sends a message to a receiver that has no corresponding method. <p> But with the present form of the Design Pattern, where the decoupling of the invoker and the implementor is part of the Design Pattern, it can merely be said that implementing it in Beta is simpler than proposed in <ref> [Gamma et al. 95] </ref>. 5.15 Interpreter The motivation behind the Interpreter-pattern is to solve simple, often occurring problems, by formulating them as sentences in a language. This language should be defined so that statements can be represented by abstract syntax trees. <p> The resulting Design Pattern proposed in <ref> [Gamma et al. 95] </ref> contains two class hierarchies, one for Aggregates and one for Iterators. 50 Design Patterns Compared with Language Constructs The structure of the Design Pattern is shown in Figure 5.24, and an example of an implementation of the Design Pattern is shown in Appendix A.14. <p> For each application of the Design Pattern, a set of Mediators, possibly specialised by subclassing, is connected to a set of objects, called Colleagues. ConcreteMediator Mediator Colleague ConcreteColleague2ConcreteColleague1 mediator This Design Pattern resembles the Observer Design Pattern, both in its motivation and structure. It is even in <ref> [Gamma et al. 95] </ref> suggested to implement this Design Pattern as an Observer, with Mediators as Observers and Colleagues as Subjects. We believe that the roles should be reversed, though, that the Mediators should act as Subjects because they serve as a centre for the Colleagues. <p> Maybe because it was a Design Pattern before Mediator. Since the Observer is only one of the variants of the Mediator, there are of course other implementation strategies proposed in <ref> [Gamma et al. 95] </ref>. And since the Observer variant is implemented in connection to the Observer description in Section 5.19, we have chosen to implement another variant of the Mediator Design Pattern. This variant lets the Colleagues be more direct in their communication. <p> The structure of the Design Pattern is in <ref> [Gamma et al. 95] </ref> presented as shown in Figure 5.27 But this structure is highly misleading since it gives no information as to how the Design Pattern is meant to work. <p> structure is shown in figure 5.28. o CareTaker Memento state = m.state return new Memento (state) Originator SetMemento (Memento m) CreateMemento () state The tricky part of the Design Pattern | namely to make sure that only the Originator-class has access to the interface of the class | is by <ref> [Gamma et al. 95] </ref> not described until in the Implementation part of the Design Pattern, which means that they have no general "object-oriented" solution to the problem, but have to fall back on features in the implementation language that is used when implementing the Design Pattern. <p> is by <ref> [Gamma et al. 95] </ref> not described until in the Implementation part of the Design Pattern, which means that they have no general "object-oriented" solution to the problem, but have to fall back on features in the implementation language that is used when implementing the Design Pattern. And in [Gamma et al. 95] they thus propose a solution in C ++ . Here it is dealt with by making the Originator a friend of Memento, and make the interface of Memento private. <p> Many applications of the Design Pattern and the example used to describe the Design Pattern in <ref> [Gamma et al. 95] </ref> deal with graphical user interfaces. An amount of data (a Subject) can have many representations (Observers) and when one of these representations are changed by the user, the data behind it and all the other representations will be changed. <p> It is thus obvious that there is a fundamental difference between the two Design Patterns, but it is not one, that is visible from the structures of the Design Patterns as presented in <ref> [Gamma et al. 95] </ref>; in fact the close connections in the purposes of the two Design Patterns is mirrored in almost identical structures of the Design Patterns. <p> They are only made for the ConcreteVisitor classes to access the attributes in the elements. This is an encapsulation- and, thereby, language-specific implementation detail and thus not relevant. The collaboration between the classes in the Design Pattern is shown in the collaboration diagram in Figure 5.36 taken from <ref> [Gamma et al. 95] </ref>. As can be seen, the diagram follows the structure from Figure 5.35, and is thus as misleading as that, when it comes to the Operation method. <p> Clos, we have chosen to view this Design Pattern as an idiom. 5.24 Discussion The aim with this chapter is to evaluate the Design Patterns and the object-oriented programming languages in relation to each other. For each of the Design Patterns in <ref> [Gamma et al. 95] </ref>, we have discussed whether it is an idiom, an inherent way of thinking in object-oriented programming, an application of another Design Pattern or a good design idea. <p> In <ref> [Gamma et al. 95] </ref>, the Design Patterns are viewed from many angles and this is not necessarily an advantage. In a Design Pattern as for instance Interpreter, we believe that the motivation part is the only thing that separates this Design Pattern from the Composite Design Pattern. <p> The same argumentation could be used for seeing the Observer Design Pattern as an application of the Mediator Design Pattern. It might just be Observer's history, which justifies it to be a Design Pattern. Since the Design Patterns from <ref> [Gamma et al. 95] </ref> are well-tested design (or at least programming) ideas, the language features which support them must be considered good abstractions in the field 5.24 Discussion 65 of object-oriented programming. <p> Consequently we use the classification of Pseudo Inheritance and Pseudo Composition in the rest of this thesis. 6.2 The Taxonomy of Design Patterns The Design Patterns of <ref> [Gamma et al. 95] </ref> are by [Gil97] divided into the three categories as follows. They offer little or no explanation to the categorisations. The degree of explanation is decreasing as the level of abstraction increases. <p> When they classify Singleton as an idiom, they only say that it corresponds to "A Module". If they by "A Module" use the traditional definition, then it can not be subclassed and it does not quite cover the Singleton Design Pattern as it is presented in <ref> [Gamma et al. 95] </ref>. As we have explained in Section 5.5, we believe that the concept of a singular object should not be tied with the possibility of subclassing, and we therefore will agree with [Gil97] in deeming Singleton an idiom. <p> They expect the Pseudo Inheritance Cadets to develop into being language features, and the Pseudo Composition Cadets to develop into programming language paradigms. 6.5 Discussion We agree with Gil and Lorenz in that many of the Design Patterns from <ref> [Gamma et al. 95] </ref> are idioms since they are language constructs from existing languages. We do not believe that all the Design Patterns classified as Pseudo Inheritance Cadets are future language constructs, not even that they ought to be. <p> Seen from a modelling point of view it is of course just as good to copy the idea of the Design Patterns directly from <ref> [Gamma et al. 95] </ref>, but this solution places a bigger demand on the designer of the application. The use of LDPs is also beneficial seen from a documentation point of view. <p> The Design Pattern will be fixed, in the sense that it will not be possible to adapt it in other ways than were foreseen when making the LDP. In many of the patterns in <ref> [Gamma et al. 95] </ref>, the authors have described a number of possible variations in the Design Patterns, some of which will be left open in the LDPs for the users to choose between, and some of which have been discarded for the sake of simplicity. <p> As the figure and above explanation shows, there is not much gained in having an implementation of the LDP in a library, since the amount of work done to apply the LDP is larger than the amount of work done when following the instructions found in <ref> [Gamma et al. 95] </ref> on how to apply the Design Pattern. 8.4 Bridge The solution of using the fragment language for a compile-time switch between actual implementations can naturally not be reused in an LDP. <p> So in the following LDP-discussion we will focus on the run-time Bridge following the structure of the Design Pattern as presented in <ref> [Gamma et al. 95] </ref>. An LDP of Bridge can capture the intent of the Design Pattern by simply containing the two classes Abstraction and Implementor. <p> If we use the motivating example of <ref> [Gamma et al. 95] </ref> as reference it thereby follows that it is already decided that a hierarchy of classes have been formed in the application: Text Picture Graphic Line The question is then what exactly it is we want to capture in the LDP, that is not already present in the <p> The question remaining is now whether it is an advantage to have the Composite Design Pattern as a LDP versus having to implement it from scratch following the directions in <ref> [Gamma et al. 95] </ref>. As an example we will use the motivating Graphics example from [Gamma et al. 95]. If the LDP is being used (we assume that the LDP of Figure 8.7 is used) the following steps will be necessary: 1. <p> The question remaining is now whether it is an advantage to have the Composite Design Pattern as a LDP versus having to implement it from scratch following the directions in <ref> [Gamma et al. 95] </ref>. As an example we will use the motivating Graphics example from [Gamma et al. 95]. If the LDP is being used (we assume that the LDP of Figure 8.7 is used) the following steps will be necessary: 1. Build the Graphics hierarchy as shown in Figure 8.5. 2. Decide which classes should play which roles of the Composite pattern. 3. <p> Even though the methods First, Next, IsDone and CurrentItem are application dependent, it is possible to specify that these should be part of the interface of every Iterator-class by declaring these as virtual methods in the abstract Iterator class. In <ref> [Gamma et al. 95] </ref> it is stated that CreateIterator plays the role of a Factory method in the Factory Method Design Pattern since it defines an interface for creating an object in a creator class (which in the current context would be the Aggregate class) but let subclasses of the creator <p> Using composition instead of inheritance in languages without multiple inheritance solves this problem. The fact, that it is possible to make a useful LDP out of a Design Pattern, proves that it is possible to make a reusable implementation of it. And since the Design Patterns in <ref> [Gamma et al. 95] </ref>, as mentioned in Chapter 5, formulate good design- or implementation-ideas, the language features that support them must be considered to be flexible and useful in relation to reuse of design. <p> This is also the idea of standard Design Patterns as they are catalogued in eg. <ref> [Gamma et al. 95] </ref>. But since these are covering framework examples they provide no means to capture the design independent of a more or less specific framework example. <p> Since the Meta Patterns are very abstract we try to give them some substance by exemplifying them using Design Patterns from <ref> [Gamma et al. 95] </ref>. 10.3 The Meta Patterns 115 HT T H Unification metapattern TH 1:1 Connection metapattern 1:1 Recursive Connection metapattern H 1:N Connection metapattern 1:N Recursive Unification metapattern 1:1 Recursive Unification metapattern 1:N Recursive Connection metapattern TH T . . * Unification Meta Pattern In the Unification Meta Pattern <p> An example of the Unification Meta Pattern can be found in the Factory Method Design Pattern from <ref> [Gamma et al. 95] </ref> (see Section 5.3). <p> An example of a 1:1 Connection Meta Pattern could be the Strategy Design Pattern from <ref> [Gamma et al. 95] </ref> (see Section 5.21). The template class will here be the Context and the hook classes will be the Strategy classes. <p> Due to this forwarding property of typical template methods in Recursive Connection Meta Patterns a hierarchy of objects built by means of the 1:N Recursive Connection Meta Pattern can be treated as a single object. This is exactly the functionality used in the Composite Design Pattern from <ref> [Gamma et al. 95] </ref> (see Section 5.8), where the Component class acts as the H class, the Composite class acts as the T class and the method Operation acts as the TH method. The Leaf classes acts as the leafs in the graph in Figure 10.9. <p> Subclasses that override or extend the UnifiedTH (...) method typically call the superclass method in their beginning or end. Otherwise the traversal of the directed graph is interrupted. The Chain of Reponsibility Design Pattern from <ref> [Gamma et al. 95] </ref> (Section 5.13 is an example of the Recursive Unification Meta Pattern. The Handler class acts as the TH class, while the Handlerequest method acts as the unifiedTH method. <p> When comparing the Meta Patterns with the Design Patterns from <ref> [Gamma et al. 95] </ref>, the examples of the Design Patterns that plays the roles of the various Meta Patterns lead us to conclude that Meta Patterns provide a more compact common vocabulary, which makes it possible to classify the Design Patterns into categories as with the Interpreter, Composite and Decorator that <p> In the realm of the documentation of a framework, the Meta Patterns will supplement the use of Design Patterns, but they can not replace them | contrary to what Pree has stated. The Design Patterns in the form of <ref> [Gamma et al. 95] </ref> provide the details of the intent, structure and consequences that the Meta Patterns completely lack, but in return the Meta Patterns are more concrete in appearance and much simpler, which makes them easier and more unambiguously understood. <p> The Design Patterns tell how the classes of the framework collaborates, and the Meta Patterns can tell how the framework can be expanded to suit the user's needs. 121 Chapter 11 Pattern Languages An alternative to the catalogues of Design Pattern, that <ref> [Gamma et al. 95] </ref> is a representative of, are the so-called pattern languages. The definition of a pattern language is simply that it is a set of patterns 1 , that combined will describe some domain. <p> Since they do not concern themselves with object-oriented design, we can not compare these with the Design Patterns of <ref> [Gamma et al. 95] </ref>, and will therefore refrain from describing them further in this thesis. <p> Johnson's patterns are to a large extent based on examples, which he claims will make them easier to understand for non-experts. His patterns are closely linked together, which makes them different from the Design Patterns we are familiar with from e.g. <ref> [Gamma et al. 95] </ref>, where Design Patterns are atomic entities. <p> In chapter 5 in this thesis we have evaluated the Design Patterns of <ref> [Gamma et al. 95] </ref> according to these criteria. Only 12 of the 23 Design Patterns from [Gamma et al. 95] remain Design Patterns following these criteria, as shown in Section 5.24. <p> In chapter 5 in this thesis we have evaluated the Design Patterns of <ref> [Gamma et al. 95] </ref> according to these criteria. Only 12 of the 23 Design Patterns from [Gamma et al. 95] remain Design Patterns following these criteria, as shown in Section 5.24. <p> This leads us to conclude that it is beneficial to have a critical approach to Design Patterns, because it minimises the amount of Design Patterns and thereby makes the area of Design Patterns easier to get on top of. Since the Design Patterns from <ref> [Gamma et al. 95] </ref> are well-tested design (or at least programming) ideas, the language features which support them must be considered good abstractions in the field of object-oriented programming. <p> In chapter 6 we have described how Joseph Gil and David H. Lorenz in their article [Gil97] have divided the Design Patterns from <ref> [Gamma et al. 95] </ref> into three categories; the cliches, which are programming advice, the idioms, which are language features in at least one object-oriented language and the cadets, which are neither cliches nor idioms. We have divided the Design Patterns into these three categories too, but in a different way. <p> The fact that it is possible to make a useful LDP out of a Design Pattern proves that it is possible to make a reusable implementation of it. And since the Design Patterns in <ref> [Gamma et al. 95] </ref>, as mentioned in Section 5, formulate good design or programming ideas, the language features which support them must be considered to be flexible and useful in relation to reuse of design. <p> It would be even better if virtual lists and a renaming scheme was incorporated. Part IV | Formats of Patterns As stated in the introduction, the benefits of the Design Patterns from <ref> [Gamma et al. 95] </ref> are the following: * They encapsulate experience. * They provide a common vocabulary for computer scientists across domain barriers. * They enhance the documentation of a framework. In chapter 10 we have introduced Wolfgang Pree's Meta Patterns as they are described in [Pree94]. <p> So the Meta Patterns: * Encapsulate no experience. * Provide a common vocabulary. * Make it more evident where to extend frameworks, but they do not ease the understanding of them. Ralph Johnson, one of the authors behind <ref> [Gamma et al. 95] </ref>, has proposed another view of patterns, namely pattern languages, in his article [Johnson92] as found in chapter 11. These frame work specific pattern languages: * Encapsulate no generally useful experience. * Do not provide a common vocabulary. * Document a specific framework in detail. <p> There are many views of what constitute a Design Pattern. In the catalogue of Design Patterns in <ref> [Gamma et al. 95] </ref>, they encapsulate ideas that have been recurrently used in existing software systems as Design Patterns. <p> do 'Action in first extension' -&gt; putline; #); hook2 :: (# do 'Action in second extension' -&gt; putline; #); hook3 :: (# do 'Action in third extension' -&gt; putline; #); #) c: @ConcreteClass; 180 The Beta programs do c.TemplateMethod; #) A multiple-hook implementation, using the Design Pattern as proposed in <ref> [Gamma et al. 95] </ref>: ORIGIN '~beta/basiclib/v1.5/betaenv' --- PROGRAM: descriptor --- (# AbstractClass: (# TemplateMethod: (# Hook1; Hook2; #); Hook1 :&lt; (# do inner; #); Hook2 :&lt; (# do inner; #) ConcreteClass: AbstractClass (# hook1 ::&lt; (# do #); hook2 ::&lt; (# do #) #) A.20 Visitor 181 A.20 Visitor An implementation <p> PROGRAM: descriptor --- (# AbstractClass: (# TemplateMethod: (# Hook1; Hook2; #); Hook1 :&lt; (# do inner; #); Hook2 :&lt; (# do inner; #) ConcreteClass: AbstractClass (# hook1 ::&lt; (# do #); hook2 ::&lt; (# do #) #) A.20 Visitor 181 A.20 Visitor An implementation of the Visitor as found in <ref> [Gamma et al. 95] </ref> ORIGIN '~beta/basiclib/v1.5/betaenv'; --- PROGRAM: descriptor --- (# Visitor: (# VisitConcreteElementA:&lt; (# Elm1:^ConcreteElementA enter Elm1 [] do INNER #); VisitConcreteElementB:&lt; (# Elm2:^ConcreteElementB enter Elm2 [] do INNER #) ConcreteVisitor1: Visitor (# VisitConcreteElementA ::&lt; (# do 'ConcreteElementA visited by ConcreteVisitor1' -&gt; puttext; newline #); VisitConcreteElementB ::&lt; (# do 'ConcreteElementB <p> Of the 'WrapperCreationTool' subclass of 'CreationTool' no information was offered. What we really lacked now was some structure on the framework; some exact information on how the classes were supposed to collaborate. Some Design Patterns in the style of <ref> [Gamma et al. 95] </ref> would at this point have been very helpful to enlighten this aspect of the framework. Since such were not available, we decided to concentrate on only a part of the framework. We chose the Tool-classes, because we understood that part of the framework.
Reference: [Gil97] <author> Joseph Gil and David H. </author> <title> Lorenz (1997): Design Patterns vs. Language Design. Workshop on Language Support for Design Patterns and Object-Oriented Frameworks (LSDF), ECOOP '97. [JAVA] http://www.javasoft.com:80/products/JDK/1.1/docs/guide/innerclasses </title>
Reference-contexts: Language Design Joseph Gil and David H. Lorenz have in their article "Design Patterns vs. Language Design" <ref> [Gil97] </ref> offered a taxonomy of Design Patterns based on how far they are from becoming actual language features. Their main hypothesis is that in many ways, Design Patterns are nothing but "puppy language features" [Gil97, p. 2]. <p> Lorenz have in their article "Design Patterns vs. Language Design" [Gil97] offered a taxonomy of Design Patterns based on how far they are from becoming actual language features. Their main hypothesis is that in many ways, Design Patterns are nothing but "puppy language features" <ref> [Gil97, p. 2] </ref>. That is, Design Patterns could (sometimes even should) grow to be language features, although they are not yet implemented as such. <p> Later in the article, the specialisation is suddenly changed to comprise three categories: Relators, Pseudo Inheritance and Pseudo Composition. Relators are here the patterns that involve a single object, Pseudo Inheritance involve two objects and Pseudo Composition are patterns that comprise a system of objects. <ref> [Gil97] </ref> from then on sticks to this categorisation, with the 68 Design Patterns vs. Language Design modification that they only use the categories Pseudo Inheritance and Pseudo Composition in their taxonomy; Relators are not mentioned any more in the article. <p> Consequently we use the classification of Pseudo Inheritance and Pseudo Composition in the rest of this thesis. 6.2 The Taxonomy of Design Patterns The Design Patterns of [Gamma et al. 95] are by <ref> [Gil97] </ref> divided into the three categories as follows. They offer little or no explanation to the categorisations. The degree of explanation is decreasing as the level of abstraction increases. <p> We will abstain from giving our comments to the categorisation and the motivation in this section; this is reserved for Section 6.5. 6.2.1 The Cliches The Design Patterns in this category are characterised by being captivating to the novice and obvious to the expert. In this way <ref> [Gil97] </ref> motivates the categorisations of the Design Patterns once and for all; they do not give other specific explanations to the individual patterns except repeating the intent of the Design Pattern. * Command * Template Method * Facade [Gil97] repeat the intents of Template Method and Facade reasonably accurately, whereas the <p> In this way <ref> [Gil97] </ref> motivates the categorisations of the Design Patterns once and for all; they do not give other specific explanations to the individual patterns except repeating the intent of the Design Pattern. * Command * Template Method * Facade [Gil97] repeat the intents of Template Method and Facade reasonably accurately, whereas the intent of Command is reduced to encapsulating non-physical things in objects. 6.2.2 The Idioms [Gil97] motivates the categorisations of the Design Patterns in this category by naming the language constructs that supposedly encorporate the Design Pattern in question. <p> give other specific explanations to the individual patterns except repeating the intent of the Design Pattern. * Command * Template Method * Facade <ref> [Gil97] </ref> repeat the intents of Template Method and Facade reasonably accurately, whereas the intent of Command is reduced to encapsulating non-physical things in objects. 6.2.2 The Idioms [Gil97] motivates the categorisations of the Design Patterns in this category by naming the language constructs that supposedly encorporate the Design Pattern in question. <p> offer no explanations as to how the language constructs encorporate the Design Pattern. * Abstract Factory * Factory Method * Singleton * Prototype * Memento * Visitor * Iterator * Flyweight Class and type separation Class and type separation A Module ATemplate Friend - Multi-methods - (probably) - (not sure) <ref> [Gil97] </ref> also claim, that today's Design Patterns may well be tomorrow's language mechanisms, and as an example of such a Design Pattern that is a likely candidate for an idiom, they use Observer, that allegedly almost is part of Java. 6.3 Evaluation of the Taxonomy 69 6.2.3 The Cadets This category <p> language mechanisms, and as an example of such a Design Pattern that is a likely candidate for an idiom, they use Observer, that allegedly almost is part of Java. 6.3 Evaluation of the Taxonomy 69 6.2.3 The Cadets This category contains the Design Patterns, which are neither cliches nor idioms. <ref> [Gil97] </ref> argues for their categorisation of Design Patterns into the subcategory of Pseudo Composition, that this category basically comprises all architectures which revolve around trees of objects. * Composite * Interpreter * Builder * Visitor (unless it is regarded as an idiom) In the categorisation of the Design Patterns into the <p> of Design Patterns into the subcategory of Pseudo Composition, that this category basically comprises all architectures which revolve around trees of objects. * Composite * Interpreter * Builder * Visitor (unless it is regarded as an idiom) In the categorisation of the Design Patterns into the subcategory of Pseudo Inheritance, <ref> [Gil97] </ref> simply state that these are the Design Patterns that deal with the relation between two objects: * Abstract Factory * Factory Method * Adapter * Bridge * Decorator * Proxy * Chain-of-Responsibility * Mediator * Memento * Observer * State * Strategy 6.3 Evaluation of the Taxonomy We will in <p> Instead we will evaluate the taxonomy of <ref> [Gil97] </ref> from the criteria they give as motivations. 6.3.1 The Cliches We quite agree with [Gil97] in their evaluation of the Template Method Design Pattern as a fundamental way of thinking in object-oriented programming, and to some extent also in this evaluation of Facade. <p> Instead we will evaluate the taxonomy of <ref> [Gil97] </ref> from the criteria they give as motivations. 6.3.1 The Cliches We quite agree with [Gil97] in their evaluation of the Template Method Design Pattern as a fundamental way of thinking in object-oriented programming, and to some extent also in this evaluation of Facade. <p> Therefore we do not agree in classifying the Command Design Pattern as a cliche. 70 Design Patterns vs. Language Design 6.3.2 The Idioms The classification of Abstract Factory and Factory Method as idioms is not quite justified. In their own definition, idioms are what other languages have as built-ins. <ref> [Gil97] </ref> claim that Abstract Factory and Factory Method are idioms, because they | in a language that distinguishes between class and type | provide the separation of class and type, so that a creation of an object would reveal its type and not its class. <p> As we have explained in Section 5.5, we believe that the concept of a singular object should not be tied with the possibility of subclassing, and we therefore will agree with <ref> [Gil97] </ref> in deeming Singleton an idiom. Prototype is stated to be covered by the template construct. <p> We can think of no language constructs that supports either one, and with only the comments "probably" and "not sure" from <ref> [Gil97] </ref> as motivations, we find it hard to believe that they truly should be idioms. 6.3.3 The Cadets Since the Design Patterns have been categorised as Cadets on the grounds that they do not belong in any of the other two categories, it is only possible for us to comment on <p> The reasons for these classifications is explained in Section 5.24, and we will therefore refrain from repeating them here. * Composite * Visitor * Factory Method * Strategy Cliche Idiom Idiom Cliche 6.4 Gil's and Lorenz's Conclusion 71 6.4 Gil's and Lorenz's Conclusion <ref> [Gil97] </ref> believe that the biggest weakness of the Design Patterns are their evasiveness. They state that the current process of forming Design Patterns is fundamentally different from similar processes in the emerging of traditional engineering solutions. Traditionally engineering solutions are based on the socalled "exact sciences"; mathematics, physics, etc. <p> Traditionally engineering solutions are based on the socalled "exact sciences"; mathematics, physics, etc. And these sciences do not encorporate the whys; the purpose or the intent of the solutions. They only encorporate the hows; the structures and the collaborations of the solutions. Since computer science is an exact science, <ref> [Gil97] </ref> believe that it should be possible to describe Design Patterns in a less evasive form than the current. Therefore they chose to concentrate on the mechanics of the Design Patterns, which led them to make the above presented taxonomy. <p> Some of these Design Patterns are good design ideas, which is not possible or even profitable to incorporate in a language. An exampe is the Observer Design Pattern, which <ref> [Gil97] </ref> state almost lies in Java, and therefore almost certainly will be a future language construct. But the way it is in Java is that it is placed in a library, where it can be used as our LDP's are suggested to be used. <p> In chapter 6 we have described how Joseph Gil and David H. Lorenz in their article <ref> [Gil97] </ref> have divided the Design Patterns from [Gamma et al. 95] into three categories; the cliches, which are programming advice, the idioms, which are language features in at least one object-oriented language and the cadets, which are neither cliches nor idioms. <p> And what was left was twelve cadets. Now one would assume, that the Design Patterns which are cadets in our taxonomy would be the same as the Design Patterns which are cadets in <ref> [Gil97] </ref>. But this is not the case. and the reason must be found in the other two categories, since the subtraction of the Design Patterns in these define the cadets. The sets of idioms ought to be identical, since language features are well-defined by the semantics of object-oriented languages.
Reference: [Johnson92] <author> Ralph Johnson (1992): </author> <title> Documenting Frameworks using Patterns. </title> <booktitle> OOPSLA '92, </booktitle> <pages> pp. 63-76. </pages>
Reference-contexts: Ralph Johnson, one of the authors behind [Gamma et al. 95], has proposed another view of patterns, namely pattern languages, in his article <ref> [Johnson92] </ref> as found in chapter 11. These frame work specific pattern languages: * Encapsulate no generally useful experience. * Do not provide a common vocabulary. * Document a specific framework in detail.
Reference: [Kristensen83] <author> Bent Bruun Kristensen, Ole Lehrmann Madsen, Birger Moller-Pedersen and Kris-ten Nygaard (1983): </author> <title> Abstraction mechanisms in the Beta programming language. </title> <booktitle> Conference Record of the POPL '83 pp. </booktitle> <pages> 285-298. </pages> <publisher> ACM </publisher>
Reference-contexts: First the concept of virtual nonterminals is introduced; then it is demonstrated how these can be used for simulation of virtual patterns as known in Beta 97 and finally the concept of a virtual-list is introduced. 3.2.1 Virtual Nonterminals in Beta In <ref> [Kristensen83] </ref> a generalisation of the virtual concept is proposed that will make it possible to parameterise a pattern with any syntactic category of the language. This generalisation is called virtual nonterminals. <p> possible extension hvirt AC: Action-Parti Action-part ACA: Specification of actions after possible extension #) And the binding of V in subpatterns of P will be done in the following way: subP: P (# V.virt AT:: Specification of extending attribute-part V.virt AC:: Specification of extending action-part #) 3.2.3 Virtual Lists In <ref> [Kristensen83] </ref> it is furthermore proposed that it should be possible to declare a list of virtual nonterminals; a so-called virtual-list.
Reference: [Madsen92] <author> O. L. Madsen, B. </author> <month> Moller-Pedersen </month> <year> (1992): </year> <title> Part-objects and their location. </title> <booktitle> Proceeding of TOOLS '92 pp. </booktitle> <pages> 283-297. </pages>
Reference-contexts: a circumvention of this by use of pattern variables is a violation of the design. 13 Chapter 3 Proposed Extensions of Beta In this chapter we will describe some proposed extensions to Beta 97 , that we find useful in connection to our work with the Design Patterns. 3.1 Renaming <ref> [Madsen92] </ref> proposes a renaming scheme for components, which makes the attributes in the objects' components directly accessible as if they were attributes of the object itself. <p> Incidental inheritance supports code sharing and reuse; inheritance of implementation. Essential inheritance supports the specification of the classes; inheritance of the interface and the semantics of methods and attributes. This classification can be extended with a third branch, namely aspects as described by <ref> [Madsen92] </ref>. A class C can be described as having many different aspects a 1 ,a 2 . . . a n each forming its own class A 1 ,A 2 . . . A n , and A should then inherit from each of these classes. <p> Then the different roles they play could be viewed as aspects of the classes <ref> [Madsen92] </ref>. <p> It is not possible to use an object everywhere one of its components can be used, but the functionality can be achieved explicitly by using the loc reference as proposed in <ref> [Madsen92] </ref>. This is depicted in the four part-figures of Figure 7.4. M1 M2 M3 - M myVar:&lt;Object Figure C k: @K myVar:: K2 my: ^myVar M3-specific attributes M3 f (m3.k) (= ObjectKn) my f (K) = K.loc.my.... <p> Moreover, we will in the LDPs affected by this problem propose a way of circumventing this problem by using the possibility of renaming attributes in part objects as proposed in <ref> [Madsen92] </ref>; a short description is found in Section 3.1. In Chapter 5 we have divided the Design Patterns into two categories; the ones which constitute an idea worth preserving as a structure and the idioms, which are concepts that could have been language constructs.
Reference: [Madsen95] <author> Ole Lehrmann Madsen (1995): </author> <title> Open Issues in Object-oriented Programming | A Scandinavian Perspective. </title> <journal> Software | practice and experience, </journal> <volume> Vol. </volume> <publisher> 25(S4), S4/3-S4/43 (De-cember 1995) John Wiley & Sons, Ltd. </publisher>
Reference-contexts: The nesting extension of the OMT-notation is explained in Section 4.1. BA A B Multiple inheritance nested classes simulated using Multiple inheritance For those who are interested in reading more about nested classes we refer to <ref> [Madsen95] </ref>, [Rapin95] and [Einarson97]. 2.4 Virtual Classes The virtual patterns in Beta have two aspects: The virtual procedure patterns and the virtual class patterns. The virtual procedure patterns correspond to the use of virtual functions in C ++ or methods in Smalltalk.
Reference: [Pree94] <author> Wolfgang Pree (1994): </author> <title> Meta Patterns A Means For Capturing the Essentials of Reusable Object-Oriented Design. </title> <booktitle> ECOOP '94, </booktitle> <pages> pp. 150-162. BIBLIOGRAPHY 191 </pages>
Reference-contexts: Whereas the OO-society has fully adopted the idea of Design Patterns, no language has as yet been developed that satisfies these two goals. The concept of Meta Patterns as introduced by Wolfgang Pree in [Pree95] is presented as a capable candidate to be this counterpart in OO-programming. In <ref> [Pree94] </ref> Pree states: "To learn new frameworks, experts recommend that one should start by learning basic concepts first, and then proceed to take a look at various frameworks. The major disadvantage of that approach is the enormous effort required. <p> In chapter 10 we have introduced Wolfgang Pree's Meta Patterns as they are described in <ref> [Pree94] </ref>. The advantage of these should allegedly be to describe all Design Patterns on a higher level and thereby make them redundant. We believe, that they are too abstract, only useful in relation to hot spots and not generally useful on an entire framework. <p> As in <ref> [Pree94] </ref> we exemplify the attachement of Meta Patterns to framework examples by connecting the classes and methods to the roles they play in the Meta Pattern by arrows as shown in Figure B.2, Figure B.3 and Figure B.4.
Reference: [Pree95] <author> Wolfgang Pree (1995): </author> <title> Design Patterns for Object-Oriented Software Development. </title> <publisher> Addison-Wesley Publishing Company. </publisher>
Reference-contexts: Whereas the OO-society has fully adopted the idea of Design Patterns, no language has as yet been developed that satisfies these two goals. The concept of Meta Patterns as introduced by Wolfgang Pree in <ref> [Pree95] </ref> is presented as a capable candidate to be this counterpart in OO-programming. In [Pree94] Pree states: "To learn new frameworks, experts recommend that one should start by learning basic concepts first, and then proceed to take a look at various frameworks. <p> Of course they could contain a UnifiedTH method but they do not need that functionality. More information on the different Meta Patterns and examples of their use can be found in <ref> [Pree95] </ref>. 10.3.3 Evaluation of the Meta Patterns We can now answer the question we started this chapter with: 10.4 Application of Meta Patterns 119 "What exactly is a Meta Pattern?" A Meta Pattern is a structure, that tells how a template class works together with one or more hook classes, indicating <p> This now raises the question of how the Meta Patterns are meant to be applied. In <ref> [Pree95] </ref> it is indicated that their main purpose is to document the hot spots of an application, thereby making it easy for a user to apply the framework to his specific needs. <p> Unfortunately this didn't mean that we knew where classes should be overridden or specialised to some specific need, so for to use the Meta Patterns to some practical purpose at all, we were forced to bend the goal of Meta Patterns (as it was described in <ref> [Pree95] </ref>) a little and apply them to a part of the framework that not necessarily is a hot spot. As we have argued in the conclusion of Chapter 10, this is also necessary to document a framework in a useful way.
Reference: [Rapin95] <author> Charles Rapin (1997): </author> <title> Block Structured Object Programming. </title> <journal> Sigplan Notices. ACM Press, </journal> <volume> Vol. 32 No 4, </volume> <month> April </month> <year> 1997. </year>
Reference-contexts: The nesting extension of the OMT-notation is explained in Section 4.1. BA A B Multiple inheritance nested classes simulated using Multiple inheritance For those who are interested in reading more about nested classes we refer to [Madsen95], <ref> [Rapin95] </ref> and [Einarson97]. 2.4 Virtual Classes The virtual patterns in Beta have two aspects: The virtual procedure patterns and the virtual class patterns. The virtual procedure patterns correspond to the use of virtual functions in C ++ or methods in Smalltalk.
Reference: [Riehle96] <author> Dirk Baumer and Dirk Riehle (1996): </author> <title> Late Creation | A Creational Pattern. </title> <publisher> PLoP'96. </publisher>
Reference: [Sakkinen92] <author> Markku Sakkinen (1992): </author> <title> Inheritance and Other Main Principles of C ++ and Other Object-oriented Languages. </title> <institution> chapter 4 University of Jyv askyl a. </institution>
Reference-contexts: C In languages that support part objects, composition can be used to simulate multiple inheritance as can be seen in Figure 7.2. A C But there are different motivations of multiple inheritance with different ways to simulate multiple inheritance. 76 Using Libraries of Design Patterns In <ref> [Sakkinen92] </ref> Markku Sakkinen proposes a classification of the motivations behind inheritance as a distinction between incidental and essential inheritance. Incidental inheritance supports code sharing and reuse; inheritance of implementation. Essential inheritance supports the specification of the classes; inheritance of the interface and the semantics of methods and attributes.
Reference: [Soukup95] <author> Jiri Soukup (1995): </author> <title> Implementing Patterns. Pattern Languages of Program Design. </title> <editor> Eds. Coplien and Schmidt. </editor> <publisher> Addison-Wesley 1995. </publisher>
Reference-contexts: Only clients needing more customisability will need to look beyond the Facade class to call methods which are too specific to be placed in the unified interface. This solution resembles the solution to one of the problems described in the article "Implementing Patterns" by Jiri Soukup <ref> [Soukup95] </ref>: "Multiple patterns can lead to large clusters of mutually dependent classes, which is one of the main reasons why object-oriented systems can be difficult to manage." In Chapter 9 this article is further discussed. * When there are many dependencies between clients and the implementation classes of an abstraction. <p> Part III | Libraries of Design Patterns In chapter 9 we have described the idea found in <ref> [Soukup95] </ref> in which Jiri Soukup states that pattern classes formulates a solution to the three problems which from his point of view attaches to the use of Design Patterns. 1. The Design Patterns get lost during the implementation. This leads to debugging and maintenance problems later. 2.
Reference: [Wills96] <author> Alan Cameron Wills (1996): </author> <title> Frameworks. </title> <booktitle> Object Expert 1(5) Jul/Aug 1996. </booktitle>
References-found: 21

