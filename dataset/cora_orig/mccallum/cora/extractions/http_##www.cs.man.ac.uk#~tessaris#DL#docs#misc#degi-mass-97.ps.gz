URL: http://www.cs.man.ac.uk/~tessaris/DL/docs/misc/degi-mass-97.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~tessaris/DL/papers.html
Root-URL: http://www.cs.man.ac.uk
Title: Combining Deduction and Model Checking into Tableaux and Algorithms for Converse-PDL  
Phone: 113,  
Author: Giuseppe De Giacomo and Fabio Massacci 
Address: Informat  via Salaria  "La Sapienza", Italy  
Affiliation: Dipartimento di  ica e Sistemistica,  Roma.  Dip. di Informatica e Sistemistica, Universita di Roma  
Note: To appear in Information and Computation, special issue on the "Federated Logic Conferences", 1997. Preprint stampato da  
Abstract: This paper presents a prefixed tableaux calculus for Propositional Dynamic Logic with Converse based on a combination of different techniques such as prefixed tableaux for modal logics and model checkers for -calculus. We prove the correctness and completeness of the calculus and illustrate its features. We also discuss the transformation of the tableaux method (naively NEXPTIME) into an EXPTIME algorithm. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <editor> R. Alur and T. Henzinger, editors. </editor> <booktitle> Proc. of the Int. Conf. on Comp.Aided Verification (CAV-96), vol. 1102 of Lecture Notes in Comp. </booktitle> <publisher> Sci., Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Indeed, the work in this paper confirms that the combination of model-checking and theorem proving techniques, as witnessed also by the recent CAV conference <ref> [1] </ref>, may be very fruitful also for purely deductive techniques. 1.1 Plan of the paper In the rest of the paper we present at first the intuitions underlying our work and emphasize the possibility of merging theorem proving and model checking techniques for dynamic and temporal logics (x2).
Reference: 2. <author> G. Bhat and R. Cleaveland. </author> <title> Efficient local model-checking for fragments of the modal -calculus. </title> <booktitle> In Proc. of the Int. Conf. on Tools and Algorithms for the Construction and Analysis of Systems (TACAS-96), vol. 1055 of Lecture Notes in Comp. Sci., </booktitle> <pages> pp. 107-126. </pages> <publisher> Springer-Verlag 1996. </publisher>
Reference: 3. <author> G. Bhat, R. Cleaveland, and O. Grumberg. </author> <title> Efficient on-the-fly model checking for CT L fl . In Proc. </title> <booktitle> of the 10th Int. Conf. of Logic in Comp. Sci. (LICS-95), </booktitle> <pages> pp. 388-397. </pages> <publisher> IEEE Comp. Society Press, </publisher> <year> 1995. </year>
Reference-contexts: The key point is that to avoid exponential behaviour on average it is not enough to store only the visited nodes as in [22]. We must also track the nodes already proven to be inconsistent as in <ref> [3] </ref>. Intuition 27. Use a global data structure to store "bad" sets, which have been proven to lead to contradiction in previous expansion of the tableau. <p> We can transform this algorithm into an on-the-fly method by creating the data structure dynamically as in <ref> [3] </ref>, [17, Sec. 5.5] or in [11,18] for modal logics rather than starting from an already fully developed one. Each time we find a a new set of formulae S=oe we add the pair hS=oe; last (oe)i to the database. <p> Still the flavor of the algorithm is breadth first. Its transformation into a depth-first algorithm is similar to the techniques of <ref> [3] </ref>. We first present the algorithm for PDL to clarify the intuitions and afterward we extend it to CPDL.
Reference: 4. <author> P. Blackburn and E. Spaan. </author> <title> A modal perspective on computational complexity of attribute value grammar. </title> <journal> J. of Logic, Language and Information, </journal> <volume> 2 </volume> <pages> 129-169, </pages> <year> 1993. </year>
Reference: 5. <author> D. Calvanese, G. De Giacomo, and M. Lenzerini. </author> <title> Structured objects: Modeling and reasoning. </title> <booktitle> In Proc. of the 4th Int. Conf. on Deductive and Object-Oriented Databases (DOOD-95), vol. 1013 of Lecture Notes in Comp. Sci., </booktitle> <pages> pp. 229-246. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference: 6. <author> G. De Giacomo. </author> <title> Eliminating "converse" from Converse PDL. </title> <journal> J. of Logic, Language and Information, </journal> <volume> 5 </volume> <pages> 193-208, </pages> <year> 1996. </year>
Reference-contexts: The existence of a set characterising past symmetric computations was pointed out in [11] and used in <ref> [6] </ref> to provide a translation of CPDL into PDL. Intuition 26. To identify two duplicate nodes the formulae which compose them must also completely specify the past (the arriving program), so we use analytic cut on a small subset of subformulae to complete the nodes. <p> For the other case this means that X j+i j X j j X. Hence the only way to introduce oe j+1 : X is to reduce completely oe j : haeiX. By induction on the construction of ae (with a 16 technique similar to those used in <ref> [6] </ref>) it is possible to verify that hoe j ; oe j+1 i is in ae I and therefore the claim follows by definition of j=.
Reference: 7. <author> G. De Giacomo and M. Lenzerini. </author> <title> Boosting the correspondence between description logics and propositional dynamic logics. </title> <booktitle> In Proc. of the 12th Nat. Conf. on Artificial Intelligence (AAAI-94), </booktitle> <pages> pp. 205-212. </pages> <publisher> AAAI Press/The MIT Press, </publisher> <year> 1994. </year>
Reference: 8. <author> G. De Giacomo and F. Massacci. </author> <title> Tableaux and algorithms for propositional dynamic logic with converse. </title> <booktitle> In Proc. of the 13th Int. Conf. on Automated Deduction (CADE-96), vol. 1104 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pp. 613-628. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: From the formal point of view, CPDL shares many characteristics with the basic PDL, and many results for PDL extend to CPDL without difficulties. For instance the proofs of finite model property for PDL in [10] are easily extended to ? A preliminary version of this work appeared in <ref> [8] </ref>. ?? Communicating author: Fabio Massacci, Dipartimento di Informatica e Sistemistica, via Salaria 113, I-00198 Roma, Italy, email: massacci@dis.uniroma1.it. 1 CPDL, as well as the proof of EXPTIME-completeness in [21].
Reference: 9. <author> A. Emerson. </author> <title> Automated temporal reasoning about reactive systems. </title> <booktitle> In Moller and Birtwistle [19], </booktitle> <pages> pp. 41-101. </pages>
Reference: 10. <author> N. Fisher and R. Ladner. </author> <title> Propositional dynamic logic of regular programs. </title> <journal> J. of Comp. and System Sci., </journal> <volume> 18 </volume> <pages> 194-211, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction Propositional Dynamic Logics (PDLs) are modal logics introduced in <ref> [10] </ref> to model the evolution of the computation process by describing the properties of states reached by programs during their execution [15,24,27]. <p> Over the years, PDLs have been proved to be a valuable formal tool in Computer Science, Logic, Computational Linguistics, and Artificial Intelligence far beyond their original use for program verification (e.g. [4,12,14,15,24,23]). In this paper we focus on Converse-PDL (CPDL) <ref> [10] </ref>, obtained from the basic logic PDL by adding the converse operator to programs, which is interpreted as the converse of the (input-output) relation interpreting the program. <p> From the formal point of view, CPDL shares many characteristics with the basic PDL, and many results for PDL extend to CPDL without difficulties. For instance the proofs of finite model property for PDL in <ref> [10] </ref> are easily extended to ? A preliminary version of this work appeared in [8]. ?? Communicating author: Fabio Massacci, Dipartimento di Informatica e Sistemistica, via Salaria 113, I-00198 Roma, Italy, email: massacci@dis.uniroma1.it. 1 CPDL, as well as the proof of EXPTIME-completeness in [21]. <p> Indeed hae fl i' j h (:'?; ae) fl i' j hwhile :' do aei&gt; is valid in CPDL <ref> [10] </ref>. 5 A formula hae fl i' can be expressed in the modal mu-calculus as X:' _ haeiX where X:(X) denote the least fixpoint of the open formula (X). 7 [fl] : oe : ' oe : :haeihae fl i' hfli : oe : hae fl i' X = hae fl
Reference: 11. <author> M. </author> <title> Fitting. Proof Methods for Modal and Intuitionistic Logics. </title> <publisher> Reidel, </publisher> <year> 1983. </year>
Reference-contexts: Finally we sketch the transformation of NEXPTIME tableaux into EXPTIME algorithms (x7) and conclude (x8). 2 Tableaux and Model Checking Techniques The use of tableaux for modal logics dates back to Kripke (see [13] for a recent overview or <ref> [11] </ref> for a "classical" treatment) and efficient procedures based on depth first search are known [14,16]. Tableaux methods for satisfiability checking have been developed for the basic PDL [20,22], but not for many extensions, such as CPDL, whereas automata theoretic techniques are available [26,27]. <p> The existence of a set characterising past symmetric computations was pointed out in <ref> [11] </ref> and used in [6] to provide a translation of CPDL into PDL. Intuition 26. To identify two duplicate nodes the formulae which compose them must also completely specify the past (the arriving program), so we use analytic cut on a small subset of subformulae to complete the nodes. <p> In the new model the state |(oe 0 ) fulfills the eventuality hae fl i' in N R &lt; N ae-steps. We can repeat the process until we reach an N 0 R, getting again a contradiction. ut The correctness theorem follows with a standard argument <ref> [11] </ref>: Theorem 20. If has a validity proof then is valid for CPDL.
Reference: 12. <author> N. Friedman and J. Halper. </author> <title> On the complexity of conditional logics. </title> <booktitle> In Proc. of the 4th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR-94), </booktitle> <pages> pp. 202-213. </pages> <publisher> Morgan Kaufman, </publisher> <year> 1994. </year>
Reference: 13. <author> R. Gore. </author> <title> Tableaux method for modal and temporal logics. </title> <type> Tech. Rep. </type> <institution> TR-ARP-15-5, Australian National University, </institution> <year> 1995. </year> <note> To appear as chapter on the "Handbook of Tableau Methods". </note>
Reference-contexts: Finally we sketch the transformation of NEXPTIME tableaux into EXPTIME algorithms (x7) and conclude (x8). 2 Tableaux and Model Checking Techniques The use of tableaux for modal logics dates back to Kripke (see <ref> [13] </ref> for a recent overview or [11] for a "classical" treatment) and efficient procedures based on depth first search are known [14,16]. Tableaux methods for satisfiability checking have been developed for the basic PDL [20,22], but not for many extensions, such as CPDL, whereas automata theoretic techniques are available [26,27].
Reference: 14. <author> J. Halpern and Y. Moses. </author> <title> A guide to completeness and complexity for modal logics of knowledge and belief. </title> <journal> Artificial Intelligence, </journal> <volume> 54 </volume> <pages> 319-379, </pages> <year> 1992. </year> <month> 20 </month>
Reference-contexts: This algorithm computes each time from scratch without keeping track of discarded branches, i.e. it does not learn from failures. This makes sense for logics in PSPACE <ref> [14] </ref> but not for PDLs. In fact the naive algorithm works in NEXP-TIME, while CPDL is EXPTIME complete [10,21].
Reference: 15. <author> D. Kozen and J. Tiuryn. </author> <title> Logic of programs. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Hand--book of Theoretical Computer Science, </booktitle> <volume> vol. II, chap. 14, </volume> <pages> pp. 789-840. </pages> <publisher> Elsevier Sci. Publishers, </publisher> <year> 1990. </year>
Reference-contexts: In the sequel is the formula to be proved valid or satisfiable. The semantics is based on Kripke structures <ref> [15] </ref>: a model is a pair hW; Ii where W is a non empty set of states and I an interpretation s.t. for every direct atomic program a it is a I W fi W and for every propositional letter P it is P I W .
Reference: 16. <author> R. Ladner. </author> <title> The computational complexity of provability in systems of modal propositional logic. </title> <journal> SIAM J. of Computing, </journal> <volume> 6(3) </volume> <pages> 467-480, </pages> <month> Sept. </month> <year> 1977. </year>
Reference: 17. <author> Z. Manna and A. Pnueli. </author> <title> Temporal Verification of Reactive Systems (Safety), </title> <journal> vol. </journal> ~ <volume> 2. </volume> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The first intuition is to build the AND-OR graph of the phase 1 in an incremental fashion, as particles tableaux for temporal logics <ref> [17] </ref>, Intuition 21. A node of the tableau is a set of formulae and new nodes are generated only by reducing already present formulae. In this way we generate nodes and check for local consistency "on-the-fly". <p> There is another way that fully addresses this problem, based on the same intuition of history variables i.e. "auxiliary variables whose values in the current states reflect all the facts we need to know about the past" <ref> [17] </ref> 3 . This idea has been used for model checking techniques for the modal -calculus, introducing new propositional variables (names) for denoting fixpoints [24]. <p> This makes sense for logics in PSPACE [14] but not for PDLs. In fact the naive algorithm works in NEXP-TIME, while CPDL is EXPTIME complete [10,21]. A worst case EXPTIME algorithm can be developed as in [22] or <ref> [17, Sec.5.1-5.4] </ref>: use a suitable data structure where all possible subsets of the formulae that may appear in the tableau are listed. <p> We can transform this algorithm into an on-the-fly method by creating the data structure dynamically as in [3], <ref> [17, Sec. 5.5] </ref> or in [11,18] for modal logics rather than starting from an already fully developed one. Each time we find a a new set of formulae S=oe we add the pair hS=oe; last (oe)i to the database. <p> Its transformation into a depth-first algorithm is similar to the techniques of [3]. We first present the algorithm for PDL to clarify the intuitions and afterward we extend it to CPDL. For a segment S we say that S=oe:A:n is a successor <ref> [17] </ref> of S=oe if the prefix oe:A:n has been introduced by an application of a hAi-rule to a prefixed formula oe : hAi' in S. Next we can define a "bad"-set as follows: Definition 23.
Reference: 18. <author> F. Massacci. </author> <title> Strongly analytic tableaux for normal modal logics. </title> <booktitle> In Proc. of the 12th Int. Conf. on Automated Deduction (CADE-94), vol. 814 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pp. 723-737. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Devise rules which take into account both formulae and prefixes. In this framework we simply devise tableaux rules for the converse of an (atomic) program with the techniques for symmetric modal logics B or S5 from <ref> [18] </ref>: Intuition 25. Necessity-like formulae with direct programs such as [A]' move formulae forward when the last prefixed transition is direct and backward when the last transition is converse. [A ] does the opposite. <p> Transitional rules for CPDL modal logics <ref> [18] </ref>: we use both forward (F) and backward (B) rules for necessities. The rules for iteration combines prefixed tableaux with the ideas of [25,24] for model checking fixpoints in the modal -calculus 5 (Fig. 3).
Reference: 19. <editor> F. Moller and G. Birtwistle, editors. </editor> <title> Logics for Concurrency (Structure versus Automata), </title> <booktitle> vol. 1043 of Lecture Notes in Comp. </booktitle> <publisher> Sci. Springer-Verlag, </publisher> <year> 1996. </year>
Reference: 20. <author> V. Pratt. </author> <title> A practical decision method for propositional dynamic logic. </title> <booktitle> In Proc. of the 10th ACM Symp. on Theory of Computing (STOC-78), </booktitle> <pages> pp. 326-337, </pages> <year> 1978. </year>
Reference-contexts: Yet, these procedures are more suited for proving theoretical results than for being used in applications. Tableaux procedures for PDL [20,22], which are typically simpler in practice, have never been extended. In <ref> [20] </ref> Pratt says "We do not have a practical approach to this difficulty with converse, and our "practical" procedure therefore does not deal with converse".
Reference: 21. <author> V. Pratt. </author> <title> Models of program logics. </title> <booktitle> In Proc. of the 20th Annual Symp. on the Found. of Comp. Sci. (FOCS-79), </booktitle> <pages> pp. 115-122. </pages> <publisher> IEEE Comp. Society Press, </publisher> <year> 1979. </year>
Reference-contexts: of finite model property for PDL in [10] are easily extended to ? A preliminary version of this work appeared in [8]. ?? Communicating author: Fabio Massacci, Dipartimento di Informatica e Sistemistica, via Salaria 113, I-00198 Roma, Italy, email: massacci@dis.uniroma1.it. 1 CPDL, as well as the proof of EXPTIME-completeness in <ref> [21] </ref>. However, efficient in practical cases inference procedures have been successfully developed for PDL, but their extension to CPDL has proved to be a difficult task and unsuccessful till now (to the best of our knowledge). <p> A node of the tableau is a set of formulae and new nodes are generated only by reducing already present formulae. In this way we generate nodes and check for local consistency "on-the-fly". In contrast with maximal model techniques <ref> [21] </ref>, tableaux methods generate all subsets of the Fisher-Ladner closure only in the worst cases. The idea of proceeding in an incremental fashion can be pushed further by executing the two phases, building the AND-OR graph and model checking eventualities, at the same time 2 .
Reference: 22. <author> V. Pratt. </author> <title> A near-optimal method for reasoning about action. </title> <journal> J. of Comp. and System Sci., </journal> <volume> 20 </volume> <pages> 231-255, </pages> <year> 1980. </year>
Reference-contexts: This problem does not arise (mutatis mutandis) in temporal logic because ae can only be "next". The solution developed by Pratt in <ref> [22] </ref> has been the introduction of an operator ) to link every eventuality of the form haei' with the corresponding fulfilling node where ' holds. However this may lead to a cumbersome tableau and to many unnecessary relations between formulae. <p> Last but not least we want to lower the complexity of the tableaux procedure from NEXPTIME to EXPTIME. The key point is that to avoid exponential behaviour on average it is not enough to store only the visited nodes as in <ref> [22] </ref>. We must also track the nodes already proven to be inconsistent as in [3]. Intuition 27. Use a global data structure to store "bad" sets, which have been proven to lead to contradiction in previous expansion of the tableau. <p> Look behind analytic cut As mentioned in Sect. 2, these variables are introduced to detect the presence of ae loops which do not fulfill hae fl i'. Using such variables, we can eliminate the ) (and its transitive closure) introduced by Pratt <ref> [22] </ref>. Remark 2. The combination of converse with iteration fl is harder than both of them in isolation: although [A] B is enough for CPDL without iteration and X rules are enough for PDL, their combination is not enough for full CPDL. <p> It can generate the longer hoe; Bi by reducing haeiX. However if oe must be a copy of oe 0 this means that also oe : :' must be there and oe would not fulfill X. In a nutshell we found an unsuccessful loop <ref> [22] </ref>: we try to fulfill an eventuality hae fl i' with X-rules; the left-hand "branches" with oe : ' are always discarded; finally we meet a prefix oe ! with the same formulae of an already seen prefix; so we conclude that we could never fulfill it and give up. <p> We need to use segments to take tests into accounts. In a nutshell we are reconstructing (only for the proof and only for iterated eventualities) the ) relation of Pratt <ref> [22] </ref>. Then we can prove the following result whose intuition is that either an eventuality is fulfilled (and OE forms a well-ordering with maximum), or after a certain stage all X fall into a final cluster (and OE is not well-founded). Lemma 17. <p> This makes sense for logics in PSPACE [14] but not for PDLs. In fact the naive algorithm works in NEXP-TIME, while CPDL is EXPTIME complete [10,21]. A worst case EXPTIME algorithm can be developed as in <ref> [22] </ref> or [17, Sec.5.1-5.4]: use a suitable data structure where all possible subsets of the formulae that may appear in the tableau are listed. <p> We use pairs &lt;set of formulae, arriving program&gt; as elements of the database. At the end, we start a marking algorithm which deletes bad pairs as in <ref> [22] </ref>. A key difference is that we discard at once all prefixes with an X making the branch ignorable. This is more effective than [22] also for PDL since we do not compute the transitive closure of ) but just look for Xs locally. <p> At the end, we start a marking algorithm which deletes bad pairs as in <ref> [22] </ref>. A key difference is that we discard at once all prefixes with an X making the branch ignorable. This is more effective than [22] also for PDL since we do not compute the transitive closure of ) but just look for Xs locally.
Reference: 23. <author> K. Schild. </author> <title> A correspondence theory for terminological logics: Preliminary report. </title> <booktitle> In Proc. of the 12th Int. Joint Conf. on Artificial Intelligence (IJCAI-91), </booktitle> <pages> pp. 466-471. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, </address> <year> 1991. </year>
Reference: 24. <author> C. Stirling. </author> <title> Modal and temporal logics for processes. </title> <booktitle> In Moller and Birtwistle [19], </booktitle> <pages> pp. 149-237. </pages>
Reference-contexts: This idea has been used for model checking techniques for the modal -calculus, introducing new propositional variables (names) for denoting fixpoints <ref> [24] </ref>.
Reference: 25. <author> C. Stirling and D. Walker. </author> <title> Local model checking in modal mu-calculus. </title> <journal> Theor. Comp. Sci., </journal> <volume> 89 </volume> <pages> 161-177, </pages> <year> 1991. </year>
Reference-contexts: The necessity of (successful and unsuccessful) loop checking for eventualities has been pointed out in [20,22] for PDL, and is even stronger for the modal mu-calculus <ref> [25] </ref>. We think that the combination of model checking and deductive techniques, improves the efficiency and readability of the calculus.
Reference: 26. <author> R. Streett and A. Emerson. </author> <title> An automata theoretic decision procedure for the propositional mu-calculus. </title> <journal> Information and Control, </journal> <volume> 81 </volume> <pages> 249-264, </pages> <year> 1989. </year>
Reference: 27. <author> M. Vardi and P. Wolper. </author> <title> Automata-theoretic techniques for modal logics of programs. </title> <journal> J. of Comp. and System Sci., </journal> <volume> 32 </volume> <pages> 183-221, </pages> <year> 1986. </year>
Reference-contexts: To be precise, inference procedures based on model enumeration [10,21] or on automata on infinite trees <ref> [27] </ref> have been extended to converse of programs. Yet, these procedures are more suited for proving theoretical results than for being used in applications. Tableaux procedures for PDL [20,22], which are typically simpler in practice, have never been extended. <p> Intuition 23. Associate iterated eventualities with new names X : define reduction rules which use the name rather than the formula. Next we focus on the converse operator. One of the intuition used for automata theoretic techniques <ref> [27] </ref> is to use two-ways tree models where a transition can go from the current state to its child (direct) or vice versa (converse). We combine this idea with the notion of prefixed tableaux developed for modal logics of knowledge and belief [11,18] to get the following: Intuition 24. <p> The next step, when we look for duplicated nodes, is to take into account what has been also noted for automata <ref> [27] </ref>: "we also have to know what program connects this node to its predecessor." With prefixed tableaux this check is straightforward: it is embedded into the label of the formulae of each state. 3 A related idea is used for automata [27] by introducing state formulae like cycle (ae) to represent <p> into account what has been also noted for automata <ref> [27] </ref>: "we also have to know what program connects this node to its predecessor." With prefixed tableaux this check is straightforward: it is embedded into the label of the formulae of each state. 3 A related idea is used for automata [27] by introducing state formulae like cycle (ae) to represent the fact that there is a ae-loop which passes through that state. 4 We still need to "guess" a small subset of formulae that characterises past computations, especially when we are trying to discard unfulfilled eventualities 4 . <p> Intuitively oe denote the sequence of two-ways transitions (in the sense of <ref> [27] </ref>) of states and atomic programs A that starts from the initial state 1 and reach the state where ' holds. For instance the prefix 1:a :2:b:3:a:5:c :4 corresponds to w 1 w 2 ! w 3 ! w 5 w 4 . PDL has only one-way transitions. <p> An identical requirement is used for automata <ref> [27] </ref>. Point (ii) is not necessary for PDL. Definition 4.
Reference: 28. <author> M. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 1-37, </pages> <year> 1994. </year>
Reference: 29. <author> W. Woods and J. Schmolze. </author> <title> The KL-ONE family. </title> <booktitle> In Semantic Networks in Artificial Intelligence, </booktitle> <pages> pp. 133-178. </pages> <publisher> Pergamon Press, </publisher> <year> 1992. </year> <month> 21 </month>
Reference-contexts: There are certain applications of PDLs where the ability of denoting converse programs is essential. For instance, recent research in Knowledge Representation [7,5,23] points out a tight correspondence between PDLs and a family of class-based knowledge representation formalisms, known as the Description Logics <ref> [29] </ref>. Such research shows that, by means of suitable polynomial reductions, inference in very expressive description logics can be rephrased as inference in CPDL. Thus, inference procedures for CPDL can be exploited as the reasoning core for such knowledge representation formalisms.
References-found: 29

