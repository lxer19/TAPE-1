URL: http://www.cs.cornell.edu/mayr/sigmod98-81.ps
Refering-URL: http://www.cs.cornell.edu/mayr/research.htm
Root-URL: http://www.cs.cornell.edu
Email: fmigod,mayr,praveen,tveg@cs.cornell.edu  
Title: Secure and Portable Database Extensibility  
Author: Michael Godfrey Tobias Mayr Praveen Seshadri Thorsten von Eicken 
Address: Ithaca, NY 14853  
Affiliation: Computer Science Department Cornell University,  
Abstract: We explore the tradeoffs involved in extending the PREDATOR object-relational database server using Java. We also describe some interesting details of our implementation. The issues examined in our study are security, efficiency, and portability. Our performance experiments compare Java-based extensibility with traditional alternatives in the native language of the server. We explore a variety of UDFs that differ in the amount of computation involved and in the quantity of data accessed. We also qualitatively compare the security and portability of the different alternatives. Our conclusion is that Java-based UDFs are a viable approach in terms of performance. However, there may be challenging design issues in integrating Java UDFs with existing database systems. 
Abstract-found: 1
Intro-found: 1
Reference: [Ber95] <author> Brian Bershad. </author> <title> Extensibility, safety and performance in the spin operating system. </title> <booktitle> In Fifteenth Symposium on Operating Systems Principle, </booktitle> <year> 1995. </year>
Reference-contexts: The main sources of security violations considered are illegal memory accesses and the unauthorized invocation of procedures. One proposed technique is to use safe languages to write the extensions, and to ensure at compile and link time that the extensions are safe. The Spin project <ref> [Ber95] </ref>, for example, uses a variant of Modula-3 and a sophisticated linker to provide the desired protection.
Reference: [Car97] <author> Luca Cardelli. </author> <booktitle> Type Systems The Computer Science and Engineering Handbook 1997: </booktitle> <pages> 2208-2236 </pages>
Reference-contexts: Any access using such an identifier has to accord to the rules of that type. The necessary information that cannot be determined statically, like array bounds and dynamic casts, is checked at runtime (for a survey of type systems, see <ref> [Car97] </ref>). 2 The security community calls this the `least privilege' principle [SS75]. Every user is granted the least set of privileges necessary. Safe languages depend on the trustworthiness of their compilers: the compiled code is guaranteed to have no invalid memory accesses and perform no invalid jumps.
Reference: [CDF + 94] <author> M.J. Carey, D.J. DeWitt, M.J. Franklin, N.E. Hall, M. McAuliffe, J.F. Naughton, D.T. Schuh, M.H. Solomon, C.K. Tan, O. Tsatalos, S. White, and M.J. Zwilling. </author> <title> Shoring up persistent objects. </title> <booktitle> In Proceedings of ACM SIGMOD '94 International Conference on Management of Data, </booktitle> <address> Minneapolis, MN, </address> <pages> pages 526-541, </pages> <year> 1994. </year>
Reference-contexts: It provides a query processing engine on top of the Shore storage manager <ref> [CDF + 94] </ref>. The server is a single multi-threaded process, with at least one thread per connected client. While the server is written in C++, clients can be written in several languages, including C++ and Java.
Reference: [Cim97] <author> Cimarron Taylor. </author> <title> Java-Relational Database Management Systems. </title> <note> http://www.jbdev.com/, 1997. </note>
Reference-contexts: In an interesting development, a few research projects and small companies are building database systems totally in Java <ref> [Cim97] </ref>. arguments to the client. A further problem which is often overlooked is that UDFs may require access to other functions and facilities in the database server (for example, to store intermediate results). Consequently, we will focus on server-side UDFs in this paper.
Reference: [DFW96] <author> Drew Dean, Edward W. Felten, and Dan S. </author> <title> Wal-lach Java Security: From HotJava to Netscape and Beyond 1996 IEEE Symposium on Security and Privacy, </title> <address> Oakland, CA </address>
Reference-contexts: We note that while these mechanisms do provide an increased level of security, they are not foolproof; indeed, there is much ongoing research into further enhancements to Java security. The security mechanisms used in Java are complex and lack formal specification <ref> [DFW96] </ref>. Their correct ness cannot be formally verified without such a specifica-tion, and further, their implementations are complex and have been known to exhibit vulnerabilities. Additionally, the three main components: verifier, class loader, and security manager are strongly inter-dependent. If one of them fails, all security restrictions can be circumvented.
Reference: [Fra96] <author> M.J. Franklin. </author> <title> Client Data Caching. </title> <publisher> Kluwer Academic Press, </publisher> <address> Boston, </address> <year> 1996. </year>
Reference-contexts: This would correspond to the "data-shipping" approach used by object-oriented databases <ref> [Fra96] </ref> which is known to be a poor choice for certain queries, as both the server and the network perform significant unnecessary work. An alternative strategy is for the server to contact the client for each UDF execution.
Reference: [FJK96] <author> M.J. Franklin, B.T. Jonsson and D. Kossman. </author> <title> Performance Tradeoffs for Client-Server Query Processing. </title> <booktitle> In Proceedings of ACM SIGMOD '96 International Conference on Management of Data 1996. </booktitle>
Reference-contexts: In a Two-Tier architecture, a Java applet running within the web browser also acts as the database client, meaning that it directly connects to the database server, sends requests to the server and displays the results to the user. This resembles the familiar "query-shipping" architecture of client-server database systems <ref> [FJK96] </ref> . The Java applets that act as client programs are downloaded from a web server (i.e., HTTP server) running on the same machine as the database server. In a Three-Tier architecture, the work of the client program is divided into two components: presentation and program logic. <p> Specifically, cost-based query optimization algorithms have been developed to "place" UDFs within query plans [Hel95, Jhi88]. Some recent research has explored the possibility of evaluating queries partially at the server and partially at the client (this has been called "hybrid-shipping") <ref> [FJK96] </ref>. However, this work has not been applied to extensible systems. Portability and ease of extensibility have largely been neglected by current OR-DBMS technology. Traditionally, it has been assumed that most database extensions would be written by authorized and experienced "DB Developers", and not by naive users.
Reference: [HCL + 90] <author> L. Haas, W. Chang, G.M. Lohman, J. McPher-son, P.F. Wilms, G. Lapis, B. Lindsay, H. Pira-hesh, M. Carey, and E. Shekita. </author> <title> Starburst mid-flight: As the dust clears. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March </month> <year> 1990. </year>
Reference-contexts: However, our results apply equally to OO-DBMSs as well. While some research has addressed the ability to add new data types [Sto86, SRG83] and new access methods <ref> [SRH90, HCL + 90] </ref>, most extensible commercial DBMSs and large research prototypes have been built to support user-defined functions (UDFs) that can be added to the server and accessed within SQL queries.
Reference: [Hel95] <author> Joseph M. Hellerstein. </author> <title> Optimization and Execution Techniques for Queries With Expensive Methods. </title> <type> PhD thesis, </type> <institution> University of Wisconsin, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: Further, this may lead to a smaller data transfer to the client over the network. Given the focus on efficiency, most research on UDFs has investigated the interaction between database query optimization and UDFs. Specifically, cost-based query optimization algorithms have been developed to "place" UDFs within query plans <ref> [Hel95, Jhi88] </ref>. Some recent research has explored the possibility of evaluating queries partially at the server and partially at the client (this has been called "hybrid-shipping") [FJK96]. However, this work has not been applied to extensible systems. Portability and ease of extensibility have largely been neglected by current OR-DBMS technology.
Reference: [Jhi88] <author> Anant Jhingran. </author> <title> A Performance Study of Query Optimization Algorithms on a Database System Supporting Procedures. </title> <booktitle> In Proceedings of the Fourteenth International Conference on Very Large Databases, </booktitle> <pages> pages 88-99, </pages> <year> 1988. </year>
Reference-contexts: Further, this may lead to a smaller data transfer to the client over the network. Given the focus on efficiency, most research on UDFs has investigated the interaction between database query optimization and UDFs. Specifically, cost-based query optimization algorithms have been developed to "place" UDFs within query plans <ref> [Hel95, Jhi88] </ref>. Some recent research has explored the possibility of evaluating queries partially at the server and partially at the client (this has been called "hybrid-shipping") [FJK96]. However, this work has not been applied to extensible systems. Portability and ease of extensibility have largely been neglected by current OR-DBMS technology.
Reference: [JNI] <institution> JNI - Java Native Interface http://www.javasoft.com/products/jdk/1.1 /docs/guide/jni/index.html </institution>
Reference-contexts: This is usually reflected in the efficiency of the system. Note 5 In our case, the impedance mismatch is incurred by using the Java native interfacing mechanism (e.g., JNI). There are different implementations available from Sun <ref> [JNI] </ref> and Microsoft [RNI]. that the language boundary needs to be crossed for each UDF invocation, and there may be several such invocations. <p> by the size of the data (arguments and results) that has to be passed through shared memory. 4.2 Integrated Execution of Java UDFs In our implementation, Java functions are invoked from within the server using the Java Native Interface (JNI) provided as part of Sun's Java Development Kit (JDK) 1.1 <ref> [JNI] </ref>. The first step is to instantiate a Java Virtual Machine (JVM) as a C++ object. Any classes that need to be used should have been compiled from Java source (.java files) to Java byte-codes (.class files). The classes are loaded into the JVM using a specified interface.
Reference: [MWCG98] <author> Greg Morrisett, David Walker, Karl Crary, and Neal Glew. </author> <booktitle> From System F to Typed Assembly Language To appear in the 1998 Symposium on Principles of Programming Languages </booktitle>
Reference-contexts: Possible solutions to this problem are the addition of a verifiable certificate to the compiled code either in the form of proof carrying code [Nec97] or as typed assembly language <ref> [MWCG98] </ref>. Another approach is the use of typed intermediate code as the target language for compilation. This code can be verified and executed by platform-specific interpreters while the code itself remains platform independent. The safety of strongly-typed languages is preserved without the need for a trusted compiler.
Reference: [NCW98] <institution> Just In Time for Java vs. </institution> <address> C++ http://www.ncworldmag.com/ncworld/ncw-01-1998/ncw-01-rmi.html </address>
Reference-contexts: This paper presents such a qualitative study, and a quantitative comparison of Java-based UDFs with other UDF technologies. The experimental conclusions are consistent with results from the Java benchmarking community <ref> [NCW98] </ref>. * Java UDFs suffer marginally in performance compared to native UDFs when the functions are computationally intensive.
Reference: [Nec97] <author> George C. Necula. </author> <booktitle> Proof-Carrying Code Proceedings of the 24th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Lnaguages (POPL'97), </booktitle> <address> Paris, France, </address> <year> 1997. </year>
Reference-contexts: Unfortunately, these properties cannot, in general, be verified on resulting compiled code because the type information of the source program is stripped off during compilation. Possible solutions to this problem are the addition of a verifiable certificate to the compiled code either in the form of proof carrying code <ref> [Nec97] </ref> or as typed assembly language [MWCG98]. Another approach is the use of typed intermediate code as the target language for compilation. This code can be verified and executed by platform-specific interpreters while the code itself remains platform independent.
Reference: [Nor97] <author> Anil Nori. </author> <type> Personal Communication, </type> <year> 1997. </year>
Reference-contexts: This paper represents our initial work on this subject, and is limited to studying the execution of UDFs at the database server. Many vendors of universal database servers are in the process of adding Java-based extensibility <ref> [Nor97] </ref>. However, to the best of our knowledge, there has been no study of the design needed or of the tradeoffs underlying various design decisions. This paper presents such a qualitative study, and a quantitative comparison of Java-based UDFs with other UDF technologies. <p> In fact, some large commercial database vendors have attempted to use an off-the-shelf JVM, and have encountered difficulties that have lead them to roll-their-own JVMs <ref> [Nor97] </ref>. The primary problem is that database servers tend to build proprietary OS-level mechanisms. For instance, many database servers use their own threads package and memory management mechanisms.
Reference: [RNI] <institution> Microsoft Raw Native Interface http://premium.microsoft.com/msdn/library/ sdkdoc/java/htm/rni introduction.htm </institution>
Reference-contexts: This is usually reflected in the efficiency of the system. Note 5 In our case, the impedance mismatch is incurred by using the Java native interfacing mechanism (e.g., JNI). There are different implementations available from Sun [JNI] and Microsoft <ref> [RNI] </ref>. that the language boundary needs to be crossed for each UDF invocation, and there may be several such invocations.
Reference: [PS97] <author> Mark Paskin and Praveen Seshadri. </author> <title> Building an OR-DBMS over the WWW: Design and Implementation Issues. </title> <note> Submitted to SIGMOD 98, </note> <year> 1997. </year>
Reference-contexts: While the server is written in C++, clients can be written in several languages, including C++ and Java. Specifically, considerable effort has been invested in building Java applet clients than can run within web browsers and connect directly with the database server <ref> [PS97] </ref>. The feature of PREDATOR most relevant to this paper is the ability to specify and integrate UDFs. The original implementation supports only Design 1 (i.e., UDFs implemented in C++ and integrated into the server process). <p> The details of this library are presented in <ref> [PS97] </ref>. It is roughly analogous to a JDBC driver (in fact, we have built a JDBC driver on top of it) with extensions for handling complex data types. The user sits at a client machine and accesses the PREDATOR database server through a standard web browser.
Reference: [SLR97] <author> Praveen Seshadri, Miron Livny, and Raghu Ra-makrishnan. </author> <title> The Case for Enhanced Abstract Data Types. </title> <booktitle> In Proceedings of the Twenty Third International Conference on Very Large Databases (VLDB), </booktitle> <address> Athens, Greece, </address> <month> August </month> <year> 1997. </year>
Reference-contexts: However, with the growing acceptance of Java as a relatively secure and portable programming language, the question arises: can the use of Java aid database extensibility? We are exploring this question through implementation and performance measurement in the PREDATOR OR-DBMS <ref> [SLR97] </ref>. Specifically, this work is performed in the context of the Jaguar project which explores various benefits of incorporating Java into PREDATOR. The motivation of the project is the next-generation of database applications that will be deployed over the web. <p> We do not consider Design 4 explicitly | we assume that its behavior can be extrapolated as a combination of Design 2 and Design 3. 4 Implementation in PREDATOR PREDATOR is an object-relational database system developed at Cornell <ref> [SLR97] </ref>. It provides a query processing engine on top of the Shore storage manager [CDF + 94]. The server is a single multi-threaded process, with at least one thread per connected client. While the server is written in C++, clients can be written in several languages, including C++ and Java.
Reference: [SRG83] <author> M. Stonebraker, B. Rubenstein, and A. Guttman. </author> <title> Application of Abstract Data Types and Abstract Indices to CAD Data Bases. </title> <booktitle> In Proceedings of the Engineering Applications Stream of Database Week, </booktitle> <address> San Jose, CA, </address> <month> May </month> <year> 1983. </year>
Reference-contexts: In this paper, we focus on OR-DBMS systems, because they are the dominant commercial database systems, and because PREDATOR falls into this category. However, our results apply equally to OO-DBMSs as well. While some research has addressed the ability to add new data types <ref> [Sto86, SRG83] </ref> and new access methods [SRH90, HCL + 90], most extensible commercial DBMSs and large research prototypes have been built to support user-defined functions (UDFs) that can be added to the server and accessed within SQL queries.
Reference: [SRH90] <author> Michael Stonebraker, Lawrence Rowe, and Michael Hirohama. </author> <title> The Implementation of POSTGRES. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 125-142, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: However, our results apply equally to OO-DBMSs as well. While some research has addressed the ability to add new data types [Sto86, SRG83] and new access methods <ref> [SRH90, HCL + 90] </ref>, most extensible commercial DBMSs and large research prototypes have been built to support user-defined functions (UDFs) that can be added to the server and accessed within SQL queries.
Reference: [SS75] <author> Jerome H. Saltzer, Michael D. Schroeder. </author> <note> The Protection of Information in Computer Systems http://web.mit.edu/Saltzer/www/ publications/protection </note>
Reference-contexts: The necessary information that cannot be determined statically, like array bounds and dynamic casts, is checked at runtime (for a survey of type systems, see [Car97]). 2 The security community calls this the `least privilege' principle <ref> [SS75] </ref>. Every user is granted the least set of privileges necessary. Safe languages depend on the trustworthiness of their compilers: the compiled code is guaranteed to have no invalid memory accesses and perform no invalid jumps.
Reference: [Sto86] <author> Michael Stonebraker. </author> <title> Inclusion of New Types in Relational Data Base Systems. </title> <booktitle> In Proceedings of the Second IEEE Conference on Data Engineering, </booktitle> <pages> pages 262-269, </pages> <year> 1986. </year>
Reference-contexts: In this paper, we focus on OR-DBMS systems, because they are the dominant commercial database systems, and because PREDATOR falls into this category. However, our results apply equally to OO-DBMSs as well. While some research has addressed the ability to add new data types <ref> [Sto86, SRG83] </ref> and new access methods [SRH90, HCL + 90], most extensible commercial DBMSs and large research prototypes have been built to support user-defined functions (UDFs) that can be added to the server and accessed within SQL queries.
Reference: [vEHCCH98] <author> Thorsten von Eicken, Chris Hawblitzel,Chi-Chao Chang, Gzegorz Czajkowski, and Deyu Hu. </author> <title> Implementing Multiple Protection Domains in Java to appear, </title> <booktitle> Usenix 1998 Annual Technical Conference, </booktitle> <address> June 15-19, New Orleans, Louisiana. </address>
Reference-contexts: Memory usage, however, cannot currently be monitored: the JVM does not maintain any information on the memory usage of individual UDFs. The J-Kernel project at Cornell <ref> [vEHCCH98] </ref> is exploring resource management mechanisms in secure language mechanisms, like JVMs. Specifically, the project is developing mechanisms that will instrument Java byte-codes so that the use of resources can be monitored and policed.
Reference: [WLAG93] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Fourteenth Symposium on Operating Systems Principle, </booktitle> <year> 1993. </year>
Reference-contexts: The original implementation supports only Design 1 (i.e., UDFs implemented in C++ and integrated into the server process). No protection mechanism (like software fault isolation) was used to ensure that the UDF is well-behaved. From published research on the subject <ref> [WLAG93] </ref>, we expect such a mechanism to add an overhead of approximately 25%. For the purposes of this study, we have also implemented Design 2 (C++ UDFs run in a separate process) and Design 3 (Java UDFs run within the server process). We now discuss these implementations.
Reference: [Yell96] <author> Frank Yellin. </author> <title> Low Level Security in Java http://www.javasoft.com:81/sfaq/verifier.html </title>
Reference-contexts: Under the assumption that we trust the correctness of the JVM implementation, these mechanisms guarantee that only safe code is loaded from classes that the UDF is allowed to use <ref> [Yell96] </ref>. These can include other UDF classes, but, for example, not the classes in control of the system resources.
References-found: 25

