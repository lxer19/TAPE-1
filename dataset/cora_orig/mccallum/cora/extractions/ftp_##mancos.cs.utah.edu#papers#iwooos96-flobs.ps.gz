URL: ftp://mancos.cs.utah.edu/papers/iwooos96-flobs.ps.gz
Refering-URL: http://www.cs.utah.edu/~baford/pub.html
Root-URL: 
Email: ftullmann, lepreau, baford, mikeg@cs.utah.edu  
Title: User-level Checkpointing Through Exportable Kernel State  
Author: Patrick Tullmann Jay Lepreau Bryan Ford Mike Hibler 
Web: http://www.cs.utah.edu/projects/flux/  
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science University of Utah  
Abstract: We have implemented a transparent user-mode check-pointer as an application on our Fluke microkernel. This microkernel consistently and cleanly supports the importing and exporting of fundamental kernel state safely to and from user applications. Implementing a transparent checkpoint-ing facility with this sort of kernel support simplifies the implementation, and expands its flexibility and power. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: A new kernel foundation for UNIX development. </title> <booktitle> In Proc. of the Summer 1986 USENIX Conference, </booktitle> <pages> pages 93-112, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: The call will be transparently restarted later. All other error codes roll the kernel state back and dispatch the error as appropriate. Except for threads, which are automatically stopped upon a get state call, exporting the state does not affect the kernel object itself. Mach 3.0 <ref> [1] </ref> attempted to provide interruption and rollback of kernel operations, by providing the thread abort () operation. However, thread abort () will abort a non-atomic operation in a non-restartable way. For example, a multi-page IPC transfer may have transferred an arbitrary amount of data at the time of the abort.
Reference: [2] <author> K. Chandy and L. Lamport. </author> <title> Distributed snapshots: Deter mining global states of distributed systems. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> Feb. </month> <year> 1985. </year>
Reference-contexts: Since thread abort () is not a transparent operation, but can impact IPC state, the Mach 3.0 task migration is not guaranteed to function correctly in all situations. User-level checkpointers have been implemented in a variety of operating systems with varying levels of service and transparency <ref> [2, 4, 11] </ref>. Most of them require re-linking with the target application in order to intercept appropriate system calls [11], or use shared libraries. Kernel state is inferred from calls to and results of kernel system calls.
Reference: [3] <author> D. R. Cheriton and K. J. Duda. </author> <title> A caching model of operating system kernel functionality. </title> <booktitle> In Proc. of the First Symp. on Operating Systems Design and Implementation, </booktitle> <pages> pages 179-193. </pages> <publisher> USENIX Association, </publisher> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: The nested process model is the focus of a paper [5] published in OSDI `96. This paper concentrates on the issues associated with the exportability of kernel state. 3. Related work The V++ Cache Kernel <ref> [3] </ref> supports loading and unloading threads, address spaces, and kernels between the Cache Kernel and special user process application kernels. The state in these objects may be changed when they are unloaded from the Cache Kernel.
Reference: [4] <author> E. N. Elnoxzahy, D. B. Johnson, and W. Zwaenepoel. </author> <title> The performance of consistent checkpointing. </title> <booktitle> In 11th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 39-47, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Since thread abort () is not a transparent operation, but can impact IPC state, the Mach 3.0 task migration is not guaranteed to function correctly in all situations. User-level checkpointers have been implemented in a variety of operating systems with varying levels of service and transparency <ref> [2, 4, 11] </ref>. Most of them require re-linking with the target application in order to intercept appropriate system calls [11], or use shared libraries. Kernel state is inferred from calls to and results of kernel system calls. <p> In a second pass the pickled flob state is injected, and the inter-object references are restored. There is a lot of room for improvement in the policy our checkpointer implements. There are well known optimizations <ref> [4, 11] </ref> which are orthogonal to the use of exportable kernel state; we plan to integrate several of these features into our checkpointer in the future. 5.
Reference: [5] <author> B. Ford, M. Hibler, J. Lepreau, P. Tullmann, G. Back, and S. Clawson. </author> <title> Microkernels meet recursive virtual machines. </title> <booktitle> In Proc. of the Second Symp. on Operating Systems Design and Implementation, </booktitle> <address> Seattle, WA, Oct. 1996. </address> <publisher> USENIX Association. </publisher>
Reference-contexts: If the immediate child is a full multi-process POSIX system manager, then the entire systemPIDs, signal state, everything kept track of by the manageris included in the checkpoint. The nested process model is the focus of a paper <ref> [5] </ref> published in OSDI `96. This paper concentrates on the issues associated with the exportability of kernel state. 3. Related work The V++ Cache Kernel [3] supports loading and unloading threads, address spaces, and kernels between the Cache Kernel and special user process application kernels.
Reference: [6] <author> B. Ford, M. Hibler, and F. P. </author> <title> Members. Fluke: Flexible kernel Environment (draft documents). </title> <institution> University of Utah. </institution> <note> Postscript and html available under http://www.cs.utah.edu/-projects/flux/fluke/html/, 1996. </note>
Reference-contexts: This process is termed pickling. The ability to import and export kernel state is not a requirement unique to checkpointing. Process migration and distributed memory systems also must be capable of manipulating kernel state. 2. Completely Exportable and Settable Kernel State The Fluke microkernel architecture <ref> [6] </ref> provides nine kernel supported object types, or flobs, which are needed for memory, synchronization, communication, and control. Flobs encapsulate all user-visible kernel state in well defined objects. For example, a thread encapsulates the flow of control in an address space.
Reference: [7] <author> B. A. Kingsbury and J. T. Kline. </author> <title> Job and Process Recovery in a UNIX-based Operating System. </title> <booktitle> In Proc. of the Winter 1991 USENIX Conference, </booktitle> <pages> pages 355-364, </pages> <year> 1989. </year>
Reference-contexts: In Fluke, checkpointing is a regular application, and runs only when needed. These systems do more for fault tolerance than our current checkpointer, with which we have not yet demonstrated whole-system persistence. However, our system provides more flexibility. Cray Research's UNICOS <ref> [7] </ref> can checkpoint processes and related collections of processesthe majority of check-pointers for single machines can checkpoint only a single process image. 4. Design of the Fluke Checkpointer The Fluke checkpointer is, in Fluke-ese, a nester. It controls the environment and resources of its child.
Reference: [8] <author> C. Landau. </author> <title> The checkpoint mechanism in KeyKOS. </title> <booktitle> In Proc. Second International Workshop on Object Orientation in Operating Systems, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: Most of them require re-linking with the target application in order to intercept appropriate system calls [11], or use shared libraries. Kernel state is inferred from calls to and results of kernel system calls. KeyKOS <ref> [8] </ref> and L3 [9] have transparent multi-process checkpointing, but it is an integral part of both kernels, which makes extracting kernel state simpler. In Fluke, checkpointing is a regular application, and runs only when needed.
Reference: [9] <author> J. Liedtke. </author> <title> Improving IPC by kernel design. </title> <booktitle> In Proc. of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <address> Asheville, NC, </address> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Most of them require re-linking with the target application in order to intercept appropriate system calls [11], or use shared libraries. Kernel state is inferred from calls to and results of kernel system calls. KeyKOS [8] and L3 <ref> [9] </ref> have transparent multi-process checkpointing, but it is an integral part of both kernels, which makes extracting kernel state simpler. In Fluke, checkpointing is a regular application, and runs only when needed.
Reference: [10] <author> D. S. Milojicic, W. Zint, A. Dangel, and P. Giese. </author> <title> Task mi gration on the top of the Mach microkernel. </title> <booktitle> In Proc. of the Third USENIX Mach Symposium, </booktitle> <pages> pages 273-289, </pages> <address> Santa Fe, NM, </address> <month> Apr. </month> <year> 1993. </year>
Reference-contexts: To our knowledge there isn't any other work on systematically exportable (and importable) kernel state. There is indirect evidence that not having systematically exportable kernel state makes checkpointing difficult. When others implemented support for task migration (which also needs to acquire relevant kernel state), on Mach 3.0 <ref> [10] </ref> to migrate a thread they effectively cleared all kernel thread state with a thread abort (), so that when the a new thread is created it has equivalent kernel state (none).
Reference: [11] <author> J. S. Plank, M. Beck, G. Kingsley, and K. Li. Libckpt: </author> <title> Trans parent checkpointing under UNIX. </title> <booktitle> In Proc. of the Winter 1995 USENIX Technical Conference, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: Since thread abort () is not a transparent operation, but can impact IPC state, the Mach 3.0 task migration is not guaranteed to function correctly in all situations. User-level checkpointers have been implemented in a variety of operating systems with varying levels of service and transparency <ref> [2, 4, 11] </ref>. Most of them require re-linking with the target application in order to intercept appropriate system calls [11], or use shared libraries. Kernel state is inferred from calls to and results of kernel system calls. <p> User-level checkpointers have been implemented in a variety of operating systems with varying levels of service and transparency [2, 4, 11]. Most of them require re-linking with the target application in order to intercept appropriate system calls <ref> [11] </ref>, or use shared libraries. Kernel state is inferred from calls to and results of kernel system calls. KeyKOS [8] and L3 [9] have transparent multi-process checkpointing, but it is an integral part of both kernels, which makes extracting kernel state simpler. <p> In a second pass the pickled flob state is injected, and the inter-object references are restored. There is a lot of room for improvement in the policy our checkpointer implements. There are well known optimizations <ref> [4, 11] </ref> which are orthogonal to the use of exportable kernel state; we plan to integrate several of these features into our checkpointer in the future. 5.
References-found: 11

