URL: ftp://ftp.csd.uu.se/pub/papers/reports/0046.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: JONAS@AIDA.CSD.UU.SE, HAKANM@AIDA.CSD.UU.SE  
Phone: +46-18-18 25 00  
Title: Parallel Unification Algorithm  
Author: Jonas Barklund and H-akan Millroth UPMAIL 
Address: Box 520, S-751 20 Uppsala, Sweden  
Affiliation: Computing Science Dept., Uppsala University  
Note: A  Electronic mail:  
Abstract: UPMAIL Technical Report No. 46 April 1, 1989 ISSN 1100-0686 ABSTRACT We define an abstract unification algorithm which can be (and has been) implemented on a parallel Single-Instruction Multiple-Data (SIMD) computer. We proceed to suggest an actual representation for the unification problem and a realization of the algorithm. The representation is based on Robinson's representation for sequential unification but where each processing element represents one term. We show how to modify the realization of the algorithm to speed up unification of lists. In some situations unification of two lists can be done in O(log n) time. The algorithm has been implemented on a Connection Machine and is intended for parallel logic programming languages. The research reported herein was partially supported by the Swedish Board for Technical Development (STU). 
Abstract-found: 1
Intro-found: 1
Reference: <author> Dwork, C., P. C. Kanellakis, and J. C. Mitchell, </author> <title> "On the Sequential Nature of Unification," </title> <journal> Journal of Logic Programming 1 (1984): </journal> <pages> 35-50. </pages>
Reference-contexts: COMPLEXITY OF THE ALGORITHM It is obvious that the algorithm uses O (n) processors for a unification problem with n terms. We are of course aware that unification is linear in the worst case <ref> (Dwork et al., 1984) </ref> but also that there are special cases when better time complexity can be achieved (Kanellakis, 1988). For example, the realization of our algorithm with the log-list modification can unify a list of n distinct variables with a list of n constants in O (log n) steps.
Reference: <author> Hillis, W. D., </author> <title> The Connection Machine (Cambridge: </title> <publisher> MIT Press, </publisher> <year> 1985). </year>
Reference-contexts: The advent of parallel computers has changed the picture. Implementing sequential languages on parallel computers requires constraining the parallelism of the machine to simulate the semantics of the sequential language. Massively parallel SIMD computers, such as the Connection Machine* <ref> (Hillis, 1985) </ref>, take another approach. On such a machine a sequential language can be implemented on its (sequential) host computer, and the parallelism be achieved when manipulating certain data structures, which are stored in the parallel computer.
Reference: <author> Hillis, W. D., and G. L. Steele, Jr., </author> <title> "Data Parallel Algorithms," </title> <booktitle> Communications of the ACM 29 (December 1986): </booktitle> <pages> 1170-83. </pages>
Reference-contexts: LOGARITHMIC LIST UNIFICATION It is known that many algorithms over lists of length n (or any uniformly recursive term) can be executed in O (log n) steps on a Connection Machine <ref> (Hillis and Steele, 1986) </ref>. They give several examples, e.g., a list matching program. The basic idea is to add a new field chum to the usual head and tail fields of a list cell. <p> However, we have not made precise which unifications can be handled in O (log n) time. 12. RELATED WORK This work was very much inspired by the paper by Hillis and Steele on data parallel algorithms (1986). 11 CM-Lisp <ref> (Steele and Hillis, 1986) </ref> and our approach both aim to create a high-level language where the programmer has little responsibility for uncovering the parallelism, and whose programs can be reasoned about formally.
Reference: <author> Kacsuk, P., and A. Bale, </author> <title> "DAP Prolog: A Set-oriented Approach to Prolog," </title> <journal> Computer Journal 30 (1987): </journal> <pages> 393-403. </pages>
Reference: <author> Kanellakis, P. C., </author> <title> "Logic Programming and Parallel Complexity," Foundations of Deductive Databases and Logic Programming, </title> <editor> ed. J. </editor> <publisher> Minker (Los Altos: Morgan Kaufmann, </publisher> <year> 1988), </year> <pages> 547-85. </pages>
Reference-contexts: We are of course aware that unification is linear in the worst case (Dwork et al., 1984) but also that there are special cases when better time complexity can be achieved <ref> (Kanellakis, 1988) </ref>. For example, the realization of our algorithm with the log-list modification can unify a list of n distinct variables with a list of n constants in O (log n) steps. However, we have not made precise which unifications can be handled in O (log n) time. 12.
Reference: <author> Kowalski, R., </author> <title> Logic for Problem Solving (New York: </title> <publisher> North Holland, </publisher> <year> 1979). </year>
Reference-contexts: Unification and pattern matching is part of many applications in symbolic processing, including expert systems and theorem proving systems. Unification is also an essential part of resolution-based logic programming languages <ref> (Kowalski, 1979) </ref>. These languages have very attractive properties for parallel processing, since programs can be written without any particular sequential or parallel execution model in mind.
Reference: <author> Lassez, J.-L., M. J. Maher, and K. Marriott, </author> <title> "Unification Revisited," Foundations of Deductive Databases and Logic Programming, </title> <editor> ed. J. </editor> <publisher> Minker (Los Altos: Morgan Kaufmann, </publisher> <year> 1988), </year> <pages> 587-625. </pages>
Reference-contexts: 1. INTRODUCTION Unification is a powerful generalization of pattern matching, the purpose of which can be seen as finding the `least' substitution which when applied to two terms makes them identical (Lloyd, 1987), although many other interpretations exist <ref> (Lassez et al., 1988) </ref>. Unification and pattern matching is part of many applications in symbolic processing, including expert systems and theorem proving systems. Unification is also an essential part of resolution-based logic programming languages (Kowalski, 1979).
Reference: <author> Lloyd, J. W., </author> <booktitle> Foundations of Logic Programming, </booktitle> <address> 2nd edition (Berlin: </address> <publisher> Springer-Verlag, </publisher> <year> 1987). </year>
Reference-contexts: 1. INTRODUCTION Unification is a powerful generalization of pattern matching, the purpose of which can be seen as finding the `least' substitution which when applied to two terms makes them identical <ref> (Lloyd, 1987) </ref>, although many other interpretations exist (Lassez et al., 1988). Unification and pattern matching is part of many applications in symbolic processing, including expert systems and theorem proving systems. Unification is also an essential part of resolution-based logic programming languages (Kowalski, 1979).
Reference: <author> Martelli, A., and U. Montanari, </author> <title> "An Efficient Unification Algorithm," </title> <booktitle> ACM TOPLAS 4 (1982): </booktitle> <pages> 258-82. </pages>
Reference-contexts: The diagram in figure 1 may help clarifying the `data flow' between the four steps of each iteration. 2 Multiple variable elimination. This is an extension of variable elimination <ref> (Martelli and Montanari, 1982) </ref>. A set A 0 A i of variable equations is eliminated (unless some equation in A 0 violates the `occur check') and a substitution is formed. <p> A 3 = fa = x; b = G (x; F (d; c))g, 3 = 1 ffi 2 . 3 (B 3 ) = ;, 4 U4. C 3 = ;, U5. A 4 = ;, 4 = 1 ffi 2 ffi 3 . Example 2 <ref> (Martelli and Montanari, 1982) </ref>. Compute a unifying substitution for S = (G (x 2 ) = x 1 ; F (x 1 ; H (x 1 ); x 2 ) = F (G (x 3 ); x 4 ; x 3 )). U1. <p> PARTIAL AND TOTAL CORRECTNESS OF THE ALGORITHM To prove the partial correctness of the algorithm we have to prove that the operations on (A; D) preserve the set of solutions to the system. Correctness of term reduction and variable elimination has been proved <ref> (Martelli and Montanari, 1982) </ref> and proving the correctness of our multiple versions of these should be straightforward. The other operations are concerned with the partition of the equation system into (A; D) and does not affect the partial correctness, as long as no equations are added or removed.
Reference: <author> Nilsson, M., and H. Tanaka, </author> <title> "Cyclic Tree Traversal," </title> <booktitle> Third International Conference on Logic Programming, </booktitle> <volume> LNCS 225, </volume> <editor> ed. E. </editor> <publisher> Shapiro (Berlin: Springer-Verlag, </publisher> <year> 1986), </year> <pages> 593-99. </pages>
Reference: <author> Paterson, M. S., and M. N. Wegman, </author> <title> "Linear Unification," </title> <journal> Journal of Computer and System Sciences 16 (1978): </journal> <pages> 158-67. </pages>
Reference: <author> Robinson, J. A., </author> <title> "Computational Logic: the Unification Computation," </title> <booktitle> Machine Intelligence 6, </booktitle> <editor> ed. B. Meltzer and D. Michie (Edinburgh: </editor> <publisher> Edinburgh University Press, </publisher> <year> 1971), </year> <pages> 63-72. </pages>
Reference-contexts: Set (i; i+1 ) (i + 1; i ffi i ) and return to U2. If the algorithm terminates in steps U1, U3, or U5 then S has no unifier. Otherwise is a unifier of S. Example 1 <ref> (Robinson, 1971) </ref>. Compute a unifying substitution for S = (F (x; G (x; y)) = z; H (z; y) = H (F (a; b); F (d; c))). U1.
Reference: <author> Steele, Jr., G. L., and W. D. Hillis, </author> <title> "Connection Machine Lisp: Fine-Grained Parallel Symbolic Processing," </title> <booktitle> 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <publisher> ed. W. </publisher>
Reference-contexts: LOGARITHMIC LIST UNIFICATION It is known that many algorithms over lists of length n (or any uniformly recursive term) can be executed in O (log n) steps on a Connection Machine <ref> (Hillis and Steele, 1986) </ref>. They give several examples, e.g., a list matching program. The basic idea is to add a new field chum to the usual head and tail fields of a list cell. <p> However, we have not made precise which unifications can be handled in O (log n) time. 12. RELATED WORK This work was very much inspired by the paper by Hillis and Steele on data parallel algorithms (1986). 11 CM-Lisp <ref> (Steele and Hillis, 1986) </ref> and our approach both aim to create a high-level language where the programmer has little responsibility for uncovering the parallelism, and whose programs can be reasoned about formally.
Reference: <editor> L. Scherlis and J. H. </editor> <address> Williams (New York: </address> <publisher> ACM, </publisher> <year> 1986), </year> <pages> 279-97. </pages>
Reference: <author> Warren, D. H. D., </author> <title> "An Abstract Prolog Instruction Set," </title> <type> SRI Technical Note 309 (Menlo Park: </type> <institution> SRI, </institution> <month> October </month> <year> 1983). </year> <month> 13 </month>
Reference-contexts: PARALLEL REALIZATION OF THE ALGORITHM The realization of our algorithm is based on a Robinson's representation of expressions with a few exceptions, noted below. We are of course aware of the further development of representation of expressions since 1971 <ref> (Warren, 1983) </ref>, but all current implementations which we are aware of are elaborations and optimizations of this scheme in one way or another. Furthermore, to utilize the full power of SIMD machines we cannot use too "clever" representations, because we will apply the same instructions to all processors.
References-found: 15

