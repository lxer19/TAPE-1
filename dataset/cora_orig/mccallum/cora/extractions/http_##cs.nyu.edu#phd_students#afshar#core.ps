URL: http://cs.nyu.edu/phd_students/afshar/core.ps
Refering-URL: http://www.cs.nyu.edu/phd_students/afshar/index.html
Root-URL: http://www.cs.nyu.edu
Title: Higher-Order Conditional Synchronization  
Author: by Niki Afshartous 
Note: DRAFT -August 31  
Abstract-found: 0
Intro-found: 1
Reference: [Agh86] <author> Gul Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Actor model (non-orthogonal). Languages in the non-orthogonal category sometimes integrate concurrency with objects by providing active objects. The foundation for active objects is largely due to the Actor [Hew77], <ref> [Agh86] </ref> model of computation. We therefore feel it its appropriate to present a brief overview of Actors before continuing into the non-orthogonal category. The Actor approach is to view each object as a function of incoming communications. Actors are autonomous components of a computing system that communicate via asynchronous message-passing.
Reference: [Agh90] <author> Gul Agha. </author> <title> Concurrent object-oriented programming. </title> <journal> Communications of the ACM, </journal> <volume> 33(9):125 141, </volume> <month> September </month> <year> 1990. </year>
Reference-contexts: The change in behavior could constitute a simple change of state variables, or the actual code body (method) of the actor may be modited. The set of actor primitives, although simple, can form the basis upon which to build higher level abstractions and concurrent programming paradigms. Agha <ref> [Agh90] </ref> draws comparisons between actor primitives and their sequential counterparts. For example, the actor create primitive is to concurrent programming what the detnition of the lambda abstraction is to sequential programming. The send to primitive is the asynchronous analog of function application. 1.2.3. Ada95 (non-orthogonal ) non-uniform).
Reference: [AJLR96] <author> Wikstrom C. Armstrong J. L., Williams M. C. and Virding S. R. </author> <title> Concurrent Programming in Erlang. </title> <booktitle> Prentice-Hall, 2nd edition, </booktitle> <year> 1996. </year>
Reference-contexts: Concurrent Clean [AP95] is another purely functional language which is also based on monadic operations. Concurrent Clean has processes which communicate via either synchronous or asynchronous message-passing. 1.3.4. Erlang. The concurrent functional language Erlang <ref> [AJLR96] </ref> [Wik96] was initiated in the late 1980's at Ericsson's Computer Science Lab for the development of telecom applications within Ericsson. Erlang is a dynamically typed language although 1.4. CONCURRENT CONSTRAINT LANGUAGES 39 recently a type system has been designed for Erlang [MW97]. <p> The function spawn creates a new concurrent process to perform an action. The message-passing operations are send (intx !) and receive (which uses pattern-matching). Channels are not provided since the sender specites the process ID of the receiver. We use the example in Figures 1.3.4 from <ref> [AJLR96] </ref> to illustrate the concurrent facilities of Erlang.
Reference: [AMT94] <author> Andrew W. Appel, James S. Mattson, and David R. Tarditi. </author> <title> A lexical analyzer generator for Standard ML.version 1.6.0. </title> <month> October </month> <year> 1994. </year>
Reference-contexts: The implementation consists of a parser which utilizes sml-lex <ref> [AMT94] </ref> and sml-yacc [TA94], a static analysis and translation module which utilizes the sml basis library, and a run-time system module which extends CML with support for FCS. The architecture diagram (Figure 6.0.1) illustrates a source-to-source transformation and a run-time system consisting of CML extended for FCS loaded into SML/NJ.
Reference: [AP89] <author> R Nikhil Arvind and K Pingali. </author> <title> I-structures data structues for parallel computing. </title> <journal> TOPLAS, </journal> <volume> 11:598632, </volume> <year> 1989. </year>
Reference-contexts: mvar val mPut : ('a mvar * 'a) -&gt; unit val mTake : 'a mvar -&gt; 'a val mTakeEvt : 'a mvar -&gt; 'a event val mGet : 'a mvar -&gt; 'a val mGetEvt : 'a mvar -&gt; 'a event the events corresponding to channel communication, CML also has Id-style <ref> [AP89] </ref> synchronous variables called M-variables whose operations are shown in Figure 1.3.2. An M-variable may be created by calling mVar or by calling mVarInit to store an initial value in the M-variable. <p> Synchronization between concurrent processes is based on the MVar which integrates previous work on mutable structures [LJ96] and the I-structures and M-structures of the dataow language Id <ref> [AP89] </ref>. Mvar's are similar to the CML M-variable.
Reference: [AP95] <author> P. Achten and R. Plasmeijer. </author> <title> Concurrent interactive processes in a pure functional language. </title> <booktitle> In Proc. of Computing Science in the Netherlands (CSN '95), </booktitle> <pages> pages 1021, </pages> <year> 1995. </year>
Reference-contexts: We note that if putMVar on a full MVar simply blocked the calling process (as opposed to generating an error) then one MVar would suce as a solution to the one-slot bounded buer since the second MVar would be unnecessary. Concurrent Clean <ref> [AP95] </ref> is another purely functional language which is also based on monadic operations. Concurrent Clean has processes which communicate via either synchronous or asynchronous message-passing. 1.3.4. Erlang.
Reference: [Bac86] <author> Muarice J. Bach. </author> <title> The Design of the Unix Operating System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Concurrency Support for expressing concurrency (the potential to execute separate tasks in parallel) previously existed solely in the operating systems (OS) domain. At the OS level concurrency was only accessible to the programmer via system calls like the Unix <ref> [Bac86] </ref> fork routine. Later, support for concurrency appeared at the programming language level. Pascal Plus [Per87] incorporated monitors, Modula-2 [Wir83] supported co-routines, and Ada [Bar89] introduced the task as a unit of concurrency.
Reference: [Bal95] <author> Henri E. Bal. </author> <title> Comparing data sychronization in Ada 95 and Orca. </title> <journal> ACM Ada Letters, </journal> <volume> 15(1):50 63, </volume> <month> Jan/Feb </month> <year> 1995. </year>
Reference-contexts: Communication/synchronization in concurrent object-oriented languages. More recently Ada95 and Orca have introduced conditional synchronization as a mechanism that uses boolean conditions to control synchronization. The event of a condition becoming true enables waiting processes to proceed. Figure 1.2.14 shows an example from <ref> [Bal95] </ref> that was used to compare the synchronization facilities of the two languages. The left column is Orca code and the right column is Ada95 code. Both examples implement a shared counter abstraction whose operations may be invoked concurrently.
Reference: [Bar84] <author> H. P. Barendregt. </author> <title> The Lambda Calculus, </title> <booktitle> volume 103 of Studies In Logic And The Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <year> 1984. </year>
Reference-contexts: However we survey 1.3. CONCURRENT FUNCTIONAL LANGUAGES 33 a selection of concurrent functional languages in a separate section due to their distinctive properties relative to COOL's. There is considerable variety in the characteristics of functional languages (FL's) however the basis is Church's -calculus <ref> [Bar84] </ref> which is a calculus of functions and computation. Functional languages also have higher-level constructs such as pattern-matching and facilitate the use of recursion by performing optimizations.
Reference: [Bar89] <author> J. G. P. Barnes. </author> <title> Programming in Ada. </title> <publisher> Addison-Wesley, 3rd edition, </publisher> <year> 1989. </year>
Reference-contexts: At the OS level concurrency was only accessible to the programmer via system calls like the Unix [Bac86] fork routine. Later, support for concurrency appeared at the programming language level. Pascal Plus [Per87] incorporated monitors, Modula-2 [Wir83] supported co-routines, and Ada <ref> [Bar89] </ref> introduced the task as a unit of concurrency. There were several motivations driving this trend pertaining to the benetts derived from incorporating concurrency: * improved performance concurrent programs can exploit the inherent parallelism of multi-processors and distributed systems. 7 8 1.
Reference: [Bar96] <author> John Barnes. </author> <title> Programming in Ada 95. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: If there are tasks queued on barriers then the conditions are re-evaluated every time a task exits a procedure or entry. To illustrate protected objects we examine two examples from <ref> [Bar96] </ref>. Figure 1.2.5 is a solution to the readers/writers problem. Since the read operation has no side-eects it is written as a function 1.2.
Reference: [BB90] <author> G. Berry and G. Boudol. </author> <title> The chemical abstract machine. </title> <booktitle> In Principles of Programming Languages, </booktitle> <pages> pages 8194. </pages> <publisher> ACM, </publisher> <year> 1990. </year>
Reference-contexts: Concurrent evaluation . As in semantics of cv , concurrent evaluation is detned as a transition system between tnite sets of process states. This is based on the style of the Chemical Abstract Machine <ref> [BB90] </ref>. The concurrent evaluation relation =) extends 7! to processes, and adds additional rules for process creation, channel creation 60 3.
Reference: [BC93] <author> Frederic Benhammou and Alain Colmerauer. </author> <title> Constraint Logic Programming Selected Research. Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Unlike the COOL languages, conditional synchronization has yet to be explored in the context of a concurrent function language. 1.4. Concurrent constraint languages Vijay Saraswat's thesis work [Sar93] was the design of concurrent-constraint programming CCP which united the areas of concurrent logic programming [Sha86] [Sha87] and constraint logic languages <ref> [BC93] </ref> [JL87]. 40 1.
Reference: [BDG + 91] <author> A. Beguelin, J. J. Dongarra, A. Geist, R. Mancheck, and V. Sunderam. </author> <title> A users' guide to PVM (parallel virtual machine). </title> <type> Technical Report ORNL/TM-11826, </type> <institution> Oak Ridge National Laboratory, </institution> <year> 1991. </year> <note> 137 138 BIBLIOGRAPHY </note>
Reference-contexts: In addition to languages supporting concurrency, there are a plethora of distributed systems that allow programmers to exploit the inherent parallelism of networks. Most provide libraries on top of existing languages (Linda [Gel85], and PVM <ref> [BDG + 91] </ref>). However writing and debugging concurrent programs is not a trivial endeavor. The concurrent programmer must deal with potential problems such as deadlock and race conditions that are not present in sequential programming.
Reference: [BF96] <author> Paolo Di Blasio and Kathleen Fisher. </author> <title> A calculus for concurent objects. </title> <booktitle> In Concurrency Theory CONCUR '96, volume 1119 of LNCS, </booktitle> <pages> pages 655670, </pages> <year> 1996. </year>
Reference-contexts: In addition, blocking operations should be prevented during evaluation of the synchronization condition. To allow otherwise would result in ambiguous semantics. To enforce these restrictions we identify eects ' as being either pure or impure eects as in <ref> [BF96] </ref>. Di Blasio and Fisher detne an impure eect ' as containing a write eect for the purpose of disallowing write eects in their synchronization guards. We take this detnition a step further by incorporating block eects and any other eect which generates a new concurrent contguration in the 3.2.
Reference: [BKT88] <author> Henri Bal, M. Frans Kaashock, and Andrew Tanenbaum. Orca: </author> <title> A language for parallel programming of distributed systems. In Usenix/SERC Workshop on Experiences with Building Distributed and Multiprocessor Systems. </title> <publisher> Vrije University, </publisher> <address> Netherlands, </address> <year> 1988. </year>
Reference-contexts: The automatic wrapping of the variables I and J is a property of the type Index. 1.2.4. Orca (non-orthogonal ) uniform ) non-integrated). Orca <ref> [BKT88] </ref> supports concurrent programming by processes that communicate via shared objects. The language goals were to make it simple, expressive, and ecient with clean semantics. Logically shared memory is supported via a reliable broadcast protocol.
Reference: [Bla85] <author> A. Black. </author> <title> Supporting distributed applications: Experience with eden. </title> <booktitle> In 10th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 181193, </pages> <month> [12] </month> <year> 1985. </year>
Reference-contexts: This is in contrast to other languages which provide either small, local data objects ([SmallTalk13] and [CLU22]) or systems that have large active objects ([Hydra30] and [Clouds1]). Distributed systems such as Argus [Lis88] or Eden <ref> [Bla85] </ref> have both kinds of objects and a separate object detnition mechanism for each. The rationale behind the single object model is that although multiple implementations are important for eciency, this should not be visible to the programmer. An Emerald object consists of: 1. A unique network-wide name. 2.
Reference: [D.C89] <author> Matthews D.C.J. </author> <title> Processes for Poly and ML. </title> <type> Technical Report 16, </type> <institution> University of Cambridge, </institution> <year> 1989. </year>
Reference-contexts: CML also has I-variables which are similar to M-variables except that I-variables encapsulate wright-once memory locations. An exception is raised on successive attempts to put a value in the I-variable. In addition to CML there have been several other attempts at integrating message-passing and ML [KPT96] [Ram90] <ref> [D.C89] </ref>. 1.3.2. Synchrons. The synchron [Tur96] is a trst-class barrier synchronization mechanism. With the synchron the number of threads participating in the barrier is not txed as additional threads may subsequently join the barrier group.
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1982. </year>
Reference-contexts: S then ranges over all substitutions. The type variables ff are used for type generalization (polymorphism): ff 2 TyVar We use FTV (t ) to denote the free type variables of t . Type schemes <ref> [DM82] </ref> can have quantited type variables: ::= 8ff 1 ; :::; ff n :t The variables ff 1 ; :::; ff n are bound in and are denoted by bv (). Substitutions map type 3.2.
Reference: [EGLT76] <author> K.P. Eswaran, J.N. Gray, R.A. Lorie, </author> <title> and I.L. Traiger. The notions of consistency and predicate locks in a database system. </title> <journal> CACM, </journal> <volume> 19(11):624633, </volume> <month> Nov </month> <year> 1976. </year>
Reference-contexts: Orca provides two types of synchronization: mutual exclusion and conditional synchronization. Mutual exclusion is performed implicitly by executing all object operations atomically. Conceptually an operation locks the entire object so that other invocations of operations cannot interfere. More precisely, serializability <ref> [EGLT76] </ref> of operations is guaranteed. An implementation of the serializability model is not restricted to executing each operation one by one. To allow for greater concurrency, operations which do not conict may be run simultaneously. 22 1. <p> Similarly database transactions do not have to be executed one after another as long as the resulting execution satistes the serializable property that transactions appear to execute in some serial order <ref> [EGLT76] </ref>. Therefore implementations may optimize performance as long as the correct semantic properties are guaranteed. 64 3.
Reference: [FF86] <author> Mattias Felleisen and Daniel Friedman. </author> <title> Formal Description of Programming Concepts III, chapter Control operators, the SECD-machine, and the calculus. </title> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference-contexts: We add to this list condEvt and the store operations: assignment, dereference, and allocation (set,get, and new). The style of the dynamic semantics is based on Felleisen and Friedman's notion of an evaluation context <ref> [FF86] </ref> which uses term-rewriting and small-step reductions. This method has been shown to simplify type soundness proofs and provides a framework amenable to language extensions [WF92]. The source language grammar is shown in Figure 3.1.1.
Reference: [Fuc96] <author> Matthew Fuchs. Dreme. </author> <type> PhD thesis, </type> <address> New York University, </address> <year> 1996. </year>
Reference-contexts: INTRODUCTION * improved response of interactive applications it has been shown that designing concurrent graphical-user interfaces (GUI's) improves response time <ref> [Fuc96] </ref> [GR93]. This is in contrast to the traditional GUI which is based on a sequential event model. * expressiveness certain application's have inherent concurrent structure and thus are more easily implemented as concurrent programs Some examples are animation and client/server applications.
Reference: [GA89] <author> Allan Gottlieb and George S Almasi. </author> <title> Highly Parallel Computing, chapter 2. </title> <publisher> Ben-jamin/Cummings Publishing, </publisher> <year> 1989. </year>
Reference-contexts: makeBarrier n = let val counter = new 0 val incCh = channel () fun inc () = (recv incCh; set (counter,get counter + 1); inc ()) val barrierEvt = condEvt (fn () =&gt; get counter = n) in spawn inc; wrap (sendEvt (incCh,()), fn ()=&gt; sync barrierEvt) end sorting <ref> [GA89] </ref>. The argument n to function makeBarrier in Figure 2.1.3 corresponds to the number of threads participating. Each thread signals that it has reached the barrier applying sync to the event returned by makeBarrier. An auxiliary thread is spawned to coordinate increments to the counter reference variable.
Reference: [GDM87] <author> Lucassen J M Giord D, Jouvelot P and Sheldon M. </author> <title> Fx-87 reference manual. </title> <type> Technical Report TR-407, </type> <institution> MIT-LCS, </institution> <year> 1987. </year>
Reference-contexts: One product of this research was the The FX language <ref> [GDM87] </ref> which applies its eect system to perform parallel code generation and stack allocation of temporary data structures. Talpin and Jouvelot subsequently designed an eect type system for the core of ML [TJ92] . They then applied their framework to make the type generalization associated with let 70 3.
Reference: [Gel85] <author> David Gelernter. </author> <title> Generative communication in Linda. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1):80112, </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: In addition to languages supporting concurrency, there are a plethora of distributed systems that allow programmers to exploit the inherent parallelism of networks. Most provide libraries on top of existing languages (Linda <ref> [Gel85] </ref>, and PVM [BDG + 91]). However writing and debugging concurrent programs is not a trivial endeavor. The concurrent programmer must deal with potential problems such as deadlock and race conditions that are not present in sequential programming.
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specitcation. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <month> June </month> <year> 1996. </year>
Reference-contexts: This is in contrast to the traditional GUI which is based on a sequential event model. * expressiveness certain application's have inherent concurrent structure and thus are more easily implemented as concurrent programs Some examples are animation and client/server applications. For instance, Java <ref> [GJS96] </ref> programmers frequently use the technique of running each animated object in a separate thread. Another factor in the trend to support concurrency has been the increasing pervasiveness of multiprocessors and network clusters. <p> Our conditional event incorporates broadcast synchronization which complements the existing CML synchronization facilities associated with channel communication, M-variables, and I-variables. In this case either a synchronous rendezvous between two threads or FCS. With the introduction of concurrency into mainstream languages like Java <ref> [GJS96] </ref> concurrency has manifested itself as being useful for a broad class of application development. Yet the basis for synchronization in Java, the monitor [Hoa74], is not well-integrated with the type system and consequently does not aid the programmer suciently in building concurrent-access abstractions.
Reference: [GMP89] <author> A Giacalone, P Mishra, and S Prasad. </author> <title> Facile: A symmetric integration of concurrent and functional programming. </title> <journal> In International Journal of Parallel Programming, </journal> <volume> volume 18. </volume> <year> 1989. </year>
Reference-contexts: Recursion. We provide no built-in mechanism for recursion since cv has none due to the fact that the call-by-value Y v combinator can be implemented using processes and channels. The CML example in Figure 3.1.4 by Reppy was adopted from <ref> [GMP89] </ref> and uses only the what is provided by cv . The unrolling normally associated with the Y v combinator is done by sending a copy of the function across a channel. In Figure 3.1.4 a copy of the function g is sent across channel a for the next iteration.
Reference: [Gor95] <author> Andrew D. Gordon. </author> <title> Bisimilarity as a theory of functional programming. </title> <month> June </month> <year> 1995. </year>
Reference-contexts: j S is a simulationg We also detne [ ] as [S] = f (a; b) j whenever a ! a 0 there exists b 0 such that b ! b 0 and a 0 S b 0 g Our proof technique is based on the following principle called strong-coinduction <ref> [Gor95] </ref>. Let be the greatest txed-point of monotone F then X if X F (X [ -) We are interested in similarity as opposed to bisimilarity since there is only a translation in one direction (source to target). Next we detne consistency for sequential contgurations.
Reference: [GR93] <author> Emden R. Gansner and John H. Reppy. </author> <title> A Multi-threaded Higher-order User Interface Toolkit, </title> <booktitle> volume 1 of Software Trends, </booktitle> <pages> pages 6180. </pages> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference-contexts: INTRODUCTION * improved response of interactive applications it has been shown that designing concurrent graphical-user interfaces (GUI's) improves response time [Fuc96] <ref> [GR93] </ref>. This is in contrast to the traditional GUI which is based on a sequential event model. * expressiveness certain application's have inherent concurrent structure and thus are more easily implemented as concurrent programs Some examples are animation and client/server applications.
Reference: [Hew77] <author> Carl Hewitt. </author> <title> Viewing control structures as patterns of passing messages. </title> <journal> Artitcial Intelligence, </journal> <volume> 8(3), </volume> <month> June </month> <year> 1977. </year>
Reference-contexts: Following the call, the argument object returns to its original site (call-by-visit ) or remains at the remote site (call-by-move). 1.2.2. Actor model (non-orthogonal). Languages in the non-orthogonal category sometimes integrate concurrency with objects by providing active objects. The foundation for active objects is largely due to the Actor <ref> [Hew77] </ref>, [Agh86] model of computation. We therefore feel it its appropriate to present a brief overview of Actors before continuing into the non-orthogonal category. The Actor approach is to view each object as a function of incoming communications.
Reference: [Hoa74] <author> C. A. R. Hoare. </author> <title> Monitors: an operating system structuring concept. </title> <journal> Communications of the ACM, </journal> <note> 17:549557, 1974. BIBLIOGRAPHY 139 </note>
Reference-contexts: The left column is Orca code and the right column is Ada95 code. Both examples implement a shared counter abstraction whose operations may be invoked concurrently. Updates to variables inside the Orca object and the Ada95 protected type are properly synchronized according to the language detnitions. This provides monitor-like <ref> [Hoa74] </ref> functionality. Our focus will be on the AwaitValue operation in the Orca code and the Await_Zero entry in the Ada95 code since this is where the conditional synchronization appears. <p> In this case either a synchronous rendezvous between two threads or FCS. With the introduction of concurrency into mainstream languages like Java [GJS96] concurrency has manifested itself as being useful for a broad class of application development. Yet the basis for synchronization in Java, the monitor <ref> [Hoa74] </ref>, is not well-integrated with the type system and consequently does not aid the programmer suciently in building concurrent-access abstractions. By incorporating trst-class mechanisms like FCS the programming language can facilitate programming with concurrency.
Reference: [Hoa78] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> In Communications of the ACM, </journal> <volume> volume 21, </volume> <pages> pages 666677. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1978. </year>
Reference-contexts: Synchronization is provided by some variation of either message-passing (synchronous or asynchronous), monitors, or the rendezvous. Some languages also provide a select construct to allow a non-deterministic choice among several synchronous operations <ref> [Hoa78] </ref>. These synchronization mechanisms are described as follows. * message-passing (synchronous) After both a sender and a receiver have arrived at their respective synchronization points a message is transmitted from the sender to the receiver and then both processes continue.
Reference: [HS86] <author> R. J. Hindley and J. P. Seldin. </author> <title> Introduction to Combinators and -Calculus. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: This approach involves: * proving subject reduction holds (i.e. that evaluation preserves types) * characterizing answers and stuck expressions * proving stuck expressions are untypable The following lemma is used in the subject reduction theorems. Lemma 4.2.3. (Replacement Lemma - <ref> [HS86] </ref>) If: 1. D is a deduction concluding T E ` C [e 1 ] : t; 2. D 1 is a subdeduction of D concluding T E 0 ` e 1 : t 0 ; 0 3. <p> Then if we cut out D 1 and replace it with D 2 and also substitute occurrences of e 1 for e 2 then the resulting tree still satistes deduction D. The detailed proof in <ref> [HS86] </ref> uses induction on the height of the tree. Subject reduction illustrates that evaluation preserves types.
Reference: [HW87] <author> M. Herlihy and J. Wing. </author> <title> Avalon : Language support for reliable distributed system. </title> <booktitle> In 17th Int. Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 8994. </pages> , <address> Pittsburgh, PA, </address> <month> [7] </month> <year> 1987. </year>
Reference-contexts: In addition improved performance may be achieved by having the compiler perform optimization. For instance, it has been discovered that in the case of integrating transactions and persistence into a language, greater concurrency can be achieved with user detned type-specitc locking as opposed to traditional read/write locking <ref> [HW87] </ref>. Thus, it becomes clear that when new language concepts are well integrated into a programming language there are many benetts.
Reference: [Int95] <author> Intermetrics, Inc. </author> <title> Ada 95 Rationale, </title> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: A rendezvous may proceed when task A invokes the entry of task B and task B has reached the accept statement corresponding to the entry. This is illustrated by an example from <ref> [Int95] </ref> in Figure 1.2.4. The task Buer encapsulates a single value while supporting read and write operations as entries.
Reference: [iTCS96] <editor> Algol-Like Languages (Progress in Theoretical Computer Science. Peter W. O'Hearn R. D. Tennent. </editor> <publisher> Birkhauser, </publisher> <year> 1996. </year>
Reference-contexts: One has to be careful so that dierent evaluations do not result in dierent execution results. Non-strict language may be lazy meaning that arguments are not evaluated until their values are needed inside the function body. This is implemented by associating a parameterless function (called a thunk <ref> [iTCS96] </ref>) with each argument which is evaluated for each use of the corresponding formal parameter inside the function body. As with COOL's, concurrent functional languages integrate a notion of process and some variation of the mechanisms for synchronization/communication. 34 1. INTRODUCTION 1.3.1. Concurrent ML.
Reference: [JG91] <author> Pierre Jouvelot and D. Giord. </author> <title> Algebraic reconstruction of types and eects. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: Static semantics of source In order to enforce certain restrictions within synchronization conditions we incorporate eects into the source static semantics which are based on research done at the MIT Laboratory for Computer Science in the late 1980's [Luc87] <ref> [JG91] </ref> [LG91]. One product of this research was the The FX language [GDM87] which applies its eect system to perform parallel code generation and stack allocation of temporary data structures. Talpin and Jouvelot subsequently designed an eect type system for the core of ML [TJ92] .
Reference: [JGF96] <author> Simon Peyton Jones, Andrew Gordon, and Sigbjorn Finne. </author> <title> Concurrent Haskell. </title> <booktitle> ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1996. </year>
Reference-contexts: The motivation for synchrons was the design of space-ecient algorithms as the modular composition of aggregate data operations. 1.3. CONCURRENT FUNCTIONAL LANGUAGES 37 1.3.3. Concurrent Haskell. Concurrent Haskell <ref> [JGF96] </ref> is a lazy (non-strict) purely functional language in which IO and mutable state operations are based on monads [Wad95]. Monadic operations are viewed as sate transformations which transform the current state of the world into a new state. <p> This operation results in an error if the MVar is already full. The design philosophy was to provide only the MVar as a low-level synchronization mechanism around which higher-level abstraction could be built. Using MVar it is shown in <ref> [JGF96] </ref> how to construct a buered channel, skip channel, and quantity semaphore. The example in Figure 1.3.3 from [JGF96] uses the MVar to implement a one-slot bounded buer. The CVar abstraction encapsulates two MVar's. <p> The design philosophy was to provide only the MVar as a low-level synchronization mechanism around which higher-level abstraction could be built. Using MVar it is shown in <ref> [JGF96] </ref> how to construct a buered channel, skip channel, and quantity semaphore. The example in Figure 1.3.3 from [JGF96] uses the MVar to implement a one-slot bounded buer. The CVar abstraction encapsulates two MVar's. The trst is used to hold the data and the second is used for the consumer to communicate to the producer that the CVar is empty.
Reference: [JL87] <author> Joxan Jaar and Jean-Louis Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In ACM Symposium on Principles of Programming Lanaguages, </booktitle> <pages> pages 111119, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Concurrent constraint languages Vijay Saraswat's thesis work [Sar93] was the design of concurrent-constraint programming CCP which united the areas of concurrent logic programming [Sha86] [Sha87] and constraint logic languages [BC93] <ref> [JL87] </ref>. 40 1.
Reference: [JL96] <author> Richard Jones and Rafael Lins. </author> <title> Garbage Collection : Algorithms for Automatic Dynamic Memory Management. </title> <publisher> John Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: There is considerable variety in the characteristics of functional languages (FL's) however the basis is Church's -calculus [Bar84] which is a calculus of functions and computation. Functional languages also have higher-level constructs such as pattern-matching and facilitate the use of recursion by performing optimizations. Garbage collection <ref> [JL96] </ref> is employed to relieve the programmer from the burden of dynamic memory management and variables are bound to values as opposed to state.
Reference: [JLHB88] <author> Eric Jul, Henry Levy, Norman Hutchinson, and Andrew Black. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1), </volume> <month> Feb </month> <year> 1988. </year>
Reference-contexts: INTRODUCTION In the integrated sub-category, concurrency is expressed by object interaction, whereas in the non-integrated sub-category, another concept such as a process is provided for expressing concurrent activities. The categories and their relationships are illustrated in tgure 1.2.1. 1.2.1. Emerald (Orthogonal). The principle goal of Emerald <ref> [JLHB88] </ref> was to experiment with object mobility in distributed programming.
Reference: [Jor78] <author> Harry Jordan. </author> <title> A special purpose architecture for tnite element analysis. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <pages> pages 263266, </pages> <year> 1978. </year>
Reference-contexts: This kind of guarantee cannot be programmed since it is dependant upon the thread scheduler. Next, we use condEvt to write the function makeBarrier that returns an event to be subsequently used by a group of threads participating in barrier synchronization. The term barrier was coined by Jordan <ref> [Jor78] </ref>. Barriers have been applied in parallel applications such as global atmospheric circulation, the n-body gravitational problem, and parallel 50 2.
Reference: [KPT96] <author> Naoki Kobayashi, Benjamin C. Pierce, and David N. Turner. </author> <title> Linearity and the pi-calculus. </title> <booktitle> In Proceedings of Principles of Programming Languages (POPL'96). ACM, </booktitle> <year> 1996. </year>
Reference-contexts: CML also has I-variables which are similar to M-variables except that I-variables encapsulate wright-once memory locations. An exception is raised on successive attempts to put a value in the I-variable. In addition to CML there have been several other attempts at integrating message-passing and ML <ref> [KPT96] </ref> [Ram90] [D.C89]. 1.3.2. Synchrons. The synchron [Tur96] is a trst-class barrier synchronization mechanism. With the synchron the number of threads participating in the barrier is not txed as additional threads may subsequently join the barrier group.
Reference: [Ler97] <author> Xavier Leroy. </author> <title> The Objective Caml system, documentation and user's guide. </title> <publisher> INRIA, </publisher> <address> 1.07 edition, </address> <year> 1997. </year>
Reference-contexts: Concurrent functional languages Functional languages are no longer disjoint from OOP since there has been much recent work on integrating objects into functional languages <ref> [Ler97] </ref> [RR96]. However we survey 1.3. CONCURRENT FUNCTIONAL LANGUAGES 33 a selection of concurrent functional languages in a separate section due to their distinctive properties relative to COOL's.
Reference: [LG91] <author> J. Lucassen and D. Giord. </author> <title> Polymorphic eect systems. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: Static semantics of source In order to enforce certain restrictions within synchronization conditions we incorporate eects into the source static semantics which are based on research done at the MIT Laboratory for Computer Science in the late 1980's [Luc87] [JG91] <ref> [LG91] </ref>. One product of this research was the The FX language [GDM87] which applies its eect system to perform parallel code generation and stack allocation of temporary data structures. Talpin and Jouvelot subsequently designed an eect type system for the core of ML [TJ92] .
Reference: [Lis88] <author> B. Liskov. </author> <title> Distributed programming in Argus. </title> <journal> Communication of the ACM, </journal> <volume> 31(3):300312, </volume> <month> Mar </month> <year> 1988. </year>
Reference-contexts: This is in contrast to other languages which provide either small, local data objects ([SmallTalk13] and [CLU22]) or systems that have large active objects ([Hydra30] and [Clouds1]). Distributed systems such as Argus <ref> [Lis88] </ref> or Eden [Bla85] have both kinds of objects and a separate object detnition mechanism for each. The rationale behind the single object model is that although multiple implementations are important for eciency, this should not be visible to the programmer. An Emerald object consists of: 1. <p> In a distributed system the method of parameter passing can have serious performance implications. On a remote invocation, access by the remote operation to an argument is likely to cause additional remote invocation. For this reason, systems such as Argus <ref> [Lis88] </ref> have required that arguments to remote calls be passed by value, not by object-reference. Similarly, RPC systems require call-by value since addresses are only valid on a single node. 16 1.
Reference: [LJ96] <editor> J Launchbury and SL Peyton Jones. </editor> <booktitle> I-structures data structues for parallel computing. Lisp and Symbolic Computation, </booktitle> <year> 1996. </year>
Reference-contexts: Processes are created by calling forkIO: forkIO :: IO () -&gt; IO () which takes an action as its argument and performs the action in a new concurrent process. Synchronization between concurrent processes is based on the MVar which integrates previous work on mutable structures <ref> [LJ96] </ref> and the I-structures and M-structures of the dataow language Id [AP89]. Mvar's are similar to the CML M-variable.
Reference: [Luc87] <author> J. M. Lucassen. </author> <title> Types and Eects, towards the integration of functional and imperative programing. </title> <institution> Mit/lcs/tr-408, MIT Laboratory for Computer Science, </institution> <year> 1987. </year> <note> 140 BIBLIOGRAPHY </note>
Reference-contexts: Static semantics of source In order to enforce certain restrictions within synchronization conditions we incorporate eects into the source static semantics which are based on research done at the MIT Laboratory for Computer Science in the late 1980's <ref> [Luc87] </ref> [JG91] [LG91]. One product of this research was the The FX language [GDM87] which applies its eect system to perform parallel code generation and stack allocation of temporary data structures. Talpin and Jouvelot subsequently designed an eect type system for the core of ML [TJ92] .
Reference: [Mey88] <author> B. Meyer. </author> <title> Object-oriented software construction. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Clis, New Jersey, </address> <year> 1988. </year>
Reference-contexts: We conclude by evaluating our language extension based on the above criteria and then suggest some topics for future research. 1.2. Concurrent object-oriented languages During the same time that languages supporting concurrency and distribution have evolved, languages based on the object-oriented paradigm <ref> [Mey88] </ref> have been gaining popularity.
Reference: [Mil89] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: Then following Lemma 5.2.3 we state and prove consistency for sequential and subsequently concurrent contgurations. We also show that the consistency properties can be formulated as satisfying a similarity relation. The following detnitions are from <ref> [Mil89] </ref>. 5.2. CORRECTNESS OF THE TRANSLATION 109 Definition 5.2.1. (Simulation) A relation S Rel is a simulation i a S b implies: whenever a ! a 0 9b 0 such that b ! b 0 and a 0 S b 0 . Let similarity .
Reference: [MW97] <author> Simon Marlow and Philip Wadler. </author> <title> A practical subtyping system for Erlang. </title> <booktitle> In 2'nd ACM International Conference on Functional Programming, </booktitle> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Erlang. The concurrent functional language Erlang [AJLR96] [Wik96] was initiated in the late 1980's at Ericsson's Computer Science Lab for the development of telecom applications within Ericsson. Erlang is a dynamically typed language although 1.4. CONCURRENT CONSTRAINT LANGUAGES 39 recently a type system has been designed for Erlang <ref> [MW97] </ref>. Multiprocessor and distributed implementations of Erlang are also available [Wik86] . Erlang is distinct among functional languages in that it has been used commercially in large scale applications. Concurrency is supported by processes and message-passing for communication and synchronization.
Reference: [Nie92] <author> Oscar Nierstrasz. </author> <title> Advances in Object-Oriented Software Engineering, chapter A Tour of Hybrid </title>
Reference-contexts: CONCURRENT OBJECT-ORIENTED LANGUAGES 25 The cost for these advantages is the extra overhead performed by the run-time system, and that it is more cumbersome to hook together two dynamic data structures. 1.2.5. Hybrid (non-orthogonal ) uniform ) integrated). Hybrid <ref> [Nie92] </ref> was developed at the University of Geneva and integrates a polymorphic type system, con-currency, persistence, and distribution. The main innovation is the concurrency model, which provides for a uniform message-passing paradigm for communication. Every object in Hybrid is an instance of an object type.
References-found: 52

