URL: http://www-icparc.doc.ic.ac.uk/papers/constraint_logic_programming_for_schedul.ps
Refering-URL: http://www-icparc.doc.ic.ac.uk/papers.html
Root-URL: 
Title: Constraint Logic Programming for Scheduling and Planning  
Author: Jonathan Lever, Mark Wallace and Barry Richards 
Date: January 1995.  
Note: Appears in BT Technology Journal Vol. 13 No.1,  
Address: London  
Affiliation: IC-Parc, Imperial College,  
Pubnum: SW7 2AZ  
Abstract: This paper provides an introduction to Finite-domain Constraint Logic Programming (CLP) and its application to problems in scheduling and planning. We cover the fundamentals of CLP and indicate recent developments and trends in the field. Some current limitations are identified, and areas of research that may contribute to addressing these limitations are suggested.
Abstract-found: 1
Intro-found: 1
Reference: [CDNT92] <author> T.-L. Chew, J.-M. David, L. Nguyen, and Y. Tourbier. </author> <title> Le car sequencing problem revisite: </title> <institution> analyse d'une utilisation du recuit simule. </institution> <type> Technical report, </type> <institution> RENAULT, Service Systemes Experts, </institution> <year> 1992. </year>
Reference-contexts: For many hard search problems, such as the travelling salesman problem, assembly-line sequencing, and scheduling, approximation algorithms have been used very successfully <ref> [Muh92, CDNT92, MJPL92] </ref>. 7 Such methods are often viewed as an alternative to constrained search. In fact constraints can be used with approximation algorithms in exactly the same way they are used with enumeration algorithms: the choice of approximation or enumeration is independent of the use of constraints.
Reference: [CF93] <author> A. Chamard and A. Fischler. </author> <title> Applying CHIP to a complex scheduling problem. </title> <type> Technical Report D3.1.2, </type> <institution> Dassault Aviation, </institution> <year> 1993. </year> <note> CHIC report. </note>
Reference-contexts: is expressed as a rule with two clauses, one for each constraint. 2 contention (Task1,Task2) start (Task1) + duration (Task1) &lt; start (Task2) contention (Task1,Task2) start (Task2) + duration (Task2) &lt; start (Task1) However, for many problems such an approach introduces too many choice points and yields an unsatisfactory performance <ref> [CF93] </ref>. Disjunctive constraints can be used completely passively, by simply checking them for consistency. In this case the constraint is not used to prune the domains of any problem variables, it merely causes failure if, at any point in the search, all the disjuncts are inconsistent. <p> When only one consistent disjunct remains, it is imposed as an active constraint, and can be used for pruning the domains of the remaining variables. The simplest way to achieve this behaviour is to introduce an auxiliary variable with a binary domain <ref> [CF93] </ref>. In fact it has proved effective to include the auxiliary variable in the labelling routine. This gives the effect of setting the constraint at a choice point as above, but in this case the labelling routine can select the variable for labelling at the best point in the search. <p> In [DSVH90] various ways of using disjunctive constraints for a scheduling problem were investigated. The constraints were used for lookahead a powerful form of propagation for forward checking which corresponds approximately to the weak form of propagation proposed by <ref> [CF93] </ref> and as choice points. For the particular scheduling application at hand, the use of disjunctive constraints as choice points proved to be most efficient! Generalised propagation [LW93] allows the disjunctive constraints to be expressed as ordinary Prolog rules (as in the first example above).
Reference: [CL94] <author> Y. Caseau and F. Laburthe. </author> <title> Improved CLP scheduling with task intervals. </title> <booktitle> In Eleventh International Conference on Logic Programming (ICLP'94). </booktitle> <publisher> M.I.T Press, </publisher> <year> 1994. </year> <month> 9 </month>
Reference-contexts: Another likely source of techniques to increase the scalability of CLP solutions is Operations Research (OR) algorithms. A recent paper has reported very successful results obtained in the context of the 10x10 job-shop scheduling problem through the incorporation of OR techniques with CLP <ref> [CL94] </ref>. 4.3 Constraint Logic Programming for Planning So far, the discussion has focussed on scheduling problems.
Reference: [Col90] <author> A. Colmerauer. </author> <title> An introduction to Prolog III. </title> <journal> CACM, </journal> <volume> 33 </volume> <pages> 69-90, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Constraint Logic Programming languages are extensions of logic programming systems such as PROLOG with constraint-handling facilities. There have been two lines of development: systems such as the CLP (X) scheme [JL87] and PROLOG III <ref> [Col90] </ref> in which constraints are handled by specific black-box solvers, and systems such as CHIP [DVHS + 88] and cc (FD) [VSD92], in which constraints over finite-domain variables are handled through constraint propagation.
Reference: [dK86] <author> J. de Kleer. </author> <title> An assumption-based TMS. </title> <journal> Artificial Intelligence, </journal> <volume> 28 </volume> <pages> 127-162, </pages> <year> 1986. </year>
Reference-contexts: The idea is based on the concept of nogood environments introduced by Assumption-Based Truth Maintenance Systems <ref> [dK86] </ref>. The approach is complementary to constraint propagation: propagation is performed before and during search, whilst nogoods are extracted after the search has failed. Both propagation and nogoods are used to prune the search tree subsequently.
Reference: [DSVH88] <author> M. Dincbas, H. Simonis, and P. Van Hentenryck. </author> <title> Solving a cutting-stock problem in constraint programming. </title> <booktitle> In Fifth International Conference on Logic Programming (ICLP'88), </booktitle> <address> Seattle, USA, August 1988. </address> <publisher> M.I.T Press. </publisher>
Reference-contexts: It is desirable to avoid repeated generation of isomorphic configurations during the search for an optimal solution, as the size of the search space will then be drastically reduced. A problem which had been solved with CHIP <ref> [DSVH88] </ref> in which such configurations occur was solved even more efficiently by a new approach which used dynamically generated nogood assertions to prune branches of the search tree according to this criteria [MMST92]. The idea is based on the concept of nogood environments introduced by Assumption-Based Truth Maintenance Systems [dK86].
Reference: [DSVH90] <author> M. Dincbas, H. Simonis, and P. Van Hentenryck. </author> <title> Solving large combinatorial problems in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 8, </volume> <year> 1990. </year>
Reference-contexts: Either one task must run first imposing one constraint on the final schedule or the other runs first in which case a different constraint must be imposed. Such disjunctive constraints have been dealt with in CHIP by simply choosing one disjunct during the search process <ref> [DSVH90] </ref>. <p> The amount of propagation invested in a disjunctive constraint has a significant effect on overall performance. In <ref> [DSVH90] </ref> various ways of using disjunctive constraints for a scheduling problem were investigated. The constraints were used for lookahead a powerful form of propagation for forward checking which corresponds approximately to the weak form of propagation proposed by [CF93] and as choice points.
Reference: [DVHS + 88] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Berthier. </author> <title> The constraint logic programming language chip. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems (FGCS'88), </booktitle> <pages> pages 693-702, </pages> <address> Tokyo, Japan, </address> <month> December </month> <year> 1988. </year>
Reference-contexts: There have been two lines of development: systems such as the CLP (X) scheme [JL87] and PROLOG III [Col90] in which constraints are handled by specific black-box solvers, and systems such as CHIP <ref> [DVHS + 88] </ref> and cc (FD) [VSD92], in which constraints over finite-domain variables are handled through constraint propagation.
Reference: [Fru92] <author> T. Fruhwirth. </author> <title> Constraint simplification rules. </title> <type> Technical Report ECRC-92-18, </type> <institution> ECRC, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: Recently, new techniques such as Generalised Propagation [LW93] and Constraint Handling Rules <ref> [Fru92] </ref> have been developed, providing propagation in a more general context than finite-domains and allowing constraint-solving to be applied to user-defined predicates rather than only to a restricted set of system-defined primitives.
Reference: [FSB89] <author> M.S. Fox, N. Sadeh, and C. Baycan. </author> <title> Constrained heuristic search. </title> <booktitle> In Proc. IJCAI, </booktitle> <pages> pages 309-316, </pages> <year> 1989. </year>
Reference-contexts: The other parts of the schedule can then be fitted around the bottlenecks. This is often known as the "first fail" principle. To identify bottlenecks the concept of variable "tightness" was introduced in <ref> [FSB89] </ref>. A tight variable is one that eliminates lots of possible solutions. Specifically "the tightness of a variable is the probability that an assignment consistent with all the problem constraints that do not involve the variable does not result in a solution".
Reference: [JL87] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Principles of Programming Languages (POPL'87), </booktitle> <address> Munich, FRG, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Constraint Logic Programming languages are extensions of logic programming systems such as PROLOG with constraint-handling facilities. There have been two lines of development: systems such as the CLP (X) scheme <ref> [JL87] </ref> and PROLOG III [Col90] in which constraints are handled by specific black-box solvers, and systems such as CHIP [DVHS + 88] and cc (FD) [VSD92], in which constraints over finite-domain variables are handled through constraint propagation.
Reference: [Kuc92] <author> V. Kuchenhoff. </author> <title> Novel search and constraints an integration. </title> <type> Technical report, </type> <institution> ECRC, </institution> <year> 1992. </year> <note> CHIC deliverable. </note>
Reference-contexts: Experiments we have carried out show that constraints bring the same benefits of simplicity and efficiency when used with approximation algorithms as with enumeration algorithms <ref> [Kuc92] </ref>. Intuitively, approximation algorithms such as hill-climbing, simulated annealing and genetic algorithms, work when solutions which are similar have a broadly similar cost: the cost function is in a loose sense continuous. <p> The latter variables are subsequently labelled under the constraints in the usual CLP manner. The 8 constrained TSP problem was too large too be solved by enumeration techniques, but very good solutions were found by the constrained genetic algorithm. These experiments are described in more detail in <ref> [Kuc92] </ref>. Our experiments and our work on the theoretical foundations of constrained approximation are still in progress. Based on early results we are optimistic that the technique will be effective for a broad range of problems.
Reference: [Le 93] <author> T. Le Provost. </author> <title> Approximation in the framework of generalised propagation. </title> <type> Technical report, </type> <institution> ECRC, </institution> <year> 1993. </year> <note> Presented at the CLP workshop, FGCS'92. </note>
Reference-contexts: When the constraint is invoked as a goal it is then possible to specify how it should be used for propagation, or for search. A way of experimenting with different amounts of propagation is offered by approximate generalised propagation <ref> [Le 93] </ref>. The advantage is that different amounts of propagation can be achieved by modifying a single parameter.
Reference: [LR94] <author> J. M. Lever and B. Richards. parcPLAN: </author> <title> a planning architecture with parallel actions, resources and constraints. </title> <booktitle> In Proc. ISMIS 94, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: Planning problems are therefore a superset of scheduling problems and inherit their complications, whilst also requiring a higher level of reasoning. Constraint-solving is therefore a useful tool for tackling planning problems, and the genereric planning architecture parcPLAN <ref> [LR94] </ref>, developed at IC-Parc, has used Constraint Logic Programming to build a generic shell with capabilities in planning, scheduling and resource allocation.
Reference: [LS87] <author> C. Lepape and S. F. Smith. </author> <title> Management of temporal constraints for factory scheduling. </title> <booktitle> In IFIP Working Conf. on Temporal Aspects in Information Systems, </booktitle> <year> 1987. </year>
Reference-contexts: Two variables constrained by a common set of constraints should be labelled in such a way as to minimise this contention. Preference Propagation In order to use the measures of tightness and contention outlined above, some technique of estimating them is required. The techniques described in <ref> [LS87] </ref> and [SF89] are based on constraint propagation. In this context, the purpose of propagation is not to eliminate impossible values from the domains of variables, but rather to identify degrees of freedom for variables and sources of contention.
Reference: [LW93] <author> T. Le Provost and M. G. Wallace. </author> <title> Generalised constraint propagation over the CLP scheme. </title> <journal> Journal of Logic Programming, </journal> <volume> 16, </volume> <year> 1993. </year>
Reference-contexts: Recently, new techniques such as Generalised Propagation <ref> [LW93] </ref> and Constraint Handling Rules [Fru92] have been developed, providing propagation in a more general context than finite-domains and allowing constraint-solving to be applied to user-defined predicates rather than only to a restricted set of system-defined primitives. <p> For the particular scheduling application at hand, the use of disjunctive constraints as choice points proved to be most efficient! Generalised propagation <ref> [LW93] </ref> allows the disjunctive constraints to be expressed as ordinary Prolog rules (as in the first example above). When the constraint is invoked as a goal it is then possible to specify how it should be used for propagation, or for search.
Reference: [Mac77] <author> A. K. Mackworth. </author> <title> Consistency in networks of relations. </title> <journal> Artificial Intelligence, </journal> <volume> 8 </volume> <pages> 99-118, </pages> <year> 1977. </year>
Reference-contexts: Similarly, Start1 cannot take the value 10. These values are removed from their respective domains, leaving it in the form Start1f1..9g &lt; Start2f2..10g In constraint-solving terms, the constraint has been made arc-consistent <ref> [Mac77] </ref>. However, it is not solved as it is possible to assign values from the domains which violate the constraint, for example Start1 = 9, Start2 = 2. So the constraint is put to sleep.
Reference: [MJPL92] <author> S. Minton, M. D. Johnston, A. B. Philips, and P. Laird. </author> <title> Minimizing conflicts: a heuristic repair method for constraint satisfaction and scheduling problems. </title> <journal> Artificial Intelligence, </journal> <volume> 58, </volume> <year> 1992. </year>
Reference-contexts: For many hard search problems, such as the travelling salesman problem, assembly-line sequencing, and scheduling, approximation algorithms have been used very successfully <ref> [Muh92, CDNT92, MJPL92] </ref>. 7 Such methods are often viewed as an alternative to constrained search. In fact constraints can be used with approximation algorithms in exactly the same way they are used with enumeration algorithms: the choice of approximation or enumeration is independent of the use of constraints. <p> The Need for Constrained Approximation Unconstrained approximation algorithms make no distinction between feasible solutions and others. Therefore, the elimination of infeasible solutions has to be achieved by a kind of trick. Violated constraints have an associated cost. For example, in a hill-climbing algorithm for the n-queens problem <ref> [MJPL92] </ref> the cost of a solution is simply the number of pairs of queens which can take each other thenumber of violated constraints.
Reference: [MMST92] <author> F. Maruyama, Y. Minoda, Sawada S., and Y. Takizawa. </author> <title> Constraint satisfaction and optimisation using nogood justifications. </title> <booktitle> In Proc. 2nd Pacific Rim Conf. on AI, </booktitle> <year> 1992. </year>
Reference-contexts: A problem which had been solved with CHIP [DSVH88] in which such configurations occur was solved even more efficiently by a new approach which used dynamically generated nogood assertions to prune branches of the search tree according to this criteria <ref> [MMST92] </ref>. The idea is based on the concept of nogood environments introduced by Assumption-Based Truth Maintenance Systems [dK86]. The approach is complementary to constraint propagation: propagation is performed before and during search, whilst nogoods are extracted after the search has failed.
Reference: [Muh92] <author> Heinz Muhlenbein. </author> <title> Parallel genetic algorithms and combinatorial optimization. </title> <journal> SIAM J. on Optimization, </journal> <year> 1992. </year>
Reference-contexts: For many hard search problems, such as the travelling salesman problem, assembly-line sequencing, and scheduling, approximation algorithms have been used very successfully <ref> [Muh92, CDNT92, MJPL92] </ref>. 7 Such methods are often viewed as an alternative to constrained search. In fact constraints can be used with approximation algorithms in exactly the same way they are used with enumeration algorithms: the choice of approximation or enumeration is independent of the use of constraints.
Reference: [SF89] <author> N. Sadeh and M. S. Fox. </author> <title> Preference propagation in temporal/capacity constraint graphs. </title> <type> Technical Report CMU-RI-TR-89-2, </type> <institution> Robotics Institute, Carneggie Mellon Univ., </institution> <year> 1989. </year>
Reference-contexts: Two variables constrained by a common set of constraints should be labelled in such a way as to minimise this contention. Preference Propagation In order to use the measures of tightness and contention outlined above, some technique of estimating them is required. The techniques described in [LS87] and <ref> [SF89] </ref> are based on constraint propagation. In this context, the purpose of propagation is not to eliminate impossible values from the domains of variables, but rather to identify degrees of freedom for variables and sources of contention.
Reference: [VSD92] <author> P. Van Hentenryck, H. Simonis, and M. Dincbas. </author> <title> Constraint satisfaction using constraint logic programming. </title> <journal> Artificial Intelligence, </journal> <volume> 58, </volume> <year> 1992. </year> <month> 10 </month>
Reference-contexts: There have been two lines of development: systems such as the CLP (X) scheme [JL87] and PROLOG III [Col90] in which constraints are handled by specific black-box solvers, and systems such as CHIP [DVHS + 88] and cc (FD) <ref> [VSD92] </ref>, in which constraints over finite-domain variables are handled through constraint propagation.
References-found: 22

