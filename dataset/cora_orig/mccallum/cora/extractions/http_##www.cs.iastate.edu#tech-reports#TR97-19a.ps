URL: http://www.cs.iastate.edu/tech-reports/TR97-19a.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Enhancing the Pre- and Postcondition Technique for More Expressive Specifications  
Author: Gary T. Leavens and Albert L. Baker TR #-a Gary T. Leavens and Albert L. Baker 
Keyword: formal methods, liberal specification, redundancy, debugging, history constraint. 1997 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications languages, human factors; D.2.m [Software Engineering] Miscellaneous reusable software; F.3.1 [Logics and Meanings of Programs] Specifying and Verifying and Reasoning about Programs Pre- and post-conditions, specification techniques.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: 1999  Submitted for publication Copyright c 1997,1999 by  
Date: September 1997, revised February  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Derek Andrews. </author> <title> A Theory and Practice of Program Development. </title> <publisher> FACIT. Springer-Verlag, </publisher> <address> London, UK, </address> <year> 1997. </year>
Reference-contexts: These enhancements are found in the specification language COLD-1 [14]. The following briefly summarizes the enhancements in COLD-1 over previous specification languages, such as VDM <ref> [1, 15, 27] </ref> and other languages in the Larch family [22]: Dependent variables, the declaration of which allows the dependent variable to be modified whenever the variables it depends on are modified.
Reference: 2. <author> R. J. R. </author> <title> Back. A calculus of refinements for program derivations. </title> <journal> Acta Informatica, </journal> <volume> 25(6) </volume> <pages> 593-624, </pages> <month> August </month> <year> 1988. </year> <month> 17 </month>
Reference-contexts: However, an explanation of weak behavioral subtyping is outside the scope of this paper. 7 Other Related Work Our goal of making pre- and postcondition specifications more expressive is also served by the refinement calculus <ref> [3, 2, 41-43] </ref>. The major extension in the refinement calculus is the use of abstract programs as specifications. These are programs that may include specification statements (and other kinds of nonconstructive statements).
Reference: 3. <author> R. J. R. Back and J. von Wright. </author> <title> Refinement calculus, part I: Sequential nondeter-ministic programs. </title> <type> Technical Report Ser. </type> <note> A, No 92, </note> <institution> Abo Akademi University, Department of Computer Science, </institution> <address> Lemminkainengatan 14, 20520 Abo, Finland, </address> <year> 1989. </year> <title> Appears in Stepwise Refinement of Distributed Systems, Models, Formalisms, Correctness, </title> <booktitle> REX Workshop, Mook, </booktitle> <address> The Netherlands, </address> <month> May/June </month> <year> 1989, </year> <note> Spring-Verlag, LNCS 430, </note> <editor> J. W. de Bakker, et al, </editor> <booktitle> (eds.), </booktitle> <pages> pages 42-66. </pages>
Reference-contexts: However, an explanation of weak behavioral subtyping is outside the scope of this paper. 7 Other Related Work Our goal of making pre- and postcondition specifications more expressive is also served by the refinement calculus <ref> [3, 2, 41-43] </ref>. The major extension in the refinement calculus is the use of abstract programs as specifications. These are programs that may include specification statements (and other kinds of nonconstructive statements).
Reference: 4. <author> Alex Borgida, John Mylopoulos, and Raymond Reiter. </author> `... <title> and nothing else changes': The frame problem in procedure specification. </title> <booktitle> In Proceedings Fifteenth International Conference on Software Engineering, </booktitle> <address> Baltimore, </address> <month> May </month> <year> 1993. </year> <note> Preliminary version obtained from the authors. </note>
Reference-contexts: This ensures that subtyping is behavioral [10, 40]; that is, subtype objects can be reused according to their supertypes' contracts. 4 Framing A frame axiom in a procedure specification says that "nothing else changes" <ref> [4] </ref>. VDM and Z both have features to permit the specification of frame axioms (write permissions in VDM, and in Z). <p> This can be used to collect common, monotonic, parts of the postconditions of several operations in one place. A more general version of this idea was advocated by Borgida et al. as an approach to dealing with frame axioms <ref> [4] </ref>. The form found in Larch/C ++ is useful in specifying history constraints for types that are intended as supertypes of weak behavioral subtypes [10, 9] [32, Section 7.8].
Reference: 5. <author> Martin Buchi and Emil Sekerinski. </author> <title> Formal methods for component software: The refinement calculus perspective. </title> <booktitle> In Proceedings of the Second Workshop on Component-Oriented Programming (WCOP), </booktitle> <month> June </month> <year> 1997. </year> <month> ftp://ftp.abo.fi/pub/cs/papers/mbuechi/FMforCS.ps.gz. </month>
Reference-contexts: The major extension in the refinement calculus is the use of abstract programs as specifications. These are programs that may include specification statements (and other kinds of nonconstructive statements). This makes it possible to specify higher-order procedures conveniently, and is particularly useful in component-based or event-driven settings <ref> [5] </ref>. However, this extension is orthogonal to the techniques we have discussed. The work of Perry on Inscape [46] also has as one of its goals making pre-and postcondition specifications more practical. It adds to postconditions the notion of an obligation, which clients are expected to satisfy eventually.
Reference: 6. <author> Patrice Chalin. </author> <title> On the Language Design and Semantic Foundation of LCL, a Larch/C Interface Specification Language. </title> <type> PhD thesis, </type> <institution> Concordia University, 1455 de Maisonneuve Blvd. West, </institution> <address> Montreal, Quebec, Canada, </address> <month> October </month> <year> 1995. </year> <note> Available as CU/DCS TR 95-12, from the URL ftp://ftp.cs.concordia.ca/pub/chalin/tr.ps.Z. </note>
Reference-contexts: Since these actions are not considered modifications, they are not covered by the modifies clause. However, without additional support from the specification language, specifiers would have to make assertions about which objects remain allocated and assigned in each postcondition <ref> [6] </ref>, which would be inconvenient and verbose. To avoid having users write in postconditions assertions about what is not trashed, Chalin [6] argued for a second part to the frame axiom in Larch interface specifications. In Larch/C ++ this is called the trashes clause. <p> However, without additional support from the specification language, specifiers would have to make assertions about which objects remain allocated and assigned in each postcondition <ref> [6] </ref>, which would be inconvenient and verbose. To avoid having users write in postconditions assertions about what is not trashed, Chalin [6] argued for a second part to the frame axiom in Larch interface specifications. In Larch/C ++ this is called the trashes clause.
Reference: 7. <author> Patrice Chalin, Peter Grogono, and T. Radhakrishnan. </author> <title> Identification of and solutions to shortcomings of LCL, a Larch/C interface specification language. </title> <editor> In Marie-Claude Gaudel and James Woodcock, editors, </editor> <booktitle> FME '96: Industrial Benefit and Advances in Formal Methods, volume 1051 of Lecture Notes in Computer Science, </booktitle> <pages> pages 385-404, </pages> <address> New York, N.Y., March 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: If this is not done, then logical problems may occur <ref> [7, 26, 34] </ref>. To avoid such problems in the semantics of the modifies clause, the set ModifiedObjects (pre, post) can only include objects that are assigned values in both the pre- and post-states and change their values, or that are allocated in the pre-state and become assigned in the post-state.
Reference: 8. <author> David L. Detlefs, K. Rustan M. Leino, Greg Nelson, and James B. Saxe. </author> <title> Extended static checking. </title> <note> SRC Research Report 159, </note> <institution> Compaq Systems Research Center, </institution> <address> 130 Lytton Ave., Palo Alto, </address> <month> Dec </month> <year> 1998. </year>
Reference-contexts: Inscape also splits preconditions up into three kinds, although none of them are redundant and thus cannot be used for debugging specifications. Perry's Instress tool uses static analysis to help debug programs, not specifications. The Extended Static Checker from Compaq SRC <ref> [8] </ref> carries on this tradition of static analysis using specifications to help debug programs; again the work is not aimed at helping debug specifications. The specifications used in this checker do, however, have some additional constructs for more expressive framing than what is described in this paper.
Reference: 9. <author> Krishna Kishore Dhara. </author> <title> Behavioral subtyping in object-oriented languages. </title> <type> Technical Report TR97-09, </type> <institution> Department of Computer Science, Iowa State University, 226 Atanasoff Hall, </institution> <address> Ames IA 50011-1040, </address> <month> May </month> <year> 1997. </year> <title> The author's Ph.D. </title> <type> dissertation. </type>
Reference-contexts: A more general version of this idea was advocated by Borgida et al. as an approach to dealing with frame axioms [4]. The form found in Larch/C ++ is useful in specifying history constraints for types that are intended as supertypes of weak behavioral subtypes <ref> [10, 9] </ref> [32, Section 7.8]. However, an explanation of weak behavioral subtyping is outside the scope of this paper. 7 Other Related Work Our goal of making pre- and postcondition specifications more expressive is also served by the refinement calculus [3, 2, 41-43].
Reference: 10. <author> Krishna Kishore Dhara and Gary T. Leavens. </author> <title> Forcing behavioral subtyping through specification inheritance. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <address> Berlin, Germany, </address> <pages> pages 258-267. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> March </month> <year> 1996. </year> <institution> A corrected version is Iowa State University, Dept. of Computer Science TR #95-20c. </institution>
Reference-contexts: The ensures redundantly clause is explained below. For OO specification languages, Wills pointed out that one can understand inheritance of specifications as meaning that subtype objects must satisfy the cases specified for them explicitly, as well as those of their supertypes. This ensures that subtyping is behavioral <ref> [10, 40] </ref>; that is, subtype objects can be reused according to their supertypes' contracts. 4 Framing A frame axiom in a procedure specification says that "nothing else changes" [4]. VDM and Z both have features to permit the specification of frame axioms (write permissions in VDM, and in Z). <p> An innovation in Larch/C ++ is that one can limit a history constraint so that it only applies to various named operations <ref> [10] </ref> [32, Section 7.4]. This can be used to collect common, monotonic, parts of the postconditions of several operations in one place. A more general version of this idea was advocated by Borgida et al. as an approach to dealing with frame axioms [4]. <p> A more general version of this idea was advocated by Borgida et al. as an approach to dealing with frame axioms [4]. The form found in Larch/C ++ is useful in specifying history constraints for types that are intended as supertypes of weak behavioral subtypes <ref> [10, 9] </ref> [32, Section 7.8]. However, an explanation of weak behavioral subtyping is outside the scope of this paper. 7 Other Related Work Our goal of making pre- and postcondition specifications more expressive is also served by the refinement calculus [3, 2, 41-43].
Reference: 11. <author> E. W. Dijkstra, </author> <title> editor. Formal Development of Programs and Proofs. </title> <booktitle> University of Texas at Austin Year of Programming series. </booktitle> <publisher> Addison-Wesley Publishing Co., </publisher> <year> 1990. </year>
Reference-contexts: Our emphasis on expressiveness in specifications can be seen as following the emphasis on expressive notation in the "calculational school" of Dijkstra, Gries, and others (see, e.g., <ref> [11, 13, 18, 19] </ref>). These authors have considerably adapted standard mathematical notations to be more consistent and communicative. However, they have not directed much attention to the pre- and post-condition technique itself.
Reference: 12. <author> Edsger W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1976. </year>
Reference-contexts: In Section 5, we describe how to add redundancy, including examples, to specifications. In Section 6, we describe "history constraints" that can constrain how states can change. Finally, we offer some conclusions. 2 Liberal Specifications Most pre- and postcondition-based specification languages have a total correctness <ref> [12] </ref> semantics. <p> In Larch/C ++ users can specify procedures using either the total or partial correctness semantics. Specifications that use just the keyword ensures have a total correctness semantics, and those that use ensures liberally have a partial correctness semantics. (The keyword liberally is inspired by Dijkstra's terminology <ref> [12] </ref>; it has been suggested that on exit might be better.) One use for partial correctness specifications, as in Hoare's original work [25], is to avoid finiteness issues. <p> In Larch/C ++ , one can combine total and partial correctness specifications for the same procedure, and thus more precisely specify both when a call must terminate and what must be true on termination. The semantics of such combinations uses the ideas of Dijkstra and others <ref> [12, 44, 24] </ref>. Another way out of the difficulty with allocation routines would be to change the meaning of total correctness. For example, one could use a variation on Poetzsch-Heffter's semantics [47, page 48] and require termination only if no memory allocation errors occur.
Reference: 13. <author> Edsger W. Dijkstra and Carel S. Scholten. </author> <title> Predicate Calculus and program semantics. </title> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1990. </year>
Reference-contexts: Our emphasis on expressiveness in specifications can be seen as following the emphasis on expressive notation in the "calculational school" of Dijkstra, Gries, and others (see, e.g., <ref> [11, 13, 18, 19] </ref>). These authors have considerably adapted standard mathematical notations to be more consistent and communicative. However, they have not directed much attention to the pre- and post-condition technique itself.
Reference: 14. <author> L. M. G. Feijs and H. B. M. Jonkers. </author> <title> Formal Specification and Design, </title> <booktitle> volume 35 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1992. </year>
Reference-contexts: The fact that this is not really the case is camouflaged by the sloppy and informal way pre- and postconditions are generally used in practice." Besides reconstructing the pre- and postcondition technique, Jonkers describes several enhancements. These enhancements are found in the specification language COLD-1 <ref> [14] </ref>. The following briefly summarizes the enhancements in COLD-1 over previous specification languages, such as VDM [1, 15, 27] and other languages in the Larch family [22]: Dependent variables, the declaration of which allows the dependent variable to be modified whenever the variables it depends on are modified.
Reference: 15. <author> John Fitzgerald and Peter Gorm Larsen. </author> <title> Modelling Systems: </title> <booktitle> Practical Tools in Software Development. </booktitle> <address> Cambridge, Cambridge, UK, </address> <year> 1998. </year>
Reference-contexts: These enhancements are found in the specification language COLD-1 [14]. The following briefly summarizes the enhancements in COLD-1 over previous specification languages, such as VDM <ref> [1, 15, 27] </ref> and other languages in the Larch family [22]: Dependent variables, the declaration of which allows the dependent variable to be modified whenever the variables it depends on are modified.
Reference: 16. <author> Stephen J. Garland, John V. Guttag, and James J. Horning. </author> <title> Debugging Larch Shared Language specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(6) </volume> <pages> 1044-1057, </pages> <month> September </month> <year> 1990. </year> <month> 18 </month>
Reference-contexts: The Larch family has emphasized the benefit of checking how well a specification captures the specifier's intuition by comparing the redundant parts against the main parts; such checking is called "debugging" a specification <ref> [16] </ref>. For example, the Larch Shared Language incorporates features that can be used to state redundant claims about theories [22, Chapter 7]. 5.1 Redundant Postconditions Tan's work on LCL introduced redundancy into a specification language with pre- and postconditions [53, 52, 54].
Reference: 17. <author> M. Gogolla, S. Conrad, G. Denker, R. Herzig, N. Vlachantonis, and H. Ehrig. </author> <title> TROLL light | the language and its development environment. </title> <editor> In Manfred Broy and Stefan Jahnichen, editors, KORSO: </editor> <booktitle> Methods, Languages and Tools for the Construction of Correct Software, volume 1009 of Lecture Notes in Computer Science, </booktitle> <pages> pages 205-220. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1995. </year>
Reference: 18. <author> David Gries. </author> <title> Teaching calculation and discrimination: A more effective curriculum. </title> <journal> Communications of the ACM, </journal> <volume> 34(3) </volume> <pages> 44-55, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: Our emphasis on expressiveness in specifications can be seen as following the emphasis on expressive notation in the "calculational school" of Dijkstra, Gries, and others (see, e.g., <ref> [11, 13, 18, 19] </ref>). These authors have considerably adapted standard mathematical notations to be more consistent and communicative. However, they have not directed much attention to the pre- and post-condition technique itself.
Reference: 19. <author> David Gries and Fred B. Schneider. </author> <title> A Logical Approach to Discrete Math. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference-contexts: Our emphasis on expressiveness in specifications can be seen as following the emphasis on expressive notation in the "calculational school" of Dijkstra, Gries, and others (see, e.g., <ref> [11, 13, 18, 19] </ref>). These authors have considerably adapted standard mathematical notations to be more consistent and communicative. However, they have not directed much attention to the pre- and post-condition technique itself.
Reference: 20. <author> David Gries and Fred B. Schneider. </author> <title> Avoiding the undefined by underspecification. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Computer Science Today: Recent Trends and Developments, number 1000 in Lecture Notes in Computer Science, </booktitle> <pages> pages 366-373. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1995. </year>
Reference-contexts: The modifies clause gives considerable notational abbreviation, because it asserts that all objects not mentioned retain their values. 4.1 Trashing In the Larch family, predicates use the logic of the Larch Shared Language, which is a logic of total functions <ref> [20, 33] </ref>. In such a logic, the pre- and post-states, which are modeled by functions, will return proper values for objects that are not allocated or that are not assigned a proper value.
Reference: 21. <author> M. Gurski and A. L. Baker. </author> <title> Testing SPECS-C++: A first step in validating distributed systems. </title> <booktitle> In Intellegent Information Management Systems, </booktitle> <pages> pages 105-108, </pages> <address> Anaheim, </address> <year> 1994. </year> <booktitle> The International Society for Mini and Microcomputers - ISMM. </booktitle>
Reference-contexts: In our experience, the most significant of these enhancements is the ability to add redundant examples to specifications. In addition to their potential use in debugging specifications, we have found that they can help make specifications clearer. We are also excited about their potential for automated testing <ref> [21] </ref>. Besides examples, the enhancement we use most often is case analysis [57, Section 4.1.4] [55]. This is helpful in stating specifications of procedures that may throw exceptions.
Reference: 22. <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: These enhancements are found in the specification language COLD-1 [14]. The following briefly summarizes the enhancements in COLD-1 over previous specification languages, such as VDM [1, 15, 27] and other languages in the Larch family <ref> [22] </ref>: Dependent variables, the declaration of which allows the dependent variable to be modified whenever the variables it depends on are modified. <p> This technique is useful in precisely specifying contracts for procedures written for languages (or compilers) without exception handling. This idea appears in sugared form in the LCL checks clause <ref> [22, 53, 52, 54] </ref>. Partial correctness is also useful for specifying procedures for which there is no known totally-correct implementation. <p> Interpreters for Turing-complete languages are examples. 3 Case Analysis A simple syntactic sugar, which we call case analysis, is helpful in breaking up specifications into more manageable chunks, and in specifying procedures that can throw exceptions. Its advantage over special-purpose notations for exceptions (as in LM3 <ref> [28, 22] </ref>, to cite just one example) is that it is also useful for other kinds of case analysis This sugar was pioneered by Wing [57, Section 4.1.4]. The idea is that a specification can be split into several cases, all of which must be satisfied by a correct implementation. <p> For example, the Larch Shared Language incorporates features that can be used to state redundant claims about theories <ref> [22, Chapter 7] </ref>. 5.1 Redundant Postconditions Tan's work on LCL introduced redundancy into a specification language with pre- and postconditions [53, 52, 54]. Of particular relevance here are Tan's "procedure claims," which state redundant properties that follow from the main part 10 of a specification.
Reference: 23. <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction 1.1 Background and Motivation The pre- and postcondition technique was described by Hoare in his classic article [25]. This technique forms the basis of most contemporary specification languages for sequential systems [1, 14, 15, 17, 22, 27, 30, 39, 38, 40, 41, 45, 48, 49]. (However, Z <ref> [23, 50] </ref> is an exception, as Z preconditions are not explicitly stated, but instead are calculated from the specification given [58, Chapter 14].) We take as our starting point an excellent article by Jonkers [29], which, like this paper, is addressed to specification language designers.
Reference: 24. <author> Wim H. Hesselink. </author> <title> Programs, Recursion, and Unbounded Choice, </title> <booktitle> volume 27 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: In Larch/C ++ , one can combine total and partial correctness specifications for the same procedure, and thus more precisely specify both when a call must terminate and what must be true on termination. The semantics of such combinations uses the ideas of Dijkstra and others <ref> [12, 44, 24] </ref>. Another way out of the difficulty with allocation routines would be to change the meaning of total correctness. For example, one could use a variation on Poetzsch-Heffter's semantics [47, page 48] and require termination only if no memory allocation errors occur.
Reference: 25. <author> C. A. R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: 1 Introduction 1.1 Background and Motivation The pre- and postcondition technique was described by Hoare in his classic article <ref> [25] </ref>. <p> just the keyword ensures have a total correctness semantics, and those that use ensures liberally have a partial correctness semantics. (The keyword liberally is inspired by Dijkstra's terminology [12]; it has been suggested that on exit might be better.) One use for partial correctness specifications, as in Hoare's original work <ref> [25] </ref>, is to avoid finiteness issues. For example, instead of specifying inc as in Figure 1, one could drop the precondition conjunct i^ &lt; INT_MAX and use ensures liberally in the postcondition.
Reference: 26. <author> C.B. Jones. </author> <title> Partial functions and logics: A warning. </title> <journal> Information Processing Letters, </journal> <volume> 54(2) </volume> <pages> 65-67, </pages> <year> 1995. </year>
Reference-contexts: If this is not done, then logical problems may occur <ref> [7, 26, 34] </ref>. To avoid such problems in the semantics of the modifies clause, the set ModifiedObjects (pre, post) can only include objects that are assigned values in both the pre- and post-states and change their values, or that are allocated in the pre-state and become assigned in the post-state.
Reference: 27. <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: These enhancements are found in the specification language COLD-1 [14]. The following briefly summarizes the enhancements in COLD-1 over previous specification languages, such as VDM <ref> [1, 15, 27] </ref> and other languages in the Larch family [22]: Dependent variables, the declaration of which allows the dependent variable to be modified whenever the variables it depends on are modified.
Reference: 28. <author> Kevin D. Jones. LM3: </author> <title> A Larch interface language for Modula-3: A definition and introduction: Version 1.0. </title> <type> Technical Report 72, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue Palo Alto, CA 94301, </address> <month> June </month> <year> 1991. </year> <title> Order from src-report@src.dec.com. </title>
Reference-contexts: Interpreters for Turing-complete languages are examples. 3 Case Analysis A simple syntactic sugar, which we call case analysis, is helpful in breaking up specifications into more manageable chunks, and in specifying procedures that can throw exceptions. Its advantage over special-purpose notations for exceptions (as in LM3 <ref> [28, 22] </ref>, to cite just one example) is that it is also useful for other kinds of case analysis This sugar was pioneered by Wing [57, Section 4.1.4]. The idea is that a specification can be split into several cases, all of which must be satisfied by a correct implementation.
Reference: 29. <author> H. B. M. Jonkers. </author> <title> Upgrading the pre- and postcondition technique. </title> <editor> In S. Prehn and W. J. Toetenel, editors, </editor> <booktitle> VDM '91 Formal Software Development Methods 4th International Symposium of VDM Europe Noordwijkerhout, The Netherlands, Volume 1: Conference Contributions, volume 551 of Lecture Notes in Computer Science, </booktitle> <pages> pages 428-456. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> October </month> <year> 1991. </year>
Reference-contexts: [1, 14, 15, 17, 22, 27, 30, 39, 38, 40, 41, 45, 48, 49]. (However, Z [23, 50] is an exception, as Z preconditions are not explicitly stated, but instead are calculated from the specification given [58, Chapter 14].) We take as our starting point an excellent article by Jonkers <ref> [29] </ref>, which, like this paper, is addressed to specification language designers. Jonkers says (page 428): "Nowadays the pre- and postcondition technique is considered a stan-dard technique in software development as it is being taught in almost every basic software engineering course.
Reference: 30. <author> Kevin Lano. </author> <title> The B Language and Method: A guide to Practical Formal Development. Formal Appoaches to Computing and Information Technology. </title> <publisher> Springer-Verlag, </publisher> <address> London, UK, </address> <year> 1996. </year>
Reference: 31. <author> Gary T. Leavens. </author> <title> An overview of Larch/C++: Behavioral specifications for C++ modules. </title> <editor> In Haim Kilov and William Harvey, editors, </editor> <booktitle> Specification of Behavioral Semantics in Object-Oriented Information Modeling, chapter 8, </booktitle> <pages> pages 121-142. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1996. </year> <note> An extended version is TR #96-01d, </note> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011. </month>
Reference-contexts: Instead we wish to highlight them so that they might become more widely known and used in specification language design. We show how all these enhancements are integrated in Larch/C ++ <ref> [31, 32] </ref>, a Larch-style behavioral interface specification language for C ++ . Larch/C ++ adopts most of the COLD-1 extensions, except for the technical ideas for fine-grained frame axioms and the extensions for the specification of reactive systems, and includes the enhancements discussed below. <p> By adding examples as another form of redundancy to specifications one gains the benefits of additional redundancy as well as the ability to convey more clearly what is to be done. (Examples as part of interface specifications first appeared in Larch/C ++ <ref> [31] </ref>.) For instance, in Figure 7, examples are used to show that isqrt is underspecified; the two examples given show different approximations that may be returned for the square root of 31. extern unsigned int isqrt (unsigned int & x) throw (); //@ behavior - //@ requires assigned (x, pre); //@
Reference: 32. <author> Gary T. Leavens. </author> <note> Larch/C++ Reference Manual. Version 5.25. Available in ftp://ftp.cs.iastate.edu/pub/larchc++/lcpp.ps.gz or on the World Wide Web at the URL http://www.cs.iastate.edu/~leavens/larchc++.html, January 1999. 19 </note>
Reference-contexts: Instead we wish to highlight them so that they might become more widely known and used in specification language design. We show how all these enhancements are integrated in Larch/C ++ <ref> [31, 32] </ref>, a Larch-style behavioral interface specification language for C ++ . Larch/C ++ adopts most of the COLD-1 extensions, except for the technical ideas for fine-grained frame axioms and the extensions for the specification of reactive systems, and includes the enhancements discussed below. <p> In Larch/C ++ , the meaning of the modifies clause "modifies i;" is translated by a predicate like the following (see <ref> [32, Section 6.2.3.4] </ref> for exact details), which can be thought of as conjoined to the postcondition. 8 ModifiedObjects (pre, post) "subseteq -i, residue_i- In the above, the term ModifiedObjects (pre, post) denotes the set of all objects modified in the transition from the pre-state to the post-state, and "subseteq is a <p> As with the modifies clause, the trashes clause is a permission, not a requirement to trash the objects mentioned. Consider the example in Figure 6 <ref> [32, Section 6.3.2.1] </ref>. The object pointed to by cp may be trashed, since it is mentioned in the trashes clause. The postcondition says that it must be trashed when the value of ref_count drops to 0, but may not be otherwise. <p> The postcondition says that it must be trashed when the value of ref_count drops to 0, but may not be otherwise. In Larch/C ++ , the meaning of the trashes clause "trashes *cp;" is translated by a predicate like the following (see <ref> [32, Section 6.2.3.4] </ref> for details), which can be thought of as conjoined to the postcondition. <p> To use redundant postconditions in debugging a specification, for each such redundancy claim, one would try to prove the following, where Pre is the case's precondition, Frame is the predicate that translates its frame axioms, Post is its postcondition, and RedunPost is the claimed redundant postcondition [53, 52, 54] <ref> [32, Section 6.8] </ref>. (All of these should be in their desugared forms.) Pre ^ Frame ^ Post ) RedunPost (1) 5.2 Examples When we give problem statements to students, we observe that many students primarily focus on examples. <p> The example input predicates would be used in debugging the specification by checking that they are consistent with the precondition. Example inputs are not included in the current version of Larch/C ++ <ref> [32] </ref>, because we have not found a great need for them. 5.4 Redundant Frames Larch/C ++ was also the first interface specification language to extend the idea of redundancy to the modifies and trashes clauses. In Larch/C ++ , one can use modifies redundantly and trashes redundantly clauses. <p> For example, the Larch/C ++ manual's specification of a class Person <ref> [32, Section 7.1.1] </ref>, includes the following history constraint, which expresses the inexorable arrow of time. //@ constraint age^ &lt;= age'; To allow debugging of invariants and history constraints, Larch/C ++ also allows one to state redundant invariants and history constraints, using invariant redundantly and constraint redundantly clauses. <p> An innovation in Larch/C ++ is that one can limit a history constraint so that it only applies to various named operations [10] <ref> [32, Section 7.4] </ref>. This can be used to collect common, monotonic, parts of the postconditions of several operations in one place. A more general version of this idea was advocated by Borgida et al. as an approach to dealing with frame axioms [4]. <p> A more general version of this idea was advocated by Borgida et al. as an approach to dealing with frame axioms [4]. The form found in Larch/C ++ is useful in specifying history constraints for types that are intended as supertypes of weak behavioral subtypes [10, 9] <ref> [32, Section 7.8] </ref>. However, an explanation of weak behavioral subtyping is outside the scope of this paper. 7 Other Related Work Our goal of making pre- and postcondition specifications more expressive is also served by the refinement calculus [3, 2, 41-43].
Reference: 33. <author> Gary T. Leavens and Jeannette M. Wing. </author> <title> Protective interface specifications. </title> <editor> In Michel Bidoit and Max Dauchet, editors, </editor> <booktitle> TAPSOFT '97: Theory and Practice of Software Development, 7th International Joint Conference CAAP/FASE, Lille, France, volume 1214 of Lecture Notes in Computer Science, </booktitle> <pages> pages 520-534. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1997. </year>
Reference-contexts: The modifies clause gives considerable notational abbreviation, because it asserts that all objects not mentioned retain their values. 4.1 Trashing In the Larch family, predicates use the logic of the Larch Shared Language, which is a logic of total functions <ref> [20, 33] </ref>. In such a logic, the pre- and post-states, which are modeled by functions, will return proper values for objects that are not allocated or that are not assigned a proper value.
Reference: 34. <author> Gary T. Leavens and Jeannette M. Wing. </author> <title> Protective interface specifications. </title> <journal> Formal Aspects of Computing, </journal> <volume> 10 </volume> <pages> 59-75, </pages> <year> 1998. </year>
Reference-contexts: If this is not done, then logical problems may occur <ref> [7, 26, 34] </ref>. To avoid such problems in the semantics of the modifies clause, the set ModifiedObjects (pre, post) can only include objects that are assigned values in both the pre- and post-states and change their values, or that are allocated in the pre-state and become assigned in the post-state.
Reference: 35. <author> K. Rustan M. Leino. </author> <title> Toward Reliable Modular Programs. </title> <type> PhD thesis, </type> <institution> California Institute of Technology, </institution> <year> 1995. </year> <note> Available as Technical Report Caltech-CS-TR-95-03. </note>
Reference-contexts: Dependent variables can be specified either directly, or indirectly using pre- and postconditions. (See also Leino's work on dependencies <ref> [35] </ref>.) - Fine-grained frame axioms using wild cards and expressions, which allow one to specify the variables that can be changed more concisely and precisely. Let clauses, which allow the introduction of local named abbreviations. <p> The object residue_i stands for whatever objects i may depend on that are not in scope <ref> [35, Section 11.3] </ref>. The modifies clause gives considerable notational abbreviation, because it asserts that all objects not mentioned retain their values. 4.1 Trashing In the Larch family, predicates use the logic of the Larch Shared Language, which is a logic of total functions [20, 33]. <p> Specification of the C++ function dec ref. The ensures redundantly and example clauses are explained below. As above, the object residue_star_cp stands for whatever objects *cp may depend on that are not in scope <ref> [35, Section 11.3] </ref>. 5 Redundancy A redundant part of a specification does not itself form part of the contract, but instead is a formalized commentary on it. By allowing a specifier to state redundant properties explicitly, a specification language becomes more expressive. <p> In Larch/C ++ , one can use modifies redundantly and trashes redundantly clauses. One use for such clauses is to highlight objects that are implicitly allowed to be modified or trashed because some explicitly named object has been declared to depend on them <ref> [35] </ref>.
Reference: 36. <author> Barbara Liskov and Jeannette Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(6) </volume> <pages> 1811-1841, </pages> <month> Novem-ber </month> <year> 1994. </year>
Reference-contexts: However, invariants are not mere notational abbreviations, because they apply to all operations, even when new ones are added to an ADT. Liskov and Wing introduced a similar idea as an aid to specifying OO programs that use behavioral subtyping <ref> [37, 36] </ref>. A history constraint for a type describes a property of objects of that type (and all subtypes) that must hold for any ordered pair of visible states in a computation, where the first state occurs before the second.
Reference: 37. <author> Barbara Liskov and Jeannette M. Wing. </author> <title> Specifications and their use in defining subtypes. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(10) </volume> <pages> 16-28, </pages> <month> October </month> <year> 1993. </year> <booktitle> OOPSLA '93 Proceedings, Andreas Paepcke (editor). </booktitle>
Reference-contexts: However, invariants are not mere notational abbreviations, because they apply to all operations, even when new ones are added to an ADT. Liskov and Wing introduced a similar idea as an aid to specifying OO programs that use behavioral subtyping <ref> [37, 36] </ref>. A history constraint for a type describes a property of objects of that type (and all subtypes) that must hold for any ordered pair of visible states in a computation, where the first state occurs before the second.
Reference: 38. <author> David Luckham. </author> <title> Programming with Specifications: An Introduction to Anna, A Language for Specifying Ada Programs. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference: 39. <author> David Luckham and Friedrich W. von Henke. </author> <title> An overview of anna aspecification language for Ada. </title> <journal> IEEE Software, </journal> <volume> 2(2) </volume> <pages> 9-23, </pages> <month> March </month> <year> 1985. </year>
Reference: 40. <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1997. </year>
Reference-contexts: The ensures redundantly clause is explained below. For OO specification languages, Wills pointed out that one can understand inheritance of specifications as meaning that subtype objects must satisfy the cases specified for them explicitly, as well as those of their supertypes. This ensures that subtyping is behavioral <ref> [10, 40] </ref>; that is, subtype objects can be reused according to their supertypes' contracts. 4 Framing A frame axiom in a procedure specification says that "nothing else changes" [4]. VDM and Z both have features to permit the specification of frame axioms (write permissions in VDM, and in Z).
Reference: 41. <author> Carroll Morgan. </author> <title> Programming from Specifications: Second Edition. </title> <publisher> Prentice Hall International, </publisher> <address> Hempstead, UK, </address> <year> 1994. </year>
Reference: 42. <author> Carroll Morgan and Trevor Vickers, </author> <title> editors. </title> <booktitle> On the refinement calculus. Formal approaches of computing and information technology series. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference: 43. <author> Joseph M. Morris. </author> <title> A theoretical basis for stepwise refinement and the programming calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 9(3) </volume> <pages> 287-306, </pages> <month> December </month> <year> 1987. </year>
Reference: 44. <author> Greg Nelson. </author> <title> A generalization of Dijkstra's calculus. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 517-561, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: In Larch/C ++ , one can combine total and partial correctness specifications for the same procedure, and thus more precisely specify both when a call must terminate and what must be true on termination. The semantics of such combinations uses the ideas of Dijkstra and others <ref> [12, 44, 24] </ref>. Another way out of the difficulty with allocation routines would be to change the meaning of total correctness. For example, one could use a variation on Poetzsch-Heffter's semantics [47, page 48] and require termination only if no memory allocation errors occur.
Reference: 45. <author> William F. Ogden, Murali Sitaraman, Bruce W. Weide, and Stuart H. </author> <title> Zweben. Part I: The RESOLVE framework and discipline | a research synopsis. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 19(4) </volume> <pages> 23-28, </pages> <month> Oct </month> <year> 1994. </year>
Reference: 46. <author> D. E. Perry. </author> <title> The Inscape environment. </title> <booktitle> In Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 2-12, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: This makes it possible to specify higher-order procedures conveniently, and is particularly useful in component-based or event-driven settings [5]. However, this extension is orthogonal to the techniques we have discussed. The work of Perry on Inscape <ref> [46] </ref> also has as one of its goals making pre-and postcondition specifications more practical. It adds to postconditions the notion of an obligation, which clients are expected to satisfy eventually. Again, this extension is orthogonal to those discussed in this paper.
Reference: 47. <author> Arnd Poetzsch-Heffter. </author> <title> Specification and verification of object-oriented programs. </title> <type> Habilitation thesis, </type> <institution> Technical University of Munich, </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: The semantics of such combinations uses the ideas of Dijkstra and others [12, 44, 24]. Another way out of the difficulty with allocation routines would be to change the meaning of total correctness. For example, one could use a variation on Poetzsch-Heffter's semantics <ref> [47, page 48] </ref> and require termination only if no memory allocation errors occur. However, there are other uses for partial correctness. A prime use is in specifying when a procedure must not terminate. A simple example is the C ++ abort procedure, which can be specified as in Figure 2. <p> The desugaring first conjoins the outer precondition to each of the inner ones, and applies the previous desugaring. Extracting common parts of preconditions like this also highlights them for the reader. (We attach no special semantics to such common preconditions, unlike Poetzsch-Heffter <ref> [47, pages 96-97] </ref>.) #include "Stack.h" #include "BadSize.h" extern void pop2 (Stack & s) throw (BadSize); //@ behavior - //@ requires assigned (s, pre); //@ - //@ requires size (s^) &lt; 2; //@ ensures throws (BadSize); //@ also //@ requires size (s^) &gt;= 2; //@ modifies s; //@ ensures returns /" s'
Reference: 48. <author> David S. Rosenblum. </author> <title> A practical approach to programming with assertions. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(1) </volume> <pages> 19-31, </pages> <month> January </month> <year> 1995. </year>
Reference: 49. <author> Murali Sitaraman, Lonnie R. Welch, and Douglas E. Harms. </author> <title> On specification of reusable software components. </title> <journal> International Journal of Software Engineering and Knowledege Engineering, </journal> <volume> 3(2) </volume> <pages> 207-229, </pages> <year> 1993. </year>
Reference: 50. <author> J. Michael Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: 1 Introduction 1.1 Background and Motivation The pre- and postcondition technique was described by Hoare in his classic article [25]. This technique forms the basis of most contemporary specification languages for sequential systems [1, 14, 15, 17, 22, 27, 30, 39, 38, 40, 41, 45, 48, 49]. (However, Z <ref> [23, 50] </ref> is an exception, as Z preconditions are not explicitly stated, but instead are calculated from the specification given [58, Chapter 14].) We take as our starting point an excellent article by Jonkers [29], which, like this paper, is addressed to specification language designers.
Reference: 51. <author> Susan Stepney, Rosalind Barden, and David Cooper, </author> <title> editors. Object Orientation in Z. Workshops in Computing. </title> <publisher> Springer-Verlag, </publisher> <address> Cambridge CB2 1LQ, UK, </address> <year> 1992. </year>
Reference: 52. <author> Yang Meng Tan. </author> <title> Formal specification techniques for promoting software modularity, enhancing documentation, and testing specifications. </title> <type> Technical Report 619, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, 545 Technology Square, </institution> <address> Cambridge, Mass., </address> <month> June </month> <year> 1994. </year> <month> 20 </month>
Reference-contexts: We also claim that some of the enhancements we describe can increase the quality of specifications. This is particularly true of the redundancy enhancements described in Section 5, which can be used to check that the specification says what is intended <ref> [53, 52, 54] </ref>. 1.3 Overview In Section 2 below we show how to allow the specifier to choose either total or partial correctness specifications. In Section 3, we describe a syntactic sugar, "case analysis," that helps break specifications up into more easily understood pieces. <p> This technique is useful in precisely specifying contracts for procedures written for languages (or compilers) without exception handling. This idea appears in sugared form in the LCL checks clause <ref> [22, 53, 52, 54] </ref>. Partial correctness is also useful for specifying procedures for which there is no known totally-correct implementation. <p> For example, the Larch Shared Language incorporates features that can be used to state redundant claims about theories [22, Chapter 7]. 5.1 Redundant Postconditions Tan's work on LCL introduced redundancy into a specification language with pre- and postconditions <ref> [53, 52, 54] </ref>. Of particular relevance here are Tan's "procedure claims," which state redundant properties that follow from the main part 10 of a specification. In Larch/C ++ , one can use an ensures redundantly clause to state procedure claims. <p> To use redundant postconditions in debugging a specification, for each such redundancy claim, one would try to prove the following, where Pre is the case's precondition, Frame is the predicate that translates its frame axioms, Post is its postcondition, and RedunPost is the claimed redundant postcondition <ref> [53, 52, 54] </ref> [32, Section 6.8]. (All of these should be in their desugared forms.) Pre ^ Frame ^ Post ) RedunPost (1) 5.2 Examples When we give problem statements to students, we observe that many students primarily focus on examples.
Reference: 53. <author> Yang Meng Tan. </author> <title> Interface language for supporting programming styles. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(8) </volume> <pages> 74-83, </pages> <month> August </month> <year> 1994. </year> <booktitle> Proceedings of the Workshop on Interface Definition Languages. </booktitle>
Reference-contexts: We also claim that some of the enhancements we describe can increase the quality of specifications. This is particularly true of the redundancy enhancements described in Section 5, which can be used to check that the specification says what is intended <ref> [53, 52, 54] </ref>. 1.3 Overview In Section 2 below we show how to allow the specifier to choose either total or partial correctness specifications. In Section 3, we describe a syntactic sugar, "case analysis," that helps break specifications up into more easily understood pieces. <p> This technique is useful in precisely specifying contracts for procedures written for languages (or compilers) without exception handling. This idea appears in sugared form in the LCL checks clause <ref> [22, 53, 52, 54] </ref>. Partial correctness is also useful for specifying procedures for which there is no known totally-correct implementation. <p> For example, the Larch Shared Language incorporates features that can be used to state redundant claims about theories [22, Chapter 7]. 5.1 Redundant Postconditions Tan's work on LCL introduced redundancy into a specification language with pre- and postconditions <ref> [53, 52, 54] </ref>. Of particular relevance here are Tan's "procedure claims," which state redundant properties that follow from the main part 10 of a specification. In Larch/C ++ , one can use an ensures redundantly clause to state procedure claims. <p> To use redundant postconditions in debugging a specification, for each such redundancy claim, one would try to prove the following, where Pre is the case's precondition, Frame is the predicate that translates its frame axioms, Post is its postcondition, and RedunPost is the claimed redundant postcondition <ref> [53, 52, 54] </ref> [32, Section 6.8]. (All of these should be in their desugared forms.) Pre ^ Frame ^ Post ) RedunPost (1) 5.2 Examples When we give problem statements to students, we observe that many students primarily focus on examples.
Reference: 54. <author> Yang Meng Tan. </author> <title> Formal Specification Techniques for Engineering Modular C Programs, </title> <booktitle> volume 1 of Kluwer International Series in Software Engineering. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1995. </year>
Reference-contexts: We also claim that some of the enhancements we describe can increase the quality of specifications. This is particularly true of the redundancy enhancements described in Section 5, which can be used to check that the specification says what is intended <ref> [53, 52, 54] </ref>. 1.3 Overview In Section 2 below we show how to allow the specifier to choose either total or partial correctness specifications. In Section 3, we describe a syntactic sugar, "case analysis," that helps break specifications up into more easily understood pieces. <p> This technique is useful in precisely specifying contracts for procedures written for languages (or compilers) without exception handling. This idea appears in sugared form in the LCL checks clause <ref> [22, 53, 52, 54] </ref>. Partial correctness is also useful for specifying procedures for which there is no known totally-correct implementation. <p> For example, the Larch Shared Language incorporates features that can be used to state redundant claims about theories [22, Chapter 7]. 5.1 Redundant Postconditions Tan's work on LCL introduced redundancy into a specification language with pre- and postconditions <ref> [53, 52, 54] </ref>. Of particular relevance here are Tan's "procedure claims," which state redundant properties that follow from the main part 10 of a specification. In Larch/C ++ , one can use an ensures redundantly clause to state procedure claims. <p> To use redundant postconditions in debugging a specification, for each such redundancy claim, one would try to prove the following, where Pre is the case's precondition, Frame is the predicate that translates its frame axioms, Post is its postcondition, and RedunPost is the claimed redundant postcondition <ref> [53, 52, 54] </ref> [32, Section 6.8]. (All of these should be in their desugared forms.) Pre ^ Frame ^ Post ) RedunPost (1) 5.2 Examples When we give problem statements to students, we observe that many students primarily focus on examples.
Reference: 55. <author> Alan Wills. </author> <title> Specification in Fresco. </title> <editor> In Stepney et al. </editor> <volume> [51], chapter 11, </volume> <pages> pages 127-135. </pages>
Reference-contexts: The idea is that a specification can be split into several cases, all of which must be satisfied by a correct implementation. This concept was independently reinvented by Wills <ref> [55] </ref>. Wills called specification cases "capsules", and used them effectively in OO specifications. In Larch/C ++ , specification cases are separated by the keyword also. Consider the example of Figure 3. This example shows a specification with two cases. <p> In addition to their potential use in debugging specifications, we have found that they can help make specifications clearer. We are also excited about their potential for automated testing [21]. Besides examples, the enhancement we use most often is case analysis [57, Section 4.1.4] <ref> [55] </ref>. This is helpful in stating specifications of procedures that may throw exceptions. However, since it is more general than a special-purposed notation for exceptions, it is also useful in breaking up the logic of a specification into more easily understood parts.
Reference: 56. <author> Jeannette M. Wing. </author> <title> Writing Larch interface language specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 1-24, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: VDM and Z both have features to permit the specification of frame axioms (write permissions in VDM, and in Z). In the Larch family, interface specifications languages have followed Wing's design for Larch/CLU <ref> [56] </ref> in using the modifies clause to say that only the objects listed may have their abstract values changed.
Reference: 57. <author> Jeannette Marie Wing. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: Its advantage over special-purpose notations for exceptions (as in LM3 [28, 22], to cite just one example) is that it is also useful for other kinds of case analysis This sugar was pioneered by Wing <ref> [57, Section 4.1.4] </ref>. The idea is that a specification can be split into several cases, all of which must be satisfied by a correct implementation. This concept was independently reinvented by Wills [55]. Wills called specification cases "capsules", and used them effectively in OO specifications. <p> In addition to their potential use in debugging specifications, we have found that they can help make specifications clearer. We are also excited about their potential for automated testing [21]. Besides examples, the enhancement we use most often is case analysis <ref> [57, Section 4.1.4] </ref> [55]. This is helpful in stating specifications of procedures that may throw exceptions. However, since it is more general than a special-purposed notation for exceptions, it is also useful in breaking up the logic of a specification into more easily understood parts.
Reference: 58. <author> Jim Woodcock and Jim Davies. </author> <title> Using Z: Specification, Refinement, and Proof. </title> <publisher> Prentice Hall International Series in Computer Science, </publisher> <year> 1996. </year> <month> 21 </month>
Reference-contexts: This technique forms the basis of most contemporary specification languages for sequential systems [1, 14, 15, 17, 22, 27, 30, 39, 38, 40, 41, 45, 48, 49]. (However, Z [23, 50] is an exception, as Z preconditions are not explicitly stated, but instead are calculated from the specification given <ref> [58, Chapter 14] </ref>.) We take as our starting point an excellent article by Jonkers [29], which, like this paper, is addressed to specification language designers.
References-found: 58

