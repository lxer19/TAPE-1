URL: http://www.cs.virginia.edu/~legion/documentation/Developer_entire.630.ps
Refering-URL: http://www.cs.virginia.edu/~legion/Documentation.html
Root-URL: http://www.cs.virginia.edu
Email: legion@virginia.edu  
Title: L  
Author: egion . D eveloper M anual 
Web: http://legion.virginia.edu/  
Address: Charlottesville, VA 22903  
Affiliation: The Legion Research Group Department of Computer Science University of Virginia  
Abstract-found: 0
Intro-found: 1
Reference: <institution> Several of the Legion-related papers listed in this bibliography are available on the Legion web site, at &lt;http://legion.virginia.edu/&gt;. </institution>
Reference: [1] <author> T.E. Anderson, D.E. Culler, D.A. Patterson, </author> <title> and the NOW team, A Case for NOW (Networks of Workstations), </title> <note> to appear in IEEE Micro </note> . 
Reference-contexts: Nexus [10] provides communication and resource management facilities for parallel language compilers. Castle [6] is a set of related projects that aims to support scientific applications, parallel languages and libraries, and low-level communication issues. The NOW <ref> [1] </ref> project provides a somewhat more unified strategy for managing networks of workstations, but is intended to scale only to hundreds of machines instead of millions. 2.5.6 Java In its intended application for distributed collaboration and information systems, Legion might be compared to the World Wide Web. <p> The correct way to unpack the data is shown in Example F (bottom). Example F Packing a LegionBuffer into another Legion Buffer. LegionBuffer hello_buf; char *hello = Hello; hello_buf.put_char (hello, 5); LegionBuffer world_buf; char *world = World; world_buf.put_char (world, 5); LegionBuffer hello_world_buf; hello_buf.pack (hello_world_buf); world_buf.pack (hello_world_buf); char hello_world <ref> [1] </ref>; hello_world [10] = /"0; // Rewind the buffer hello_world_buf.seek (BEGINNING, 0); // Try (unsuccessfully) to unpack all 10 characters // at once hello_world_buf.get_char (hello_world, 10); // Declare two separate LegionBuffers for unpacking // the two buffers that were packed into // hello_world_buf LegionBuffer out1, out2; // Rewind the buffer hello_world_buf.seek
Reference: [2] <author> Ben-Naten, Ron, </author> <title> CORBA: A Guide to the Common Object Request Broker Architecture , McGraw-Hill, </title> <year> 1995. </year>
Reference-contexts: It must be possible to integrate heterogeneous source-language application components in much the same manner that heterogeneous architectures are integrated. Interoperability requires that Legion support legacy codes, as well as work with emerging standards such as CORBA <ref> [2] </ref> and DCE [22]. 2.1.3 High performance via parallelism Legion supports easy-to-use parallel processing with large degrees of parallelism, including task and data parallelism and their arbitrary combinations. This does not mean that all applications will be parallelLegion will necessarily best support relatively course-grain applications. <p> However, a large body of relevant research in distributed systems, parallel computing, fault-tolerance, workstation farm management, and pioneering wide-area parallel processing projects provides a strong foundation for building a metacomputer. 2.5.1 DCE Related efforts such as OSF/DCE (Open Software Foundation/Distributed Computing Environment) [22] and CORBA (Common Object Request Broker Architecture) <ref> [2] </ref> are rapidly becoming industry standards. Legion and DCE share many of the same objectives, and draw upon the same heterogeneous distributed computing literature for inspiration. <p> In the case of the IDL, the programmer provides a class definition of the object, which lists the functions, type and number of any parameters, the objects state, etc.; a compiler generates the interface. This is a common technique, and is used in the OMG ORB <ref> [2] </ref>.
Reference: [3] <author> F. Berman, R. Wolski, S. Figueira, J. Schopf, and G. Shao, </author> <title> Application-Level Scheduling on Distributed Heterogeneous Networks, </title> <booktitle> Proceedings of Supercomputing '96 , November 1996. </booktitle>
Reference-contexts: to write into the // buffer char *in_string = "Hello World"; int in_int_array [5] = -100, 101, 102, 103, 104-; // Insert the string buffer.put_char (in_string, 11); // Insert the integers buffer.put_int (in_int_array, 5); // Insert a single char buffer.put_char (&in_string [6], 1); // Insert a single int buffer.put_int (&in_int_array <ref> [3] </ref>, 1); // "Rewind" the buffer back to the beginning so we // can read out the data we just wrote in buffer.seek (BEGINNING, 0); // Declare data structures to read the buffer data into July 9, 1998 Legion 1.2 Developer Manual Page 51 char out_string [12]; int out_int_array [5]; char <p> Note, though, that the placement process is guided by a set of restrictions determined by the class, such as a list of acceptable object implementations. For more details on the scheduling model see Karpovich [19]. For more information on application specific scheduling agents see Berman <ref> [3] </ref>. The placement process is performed by the class object itself or by an external agent, and returns the LOID of the chosen host object. The class must then ensure that the instance will be able to access its OPR when it runs on that host.
Reference: [4] <author> B. Bershad, et al, </author> <title> Extensibility, Safety, and Performance in the SPIN Operating System, </title> <booktitle> 15th Symposium on Operating System Principles , 1994. </booktitle>
Reference-contexts: (char *classid,short classid_len, char *instid,short instid_len, char *pubkey,short pubkey_len) - short *fld_sz; // Will carry the field sizes char **fld_val; // Will carry the field values UVaL_Reference&lt;LegionLOID&gt; loid; // Create new structures to fill in and pass to the // constructor fld_val = new (char *)<ref> [4] </ref>; fld_sz = new short [4]; // Field 0 : Domain fld_sz [LEGION_DOMAIN_FIELD] = UVaL_LegionDomain_Virginia_len; fld_val [LEGION_DOMAIN_FIELD] = UVaL_LegionDomain_Virginia; // Field 1 : Class ID fld_sz [CLASS_ID_FIELD] = classid_len; fld_val [CLASS_ID_FIELD] = classid; July 9, 1998 Legion 1.2 Developer Manual Page 48 // Field 2 : Instance ID fld_sz [INSTANCE_ID_FIELD] = instid_len; fld_val [INSTANCE_ID_FIELD] = instid;
Reference: [5] <author> R.H. </author> <title> Campbell and A.N. Habermann. The Specification of Process Synchronization by Path Expressions, </title> <booktitle> Lecture Notes in Computer Science , No. </booktitle> <volume> 16, </volume> <publisher> Springer Verlag, </publisher> <pages> 89-102, </pages> <year> 1973. </year>
Reference-contexts: the LegionPacker interface // Use the default constructor to declare a new empty // LegionBuffer, which will be configured to contain // the default storage, packer, encryptor, and // compressor LegionBuffer buffer; // Declare and initialize data to write into the // buffer char *in_string = "Hello World"; int in_int_array <ref> [5] </ref> = -100, 101, 102, 103, 104-; // Insert the string buffer.put_char (in_string, 11); // Insert the integers buffer.put_int (in_int_array, 5); // Insert a single char buffer.put_char (&in_string [6], 1); // Insert a single int buffer.put_int (&in_int_array [3], 1); // "Rewind" the buffer back to the beginning so we // can <p> (&in_int_array [3], 1); // "Rewind" the buffer back to the beginning so we // can read out the data we just wrote in buffer.seek (BEGINNING, 0); // Declare data structures to read the buffer data into July 9, 1998 Legion 1.2 Developer Manual Page 51 char out_string [12]; int out_int_array <ref> [5] </ref>; char out_char; int out_int; // Data must be read out in the same order it was put in, // but not necessarily the same way. // Read 1st 6 chars buffer.get_char (out_string, 6); // Read the next 5 for (j = 6; j &lt; 11; j++) // one at a <p> The active messages approach, on the other hand, allows any number of operations of all types to be active at the same time in the same object. A more general approach to customizing the concurrency control requirements of operations on an object can be designed based on path expressions <ref> [5] </ref>. Path expressions permit the programmer to specify: (1) sequencing constraints among operations; (2) selection (mutual exclusion) between operations; and (3) allowable concurrency between operations. These concurrency control primitives let programmers maintain the sequential consistency of their programs and at the same time indicate potential concurrency to a runtime environment.
Reference: [6] <institution> The Castle Project, University of California, Berkeley. </institution> <note> URL http://www.cs.berkeley.edu/projects/parallel/castle/castle.html </note>
Reference-contexts: It also does not address key issues such as security and site autonomy [30]. 2.5.5 Other projects Other projects share many of the same objectives, but not the scope of Legion. Nexus [10] provides communication and resource management facilities for parallel language compilers. Castle <ref> [6] </ref> is a set of related projects that aims to support scientific applications, parallel languages and libraries, and low-level communication issues. <p> // compressor LegionBuffer buffer; // Declare and initialize data to write into the // buffer char *in_string = "Hello World"; int in_int_array [5] = -100, 101, 102, 103, 104-; // Insert the string buffer.put_char (in_string, 11); // Insert the integers buffer.put_int (in_int_array, 5); // Insert a single char buffer.put_char (&in_string <ref> [6] </ref>, 1); // Insert a single int buffer.put_int (&in_int_array [3], 1); // "Rewind" the buffer back to the beginning so we // can read out the data we just wrote in buffer.seek (BEGINNING, 0); // Declare data structures to read the buffer data into July 9, 1998 Legion 1.2 Developer Manual
Reference: [7] <institution> Digital Equipment Corporation, Hewlett-Packard Company, HyperDesk Corporation, NCR Corporation, Object Design Inc., </institution> <note> SunSoft, </note> <author> Inc., </author> <title> The Common Object Request Broker: Architecture and Specification , OMG Document Number 93.xx.yy, Revision 1.2, </title> <type> Draft 29, </type> <month> December </month> <year> 1993. </year>
Reference-contexts: Class objects also export a set of class-mandatory member functions, such as createInstance () , activateInstance () , and deactivate-Instance11 () . Legion class interfaces can be described in an Interface Description Language (IDL). Initially, two different IDLs will be supported by Legion: the CORBA IDL <ref> [7] </ref>, and the Mentat Programming Language (MPL) [23]. Method calls are non-blocking and may be accepted in any order by the called object. Each method has a signature that describes the parameters and return value, if any, of the method.
Reference: [8] <author> A.J. Ferrari., M.J. Lewis, A. Nguyen-Tuong, and A. Grimshaw, </author> <title> The Legion runtime library, under construction </title> . 
Reference-contexts: In its most useful form Legion presents programmers with high-level programming language interfaces to the system. These high-level interfaces are supported by Legion-targeted compilers, which in turn use the services of a runtime library that enables Legion-compliant interobject communication. We have implemented a Legion runtime library (LRTL) <ref> [32, 8] </ref>, and we have ported the Mentat [11] programming language compiler (MPLC) to use the LRTL. * Thus, programmers can define Legion object implementations in MPL, which can be translated by MPLC to create executable objects that communicate with one another in a Legion-compliant fashion.
Reference: [9] <author> I. Foster, C. Kesselman, Globus: </author> <title> A Metacomputing Infrastructure Toolkit, </title> <note> International Journal of Supercomputing Applications . (to appear) </note>
Reference-contexts: But, like DCE, CORBA is based on a clientserver model, rather than a parallel computing model, and less emphasis is placed on issues such as object persistence, placement, and migration. 2.5.3 Globus The Globus project <ref> [9] </ref> at Argonne National Laboratory and the University of Southern California has similar goals, as well as a number of similar design features. Both systems also support a range of programming interfaces, including popular packages such as MPI. They differ significantly, however, in their basic architectural techniques and design principles.
Reference: [10] <author> I. Foster, Carl Kesselman, Steven Tuecke, </author> <title> Nexus, Runtime Support for Task-Parallel Programming Languages, </title> <institution> Argonne National Laboratories. </institution> <note> URL http://www.mcs.anl.gov/nexus/paper/ </note>
Reference-contexts: To our knowledge Globe does not offer an equivalent set of tools. It also does not address key issues such as security and site autonomy [30]. 2.5.5 Other projects Other projects share many of the same objectives, but not the scope of Legion. Nexus <ref> [10] </ref> provides communication and resource management facilities for parallel language compilers. Castle [6] is a set of related projects that aims to support scientific applications, parallel languages and libraries, and low-level communication issues. <p> Example F Packing a LegionBuffer into another Legion Buffer. LegionBuffer hello_buf; char *hello = Hello; hello_buf.put_char (hello, 5); LegionBuffer world_buf; char *world = World; world_buf.put_char (world, 5); LegionBuffer hello_world_buf; hello_buf.pack (hello_world_buf); world_buf.pack (hello_world_buf); char hello_world [1]; hello_world <ref> [10] </ref> = /"0; // Rewind the buffer hello_world_buf.seek (BEGINNING, 0); // Try (unsuccessfully) to unpack all 10 characters // at once hello_world_buf.get_char (hello_world, 10); // Declare two separate LegionBuffers for unpacking // the two buffers that were packed into // hello_world_buf LegionBuffer out1, out2; // Rewind the buffer hello_world_buf.seek (BEGINNING, 0); <p> at once hello_world_buf.get_char (hello_world, 10); // Declare two separate LegionBuffers for unpacking // the two buffers that were packed into // hello_world_buf LegionBuffer out1, out2; // Rewind the buffer hello_world_buf.seek (BEGINNING, 0); // Unpack hello_buf into out1 out1.unpack (hello_world_buf); // Unpack world_buf into out2 out2.unpack (hello_world_buf); char hello_world [11]; hello_world <ref> [10] </ref> = "0; // Unpack Hello out1.get_char (hello_world, 5); // Unpack World out2.get_char (&hello_world,[5], 5); July 9, 1998 Legion 1.2 Developer Manual Page 55 // This line will print HelloWorld printf (hello_world); LegionBuffers pack and unpack their bytes raw (without data format conversion), so that each buffer maintains its own meta-data.
Reference: [11] <author> A. S. Grimshaw, </author> <title> Easy-to-use objectoriented parallel processing with Mentat, </title> <journal> IEEE Computer , pp. </journal> <pages> 39-51, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Fortran code that will be used to implement Legion objects (i.e. Fortran code that will be called through a Legion member function interface) must be described by programmersupplied BFS IDL interfaces. These IDL interfaces are translated by the legion_bfs filter, which generates Mentat Programming Language (MPL) <ref> [11] </ref> skeleton code. This skeleton code is compiled using the legion_mplc compiler and linked to Fortran implementation code (see Figure 5). <p> These high-level interfaces are supported by Legion-targeted compilers, which in turn use the services of a runtime library that enables Legion-compliant interobject communication. We have implemented a Legion runtime library (LRTL) [32, 8], and we have ported the Mentat <ref> [11] </ref> programming language compiler (MPLC) to use the LRTL. * Thus, programmers can define Legion object implementations in MPL, which can be translated by MPLC to create executable objects that communicate with one another in a Legion-compliant fashion. <p> characters // at once hello_world_buf.get_char (hello_world, 10); // Declare two separate LegionBuffers for unpacking // the two buffers that were packed into // hello_world_buf LegionBuffer out1, out2; // Rewind the buffer hello_world_buf.seek (BEGINNING, 0); // Unpack hello_buf into out1 out1.unpack (hello_world_buf); // Unpack world_buf into out2 out2.unpack (hello_world_buf); char hello_world <ref> [11] </ref>; hello_world [10] = "0; // Unpack Hello out1.get_char (hello_world, 5); // Unpack World out2.get_char (&hello_world,[5], 5); July 9, 1998 Legion 1.2 Developer Manual Page 55 // This line will print HelloWorld printf (hello_world); LegionBuffers pack and unpack their bytes raw (without data format conversion), so that each buffer maintains its
Reference: [12] <author> A.S. Grimshaw, A.J. Ferrari, </author> <title> E.A. West, Mentat, from Parallel Programming Using C++ , pp. </title> <address> 383-427, </address> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1997 </year>
Reference-contexts: Organizations will not allow use of their machines if their operating systems must be replaced, their applications rewritten, and their users retrained. Our experience with Mentat <ref> [12] </ref> indicates that it is sufficient to layer a system on top of an existing hosts operating system. We cannot legislate changes to the interconnection network . We must assume that the network resources and the protocols currently used are established and will not be changed. <p> single int buffer.put_int (&in_int_array [3], 1); // "Rewind" the buffer back to the beginning so we // can read out the data we just wrote in buffer.seek (BEGINNING, 0); // Declare data structures to read the buffer data into July 9, 1998 Legion 1.2 Developer Manual Page 51 char out_string <ref> [12] </ref>; int out_int_array [5]; char out_char; int out_int; // Data must be read out in the same order it was put in, // but not necessarily the same way. // Read 1st 6 chars buffer.get_char (out_string, 6); // Read the next 5 for (j = 6; j &lt; 11; j++) //
Reference: [13] <author> Andrew S. Grimshaw, Jon Weissman, and W. Timothy Strayer. </author> <title> Portable RunTime Support for Dynamic ObjectOriented Parallel Processing, </title> <journal> ACM Transactions on Computer Systems , 14(2), </journal> <month> May </month> <year> 1996. </year>
Reference-contexts: The motivation for continuation lists arises from the macro data-flow programming model that is the initial Legion target. In this model, results from method invocations are sent directly to other invocations that use these results as parameters. These data dependencies are determined through analysis of the program code (see <ref> [13] </ref> for more information). LegionProgramGraphs are the representation of these data dependencies, and are described in section 7.3.5 on page 62. For further information, refer to the Legion online documentation at &lt;http://legion.virginia.edu/&gt;. The LegionMessage class implements Legion messages in the Library. <p> For example, the current Legion implementation contains an OA that consists of a single OA element. This element contains a 32-bit IP address and a 16-bit port number; every Legion object is linked with a Unix-sockets-based data delivery layer (called the Modular Message Passing System , or MMPS <ref> [13] </ref>) that communicates with the data delivery layers of other objects using these OA types. (See section 7.3 for more information on Legion message passing.) Format Class Identifier Instance Number Public Key 63533f3f96b2bba0572 aed8d47efec7c24618f ca3a3d49326fa84eaa3 20aced7458619497425 6ee86c2ae0565d55c8e July 9, 1998 Legion 1.2 Developer Manual Page 89 The address semantic field is
Reference: [14] <author> A.S. Grimshaw, E.A. West, and W.R. Pearson, </author> <title> No Pain and Gain!Experiences with Mentat on Biological Application, </title> <journal> Concurrency: Practice & Experience , pp. </journal> <pages> 309-328, </pages> <address> 5:4, </address> <month> June, </month> <year> 1993. </year> <month> July 9, </month> <note> 1998 Legion 1.2 Developer Manual Page 111 </note>
Reference-contexts: July 9, 1998 Legion 1.2 Developer Manual Page 12 For our demonstration, we exercised our utilities and ran one of our applications, complib, on the I-Way. Complib compares two DNA or protein sequence databases using one of several selectable algorithms <ref> [14] </ref>. The first database was located at ANL, while the second was located at NCSA. The application transparently accessed the databases using the Legion file system while the underlying system schedulers placed application computation objects throughout the threesite system. <p> The code in Example H builds a parameter list that contains two parameters, an integer, and a 14-element character string. Example H Use of LegionParameterList and LegionParameter // Declare the variables to be packed into a // parameter list int int_parameter; char string_parameter <ref> [14] </ref>; // Initialize the variables appropriately int_parameter = 7; sprintf (string_parameter,"Hello, World."); // Create a LegionBuffer to hold the integer parameter UVaL_Reference&lt;LegionBuffer&gt; lb1; lb1 = new LegionBuffer (); lb1-&gt;put_int (&int_parameter, 1); July 9, 1998 Legion 1.2 Developer Manual Page 57 // Create a LegionBuffer to hold the string parameter UVaL_Reference&lt;LegionBuffer&gt; lb2;
Reference: [15] <author> W. Gropp, E. Lusk, and A. Skjellum, </author> <title> Using MPI: Portable Parallel Programming with the Message Passing Interface , MIT Press, </title> <year> 1994. </year>
Reference: [16] <author> D. Kuck, D. Lawrie, R. Cytron, A. Sameh and D. Gajski, </author> <title> The Architecture and Programming of the Cedar System, Cedar Document no. </title> <type> 21, </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <month> August, </month> <year> 1983. </year>
Reference-contexts: This alternative, which we call Basic Fortran Support or BFS , is a compromise between full-fledged compiler support and essentially no support. The basic idea is simple and harks back to the pseudo-comments used in early parallelizing Fortran compilers such as Paraphrase <ref> [16] </ref>. Rather than creating an extended Fortran dialect that includes coarse-grain objects and attempting to parse and perform data-dependence analysis on Fortran programs, we provide a set of Legion directives that can be embedded in Fortran code in the form of pseudo-comment lines.
Reference: [17] <author> N.C. Hutchinson, L.L. Peterson. </author> <title> The x Kernel: An Architecture for Implementing Network Protocols, </title> <journal> IEEE Transactions on Software Engineering , 17(1): </journal> <pages> 64-76, </pages> <year> 1991. </year>
Reference-contexts: sometimes clients are servers and sometime servers are clients. 7.7.1 Implementing the configurable protocol stack: events As Figure 17 illustrates, the Legion protocol stack supports a variety of functions, in order to allow modules to be easily added and configured, an approach similar to that used in the x Kernel <ref> [17] </ref>. The problem with the traditional approach to building protocol stacks is that each layer in the stack explicitly calls the layer below or above. This static coupling makes it difficult to dynamically configure the stack.
Reference: [18] <institution> IBM, IBM LoadLeveler: </institution> <note> Users Guide (SH26-7226-02), </note> <institution> IBM Publication number ST00-9696, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: If the implementation is Java bytecode the host executes it within a Java Virtual Machine. In yet another case, if the host represents a workstation farm that is managed by a queueing system such as Condor [21] or LoadLeveler <ref> [18] </ref>, the host starts the object through the batch systems particular interface. Once the host activates the object, the host object passes the newly started object its LOID and new OPA. The host object determines the activated objects local OA, and returns it to the calling class object. <p> LoadLeveler <ref> [18] </ref>). Host object implementations provide a uniform interface to different resource management interfaces, as well as (more importantly) providing a means for users to enforce security and resource management policies for Legion objects.
Reference: [19] <author> J. Karpovich, </author> <title> Support for object placement in wide-area heterogeneous distributed systems, </title> <institution> University of Virginia Computer Science Technical Report CS-96-03, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: Note, though, that the placement process is guided by a set of restrictions determined by the class, such as a list of acceptable object implementations. For more details on the scheduling model see Karpovich <ref> [19] </ref>. For more information on application specific scheduling agents see Berman [3]. The placement process is performed by the class object itself or by an external agent, and returns the LOID of the chosen host object.
Reference: [20] <author> Michael Lewis, Andrew S. Grimshaw. </author> <title> The Core Legion Object Model, </title> <booktitle> Proceedings of the Fifth IEEE International Symposium on High Performance Distributed Computing, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <month> August, </month> <year> 1996. </year>
Reference-contexts: Here, a handler could be inserted to capture a message with certain desired function identifiers (i.e., a special message passing function identifier), and enqueue the message contents on a message queue for use by the message passing library. Message with other function identifiers (those associated with object mandatory methods <ref> [20] </ref>, for example) would be allowed to continue up the protocol stack and through the normal method invocation mechanism. In this scheme, the send () library operation would construct a LegionMessage object containing the message contents and reflecting the appropriate agreed upon function identifier.
Reference: [21] <author> M.J. Litzkow, M. Livny, and M.W. </author> <title> Mutka, CondorA Hunter of Idle Workstations, </title> <booktitle> Proceedings of the Eighth International Conference on Distributed Computing Systems , 1988, </booktitle> <pages> pp. 104-111. </pages>
Reference-contexts: If the implementation is Java bytecode the host executes it within a Java Virtual Machine. In yet another case, if the host represents a workstation farm that is managed by a queueing system such as Condor <ref> [21] </ref> or LoadLeveler [18], the host starts the object through the batch systems particular interface. Once the host activates the object, the host object passes the newly started object its LOID and new OPA.
Reference: [22] <author> H.W. Lockhart, Jr., </author> <title> OSF DCE Guide to Developing Distributed Applications , McGraw-Hill, </title> <publisher> Inc., </publisher> <address> New York, </address> <year> 1994. </year>
Reference-contexts: It must be possible to integrate heterogeneous source-language application components in much the same manner that heterogeneous architectures are integrated. Interoperability requires that Legion support legacy codes, as well as work with emerging standards such as CORBA [2] and DCE <ref> [22] </ref>. 2.1.3 High performance via parallelism Legion supports easy-to-use parallel processing with large degrees of parallelism, including task and data parallelism and their arbitrary combinations. This does not mean that all applications will be parallelLegion will necessarily best support relatively course-grain applications. <p> However, a large body of relevant research in distributed systems, parallel computing, fault-tolerance, workstation farm management, and pioneering wide-area parallel processing projects provides a strong foundation for building a metacomputer. 2.5.1 DCE Related efforts such as OSF/DCE (Open Software Foundation/Distributed Computing Environment) <ref> [22] </ref> and CORBA (Common Object Request Broker Architecture) [2] are rapidly becoming industry standards. Legion and DCE share many of the same objectives, and draw upon the same heterogeneous distributed computing literature for inspiration.
Reference: [23] <institution> The Mentat Research Group, Mentat 2.8 Programming Language Reference Manual , Department of Computer Science, University of Virginia, </institution> <year> 1995. </year>
Reference-contexts: Legion class interfaces can be described in an Interface Description Language (IDL). Initially, two different IDLs will be supported by Legion: the CORBA IDL [7], and the Mentat Programming Language (MPL) <ref> [23] </ref>. Method calls are non-blocking and may be accepted in any order by the called object. Each method has a signature that describes the parameters and return value, if any, of the method.
Reference: [24] <author> G.C. Necula, </author> <title> Proof-Carrying Code, </title> <booktitle> Proceedings of the 24th ACM Symposium on Principles of Programming Languages , pp. </booktitle> <pages> 106-119, </pages> <month> Jan 15-17, </month> <year> 1997. </year>
Reference-contexts: User authentication can be performed using any means desired. Host objects can also restrict access based on code characteristics. For example, a host might be configured to accept only object implementations containing proof-carrying code <ref> [24] </ref> that demonstrates certain desired security properties. A less formally restrictive host might analyze incoming object implementations for certain restricted system calls. We now consider a sample host object implementation (our default current host object) and two possible alternative implementations.
Reference: [25] <author> Anh Nguyen-Tuong, Andrew S. Grimshaw, </author> <title> Building Robust Distributed Applications with Reflective Transformations, </title> <institution> University of Virginia Computer Science Technical Report TR-CS-97-26 , Nov. </institution> <year> 1997. </year>
Reference-contexts: Examples of the latter policy would be to propagate all security exceptions to a Security Monitor object or propagate all Communication errors to a Fault Detector object. For a detailed description of various policies please refer to Building Robust Distributed Applications with Reflective Transformations <ref> [25] </ref>. 7.5.1 Standard exception propagation policy The Legion Library comes with default functions for the common case in which users want to propagate exceptions back to the caller. To raise an exception, users must first create an instance of LegionException . <p> Most of the Legion command line utilities use (1). Interested readers may find an application of the Legion exception propagation model in the standard Legion distribution in the Legion/src/Examples directory. Furthermore, more complex policies are possible and are described in Building Robust Distributed Applications with Reflective Transformations <ref> [25] </ref>. 7.6 How to use the runtime library This section describes how to use the Library as is, with no internal modification. We begin by describing the class LegionLibraryState , which encapsulates startup and initialization routines, and provides a public interface to an objects Legion related state.
Reference: [26] <author> B. Stroustrup, </author> <title> The C++ Programming Language , Addison-Wesley Publishing Company, </title> <address> Reading, Massachusetts, 2nd Edition, </address> <year> 1991. </year>
Reference-contexts: a class. applied to (a) sequential codes and (b) parallel codes Interface Manager Executable Code (Fortran, Ada, C, etc.) Interface Manager SIMD & MIMD code (a) function calls July 9, 1998 Legion 1.2 Developer Manual Page 15 Languages 3.0 Mentat The Mentat Programming Language (MPL) is an extension of C++ <ref> [26] </ref> and is designed to simplify, via parallelism encapsulation, the task of writing parallel applications. Parallelism encapsulation takes two forms, intra-object encapsulation and inter-object encapsulation.
Reference: [27] <author> Sun Microsystems, </author> <title> The Java Language Specification, Version 1.0 Beta, </title> <month> October 30, </month> <year> 1995. </year>
Reference-contexts: In particular, the objectoriented, secure, platform-independent, remote execution model afforded by the Java language <ref> [27] </ref> has added more Legion-like capabilities to the Web.
Reference: [28] <author> V.S. Sunderam, </author> <title> PVM: A framework for parallel distributed computing, </title> <journal> Concurrency: Practice and Experience , vol. </journal> <volume> 2(4), </volume> <pages> pp. 315-339, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: In this section, we examine the ways in which the Legion library can be configured to support a message passing model. We describe how Legion can be used as runtime support to implement a message-passing interface such as MPI [15]or PVM <ref> [28] </ref> (see page 42 for information about the Legion PVM library and page 45 for information about the Legion MPI library in the Basic User Manual). These systems allow asynchronous send and receive operations.
Reference: [29] <author> M. van Steen, P. Homburg, L. van Doorn, A.S. Tanenbaum, and W. de Jonge. </author> <title> Towards Object-based Wide Area Distributed Systems. </title> <editor> In L.-F. Carbrera and M. Theimer, (eds), </editor> <booktitle> Proceedings International Workshop on Object Orientations in Operating Systems , pp. </booktitle> <pages> 24-227, </pages> <institution> Lund, Sweden, </institution> <month> August, </month> <year> 1995. </year>
Reference-contexts: Essentially, Legion feels that the short-term advantages of patching existing parallel and distributed computing services together do not outweigh the long-term necessity of constructing a metacomputing software system on an extensible design made up of orthogonal building blocks. 2.5.4 Globe The Globe <ref> [29] </ref> project, developed at Vrije Univeriteit, Netherlands, also shares many goals and attributes with Legion.
Reference: [30] <author> M. van Steen, P. Homburg, </author> <title> A.S. Tanenbaum, The Architectural Design of Globe: A Wide-Area Distributed System, </title> <type> Internal report IR-422, </type> <institution> Vrije Universiteit, </institution> <month> March, </month> <year> 1997. </year>
Reference-contexts: Legion also has a set of core object types that are designed to provide abstractions for a wide variety of implementations. To our knowledge Globe does not offer an equivalent set of tools. It also does not address key issues such as security and site autonomy <ref> [30] </ref>. 2.5.5 Other projects Other projects share many of the same objectives, but not the scope of Legion. Nexus [10] provides communication and resource management facilities for parallel language compilers.
Reference: [31] <author> Thornsten von Eicken, David E. Culler, Seth C. Goldstein, and Klaus E. Schaser. </author> <title> Active Messages: A Mechanism for Integrated Communication and Computation, </title> <booktitle> Proceedings of the International Symposium on Computer Architecture , 256-266, </booktitle> <month> May, </month> <year> 1992. </year> <month> July 9, </month> <note> 1998 Legion 1.2 Developer Manual Page 112 </note>
Reference-contexts: These ordering constraints are realized by registering encyprtionHandler () with a high priority number and decryptionHandler () with a low priority number. The new protocol stack is shown in Figure 18. 7.7.6 Active messages The active messages programming model <ref> [31] </ref> is a message passing scheme that is intended to integrate communication and computation in order to increase the compute/communicate overlap, thereby masking the latency of message passing and Transport Level Communication Protocol Data Delivery Legion Message Program Graph Data Delivery Legion Message Message Database Sender Receiver Security:Encryption Security:Decryption July 9,
Reference: [32] <author> C.L. Viles, M.J.Lewis, A.J Ferrari, A. Nguyen-Tuong, </author> <title> and A.S. Grimshaw, Enabling flexibility in the Legion runtime library, </title> <booktitle> Proceedings of the International Conference on Parallel and Distributed Processing Techniques and Applications (PDPTA97) , pp. </booktitle> <pages> 265-274. </pages> <address> Las Vegas, Nevada, </address> <month> June 30 July 2, </month> <year> 1997. </year>
Reference-contexts: In its most useful form Legion presents programmers with high-level programming language interfaces to the system. These high-level interfaces are supported by Legion-targeted compilers, which in turn use the services of a runtime library that enables Legion-compliant interobject communication. We have implemented a Legion runtime library (LRTL) <ref> [32, 8] </ref>, and we have ported the Mentat [11] programming language compiler (MPLC) to use the LRTL. * Thus, programmers can define Legion object implementations in MPL, which can be translated by MPLC to create executable objects that communicate with one another in a Legion-compliant fashion. <p> The compiler generates code to organize the integer argument, constructing a simple macro data-flow program graph <ref> [32] </ref> representing the function call, then translating the graph into a Legion message, and retrieving the return value and placing it in the return_value variable.
Reference: [33] <author> William A. Wulf, Chenxi Wang, Darrell Kienzel, </author> <title> A New Model of Security for Distributed Systems, </title> <institution> University of Virginia, Department of Computer Science Technical Report CS-95-34 , August, </institution> <year> 1995. </year>
Reference-contexts: Such an application might instead choose a lightweight policy that merely verifies communication integrity or perhaps one with no security at all. Users decide what tradeoffs to make, whether by implementing their own policies or using existing policies via inheritance <ref> [33] </ref>, instead of coping with an inevitably unsatisfactory fixed security mechanism. Next, consider the problem of maintaining consistent semantics in a distributed file system. To achieve good performance, it is often desirable to copy all or part of a file. <p> The security handler LegionEvent_ Can_I may disallow the remote method invocation <ref> [33] </ref>. If it doesnt, a following handler generates a LegionEvent_MessageSend event for each method invocation. Once the message has been successfully sent, the data delivery layer generates a LegionEvent_MessageComplete event. On the receiving side, the data delivery layer will generate a LegionEvent_MessageReceive once it has successfully assembled a complete message. <p> The LegionDefaultMessageHandler is the last handler for the event LegionEvent_MessageReceive and generates a LegionEvent_MethodReceive , once the invocation matcher has assembled a complete method invocation. The first handler for LegionEvent_ MethodReceive is a security handler, and it implements access control on this object <ref> [33] </ref>.
Reference: [34] <author> P.-C.Yew, N.-F. Tzeng, and D.H. Lawrie, </author> <title> Distributing Hot-Spot Addressing in Large-Scale Multiprocessors, </title> <journal> IEEE Transactions on Computers , Vol. </journal> <volume> C-36(4), </volume> <month> April </month> <year> 1987. </year>
Reference-contexts: In addition to these strategies in which binding agents act essentially autonomously, many binding agents can be configured to cooperate with one another to serve their clients. For instance, binding agents could be organized hierarchically, as DNS name servers are, or could emulate a software combining tree <ref> [34] </ref>, thereby sharing the responsibility for providing bindings and improving the mechanism for scaling to the millions of objects the system will need to support.

References-found: 35

