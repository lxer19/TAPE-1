URL: ftp://ftp.eecs.umich.edu/groups/gasm/eam.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: fgiusp,glaesserg@uni-paderborn.de  igor@uni-paderborn.de  
Phone: 2  
Title: An Evolving Algebra Abstract Machine  
Author: Giuseppe Del Castillo Igor D urd -anovic Uwe Glasser 
Address: Furstenallee 11, 33102 Paderborn, Germany,  Warburger Str. 100, 33098 Paderborn, Germany,  
Affiliation: 1 Heinz Nixdorf Institut, Universitat-GH Paderborn,  FB Mathematik-Informatik, Universitat-GH Paderborn,  
Abstract: Evolving algebras (EAs) as defined by Yuri Gurevich constitute the basis of a powerful and elegant specification and verification method which has successfully been applied to the design and analysis of various kinds of discrete dynamic systems. Aiming at the development of a comprehensive EA-based specification and design environment, we introduce the concept of an evolving algebra abstract machine (EAM ) as a platform for the systematic development of EA tools; for instance, as required for machine based analysis and execution of EA specifications. We give a formal definition of the EAM ground model in terms of a universal evolving algebra, where we validate the correctness of the relation between evolving algebras (their theoretical foundations) and their EAM representation and interpretation. Our approach covers sequential as well as distributed evolving algebras.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Bernhard Beckert and Joachim Posegga. </author> <title> lean EA: A poor's man's evolving algebra compiler. </title> <type> Internal Report 25/95, </type> <institution> Fakultat fur Informatik, Universitat Karlsruhe, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: A Prolog interpreter was developed by Angelika Kappel at the Computer Science Department of Dortmund University [15]. At the Computer Science Department of Karlsruhe University, Bernhard Beckert and Joachim Posegga have implemented a compiler to Prolog for a special subset of evolving algebras, which they call lean EA <ref> [1] </ref>. An interpreter in Scheme was developed by Dag Diesen at the Department of Informatics, University of Oslo [9].
Reference: 2. <author> Andreas Blass and Yuri Gurevich. </author> <title> Evolving Algebras and Linear Time Hierarchy. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> Proc. of the IFIP 13th World Computer Congress 1994, Volume I: Technology and Foundations, </booktitle> <publisher> Elsevier Science Publishers B. V., </publisher> <year> 1994, </year> <pages> pp. 383-390. </pages>
Reference-contexts: With exception of RESERVE , all function names in 0 are treated as static names. 2. A second (possibly empty) part of the initial state S 0 is explicitly specified through initial state definitions belonging to a set of function definitions D provided by the user. 10 In <ref> [2] </ref>, Blass and Gurevich used the model of a universal evolving algebra for complexity theoretic considerations. <p> (see the discussion of the Collect rule above): FireUpdates var hhloc; val i; agent i ranges over UPDATE SET if agent = Self then cont (loc) : = val UPDATE SET (hhloc; val i; agent i) : = false 4 Related Work Closely related to the work presented here is <ref> [2] </ref>, which presents a universal evolving algebra for sequential deterministic evolving algebras (without variables). Also related to our work are various developments of EA interpreters.
Reference: 3. <author> Egon Borger. </author> <title> Annotated bibliography on evolving algebras. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Evolving algebras have been used with considerable success for the specification and verification of various kinds of discrete dynamic systems including architectures, languages, and protocols of sequential, distributed, and real-time systems (see <ref> [3, 4, 5] </ref> for a comprehensive overview on EA-related work) 3 . From a pragmatic point of view, however, a specification methodology does not meet the requirements imposed by complex systems engineering and design tasks, as long as there is no appropriate tool support.
Reference: 4. <editor> Egon Borger, editor. </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Evolving algebras have been used with considerable success for the specification and verification of various kinds of discrete dynamic systems including architectures, languages, and protocols of sequential, distributed, and real-time systems (see <ref> [3, 4, 5] </ref> for a comprehensive overview on EA-related work) 3 . From a pragmatic point of view, however, a specification methodology does not meet the requirements imposed by complex systems engineering and design tasks, as long as there is no appropriate tool support.
Reference: 5. <author> Egon Borger. </author> <title> On the use of evolving algebras for hardware and software engineering. </title> <note> In Proc. of SOFSEM'95 (Nov. 25 - Dec. 2, 1995, Bratislava, Czech Republic). To appear in LNCS. </note>
Reference-contexts: of evolving algebra (EA) as introduced by Yuri Gurevich in [13, 14] constitutes a powerful and elegant concept of mathematical modelling of discrete dynamic systems: it provides an expressive means to specify the operational semantics of a system at a natural abstraction level in a direct and essentially coding-free manner <ref> [7, 5] </ref>. Evolving algebras have been used with considerable success for the specification and verification of various kinds of discrete dynamic systems including architectures, languages, and protocols of sequential, distributed, and real-time systems (see [3, 4, 5] for a comprehensive overview on EA-related work) 3 . <p> Evolving algebras have been used with considerable success for the specification and verification of various kinds of discrete dynamic systems including architectures, languages, and protocols of sequential, distributed, and real-time systems (see <ref> [3, 4, 5] </ref> for a comprehensive overview on EA-related work) 3 . From a pragmatic point of view, however, a specification methodology does not meet the requirements imposed by complex systems engineering and design tasks, as long as there is no appropriate tool support. <p> The ground model reflects our intuitions about the basic objects and basic operations of S in such a way that we are able to establish its correctness versus our understanding of S (for further detail see <ref> [5] </ref>). To refer to the interpretation of a ground term t in S, we write S (t). <p> Finally, there are also functions which are externally and internally alterable at the same time. Such functions are not considered here. For further details see on the classification of functions see <ref> [5] </ref>. Note also that, in the new classification of [5], the external functions defined by the Lipari Guide correspond to externally alterable oracle functions: we use both terms interchangeably in this paper. 13 We do not consider here the specification and representation of user-defined domains. <p> Finally, there are also functions which are externally and internally alterable at the same time. Such functions are not considered here. For further details see on the classification of functions see <ref> [5] </ref>. Note also that, in the new classification of [5], the external functions defined by the Lipari Guide correspond to externally alterable oracle functions: we use both terms interchangeably in this paper. 13 We do not consider here the specification and representation of user-defined domains.
Reference: 6. <author> Egon Borger and Igor D - urd -anovic. </author> <title> Correctness of compiling Occam to Transputer code. </title> <journal> Computer Journal, </journal> <note> to appear. </note>
Reference: 7. <author> Egon Borger and Uwe Glasser. </author> <title> Modelling and analysis of distributed and reactive systems using evolving algebras. </title> <type> Technical Report NS-95-4, BRICS, </type> <month> July </month> <year> 1995. </year>
Reference-contexts: of evolving algebra (EA) as introduced by Yuri Gurevich in [13, 14] constitutes a powerful and elegant concept of mathematical modelling of discrete dynamic systems: it provides an expressive means to specify the operational semantics of a system at a natural abstraction level in a direct and essentially coding-free manner <ref> [7, 5] </ref>. Evolving algebras have been used with considerable success for the specification and verification of various kinds of discrete dynamic systems including architectures, languages, and protocols of sequential, distributed, and real-time systems (see [3, 4, 5] for a comprehensive overview on EA-related work) 3 .
Reference: 8. <author> G. Del Castillo, I. D - urd -anovic and U. Glasser. </author> <title> Specification and Design of the EAM (EAM Evolving Algebra Abstract Machine). </title> <type> Technical Report tr-rsfb-96-003, </type> <institution> Paderborn University. </institution>
Reference-contexts: If the initial state S 0 of the EAM satisfies the Assumption 2, then S 0 and the EAM-state S 0 (resulting from the encoding of the user specification into the EAM) are equivalent. Proof. By induction on the structure of terms (see <ref> [8] </ref>). 2.4 The Metainterpreter The last step of the EAM construction is the definition of an evolving algebra program (the metainterpreter ) which|given the EAM-encoding of the user specification|simulates the execution of the user program. <p> Proof. By choosing g such that S g (0) ; S g (1) ; S g (2) ; : : : is the sequence of all signif-icant states reached by the EAM during its computation (see <ref> [8] </ref> for details). 3 Execution of Distributed Evolving Algebras So far we have considered the case of single-agent evolving algebras.
Reference: 9. <author> Dag Diesen. </author> <title> Specifying Algorithms using Evolving Algebra. Implementation of Functional Programming Languages. </title> <type> Research Report 199, </type> <institution> Department of Infor-matics, University of Oslo, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: At the Computer Science Department of Karlsruhe University, Bernhard Beckert and Joachim Posegga have implemented a compiler to Prolog for a special subset of evolving algebras, which they call lean EA [1]. An interpreter in Scheme was developed by Dag Diesen at the Department of Informatics, University of Oslo <ref> [9] </ref>.
Reference: 10. <editor> H. Ehrig and B. Mahr, editors. </editor> <title> Fundamentals of Algebraic Specification 1 Equations and Initial Semantics. </title> <booktitle> EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference: 11. <editor> L.M.G. Feijs and H.B.M. Jonkers, editors. </editor> <booktitle> Formal Specification and Design. Cam-bridge Tracts in Theoretical Computer Science 35. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: On the other hand, every implementable model of evolving algebras must restrict to some concrete and a priori specified notation for defining domains and functions. There are well known examples showing us how this could be done; algebraic specification languages, like COLD-K <ref> [11] </ref> for instance, suggest to have at least the following two options: constructive definitions, which uniquely characterize a domain or function in terms of other domains or functions, and axiomatic definitions, which introduce a domain or function that is characterized (not necessarily in a unique way) through axioms.
Reference: 12. <author> R.W. Gray, V.P. Heuring, St.P. Levi, A.M. Sloane, W.M. Waite, Eli: </author> <title> A Complete, Flexible Compiler Construction System. </title> <journal> Communications of the ACM, </journal> <note> Februar 1992, 121ff. </note>
Reference-contexts: As a first step in this direction some EAM-based tools are currently being developed, namely: (i) a parser/preprocessor, implemented using the compiler tool system Eli <ref> [12, 16] </ref>, which produces the abstract syntax trees described in Sect. 2.2 from an EA specification in textual form; (ii) various tools for processing EA specifications in abstract syntax tree form, written in Standard ML [17], including a code generator producing C++ code corresponding to the EAM 1 model (not described
Reference: 13. <author> Yuri Gurevich. </author> <title> Evolving algebras a tutorial introduction. </title> <journal> Bulletin of the EATCS, </journal> (43):264-284, February 1991. 
Reference-contexts: Introduction The notion of evolving algebra (EA) as introduced by Yuri Gurevich in <ref> [13, 14] </ref> constitutes a powerful and elegant concept of mathematical modelling of discrete dynamic systems: it provides an expressive means to specify the operational semantics of a system at a natural abstraction level in a direct and essentially coding-free manner [7, 5].
Reference: 14. <author> Yuri Gurevich. </author> <title> Evolving Algebras 1993: Lipari Guide. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Introduction The notion of evolving algebra (EA) as introduced by Yuri Gurevich in <ref> [13, 14] </ref> constitutes a powerful and elegant concept of mathematical modelling of discrete dynamic systems: it provides an expressive means to specify the operational semantics of a system at a natural abstraction level in a direct and essentially coding-free manner [7, 5]. <p> Readers who are familiar with the subject may skip Sects. 1.2 and 1.3. For an exhaustive definition of evolving algebras, however, we refer to the Lipari Guide <ref> [14] </ref>. 1.1 Notational Conventions Function and relation names other than names of unary relations are written in small italic letters; unary relation names denote universes (or domains) and are written in capital italic letters. <p> Then, for import rules, the update set Updates (R; S; ; ~) will be defined as follows: 8 Note that rules can always be transformed into this form by appropriately renaming the variables (as explained in <ref> [14] </ref>). <p> a preprocessing step. if R import v R 0 endimport, then Updates (R; S; ; ~) = f ((RESERVE ; (~(v))); false) g [ Updates (R 0 ; S; [v 7! ~(v)]; ~); Note that, due to the special properties of the reserve (which is essentially a set without structure|see <ref> [14] </ref> for details), the choice of ~ is irrelevant: in fact, in the presence of import rules, the computed states are unique up to isomorphism. <p> this section we show how the EAM 0 model can be extended, in a simple and elegant way, to simulate multiple-agent evolving algebras as well. 3.1 Distributed Evolving Algebras We recall here, for the convenience of the reader, the basic ideas and definitions of distributed evolving algebras, as given by <ref> [14] </ref> (to which we refer for a more extensive discussion) up to slight notational changes. We also restrict here to the deterministic case (i.e., distributed evolving algebras without external functions or choose constructs).
Reference: 15. <author> A.M. Kappel. </author> <title> Executable specifications based on dynamic algebras. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Logic Programming and Automated Reasoning, volume 698 of LNAI, </booktitle> <pages> pages 229-240. </pages> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: An improved interpreter based on this one, which can also handle distributed EA programs, is currently being developed at the University of Michigan by Raghu Mani. A Prolog interpreter was developed by Angelika Kappel at the Computer Science Department of Dortmund University <ref> [15] </ref>. At the Computer Science Department of Karlsruhe University, Bernhard Beckert and Joachim Posegga have implemented a compiler to Prolog for a special subset of evolving algebras, which they call lean EA [1].
Reference: 16. <author> U. Kastens, W.M. Waite. </author> <title> Modularity and Reusability in Attribute Grammars. </title> <booktitle> Universitat-GH Paderborn, Reihe Informatik, Bericht Nr. </booktitle> <volume> 102, </volume> <month> Juli </month> <year> 1992. </year>
Reference-contexts: As a first step in this direction some EAM-based tools are currently being developed, namely: (i) a parser/preprocessor, implemented using the compiler tool system Eli <ref> [12, 16] </ref>, which produces the abstract syntax trees described in Sect. 2.2 from an EA specification in textual form; (ii) various tools for processing EA specifications in abstract syntax tree form, written in Standard ML [17], including a code generator producing C++ code corresponding to the EAM 1 model (not described
Reference: 17. <author> R. Milner, M. Tofte and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: are currently being developed, namely: (i) a parser/preprocessor, implemented using the compiler tool system Eli [12, 16], which produces the abstract syntax trees described in Sect. 2.2 from an EA specification in textual form; (ii) various tools for processing EA specifications in abstract syntax tree form, written in Standard ML <ref> [17] </ref>, including a code generator producing C++ code corresponding to the EAM 1 model (not described in this paper); (iii) a C++ kernel implementing the EAM 1 model, which efficiently executes the EAM 1 code produced by the code generator.
Reference: 18. <author> Martin Wirsing. </author> <title> Algebraic specifications. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science B, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
References-found: 18

