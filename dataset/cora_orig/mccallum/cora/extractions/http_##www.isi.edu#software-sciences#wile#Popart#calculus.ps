URL: http://www.isi.edu/software-sciences/wile/Popart/calculus.ps
Refering-URL: http://www.isi.edu/software-sciences/wile/Popart/popart.html
Root-URL: http://www.isi.edu
Email: wile@isi.edu  
Title: TOWARD A CALCULUS FOR ABSTRACT SYNTAX TREES  
Author: David S. Wile 
Keyword: Metaprogramming, programming calculus, transformations, abstract syntax trees  
Note: [To appear in Proceedings of a Working Conference on Algorithmic Languages and Calculi, IFIP Working Group 2.1, February, 1997, Strasbourg, France, (without appendix).] Support for this provided under DARPA contract number F30602-93-C-0240 and F3062-96-2-0224.  
Address: 4676 Admiralty Way Marina del Rey, CA 90292  
Affiliation: University of Southern California Information Sciences Institute  
Abstract: Metaprogramming writing programs that manipulate programs as data requires a formal foundation in order that people be able to reason about the effects of their metaprograms. Of equal importance, metaprogramming requires an intuitive foundation that facilitates most frequent, natural manipulations of programs as data. In the past, the program transformation community has characterized well means for expressing pattern-matching and individual transformations. This report concentrates on developing a calculus for characterizing transformation application by providing operators on abstract syntax trees and studying their relationships . The work builds directly on the Theory of Lists developed by Meertens and Bird and an extension to the Theory of Binary Labeled Trees developed by Gibbons. Although the foundations for the theory lie in category theory, the presentation should be accessible to a wide audience interested in program manipulation systems. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Bird, </author> <title> R.S. (1987) An introduction to the Theory of Lists. in Logic of Programming and Calculi of Discrete Design (ed. </title> <editor> M. Broy), </editor> <publisher> Springer-Verlag, </publisher> <pages> 3-42. </pages>
Reference-contexts: Tricks like making the first subtree be a leaf node carrying the type, or pairing trees and subsequences, etc., would destroy the beauty of the reduction operators applied to the trees. However, Meertens' development is most like the present, much in the spirit of the Theory of Lists <ref> (Bird, 1987) </ref>. His work has many more theorems and goes on to great depths in categorizing how trees can be evaluated in different orders, etc. The present work must be reexamined page-by-page for insights and crossover theorems.
Reference: <author> Donzeau-Gouge, V., Kahn, G., Lang, B., and Mlse, B. </author> <title> (1984) Document structure and modularity in Mentor. </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Symposium on Practical Software Development Environments, </booktitle> <pages> 141-148. </pages>
Reference: <author> Gibbons, J. </author> <title> (1991) Algebras for Tree Algorithms . Ph.D. </title> <type> Thesis, </type> <institution> Programming Research Group, Oxford University. </institution>
Reference: <author> Gibbons, J. </author> <booktitle> (1993) Upwards and downwards accumulations on trees. in LNCS 669 : Mathematics of Program Construction (eds. </booktitle> <editor> R. S. Bird, C. C. Morgan, and J. C. P. Woodcock), </editor> <publisher> Springer-Verlag, </publisher> <pages> 122-138. </pages>
Reference: <author> Gibbons, J. </author> <title> (1994) An initial-algebra approach to directed acyclic graphs. in Mathematics of Program Construction, </title> <editor> ed. B. Mller, </editor> <publisher> LNCS 947, Springer-Verlag. </publisher> <pages> 122-138. </pages>
Reference: <author> Goldman, N. M. </author> <title> (1989) Code walking and recursive descent: a generic approach. </title> <booktitle> in Lisp and Functional Programming Conference. </booktitle>
Reference-contexts: One hopes that the incremental update analysis will have analogs in the metaprogramming calculus. Many other relationships exist, e.g. with Lieberherr's (1995) adaptive programming methodology, where implicit paths replace the various mapping operators defined here. Code walking techniques are also relevant <ref> (Goldman, 1989) </ref>, especially as targets for compilation of the metaprogramming calculus. CONCLUSIONS The foundations for a calculus for metaprogramming will include a calculus for pattern matching and primitive transformation as well as a calculus for transformation application.
Reference: <author> Heckmann, R. </author> <title> (1988) A functional language for the specification of complex tree transformations. </title> <booktitle> in Proceedings of the 2nd European Symposium on Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <pages> 175-190. </pages>
Reference-contexts: For example, his Extend operator is a flat version of the splicing operator presented here. His mechanism for applying transformations is quite rudimentary, despite the rather well-developed pattern language presented in <ref> ( Heckmann, 1988) </ref>. In fact, neither Heckman, nor Huet and Lang, nor Paulson, focus on the recursive structure of transformation application that is featured in the calculus here.
Reference: <author> Hudak, P., Jones, S. P., and Wadler, P. </author> <title> (1992) Report on the programming language Haskell. </title> <institution> Yale Computer Science report YALEU/DCS/RR-777. </institution>
Reference: <author> Huet, G. and Lang, B. </author> <title> (1978) Proving and applying program transformations expressed with second-order patterns. </title> <note> Acta Informatica 11(1) . 31-55. </note>
Reference: <author> Jeuring, J., and Swierstra, S. D. </author> <title> (1995) Constructing functional programs for grammar analysis problems. </title> <booktitle> in Proceedings of a Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> La Jolla, CA, USA, </address> <pages> 259-269. </pages>
Reference: <author> Jones, G. and Gibbons, J. </author> <title> (1993) Linear-time breadth-first tree algorithms: an exercise in the arithmetic of folds and zips. IFIP Working Group 2.1 working paper 705: </title> <type> WIN 2, </type> <institution> University of Auckland Computer Science Report No. </institution> <month> 71. </month>
Reference: <author> Kibler, D. </author> <title> (1978) Power, Efficiency, and Correctness of Transformation Systems . Ph.D. </title> <type> Thesis. </type> <institution> University of California, Irvine. </institution>
Reference: <author> Lieberherr, K. </author> <title> (1995) Adaptive ObjectOriented Software: the Demeter Method with Propagation Patterns. </title> <publisher> PWS Publishing Company, </publisher> <address> Boston. </address>
Reference: <author> Malcolm, G. </author> <booktitle> (1990) Data structures and program transformation . Science of Computer Programming 14 . 255-280. </booktitle>
Reference: <author> Meertens, L. </author> <title> (1988) First steps toward the theory of rose trees. </title> <booktitle> IFIP Working Group 2.1 working paper 592: ROM 25, </booktitle> <publisher> CWI, Amsterdam. </publisher>
Reference: <author> Meertens, L. </author> <year> (1992) </year> <month> Paramorphisms. </month> <note> In Formal Aspects of Computing 4 . 413-425. 26 Paulson, </note> <author> L. </author> <title> (1983) A higher-order implementation of rewriting. </title> <booktitle> in Science of Computer Programming 3, </booktitle> <pages> 119-149. </pages>
Reference: <author> Reps, T. </author> <title> (1982) Optimal-time incremental semantic analysis for syntax-directed editors. </title> <booktitle> in Ninth Annual ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> 169-176. </pages>
Reference-contexts: Indeed, the various means for expressing transformations presented in these works could be used in concert with this calculus. (Using Paulsons tactics would not be germane, however, for one cannot reason about the calculus if the entirety of recursive function theory is available within the operators!) 24 Naturally, attribute grammars <ref> (Reps, 1982) </ref> are also related to these operators, as competitors, in fact. They motivated the naming of the inherit and synthesize operators. One hopes that the incremental update analysis will have analogs in the metaprogramming calculus.
Reference: <author> Runciman, C. </author> <title> (1989) Another look at labeled trees. </title> <note> IFIP Working Group 2.1 working paper 621: JVL 2, </note> <institution> University of York. </institution>
Reference: <author> Wile, D. S. </author> <title> (1986) Organizing programming knowledge into syntax-directed experts. </title> <booktitle> in Proceedings of an International Workshop on Advanced Programming Environments , WG2.4, </booktitle> <address> Trondheim, Norway, </address> <month> June. </month>
Reference: <author> Wile, D. S. </author> <title> (1988) Definitions toward the theory of labeled tree expressions. </title> <institution> IFIP Working Group 2.1 working paper: CHM 8, USC/Information Sciences Institute. </institution>
Reference: <author> Wile, D. S. </author> <year> (1991). </year> <note> Popart Manual. </note> <institution> USC/Information Sciences Institute. </institution> <year> 1991. </year>
Reference: <author> Wile, D. S. </author> <title> (1996) Abstract syntax from concrete syntax. </title> <institution> Working Group 2.1 working paper, Rancho Santa Fe, CA. </institution> <note> (To appear in ICSE 97). </note> <editor> APPENDIX: </editor> <title> TRANSFORMATION DEFINITIONS The following descriptions of transformations referred to in the large example in the paper use Popart's Syntax-Directed Experts facility to describe transformations. Each transformation is a sequence of rules, the left hand sides of which are patterns to be matched with an abstract syntax tree that is passed to the transformation. </title>

References-found: 22

