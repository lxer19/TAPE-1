URL: http://www.cs.umd.edu/~hollings/papers/onlineCP.ps.gz
Refering-URL: http://www.cs.umd.edu/~hollings/cs818z/f96/readingList.htm
Root-URL: 
Email: hollings@cs.umd.edu  
Title: An Online Computation of Critical Path Profiling  
Author: Jeffrey K. Hollingsworth 
Address: College Park, MD 20742  
Affiliation: Computer Science Department University of Maryland  
Abstract: In this paper we introduce a runtime, non-trace based algorithm to compute the critical path profile of the execution of a message passing parallel program. Our algorithm permits starting or stopping the critical path computation during program execution and reporting intermediate values. We also present an online algorithm to compute a variant of critical path, called critical path zeroing, that measures the reduction in application exec u-tion time that improving a selected procedure will have. Finally, we present a brief case study to quantify the runtime overhead of our algorithm and to show that online critical path profiling can be used to find program bottlenecks. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> T. E. Anderson and E. D. Lazowska, Quartz: </author> <title> A Tool for Tuning Parallel Program Performance, </title> <booktitle> 1990 SIGMETRICS Conference on Measurement and Mo d-eling of Computer Systems . May 1990, Boston, </booktitle> <pages> pp. 115-125. </pages>
Reference-contexts: Many metrics and tools have been developed to qua n-tify the performance of parallel programs. The Paradyn [11] and Pablo [14] tools provide a wealth of performance me t-rics. Other metrics focus on specific sources of bottlenecks in parallel programs <ref> [1, 10] </ref>. 6. Conclusion We have presented an online algorithm to compute the critical path profile of a parallel program, and a variant of critical path called critical path zeroing. <p> For each sample i, let G [ p,i] be the latest event for process p from all of the state slices for samples 0 to i (i.e., G [ p,i] = max (G [p,i-1], slice [ p,i]). G [p,0] = PT <ref> [p, 1] </ref>. Let G [*, i] denote the set of events for all processes p in G [p,i].
Reference: 2. <author> K. Bryan, </author> <title> A numerical method for the circulation of the World Ocean , Journal of Computational Physics , 1969. </title> <type> 4 (1), </type> <pages> pp. </pages> <month> 347-. </month>
Reference-contexts: struct node - // one record per PAG node (program event) 2 longest // longest path to this node 3 cpPred // predecessor node along longest path 4 inArcs // count of inbound arcs processed 5 totalInArcs // total number of inbound arcs (set when graph is built) 6 outArc <ref> [2] </ref> // pointer to successor nodes (set when graph it built) 7 activeFunc // function that is active when event occurs 8 -; 9 // First Pass: forward along all arcs of the PAG 10 while (not empty queue) - 11 dequeue (node, fromNode, length); 12 if (length &gt; node.longest) - <p> The reason for this is that the routine is completely sequential. Other sequential metrics would not have easily identified the importance of creat_seq. We also measured a PVM application running on an IBM SP-2. For this program, we measured an implement a-tion of the GFDL Modular Ocean Model <ref> [2] </ref> developed by Webb [15].
Reference: 3. <author> K. M. Chandy and L. Lamport, </author> <title> Distributed Snapshots: Determining Global States of Distributed Systems , ACM TOCS, </title> <journal> Feb 1985. </journal> <volume> 3 (1), </volume> <pages> pp. 63-75. </pages>
Reference-contexts: This is a special case of the consistent global snapshot problem described by Chandy and Lamport in <ref> [3] </ref>. Chandy and Lamport describe an algorithm to record the global state of a computation by sending a marker token along communication channels. In our scheme, the receipt of a critical path start message is equivalent to receipt of a marker token in their scheme.
Reference: 4. <author> K. M. Chandy and A. J. Misra, </author> <title> Distributed computation on graphs: Shortest path algorithms , CACM, </title> <journal> Nov 1982. </journal> <volume> 25 (11), </volume> <pages> pp. 833-837. </pages>
Reference-contexts: Unless one of these procedures is improved, the appl i-cation will not run any faster. Since the PAG is a directed acyclic graph and none of the arcs are negative, a variation on the distributed shortest path algorithm described by Chandy and Misra in <ref> [4] </ref> can be used for this calculation. This algorithm passes messages along the arcs of the graph. Each message contains the value of the longest path to the current node.
Reference: 5. <author> R. Cypher and E. Leu, </author> <title> Eficient Race Detection for Message-Passing Programs with Nonblocking Sends and Receives, </title> <booktitle> IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pp. 534-541. </pages>
Reference-contexts: Related Work Implicitly walking a PAG by attaching instrumentation messages onto applications messages has been used for online detection of race conditions in parallel programs <ref> [5, 8] </ref>. Similar instrumentation has also been used to reduce the number of events that must be logged for program r e-play [13]. Many metrics and tools have been developed to qua n-tify the performance of parallel programs.
Reference: 6. <author> J. Dongarra, A. Geist, R. Manchek, and V. S. Sun-deram, </author> <title> Integrated PVM framework supports heter o-geneous network computing , Computers in Physics , March-April 1993. </title> <type> 7 (2), </type> <pages> pp. 166-174. </pages>
Reference-contexts: Critical path zeroing measures the reduction in application execution time that improving a selected procedure will have. Finally, we present results from running an initial implementation of our algorithm using several PVM <ref> [6] </ref>, based parallel pr o-grams. Initial results indicate that our online critical path algorithm can profile up to eight procedures with a 3-10% slow down of the application program. 2.
Reference: 7. <author> J. K. Hollingsworth and B. P. Miller, </author> <title> Parallel Program Performance Metrics: A Comparison and Validation, </title> <booktitle> Supercomputing 1992 . Nov. 1992, </booktitle> <address> Minneapolis, MN, </address> <pages> pp. </pages> <month> 4-13. </month> <title> 2 We will show how to permit this computation do be done in a single execution of the program at the end of this Appendix. </title>
Reference-contexts: Based on our experience with commercial and scientific users, Critical Path Profiling is an effective metric for tu n-ing parallel programs. It is especially useful during the early stages of tuning a parallel program when load imbalance is a significant bottleneck <ref> [7] </ref>. In this paper we introduce a runtime, non-trace based algorithm to compute the critical path profile. Our algorithm also permits starting or stopping the critical path computation during program execution and reporting intermediate values. Previous algorithms to compute the critical path profile are expensive. <p> Selecting high CPU time procedures works well since although critical path profiling assigns a different ordering and importance to the top ten procedures, the procedures generally remain the same <ref> [7] </ref>. If top procedures are not the same, this fact can be detected since their cumulative share of the critical path length will be small. <p> To provide better guidance in this situation, we previously proposed a metric called log i-cal zeroing <ref> [7] </ref> that computes the reduction in the length of the critical path length due to tuning specific procedures. However, computing logical zeroing also required collec t-ing a large amount of data and building a postmortem graph.
Reference: 8. <author> R. Hood, K. Kennedy, and J. Mellor-Chrummey, </author> <title> Parallel Program Debugging with On-the-fly Anomaly Detection, </title> <booktitle> Supercomputing 1990 . Nov 1990, </booktitle> <address> New York, </address> <pages> pp. 78-81. </pages>
Reference-contexts: Related Work Implicitly walking a PAG by attaching instrumentation messages onto applications messages has been used for online detection of race conditions in parallel programs <ref> [5, 8] </ref>. Similar instrumentation has also been used to reduce the number of events that must be logged for program r e-play [13]. Many metrics and tools have been developed to qua n-tify the performance of parallel programs.
Reference: 9. <author> L. Lamport, </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System, </title> <journal> CACM, July 1978. </journal> <volume> 21 (7), </volume> <pages> pp. 558-564. </pages>
Reference-contexts: For local events, one event happened before another event if it occurred earlier in the program trace for that process. For remote events, send happens before the corresponding receive event. Formally, it is the set of precedence relatio n-ships between events implied by Lamport's happened before relationship <ref> [9] </ref>. If event x happens before event y, we denote this by x y.
Reference: 10. <author> M. Martonosi, A. Gupta, and T. Anderson, MemSpy: </author> <title> Analyzing Memory System Bottlenecks in Programs, </title> <booktitle> 1992 SIGMETRICS Conference on Measurement and Modeling of Computer Systems . June 1-5, 1992, </booktitle> <address> Ne w-port, Rhode Island, </address> <pages> pp. 1-12. </pages>
Reference-contexts: Many metrics and tools have been developed to qua n-tify the performance of parallel programs. The Paradyn [11] and Pablo [14] tools provide a wealth of performance me t-rics. Other metrics focus on specific sources of bottlenecks in parallel programs <ref> [1, 10] </ref>. 6. Conclusion We have presented an online algorithm to compute the critical path profile of a parallel program, and a variant of critical path called critical path zeroing.
Reference: 11. <author> B. P. Miller, M. D. Callaghan, J. M. Cargille, J. K. Hollingsworth, R. B. Irvin, K. L. Karavanic, K. Kunchithapadam, and T. Newhall, </author> <title> The Paradyn Pa r-allel Performance Measurement Tools , IEEE Co m-puter, </title> <journal> Nov. 1995. </journal> <volume> 28 (11), </volume> <pages> pp. 37-46. </pages>
Reference-contexts: The time required is O (e) where e is a subset of e co n-sisting of inter-process events and call and return events for the selected procedure (s). Our online approach makes it possible to integrate critical path profiling into online pe r-formance monitoring systems such as Paradyn <ref> [11] </ref>. By u sing Paradyns dynamic instrumentation system, we only need to insert instrumentation code for the procedures whose share of the critical path we are currently computing. We also present an online algorithm to compute a var i-ant of critical path, called critical path zeroing. <p> Similar instrumentation has also been used to reduce the number of events that must be logged for program r e-play [13]. Many metrics and tools have been developed to qua n-tify the performance of parallel programs. The Paradyn <ref> [11] </ref> and Pablo [14] tools provide a wealth of performance me t-rics. Other metrics focus on specific sources of bottlenecks in parallel programs [1, 10]. 6.
Reference: 12. <author> B. P. Miller, M. Clark, J. Hollingsworth, S. Kierstead, S.-S. Lim, and T. Torzewski, IPS-2: </author> <title> The Second Ge n-eration of a Parallel Program Measurement System , IEEE Transactions on Parallel and Distributed Sy stems, </title> <month> April </month> <year> 1990. </year> <pages> 1 (2), pp. 206-217. </pages>
Reference-contexts: In this paper we introduce a runtime, non-trace based algorithm to compute the critical path profile. Our algorithm also permits starting or stopping the critical path computation during program execution and reporting intermediate values. Previous algorithms to compute the critical path profile are expensive. In an earlier paper <ref> [12] </ref>, we d escribed an offline (post-mortem) approach to computing the critical path profile that required recording all inter-process, procedure entry, and procedure exit events during execution. Once the program had finished, a graph containing all recorded events is constructed.
Reference: 13. <author> R. H. B. Netzer and J. Xu, </author> <title> Adaptive Message Logging for Incremental Replay of Message-Passing Programs, </title> <booktitle> Supercomputing 1993 . 1993, </booktitle> <address> Portland, OR, </address> <pages> pp. 840-849. </pages>
Reference-contexts: Related Work Implicitly walking a PAG by attaching instrumentation messages onto applications messages has been used for online detection of race conditions in parallel programs [5, 8]. Similar instrumentation has also been used to reduce the number of events that must be logged for program r e-play <ref> [13] </ref>. Many metrics and tools have been developed to qua n-tify the performance of parallel programs. The Paradyn [11] and Pablo [14] tools provide a wealth of performance me t-rics. Other metrics focus on specific sources of bottlenecks in parallel programs [1, 10]. 6.
Reference: 14. <author> D. A. Reed, R. A. Aydt, R. J. Noe, P. C. Roth, K. A. Shields, B. W. Schwartz, and L. F. Tavera, </author> <title> Scalable Performance Analysis: The Pablo Performance Analysis Environment , in Scalable Parallel Libraries Conference, </title> <editor> A. Skjellum, Editor. </editor> <booktitle> 1993, </booktitle> <publisher> IEEE Co m-puter Society. </publisher>
Reference-contexts: Similar instrumentation has also been used to reduce the number of events that must be logged for program r e-play [13]. Many metrics and tools have been developed to qua n-tify the performance of parallel programs. The Paradyn [11] and Pablo <ref> [14] </ref> tools provide a wealth of performance me t-rics. Other metrics focus on specific sources of bottlenecks in parallel programs [1, 10]. 6. Conclusion We have presented an online algorithm to compute the critical path profile of a parallel program, and a variant of critical path called critical path zeroing.
Reference: 15. <author> D. J. Webb, </author> <type> Personal Communication. </type>
Reference-contexts: Other sequential metrics would not have easily identified the importance of creat_seq. We also measured a PVM application running on an IBM SP-2. For this program, we measured an implement a-tion of the GFDL Modular Ocean Model [2] developed by Webb <ref> [15] </ref>.
Reference: 16. <author> C.-Q. Yang and B. P. Miller, </author> <title> Critical Path Analysis for the Execution of Parallel and Distributed Pr o-grams, </title> <booktitle> 8 th Intl Conf. on Distributed Computing Sy stems. </booktitle> <address> June 1988, San Jose, Calif., </address> <pages> pp. 366-375. </pages>
Reference-contexts: Due to the interactions between threads of execution, improving the performance of a single procedure may not reduce the overall execution time of the program. One metric, explicitly developed for parallel pr o-grams, that has proved useful is Critical Path Profiling <ref> [16] </ref>. Based on our experience with commercial and scientific users, Critical Path Profiling is an effective metric for tu n-ing parallel programs. It is especially useful during the early stages of tuning a parallel program when load imbalance is a significant bottleneck [7].
References-found: 16

