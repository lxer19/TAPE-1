URL: http://www.cs.brown.edu/research/oodb/papers/dbpl-93-algebra.ps
Refering-URL: http://www.cs.brown.edu/research/oodb/
Root-URL: http://www.cs.brown.edu
Title: The AQUA Data Model and Algebra  
Author: Theodore W. Leung Gail Mitchell Bharathi Subramanian Bennet Vance Scott L. Vandenberg Stanley B. Zdonik 
Address: Providence, USA  Providence, USA  Providence, USA  Oregon, USA  Mass. at Amherst Amherst, USA  Providence, USA  
Affiliation: Brown University  Brown University  Brown University  Oregon Graduate Institute of Science Technology  University of  Brown University  
Date: 1993  
Note: Proc. of the 4th Intl. Workshop on Database Programming Languages (DBPL),  
Abstract: This paper describes a new object-oriented model and query algebra that will be used as an input language for the query optimizers that are being built as a part of the EREQ project. The model adopts a uniform view of objects and values and separates syntactic, semantic, and implementation concerns. The algebra addresses issues of type-defined equality and duplicate elimination as well as extensions to bulk types other than sets.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and P. Kanellakis. </author> <title> Object identity as a query language primitive. </title> <editor> In James Clifford, Bruce Lindsay, and David Maier, editors, </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data. </booktitle> <publisher> ACM Press, </publisher> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: EXCESS [33]) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g. Smalltalk and ORION [13, 5]) choose to support only objects in the type system and to model values as a special case of objects. IQL (see <ref> [1] </ref>) defines two separate languages, one enforcing object identity and one not supporting it at all.
Reference: [2] <author> S. Abiteboul, E. Simon, and V. Vianu. </author> <title> Non-deterministic languages to express deterministic transformations. </title> <booktitle> In Proceedings of the Ninth ACM SIGACT/SIGMOD Symposium on Principles of Database Systems, </booktitle> <address> Nashville, Tennesee, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: A set-theoretic choose operator appears in the algebras of Osborne and MDM (see [24, 25]). Non-determinism is also present in <ref> [2] </ref>, which describes a witness operator which operates in a logical (rather than an algebraic) setting and creates a set of possible interpretations of a formula, resulting Proc. of the 4th Intl. Workshop on Database Programming Languages (DBPL), 1993 in non-determinism.
Reference: [3] <author> Antonio Albano, Giorgio Ghelli, and Renzo Orsini. </author> <title> Objects for a database programming language. </title> <booktitle> In Kanellakis and Schmidt [18], </booktitle> <pages> pages 236-253. </pages>
Reference-contexts: AQUA can, of course, emulate these features of Postgres and EXCESS. The use of a type constructor to represent abstraction enables all objects in an AQUA database to exist in one seamless type system. Our approach is similar to that of <ref> [3] </ref>, but in their model not everything is an object, so their equivalent to our abstraction constructor must enforce many more of the facets of "objectness" than must ours. Several of our operators resemble operators of ENCORE/EQUAL, EXTRA/EXCESS, and Revelation. See Section 5 for detailed descriptions of the operators.
Reference: [4] <author> M. P. Atkinson, C. Lecluse, P. Philbrow, and P. Richard. </author> <title> Design issues in a map language. </title> <booktitle> In Kanellakis and Schmidt [18], </booktitle> <pages> pages 20-32. </pages>
Reference-contexts: 1 Introduction Recently, a great deal of work has been done on the topic of object-oriented query algebras [29, 24, 12] and the modeling of bulk types <ref> [4, 27, 21] </ref>. These proposals, as well as those of other researchers on the topic, have explored some of the fundamental issues and provided the starting point for the work reported here. <p> Unlike ILOG (see [15]) and others, we avoid explicit identifiers in the model, viewing them as an implementation concern, and reflecting the distinctions between objects and values by using varying semantics (see Section 3.3). It has been pointed out by Atkinson et al. (see <ref> [4] </ref>) that in object-oriented Proc. of the 4th Intl. Workshop on Database Programming Languages (DBPL), 1993 systems, a type may supply its own method for testing equality.
Reference: [5] <author> Jay Banerjee, Hong-Tai Chou, Jorge F. Garza, Won Kim, Darrell Woelk, Nat Ballou, and Hyoung-Joo Kim. </author> <title> Data model issues for object-oriented applications. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 3-26, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: In attempting to support both values and objects, some systems (e.g. EXCESS [33]) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g. Smalltalk and ORION <ref> [13, 5] </ref>) choose to support only objects in the type system and to model values as a special case of objects. IQL (see [1]) defines two separate languages, one enforcing object identity and one not supporting it at all.
Reference: [6] <author> Catriel Beeri and Yoram Kornatzky. </author> <title> Algebraic optimization of object-oriented query languages. </title> <editor> In S. Abiteboul and P. C. Kanellakis, editors, </editor> <booktitle> Proceedings of the Third International Conference on Database Theory, </booktitle> <pages> pages 72-88, </pages> <address> Paris, France, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: AQUA is intended to support large numbers of bulk types and to do so in a flexible, uniform way, such that the addition of other bulk types later on will be straightforward. <ref> [6] </ref> proposes a meta-level algebra for collections of complex objects with identity and also includes some transformation rules for optimization. This algebra, however, does not correspond to a specific data model but rather to a higher-level notion of collections of objects.
Reference: [7] <author> Val Breazu-Tannen, Peter Buneman, and Shamim Naqvi. </author> <title> Structural recursion as a query language. </title> <booktitle> In Kanellakis and Schmidt [18], </booktitle> <pages> pages 9-19. </pages>
Reference: [8] <author> Peter Buneman and Atsushi Ohori. </author> <title> A type system that reconciles classes and extents. </title> <booktitle> In Kanellakis and Schmidt [18], </booktitle> <pages> pages 191-202. </pages>
Reference-contexts: We are not aware of another model that takes this approach, nor of one that takes the clearly-separated, 3-level view of an object that we do (type, semantics, and implementation; see Section 3.1). Buneman and Ohori (see <ref> [8] </ref>) exhibit a similar philosophy, though, in their distinction between a kind and a type.
Reference: [9] <author> M. Carey, D. DeWitt, and S. Vandenberg. </author> <title> A data model and query language for EXODUS. </title> <editor> In Haran Boral and Per ake Larson, editors, </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 413-423, </pages> <address> Chicago, Illinois, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: This is similar to Postgres's notion of user-defined Postquel functions and the functions and procedures of EXCESS <ref> [9] </ref>, but in those systems, the ability to define functions allows one to add operations to an existing, non-encapsulated type (i.e., encapsulation is not enforced in those systems but is in AQUA). AQUA can, of course, emulate these features of Postgres and EXCESS. <p> Most of these operators are derived from similar operators in the literature <ref> [9, 28, 32] </ref> and exceptions are noted as they arise. It is our combination and utilization of them, in Proc. of the 4th Intl. <p> The binary set operators, union, intersection and difference are the familiar set-theoretic operations; however our definitions are complicated by considerations of typing. When two sets are combined using a binary set operator, it is not necessary that they have the same type. As in EXCESS <ref> [9] </ref>, these operators take an extra argument that specifies the type of the result, as discussed in subsection 4.2. The result type of union has to be a supertype of the types of the input sets.
Reference: [10] <author> A. Chandra. </author> <title> Theory of database queries. </title> <booktitle> In Proc. Conf. on Principles of Database Systems, </booktitle> <pages> pages 1-9, </pages> <year> 1988. </year> <booktitle> Proc. of the 4th Intl. Workshop on Database Programming Languages (DBPL), </booktitle> <year> 1993 </year>
Reference: [11] <author> Scott Daniels, Goetz Graefe, Thomas Keller, David Maier, Duri Schmidt, and Bennet Vance. </author> <title> Query Optimization in Revelation, an Overview. </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> 14(2) </volume> <pages> 58-62, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: If the two input sets were sets of lists, it could combine the two elements by concatenation, thereby producing a set of lists. AQUA is currently being used as the input language for two prototype extensible optimizers, Epoq at Brown University [23] and Revelation at OGI <ref> [11] </ref>.
Reference: [12] <author> Umeshwar Dayal, Frank Manola, Alejandro Buchmann, Upen Chak-ravarthy, David Goldhirsch, Sandra Heiler, Jack Orenstein, and Arnon Rosenthal. </author> <title> Simplifying complex objects: The PROBE approach to mod-elling and querying them. </title> <editor> In Stanley B. Zdonik and David Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, </booktitle> <pages> pages 390-399. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Los Altos, California, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Recently, a great deal of work has been done on the topic of object-oriented query algebras <ref> [29, 24, 12] </ref> and the modeling of bulk types [4, 27, 21]. These proposals, as well as those of other researchers on the topic, have explored some of the fundamental issues and provided the starting point for the work reported here.
Reference: [13] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: In attempting to support both values and objects, some systems (e.g. EXCESS [33]) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g. Smalltalk and ORION <ref> [13, 5] </ref>) choose to support only objects in the type system and to model values as a special case of objects. IQL (see [1]) defines two separate languages, one enforcing object identity and one not supporting it at all.
Reference: [14] <author> John V. Guttag, James J. Horning, and Jeanette M. Wing. </author> <title> The Larch family of specification languages. </title> <journal> IEEE Software, </journal> <volume> 2(5) </volume> <pages> 24-36, </pages> <month> September </month> <year> 1985. </year>
Reference-contexts: Our characterization of the distinction between "objects" and "values" as the difference between entities (objects) with mutable and immutable semantics provides a much cleaner formalism, and was partially inspired by systems such as Larch <ref> [14] </ref>. By cleanly separating the notions of type (a syntactic concept) and semantics we provide a model that treats both values and objects as first-class citizens and has a simpler type system. <p> Functions have types, although our notation (described below) only allows the instantiation of particular functions. The name equivalence rule is used for determining the equality of two AQUA types. The semantics of a type might loosely be thought of as a Larch <ref> [14] </ref> specification, which axiomatically describes properties of the operations on a type. The particular language used for describing semantics is a topic of our current research. Specifying semantics separately from types allows different instances of the same type to have different behaviors.
Reference: [15] <author> Hull and Yoshikawa. </author> <title> ILOG: Declarative creation and manipulation of object identifiers. </title> <editor> In Dennis McLeod, Ron Sacks-Davis, and Hans Schek, editors, </editor> <booktitle> Proceedings of the 16th International Conference on Very Large Data Bases. </booktitle> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Eiffel [22] makes a distinction between reference and copy semantics, but not between mutable and immutable semantics. Unlike ILOG (see <ref> [15] </ref>) and others, we avoid explicit identifiers in the model, viewing them as an implementation concern, and reflecting the distinctions between objects and values by using varying semantics (see Section 3.3). It has been pointed out by Atkinson et al. (see [4]) that in object-oriented Proc. of the 4th Intl.
Reference: [16] <editor> IEEE. </editor> <booktitle> Proceedings of the Sixth International Conference on Data Engineering, </booktitle> <address> Los Angeles, California, February 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [17] <author> Paris Kanellakis. </author> <title> Elements of relational database theory. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> volume 2, chapter 17, </volume> <pages> pages 1073-1144. </pages> <publisher> Elsevier Science Publishers B.V., </publisher> <address> Amster-dam, </address> <year> 1990. </year>
Reference-contexts: Familiar join operators like natural join, equijoin, semijoin and antijoin are not primitives in the algebra, but they can be expressed easily in terms of the included join operators. The LFP operator <ref> [17] </ref> is defined in table 3. The function f is of type T ! T , where T is a set type. The notation f i is equivalent to f (f i1 ).
Reference: [18] <author> Paris Kanellakis and Joachim W. Schmidt, </author> <title> editors. Bulk Types & Persistent Data: </title> <booktitle> The Third International Workshop on Database Programming Languages, </booktitle> <address> Nafplion, Greece, August 1991. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference: [19] <author> G. M. Kuper. </author> <title> The Logical Data Model: A New Approach to Database Logic. </title> <type> Ph.D. thesis, </type> <institution> Dept. of Computer Science, Stanford University,, Stanford, </institution> <address> CA, </address> <month> Sept </month> <year> 1985. </year>
Reference-contexts: EXTRA/EXCESS [33] also attempts to support a large number of bulk types, but does not explicitly provide sets (they are provided only by eliminating duplicates from multisets). The inclusion of a union type is not new (see <ref> [19] </ref>), but we provide it with a clean algebraic interface using both tagcase and typecase constructs to be fully general.
Reference: [20] <author> David Maier, Jacob Stein, Allen Otis, and Alan Purdy. </author> <title> Development of an object-oriented DBMS. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> Proceedings of the Conference on Object-oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 472-482, </pages> <address> Portland, Oregon, </address> <month> September-October </month> <year> 1986. </year>
Reference: [21] <author> Florian Matthes and Joachim W. Schmidt. </author> <title> Bulk types: </title> <booktitle> Built-in or add-on? In Kanellakis and Schmidt [18], </booktitle> <pages> pages 33-53. </pages>
Reference-contexts: 1 Introduction Recently, a great deal of work has been done on the topic of object-oriented query algebras [29, 24, 12] and the modeling of bulk types <ref> [4, 27, 21] </ref>. These proposals, as well as those of other researchers on the topic, have explored some of the fundamental issues and provided the starting point for the work reported here. <p> The inclusion of a union type is not new (see [19]), but we provide it with a clean algebraic interface using both tagcase and typecase constructs to be fully general. The importance of being flexible about the addition of new bulk types has been established (see <ref> [21] </ref>); the modularity of the AQUA approach facilitates this to an extent by following a rationale similar to that of Rozen and Shasha (see [27]) in several respects. In attempting to support both values and objects, some systems (e.g.
Reference: [22] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1988. </year> <booktitle> Proc. of the 4th Intl. Workshop on Database Programming Languages (DBPL), </booktitle> <year> 1993 </year>
Reference-contexts: C++ [30] has a notion of "const" that is similar to our notion of "immutable", but in C++ this notion is part of the type system, and thus causes a variety of problems that motivated us to separate type and semantics. Eiffel <ref> [22] </ref> makes a distinction between reference and copy semantics, but not between mutable and immutable semantics. Unlike ILOG (see [15]) and others, we avoid explicit identifiers in the model, viewing them as an implementation concern, and reflecting the distinctions between objects and values by using varying semantics (see Section 3.3).
Reference: [23] <author> Gail Mitchell, Stanley B. Zdonik, and Umeshwar Dayal. </author> <title> An Architecture for Query Processing in Persistent Object Stores. </title> <booktitle> In Proceedings of the Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 787-798, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: If the two input sets were sets of lists, it could combine the two elements by concatenation, thereby producing a set of lists. AQUA is currently being used as the input language for two prototype extensible optimizers, Epoq at Brown University <ref> [23] </ref> and Revelation at OGI [11].
Reference: [24] <author> S. Osborn. </author> <title> Identity, equality, and query optimization. </title> <editor> In K. Dittrich, editor, </editor> <booktitle> Advances in Object-Oriented Database Systems. </booktitle> <address> Berlin, Germany, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction Recently, a great deal of work has been done on the topic of object-oriented query algebras <ref> [29, 24, 12] </ref> and the modeling of bulk types [4, 27, 21]. These proposals, as well as those of other researchers on the topic, have explored some of the fundamental issues and provided the starting point for the work reported here. <p> A set-theoretic choose operator appears in the algebras of Osborne and MDM (see <ref> [24, 25] </ref>). Non-determinism is also present in [2], which describes a witness operator which operates in a logical (rather than an algebraic) setting and creates a set of possible interpretations of a formula, resulting Proc. of the 4th Intl. Workshop on Database Programming Languages (DBPL), 1993 in non-determinism.
Reference: [25] <author> Joel Richardson and Peter Schwarz. </author> <title> MDM: An object-oriented data model. </title> <booktitle> In Kanellakis and Schmidt [18], </booktitle> <pages> pages 86-95. </pages>
Reference-contexts: Many models (e.g. MDM <ref> [25] </ref>) do not have this flexibility. Most "pure" object-oriented models ([13, 20], and others) provide and enforce encapsulation of data types. <p> AQUA's dup elim can be thought of as a generalization of other duplicate elimination operators (e.g. that of ENCORE/EQUAL [28]). Our binary join operation is similar to the n-ary image operator of MDM <ref> [25] </ref>, but differs from it in that we separate the join predicate from the function to be applied to matching pairs; the idea of this is to enhance optimization by making certain queries (e.g. equijoins) easier to recognize. <p> A set-theoretic choose operator appears in the algebras of Osborne and MDM (see <ref> [24, 25] </ref>). Non-determinism is also present in [2], which describes a witness operator which operates in a logical (rather than an algebraic) setting and creates a set of possible interpretations of a formula, resulting Proc. of the 4th Intl. Workshop on Database Programming Languages (DBPL), 1993 in non-determinism.
Reference: [26] <author> L. Rowe and M. Stonebraker. </author> <title> The POSTGRES data model. </title> <booktitle> In Proceedings of the Thirteenth Very Large Databases Conference. </booktitle> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1987. </year>
Reference-contexts: But AQUA does support such types, and does so using the "abstraction" type constructor, allowing any database object to be described using a single uniform type system. This is similar to the ADT concept provided by Postgres <ref> [26] </ref>, but more general in the sense that any type definable in the AQUA type system can be abstracted into a true encapsulated type, and an abstraction in AQUA is a first-class citizen of the type system the abstraction constructor has the same status as any other constructor.
Reference: [27] <author> Steve Rozen and Dennis Shasha. </author> <title> Rationale and design of Bulk. </title> <booktitle> In Kanel-lakis and Schmidt [18], </booktitle> <pages> pages 71-85. </pages>
Reference-contexts: 1 Introduction Recently, a great deal of work has been done on the topic of object-oriented query algebras [29, 24, 12] and the modeling of bulk types <ref> [4, 27, 21] </ref>. These proposals, as well as those of other researchers on the topic, have explored some of the fundamental issues and provided the starting point for the work reported here. <p> The importance of being flexible about the addition of new bulk types has been established (see [21]); the modularity of the AQUA approach facilitates this to an extent by following a rationale similar to that of Rozen and Shasha (see <ref> [27] </ref>) in several respects. In attempting to support both values and objects, some systems (e.g. EXCESS [33]) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g.
Reference: [28] <author> Gail M. Shaw and Stanley B. Zdonik. </author> <title> A query algebra for object-oriented databases. </title> <booktitle> In Proceedings of the Sixth International Conference on Data Engineering [16], </booktitle> <pages> pages 152-162. </pages>
Reference-contexts: AQUA (A QUery Algebra) is the result of a joint effort among researchers who have participated in the design of previous algebras <ref> [28, 32, 33] </ref>. AQUA has been designed to address a number of detailed modeling issues that we believe needed further work, but the overarching goal for this work has been the design of an algebra that would serve as the input to a broad class of query optimizers. <p> Other models have claimed similar goals, but not necessarily in all these areas at once, and our mechanisms for achieving these goals differ substantially from those of our predecessors. Many of the specific constructs of AQUA were inspired by or drawn from the EXTRA/EXCESS system [33], ENCORE/EQUAL <ref> [28] </ref>, and Revelation [32]. <p> Dup elim for both sets and multisets (as we've defined it) and convert appear to be original to this model, with dup elim being by far the more interesting. AQUA's dup elim can be thought of as a generalization of other duplicate elimination operators (e.g. that of ENCORE/EQUAL <ref> [28] </ref>). <p> Most of these operators are derived from similar operators in the literature <ref> [9, 28, 32] </ref> and exceptions are noted as they arise. It is our combination and utilization of them, in Proc. of the 4th Intl.
Reference: [29] <author> David D. Straube and M. Tamer Ozsu. </author> <title> Queries and query processing in object-oriented database systems. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 8(4), </volume> <month> Oct </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Recently, a great deal of work has been done on the topic of object-oriented query algebras <ref> [29, 24, 12] </ref> and the modeling of bulk types [4, 27, 21]. These proposals, as well as those of other researchers on the topic, have explored some of the fundamental issues and provided the starting point for the work reported here. <p> Workshop on Database Programming Languages (DBPL), 1993 in non-determinism. Also, the decision to make the boolean operators (and, or, and not) full-fledged algebra operators, rather than constructs available only in certain parts of the language (e.g. predicates), as in the relational algebra, EXCESS, and Straube's algebra (see <ref> [33, 29] </ref>), adds to the flexibility of the algebra. Finally, the type parameter to union, difference, and intersection is similar to that used in EXCESS. 3 The AQUA Data Model The AQUA data model is founded on the notions of strong typing and abstract data types.
Reference: [30] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: Buneman and Ohori (see [8]) exhibit a similar philosophy, though, in their distinction between a kind and a type. C++ <ref> [30] </ref> has a notion of "const" that is similar to our notion of "immutable", but in C++ this notion is part of the type system, and thus causes a variety of problems that motivated us to separate type and semantics.
Reference: [31] <author> Bharathi Subramanian, Stanley B. Zdonik, Theodore W. Leung, and Scott L. Vandenberg. </author> <title> Ordered types in the AQUA data model. </title> <booktitle> In Proceedings of the Fourth International Workshop on Database Programming Languages, </booktitle> <address> New York, New York, August 1993. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: The presentation in this paper covers two bulk types, sets and multisets. The discussion of more complex, ordered types is beyond the scope of this paper <ref> [31] </ref>. Some of the operators that one would expect to find in any algebra appear in AQUA as well. They have, however, been generalized to deal with many data models and many possible bulk types. <p> Lists, trees, and graphs are not discussed further here; see <ref> [31] </ref> for a complete description of them. N-dimensional arrays are a subject of our future research. Abstractions, tuples and unions are subtypeable. Functions are subtypeable using the standard contravariance rule. Sets and multisets are not subtypeable. <p> Workshop on Database Programming Languages (DBPL), 1993 This paper has discussed algebraic operators for the Set and the Multiset types. We also propose an extension to AQUA to include algebraic operators for other bulk types such as List, Tree, and Graph <ref> [31] </ref>. Acknowledgements Thanks to: Catriel Beeri, DARPA, Leo Fegaras, David Maier, Scott Meyers, and Hagit Shatkay.
Reference: [32] <author> B. Vance. </author> <title> Towards an object-oriented query algebra. </title> <type> Tech. Report CS/E91-008, </type> <institution> Dept. of Computer Science and Eng., Oregon Graduate Institute, Beaverton, </institution> <address> OR, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: AQUA (A QUery Algebra) is the result of a joint effort among researchers who have participated in the design of previous algebras <ref> [28, 32, 33] </ref>. AQUA has been designed to address a number of detailed modeling issues that we believe needed further work, but the overarching goal for this work has been the design of an algebra that would serve as the input to a broad class of query optimizers. <p> Many of the specific constructs of AQUA were inspired by or drawn from the EXTRA/EXCESS system [33], ENCORE/EQUAL [28], and Revelation <ref> [32] </ref>. <p> Most of these operators are derived from similar operators in the literature <ref> [9, 28, 32] </ref> and exceptions are noted as they arise. It is our combination and utilization of them, in Proc. of the 4th Intl.
Reference: [33] <author> S. Vandenberg and D. DeWitt. </author> <title> Algebraic support for complex objects with arrays, identity, and inheritance. </title> <editor> In James Clifford and Roger King, editors, </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 158-167, </pages> <address> Denver, Colorado, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: AQUA (A QUery Algebra) is the result of a joint effort among researchers who have participated in the design of previous algebras <ref> [28, 32, 33] </ref>. AQUA has been designed to address a number of detailed modeling issues that we believe needed further work, but the overarching goal for this work has been the design of an algebra that would serve as the input to a broad class of query optimizers. <p> Other models have claimed similar goals, but not necessarily in all these areas at once, and our mechanisms for achieving these goals differ substantially from those of our predecessors. Many of the specific constructs of AQUA were inspired by or drawn from the EXTRA/EXCESS system <ref> [33] </ref>, ENCORE/EQUAL [28], and Revelation [32]. <p> Thus it takes a different approach to generality than does AQUA. It also does not support several of the constructs of AQUA (including grouping and immutable semantics). EXTRA/EXCESS <ref> [33] </ref> also attempts to support a large number of bulk types, but does not explicitly provide sets (they are provided only by eliminating duplicates from multisets). <p> In attempting to support both values and objects, some systems (e.g. EXCESS <ref> [33] </ref>) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g. Smalltalk and ORION [13, 5]) choose to support only objects in the type system and to model values as a special case of objects. <p> Workshop on Database Programming Languages (DBPL), 1993 in non-determinism. Also, the decision to make the boolean operators (and, or, and not) full-fledged algebra operators, rather than constructs available only in certain parts of the language (e.g. predicates), as in the relational algebra, EXCESS, and Straube's algebra (see <ref> [33, 29] </ref>), adds to the flexibility of the algebra. Finally, the type parameter to union, difference, and intersection is similar to that used in EXCESS. 3 The AQUA Data Model The AQUA data model is founded on the notions of strong typing and abstract data types.
References-found: 33

