URL: http://www.icsi.berkeley.edu/~tschudin/ps/ma-security.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/~tschudin/
Root-URL: http://www.icsi.berkeley.edu
Email: fsander|tschuding@icsi.berkeley.edu  
Title: Protecting Mobile Agents Against Malicious Hosts  
Author: Tomas Sander and Christian F. Tschudin 
Address: 1947 Center Street, Berkeley, CA 94704, USA  
Affiliation: International Computer Science Institute  
Note: Feb 1998, to appear in G. Vigna (ed.), Mobile Agent Security, LNCS xxxx  
Abstract: A key element of any mobile code based distributed system are the security mechanisms available to protect (a) the host against potentially hostile actions of a code fragment under execution and (b) the mobile code against tampering attempts by the executing host. Many techniques for the first problem (a) have been developed. The second problem (b) seems to be much harder: It is the general belief that computation privacy for mobile code cannot be provided without tamper resistant hardware. Furthermore it is doubted that an agent can keep a secret (e.g., a secret key to generate digital signatures). There is an error in reasoning in the arguments supporting these beliefs which we are going to point out. In this paper we describe software-only approaches for providing computation privacy for mobile code in the important case that the mobile code fragment computes an algebraic circuit (a polynomial). We further describe an approach how a mobile agent can digitally sign his output securely.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Abadi and J. Feigenbaum. </author> <title> Secure circuit evaluation. </title> <journal> Journal of Cryptology, </journal> <volume> 2(1) </volume> <pages> 1-12, </pages> <year> 1990. </year>
Reference-contexts: We then identify an important class of such encryptable functions, namely polynomials and rational functions. 3.1 Computing with Encrypted Data The problem of computing with encrypted data (CED) has been described by Abadi and Feigenbaum <ref> [1] </ref> in the following way: Bob has an algorithm to compute a function f and is willing to compute f (x) for Alice. Alice wants to compute f on her private input x but does not want to reveal x to Bob.
Reference: 2. <author> J. Benaloh. </author> <title> Dense probabilistic encryption. </title> <booktitle> In Proceedings of the Workshop on Selected Areas of Cryptography, </booktitle> <pages> pages 120-128, </pages> <year> 1994. </year>
Reference-contexts: Remark. The security of the scheme relies on the secrecy of g. An additively homomorphic encryption scheme based on discrete logarithms which does not have this shortcoming i.e., which can be published, is currently under development by Lipton and Sander [8] (see also <ref> [2] </ref>). Their scheme is furthermore probabilistic which significantly reduces the information leakage about the original polynomial. 4.5 Preliminary Conclusions Non-interactive computing with encrypted functions is a challenge to cryptography.
Reference: 3. <author> D. Chess, B. Grosof, C. Harrison, D. Levine, and C. Parris. </author> <title> Itinerant agents for mobile computing. </title> <type> Technical Report RC 20010, </type> <institution> IBM, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Without linking the execution of a program to some trusted safe haven there would therefore be no way to let a mobile agent do security sensitive operations. This view has been expressed at several places in the literature. Chess et al., for example, write in <ref> [3] </ref>: It is impossible to prevent agent tampering unless trusted (and tamper-resistant) hardware is available [: : : ].
Reference: 4. <author> Don Coppersmith, Jacques Stern, and Serge Vaudenay. </author> <title> Attacks on the birational permutation signature schemes. </title> <editor> In Douglas R. Stinson, editor, </editor> <booktitle> Proceedings of CRYPTO'93, number 773 in LNCS, </booktitle> <pages> pages 435-443, </pages> <year> 1993. </year>
Reference-contexts: However, the schemes resulting from those constructions have been successfully attacked by Coppersmith, Stern and Vaudenay <ref> [4] </ref>. So there is a need to find new constructions for secure birational functions to put our ideas to work. We expect that other ways to construct secure birational maps can be found e.g., based on concepts from Algebraic Geometry where birational maps are extensively studied.
Reference: 5. <author> Dave Dyer. </author> <title> Java decompilers compared. </title> <note> http://www.javaworld.com/javaworld/jw-07-1997/jw-07-decompilers.html, June 1997. </note>
Reference-contexts: One major problem is that unless provably effective techniques can be applied here, this remains an arms race where each new masquerade technique is immediately paralleled by countermeasures (see for example the case of Java byte code obfuscators <ref> [14, 5] </ref>). Still another approach would be to protect an application as a whole instead of protecting the individual agents it is composed of (see e.g., [18] for a discussion of such an approach and further references).
Reference: 6. <author> J. Feigenbaum and M. Merritt. </author> <title> Open questions, talk abstracts, and summary of discussions. </title> <booktitle> DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <volume> 2 </volume> <pages> 1-45, </pages> <year> 1991. </year>
Reference-contexts: In the beginning of the 90s Feigenbaum and Merritt asked the following question <ref> [6] </ref>: Is there an encryption function E such that both E (x + y) and E (xy) are easy to compute from E (x) and E (y)? Encryption functions E : R ! S for rings R and S having the property stated above are called algebraic homomorphic encryption schemes. <p> (y) that does not reveal x and y, mixed multiplicatively homomorphic if there is an efficient algorithm MIXED-MULT to compute E (xy) from E (x) and y that does not reveal x, algebraically homomorphic if it is additively and multiplicatively homomorphic. 4.1 Homomorphic Schemes for Computing with Encrypted Data In <ref> [6] </ref> Feigenbaum and Merritt wonder whether there exist algebraic homomorphic encryption schemes. The reason for this is the following Proposition 2.
Reference: 7. <author> Don Libes. </author> <title> Obfuscated C and other mysteries. </title> <publisher> Wiley, </publisher> <year> 1993. </year>
Reference-contexts: A further step towards protecting a mobile agent against malicious hosts is to make tampering difficult or expensive. Code obfuscation, for example, proposes to make the agent's program illegible and thus difficult to manipulate <ref> [7] </ref>. One major problem is that unless provably effective techniques can be applied here, this remains an arms race where each new masquerade technique is immediately paralleled by countermeasures (see for example the case of Java byte code obfuscators [14, 5]).
Reference: 8. <author> Richard Lipton and Tomas Sander. </author> <title> An additively homomorphic encryption scheme or how to introduce a partial trapdoor in the discrete log, </title> <month> November </month> <year> 1997. </year> <note> Submitted for publication. </note>
Reference-contexts: Alice can use corollary 6 to realize CEF. Remark. The security of the scheme relies on the secrecy of g. An additively homomorphic encryption scheme based on discrete logarithms which does not have this shortcoming i.e., which can be published, is currently under development by Lipton and Sander <ref> [8] </ref> (see also [2]). Their scheme is furthermore probabilistic which significantly reduces the information leakage about the original polynomial. 4.5 Preliminary Conclusions Non-interactive computing with encrypted functions is a challenge to cryptography.
Reference: 9. <author> Catherine Meadows. </author> <title> Detecting attacks on mobile agents. </title> <booktitle> In Proceedings of the DARPA workshop on foundations for secure mobile code, </booktitle> <address> Monterey CA, USA, </address> <month> March </month> <year> 1997. </year>
Reference-contexts: It would also be possible to add dummy data items to an agents which are offered as potential objects to tamper with: a returning agent may then be checked to see whether these items were modified or not <ref> [9] </ref>. Clearly the last approach lacks the necessary cryptographic strength that would be required to serve as a proof in a court room. In general, detection approaches are ineffective for attacks where the culprit may not be identified or does not exist anymore once a fraud is detected.
Reference: 10. <author> David Naccache and Jacques Stern. </author> <title> A new public-key cryptosystem. </title> <booktitle> In Advances in Cryptology - EUROCRYPT'97, </booktitle> <publisher> LNCS, </publisher> <pages> pages 27-36, </pages> <year> 1997. </year>
Reference-contexts: Proof. Combine proposition 4 and lemma 5. 4.4 Algebraic Schemes That are Additively Homomorphic There already exist schemes on Z=nZthat enable to compute E (x + y) from E (x) and E (y) directly. An example is the Naccache-Stern public key encryption function <ref> [10] </ref>. However, this scheme can not be used for CEF. The Naccache-Stern approach is compu-tationally infeasible because to guarantee the correctness of the results the polynomial many calls to PLUS that in general are needed to perform CEF require the system parameter p to be chosen exponentially large.
Reference: 11. <author> Franco P. Preparata. </author> <title> Generation of near-optimal universal boolean functions. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 4 </volume> <pages> 93-102, </pages> <year> 1970. </year>
Reference-contexts: However, for a function U : B m ! B that is universal for the class of boolean functions ff : B n ! Bg we necessarily have that m 2 n log (2n+2) <ref> [11] </ref>. Thus we get an exponential blowup by using universal Boolean functions which means that this principally correct approach is computationally infeasible. So seemingly there is a difference between hiding data and hiding circuits. The infeasibility of the reduction suggests that CEF may me much harder then CED.
Reference: 12. <author> Ronald L. Rivest, Len Adleman, and Michael L. Dertouzos. </author> <title> On data banks and privacy homomorphisms. </title> <editor> In R. A. DeMillo, D. P. Dobkin, A. K. Jones, and R. J. Lipton, editors, </editor> <booktitle> Foundations of Secure Computation, </booktitle> <pages> pages 169-179. </pages> <publisher> Academic Press, </publisher> <year> 1978. </year>
Reference-contexts: Programs are usually build out of a small set of building blocks the instructions the programming language provides. What we need is the computational analogue to homomorphisms which respects the building blocks. Processing data via homomorphic functions has been studied e.g., in <ref> [12] </ref>. In the following section we focus on algebraic homomorphic encryption schemes i.e., maps between algebraic structures (we study rings) that are compliant with the compatibility constraint. Programs thus would be represented by algebraic circuits or polynomials.
Reference: 13. <author> Adi Shamir. </author> <title> Efficient signature schemes based on birational permutations. </title> <editor> In Douglas R. Stinson, editor, </editor> <booktitle> Proceedings of CRYPTO'93, number 773 in LNCS, </booktitle> <pages> pages 1-12, </pages> <year> 1993. </year>
Reference-contexts: Interestingly, there are already results on the hardness of decomposing rational functions. No polynomial time algorithm for decomposing multivariate rational functions is known [19]! Furthermore, ways to construct rational functions s that we use to garble f and that are easy to invert have been proposed by Shamir <ref> [13] </ref> in a different context. An in-depth analysis of such a composition approach remains to be carried out. But it shows that interesting candidates for doing CEF indeed exist. 3.4 Encrypting Polynomials and Rational Functions The challenge is to find encryption schemes for arbitrary functions. <p> This problem is known to be very hard. So an adversary will not be able to invert f except for some very simple choices of f .) Ways to construct birational functions s that are easy to invert have been described by Shamir in the second part of <ref> [13] </ref>. However, the schemes resulting from those constructions have been successfully attacked by Coppersmith, Stern and Vaudenay [4]. So there is a need to find new constructions for secure birational functions to put our ideas to work.
Reference: 14. <author> K. B. Sriram. </author> <title> Hashjava a java applet obfuscator. </title> <note> http://www.sbktech.org/hashjava.html, July 1997. </note>
Reference-contexts: One major problem is that unless provably effective techniques can be applied here, this remains an arms race where each new masquerade technique is immediately paralleled by countermeasures (see for example the case of Java byte code obfuscators <ref> [14, 5] </ref>). Still another approach would be to protect an application as a whole instead of protecting the individual agents it is composed of (see e.g., [18] for a discussion of such an approach and further references).
Reference: 15. <author> Giovanni Vigna. </author> <title> Protecting mobile agents through tracing. </title> <booktitle> In Proceedings of the Third ECOOP Workshop on Mobile Object Systems, </booktitle> <address> Jyv askyl a Finnland, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Alternatively one could attempt legal steps to recover possible losses and to make punitive claims. Several (cryptographic and non-cryptographic) techniques have been proposed in this direction which require the host to do some extra work in order to proof later on that it duly executed a specific mobile agent <ref> [18, 15] </ref>. It would also be possible to add dummy data items to an agents which are offered as potential objects to tamper with: a returning agent may then be checked to see whether these items were modified or not [9].
Reference: 16. <author> Joachim von zur Gathen and Gadiel Seroussi. </author> <title> Boolean circuits versus arithmetic circuits. </title> <journal> Information and Computation, </journal> <volume> 91 </volume> <pages> 142-154, </pages> <year> 1991. </year>
Reference-contexts: Exponentiation in Z=pZis an example for such a map. How do algebraic circuits relate to Boolean circuits? It is known that (under reasonable conditions) every algebraic circuit on finite fields can be simulated efficiently by Boolean circuits. The converse of this is wide open (cf. <ref> [16] </ref> for a discussion of these issues). Shifting from a Turing machine model to Boolean circuits is not a restriction: Every language in P i.e., which can be recognized by a deterministic Turing machine in polynomial time, can be recognized by uniform Boolean circuits of polynomial size [17].
Reference: 17. <author> Ingo Wegener. </author> <title> The Complexity of Boolean Functions. </title> <address> Eiley-Teubner, </address> <year> 1987. </year>
Reference-contexts: Shifting from a Turing machine model to Boolean circuits is not a restriction: Every language in P i.e., which can be recognized by a deterministic Turing machine in polynomial time, can be recognized by uniform Boolean circuits of polynomial size <ref> [17] </ref>. So there may be programs that can not be efficiently simulated using algebraic circuits (but which are feasible for Boolean circuits). It would be very interesting to derive methods for evaluating encrypted Boolean circuits non-interactively by conceding that some information about the original circuit may be revealed.
Reference: 18. <author> Bennet S. Yee. </author> <title> A sanctuary for mobile agents. </title> <booktitle> In Proceedings of the DARPA workshop on foundations for secure mobile code, </booktitle> <address> Monterey CA, USA, </address> <month> March </month> <year> 1997. </year>
Reference-contexts: Alternatively one could attempt legal steps to recover possible losses and to make punitive claims. Several (cryptographic and non-cryptographic) techniques have been proposed in this direction which require the host to do some extra work in order to proof later on that it duly executed a specific mobile agent <ref> [18, 15] </ref>. It would also be possible to add dummy data items to an agents which are offered as potential objects to tamper with: a returning agent may then be checked to see whether these items were modified or not [9]. <p> Still another approach would be to protect an application as a whole instead of protecting the individual agents it is composed of (see e.g., <ref> [18] </ref> for a discussion of such an approach and further references). A specific task may be split into several mobile agents that collaborate with each other from different computation platforms, using secret sharing schemes. One of these platforms may be a Trusted Mobile Agent Computing Base that the originator trusts.
Reference: 19. <author> Richard E. Zippel. </author> <title> Rational function decomposition. </title> <booktitle> In Proceedings of the International Symposium on Symbolic and Algebraic Computation, </booktitle> <pages> pages 1-6. </pages> <publisher> ACM Press, </publisher> <month> July </month> <year> 1991. </year>
Reference-contexts: Interestingly, there are already results on the hardness of decomposing rational functions. No polynomial time algorithm for decomposing multivariate rational functions is known <ref> [19] </ref>! Furthermore, ways to construct rational functions s that we use to garble f and that are easy to invert have been proposed by Shamir [13] in a different context. An in-depth analysis of such a composition approach remains to be carried out.
References-found: 19

