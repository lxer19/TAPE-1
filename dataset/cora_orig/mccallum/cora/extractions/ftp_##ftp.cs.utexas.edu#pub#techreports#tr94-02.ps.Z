URL: ftp://ftp.cs.utexas.edu/pub/techreports/tr94-02.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/psp/
Root-URL: 
Email: e-mail: will@cs.utexas.edu  
Title: Verifying adder circuits using powerlists  
Author: William Adams 
Date: March 29, 1994  
Address: Austin, TX 78712-1188 USA  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract: We define the ripple-carry and the carry-lookahead adder circuits in the powerlist notation and we use the powerlist algebra to prove that these circuits correctly implement addition for natural numbers represented as bit vectors.
Abstract-found: 1
Intro-found: 1
Reference: [0] <author> E W Dijkstra and C S Scholten. </author> <title> Predicate calculus and program semantics. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Other colleagues at UT Austin, notably Al Carruth, Warren Hunt and Jacob Kornerup, made several suggestions for improving the presentation of the material. A Appendix: additional proofs A.0 Proof format Where we give calculational proofs we use the format from Dijkstra and Scholten <ref> [0] </ref>.
Reference: [1] <author> M J C Gordon. </author> <title> Why higher-order logic is a good formalism for specifying and verifying hardware. </title> <type> Technical report 77, </type> <institution> University of Cambridge Computer Laboratory, </institution> <year> 1985. </year>
Reference-contexts: 0 Introduction As hardware designs increase in complexity it is less possible to reason informally about their behaviour, or to exhaustively test all possible behaviours. Several researchers have used formal systems for hardware verification, such as the Boyer-Moore logic [2], HOL <ref> [1] </ref>, Nuprl [5] and Ruby [3]. We propose the use of a new data structure, the powerlist , for circuit verification. We show how powerlists may be used to express circuits and reason about their correctness. The powerlist data structure has been recently introduced by Misra [6].
Reference: [2] <author> Warren A Hunt, Jr and Bishop C Brock. </author> <title> Verification of a bit-slice ALU . Technical report 49, </title> <booktitle> Computational Logic Inc, </booktitle> <year> 1989. </year> <month> 33 </month>
Reference-contexts: 0 Introduction As hardware designs increase in complexity it is less possible to reason informally about their behaviour, or to exhaustively test all possible behaviours. Several researchers have used formal systems for hardware verification, such as the Boyer-Moore logic <ref> [2] </ref>, HOL [1], Nuprl [5] and Ruby [3]. We propose the use of a new data structure, the powerlist , for circuit verification. We show how powerlists may be used to express circuits and reason about their correctness. The powerlist data structure has been recently introduced by Misra [6]. <p> The style of definition we use is similar to that used by Hunt and Brock <ref> [2] </ref>, except they used Lisp lists where we use powerlists and they provided mappings down to the hardware level. The input and output values of circuits are given in terms of values from the set f0; 1g, which we call bits.
Reference: [3] <author> Geraint Jones and Mary Sheeran. </author> <title> Circuit design in Ruby. </title> <editor> In Jtrgen Staunstrup, editor, </editor> <title> Formal methods for VLSI design. </title> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: 0 Introduction As hardware designs increase in complexity it is less possible to reason informally about their behaviour, or to exhaustively test all possible behaviours. Several researchers have used formal systems for hardware verification, such as the Boyer-Moore logic [2], HOL [1], Nuprl [5] and Ruby <ref> [3] </ref>. We propose the use of a new data structure, the powerlist , for circuit verification. We show how powerlists may be used to express circuits and reason about their correctness. The powerlist data structure has been recently introduced by Misra [6].
Reference: [4] <author> Jacob Kornerup. </author> <title> Mapping powerlists onto hypercubes. </title> <type> PhD thesis, </type> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <year> 1994. </year> <note> In preparation. </note>
Reference-contexts: Kornerup <ref> [4] </ref> has another example where j and 1 are defined differently, using the Gray-code and inverse Gray-code permutations.
Reference: [5] <author> Miriam Leeser. </author> <title> Using Nuprl for the verification and synthesis of hardware. </title> <journal> Philosopical Transactions of the Royal Society, </journal> <volume> A 339, </volume> <pages> 49-68, </pages> <year> 1992. </year>
Reference-contexts: 0 Introduction As hardware designs increase in complexity it is less possible to reason informally about their behaviour, or to exhaustively test all possible behaviours. Several researchers have used formal systems for hardware verification, such as the Boyer-Moore logic [2], HOL [1], Nuprl <ref> [5] </ref> and Ruby [3]. We propose the use of a new data structure, the powerlist , for circuit verification. We show how powerlists may be used to express circuits and reason about their correctness. The powerlist data structure has been recently introduced by Misra [6].
Reference: [6] <author> Jayadev Misra. Powerlist: </author> <title> a structure for parallel recursion (preliminary version). In A W Roscoe, editor, A classical mind: </title> <booktitle> essays in honour of C A R Hoare, </booktitle> <pages> pages 295-316. </pages> <publisher> Prentice Hall International, </publisher> <year> 1994. </year> <month> 34 </month>
Reference-contexts: We propose the use of a new data structure, the powerlist , for circuit verification. We show how powerlists may be used to express circuits and reason about their correctness. The powerlist data structure has been recently introduced by Misra <ref> [6] </ref>. It provides a notation for compactly expressing synchronous parallel computations in a functional programming style and an algebra within which properties of such computations can be proven. <p> We can derive other algorithms for the prefix computation which have running time logarithmic in the length of the input list. These algorithms use 1 to deconstruct the list in the recursive case. See <ref> [6] </ref> for details. The following lemma shows how [x ?] distributes over 7! .
References-found: 7

