URL: http://www.cs.ucsb.edu/conferences/java98/papers/jfft.ps
Refering-URL: http://www.cs.ucsb.edu/conferences/java98/program.html
Root-URL: http://www.cs.ucsb.edu
Email: -glossner,jthilio,stamatis-@cardit.et.tudelft.nl  
Phone: 2  
Title: Java Signal Processing: FFTs with bytecodes  
Author: John Glossner, ; Jesse Thilo, ; and Stamatis Vassiliadis 
Date: February 7, 1998  
Address: Allentown, Pa  Netherlands  
Affiliation: 1 Lucent Bell Labs,  Delft University of Technology, Delft, The  
Abstract: This paper investigates the possibility of using Java as a language for Digital Signal Processing. We compare the performance of the Fast Fourier Transform using Java interpreters, compilers, and native execution. To characterize the Java language as a platform for signal processing, we have implemented a traditional FFT algorithm in both C and Java and compared their relative performance. Additionally, we have developed a Tensor algebra FFT library in both Matlab and Java. Each of the Tensor libraries has been coded to exploit the characteristics of the source language. Our results indicate that the latest Sun Solaris 2.6 Java platform can provide performance within 20% to 60% of optmized C code on short FFT computations. On longer FFT computations, Java is about a factor of 2 to 3 times less ecient than optimized C code. We anticipate this gap to narrow with better compiler technology and direct execution on Java processors such as the Delft-Java multithreaded processor.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> James Gosling, Bill Joy, and Guy Steele, </author> <title> editors. The Java Language Specitcation. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction Java is a new C++-like programming language designed for general-purpose, concurrent, class-based object-oriented programming <ref> [1] </ref>. The language includes a number of useful programming features including: 1) programmer detned parallelism in the form of synchronized threads, 2) strong typing, 3) garbage collection, 4) classes, 5) inheritance, and 6) dynamic linking. An appeal of the language is a write once, run anywhere philosophy [2].
Reference: [2] <author> James Gosling and Henry McGilton. </author> <title> The Java Language Environment: A White Paper. </title> <type> Technical report, </type> <institution> Sun Microsystems, Mountain View, California, </institution> <month> October </month> <year> 1995. </year> <note> Available from ftp.javasoft.com/docs. </note>
Reference-contexts: The language includes a number of useful programming features including: 1) programmer detned parallelism in the form of synchronized threads, 2) strong typing, 3) garbage collection, 4) classes, 5) inheritance, and 6) dynamic linking. An appeal of the language is a write once, run anywhere philosophy <ref> [2] </ref>. This is accomplished by providing a Java Virtual Machine (JVM) interpreter and runtime for each platform supported [3]. In theory, any platform that supports the Java runtime environment will produce the same execution results independent of the platform.
Reference: [3] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specitcation. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <year> 1997. </year>
Reference-contexts: An appeal of the language is a write once, run anywhere philosophy [2]. This is accomplished by providing a Java Virtual Machine (JVM) interpreter and runtime for each platform supported <ref> [3] </ref>. In theory, any platform that supports the Java runtime environment will produce the same execution results independent of the platform. Because of Java's interpreted execution, it has been asserted that Java is inappropriate for Signal Processing applications. <p> The architecture has two logical views: 1) a JVM Instruction Set Architecture (ISA) and 2) a RISC-based ISA. The JVM is a stack-based ISA with support for standard datatypes, synchronization, object-oriented method invocation, arrays, and object allocation <ref> [3] </ref>. An important property of Java bytecodes is that statically determinable type state enables simple on-the-y translation of bytecodes into ecient machine code [5]. We utilize this property to dynamically translate Java bytecodes into Delft-Java instructions.
Reference: [4] <author> C. John Glossner and Stamatis Vassiliadis. </author> <title> The Delft-Java Engine: An Introduction. </title> <booktitle> In Lecture Notes In Computer Science. Third International Euro-Par Conference (Euro-Par'97 Parallel Processing), </booktitle> <pages> pages 766770, </pages> <address> Passau, Germany, Aug. 26 - 29 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We investigate this hypothesis by comparing the performance of a traditional Fast Fourier Transform (FFT) algorithm originally written in C and translated to Java. We then extend our analysis to a Tensor algebra FFT library coded in both Matlab and Java. We have also designed the Delft-Java processor <ref> [4] </ref>. An important feature of this architecture is that it has been designed to eciently execute JVM bytecodes. The architecture has two logical views: 1) a JVM Instruction Set Architecture (ISA) and 2) a RISC-based ISA.
Reference: [5] <author> James Gosling. </author> <title> Java Intermediate Bytecodes. </title> <journal> In ACM SIGPLAN Notices, </journal> <pages> pages 111118, </pages> <address> New York, NY, </address> <month> January </month> <year> 1995. </year> <title> Association for Computing Machinery. </title> <booktitle> ACM SIGPLAN Workshop on Intermediate Representations (IR95). </booktitle>
Reference-contexts: The JVM is a stack-based ISA with support for standard datatypes, synchronization, object-oriented method invocation, arrays, and object allocation [3]. An important property of Java bytecodes is that statically determinable type state enables simple on-the-y translation of bytecodes into ecient machine code <ref> [5] </ref>. We utilize this property to dynamically translate Java bytecodes into Delft-Java instructions. Because the bytecodes are stored as pure Java instructions, Java programs generated by Java compilers execute on a Delft-Java processor without moditcation. We have previously developed a Matlab implementation of a Tensor algebra library [6].
Reference: [6] <author> C. John Glossner, Gerald G. Pechanek, Stamatis Vassiliadis, and Joe Landon. </author> <title> High-Performance Parallel FFT Algorithms on M.f.a.s.t. Using Tensor Algebra. </title> <booktitle> In Proceedings of the Signal Processing Applications Conference at DSPx'96, </booktitle> <pages> pages 529536, </pages> <address> San Jose Convention Center, San Jose, Ca., </address> <month> March 11-14 </month> <year> 1996. </year>
Reference-contexts: We utilize this property to dynamically translate Java bytecodes into Delft-Java instructions. Because the bytecodes are stored as pure Java instructions, Java programs generated by Java compilers execute on a Delft-Java processor without moditcation. We have previously developed a Matlab implementation of a Tensor algebra library <ref> [6] </ref>. For this analysis, we developed an equivalent library in Java. A key point of each implementation is that it is written to utilize important features of the source language. The Matlab implementation utilizes a vector encoding and takes advantage of the built-in Complex datatype.
Reference: [7] <author> Marshall C. Pease. </author> <title> An Adaptation of the Fast Fourier Transform for Parallel Processing. </title> <journal> Journal of the ACM, </journal> <volume> 15(2):252264, </volume> <month> April </month> <year> 1968. </year>
Reference-contexts: Each Tensor algebra implementation is built from basic functions. 1 A stage of an FFT is built by executing a number of parallel FFTs followed by a Permutation phase. The mathematical description of the algorithm is a parallel decomposition based on Pease <ref> [7] </ref> and is only briey summarized along with one possible mapping to a multithreaded processor. More detailed detnitions of the Kronecker product (denoted by ) can be found in [8, 9]. In Section 2 we give a brief introduction to Tensor algebra and the Fast Fourier Transform.
Reference: [8] <author> J.R. Johnson, R.W. Johnson, D. Rodriguez, and R. Tolimieri. </author> <title> A Methodology for Designing, Modifying, and Implementing Fourier Transform Algorithms on Various Architectures. Circuits Systems Signal Process, </title> <address> 9(4):449500, </address> <year> 1990. </year>
Reference-contexts: The mathematical description of the algorithm is a parallel decomposition based on Pease [7] and is only briey summarized along with one possible mapping to a multithreaded processor. More detailed detnitions of the Kronecker product (denoted by ) can be found in <ref> [8, 9] </ref>. In Section 2 we give a brief introduction to Tensor algebra and the Fast Fourier Transform. In Section 3 we present the results of two studies. The trst study compares optimized C and Java FFT routines.
Reference: [9] <author> R. Tolimieri, M. An, and C. Lu. </author> <title> Algorithms for Discrete Fourier Transform and Convolution. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: The mathematical description of the algorithm is a parallel decomposition based on Pease [7] and is only briey summarized along with one possible mapping to a multithreaded processor. More detailed detnitions of the Kronecker product (denoted by ) can be found in <ref> [8, 9] </ref>. In Section 2 we give a brief introduction to Tensor algebra and the Fast Fourier Transform. In Section 3 we present the results of two studies. The trst study compares optimized C and Java FFT routines. <p> However, we can use a class of permutations called stride permutations which will commute the tensor product. Furthermore, these stride permutations govern the load and store data addressing between stages of the tensor product decompositions of DSP algorithms <ref> [9] </ref>. The permutation matrix partitions the computations and communications by changing the dataows from vector to parallel or from parallel to vector dataows.
Reference: [10] <author> S. K. S. Gupta. </author> <title> Synthesizing Communication-Ecient Distrubted-Memory Parallel Programs for Block Recursive Algorithms. </title> <type> PhD dissertation, </type> <institution> The Ohio State University, Computer Science Department, </institution> <year> 1995. </year>
Reference-contexts: It is also possible to rearrange the tensor formulation so that communication through shared memory is minimized <ref> [10] </ref>. For the purposes of this paper, Equations (4-8) provide adequate comparison performance.
Reference: [11] <author> William H. Press, Saul A. Teukolskey, William T. Vetterling, and Brian P. Flannery. </author> <title> Numerical Recipes in C: </title> <booktitle> The Art of Scientitc Computing. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, 2 edition, </address> <year> 1992. </year>
Reference-contexts: We measure the execution time of the algorithms and not the time to load the interpreters or the time to compile the C code. The trst experiment investigates a traditional FFT algorithm from Press <ref> [11] </ref>. The C code is compiled using gcc 2.7.2. Results are presented for unoptimized and -O3 optimized execution. The C program was then hand-translated into an equivalent Java program. The resulting code does not take advantage of most of the Java programming constructs.
Reference: [12] <author> Todd A. Proebsting, Gregg Townsend, Patrick Bridges, John H. Hartman, Tim Newsham, and Scott A. Watterson. Toba: </author> <title> Java For Applications AWay Ahead of Time (WAT) Compiler. </title> <booktitle> In Proceedings Third Conference on Object-Oriented Technologies and Systems (COOTS'97), </booktitle> <year> 1997. </year> <month> 5 </month>
Reference-contexts: The Sun Solaris 2.6 results are for the built-in Java interpreter with JIT that comes standard as part of the Solaris 2.6 installation. The Sun JDK 1.1.4 results are reported for comparison. The Kae 0.9.2 just-in-time compiler results are also presented for comparison . The Toba <ref> [12] </ref> results are for the 1.0b6 beta release. Toba o-line translates Java bytecodes to C code. The C code was then compiled with gcc 2.7.2 with -O3 optimization. Table 1 shows that the best performance in all cases was for optimized C code.
References-found: 12

