URL: ftp://cse.ogi.edu/pub/pacsoft/papers/CalculatingGenerators.ps
Refering-URL: http://www.cse.ogi.edu/~dick/dick.html
Root-URL: http://www.cse.ogi.edu
Title: Calculating Software Generators from Solution Specifications produce a generator for modules that validate and translate
Author: Richard B. Kieburtz Francoise Bellegarde Jef Bell James Hook Jeffrey Lewis Dino Oliva Tim Sheard Lisa Walton Tong Zhou 
Note: The technique and the system have been applied to  The research reported here has been sponsored by the USAF Materiel Command.  
Date: October 14, 1994  
Address: PO Box 91000, Portland, OR 97291-1000 USA  
Affiliation: Pacific Software Research Center Oregon Graduate Institute of Science Technology  
Abstract: Software application generators can eliminate many of the technical aspects of programming for most computer users. We have developed a uniform approach to the design of program generators, based upon a simple idea|provide a declarative specification language for each application domain and give it a computable, denotational semantics. To make this idea practical, however, requires a comprehensive system for transforming and translati-ing expressions in the higher-order functional operators of the semantics formulation into a reasonably efficient implementation expressed in a first-order, imperative programming language. This paper describes the system we have built to accomplish this. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Jeffrey M. Bell and James Hook. </author> <title> Defunctionalization of typed programs. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: This specialization increases the size of the program but has no negative impact on its execution time. Generation of an appropriate data structure to represent closures <ref> [22, 1] </ref> leads to a more general but less straightforward approach for this class of transformations. Specialization of functions can also be used to eliminate parametric polymorphism in a program.
Reference: [2] <author> F. Bellegarde. </author> <title> A transformation system combining partial evaluation with term rewriting. In Higher Order Algebra, Logic and Term Rewriting (HOA '93), </title> <booktitle> volume 816 of Lecture Notes in Computer Science, </booktitle> <pages> pages 40-58. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1993. </year>
Reference-contexts: Laws justify tactics such as recursion elimination, which can sometimes reduce the asymptotic complexity of an algorithm. Unfortunately, it is very difficult to fully automate the application of such tactics. Astre is a transformation tool based on rewriting techniques <ref> [2] </ref>. It is flexible enough so that some tactics can be fully automated. An example is the elimination of structural recursion by accumulator introduction in the presence of an associative operator, which is the familiar foldr-to-foldl transformation when specialized to list algebras.
Reference: [3] <author> F. Bellegarde. </author> <title> Termination issues in automated syntheses. </title> <note> Submitted to RTA95, </note> <month> September </month> <year> 1994. </year>
Reference-contexts: Astre controls the orientation of critical pairs into rules as required by the transformation strategy. It guarantees that termination of the rewrite system is preserved during the synthesis. Astre also carefully controls the production of critical pairs hence ensuring termination of the completion <ref> [3] </ref>. Consider, for example, the function that reverses the elements of a list.
Reference: [4] <author> Fran~coise Bellegarde. </author> <title> Program transformation and rewriting. </title> <booktitle> In Proceedings of the fourth conference on Rewriting Techniques and Applications, volume 488 of LNCS, </booktitle> <pages> pages 226-239, </pages> <address> Berlin, 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: It can be exploited by transformation systems based on the unfold-fold method [10], but these require human intervention or ad hoc heuristics to direct them. Term-rewriting, using a theory completion process for control, provides a flexible basis for implementing algebra-specific transformations <ref> [12, 4] </ref>. Such systems perform transformations on first-order programs. Parametric transformation strategies can also be performed by term-rewriting methods. Algebra-specific transformations are more costly and more difficult to automate than parametric transformations but they can have a dramatic impact on the performance of programs.
Reference: [5] <author> Richard S. Bird. </author> <title> An introduction to the theory of lists. </title> <editor> In M. Broy, editor, </editor> <booktitle> Logic of Programming and Calculi of Discrete Design, volume 36 of NATO Series F. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: ADL also incorporates a dual concept of coalgebras, which contribute control structures that correspond naturally to iteration. 3.1 Structure algebras in ADL Some structure algebras, most notably the algebra of lists, are familiar to functional programmers and have been used by Bird, Meertens and their students <ref> [5, 17, 18, 13] </ref> to derive programs from logical specifications by formal reasoning.
Reference: [6] <author> W.H. Burge. </author> <title> Recursive Programming Techniques. </title> <publisher> Addison-Wesley, </publisher> <year> 1975. </year>
Reference-contexts: These prob lems can be addressed by two parametric transformation strategies: * fusion or deforestation, in which identical control structures of sequentially applied functions are merged, often allowing an intermediate data structure to be elimi nated [27, 9], and * the tupling or parallel fusion strategy <ref> [6, 10] </ref>. in which a pair of functions that operate on the same data are transformed into a single function that returns paired results.
Reference: [7] <author> P. Chatelin. </author> <title> Program manipulation: to duplicate is not to complicate. </title> <type> Technical report, </type> <institution> Universite de Grenoble, </institution> <year> 1976. </year> <type> Technical Report CNRS, </type> <institution> Laboratoire d'informatique. </institution>
Reference-contexts: A more sophisticated instance of this strategy eliminates one recursive call in the following example [21], originally proposed by P. Chatelin <ref> [7] </ref>. height (tip (x)) ! 0 height (tree (lt; rt)) ! 1 + max (height (lt); height (rt)) Here the recursive calls occurs under two associative operators with left and right unit, namely (+) and max.
Reference: [8] <author> W. Chin and J. Darlington. </author> <title> Higher-order removal: A modular approach. Unpublished work, </title> <booktitle> 1993. </booktitle> <pages> 16 </pages>
Reference-contexts: This transformation sometimes enables an expression in the body of a function declaration to be statically reduced, and is a prerequisite to further steps of function specialization and reduction. This transformation has been studied by Chin and Dar lington <ref> [8] </ref>, who refer to it as Algorithm A for higher-order function removal. * Specializing a function to the arguments found at each of its call sites is a familiar technique for order-reduction (see for instance, Algorithm R of [8]). Specialization occurs in two phases. <p> This transformation has been studied by Chin and Dar lington <ref> [8] </ref>, who refer to it as Algorithm A for higher-order function removal. * Specializing a function to the arguments found at each of its call sites is a familiar technique for order-reduction (see for instance, Algorithm R of [8]). Specialization occurs in two phases. A naive but efficient algorithm is effective in nearly all cases that arise in practice. For cases that are beyond the scope of the naive algorithm, we have implemented a more general specializer based upon Reynolds algorithm [22].
Reference: [9] <author> Wei-Ngan Chin. </author> <title> Safe fusion of functional expressions. </title> <booktitle> In Proc. of 1992 ACM Conf. on Lisp and Functional Programming, </booktitle> <pages> pages 11-20, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: These prob lems can be addressed by two parametric transformation strategies: * fusion or deforestation, in which identical control structures of sequentially applied functions are merged, often allowing an intermediate data structure to be elimi nated <ref> [27, 9] </ref>, and * the tupling or parallel fusion strategy [6, 10]. in which a pair of functions that operate on the same data are transformed into a single function that returns paired results.
Reference: [10] <author> J. Darlington and R. Burstall. </author> <title> A system which automatically improves programs. </title> <journal> Acta Informatica, </journal> <volume> 6(1) </volume> <pages> 41-60, </pages> <year> 1976. </year>
Reference-contexts: These prob lems can be addressed by two parametric transformation strategies: * fusion or deforestation, in which identical control structures of sequentially applied functions are merged, often allowing an intermediate data structure to be elimi nated [27, 9], and * the tupling or parallel fusion strategy <ref> [6, 10] </ref>. in which a pair of functions that operate on the same data are transformed into a single function that returns paired results. <p> A property like the associativity and commutativity of multiplication over natural numbers is not parametric. Associativity is necessary to apply the accumulator-introduction strategy that eliminates recursion in favor of iteration. It can be exploited by transformation systems based on the unfold-fold method <ref> [10] </ref>, but these require human intervention or ad hoc heuristics to direct them. Term-rewriting, using a theory completion process for control, provides a flexible basis for implementing algebra-specific transformations [12, 4]. Such systems perform transformations on first-order programs. Parametric transformation strategies can also be performed by term-rewriting methods.
Reference: [11] <author> N. Dershowitz. </author> <title> Synthesis by completion. </title> <booktitle> In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 208-214, </pages> <address> Los Angeles, </address> <year> 1985. </year>
Reference-contexts: Rewriting enables both folding and unfolding of definitions, depending upon the orientation of the equations as rules. Critical pair computation performs both instantiation and unfolding, hence providing an implemention for transformation by the unfold/fold methodology. This technique has been called synthesis by completion <ref> [11, 12] </ref>.
Reference: [12] <author> Nachum Dershowitz. </author> <title> Completion and its applications. In Resolution of Equations in Algebraic Structures. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: It can be exploited by transformation systems based on the unfold-fold method [10], but these require human intervention or ad hoc heuristics to direct them. Term-rewriting, using a theory completion process for control, provides a flexible basis for implementing algebra-specific transformations <ref> [12, 4] </ref>. Such systems perform transformations on first-order programs. Parametric transformation strategies can also be performed by term-rewriting methods. Algebra-specific transformations are more costly and more difficult to automate than parametric transformations but they can have a dramatic impact on the performance of programs. <p> Rewriting enables both folding and unfolding of definitions, depending upon the orientation of the equations as rules. Critical pair computation performs both instantiation and unfolding, hence providing an implemention for transformation by the unfold/fold methodology. This technique has been called synthesis by completion <ref> [11, 12] </ref>.
Reference: [13] <author> Maarten M. Fokkinga. </author> <title> Law and Order in Algorithmics. </title> <type> PhD thesis, </type> <institution> University of Twente, Twente, </institution> <address> The Netherlands, </address> <month> February </month> <year> 1992. </year>
Reference-contexts: ADL also incorporates a dual concept of coalgebras, which contribute control structures that correspond naturally to iteration. 3.1 Structure algebras in ADL Some structure algebras, most notably the algebra of lists, are familiar to functional programmers and have been used by Bird, Meertens and their students <ref> [5, 17, 18, 13] </ref> to derive programs from logical specifications by formal reasoning.
Reference: [14] <author> Thomas Johnsson. </author> <title> Lambda lifting: transforming programs to recursive equations. </title> <editor> In J-P. Jouannaud, editor, </editor> <booktitle> Functiona Programming Languages and Computer Architecture, volume 201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 190-203. </pages> <publisher> Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Obviously, this is only possible for programs that calculate ground-typed results from ground-typed data. The order-reduction stage in our translation pipeline consists of a suite of individual algorithms that perform specific order-reduction transformations efficiently. These are: * A lambda-lifter <ref> [14] </ref>, which removes nested function declarations and explicit abstractions, replacing them by new, closed function declarations and replacings occurrences of locally defined functions by applications of the new function constants. (Some nested declarations may be reintroduced during code generation, but if left in place throughout the pipeline, they might interfere with
Reference: [15] <author> Richard B. Kieburtz and Jeffrey Lewis. </author> <title> Algebraic Design Language|Preliminary definition. </title> <type> Technical report, </type> <institution> Pacific Software Research Center, Oregon Graduate Institute of Science & Technology, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: Our tactic for making a specification language computable is to formalize its intuitive meaning in terms of a computable denotational semantics expressed in an executable meta-language. We have designed the ADL language <ref> [15] </ref> as our preferred meta-language. ADL is an acronym for Algebraic Design Language. It adapts the notion of structure algebras from the mathematics of universal algebras to provide an unusually rich control structure without employing an explicit recursion operator.
Reference: [16] <author> Grant Malcolm. </author> <title> Homomorphisms and promotability. </title> <editor> In J. L. A. van de Snepscheut, editor, </editor> <booktitle> Mathematics of Program Construction, volume 375 of Lecture Notes in Computer Science, </booktitle> <pages> pages 335-347. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: However, the control structure of programs is exactly what we are interested in when looking for transformations to apply. 3.3 A tool for parametric transformations A parametric transformation schema has an instance for every variety of structure algebra. The quintessential parametric transformation is based upon the Promotion Theorem <ref> [16] </ref>. This theorem and the transformation derived from it are most easily presented with the help of some notation from category theory. The data of a signature with type parameter a consists of the domain typings of its operators.
Reference: [17] <author> Lambert Meertens. </author> <title> Algorithmics|towards programming as a mathematical activity. </title> <booktitle> In Proc. of the CWI Symbposium on Mathematics and Computer Science, </booktitle> <pages> pages 289-334. </pages> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference-contexts: ADL also incorporates a dual concept of coalgebras, which contribute control structures that correspond naturally to iteration. 3.1 Structure algebras in ADL Some structure algebras, most notably the algebra of lists, are familiar to functional programmers and have been used by Bird, Meertens and their students <ref> [5, 17, 18, 13] </ref> to derive programs from logical specifications by formal reasoning.
Reference: [18] <author> Erik Meijer, Maarten Fokkinga, and Ross Paterson. </author> <title> Functional programming with bananas, lenses, envelopes and barbed wire. </title> <booktitle> In Proc. of 5th ACM Conf. on Functional Programming Languages and Computer Architecture, volume 523 of Lecture Notes in Computer Science, </booktitle> <pages> pages 124-144. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: ADL also incorporates a dual concept of coalgebras, which contribute control structures that correspond naturally to iteration. 3.1 Structure algebras in ADL Some structure algebras, most notably the algebra of lists, are familiar to functional programmers and have been used by Bird, Meertens and their students <ref> [5, 17, 18, 13] </ref> to derive programs from logical specifications by formal reasoning. <p> However, the recursion is not explicit in ADL, it is instead calculated from the signature declaration given for the variety list. The combinator red is also called a catamorphism combinator <ref> [18] </ref>. The combinator hom generalizes the reduction scheme implicit in red to that of more general structure algebra morphisms. The domain of a hom expression need not be the carrier of an initial term algebra of the specified variety. Its domain may be any nonfunctional type.
Reference: [19] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: The type parameter, a, instantiated to any type, determines a particular instance of a free list algebra. Thus the carrier of a free term algebra derived from the variety list corresponds exactly to an instance of a list datatype in a functional programming language such as Standard ML <ref> [19] </ref>. For each variety declared by a signature in an ADL program, its free term algebra functor is declared implicitly. In ADL, we distinguish two degrees of knowledge of the structure of an algebra. <p> Some possible target languages (`C', for instance) impose restrictions on the declarations of nested scopes. The PI does not currently provide for such restrictions. 7 Implementing the pipeline The translation and transformation tools described in the preceding sections have all been implemented in Standard ML (SML) <ref> [19] </ref> except for Astre, the term-rewriting transformation tool, which is implemented in CAML. Furthermore, a restricted sublanguage of SML is used for the intermediate representation of programs as they are passed through the pipeline. An abstract syntax representation of SML is used internally by each tool.
Reference: [20] <author> Peter D. Mosses. </author> <title> Sis|semantics implementation system: reference manual and user guide. </title> <type> Technical Report DAIMI MD-30, </type> <institution> Computer Science Department, University of Aarhus, </institution> <year> 1979. </year>
Reference-contexts: The requirement that all semantic functions must be total allows us to use equational theories to drive program transformations. The idea of deriving an implementation for a formally specified language from its semantics was first tried experimentally in the SIS system <ref> [20] </ref> over 25 years ago. However, at that time, the prospect of a technology to improve the performance of an implementation enough that it would become acceptable for practical use seemed remote.
Reference: [21] <author> A. Petorossi and M. Priotti. </author> <title> Rules and strategies for program transformation. In Formal Program Development, </title> <booktitle> IFIP TC2/WG2.1 State of the Art Report, volume 755 of Lecture Notes in Computer Science, </booktitle> <pages> pages 263-304. </pages> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: A more sophisticated instance of this strategy eliminates one recursive call in the following example <ref> [21] </ref>, originally proposed by P. Chatelin [7]. height (tip (x)) ! 0 height (tree (lt; rt)) ! 1 + max (height (lt); height (rt)) Here the recursive calls occurs under two associative operators with left and right unit, namely (+) and max.
Reference: [22] <author> John C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In ACM National Conference, </booktitle> <pages> pages 717-740. </pages> <publisher> ACM, </publisher> <year> 1972. </year>
Reference-contexts: This specialization increases the size of the program but has no negative impact on its execution time. Generation of an appropriate data structure to represent closures <ref> [22, 1] </ref> leads to a more general but less straightforward approach for this class of transformations. Specialization of functions can also be used to eliminate parametric polymorphism in a program. <p> Specialization occurs in two phases. A naive but efficient algorithm is effective in nearly all cases that arise in practice. For cases that are beyond the scope of the naive algorithm, we have implemented a more general specializer based upon Reynolds algorithm <ref> [22] </ref>.
Reference: [23] <author> Tim Sheard and Leonidas Fegaras. </author> <title> A fold for all seasons. </title> <booktitle> In Proceedings of the conference on Functional Programming and Computer Architecture, </booktitle> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: fc 0 g. 7 E T (a; T (a)) - T (a) ? ? E T (a; c) - c ? ? E T (a; c 0 ) - c 0 The higher-order transformation tool, HOT, uses a clever heuristic tactic to calculate an operator that satisfies the promotion theorem <ref> [24, 23] </ref>. The tactic is not complete|it does not always find a candidate if one exists|but it is inexpensive to apply and it often succeeds.
Reference: [24] <author> Timothy Sheard. </author> <title> Optimizing algebraic programs. </title> <type> Technical Report OGI-CSE-94-004, </type> <institution> Oregon Graduate Institute of Science & Technology, </institution> <month> January </month> <year> 1994. </year> <month> 17 </month>
Reference-contexts: fc 0 g. 7 E T (a; T (a)) - T (a) ? ? E T (a; c) - c ? ? E T (a; c 0 ) - c 0 The higher-order transformation tool, HOT, uses a clever heuristic tactic to calculate an operator that satisfies the promotion theorem <ref> [24, 23] </ref>. The tactic is not complete|it does not always find a candidate if one exists|but it is inexpensive to apply and it often succeeds.
Reference: [25] <author> Dennis Volpano and Richard B. Kieburtz. </author> <title> Software templates. </title> <booktitle> In Proceedings Eighth International Conference on Software Engineering, </booktitle> <pages> pages 55-60. </pages> <publisher> IEEE Computer Society, </publisher> <month> August </month> <year> 1985. </year>
Reference-contexts: To provide for alternate implementations, a back-end tool called the Program Instantiator generates target code to meet requirements imposed on a desired implementation. The Program Instantiator (abbreviated PI) is based upon earlier research by Dennis Volpano <ref> [25, 26] </ref>.
Reference: [26] <author> Dennis Volpano and Richard B. Kieburtz. </author> <title> The templates approach to software reuse. </title> <editor> In Ted J. Biggersstaff and Alan J. Perlis, editors, </editor> <booktitle> Software Reusability, </booktitle> <pages> pages 247-255. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: To provide for alternate implementations, a back-end tool called the Program Instantiator generates target code to meet requirements imposed on a desired implementation. The Program Instantiator (abbreviated PI) is based upon earlier research by Dennis Volpano <ref> [25, 26] </ref>.
Reference: [27] <author> P. Wadler. </author> <title> Deforestation: Transforming programs to eliminate trees. </title> <booktitle> In 2nd European Symposium on Programming ESOP'88, volume 300 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <month> 18 </month>
Reference-contexts: These prob lems can be addressed by two parametric transformation strategies: * fusion or deforestation, in which identical control structures of sequentially applied functions are merged, often allowing an intermediate data structure to be elimi nated <ref> [27, 9] </ref>, and * the tupling or parallel fusion strategy [6, 10]. in which a pair of functions that operate on the same data are transformed into a single function that returns paired results.
References-found: 27

