URL: http://www.math.luc.edu/~laufer/ftp/papers/functoids.ps.gz
Refering-URL: http://www.progsoc.uts.edu.au/~geldridg/cpp/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: laufer@math.luc.edu  
Title: A Framework for Higher-Order Functions in C++ in C++ by enclosing a function inside an
Author: Konstantin Lufer 
Note: In fact, function closures can be modeled directly  is captured by data members of the object. This idiom is described in  
Address: Chicago  
Affiliation: Loyola University of  
Abstract: The purpose of this paper is twofold: First, we demonstrate how this idiom can be generalized to a type-safe framework of C++ class templates for higher-order functions that support composition and partial application. Second, we explore the expressiveness of the framework and compare it with that of existing functional programming languages. We illustrate by means of various examples that object-oriented and functional idioms can coexist productively and can be used to enhance the functionality of common classes, for example, of nonlinear collections such as trees. A C++ implementation of the framework is available on request. 
Abstract-found: 1
Intro-found: 1
Reference: [App89] <institution> Apple Computer, Inc., Cupertino, CA. </institution> <note> Macintosh Programmers Workshop Pascal 3.0 Reference, </note> <year> 1989. </year>
Reference-contexts: Unlike Khne, Gamma et al. do not establish a relationship between the command and iterator idioms. The command idiom is also known as action or transaction and is used in various object-oriented application frameworks [JF88], including ET++ [WGM88], InterViews [LCI + 92], MacApp <ref> [App89] </ref>, and Unidraw [VL90]. Nevertheless, various existing class libraries provide internal (passive) iterators with weakly-typed interfaces and place the responsibility of applying suitable type casts on the user.
Reference: [Bak93] <author> H. Baker. </author> <title> Iterators: Signs of weakness in object-oriented languages. </title> <journal> ACM OOPS Messenger, </journal> <volume> 4(3):1825, </volume> <month> July </month> <year> 1993. </year>
Reference-contexts: First, it demonstrates how functional programming styles can be incorporated directly in C++ programs. Second, it serves as a case study that shows the practical usefulness of our system. Third, it disproves claims that this style of programming is not supported by C++ <ref> [Bak93] </ref>. The same-fringe problem The fringe of a finite tree is the enumeration of its leaves in left-to-right order. The same-fringe problem is the problem of deciding whether two finite trees have the same fringe.
Reference: [Bor94] <author> Borland, Inc. </author> <title> Borland C/C++ 4.0 Reference Manual, </title> <year> 1994. </year>
Reference-contexts: Nevertheless, various existing class libraries provide internal (passive) iterators with weakly-typed interfaces and place the responsibility of applying suitable type casts on the user. For example, Bor-land C++ <ref> [Bor94] </ref> uses the following internal itera-tor in its container class templates. void Container&lt;Item&gt;::forEach (void (* f )(Item&, void*), void* args); The purpose of the second argument of f and the argument args is to allow passing specific arguments to f.
Reference: [Bre88] <author> T. Breuel. </author> <title> Lexical closures for C++. </title> <booktitle> In Proc. USENIX C++ Conf., </booktitle> <pages> pages 293304, </pages> <address> Denver, CO, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: By contrast, functional and other languages with block structure and nested functions, such as Algol or Pascal, automatically capture all local variables that are used in the closure. Breuel <ref> [Bre88] </ref> solves this shortcoming in C and C++ by allowing functions to be nested. Thunks [Ros95b] provide a solution as well. Another drawback of the functoid framework stems from the way type information is required in instantiations of C++ class templates.
Reference: [CL95] <author> M. Cline and G. Lomow. C++ FAQs. Ad-dison-Wesley, </author> <year> 1995. </year>
Reference-contexts: This fundamental difference in the calling mechanism makes it impossible to use a member function where a nonmember function is expected, for example, as a call-back from an existing class library. The proposed solutions <ref> [Fek91, You92, CL95] </ref> require that the programmer writes a nonmember function that explicitly invokes the C++ member function from a specific receiver.
Reference: [Cop92] <author> J. Coplien. </author> <title> Advanced C++ Programming Styles and Idioms. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: This is possible because objects in C++ are essentially higher-order records, that is, records with fields that can contain not only values, but also functions [Red95]. The idiom of objects that enclose functions is first described by Coplien <ref> [Cop92] </ref>, who calls these objects functors, and further developed by Khne [Kh95], who calls them function objects. In this paper, we use the term functoid for brevity and to avoid confusion with established meanings of functor in other areas of computer science. <p> On the other hand, memory management becomes an important issue when objects are not returned by value [Mey92]. What we want here is both call-by-value and dynamic method selection. Fortunately, the envelope/letter idiom <ref> [Cop92] </ref>, also known as the bridge pattern [GHJV93], gives us a way out of this dilemma. We apply this idiom to the framework as follows. We provide a class template called Fun to capture the interface of our abstraction.
Reference: [Dam94] <author> L. Dami. </author> <title> Software Composition: Towards an Integration of Functional and Object-Oriented Approaches. </title> <type> PhD thesis, </type> <institution> Universit de Genve, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: The heterogeneity problem The fundamental difference between member functions and nonmember functions was recognized by Young [You92] and is called the heterogeneity problem by Dami <ref> [Dam94] </ref>. Technically, a call to a nonmember function requires a stack pointer to store the actual arguments and the address of the function to be called. <p> More seriously, this solution does not work at all for the framework because we create functoids on the y and thus cannot anticipate what wrappers to provide. The solution using partial binding Rescue comes in the form of a solution proposed and implemented by Dami <ref> [Dam94] </ref>, which addresses a more general partial binding problem. In this solution, when we perform a partial binding, we create a data structure that stores the address of the function, the arguments, and code to complete the bindings and invoke the function later. <p> The framework is implemented entirely in the form of C++ class templates, except for a compiler and machine-dependent mechanism for converting member functions to nonmember functions <ref> [Dam94] </ref>. The framework could be translated to other object-oriented languages that support both inheritance and genericity. The main issues in the assessment of our framework are expressiveness and efficiency. To address the first issue, we compare our framework to existing functional programming languages.
Reference: [Dam95] <author> L. Dami. </author> <title> Adding closure support to the C++ compiler. </title> <type> Personal communication, </type> <month> March </month> <year> 1995. </year>
Reference-contexts: While the examples presented in this paper do not require lengthy type parameters, the type information re quired in more complex applications of the framework is likely to get out of hand, especially when higher numbers of arguments are involved. Dami <ref> [Dam95] </ref> suggests extending the compiler to keep track of the required type parameters automatically. There are several sources of inefficiency in the framework as compared to typical implementations of functional languages. First, we use call-by-value to facilitate memory management.
Reference: [ES90] <author> M. Ellis and B. Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction The programming languages C [HS87] and C++ <ref> [ES90] </ref> allow passing functions as arguments to other functions in the form of function pointers. However, since function pointers can refer only to existing functions declared at global or file scope, these function arguments cannot capture local environments. <p> To make this approach work, the function call operator would have to be declared as virtual so that dynamic method selection is used, and functoids would always have to be passed and returned by pointer or reference <ref> [ES90] </ref>. On the other hand, memory management becomes an important issue when objects are not returned by value [Mey92]. What we want here is both call-by-value and dynamic method selection. Fortunately, the envelope/letter idiom [Cop92], also known as the bridge pattern [GHJV93], gives us a way out of this dilemma.
Reference: [Fek91] <author> J. Fekete. WWL, </author> <title> a widget wrapper library for C++, 1991. </title> <institution> Laboratoire de Recherche en Informatique, Orsay. </institution>
Reference-contexts: This fundamental difference in the calling mechanism makes it impossible to use a member function where a nonmember function is expected, for example, as a call-back from an existing class library. The proposed solutions <ref> [Fek91, You92, CL95] </ref> require that the programmer writes a nonmember function that explicitly invokes the C++ member function from a specific receiver.
Reference: [FW76] <author> D. Friedman and D. Wise. </author> <title> CONS should not evaluate its arguments. </title> <editor> In S. Michaelson and R. Milner, editors, </editor> <booktitle> Automata, Languages and Programming, </booktitle> <pages> pages 257284. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1976. </year>
Reference-contexts: The drawback of this approach is that the tree traversal has to be made explicit instead of implicit and recursive. A solution in a functional language In a functional language, this problem could be solved elegantly in terms of lazy streams <ref> [FW76] </ref>. A lazy stream is a recursive data structure that is either an empty stream or a data item paired with a function that evaluates to another stream when invoked.
Reference: [GHJV93] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns. </title> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: The functoid idiom has been used, for example, in call-backs and iterators with type-safe interfaces. A related idiom that focuses on maintaining a binding between a receiver and a function is called command by Gamma et al. <ref> [GHJV93] </ref>. Unlike Khne, Gamma et al. do not establish a relationship between the command and iterator idioms. The command idiom is also known as action or transaction and is used in various object-oriented application frameworks [JF88], including ET++ [WGM88], InterViews [LCI + 92], MacApp [App89], and Unidraw [VL90]. <p> On the other hand, memory management becomes an important issue when objects are not returned by value [Mey92]. What we want here is both call-by-value and dynamic method selection. Fortunately, the envelope/letter idiom [Cop92], also known as the bridge pattern <ref> [GHJV93] </ref>, gives us a way out of this dilemma. We apply this idiom to the framework as follows. We provide a class template called Fun to capture the interface of our abstraction. This is the envelope class, and functoids are passed and returned by value as instances of this class. <p> These class templates are parameterized only by the result type of the function. We illustrate the structure of the framework in the notation used by Gamma et al. <ref> [GHJV93] </ref>, which is an extension of the OMT (Object Modeling Technique) notation [R + 91]. The framework for zero arguments is shown in Figure 1. The framework for one argument is shown in Figure 2.
Reference: [HS87] <author> S. Harbison and G. Steele. </author> <title> C: A Reference Manual. </title> <booktitle> Prentice-Hall, 2nd edition, </booktitle> <year> 1987. </year>
Reference-contexts: 1 Introduction The programming languages C <ref> [HS87] </ref> and C++ [ES90] allow passing functions as arguments to other functions in the form of function pointers. However, since function pointers can refer only to existing functions declared at global or file scope, these function arguments cannot capture local environments.
Reference: [JF88] <author> R. Johnson and B. Foote. </author> <title> Designing reusable classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(2):2235, </volume> <month> June </month> <year> 1988. </year>
Reference-contexts: Unlike Khne, Gamma et al. do not establish a relationship between the command and iterator idioms. The command idiom is also known as action or transaction and is used in various object-oriented application frameworks <ref> [JF88] </ref>, including ET++ [WGM88], InterViews [LCI + 92], MacApp [App89], and Unidraw [VL90]. Nevertheless, various existing class libraries provide internal (passive) iterators with weakly-typed interfaces and place the responsibility of applying suitable type casts on the user.
Reference: [Kla93] <author> H. Klagges. </author> <title> A functional language interpreter integrated into the C++ language system. </title> <type> Masters thesis, </type> <institution> Balliol College, University of Oxford, University Computing Laboratory, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: Third, unlike in functional languages, function closures are controlled by the programmer instead of the compiler. This precludes the sort of optimizations a compiler of a functional language would apply. Other approaches that combine functional languages and C++ include an interpreter accessible within C++ <ref> [Kla93] </ref> and an interpreter written in C++ [RK88]. A detailed comparison with our work would go beyond the scope of this paper.
Reference: [Kh95] <author> T. Khne. </author> <title> Inheritance versus parameterization. </title> <editor> In Christine Mingins and Ber-trand Meyer, editors, </editor> <booktitle> Proc. Technology of Object-Oriented Languages and Systems (TOOLS Pacific 94), </booktitle> <pages> pages 235245, </pages> <publisher> Pren-tice Hall International, Inc., </publisher> <address> London, </address> <year> 1995. </year> <note> Prentice-Hall. For correct version ask author; proceedings contain corrupted version. [LCI + 92] M. </note> <author> Linton, P. Calder, J. Interrante, S. Tang, and J. Vlissides. </author> <title> InterViews 3.1 Reference Manual. </title> <type> CSL, </type> <institution> Stanford University, </institution> <year> 1992. </year>
Reference-contexts: This is possible because objects in C++ are essentially higher-order records, that is, records with fields that can contain not only values, but also functions [Red95]. The idiom of objects that enclose functions is first described by Coplien [Cop92], who calls these objects functors, and further developed by Khne <ref> [Kh95] </ref>, who calls them function objects. In this paper, we use the term functoid for brevity and to avoid confusion with established meanings of functor in other areas of computer science. The functoid idiom has been used, for example, in call-backs and iterators with type-safe interfaces.
Reference: [Mey92] <author> S. Meyers. Effective C++. Addison-Wes-ley, </author> <year> 1992. </year>
Reference-contexts: On the other hand, memory management becomes an important issue when objects are not returned by value <ref> [Mey92] </ref>. What we want here is both call-by-value and dynamic method selection. Fortunately, the envelope/letter idiom [Cop92], also known as the bridge pattern [GHJV93], gives us a way out of this dilemma. We apply this idiom to the framework as follows.
Reference: [MTH90] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In a functional programming language such as ML <ref> [MTH90] </ref>, a function that composes two functions can be expressed as follows: fun compose (f,g) = fn x =&gt; f (g (x)) The form fn x =&gt; e creates an anonymous function with argument x and body e. <p> This technique allows us to delay the generation of the entire fringe: we seemingly construct the fringe like an ordinary list, but the actual construction is performed on demand. In the functional language ML <ref> [MTH90] </ref>, a data structure for lazy streams could be defined as follows. The two cases are called Nil and Cons in analogy to ordinary lists in functional languages.
Reference: [Red95] <author> U. Reddy. </author> <title> The design of Core C++. </title> <type> Unpublished draft, </type> <month> March </month> <year> 1995. </year>
Reference-contexts: This is possible because objects in C++ are essentially higher-order records, that is, records with fields that can contain not only values, but also functions <ref> [Red95] </ref>. The idiom of objects that enclose functions is first described by Coplien [Cop92], who calls these objects functors, and further developed by Khne [Kh95], who calls them function objects.
Reference: [RK88] <author> V. Russo and S. Kaplan. </author> <title> A C++ interpreter for Scheme. </title> <booktitle> In Proc. USENIX C++ Conf., </booktitle> <pages> pages 95108, </pages> <address> Denver, CO, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: This precludes the sort of optimizations a compiler of a functional language would apply. Other approaches that combine functional languages and C++ include an interpreter accessible within C++ [Kla93] and an interpreter written in C++ <ref> [RK88] </ref>. A detailed comparison with our work would go beyond the scope of this paper. While the translation outlined informally in Section 3 is not suitable at present as an efficient implementation of functional languages, the paper demonstrates that the framework provides access to various functional idioms within object-oriented languages.
Reference: [RM92] <author> J. Rose and H. Muller. </author> <title> Integrating the Scheme and C languages. </title> <booktitle> In Proc. ACM Conf. Lisp and Functional Programming, </booktitle> <pages> pages 247259, </pages> <address> San Francisco, </address> <year> 1992. </year>
Reference-contexts: This approach is compiler and machine-dependent; it currently works with the GNU CC compiler [Sta94] on NeXT and Sparc architectures, but could be ported to other languages, compilers, or architectures. A similar mechanism that maps Scheme closure objects to C functions is described by Rose and Muller <ref> [RM92] </ref>. The ObjectKit system for ParcPlace Small-talk allows passing Smalltalk objects, including closures, to C functions [RM92, quoting P. Deutsch]. <p> A similar mechanism that maps Scheme closure objects to C functions is described by Rose and Muller [RM92]. The ObjectKit system for ParcPlace Small-talk allows passing Smalltalk objects, including closures, to C functions <ref> [RM92, quoting P. Deutsch] </ref>.
Reference: [Ros95a] <author> J. Rose. </author> <title> C closures. </title> <type> Personal communication, </type> <month> April </month> <year> 1995. </year>
Reference-contexts: The main issues in the assessment of our framework are expressiveness and efficiency. To address the first issue, we compare our framework to existing functional programming languages. It is a fundamental limitation of most class-based object-oriented languages that each distinct behavior must be given a class name <ref> [Ros95a] </ref>. Consequently, our framework does not provide a mechanism for creating anonymous function closures on the y. This is in contrast to functional languages, in which anonymous closures are routinely passed to and returned from functions.
Reference: [Ros95b] <author> J. Rose. </author> <title> Functional programming and call-by-name in C++. </title> <type> Personal communication, </type> <month> April </month> <year> 1995. </year> <title> [R 91] J. </title> <editor> Rumbaugh et al. </editor> <title> Object-Oriented Model ing and Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Consequently, our framework does not provide a mechanism for creating anonymous function closures on the y. This is in contrast to functional languages, in which anonymous closures are routinely passed to and returned from functions. Rose <ref> [Ros95b] </ref> describes an extension of C++ with parameterless anonymous functions called thunks; a thunk can be converted to a parameterized function by specifying which variables used in the body of the thunk are to be treated as parameters. <p> By contrast, functional and other languages with block structure and nested functions, such as Algol or Pascal, automatically capture all local variables that are used in the closure. Breuel [Bre88] solves this shortcoming in C and C++ by allowing functions to be nested. Thunks <ref> [Ros95b] </ref> provide a solution as well. Another drawback of the functoid framework stems from the way type information is required in instantiations of C++ class templates.
Reference: [Sta94] <author> R. Stallman. </author> <title> Using and Porting GNU CC. Free Software Foundation, </title> <address> Cambridge, Massachusetts, </address> <month> September </month> <year> 1994. </year> <title> Avail able as part of the GCC-2.6.3 distribution. </title>
Reference-contexts: In this solution, when we perform a partial binding, we create a data structure that stores the address of the function, the arguments, and code to complete the bindings and invoke the function later. This approach is compiler and machine-dependent; it currently works with the GNU CC compiler <ref> [Sta94] </ref> on NeXT and Sparc architectures, but could be ported to other languages, compilers, or architectures. A similar mechanism that maps Scheme closure objects to C functions is described by Rose and Muller [RM92].
Reference: [VL90] <author> J. Vlissides and M. Linton. Unidraw: </author> <title> A framework for building domain-specific graphical editors. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 8(3):237268, </volume> <month> July </month> <year> 1990. </year>
Reference-contexts: Unlike Khne, Gamma et al. do not establish a relationship between the command and iterator idioms. The command idiom is also known as action or transaction and is used in various object-oriented application frameworks [JF88], including ET++ [WGM88], InterViews [LCI + 92], MacApp [App89], and Unidraw <ref> [VL90] </ref>. Nevertheless, various existing class libraries provide internal (passive) iterators with weakly-typed interfaces and place the responsibility of applying suitable type casts on the user.
Reference: [WGM88] <author> A. Weinand, E. Gamma, and R. Marty. </author> <title> ET++ An object-oriented application framework in C++. </title> <booktitle> In Proc. ACM Conf. Object-Oriented Programming: Systems, Languages, Applications (OOPSLA), </booktitle> <pages> pages 4657, </pages> <address> San Diego, CA, </address> <year> 1988. </year>
Reference-contexts: Unlike Khne, Gamma et al. do not establish a relationship between the command and iterator idioms. The command idiom is also known as action or transaction and is used in various object-oriented application frameworks [JF88], including ET++ <ref> [WGM88] </ref>, InterViews [LCI + 92], MacApp [App89], and Unidraw [VL90]. Nevertheless, various existing class libraries provide internal (passive) iterators with weakly-typed interfaces and place the responsibility of applying suitable type casts on the user.
Reference: [You92] <author> D. Young. </author> <title> Object-Oriented Programming with C++ and OSF/Motif. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: This shortcoming stems from a fundamental difference between member functions and nonmember functions, which precludes us from simply using a pointer to the function call operator of a functoid as an ordinary function. The heterogeneity problem The fundamental difference between member functions and nonmember functions was recognized by Young <ref> [You92] </ref> and is called the heterogeneity problem by Dami [Dam94]. Technically, a call to a nonmember function requires a stack pointer to store the actual arguments and the address of the function to be called. <p> This fundamental difference in the calling mechanism makes it impossible to use a member function where a nonmember function is expected, for example, as a call-back from an existing class library. The proposed solutions <ref> [Fek91, You92, CL95] </ref> require that the programmer writes a nonmember function that explicitly invokes the C++ member function from a specific receiver.
References-found: 27

