URL: http://www.neci.nj.nec.com/tr/neci-tr-96-2.ps
Refering-URL: http://www.neci.nj.nec.com/tr/index.html
Root-URL: 
Email: avg@research.nj.nec.com  csilvers@theory.stanford.edu  
Title: Implementations of Dijkstra's Algorithm Based on Multi-Level Buckets  
Author: Andrew V. Goldberg Craig Silverstein 
Note: Part of this work was done while the author was  supported in part by NSF Grant CCR-9307045.  
Date: November 1995  
Address: 4 Independence Way Princeton, NJ 08540  Stanford, CA 94305  
Affiliation: NEC Research Institute  Computer Science Department Stanford University  at Computer Science Department, Stanford University, and  
Abstract: A 2-level bucket data structure has been shown to perform well in a Dijkstra's algorithm implementation [4, 5]. In this paper we study how the implementation performance depends on the number of bucket levels used. In particular we are interested in the best number of levels to use in practice. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. K. Ahuja, K. Mehlhorn, J. B. Orlin, and R. E. Tarjan. </author> <title> Faster Algorithms for the Shortest Path Problem. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 37(2) </volume> <pages> 213-223, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Under the assumption that arc lengths are integers in the interval [0; : : :; C], C 2, the implementation of <ref> [1] </ref> runs in O (m + n p log C) time. In a recent computational study [4, 5], however, a 2-level bucket implementation of Dijk-stra's algorithm gave the best overall performance among the codes studied. <p> In addition, the algorithm examines each edge exactly once. The worst-case complexity of Dijkstra's algorithm depends on the method used to find the labeled node with the smallest distance label. The implementation using Fibonacci heaps [11] runs in O (m + n log n) time. The implementation using R-heaps <ref> [1] </ref> runs in O (m + n p log C) time. 4 Multi-Level Bucket Implementation 4.1 1-level Bucket Implementation Another way to implement Dijkstra's algorithm is by using the bucket data structure, proposed independently by Dial [7], Wagner [18], and Dinitz [9].
Reference: [2] <author> R. E. Bellman. </author> <title> On a Routing Problem. </title> <journal> Quart. Appl. Math., </journal> <volume> 16 </volume> <pages> 87-90, </pages> <year> 1958. </year>
Reference-contexts: 1 Introduction The shortest paths problem is a fundamental network optimization problem. Algorithms for this problem have been studied for a long time. (See e.g. <ref> [2, 7, 8, 10, 14, 15, 16] </ref>.) An important special case of the problem occurs when no arc length is negative. In this case, implementations of Dijkstra's algorithm [8] achieve the best time bounds.
Reference: [3] <author> R. Brown. </author> <title> Calandar Queues: A Fast O(1) Priority Queue Implementation for the Simulation Event Set Problem. </title> <journal> Comm. ACM, </journal> <volume> 31 </volume> <pages> 1220-1227, </pages> <year> 1988. </year>
Reference-contexts: Multi-level bucket data structure may be useful in other applications. One promissing application is the simulation event set problem, for which the calendar queue data structure, in some respects similar to the 2-level bucket data structure, appears to work very well in practice <ref> [3] </ref>.
Reference: [4] <author> B. V. Cherkassky, A. V. Goldberg, and T. Radzik. </author> <title> Shortest Paths Algorithms: Theory and Experimental Evaluation. </title> <type> Technical Report STAN-CS-93-1480, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1993. </year>
Reference-contexts: Under the assumption that arc lengths are integers in the interval [0; : : :; C], C 2, the implementation of [1] runs in O (m + n p log C) time. In a recent computational study <ref> [4, 5] </ref>, however, a 2-level bucket implementation of Dijk-stra's algorithm gave the best overall performance among the codes studied. In particular, the implementation proved to be much more robust than the classical 1-level bucket implementation [7, 9, 18].
Reference: [5] <author> B. V. Cherkassky, A. V. Goldberg, and T. Radzik. </author> <title> Shortest Paths Algorithms: Theory and Experimental Evaluation. </title> <booktitle> In Proc. 5th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 516-525, </pages> <year> 1994. </year>
Reference-contexts: Under the assumption that arc lengths are integers in the interval [0; : : :; C], C 2, the implementation of [1] runs in O (m + n p log C) time. In a recent computational study <ref> [4, 5] </ref>, however, a 2-level bucket implementation of Dijk-stra's algorithm gave the best overall performance among the codes studied. In particular, the implementation proved to be much more robust than the classical 1-level bucket implementation [7, 9, 18]. <p> If necessary, we expand L i1 as well, until we have a new, non-empty active bucket at the bottom level. The algorithm then continues. The space and time bounds on the k-level implementation are generalizations of those for the 2-level case. Theorem 4.2 <ref> [5] </ref> If the length function is nonnegative, the k-level implementation runs in O (m + n (k + C 1=k )) time and uses fi (kC 1=k ) buckets. <p> This can be achieved by dividing all arc lengths by M . In this case, C is defined as the ratio between the biggest and the smallest positive lengths. The second heuristic, which we call the end cutoff heuristic, is due to Cherkassky <ref> [5] </ref>. This heuristic keeps track of the first and the last nonempty bucket at each level, which allows the algorithm to skip empty buckets at the ends of the bucket array. The heuristic is more helpful than it may look at first. <p> We would like to point out that the experiments described in this paper are designed to compare the multi-level bucket implementations to each other, not to the k-ary heap implementation. A comparison of a 2-level bucket implementation to a k-ary heap implementation appears in <ref> [5] </ref>, and our data is consistent with that of [5]. 5.1 The Graph Types Two types of graphs we explored were grids produced using the GRIDGEN generator [5]. These graphs can be characterized by a length x and width y. <p> A comparison of a 2-level bucket implementation to a k-ary heap implementation appears in <ref> [5] </ref>, and our data is consistent with that of [5]. 5.1 The Graph Types Two types of graphs we explored were grids produced using the GRIDGEN generator [5]. These graphs can be characterized by a length x and width y. The graph is formed by constructing x layers, each of which is a path of length y. <p> A comparison of a 2-level bucket implementation to a k-ary heap implementation appears in <ref> [5] </ref>, and our data is consistent with that of [5]. 5.1 The Graph Types Two types of graphs we explored were grids produced using the GRIDGEN generator [5]. These graphs can be characterized by a length x and width y. The graph is formed by constructing x layers, each of which is a path of length y. <p> Thus some of these implementations sometimes lose to the heap implementation for small n. For large n, however, the bucket implementations are always faster. 8 Conclusions The previous study <ref> [5] </ref> concluded that the 2-level implementation often significantly outperforms, and never significantly underperforms, the 1-level implementation. The goal of our study was to evaluate the effect of the number of levels on performance. <p> The 3-level implementation requires is 12M words for buckets in this case; too big for many of today's (but not tomorrow's) computers. The 4-level implementation requires only 256K words. The 2-level bucket implementation has been suggested as a robust choice for shortest path problems with nonnegative arc length <ref> [5] </ref>. Our results confirm this conclusion and show that 3-and 4-level bucket implementations are even more robust choices. Multi-level bucket data structure may be useful in other applications.
Reference: [6] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: s such that for any v 2 V , the reversal of the v to s path in the tree is a shortest path from s to v. 1 3 Dijkstra's Algorithm Dijkstra's algorithm [8] for solving the shortest path problem with nonnegative length function works as follows. (See e.g. <ref> [6, 13, 17] </ref> for more detail.) For every node v, the algorithm maintains a distance label d (v), parent (v), and status S (v) 2 funreached; labeled; scannedg. These values are initially d (v) = 1, (v) = nil, and S (v) = unreached for each node.
Reference: [7] <author> R. B. Dial. </author> <title> Algorithm 360: Shortest Path Forest with Topological Ordering. </title> <journal> Comm. ACM, </journal> <volume> 12 </volume> <pages> 632-633, </pages> <year> 1969. </year>
Reference-contexts: 1 Introduction The shortest paths problem is a fundamental network optimization problem. Algorithms for this problem have been studied for a long time. (See e.g. <ref> [2, 7, 8, 10, 14, 15, 16] </ref>.) An important special case of the problem occurs when no arc length is negative. In this case, implementations of Dijkstra's algorithm [8] achieve the best time bounds. <p> In a recent computational study [4, 5], however, a 2-level bucket implementation of Dijk-stra's algorithm gave the best overall performance among the codes studied. In particular, the implementation proved to be much more robust than the classical 1-level bucket implementation <ref> [7, 9, 18] </ref>. In this paper we study relative performance of the multi-level bucket implementations of the algorithm. We conduct computational experiments and explain their results. Our study leads to better understanding of the multi-level implementations and confirms that the 1-level implementation is much less robust than the multi-level implementations. <p> The implementation using R-heaps [1] runs in O (m + n p log C) time. 4 Multi-Level Bucket Implementation 4.1 1-level Bucket Implementation Another way to implement Dijkstra's algorithm is by using the bucket data structure, proposed independently by Dial <ref> [7] </ref>, Wagner [18], and Dinitz [9]. This implementation maintains an array of buckets, with the i-th bucket containing all nodes v with d (v) = i.
Reference: [8] <author> E. W. Dijkstra. </author> <title> A Note on Two Problems in Connection with Graphs. </title> <journal> Numer. Math., </journal> <volume> 1 </volume> <pages> 269-271, </pages> <year> 1959. </year>
Reference-contexts: 1 Introduction The shortest paths problem is a fundamental network optimization problem. Algorithms for this problem have been studied for a long time. (See e.g. <ref> [2, 7, 8, 10, 14, 15, 16] </ref>.) An important special case of the problem occurs when no arc length is negative. In this case, implementations of Dijkstra's algorithm [8] achieve the best time bounds. <p> Algorithms for this problem have been studied for a long time. (See e.g. [2, 7, 8, 10, 14, 15, 16].) An important special case of the problem occurs when no arc length is negative. In this case, implementations of Dijkstra's algorithm <ref> [8] </ref> achieve the best time bounds. <p> A shortest paths tree of G is a spanning tree rooted at s such that for any v 2 V , the reversal of the v to s path in the tree is a shortest path from s to v. 1 3 Dijkstra's Algorithm Dijkstra's algorithm <ref> [8] </ref> for solving the shortest path problem with nonnegative length function works as follows. (See e.g. [6, 13, 17] for more detail.) For every node v, the algorithm maintains a distance label d (v), parent (v), and status S (v) 2 funreached; labeled; scannedg.
Reference: [9] <author> E. A. Dinic. </author> <title> Economical algorithms for finding shortest paths in a network. </title> <editor> In Yu.S. Popkov and B.L. Shmulyian, editors, </editor> <booktitle> Transportation Modeling Systems, </booktitle> <pages> pages 36-44. </pages> <institution> Institute for System Studies, Moscow, </institution> <year> 1978. </year> <note> In Russian. </note>
Reference-contexts: In a recent computational study [4, 5], however, a 2-level bucket implementation of Dijk-stra's algorithm gave the best overall performance among the codes studied. In particular, the implementation proved to be much more robust than the classical 1-level bucket implementation <ref> [7, 9, 18] </ref>. In this paper we study relative performance of the multi-level bucket implementations of the algorithm. We conduct computational experiments and explain their results. Our study leads to better understanding of the multi-level implementations and confirms that the 1-level implementation is much less robust than the multi-level implementations. <p> The implementation using R-heaps [1] runs in O (m + n p log C) time. 4 Multi-Level Bucket Implementation 4.1 1-level Bucket Implementation Another way to implement Dijkstra's algorithm is by using the bucket data structure, proposed independently by Dial [7], Wagner [18], and Dinitz <ref> [9] </ref>. This implementation maintains an array of buckets, with the i-th bucket containing all nodes v with d (v) = i. <p> These heuristics have low overhead: They never decrease performance by much, and they often give significant time savings. 4 The first heuristic, which we call the minimum length heuristic, is due to Dinitz <ref> [9] </ref>. Let M be is the smallest nonzero arc cost (we assume that at least one arc length is positive). Then the bucket-based implementations remain correct if the i-th lowest level bucket contains nodes with distance labels in the range [iM; : : :; (i + 1)M ).
Reference: [10] <author> L. R. Ford, Jr. and D. R. Fulkerson. </author> <title> Flows in Networks. </title> <publisher> Princeton Univ. Press, </publisher> <address> Princeton, NJ, </address> <year> 1962. </year>
Reference-contexts: 1 Introduction The shortest paths problem is a fundamental network optimization problem. Algorithms for this problem have been studied for a long time. (See e.g. <ref> [2, 7, 8, 10, 14, 15, 16] </ref>.) An important special case of the problem occurs when no arc length is negative. In this case, implementations of Dijkstra's algorithm [8] achieve the best time bounds.
Reference: [11] <author> M. L. Fredman and R. E. Tarjan. </author> <title> Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 34 </volume> <pages> 596-615, </pages> <year> 1987. </year>
Reference-contexts: In this case, implementations of Dijkstra's algorithm [8] achieve the best time bounds. An implementation of <ref> [11] </ref> runs in O (m + n log n) time. (Here n and m denote the number of nodes and arcs in the network, respectively.) An improved time bound of O (m+n log n= log log n) [12] can be obtained in a random access machine computation model that allows certain <p> In addition, the algorithm examines each edge exactly once. The worst-case complexity of Dijkstra's algorithm depends on the method used to find the labeled node with the smallest distance label. The implementation using Fibonacci heaps <ref> [11] </ref> runs in O (m + n log n) time.
Reference: [12] <author> M. L. Fredman and D. E. Willard. </author> <title> Trans-dichotomous Algorithms for Minimum Spanning Trees and Shortest Paths. </title> <journal> J. Comp. and Syst. Sci., </journal> <volume> 48 </volume> <pages> 533-551, </pages> <year> 1994. </year>
Reference-contexts: An implementation of [11] runs in O (m + n log n) time. (Here n and m denote the number of nodes and arcs in the network, respectively.) An improved time bound of O (m+n log n= log log n) <ref> [12] </ref> can be obtained in a random access machine computation model that allows certain word operations. Under the assumption that arc lengths are integers in the interval [0; : : :; C], C 2, the implementation of [1] runs in O (m + n p log C) time.
Reference: [13] <author> G. Gallo and S. Pallottino. </author> <title> Shortest Paths Algorithms. </title> <journal> Annals of Oper. Res., </journal> <volume> 13 </volume> <pages> 3-79, </pages> <year> 1988. </year>
Reference-contexts: s such that for any v 2 V , the reversal of the v to s path in the tree is a shortest path from s to v. 1 3 Dijkstra's Algorithm Dijkstra's algorithm [8] for solving the shortest path problem with nonnegative length function works as follows. (See e.g. <ref> [6, 13, 17] </ref> for more detail.) For every node v, the algorithm maintains a distance label d (v), parent (v), and status S (v) 2 funreached; labeled; scannedg. These values are initially d (v) = 1, (v) = nil, and S (v) = unreached for each node.
Reference: [14] <author> B. Ju. Levit and B. N. Livshits. Neleneinye Setevye Transportnye Zadachi. </author> <title> Transport, </title> <address> Moscow, </address> <year> 1972. </year> <note> In Russian. </note>
Reference-contexts: 1 Introduction The shortest paths problem is a fundamental network optimization problem. Algorithms for this problem have been studied for a long time. (See e.g. <ref> [2, 7, 8, 10, 14, 15, 16] </ref>.) An important special case of the problem occurs when no arc length is negative. In this case, implementations of Dijkstra's algorithm [8] achieve the best time bounds.
Reference: [15] <author> E. F. Moore. </author> <title> The Shortest Path Through a Maze. </title> <booktitle> In Proc. of the Int. Symp. on the Theory of Switching, </booktitle> <pages> pages 285-292. </pages> <publisher> Harvard University Press, </publisher> <year> 1959. </year>
Reference-contexts: 1 Introduction The shortest paths problem is a fundamental network optimization problem. Algorithms for this problem have been studied for a long time. (See e.g. <ref> [2, 7, 8, 10, 14, 15, 16] </ref>.) An important special case of the problem occurs when no arc length is negative. In this case, implementations of Dijkstra's algorithm [8] achieve the best time bounds.
Reference: [16] <author> U. Pape. </author> <title> Implementation and Efficiency of Moore Algorithms for the Shortest Root Problem. </title> <journal> Math. Prog., </journal> <volume> 7 </volume> <pages> 212-222, </pages> <year> 1974. </year>
Reference-contexts: 1 Introduction The shortest paths problem is a fundamental network optimization problem. Algorithms for this problem have been studied for a long time. (See e.g. <ref> [2, 7, 8, 10, 14, 15, 16] </ref>.) An important special case of the problem occurs when no arc length is negative. In this case, implementations of Dijkstra's algorithm [8] achieve the best time bounds.
Reference: [17] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA, </address> <year> 1983. </year>
Reference-contexts: s such that for any v 2 V , the reversal of the v to s path in the tree is a shortest path from s to v. 1 3 Dijkstra's Algorithm Dijkstra's algorithm [8] for solving the shortest path problem with nonnegative length function works as follows. (See e.g. <ref> [6, 13, 17] </ref> for more detail.) For every node v, the algorithm maintains a distance label d (v), parent (v), and status S (v) 2 funreached; labeled; scannedg. These values are initially d (v) = 1, (v) = nil, and S (v) = unreached for each node.
Reference: [18] <author> R. A. Wagner. </author> <title> A shortest path algorithm for edge-sparse graphs. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 23 </volume> <pages> 50-57, </pages> <year> 1976. </year>
Reference-contexts: In a recent computational study [4, 5], however, a 2-level bucket implementation of Dijk-stra's algorithm gave the best overall performance among the codes studied. In particular, the implementation proved to be much more robust than the classical 1-level bucket implementation <ref> [7, 9, 18] </ref>. In this paper we study relative performance of the multi-level bucket implementations of the algorithm. We conduct computational experiments and explain their results. Our study leads to better understanding of the multi-level implementations and confirms that the 1-level implementation is much less robust than the multi-level implementations. <p> The implementation using R-heaps [1] runs in O (m + n p log C) time. 4 Multi-Level Bucket Implementation 4.1 1-level Bucket Implementation Another way to implement Dijkstra's algorithm is by using the bucket data structure, proposed independently by Dial [7], Wagner <ref> [18] </ref>, and Dinitz [9]. This implementation maintains an array of buckets, with the i-th bucket containing all nodes v with d (v) = i.
References-found: 18

