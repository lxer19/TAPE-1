URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1994/tr-94-053.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1994.html
Root-URL: http://www.icsi.berkeley.edu
Email: blum@cs.berkeley.edu.  halw@cs.berkeley.edu.  
Title: Software Reliability via Run-Time  
Phone: (510) 643-9153 FAX (510) 643-7684  
Date: October 1994  
Note: TR-94-053  This work was supported in part by NSF grant ccr92-01092 and in part by a MICRO grant from Hughes Aircraft Corporation and  Supported by NDSEG Fellowship daah04-93-g-0267.  
Address: I 1947 Center St. Suite 600 Berkeley, California 94704-1198  Berkeley, CA 94720,  Berkeley, CA 94720,  
Affiliation: INTERNATIONAL COMPUTER SCIENCE INSTITUTE  Computer Science Division, University of California,  the State of California. Computer Science Division, University of California,  
Abstract: Result-Checking fl Abstract We review the field of result-checking, discussing simple checkers and self-correctors. We argue that such checkers could profitably be incorporated in software as an aid to efficient debugging and reliable functionality. We consider how to modify traditional checking methodologies to make them more appropriate for use in real-time, real-number computer systems. In particular, we suggest that checkers should be allowed to use stored randomness: i.e., that they should be allowed to generate, pre-process, and store random bits prior to run-time, and then to use this information repeatedly in a series of run-time checks. In a case study of checking a general real-number linear transformation (for example, a Fourier Transform), we present a simple checker which uses stored randomness, and a self-corrector which is particularly efficient if stored randomness is allowed. fl A preliminary version of this paper appears as: "Program result-checking: a theory of testing meets a test of theory," Proc. 35th IEEE FOCS, 1994. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Alon, J. H. Spencer, and P. Erd-os, </author> <title> The Probabilistic Method, </title> <publisher> John Wiley & Sons, </publisher> <year> 1992. </year>
Reference-contexts: Similarly, consider the problem of checking an (log n)-time binary-search task. As traditionally stated (see [10, p. 35], where it features in a relevant discussion of the difficulty of writing correct algorithms), binary search has as input a key k and a numerical array a <ref> [1] </ref>; : : : ; a [n], a [1] a [n], and as output i such that a [i] = k, or 0 if k is not in the array. <p> As traditionally stated (see [10, p. 35], where it features in a relevant discussion of the difficulty of writing correct algorithms), binary search has as input a key k and a numerical array a <ref> [1] </ref>; : : : ; a [n], a [1] a [n], and as output i such that a [i] = k, or 0 if k is not in the array. <p> For example, if a search program, given key k and array a <ref> [1] </ref>; : : : ; a [n], claims that k does not occur in a, we could check this by selecting an element of a at random and verifying that it is not equal to k. This weak checker has probability 1 n of identifying an incorrect claim. <p> P's I/O specifications could then reasonably be formulated as follows: * Input: ~x = (x 1 ; : : : ; x n ), where each x i is a fixed-point real number and so is limited to a legal subrange of &lt;: say, to range <ref> [1; 1] </ref>. * Output: P (~x) = ~y = (y 1 ; : : : ; y n ), where each y i is a fixed-point real. * Let ffi 2 &lt; + be a constant; let ~ = ( 1 ; : : :; n ) be the "error vector" <p> Lemma 1 For any definitely correct h~x; ~y i, Pr ~r k jD k j 6 n ffi 10; 000; 000 Proof: Each j i j ffi. Thus, by a Chernoff Bound <ref> [1, Theorem A.16] </ref>, Pr j 1 n j 6 n ffi 2e (6 n) 2 =2n 1 : Lemma 2 For any definitely incorrect h~x; ~y i, Pr ~r k jD k j &lt; 6 n ffi 2 Proof: We know there exists i such that j i j 6 p <p> The error bound in Lemma 3 (I) is 2te c 2 =2 , and that in Lemma 3 (II) is 1 t . Lemma 4 (III) generalizes: for any q 2 <ref> [0; 1] </ref>, the probability that an at least q portion of all definitely incorrect I/O pairs will be mistakenly accepted is q , where is the error bound from Lemma 3 (II). <p> This method may be compared to those employed in [21]. Algorithm: Assume that we have tested P on a large number of random input vectors: i.e., vectors generated by choosing each component uniform-randomly from the set of fixed-point real numbers on legal range <ref> [1; 1] </ref>. For each input ~x, we verify that P (~x) is correct ( an allowable error-delta); a version of our simple checker might be employed to facilitate this verification. <p> As ~r varies over all legal input vectors, each component of vector 1 n ~r varies over a n fraction of legal range <ref> [1; 1] </ref>. Thus, since ~r is a random input vector, the value of 1 n ~r is distributed uniform-randomly 2 over a "neighborhood" of input vectors whose size, as a fraction of the space of all legal input vectors, is n 1 3 . <p> Lemma 7 (II) generalizes: for any q 2 <ref> [0; 1] </ref>, the probability that an at least q portion of the corrected outputs will be erroneous is (e+1)p * Having calculated corrected output ~y c as described above, we could then employ a version of our simple checker to double-check the correctness of ~y c .
Reference: [2] <author> S. Ar, M. Blum, B. Codenotti, and P. </author> <title> Gemmell, "Checking approximate computations over the reals," </title> <booktitle> Proc. 25th ACM STOC, </booktitle> <pages> pp. 786-795, </pages> <year> 1993. </year> <title> Extends checking methodologies to computations on limited-accuracy real numbers. Examples: matrix multiplication, inversion, and determinant; solving systems of linear equations. </title>
Reference-contexts: Thus we would expect condition (III) to be far less frequent than condition (II). * Real-number issues (see <ref> [21, 2] </ref>): Traditional checkers, such as our example self-corrector in Section 1.3, often rely on the orderly properties of finite fields. In many programming situations, we are more likely to encounter real numbers|or, actually, approximate reals represented by a fixed number of bits. <p> This method is a variant of that in <ref> [2, Section 4.1.1] </ref>. To facilitate the calculation of (~xA) ~r, we will employ the method of stored randomness: by generating ~r and pre-processing it together with A prior to run-time, we are then able to complete the calculation of (~xA) ~r with just O (n) run-time arithmetic operations.
Reference: [3] <author> S. Arora and S. Safra, </author> <title> "Probabilistic checking of proofs; a new characterization of NP," </title> <booktitle> Proc. 33rd IEEE FOCS, </booktitle> <pages> pp. 2-13, </pages> <year> 1992. </year> <title> Equates NP languages with those in interactive-proof class PCP(log n; p log n). </title>
Reference: [4] <author> L. Babai, L. Fortnow, and C. Lund, </author> <title> "Non-deterministic exponential time has two-prover interactive protocols," </title> <journal> Computational Complexity, </journal> <volume> Vol. 1, </volume> <pages> pp. 3-40, </pages> <year> 1991. </year> <title> Proves that NEXP = 2IP, and hence that NEXP-complete problems have complex checkers. </title> <type> 11 </type>
Reference: [5] <author> L. Babai and L. Fortnow, "Arithmetization: </author> <title> a new method in structural complexity theory," </title> <journal> Computational Complexity, </journal> <volume> Vol. 1, </volume> <pages> pp. 41-46, </pages> <year> 1991. </year> <title> Preliminary version: "A characterization of #P by arithmetic straight line programs," </title> <booktitle> Proc. 31st IEEE FOCS, </booktitle> <pages> pp. 26-34, </pages> <year> 1990. </year> <title> Further develops a technique from [4] of translating Boolean formulae into multivariate polynomials. </title>
Reference: [6] <author> L. Babai, L. Fortnow, L. Levin, and M. Szegedy, </author> <title> "Checking computations in polylogarithmic time," </title> <booktitle> Proc. 23rd ACM STOC, </booktitle> <pages> pp. 21-31, </pages> <year> 1991. </year> <title> A variant of [4] with lower time-bounds, this paper introduces an unusual sort of very fast checker for NP computations. Such checkers could be regarded as "hardware checkers," in that they ensure that the hardware follows instructions correctly, but don't ensure that the software is correct. </title>
Reference: [7] <author> D. Beaver and J. Feigenbaum, </author> <title> "Hiding instances in multioracle queries," </title> <booktitle> Proc. 7th Annual Symposium of Theoretical Aspects of Computer Science, </booktitle> <pages> pp. 37-48, </pages> <year> 1990. </year>
Reference: [8] <author> R. Beigel and J. Feigenbaum, </author> <title> "On the complexity of coherent sets," </title> <type> AT&T Technical Report, </type> <year> 1990. </year>
Reference: [9] <author> R. Beigel and J. Feigenbaum, </author> <title> "On being incoherent without being very hard," </title> <journal> Computational Complexity, </journal> <volume> Vol. 2, </volume> <pages> pp. 1-17, </pages> <year> 1992. </year> <title> Response to questions of [13, 40], including a proof that all NP-complete languages are coherent. </title>
Reference: [10] <author> J. Bentley, </author> <title> Programming Pearls, </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Similarly, consider the problem of checking an (log n)-time binary-search task. As traditionally stated (see <ref> [10, p. 35] </ref>, where it features in a relevant discussion of the difficulty of writing correct algorithms), binary search has as input a key k and a numerical array a [1]; : : : ; a [n], a [1] a [n], and as output i such that a [i] = k,
Reference: [11] <author> Avrim Blum, </author> <type> personal communication. </type>
Reference-contexts: Any natural binary-search program can easily be modified to give such output, and completing an O (1)-time check is then straightforward. * Weak or occasional checks <ref> [11] </ref>: Certain pseudo-checkers have only a small probability of noticing a bug.
Reference: [12] <author> M. Blum, </author> <title> "Designing programs to check their work," </title> <type> ICSI Technical Report TR-88-009, </type> <year> 1988. </year> <note> Introduces result-checking. </note>
Reference-contexts: Carrying out this computation is currently believed to be difficult, and yet, given I/O pair hc; di, it takes just one division to determine whether or not d is a correct output on input c. These ideas have been formalized into the concept of a simple checker <ref> [12] </ref>. Let f be a function with smallest possible computation time T (n) (or, if a strong lower bound cannot be determined, we informally set T (n) equal to the smallest known computation time for f ). <p> But what if ~y cannot be augmented with such pointers? Similarly, what if ~x and ~y are only available on-line from sequential storage, so that O (1)-time pointer-dereferencing is not possible? Then we may still employ a randomized method due to <ref> [39, 12] </ref>. We randomly select a deterministic hash-function h from a suitably defined set of possibilities, and we compare h (x 1 ) + + h (x n ) with h (y 1 ) + + h (y n ). <p> One may also define a complex checker <ref> [12] </ref>, which outputs an accept/reject correctness-check similar to that of a simple checker, but which, like a self-corrector, is allowed to poll P at several locations.
Reference: [13] <author> M. Blum and S. Kannan, </author> <title> "Designing programs that check their work," </title> <booktitle> Proc. 21st ACM STOC, </booktitle> <pages> pp. 86-97, </pages> <year> 1989. </year>
Reference: [14] <author> M. Blum, M. Luby, and R. Rubinfeld, </author> <title> "Self-testing/correcting with applications to numerical problems," </title> <journal> Journal of Computer & System Sciences, </journal> <volume> Vol. 47, </volume> <pages> pp. 549-95, </pages> <year> 1993. </year> <title> Preliminary version: </title> <booktitle> Proc. 22nd ACM STOC, </booktitle> <pages> pp. 73-83, </pages> <year> 1990. </year> <note> Introduces self-testers and self-correctors. </note>
Reference-contexts: We envision this testing stage as being completed prior to run time. Another possibility is the use of a self-tester <ref> [14] </ref>, which can give such assurances with less reliance on an outside oracle. <p> We envision this testing stage as being completed prior to run time. Another possibility is the use of a self-tester [14], which can give such assurances with less reliance on an outside oracle. A self-corrector for f <ref> [14, 25] </ref> is then an algorithm (generally randomized) with I/O specifications as follows: * Input: x (an input to f ), along with P, a program known to compute f with probability of error on D-random inputs limited to a small value p. <p> for p c a constant close to 1. * Time-bound: The corrector's time-bound, including subroutine calls to P, must be limited to a constant multiple of P's time-bound; the corrector's time-bound, counting each subroutine call to P as just one step, must be o (T (n)). 2 As an example <ref> [14] </ref>, consider a task of multiplication over a finite field: input is w; x 2 F ; output is product wx 2 F . We assume addition over F to be a quicker and more reliable computation than multiplication.
Reference: [15] <author> M. Blum, W. Evans, P. Gemmell, S. Kannan, and M. Naor, </author> <title> "Checking the correctness of memories," </title> <journal> Algorithmica, </journal> <volume> Vol. 12, </volume> <pages> pp. 225-244, </pages> <year> 1994. </year> <title> Demonstrates that, given a small, secure data base, one may check the correctness of a large, adversarial data base. </title>
Reference: [16] <author> R. Butler and G. Finelli, </author> <title> "The infeasibility of quantifying the reliability of life-critical real-time software," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 19, </volume> <pages> pp. 3-12, </pages> <year> 1993. </year> <title> Proves inherent limitations of conventional software testing and of the attempt to assure reliability by running several versions of a program. </title>
Reference: [17] <author> R. Cleve and M. Luby, </author> <title> "A note on self-testing/correcting methods for trigonometric functions," </title> <type> ICSI Technical Report 90-032, </type> <year> 1990. </year>
Reference: [18] <author> Funda Ergun, </author> <title> "Testing multivariate linear functions: overcoming the generator bottleneck," </title> <type> manuscript, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1994. </year> <title> Specifies self-testers for functions including the Fourier Transform. </title>
Reference-contexts: For each input ~x, we verify that P (~x) is correct ( an allowable error-delta); a version of our simple checker might be employed to facilitate this verification. Through such a testing stage (or by use of a self-tester <ref> [18] </ref>), we can satisfy ourselves that (with high probability) the fraction of inputs on which P returns incorrect output is very small: say, 1 10;000;000 .
Reference: [19] <author> L. Fortnow and M. Sipser, </author> <title> "Are there interactive protocols for co-NP languages?" Information Processing Letters, </title> <journal> Vol. </journal> <volume> 28, </volume> <pages> pp. 249-251, </pages> <year> 1988. </year> <note> Suggests that co-NP may not be contained in IP. [35] later proved the contrary. 12 </note>
Reference: [20] <author> R. Freivalds, </author> <title> "Fast probabilistic algorithms," </title> <booktitle> Springer Verlag Lecture Notes in Computer Sci--ence #74: Mathematical Foundations of Computer Science, </booktitle> <pages> pp. 57-69, </pages> <year> 1979. </year> <title> Early instances of result-checking, including a simple checker for matrix multiplication. </title>
Reference-contexts: For example, some computers now use intricate, arithmetically unstable algorithms to compute matrix multiplication in time, say, O (n 2:4 ), rather than the standard O (n 3 ). And yet an O (n 2 )-time checker for matrix multiplication <ref> [20] </ref> uses only the simplest of multiplication algorithms, and so is seemingly likely to be bug-free. Second, observe that one of the following four conditions must hold each time a (possibly buggy) simple checker C attempts to check the output of a (possibly buggy) program P: (I).
Reference: [21] <author> P. Gemmell, R. Lipton, R. Rubinfeld, M. Sudan, and A. Wigderson, </author> <title> "Self-testing/correcting for polynomials and for approximate functions," </title> <booktitle> Proc. 23rd ACM STOC, </booktitle> <pages> pp. 32-42, </pages> <year> 1991. </year> <title> Commences the extension of traditional checking methodologies to computations on limited-accuracy reals. </title>
Reference-contexts: Thus we would expect condition (III) to be far less frequent than condition (II). * Real-number issues (see <ref> [21, 2] </ref>): Traditional checkers, such as our example self-corrector in Section 1.3, often rely on the orderly properties of finite fields. In many programming situations, we are more likely to encounter real numbers|or, actually, approximate reals represented by a fixed number of bits. <p> If we weight the sum so that ~r dominates, the resulting sum-vector is near-uniformly distributed, allowing us to prove the reliability of our self-corrector. This method may be compared to those employed in <ref> [21] </ref>. Algorithm: Assume that we have tested P on a large number of random input vectors: i.e., vectors generated by choosing each component uniform-randomly from the set of fixed-point real numbers on legal range [1; 1].
Reference: [22] <author> P. Gemmell and M. Sudan, </author> <title> "Highly resilient correctors for polynomials," </title> <journal> Information Processing Letters, </journal> <volume> Vol. 43, </volume> <pages> pp. 169-174, </pages> <year> 1992. </year> <title> Gives near-optimal self-correctors for programs supposed to compute multivariate polynomials. As long as a program is correct on a 1 2 +ffi fraction of inputs (for ffi 2 &lt; + ), self-correcting is possible. </title>
Reference: [23] <author> S. Kannan, </author> <title> Program Result-Checking with Applications, </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, University of California, Berkeley, </institution> <year> 1990. </year> <title> Includes checkers for several hard group theoretic problems. </title>
Reference: [24] <author> R. Lipton, </author> <title> "Efficient checking of computations," </title> <booktitle> Proc. 7th Annual Symposium of Theoretical Aspects of Computer Science, </booktitle> <pages> pp. 207-215, </pages> <year> 1990. </year>
Reference: [25] <author> R. Lipton, </author> <title> "New directions in testing, </title> <journal> distributed computing and cryptography," DIMACS Series on Discrete Mathematics and Theoretical Computer Science, </journal> <volume> Vol. 2, </volume> <pages> pp. 191-202, </pages> <year> 1991. </year> <title> Proves that #P-complete problems have checker/correctors. </title>
Reference-contexts: We envision this testing stage as being completed prior to run time. Another possibility is the use of a self-tester [14], which can give such assurances with less reliance on an outside oracle. A self-corrector for f <ref> [14, 25] </ref> is then an algorithm (generally randomized) with I/O specifications as follows: * Input: x (an input to f ), along with P, a program known to compute f with probability of error on D-random inputs limited to a small value p.
Reference: [26] <author> C. Lund, L. Fortnow, H. Karloff, and N. Nisan, </author> <title> "Algebraic methods for interactive proof sys tems," </title> <booktitle> Proc. 31st IEEE FOCS, </booktitle> <pages> pp. 2-10, </pages> <year> 1990. </year>
Reference: [27] <author> S. Micali, </author> <title> "Computer science proofs and error-detecting computation," </title> <institution> MIT Lab for Computer Science Technical Report, 1992, and "Computer science proofs," MIT Lab for Computer Science Technical Report TM-510, </institution> <year> 1994. </year> <title> Gives result-checkers for NP-complete problems, subject to the assumptions that we have available a random oracle which can serve as a cryptographically-secure hash-function, and that the program being checked has insufficient time to find collisions in this hash-function. </title>
Reference: [28] <author> N. Nisan, </author> <title> "Co-SAT has multi-prover interactive proofs," e-mail message, 1989. Initiated events leading to [35, </title> <type> 4]. </type>
Reference: [29] <author> R. Rubinfeld, </author> <title> A Mathematical Theory of Self-Checking, Self-Testing, and Self-Correcting Programs, </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, University of California, Berkeley, </institution> <year> 1990. </year> <title> Incorporates efficient random testing into the run-time checking/correcting process. </title>
Reference: [30] <author> R. Rubinfeld, </author> <title> "Batch checking with applications to linear functions," </title> <journal> Information Processing Letters, </journal> <volume> Vol. 42, </volume> <pages> pp. 77-80, </pages> <year> 1992. </year>
Reference-contexts: Alternatively, a lengthy check might be employed, to save time, only on occasional I/O pairs. Given that some bugs cause quite frequent errors over the lifetime of a program, such weak or occasional checkers may well be of use. * Batch checks <ref> [30] </ref>: For certain computational tasks, if one stores up a number of I/O pairs, one may check them all at once more quickly than one could have checked them separately.
Reference: [31] <author> R. Rubinfeld and M. Sudan, </author> <title> "Self-testing polynomial functions efficiently and over rational domains," </title> <booktitle> Proc. 3rd ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pp. 23-32, </pages> <year> 1992. </year> <title> Extends checking methodologies from finite fields to integer and rational domains. </title>
Reference: [32] <author> R. Rubinfeld and M. Sudan, </author> <title> "Robust characterizations of polynomials and their applications to program testing," </title> <institution> IBM Research Report RC19156, 1993, and Cornell Computer Science Technical Report 93-1387, </institution> <year> 1993. </year>
Reference: [33] <author> R. Rubinfeld, </author> <title> "Robust functional equations with applications to self-testing/correcting," </title> <booktitle> Proc. 35th IEEE FOCS, </booktitle> <year> 1994. </year> <title> Gives self-testers and self-correctors for a variety of functions. Exam ples: tan x, 1=(1 + cot x), </title> <journal> cosh x. </journal> <volume> 13 </volume>
Reference: [34] <author> J. Schwartz, </author> <title> "Fast probabilistic algorithms for verification of polynomial identities," </title> <journal> Journal of the ACM, </journal> <volume> Vol. 27, </volume> <pages> pp. 701-717, </pages> <year> 1980. </year> <title> A fundamental result: to determine (with high probability) whether two polynomials are identical, it generally suffices to check their equality at a random location. Applications include: testing multiset equality; proving that two straight-line arithmetic programs compute the same function. </title>
Reference: [35] <author> A. Shamir, </author> <title> "IP = PSPACE," </title> <booktitle> Proc. 31st IEEE FOCS, </booktitle> <pages> pp. 11-15, </pages> <year> 1990. </year> <title> It follows from this result that all PSPACE-complete problems have complex checkers. </title>
Reference: [36] <author> F. Vainstein, </author> <title> "Error detection and correction in numerical computations by algebraic methods," </title> <booktitle> Proc. 9th International Symposium on Applied Algebra, Algebraic Algorithms and Error-Detecting Codes, 1991. Springer-Verlag Lecture Notes in Computer Science #539, </booktitle> <pages> pp. 456-464, </pages> <year> 1991. </year>
Reference: [37] <author> F. Vainstein, </author> <title> Algebraic Methods in Hardware/Software Testing, </title> <type> Ph.D. thesis, </type> <institution> EECS Department, Boston University, </institution> <year> 1993. </year> <title> Uses the theory of algebraic and transcendental fields to design partial complex checkers for rational functions constructed from x, e x , sin(ax+b), and cos(ax+b) using operators + - x / and fractional exponentiation. </title>
Reference: [38] <author> L. Valiant, </author> <title> "The complexity of computing the permanent," </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. 8, </volume> <pages> pp. 189-201, </pages> <year> 1979. </year> <title> Defines #P-completeness and proves that computing the permanent of a matrix is #P-complete. </title> <note> Also see [25]. </note>
Reference: [39] <author> M. Wegman and J. Carter, </author> <title> "New hash functions and their use in authentication and set equality," </title> <journal> Journal of Computer & System Sciences, </journal> <volume> Vol. 22, </volume> <pages> pp. 265-279, </pages> <year> 1981. </year> <title> Includes an idea for a simple check of multiset equality (completed in [12]). </title>
Reference-contexts: But what if ~y cannot be augmented with such pointers? Similarly, what if ~x and ~y are only available on-line from sequential storage, so that O (1)-time pointer-dereferencing is not possible? Then we may still employ a randomized method due to <ref> [39, 12] </ref>. We randomly select a deterministic hash-function h from a suitably defined set of possibilities, and we compare h (x 1 ) + + h (x n ) with h (y 1 ) + + h (y n ).
Reference: [40] <author> A. Yao. </author> <title> "Coherent functions and program checkers," </title> <booktitle> Proc. 22nd ACM STOC, </booktitle> <pages> pp. 84-94, </pages> <year> 1990. </year> <title> Function f is coherent iff on input hx; yi one can determine whether or not f (x) = y via a BPP f algorithm which is not allowed to query f at x. Author proves the existence of incoherent (and thus uncheckable) functions in EXP. </title> <note> See also [9]. 14 </note>
References-found: 40

