URL: http://www.cs.ucl.ac.uk/staff/T.Yu/ep97.ps
Refering-URL: http://www.cs.ucl.ac.uk/research/nuclear/nuclearpapers.html
Root-URL: http://www.cs.ucl.ac.uk
Email: C.Clack@cs.ucl.ac.uk T.Yu@cs.ucl.ac.uk  
Title: Performance Enhanced Genetic Programming  
Author: Chris Clack and Tina Yu 
Address: Gower Street, London WC1E 6BT, England  
Affiliation: Department of Computer Science University College London  
Abstract: Genetic Programming is increasing in popularity as the basis for a wide range of learning algorithms. However, the technique has to date only been successfully applied to modest tasks because of the performance overheads of evolving a large number of data structures, many of which do not correspond to a valid program. We address this problem directly and demonstrate how the evolutionary process can be achieved with much greater efficiency through the use of a formally-based representation and strong typing. We report initial experimental results which demonstrate that our technique exhibits significantly better performance than previous work. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <editor> P.J. Angeline. </editor> <booktitle> Genetic Programming and Emergent Intelligence. Advances in Genetic Programming, </booktitle> <editor> K.E. Kinnear, Jr. (ed.), </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <pages> pp. 75-98, </pages> <year> 1994. </year>
Reference: 2. <author> S. Brave. </author> <title> Evolving Recursive Programs for Tree Search. </title> <booktitle> Advances in Genetic Programming II, </booktitle> <editor> P.J. Angeline and K.E. Kinnear, Jr. (eds.), </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <pages> pp. 203-220, </pages> <year> 1996. </year>
Reference-contexts: Recent GP research has investigated ways to reduce the size of parse trees and to reduce the size of the search space in order to make GP more efficient: 1. reusable program parts. This includes research into Automatically Defined Functions [8], Module Acquisition [1,5] and the use of Recursion <ref> [2] </ref>. Also, Montana [10] argues that generic functions and generic data types can help to reduce program size by providing abstraction of program parts. 2. type constraints ensure that only type-correct programs are generated for the initial population and during genetic crossover and mutation. <p> We limit the number of recursive calls (by the length of the input list) to avoid infinite loops <ref> [2] </ref>.
Reference: 3. <author> L. Cardelli. </author> <title> Basic Polymorphic Typechecking. </title> <booktitle> Science of Computer Programming. </booktitle> <volume> Vol. 8, </volume> <pages> pp. 147-172, </pages> <year> 1987. </year>
Reference-contexts: Furthermore, whenever an occurrence of a dummy type variable is instantiated, all the other occurrences of the same dummy type variable in that type must be instantiated to the same value: this process is called contextual instantiation <ref> [3] </ref> which is performed by a unification algorithm explained in the next section. The following table shows how the dummy type variables can be instantiated: Within a parse tree, temporary type variables must be instantiated consistently to maintain the legality of the tree.
Reference: 4. <author> A.L. Cox, Jr., L. Davis, & Y. Qiu. </author> <title> Dynamic Anticipatory Routing in Circuit-Switched Telecommunications Networks. Handbook of Genetic Algorithms. </title> <editor> L. Davis (ed.), </editor> <publisher> Van Nostrand Reinhold, </publisher> <address> New York, pp.124-143, </address> <year> 1991. </year>
Reference-contexts: The advantage of steady-state replacement is that a tree with a good fitness score is immediately available as a parent for reproduction rather than having to wait until the next generation. To facilitate direct comparison, we follow Montana's STGP in using exponential fitness normalization <ref> [4] </ref> to select parents for reproduction. This means: (1) We use rank selection instead of fitness-proportionate selection, and (2) The probability of selecting the nth best individual is Parent-Scalar times the probability of selecting the (n-1)-th best individual.
Reference: 5. <author> K.E. Kinnear, Jr. </author> <title> Alternatives in Automatic Function Definition: A Comparison of Performance. </title> <booktitle> Advances in Genetic Programming. </booktitle> <editor> K.E. Kinnear, Jr.(ed.), </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <pages> pp. 119-141, </pages> <year> 1994. </year>
Reference: 6. <author> J.R. Koza. </author> <title> Hierarchical Genetic Algorithms Operating on Populations of Computer Programs. </title> <booktitle> Proceedings of the 11th International Conference on Artificial Intelligence, </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <booktitle> Vol. </booktitle> <volume> I, </volume> <pages> pp 768-774, </pages> <year> 1989. </year>
Reference-contexts: We choose to discard those trees with the lowest fitness score. We restrict crossover to be performed in application nodes only (these include full application and partial application nodes): this is to promote the recombining of large structures <ref> [6] </ref>. By reference to our abstract syntax, this means that any occurrence of the application expression (exp1 exp2) appearing at any place in one tree can be swapped with any application expression in another parse tree. When performing crossover, we first select a crossover node from one parent.
Reference: 7. <author> J. R. Koza. </author> <title> Genetic Programming: On the Programming of Computers by Means of Natural Selection. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: This approach was originally suggested by Koza <ref> [7] </ref> and then extended by Montana who has developed the idea of Strongly Typed Genetic Programming [10]. We address the problem of GP performance by building on Montanas Strongly Typed Genetic Programming. <p> In this section we very briefly outline these two important pieces of related work. 2.1 Constrained Syntactic Structure With Kozas Constrained Syntactic Structure <ref> [7] </ref>, a set of rules is defined to specify which terminals and functions are allowed to be the child nodes of every function in the parse tree. When generating a new parse tree and when performing genetic operations, these rules are applied to ensure the syntactic constraints.
Reference: 8. <editor> J. R. Koza. </editor> <booktitle> Genetic Programming II, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1994. </year>
Reference-contexts: Recent GP research has investigated ways to reduce the size of parse trees and to reduce the size of the search space in order to make GP more efficient: 1. reusable program parts. This includes research into Automatically Defined Functions <ref> [8] </ref>, Module Acquisition [1,5] and the use of Recursion [2].
Reference: 9. <author> R. Milner. </author> <title> A Theory of Type Polymorphism in Programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> Vol. 17, </volume> <pages> pp. 348-375, </pages> <year> 1978. </year>
Reference-contexts: Furthermore, the use of a formally-based representation (our parse tree syntax is based on the l-calculus) and a formally-based type system (our type system is loosely based on the Hindley/Milner polymorphic type system <ref> [9] </ref> and we use Robinsons unification algorithm [11]) will provide greater confidence in the correctness, completeness and expressiveness of our GP system.
Reference: 10. <author> D.J. Montana. </author> <title> Strongly Typed Genetic Programming. </title> <journal> Journal of Evolutionary Computation, </journal> <volume> Vol. 3:3, </volume> <pages> pp. 199-230. </pages> <year> 1995. </year>
Reference-contexts: Montana <ref> [10] </ref> has illustrated how the size of the search space of possible parse trees depends upon the number of terminals (T), the number of functions (F), and the maximum tree depth (D); even for small problems (for example, T=2, F=5, D=6), Montana calculates a search space of roughly 10 27 parse <p> This includes research into Automatically Defined Functions [8], Module Acquisition [1,5] and the use of Recursion [2]. Also, Montana <ref> [10] </ref> argues that generic functions and generic data types can help to reduce program size by providing abstraction of program parts. 2. type constraints ensure that only type-correct programs are generated for the initial population and during genetic crossover and mutation. <p> This approach was originally suggested by Koza [7] and then extended by Montana who has developed the idea of Strongly Typed Genetic Programming <ref> [10] </ref>. We address the problem of GP performance by building on Montanas Strongly Typed Genetic Programming. <p> When generating a new parse tree and when performing genetic operations, these rules are applied to ensure the syntactic constraints. There are many similarities between Kozas approach and the program structuring requirements of a simple monomorphic type system. 2.2 Strongly Typed Genetic Programming Montana <ref> [10] </ref> has developed Kozas original approach so that constraints are given indirectly, through a type system, rather than directly (per-function). Furthermore, Montana has extended this notion to include generic functions and generic data types. Montana maintains a table giving the types of all available terminals and functions.
Reference: 11. <author> J.A. Robinson. </author> <title> A Machine-Oriented Logic Based on the Resolution Principle. </title> <journal> Journal of ACM. </journal> <volume> Vol. 12:1, </volume> <pages> pp. 23-49, </pages> <month> January </month> <year> 1965. </year>
Reference-contexts: Furthermore, the use of a formally-based representation (our parse tree syntax is based on the l-calculus) and a formally-based type system (our type system is loosely based on the Hindley/Milner polymorphic type system [9] and we use Robinsons unification algorithm <ref> [11] </ref>) will provide greater confidence in the correctness, completeness and expressiveness of our GP system.
Reference: 12. <author> G. Syswerda. </author> <title> Uniform Crossover in Genetic Algorithms. </title> <booktitle> Proceedings of the Third International Conference on Genetic Algorithms and Their Applications, </booktitle> <editor> J.D. Schaffer (ed.), </editor> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <pages> pp. 2-9, </pages> <year> 1989. </year>
Reference-contexts: First we describe our genetic algorithm and then we present the results of two of Montanas experiments: NTH-3 and MAPCAR. 5.1 The Genetic Algorithm We follow Montana's STGP in using steady-state replacement <ref> [12] </ref> to perform population updates. Initially, we create a population with a specified size. Within the population, every tree is unique. During evolution, we select two trees to perform crossover.
References-found: 12

