URL: http://www.cs.mu.oz.au/tr_db/mu_95_25.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: ffjh,zs,conwayg@cs.mu.OZ.AU  
Phone: Fax: +61 3 348 1184, Phone: +61 3 282 2401  
Title: Determinism analysis in the Mercury compiler  
Author: Fergus Henderson, Zoltan Somogyi and Thomas Conway 
Keyword: determinism, Mercury, program analysis, logic programming, programming language implementation.  
Address: Parkville, 3052 Victoria, Australia  
Affiliation: Department of Computer Science, University of Melbourne  
Abstract: Mercury is a new purely declarative logic programming language. The Mercury determinism system allows programmers to specify which predicates never fail and which predicates succeed at most once. This information allows the compiler to check the program for errors, pinpointing predicates that do not satisfy their declarations. This makes programmers significantly more productive and enhances the reliability of their programs. The Mercury compiler also uses determinism information to generate much faster code than any other logic programming system. This paper presents the algorithms used by the Mercury compiler to infer determinism information and to detect determinism errors. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Conway, F. Henderson, and Z. Somogyi. </author> <title> Code generation for mercury. </title> <booktitle> In Proceedings of the Twelfth International Conference on Logic Programming, </booktitle> <address> Portland, Oregon, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Therefore the stack frames of nondet and multi procedures are both larger and much longer lived than the stack frames of other procedures <ref> [1] </ref>. Functional and logic languages do not allow programmers to express destructive update operations directly; programmers must make a slightly modified copy of the data structure instead. This is why their implementations have traditionally been very allocation-intensive which usually leads to bad locality.
Reference: [2] <author> S. Dawson, C. Ramakrishnan, I. Ramakrishnan, and R. Sekar. </author> <title> Extracting determinacy in logic programs. </title> <booktitle> In Proceedings of the Tenth International Conference on Logic Programming, </booktitle> <pages> pages 424-438, </pages> <address> Budapest, Hungary, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Several researchers <ref> [2, 3, 6] </ref> have proposed global analysis algorithms for finding out which predicates in a Prolog program can succeed at most once with the intention of optimizing the compilation of such predicates.
Reference: [3] <author> S. K. Debray and D. S. Warren. </author> <title> Detection and optimisation of functional computations in Prolog. </title> <booktitle> In Proceedings of the Third International Conference on Logic Programming, </booktitle> <pages> pages 490-504, </pages> <address> London, England, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: Several researchers <ref> [2, 3, 6] </ref> have proposed global analysis algorithms for finding out which predicates in a Prolog program can succeed at most once with the intention of optimizing the compilation of such predicates.
Reference: [4] <author> P. M. Hill and J. W. Lloyd. </author> <title> The Godel programming language. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: We assume that the reader is familiar with Prolog syntax. 2 The Mercury language Syntactically, Mercury is similar to Prolog with additional declarations. Semantically, however, it is very different. Mercury is a pure logic programming language with a well-defined declarative semantics. Like Godel <ref> [4] </ref>, Mercury provides declarative replacements for Prolog's non-logical features. Unlike Godel, Mercury provides replacements for all such features, including I/O. The rest of this section is necessarily brief, and omits many details of the language. <p> For information on those details see http://www.cs.mu.oz.au/~zs/mercury.html. 2.1 Types Mercury's type system is based on a polymorphic many-sorted logic. It is essentially equivalent to the Mycroft-O'Keefe type system [5], and to the type system of Godel <ref> [4] </ref>. We borrow our syntax from the NU-Prolog type checkers. <p> In some ways, the most important contribution of the Mercury determinism system is that it provides a necessary basis for safe declarative I/O. Other logic programming languages (e.g. NU-Prolog [12] and Godel <ref> [4] </ref>) have provided replacements for most of Prolog's nonlogical constructs, but Mercury is the first pure logic programming language (apart from toy languages without any I/O). Making the language purely declarative has several enormous benefits.
Reference: [5] <author> A. Mycroft and R. A. O'Keefe. </author> <title> A polymorphic type system for Prolog. </title> <journal> Artificial Intelligence, </journal> <volume> 23 </volume> <pages> 295-307, </pages> <year> 1984. </year>
Reference-contexts: The rest of this section is necessarily brief, and omits many details of the language. For information on those details see http://www.cs.mu.oz.au/~zs/mercury.html. 2.1 Types Mercury's type system is based on a polymorphic many-sorted logic. It is essentially equivalent to the Mycroft-O'Keefe type system <ref> [5] </ref>, and to the type system of Godel [4]. We borrow our syntax from the NU-Prolog type checkers.
Reference: [6] <author> K. Nakamura. </author> <title> Control of logic program execution based on the functional relations. </title> <booktitle> In Proceedings of the Third International Conference on Logic Programming, </booktitle> <pages> pages 505-512, </pages> <address> London, England, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: Several researchers <ref> [2, 3, 6] </ref> have proposed global analysis algorithms for finding out which predicates in a Prolog program can succeed at most once with the intention of optimizing the compilation of such predicates.
Reference: [7] <author> R. A. O'Keefe. </author> <title> The craft of Prolog. </title> <publisher> MIT Press, </publisher> <year> 1990. </year> <month> 18 </month>
Reference-contexts: The code that works with such a "defaulty" representation usually has a last clause that matches any input, which means the predicate cannot be deterministic without cuts. This is one reason why Richard O'Keefe argues against this technique <ref> [7] </ref>. His suggested alternative (which is the only alternative in Mercury) is a representation that fully discriminates among all the alternatives, which naturally leads to code that Mercury can turn into a switch.
Reference: [8] <author> H. Sawamura and T. Takeshima. </author> <title> Recursive unsolvability of determinacy, solvable cases of deter minacy and their applications to prolog optimization. </title> <booktitle> In Proceedings of the Second International Conference on Logic Programming, </booktitle> <pages> pages 200-207, </pages> <address> Boston, Massachusetts, </address> <month> June </month> <year> 1985. </year>
Reference-contexts: Sometimes the Mercury compiler rejects a program in which the declarations and definitions are consistent simply because it cannot prove that they are consistent. This is unavoidable, because proving that a predicate can have e.g. at most one solution is an undecidable problem <ref> [8] </ref>. It turns out that the simple algorithms employed by the Mercury compiler are sufficient to discover the true determinism of the vast majority of predicates in real programs. The few predicates falsely rejected can easily be modified to make them acceptable to the compiler.
Reference: [9] <author> G. Smolka. </author> <title> TEL (version 0.9) report and user manual. </title> <type> Technical Report SEKI Report SR-87-11, </type> <institution> Department of Computer Science, University of Kaiserslautern, Germany, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: Several researchers [2, 3, 6] have proposed global analysis algorithms for finding out which predicates in a Prolog program can succeed at most once with the intention of optimizing the compilation of such predicates. Smolka <ref> [9, 10] </ref> has proposed a system that requires determinism declarations somewhat similar to ours but in which these declarations are not checked by the compiler. Neither of these approaches is as effective as the Mercury determinism system in improving programmer productivity and program reliability.
Reference: [10] <author> G. Smolka. </author> <title> Making control and data flow in logic programs explicit. </title> <booktitle> In Conference Record of the ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 311-322, </pages> <address> Austin, Texas, </address> <month> July </month> <year> 1984. </year>
Reference-contexts: Several researchers [2, 3, 6] have proposed global analysis algorithms for finding out which predicates in a Prolog program can succeed at most once with the intention of optimizing the compilation of such predicates. Smolka <ref> [9, 10] </ref> has proposed a system that requires determinism declarations somewhat similar to ours but in which these declarations are not checked by the compiler. Neither of these approaches is as effective as the Mercury determinism system in improving programmer productivity and program reliability.
Reference: [11] <author> Z. Somogyi, F. Henderson, and T. Conway. </author> <title> The execution algorithm of Mercury, an efficient purely declarative logic programming language. </title> <journal> Journal of Logic Programming, </journal> <note> to appear. </note>
Reference-contexts: The Mercury approach is also much more effective in improving the efficiency of compiled code. Benchmarks show the Mercury compiler to be about twice as fast as Aquarius Prolog, about five times as fast as SICStus Prolog, and about ten times as fast as Quintus Prolog <ref> [11] </ref>. In some ways, the most important contribution of the Mercury determinism system is that it provides a necessary basis for safe declarative I/O. Other logic programming languages (e.g.
Reference: [12] <author> J. Thom and J. Zobel. </author> <title> NU-Prolog reference manual. </title> <type> Technical Report 86/10, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <year> 1986. </year> <month> 19 </month>
Reference-contexts: In some ways, the most important contribution of the Mercury determinism system is that it provides a necessary basis for safe declarative I/O. Other logic programming languages (e.g. NU-Prolog <ref> [12] </ref> and Godel [4]) have provided replacements for most of Prolog's nonlogical constructs, but Mercury is the first pure logic programming language (apart from toy languages without any I/O). Making the language purely declarative has several enormous benefits.
References-found: 12

