URL: http://www.cs.sunysb.edu/~abhik/transform/main.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~abhik/transform/papers.html
Root-URL: http://www.cs.sunysb.edu
Email: fabhik,kumar,cram,ramg@cs.sunysb.edu  email: abhik@cs.sunysb.edu  
Phone: Phone: +1 516 632 8470 Fax: +1 516 632 8334  
Title: A General Unfold/Fold Logic Program Transformation System based on a Parameterized Framework  
Author: Abhik Roychoudhury K. Narayan Kumar C.R. Ramakrishnan I.V. Ramakrishnan 
Keyword: Logic programming, Program transformation.  
Web: Roychoudhury  
Note: Contact Author: Abhik  Address:  Research done while on leave from SPIC Mathematical Institute, Chennai, India.  
Date: Synopsis  
Address: NY 11794, USA.  NY 11794-4400, USA.  
Affiliation: Department of Computer Science SUNY at Stony Brook,  Department of Computer Science SUNY at Stony Brook Stony Brook,  
Abstract: The numerous (irreversible) unfold/fold transformation systems for definite logic programs differ from one another mainly in the kind of foldings they permit. Some of them allow folding using a single (possibly recursive) clause while others fold with multiple clauses but they must all be non-recursive. In this paper we present a more general transformation system for definite programs, that allows folding using multiple clauses which may be recursive. Our approach is based on a parameterized framework for unfold/fold transformations that we develop by suitably abstracting and extending the proofs of existing transformation systems. Our transformation system is readily constructed by simply instantiating the framework. This framework forms a basis for not only understanding the strengths and limitations of existing systems but also for synthesizing new unfold/fold transformation systems. 
Abstract-found: 1
Intro-found: 1
Reference: [AD95] <author> C. Aravindan and P.M. Dung. </author> <title> On the correctness of unfold/fold transformations of normal and extended logic programs. </title> <journal> In Journal of Logic Programming, </journal> <pages> pages 295-322, </pages> <year> 1995. </year>
Reference-contexts: Kanamori and Fujita [KF87] proposed a transformation framework that was based on maintaining counters to guide folding. Maher described a system that permits only reversible folding [Mah87]. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses [GK94], negation <ref> [AD95, Sek91, Sek93] </ref>) and applied to practical problems (e.g., [BCD90, BB93, PPR97]). All the above systems differ from each other mainly in terms of the fold operations they permit. Correctness of Unfold/Fold Transformations Consider the sequence of programs in Figure 1. <p> In future work, two directions for further development are immediately apparent: extending the framework for (i) handling logic programs with negation and (ii) the different semantics for logic programs with and without negation. Aravindan and Dung <ref> [AD95] </ref> developed an approach to parameterize the correctness proofs of the original Tamaki-Sato system with respect to various semantics based on the notion of semantic kernels.
Reference: [BB93] <author> D. Boulanger and M. Bruynooghe. </author> <title> Deriving unfold/fold transformations of logic programs using extended OLDT-based abstract interpretation. </title> <journal> Journal of Symbolic Computation, </journal> <pages> pages 495-521, </pages> <year> 1993. </year>
Reference-contexts: Maher described a system that permits only reversible folding [Mah87]. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses [GK94], negation [AD95, Sek91, Sek93]) and applied to practical problems (e.g., <ref> [BCD90, BB93, PPR97] </ref>). All the above systems differ from each other mainly in terms of the fold operations they permit. Correctness of Unfold/Fold Transformations Consider the sequence of programs in Figure 1.
Reference: [BCD90] <author> A. Bossi, N. Cocco, and S. Dulli. </author> <title> A method of specializing logic programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <pages> pages 253-302, </pages> <year> 1990. </year>
Reference-contexts: Maher described a system that permits only reversible folding [Mah87]. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses [GK94], negation [AD95, Sek91, Sek93]) and applied to practical problems (e.g., <ref> [BCD90, BB93, PPR97] </ref>). All the above systems differ from each other mainly in terms of the fold operations they permit. Correctness of Unfold/Fold Transformations Consider the sequence of programs in Figure 1.
Reference: [BD77] <author> R.M. Burstall and J. Darlington. </author> <title> A transformation system for developing recursive programs. </title> <journal> In Journal of the ACM, </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <year> 1977. </year>
Reference-contexts: Program transformation techniques have been used for program optimization (e.g., partial evaluation [LS95, LSdW96, JGS93, Sch81]) and deriving efficient programs from high-level specifications (e.g., program synthesis <ref> [BD77, DL94] </ref>). Development of transformation techniques is an active area of research in logic programming (see [PP98] for an excellent survey of research done on this topic over the past decade).
Reference: [DL94] <author> Y. Deville and K.-K. Lau. </author> <title> Logic program synthesis. </title> <journal> In Journal of Logic Programming, </journal> <pages> pages 321-350, </pages> <year> 1994. </year>
Reference-contexts: Program transformation techniques have been used for program optimization (e.g., partial evaluation [LS95, LSdW96, JGS93, Sch81]) and deriving efficient programs from high-level specifications (e.g., program synthesis <ref> [BD77, DL94] </ref>). Development of transformation techniques is an active area of research in logic programming (see [PP98] for an excellent survey of research done on this topic over the past decade).
Reference: [GK94] <author> M. Gergatsoulis and M. Katzouraki. </author> <title> Unfold/fold transformations for definite clause programs. </title> <booktitle> In PLILP'94, </booktitle> <volume> LNCS 844, </volume> <pages> pages 340-354, </pages> <year> 1994. </year>
Reference-contexts: Kanamori and Fujita [KF87] proposed a transformation framework that was based on maintaining counters to guide folding. Maher described a system that permits only reversible folding [Mah87]. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses <ref> [GK94] </ref>, negation [AD95, Sek91, Sek93]) and applied to practical problems (e.g., [BCD90, BB93, PPR97]). All the above systems differ from each other mainly in terms of the fold operations they permit. Correctness of Unfold/Fold Transformations Consider the sequence of programs in Figure 1. <p> In order to ensure that folding is still totally correct, these systems permit folding using only clauses with certain (syntactic) properties. Thus, the original Tamaki-Sato system permits folding using a single clause only (conjunctive folding) and this clause is required to be non-recursive. In <ref> [GK94] </ref> the above system was extended to allow folding with multiple clauses (disjunctive folding) but all of these clauses are required to be be non-recursive. Kanamori and Fujita [KF87] as well Tamaki and Sato in a later paper [TS86] gave two different approaches for conjunctive folding using recursive clauses. <p> Design of such a transformation system has remained open. We describe one such system in Section 3. Despite their apparent diversity, the above transformation systems <ref> [KF87, TS84, TS86, GK94] </ref> show a striking similarity in how they are proved correct. Essentially, these systems associate some measure with different program elements, namely, atoms and clauses to determine whether folding is permissible in that step (e.g., "foldable" flag in [TS84], stratified clauses in [TS86], and counters in [KF87]). <p> Moreover, they ensure that each transformation step maintains an invariant relating proofs in the derived program to the various measures (e.g., the notions of rank-consistency in [TS84, KF87], weight-consistency in <ref> [GK94] </ref> and -completeness in [TS86]). The question then is whether a parameterized framework for unfold/fold transformations can be designed such that the above systems can be derived by simply instantiating the framework appropriately. <p> In this paper, we present such a parameterized framework (see Section 2). 1.1 Summary of Results * By suitably abstracting and extending the measures used in <ref> [TS84, TS86, KF87, GK94] </ref>, we develop a general transformation framework for definite logic programs parameterized by an abstract measure (see Section 2). We relax the invariants needed in the proofs to permit approximation of measure values, thereby modeling a large class of transformations. <p> The above instantiations completely specify the Kanamori-Fujita system as an instance of our framework. Along similar lines, we can instantiate our framework to obtain other unfold/fold systems such as <ref> [TS86, GK94] </ref>. 6 2.3 Goal Replacement Goal replacement is a powerful transformation that allows semantically equivalent conjunctions of atoms to be freely interchanged. <p> The measure space of SCOUT is fine-grained, and it subsumes the measures used in existing systems, particularly the counters of Kanamori-Fujita [KF87] and the strata of Tamaki-Sato [TS86]. We can show that SCOUT is strictly more expressive (in terms of transformation sequences allowed) than existing unfold/fold systems such as <ref> [KF87, TS86, GK94] </ref>. We now construct SCOUT by instantiating our parametrized framework as follows. We assume that predicate symbols appearing in initial program P 0 are partitioned into n strata a priori. <p> All predicate symbols are placed in a single stratum. The lower and upper bound measures of clauses are of the form hi; ji, where i; j; 2 Z. The initial program P 0 = fC 1 ; :::; C 12 g is given in figure 2. Following <ref> [GK94, TS84] </ref> we assume that all definitions (i.e. new predicates needed for specialization, such as spec_red in the above example) are introduced in the original program.
Reference: [JGS93] <author> N.D. Jones, C.K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Program transformation techniques have been used for program optimization (e.g., partial evaluation <ref> [LS95, LSdW96, JGS93, Sch81] </ref>) and deriving efficient programs from high-level specifications (e.g., program synthesis [BD77, DL94]). Development of transformation techniques is an active area of research in logic programming (see [PP98] for an excellent survey of research done on this topic over the past decade).
Reference: [KF87] <author> T. Kanamori and H. Fujita. </author> <title> Unfold/fold Transformation of Logic Programs with Counters. In USA-Japan Seminar on Logics of Programs, </title> <note> Available at http://www.cs.sunysb.edu/~abhik/transform/papers.html, 1987. </note>
Reference-contexts: A unfold/fold transformation system for definite logic programs was first described in a seminal paper by Tamaki and Sato [TS84]. In the flurry of research activity that followed, a number of unfold/fold transformation systems were developed. Kanamori and Fujita <ref> [KF87] </ref> proposed a transformation framework that was based on maintaining counters to guide folding. Maher described a system that permits only reversible folding [Mah87]. <p> Many program transformation systems permit irreversible folding, by allowing folding at step i using clauses that are not in P i . For example, in the original and extended Tamaki-Sato systems [TS84, TS86] folding always uses clauses in P 0 whereas in the Kanamori-Fujita system <ref> [KF87] </ref> the clauses can come from any P j (j i). In order to ensure that folding is still totally correct, these systems permit folding using only clauses with certain (syntactic) properties. <p> In [GK94] the above system was extended to allow folding with multiple clauses (disjunctive folding) but all of these clauses are required to be be non-recursive. Kanamori and Fujita <ref> [KF87] </ref> as well Tamaki and Sato in a later paper [TS86] gave two different approaches for conjunctive folding using recursive clauses. In many examples, such as the one we describe in Section 3 which stems from an automated verification application, folding in presence of both disjunction and recursion is crucial. <p> Design of such a transformation system has remained open. We describe one such system in Section 3. Despite their apparent diversity, the above transformation systems <ref> [KF87, TS84, TS86, GK94] </ref> show a striking similarity in how they are proved correct. Essentially, these systems associate some measure with different program elements, namely, atoms and clauses to determine whether folding is permissible in that step (e.g., "foldable" flag in [TS84], stratified clauses in [TS86], and counters in [KF87]). <p> Essentially, these systems associate some measure with different program elements, namely, atoms and clauses to determine whether folding is permissible in that step (e.g., "foldable" flag in [TS84], stratified clauses in [TS86], and counters in <ref> [KF87] </ref>). Moreover, they ensure that each transformation step maintains an invariant relating proofs in the derived program to the various measures (e.g., the notions of rank-consistency in [TS84, KF87], weight-consistency in [GK94] and -completeness in [TS86]). <p> Moreover, they ensure that each transformation step maintains an invariant relating proofs in the derived program to the various measures (e.g., the notions of rank-consistency in <ref> [TS84, KF87] </ref>, weight-consistency in [GK94] and -completeness in [TS86]). The question then is whether a parameterized framework for unfold/fold transformations can be designed such that the above systems can be derived by simply instantiating the framework appropriately. <p> In this paper, we present such a parameterized framework (see Section 2). 1.1 Summary of Results * By suitably abstracting and extending the measures used in <ref> [TS84, TS86, KF87, GK94] </ref>, we develop a general transformation framework for definite logic programs parameterized by an abstract measure (see Section 2). We relax the invariants needed in the proofs to permit approximation of measure values, thereby modeling a large class of transformations. <p> SCOUT is derived by instantiating our parameterized framework with a fine grained measure based on counters due to Kanamori and Fujita <ref> [KF87] </ref> and the notion of strata introduced by Tamaki and Sato in [TS86]. The development of SCOUT was based on two crucial observations made possible by our framework. <p> The implications of the parameterized framework and SCOUT are discussed at length in Section 4. 2 A Parameterized Transformation Framework Following <ref> [KF87, TS84] </ref> we first develop our abstract framework using two transformations: Unfolding and Folding. Subsequently, we show how Goal Replacement transformation can be added to this framework. Throughout we will draw on the Kanamori-Fujita system for illustrating the abstract concepts in our framework. <p> It is worth noting that we do not attempt to translate every proof of A in P i to a proof of A in P i+1 . Instead, following <ref> [KF87, TS86, TS84] </ref> we consider a "special proof" called strongly measure-consistent proof (see Definition 6) of A in P i and construct a proof of A in P i+1 . <p> We use to denote the inverse operation of the group hM; i. We also use as a binary operator, with a b meaning a (b) (where (b) is the inverse of b). The Kanamori-Fujita system <ref> [KF87] </ref> keeps track of integer counters. Thus the corresponding measure structure is hZ; +; ; Ni, where Z and N are the set of integers and natural numbers respectively, + denotes integer addition, and is the arithmetic comparison operator. <p> ; : : : ; A n of a clause C 2 P used in T satisfies: (i) ff (A i ) ff (A) and (ii) fl lo (C) P We point out that our abstract notion of strong measure consistency relaxes the concrete notion of rank consistency used in <ref> [KF87] </ref>. While rank consistency of [KF87] imposes a strict equality constraint on ff (A), strong consistency only bounds it from above and below. As we will show later, this facilitates maintenance of approximate information which is crucial to permit disjunctive folding. Weak consistency corresponds to invariant I3 used in [KF87]. <p> A n of a clause C 2 P used in T satisfies: (i) ff (A i ) ff (A) and (ii) fl lo (C) P We point out that our abstract notion of strong measure consistency relaxes the concrete notion of rank consistency used in <ref> [KF87] </ref>. While rank consistency of [KF87] imposes a strict equality constraint on ff (A), strong consistency only bounds it from above and below. As we will show later, this facilitates maintenance of approximate information which is crucial to permit disjunctive folding. Weak consistency corresponds to invariant I3 used in [KF87]. <p> in <ref> [KF87] </ref>. While rank consistency of [KF87] imposes a strict equality constraint on ff (A), strong consistency only bounds it from above and below. As we will show later, this facilitates maintenance of approximate information which is crucial to permit disjunctive folding. Weak consistency corresponds to invariant I3 used in [KF87]. For proving total correctness, we need : Definition 7 (Measure consistent Program) A program P is said to be measure consistent w.r.t. atom measure ff and clause measure (fl lo ; fl hi ), if for all A 2 M (P ), we have: 1. <p> The clause measures of the other clauses of P i+1 are inherited from P i . 2 Observe that, similar to the goal replacement transformation in <ref> [KF87, TS84, TS86] </ref> the conditions under which the above rule may be applied are not testable at transformation time. <p> The measure space of SCOUT is fine-grained, and it subsumes the measures used in existing systems, particularly the counters of Kanamori-Fujita <ref> [KF87] </ref> and the strata of Tamaki-Sato [TS86]. We can show that SCOUT is strictly more expressive (in terms of transformation sequences allowed) than existing unfold/fold systems such as [KF87, TS86, GK94]. We now construct SCOUT by instantiating our parametrized framework as follows. <p> The measure space of SCOUT is fine-grained, and it subsumes the measures used in existing systems, particularly the counters of Kanamori-Fujita [KF87] and the strata of Tamaki-Sato [TS86]. We can show that SCOUT is strictly more expressive (in terms of transformation sequences allowed) than existing unfold/fold systems such as <ref> [KF87, TS86, GK94] </ref>. We now construct SCOUT by instantiating our parametrized framework as follows. We assume that predicate symbols appearing in initial program P 0 are partitioned into n strata a priori. <p> Secondly, the framework makes it possible to incorporate ideas derived from one transformation system to extend and strengthen other systems. A case in point is the construction of SCOUT, where by adding the notion of strata from [TS86] to the counter-based measure of <ref> [KF87] </ref> we derived a system more powerful than either of the two individual systems. Folding using recursive and disjunctive clauses is particularly important for verifying parametrized systems (such as a n-process token ring for arbitrary n) using logic program evaluation and deduction [RRRS98, Ram98].
Reference: [Llo93] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming, Second Edition. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Throughout we will draw on the Kanamori-Fujita system for illustrating the abstract concepts in our framework. We assume familiarity with the standard notions of terms, models, substitutions, unification, most general unifier (mgu), definite clauses, SLD resolution, and proof trees <ref> [Llo93] </ref>.
Reference: [LS95] <author> J.W. Lloyd and J.C. Shepherdson. </author> <title> Partial evaluation in logic programming. </title> <journal> In Journal of Logic Programming, </journal> <volume> 11 </volume> <pages> 295-322, </pages> <year> 1995. </year>
Reference-contexts: Program transformation techniques have been used for program optimization (e.g., partial evaluation <ref> [LS95, LSdW96, JGS93, Sch81] </ref>) and deriving efficient programs from high-level specifications (e.g., program synthesis [BD77, DL94]). Development of transformation techniques is an active area of research in logic programming (see [PP98] for an excellent survey of research done on this topic over the past decade).
Reference: [LSdW96] <author> M. Leuschel, D. De Schreye, and A. de Waal. </author> <title> A conceptual embedding of folding into partial deduction : Towards a maximal integration. </title> <booktitle> In Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 319-332, </pages> <year> 1996. </year>
Reference-contexts: Program transformation techniques have been used for program optimization (e.g., partial evaluation <ref> [LS95, LSdW96, JGS93, Sch81] </ref>) and deriving efficient programs from high-level specifications (e.g., program synthesis [BD77, DL94]). Development of transformation techniques is an active area of research in logic programming (see [PP98] for an excellent survey of research done on this topic over the past decade).
Reference: [Mah87] <author> M. J. Maher. </author> <title> Correctness of a Logic Program Transformation System. </title> <type> Technical report, </type> <institution> IBM T.J. Watson Research Center, </institution> <year> 1987. </year>
Reference-contexts: In the flurry of research activity that followed, a number of unfold/fold transformation systems were developed. Kanamori and Fujita [KF87] proposed a transformation framework that was based on maintaining counters to guide folding. Maher described a system that permits only reversible folding <ref> [Mah87] </ref>. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses [GK94], negation [AD95, Sek91, Sek93]) and applied to practical problems (e.g., [BCD90, BB93, PPR97]). All the above systems differ from each other mainly in terms of the fold operations they permit. <p> Program P 0 Program P 1 Program P 2 Program P 0 2 Program P 0 3 1 Maher's reversible transformation system <ref> [Mah87] </ref> ensures total correctness by exploiting the prop-erty of reversibility: since the effect of any reversible transformation can be undone by applying another transformation, all partially correct transformation sequences are also totally correct [PP98].
Reference: [PP98] <author> A. Pettorossi and M. Proietti. </author> <title> Transformation of Logic Programs, </title> <booktitle> volume 5 of Handbook of Logic in Artificial Intelligence, </booktitle> <pages> pages 697-787. </pages> <publisher> Oxford University Press, </publisher> <year> 1998. </year>
Reference-contexts: Program transformation techniques have been used for program optimization (e.g., partial evaluation [LS95, LSdW96, JGS93, Sch81]) and deriving efficient programs from high-level specifications (e.g., program synthesis [BD77, DL94]). Development of transformation techniques is an active area of research in logic programming (see <ref> [PP98] </ref> for an excellent survey of research done on this topic over the past decade). Unfold/Fold Transformations Some of the most extensively studied transformation systems for logic programs are the so called unfold/fold transformation systems, which consist of two elementary transformations unfolding and folding. <p> 1 Program P 2 Program P 0 2 Program P 0 3 1 Maher's reversible transformation system [Mah87] ensures total correctness by exploiting the prop-erty of reversibility: since the effect of any reversible transformation can be undone by applying another transformation, all partially correct transformation sequences are also totally correct <ref> [PP98] </ref>. However, for reversibility, folding at step i of the transformation can only use the clauses in P i . Transformation Systems with Irreversible Folding Reversibility is a strict condition and disallows many correct folding transformations.
Reference: [PPR97] <author> A. Pettorossi, M. Proietti, and S. Renault. </author> <title> Reducing nondeterminism while specializing logic programs. </title> <booktitle> In 24th POPL, </booktitle> <pages> pages 414-427, </pages> <year> 1997. </year>
Reference-contexts: Maher described a system that permits only reversible folding [Mah87]. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses [GK94], negation [AD95, Sek91, Sek93]) and applied to practical problems (e.g., <ref> [BCD90, BB93, PPR97] </ref>). All the above systems differ from each other mainly in terms of the fold operations they permit. Correctness of Unfold/Fold Transformations Consider the sequence of programs in Figure 1.
Reference: [Ram98] <author> C.R. Ramakrishnan et. al. </author> <title> Logic programming and Model checking. </title> <booktitle> Proceedings of PLILP/ALP, </booktitle> <volume> LNCS 1490, </volume> <pages> pages 1-20, </pages> <year> 1998. </year>
Reference-contexts: red (T) :- reducible ([b|T]). (h0; 1i; h0; 1i) C 12 : theorem (N) :- generate (N, L), reducible (L). (h0; 1i; h0; 1i) programs we encounter when we model verification of parameterized systems (such as n-process token rings, for arbitrary n) as a logic program evaluation and transformation problem <ref> [RRRS98, Ram98] </ref>. 8 The example defines a simple rewrite system to change any occurrence of a to b (predicate edge), and lifts these rewrites to strings of a's and b's (transform). <p> Folding using recursive and disjunctive clauses is particularly important for verifying parametrized systems (such as a n-process token ring for arbitrary n) using logic program evaluation and deduction <ref> [RRRS98, Ram98] </ref>. For instance, the underlying inductive structure of the example in Section 3 is made explicit by applying unfold, fold and goal replacement transformations.
Reference: [RKRR98] <author> A. Roychoudhury, K. Narayan Kumar, C. R. Ramakrishnan, and I. V. Ramakrishnan. </author> <title> A Generalized Unfold/fold transformation System for Definite Logic Programs. </title> <type> Technical report, </type> <institution> SUNY at Stony Brook, </institution> <note> Available at http://www.cs.sunysb.edu/~abhik/transform/papers.html, 1998. </note>
Reference-contexts: In our framework we choose to approximate the savings by a range. In particular fl lo , fl hi bound the range from above and below. We have now set up all the machinery for proving total correctness (Theorem 2) and sketched the salient points of the proof (see <ref> [RKRR98] </ref> for details). Theorem 2 (Total Correctness) Let P 0 ; P 1 ; : : : ; P i be a transformation sequence of measure consistent programs such that M (P 0 ) = M (P j ) for all 0 j i. <p> Having estimated the values of ffi and ffi 0 , the only problem that remains is the identification of semantically equivalent (conjunctions of) atoms. Using a syntax-based procedure to determine whether two atoms are equivalent, we can define a special case of goal replacement, called Syntactic Goal Replacement (see <ref> [RKRR98] </ref> for details). 7 3 SCOUT : A Generalized Unfold/fold Transformation System We now use our parametrized framework to synthesize SCOUT, a concrete unfold/fold transformation system for definite logic programs, that allows disjunctive folding using recursive clauses. <p> The equivalence of these two atoms is evident from the syntax of their clauses in P 0 2 . This forms the basis of our Syntactic Goal Replacement transformation <ref> [RKRR98] </ref>. The ffi and ffi 0 for this syntactic goal replacement step are computed as described in section 2.3, and we have ffi = h0; 1i and ffi 0 = h1; 0i for this step.
Reference: [RRRS98] <author> A. Roychoudhury, C. R. Ramakrishnan, I. V. Ramakrishnan, and S. A. Smolka. </author> <title> Tabulation based Induction proofs with applications to Automated Verification. International Workshop on Tabulation in Parsing and Deduction, </title> <note> Available at http://www.cs.sunysb.edu/~abhik/transform/papers.html, 1998. </note>
Reference-contexts: red (T) :- reducible ([b|T]). (h0; 1i; h0; 1i) C 12 : theorem (N) :- generate (N, L), reducible (L). (h0; 1i; h0; 1i) programs we encounter when we model verification of parameterized systems (such as n-process token rings, for arbitrary n) as a logic program evaluation and transformation problem <ref> [RRRS98, Ram98] </ref>. 8 The example defines a simple rewrite system to change any occurrence of a to b (predicate edge), and lifts these rewrites to strings of a's and b's (transform). <p> Folding using recursive and disjunctive clauses is particularly important for verifying parametrized systems (such as a n-process token ring for arbitrary n) using logic program evaluation and deduction <ref> [RRRS98, Ram98] </ref>. For instance, the underlying inductive structure of the example in Section 3 is made explicit by applying unfold, fold and goal replacement transformations.
Reference: [Sch81] <author> W.L. Scherlis. </author> <title> Program improvement by internal specialization. </title> <booktitle> In POPL'81, </booktitle> <pages> pages 41-49, </pages> <year> 1981. </year>
Reference-contexts: Program transformation techniques have been used for program optimization (e.g., partial evaluation <ref> [LS95, LSdW96, JGS93, Sch81] </ref>) and deriving efficient programs from high-level specifications (e.g., program synthesis [BD77, DL94]). Development of transformation techniques is an active area of research in logic programming (see [PP98] for an excellent survey of research done on this topic over the past decade).
Reference: [Sek91] <author> H. Seki. </author> <title> Unfold/fold transformation of startified programs. </title> <booktitle> In Theoretical Computer Science, </booktitle> <pages> pages 107-139, </pages> <year> 1991. </year>
Reference-contexts: Kanamori and Fujita [KF87] proposed a transformation framework that was based on maintaining counters to guide folding. Maher described a system that permits only reversible folding [Mah87]. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses [GK94], negation <ref> [AD95, Sek91, Sek93] </ref>) and applied to practical problems (e.g., [BCD90, BB93, PPR97]). All the above systems differ from each other mainly in terms of the fold operations they permit. Correctness of Unfold/Fold Transformations Consider the sequence of programs in Figure 1.
Reference: [Sek93] <author> H. Seki. </author> <title> Unfold/fold transformation of general logic programs for well-founded semantics. </title> <journal> In Journal of Logic Programming, </journal> <pages> pages 5-23, </pages> <year> 1993. </year>
Reference-contexts: Kanamori and Fujita [KF87] proposed a transformation framework that was based on maintaining counters to guide folding. Maher described a system that permits only reversible folding [Mah87]. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses [GK94], negation <ref> [AD95, Sek91, Sek93] </ref>) and applied to practical problems (e.g., [BCD90, BB93, PPR97]). All the above systems differ from each other mainly in terms of the fold operations they permit. Correctness of Unfold/Fold Transformations Consider the sequence of programs in Figure 1.
Reference: [TS84] <author> H. Tamaki and T. Sato. </author> <title> Unfold/Fold Transformations of Logic Programs. </title> <booktitle> In Second International Conference on Logic Programming, </booktitle> <pages> pages 127-138, </pages> <year> 1984. </year>
Reference-contexts: As explained below, folding transformations may introduce circularities in definitions and hence may not preserve the meaning of a program. A unfold/fold transformation system for definite logic programs was first described in a seminal paper by Tamaki and Sato <ref> [TS84] </ref>. In the flurry of research activity that followed, a number of unfold/fold transformation systems were developed. Kanamori and Fujita [KF87] proposed a transformation framework that was based on maintaining counters to guide folding. Maher described a system that permits only reversible folding [Mah87]. <p> Transformation Systems with Irreversible Folding Reversibility is a strict condition and disallows many correct folding transformations. Many program transformation systems permit irreversible folding, by allowing folding at step i using clauses that are not in P i . For example, in the original and extended Tamaki-Sato systems <ref> [TS84, TS86] </ref> folding always uses clauses in P 0 whereas in the Kanamori-Fujita system [KF87] the clauses can come from any P j (j i). In order to ensure that folding is still totally correct, these systems permit folding using only clauses with certain (syntactic) properties. <p> Design of such a transformation system has remained open. We describe one such system in Section 3. Despite their apparent diversity, the above transformation systems <ref> [KF87, TS84, TS86, GK94] </ref> show a striking similarity in how they are proved correct. Essentially, these systems associate some measure with different program elements, namely, atoms and clauses to determine whether folding is permissible in that step (e.g., "foldable" flag in [TS84], stratified clauses in [TS86], and counters in [KF87]). <p> Despite their apparent diversity, the above transformation systems [KF87, TS84, TS86, GK94] show a striking similarity in how they are proved correct. Essentially, these systems associate some measure with different program elements, namely, atoms and clauses to determine whether folding is permissible in that step (e.g., "foldable" flag in <ref> [TS84] </ref>, stratified clauses in [TS86], and counters in [KF87]). Moreover, they ensure that each transformation step maintains an invariant relating proofs in the derived program to the various measures (e.g., the notions of rank-consistency in [TS84, KF87], weight-consistency in [GK94] and -completeness in [TS86]). <p> Moreover, they ensure that each transformation step maintains an invariant relating proofs in the derived program to the various measures (e.g., the notions of rank-consistency in <ref> [TS84, KF87] </ref>, weight-consistency in [GK94] and -completeness in [TS86]). The question then is whether a parameterized framework for unfold/fold transformations can be designed such that the above systems can be derived by simply instantiating the framework appropriately. <p> In this paper, we present such a parameterized framework (see Section 2). 1.1 Summary of Results * By suitably abstracting and extending the measures used in <ref> [TS84, TS86, KF87, GK94] </ref>, we develop a general transformation framework for definite logic programs parameterized by an abstract measure (see Section 2). We relax the invariants needed in the proofs to permit approximation of measure values, thereby modeling a large class of transformations. <p> First, when 2 instantiating our framework to derive the Kanamori-Fujita system, it is easy to see that the counters (the measure used in their system) may come from any linearly ordered set; this permits us to incorporate stratification into the counters to obtain a system that generalizes the Tamaki-Sato systems <ref> [TS84, TS86] </ref> as well as the Kanamori-Fujita system. Secondly, the framework allows us to maintain approximate counters; we can hence extend the combined Kanamori-Fujita and Tamaki-Sato system to fold using disjunctive as well as recursive clauses. <p> The implications of the parameterized framework and SCOUT are discussed at length in Section 4. 2 A Parameterized Transformation Framework Following <ref> [KF87, TS84] </ref> we first develop our abstract framework using two transformations: Unfolding and Folding. Subsequently, we show how Goal Replacement transformation can be added to this framework. Throughout we will draw on the Kanamori-Fujita system for illustrating the abstract concepts in our framework. <p> It is worth noting that we do not attempt to translate every proof of A in P i to a proof of A in P i+1 . Instead, following <ref> [KF87, TS86, TS84] </ref> we consider a "special proof" called strongly measure-consistent proof (see Definition 6) of A in P i and construct a proof of A in P i+1 . <p> The clause measures of the other clauses of P i+1 are inherited from P i . 2 Observe that, similar to the goal replacement transformation in <ref> [KF87, TS84, TS86] </ref> the conditions under which the above rule may be applied are not testable at transformation time. <p> All predicate symbols are placed in a single stratum. The lower and upper bound measures of clauses are of the form hi; ji, where i; j; 2 Z. The initial program P 0 = fC 1 ; :::; C 12 g is given in figure 2. Following <ref> [GK94, TS84] </ref> we assume that all definitions (i.e. new predicates needed for specialization, such as spec_red in the above example) are introduced in the original program.
Reference: [TS86] <author> H. Tamaki and T. Sato. </author> <title> A Generalized correctness proof of the unfold/ fold logic program transformation. </title> <type> Technical report, </type> <institution> Ibaraki University, </institution> <address> Japan, </address> <year> 1986. </year> <month> 11 </month>
Reference-contexts: Transformation Systems with Irreversible Folding Reversibility is a strict condition and disallows many correct folding transformations. Many program transformation systems permit irreversible folding, by allowing folding at step i using clauses that are not in P i . For example, in the original and extended Tamaki-Sato systems <ref> [TS84, TS86] </ref> folding always uses clauses in P 0 whereas in the Kanamori-Fujita system [KF87] the clauses can come from any P j (j i). In order to ensure that folding is still totally correct, these systems permit folding using only clauses with certain (syntactic) properties. <p> In [GK94] the above system was extended to allow folding with multiple clauses (disjunctive folding) but all of these clauses are required to be be non-recursive. Kanamori and Fujita [KF87] as well Tamaki and Sato in a later paper <ref> [TS86] </ref> gave two different approaches for conjunctive folding using recursive clauses. In many examples, such as the one we describe in Section 3 which stems from an automated verification application, folding in presence of both disjunction and recursion is crucial. Design of such a transformation system has remained open. <p> Design of such a transformation system has remained open. We describe one such system in Section 3. Despite their apparent diversity, the above transformation systems <ref> [KF87, TS84, TS86, GK94] </ref> show a striking similarity in how they are proved correct. Essentially, these systems associate some measure with different program elements, namely, atoms and clauses to determine whether folding is permissible in that step (e.g., "foldable" flag in [TS84], stratified clauses in [TS86], and counters in [KF87]). <p> Essentially, these systems associate some measure with different program elements, namely, atoms and clauses to determine whether folding is permissible in that step (e.g., "foldable" flag in [TS84], stratified clauses in <ref> [TS86] </ref>, and counters in [KF87]). Moreover, they ensure that each transformation step maintains an invariant relating proofs in the derived program to the various measures (e.g., the notions of rank-consistency in [TS84, KF87], weight-consistency in [GK94] and -completeness in [TS86]). <p> in that step (e.g., "foldable" flag in [TS84], stratified clauses in <ref> [TS86] </ref>, and counters in [KF87]). Moreover, they ensure that each transformation step maintains an invariant relating proofs in the derived program to the various measures (e.g., the notions of rank-consistency in [TS84, KF87], weight-consistency in [GK94] and -completeness in [TS86]). The question then is whether a parameterized framework for unfold/fold transformations can be designed such that the above systems can be derived by simply instantiating the framework appropriately. <p> In this paper, we present such a parameterized framework (see Section 2). 1.1 Summary of Results * By suitably abstracting and extending the measures used in <ref> [TS84, TS86, KF87, GK94] </ref>, we develop a general transformation framework for definite logic programs parameterized by an abstract measure (see Section 2). We relax the invariants needed in the proofs to permit approximation of measure values, thereby modeling a large class of transformations. <p> SCOUT is derived by instantiating our parameterized framework with a fine grained measure based on counters due to Kanamori and Fujita [KF87] and the notion of strata introduced by Tamaki and Sato in <ref> [TS86] </ref>. The development of SCOUT was based on two crucial observations made possible by our framework. <p> First, when 2 instantiating our framework to derive the Kanamori-Fujita system, it is easy to see that the counters (the measure used in their system) may come from any linearly ordered set; this permits us to incorporate stratification into the counters to obtain a system that generalizes the Tamaki-Sato systems <ref> [TS84, TS86] </ref> as well as the Kanamori-Fujita system. Secondly, the framework allows us to maintain approximate counters; we can hence extend the combined Kanamori-Fujita and Tamaki-Sato system to fold using disjunctive as well as recursive clauses. <p> It is worth noting that we do not attempt to translate every proof of A in P i to a proof of A in P i+1 . Instead, following <ref> [KF87, TS86, TS84] </ref> we consider a "special proof" called strongly measure-consistent proof (see Definition 6) of A in P i and construct a proof of A in P i+1 . <p> The above instantiations completely specify the Kanamori-Fujita system as an instance of our framework. Along similar lines, we can instantiate our framework to obtain other unfold/fold systems such as <ref> [TS86, GK94] </ref>. 6 2.3 Goal Replacement Goal replacement is a powerful transformation that allows semantically equivalent conjunctions of atoms to be freely interchanged. <p> The clause measures of the other clauses of P i+1 are inherited from P i . 2 Observe that, similar to the goal replacement transformation in <ref> [KF87, TS84, TS86] </ref> the conditions under which the above rule may be applied are not testable at transformation time. <p> The measure space of SCOUT is fine-grained, and it subsumes the measures used in existing systems, particularly the counters of Kanamori-Fujita [KF87] and the strata of Tamaki-Sato <ref> [TS86] </ref>. We can show that SCOUT is strictly more expressive (in terms of transformation sequences allowed) than existing unfold/fold systems such as [KF87, TS86, GK94]. We now construct SCOUT by instantiating our parametrized framework as follows. <p> The measure space of SCOUT is fine-grained, and it subsumes the measures used in existing systems, particularly the counters of Kanamori-Fujita [KF87] and the strata of Tamaki-Sato [TS86]. We can show that SCOUT is strictly more expressive (in terms of transformation sequences allowed) than existing unfold/fold systems such as <ref> [KF87, TS86, GK94] </ref>. We now construct SCOUT by instantiating our parametrized framework as follows. We assume that predicate symbols appearing in initial program P 0 are partitioned into n strata a priori. <p> Secondly, the framework makes it possible to incorporate ideas derived from one transformation system to extend and strengthen other systems. A case in point is the construction of SCOUT, where by adding the notion of strata from <ref> [TS86] </ref> to the counter-based measure of [KF87] we derived a system more powerful than either of the two individual systems. Folding using recursive and disjunctive clauses is particularly important for verifying parametrized systems (such as a n-process token ring for arbitrary n) using logic program evaluation and deduction [RRRS98, Ram98].
References-found: 22

