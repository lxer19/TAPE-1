URL: ftp://ftp.fzi.de/pub/PROST/papers/modules-in-oo.ps.Z
Refering-URL: http://www.fzi.de/prost/publications/overview.html
Root-URL: http://www.fzi.de
Email: e-mail: rueping@fzi.de  
Title: Modules In Object-Oriented Systems  
Author: Andreas Rping 
Address: Haid-und-Neu-Strae 10-14 D-76131 Karlsruhe, Germany  
Affiliation: Forschungszentrum Informatik (FZI) Bereich Programmstrukturen  
Abstract: This paper discusses aspects of modularity in object-oriented systems. We substantiate the need for components that are less fine-grained than classes. We propose to use subsystems in design and modules in specification and implementation to encapsulate cooperating classes. Such larger components are better comprehensible and reusable than single classes can be. We present precise criteria that modules have to fulfil, ensuring modules to be self-contained. This supports incremental software development: a module being added to a software library, its specified properties cannot be invalidated by other components. Also, we discuss how several modules relate to one another and introduce a compatibility relationship between modules. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Antonio J. Alencar, Joseph A. Goguen. </author> <title> OOZE: An Object Oriented Z Environment, </title> <editor> in Pierre America (Ed.), </editor> <booktitle> ECOOP 91 - European Conference on Object-Oriented Programming. Lecture Notes in Computer Science No. </booktitle> <volume> 512. </volume> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Doing so, the module concept and its advantages for incremental software development can well be applied to Eiffel. Furthermore, Lace (Language for Assembling Classes in Eiffel) supplies so-called clusters which are very similar to modules. OOZE (cf. <ref> [1] </ref>), an object-oriented extension of Z, supplies object-oriented constructs, modula-risation, and specification techniques. One is explicitly encouraged to organize mutually dependent classes in one encapsulating module, although the relationship between the classes is not specified with a module invariant.
Reference: [2] <author> Timothy Budd. </author> <title> An Introduction to Object-Oriented Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Modules in Object-Oriented Systems 2 2 The Process of Software Development The concepts presented in this paper are based on a particular software development process (cf. [9]). Our approach differs from the well known object-oriented methodologies described in literature (cf. <ref> [2] </ref>, [24]) where the development process is often said to consist of (requirement) analysis, modelling and design, and implementation. We adopt these three stages from Responsibility-Driven Design (cf. [24]), but add a specification phase. We start with informal development steps and later formalize the results.
Reference: [3] <author> L. Cardelli, P. Wegner. </author> <title> On Understanding Types, Data Abstraction, and Polymorphism. </title> <journal> ACM Computing Surveys Vol. </journal> <volume> 17, No. 4. </volume> <publisher> ACM Press, </publisher> <month> December </month> <year> 1985. </year>
Reference-contexts: Therefore, inheritance is used to express compatibility between classes. A subclass is required to have at least the same features and properties as its superclass. However, the term compatibility covers several kinds of relationships between classes, including conformance and imitation: Essentially, conformance means that the principle of substitutability (cf. <ref> [3] </ref>) holds for all objects: an object of a superclass can be safely replaced by an object of a conforming subclass. This requires contravariant typing policy. Also, preconditions may be weakened and postconditions may only be strengthened in the subclass.
Reference: [4] <author> Dennis de Champeaux, Douglas Lea, and Penelope Faure. </author> <title> Object-Oriented System Development. </title> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: To a certain extent, our module concept incorporates the glue pattern. For instance, it is the class Graph which exports almost all methods that are exported from the module GRAPH in our example. A concept similar to modules is also proposed in <ref> [4] </ref>. De Champeaux, Lea, and Faure organize closely cooperating objects in so-called ensembles. An ensemble contains other objects that are considered internal to the encompassing object. Only the ensemble communicates with the outside world. The relationships between an ensemble and its internal objects are protected.
Reference: [5] <author> Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. </author> <title> Design Patterns: Abstraction and Reuse of Object-Oriented Design, </title> <editor> in Oscar M. Nierstrasz (Ed.), </editor> <booktitle> ECOOP 93 - European Conference on Object-Oriented Programming. Lecture Notes in Computer Science (LNCS) No. </booktitle> <volume> 707. </volume> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: A subsystem provides a unit of responsibilities and functionality to its outside world. Wirfs-Brock et al. use subsystems as a means of abstraction and encapsulation. A subsystem hides from the rest of the entire system the information which is of interest for the subsystems classes only. Design patterns (cf. <ref> [5] </ref>, [6]) describe common structures found in reusable object-oriented designs. They are considered reusable microar-chitectures. Since design patterns describe how smaller components can be composed to a larger structure, they often refer to more than one class or more than one object.
Reference: [6] <author> Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. </author> <title> A Catalog of Object-Oriented Design Patterns. </title> <note> 1994, to appear. </note>
Reference-contexts: Wirfs-Brock et al. use subsystems as a means of abstraction and encapsulation. A subsystem hides from the rest of the entire system the information which is of interest for the subsystems classes only. Design patterns (cf. [5], <ref> [6] </ref>) describe common structures found in reusable object-oriented designs. They are considered reusable microar-chitectures. Since design patterns describe how smaller components can be composed to a larger structure, they often refer to more than one class or more than one object.
Reference: [7] <author> A. Goldberg, D. Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Modularity is widely accepted to be an important issue for the comprehensibility, the extendibility, and the reusability of software, in particular in the context of library construction. However, many object-oriented programming languages such as C++ (cf. [20]), Smalltalk (cf. <ref> [7] </ref>), Eiffel (cf. [10], [11]), and Sather (cf. [14]) refer to classes as the only structuring mechanism. Still, problems can be circumvented if classes call methods of other classes only in a restricted way (according to the criteria presented).
Reference: [8] <author> Samuel P. Harbison. </author> <title> Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: As already pointed out, this is not necessarily achieved in practical cases, especially in the presence of abstraction between modules. Module compatibility is not considered in [21]. Among the object-oriented successors of Modula-2 (cf. [25]), Modula-3 (cf. <ref> [8] </ref>, [13]) places the emphasis on concurrent programming with threads, while Oberon (cf. [12], [16]) focuses on the integration of structured, modular, and object-oriented programming. Modules are considered a structuring medium, an abstraction medium, and compilation units. Inheritance means type extension.
Reference: [9] <author> Thomas Lindner, Andreas Rping. </author> <title> Formal Object-Oriented Software Design: The Coffer Approach. </title> <type> Technical Report FZI-ProSt, </type> <institution> Forschungszentrum Informatik Karlsruhe, </institution> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: Section 4 is a discussion of related work. In Section 5 we draw some conclusions from the concepts presented. Modules in Object-Oriented Systems 2 2 The Process of Software Development The concepts presented in this paper are based on a particular software development process (cf. <ref> [9] </ref>). Our approach differs from the well known object-oriented methodologies described in literature (cf. [2], [24]) where the development process is often said to consist of (requirement) analysis, modelling and design, and implementation. We adopt these three stages from Responsibility-Driven Design (cf. [24]), but add a specification phase. <p> We continue our example and present the specification of the directed graph in Figure 4. We apply a specification language which is inu-enced by both Eiffel (cf. [11]) and several specification techniques (cf. <ref> [9] </ref>). Behaviour is specified with specification statements (statements which may or may not be executable) or with pre and postconditions, whatever is easier.
Reference: [10] <author> Bertrand Meyer. </author> <title> Tools for the New Culture: Lessons from the Design of the Eiffel Libraries, </title> <journal> in Communications of the ACM, </journal> <volume> Volume 33, No. 9, </volume> <year> 1990. </year>
Reference-contexts: Modularity is widely accepted to be an important issue for the comprehensibility, the extendibility, and the reusability of software, in particular in the context of library construction. However, many object-oriented programming languages such as C++ (cf. [20]), Smalltalk (cf. [7]), Eiffel (cf. <ref> [10] </ref>, [11]), and Sather (cf. [14]) refer to classes as the only structuring mechanism. Still, problems can be circumvented if classes call methods of other classes only in a restricted way (according to the criteria presented). <p> Both Modula-3 and Oberon modules can be used to protect such invariants against violation. However, no abstraction relationship for modules is proposed in either language. Modules are therefore not used to express the refinement or specialization of a group of classes. As opposed to Modula-3 and Oberon, Eiffel (cf. <ref> [10] </ref>, [11]) does not support modules. The notions of class and of module are in fact unified. Eiffel provides specification constructs such as invariants, pre and postconditions. Modules can be simulated in Eiffel by restricting the export of methods to certain classes.
Reference: [11] <author> Bertrand Meyer. </author> <title> Eiffel - The Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Specification The results from the design stage are then transformed into a specification. For instance, contracts are transformed into public abstract methods (cf. Figure 2). We use an Eiffel-like language including the specification constructs Eiffel offers (cf. <ref> [11] </ref>), and enriched by first Requirement Analysis Modelling & Design Specification Implementation Design: Class Contract Subsystem Specification / Implementation: Class Public Method Module Modules in Object-Oriented Systems 3 order logic predicates in pre and postcondi-tions and in invariants. <p> We continue our example and present the specification of the directed graph in Figure 4. We apply a specification language which is inu-enced by both Eiffel (cf. <ref> [11] </ref>) and several specification techniques (cf. [9]). Behaviour is specified with specification statements (statements which may or may not be executable) or with pre and postconditions, whatever is easier. <p> Modularity is widely accepted to be an important issue for the comprehensibility, the extendibility, and the reusability of software, in particular in the context of library construction. However, many object-oriented programming languages such as C++ (cf. [20]), Smalltalk (cf. [7]), Eiffel (cf. [10], <ref> [11] </ref>), and Sather (cf. [14]) refer to classes as the only structuring mechanism. Still, problems can be circumvented if classes call methods of other classes only in a restricted way (according to the criteria presented). <p> However, no abstraction relationship for modules is proposed in either language. Modules are therefore not used to express the refinement or specialization of a group of classes. As opposed to Modula-3 and Oberon, Eiffel (cf. [10], <ref> [11] </ref>) does not support modules. The notions of class and of module are in fact unified. Eiffel provides specification constructs such as invariants, pre and postconditions. Modules can be simulated in Eiffel by restricting the export of methods to certain classes.
Reference: [12] <editor> Hanspeter Mssenbck. </editor> <booktitle> Object-Oriented Programming in Oberon-2. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Module compatibility is not considered in [21]. Among the object-oriented successors of Modula-2 (cf. [25]), Modula-3 (cf. [8], [13]) places the emphasis on concurrent programming with threads, while Oberon (cf. <ref> [12] </ref>, [16]) focuses on the integration of structured, modular, and object-oriented programming. Modules are considered a structuring medium, an abstraction medium, and compilation units. Inheritance means type extension. Although no specification constructs are provided in either language, we can think of invariants assigned to a module as a comment.
Reference: [13] <author> Greg Nelson (Ed.). </author> <title> Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: As already pointed out, this is not necessarily achieved in practical cases, especially in the presence of abstraction between modules. Module compatibility is not considered in [21]. Among the object-oriented successors of Modula-2 (cf. [25]), Modula-3 (cf. [8], <ref> [13] </ref>) places the emphasis on concurrent programming with threads, while Oberon (cf. [12], [16]) focuses on the integration of structured, modular, and object-oriented programming. Modules are considered a structuring medium, an abstraction medium, and compilation units. Inheritance means type extension.
Reference: [14] <author> Steven M. Omohundro. </author> <title> The Sather 1.0 Specification. </title> <type> Technical Report, </type> <institution> International Computer Science Institute, Berkeley, California, </institution> <year> 1993. </year>
Reference-contexts: Modularity is widely accepted to be an important issue for the comprehensibility, the extendibility, and the reusability of software, in particular in the context of library construction. However, many object-oriented programming languages such as C++ (cf. [20]), Smalltalk (cf. [7]), Eiffel (cf. [10], [11]), and Sather (cf. <ref> [14] </ref>) refer to classes as the only structuring mechanism. Still, problems can be circumvented if classes call methods of other classes only in a restricted way (according to the criteria presented).
Reference: [15] <author> David L. Parnas. </author> <title> On the Criteria to be Used in Decomposing Systems into Modules. </title> <journal> Communications of the ACM, </journal> <volume> Vol. 15, No. 2. </volume> <publisher> ACM Press, </publisher> <month> December </month> <year> 1972. </year> <title> Modules in Object-Oriented Systems 13 </title>
Reference-contexts: Basically, the idea of modularity says that single components need to be understood independently, without knowledge of the details of other components (cf. <ref> [15] </ref>) Single classes often do not fulfil these requirements. Classes have to cooperate and sometimes have to depend on each other in a very natural way.
Reference: [16] <author> Martin Reiser, Niklaus Wirth. </author> <title> Programming in Oberon - Steps Beyond Pascal and Modula. </title> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Module compatibility is not considered in [21]. Among the object-oriented successors of Modula-2 (cf. [25]), Modula-3 (cf. [8], [13]) places the emphasis on concurrent programming with threads, while Oberon (cf. [12], <ref> [16] </ref>) focuses on the integration of structured, modular, and object-oriented programming. Modules are considered a structuring medium, an abstraction medium, and compilation units. Inheritance means type extension. Although no specification constructs are provided in either language, we can think of invariants assigned to a module as a comment.
Reference: [17] <author> Andreas Rping, Franz Weber, Walter Zimmer. </author> <title> Demonstrating Coherent Design - A Data Structure Catalogue, </title> <editor> in Raimund Ege, Madhu Singh, Bertrand Meyer (Eds.), </editor> <booktitle> TOOLS 11 - Technology of Object-Oriented Languages and Systems. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Concepts shared by several classes are factored out into a common superclass. Conceptual abstraction is recognized to be an important structuring mechanism for large software systems, for instance software libraries (cf. <ref> [17] </ref>). Typically, an abstraction relationship between classes is represented by inheritance, with the more concrete subclass inheriting from the more abstract superclass. Therefore, inheritance is used to express compatibility between classes. A subclass is required to have at least the same features and properties as its superclass.
Reference: [18] <author> Andreas Rping. </author> <title> Hypertext Case Study - An Object-Oriented Specification, </title> <editor> in Eduardo Casais, Claus Lewerentz (Eds.), </editor> <title> Building Object Oriented Software Libraries. </title> <type> FZI-Publication 6/93, </type> <institution> Forschungszentrum Informatik Karlsruhe, </institution> <year> 1993 </year>
Reference-contexts: add_node () is ... remove_node (n: Node) is ... is_elem (n: Node): Boolean is result := (n = node) left.is_elem (n) right.is_elem (n) end Tree class Node [T-&gt;Tree] invariant contained_in.is_elem (self) end Node [T-&gt;Tree] Modules in Object-Oriented Systems 10 The design and specification of a hypertext system is presented in <ref> [18] </ref>. Properties of the system are specified with invariants. It is demonstrated that, due to the use of modules, the invariants can be checked for locally. The module that contains the hypertext system is showed to be a well encapsulated and self contained software component.
Reference: [19] <author> Andreas Rping, Emil Sekerinski. </author> <title> Modula-3 - Modelling and Implementation of an Industrial Production Cell, </title> <editor> in Claus Lewerentz, Thomas Lindner (Eds.), </editor> <title> Case Study Production Cell: A Comparative Study in Formal Software Development. </title> <type> FZI-Publication 1-94, </type> <institution> Forschungszentrum Informatik Karlsruhe, </institution> <year> 1994. </year>
Reference-contexts: The module that contains the hypertext system is showed to be a well encapsulated and self contained software component. The control software for an industrial production cell is an example from a different application domain (cf. <ref> [19] </ref>). The machinery of the production cell consists of several cooperating devices which have to fulfil certain safety requirements. The single devices being modelled as individual objects, the invariants which express the safety requirements have to refer to objects of different classes.
Reference: [20] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Modularity is widely accepted to be an important issue for the comprehensibility, the extendibility, and the reusability of software, in particular in the context of library construction. However, many object-oriented programming languages such as C++ (cf. <ref> [20] </ref>), Smalltalk (cf. [7]), Eiffel (cf. [10], [11]), and Sather (cf. [14]) refer to classes as the only structuring mechanism. Still, problems can be circumvented if classes call methods of other classes only in a restricted way (according to the criteria presented).
Reference: [21] <author> Clemens A. Szyperski. </author> <title> Import Is not Inheritance - Why We Need Both: Modules and Classes, </title> <editor> in Ole Lehrmann Madsen (Ed.), </editor> <booktitle> ECOOP 92 - European Conference on Object-Oriented Programming. Lecture Notes in Computer Science (LNCS) No. </booktitle> <volume> 615. </volume> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The relationships between an ensemble and its internal objects are protected. Although ensembles and Modules in Object-Oriented Systems 11 modules are not the same, this approach resembles our example where nodes and edges are regarded as internal to a graph. Programming and specification languages In <ref> [21] </ref>, Clemens Szyperski suggests to use modules in object-oriented programming languages for two different motives. First, it is stated that import and inheritance are often confused. Distinguishing between classes and modules helps clarify the difference between these two relationships. <p> However, in <ref> [21] </ref>modules are defined as a partitioning over all items in a system. As already pointed out, this is not necessarily achieved in practical cases, especially in the presence of abstraction between modules. Module compatibility is not considered in [21]. Among the object-oriented successors of Modula-2 (cf. [25]), Modula-3 (cf. [8], [13]) places the emphasis on concurrent programming with threads, while Oberon (cf. [12], [16]) focuses on the integration of structured, modular, and object-oriented programming. Modules are considered a structuring medium, an abstraction medium, and compilation units.
Reference: [22] <author> Franz Weber. </author> <title> Getting Class Correctness and System Correctness Equivalent - How to Get Covariance Right, </title> <editor> in Raimund Ege, Madhu Singh, Bertrand Meyer (Eds.), </editor> <booktitle> TOOLS 8 - Technology of Object-Oriented Languages and Systems. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: This requires contravariant typing policy. Also, preconditions may be weakened and postconditions may only be strengthened in the subclass. Imitation (cf. <ref> [22] </ref>) is a weaker form of compatibility, compared to conformance. It allows for an exception to the contravariant typing policy, namely the use of a parameter typed with selftype in method declarations inside abstract classes. <p> Thus, the Criteria 6 and 7 extend the notion of imitation (cf. <ref> [22] </ref>) to modules. Third, our concept allows for using a class in the contexts of different modules. Node is included in all three modules of the example. We therefore prevent modules from strictly partitioning a software system or a library.
Reference: [23] <author> Alan Wills. </author> <title> Capsules and Types in Fresco: Program Verification in Smalltalk, </title> <editor> in Pierre America (Ed.), </editor> <booktitle> ECOOP 91 - European Conference on Object-Oriented Programming. Lecture Notes in Computer Science No. </booktitle> <volume> 512. </volume> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: However, there is no support for refining or specializing such mutually dependent classes by introducing a submodule. Also, OOZE focuses on algebraic specification, in contrast to the model based approach of this paper. Fresco (cf. <ref> [23] </ref>) is an interactive environment extending Smalltalk in two ways. First, so-called capsules are introduced. A capsule is a reusable unit containing code, specification, and proofs. Different capsules are required to be mutually independent. Second, Fresco provides a notation for describing behaviour and tools for program verification. <p> In fact, capsules resemble the modules described in this paper. The main difference is that no abstraction relationship between capsules is defined, as opposed to supermodules and less abstract or more specialized submodules. Yet, both capsules and modules are introduced for similar motives. In <ref> [23] </ref>, Alan Wills argues that capsules made of several classes support reuse and incremental software construction. The same applies to modules. 5 Conclusions We have analysed the modularity of object-oriented systems during design and specification. The discussion showed that a well modularised system requires structures less fine-grained than classes.
Reference: [24] <author> Rebecca Wirfs-Brock, Brian Wilkerson, Lauren Wiener. </author> <title> Designing Object-Oriented Software. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Modules in Object-Oriented Systems 2 2 The Process of Software Development The concepts presented in this paper are based on a particular software development process (cf. [9]). Our approach differs from the well known object-oriented methodologies described in literature (cf. [2], <ref> [24] </ref>) where the development process is often said to consist of (requirement) analysis, modelling and design, and implementation. We adopt these three stages from Responsibility-Driven Design (cf. [24]), but add a specification phase. We start with informal development steps and later formalize the results. <p> Our approach differs from the well known object-oriented methodologies described in literature (cf. [2], <ref> [24] </ref>) where the development process is often said to consist of (requirement) analysis, modelling and design, and implementation. We adopt these three stages from Responsibility-Driven Design (cf. [24]), but add a specification phase. We start with informal development steps and later formalize the results. In detail, we propose a software development process consisting of the following stages, with possible iterations (cf. Figure 1): Requirement analysis During requirement analysis the tasks of a software system are defined. <p> Some approaches, however, do include structures less fine-grained than classes: Analysis and design Most methodologies for object-oriented analysis and design group closely cooperating classes into subsystems. As an example we refer to Responsibility-Driven Design (cf. <ref> [24] </ref>). A subsystem provides a unit of responsibilities and functionality to its outside world. Wirfs-Brock et al. use subsystems as a means of abstraction and encapsulation. A subsystem hides from the rest of the entire system the information which is of interest for the subsystems classes only.
Reference: [25] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer Verlag, </publisher> <year> 1984. </year>
Reference-contexts: However, in [21]modules are defined as a partitioning over all items in a system. As already pointed out, this is not necessarily achieved in practical cases, especially in the presence of abstraction between modules. Module compatibility is not considered in [21]. Among the object-oriented successors of Modula-2 (cf. <ref> [25] </ref>), Modula-3 (cf. [8], [13]) places the emphasis on concurrent programming with threads, while Oberon (cf. [12], [16]) focuses on the integration of structured, modular, and object-oriented programming. Modules are considered a structuring medium, an abstraction medium, and compilation units. Inheritance means type extension.
References-found: 25

