URL: http://www.cs.iastate.edu/tech-reports/TR97-22.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: LSL traits for using Z with Larch languages, tools; F.3.1 [Logics and Meanings of Programs]
Author: Hua Zhong Hua Zhong 
Keyword: formal methods, specification, Larch, Z, LSL, Larch/C++, mathematical toolkit, debugging,  
Address: Ames, Iowa 50011, USA  
Affiliation: Department of Computer Science Iowa State University  
Note: TR #97-22 December 1997  1997 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications  Partions will be Submitted Copyright c 1997 by  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Jonathan Bowen. </author> <title> Z Frequently Asked Questions. </title> <note> Available in ftp://ftp.comlab.ox.ac.uk/archive/z.html, </note> <month> September </month> <year> 1997. </year>
Reference-contexts: All the other abstract values can be generated by using a sequence of pop and push applied to the emptystack. 1.1.1 Z "Z is a specification language which is based on the set theory and first order predicate logic" <ref> [1] </ref>. It has a predefined mathematical toolkit which defines sets, relations, functions, sequences and bags.
Reference: [2] <author> Stephen J. Garland and John V. Guttag. </author> <title> A guide to lp, the larch prover. </title> <type> Technical Report 82, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> December </month> <year> 1991. </year> <title> Order from src-report@src.dec.com. </title>
Reference-contexts: This makes it possible for one to find the bugs in a specification by trying to prove these theorems from the original axioms of the specification [3]. The Larch Prover (LP) is an interactive theorem proof assistant that can help in debugging Larch-style specification. Galand and Guttag's paper <ref> [2] </ref> and Chapter 7 of Guttag and Horning's book [3] talk in more detail of how to debug traits using LP. I have used LP to help debug some of the traits I present in this paper. I now describe the process of using LP for debugging LSL traits. <p> So the current subgoal is : "A x (x "mem p1 &lt;=&gt; x "mem p) =&gt; p = p1. After we observe this subgoal, we can see that it has the form A =&gt; B . Thus, using the tips that Garland gives in his LP guide <ref> [2] </ref>, we first try "resume by =&gt;". Then this conjecture is proved. The other part of this proof is easier. <p> They might contain claims which can prove true = false. If this happens to be the case, any implication can be proved. But unfortunately, there is no general way to help us always write consistent traits. For more details about using LP, see Garland and Guttag's guide for LP <ref> [2] </ref> and Leavens's Larch FAQ [7]. 34 Chapter 5 Discussion When I wrote these traits, I found the following differences between Z and Larch that are described in the next two sections. 5.1 LSL differences The following is some differences between Z and LSL: * First, a big difference is that <p> x)) /" (("dom f) = (1 "upto (#f))); f "mem ("seqone x) == f "mem ("seq x) /" ((# f) &gt;0); "iseq x == ("seq x) "int (nat "pinj x); "langle "rangle == emptyset:P [P [pair [Z,X]]]; "langle y "rangle == -[1, y]-; "langle y1, y2 "rangle == -[1, y1], <ref> [2, y2] </ref>-; "langle y1, y2, y3 "rangle == -[1, y1], [2, y2], [3, y3]-; A.34 SetMap.lsl % @(#)$Id: SetMap.lsl,v 1.4 1997/09/28 03: 30: 17 hzhong Exp $ % Written by Hua Zhong with the help of Dr. Gary T. <p> ("seqone x) == f "mem ("seq x) /" ((# f) &gt;0); "iseq x == ("seq x) "int (nat "pinj x); "langle "rangle == emptyset:P [P [pair [Z,X]]]; "langle y "rangle == -[1, y]-; "langle y1, y2 "rangle == -[1, y1], <ref> [2, y2] </ref>-; "langle y1, y2, y3 "rangle == -[1, y1], [2, y2], [3, y3]-; A.34 SetMap.lsl % @(#)$Id: SetMap.lsl,v 1.4 1997/09/28 03: 30: 17 hzhong Exp $ % Written by Hua Zhong with the help of Dr. Gary T.
Reference: [3] <author> John V. Guttag and James J. Horning, </author> <title> editors. Larch: Languages and Tools for Formal Specification. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <editor> With Stephen J. Garland, Kevin D. Jones, Andres Modet, and Jeannette M. </editor> <publisher> Wing. </publisher>
Reference-contexts: Only some syntax is changed; e.g., 8 is converted to "A, and , is converted to == . We use a different way of defining ("psubs), because in Guttag and Horning's Larch handbook <ref> [3] </ref>, there is a trait called DerivedOrders that can be used. So, we define using DerivedOrders. Meanwhile we add two more operations: ("sups) and ("psups). P ("pset) is defined in page 56 of Spivey's book [9]. There is no Z definition of it. <p> After writing the specification, one can give some theorems that intuitively follow from it. This makes it possible for one to find the bugs in a specification by trying to prove these theorems from the original axioms of the specification <ref> [3] </ref>. The Larch Prover (LP) is an interactive theorem proof assistant that can help in debugging Larch-style specification. Galand and Guttag's paper [2] and Chapter 7 of Guttag and Horning's book [3] talk in more detail of how to debug traits using LP. <p> find the bugs in a specification by trying to prove these theorems from the original axioms of the specification <ref> [3] </ref>. The Larch Prover (LP) is an interactive theorem proof assistant that can help in debugging Larch-style specification. Galand and Guttag's paper [2] and Chapter 7 of Guttag and Horning's book [3] talk in more detail of how to debug traits using LP. I have used LP to help debug some of the traits I present in this paper. I now describe the process of using LP for debugging LSL traits. <p> == f "mem ("seq x) /" ((# f) &gt;0); "iseq x == ("seq x) "int (nat "pinj x); "langle "rangle == emptyset:P [P [pair [Z,X]]]; "langle y "rangle == -[1, y]-; "langle y1, y2 "rangle == -[1, y1], [2, y2]-; "langle y1, y2, y3 "rangle == -[1, y1], [2, y2], <ref> [3, y3] </ref>-; A.34 SetMap.lsl % @(#)$Id: SetMap.lsl,v 1.4 1997/09/28 03: 30: 17 hzhong Exp $ % Written by Hua Zhong with the help of Dr. Gary T.
Reference: [4] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: These traits appear in Appendix A. Thus users can use the Z mathematical toolkit for writing Larch/C++ specifications. A summary of these traits is given in Tables 2.1, 2.2, 2.3, 2.5, 2.4, 2.6, and 2.7. Table 2.1: Sets Trait Name Page in <ref> [4] </ref> Operations Symbols in Z ZPowerSet 89,90 "mem 2 "nem 62 emptyset,varemptyset ? - __ fag - __, __ ,__ - fa; b; cg ZSet 90 "subs "pset P "psetone P 1 SetUnionIntersectDiff 91 "int " "uni [ "setminus n GeneUniInt 92 "duni [ "dint " 10 Table 2.2: Relations Trait <p> Z ZPowerSet 89,90 "mem 2 "nem 62 emptyset,varemptyset ? - __ fag - __, __ ,__ - fa; b; cg ZSet 90 "subs "pset P "psetone P 1 SetUnionIntersectDiff 91 "int " "uni [ "setminus n GeneUniInt 92 "duni [ "dint " 10 Table 2.2: Relations Trait Name Page in <ref> [4] </ref> Operations Symbols in Z Rel 95 "rel $ DomRan 96 "dom dom "ran ran Cmp 97 "fcmp o 9 "cmp ffi DresRres 98 "dres C "rres B DsubRsub 99 "dsub C "rsub B RelInv 100 "inv R ~ RelImg 101 "img (jj) RelOvr 102 "fovr TclRtcl 103 "tcl + "rtcl <p> DomRan 96 "dom dom "ran ran Cmp 97 "fcmp o 9 "cmp ffi DresRres 98 "dres C "rres B DsubRsub 99 "dsub C "rsub B RelInv 100 "inv R ~ RelImg 101 "img (jj) RelOvr 102 "fovr TclRtcl 103 "tcl + "rtcl fl Table 2.3: Functions Trait Name Page in <ref> [4] </ref> Operations Symbols in Z Function 105 "pfun 7! "tfun ! "pinj 7 "tinj "psur 7!! "tsur !! "bij ! apply f (x ) Table 2.4: Misc Trait Name Page in [4] Operations Symbols in Z Func func Pass pass SetMap map Pair 93 first second "prod fi 11 Table 2.5: <p> 101 "img (jj) RelOvr 102 "fovr TclRtcl 103 "tcl + "rtcl fl Table 2.3: Functions Trait Name Page in <ref> [4] </ref> Operations Symbols in Z Function 105 "pfun 7! "tfun ! "pinj 7 "tinj "psur 7!! "tsur !! "bij ! apply f (x ) Table 2.4: Misc Trait Name Page in [4] Operations Symbols in Z Func func Pass pass SetMap map Pair 93 first second "prod fi 11 Table 2.5: Numbers and finiteness Trait Name Page in [4] Operations Symbols in Z ZNumber 108 nat N integer Z natone N 1 "succ succ "upto n : : m Iteration 110 iter <p> 7! "tfun ! "pinj 7 "tinj "psur 7!! "tsur !! "bij ! apply f (x ) Table 2.4: Misc Trait Name Page in <ref> [4] </ref> Operations Symbols in Z Func func Pass pass SetMap map Pair 93 first second "prod fi 11 Table 2.5: Numbers and finiteness Trait Name Page in [4] Operations Symbols in Z ZNumber 108 nat N integer Z natone N 1 "succ succ "upto n : : m Iteration 110 iter (0,R) iter 0 R "iter R k FiniteSet 111 "fset F "fsetone F 1 # # FinitePartial 112 "ffun 7 7! "finj 7 7 SetMinMax 113 "min <p> natone N 1 "succ succ "upto n : : m Iteration 110 iter (0,R) iter 0 R "iter R k FiniteSet 111 "fset F "fsetone F 1 # # FinitePartial 112 "ffun 7 7! "finj 7 7 SetMinMax 113 "min min "max max Table 2.6: Sequences Trait Name Page in <ref> [4] </ref> Operations Symbols in Z Sequences 115 "seq seq "seqone seq 1 "iseq iseq ConcatRev 116 "cat a "rev rev HeadLastTailFront 117 "head head "last last "tail tail "front front ExtFilCom 118 "ires ~ "sres "squash squash PrefixSuffixIn 119 "prefix "suffix suffix "inseq in DConcat 121 "dcat a = 12 Table <p> "seq seq "seqone seq 1 "iseq iseq ConcatRev 116 "cat a "rev rev HeadLastTailFront 117 "head head "last last "tail tail "front front ExtFilCom 118 "ires ~ "sres "squash squash PrefixSuffixIn 119 "prefix "suffix suffix "inseq in DConcat 121 "dcat a = 12 Table 2.7: Bags Trait Name Page in <ref> [4] </ref> Operations Symbols in Z Bags 124 "bag bag "bagcount count # ] "otimes BagMemSub 125 "inbag in "bagsubs v BagUniDiff 126 "buni ] "bdiff BagItems 127 "items items DisjointPartitions 122 "disjoint disjoint "partitions partitions Filter filter 13 Chapter 3 Using Z with Larch Now, let's see an example of how <p> Filter filter 13 Chapter 3 Using Z with Larch Now, let's see an example of how to use those traits to translate a specification written in Z to Larch/C++. 3.1 Example 1: Symbol Table The first example is taken from the example first given in page 38-42 of Hayes' book <ref> [4] </ref>. It defines symbol tables, which are used to record attributes of the symbols in a compiler. In this example, symbol tables are defined as a partial function from type SYM to type VAL. SYM is the type for the symbol, and VAL is the type for its attribute. <p> The following invariant clause is converted from the Z definition: st ; st 0 : SYM 7! VAL. It means st is always a partial function that maps from a SYM to a VAL. //@ invariant st"any "mem (universe:SetOfSym "pfun universe:SetOfVal); In the original example in Hayes's book <ref> [4] </ref>, Update is defined in following way: Update st ; st 0 : SYM 7! VAL v ? : VAL In Larch/C++, we write the Update operation in this way: virtual Update (SYM s,VAL v) throw (); //@ behavior - //@ modifies st; //@ ensures st' = (st^ "fovr - s <p> As I mentioned in Chapter 2, the L A T E X notation has been used in my traits for the operation name if possible. In the original example in Hayes's book <ref> [4] </ref>, LookUp is defined in following way: LookUp st ; st 0 : SYM 7! VAL v ? : VAL v ! = st (s?) ^ In Larch/C++, this becomes, virtual VAL LookUp (SYM s) throw (); //@ behavior - //@ requires s "mem ("dom st^); //@ ensures result = apply <p> The default for Larch/C++ is that an omitted modifies clause means no objects may be changed. In the original example <ref> [4] </ref>, Delete is defined in following way: Delete st ; st 0 : SYM 7! VAL s? 2 dom st ^ We translate it to the following, virtual void Delete (SYM s) throw (); //@ behavior - //@ requires s "mem ("dom st^); //@ modifies st; //@ ensures st' = -s- <p> //@ - virtual void Delete (SYM s) throw (); //@ behavior - //@ requires s "mem ("dom st^); //@ modifies st; //@ ensures st' = -s- "dsub st^; //@ - 3.2 Example 2: Symbol Table with Error Han dling The second example is taken from page 52-57 of Hayes' book <ref> [4] </ref>. It still talks about symbol tables. But different notations of Z are used for the Z specification, and error handling is added into the specification. The Z specification is given in Figure 3.1. In Z, when one uses symbol , one usually means that this object may be modified.
Reference: [5] <author> Daniel Jackson. </author> <title> Structuring Z specifications with views. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 4(4) </volume> <pages> 365-389, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: ensures st' = -s- "dsub st^ /" returns; //@ also 22 //@ requires s "nem -"dom st^-; //@ ensures throws (RepSignal) /" //@ thrown (RepSignal)= Symbol_not_present; //@ - 3.3 Example 3: Phone Network The third example is taken from a complex example that given in page 370-388 of Jackson's paper <ref> [5] </ref>. It gives a specification of phone network. In Jackson's paper, he talks about using views to simplify the writing of specification. Two views have been used for the example of a phone network: a phone view and a switch view.
Reference: [6] <author> Leslie Lamport and Lawrence C. Paulson. </author> <title> Should your specification language be typed? Technical report, </title> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: Thus the type system of Z is more flexible <ref> [6] </ref>. For example, in Z, schema a: X actually has the same meaning as a 2 X . On the other hand, in LSL the declaration a : X means that, X is the name of a sort. X can not be treated as a set at any time.
Reference: [7] <author> Gary T. Leavens. </author> <title> Larch Frequently Asked Questions. </title> <note> Version 1.88. Available in http://www.cs.iastate.edu/~leavens/larch-faq.html, October 1997. </note>
Reference-contexts: If this happens to be the case, any implication can be proved. But unfortunately, there is no general way to help us always write consistent traits. For more details about using LP, see Garland and Guttag's guide for LP [2] and Leavens's Larch FAQ <ref> [7] </ref>. 34 Chapter 5 Discussion When I wrote these traits, I found the following differences between Z and Larch that are described in the next two sections. 5.1 LSL differences The following is some differences between Z and LSL: * First, a big difference is that the mathematical model of Z
Reference: [8] <author> Gary T. Leavens and Jeannette M. Wing. </author> <title> Protective interface specifications. </title> <editor> In Michel Bidoit and Max Dauchet, editors, </editor> <booktitle> TAPSOFT '97: Theory and Practice of Software Development, 7th International Joint Conference CAAP/FASE, Lille, France, volume 1214 of Lecture Notes in Computer Science, </booktitle> <pages> pages 520-534. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1997. </year>
Reference-contexts: Technically, the requires clause is what is needed to make the Z predicate well-defined. That is, this is calculated to make the whole specification protective in the sense of Leavens's and Wing's paper <ref> [8] </ref>. Then we can drop those parts of what would be the postcondition that are implied by this precondition. As a rule of thumb: conjuncts that only involve the pre-state variables go into the precondition. However sometimes more is needed.
Reference: [9] <author> J. Michael Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, NY, </address> <note> second edition, 1992. 69 </note>
Reference-contexts: Since the purpose of writing these traits is to allow users using Z mathematical toolkit in Larch, most of these traits are defined in the same way as they are defined in Spivey's book <ref> [9] </ref>. In addition, we also use the notation for Z in L A T E X for each of our operations in these traits. <p> Take the trait ZSet in Figure 2.1 as an example. It is translated from the definition on page 90 of Spivey's book <ref> [9] </ref>. ZSet defines subset, proper subset, power set, and non-empty power set operations. 7 % @(#)$Id: ZSet.lsl,v 1.13 1997/10/03 02: 12: 45 hzhong Exp $ % Written by Hua Zhong with the help of Dr. Gary T. <p> So, we define using DerivedOrders. Meanwhile we add two more operations: ("sups) and ("psups). P ("pset) is defined in page 56 of Spivey's book <ref> [9] </ref>. There is no Z definition of it. It is described by the sentence: "If S is a set, P S is the set of all subsets of S." From the meaning of this sentence, its Larch definition is given by using the operation "subs. <p> The reason is given as following: suppose we have the following schema: X b= A ^ B The disjunction (_) of two schemas means merging their declarations together, and disjoining their predicate parts (the common variables of the two schemas must have the same type) <ref> [9] </ref>. So, Z b= X _ Y is equal to definition Z b= (A ^ B ) _ : A ^ C . <p> And when B /" C = false, the above two specifications for Z and Larch/C++ is equivalent. The conjunction (^) of two schemas means merging their declarations together, and conjoining their predicate parts (the common variables of the two schemas must have the same type) <ref> [9] </ref>. There is no trivial way to translate Z specification of the form A ^ B when A and B are two schema that are already defined. But if they have the same declarations, you can translate separately and use also in Larch/C++. <p> For the convenience of using the Set for a certain sort X, in the LSL trait ZPowerSet, there is a constant universe. The universe is the set that contains all the element of that sort. An example is taken from Spivey's book <ref> [9, page 97] </ref>, where the function o 9 is defined as following: X ; Y ; Z 8 Q : X $ Y ; R : Y $ Z * Following this, in spiveys book, there is a law id X o 9 P = P , and id X has
References-found: 9

