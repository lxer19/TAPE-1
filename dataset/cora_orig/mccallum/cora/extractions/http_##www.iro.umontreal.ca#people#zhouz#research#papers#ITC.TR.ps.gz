URL: http://www.iro.umontreal.ca/people/zhouz/research/papers/ITC.TR.ps.gz
Refering-URL: http://www.iro.umontreal.ca/people/zhouz/research/project_papers.html
Root-URL: http://www.iro.umontreal.ca
Email: fzhouz,song,tahar,cernyg@iro.umontreal.ca  fcorella@hprpcd.rose.hp.com  langevin@gmd.de  
Title: Formal Verification of the Island Tunnel Controller using Multiway Decision Graphs  
Author: Z. Zhou X. Song S. Tahar E. Cerny F. Corella M. Langevin 
Note: Hewlett-Packard Company, USA,  
Address: Montreal, Canada,  GMD-SET, Germany,  
Affiliation: D'IRO, Universite de  
Abstract: Multiway Decision Graphs (MDGs) have recently been proposed as an efficient representation tool for RTL designs. In this paper we demonstrate the MDG-based formal verification technique on the example of the Island Tunnel Controller. We perform various verification experiments on the ITC example including combinational verification, invariant checking and behavioral equivalence checking. We show how several errors that were present in the original designs have been identified using the counterexample facility of the MDG tools. We also provide comparative experimental results for the verification of a number of properties using two well-known ROBDD-based verification tools SMV (Symbolic Model verifier) and VIS (Verification Interacting with Synthesis). Finally, we study in detail the non-termination problem of the abstract state enumeration and present several solutions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 35(8) </volume> <pages> 677-691, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: 1 Introduction For automated hardware verification, ROBDDs <ref> [1] </ref> have proved to be a powerful tool [4, 10]. However, since they require a Boolean representation of the circuit, the size of an ROBDD grows, sometimes exponentially, with the number of Boolean variables. Therefore, ROBDD-based verification cannot be directly applied to circuits with complex datapaths. <p> a root node labeled A with edges labeled B 1 : : : B n leading to subgraphs G 0 1 : : : G 0 n , and if each G 0 i represents a formula P i , then G represents the formula W Just as Bryant's OBDDs <ref> [1] </ref> must be reduced and ordered, MDGs must also be reduced and ordered, and obey a set of other well-formedness conditions given in [8]. Among other things, these conditions specify the kinds of nodes that may appear in an MDG. <p> The transition relation for the tunnel counter in MDG-HDL looks as follows: component (tunnel counter, table ([ [equz (tc), itc+, mtc+, itc-, mtc-, n tc], <ref> [0, 0, 0, 1, 0, dec (tc)] </ref>, [*, 1, 0, 0, 0, inc (tc)], [*, 0, 1, 0, 0, inc (tc)]jtc])). % 'tc' is the default value. compilation. 4.2 Implementation In [12], the authors gave two implementations for ITC. <p> The transition relation for the tunnel counter in MDG-HDL looks as follows: component (tunnel counter, table ([ [equz (tc), itc+, mtc+, itc-, mtc-, n tc], [0, 0, 0, 1, 0, dec (tc)], <ref> [*, 1, 0, 0, 0, inc (tc)] </ref>, [*, 0, 1, 0, 0, inc (tc)]jtc])). % 'tc' is the default value. compilation. 4.2 Implementation In [12], the authors gave two implementations for ITC. <p> The transition relation for the tunnel counter in MDG-HDL looks as follows: component (tunnel counter, table ([ [equz (tc), itc+, mtc+, itc-, mtc-, n tc], [0, 0, 0, 1, 0, dec (tc)], [*, 1, 0, 0, 0, inc (tc)], <ref> [*, 0, 1, 0, 0, inc (tc)] </ref>jtc])). % 'tc' is the default value. compilation. 4.2 Implementation In [12], the authors gave two implementations for ITC.
Reference: [2] <author> R. E. Bryant and Y. Chen. </author> <title> Verification of arithmetic circuits with binary moment diagrams. </title> <booktitle> In 32nd ACM/IEEE Design Automation Conference (DAC'95). </booktitle> <address> San Francisco, California, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: One is to reduce the complexity of hardware designs by means of data abstraction [6, 15]. Another way is to represent hardware designs at different levels of abstraction, and verify the designs hierarchically. Recently, a number of ROBDD extensions such as BMDs <ref> [2] </ref>, HDDs [7] and K*BMDs [11] have been developed to represent arithmetic functions more compactly than ROBDDs. A number of methods [8, 5, 13], which verify the overall functionality of designs at an abstract level, have also emerged.
Reference: [3] <author> R. K. Brayton et. al. </author> <title> VIS: A system for verification and synthesis. </title> <type> Technical Report UCB/ERL M95, </type> <institution> Electronics Research Laboratory, University of California, Berkeley, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: In addition, we also used two well-known ROBDD-based tools: SMV (V2.4.4) and VIS. SMV [17] is a symbolic model checker for CTL formulas developed by McMillan at Carnegie-Mellon University. We only used the option `-f' (forward search) and the node order was generated automatically by the system. VIS <ref> [3] </ref>, developed at University of California at Berkeley, is an integrated tool for verification, simulation and synthesis of finite state systems. It contains Fair CTL model checker and behavioral equivalence checker for sequential circuits, language emptiness check for Buchi automata, and combinational verification.
Reference: [4] <author> J. R. Burch, E. M. Clarke, D. E. Long, K. L. McMillan and D. L. Dill. </author> <title> Symbolic model checking for sequential circuit verification. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 13(4) </volume> <pages> 401-424, </pages> <month> April </month> <year> 1994. </year> <month> 18 </month>
Reference-contexts: 1 Introduction For automated hardware verification, ROBDDs [1] have proved to be a powerful tool <ref> [4, 10] </ref>. However, since they require a Boolean representation of the circuit, the size of an ROBDD grows, sometimes exponentially, with the number of Boolean variables. Therefore, ROBDD-based verification cannot be directly applied to circuits with complex datapaths. There are two different ways to deal with this problem. <p> The MDG represents the formula: (g (x) = 0 ^ P ) _ (g (x) = 1 ^ P 0 ) _ (g (x) = 3 ^ P 00 ): (3) We developed a set of MDG algorithms for computing disjunction, relational product (Conjunction followed by existential quantification <ref> [4] </ref>) and what we call pruning-by-subsumption. A detailed description of the algorithms can be found in [8]. Note that there is no negation operation for MDGs. A state machine is described using finite sets of input, state and output variables, which are pairwise disjoint. <p> Just as ROBDDs are used to represent set of states, transition and output relations for finite state machines, MDGs are used to compactly encode set of (abstract) states and transition and output relations for abstract state machines. Thus, it is possible to lift the implicit enumeration <ref> [4, 10] </ref> technique from the Boolean level to the abstract level, which is referred to as implicit abstract enumeration [8]. Based on the implicit abstract enumeration technique, we developed a reachability analysis algorithm that verifies whether an invariant holds in all reachable states of an ASM. <p> The paths removed are those subsumed (or covered) by H. PbyS is used for multiple purposes. It provides a form of frontier-set simplification <ref> [4, 10] </ref>.
Reference: [5] <author> J. R. Burch and D. L. Dill. </author> <title> Automatic verification of pipelined microprocessor control. </title> <editor> In: D. L. Dill, editor, </editor> <booktitle> Computer Aided Verification. Lecture Notes in Computer Science 818, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Another way is to represent hardware designs at different levels of abstraction, and verify the designs hierarchically. Recently, a number of ROBDD extensions such as BMDs [2], HDDs [7] and K*BMDs [11] have been developed to represent arithmetic functions more compactly than ROBDDs. A number of methods <ref> [8, 5, 13] </ref>, which verify the overall functionality of designs at an abstract level, have also emerged. Those methods use abstract variables to denote data signals and uninterpreted function symbols to denote data operations, and hence are well suited for the verification of RTL designs. <p> One application of the algorithm is the verification of observational equivalence of synchronous circuits. We also developed a procedure for combinational circuit verification based on the canonicity of MDGs [8]. The MDG operators and the verification algorithms are implemented in the Prolog-based MDG tools [21]. Recently, Burch and Dill <ref> [5, 14] </ref> proposed a validity checking algorithm for processor verification which is also based on the use of abstract sorts and uninterpreted function symbols. A logic expression representing the correctness statement is generated using symbolic simulation. The algorithm is then used to check its validity. <p> A logic expression representing the correctness statement is generated using symbolic simulation. The algorithm is then used to check its validity. With carefully chosen heuristics for avoiding exponential case splitting, the authors verified a subset of a RISC pipeline processor DLX <ref> [5] </ref> and a protocol processor (PP) [14]. Galter [13] presented a similar approach with which he verified the Tamarack-3 microprocessor.
Reference: [6] <author> E. M. Clarke, O. Grumberg, and D. E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> In Proc. 19th ACM Symp. on Principles of Programming Languages. </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: Therefore, ROBDD-based verification cannot be directly applied to circuits with complex datapaths. There are two different ways to deal with this problem. One is to reduce the complexity of hardware designs by means of data abstraction <ref> [6, 15] </ref>. Another way is to represent hardware designs at different levels of abstraction, and verify the designs hierarchically. Recently, a number of ROBDD extensions such as BMDs [2], HDDs [7] and K*BMDs [11] have been developed to represent arithmetic functions more compactly than ROBDDs. <p> On the other hand, only the MDG tools can verify a parameterized implementation having n bits, and it does so quite efficiently in time independent of the datapath width. It may be argued that the data abstraction method <ref> [6, 15] </ref> is sufficient to imply the correctness of this ITC example, i.e., we reduce n to a small number encoded by a few bits, e.g., 2 bits (4), 4 bits (16), etc. Yet in general, the equivalence of the reduced circuit against the original one is not verified mechanically.
Reference: [7] <author> E. Clarke, M. Fujita and X. Zhao. </author> <title> Hybrid decision diagrams. </title> <booktitle> In Proc. IEEE International Conference on Computer-Aided Design (ICCAD'95). </booktitle> <address> San Jose, California, USA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: One is to reduce the complexity of hardware designs by means of data abstraction [6, 15]. Another way is to represent hardware designs at different levels of abstraction, and verify the designs hierarchically. Recently, a number of ROBDD extensions such as BMDs [2], HDDs <ref> [7] </ref> and K*BMDs [11] have been developed to represent arithmetic functions more compactly than ROBDDs. A number of methods [8, 5, 13], which verify the overall functionality of designs at an abstract level, have also emerged.
Reference: [8] <author> F. Corella, Z. Zhou, X. Song, M. Langevin and E. Cerny. </author> <title> Multiway decision graphs for automated hardware verification. </title> <note> To appear in the journal Formal Methods in System Design. Preliminary version published as IBM technical report RC19676, </note> <month> July </month> <year> 1994. </year>
Reference-contexts: Another way is to represent hardware designs at different levels of abstraction, and verify the designs hierarchically. Recently, a number of ROBDD extensions such as BMDs [2], HDDs [7] and K*BMDs [11] have been developed to represent arithmetic functions more compactly than ROBDDs. A number of methods <ref> [8, 5, 13] </ref>, which verify the overall functionality of designs at an abstract level, have also emerged. Those methods use abstract variables to denote data signals and uninterpreted function symbols to denote data operations, and hence are well suited for the verification of RTL designs. <p> Those methods use abstract variables to denote data signals and uninterpreted function symbols to denote data operations, and hence are well suited for the verification of RTL designs. We have proposed a new class of decision graphs, called Multiway Decision Graphs (MDGs) <ref> [8] </ref>, that comprises, but is much broader than, the class of ROBDDs. The underlying logic of MDGs is a subset of many-sorted first-order logic with a distinction between concrete and abstract sorts. A concrete sort has an enumeration while an abstract sort does not. <p> MDGs are thus much more compact than ROBDDs for designs containing a datapath. In <ref> [8] </ref> we described a basic set of MDG operators and a reachability analysis algorithm based on abstract implicit enumeration. This algorithm verifies whether an invariant holds in all reachable states of an abstract state machine [9]. One application of the algorithm is the verification of observational equivalence of synchronous circuits. <p> This algorithm verifies whether an invariant holds in all reachable states of an abstract state machine [9]. One application of the algorithm is the verification of observational equivalence of synchronous circuits. We also developed a procedure for combinational circuit verification based on the canonicity of MDGs <ref> [8] </ref>. The MDG operators and the verification algorithms are implemented in the Prolog-based MDG tools [21]. Recently, Burch and Dill [5, 14] proposed a validity checking algorithm for processor verification which is also based on the use of abstract sorts and uninterpreted function symbols. <p> : G 0 n , and if each G 0 i represents a formula P i , then G represents the formula W Just as Bryant's OBDDs [1] must be reduced and ordered, MDGs must also be reduced and ordered, and obey a set of other well-formedness conditions given in <ref> [8] </ref>. Among other things, these conditions specify the kinds of nodes that may appear in an MDG. <p> A detailed description of the algorithms can be found in <ref> [8] </ref>. Note that there is no negation operation for MDGs. A state machine is described using finite sets of input, state and output variables, which are pairwise disjoint. The behavior of a state machine is defined by its transition and output relations, together with a set of initial states. <p> Thus, it is possible to lift the implicit enumeration [4, 10] technique from the Boolean level to the abstract level, which is referred to as implicit abstract enumeration <ref> [8] </ref>. Based on the implicit abstract enumeration technique, we developed a reachability analysis algorithm that verifies whether an invariant holds in all reachable states of an ASM. One of its variations is the verification of observational equivalence of two ASMs. <p> This is very helpful for identifying design errors. In addition to sequential verification, we also have an equivalence checking procedure for combinational circuits that takes advantage of the canonicity of MDGs <ref> [8] </ref>. The above MDG operators and verification applications are packaged as MDG tools [21]. 3 The Island Tunnel Controller (ITC) The Island Tunnel Controller (ITC) example was originally introduced by Fisler and Johnson [12]. <p> P3: The island counter is never signaled to increment and decrement simultaneously. AG ( ! ((ic = 1) & (ic+ = 1)) ). The invariant checking is based on reachability analysis of state machines. However, the reachability analysis procedure may not terminate in general <ref> [8] </ref>, which is the case for the ITC example. To deal with the problem, we developed a heuristic state generalization method which is to be explained in detail in Section 6 . <p> The reachability analysis algorithm is based on abstract implicit enumeration <ref> [8] </ref> where sets of states as well as transition and output relations are represented using MDGs. Starting from the initial set of states, the set of states reached in one transition is computed by the relational product operation. <p> The paths removed are those subsumed (or covered) by H. PbyS is used for multiple purposes. It provides a form of frontier-set simplification [4, 10]. It is also used for detecting termination and for checking that an invariant is satisfied during reachability analysis <ref> [8] </ref>. 13 6.1 Non-termination problem and termination with state general- ization 6.1.1 Review An abstract state machine may have an infinite member of states due to the abstract variables and the uninterpreted nature of function symbols. Thus a least fixed point may not be reached in state enumeration. In [8], the <p> analysis <ref> [8] </ref>. 13 6.1 Non-termination problem and termination with state general- ization 6.1.1 Review An abstract state machine may have an infinite member of states due to the abstract variables and the uninterpreted nature of function symbols. Thus a least fixed point may not be reached in state enumeration. In [8], the non-termination problem is explained and a solution is given to a class of interesting problems known as processor-like circuits by generalizing the initial state (i.e., by replacing abstract constants with abstract variables as initial values of some of the registers).
Reference: [9] <author> F. Corella, M. Langevin, E. Cerny, Z. Zhou and X. Song. </author> <title> State enumeration with abstract descriptions of state machines. </title> <booktitle> In Proc. IFIP WG 10.5 Advanced Research Working Conference on Correct Hardware Design and Verification Methods (Charme'95). </booktitle> <address> Frankfurt, Germany, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: MDGs are thus much more compact than ROBDDs for designs containing a datapath. In [8] we described a basic set of MDG operators and a reachability analysis algorithm based on abstract implicit enumeration. This algorithm verifies whether an invariant holds in all reachable states of an abstract state machine <ref> [9] </ref>. One application of the algorithm is the verification of observational equivalence of synchronous circuits. We also developed a procedure for combinational circuit verification based on the canonicity of MDGs [8]. The MDG operators and the verification algorithms are implemented in the Prolog-based MDG tools [21]. <p> The behavior of a state machine is defined by its transition and output relations, together with a set of initial states. An abstract description of the state machine, called abstract state machine (ASM) <ref> [9] </ref>, is obtained by letting some data input, state or output variables be of an abstract sort, and the datapath operations be uninterpreted function symbols. <p> The island counter operates in a similar way, except that the increment and decrement signals are ic+ and ic, respectively. 4 Hardware description Due to the generic constraint in the ITC, we model the state transition diagrams in Figure 3 as Abstract State Machines (ASMs) <ref> [9] </ref> rather than Finite State Machines (FSMs). The ASM 1 Figure 3 (a), (b) and (c) are taken from [12] with the exception of replacing 16 by n in the original diagrams. 2 We use itc+ and mtc+ instead of tc+ in [12].
Reference: [10] <author> O. Coudert, C. Berthet and J. C. Madre. </author> <title> Verification of synchronous sequential machines based on symbolic execution. </title> <editor> In J. Sifakis, editor, </editor> <title> Automatic Verification Methods for Finite State Systems. </title> <booktitle> Lecture Notes in Computer Science 407, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction For automated hardware verification, ROBDDs [1] have proved to be a powerful tool <ref> [4, 10] </ref>. However, since they require a Boolean representation of the circuit, the size of an ROBDD grows, sometimes exponentially, with the number of Boolean variables. Therefore, ROBDD-based verification cannot be directly applied to circuits with complex datapaths. There are two different ways to deal with this problem. <p> Just as ROBDDs are used to represent set of states, transition and output relations for finite state machines, MDGs are used to compactly encode set of (abstract) states and transition and output relations for abstract state machines. Thus, it is possible to lift the implicit enumeration <ref> [4, 10] </ref> technique from the Boolean level to the abstract level, which is referred to as implicit abstract enumeration [8]. Based on the implicit abstract enumeration technique, we developed a reachability analysis algorithm that verifies whether an invariant holds in all reachable states of an ASM. <p> The paths removed are those subsumed (or covered) by H. PbyS is used for multiple purposes. It provides a form of frontier-set simplification <ref> [4, 10] </ref>.
Reference: [11] <author> R. Drechsler, B. Becker and S. Ruppertz. K*BMDs: </author> <title> a new data structure for verification. </title> <booktitle> In Proc. IFIP WG 10.5 Advanced Research Working Conference on Correct Hardware Design and Verification Methods (Charme'95). </booktitle> <address> Frankfurt, Germany, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: One is to reduce the complexity of hardware designs by means of data abstraction [6, 15]. Another way is to represent hardware designs at different levels of abstraction, and verify the designs hierarchically. Recently, a number of ROBDD extensions such as BMDs [2], HDDs [7] and K*BMDs <ref> [11] </ref> have been developed to represent arithmetic functions more compactly than ROBDDs. A number of methods [8, 5, 13], which verify the overall functionality of designs at an abstract level, have also emerged.
Reference: [12] <author> K. Fisler and S. Johnson. </author> <title> Integrating design and verification environments through a logic supporting hardware diagrams. </title> <booktitle> In Proc. IFIP Conference on Hardware Description Languages and their Applications (CHDL'95). Chiba, </booktitle> <address> Japan, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: The method is interesting and we conjecture that it could be incorporated into other more general methods such as those based on MDGs. In this paper we present a case study of MDG-based formal hardware verification using the Island Tunnel Controller (ITC) <ref> [12] </ref> as an example. This example was originally used to illustrate the notation of a heterogeneous logic system supporting diagrams as logic entities. However, no verification experiments were performed. <p> In Section 4 , we describe the hardware modeling of the ITC at an abstract level. In Section 5, we explain the verification of the ITC example including combinational verification, invariant checking and behavioral equivalence checking. We show how we identify several errors in the original designs of <ref> [12] </ref> using the counterexample facility in the MDG tools. We also present experimental results, including a comparison with results obtained using SMV and VIS. Section 6 studies in detail the non-termination problem of the abstract state enumeration and present several solutions. <p> The above MDG operators and verification applications are packaged as MDG tools [21]. 3 The Island Tunnel Controller (ITC) The Island Tunnel Controller (ITC) example was originally introduced by Fisler and Johnson <ref> [12] </ref>. There is a one lane tunnel connecting the mainland to a small island, as shown in Figure 2 (a). At each end of the tunnel, there is a traffic light. <p> In <ref> [12] </ref>, an additional constraint is imposed: "at most sixteen cars may be on the island at any time". The number "sixteen" can be taken as a parameter and it can be any natural number. <p> Thus the constraint may be read: "at most n (n 0) cars may be on the island at any time". For ROBDD-based verification methods, their performance depends on the particular instance of n, as we shall see in Section 5.3 . Fisler and Johnson <ref> [12] </ref> proposed a specification of ITC using three communicating controllers and two counters shown in Figure 2 (b). Their state transition diagrams are shown in Figure 3 1 . The island light controller (ILC) (Figure 3 (a)) has four states: green, entering, red and exiting. <p> The ASM 1 Figure 3 (a), (b) and (c) are taken from <ref> [12] </ref> with the exception of replacing 16 by n in the original diagrams. 2 We use itc+ and mtc+ instead of tc+ in [12]. Similarly for tc. 5 model represented by MDGs (referred to as MDG-ASM) is obtained by compiling its MDG-HDL description (a Prolog-style HDL). <p> The ASM 1 Figure 3 (a), (b) and (c) are taken from <ref> [12] </ref> with the exception of replacing 16 by n in the original diagrams. 2 We use itc+ and mtc+ instead of tc+ in [12]. Similarly for tc. 5 model represented by MDGs (referred to as MDG-ASM) is obtained by compiling its MDG-HDL description (a Prolog-style HDL). MDG-HDL supports structural descriptions, behavioral ASM descriptions, or a mixture of structural and behavioral descriptions. <p> counter in MDG-HDL looks as follows: component (tunnel counter, table ([ [equz (tc), itc+, mtc+, itc-, mtc-, n tc], [0, 0, 0, 1, 0, dec (tc)], [*, 1, 0, 0, 0, inc (tc)], [*, 0, 1, 0, 0, inc (tc)]jtc])). % 'tc' is the default value. compilation. 4.2 Implementation In <ref> [12] </ref>, the authors gave two implementations for ITC. Observing that the MLC (Figure 3 (b)) is quite similar to ILC (Figure 3 (c)), the implementations of MLC can be derived from that of ILC by small modifications. <p> Figure 5 (b) is a simplified implementation I 2 derived from that in Figure 5 (a). The circuit diagrams excluding the portion in the dashed frame and its related connections are exactly the same as the ILC implementations in <ref> [12] </ref>. The additional 7 circuitry in the dashed frame implements the next-state function associated with the condition "ic &lt; n" (Figure 3 (b)), i.e., in state green, if the condition is not satisfied, the MLC transits to red. <p> Column Mem is the memory allocated in megabytes. Column #Nodes is the number of total MDG (or ROBDD) nodes generated. 5.1 Equivalence checking of MLC implementations against their specification We first compared the two ILC implementations given in <ref> [12] </ref> against their behavioral specification. We found and corrected the design errors before further experiments. All these errors 8 were confirmed by the original designer. In the following, however, we verify, for illustration purposes, the MLC implementations including the errors. <p> Table 3 shows the invariant checking results of the conjunction of P1, P2 and P3 on the ITC specifications. Properties Time (Sec) Mem (MB) #Nodes P1, P2, P3 55 2.7 4329 Table 3: Invariant checking using the ASM model 3 Fisler and Johnson <ref> [12] </ref> proposed a set of properties that the ITC design should satisfy. Currently, we only consider the verification of invariants. 11 5.4 Comparative results using FSM model Besides the ASM-based verification experiments using MDGs, we also verified the above example invariants (P1, P2 and P3) using FSM-based methods.
Reference: [13] <author> D. Galter. </author> <title> Symbolic verification of instruction-set processors. </title> <institution> Master of Mathematics thesis, Dept. of Computer Science, University of Waterloo, </institution> <year> 1994. </year>
Reference-contexts: Another way is to represent hardware designs at different levels of abstraction, and verify the designs hierarchically. Recently, a number of ROBDD extensions such as BMDs [2], HDDs [7] and K*BMDs [11] have been developed to represent arithmetic functions more compactly than ROBDDs. A number of methods <ref> [8, 5, 13] </ref>, which verify the overall functionality of designs at an abstract level, have also emerged. Those methods use abstract variables to denote data signals and uninterpreted function symbols to denote data operations, and hence are well suited for the verification of RTL designs. <p> A logic expression representing the correctness statement is generated using symbolic simulation. The algorithm is then used to check its validity. With carefully chosen heuristics for avoiding exponential case splitting, the authors verified a subset of a RISC pipeline processor DLX [5] and a protocol processor (PP) [14]. Galter <ref> [13] </ref> presented a similar approach with which he verified the Tamarack-3 microprocessor. These methods, however, are not applicable to state exploration-based verification, such as model checking or behavioral equivalence checking, while MDGs provide a tool for both validity checking and verification based on state-space exploration.
Reference: [14] <author> R. B. Jones and D. L. Dill. </author> <title> Efficient validity checking for processor verification. </title> <booktitle> In Proc. IEEE International Conference on Computer-Aided Design (ICCAD'95). </booktitle> <address> San Jose, California, USA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: One application of the algorithm is the verification of observational equivalence of synchronous circuits. We also developed a procedure for combinational circuit verification based on the canonicity of MDGs [8]. The MDG operators and the verification algorithms are implemented in the Prolog-based MDG tools [21]. Recently, Burch and Dill <ref> [5, 14] </ref> proposed a validity checking algorithm for processor verification which is also based on the use of abstract sorts and uninterpreted function symbols. A logic expression representing the correctness statement is generated using symbolic simulation. The algorithm is then used to check its validity. <p> A logic expression representing the correctness statement is generated using symbolic simulation. The algorithm is then used to check its validity. With carefully chosen heuristics for avoiding exponential case splitting, the authors verified a subset of a RISC pipeline processor DLX [5] and a protocol processor (PP) <ref> [14] </ref>. Galter [13] presented a similar approach with which he verified the Tamarack-3 microprocessor. These methods, however, are not applicable to state exploration-based verification, such as model checking or behavioral equivalence checking, while MDGs provide a tool for both validity checking and verification based on state-space exploration.
Reference: [15] <author> D. E. </author> <title> Long. Model Checking, Abstraction, and Compositional Verification. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1993. </year>
Reference-contexts: Therefore, ROBDD-based verification cannot be directly applied to circuits with complex datapaths. There are two different ways to deal with this problem. One is to reduce the complexity of hardware designs by means of data abstraction <ref> [6, 15] </ref>. Another way is to represent hardware designs at different levels of abstraction, and verify the designs hierarchically. Recently, a number of ROBDD extensions such as BMDs [2], HDDs [7] and K*BMDs [11] have been developed to represent arithmetic functions more compactly than ROBDDs. <p> On the other hand, only the MDG tools can verify a parameterized implementation having n bits, and it does so quite efficiently in time independent of the datapath width. It may be argued that the data abstraction method <ref> [6, 15] </ref> is sufficient to imply the correctness of this ITC example, i.e., we reduce n to a small number encoded by a few bits, e.g., 2 bits (4), 4 bits (16), etc. Yet in general, the equivalence of the reduced circuit against the original one is not verified mechanically.
Reference: [16] <author> M. Langevin, S. Tahar, Z. Zhou, X. Song and E. Cerny. </author> <title> Behavioral V verification of an ATM switch fabric using implicit abstract state enumeration. </title> <type> Technical Report No. </type> <institution> IRO-1021 , IRO Department, University of Montreal, </institution> <address> Montreal, Quebec, Canada, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: Also, it is not always obvious to provide an appropriate data abstract function. Moreover, such data abstraction is not always possible. One example is the 4fi4 Fairisle ATM switch fabric recently verified using MDGs <ref> [16, 18] </ref>. The switch fabric routes incoming cells a finite stream of words, from input ports to output ports. The first word of the stream contains control information (4 bits) which makes routing decisions.
Reference: [17] <author> K. L. McMillan. </author> <title> Symbolic model checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, Massachusetts, </address> <year> 1993. </year>
Reference-contexts: In addition, we also used two well-known ROBDD-based tools: SMV (V2.4.4) and VIS. SMV <ref> [17] </ref> is a symbolic model checker for CTL formulas developed by McMillan at Carnegie-Mellon University. We only used the option `-f' (forward search) and the node order was generated automatically by the system.
Reference: [18] <author> S. Tahar, Z. Zhou, X. Song, E. Cerny and M. Langevin. </author> <title> Formal verification of an ATM switch fabric using multiway decision graphs. </title> <booktitle> In Proc. IEEE Sixth Great Lakes Symposium on VLSI. </booktitle> <address> Ames, Iowa, USA, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: Also, it is not always obvious to provide an appropriate data abstract function. Moreover, such data abstraction is not always possible. One example is the 4fi4 Fairisle ATM switch fabric recently verified using MDGs <ref> [16, 18] </ref>. The switch fabric routes incoming cells a finite stream of words, from input ports to output ports. The first word of the stream contains control information (4 bits) which makes routing decisions.
Reference: [19] <author> Z. Zhou and W. Burleson. </author> <title> A canonical representation of algebraic expressions in high-level synthesis. </title> <type> Technical report TR-94-CSE-9, </type> <institution> University of Massachusetts at Amherst, </institution> <month> October </month> <year> 1994. </year> <month> 19 </month>
Reference-contexts: Galter [13] presented a similar approach with which he verified the Tamarack-3 microprocessor. These methods, however, are not applicable to state exploration-based verification, such as model checking or behavioral equivalence checking, while MDGs provide a tool for both validity checking and verification based on state-space exploration. Zhou and Burleson <ref> [19] </ref> proposed another kind of diagrams: ConT rast (Conditional Term Rewriting on Attribute Syntax Trees). ConTrast uses attribute grammars (for storing semantic information) to represent arithmetic expressions at an abstract level, and conditional term rewriting to translate an expression into its canonical form.
Reference: [20] <author> Z. Zhou, X. Song, F. Corella, E. Cerny, and M. Langevin. </author> <title> Description and verification of RTL designs using Multiway Decision Graphs. </title> <booktitle> In Proc. IFIP Conference on Hardware Description Languages and their Applications (CHDL'95). Chiba, </booktitle> <address> Japan, </address> <month> August </month> <year> 1995. </year>
Reference: [21] <author> Z. Zhou, X. Song, F. Corella, M. Langevin, E. Cerny and S. Tahar. </author> <title> MDG tools for the verification of RTL designs. </title> <booktitle> To appear in Proc. 8th International Conference on Computer-Aided Verification (CAV'96). </booktitle> <address> New Brunswick, New Jersey, USA, </address> <month> July </month> <year> 1996. </year> <month> 20 </month>
Reference-contexts: One application of the algorithm is the verification of observational equivalence of synchronous circuits. We also developed a procedure for combinational circuit verification based on the canonicity of MDGs [8]. The MDG operators and the verification algorithms are implemented in the Prolog-based MDG tools <ref> [21] </ref>. Recently, Burch and Dill [5, 14] proposed a validity checking algorithm for processor verification which is also based on the use of abstract sorts and uninterpreted function symbols. A logic expression representing the correctness statement is generated using symbolic simulation. The algorithm is then used to check its validity. <p> This is very helpful for identifying design errors. In addition to sequential verification, we also have an equivalence checking procedure for combinational circuits that takes advantage of the canonicity of MDGs [8]. The above MDG operators and verification applications are packaged as MDG tools <ref> [21] </ref>. 3 The Island Tunnel Controller (ITC) The Island Tunnel Controller (ITC) example was originally introduced by Fisler and Johnson [12]. There is a one lane tunnel connecting the mainland to a small island, as shown in Figure 2 (a).
References-found: 21

