URL: http://www.tns.lcs.mit.edu/~djw/library/rt_plugins_sigcomm98.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/
Root-URL: 
Note: 1. ABSTRACT  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> Adiseshu, H., and Parulkar, G., </author> <title> SSP: A State Setup Protocol, </title> <note> to be published </note>
Reference-contexts: In most cases, the plugin manager is invoked from a configuration script during system initialization, but it can also be used to manually issue commands to various plugins. We show an example of how the Plugin Manager is used in Section 6. Daemons: The RSVP [31], SSP <ref> [1] </ref> (a simplified version of RSVP), and route daemon are linked against the Router Plugin Library to perform their respective tasks. We implemented an SSP daemon for our system, and are cur rently in the process of porting an RSVP implementation.
Reference: [2] <author> Atkinson, R., </author> <title> Security Architecture for the Internet Protocol, </title> <type> RFC 1825, </type> <month> August </month> <year> 1995 </year>
Reference-contexts: Implementations of plugins for two state-of-the-art packet schedulers: Deficit Round Robin (DRR, [23]) for fair queuing, and the Hierarchical Fair Service Curves (H-FSC, [27]) scheduler for class-based packet schedul ing; Implementation of plugins for IP security <ref> [2] </ref>. There are a few commercial attempts that we are aware of which follow similar lines. <p> They are usually invoked only for the first packet of a flow. Nonetheless, many flows may be very short-lived (just one or a few packets), so it is important to have an efficient filter table implementation. Several generic packet filtering algorithms have been proposed in the literature <ref> [2, 10, 20] </ref>. These algorithms are very powerful and flexible when they are used to look into arbitrary packet fields. They usually come with a language which allows for the specification of filters in terms of individual bytes in the packet header, and the values they should be checked against. <p> To specify a simple filter to match a given TCP connection, half a page of filter specification written in the filters language might be required (see <ref> [2] </ref> for an example of a TCP filter specification). Besides complexity, all except DPF [10] typically provide performance which is worse than that of tailor-made packet classifiers optimized for a certain fixed pattern of packet header.
Reference: [3] <author> Bennett, J.C.R. and Zhang, H., </author> <title> Hierarchical Packet Fair Queueing Algorithms, </title> <booktitle> In Proceedings of SIGCOMM'96, </booktitle> <month> August </month> <year> 1996. </year>
Reference: [4] <author> Bennett, J.C.R., and Zhang, H., WF2Q: </author> <title> Worst-case Fair Weighted Fair Queueing, </title> <booktitle> In Proceedings of INFOCOM'96, </booktitle> <month> March </month> <year> 1996 </year>
Reference: [5] <author> Cho, K., </author> <title> "A Framework for Alternate Queueing", </title> <booktitle> In Proceedings of USENIX 1998, </booktitle> <month> June </month> <year> 1998 </year>
Reference-contexts: Our proposed framework has been implemented in the NetBSD UNIX kernel. This platform was selected because of its portability (all major hardware platforms are supported), efficiency, and extensive documentation. In addition, we found state-of-the-art implementations on this platform for IPv6 [13] and packet schedulers <ref> [27, 5] </ref> that could be integrated into our framework. We envision several applications for our framework. First, our architecture fits very well into the operating system of small and midsized routers. <p> The original implementation comes from the WFQ module found in the ALTQ <ref> [5] </ref> software distribution. The ALTQ WFQ modules implement fair queueing for a limited number of flows, which it distributes over a fixed number of queues. ALTQ came with a basic packet classifier which mapped flows to these queues by hashing on fields in the packet header.
Reference: [6] <author> Cisco Corporation, </author> <title> web pages on IOS, </title> <address> http://www.cisco.com/public/ sw-center/sw-ios.shtml </address>
Reference-contexts: There are a few commercial attempts that we are aware of which follow similar lines. The latest versions of Ciscos Internet OS (IOS, <ref> [6] </ref>) claims to fulfill some of the requirements, but since its a commercial operating system, there is no easy access for the research community and these claims are not verifiable.
Reference: [7] <author> Decasper, D., et. al., </author> <title> Router Plugins", </title> <institution> Washington University Tech Report WUCS-98-08, </institution> <month> February </month> <year> 1998 </year>
Reference-contexts: It comes with router components implementing simple QoS support. Since the whole operating system is implemented from scratch, most of the provided functionality is oversimplified and does not provide the large feature set that is found in mature implementations. We discuss these related approaches in more detail in <ref> [7] </ref>. In Section 3, we describe our architecture and explain how it achieves modularity, extensibility, and flexibility while maintaining high-performance. In Section 4, we describe the implementation of a module called the Plugin Control Unit (PCU), which is responsible for all control path interactions with plugins. <p> Due to space limitations, descriptions of these and other optimizations are not included here. We have also omitted a discussion of filter ambiguities and their resolution. The interested reader is referred to <ref> [7] </ref> for more details. Our DAG-based lookup data structure is an example of a more general data structure which we call set-pruning tries. Cecilia Tries [29] are another example of set-pruning tries. <p> From a practical standpoint, our current implementation does not exploit hardware properties such as the machines cache subsystem architecture or main memory quirks to improve performance. Also, if there are many ambiguous filters (see <ref> [7] </ref>), the memory requirements of our algorithm can be excessive. More advanced techniques such as grid-of-tries [26] can provide better memory utilization without sacrificing performance, but work only in the special case of two-dimensional filters.
Reference: [8] <author> Deering, S., Hinden, R., </author> <title> Internet Protocol, </title> <note> Version 6 (IPv6), Specifi cation, RFC 1883, </note> <month> December </month> <year> 1995 </year>
Reference-contexts: Modern routers, however, incorporate several new services: Integrated/differentiated Services Enhanced routing functionality (level 3 and level 4 rout ing and switching, QoS routing, multicast) Security algorithms (e.g. to implement virtual private networks (VPN)) Enhancements to existing protocols (e.g. Random Early Detection (RED)) New core protocols (e.g. IPv6 <ref> [8] </ref>) Extended Integrated Services Router (EISR) with that of a conventional best-effort router. A typical EISR kernel features the following important additional components: a packet scheduler, a packet classifier, security mechanisms, and QoS-based routing/Level 4 switching.
Reference: [9] <author> Demers, Keshav, Shenker, </author> <title> "Analysis and Simulation of a Fair Queue ing Algorithm", </title> <booktitle> In Proceedings of SIGCOMM89, </booktitle> <month> August </month> <year> 1989 </year>
Reference: [10] <author> Engler, D., Kaashoek, M., DPF: </author> <title> Fast, Flexible Message Demulti-plexing using Dynamic Code Generation, </title> <booktitle> In Proceedings of SIG COMM96, </booktitle> <month> August </month> <year> 1996 </year>
Reference-contexts: They are usually invoked only for the first packet of a flow. Nonetheless, many flows may be very short-lived (just one or a few packets), so it is important to have an efficient filter table implementation. Several generic packet filtering algorithms have been proposed in the literature <ref> [2, 10, 20] </ref>. These algorithms are very powerful and flexible when they are used to look into arbitrary packet fields. They usually come with a language which allows for the specification of filters in terms of individual bytes in the packet header, and the values they should be checked against. <p> To specify a simple filter to match a given TCP connection, half a page of filter specification written in the filters language might be required (see [2] for an example of a TCP filter specification). Besides complexity, all except DPF <ref> [10] </ref> typically provide performance which is worse than that of tailor-made packet classifiers optimized for a certain fixed pattern of packet header.
Reference: [11] <author> Floyd, S., Jacobson, V., </author> <title> Linksharing and Resource Management Models for Packet Networks, </title> <journal> In IEEE/ACM Transactions on Net working, </journal> <volume> Vol. 3 No. 4, </volume> <month> August </month> <year> 1995 </year>
Reference-contexts: This kind of enforcement can be done either on a per-application flow basis, or on a generalized class-based approach (e.g. CBQ <ref> [11] </ref>). Our implementation supports both models efficiently. Our framework is also very well suited to Application Layer Gateways (ALGs), and to security devices like Firewalls. <p> These two plugins are complementary in the sense that DRR is particularly useful to implement fair queuing among best-effort flows, whereas H-FSC implements hierarchical scheduling similar to Class Based Queuing (CBQ, <ref> [11] </ref>) with several advantages over CBQ. We believe that H-FSC represents the state-of-the-art in packet scheduling. One of its main advantages is the decoupling of delay and bandwidth allocation, which is very useful if both real-time and hierarchical linksharing services are required concurrently.
Reference: [12] <author> Hutchinson, C., Peterson, P., </author> <title> The x-Kernel: An architecture for implementing network protocols, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> January </month> <year> 1991 </year>
Reference-contexts: The API does not provide an interface to the routing and forwarding engines, and the platform offers no integrated services components. A few research projects attempt to achieve some of the goals mentioned above <ref> [12, 20, 21] </ref>. Most of them are focused on the implementation of modular endsystem networking subsystems instead of routing architectures. Scout from the University of Arizona is a particularly interesting project based on the x-kernel that implements an operating system targeted at network appliances (including routers).
Reference: [13] <institution> INRIA ftp site for IPv6 source code. ftp://ftp.inria.fr/network/ipv6 </institution>
Reference-contexts: Our proposed framework has been implemented in the NetBSD UNIX kernel. This platform was selected because of its portability (all major hardware platforms are supported), efficiency, and extensive documentation. In addition, we found state-of-the-art implementations on this platform for IPv6 <ref> [13] </ref> and packet schedulers [27, 5] that could be integrated into our framework. We envision several applications for our framework. First, our architecture fits very well into the operating system of small and midsized routers.
Reference: [14] <author> Intel Corporation, </author> <title> web pages on VTUNE, </title> <address> http://developer.intel.com/ design/perftool/vtune/index.htm, </address> <year> 1997 </year>
Reference-contexts: PERFORMANCE In this section, we elaborate on the performance of our architecture and implementation. We did all of our measurements on a Pentium Pro with 512 KB Level 2 cache running at 233 MHz. For our measurements, we used the VTUNE <ref> [14] </ref> tool to obtain dynamic clock cycle counts. Further we used special functions to access the Pentiums processor clock register (tsc) which is incremented by one every cycle and allows for very accurate measurements.
Reference: [15] <author> Lampson, B., Srinivasan, V., Varghese, G., </author> <title> IP Lookups using Multi way and Multicolumn Search, </title> <booktitle> In Proceedings of INFOCOM98, </booktitle> <month> April </month> <year> 1998 </year>
Reference-contexts: Recently, several new BMP algorithms have been proposed to replace the PATRICIA [24] algorithm found in many of todays BSD-based routing engines: Binary search on prefix lengths (BSPL, [27]), Multiway and Multicolumn search <ref> [15] </ref>, and Controlled Prefix Expansion [25], to name just a few. Most of these schemes are optimized for one lookup table which they usually try to fit into the processors cache.
Reference: [16] <author> Lin, S., McKeown, N., </author> <title> A Simulation Study of IP Switching, </title> <booktitle> In Pro ceedings of SIGCOMM97, </booktitle> <month> September </month> <year> 1997 </year>
Reference-contexts: It requires 17 cycles or 73 ns to compute, and turned out to result in a reasonably even distribution of individual flows over the hash table. We simulated hashing in user space to get a better idea of how well our hash function would perform. From <ref> [16] </ref> we found that a large backbone router (FIXWEST2) has to manage an average of 22000 active flows concurrently. We set the hash table size to 32768 and used larger numbers of flows to show how hash table overload affected performance.
Reference: [17] <editor> Linux kernel packet filter implementation, </editor> <address> http://wafu.netgate.net/ linux/index.html </address>
Reference-contexts: Cecilia Tries [29] are another example of set-pruning tries. The DAG-based algorithm is simple and easy to implement (our implementation requires approximately 800 lines of C code), and it is much faster than the typical filter algorithms used in existing implementations <ref> [17, 22] </ref>. While most of these existing techniques require O (n) time, n being the number of filters, our solution when used with a state-ofthe-art best matching prefix algorithm (e.g., controlled prefix expansion [25]), is more or less independent of the number of filters.
Reference: [18] <author> Microsoft Corporation, </author> <title> Update to Routing and Remote Access Ser vice for Windows NT Server 4.0, Review and Evaluation Guide, </title> <month> March </month> <year> 1997 </year>
Reference-contexts: Microsofts Routing and Remote Access Service for Windows NT (RRAS, previously referred to as Steelhead <ref> [18, 19] </ref>) is an attempt to implement router functionality under Windows NT. RRAS exports an API and allows third party modules to implement routing protocols like OSPF and SNMP agents in user space.
Reference: [19] <institution> Microsoft Corporation, </institution> <note> web pages on RRAS SDK, http://premium.microsoft.com/msdn/library/sdkdoc/pdnds/ remacces_8085.htm </note>
Reference-contexts: Microsofts Routing and Remote Access Service for Windows NT (RRAS, previously referred to as Steelhead <ref> [18, 19] </ref>) is an attempt to implement router functionality under Windows NT. RRAS exports an API and allows third party modules to implement routing protocols like OSPF and SNMP agents in user space.
Reference: [20] <author> Mogul, J.C., Rashid, R.F., Accetta, M.J., </author> <title> The packet filter: An effi cient mechanism for user-level network code, </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, Novem ber 1987 </booktitle>
Reference-contexts: The API does not provide an interface to the routing and forwarding engines, and the platform offers no integrated services components. A few research projects attempt to achieve some of the goals mentioned above <ref> [12, 20, 21] </ref>. Most of them are focused on the implementation of modular endsystem networking subsystems instead of routing architectures. Scout from the University of Arizona is a particularly interesting project based on the x-kernel that implements an operating system targeted at network appliances (including routers). <p> They are usually invoked only for the first packet of a flow. Nonetheless, many flows may be very short-lived (just one or a few packets), so it is important to have an efficient filter table implementation. Several generic packet filtering algorithms have been proposed in the literature <ref> [2, 10, 20] </ref>. These algorithms are very powerful and flexible when they are used to look into arbitrary packet fields. They usually come with a language which allows for the specification of filters in terms of individual bytes in the packet header, and the values they should be checked against.
Reference: [21] <author> Mosberger, D., </author> <title> Scout: A Path-based Operating System, </title> <type> PhD Dissertation, </type> <institution> Department of Computer Science, University of Arizona, </institution> <month> July </month> <year> 1997 </year>
Reference-contexts: The API does not provide an interface to the routing and forwarding engines, and the platform offers no integrated services components. A few research projects attempt to achieve some of the goals mentioned above <ref> [12, 20, 21] </ref>. Most of them are focused on the implementation of modular endsystem networking subsystems instead of routing architectures. Scout from the University of Arizona is a particularly interesting project based on the x-kernel that implements an operating system targeted at network appliances (including routers).
Reference: [22] <author> Reed, D., </author> <title> IP Filter, </title> <address> http://www.cyber.com.au/users/darrenr/ </address>
Reference-contexts: Cecilia Tries [29] are another example of set-pruning tries. The DAG-based algorithm is simple and easy to implement (our implementation requires approximately 800 lines of C code), and it is much faster than the typical filter algorithms used in existing implementations <ref> [17, 22] </ref>. While most of these existing techniques require O (n) time, n being the number of filters, our solution when used with a state-ofthe-art best matching prefix algorithm (e.g., controlled prefix expansion [25]), is more or less independent of the number of filters.
Reference: [23] <author> Shreedar, M., Varghese, G., </author> <title> Efficient Fair Queueing using Deficit Round Robin, </title> <booktitle> In Proceedings of SIGCOMM 95, </booktitle> <month> August </month> <year> 1995 </year>
Reference-contexts: With a very large number of filters (in the order of 50000), it classifies IPv6 packets in 24 memory accesses, and is much faster for smaller numbers of filters. Implementations of plugins for two state-of-the-art packet schedulers: Deficit Round Robin (DRR, <ref> [23] </ref>) for fair queuing, and the Hierarchical Fair Service Curves (H-FSC, [27]) scheduler for class-based packet schedul ing; Implementation of plugins for IP security [2]. There are a few commercial attempts that we are aware of which follow similar lines. <p> We implemented two packet scheduling plugins: the first is a port of Carnegie Mellon Universitys (CMU) Hierarchical Fair Service Curve (H-FSC, [27]) algorithm, and the second is our own implementation of a simple weighted Deficit Round Robin (DRR, <ref> [23] </ref>) plugin. These two plugins are complementary in the sense that DRR is particularly useful to implement fair queuing among best-effort flows, whereas H-FSC implements hierarchical scheduling similar to Class Based Queuing (CBQ, [11]) with several advantages over CBQ. We believe that H-FSC represents the state-of-the-art in packet scheduling. <p> The H-FSC algorithm is well documented in [27] and our results are consistent with that paper. We will not discuss our port in more detail in this paper. 6.1 The Weighted DRR Plugin The Deficit Round Robin (DRR, <ref> [23] </ref>) algorithm is a very simple yet powerful packet scheduling scheme which provides fair link bandwidth distribution among different flows. The original implementation comes from the WFQ module found in the ALTQ [5] software distribution.
Reference: [24] <author> Sklower, K., </author> <title> A tree-based routing table for Berkeley Unix, </title> <type> Techni cal report, </type> <institution> University of California, Berkley, </institution> <year> 1993 </year>
Reference-contexts: Recently, several new BMP algorithms have been proposed to replace the PATRICIA <ref> [24] </ref> algorithm found in many of todays BSD-based routing engines: Binary search on prefix lengths (BSPL, [27]), Multiway and Multicolumn search [15], and Controlled Prefix Expansion [25], to name just a few.
Reference: [25] <author> Srinivasan, V., Varghese, G., </author> <title> Faster IP Lookups using Controlled Prefix Expansion, </title> <booktitle> In Proceedings of SIGMETRICS98, </booktitle> <month> June </month> <year> 1998 </year>
Reference-contexts: While most of these existing techniques require O (n) time, n being the number of filters, our solution when used with a state-ofthe-art best matching prefix algorithm (e.g., controlled prefix expansion <ref> [25] </ref>), is more or less independent of the number of filters. If we were to characterize the performance of our DAG approach, it would be O (f), where f is the number of fields in a filter specification. <p> Recently, several new BMP algorithms have been proposed to replace the PATRICIA [24] algorithm found in many of todays BSD-based routing engines: Binary search on prefix lengths (BSPL, [27]), Multiway and Multicolumn search [15], and Controlled Prefix Expansion <ref> [25] </ref>, to name just a few. Most of these schemes are optimized for one lookup table which they usually try to fit into the processors cache.
Reference: [26] <author> Srinivasan, V., et al., </author> <title> Fast Scalable Algorithms for Level Four Switching, </title> <booktitle> In Proceedings of SIGCOMM98, </booktitle> <month> September </month> <year> 1998 </year>
Reference-contexts: Also, if there are many ambiguous filters (see [7]), the memory requirements of our algorithm can be excessive. More advanced techniques such as grid-of-tries <ref> [26] </ref> can provide better memory utilization without sacrificing performance, but work only in the special case of two-dimensional filters. It is important to note that because of the modular character of our implementation, we can easily replace our DAG-based classifier with a new classifier plugin when better approaches become available. <p> The integration of routing will make fast packet classification schemes even more important. While we believe that our DAG algorithm is a valid contribution to the state-of-the-art, we plan to pursue research in packet classification algorithms, and incorporate enhanced implementations and algorithms (such as those in <ref> [26] </ref>) into our framework. 9. ACKNOWLEDGMENTS We would like to acknowledge the help of Marcel Waldvogel (ETH Zurich) for his invaluable contributions to our design effort. Our thanks also go to Ron Cytron (Washington University, St.
Reference: [27] <author> Stoica, I., Zhang, H., Ng, T.S.E., </author> <title> A Hierarchical Fair Service Curve Algorithm for LinkSharing, Real-Time and Priority Services, </title> <booktitle> In Proceedings of SIGCOMM97, </booktitle> <month> September </month> <year> 1997 </year>
Reference-contexts: Our proposed framework has been implemented in the NetBSD UNIX kernel. This platform was selected because of its portability (all major hardware platforms are supported), efficiency, and extensive documentation. In addition, we found state-of-the-art implementations on this platform for IPv6 [13] and packet schedulers <ref> [27, 5] </ref> that could be integrated into our framework. We envision several applications for our framework. First, our architecture fits very well into the operating system of small and midsized routers. <p> Implementations of plugins for two state-of-the-art packet schedulers: Deficit Round Robin (DRR, [23]) for fair queuing, and the Hierarchical Fair Service Curves (H-FSC, <ref> [27] </ref>) scheduler for class-based packet schedul ing; Implementation of plugins for IP security [2]. There are a few commercial attempts that we are aware of which follow similar lines. <p> We implemented two packet scheduling plugins: the first is a port of Carnegie Mellon Universitys (CMU) Hierarchical Fair Service Curve (H-FSC, <ref> [27] </ref>) algorithm, and the second is our own implementation of a simple weighted Deficit Round Robin (DRR, [23]) plugin. <p> Note that in its current implementation, H-FSC uses FIFO queueing for all flows matching the same leaf node, which may result in unfair service to different flows. The H-FSC algorithm is well documented in <ref> [27] </ref> and our results are consistent with that paper. <p> Recently, several new BMP algorithms have been proposed to replace the PATRICIA [24] algorithm found in many of todays BSD-based routing engines: Binary search on prefix lengths (BSPL, <ref> [27] </ref>), Multiway and Multicolumn search [15], and Controlled Prefix Expansion [25], to name just a few. Most of these schemes are optimized for one lookup table which they usually try to fit into the processors cache. <p> Packet scheduling introduces an overhead of 20% compared to a best-effort kernel. While 20% overhead may sound excessive, it corresponds to the numbers reported by others. Although H-FSC has very different scheduling characteristics from DRR, thereby making any direct comparison difficult, <ref> [27] </ref> reports between 6.8 and 10.3 ms 1 for packet queueing overhead, which would correspond to about 25% to 37% overhead. It is important to see that every integrated services platform requires some sort of packet classification. <p> It is important to see that every integrated services platform requires some sort of packet classification. By carefully implementing packet classification, we achieve faster lookups for IPv6 than other integrated services platforms for IPv4 (e.g, <ref> [27] </ref> states that they require 2.6 ms for packet classification for IPv4 packets), even though IPv6 addresses are larger.
Reference: [28] <author> Suri, S., Varghese, G., Chandranmenon, G., </author> <title> Leap Forward Virtual Clock, </title> <booktitle> In Proceedings of INFOCOM97, </booktitle> <month> April </month> <year> 1997 </year>
Reference: [29] <author> Tsuchiya, P., </author> <title> A Search Algorithm for Table Entries with Non-contig uous Wildcarding, </title> <type> unpublished paper, </type> <year> 1992 </year>
Reference-contexts: We have also omitted a discussion of filter ambiguities and their resolution. The interested reader is referred to [7] for more details. Our DAG-based lookup data structure is an example of a more general data structure which we call set-pruning tries. Cecilia Tries <ref> [29] </ref> are another example of set-pruning tries. The DAG-based algorithm is simple and easy to implement (our implementation requires approximately 800 lines of C code), and it is much faster than the typical filter algorithms used in existing implementations [17, 22].
Reference: [30] <author> Waldvogel, M., et al., </author> <title> Scalable High Speed IP Routing Lookups, </title> <booktitle> In Proceedings of SIGCOMM97, </booktitle> <month> September </month> <year> 1997 </year>
Reference-contexts: For IP address matching, we implemented two such plugins: one is based on the slower but freely available PATRICIA algorithm, and the second is based on the patented binary search on prefix length <ref> [30] </ref> algorithm. For the other levels, we use a default plugin provided as part of our kernel, which performs the simple equality checks mentioned above. Note that the leaf nodes of a DAG correspond to the installed filters, and therefore contain all information associated with filters.
Reference: [31] <author> Zhang, L, et al., RSVP: </author> <title> A New Resource ReSerVation Protocol, </title> <journal> In IEEE Network Magazine, </journal> <volume> Vol. 7, No. 5., </volume> <month> September </month> <year> 1993 </year>
Reference-contexts: In most cases, the plugin manager is invoked from a configuration script during system initialization, but it can also be used to manually issue commands to various plugins. We show an example of how the Plugin Manager is used in Section 6. Daemons: The RSVP <ref> [31] </ref>, SSP [1] (a simplified version of RSVP), and route daemon are linked against the Router Plugin Library to perform their respective tasks. We implemented an SSP daemon for our system, and are cur rently in the process of porting an RSVP implementation.
References-found: 31

