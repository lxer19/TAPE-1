URL: http://cobar.cs.umass.edu/pubfiles/ds10.ps.gz
Refering-URL: http://cobar.cs.umass.edu/pubfiles/
Root-URL: 
Email: fmoss,hudsong@cs.umass.edu dave@dcs.st-and.ac.uk  
Title: PMOS: A Complete and Coarse-Grained Incremental Garbage Collector for Persistent Object Stores  
Author: J. Eliot B. Moss David S. Munro and Richard L. Hudson 
Keyword: persistence, garbage collection, memory management, mature object space, train algorithm  
Address: St. Andrews Amherst, MA 01003-4610, USA St. Andrews, Fife, KY16 9SS, UK  
Affiliation: Department of Computer Science 1 Department of Computer Science 2 University of Massachusetts University of  
Abstract: Traditional garbage collection techniques designed for language systems operating over transient data do not readily migrate to a persistent context. The size, complexity, and permanence characteristics of a persistent object store mean that an automatic storage reclamation system, in addition to ensuring that all unreachable and only unreachable data is reclaimed, must also maintain store consistency while limiting I/O overhead when collecting secondary-memory data. Research has shown that careful selection of which area of a store to collect can significantly increase the amount of reclaimed storage while reducing the I/O costs. Many garbage collectors for existing stores, however, either are off-line or rely on reclaiming space in a predefined order. This paper presents a new incremental garbage collection algorithm specifically designed for reclaiming persistent object storage. The collector extends the Mature Object Space algorithm to ensure incrementality in a persistent context, to achieve recoverability, and to impose minimum constraints on the order of collection of areas of the persistent address space.
Abstract-found: 1
Intro-found: 1
Reference: [Bekkers & Cohen, 1992] <editor> Yves Bekkers and Jacques Cohen, Eds. </editor> <booktitle> International Workshop on Memory Management (St. </booktitle> <address> Malo, France, </address> <month> September </month> <year> 1992), </year> <title> no. </title> <booktitle> 637 in Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference: [Bishop, 1977] <author> Peter B. Bishop. </author> <title> Computer Systems with a Very Large Address Space and Garbage Collection. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> May </month> <year> 1977. </year>
Reference-contexts: The work of Cook, Wolf, and Zorn has done a useful job in starting the investigation of suitable policies for selecting an order in which to collect partitions. To our knowledge, Bishop introduced the notion of partitioned gc <ref> [Bishop, 1977] </ref>. There are numerous papers on concurrent and/or distributed garbage collection, and undoubtedly more on persistent store or object base collection as well, but the references discussed above are representative of the prior and current art in object base garbage collection algorithms and performance.
Reference: [Cook et al., 1994a] <author> Jonathan E. Cook, Artur W. Klauser, Alexander L. Wolf, and Benjamin G. Zorn. </author> <title> Effectively con-trolling garbage collection rates in object databases. </title> <type> Tech. Rep. </type> <institution> CU-CS-758-94, Department of Computer Science, University of Colorado, Boulder, CO, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: Work by Cook, Wolf, and Zorn <ref> [Cook et al., 1994a, Cook et al., 1994b] </ref> suggests that a flexible selection policy allowing a collector to choose which partition to collect can significantly reduce I/O and increase the amount of space reclaimed. <p> See, for example, [Detlefs, 1990, Kolodner, 1987, Kolodner et al., 1989, Kolodner, 1990]. The second, more recent, body is more concerned with policies and performance <ref> [Cook et al., 1994a, Cook et al., 1994b] </ref>. Our scheme differs from the first group in that it uses partitions (we call them blocks or cars) and uses them to collect in a coarse-grained incremental way, but at least somewhat obeying the existing object clustering pattern.
Reference: [Cook et al., 1994b] <author> Jonathan E. Cook, Alexander L. Wolf, and Benjamin G. Zorn. </author> <title> Partition selection policies in object database garbage collection. </title> <booktitle> In Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data (SIGMOD '94) (Minneapolis, </booktitle> <address> MN, </address> <month> May </month> <year> 1994), </year> <pages> pp. 371382. </pages>
Reference-contexts: Work by Cook, Wolf, and Zorn <ref> [Cook et al., 1994a, Cook et al., 1994b] </ref> suggests that a flexible selection policy allowing a collector to choose which partition to collect can significantly reduce I/O and increase the amount of space reclaimed. <p> See, for example, [Detlefs, 1990, Kolodner, 1987, Kolodner et al., 1989, Kolodner, 1990]. The second, more recent, body is more concerned with policies and performance <ref> [Cook et al., 1994a, Cook et al., 1994b] </ref>. Our scheme differs from the first group in that it uses partitions (we call them blocks or cars) and uses them to collect in a coarse-grained incremental way, but at least somewhat obeying the existing object clustering pattern.
Reference: [Detlefs, 1990] <author> David L. Detlefs. </author> <title> Concurrent, atomic garbage collection. </title> <type> Tech. Rep. </type> <institution> CMU-CS-90-177, Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: The first, older, body is concerned primarily with designing garbage collection schemes that will work in the concurrent and atomic world of databases (i.e., in the presence of concurrency, concurrency control, and crash recovery). See, for example, <ref> [Detlefs, 1990, Kolodner, 1987, Kolodner et al., 1989, Kolodner, 1990] </ref>. The second, more recent, body is more concerned with policies and performance [Cook et al., 1994a, Cook et al., 1994b].
Reference: [Hudson & Moss, 1992] <author> Richard L. Hudson and J. Eliot B. Moss. </author> <title> Incremental collection of mature objects. </title> <editor> In [Bekkers & Cohen, </editor> <year> 1992], </year> <pages> pp. 388403. </pages>
Reference-contexts: Most existing collector algorithms are not inherently atomic and are thus unsuitable in this context. We present here a new garbage collection algorithm for persistent object stores, called PMOS, tailored to address the issues above. The PMOS collector is an extension of the Mature Object Space (MOS) algorithm <ref> [Hudson & Moss, 1992] </ref> (colloquially known as the train algorithm) which is an incremental main-memory copying collector specifically designed to collect large, older generations of a generational scheme in a non-disruptive manner. <p> New cars are added to the rear or end of the train. It is assumed there are at least two trains (it 1 The technique can handle objects larger than a block as well; see <ref> [Hudson & Moss, 1992] </ref> for details. 2 is a policy issue as to the number of trains), and that the trains are also ordered from oldest to newest (in terms of the time the trains were created).
Reference: [Kolodner, 1990] <author> Elliot Kolodner. </author> <title> Atomic incremental garbage collection and recovery for a large stable heap. </title> <booktitle> In Proceedings of the Fourth International Workshop on Persistent Object Systems (Martha's Vineyard, </booktitle> <address> Massachusetts, </address> <month> September </month> <year> 1990), </year> <editor> Alan Dearle, Gail M. Shaw, and Stanley B. Zdonik, Eds., </editor> <title> Published as Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1990, </year> <pages> pp. 185198. </pages>
Reference-contexts: The first, older, body is concerned primarily with designing garbage collection schemes that will work in the concurrent and atomic world of databases (i.e., in the presence of concurrency, concurrency control, and crash recovery). See, for example, <ref> [Detlefs, 1990, Kolodner, 1987, Kolodner et al., 1989, Kolodner, 1990] </ref>. The second, more recent, body is more concerned with policies and performance [Cook et al., 1994a, Cook et al., 1994b].
Reference: [Kolodner et al., 1989] <author> Elliot Kolodner, Barbara Liskov, and William Weihl. </author> <title> Atomic garbage collection: Managing a stable heap. </title> <booktitle> In Proceedings of the 1989 ACM SIGMOD International Conference on Management of Data (Portland, </booktitle> <address> Oregon, </address> <month> June </month> <year> 1989), </year> <booktitle> ACM SIGMOD Record 18, </booktitle> <month> 2 (May </month> <year> 1989), </year> <pages> pp. 1525. </pages>
Reference-contexts: The first, older, body is concerned primarily with designing garbage collection schemes that will work in the concurrent and atomic world of databases (i.e., in the presence of concurrency, concurrency control, and crash recovery). See, for example, <ref> [Detlefs, 1990, Kolodner, 1987, Kolodner et al., 1989, Kolodner, 1990] </ref>. The second, more recent, body is more concerned with policies and performance [Cook et al., 1994a, Cook et al., 1994b].
Reference: [Kolodner, 1987] <author> Elliot K. Kolodner. </author> <title> Recovery using virtual memory. </title> <type> Tech. Rep. </type> <institution> MIT/LCS/TR-404, Laboratory for Computer Science, MIT, Cambridge, Massachusetts, </institution> <month> July </month> <year> 1987. </year>
Reference-contexts: The first, older, body is concerned primarily with designing garbage collection schemes that will work in the concurrent and atomic world of databases (i.e., in the presence of concurrency, concurrency control, and crash recovery). See, for example, <ref> [Detlefs, 1990, Kolodner, 1987, Kolodner et al., 1989, Kolodner, 1990] </ref>. The second, more recent, body is more concerned with policies and performance [Cook et al., 1994a, Cook et al., 1994b].
Reference: [Munro et al., 1995] <author> David S. Munro, Richard C. H. Connor, Ron Morrison, J. Eliot B. Moss, and Stephan J. G. Scheuerl. </author> <title> Validating the MaStA I/O cost model for DB crash recovery mechanisms. Position paper for workshop on database performance at OOPSLA '95, </title> <month> October </month> <year> 1995. </year> <month> 10 </month>
Reference-contexts: One of the design goals for PMOS was to free the algorithm from imposing any collection order thus allowing the implementor to provide a policy appropriate to the application. * Results from the MaStA I/O cost model work <ref> [Scheuerl et al., 1995, Munro et al., 1995] </ref> suggest that no single recovery mechanism gives the best performance under different workloads and configurations. Hence one of the aims of the PMOS design was to provide atomicity to the MOS collector without binding it to a particular recovery mechanism.
Reference: [Scheuerl et al., 1995] <author> Stephan J. G. Scheuerl, Richard C. H. Connor, Ron Morrison, J. Eliot B. Moss, and David S. Munro. </author> <title> Validation experiments for the MaStA I/O cost model. </title> <booktitle> In Second International Workshop on Advances in Databases and Information Systems (ADBIS '95), Volume 1 (Moscow, </booktitle> <address> Russia, </address> <month> June </month> <year> 1995), </year> <pages> pp. 165175. </pages>
Reference-contexts: One of the design goals for PMOS was to free the algorithm from imposing any collection order thus allowing the implementor to provide a policy appropriate to the application. * Results from the MaStA I/O cost model work <ref> [Scheuerl et al., 1995, Munro et al., 1995] </ref> suggest that no single recovery mechanism gives the best performance under different workloads and configurations. Hence one of the aims of the PMOS design was to provide atomicity to the MOS collector without binding it to a particular recovery mechanism.
Reference: [Seligmann & Grarup, 1995] <author> Jacob Seligmann and Steffen Grarup. </author> <title> Incremental mature garbage collection using the train algorithm. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming (ECOOP '95) (Aarhus, </booktitle> <address> Denmark, </address> <month> August </month> <year> 1995), </year> <note> no. 952 in LNCS, Spring-Verlag, pp. 235252. </note>
Reference-contexts: naturally supports compaction and clustering. * It can be implemented on stock hardware and does not require special operating systems support such as pinning or external pager control. * It has been implemented, proved to be complete, and to achieve the stated objective of bounded time for any single collection <ref> [Seligmann & Grarup, 1995] </ref>. The PMOS collector partitions the persistent address space into distinct areas and retains many of the same features and mechanisms of MOS, but with two important extensions: * Unlike MOS, the algorithm does not impose any constraints on the order of collection of the areas. <p> The MOS algorithm has the same problem, noted and fixed by Grarup <ref> [Seligmann & Grarup, 1995] </ref>. Here is a description of the problem via an example. Suppose we have a cycle of objects lying in two cars, and one of the objects is a root.
Reference: [Wilson, 1992] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <editor> In [Bekkers & Cohen, </editor> <year> 1992]. </year> <month> 11 </month>
Reference-contexts: Indeed, lack of completeness will be a more acute problem than in transient systems since failure to reclaim all garbage leads to permanent space loss. Although many garbage collectors for main-memory programming languages and systems have been designed, built, and measured (see Wilson's survey <ref> [Wilson, 1992] </ref> for a good introduction), the collection of garbage for a persistent store raises additional concerns: * The sheer size of many persistent stores suggests that semi-space techniques will be unworkable because they approximately double space requirements.
References-found: 13

