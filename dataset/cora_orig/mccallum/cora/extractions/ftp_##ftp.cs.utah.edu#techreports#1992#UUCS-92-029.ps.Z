URL: ftp://ftp.cs.utah.edu/techreports/1992/UUCS-92-029.ps.Z
Refering-URL: http://www.cs.utah.edu/~willrich/async/bib.html
Root-URL: 
Email: (willrich@cs.utah.edu)  (brunvand@cs.utah.edu)  
Title: The NSR Processor Prototype  
Author: WILLIAM F. RICHARDSON ERIK L. BRUNVAND 
Keyword: Self-Timed Systems, Asynchronous Systems, Micropipelines, FPGAs  
Address: 3190 Merrill Engineering Building  Salt Lake City, Utah 84112  
Affiliation: Asynchronous Systems Research Group University of Utah, Department of Computer Science  Computer Science Department  University of Utah  
Abstract: The NSR (Non-Synchronous RISC) processor is a general purpose processor structured as a collection of self-timed units that operate concurrently and communicate over bundled data channels in the style of micropipelines. These units correspond to standard synchronous pipeline stages such as Instruction Fetch, Instruction Decode, Execute, Memory Interface, and Register File, but each operates concurrently as a separate self-timed process. In addition to being internally self-timed, the units are decoupled through self-timed FIFO queues between each of the units which allows a high degree of overlap in instruction execution. Branches, jumps, and memory accesses are also decoupled through the use of additional FIFO queues which can hide the execution latency of these instructions. The prototype implementation of the NSR has been constructed using Actel FPGAs (Field Programmable Gate Arrays). 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Actel Corporation. </author> <title> ACT Family Field Programmable Gate Array Data-book, </title> <month> March </month> <year> 1991. </year>
Reference-contexts: A heavier drain was also noted when the operands of instructions had a larger number of ones in their binary representation. The standby current for a typical Actel Act-1 series FPGA should be around 3 mA with a maximum of 10 mA <ref> [1] </ref>, if all outputs are unloaded. The measured standby current for the seven FPGAs comprising the NSR was 45.3 mA. Surprisingly, the current drain was actually less while running some particular programs than when deadlocked.
Reference: 2. <author> Erik Brunvand. </author> <title> A cell set for self-timed design using actel FPGAs. </title> <type> Technical Report UUCS-91-013, </type> <institution> University of Utah, </institution> <year> 1991. </year>
Reference-contexts: The two-phase transition control modules and bundled data modules have been assembled from a library of macros designed to be used with the Actel parts <ref> [3, 2] </ref>. The individual units of the NSR are designed to behave as pipeline stages that also process the information that flows through them [5, 4].
Reference: 3. <author> Erik Brunvand. </author> <title> Implementing self-timed systems with FPGAs. </title> <editor> In W. R. Moore and W. Luk, editors, FPGAs, </editor> <booktitle> chapter 6.2, </booktitle> <pages> pages 312-323. </pages> <publisher> Abingdon EE&CS Books, </publisher> <year> 1991. </year>
Reference-contexts: The two-phase transition control modules and bundled data modules have been assembled from a library of macros designed to be used with the Actel parts <ref> [3, 2] </ref>. The individual units of the NSR are designed to behave as pipeline stages that also process the information that flows through them [5, 4].
Reference: 4. <author> Erik Brunvand. </author> <title> Translating Concurrent Communicating Programs into Asynchronous Circuits. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1991. </year> <note> Available as Technical Report CMU-CS-91-198. </note>
Reference-contexts: Although self-timed circuits can be designed in a variety of ways, the circuits used to build the NSR processor use two-phase transition signalling for control and a bundled protocol for data paths. Two-phase transition signalling <ref> [8, 4] </ref> uses transitions on signal wires to communicate the request and acknowledge events described previously. Only the transitions are meaningful; a transition from low to high is the same as a transition from high to low and the particular state, high or low, of each wire is not important. <p> The two-phase transition control modules and bundled data modules have been assembled from a library of macros designed to be used with the Actel parts [3, 2]. The individual units of the NSR are designed to behave as pipeline stages that also process the information that flows through them <ref> [5, 4] </ref>. These parts were designed and implemented by students in a graduate seminar on VLSI architecture using the Workview suite of schematic capture and simulation tools from ViewLogic. The resulting FPGAs have been assembled as a wire-wrapped prototype for testing and evaluation.
Reference: 5. <author> Erik Brunvand and Robert F. Sproull. </author> <title> Translating concurrent programs into delay-insensitive circuits. </title> <booktitle> In ICCAD-89, </booktitle> <pages> pages 262-265. </pages> <publisher> IEEE, </publisher> <month> November </month> <year> 1989. </year>
Reference-contexts: The two-phase transition control modules and bundled data modules have been assembled from a library of macros designed to be used with the Actel parts [3, 2]. The individual units of the NSR are designed to behave as pipeline stages that also process the information that flows through them <ref> [5, 4] </ref>. These parts were designed and implemented by students in a graduate seminar on VLSI architecture using the Workview suite of schematic capture and simulation tools from ViewLogic. The resulting FPGAs have been assembled as a wire-wrapped prototype for testing and evaluation.
Reference: 6. <author> Eric C. Cooper and Richard P. Draves. </author> <title> C threads. </title> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: After writing a few programs and running them on the simulator, it was realized that this was awkward, and the modification to the instruction set was made. The simulator is based on an implementation of the C-Threads library routines <ref> [6] </ref>, and has been built on both Sun SPARC and Hewlett-Packard workstations. The simulator consists of C-Threads libraries which are machine-dependent, plus the actual NSR simulation code written in C. Separate threads are used for each functional unit of the NSR, with two threads required for the Register File.
Reference: 7. <author> J. R. Goodman, J. Hsieh, K. Liou, A. R. Pleszkun, P. B. Schechter, and H. C. Young. </author> <title> PIPE: A VLSI decoupled architecture. </title> <booktitle> In 12th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 20-27. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1985. </year>
Reference-contexts: In fact, one way to look at the architecture of the NSR processor is as a large FIFO buffer that also modifies the data passing through it according to some rules. The overall architecture of the NSR is inspired by the synchronous WM [10] and PIPE <ref> [7] </ref> processors which also use FIFO queues extensively. The units that make up the NSR processor correspond to standard synchronous pipeline stages, and consist of Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Register File (RF), and Memory Interface (MEM) as shown in Figure 4.
Reference: 8. <author> C. L. Seitz. </author> <title> System timing. In Mead and Conway, Introduction to VLSI Systems, chapter 7. </title> <publisher> Addison-Wesley, </publisher> <year> 1980. </year>
Reference-contexts: One solution is to use non-clocked asynchronous techniques or restricted versions of asynchrony known as self-timed <ref> [8] </ref>. 1.1 Self-Timed Systems Self-timed circuits are a subset of a broad class of asynchronous circuits. General asynchronous circuits do not use a global clock for synchronization, but instead rely on the behavior and arrangement of the circuits to keep the signals proceeding in the correct sequence. <p> Although self-timed circuits can be designed in a variety of ways, the circuits used to build the NSR processor use two-phase transition signalling for control and a bundled protocol for data paths. Two-phase transition signalling <ref> [8, 4] </ref> uses transitions on signal wires to communicate the request and acknowledge events described previously. Only the transitions are meaningful; a transition from low to high is the same as a transition from high to low and the particular state, high or low, of each wire is not important. <p> This requires that the data bundle and the control wires be constructed such that the value on the data bundle is stable at the receiver before a signal appears on the control wire. This condition is similar to, but weaker than, the equipotential constraint <ref> [8] </ref>. Two modules connected with a bundled data path are shown in Figure 1 and a timing diagram showing the sequence of the signal transitions using two-phase transition signalling is shown in Figure 2.
Reference: 9. <author> Ivan Sutherland. </author> <title> Micropipelines. </title> <journal> CACM, </journal> <volume> 32(6), </volume> <year> 1989. </year>
Reference-contexts: If no processing is present between the stages, as seen in the right two stages in the figure, the pipeline is a simple FIFO buffer. This type of FIFO is also known as a micropipeline <ref> [9] </ref>. 2 NSR Architecture The NSR (Non-Synchronous RISC 1 ) processor prototype is structured as a collection of self-timed units which operate concurrently and cooperate by communicating with other units using self-timed communication protocols. First-in first-out (FIFO) buffers play an extremely important role in the implementation of the NSR.
Reference: 10. <author> Wm. A. Wulf. </author> <title> The WM computer architecture. </title> <journal> Computer Architecture News, </journal> <volume> 16(1), </volume> <month> March </month> <year> 1988. </year>
Reference-contexts: In fact, one way to look at the architecture of the NSR processor is as a large FIFO buffer that also modifies the data passing through it according to some rules. The overall architecture of the NSR is inspired by the synchronous WM <ref> [10] </ref> and PIPE [7] processors which also use FIFO queues extensively. The units that make up the NSR processor correspond to standard synchronous pipeline stages, and consist of Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Register File (RF), and Memory Interface (MEM) as shown in Figure 4.
References-found: 10

