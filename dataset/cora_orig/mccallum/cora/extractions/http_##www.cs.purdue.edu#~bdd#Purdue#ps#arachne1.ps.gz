URL: http://www.cs.purdue.edu/~bdd/Purdue/ps/arachne1.ps.gz
Refering-URL: http://www.cs.purdue.edu/~bdd/Purdue/resume.html
Root-URL: http://www.cs.purdue.edu
Title: Arachne: A Portable Threads Library Supporting Migrant Threads on Heterogeneous Network Farms  
Author: Bozhidar Dimitrov and Vernon Rego 
Address: West Lafayette, IN 47907  
Affiliation: Department of Computer Sciences, Purdue University,  
Abstract: We describe the design of an efficient and portable threads system that supports multi-threaded distributed computations on heterogeneous networks. The system enables threads to migrate between processes that run on different hardware platforms. We present a complete implementation of the design in ANSI C++. This implementation consists of a code preprocessor and a runtime library, and supports applications developed in C or C++. The runtime environment is capable of supporting tens to hundreds of thousands of threads. We also present some performance measurements on the costs of basic thread operations and thread migration.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. Banks and J. Carson. </author> <title> Process interaction simulation languages. </title> <journal> Simulation, </journal> <volume> 44(5) </volume> <pages> 225-235, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: There is a general acceptance that threads can enhance application development in various ways. For example, process-oriented simulations (e.g., CSIM [14], Si [11]) which are known to offer the simplest simulation programming model <ref> [1] </ref>, are surprisingly easy to construct using threads [13]. There are two factors that significantly impact upon the runtime performance of large distributed systems: load-imbalance and non-local data access. Threads are a simple remedy to performance problems caused by both factors.
Reference: 2. <author> IEEE. </author> <title> Information Technology|Portable Operating System Interface (POSIX)| Part 1: System Application Program Interface (API) [C Language]. </title> <address> Std. 1003.1c-1995, </address> <year> 1995. </year>
Reference-contexts: Very few user-space threads systems support thread migration, and these are almost exclusively runtime-only systems supporting migration across homogeneous platforms. These tend to implement context-switch actions using either the C-library setjmp () and longjmp () primitives <ref> [8, 2] </ref> or assembly [10]. Because transforming migrant stacks at runtime is prohibitively expensive, we advocate a solution based on the use of a preprocessor [12] for C/C++. With such a setup, the user writes programs in that language, preprocesses the code, and finally compiles with a conventional compiler.
Reference: 3. <author> E. Jul, H. Levy, N. Hutchinson, and A. Black. </author> <title> Fine-Grained Mobility in the Emerald System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <year> 1988. </year>
Reference-contexts: With such a setup, the user writes programs in that language, preprocesses the code, and finally compiles with a conventional compiler. A related effort has been reported in [15], where a group of researchers developed a heterogeneous compiler for the Emerald programming language <ref> [3] </ref>. This compiler inserts instructions that encode the function's state, thus enabling threads and objects to freely migrate between the four supported architectures: Sun 3, Sun SPARC, VAX, and HP. While very powerful, this approach has disadvantages.
Reference: 4. <author> F. Knop. </author> <title> Software Architectures for Fault-Tolerant Replications and Multithreaded Decompositions: Experiments with Practical Parallel Simulation. </title> <type> PhD thesis, </type> <institution> Pur-due University, </institution> <month> August </month> <year> 1996. </year>
Reference-contexts: With appropriate layering and support for locating ob-jects [8], thread migration can be made transparent to end-users. This approach has proven very useful in the ParaSol parallel simulation system <ref> [6, 4, 9] </ref>. In this effort, we focus on the design of a threads system that enables threads to migrate between heterogeneous hosts. Because contexts and stacks are meaningless across distinct architectures, the formidable problems of context and stack translation make thread migration on heterogeneous systems a real challenge.
Reference: 5. <author> B. Malloy and M. Soffa. </author> <title> Conversion of Simulation Processes to Pascal Constructs. </title> <journal> Software: Practice and Experience, </journal> 202(2) 191-207, February 1990. 
Reference-contexts: Because Arachne, its output, and libarachne.a all conform to ANSI C++, the system is readily portable to different environments. The idea behind our design has its origins in work done by Malloy and Soffa <ref> [5] </ref>. By augmenting Pascal with certain Simula control structures, the authors defined a language called SimCal. They then developed a preprocessor that accepts SimCal as input and produces Pascal as output. While similar, the SimCal preprocessor's duties are a small subset of app's duties. <p> The latter point is of great significance since a thread may, for example, invoke a strand s1 () which in turn invokes a strand s2 () that subsequently requests migration. While this scenario is prohibited by Ythreads [12] and SimCal <ref> [5] </ref>, Arachne packages the entire activation stack, ships it to the remote machine, and continues to compute. We should point out that while Arachne supports programs written in C or C++, Arachne threads (currently) can only execute C-type functions and not class methods, as for example Java threads do.
Reference: 6. <author> E. Mascarenhas, F. Knop, and V. Rego. ParaSol: </author> <title> A Multi-threaded System for Parallel Simulation Based on Mobile Threads. </title> <booktitle> In Proceedings of the Winter Simulation Conference, </booktitle> <pages> pages 690-697, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: With appropriate layering and support for locating ob-jects [8], thread migration can be made transparent to end-users. This approach has proven very useful in the ParaSol parallel simulation system <ref> [6, 4, 9] </ref>. In this effort, we focus on the design of a threads system that enables threads to migrate between heterogeneous hosts. Because contexts and stacks are meaningless across distinct architectures, the formidable problems of context and stack translation make thread migration on heterogeneous systems a real challenge.
Reference: 7. <author> E. Mascarenhas and V. Rego. </author> <title> Migrant Threads on Process Farms: Parallel Pro--gramming with Ariadne. </title> <type> Technical Report TR 95-081, </type> <institution> Department of Computer Sciences, Purdue University, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: If threads are free to migrate (i.e., move their data and computation state) from one processor to another, threads from densely populated processors may migrate to less densely populated processors with the aim of balancing loads. For example, on shared-memory multiprocessors the Ariadne threads system <ref> [8, 7] </ref> sees balanced loads as a direct result of placing runnable threads in a shared queue. If threads on one processor require frequent access to data on remote processors, these threads may migrate to their respective data hosts so that subsequent data accesses become local.
Reference: 8. <author> E. Mascarenhas and V. Rego. Ariadne: </author> <title> Architecture of a Portable Threads System Supporting Thread Migration. </title> <journal> Software Practice and Experience, </journal> <volume> 26(3) </volume> <pages> 327-357, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: If threads are free to migrate (i.e., move their data and computation state) from one processor to another, threads from densely populated processors may migrate to less densely populated processors with the aim of balancing loads. For example, on shared-memory multiprocessors the Ariadne threads system <ref> [8, 7] </ref> sees balanced loads as a direct result of placing runnable threads in a shared queue. If threads on one processor require frequent access to data on remote processors, these threads may migrate to their respective data hosts so that subsequent data accesses become local. <p> If threads on one processor require frequent access to data on remote processors, these threads may migrate to their respective data hosts so that subsequent data accesses become local. With appropriate layering and support for locating ob-jects <ref> [8] </ref>, thread migration can be made transparent to end-users. This approach has proven very useful in the ParaSol parallel simulation system [6, 4, 9]. In this effort, we focus on the design of a threads system that enables threads to migrate between heterogeneous hosts. <p> Very few user-space threads systems support thread migration, and these are almost exclusively runtime-only systems supporting migration across homogeneous platforms. These tend to implement context-switch actions using either the C-library setjmp () and longjmp () primitives <ref> [8, 2] </ref> or assembly [10]. Because transforming migrant stacks at runtime is prohibitively expensive, we advocate a solution based on the use of a preprocessor [12] for C/C++. With such a setup, the user writes programs in that language, preprocesses the code, and finally compiles with a conventional compiler. <p> We also compare Arachne's performance with that of the SunOS 5.3 multi-threads (Sun-MT) and Ariadne threads sys-tems, all operating on the Sun Sparc 20. The performance numbers for the latter two systems are those reported in <ref> [8] </ref>. For each run, the average time required to execute an operation is obtained by dividing the run time (as measured by Unix's clock (3C)) by the total number of operation invocations. To account for variability, we report an average over ten independent runs.
Reference: 9. <author> E. Masceranhas. </author> <title> A System for Multithreaded Parallel Simulation and Computation with Migrant Threads and Objects. </title> <type> PhD thesis, </type> <institution> Purdue University, </institution> <month> August </month> <year> 1996. </year>
Reference-contexts: With appropriate layering and support for locating ob-jects [8], thread migration can be made transparent to end-users. This approach has proven very useful in the ParaSol parallel simulation system <ref> [6, 4, 9] </ref>. In this effort, we focus on the design of a threads system that enables threads to migrate between heterogeneous hosts. Because contexts and stacks are meaningless across distinct architectures, the formidable problems of context and stack translation make thread migration on heterogeneous systems a real challenge.
Reference: 10. <author> J. Sang, F. Knop, V. Rego, J. Lee, and C. King. </author> <title> The Xthreads Library: </title> <booktitle> Design, Implementation and Applications. In Proceedings of the 17th Annual Computer Software and Applications Conference (COMPSAC '93), </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: Very few user-space threads systems support thread migration, and these are almost exclusively runtime-only systems supporting migration across homogeneous platforms. These tend to implement context-switch actions using either the C-library setjmp () and longjmp () primitives [8, 2] or assembly <ref> [10] </ref>. Because transforming migrant stacks at runtime is prohibitively expensive, we advocate a solution based on the use of a preprocessor [12] for C/C++. With such a setup, the user writes programs in that language, preprocesses the code, and finally compiles with a conventional compiler.
Reference: 11. <author> J. Sang, E. Mascarenhas, and V. Rego. </author> <title> Mobile-Process Based Parallel Simulation. </title> <journal> Journal of Parallel & Distributed Computing, </journal> <volume> 33(1) </volume> <pages> 12-23, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: There is a general acceptance that threads can enhance application development in various ways. For example, process-oriented simulations (e.g., CSIM [14], Si <ref> [11] </ref>) which are known to offer the simplest simulation programming model [1], are surprisingly easy to construct using threads [13]. There are two factors that significantly impact upon the runtime performance of large distributed systems: load-imbalance and non-local data access.
Reference: 12. <author> J. Sang, G. Peters, and V. Rego. </author> <title> Thread Migration on Heterogeneous Systems via Compile-Time Transformations. </title> <booktitle> In Proceedings of the International Conference on Parallel and Distributed Systems - ICPADS, </booktitle> <pages> pages 634-639, </pages> <year> 1994. </year>
Reference-contexts: To accommodate heterogeneity, we take a transformation-oriented approach to migration and other threads operations. Our system builds upon and removes significant limitations of an earlier work, namely, the Ythreads <ref> [12] </ref> system. Very few user-space threads systems support thread migration, and these are almost exclusively runtime-only systems supporting migration across homogeneous platforms. These tend to implement context-switch actions using either the C-library setjmp () and longjmp () primitives [8, 2] or assembly [10]. <p> These tend to implement context-switch actions using either the C-library setjmp () and longjmp () primitives [8, 2] or assembly [10]. Because transforming migrant stacks at runtime is prohibitively expensive, we advocate a solution based on the use of a preprocessor <ref> [12] </ref> for C/C++. With such a setup, the user writes programs in that language, preprocesses the code, and finally compiles with a conventional compiler. A related effort has been reported in [15], where a group of researchers developed a heterogeneous compiler for the Emerald programming language [3]. <p> The latter point is of great significance since a thread may, for example, invoke a strand s1 () which in turn invokes a strand s2 () that subsequently requests migration. While this scenario is prohibited by Ythreads <ref> [12] </ref> and SimCal [5], Arachne packages the entire activation stack, ships it to the remote machine, and continues to compute.
Reference: 13. <author> J. Sang and V. Rego. </author> <title> A Simulation Testbed based on Lightweight Processes. </title> <journal> Software, Practice & Experience, </journal> <volume> 24(5) </volume> <pages> 485-505, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: There is a general acceptance that threads can enhance application development in various ways. For example, process-oriented simulations (e.g., CSIM [14], Si [11]) which are known to offer the simplest simulation programming model [1], are surprisingly easy to construct using threads <ref> [13] </ref>. There are two factors that significantly impact upon the runtime performance of large distributed systems: load-imbalance and non-local data access. Threads are a simple remedy to performance problems caused by both factors.
Reference: 14. <author> H. D. Schwetman. </author> <title> Using CSIM to model complex systems. </title> <booktitle> In Proceedings of the Winter Simulation Conference, </booktitle> <pages> pages 246-253, </pages> <year> 1988. </year>
Reference-contexts: There is a general acceptance that threads can enhance application development in various ways. For example, process-oriented simulations (e.g., CSIM <ref> [14] </ref>, Si [11]) which are known to offer the simplest simulation programming model [1], are surprisingly easy to construct using threads [13]. There are two factors that significantly impact upon the runtime performance of large distributed systems: load-imbalance and non-local data access.
Reference: 15. <author> B. Steensgaard and E. </author> <month> Jul. </month> <title> Object and native code thread mobility among heterogeneous computers. </title> <booktitle> In Proceedings of the ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 68-78, </pages> <year> 1995. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: With such a setup, the user writes programs in that language, preprocesses the code, and finally compiles with a conventional compiler. A related effort has been reported in <ref> [15] </ref>, where a group of researchers developed a heterogeneous compiler for the Emerald programming language [3]. This compiler inserts instructions that encode the function's state, thus enabling threads and objects to freely migrate between the four supported architectures: Sun 3, Sun SPARC, VAX, and HP.
References-found: 15

