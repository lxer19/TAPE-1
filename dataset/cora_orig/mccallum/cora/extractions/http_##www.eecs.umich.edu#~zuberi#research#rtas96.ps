URL: http://www.eecs.umich.edu/~zuberi/research/rtas96.ps
Refering-URL: http://www.eecs.umich.edu/~zuberi/research/
Root-URL: http://www.cs.umich.edu
Title: EMERALDS: A Microkernel for Embedded Real-Time Systems  
Author: Khawar M. Zuberi and Kang G. Shin 
Address: Ann Arbor, MI 48109-2122  
Affiliation: Real-Time Computing Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: EMERALDS (Extensible Microkernel for Embedded, ReAL-time, Distributed Systems) is a real-time microkernel designed for cost-conscious, small to medium size embedded systems. It not only offers standard OS services like multi-threaded processes, real-time scheduling, protected address spaces, message-passing, semaphores, and timers, but does so in an efficient manner while keeping the kernel size to just tens of kilobytes. For efficiency, EMERALDS uses the novel approach of mapping the kernel into each user-level address space, so even with full memory protection, system calls do not need context switches unless a user-level server is involved. EMERALDS also provides the flexibility for users to add communication protocol stacks and device drivers as user-level servers without modifying the kernel. We have completed a uniprocessor version of EMERALDS for the Motorola 68040 processor whose size is under 13 KBytes. Context switch takes under 12 s and system calls have overhead just 1.8 s more than that of simple subroutine calls. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. G. Shin and P. Ramanathan, </author> <title> "Real-time computing: a new discipline of computer science and engineering," </title> <journal> Procedings of the IEEE, </journal> <volume> vol. 82, no. 1, </volume> <pages> pp. 6-24, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Real-time computing systems <ref> [1] </ref> must behave predictably in possibly unpredictable environments. This predictability is usually ensured by a real-time operating system (RTOS). The variety of real-time applications | from soft multimedia applications to hard real-time automotive control systems | have resulted in dozens of RTOSs being designed for both commercial and research purposes.
Reference: [2] <author> L. M. Thompson, </author> <title> "Using pSOS+ for embedded real-time computing," </title> <booktitle> in COMPCON, </booktitle> <pages> pp. 282-288, </pages> <year> 1990. </year>
Reference-contexts: Some RTOSs are "general-purpose" in that they cater to a wide range of real-time applications. Examples include commercial RTOSs like pSOS <ref> [2] </ref>, QNX [3], and VxWorks [4]; and research ones like Real-Time Mach [5]. Somewhat more specialized RTOSs include HARTOS [6] and the Spring Kernel [7], designed for parallel and distributed platforms. Even more specialized RTOSs include CHAOS [8] and Harmony [9], designed primarily for complex robotic systems.
Reference: [3] <author> D. Hildebrand, </author> <title> "An architectural overview of QNX," </title> <booktitle> in Proc. Usenix Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: Some RTOSs are "general-purpose" in that they cater to a wide range of real-time applications. Examples include commercial RTOSs like pSOS [2], QNX <ref> [3] </ref>, and VxWorks [4]; and research ones like Real-Time Mach [5]. Somewhat more specialized RTOSs include HARTOS [6] and the Spring Kernel [7], designed for parallel and distributed platforms. Even more specialized RTOSs include CHAOS [8] and Harmony [9], designed primarily for complex robotic systems. <p> Comparing this to other major RTOSs for embedded applications (Table 4), we see that our goal of a small-sized RTOS has been achieved. RTOS Size (KBytes) QNX 101 VxWorks 5.1 286 EMERALDS 13 Table 4: Sizes of various RTOSs (uniprocessor versions). Size of QNX is from <ref> [3] </ref> and includes the "kernel," Proc, and Dev modules which is the minimal configuration with device driver support. VxWorks' size is from a compiled stand-alone version.
Reference: [4] <institution> VxWorks Programmer's Guide, 5.1, Wind River Systems, </institution> <year> 1993. </year>
Reference-contexts: Some RTOSs are "general-purpose" in that they cater to a wide range of real-time applications. Examples include commercial RTOSs like pSOS [2], QNX [3], and VxWorks <ref> [4] </ref>; and research ones like Real-Time Mach [5]. Somewhat more specialized RTOSs include HARTOS [6] and the Spring Kernel [7], designed for parallel and distributed platforms. Even more specialized RTOSs include CHAOS [8] and Harmony [9], designed primarily for complex robotic systems.
Reference: [5] <author> H. Tokuda, T. Nakajima, and P. Rao, </author> <title> "Real-Time Mach: Towards a predictable real-time system," </title> <booktitle> in Proc. USENIX Mach Workshop, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: Some RTOSs are "general-purpose" in that they cater to a wide range of real-time applications. Examples include commercial RTOSs like pSOS [2], QNX [3], and VxWorks [4]; and research ones like Real-Time Mach <ref> [5] </ref>. Somewhat more specialized RTOSs include HARTOS [6] and the Spring Kernel [7], designed for parallel and distributed platforms. Even more specialized RTOSs include CHAOS [8] and Harmony [9], designed primarily for complex robotic systems.
Reference: [6] <author> K. G. Shin, D. D. Kandlur, D. Kiskis, P. Dodd, H. Rosenberg, and A. Indiresan, </author> <title> "A distributed real-time operating system," </title> <journal> IEEE Software, </journal> <pages> pp. 58-68, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Some RTOSs are "general-purpose" in that they cater to a wide range of real-time applications. Examples include commercial RTOSs like pSOS [2], QNX [3], and VxWorks [4]; and research ones like Real-Time Mach [5]. Somewhat more specialized RTOSs include HARTOS <ref> [6] </ref> and the Spring Kernel [7], designed for parallel and distributed platforms. Even more specialized RTOSs include CHAOS [8] and Harmony [9], designed primarily for complex robotic systems. In this paper we present the EMERALDS designed specifically for mass-produced, small- to medium-sized embedded systems.
Reference: [7] <author> J. Stankovic and K. Ramamritham, </author> <title> "The Spring Kernel: a new paradigm for real-time operating systems," </title> <journal> ACM Operating Systems Review, </journal> <volume> vol. 23, no. 3, </volume> <pages> pp. 54-71, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Some RTOSs are "general-purpose" in that they cater to a wide range of real-time applications. Examples include commercial RTOSs like pSOS [2], QNX [3], and VxWorks [4]; and research ones like Real-Time Mach [5]. Somewhat more specialized RTOSs include HARTOS [6] and the Spring Kernel <ref> [7] </ref>, designed for parallel and distributed platforms. Even more specialized RTOSs include CHAOS [8] and Harmony [9], designed primarily for complex robotic systems. In this paper we present the EMERALDS designed specifically for mass-produced, small- to medium-sized embedded systems.
Reference: [8] <author> P. Gopinath and K. Schwan, </author> <title> "CHAOS: Why one cannot have only an operating system for real-time applications," </title> <journal> ACM SIGOPS Operating Systems Review, </journal> <volume> vol. 23, no. 3, </volume> <pages> pp. 106-125, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: Examples include commercial RTOSs like pSOS [2], QNX [3], and VxWorks [4]; and research ones like Real-Time Mach [5]. Somewhat more specialized RTOSs include HARTOS [6] and the Spring Kernel [7], designed for parallel and distributed platforms. Even more specialized RTOSs include CHAOS <ref> [8] </ref> and Harmony [9], designed primarily for complex robotic systems. In this paper we present the EMERALDS designed specifically for mass-produced, small- to medium-sized embedded systems. Such systems consist of a small number of microprocessors (about 10 or less) interconnected by a local area network.
Reference: [9] <author> W. M. Gentleman, </author> <title> "Realtime applications: Multiprocessors in Harmony," </title> <booktitle> in Proc. BUSCON/88 East, </booktitle> <pages> pp. 269-278, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Examples include commercial RTOSs like pSOS [2], QNX [3], and VxWorks [4]; and research ones like Real-Time Mach [5]. Somewhat more specialized RTOSs include HARTOS [6] and the Spring Kernel [7], designed for parallel and distributed platforms. Even more specialized RTOSs include CHAOS [8] and Harmony <ref> [9] </ref>, designed primarily for complex robotic systems. In this paper we present the EMERALDS designed specifically for mass-produced, small- to medium-sized embedded systems. Such systems consist of a small number of microprocessors (about 10 or less) interconnected by a local area network.
Reference: [10] <author> C. L. Liu and J. W. Layland, </author> <title> "Scheduling algorithms for multiprogramming in a hard real-time environment," </title> <journal> Journal of the ACM, </journal> <volume> vol. 20, no. 1, </volume> <pages> pp. 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: The user specifies a thread's priority at creation time. Users may choose priorities based on rate-monotonic <ref> [10] </ref>, deadline-monotonic [11], or any other fixed-priority scheme suitable for the application at hand. Also, a system call is provided to change a thread's priority at run-time to respond to changing operating conditions. This can be used to emulate dynamic earliest-deadline first (EDF) [10] scheduling at the user level (even though <p> Users may choose priorities based on rate-monotonic <ref> [10] </ref>, deadline-monotonic [11], or any other fixed-priority scheme suitable for the application at hand. Also, a system call is provided to change a thread's priority at run-time to respond to changing operating conditions. This can be used to emulate dynamic earliest-deadline first (EDF) [10] scheduling at the user level (even though currently, EDF is not explicitly supported by the kernel).
Reference: [11] <author> J. Y.-T. Leung and J. Whitehead, </author> <title> "On the complexity of fixed-priority scheduling of periodic, real-time tasks," </title> <journal> Performance Evaluation, </journal> <volume> vol. 2, no. 4, </volume> <pages> pp. 237-250, </pages> <month> De-cember </month> <year> 1982. </year>
Reference-contexts: The user specifies a thread's priority at creation time. Users may choose priorities based on rate-monotonic [10], deadline-monotonic <ref> [11] </ref>, or any other fixed-priority scheme suitable for the application at hand. Also, a system call is provided to change a thread's priority at run-time to respond to changing operating conditions.
Reference: [12] <institution> Road vehicles | Interchange of digital information | Controller area network (CAN) for high-speed communication. </institution> <note> ISO 11898, 1st edition, </note> <year> 1993. </year>
Reference-contexts: Message-passing in EMERALDS has been designed with efficiency and flexibility in mind. Most communication networks designed for embedded, real-time systems such as CAN <ref> [12] </ref>, TTP [13], SERCOS [14], SP50, etc., provide the bottom two layers of the ISO OSI reference stack (the physical and data-link layers) which is sufficient for exchanging simple messages (all that the sender has to do is talk directly to the network device driver). <p> This is why we chose a microkernel architecture and provided features such as user-level servers for communication protocols and device drivers. The next step in the development of EMERALDS is networking. We plan to use CAN <ref> [12] </ref> for this purpose, which is a popular network for real-time control applications. We also plan to add features like kernel-supported deadline-driven scheduling and clock synchronization to EMERALDS.
Reference: [13] <author> H. Kopetz and G. Grunsteidl, </author> <title> "TTP a protocol for fault-tolerant real-time systems," </title> <journal> IEEE Computer, </journal> <volume> vol. 27, no. 1, </volume> <pages> pp. 14-23, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Message-passing in EMERALDS has been designed with efficiency and flexibility in mind. Most communication networks designed for embedded, real-time systems such as CAN [12], TTP <ref> [13] </ref>, SERCOS [14], SP50, etc., provide the bottom two layers of the ISO OSI reference stack (the physical and data-link layers) which is sufficient for exchanging simple messages (all that the sender has to do is talk directly to the network device driver).
Reference: [14] <institution> Electrical Equipment of Industrial Machines | Serial Data Link for Real-Time Communication between Controls and Drives, International Electrotechnical Commission, </institution> <year> 1994. </year> <note> Revision 8. </note>
Reference-contexts: Message-passing in EMERALDS has been designed with efficiency and flexibility in mind. Most communication networks designed for embedded, real-time systems such as CAN [12], TTP [13], SERCOS <ref> [14] </ref>, SP50, etc., provide the bottom two layers of the ISO OSI reference stack (the physical and data-link layers) which is sufficient for exchanging simple messages (all that the sender has to do is talk directly to the network device driver).
Reference: [15] <author> H. Kopetz, </author> <title> "Sparse time versus dense time in distributed real-time systems," </title> <booktitle> in Proc. Int'l Conf. on Distributed Computing Systems, </booktitle> <pages> pp. 460-467, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Using Communication Protocol Stacks: There are many reasons why an embedded system may need a (partial or complete) communication stack. One simple reason is to add count information to detect duplicate transmissions. Some applications may also require that messages be properly ordered in which case timestamps <ref> [15] </ref> or logical clocks [16] may have to be attached to messages. To cater to the needs of such applications, the EMERALDS microkernel allows communication stacks to be used with message-passing in the form of user-level servers. Figure 4 shows this form of message-passing.
Reference: [16] <author> L. Lamport, </author> <title> "Time, clocks, and the ordering of events in a distributed system," </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. 7, </volume> <pages> pp. 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: One simple reason is to add count information to detect duplicate transmissions. Some applications may also require that messages be properly ordered in which case timestamps [15] or logical clocks <ref> [16] </ref> may have to be attached to messages. To cater to the needs of such applications, the EMERALDS microkernel allows communication stacks to be used with message-passing in the form of user-level servers. Figure 4 shows this form of message-passing.
Reference: [17] <author> L. Sha, R. Rajkumar, and J. Lehoczky, </author> <title> "Priority inheritance protocols: an approach to real-time synchronization," </title> <journal> IEEE Trans. Comput., </journal> <volume> vol. 39, no. 3, </volume> <pages> pp. 1175-1198, </pages> <year> 1990. </year>
Reference-contexts: Priority of Server Processes: User-level servers which implement protocol stacks cannot run at a fixed priority all the time because of a form of the priority inversion <ref> [17] </ref> problem. Suppose the server runs at a low priority and some message arrives for a high-priority thread T 1. <p> Making the server run at a high priority is also infeasible for similar reasons. Our solution to this priority inversion problem is to use priority inheritance <ref> [17] </ref> which, in the context of message-passing in EMERALDS, works as follows. Define an inherited thread priority (ITP) associated with each message. For an outgoing message, it is the priority of the sender thread, while for incoming messages, it is the priority of the receiver thread.
References-found: 17

