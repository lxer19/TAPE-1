URL: ftp://ftp.cs.unc.edu/pub/users/manocha/PAPERS/COLLISION/collision.ps.Z
Refering-URL: http://www.cs.unc.edu/~lin/papers.html
Root-URL: http://www.cs.unc.edu
Email: cohenj@cs.unc.edu  mlin@cs.nps.navy.mil  manocha@cs.unc.edu  ponamgi@cs.unc.edu  
Title: Interactive and Exact Collision Detection for Large-Scaled Environments  
Author: Jonathan D. Cohen Ming C. Lin Dinesh Manocha Madhav K. Ponamgi 
Keyword: Additional Keywords and Phrases: interference, contact, geometric coherence, simulations, virtual environment, walkthrough  
Note: Supported in part by NSF MIP-9306208 Supported in part by a Junior Faculty Award, University Research Award, NSF Grant CCR-9319957, ARPA Contract DABT63-93-C-0048 and NSF/ARPA Science and Technology Center for Computer Graph ics and Scientific Visualization, NSF Prime Contract Number 8920219. Supported in part by NSF MIP-9306208 and NSF Grant CCR-9319957  
Address: Chapel Hill, NC 27599-3175  Monterey, CA 93943  Chapel Hill, NC 27599-3175  Chapel Hill, NC 27599-3175  
Affiliation: Computer Science Department University of North Carolina  Computer Science Department Naval Postgraduate School  Computer Science Department University of North Carolina  Computer Science Department University of North Carolina  
Abstract: We present algorithms for exact collision detection in interactive environments. Such environments are characterized by the number of objects undergoing motion and the complexity of the models. We do not assume that the motions of the objects are expressible as closed-form functions of time, nor do we assume any limitations on their velocities. The algorithms use a two-level hierarchical representation for each model to selectively compute the precise contact between objects, achieving real-time performance without compromising accuracy. In large environments with n moving objects, they use the temporal and geometric coherence that exists between successive frames to overcome the bottleneck of O(n 2 ) pairwise comparisons. The algorithms have been successfully demonstrated in architectural walkthrough and simulated environments. In particular, the algorithm takes less than 1=20 of a second to determine all the collisions and contacts in environment consisting of more than 1000 moving polytopes, each consisting of more than 50 faces. 
Abstract-found: 1
Intro-found: 1
Reference: [ARJ90] <author> John M. Airey, John H. Rohlf, and Frederick P. Brooks Jr. </author> <title> Towards image realism with interactive update rates in complex virtual building environments. </title> <booktitle> ACM SIGGRAPH Special Issue on 1990 Symposium on Interactive 3D Graphics, </booktitle> <volume> 24(2) </volume> <pages> 41-50, </pages> <year> 1990. </year>
Reference-contexts: See Frames 1-4 for examples of the simulation with several sets of parameters. 5.4 Walkthrough The walkthrough is a head-mounted display application that involves a large number of polytopes depicting a realistic scene <ref> [ARJ90] </ref>. The integration of our library to such an 17 environment demonstrates that an interactive environment can use our collision detection library without affecting the application's real-time performance. The walkthrough creates a virtual environment, such as a kitchen or a porch.
Reference: [AS90] <author> P. K. Agarwal and M. Sharir. </author> <title> Red-blue intersection detection algorithms, with applications to motion planning and collision detection. </title> <journal> SIAM J. Comput., </journal> <volume> 19 </volume> <pages> 297-321, </pages> <year> 1990. </year>
Reference-contexts: The problem has also been addressed in computational geometry. The emphasis in the computational geometry literature has been on theoretically efficient intersection detection algorithms for pairs of objects at a single instance in time <ref> [AS90, Cha89, CD87, DK90, 3 Ede83] </ref>. For convex 3-polytopes 1 linear time algorithms based on linear programming [Meg83, Sei90] and tracking closest points [GJK88] have been proposed. More recently, temporal and geometric coherence has been used to devise algorithms based on checking local features of convex 3-polytopes [Bar90, Lin93].
Reference: [ASF94] <author> A. Garcia-Alonso, N. Serrano, and J. </author> <booktitle> Navarre Solving the Collision Detection Problem IEEE Computer Graphics and Applications, </booktitle> <pages> pp. 36-43, </pages> <month> May, </month> <year> 1994. </year>
Reference-contexts: For an environment where almost all objects are of uniform size and fat [Ove92], like a vibrating parts feeder bowl, or molecular modeling application [Lev66, Tur89], this algorithm is ideal, especially for execution on a parallel machine. Alonso et. al. <ref> [ASF94] </ref> have an algorithm that combines space partitioning with hierarchical bounding boxes. The running time of their approach depends on the complexity and size of the objects being considered for collision detection. They perform simple convex decompositions of the objects into voxels and place the objects into bounding boxes.
Reference: [Bar90] <author> D. Baraff. </author> <title> Curved surfaces and coherence for non-penetrating rigid body simulation. </title> <journal> ACM Computer Graphics, </journal> <volume> 24(4) </volume> <pages> 19-28, </pages> <year> 1990. </year>
Reference-contexts: For convex 3-polytopes 1 linear time algorithms based on linear programming [Meg83, Sei90] and tracking closest points [GJK88] have been proposed. More recently, temporal and geometric coherence has been used to devise algorithms based on checking local features of convex 3-polytopes <ref> [Bar90, Lin93] </ref>. To handle curved models, algorithms based on interval arithmetic have been proposed by [Duf92, HBZ90, SWF + 93]. Faster algorithms using coherence have been proposed for curved models defined algebraically or using NURBs [LM93]. <p> In general, however, most configurations of a simulation have far fewer than O (n 2 ) collisions. Combining temporal and geometric coherence with this observation has resulted in some efficient collision detection schemes between single pairs of objects <ref> [Bar90, Lin93, LM93] </ref>. 3.2 Pairwise Collision Detection for Convex Polytopes Here we will review an efficient collision detection algorithm which tracks closest points between pairs of convex polytopes [LC92, Lin93]. This algorithm is used at the second level of collision detection to determine the exact contact status between convex polytopes.
Reference: [BB88] <author> R. Barzel and A. Barr. </author> <title> A modeling system based on dynamic constraints. </title> <journal> ACM Computer Graphics, </journal> <volume> 22(4) </volume> <pages> 31-39, </pages> <year> 1988. </year>
Reference: [BF79] <author> J. L. Bentley and J. H. Friedman. </author> <title> Data structures for range searching. </title> <journal> Computing Surveys, </journal> <volume> 11(4), </volume> <month> December </month> <year> 1979. </year>
Reference-contexts: Different methods have been proposed to overcome the bottleneck of O (n 2 ) pairwise tests in an environment of n bodies. The simplest of these are based on spatial subdivision <ref> [BF79, Lev66] </ref>. The space is divided into cells of equal volume, and at each instance the objects are assigned to one or more cells. Collisions are checked between all object pairs belonging to a particular cell. <p> In addition, the velocity and acceleration information is not readily available in a truly interactive environment, such as the architectural walkthrough environment. Several practical and efficient algorithms are based on uniform space division. We divide space into unit cells (or volumes) and place each object in some cell (s) <ref> [BF79, Lev66] </ref>. To check for collisions, we examine the cell (s) occupied by each object to verify if the cell (s) is (are) shared by other objects. But, it is difficult to set a near-optimal size for each cell and it requires tremendous amount of allocated memory.
Reference: [Cam90] <author> S. A. Cameron. </author> <title> Collision detection by four-dimensional intersection testing. </title> <journal> IEEE Trans. on Robotics and Automation, </journal> <volume> 6(3) </volume> <pages> 291-302, </pages> <year> 1990. </year>
Reference-contexts: This approach works well for sparse environments in which the objects are uniformly distributed through the space. Object space coherence has been used extensively in ray tracing for the past decade [SML90]. Another approach operates directly on four-dimensional volumes swept out by object motion over time <ref> [Cam90, Hub93] </ref>. This is difficult not only to visualize, but to model as well, especially when the motion is complex and abrupt. In addition, computing the intersection of complex hyper-cones induced by acceleration or uncertainty of position is non-trivial.
Reference: [Can86] <author> J. F. Canny. </author> <title> Collision detection for moving polyhedra. </title> <journal> IEEE Trans. PAMI, </journal> <volume> 8:pp. </volume> <pages> 200-209, </pages> <year> 1986. </year>
Reference-contexts: Section 5 describes the implementation of our algorithm. Section 6 presents our experimental results on architectural walkthrough environments and simulations. 2 Previous Work The problem of collision detection has extensively studied in robotics. However, the goal here has been the planning of collision-free trajectories between obstacles <ref> [Can86, Lat91, LPW79, Sha87] </ref>. This differs from virtual environments and physically-based simulations, where the motion is subject to dynamic constraints or external forces and cannot typically be expressed as a closed form function of time . The problem has also been addressed in computational geometry.
Reference: [CD87] <author> B. Chazelle and D. P. Dobkin. </author> <title> Intersection of convex objects in two and three dimensions. </title> <journal> J. ACM, </journal> <volume> 34 </volume> <pages> 1-27, </pages> <year> 1987. </year>
Reference-contexts: The problem has also been addressed in computational geometry. The emphasis in the computational geometry literature has been on theoretically efficient intersection detection algorithms for pairs of objects at a single instance in time <ref> [AS90, Cha89, CD87, DK90, 3 Ede83] </ref>. For convex 3-polytopes 1 linear time algorithms based on linear programming [Meg83, Sei90] and tracking closest points [GJK88] have been proposed. More recently, temporal and geometric coherence has been used to devise algorithms based on checking local features of convex 3-polytopes [Bar90, Lin93].
Reference: [Cha89] <author> B. Chazelle. </author> <title> An optimal algorithm for intersecting three-dimensional convex polyhedra. </title> <booktitle> In Proc. 30th Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 586-591, </pages> <year> 1989. </year>
Reference-contexts: The problem has also been addressed in computational geometry. The emphasis in the computational geometry literature has been on theoretically efficient intersection detection algorithms for pairs of objects at a single instance in time <ref> [AS90, Cha89, CD87, DK90, 3 Ede83] </ref>. For convex 3-polytopes 1 linear time algorithms based on linear programming [Meg83, Sei90] and tracking closest points [GJK88] have been proposed. More recently, temporal and geometric coherence has been used to devise algorithms based on checking local features of convex 3-polytopes [Bar90, Lin93].
Reference: [DK90] <author> D. P. Dobkin and D. G. Kirkpatrick. </author> <title> Determining the separation of preprocessed polyhedra a unified approach. </title> <booktitle> In Proc. 17th Internat. Colloq. Automata Lang. Program., volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 400-413. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The problem has also been addressed in computational geometry. The emphasis in the computational geometry literature has been on theoretically efficient intersection detection algorithms for pairs of objects at a single instance in time <ref> [AS90, Cha89, CD87, DK90, 3 Ede83] </ref>. For convex 3-polytopes 1 linear time algorithms based on linear programming [Meg83, Sei90] and tracking closest points [GJK88] have been proposed. More recently, temporal and geometric coherence has been used to devise algorithms based on checking local features of convex 3-polytopes [Bar90, Lin93].
Reference: [Duf92] <author> Tom Duff. </author> <title> Interval arithmetic and recursive subdivision for implicit functions and constructive solid geometry. </title> <journal> ACM Computer Graphics, </journal> <volume> 26(2) </volume> <pages> 131-139, </pages> <year> 1992. </year>
Reference-contexts: More recently, temporal and geometric coherence has been used to devise algorithms based on checking local features of convex 3-polytopes [Bar90, Lin93]. To handle curved models, algorithms based on interval arithmetic have been proposed by <ref> [Duf92, HBZ90, SWF + 93] </ref>. Faster algorithms using coherence have been proposed for curved models defined algebraically or using NURBs [LM93]. Algorithms for collision detection between single pairs of objects are often extended to multiple-object interactions.
Reference: [DZ93] <author> P. Dworkin and D. Zeltzer. </author> <title> A new model for efficient dynamics simulation. </title> <booktitle> Proceedings of the Fourth Eurographics Workshop on Animation and Simulation, </booktitle> <year> 1993. </year>
Reference-contexts: However, exact contact determination is required for realistic simulations, so this tradeoff is not always acceptable. In an early extension of their work Lin and Canny [LC92] proposed a scheduling scheme to handle multiple moving objects. Dworkin and Zeltzer extended this work for a sparse model <ref> [DZ93] </ref>. The model works well for sparse environments only and requires information about time-parameterized trajectories of the objects to predict the possible intersection. 3 Background In this section, we will first discuss the importance of coherence. <p> The first time a polytope pair is considered, we select a random feature from each polytope; otherwise we use previous closest feature pair as a starting point. This previous closest feature pair may not be a good guess when the polytope pair has just become active. Dworkin and Zeltzer <ref> [DZ93] </ref> suggest precomputing a lookup table for each polytope to help find better starting guesses. Our current collision detection implementation uses only the external Voronoi regions of the polytopes. <p> This is explained further in our discussion of Graph 5. The seconds per frame numbers in Graph 1 compare very favorably with the work of Dworkin and Zeltzer <ref> [DZ93] </ref> as well as those of Hubbard [Hub93]. For a 1000 polytopes in our simulation, our frame rate is 23 frames per second using the fixed bounding cubes. Graph 2 shows how the number faces affects the frame time. We took 20 uniformly sampled data points.
Reference: [Ede83] <author> H. Edelsbrunner. </author> <title> A new approach to rectangle intersections, Part I. </title> <journal> Internat. J. Comput. Math., </journal> <volume> 13 </volume> <pages> 209-219, </pages> <year> 1983. </year>
Reference-contexts: In computational geometry literature several algorithms exist that solve the static version of determining bounding box overlaps in O (nlog d1 n + s) time, where d is the dimension of the bounding boxes and s is the number of pairwise overlaps <ref> [Ede83, HSS83, SW82] </ref>. For 3-D bounding boxes we have reduced this from O (nlog 2 n + s) to O (n + s) by using coherence. 12 4.3 Two-Dimensional Intersection Tests The two-dimensional intersection algorithm begins by projecting each three-dimensional axis-aligned bounding box onto the x-y, x-z, and y-z planes.
Reference: [ETHA87] <author> M. Edahiro, K. Tanaka, R. Hoshino, and Ta. Asano. </author> <title> A bucketing algorithm for the orthogonal segment intersection search problem and its practical efficiency. </title> <booktitle> In Proc. 3rd Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 258-267, </pages> <year> 1987. </year>
Reference-contexts: They perform simple convex decompositions of the objects into voxels and place the objects into bounding boxes. They efficiently determine which top-level bounding boxes overlap, then examine them using lower-level voxel representation. 14 Edahiro et. al. <ref> [ETHA87] </ref> proposed a O (k) search time, O (n) preprocessing time bucket-ing algorithm for reporting all segment intersections with a given orthogonal query segment, where n is the number of orthogonal segments and k is the number of reported intersecting segments.
Reference: [GJK88] <author> E. G. Gilbert, D. W. Johnson, and S. S. Keerthi. </author> <title> A fast procedure for computing the distance between objects in three-dimensional space. </title> <journal> IEEE J. Robotics and Automation, </journal> <volume> vol RA-4:pp. </volume> <pages> 193-203, </pages> <year> 1988. </year>
Reference-contexts: The emphasis in the computational geometry literature has been on theoretically efficient intersection detection algorithms for pairs of objects at a single instance in time [AS90, Cha89, CD87, DK90, 3 Ede83]. For convex 3-polytopes 1 linear time algorithms based on linear programming [Meg83, Sei90] and tracking closest points <ref> [GJK88] </ref> have been proposed. More recently, temporal and geometric coherence has been used to devise algorithms based on checking local features of convex 3-polytopes [Bar90, Lin93]. To handle curved models, algorithms based on interval arithmetic have been proposed by [Duf92, HBZ90, SWF + 93].
Reference: [Hah88] <author> J. K. Hahn. </author> <title> Realistic animation of rigid bodies. </title> <journal> Computer Graphics, </journal> <volume> 22(4):pp. </volume> <pages> 299-308, </pages> <year> 1988. </year>
Reference: [HBZ90] <author> B. V. Herzen, A. H. Barr, and H. R. Zatz. </author> <title> Geometric collisions for time-dependent parametric surfaces. </title> <journal> Computer Graphics, </journal> <volume> 24(4) </volume> <pages> 39-48, </pages> <year> 1990. </year>
Reference-contexts: More recently, temporal and geometric coherence has been used to devise algorithms based on checking local features of convex 3-polytopes [Bar90, Lin93]. To handle curved models, algorithms based on interval arithmetic have been proposed by <ref> [Duf92, HBZ90, SWF + 93] </ref>. Faster algorithms using coherence have been proposed for curved models defined algebraically or using NURBs [LM93]. Algorithms for collision detection between single pairs of objects are often extended to multiple-object interactions.
Reference: [Hof89] <author> C.M. Hoffmann. </author> <title> Geometric and Solid Modeling. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1989. </year>
Reference: [HSS83] <author> J.E. Hopcroft, J.T. Schwartz, and M. Sharir. </author> <title> Efficient detection of intersections among spheres. </title> <journal> The International Journal of Robotics Research, </journal> <volume> 2(4) </volume> <pages> 77-80, </pages> <year> 1983. </year>
Reference-contexts: In computational geometry literature several algorithms exist that solve the static version of determining bounding box overlaps in O (nlog d1 n + s) time, where d is the dimension of the bounding boxes and s is the number of pairwise overlaps <ref> [Ede83, HSS83, SW82] </ref>. For 3-D bounding boxes we have reduced this from O (nlog 2 n + s) to O (n + s) by using coherence. 12 4.3 Two-Dimensional Intersection Tests The two-dimensional intersection algorithm begins by projecting each three-dimensional axis-aligned bounding box onto the x-y, x-z, and y-z planes.
Reference: [Hub93] <author> P. M. Hubbard. </author> <title> Interactive collision detection. </title> <booktitle> In Proceedings of IEEE Symposium on Research Frontiers in Virtual Reality, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: Moreover, we do not restrict ourselves to the sparse environment only, because in many interesting environments (e.g. vibrating parts feeder bowl) this assumption does not hold. Nor do we make any assumptions about object velocity or acceleration as required by a space-time approach <ref> [Hub93] </ref>; this type of information may be available in a simulation but is typically absent in a truly interactive virtual environment. The algorithms makes use of spatial and temporal coherence between successive instances and works very well in practice, whenever the collision detection routine is called at small time intervals. <p> This approach works well for sparse environments in which the objects are uniformly distributed through the space. Object space coherence has been used extensively in ray tracing for the past decade [SML90]. Another approach operates directly on four-dimensional volumes swept out by object motion over time <ref> [Cam90, Hub93] </ref>. This is difficult not only to visualize, but to model as well, especially when the motion is complex and abrupt. In addition, computing the intersection of complex hyper-cones induced by acceleration or uncertainty of position is non-trivial. <p> An interactive, large-scaled virtual environment poses a new challenge to the detection problem because it requires performance at interactive rates for thousands of pairwise tests. Very recently, Hubbard has proposed a solution to address this problem by an interactive collision detection algorithm that trades accuracy for speed <ref> [Hub93] </ref>. However, exact contact determination is required for realistic simulations, so this tradeoff is not always acceptable. In an early extension of their work Lin and Canny [LC92] proposed a scheduling scheme to handle multiple moving objects. Dworkin and Zeltzer extended this work for a sparse model [DZ93]. <p> The number of levels in a tree is limited to the geometric complexity of the object. Exact contact status between two trees is determined by the exact collision detection between their convex sub-parts. This differs from Hubbard's approach <ref> [Hub93] </ref> which creates some number of nested levels of bounding spheres to achieve an approximate solution to a desired accuracy; our approach finds the exact collision points. 4 Collision Detection for Multiple Objects Virtual environments contain both stationary and moving objects. <p> This is explained further in our discussion of Graph 5. The seconds per frame numbers in Graph 1 compare very favorably with the work of Dworkin and Zeltzer [DZ93] as well as those of Hubbard <ref> [Hub93] </ref>. For a 1000 polytopes in our simulation, our frame rate is 23 frames per second using the fixed bounding cubes. Graph 2 shows how the number faces affects the frame time. We took 20 uniformly sampled data points.
Reference: [KWBB93] <author> Kass, Witkin, Baraff, and Barr. </author> <title> An introduction to physically based modeling. </title> <booktitle> Course Notes 60, </booktitle> <year> 1993. </year>
Reference: [Lat91] <author> J.C. Latombe. </author> <title> Robot Motion Planning. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Section 5 describes the implementation of our algorithm. Section 6 presents our experimental results on architectural walkthrough environments and simulations. 2 Previous Work The problem of collision detection has extensively studied in robotics. However, the goal here has been the planning of collision-free trajectories between obstacles <ref> [Can86, Lat91, LPW79, Sha87] </ref>. This differs from virtual environments and physically-based simulations, where the motion is subject to dynamic constraints or external forces and cannot typically be expressed as a closed form function of time . The problem has also been addressed in computational geometry.
Reference: [LC92] <author> M.C. Lin and John F. Canny. </author> <title> Efficient collision detection for animation. </title> <booktitle> In Proceedings of the Third Eurographics Workshop on Animation and Simulation, 1992. </booktitle> <address> Cambridge, England. </address>
Reference-contexts: Very recently, Hubbard has proposed a solution to address this problem by an interactive collision detection algorithm that trades accuracy for speed [Hub93]. However, exact contact determination is required for realistic simulations, so this tradeoff is not always acceptable. In an early extension of their work Lin and Canny <ref> [LC92] </ref> proposed a scheduling scheme to handle multiple moving objects. Dworkin and Zeltzer extended this work for a sparse model [DZ93]. <p> Combining temporal and geometric coherence with this observation has resulted in some efficient collision detection schemes between single pairs of objects [Bar90, Lin93, LM93]. 3.2 Pairwise Collision Detection for Convex Polytopes Here we will review an efficient collision detection algorithm which tracks closest points between pairs of convex polytopes <ref> [LC92, Lin93] </ref>. This algorithm is used at the second level of collision detection to determine the exact contact status between convex polytopes. The method maintains a pair of closest features (vertex, edge, or face) for each convex polytope pair and calculates the Euclidean distance between the features to detect collisions. <p> One of the first approaches we implemented uses a priority queue (implemented as a heap) sorted by the lower bound on the expected time to collision <ref> [LC92, Lin93] </ref>. This works well for a sparse simulation environment where very few collisions are occurring. However, as the number of objects increases, the number of "near misses" increases as well.
Reference: [Lev66] <author> C. Leventhal. </author> <title> Molecular model-building by computer. </title> <journal> Scientific American, </journal> <volume> 214(6), </volume> <month> June </month> <year> 1966. </year>
Reference-contexts: Different methods have been proposed to overcome the bottleneck of O (n 2 ) pairwise tests in an environment of n bodies. The simplest of these are based on spatial subdivision <ref> [BF79, Lev66] </ref>. The space is divided into cells of equal volume, and at each instance the objects are assigned to one or more cells. Collisions are checked between all object pairs belonging to a particular cell. <p> In addition, the velocity and acceleration information is not readily available in a truly interactive environment, such as the architectural walkthrough environment. Several practical and efficient algorithms are based on uniform space division. We divide space into unit cells (or volumes) and place each object in some cell (s) <ref> [BF79, Lev66] </ref>. To check for collisions, we examine the cell (s) occupied by each object to verify if the cell (s) is (are) shared by other objects. But, it is difficult to set a near-optimal size for each cell and it requires tremendous amount of allocated memory. <p> If the size of the cell is not properly chosen, the computation can be rather expensive. For an environment where almost all objects are of uniform size and fat [Ove92], like a vibrating parts feeder bowl, or molecular modeling application <ref> [Lev66, Tur89] </ref>, this algorithm is ideal, especially for execution on a parallel machine. Alonso et. al. [ASF94] have an algorithm that combines space partitioning with hierarchical bounding boxes. The running time of their approach depends on the complexity and size of the objects being considered for collision detection.
Reference: [Lin93] <author> M. C. Lin. </author> <title> Efficient Collision Detection for Animation and Robotics. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, </institution> <month> December </month> <year> 1993. </year> <institution> Department of Electrical Engineering and Computer Science. </institution>
Reference-contexts: For convex 3-polytopes 1 linear time algorithms based on linear programming [Meg83, Sei90] and tracking closest points [GJK88] have been proposed. More recently, temporal and geometric coherence has been used to devise algorithms based on checking local features of convex 3-polytopes <ref> [Bar90, Lin93] </ref>. To handle curved models, algorithms based on interval arithmetic have been proposed by [Duf92, HBZ90, SWF + 93]. Faster algorithms using coherence have been proposed for curved models defined algebraically or using NURBs [LM93]. <p> In general, however, most configurations of a simulation have far fewer than O (n 2 ) collisions. Combining temporal and geometric coherence with this observation has resulted in some efficient collision detection schemes between single pairs of objects <ref> [Bar90, Lin93, LM93] </ref>. 3.2 Pairwise Collision Detection for Convex Polytopes Here we will review an efficient collision detection algorithm which tracks closest points between pairs of convex polytopes [LC92, Lin93]. This algorithm is used at the second level of collision detection to determine the exact contact status between convex polytopes. <p> Combining temporal and geometric coherence with this observation has resulted in some efficient collision detection schemes between single pairs of objects [Bar90, Lin93, LM93]. 3.2 Pairwise Collision Detection for Convex Polytopes Here we will review an efficient collision detection algorithm which tracks closest points between pairs of convex polytopes <ref> [LC92, Lin93] </ref>. This algorithm is used at the second level of collision detection to determine the exact contact status between convex polytopes. The method maintains a pair of closest features (vertex, edge, or face) for each convex polytope pair and calculates the Euclidean distance between the features to detect collisions. <p> In this case, the running time is proportional to the number of feature pairs traversed in this process. Because the Euclidean distance between feature pairs must always decrease when a switch is made <ref> [Lin93] </ref>, cycling is impossible for non-penetrating objects. An example of this algorithm is given in Fig. 3. <p> As a precomputation, we compute each object's initial minima and maxima. Then as an object moves, we recompute its minima and maxima as follows: Method 1 - We can use a modified routine from the exact collision detection algorithm described in Sec 3.2.2 or <ref> [Lin93] </ref>. We can set up 6 imaginary boundary walls. Each of these walls is located at a minimal or maximal x, y, or z-coordinate possible in the environment. <p> One of the first approaches we implemented uses a priority queue (implemented as a heap) sorted by the lower bound on the expected time to collision <ref> [LC92, Lin93] </ref>. This works well for a sparse simulation environment where very few collisions are occurring. However, as the number of objects increases, the number of "near misses" increases as well.
Reference: [LM93] <author> M.C. Lin and Dinesh Manocha. </author> <title> Interference detection between curved objects for computer animation. </title> <booktitle> In Models and Techniques in Computer Animation, </booktitle> <pages> pages 43-57. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <month> 26 </month>
Reference-contexts: To handle curved models, algorithms based on interval arithmetic have been proposed by [Duf92, HBZ90, SWF + 93]. Faster algorithms using coherence have been proposed for curved models defined algebraically or using NURBs <ref> [LM93] </ref>. Algorithms for collision detection between single pairs of objects are often extended to multiple-object interactions. An early algorithm of complexity O (n 2 m 2 ), where n is the number of polyhedra with m vertices per polyhedron, is described in [MW88]. <p> In general, however, most configurations of a simulation have far fewer than O (n 2 ) collisions. Combining temporal and geometric coherence with this observation has resulted in some efficient collision detection schemes between single pairs of objects <ref> [Bar90, Lin93, LM93] </ref>. 3.2 Pairwise Collision Detection for Convex Polytopes Here we will review an efficient collision detection algorithm which tracks closest points between pairs of convex polytopes [LC92, Lin93]. This algorithm is used at the second level of collision detection to determine the exact contact status between convex polytopes.
Reference: [LPW79] <author> T. Lozano-Perez and M. Wesley. </author> <title> An algorithm for planning collision-free paths among polyhedral obstacles. </title> <journal> Comm. ACM, </journal> <volume> 22(10):pp. </volume> <pages> 560-570, </pages> <year> 1979. </year>
Reference-contexts: Section 5 describes the implementation of our algorithm. Section 6 presents our experimental results on architectural walkthrough environments and simulations. 2 Previous Work The problem of collision detection has extensively studied in robotics. However, the goal here has been the planning of collision-free trajectories between obstacles <ref> [Can86, Lat91, LPW79, Sha87] </ref>. This differs from virtual environments and physically-based simulations, where the motion is subject to dynamic constraints or external forces and cannot typically be expressed as a closed form function of time . The problem has also been addressed in computational geometry.
Reference: [Meg83] <author> N. Megiddo. </author> <title> Linear-time algorithms for linear programming in r 3 and related problems. </title> <journal> SIAM J. Computing, </journal> <volume> 12:pp. </volume> <pages> 759-776, </pages> <year> 1983. </year>
Reference-contexts: The emphasis in the computational geometry literature has been on theoretically efficient intersection detection algorithms for pairs of objects at a single instance in time [AS90, Cha89, CD87, DK90, 3 Ede83]. For convex 3-polytopes 1 linear time algorithms based on linear programming <ref> [Meg83, Sei90] </ref> and tracking closest points [GJK88] have been proposed. More recently, temporal and geometric coherence has been used to devise algorithms based on checking local features of convex 3-polytopes [Bar90, Lin93]. To handle curved models, algorithms based on interval arithmetic have been proposed by [Duf92, HBZ90, SWF + 93].
Reference: [MW88] <author> M. Moore and J. Wilhelms. </author> <title> Collision detection and response for computer animation. </title> <journal> Computer Graphics, </journal> <volume> 22(4) </volume> <pages> 289-298, </pages> <year> 1988. </year>
Reference-contexts: Algorithms for collision detection between single pairs of objects are often extended to multiple-object interactions. An early algorithm of complexity O (n 2 m 2 ), where n is the number of polyhedra with m vertices per polyhedron, is described in <ref> [MW88] </ref>. Different methods have been proposed to overcome the bottleneck of O (n 2 ) pairwise tests in an environment of n bodies. The simplest of these are based on spatial subdivision [BF79, Lev66].
Reference: [Ove92] <author> M. H. Overmars. </author> <title> Point location in fat subdivisions. </title> <journal> Inform. Proc. Lett., </journal> <volume> 44 </volume> <pages> 261-265, </pages> <year> 1992. </year>
Reference-contexts: We define this axis-aligned cube by a center and a radius. Fixed cubes are easy to recompute as objects move, making them well-suited to dynamic environments. If an object is nearly spherical, or "fat" <ref> [Ove92] </ref>, the fixed cube fits it well. As preprocessing steps we calculate the center and radius of the fixed cube. At each time step, as the object moves we recompute the cube as follows: 1. Transform the center using one vector-matrix multiplication. 10 2. <p> But, it is difficult to set a near-optimal size for each cell and it requires tremendous amount of allocated memory. If the size of the cell is not properly chosen, the computation can be rather expensive. For an environment where almost all objects are of uniform size and fat <ref> [Ove92] </ref>, like a vibrating parts feeder bowl, or molecular modeling application [Lev66, Tur89], this algorithm is ideal, especially for execution on a parallel machine. Alonso et. al. [ASF94] have an algorithm that combines space partitioning with hierarchical bounding boxes. <p> In fact, Overmars has shown that using a hashing scheme to look up entries and variable sizes (levels) for cubes or cells, we can use a data structure of O (n) storage space to perform the point location queries in constant time <ref> [Ove92] </ref>. This approach works especially well if the objects are both fat and not intersecting, since the assumption behind the basic algorithm depends on the fact that each cube or cell can only be occupied by a fixed number of objects.
Reference: [Pen90] <author> A. Pentland. </author> <title> Computational complexity versus simulated environment. </title> <journal> Computer Graphics, </journal> <volume> 22(2) </volume> <pages> 185-192, </pages> <year> 1990. </year>
Reference-contexts: Because of these unconstrained variables, collision detection is currently considered to be one of the major bottlenecks in building interactive simulated environments <ref> [Pen90] </ref>. Main Contribution: We present algorithms for interactive and exact collision detection in large-scaled environments.
Reference: [PS85] <author> F.P. Preparata and M. I. Shamos. </author> <title> Computational Geometry. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: In addition, we precompute the Voronoi region for each feature. Definition: A Voronoi region (as shown in Fig. 2) associated with a feature is a set of points closer to that feature than to any others <ref> [PS85] </ref>. The Voronoi regions form a partition of space outside the polytope according to the closest feature. The collection of Voronoi regions of each polytope is the generalized Voronoi diagram of the polytope.
Reference: [PW90] <author> A. Pentland and J. Williams. </author> <title> Good vibrations: Modal dynamics for graphics and animation. </title> <journal> Computer Graphics, </journal> <volume> 23(3) </volume> <pages> 185-192, </pages> <year> 1990. </year>
Reference: [SML90] <author> A. Schmitt, H.M. Muuller, and W. </author> <title> Leister Ray tracing algorithms: </title> <booktitle> theory and practice Theoretical Foundations of Computer Graphics and CAD vol. F40, </booktitle> <pages> pages 997-1030, </pages> <publisher> Springer-Verlag 1988. </publisher>
Reference-contexts: Collisions are checked between all object pairs belonging to a particular cell. This approach works well for sparse environments in which the objects are uniformly distributed through the space. Object space coherence has been used extensively in ray tracing for the past decade <ref> [SML90] </ref>. Another approach operates directly on four-dimensional volumes swept out by object motion over time [Cam90, Hub93]. This is difficult not only to visualize, but to model as well, especially when the motion is complex and abrupt.
Reference: [Sei90] <author> R. Seidel. </author> <title> Linear programming and convex hulls made easy. </title> <booktitle> In Proc. 6th Ann. ACM Conf. on Computational Geometry, </booktitle> <pages> pages 211-215, </pages> <address> Berkeley, California, </address> <year> 1990. </year>
Reference-contexts: The emphasis in the computational geometry literature has been on theoretically efficient intersection detection algorithms for pairs of objects at a single instance in time [AS90, Cha89, CD87, DK90, 3 Ede83]. For convex 3-polytopes 1 linear time algorithms based on linear programming <ref> [Meg83, Sei90] </ref> and tracking closest points [GJK88] have been proposed. More recently, temporal and geometric coherence has been used to devise algorithms based on checking local features of convex 3-polytopes [Bar90, Lin93]. To handle curved models, algorithms based on interval arithmetic have been proposed by [Duf92, HBZ90, SWF + 93].
Reference: [SH76] <author> M. I. Shamos and D. Hoey. </author> <title> Geometric intersection problems. </title> <booktitle> In Proc. 17th Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 208-215, </pages> <year> 1976. </year>
Reference: [Sha87] <author> M. Sharir. </author> <title> Efficient algorithms for planning purely translational collision-free motion in two and three dimensions. </title> <booktitle> In Proc. IEEE Internat. Conf. Robot. Autom., </booktitle> <pages> pages 1326-1331, </pages> <year> 1987. </year>
Reference-contexts: Section 5 describes the implementation of our algorithm. Section 6 presents our experimental results on architectural walkthrough environments and simulations. 2 Previous Work The problem of collision detection has extensively studied in robotics. However, the goal here has been the planning of collision-free trajectories between obstacles <ref> [Can86, Lat91, LPW79, Sha87] </ref>. This differs from virtual environments and physically-based simulations, where the motion is subject to dynamic constraints or external forces and cannot typically be expressed as a closed form function of time . The problem has also been addressed in computational geometry.
Reference: [SW82] <author> H. W. Six and D. Wood. </author> <title> Counting and reporting intersections of d-ranges. </title> <journal> IEEE Trans. on Computers, C-31(No. </journal> <volume> 3), </volume> <month> March </month> <year> 1982. </year>
Reference-contexts: In computational geometry literature several algorithms exist that solve the static version of determining bounding box overlaps in O (nlog d1 n + s) time, where d is the dimension of the bounding boxes and s is the number of pairwise overlaps <ref> [Ede83, HSS83, SW82] </ref>. For 3-D bounding boxes we have reduced this from O (nlog 2 n + s) to O (n + s) by using coherence. 12 4.3 Two-Dimensional Intersection Tests The two-dimensional intersection algorithm begins by projecting each three-dimensional axis-aligned bounding box onto the x-y, x-z, and y-z planes.
Reference: [SWF + 93] <author> J. Snyder, A. Woodbury, K. Fleischer, B. Currin, and A. </author> <title> Bar. Interval methods for multi-point collisions between time dependent curved surfaces. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 321-334, </pages> <year> 1993. </year>
Reference-contexts: More recently, temporal and geometric coherence has been used to devise algorithms based on checking local features of convex 3-polytopes [Bar90, Lin93]. To handle curved models, algorithms based on interval arithmetic have been proposed by <ref> [Duf92, HBZ90, SWF + 93] </ref>. Faster algorithms using coherence have been proposed for curved models defined algebraically or using NURBs [LM93]. Algorithms for collision detection between single pairs of objects are often extended to multiple-object interactions.
Reference: [TN87] <author> W. Thibault and B. Naylor. </author> <title> Set operations on polyhedra using binary space partitioning trees. </title> <journal> ACM Computer Graphics, </journal> <volume> (4), </volume> <year> 1987. </year>
Reference-contexts: Therefore, reporting intersections among n rectangles can be done in O (nlogn+K) where K is the total number of intersecting rectangles. 4.4 Alternatives to Dimension Reduction There are many different methods for reducing the number of pair-wise tests, such as binary space partitioning (BSP) trees <ref> [TN87] </ref>, octrees, etc. We are currently considering other approaches for the virtual prototyping of mechanical parts/tools design and simulation, where hundreds of mechanical parts are rotating and translating in a vibrating bowl.
Reference: [Tur89] <author> G. Turk. </author> <title> Interactive collision detection for molecular graphics. </title> <type> Master's thesis, </type> <institution> Computer Science Department, University of North Carolina at Chapel Hill, </institution> <year> 1989. </year>
Reference-contexts: If the size of the cell is not properly chosen, the computation can be rather expensive. For an environment where almost all objects are of uniform size and fat [Ove92], like a vibrating parts feeder bowl, or molecular modeling application <ref> [Lev66, Tur89] </ref>, this algorithm is ideal, especially for execution on a parallel machine. Alonso et. al. [ASF94] have an algorithm that combines space partitioning with hierarchical bounding boxes. The running time of their approach depends on the complexity and size of the objects being considered for collision detection.
Reference: [Zel92] <author> D. Zeltzer. </author> <title> Autonomy, interaction and presence. Presence, </title> <address> 1(1):127, </address> <year> 1992. </year> <month> 28 </month>
Reference-contexts: This is not acceptable for virtual environments, where the issues of interactivity impose fundamental constraints on the system <ref> [Zel92] </ref>. A fast and interactive collision detection algorithm is a fundamental component of a large-scaled virtual environment. Fig. 1 shows a typical walkthrough environment. Complex simulations involve many objects moving according to some physical parameters.
References-found: 43

