URL: http://www.cs.brown.edu/courses/cs227/papers/b0/KOLA.ps
Refering-URL: http://www.cs.brown.edu/courses/cs227/readinglist.html
Root-URL: http://www.cs.brown.edu/
Title: Form(ers) Over Function(s): The KOLA Reference Manual 0.1 Still To Do 6 more fold proofs,
Author: Mitch Cherniack 
Date: June 18, 1996  
Abstract-found: 0
Intro-found: 1
Reference: [CDG + 90] <author> Michael J. Carey, David J. DeWitt, Goetz Graefe, David M. Haight, Joel E. Richardson, Daniel T. Schuh, Eugene J. Shekita, and Scott L. Vandenberg. </author> <title> The EXODUS extensible DBMS project: An overview. </title> <editor> In Stanley B. Zdonik and David Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, </booktitle> <pages> pages 474-499. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Los Altos, California, </address> <year> 1990. </year>
Reference-contexts: our argument that a combinator-based algebra in general, and KOLA in particular is especially well-suited for the declarative expression of rules, thus making for a rule-based optimizer that is easier to reason about, prove correct and implement without errors. 2 Motivation: Variables Considered Harmful 2.1 Rule-Based Optimization Rule-based optimization ([Fre87], <ref> [CDG + 90] </ref>, [SJ90]) makes the optimization of a query occur in multiple and gradual steps. <p> While most rule-based optimizers adopt the unification style [FM95], few do so without added complexity. Rule languages frequently allow external procedures to be invoked as part of their firing. These procedures typically appear in one of two places: * Head Routines (called "conditions" in <ref> [CDG + 90] </ref> and "condition functions" in [HFLP89]) are invoked in the heads (left-hand sides) of rules and analyze query representations to decide if they should be transformed by rules. * Body Routines (called "support functions" in [CDG + 90] and "action routines" in [HFLP89]) are invoked in the bodies (right-hand <p> typically appear in one of two places: * Head Routines (called "conditions" in <ref> [CDG + 90] </ref> and "condition functions" in [HFLP89]) are invoked in the heads (left-hand sides) of rules and analyze query representations to decide if they should be transformed by rules. * Body Routines (called "support functions" in [CDG + 90] and "action routines" in [HFLP89]) are invoked in the bodies (right-hand sides) of rules and are used to transform matched query representations into alternative forms.
Reference: [CM93] <author> Sophie Cluet and Guido Moerkotte. </author> <title> Nested queries in object bases. </title> <booktitle> In Proc. 4th Int'l Workshop on Database Programming Languages, </booktitle> <address> New York, New York, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: The rules that we use for these transformations are generally applicable and perform the optimization in gradual steps, unlike the monolithic and overly specific rules that sometimes appear in the literature <ref> [CM93] </ref>.
Reference: [CZ95] <author> Mitch Cherniack and Stanley B. Zdonik. </author> <title> Combinator translations of queries. </title> <type> Technical Report 29 CS-95-40, </type> <institution> Brown University Department of Computer Science, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: This is not surprising given that variables are "small" (they occupy one node of a parse tree) and the functions that replace them in a KOLA translation are usually larger. We show in <ref> [CZ95] </ref> that the increase in query size is manageable because of the expressiveness of the KOLA combinator set and because queries are typically small (relative to programs for example). 5 Finally, it might also appear that we have paid a price in the number of rules that we require to express
Reference: [CZN95] <author> Mitch Cherniack, Stanley B. Zdonik, and Marian H. Nodine. </author> <title> To form a more perfect union (intersection, difference). </title> <booktitle> In Proc. 5th Int'l Workshop on Database Programming Languages, </booktitle> <address> Gubbio, Italy, </address> <month> September </month> <year> 1995. </year> <note> Springer-Verlag. To Appear. </note>
Reference-contexts: On the other hand, mutable objects should not be compared on the basis of their mutable states as this makes their identities ephemeral and provokes unintuitive behaviors in any sets that contain them <ref> [CZN95] </ref>. Rather, we assume that mutable objects have identifiers which are perhaps invisible to the user, but which are used at run-time to determine if they are affected by invocations of functions and to determine if they are equal to other objects. <p> For a full treatment on the implications of object equality on set behavior and the reasons why we make the assumptions stated here, the reader is referred to <ref> [CZN95] </ref>. Throughout the rest of this section, we informally describe the object types supported by the KOLA data model. Section 8.1 presents formal Larch specifications of the objects described. These specifications refer to specifications that are included as part of the Larch library such as Integer, Boolean, InsertGenerated and Set.
Reference: [Day87] <author> Umeshwar Dayal. </author> <title> Of nests and trees: A unified approach to processing queries that contain nested subqueries, aggregates and quantifiers. </title> <editor> In Peter M. Stocker, William Kent, and Peter Hammersley, editors, </editor> <booktitle> Proceedings if the 13th International Conference on Very Large Databases, </booktitle> <pages> pages 197-208, </pages> <address> Brighton, England, </address> <month> September </month> <year> 1987. </year> <month> Morgan-Kaufman. </month>
Reference-contexts: To ensure that the cardinality of the result of the nest is the same as the cardinality of A, many algebras introduce an outer join operator that associates NULL values with those members of A which never satisfy the join predicate (e.g. <ref> [Day87] </ref>). That is, NULLs preserve values of A that are needed in the nesting but are lost by the join.
Reference: [FM95] <author> Leonidas Fegaras and David Maier. </author> <title> Towards an effective calculus for object query languages. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <pages> pages 47-58, </pages> <year> 1995. </year>
Reference-contexts: The unification style approach is efficient, and simplifies the formulation of general rules, since the use of unification variables to denote arbitrary query components makes rules potentially applicable to large classes of similarly structured queries. While most rule-based optimizers adopt the unification style <ref> [FM95] </ref>, few do so without added complexity. Rule languages frequently allow external procedures to be invoked as part of their firing.
Reference: [Fre87] <author> Johann Christoph Freytag. </author> <title> A rule-based view of query optimization. </title> <editor> In Umeshwar Dayal and Irv Traiger, editors, </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 173-180, </pages> <address> San Francisco, California, </address> <month> May </month> <year> 1987. </year> <booktitle> ACM Special Interest Group on Management of Data, </booktitle> <publisher> ACM Press. </publisher>
Reference: [GHG + 92] <author> J.V. Guttag, J.J. Hornung, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specifications. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Since extensible optimizers have potentially non-trivial lifetimes, their formal specification helps to ensure that they can be understood by those that maintain them long after their initial development <ref> [GHG + 92] </ref>. Formal specifications also provide an opportunity for designs and implementations to be proved correct. In this paper, we consider how to design query optimizers with software engineering considerations in mind. <p> Section 4 lists the language constructs of KOLA and motivates their use. This informal description is made formal in Appendix B where we include a full formal specification of KOLA expressed in the Larch specification language, LSL <ref> [GHG + 92] </ref>. Appendix C is a list of identities that were proven using the axioms of this specification, and using the theorem proving tool of Larch, LP. <p> Section 8.1 presents formal Larch specifications of the objects described. These specifications refer to specifications that are included as part of the Larch library such as Integer, Boolean, InsertGenerated and Set. We omit these trait definitions, referring instead to their definitions as traits in the Larch library <ref> [GHG + 92] </ref>. 3.2 A Classification of Types and Objects Supported in the KOLA Data Model 3.2.1 Base Types The base types supported in KOLA are the immutable types Int (integers), Char (characters) and Str (strings). 2 . <p> We assume a standard interface for these types as is specified formally in the library traits (Integer and String) of Larch <ref> [GHG + 92] </ref>. 3.2.2 Class Types KOLA permits queries over sets of objects that are instances of class types. We assume a class definition to define an interface to which queries have access.
Reference: [HFLP89] <author> Laura M. Haas, J. C. Freytag, G. M. Lohman, and H. Pirahesh. </author> <title> Extensible query processing in Starburst. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <pages> pages 377-388, </pages> <year> 1989. </year>
Reference-contexts: Therefore, a set of rules can be edited safely as certain rules prove more or less useful in practice. Rules can simplify the formalization of optimizers. (In fact, rule sets are typically used as specifications for optimizer generators ([CDG + 90], <ref> [HFLP89] </ref>).) Rule sets are partial specifications of optimizers in that they specify possible outputs. Rule correctness proofs prove the correctness of that output. But not all rules can be formalized simply, nor efficiently manipulated. <p> Rule languages frequently allow external procedures to be invoked as part of their firing. These procedures typically appear in one of two places: * Head Routines (called "conditions" in [CDG + 90] and "condition functions" in <ref> [HFLP89] </ref>) are invoked in the heads (left-hand sides) of rules and analyze query representations to decide if they should be transformed by rules. * Body Routines (called "support functions" in [CDG + 90] and "action routines" in [HFLP89]) are invoked in the bodies (right-hand sides) of rules and are used to <p> * Head Routines (called "conditions" in [CDG + 90] and "condition functions" in <ref> [HFLP89] </ref>) are invoked in the heads (left-hand sides) of rules and analyze query representations to decide if they should be transformed by rules. * Body Routines (called "support functions" in [CDG + 90] and "action routines" in [HFLP89]) are invoked in the bodies (right-hand sides) of rules and are used to transform matched query representations into alternative forms. External procedures are necessary additions to rule languages when unification is insufficient to capture what queries should be matched by a rule and how matched queries should be transformed.
Reference: [LMS + 93] <author> Theodore W. Leung, Gail Mitchell, Bharathi Subramanian, Bennet Vance, Scott L. Vandenberg, and Stanley B. Zdonik. </author> <title> The AQUA data model and algebra. </title> <booktitle> In Proc. 4th Int'l Workshop on Database Programming Languages, </booktitle> <address> New York, New York, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: In particular, query representations based on variable-based query algebras (algebras that use variables to name manipulated data) make external procedures necessary as supplements to rules. We will argue this point through a series of examples that show why a rule language over one particular variable-based algebra, AQUA <ref> [LMS + 93] </ref> must be supplemented with external procedures to express some desirable transformations. We will begin by giving a brief overview of AQUA insomuch as it will make our examples understood. <p> In fact, every KOLA function that constructs a set constructs an immutable set. 2 I will soon add Float (floats) to this list once I find a suitable Larch specification for floats. 8 4 The KOLA Query Algebra 4.1 A Brief Overview of KOLA KOLA is inspired by AQUA 3 <ref> [LMS + 93] </ref> but is in the style of FP [Bac78]. KOLA is not a user-level language, and KOLA queries can be hard to read. But KOLA is well-suited as an internal algebra for rule based-optimizers.
Reference: [Mit93] <author> Gail Mitchell. </author> <title> Extensible Query Processing in an Object-Oriented Database. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Brown University, </institution> <address> Providence, Rhode Island 02912-1910, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: (p:children)]) (P ) Return the set of pairs of people in P with their children, (if the parent is over 25) or the empty set otherwise. 5 : apply ( (v) [v; flatten (apply ( (p) p:garages) (select ( (p) v 2 p:cars) (P )))]) (V ) The "Garage Query" <ref> [Mit93] </ref>: Return the set of garaging locations for each vehicle in V The function and predicate arguments (f and p) to these and other AQUA operators are denoted with -expressions. <p> children, (if the parent is over 25) or the empty set otherwise. 5 k : iterate (K (true); id + (flatten ffi iter (K (true); garages ffi snd) ffi (id + (iter (mem (fst + (cars ffi snd)); snd) ffi (id + K (P ))))))))) ! V The "Garage Query" <ref> [Mit93] </ref>: Return the set of garaging locations for each vehicle in V 4.4 Translations of the AQUA Queries of Section 2 We next show some example KOLA queries that use the primitives and formers listed above.

References-found: 11

