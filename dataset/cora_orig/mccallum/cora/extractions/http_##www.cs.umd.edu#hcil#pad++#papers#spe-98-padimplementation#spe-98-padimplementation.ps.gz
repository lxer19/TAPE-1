URL: http://www.cs.umd.edu/hcil/pad++/papers/spe-98-padimplementation/spe-98-padimplementation.ps.gz
Refering-URL: http://www.cs.umd.edu/hcil/pad++/papers/
Root-URL: 
Email: bederson@cs.umd.edu  meyer@cs.nyu.edu  
Title: Implementing a Zooming User Interface: Experience Building Pad++  
Author: Ben Bederson Jon Meyer 
Keyword: Zooming User Interfaces (ZUIs), Real-time Computer Graphics, Animation, 3D Graphics, Windowing Systems, User Interface Management Systems (UIMS), Pad++. Availability  
Web: http://www.cs.umd.edu/hcil/pad++  
Note: Pad++ is available for noncommercial (educational, research and in-house) use from  
Address: 3171 A.V. Williams Building College Park, MD 20742  719 Broadway, 12 th Floor New York, NY 10003  
Affiliation: University of Maryland Computer Science Deptartment Human-Computer Interaction Lab  New York University Computer Science Department Media Research Lab  
Abstract: We are investigating a novel user interface paradigm based on zooming, in which users are presented with a zooming view of a huge planar information surface. We have developed a system called Pad++ to explore this approach. The implementation of Pad++ is related to real-time 3D graphics systems and to 2D windowing systems. However, the zooming nature of Pad++ requires new approaches to rendering, screen management, and spatial indexing. In this paper, we describe the design and implementation of the Pad++ engine, focusing in particular on rendering and data structure issues. Our goal is to present useful techniques that can be adopted in other real-time graphical systems, and also to discuss how 2D zooming systems differ from other graphical systems. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Bederson, B. B., Hollan, J. D., Perlin, K., Meyer, J., Bacon, D., & Furnas, G.. </author> <title> Pad++: A zoomable graphical sketchpad for exploring alternate interface physics, </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 7, 331, </volume> <year> 1996. </year>
Reference-contexts: In Pad++, all the fonts used with the renderer share two global fontcaches. It would be possible to allocate a separate fontcache for each font, though this is expensive since each fontcache requires 96 bitmaps that are 100x100 pixels <ref> (implemented with a single 9600x100 bitmap, approximately 100 kilobytes in size) </ref>. The fontcache mechanism accelerates rendering of smallsized text, which contains repeated uses of a character in the same font. <p> (int y = 0; y &lt; dst.height; y++) - long *srcPtr = src.data [y]; long *dstPtr = dst.data [(int)(y / scale)]; int *tablePtr = table; // SCALE THE ROW (UNROLLED) for (x = 0; x &lt; dst.width & ~7; x += 8) - dstPtr [0] = srcPtr [tablePtr [0]]; dstPtr <ref> [1] </ref> = srcPtr [tablePtr [1]]; dstPtr [2] = srcPtr [tablePtr [2]]; ... dstPtr [7] = srcPtr [tablePtr [7]]; dstPtr += 8; tablePtr += 8; - // FINISH THE ROW (-NOT- UNROLLED) for (; x &lt; dst.width; x++) *dstPtr++ = srcPtr [table [x]]; - A rough machine instruction count for the inner <p> y &lt; dst.height; y++) - long *srcPtr = src.data [y]; long *dstPtr = dst.data [(int)(y / scale)]; int *tablePtr = table; // SCALE THE ROW (UNROLLED) for (x = 0; x &lt; dst.width & ~7; x += 8) - dstPtr [0] = srcPtr [tablePtr [0]]; dstPtr <ref> [1] </ref> = srcPtr [tablePtr [1]]; dstPtr [2] = srcPtr [tablePtr [2]]; ... dstPtr [7] = srcPtr [tablePtr [7]]; dstPtr += 8; tablePtr += 8; - // FINISH THE ROW (-NOT- UNROLLED) for (; x &lt; dst.width; x++) *dstPtr++ = srcPtr [table [x]]; - A rough machine instruction count for the inner loop of this version
Reference: 2. <author> Meyer, J., </author> <title> EtchaPad Disposable Sketch Based Interfaces, </title> <booktitle> Proceedings Companion of Human Factors in Computing Systems (CHI96), 195196, ACM, </booktitle> <address> New York, </address> <year> 1996. </year>
Reference-contexts: dst.height; y++) - long *srcPtr = src.data [y]; long *dstPtr = dst.data [(int)(y / scale)]; int *tablePtr = table; // SCALE THE ROW (UNROLLED) for (x = 0; x &lt; dst.width & ~7; x += 8) - dstPtr [0] = srcPtr [tablePtr [0]]; dstPtr [1] = srcPtr [tablePtr [1]]; dstPtr <ref> [2] </ref> = srcPtr [tablePtr [2]]; ... dstPtr [7] = srcPtr [tablePtr [7]]; dstPtr += 8; tablePtr += 8; - // FINISH THE ROW (-NOT- UNROLLED) for (; x &lt; dst.width; x++) *dstPtr++ = srcPtr [table [x]]; - A rough machine instruction count for the inner loop of this version is: 2 <p> *srcPtr = src.data [y]; long *dstPtr = dst.data [(int)(y / scale)]; int *tablePtr = table; // SCALE THE ROW (UNROLLED) for (x = 0; x &lt; dst.width & ~7; x += 8) - dstPtr [0] = srcPtr [tablePtr [0]]; dstPtr [1] = srcPtr [tablePtr [1]]; dstPtr <ref> [2] </ref> = srcPtr [tablePtr [2]]; ... dstPtr [7] = srcPtr [tablePtr [7]]; dstPtr += 8; tablePtr += 8; - // FINISH THE ROW (-NOT- UNROLLED) for (; x &lt; dst.width; x++) *dstPtr++ = srcPtr [table [x]]; - A rough machine instruction count for the inner loop of this version is: 2 Memory lookup 1 Memory
Reference: 3. <author> Druin, A., Stewart, J., Proft, D., Bederson, B., and Hollan, J. D., KidPad: </author> <title> A Design Collaboration Between Children, </title> <booktitle> Technologists, and Educators, Proceedings of Human Factors in Computing Systems (CHI97), 463470, ACM, </booktitle> <address> New York, </address> <year> 1997. </year>
Reference: 4. <author> Sutherland, I. </author> <title> Sketchpad: A Man-Machine Graphical Communication System, </title> <type> Tech Report #296, </type> <institution> MIT Lincoln Labs, </institution> <address> Cambridge, MA, </address> <year> 1963. </year>
Reference-contexts: We have written elsewhere about applications we have built using Pad++ [1][2][3]. Background Zooming interfaces have a long intellectual history. Over 30 years ago, Ivan Sutherland showed the first interactive objectoriented 2D graphics system <ref> [4] </ref>. This visionary system, called Sketchpad, demonstrated many components of todays interfaces. It even provided rudimentary zooming: every drawn object could be scaled and rotated. Fifteen years later, the Spatial Data Management System (SDMS) [5] used zooming as an integral part of the interface.
Reference: 5. <author> Donelson, W. C. </author> <title> Spatial management of information, </title> <booktitle> Proceedings of Computer Graphics (SIGGRAPH 78) 203209, 1978, ACM, </booktitle> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Over 30 years ago, Ivan Sutherland showed the first interactive objectoriented 2D graphics system [4]. This visionary system, called Sketchpad, demonstrated many components of todays interfaces. It even provided rudimentary zooming: every drawn object could be scaled and rotated. Fifteen years later, the Spatial Data Management System (SDMS) <ref> [5] </ref> used zooming as an integral part of the interface. SDMS was the first system to use zooming through a two dimensional as a metaphor for finding information. SDMS supported two semantic levels - an Overview and a Zoom into Icon level.
Reference: 6. <author> Perlin, K., & Fox, D. </author> <title> Pad: An alternative approach to the computer interface, </title> <booktitle> Proceedings of Computer Graphics (SIGGRAPH 93) 5764, ACM, </booktitle> <address> New York, </address> <year> 1993. </year>
Reference-contexts: However, SDMS was implemented with custom hardware and consisted of several machines and displays integrated into a room with all of the controls organized around a single large chair. Eleven years later, a system called Pad <ref> [6] </ref> was developed and presented at an NSF workshop in 1989. Pad integrated zooming into a single program that ran on inexpensive hardware. <p> Testing if two bounding boxes intersect is cheap. A Pentium can performs hundreds of thousands of 2D bounding box intersection tests a second. So for medium sized datasets, performing bounding box checking alone is enough to yield good frame rates. Tabula Rasa [12] and the original Pad implementation <ref> [6] </ref> both use this approach.
Reference: 7. <author> Bederson, B. B., & Hollan, J. D., </author> <title> Pad++: A zooming graphical interface for exploring alternate interface physics, </title> <booktitle> Proceedings of User Interface Software and Technology (UIST 94) 1726, ACM, </booktitle> <address> New York, </address> <year> 1994. </year>
Reference-contexts: [y]; long *dstPtr = dst.data [(int)(y / scale)]; int *tablePtr = table; // SCALE THE ROW (UNROLLED) for (x = 0; x &lt; dst.width & ~7; x += 8) - dstPtr [0] = srcPtr [tablePtr [0]]; dstPtr [1] = srcPtr [tablePtr [1]]; dstPtr [2] = srcPtr [tablePtr [2]]; ... dstPtr <ref> [7] </ref> = srcPtr [tablePtr [7]]; dstPtr += 8; tablePtr += 8; - // FINISH THE ROW (-NOT- UNROLLED) for (; x &lt; dst.width; x++) *dstPtr++ = srcPtr [table [x]]; - A rough machine instruction count for the inner loop of this version is: 2 Memory lookup 1 Memory storage 11 Total <p> dst.data [(int)(y / scale)]; int *tablePtr = table; // SCALE THE ROW (UNROLLED) for (x = 0; x &lt; dst.width & ~7; x += 8) - dstPtr [0] = srcPtr [tablePtr [0]]; dstPtr [1] = srcPtr [tablePtr [1]]; dstPtr [2] = srcPtr [tablePtr [2]]; ... dstPtr <ref> [7] </ref> = srcPtr [tablePtr [7]]; dstPtr += 8; tablePtr += 8; - // FINISH THE ROW (-NOT- UNROLLED) for (; x &lt; dst.width; x++) *dstPtr++ = srcPtr [table [x]]; - A rough machine instruction count for the inner loop of this version is: 2 Memory lookup 1 Memory storage 11 Total ~3 instructions This is
Reference: 8. <author> Bederson, B.B, Hollan, J. D., Stewart, J., Rogers, D., Druin, A., Vick, D., Ring, L., Grose, E., Forsythe, C., </author> <title> A Zooming Web Browser, Human Factors and Web Development, </title> <editor> Eds.: Forsythe, C., Ratner, J., and Grose, E., </editor> <publisher> Lawrence Earlbaum, </publisher> <address> New Jersey , 1997. </address>
Reference: 9. <author> Card, S. K., Robertson, G. G., Mackinlay, J. D., </author> <title> The Information Visualizer, an Information Workspace, </title> <booktitle> Proceedings of Human Factors in Computing Systems (CHI91), 181188, ACM, </booktitle> <address> New York, </address> <year> 1991. </year> <month> 33 </month>
Reference-contexts: Several researchers have investigated full 3D interfaces, and these interfaces have implicitly used zooming, since when a user moves close to an object, that object appears bigger. A system developed at Xerox PARC called the Information Visualizer <ref> [9] </ref> made extensive use of 3D, and showed several applications which took direct advantage of the difference in scale available in 3D. We are aware of three other implementations of ZUIs. Two are specialized commercial products for World Wide Web navigation.
Reference: 10. <author> Perspecta, Inc., </author> <note> http://www.perspecta.com, 1997. </note>
Reference-contexts: We are aware of three other implementations of ZUIs. Two are specialized commercial products for World Wide Web navigation. They both use radial layouts to represent hierarchies of information <ref> [10] </ref>, [11]. The third, Tabula Rasa [12] is a Scheme based implementation created by David Fox in his Ph.D. thesis research at NYU. Other related systems include Self [13], ARK (Alternate Reality Kit) [14] and Xerox Rooms [15].
Reference: 11. <author> Merzcom, Inc., </author> <note> http://www.merzcom.com, 1997. </note>
Reference-contexts: We are aware of three other implementations of ZUIs. Two are specialized commercial products for World Wide Web navigation. They both use radial layouts to represent hierarchies of information [10], <ref> [11] </ref>. The third, Tabula Rasa [12] is a Scheme based implementation created by David Fox in his Ph.D. thesis research at NYU. Other related systems include Self [13], ARK (Alternate Reality Kit) [14] and Xerox Rooms [15].
Reference: 12. <author> Fox, D., Tab: </author> <title> The Tabula Rasa zooming user interface system. </title> <address> URL http://www.cat.nyu.edu/fox/tab.html, New York University, New York, </address> <year> 1997. </year>
Reference-contexts: We are aware of three other implementations of ZUIs. Two are specialized commercial products for World Wide Web navigation. They both use radial layouts to represent hierarchies of information [10], [11]. The third, Tabula Rasa <ref> [12] </ref> is a Scheme based implementation created by David Fox in his Ph.D. thesis research at NYU. Other related systems include Self [13], ARK (Alternate Reality Kit) [14] and Xerox Rooms [15]. <p> Testing if two bounding boxes intersect is cheap. A Pentium can performs hundreds of thousands of 2D bounding box intersection tests a second. So for medium sized datasets, performing bounding box checking alone is enough to yield good frame rates. Tabula Rasa <ref> [12] </ref> and the original Pad implementation [6] both use this approach.
Reference: 13. <author> Maloney, J. H. and Smith, R. B. </author> <title> Directness and Liveness in the Morphic User Interface Construction Environment, </title> <booktitle> Proceedings of User Interface Software and Technology (UIST 95) 2128, ACM, </booktitle> <address> New York, </address> <year> 1995. </year>
Reference-contexts: Two are specialized commercial products for World Wide Web navigation. They both use radial layouts to represent hierarchies of information [10], [11]. The third, Tabula Rasa [12] is a Scheme based implementation created by David Fox in his Ph.D. thesis research at NYU. Other related systems include Self <ref> [13] </ref>, ARK (Alternate Reality Kit) [14] and Xerox Rooms [15].
Reference: 14. <author> Smith, R. B. </author> <title> Experiences with the Alternate Reality Kit: An Example of the Tension Between Literalism and Magic, </title> <booktitle> Proceedings of the Human Factors in Computing Systems and Graphics Interface Conference, 6167, ACM, </booktitle> <address> New York, </address> <year> 1987. </year>
Reference-contexts: They both use radial layouts to represent hierarchies of information [10], [11]. The third, Tabula Rasa [12] is a Scheme based implementation created by David Fox in his Ph.D. thesis research at NYU. Other related systems include Self [13], ARK (Alternate Reality Kit) <ref> [14] </ref> and Xerox Rooms [15]. Like virtual window managers such as fvwm [16], these systems present the user with a 2D planar data surface which is much larger than a single screen, and which the user navigates by panning or by clicking on an iconic map.
Reference: 15. <author> Henderson, D. A. Jr. And Card, S. K. Rooms: </author> <title> The Use of Multiple Virtual Workspaces to Reduce Space Contention in a Window-Based Graphical User Interface, </title> <journal> IEEE Transactions on Graphics, </journal> <volume> 5 (3), 211243, </volume> <year> 1987. </year>
Reference-contexts: They both use radial layouts to represent hierarchies of information [10], [11]. The third, Tabula Rasa [12] is a Scheme based implementation created by David Fox in his Ph.D. thesis research at NYU. Other related systems include Self [13], ARK (Alternate Reality Kit) [14] and Xerox Rooms <ref> [15] </ref>. Like virtual window managers such as fvwm [16], these systems present the user with a 2D planar data surface which is much larger than a single screen, and which the user navigates by panning or by clicking on an iconic map. However they dont support smooth continuous zooming.
Reference: 16. <author> FVWM, </author> <note> http://www.hpc.uh.edu/fvwm, 1997. </note>
Reference-contexts: The third, Tabula Rasa [12] is a Scheme based implementation created by David Fox in his Ph.D. thesis research at NYU. Other related systems include Self [13], ARK (Alternate Reality Kit) [14] and Xerox Rooms [15]. Like virtual window managers such as fvwm <ref> [16] </ref>, these systems present the user with a 2D planar data surface which is much larger than a single screen, and which the user navigates by panning or by clicking on an iconic map. However they dont support smooth continuous zooming.
Reference: 17. <author> Architecture Review Board (ARB), </author> <title> OpenGL Reference Manual, </title> <publisher> Addison-Wesley, </publisher> <address> Massachusetts, </address> <year> 1992. </year>
Reference-contexts: Both must maintain high frame rates, perform animated navigation, handle scene management, clipping, and event propagation, and deal with large numbers of objects. It seems natural to base a ZUI implementation on a 3D graphics API, such as Inventor or OpenGL <ref> [17] </ref>. An advantage of this approach is that the ZUI can take advantage of hardware acceleration when it is available. In practice, while 3D programming interfaces such as OpenGL present a good starting point, they have a number of design traits that make their use in ZUIs challenging.
Reference: 18. <author> Haeberli, P., Segal, M., </author> <title> Texture Mapping as a Fundamental Drawing Primitive, </title> <booktitle> Fourth Eurographics Workshop on Rendering, </booktitle> <editor> (URL http://www.sgi.com/grafica/texmap/index.html), Cohen M., ed, </editor> <address> Paris, France, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Rendering several pages of text at once (for example in a zoomed out view) by drawing each polygons would be very slow. It is possible to draw each typeface into texture memory, and then use texture mapping as a way to generate scaled text in 3D <ref> [18] </ref>. For systems with hardware accelerated texture mapping, large quantities of text can be quickly handled using this technique. Unfortunately, texture memory is usually a scarce resource, so only a fairly small set of fonts can be supported in texture RAM.
Reference: 19. <author> Foley, J. D., van Dam, A., Feiner, S. K., Hughes, J. F., </author> <title> Computer Graphics: </title> <booktitle> Principles and Practice, </booktitle> <address> pp.992-996, </address> <publisher> Addison-Wesley, </publisher> <address> Massachusetts , 1990. </address>
Reference-contexts: To handle large windows effectively, applications must implement their own screen management schemes. To help applications carry out screen management, all the common windowing systems also provide clipping primitives that use Shape algebra <ref> [19] </ref>, which lets applications clip 2D graphic operations to arbitrary polygonal shapes. Shape algebra is useful because it supports efficient clipping and boolean operations. Using Shape algebra, applications can implement sophisticated screen management schemes. In a ZUI such as Pad++, screen management is further complicated by three factors.
Reference: 20. <author> Deyo, R.J., Briggs, A., and Doenges, P. </author> <title> Getting Graphics in Gear: Graphics and Dynamics in Driving Simulation, </title> <booktitle> Proceedings of Computer Graphics (SIGGRAPH '88), </booktitle> <volume> 24 (4), 317326, </volume> <publisher> ACM, </publisher> <address> New York, </address> <month> July </month> <year> 1988. </year>
Reference-contexts: Two representative types of 3D systems are vehicle simulators and architectural walkthrough systems. Vehicle simulators typically have strict framerate requirements, and have objects distributed fairly uniformly through space, frequently lying on a large two-dimensional surface <ref> [20] </ref>. Architectural walkthrough systems on the other hand, tend to have a large number of objects concentrated in a small three-dimensional space [21]. In most 3D systems, there can be a fairly wide range of sizes of objects, as both large structures and fine details must be represented.
Reference: 21. <author> Airey, J.M., Rohlf, J.H., and Brooks, F. P. Jr. </author> <title> Towards image realism with interactive update rates in complex virtual building environments, </title> <booktitle> ACM SIGGRAPH Special Issue on 1990 Symposium on Interactive 3D Graphics, </booktitle> <volume> 24 (2), 4150, </volume> <publisher> ACM, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Vehicle simulators typically have strict framerate requirements, and have objects distributed fairly uniformly through space, frequently lying on a large two-dimensional surface [20]. Architectural walkthrough systems on the other hand, tend to have a large number of objects concentrated in a small three-dimensional space <ref> [21] </ref>. In most 3D systems, there can be a fairly wide range of sizes of objects, as both large structures and fine details must be represented. Object visibility in 3D systems is determined by what is called the viewing frustum [22].
Reference: 22. <author> Angel, E., </author> <title> Interactive Computer Graphics, </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: In most 3D systems, there can be a fairly wide range of sizes of objects, as both large structures and fine details must be represented. Object visibility in 3D systems is determined by what is called the viewing frustum <ref> [22] </ref>. This is the truncated pyramid of space that can be seen from the current view position. It is truncated by near and far clipping planes so objects that are too near or too far from the view are clipped.
Reference: 23. <author> Funkhouser, T., Teller, S., Sequin, C., and Khorramabadi, D. </author> <title> The UC Berkeley System for Interactive Visualization of Large Architectural Models, Presence: </title> <booktitle> Teleoperators and Virtual Environments, </booktitle> <volume> 5 (1), </volume> <month> Winter </month> <year> 1996. </year>
Reference-contexts: For instance, in an architectural walkthrough of a room on one floor, no objects on any other floors are visible, and only a limited number of objects in other rooms on the same floor are visible <ref> [23] </ref>. Other 2D systems that maintain large numbers of objects and must quickly determine object visibility include integrated circuit design systems (VLSI) and geographical information systems (GIS). Both VLSI and GIS systems manage very large numbers of 2D objects and support limited forms of zooming.
Reference: 24. <author> Samet, H. </author> <title> The Design and Analysis of Spatial Data Structures, </title> <publisher> Addison-Wesley, </publisher> <address> Massachusetts, </address> <year> 1990. </year>
Reference: 25. <author> Samet, H. </author> <title> Applications of Spatial Data Structures: Computer Graphics, Image Processing, and GIS, </title> <publisher> Addison-Wesley, </publisher> <address> Massachusetts, </address> <year> 1990. </year>
Reference: 26. <author> Guttman, A. R-trees: </author> <title> A dynamic index structure for spatial searching, </title> <booktitle> Proceedings of the SIGMOD Conference, 4757, </booktitle> <address> Boston, </address> <month> June </month> <year> 1984. </year> <month> 34 </month>
Reference-contexts: There are several widely used spatial indexing algorithms (A survey of spatial indexing algorithms and their applications can be found in [24][25]). Many are hierarchical and are based on partitioning space in smaller and smaller segments. Algorithms include R-trees <ref> [26] </ref>, MX-CIF quad-trees [27], binary space partitioning trees [28] and k-d trees [29]. Each algorithm has maintenance (insertion and deletion) methods and query methods. Typically, there is a tradeoff in time between these methods where increasing the efficiency of one introduces a higher cost for the other.
Reference: 27. <author> Kedem, G. </author> <title> The quad-CIF tree: A data structure for hierarchical online algorithms, </title> <booktitle> Proceedings of the Nineteenth Design Automation Conference, 352357, </booktitle> <address> Las Vegas, </address> <month> June </month> <year> 1982. </year>
Reference-contexts: There are several widely used spatial indexing algorithms (A survey of spatial indexing algorithms and their applications can be found in [24][25]). Many are hierarchical and are based on partitioning space in smaller and smaller segments. Algorithms include R-trees [26], MX-CIF quad-trees <ref> [27] </ref>, binary space partitioning trees [28] and k-d trees [29]. Each algorithm has maintenance (insertion and deletion) methods and query methods. Typically, there is a tradeoff in time between these methods where increasing the efficiency of one introduces a higher cost for the other.
Reference: 28. <author> Fuchs H., Kedem, Z. M., and Naylor, B. F. </author> <title> On visible surface generation by a priori tree structures, </title> <journal> Computer Graphics 14 (3), </journal> <volume> 124133, </volume> <month> July </month> <year> 1980. </year>
Reference-contexts: There are several widely used spatial indexing algorithms (A survey of spatial indexing algorithms and their applications can be found in [24][25]). Many are hierarchical and are based on partitioning space in smaller and smaller segments. Algorithms include R-trees [26], MX-CIF quad-trees [27], binary space partitioning trees <ref> [28] </ref> and k-d trees [29]. Each algorithm has maintenance (insertion and deletion) methods and query methods. Typically, there is a tradeoff in time between these methods where increasing the efficiency of one introduces a higher cost for the other. <p> Objects with different depths are rendered in order according to their depth, with lower depth numbers being rendered first. This lets users specify overlapping constraints when they are important. Another possibility is to use binary space partition (BSP) trees <ref> [28] </ref> with the drawing order of each object representing its Z depth. This approach has the advantage of eliminating the sort entirely as BSP trees implicitly sort objects. However, maintaining BSP trees for dynamic scenes tends to be compute intensive.
Reference: 29. <author> Bentley, J.L., </author> <title> Multidimensional binary search trees used for associative searching, </title> <journal> Communications of the ACM (18), </journal> <volume> 509517, </volume> <publisher> ACM, </publisher> <address> New York, </address> <month> September </month> <year> 1975. </year>
Reference-contexts: Many are hierarchical and are based on partitioning space in smaller and smaller segments. Algorithms include R-trees [26], MX-CIF quad-trees [27], binary space partitioning trees [28] and k-d trees <ref> [29] </ref>. Each algorithm has maintenance (insertion and deletion) methods and query methods. Typically, there is a tradeoff in time between these methods where increasing the efficiency of one introduces a higher cost for the other.
Reference: 30. <author> Beckmann, N., Kriegel, H. P., Schneider, R., and Seeger, B. </author> <title> The R*-tree: An efficient and robust access method for points and rectangles, </title> <booktitle> Proceedings of the SIGMOD Conference, 322331, </booktitle> <address> Atlantic City, NJ, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: R-trees are similar to quad-trees except that they partition space into regions based on the 18 objects within the space, and not based on fixed-sized grids. R-trees are balanced so they have a guaranteed maximum depth. We chose to use R-trees rather than the more advanced R*-tree <ref> [30] </ref>. R*-trees produce more efficient structuring of regions, but they take longer to maintain. Since visible object determination is not the biggest factor determining rendering speeds (see Timing Results below), we decided to choose an algorithm which offers effective indexing and very fast insertion and deletion times.
Reference: 31. <author> Perlin, K., </author> <title> Layered Compositing of Facial Expression, </title> <booktitle> Visual Proceedings of Computer Graphics (SIGGRAPH '97), </booktitle> <pages> 226-227, </pages> <publisher> ACM, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: In addition, an interface to Java is under development. Most applications to date have been written in Tcl as that is the language we originally targeted, though we have also developed a procedural animation engine that runs within Pad++ and uses KPL <ref> [31] </ref>. While Pad++ now runs on Windows 95/NT, we originally designed and implemented Pad++ for UNIX with the X window system. It runs on many versions of UNIX, including Linux, SunOS, Solaris, IRIX, and FreeBSD.
Reference: 32. <author> Furnas, G. W. and Bederson, B. B. </author> <title> SpaceScale Diagrams: Understanding Multiscale Interfaces, </title> <booktitle> Proceedings of Human Factors in Computing Systems (CHI95), 234241, ACM, </booktitle> <address> New York, </address> <year> 1995. </year>
Reference-contexts: A user can very easily zoom out, pan a little, and then zoom in with the result that theyve covered a very wide expanse of space. SpaceScale Diagrams provide an analytical tool that is useful for describing and analyzing objects in scale space <ref> [32] </ref>. In Pad++, the view and object coordinates are stored with standard 32 bit floats that store roughly 7 orders of magnitude of resolution (+/-). So, we expect 14 orders of magnitude for zooming and panning.
References-found: 32

