URL: http://www.cs.toronto.edu/~david/papers-sqltp.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/papers.html
Root-URL: 
Email: david@cs.toronto.edu  
Title: Point-based Temporal Extension of SQL  
Author: David Toman 
Address: Toronto, Ontario, Canada M5S 1A4  
Affiliation: Department of Computer Science, University of Toronto  
Abstract: Most of the common proposals for temporal extensions of SQL (e.g., ATSQL2 or SQL/Temporal) use explicit interval-based references to time (interval attributes). In this paper we propose a different approach: we use point-based references to time as a basis for a temporal extension of SQL. The proposed language|SQL/TP|extends the syntax and semantics of SQL/92 in a very natural way: by adding a single new data type that represents the universe of individual time instants. Such an extension allows the users to write temporal queries in a customary fashion and vastly simplifies the semantics of the proposed language: we can essentially use the common SQL semantics. This way SQL/TP also fixes many problems present in query languages that use explicit interval-based temporal attributes. In addition, SQL/TP queries can still be efficiently evaluated over a compact interval-based encoding of possibly infinite temporal relations. The query evaluation is based on a compilation technique that translates SQL/TP queries to SQL/92. In this way existing database systems can be used for managing temporal data. We substantiate this claim by proposing an experimental version of a SQL/TP compiler to serve as a front-end for DB2 1 [13].
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abiteboul, S., Herr, L., Van den Bussche, J. </author> <title> Temporal versus First-Order Logic to Query Temporal Databases. </title> <booktitle> Proc. ACM PODS 1996, </booktitle> <pages> 49-57, </pages> <year> 1996. </year>
Reference-contexts: However, a single temporal dimension is not sufficient to formulate general temporal queries. Consider the query "are there two distinct time instants when a given relation contains exactly the same tuples?" (Section 3.3, query 3). <ref> [1] </ref> and [20] have independently shown that this query cannot be formulated in first-order temporal logic. A direct corollary of this result is that this query cannot be expressed in any single-dimensional temporal relational algebra 2 . <p> In this way our approach separates an abstract query language|SQL/TP|defined over a point-based linear model of time from the concrete interval-based encoding of timestamps which is mostly hidden from the user. The approach is based on several recent results in the area of temporal and constraint query languages <ref> [1, 15, 19, 20] </ref>. In addition, a meaningful duplicate semantics and aggregation can be naturally defined such a language independently from the particular encoding, e.g., using the results in [10, 11]. The two main design principles behind the new language are: 1. <p> Moreover, SQL/TP is complete in the sense of [8]. The results in <ref> [1, 20] </ref> show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal rela tional algebra, e.g., [7]. * Migration requirements [18], that require several levels of temporal upward compatibility with SQL; while SQL/TP itself does not literally follow all the requirements, the <p> It is easy to see that all the relational operations, with the exception of duplicate preserving projection, meet this requirement. However, the duplicate-preserving projection can produce such tables, e.g.: f ("Poland"; <ref> [1945; 1] </ref>)g k:k ! f ("Poland"; n) : n 1945g 1 ! f ("Poland"); : : : ; ("Poland"); : : :g The result of the projection contains infinite duplication of the tuple ("Poland"). <p> Thus SQL/TP can express queries, shown not to be expressible in TRA [7] or any temporal query language that assumes a fixed number of temporal dimensions in its data model, e.g., the query "List all pairs of time instants, when exactly the same countries were independent" <ref> [1, 20] </ref>. 3.3 Examples of Queries In this section we provide illustrative examples of SQL/TP queries. The examples are chosen to highlight the ease and naturality of formulating queries in SQL/TP. <p> The results in <ref> [1, 20] </ref> show that the two dimensionality is inherent to this query (this remains true even when we consider the existential closure of this query). 4.
Reference: [2] <author> Allen, J. F. </author> <title> Maintaining knowledge about temporal intervals. </title> <journal> Communications of the ACM, </journal> <volume> 26(11) </volume> <pages> 832-843, </pages> <year> 1983. </year>
Reference-contexts: temporal query languages violate both of the above principles, mainly by introducing constructs for explicit manipulation of the actual timestamp representation: both ATSQL [5] and SQL/Temporal [18] use the BEGIN and END keywords to extract the endpoints of intervals, PERIOD keyword to construct new interval timestamps, and Allen's interval algebra <ref> [2] </ref> operators to compare the timestamps. This is only possible if the user knows that the timestamps are encoded by intervals. In this paper we mostly concentrate on evaluation of temporal queries over the interval-based encoding of time. <p> Before we start the technical part of the paper, we would like to reiterate (to avoid any misunderstanding) that we are interested in intervals as encodings of sets on time instants. This is very different from the approaches taken in the various interval logics <ref> [2] </ref>, where intervals represent points in a two-dimensional (half-)space. However, due to the natural multidimensionality of SQL/TP, we can represent and query this view of intervals using two temporal dimensions (which would naturally correspond to the semantics of intervals in such logics).
Reference: [3] <author> Bohlen, M. H., Chomicki, J., Snodgrass, R. T., Toman, D. </author> <title> Querying TSQL2 Databases with Temporal Logic. </title> <booktitle> In Proc. EDBT'96, </booktitle> <volume> LNCS 1057, </volume> <pages> 325-341, </pages> <year> 1996. </year>
Reference-contexts: Indeed, in a single-dimensional case, the representation dependency problem is successfully evaded using coalescing [6] that produces a unique representation of single-dimensional temporal relations. Note that the TSQL2's informal semantics, including many TSQL2 queries, implicitly rely on this assumption <ref> [3, 17] </ref>. However, a single temporal dimension is not sufficient to formulate general temporal queries. <p> Using this result we can shoe that, e.g., the first-order temporal logic queries can be efficiently translated to SQL/TP: all the temporal operators can be translated into small fixed-size subqueries and views with exactly one temporal attribute <ref> [3] </ref>.
Reference: [4] <author> Bohlen, M. H., Jensen, C. S. </author> <title> Seamless Integration of Time into SQL. </title> <institution> University of Aalborg, </institution> <address> http://www.cs.auc.dk/ boehlen/Software/Tiger/atsql.ps.gz, </address> <year> 1996. </year>
Reference-contexts: Instead, compact encodings of sets of time instants (often called periods of validity) associated with a tuple are encoded by intervals [16, 18], bitemporal elements <ref> [4, 14] </ref>, or other fixed-dimensional products of intervals (hyper-rectangles). <p> tension between the syntax and the intended semantics of the languages, specifically: * References to time are realized using temporal attributes explicitly referring to intervals (or some other particular encoding of timestamps). 1 DB2 is a trademark of IBM Corp. 1 * The data model and the semantics are point-based <ref> [4, 9] </ref>: the intervals are used merely as compact descriptions of large sets of time instants (even in cases when one of the various duplicate semantics is used).
Reference: [5] <author> Bohlen, M. H., Jensen, C. S., Snodgrass, R. T. </author> <title> Evaluating and Enhancing the Completeness of TSQL2. </title> <type> Technical Report TR 95-5, </type> <institution> Computer Science Department, University of Arizona, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: another temporal extension of SQL? The last decade of research in temporal databases has led to the development of several temporal query languages based on extensions of existing relational languages, e.g., TQUEL [16] or various temporal extensions of SQL, most prominent of which are TSQL2 [17] and its variants: ATSQL2 <ref> [5] </ref> and the current proposal of temporal extension of SQL3 to the ISO and ANSI standardization committees|SQL/Temporal [18]. All the above languages are based on the timestamp view of temporal databases: every tuple is timestamped with the time at which the fact represented by the tuple holds [9]. <p> Note that most of the existing temporal query languages violate both of the above principles, mainly by introducing constructs for explicit manipulation of the actual timestamp representation: both ATSQL <ref> [5] </ref> and SQL/Temporal [18] use the BEGIN and END keywords to extract the endpoints of intervals, PERIOD keyword to construct new interval timestamps, and Allen's interval algebra [2] operators to compare the timestamps. This is only possible if the user knows that the timestamps are encoded by intervals.
Reference: [6] <author> Bohlen, M. H., Snodgrass, R. T., Soo, M. D. </author> <title> Coalescing in Temporal Databases. </title> <booktitle> Proc. 22nd Int. Conf. on Very Large Databases, </booktitle> <pages> 180-191, </pages> <year> 1996. </year>
Reference-contexts: Such an approach usually requires a normalization procedure on the encoding. Indeed, in a single-dimensional case, the representation dependency problem is successfully evaded using coalescing <ref> [6] </ref> that produces a unique representation of single-dimensional temporal relations. Note that the TSQL2's informal semantics, including many TSQL2 queries, implicitly rely on this assumption [3, 17]. However, a single temporal dimension is not sufficient to formulate general temporal queries. <p> Moreover, this problem cannot be avoided using a different normal form, as there is no unique coalescing-based normal form for dimension higher than one (for detailed discussion of coalescing see <ref> [6] </ref>). In addition, in many cases the user has no control over the representation of the intermediate results since the coalescing is implicitly performed by the system. <p> This problem goes hand in hand with defining various normal forms <ref> [6, 19] </ref> of temporal relations and enforcing them over updates 14 . * Can the standard indices built-in relational systems aid the query evaluation based on the proposed compilation technique? What are the tradeoffs comparing to specialized indices? Note that there are few answers to these questions even for the established
Reference: [7] <author> Clifford J., Croker A., Tuzhilin A. </author> <title> On Completeness of Historical Relational Query Languages. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 19, No. 1, </volume> <pages> 64-116, </pages> <year> 1994. </year>
Reference-contexts: Moreover, SQL/TP is complete in the sense of [8]. The results in [1, 20] show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal rela tional algebra, e.g., <ref> [7] </ref>. * Migration requirements [18], that require several levels of temporal upward compatibility with SQL; while SQL/TP itself does not literally follow all the requirements, the compatibility can be easily achieved using a very simple syntactic manipulation of the source queries, and adding tags to distinguish the particular compatibility modes, cf. <p> Theorem 3.7 The first-order fragment of SQL/TP is expressively equivalent to range restricted two-sorted first order logic (temporal relational calculus). Thus SQL/TP can express queries, shown not to be expressible in TRA <ref> [7] </ref> or any temporal query language that assumes a fixed number of temporal dimensions in its data model, e.g., the query "List all pairs of time instants, when exactly the same countries were independent" [1, 20]. 3.3 Examples of Queries In this section we provide illustrative examples of SQL/TP queries. <p> Using this result we can shoe that, e.g., the first-order temporal logic queries can be efficiently translated to SQL/TP: all the temporal operators can be translated into small fixed-size subqueries and views with exactly one temporal attribute [3]. Similar conclusion can be made about all TRA <ref> [7] </ref> based languages. 17 S 1 : "b": fxg [S 1 ;S 1 ;S 2 ] "a": S 2 : "b": fxg [S 2 ;S 1 ;S 2 ] "a": ? y except SQL/92 S 1 except S 2 : "a": View Definitions in SQL/TP.
Reference: [8] <author> Codd, E. F. </author> <title> Relational completeness of database sublanguages. In Rustin, R.(ed.) </title> <booktitle> Courant Computer Science Symposium 6: Data Base Systems, </booktitle> <pages> 65-98, </pages> <publisher> Prentice-Hall, </publisher> <year> 1972. </year>
Reference-contexts: Moreover, SQL/TP is complete in the sense of <ref> [8] </ref>. <p> This fact does not affect the generality of our proposal: we can show that the proposed fragment forms a (first-order) complete query language <ref> [8] </ref> and that all representation independent SQL/Temporal queries, including queries with aggregation, can be equivalently formulated in this fragment. 3.2.1 Syntax The chosen syntactic subset of SQL/TP uses two basic syntactic constructs: Select block.
Reference: [9] <author> Chomicki J. </author> <title> Temporal Query Languages: a Survey. </title> <booktitle> Proc. International Conference on Temporal Logic, </booktitle> <address> July 1994, Bonn, Germany, </address> <publisher> Springer-Verlag (LNAI 827), </publisher> <pages> 506-534. </pages>
Reference-contexts: All the above languages are based on the timestamp view of temporal databases: every tuple is timestamped with the time at which the fact represented by the tuple holds <ref> [9] </ref>. Moreover, all these proposals recognize that timestamping tuples with single time instants leads to enormous space requirements: a tuple would have to be repeated for every time instant at which the fact represented by the tuple holds. <p> tension between the syntax and the intended semantics of the languages, specifically: * References to time are realized using temporal attributes explicitly referring to intervals (or some other particular encoding of timestamps). 1 DB2 is a trademark of IBM Corp. 1 * The data model and the semantics are point-based <ref> [4, 9] </ref>: the intervals are used merely as compact descriptions of large sets of time instants (even in cases when one of the various duplicate semantics is used). <p> The rest of the paper is organized as follows: Section 2 introduces the temporal data model: the abstract and concrete interval-based temporal databases (following the terminology introduced in <ref> [9] </ref>). Section 3 defines the syntax and semantics of SQL/TP and gives examples of interesting temporal queries. We also include a discussion of compatibility modes that allow the migration of SQL queries to SQL/TP (Section 3.5). Section 4 gives a sketch of the proposed compilation technique. <p> Thus we summarily refer to those data types as the uninterpreted constants. The relationships between the time instants and the uninterpreted constants are captured in a finite set of temporal relations represented in a database. Following the terminology of <ref> [9] </ref> we distinguish the abstract temporal databases from the concrete temporal databases: Definition 2.1 (Abstract Temporal Databases) A signature of a relational symbol R is a tuple (a 1 : t 1 ; : : : ; a k : t k ) where a i are distinct attribute names, t
Reference: [10] <author> Chomicki, J., Kuper, G. M. </author> <title> Measuring Infinite Relations. </title> <booktitle> Proc. ACM PODS 1995, </booktitle> <pages> 78-85, </pages> <year> 1995. </year>
Reference-contexts: The approach is based on several recent results in the area of temporal and constraint query languages [1, 15, 19, 20]. In addition, a meaningful duplicate semantics and aggregation can be naturally defined such a language independently from the particular encoding, e.g., using the results in <ref> [10, 11] </ref>. The two main design principles behind the new language are: 1. The syntax and semantics of standard SQL has to be extended in a natural way: by adding a new data type to represent the universe of time instants. <p> For similar reasons we restrict the use of aggregate operations: we require the aggregated attribute to be independent of the group by attributes <ref> [10] </ref>. Moreover, the aggregation has to obey the restrictions in Figure 2. In addition we also restrict the use of duplicate-preserving projection on all temporal attributes encoded by intervals. We have already seen that duplicate-preserving projection is not possible for unbounded data types. <p> However, if we used a dense model of time, cnt would be a measure on sets and could return non-integral counts, e.g., 1.5 years. For details on aggregation and measures see <ref> [10] </ref>. Lemma 4.6 Given fixed E, G E, and ', the function cnt ' G can be defined using an integer expression over the value of x. The cnt function operates on a single tuples and thus contributes only a constant to the overall data complexity of queries.
Reference: [11] <author> Chomicki, J., Goldin, D. Q., Kuper, G. M. </author> <title> Variable Independence and Aggregation Closure. </title> <booktitle> Proc. ACM PODS 1996, </booktitle> <pages> 40-48, </pages> <year> 1996. </year>
Reference-contexts: The approach is based on several recent results in the area of temporal and constraint query languages [1, 15, 19, 20]. In addition, a meaningful duplicate semantics and aggregation can be naturally defined such a language independently from the particular encoding, e.g., using the results in <ref> [10, 11] </ref>. The two main design principles behind the new language are: 1. The syntax and semantics of standard SQL has to be extended in a natural way: by adding a new data type to represent the universe of time instants. <p> To avoid this problem we use the notion of attribute independence. Rather than a semantic definition of attribute independence <ref> [11] </ref> we use a syntactic inference system to detect attribute independence in a SQL/TP expression: Definition 3.3 (Attribute Independence) Let t 1 and t 2 be two temporal attributes in the signature of a SQL/TP expression exp.
Reference: [12] <author> Date, C. J., Drawen, H. </author> <title> A Guide to the SQL Standard (3rd ed.), </title> <address> Addison-Welsley, </address> <year> 1993. </year>
Reference-contexts: following requirements: * SQL/TP can be efficiently implemented on top of an interval-based representation of temporal databases: the performance of a SQL/TP system should be comparable to performance of SQL/Temporal [18] based DBMS on a vast majority of representation independent queries. * SQL/TP statements can be compiled to standard SQL/92 <ref> [12] </ref> 3 ; the translated queries can be evaluated using an off-shelf database system.
Reference: [13] <author> IBM Database 2, </author> <title> SQL Reference for common servers. </title> <institution> IBM Corp., </institution> <year> 1995. </year>
Reference: [14] <author> Jensen, C. S., Snodgrass, R. T., Soo, M. J. </author> <title> Unification of Temporal Data Models. </title> <booktitle> Proc. 9th Int. Conf. on Data Engineering, </booktitle> <pages> 262-271, </pages> <year> 1993. </year>
Reference-contexts: Instead, compact encodings of sets of time instants (often called periods of validity) associated with a tuple are encoded by intervals [16, 18], bitemporal elements <ref> [4, 14] </ref>, or other fixed-dimensional products of intervals (hyper-rectangles). <p> This fact combined with the use of explicit interval-valued temporal attributes leads directly to situations similar to the situation in Example 1.1. There are other reasons for including multiple temporal dimensions in a temporal database system, e.g., the need for representing both valid and transaction time <ref> [14] </ref>.
Reference: [15] <author> Kanellakis, P. C., Kuper, G. M., Revesz, </author> <title> P.Z . Constraint Query Languages. </title> <journal> Journal of Computer and System Sciences 51(1) </journal> <pages> 26-52, </pages> <year> 1995. </year>
Reference-contexts: In this way our approach separates an abstract query language|SQL/TP|defined over a point-based linear model of time from the concrete interval-based encoding of timestamps which is mostly hidden from the user. The approach is based on several recent results in the area of temporal and constraint query languages <ref> [1, 15, 19, 20] </ref>. In addition, a meaningful duplicate semantics and aggregation can be naturally defined such a language independently from the particular encoding, e.g., using the results in [10, 11]. The two main design principles behind the new language are: 1.
Reference: [16] <author> Snodgrass R. T. </author> <title> The Temporal Query Language TQuel. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2) </volume> <pages> 247-298, </pages> <month> June </month> <year> 1987. </year> <title> 14 In this paper we did not assume any particular normal form for the temporal relations. </title> <type> 20 </type>
Reference-contexts: 1 Introduction: why another temporal extension of SQL? The last decade of research in temporal databases has led to the development of several temporal query languages based on extensions of existing relational languages, e.g., TQUEL <ref> [16] </ref> or various temporal extensions of SQL, most prominent of which are TSQL2 [17] and its variants: ATSQL2 [5] and the current proposal of temporal extension of SQL3 to the ISO and ANSI standardization committees|SQL/Temporal [18]. <p> Instead, compact encodings of sets of time instants (often called periods of validity) associated with a tuple are encoded by intervals <ref> [16, 18] </ref>, bitemporal elements [4, 14], or other fixed-dimensional products of intervals (hyper-rectangles).
Reference: [17] <author> Snodgrass R.T. </author> <title> (editor). The TSQL2 Temporal Query Language. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> 674+xxiv pages, </address> <year> 1995. </year>
Reference-contexts: 1 Introduction: why another temporal extension of SQL? The last decade of research in temporal databases has led to the development of several temporal query languages based on extensions of existing relational languages, e.g., TQUEL [16] or various temporal extensions of SQL, most prominent of which are TSQL2 <ref> [17] </ref> and its variants: ATSQL2 [5] and the current proposal of temporal extension of SQL3 to the ISO and ANSI standardization committees|SQL/Temporal [18]. <p> Indeed, in a single-dimensional case, the representation dependency problem is successfully evaded using coalescing [6] that produces a unique representation of single-dimensional temporal relations. Note that the TSQL2's informal semantics, including many TSQL2 queries, implicitly rely on this assumption <ref> [3, 17] </ref>. However, a single temporal dimension is not sufficient to formulate general temporal queries. <p> 1025 Poland 1794 Poland 1918 Poland 1938 Poland 1945 Czech Kingdom 1198 Czech Kingdom 1620 Czechoslovakia 1918 Czechoslovakia 1938 Czechoslovakia 1945 Czechoslovakia 1992 Czech Republic 1995 Slovakia 1940 Slovakia 1944 Slovakia 1993 We do not impose any restrictions on the number of temporal attributes in the relations (unlike, e.g., TSQL2 <ref> [17] </ref>). Indeed, in general we may want to record relationships between different time instants as well as relationships between tuples of uninterpreted constants and a single time instant.
Reference: [18] <author> Snodgrass, R. T., Bohlen, M. H., Jensen C. S., Steiner, A. </author> <title> Adding Valid Time to SQL/Temporal, ISO/IEC JTC1/SC21/WG3 DBL MAD-146r2 21/11/96, (change proposal). </title>
Reference-contexts: development of several temporal query languages based on extensions of existing relational languages, e.g., TQUEL [16] or various temporal extensions of SQL, most prominent of which are TSQL2 [17] and its variants: ATSQL2 [5] and the current proposal of temporal extension of SQL3 to the ISO and ANSI standardization committees|SQL/Temporal <ref> [18] </ref>. All the above languages are based on the timestamp view of temporal databases: every tuple is timestamped with the time at which the fact represented by the tuple holds [9]. <p> Instead, compact encodings of sets of time instants (often called periods of validity) associated with a tuple are encoded by intervals <ref> [16, 18] </ref>, bitemporal elements [4, 14], or other fixed-dimensional products of intervals (hyper-rectangles). <p> Note that most of the existing temporal query languages violate both of the above principles, mainly by introducing constructs for explicit manipulation of the actual timestamp representation: both ATSQL [5] and SQL/Temporal <ref> [18] </ref> use the BEGIN and END keywords to extract the endpoints of intervals, PERIOD keyword to construct new interval timestamps, and Allen's interval algebra [2] operators to compare the timestamps. This is only possible if the user knows that the timestamps are encoded by intervals. <p> In addition our proposal meets the following requirements: * SQL/TP can be efficiently implemented on top of an interval-based representation of temporal databases: the performance of a SQL/TP system should be comparable to performance of SQL/Temporal <ref> [18] </ref> based DBMS on a vast majority of representation independent queries. * SQL/TP statements can be compiled to standard SQL/92 [12] 3 ; the translated queries can be evaluated using an off-shelf database system. <p> Moreover, SQL/TP is complete in the sense of [8]. The results in [1, 20] show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal rela tional algebra, e.g., [7]. * Migration requirements <ref> [18] </ref>, that require several levels of temporal upward compatibility with SQL; while SQL/TP itself does not literally follow all the requirements, the compatibility can be easily achieved using a very simple syntactic manipulation of the source queries, and adding tags to distinguish the particular compatibility modes, cf. Section 3.5. <p> The delete construction is more powerful, then the SQL/92 version (handles duplication properly). 12 3.5 Compatibility with SQL/92 To allow easy migration from SQL/92 to SQL/TP we introduce two compatibility modes <ref> [18] </ref> that allow standard SQL queries to be evaluated over a temporal database: Temporal Upward Compatibility (TUC) mode. The first level of compatibility treats standard SQL queries as queries operating with respect to the current time instant. <p> However, it is easy to see that we could extend SQL/TP with keywords to tag queries in order to distinguish the compatibility modes from the full SQL/TP mode on the syntactic level (similarly to <ref> [18] </ref>). Such a tagging mechanism would guarantee a syntactic temporal upward compatibility, should it become necessary. <p> However, the normalization operation is costly; the hope is that the cost would amortize over time as the normalization is idempotent; cf. Section 4.3. 5 Comparison with SQL/Temporal Now we are ready to compare SQL/TP with the most current proposal of temporal extensions to the SQL-3 ISO/ANSI committees|SQL/Temporal <ref> [18] </ref>. The comparison is slightly complicated as SQL/Temporal comes with three separate semantics. These three variants|the temporal up ward compatibility, the sequenced semantics, and the nonsequenced semantics|originate from the 18 migration requirements stated informally in Section 3.5 (for full definition of SQL/Temporal and examples of queries see [18]). <p> SQL-3 ISO/ANSI committees|SQL/Temporal <ref> [18] </ref>. The comparison is slightly complicated as SQL/Temporal comes with three separate semantics. These three variants|the temporal up ward compatibility, the sequenced semantics, and the nonsequenced semantics|originate from the 18 migration requirements stated informally in Section 3.5 (for full definition of SQL/Temporal and examples of queries see [18]).
Reference: [19] <author> Toman, D. </author> <title> Point-based vs. Interval-based Temporal Query Languages Proc. </title> <booktitle> ACM PODS 1996, </booktitle> <pages> 58-67, </pages> <year> 1996. </year>
Reference-contexts: In this way our approach separates an abstract query language|SQL/TP|defined over a point-based linear model of time from the concrete interval-based encoding of timestamps which is mostly hidden from the user. The approach is based on several recent results in the area of temporal and constraint query languages <ref> [1, 15, 19, 20] </ref>. In addition, a meaningful duplicate semantics and aggregation can be naturally defined such a language independently from the particular encoding, e.g., using the results in [10, 11]. The two main design principles behind the new language are: 1. <p> In the rest of this section we give a sketch of the SQL/TP to SQL/92 translation. The translation is based on an extension of results in <ref> [19] </ref> to duplicate semantics using a nouveau normalization technique. In the rest of this section we provide a high-level overview of the proposed translation. The description addresses all the major issues that need to be considered to make the translation work. <p> This semantics is indeed first-order complete. However, the completeness comes with a high price tag: the semantics is essentially based on a first-order logic over the interval-based temporal domain <ref> [19] </ref>, rather than over the domain of the individual time instants, and thus is plagued by all the problems discussed in the Introduction. <p> All this is achieved while maintaining efficient query evaluation over temporal databases based on interval encoding of timestamps. In addition, all representation independent SQL/Temporal queries are expressible in SQL/TP (follows from <ref> [19] </ref>). Future Work. Our proposal is only a first step towards an implementations of SQL/TP on top of an ordinary RDBMS systems. <p> This problem goes hand in hand with defining various normal forms <ref> [6, 19] </ref> of temporal relations and enforcing them over updates 14 . * Can the standard indices built-in relational systems aid the query evaluation based on the proposed compilation technique? What are the tradeoffs comparing to specialized indices? Note that there are few answers to these questions even for the established
Reference: [20] <author> Toman, D., Niwinski, D. </author> <title> First-Order Temporal Queries Inexpressible in Temporal Logic Proc. </title> <editor> EDBT'96, Arpes, Bouzeghoub (eds.), </editor> <volume> LNCS 1057, </volume> <pages> 307-324, </pages> <year> 1996. </year>
Reference-contexts: However, a single temporal dimension is not sufficient to formulate general temporal queries. Consider the query "are there two distinct time instants when a given relation contains exactly the same tuples?" (Section 3.3, query 3). [1] and <ref> [20] </ref> have independently shown that this query cannot be formulated in first-order temporal logic. A direct corollary of this result is that this query cannot be expressed in any single-dimensional temporal relational algebra 2 . Moreover, [20] shows that the number of temporal dimensions cannot be bounded by any constant in <p> a given relation contains exactly the same tuples?" (Section 3.3, query 3). [1] and <ref> [20] </ref> have independently shown that this query cannot be formulated in first-order temporal logic. A direct corollary of this result is that this query cannot be expressed in any single-dimensional temporal relational algebra 2 . Moreover, [20] shows that the number of temporal dimensions cannot be bounded by any constant in order to express all first-order queries. <p> In this way our approach separates an abstract query language|SQL/TP|defined over a point-based linear model of time from the concrete interval-based encoding of timestamps which is mostly hidden from the user. The approach is based on several recent results in the area of temporal and constraint query languages <ref> [1, 15, 19, 20] </ref>. In addition, a meaningful duplicate semantics and aggregation can be naturally defined such a language independently from the particular encoding, e.g., using the results in [10, 11]. The two main design principles behind the new language are: 1. <p> Moreover, SQL/TP is complete in the sense of [8]. The results in <ref> [1, 20] </ref> show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal rela tional algebra, e.g., [7]. * Migration requirements [18], that require several levels of temporal upward compatibility with SQL; while SQL/TP itself does not literally follow all the requirements, the <p> Thus SQL/TP can express queries, shown not to be expressible in TRA [7] or any temporal query language that assumes a fixed number of temporal dimensions in its data model, e.g., the query "List all pairs of time instants, when exactly the same countries were independent" <ref> [1, 20] </ref>. 3.3 Examples of Queries In this section we provide illustrative examples of SQL/TP queries. The examples are chosen to highlight the ease and naturality of formulating queries in SQL/TP. <p> The results in <ref> [1, 20] </ref> show that the two dimensionality is inherent to this query (this remains true even when we consider the existential closure of this query). 4.
Reference: [21] <author> Williams, H. P. </author> <title> Fourier-Motzkin Elimination Extension to Integer Programming Problems. </title> <journal> In Journal of Combinatorial Theory (A) 21, </journal> <pages> 118-123, </pages> <year> 1976. </year>
Reference-contexts: While the result of the translation can be defined using a SQL/92 query, we may decide to implement parts of it, e.g., the normalization operation; cf. Definition 4.3, natively to improve the efficiency of query evaluation. The translation utilizes the quantifier elimination procedure for linear order <ref> [21] </ref> to replace references to individual time instants in the queries with references to interval endpoints. In the rest of this section we give a sketch of the SQL/TP to SQL/92 translation.
Reference: [22] <author> Kabanza, F., Stevenne, J.-M., Wolper, P. </author> <title> Handling Infinite Temporal Data. </title> <journal> JCSS 51(1): </journal> <pages> 3-17, </pages> <year> 1995. </year>
Reference-contexts: In this paper we mostly concentrate on evaluation of temporal queries over the interval-based encoding of time. However, conforming to the above principles allows us to use different encoding for sets of time instants, e.g., the linear repeating points <ref> [22] </ref> for periodic events, without the need for new syntax and semantics.
References-found: 22

