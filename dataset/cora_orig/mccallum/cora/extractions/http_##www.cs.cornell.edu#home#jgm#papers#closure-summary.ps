URL: http://www.cs.cornell.edu/home/jgm/papers/closure-summary.ps
Refering-URL: http://www.cs.cornell.edu/home/jgm/papers.html
Root-URL: http://www.cs.cornell.edu
Email: nan@kurims.kyoto-u.ac.jp  jgmorris@cs.cmu.edu  rwh@cs.cmu.edu  
Title: Typed Closure Conversion  
Author: Yasuhiko Minamide Greg Morrisett Robert Harper 
Address: Kyoto 606-01, Japan  Pittsburgh, PA 15213-3891  Pittsburgh, PA 15213-3891  
Affiliation: Research Institute for Mathematical Sciences Kyoto University  School of Computer Science Carnegie Mellon University  School of Computer Science Carnegie Mellon University  
Abstract: We present closure conversion as a type-directed, and type-preserving translation for both the simply-typed and the polymorphic -calculus. Our translations are based on a simple "closures as objects" principle: higher-order functions are viewed as objects consisting of a single method (the code) and a single instance variable (the environment). In the simply-typed case, the Pierce-Turner model of object typing where objects are packages of existential type suffices. In the polymorphic case, more careful tracking of type sharing is required. We exploit a variant of the Harper-Lillibridge "translucent type" formalism to characterize the types of polymorphic closures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Closure conversion <ref> [29, 34, 5, 17, 16, 1, 39, 9] </ref> is a program transformation that achieves a separation between code and fl This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No. <p> This affords considerable flexibility in the representation of environments and is thus exploited to good advantage by Shao and Appel [30] and Wand and Steckler [39]. Previous accounts consider closure conversion as a transformation to untyped terms, even if the source language is typed <ref> [34, 17, 1, 39, 9] </ref>. This is adequate for compilers that make little or no use of types in the back end or at run time. <p> Due to lack of space, we omit the proofs of correctness here. However, full details may be found in the companion technical report [21]. Closure conversion is discussed in descriptions of various functional language compilers <ref> [34, 17, 2, 1, 30] </ref>. It is similar to -lifting [15] in that it eliminates free variables in the bodies of -abstractions but differs by making the representation of the environment explicit as a data structure. <p> The advantage of the FAM environment representation is that the cost of variable lookup is always constant and the representation is "safe for space" <ref> [1] </ref> according to Appel's definition. However, constructing the environment for a closure takes time proportional to the number of free variables in the function, and closures cannot share portions of their environment. Clearly, there are a variety of other strategies for forming environments.
Reference: [2] <author> A. W. Appel and T. Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1989. </year>
Reference-contexts: Due to lack of space, we omit the proofs of correctness here. However, full details may be found in the companion technical report [21]. Closure conversion is discussed in descriptions of various functional language compilers <ref> [34, 17, 2, 1, 30] </ref>. It is similar to -lifting [15] in that it eliminates free variables in the bodies of -abstractions but differs by making the representation of the environment explicit as a data structure.
Reference: [3] <author> D. E. Britton. </author> <title> Heap storage management for the programming language Pascal. </title> <type> Master's thesis, </type> <institution> University of Arizona, </institution> <year> 1975. </year>
Reference-contexts: Compilation strategies for polymorphic languages, such as those proposed by Morrison et al. [24] and Harper and Mor-risett [14], rely on analyzing types at run time to support unboxed representations and non-parametric operators, including printing and structural equality. Tag-free garbage collection <ref> [3, 37, 23] </ref> for both monomorphic and polymorphic programming languages relies on analyzing types at run time to determine the size and layout of objects in the heap. To support any of these implementation strategies, it is necessary to propagate type information through closure conversion and into the generated code.
Reference: [4] <author> L. Cardelli. </author> <title> The functional abstract machine. </title> <journal> Polymorphism, </journal> <volume> 1(1), </volume> <year> 1983. </year>
Reference-contexts: A critical decision in closure conversion is the choice of representation for the environment | whether to use a flat FAM-like <ref> [4] </ref>, linked CAM-like [5], or hybrid representation [30]. The choice of representation is influenced by a desire to minimize closure creation time, the space consumed by the environment, and the time to access a variable in the environment [39, 30]. <p> We describe the translation as a deductive system where the choice of environment representations may be independently made for each closure. We argue that various representations considered in the literature (such as the FAM <ref> [4] </ref> or CAM [5]), as well as hybrid representations [30], can all be explained in this uniform framework. We establish the correctness of the translation once for all environment representations. <p> Since z is in scope, it is also sensible to include z in the environment of f, resulting in the following code: let val x = 1 val z = 3 fx=x, y=y, z=zg f 100 In the examples above, we used a flat FAM-like <ref> [4] </ref> representation of the environment as a record with one field for each variable. Alternatively we could choose a linked CAM-like [5] representation in which each binding is a separate frame attached to the front of the remaining bindings. <p> However, in the worst case, accessing values in the environment takes time proportional to the length of the environment. In contrast, the FAM <ref> [4] </ref> uses flat environments with no sharing. The closure conversion of Figure 2 accurately models the environment strategy of the FAM if we choose a specific strengthening strategy in the (abs) rule where only the free variables of the function are preserved in the resulting closure's environment.
Reference: [5] <editor> C. Cousineau, P.-L. Curien, and M. Mauny. </editor> <booktitle> The categorical abstract machine. In Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 50-64, </pages> <year> 1985. </year>
Reference-contexts: 1 Introduction Closure conversion <ref> [29, 34, 5, 17, 16, 1, 39, 9] </ref> is a program transformation that achieves a separation between code and fl This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No. <p> A critical decision in closure conversion is the choice of representation for the environment | whether to use a flat FAM-like [4], linked CAM-like <ref> [5] </ref>, or hybrid representation [30]. The choice of representation is influenced by a desire to minimize closure creation time, the space consumed by the environment, and the time to access a variable in the environment [39, 30]. <p> We describe the translation as a deductive system where the choice of environment representations may be independently made for each closure. We argue that various representations considered in the literature (such as the FAM [4] or CAM <ref> [5] </ref>), as well as hybrid representations [30], can all be explained in this uniform framework. We establish the correctness of the translation once for all environment representations. The second stage, called closure representation, is another type-directed translation where closures are implemented in terms of generic typed -calculus primitives. <p> Alternatively we could choose a linked CAM-like <ref> [5] </ref> representation in which each binding is a separate frame attached to the front of the remaining bindings. This idea leads to the following translation: let val x = 1 val z = 3 (#x (#link (#link env))) + (#y (#link env)) + w) fz=z, link=fy=y, link=fx=xggg in end. <p> Nested type assignments are sufficiently flexible to handle many commonly-used environment representations. For example, the Categorical Abstract Machine, or CAM <ref> [5] </ref>, uses a linked list to represent the environment.
Reference: [6] <author> H. Friedman. </author> <title> Equality between functionals. </title> <editor> In R. Parikh, editor, </editor> <booktitle> Logic Colloquium '75. </booktitle> <address> Norh-Holland, </address> <year> 1975. </year>
Reference-contexts: In addition to the practical advantages of this approach, type-directed translation also facilitates the work of the compiler writer. In particular, the typing properties of the intermediate code may be exploited to give clear, concise proofs of compiler correctness through the method of logical relations <ref> [35, 6, 27, 32, 33] </ref>. Furthermore, the intermediate code of the compiler can be mechanically typed-checked, an important debugging tool for the compiler writer. Finally, checkable typed intermediate languages are a promising technique for ensuring safety properties of programs in a distributed environment [8, 38].
Reference: [7] <author> J.-Y. Girard, Y. Lafont, and P. Taylor. </author> <title> Proofs and Types, </title> <booktitle> volume 7 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, England, </address> <year> 1989. </year>
Reference-contexts: This fragment is sufficient to model Standard ML [13], and admits relatively simple correctness proofs based on logical relations. Our results extend to the full impredicative polymorphic - calculus, but at the expense of a substantially more complex correctness argument (based on Girard's method of candi dates <ref> [7] </ref>).
Reference: [8] <author> J. Gosling. </author> <title> Java intermediate bytecodes. </title> <booktitle> In ACM SIG-PLAN Workshop on Intermediate Representations (IR'95), </booktitle> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Furthermore, the intermediate code of the compiler can be mechanically typed-checked, an important debugging tool for the compiler writer. Finally, checkable typed intermediate languages are a promising technique for ensuring safety properties of programs in a distributed environment <ref> [8, 38] </ref>. We describe closure conversion for the simply-typed - calculus and the predicative fragment of the polymorphic -calculus. In each case we present closure conversion in two stages. The first stage, called abstract closure conversion, is a type-directed translation to an intermediate language with a primitive notion of closures.
Reference: [9] <author> J. Hannan. </author> <title> A type system for closure conversion. </title> <booktitle> In The Workshop on Types for Program Analysis, </booktitle> <year> 1995. </year>
Reference-contexts: 1 Introduction Closure conversion <ref> [29, 34, 5, 17, 16, 1, 39, 9] </ref> is a program transformation that achieves a separation between code and fl This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No. <p> This affords considerable flexibility in the representation of environments and is thus exploited to good advantage by Shao and Appel [30] and Wand and Steckler [39]. Previous accounts consider closure conversion as a transformation to untyped terms, even if the source language is typed <ref> [34, 17, 1, 39, 9] </ref>. This is adequate for compilers that make little or no use of types in the back end or at run time. <p> Wand and Steckler [39] have consider two optimizations of the basic closure conversion strategy, called selective and lightweight closure conversion, and provide a correctness proof for each of these in an un-typed setting. Hannan <ref> [9] </ref> recasts Wand's work into a typed setting and provides correctness proofs for one of Wand's optimizations.
Reference: [10] <author> R. Harper and M. Lillibridge. </author> <title> Explicit polymorphism and CPS conversion. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1993. </year>
Reference-contexts: Thus each stage of the compiler can be viewed as a type-preserving translation between typed intermediate languages. Examples of such translations have been given by Leroy [18], Ohori [25], Harper and Lillibridge <ref> [10] </ref>, and Harper and Mor-risett [14]. In contrast to type-free compilation strategies, these translations make essential use of type information during translation to increase the time or space efficiency of programs. In addition to the practical advantages of this approach, type-directed translation also facilitates the work of the compiler writer.
Reference: [11] <author> R. Harper and M. Lillibridge. </author> <title> A type-theoretic approach to higher-order modules. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 123-137, </pages> <year> 1994. </year>
Reference-contexts: In the polymorphic case, we must use a more sophisticated type discipline in order to track critical type sharing relationships within the closure. To this end, we exploit a variant of the translucent type <ref> [11] </ref> (or manifest type [19]) formalism. Our "closures as objects" model provides an interesting counterpoint to the more familiar "objects as closures" proposal introduced by Reddy [28]. We prove the correctness of both the abstract closure conversion and the closure representation stages using the method of logical relations. <p> This ensures that the type environment passed to the code and the type environment used in the construction of the closure's value environment are the same. Fortunately, typing constraints of this form have already been addressed by research on module systems <ref> [20, 19, 11] </ref>. Following Harper and Lillibridge [11], we use the notion of translucent types to express the desired constraint on the code. <p> This ensures that the type environment passed to the code and the type environment used in the construction of the closure's value environment are the same. Fortunately, typing constraints of this form have already been addressed by research on module systems [20, 19, 11]. Following Harper and Lillibridge <ref> [11] </ref>, we use the notion of translucent types to express the desired constraint on the code. <p> This type is a super-type of the original code type code because we have constrained the bound type variable tenv to be bound to a particular type, namely the type environment of the closure. (See Harper and Lillibridge <ref> [11] </ref> and Leroy [19] for further discussion of subtyping in this setting.) This constraint ensures that this reference to the code will only be applied to the type environment of the closure. <p> As in the simply-typed case, we have obtained an "object oriented" representation of polymorphic closures by exploiting a combination of the type systems proposed by Pierce and Turner [26] for objects and by Harper and Lil libridge <ref> [11] </ref> for modules. 5 A Formal Account of Polymorphic Clo sure Conversion In this section, we present closure conversion for the predica-tive fragment of the second order -calculus. This fragment is sufficient to model Standard ML [13], and admits relatively simple correctness proofs based on logical relations.
Reference: [12] <author> R. Harper, D. MacQueen, and R. Milner. </author> <title> Standard ML. </title> <type> Technical Report ECS-LFCS-86-2, </type> <institution> Laboratory for the Foundations of Computer Science, Edinburgh University, </institution> <month> Mar. </month> <year> 1986. </year>
Reference: [13] <author> R. Harper and J. C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> 15(2), </volume> <year> 1993. </year>
Reference-contexts: The definition of the rela tions and the proof of the correctness can be found in our technical report [21]. 4 Overview of Polymorphic Closure Con version Closure conversion for a language with ML-style (i.e., pred-icative <ref> [13] </ref>) explicit polymorphism follows a similar pattern to the simply-typed case, but with two additional complications. First, we must account for free type variables as well as free value variables in the code of an abstraction. Second, we must create closures for both value abstractions (-terms) and type abstractions (fl-terms). <p> This fragment is sufficient to model Standard ML <ref> [13] </ref>, and admits relatively simple correctness proofs based on logical relations. Our results extend to the full impredicative polymorphic - calculus, but at the expense of a substantially more complex correctness argument (based on Girard's method of candi dates [7]). <p> Typing judgements are derived according to the standard typing rules of the second-order -calculus (see for example <ref> [13, 14] </ref>).
Reference: [14] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 130-141, </pages> <year> 1995. </year>
Reference-contexts: Compilation strategies for polymorphic languages, such as those proposed by Morrison et al. [24] and Harper and Mor-risett <ref> [14] </ref>, rely on analyzing types at run time to support unboxed representations and non-parametric operators, including printing and structural equality. <p> Thus each stage of the compiler can be viewed as a type-preserving translation between typed intermediate languages. Examples of such translations have been given by Leroy [18], Ohori [25], Harper and Lillibridge [10], and Harper and Mor-risett <ref> [14] </ref>. In contrast to type-free compilation strategies, these translations make essential use of type information during translation to increase the time or space efficiency of programs. In addition to the practical advantages of this approach, type-directed translation also facilitates the work of the compiler writer. <p> Typing judgements are derived according to the standard typing rules of the second-order -calculus (see for example <ref> [13, 14] </ref>).

Reference: [16] <author> R. Kelsey and P. Hudak. </author> <title> Realistic compilation by program translation -detailed summary -. In ACM Symp. </title> <booktitle> on Prin ciples of Programming Languages, </booktitle> <pages> pages 281-292, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Closure conversion <ref> [29, 34, 5, 17, 16, 1, 39, 9] </ref> is a program transformation that achieves a separation between code and fl This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No.
Reference: [17] <author> D. Kranz et al. </author> <title> Orbit: An optimizing compiler for Scheme. </title> <booktitle> In Proc. of the SIGPLAN '86 Symp. on Compiler Construc tion, </booktitle> <year> 1986. </year>
Reference-contexts: 1 Introduction Closure conversion <ref> [29, 34, 5, 17, 16, 1, 39, 9] </ref> is a program transformation that achieves a separation between code and fl This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No. <p> This affords considerable flexibility in the representation of environments and is thus exploited to good advantage by Shao and Appel [30] and Wand and Steckler [39]. Previous accounts consider closure conversion as a transformation to untyped terms, even if the source language is typed <ref> [34, 17, 1, 39, 9] </ref>. This is adequate for compilers that make little or no use of types in the back end or at run time. <p> Due to lack of space, we omit the proofs of correctness here. However, full details may be found in the companion technical report [21]. Closure conversion is discussed in descriptions of various functional language compilers <ref> [34, 17, 2, 1, 30] </ref>. It is similar to -lifting [15] in that it eliminates free variables in the bodies of -abstractions but differs by making the representation of the environment explicit as a data structure.
Reference: [18] <author> X. Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1992. </year>
Reference-contexts: However, when compiling typed languages, it is often advantageous to propagate type information through each stage of the compiler, and to make use of types at link- or even run time. For example, Leroy's representation analysis <ref> [18, 31] </ref> uses types to determine procedure calling conventions, and Ohori's record compilation [25] uses a representation of types at run time to access components of a record. <p> In general, such translations transform both a term and its type, possibly relying on type information to guide the translation. Thus each stage of the compiler can be viewed as a type-preserving translation between typed intermediate languages. Examples of such translations have been given by Leroy <ref> [18] </ref>, Ohori [25], Harper and Lillibridge [10], and Harper and Mor-risett [14]. In contrast to type-free compilation strategies, these translations make essential use of type information during translation to increase the time or space efficiency of programs.
Reference: [19] <author> X. Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 109-122, </pages> <year> 1994. </year>
Reference-contexts: In the polymorphic case, we must use a more sophisticated type discipline in order to track critical type sharing relationships within the closure. To this end, we exploit a variant of the translucent type [11] (or manifest type <ref> [19] </ref>) formalism. Our "closures as objects" model provides an interesting counterpoint to the more familiar "objects as closures" proposal introduced by Reddy [28]. We prove the correctness of both the abstract closure conversion and the closure representation stages using the method of logical relations. <p> This ensures that the type environment passed to the code and the type environment used in the construction of the closure's value environment are the same. Fortunately, typing constraints of this form have already been addressed by research on module systems <ref> [20, 19, 11] </ref>. Following Harper and Lillibridge [11], we use the notion of translucent types to express the desired constraint on the code. <p> This type is a super-type of the original code type code because we have constrained the bound type variable tenv to be bound to a particular type, namely the type environment of the closure. (See Harper and Lillibridge [11] and Leroy <ref> [19] </ref> for further discussion of subtyping in this setting.) This constraint ensures that this reference to the code will only be applied to the type environment of the closure.
Reference: [20] <author> D. MacQueen. </author> <title> Modules for Standard ML. </title> <booktitle> In Proc. ACM Conf. Lisp and Functional Programming, </booktitle> <pages> pages 198-207, </pages> <year> 1984. </year> <note> Revised version appears in [12]. </note>
Reference-contexts: This ensures that the type environment passed to the code and the type environment used in the construction of the closure's value environment are the same. Fortunately, typing constraints of this form have already been addressed by research on module systems <ref> [20, 19, 11] </ref>. Following Harper and Lillibridge [11], we use the notion of translucent types to express the desired constraint on the code.
Reference: [21] <author> Y. Minamide, G. Morrisett, and R. Harper. </author> <title> Typed closure conversion. </title> <type> Technical Report CMU-CS-95-171, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: From this, we may conclude that a closed program and its translation evaluate to the same result. Due to lack of space, we omit the proofs of correctness here. However, full details may be found in the companion technical report <ref> [21] </ref>. Closure conversion is discussed in descriptions of various functional language compilers [34, 17, 2, 1, 30]. It is similar to -lifting [15] in that it eliminates free variables in the bodies of -abstractions but differs by making the representation of the environment explicit as a data structure. <p> Correctness of the translation is proven using logical relations between cl and 9 expressions, cl and 9 values, and cl and 9 substitutions. The definition of the rela tions and the proof of the correctness can be found in our technical report <ref> [21] </ref>. 4 Overview of Polymorphic Closure Con version Closure conversion for a language with ML-style (i.e., pred-icative [13]) explicit polymorphism follows a similar pattern to the simply-typed case, but with two additional complications. <p> The details of the typing rules are found in the companion technical report <ref> [21] </ref>. We define the closure representation stage as a type-directed translation from 8;cl to 8;9 . <p> However, the definition of the relations is more complicated because of the presence of polymorphic types and types of the form i (t ) in the language 8;cl . The relations and the proof appear in the companion technical report <ref> [21] </ref>. 6 Summary and Conclusions We have given a type-theoretic account of closure conversion by defining type-directed transformations for the simply-typed and polymorphic -calculi. The types used in the target languages of the translations may be characterized in a natural way based on the "closures as objects" principle.
Reference: [22] <author> J. C. Mitchell and G. D. Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> 10(3), </volume> <year> 1988. </year>
Reference-contexts: If types are to be preserved by closure conversion, the representation of the environment must be hidden. This may be achieved through the use of existential types <ref> [22] </ref>, whose typing rules are given in Figure 1. Briefly, the pack construct packages a type t with a term e, abstracting certain occurrences of t in the type of e as the type variable t. <p> The open operation extracts the contents of a package for use within a fixed scope, holding the type component of the package abstract. (See Mitchell and Plotkin's article <ref> [22] </ref> for further discussion of existential types.) Using existentials, we may hide the type of the environment by abstracting it from the type of the closure itself. <p> We assume that the free type variables of the types in the range of and the free type variables of e and t are contained in . The typing rules and evaluation rules of the language are standard (see <ref> [22] </ref> and Figure 1). We describe the closure representation phase in two parts.
Reference: [23] <author> G. Morrisett, M. Felleisen, and R. Harper. </author> <title> Abstract models of memory management. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 66-77, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Compilation strategies for polymorphic languages, such as those proposed by Morrison et al. [24] and Harper and Mor-risett [14], rely on analyzing types at run time to support unboxed representations and non-parametric operators, including printing and structural equality. Tag-free garbage collection <ref> [3, 37, 23] </ref> for both monomorphic and polymorphic programming languages relies on analyzing types at run time to determine the size and layout of objects in the heap. To support any of these implementation strategies, it is necessary to propagate type information through closure conversion and into the generated code.
Reference: [24] <author> R. Morrison, A. Dearle, R. Connor, and A. L. Brown. </author> <title> An ad hoc approach to the implementation of polymorphism. </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> 13(3), </volume> <year> 1991. </year>
Reference-contexts: For example, Leroy's representation analysis [18, 31] uses types to determine procedure calling conventions, and Ohori's record compilation [25] uses a representation of types at run time to access components of a record. Compilation strategies for polymorphic languages, such as those proposed by Morrison et al. <ref> [24] </ref> and Harper and Mor-risett [14], rely on analyzing types at run time to support unboxed representations and non-parametric operators, including printing and structural equality.
Reference: [25] <author> A. Ohori. </author> <title> A compilation method for ML-style polymorphic record calculi. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1992. </year>
Reference-contexts: However, when compiling typed languages, it is often advantageous to propagate type information through each stage of the compiler, and to make use of types at link- or even run time. For example, Leroy's representation analysis [18, 31] uses types to determine procedure calling conventions, and Ohori's record compilation <ref> [25] </ref> uses a representation of types at run time to access components of a record. <p> In general, such translations transform both a term and its type, possibly relying on type information to guide the translation. Thus each stage of the compiler can be viewed as a type-preserving translation between typed intermediate languages. Examples of such translations have been given by Leroy [18], Ohori <ref> [25] </ref>, Harper and Lillibridge [10], and Harper and Mor-risett [14]. In contrast to type-free compilation strategies, these translations make essential use of type information during translation to increase the time or space efficiency of programs.
Reference: [26] <author> B. C. Pierce and D. N. Turner. </author> <title> Simple type-theoretic foun dations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <month> Apr. </month> <year> 1994. </year> <note> A preliminary version appeared in Principles of Programming Languages, </note> <year> 1993, </year> <title> and as University of Edinburgh technical report ECS-LFCS-92-225, under the title "Object-Oriented Program ming Without Recursive Types". </title>
Reference-contexts: The main idea is to represent closures as objects consisting of a single method (the code) and a single instance variable (the environment). We show that, in the simply-typed case, Pierce and Turner's type discipline for object-oriented programming <ref> [26] </ref> may be used to characterize the types of closures. In particular, we use existential type abstraction to ensure the privacy of environment representation in much the same way that Pierce and Turner hide the representation types of instance variables. <p> As in the simply-typed case, we have obtained an "object oriented" representation of polymorphic closures by exploiting a combination of the type systems proposed by Pierce and Turner <ref> [26] </ref> for objects and by Harper and Lil libridge [11] for modules. 5 A Formal Account of Polymorphic Clo sure Conversion In this section, we present closure conversion for the predica-tive fragment of the second order -calculus.
Reference: [27] <author> G. D. Plotkin. </author> <title> Lambda-definability in the full type hierarchy. In To H.B.Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism. </title> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: In addition to the practical advantages of this approach, type-directed translation also facilitates the work of the compiler writer. In particular, the typing properties of the intermediate code may be exploited to give clear, concise proofs of compiler correctness through the method of logical relations <ref> [35, 6, 27, 32, 33] </ref>. Furthermore, the intermediate code of the compiler can be mechanically typed-checked, an important debugging tool for the compiler writer. Finally, checkable typed intermediate languages are a promising technique for ensuring safety properties of programs in a distributed environment [8, 38].
Reference: [28] <author> U. S. Reddy. </author> <title> Objects as closures. </title> <booktitle> In Proc. ACM Conf. Lisp and Functional Programming, </booktitle> <year> 1988. </year>
Reference-contexts: To this end, we exploit a variant of the translucent type [11] (or manifest type [19]) formalism. Our "closures as objects" model provides an interesting counterpoint to the more familiar "objects as closures" proposal introduced by Reddy <ref> [28] </ref>. We prove the correctness of both the abstract closure conversion and the closure representation stages using the method of logical relations. The main idea is to define a type-indexed family of simulation relations that establish a correspondence between the source and target terms of the translation.
Reference: [29] <author> J. C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Proceedings of the Annual ACM Conference, </booktitle> <pages> pages 717-740, </pages> <year> 1972. </year>
Reference-contexts: 1 Introduction Closure conversion <ref> [29, 34, 5, 17, 16, 1, 39, 9] </ref> is a program transformation that achieves a separation between code and fl This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No.
Reference: [30] <author> Z. Shao and A. W. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In Proc. ACM Conf. Lisp and Functional Program ming, </booktitle> <year> 1994. </year>
Reference-contexts: A critical decision in closure conversion is the choice of representation for the environment | whether to use a flat FAM-like [4], linked CAM-like [5], or hybrid representation <ref> [30] </ref>. The choice of representation is influenced by a desire to minimize closure creation time, the space consumed by the environment, and the time to access a variable in the environment [39, 30]. <p> The choice of representation is influenced by a desire to minimize closure creation time, the space consumed by the environment, and the time to access a variable in the environment <ref> [39, 30] </ref>. An important property of closure conversion is that the representation of the environment is private to the closure. This affords considerable flexibility in the representation of environments and is thus exploited to good advantage by Shao and Appel [30] and Wand and Steckler [39]. <p> An important property of closure conversion is that the representation of the environment is private to the closure. This affords considerable flexibility in the representation of environments and is thus exploited to good advantage by Shao and Appel <ref> [30] </ref> and Wand and Steckler [39]. Previous accounts consider closure conversion as a transformation to untyped terms, even if the source language is typed [34, 17, 1, 39, 9]. This is adequate for compilers that make little or no use of types in the back end or at run time. <p> We describe the translation as a deductive system where the choice of environment representations may be independently made for each closure. We argue that various representations considered in the literature (such as the FAM [4] or CAM [5]), as well as hybrid representations <ref> [30] </ref>, can all be explained in this uniform framework. We establish the correctness of the translation once for all environment representations. The second stage, called closure representation, is another type-directed translation where closures are implemented in terms of generic typed -calculus primitives. <p> Due to lack of space, we omit the proofs of correctness here. However, full details may be found in the companion technical report [21]. Closure conversion is discussed in descriptions of various functional language compilers <ref> [34, 17, 2, 1, 30] </ref>. It is similar to -lifting [15] in that it eliminates free variables in the bodies of -abstractions but differs by making the representation of the environment explicit as a data structure. <p> Making the environment explicit is important because it exposes environment construction and variable lookup to an optimizer. Furthermore, Shao and Appel show that not all environment representations are "safe for space" <ref> [30] </ref>, and thus choosing a good environment representation is an important part of compilation. Wand and Steckler [39] have consider two optimizations of the basic closure conversion strategy, called selective and lightweight closure conversion, and provide a correctness proof for each of these in an un-typed setting. <p> However, constructing the environment for a closure takes time proportional to the number of free variables in the function, and closures cannot share portions of their environment. Clearly, there are a variety of other strategies for forming environments. For example, the shared closure strategy described by Appel and Shao <ref> [30] </ref> that is also safe for space can also be formulated in our framework.
Reference: [31] <author> Z. Shao and A. W. Appel. </author> <title> A type-based compiler for Stan dard ML. </title> <booktitle> In Programming Language Design and Its imple-menation, </booktitle> <pages> pages 116-129, </pages> <year> 1995. </year>
Reference-contexts: However, when compiling typed languages, it is often advantageous to propagate type information through each stage of the compiler, and to make use of types at link- or even run time. For example, Leroy's representation analysis <ref> [18, 31] </ref> uses types to determine procedure calling conventions, and Ohori's record compilation [25] uses a representation of types at run time to access components of a record.
Reference: [32] <author> R. Statman. </author> <title> Completeness, invariance, </title> <journal> and lambda-definability. Journal of Symbolic Logic, </journal> <volume> 47 </volume> <pages> 17-26, </pages> <year> 1982. </year>
Reference-contexts: In addition to the practical advantages of this approach, type-directed translation also facilitates the work of the compiler writer. In particular, the typing properties of the intermediate code may be exploited to give clear, concise proofs of compiler correctness through the method of logical relations <ref> [35, 6, 27, 32, 33] </ref>. Furthermore, the intermediate code of the compiler can be mechanically typed-checked, an important debugging tool for the compiler writer. Finally, checkable typed intermediate languages are a promising technique for ensuring safety properties of programs in a distributed environment [8, 38].
Reference: [33] <author> R. Statman. </author> <title> Logical relations and the typed -calculus. </title> <journal> Information and Control, </journal> <volume> 65, </volume> <year> 1985. </year>
Reference-contexts: In addition to the practical advantages of this approach, type-directed translation also facilitates the work of the compiler writer. In particular, the typing properties of the intermediate code may be exploited to give clear, concise proofs of compiler correctness through the method of logical relations <ref> [35, 6, 27, 32, 33] </ref>. Furthermore, the intermediate code of the compiler can be mechanically typed-checked, an important debugging tool for the compiler writer. Finally, checkable typed intermediate languages are a promising technique for ensuring safety properties of programs in a distributed environment [8, 38].
Reference: [34] <author> G. L. Steele Jr. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <year> 1978. </year>
Reference-contexts: 1 Introduction Closure conversion <ref> [29, 34, 5, 17, 16, 1, 39, 9] </ref> is a program transformation that achieves a separation between code and fl This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No. <p> This affords considerable flexibility in the representation of environments and is thus exploited to good advantage by Shao and Appel [30] and Wand and Steckler [39]. Previous accounts consider closure conversion as a transformation to untyped terms, even if the source language is typed <ref> [34, 17, 1, 39, 9] </ref>. This is adequate for compilers that make little or no use of types in the back end or at run time. <p> Due to lack of space, we omit the proofs of correctness here. However, full details may be found in the companion technical report [21]. Closure conversion is discussed in descriptions of various functional language compilers <ref> [34, 17, 2, 1, 30] </ref>. It is similar to -lifting [15] in that it eliminates free variables in the bodies of -abstractions but differs by making the representation of the environment explicit as a data structure.
Reference: [35] <author> W. W. Tait. </author> <title> Intensional interpretation of functionals of finite type. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 32(2), </volume> <year> 1967. </year>
Reference-contexts: In addition to the practical advantages of this approach, type-directed translation also facilitates the work of the compiler writer. In particular, the typing properties of the intermediate code may be exploited to give clear, concise proofs of compiler correctness through the method of logical relations <ref> [35, 6, 27, 32, 33] </ref>. Furthermore, the intermediate code of the compiler can be mechanically typed-checked, an important debugging tool for the compiler writer. Finally, checkable typed intermediate languages are a promising technique for ensuring safety properties of programs in a distributed environment [8, 38].
Reference: [36] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <type> Technical report, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> Oct. </month> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: One compiler is being used to study novel approaches to tag-free garbage collection. The other compiler, called TIL (Typed Intermediate Languages), provides a general framework for analyzing types at run time to support efficient data representations, efficient calling conventions, and "nearly" tag-free garbage collection in the presence of polymorphism <ref> [36] </ref>. Propagating types through closure conversion is necessary for both compilers so that types can be examined at run time. We have found that propagating types through closure conversion (and other compilation phases) has an additional engineering benefit.
Reference: [37] <author> A. Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proc. ACM Conf. Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Compilation strategies for polymorphic languages, such as those proposed by Morrison et al. [24] and Harper and Mor-risett [14], rely on analyzing types at run time to support unboxed representations and non-parametric operators, including printing and structural equality. Tag-free garbage collection <ref> [3, 37, 23] </ref> for both monomorphic and polymorphic programming languages relies on analyzing types at run time to determine the size and layout of objects in the heap. To support any of these implementation strategies, it is necessary to propagate type information through closure conversion and into the generated code.
Reference: [38] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In 14th ACM Symposium on Operating Systems Principles, </booktitle> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Furthermore, the intermediate code of the compiler can be mechanically typed-checked, an important debugging tool for the compiler writer. Finally, checkable typed intermediate languages are a promising technique for ensuring safety properties of programs in a distributed environment <ref> [8, 38] </ref>. We describe closure conversion for the simply-typed - calculus and the predicative fragment of the polymorphic -calculus. In each case we present closure conversion in two stages. The first stage, called abstract closure conversion, is a type-directed translation to an intermediate language with a primitive notion of closures.
Reference: [39] <author> M. Wand and P. Steckler. </author> <title> Selective and lightweight closure conversion. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1994. </year>
Reference-contexts: 1 Introduction Closure conversion <ref> [29, 34, 5, 17, 16, 1, 39, 9] </ref> is a program transformation that achieves a separation between code and fl This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No. <p> The choice of representation is influenced by a desire to minimize closure creation time, the space consumed by the environment, and the time to access a variable in the environment <ref> [39, 30] </ref>. An important property of closure conversion is that the representation of the environment is private to the closure. This affords considerable flexibility in the representation of environments and is thus exploited to good advantage by Shao and Appel [30] and Wand and Steckler [39]. <p> An important property of closure conversion is that the representation of the environment is private to the closure. This affords considerable flexibility in the representation of environments and is thus exploited to good advantage by Shao and Appel [30] and Wand and Steckler <ref> [39] </ref>. Previous accounts consider closure conversion as a transformation to untyped terms, even if the source language is typed [34, 17, 1, 39, 9]. This is adequate for compilers that make little or no use of types in the back end or at run time. <p> This affords considerable flexibility in the representation of environments and is thus exploited to good advantage by Shao and Appel [30] and Wand and Steckler [39]. Previous accounts consider closure conversion as a transformation to untyped terms, even if the source language is typed <ref> [34, 17, 1, 39, 9] </ref>. This is adequate for compilers that make little or no use of types in the back end or at run time. <p> Making the environment explicit is important because it exposes environment construction and variable lookup to an optimizer. Furthermore, Shao and Appel show that not all environment representations are "safe for space" [30], and thus choosing a good environment representation is an important part of compilation. Wand and Steckler <ref> [39] </ref> have consider two optimizations of the basic closure conversion strategy, called selective and lightweight closure conversion, and provide a correctness proof for each of these in an un-typed setting. Hannan [9] recasts Wand's work into a typed setting and provides correctness proofs for one of Wand's optimizations. <p> Indeed, automatic type-checking has enabled us to isolate and eliminate various subtle bugs in TIL. For simplicity, the current implementations of our compilers use only abstract closure conversion. However, both compilers extend this translation to avoid creation of closures for "known" functions in the style of Wand and Steck-ler <ref> [39] </ref>.
References-found: 38

