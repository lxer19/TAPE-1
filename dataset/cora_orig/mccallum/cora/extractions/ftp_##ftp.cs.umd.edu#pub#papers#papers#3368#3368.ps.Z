URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3368/3368.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: Lionel.Briand@crim.ca  morasca@elet.polimi.it  basili@cs.umd.edu  
Title: Property-based Software Engineering Measurement  
Author: Lionel Briand Sandro Morasca Victor R. Basili 
Note: 1 Introduction  
Address: 1801 McGill College Avenue Montral (Quebec), H3A 2N4 Canada  Piazza Leonardo da Vinci 32 I-20133 Milano, Italy  College Park, MD 20742  
Date: 1  
Affiliation: University of Maryland  CRIM  Dip. di Elettronica e Informazione Politecnico di Milano  Computer Science Department University of Maryland  
Pubnum: CS-TR-3368  
Abstract: Little theory exists in the field of software system measurement. Concepts such as complexity, coupling, cohesion or even size are very often subject to interpretation and appear to have inconsistent definitions in the literature. As a consequence, there is little guidance provided to the analyst attempting to define proper measures for specific problems. Many controversies in the literature are simply misunderstandings and stem from the fact that some people talk about different measurement concepts under the same label (complexity is the most common case). There is a need to define unambiguously the most important measurement concepts used in the measurement of software products. One way of doing so is to define precisely what mathematical properties characterize these concepts, regardless of the specific software artifacts to which these concepts are applied. Such a mathematical framework could generate a consensus in the software engineering community and provide a means for better communication among researchers, better guidelines for analysts, and better evaluation methods for commercial static analyzers for practitioners. In this paper, we propose a mathematical framework which is generic, because it is not specific to any particular software artifact, and rigorous, because it is based on precise mathematical concepts. This framework defines several important measurement concepts (size, length, complexity, cohesion, coupling). It does not intend to be complete or fully objective; other frameworks could have been proposed and different choices could have been made. However, we believe that the formalisms and properties we introduce are convenient and intuitive. In addition, we have reviewed the literature on this subject and compared it with our work. This framework contributes constructively to a firmer theoretical ground of software measurement. Many concepts have been introduced through the years to define the characteristics of the artifacts produced during the software process. For instance, one speaks of size and complexity of software specification, design, and code, or cohesion and coupling of a software design or code. Several techniques have been introduced, with the goal of producing software which is better with respect to these concepts. As an example, Parnas [P72] design principles attempt to decrease coupling between modules, and increase cohesion within modules. These concepts are used as a guide to choose among alternative techniques or artifacts. For instance, a technique may be preferred over another because it yields artifacts that are less complex; an artifact may be preferred over another because it is less complex. In turn, lower complexity is believed to provide advantages such as lower maintenance time and cost. This shows the importance of a clear and unambiguous understanding of what these concepts actually mean, to make choices on more objective bases. The This work was supported in part by NASA grant NSG5123, UMIACS, NSF grant 01-5-24845, MURST, and CNR. This Tecnical Report is also available as Internal Report 94.078, Politecnico di Milano, Dipartimento di Elettronica e Informazione. 
Abstract-found: 1
Intro-found: 0
Reference: [BMB94(a)] <author> L. Briand, S. Morasca, V. Basili, </author> <title> "Defining and Validating High-Level Design Metrics, </title> <type> CS-TR 3301, </type> <institution> University of Maryland, College Park </institution>
Reference: [BMB94(b)] <author> L. Briand, S. Morasca, and V. R. Basili, </author> <title> "A Goal-Driven Definition Process for Product Metrics Based on Properties," </title> <institution> University of Maryland, Department of Computer Science, </institution> <type> Tech. Rep. </type> <institution> CS-TR-3346, UMIACS-TR-94-106, </institution> <year> 1994. </year> <note> Submitted for publication. </note>
Reference: [BO94] <author> J. Bieman and L. M. Ott, </author> <title> "Measuring Functional Cohesion, </title> <journal> IEEE Trans. Software Eng., </journal> <volume> vol. 20, no. 8, </volume> <pages> pp. 644-657, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Other examples of cohesion measures can be found in <ref> [BO94] </ref>, where new functional cohesion measures are introduced. Given a procedure, function, or main program, only data tokens (i.e., the occurrence of a definition or use of a variable or a constant) are taken into account.
Reference: [C90] <author> D. Card, </author> <title> "Measuring Software Design Quality, </title> <publisher> Prentice-Hall Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1990. </year>
Reference-contexts: Therefore, Henry and Kafura [HK81] information flow measure is not a complexity measure according to our definition. However, fan-in and fanout taken as separate measures, without exponent 2, are complexity measures according to our definition since all the required properties hold. Similar measures have been used in <ref> [C90] </ref> and referred to as structural complexity (SC) and defined as: SC = i [1..n] fanout 2 (subroutine i ) n Once again, property Complexity.5 does not hold because fanout is squared in the formula. A metric suite for objectoriented design is proposed in [CK94].
Reference: [CK94] <author> S. R. Chidamber and C. Kemerer, </author> <title> "A Metrics Suite for Object Oriented Design," </title> <journal> IEEE Trans. Software Eng., </journal> <volume> vol. 20, no. 6, </volume> <pages> pp. 476-493, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Surprisingly, whenever a new measure which was proposed as a software complexity measure did not satisfy the set of properties against which it was checked, several authors failed to conclude that their measure was not a software complexity measure, e.g., <ref> [CK94, H92] </ref>. Instead, they concluded that their measure was a complexity measure that does not satisfy that set of properties for complexity measures. <p> Note that, in this context, the graph is just the sequence of operand and operator occurrences. Disjoint code segments are disjoint subgraphs. On the other hand, other measures, that are meant to capture other concepts, are indeed size measures. For instance, in the objectoriented suite of measures defined in <ref> [CK94] </ref>, Weighted Methods per Class (WMC) is defined as the sum of the complexities of methods in a class. Implicitly, the program is seen as a directed acyclic graph (a hierarchy) whose terminal nodes are methods, and whose nonterminal nodes are classes. <p> However, WMC does not satisfy our properties for complexity measures (see Section 3.3). Likewise, NOC (Number Of Children of a class) and Response For a Class (RFC) <ref> [CK94] </ref> are other size measures, according to our properties. University of Maryland CS-TR-3368 - 8 3.2. Length Motivation Properties Size.1 - Size.3 characterize the concept of size as is commonly intended in software engineering. <p> A typical example is the depth of a hierarchy. Therefore, the nesting depth in a program [F91] and DIT (Depth of Inheritance Treewhich is actually a hierarchy, in the general case) defined in <ref> [CK94] </ref> are length measures. 3 . 3 . C o m p l e x i t y Motivation Intuitively, complexity is a measurement concept that is considered extremely relevant to system properties. <p> A metric suite for objectoriented design is proposed in <ref> [CK94] </ref>. A system is an object oriented design, modules are classes, elements are either methods or instance variables (depending on the measure considered) and relationships are calls to methods or uses of instance variables by other methods. <p> These measures are validated against Weyuker's properties for complexity measures, thereby implicitely implying that they were complexity measures. However, none of the measures defined by <ref> [CK94] </ref> is a complexity measure according to our properties: University of Maryland CS-TR-3368 - 15 Weighted Methods per Class (WMC) and Number Of Children of a class (NOC) are size measures (see Section 3.1); Depth of Inheritance Tree (DIT) is a length measure (see Section 3.2); Coupling Between Object classes (CBO) <p> This is consistent with what was said in the introduction: our framework does not cover all possible measurement concepts. This is not surprising. In <ref> [CK94] </ref>, it is shown that all of the above measures do not satisfy Weyuker's property 9, which is a weaker form of property Complexity.4 (see Section 4). 3 . 4 . Cohesion Motivation The concept of cohesion has been used with reference to modules or modular systems. <p> As shown in [BMB94 (a)], our coupling properties hold for these measures. Coupling Between Object classes (CBO) of a class is defined in <ref> [CK94] </ref> as the number of other classes to which it is coupled. It is a coupling measure. Properties Coupling.1 and Coupling.2 are obviously satisfied. <p> Property Coupling.4 is satisfied: CBO can only remain constant or decrease when two classes are grouped into one. Property Coupling.4 is also satisfied. Response For a Class (RFC) <ref> [CK94] </ref> is a size and a coupling measure at the same time (see Section 3.1). Methods are elements, calls are relationships, classes are modules. <p> Second, the concepts appear to have the null value (second column) and monotonicity (third column) properties based on different sets. The behavior of a measure with respect to variations in such sets characterizes the nature of the measure itself, i.e., the concept (s) it captures. As RFC, defined in <ref> [CK94] </ref>, shows (see Sections 3.1 and 3.5), the same measure may satisfy the sets of properties associated with different concepts. As a matter of fact, similar sets of properties associated with different concepts are not contradictory. <p> Weyuker 3 Weyuker's work [W88] is one of the first attempts to formalize the fuzzy concept of program complexity. This work has been discussed by many authors <ref> [CK94, F91, LJS91, TZ92, Z91] </ref> and is still a point of reference and comparison for anyone investigating the topic of software complexity.
Reference: [CS91] <author> J. C. Cherniavsky and C. H. Smith, </author> <title> "On Weyuker's Axioms for Software Complexity Measures," </title> <journal> IEEE Trans. Software Eng., </journal> <volume> vol. 17, no. 6, </volume> <pages> pp. 636-638, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: We think that properties should be used to check whether a measure actually addresses a given concept (e.g., complexity). However, given any set of properties, it is almost always possible to build a measure that satisfies them, but is of no practical interest (see <ref> [CS91] </ref>). At any rate, this is not a sensible reason to reject a set of properties associated with a concept (how many sensless measures could be defined that satisfy the three properties that characterize distance!).
Reference: [ESE94] <institution> Encyclopaedia of Software Engineering, Wiley&Sons Inc., 1994 University of Maryland CS-TR-3368 - 28 </institution>
Reference-contexts: The focus is on the conditions that should be satisfied by empirical relational systems in order to provide them with additive ratio scale measures. This class of measures is a subset of ratio scale measures, characterized by the additivity property (Theorems 2 and 3 of <ref> [ESE94] </ref>).
Reference: [F91] <author> N. Fenton, </author> <title> "Software Metrics, A Rigorous Approach," </title> <address> Chapman&Hall, </address> <year> 1991. </year>
Reference-contexts: Properties Size.1 - Size.3 hold when applying the admissible transformation of the ratio scale <ref> [F91] </ref>. Therefore, there is no contradiction between our concept of size and the definition of size measures on a ratio scale. Examples and counterexamples of size measures Several measures introduced in the literature can be classified as size measures, according to our properties Size.1 - Size.3. <p> Examples of length measures Several measures can be defined at the system or module level based on the length concept. A typical example is the depth of a hierarchy. Therefore, the nesting depth in a program <ref> [F91] </ref> and DIT (Depth of Inheritance Treewhich is actually a hierarchy, in the general case) defined in [CK94] are length measures. 3 . 3 . C o m p l e x i t y Motivation Intuitively, complexity is a measurement concept that is considered extremely relevant to system properties. <p> It assesses the tightness with which "related" program features are "grouped together" in systems or modules. It is assumed that the better the programmer is able to encapsulate related program features together, the more reliable and maintainable the system <ref> [F91] </ref>. This assumption seems to be supported by experimental results [BMB94 (a)]. Intuitively, we expect cohesion to be non-negative and, more importantly, to be normalized (property Cohesion.1) so that the measure is independent of the size of the modular system or module. <p> Therefore, there is no contradiction between our concept of coupling and the definition of coupling measures on a ratio scale. Examples and counterexamples of coupling measures Fenton has defined an ordinal coupling measure between pairs of subroutines <ref> [F91] </ref> as follows: C (S, S') = i + n + 1 University of Maryland CS-TR-3368 - 20 where i is the number corresponding to the worst coupling type (according to Myers' ordinal scale [F91]) and n the number of interconnections between S and S', i.e., global variables and formal parameters. <p> and counterexamples of coupling measures Fenton has defined an ordinal coupling measure between pairs of subroutines <ref> [F91] </ref> as follows: C (S, S') = i + n + 1 University of Maryland CS-TR-3368 - 20 where i is the number corresponding to the worst coupling type (according to Myers' ordinal scale [F91]) and n the number of interconnections between S and S', i.e., global variables and formal parameters. In this case, systems are programs, modules are subroutines, elements are formal parameters and global variables. <p> Weyuker 3 Weyuker's work [W88] is one of the first attempts to formalize the fuzzy concept of program complexity. This work has been discussed by many authors <ref> [CK94, F91, LJS91, TZ92, Z91] </ref> and is still a point of reference and comparison for anyone investigating the topic of software complexity. <p> In other words, "small" modules of a system are no more complex than the system. TZ4: If an intuitive complexity order relation exists between two systems, it must be preserved by the complexity measure (it is a weakened form of the representation condition of Measurement Theory <ref> [F91] </ref>). TZ5: Measures must not be too coarse and must show sufficient variability. TZ1, TZ2, TZ5 do not differentiate software characteristics (concepts) and can be used for all syntactic product measures. TZ3 can be derived from our set of properties.
Reference: [F94] <author> N. Fenton, </author> <title> "Software Measurement: A Necessary Scientific Basis, </title> <journal> IEEE Trans. Software Eng., </journal> <volume> vol. 20, no. 3, </volume> <pages> pp. 199-206, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Our point is that complexity is not the only factor to be taken into account when evaluating the effort needed to implement or understand a program, nor is it proven that this effort is in any way "proportional" to product complexity. Fenton In addition to Weyuker's work, Fenton <ref> [F94] </ref> shows that, based on measurement-theoretic mathematical grounds, there is no chance that a general measure for software complexity will ever be found, nor even for control flow complexity, i.e., a more specific kind of complexity. We totally agree with that.
Reference: [FM90] <author> N. Fenton and A. Melton, </author> <title> "Deriving Structurally Based Software Measures, </title> <journal> J. Syst. Software, </journal> <volume> vol. 12, </volume> <pages> pp. 177-187, </pages> <year> 1990. </year>
Reference-contexts: Comparison with Related Work We mainly compare our approach with the other approaches for defining sets of properties for software complexity measures, because they have been studied more extensively and thoroughly than other kinds of measures. Besides, we compare our approach with the axioms introduced by Fenton and Melton <ref> [FM90] </ref> for software coupling measures. As already mentioned, our approach generalizes previous work on properties for defining complexity measures. <p> We totally agree with that. By no means do we aim at defining a single complexity measure, which captures all kinds of complexity in a software artifact. Instead, our set of properties define constraints for any specific complexity measure, whatever facet of complexity it addresses. Fenton and Melton <ref> [FM90] </ref> introduced two axioms that they believe should hold for coupling measures. Both axioms assume that coupling is a measure of connectivity of a system represented by its module design chart (or structure chart). The first axiom is similar to our monotonicity property (Coupling.3).
Reference: [H77] <author> M. H. Halstead, </author> <title> "Elements of Software Science," </title> <publisher> Elsevier North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: Examples and counterexamples of size measures Several measures introduced in the literature can be classified as size measures, according to our properties Size.1 - Size.3. With reference to code measures, we have: LOC, #Statements, #Modules, #Procedures, Halstead's Length <ref> [H77] </ref>, #Occurrences of Operators, #Occurrences of Operands, #Unique Operators, #Unique Operands. In each of the above cases, the representation of a program as a system is quite straightforward. Each counted entity is an element, and the relationship between elements is just the sequential relationship. <p> Each counted entity is an element, and the relationship between elements is just the sequential relationship. Some other measures that have been introduced as size measures do not satisfy the above properties. Instances are the Estimator of length, and Volume <ref> [H77] </ref>, which are not additive when software modules are disjoint (property Size.3). Indeed, for both measures, the value obtained when two disjoint software modules are concatenated may be less than the sum of the values obtained for each module, since they may contain common operators or operands.
Reference: [H92] <author> W. Harrison, </author> <title> "An Entropy-Based Measure of Software Complexity," </title> <journal> IEEE Trans. Software Eng., </journal> <volume> vol. 18, no. 11, </volume> <pages> pp. 1025-1029, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Surprisingly, whenever a new measure which was proposed as a software complexity measure did not satisfy the set of properties against which it was checked, several authors failed to conclude that their measure was not a software complexity measure, e.g., <ref> [CK94, H92] </ref>. Instead, they concluded that their measure was a complexity measure that does not satisfy that set of properties for complexity measures.
Reference: [HK81] <author> S. Henry and D. Kafura, </author> <title> "Software Structure Metrics Based on Information Flow, </title> <journal> IEEE Trans. Software Eng., </journal> <volume> vol. 7, no. 5, </volume> <pages> pp. 510-518, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: However, it can be shown that v (G)-p satisfies all the above complexity properties. From a practical perspective, especially in large systems, this correction does not have a significant impact on the value of the measure. University of Maryland CS-TR-3368 - 14 G 1 G Henry and Kafura <ref> [HK81] </ref> proposed an information flow complexity measure. In this context, elements are subprogram variables or parameters, modules are subprograms, relationships are either fan-in's or fanout's. For a subprogram SP, the complexity is expressed as length.(fan in.fan-out) 2 , where fan-in and fanout are, respectively, the local (as defined in [HK81]) information <p> Kafura <ref> [HK81] </ref> proposed an information flow complexity measure. In this context, elements are subprogram variables or parameters, modules are subprograms, relationships are either fan-in's or fanout's. For a subprogram SP, the complexity is expressed as length.(fan in.fan-out) 2 , where fan-in and fanout are, respectively, the local (as defined in [HK81]) information flows from other subprograms to SP, and from SP to other subprograms. Such local information flows can be represented as relationships between parameters/variables of SP and parameters/variables of the other subprograms. Subprograms' parameters/variables are the system elements and the subprograms' fan-in and fanout links are the relationships. <p> Such local information flows can be represented as relationships between parameters/variables of SP and parameters/variables of the other subprograms. Subprograms' parameters/variables are the system elements and the subprograms' fan-in and fanout links are the relationships. Any size measure can be used for length (in <ref> [HK81] </ref> LOC was used). <p> However, equality does not hold because of the exponent 2, which is not fully justified, and multiplication of fan-in and fanout. Therefore, Henry and Kafura <ref> [HK81] </ref> information flow measure is not a complexity measure according to our definition. However, fan-in and fanout taken as separate measures, without exponent 2, are complexity measures according to our definition since all the required properties hold.
Reference: [LJS91] <author> K. B. Lakshmanan, S. Jayaprakash, and P. K. Sinha, </author> <title> "Properties of Control-Flow Complexity Measures," </title> <journal> IEEE Trans. Software Eng., </journal> <volume> vol. 17, no. 12, </volume> <pages> pp. 1289-1295, </pages> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: To this end, several proposals have appeared in the literature <ref> [LJS91, TZ92, W88] </ref> in recent years to provide desirable properties for software measures. These works (especially [W88]) have been used to "validate" existing and newly proposed software measures. <p> The properties we define for complexity are, to a limited extent, a generalization of the properties several authors have already provided in the literature (see <ref> [LJS91, TZ92, W88] </ref>) for software code complexity, usually for control flow graphs. We generalize them because we may want to use them on artifacts other than software code and on abstractions other than control flow graphs. <p> Weyuker 3 Weyuker's work [W88] is one of the first attempts to formalize the fuzzy concept of program complexity. This work has been discussed by many authors <ref> [CK94, F91, LJS91, TZ92, Z91] </ref> and is still a point of reference and comparison for anyone investigating the topic of software complexity. <p> Some of these properties are related to the properties defined in this paper and we believe they are characteristic properties of distinct system concepts (e.g., system monotonicity). Others do not differentiate the various concepts associated with syntactically-based measures (e.g., renaming). Lakshmanian et al. Lakshmanian et al. <ref> [LJS91] </ref> have attempted to define necessary properties for software complexity measures based on control flow graphs. In order to make these properties comparable to ours, we will use a notation similar to the one used to introduce Weyuker's properties. <p> Lakshmanian et al. <ref> [LJS91] </ref> introduce nine properties. However, only five out of them can be considered basic, since the remaining four can be derived from them. Therefore, below we will only discuss the compatibility of the basic properties with respect to our properties. L1: Non-negativity. L1 (a): Null value.
Reference: [McC76] <author> T. J. McCabe, </author> <title> "A Complexity Measure," </title> <journal> IEEE Trans. Software Eng., </journal> <volume> vol. 2, no. 5, </volume> <pages> pp. 308-320, </pages> <month> Apr. </month> <year> 1976. </year>
Reference-contexts: The number of definition-use relationships of a system composed of two disjoint modules (i.e., blocks between which no definition-use relationship exists), is equal to the sum of the numbers of definition-use relationships of each module. As a conclusion, DF is a complexity measure according to our definition. In <ref> [McC76] </ref>, McCabe proposed a control flow complexity measure. Given a control flow graph G=&lt;E,R&gt; (which correspondsunchangedto a system for our framework), Cyclomatic Complexity is defined as v (G)=|R|-|E|+2p where p is the number of connected components of G.
Reference: [MGB90] <author> A. C. Melton, D.A. Gustafson, J. M. Bieman, and A. A. Baker, </author> <title> "Mathematical Perspective of Software Measures Research," </title> <journal> IEE Software Eng. J., </journal> <volume> vol. 5, no. 5, </volume> <pages> pp. 246-254, </pages> <year> 1990. </year>
Reference-contexts: There are other factors that have a strong influence on understandability, such as the amount of available context information and knowledge about a system. In the literature <ref> [MGB90] </ref>, it has been argued that the inner loop of the ShellSort algorithm, taken in isolation, is less understandable than the whole algorithm, since the role of the inner loop in the algorithm cannot be fully understood without the rest of the algorithm. <p> TZ1, TZ2, TZ5 do not differentiate software characteristics (concepts) and can be used for all syntactic product measures. TZ3 can be derived from our set of properties. TZ4 captures the basic purpose behind the definition of all measures: preserving an intuitive order on a set of software artifacts <ref> [MGB90] </ref>. The additional set of properties which is presented in [TZ92] is used to define a measure classification system.
Reference: [O80] <author> E. I. Oviedo, </author> <title> "Control Flow, Data Flow and Program Complexity," </title> <booktitle> Proc. IEEE COMPSAC, </booktitle> <month> Nov. </month> <year> 1980, </year> <pages> pp. 146-152. </pages>
Reference-contexts: Therefore, there is no contradiction between our concept of complexity and the definition of complexity measures on a ratio scale. Comprehensive comparisons and discussions of previous work in the area of complexity properties are provided in Section 4. Examples and counterexamples of complexity measures In <ref> [O80] </ref>, Oviedo proposed a data flow complexity measure (DF). In this case, systems are programs, modules are program blocks, elements are variable definitions or uses, and relationships are defined between the definition of a given variable and its uses. The measure in [O80] is simply defined as the number of definition-use <p> Examples and counterexamples of complexity measures In <ref> [O80] </ref>, Oviedo proposed a data flow complexity measure (DF). In this case, systems are programs, modules are program blocks, elements are variable definitions or uses, and relationships are defined between the definition of a given variable and its uses. The measure in [O80] is simply defined as the number of definition-use pairs in a block or a program. Property Complexity.4 holds.
Reference: [P72] <author> D. L. Parnas, </author> <title> "On the Criteria to Be Used in Decomposing Systems into Modules," </title> <journal> Communications of the ACM, </journal> <volume> vol. 15, </volume> <pages> pp. 1053-1058, </pages> <month> May </month> <year> 1972. </year>
Reference-contexts: For instance, one speaks of size and complexity of software specification, design, and code, or cohesion and coupling of a software design or code. Several techniques have been introduced, with the goal of producing software which is better with respect to these concepts. As an example, Parnas <ref> [P72] </ref> design principles attempt to decrease coupling between modules, and increase cohesion within modules. These concepts are used as a guide to choose among alternative techniques or artifacts.
Reference: [P84] <author> R. E. Prather, </author> <title> "An Axiomatic Theory of Software Complexity Measure," </title> <journal> T h e Computer Journal, </journal> <volume> vol 27, </volume> <editor> n. </editor> <volume> 4, </volume> <pages> pp. 340-346, </pages> <year> 1984. </year>
Reference-contexts: W9: This is probably the most controversial property. The above properties Complexity.1 - Complexity.5 imply it. Actually, our properties imply the stronger form of W9, the unnumbered property following W9 in Weyuker's paper [W88] (see also <ref> [P84] </ref>) " S P , S Q Complexity (S P ) + Complexity (S Q ) Complexity (S P;Q ) Weyuker rejects it on the basis that it might lead to contradictions: she argues that the effort needed to implement or understand the composition of a program body P with itself,
Reference: [S92] <author> M. Shepperd, </author> <title> "Algebraic Models and Metric Validation," in Formal Aspects of Measurement (T. </title> <editor> Denvir, R. Herman, and R. W. </editor> <booktitle> Whitty eds.), </booktitle> <pages> pp. 157-173, </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Many of the measure properties proposed in the literature are generic in the sense that they do not characterize specific measurement concepts but are relevant to all syntactically-based measures (see <ref> [S92, TZ92, W88] </ref>). In this paper, we want to focus on properties that differentiate measurement concepts such as size, complexity, coupling, etc. Thus, we want to identify and clarify the essential properties behind these concepts that are commonplace in software engineering and form important classes of measures.
Reference: [TZ92] <author> J. Tian and M. V. Zelkowitz, </author> <title> "A Formal Program Complexity Model and Its Application," </title> <journal> J. Syst. Software, </journal> <volume> vol. 17, </volume> <pages> pp. 253-266, </pages> <year> 1992. </year>
Reference-contexts: To this end, several proposals have appeared in the literature <ref> [LJS91, TZ92, W88] </ref> in recent years to provide desirable properties for software measures. These works (especially [W88]) have been used to "validate" existing and newly proposed software measures. <p> Many of the measure properties proposed in the literature are generic in the sense that they do not characterize specific measurement concepts but are relevant to all syntactically-based measures (see <ref> [S92, TZ92, W88] </ref>). In this paper, we want to focus on properties that differentiate measurement concepts such as size, complexity, coupling, etc. Thus, we want to identify and clarify the essential properties behind these concepts that are commonplace in software engineering and form important classes of measures. <p> The properties we define for complexity are, to a limited extent, a generalization of the properties several authors have already provided in the literature (see <ref> [LJS91, TZ92, W88] </ref>) for software code complexity, usually for control flow graphs. We generalize them because we may want to use them on artifacts other than software code and on abstractions other than control flow graphs. <p> Weyuker 3 Weyuker's work [W88] is one of the first attempts to formalize the fuzzy concept of program complexity. This work has been discussed by many authors <ref> [CK94, F91, LJS91, TZ92, Z91] </ref> and is still a point of reference and comparison for anyone investigating the topic of software complexity. <p> We believe this is a very questionable assumption for product complexity. Tian and Zelkowitz Tian and Zelkowitz <ref> [TZ92] </ref> have provided axioms (necessary properties) for complexity measures and a classification scheme based on additional program characteristics that identify important measure categories. In the approach, programs are represented by means of their abstract syntax trees (e.g., parse trees). <p> TZ3 can be derived from our set of properties. TZ4 captures the basic purpose behind the definition of all measures: preserving an intuitive order on a set of software artifacts [MGB90]. The additional set of properties which is presented in <ref> [TZ92] </ref> is used to define a measure classification system.
Reference: [W88] <author> E. J. Weyuker, </author> <title> "Evaluating Software Complexity Measures," </title> <journal> IEEE Trans. Software Eng., </journal> <volume> vol. 14, no. 9, </volume> <pages> pp. 1357-1365, </pages> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: To this end, several proposals have appeared in the literature <ref> [LJS91, TZ92, W88] </ref> in recent years to provide desirable properties for software measures. These works (especially [W88]) have been used to "validate" existing and newly proposed software measures. <p> To this end, several proposals have appeared in the literature [LJS91, TZ92, W88] in recent years to provide desirable properties for software measures. These works (especially <ref> [W88] </ref>) have been used to "validate" existing and newly proposed software measures. <p> Many of the measure properties proposed in the literature are generic in the sense that they do not characterize specific measurement concepts but are relevant to all syntactically-based measures (see <ref> [S92, TZ92, W88] </ref>). In this paper, we want to focus on properties that differentiate measurement concepts such as size, complexity, coupling, etc. Thus, we want to identify and clarify the essential properties behind these concepts that are commonplace in software engineering and form important classes of measures. <p> The properties we define for complexity are, to a limited extent, a generalization of the properties several authors have already provided in the literature (see <ref> [LJS91, TZ92, W88] </ref>) for software code complexity, usually for control flow graphs. We generalize them because we may want to use them on artifacts other than software code and on abstractions other than control flow graphs. <p> Moreover, it is not defined based on some control flow operations, like sequencing or nesting, but on a general representation, i.e., a graph. Weyuker 3 Weyuker's work <ref> [W88] </ref> is one of the first attempts to formalize the fuzzy concept of program complexity. This work has been discussed by many authors [CK94, F91, LJS91, TZ92, Z91] and is still a point of reference and comparison for anyone investigating the topic of software complexity. <p> W9: This is probably the most controversial property. The above properties Complexity.1 - Complexity.5 imply it. Actually, our properties imply the stronger form of W9, the unnumbered property following W9 in Weyuker's paper <ref> [W88] </ref> (see also [P84]) " S P , S Q Complexity (S P ) + Complexity (S Q ) Complexity (S P;Q ) Weyuker rejects it on the basis that it might lead to contradictions: she argues that the effort needed to implement or understand the composition of a program body
Reference: [Z91] <author> H. Zuse, </author> <title> Software Complexity: Measures and Methods. </title> <publisher> Amsterdam: de Gruyter, </publisher> <year> 1991. </year>
Reference-contexts: Weyuker 3 Weyuker's work [W88] is one of the first attempts to formalize the fuzzy concept of program complexity. This work has been discussed by many authors <ref> [CK94, F91, LJS91, TZ92, Z91] </ref> and is still a point of reference and comparison for anyone investigating the topic of software complexity.
References-found: 23

