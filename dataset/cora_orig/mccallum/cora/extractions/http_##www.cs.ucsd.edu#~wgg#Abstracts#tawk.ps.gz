URL: http://www.cs.ucsd.edu/~wgg/Abstracts/tawk.ps.gz
Refering-URL: http://www.cs.ucsd.edu/~wgg/Abstracts/tawk.html
Root-URL: http://www.cs.ucsd.edu
Note: Copyright 1996 IEEE. Published in the Proceedings of the IEEE Fourth Workshop on Program Comprehension (WPA-96), March 29-31, 1996, Berlin, Germany. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works, must be obtained from the IEEE.  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> B. W. Boehm. </author> <title> The high cost of software. </title> <editor> In E. Horowitz, editor, </editor> <title> Practical Strategies for Developing Large Software Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1975. </year>
Reference-contexts: 1 Introduction Understanding software well enough to modify, reuse, or extend it is notoriously expensive <ref> [1] </ref>. A large part of the difficulty is understanding the semantic relationships between program components that are syntactically far apart from each other. <p> Throughout the paper we use the extraction of call-graph information as a prototypical example. Although not especially complicated, call-graph extraction is an appropriate problem for all of the approaches discussed, and succinctly reveals the strengths and weaknesses of each. <ref> [1] </ref> #!/usr/local/bin/mawk -f [2] [3] # initialize regular expressions [4] BEGIN - [5] WS = "[ "t"n]*" [7] IDCC = "[a-zA-Z0-9_]" [8] CALL = ID WS ""(" [9] DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 [13] RS=""n"n+" <p> Consequently, they chose to sacrifice some precision and accuracy to facilitate quickly developing an abstraction of the code. Their approach also makes several adjustments relative to other lexical approaches to make the matching of pro <ref> [1] </ref> comment /* */ [2] [3] [&lt;type&gt;] &lt;fn&gt; [4] @ if kywdq (fn) | opq (fn) then fail @ [5] "( [-&lt;param&gt;-+] ") [- -&lt;atype&gt;-+ ; -+] "- [6] [8] @ if kywdq (cn) | opq (cn) then fail @ [9] "( [ - &lt;arg&gt; [ , ] -+ ] ") <p> A* does not compute attributes such as symbol table information, although it is possible in principle. is performed on the abstract syntax tree (AST) of the program. SCRUPLE uses a state machine and stack to support top-down matching and backtracking on failed matches. <ref> [1] </ref> $t $f_decl () [2] -* [4] @-* #-* $f_call (#*) * *- [5] @* call) are printed to an output window in the tool. The pattern shown in Figure 3 is a call-graph extractor for C written in SCRUPLE. <p> This was chosen to avoid the spurious and perhaps costly creation and destruction of sets for other types of declarations, although it also has the effect of not matching the uses of macros in global static initializers. <ref> [1] </ref> %- [2] #define FDECL " [3] &lt;declaration:FUNCTION|declaration:MACRO&gt; [4] #define CALL expression:FUNCTION [5] [6] String curCaller; [7] Set cSet; /* funcs called by curCaller */ [8] %- [10] FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); [12] cSet = [13] SetCreate (StrCompare, StrId, NULL); [14] - [16] [CALL:$fcall]
Reference: [2] <author> A. V. Aho. </author> <title> Pattern matching in strings. </title> <editor> In R. V. Book, editor, </editor> <booktitle> Formal Language Theory: Perspectives and Open Problems, </booktitle> <pages> pages 325-347. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: Throughout the paper we use the extraction of call-graph information as a prototypical example. Although not especially complicated, call-graph extraction is an appropriate problem for all of the approaches discussed, and succinctly reveals the strengths and weaknesses of each. [1] #!/usr/local/bin/mawk -f <ref> [2] </ref> [3] # initialize regular expressions [4] BEGIN - [5] WS = "[ "t"n]*" [7] IDCC = "[a-zA-Z0-9_]" [8] CALL = ID WS ""(" [9] DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 [13] RS=""n"n+" # rec. sep. <p> The exploitation of programming conventions, unless they are widely adhered to, limits the reusability of queries. 2.1 The AWK family of tools The most well-known examples of lexical matching tools are GREP and AWK. GREP provides basic line-by-line regular expression pattern matching <ref> [2] </ref>, and AWK extends that model by supporting programmer-defined actions on the matches written in a C-like language [3]. An input line called a recordis divided into fields (i.e., tokens) according to a field separator pattern; each field is addressable by an integer. <p> Consequently, they chose to sacrifice some precision and accuracy to facilitate quickly developing an abstraction of the code. Their approach also makes several adjustments relative to other lexical approaches to make the matching of pro [1] comment /* */ <ref> [2] </ref> [3] [&lt;type&gt;] &lt;fn&gt; [4] @ if kywdq (fn) | opq (fn) then fail @ [5] "( [-&lt;param&gt;-+] ") [- -&lt;atype&gt;-+ ; -+] "- [6] [8] @ if kywdq (cn) | opq (cn) then fail @ [9] "( [ - &lt;arg&gt; [ , ] -+ ] ") [10] @ writeCall ( <p> true if a keyword [24] procedure kywdq (nm) [25] return nm == ("if" | "while" | "switch" | [26] "for" | "typedef") [27] end [29] # true if an operator (approximate) [30] procedure opq (nm) [31] return any ('?;:+-*/%!&=|&lt;&gt;', nm) & [32] (*nm == 1 | [34] any ('+-*/%!&=|&lt;&gt;', nm <ref> [2] </ref>))) gram text easier. Their approach is demonstrated in LSME (Lightweight Source Model Extractor). First, LSME augments AWK's notion of a separator by also treating any single character literal appearing in a pattern as a token, regardless of the separator rules. <p> A* does not compute attributes such as symbol table information, although it is possible in principle. is performed on the abstract syntax tree (AST) of the program. SCRUPLE uses a state machine and stack to support top-down matching and backtracking on failed matches. [1] $t $f_decl () <ref> [2] </ref> -* [4] @-* #-* $f_call (#*) * *- [5] @* call) are printed to an output window in the tool. The pattern shown in Figure 3 is a call-graph extractor for C written in SCRUPLE. It is significantly shorter than the script written using Murphy and Notkin's approach. <p> This was chosen to avoid the spurious and perhaps costly creation and destruction of sets for other types of declarations, although it also has the effect of not matching the uses of macros in global static initializers. [1] %- <ref> [2] </ref> #define FDECL " [3] &lt;declaration:FUNCTION|declaration:MACRO&gt; [4] #define CALL expression:FUNCTION [5] [6] String curCaller; [7] Set cSet; /* funcs called by curCaller */ [8] %- [10] FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); [12] cSet = [13] SetCreate (StrCompare, StrId, NULL); [14] - [16] [CALL:$fcall] - [17]
Reference: [3] <author> A. V. Aho, B. W. Kernighan, and P. J. Weinberger. </author> <title> Awk a pattern scanning and processing language. </title> <journal> Software Practice and Experience, </journal> <volume> 9(4) </volume> <pages> 267-280, </pages> <month> April </month> <year> 1979. </year>
Reference-contexts: Throughout the paper we use the extraction of call-graph information as a prototypical example. Although not especially complicated, call-graph extraction is an appropriate problem for all of the approaches discussed, and succinctly reveals the strengths and weaknesses of each. [1] #!/usr/local/bin/mawk -f [2] <ref> [3] </ref> # initialize regular expressions [4] BEGIN - [5] WS = "[ "t"n]*" [7] IDCC = "[a-zA-Z0-9_]" [8] CALL = ID WS ""(" [9] DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 [13] RS=""n"n+" # rec. sep. is <p> GREP provides basic line-by-line regular expression pattern matching [2], and AWK extends that model by supporting programmer-defined actions on the matches written in a C-like language <ref> [3] </ref>. An input line called a recordis divided into fields (i.e., tokens) according to a field separator pattern; each field is addressable by an integer. The unit of input can be customized by specifying a record separator pattern. <p> Consequently, they chose to sacrifice some precision and accuracy to facilitate quickly developing an abstraction of the code. Their approach also makes several adjustments relative to other lexical approaches to make the matching of pro [1] comment /* */ [2] <ref> [3] </ref> [&lt;type&gt;] &lt;fn&gt; [4] @ if kywdq (fn) | opq (fn) then fail @ [5] "( [-&lt;param&gt;-+] ") [- -&lt;atype&gt;-+ ; -+] "- [6] [8] @ if kywdq (cn) | opq (cn) then fail @ [9] "( [ - &lt;arg&gt; [ , ] -+ ] ") [10] @ writeCall ( fn, <p> This was chosen to avoid the spurious and perhaps costly creation and destruction of sets for other types of declarations, although it also has the effect of not matching the uses of macros in global static initializers. [1] %- [2] #define FDECL " <ref> [3] </ref> &lt;declaration:FUNCTION|declaration:MACRO&gt; [4] #define CALL expression:FUNCTION [5] [6] String curCaller; [7] Set cSet; /* funcs called by curCaller */ [8] %- [10] FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); [12] cSet = [13] SetCreate (StrCompare, StrId, NULL); [14] - [16] [CALL:$fcall] - [17] String called = CallName
Reference: [4] <author> M. D. Brennan. </author> <title> mawk pattern scanning and text processing language. Unix Manual Page, </title> <month> January </month> <year> 1992. </year> <note> Available by FTP from oxy.edu (134.69.1.2), public/mawk. </note>
Reference-contexts: Throughout the paper we use the extraction of call-graph information as a prototypical example. Although not especially complicated, call-graph extraction is an appropriate problem for all of the approaches discussed, and succinctly reveals the strengths and weaknesses of each. [1] #!/usr/local/bin/mawk -f [2] [3] # initialize regular expressions <ref> [4] </ref> BEGIN - [5] WS = "[ "t"n]*" [7] IDCC = "[a-zA-Z0-9_]" [8] CALL = ID WS ""(" [9] DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 [13] RS=""n"n+" # rec. sep. is blank line [14] - [16] <p> The unit of input can be customized by specifying a record separator pattern. MAWK is a slightly more expressive AWK, most notably supporting patterns as data, not just constants <ref> [4] </ref>. As an example, the MAWK script shown in Figure 1 is one possible approach to extracting call-graph information from a C program. The BEGIN clause (lines 4-14), which is executed on start up of the tool, defines the basic patterns for matching portions of function calls and declarations. <p> Consequently, they chose to sacrifice some precision and accuracy to facilitate quickly developing an abstraction of the code. Their approach also makes several adjustments relative to other lexical approaches to make the matching of pro [1] comment /* */ [2] [3] [&lt;type&gt;] &lt;fn&gt; <ref> [4] </ref> @ if kywdq (fn) | opq (fn) then fail @ [5] "( [-&lt;param&gt;-+] ") [- -&lt;atype&gt;-+ ; -+] "- [6] [8] @ if kywdq (cn) | opq (cn) then fail @ [9] "( [ - &lt;arg&gt; [ , ] -+ ] ") [10] @ writeCall ( fn, cn ) @ <p> A* does not compute attributes such as symbol table information, although it is possible in principle. is performed on the abstract syntax tree (AST) of the program. SCRUPLE uses a state machine and stack to support top-down matching and backtracking on failed matches. [1] $t $f_decl () [2] -* <ref> [4] </ref> @-* #-* $f_call (#*) * *- [5] @* call) are printed to an output window in the tool. The pattern shown in Figure 3 is a call-graph extractor for C written in SCRUPLE. It is significantly shorter than the script written using Murphy and Notkin's approach. <p> This was chosen to avoid the spurious and perhaps costly creation and destruction of sets for other types of declarations, although it also has the effect of not matching the uses of macros in global static initializers. [1] %- [2] #define FDECL " [3] &lt;declaration:FUNCTION|declaration:MACRO&gt; <ref> [4] </ref> #define CALL expression:FUNCTION [5] [6] String curCaller; [7] Set cSet; /* funcs called by curCaller */ [8] %- [10] FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); [12] cSet = [13] SetCreate (StrCompare, StrId, NULL); [14] - [16] [CALL:$fcall] - [17] String called = CallName ($fcall); [18]
Reference: [5] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Although not especially complicated, call-graph extraction is an appropriate problem for all of the approaches discussed, and succinctly reveals the strengths and weaknesses of each. [1] #!/usr/local/bin/mawk -f [2] [3] # initialize regular expressions [4] BEGIN - <ref> [5] </ref> WS = "[ "t"n]*" [7] IDCC = "[a-zA-Z0-9_]" [8] CALL = ID WS ""(" [9] DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 [13] RS=""n"n+" # rec. sep. is blank line [14] - [16] # When inside <p> Separators delineate fields (and records) by defining what is not in them (e.g., whitespace). In contrast, programming language tokens are typically defined by first and follow sets <ref> [5] </ref>, which is a characterization of what is in them. Consequently, fields are usually not a practical way to access portions of a matched record during processing (e.g., if whitespace does not delineate every token). <p> Their approach also makes several adjustments relative to other lexical approaches to make the matching of pro [1] comment /* */ [2] [3] [&lt;type&gt;] &lt;fn&gt; [4] @ if kywdq (fn) | opq (fn) then fail @ <ref> [5] </ref> "( [-&lt;param&gt;-+] ") [- -&lt;atype&gt;-+ ; -+] "- [6] [8] @ if kywdq (cn) | opq (cn) then fail @ [9] "( [ - &lt;arg&gt; [ , ] -+ ] ") [10] @ writeCall ( fn, cn ) @ [11] [13] procedure writeCall (fn, cf) [14] static idch [15] initial <p> SCRUPLE uses a state machine and stack to support top-down matching and backtracking on failed matches. [1] $t $f_decl () [2] -* [4] @-* #-* $f_call (#*) * *- <ref> [5] </ref> @* call) are printed to an output window in the tool. The pattern shown in Figure 3 is a call-graph extractor for C written in SCRUPLE. It is significantly shorter than the script written using Murphy and Notkin's approach. However, it is also somewhat more cryptic. <p> This was chosen to avoid the spurious and perhaps costly creation and destruction of sets for other types of declarations, although it also has the effect of not matching the uses of macros in global static initializers. [1] %- [2] #define FDECL " [3] &lt;declaration:FUNCTION|declaration:MACRO&gt; [4] #define CALL expression:FUNCTION <ref> [5] </ref> [6] String curCaller; [7] Set cSet; /* funcs called by curCaller */ [8] %- [10] FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); [12] cSet = [13] SetCreate (StrCompare, StrId, NULL); [14] - [16] [CALL:$fcall] - [17] String called = CallName ($fcall); [18] [19] if (called &&
Reference: [6] <author> G. C. Murphy and D. Notkin. </author> <title> Lightweight source model extraction. </title> <booktitle> In ACM SIGSOFT '95 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 116-27, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Also, matching of white space could be generalized by extending the pattern in the WS variable with a regular expression for comments. 2.2 LSME Murphy and Notkin's approach to source model extraction is specifically designed for quickly building high-level models of source code to aid high-level decision making <ref> [6] </ref>. Consequently, they chose to sacrifice some precision and accuracy to facilitate quickly developing an abstraction of the code. <p> Their approach also makes several adjustments relative to other lexical approaches to make the matching of pro [1] comment /* */ [2] [3] [&lt;type&gt;] &lt;fn&gt; [4] @ if kywdq (fn) | opq (fn) then fail @ [5] "( [-&lt;param&gt;-+] ") [- -&lt;atype&gt;-+ ; -+] "- <ref> [6] </ref> [8] @ if kywdq (cn) | opq (cn) then fail @ [9] "( [ - &lt;arg&gt; [ , ] -+ ] ") [10] @ writeCall ( fn, cn ) @ [11] [13] procedure writeCall (fn, cf) [14] static idch [15] initial idch := (&ucase ++ [16] &lcase ++ &digits ++ <p> This was chosen to avoid the spurious and perhaps costly creation and destruction of sets for other types of declarations, although it also has the effect of not matching the uses of macros in global static initializers. [1] %- [2] #define FDECL " [3] &lt;declaration:FUNCTION|declaration:MACRO&gt; [4] #define CALL expression:FUNCTION [5] <ref> [6] </ref> String curCaller; [7] Set cSet; /* funcs called by curCaller */ [8] %- [10] FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); [12] cSet = [13] SetCreate (StrCompare, StrId, NULL); [14] - [16] [CALL:$fcall] - [17] String called = CallName ($fcall); [18] [19] if (called && SetMember
Reference: [7] <author> Ralph E. Griswold and Madge T. Griswold. </author> <title> The Icon Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: Although not especially complicated, call-graph extraction is an appropriate problem for all of the approaches discussed, and succinctly reveals the strengths and weaknesses of each. [1] #!/usr/local/bin/mawk -f [2] [3] # initialize regular expressions [4] BEGIN - [5] WS = "[ "t"n]*" <ref> [7] </ref> IDCC = "[a-zA-Z0-9_]" [8] CALL = ID WS ""(" [9] DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 [13] RS=""n"n+" # rec. sep. is blank line [14] - [16] # When inside a procedure definition [17] !OUTSIDE <p> A pattern delimited by square brackets is optional (such as [&lt;type&gt;] on line 3), and a pattern delimited by curly braces followed by a plus (lines 5, 9) matches the pattern to one or more consecutive elements. Actions, written in Icon <ref> [7] </ref>, are delimited by @ and can be placed anywhere in the pattern (lines 4, 8, 10). The first two actions apply additional criteria to the matched tokens and reject them with fail, if necessary. The code following the pattern is also Icon (lines 13-35). <p> to avoid the spurious and perhaps costly creation and destruction of sets for other types of declarations, although it also has the effect of not matching the uses of macros in global static initializers. [1] %- [2] #define FDECL " [3] &lt;declaration:FUNCTION|declaration:MACRO&gt; [4] #define CALL expression:FUNCTION [5] [6] String curCaller; <ref> [7] </ref> Set cSet; /* funcs called by curCaller */ [8] %- [10] FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); [12] cSet = [13] SetCreate (StrCompare, StrId, NULL); [14] - [16] [CALL:$fcall] - [17] String called = CallName ($fcall); [18] [19] if (called && SetMember (cSet, called)) -
Reference: [8] <author> S. Burson, G. B. Kotik, and L. Z. Markosian. </author> <title> A program transformation approach to automating software re-engineering. </title> <booktitle> In Proceedings of the Fourteenth Annual International Computer Software and Applications Conference, </booktitle> <pages> pages 314-322, </pages> <year> 1990. </year>
Reference-contexts: Although not especially complicated, call-graph extraction is an appropriate problem for all of the approaches discussed, and succinctly reveals the strengths and weaknesses of each. [1] #!/usr/local/bin/mawk -f [2] [3] # initialize regular expressions [4] BEGIN - [5] WS = "[ "t"n]*" [7] IDCC = "[a-zA-Z0-9_]" <ref> [8] </ref> CALL = ID WS ""(" [9] DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 [13] RS=""n"n+" # rec. sep. is blank line [14] - [16] # When inside a procedure definition [17] !OUTSIDE - [18] s = <p> Their approach also makes several adjustments relative to other lexical approaches to make the matching of pro [1] comment /* */ [2] [3] [&lt;type&gt;] &lt;fn&gt; [4] @ if kywdq (fn) | opq (fn) then fail @ [5] "( [-&lt;param&gt;-+] ") [- -&lt;atype&gt;-+ ; -+] "- [6] <ref> [8] </ref> @ if kywdq (cn) | opq (cn) then fail @ [9] "( [ - &lt;arg&gt; [ , ] -+ ] ") [10] @ writeCall ( fn, cn ) @ [11] [13] procedure writeCall (fn, cf) [14] static idch [15] initial idch := (&ucase ++ [16] &lcase ++ &digits ++ '_') <p> Tools such as REFINE <ref> [8] </ref>, SCRUPLE [9], A* [10, 11], and GENOA [12] fall into this category. SCRUPLE is a prototypical syntactic matching tool. 1 To perform a query, the programmer types in a program fragment, substituting syntax-specific wildcards for expressions, statements, or declarations where appropriate. <p> destruction of sets for other types of declarations, although it also has the effect of not matching the uses of macros in global static initializers. [1] %- [2] #define FDECL " [3] &lt;declaration:FUNCTION|declaration:MACRO&gt; [4] #define CALL expression:FUNCTION [5] [6] String curCaller; [7] Set cSet; /* funcs called by curCaller */ <ref> [8] </ref> %- [10] FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); [12] cSet = [13] SetCreate (StrCompare, StrId, NULL); [14] - [16] [CALL:$fcall] - [17] String called = CallName ($fcall); [18] [19] if (called && SetMember (cSet, called)) - [20] SetInsert (cSet, called); [21] printf ("%s: %s"n", curCaller,
Reference: [9] <author> S. Paul and A. Prakash. </author> <title> A framework for source code search using program patterns. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(6) </volume> <pages> 463-475, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: especially complicated, call-graph extraction is an appropriate problem for all of the approaches discussed, and succinctly reveals the strengths and weaknesses of each. [1] #!/usr/local/bin/mawk -f [2] [3] # initialize regular expressions [4] BEGIN - [5] WS = "[ "t"n]*" [7] IDCC = "[a-zA-Z0-9_]" [8] CALL = ID WS ""(" <ref> [9] </ref> DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 [13] RS=""n"n+" # rec. sep. is blank line [14] - [16] # When inside a procedure definition [17] !OUTSIDE - [18] s = $0 [19] while (s != "") <p> to other lexical approaches to make the matching of pro [1] comment /* */ [2] [3] [&lt;type&gt;] &lt;fn&gt; [4] @ if kywdq (fn) | opq (fn) then fail @ [5] "( [-&lt;param&gt;-+] ") [- -&lt;atype&gt;-+ ; -+] "- [6] [8] @ if kywdq (cn) | opq (cn) then fail @ <ref> [9] </ref> "( [ - &lt;arg&gt; [ , ] -+ ] ") [10] @ writeCall ( fn, cn ) @ [11] [13] procedure writeCall (fn, cf) [14] static idch [15] initial idch := (&ucase ++ [16] &lcase ++ &digits ++ '_') [17] [18] realfn := (fn ? (tab (upto (idch)), tab (0))) <p> Tools such as REFINE [8], SCRUPLE <ref> [9] </ref>, A* [10, 11], and GENOA [12] fall into this category. SCRUPLE is a prototypical syntactic matching tool. 1 To perform a query, the programmer types in a program fragment, substituting syntax-specific wildcards for expressions, statements, or declarations where appropriate. <p> The interpreter uses techniques similar to SCRU PLE's <ref> [9] </ref>. In particular, the pattern is converted into an augmented state machine that walks over the AST using up, down, left, and right moves and performs matching tests on the AST nodes as specified by the pattern. Variables are bound as successful matches are performed.
Reference: [10] <author> D. A. Ladd and J. C. Ramming. </author> <title> A*: A language for implementing language processors. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer Languages, </booktitle> <pages> pages 1-10, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: appropriate problem for all of the approaches discussed, and succinctly reveals the strengths and weaknesses of each. [1] #!/usr/local/bin/mawk -f [2] [3] # initialize regular expressions [4] BEGIN - [5] WS = "[ "t"n]*" [7] IDCC = "[a-zA-Z0-9_]" [8] CALL = ID WS ""(" [9] DEFN = ID WS ""([-]+-" <ref> [10] </ref> KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 [13] RS=""n"n+" # rec. sep. is blank line [14] - [16] # When inside a procedure definition [17] !OUTSIDE - [18] s = $0 [19] while (s != "") - [20] if ((start = match <p> comment /* */ [2] [3] [&lt;type&gt;] &lt;fn&gt; [4] @ if kywdq (fn) | opq (fn) then fail @ [5] "( [-&lt;param&gt;-+] ") [- -&lt;atype&gt;-+ ; -+] "- [6] [8] @ if kywdq (cn) | opq (cn) then fail @ [9] "( [ - &lt;arg&gt; [ , ] -+ ] ") <ref> [10] </ref> @ writeCall ( fn, cn ) @ [11] [13] procedure writeCall (fn, cf) [14] static idch [15] initial idch := (&ucase ++ [16] &lcase ++ &digits ++ '_') [17] [18] realfn := (fn ? (tab (upto (idch)), tab (0))) [19] realcf := (cf ? (tab (upto (idch)), tab (0))) [20] <p> Tools such as REFINE [8], SCRUPLE [9], A* <ref> [10, 11] </ref>, and GENOA [12] fall into this category. SCRUPLE is a prototypical syntactic matching tool. 1 To perform a query, the programmer types in a program fragment, substituting syntax-specific wildcards for expressions, statements, or declarations where appropriate. <p> sets for other types of declarations, although it also has the effect of not matching the uses of macros in global static initializers. [1] %- [2] #define FDECL " [3] &lt;declaration:FUNCTION|declaration:MACRO&gt; [4] #define CALL expression:FUNCTION [5] [6] String curCaller; [7] Set cSet; /* funcs called by curCaller */ [8] %- <ref> [10] </ref> FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); [12] cSet = [13] SetCreate (StrCompare, StrId, NULL); [14] - [16] [CALL:$fcall] - [17] String called = CallName ($fcall); [18] [19] if (called && SetMember (cSet, called)) - [20] SetInsert (cSet, called); [21] printf ("%s: %s"n", curCaller, called); [22]
Reference: [11] <author> D. A. Ladd and J. C. Ramming. </author> <title> A*: A language for implementing language processors. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(11) </volume> <pages> 894-901, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: of the approaches discussed, and succinctly reveals the strengths and weaknesses of each. [1] #!/usr/local/bin/mawk -f [2] [3] # initialize regular expressions [4] BEGIN - [5] WS = "[ "t"n]*" [7] IDCC = "[a-zA-Z0-9_]" [8] CALL = ID WS ""(" [9] DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" <ref> [11] </ref> KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 [13] RS=""n"n+" # rec. sep. is blank line [14] - [16] # When inside a procedure definition [17] !OUTSIDE - [18] s = $0 [19] while (s != "") - [20] if ((start = match (s, CALL))) - [21] <p> @ if kywdq (fn) | opq (fn) then fail @ [5] "( [-&lt;param&gt;-+] ") [- -&lt;atype&gt;-+ ; -+] "- [6] [8] @ if kywdq (cn) | opq (cn) then fail @ [9] "( [ - &lt;arg&gt; [ , ] -+ ] ") [10] @ writeCall ( fn, cn ) @ <ref> [11] </ref> [13] procedure writeCall (fn, cf) [14] static idch [15] initial idch := (&ucase ++ [16] &lcase ++ &digits ++ '_') [17] [18] realfn := (fn ? (tab (upto (idch)), tab (0))) [19] realcf := (cf ? (tab (upto (idch)), tab (0))) [20] return write (realfn, " ", realcf) [21] end <p> Tools such as REFINE [8], SCRUPLE [9], A* <ref> [10, 11] </ref>, and GENOA [12] fall into this category. SCRUPLE is a prototypical syntactic matching tool. 1 To perform a query, the programmer types in a program fragment, substituting syntax-specific wildcards for expressions, statements, or declarations where appropriate. <p> it also has the effect of not matching the uses of macros in global static initializers. [1] %- [2] #define FDECL " [3] &lt;declaration:FUNCTION|declaration:MACRO&gt; [4] #define CALL expression:FUNCTION [5] [6] String curCaller; [7] Set cSet; /* funcs called by curCaller */ [8] %- [10] FDECL:$fdef - /* function BEGIN */ <ref> [11] </ref> curCaller = FunctionName ($fdef); [12] cSet = [13] SetCreate (StrCompare, StrId, NULL); [14] - [16] [CALL:$fcall] - [17] String called = CallName ($fcall); [18] [19] if (called && SetMember (cSet, called)) - [20] SetInsert (cSet, called); [21] printf ("%s: %s"n", curCaller, called); [22] - [24] [25] /* function END */
Reference: [12] <author> P.T. Devanbu. </author> <title> GENOA a customizable, language- and front-end independent code analyzer. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering, </booktitle> <pages> pages 307-317, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: strengths and weaknesses of each. [1] #!/usr/local/bin/mawk -f [2] [3] # initialize regular expressions [4] BEGIN - [5] WS = "[ "t"n]*" [7] IDCC = "[a-zA-Z0-9_]" [8] CALL = ID WS ""(" [9] DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token <ref> [12] </ref> OUTSIDE = 1 [13] RS=""n"n+" # rec. sep. is blank line [14] - [16] # When inside a procedure definition [17] !OUTSIDE - [18] s = $0 [19] while (s != "") - [20] if ((start = match (s, CALL))) - [21] match (substr (s, start), ID) [22] len = <p> Tools such as REFINE [8], SCRUPLE [9], A* [10, 11], and GENOA <ref> [12] </ref> fall into this category. SCRUPLE is a prototypical syntactic matching tool. 1 To perform a query, the programmer types in a program fragment, substituting syntax-specific wildcards for expressions, statements, or declarations where appropriate. <p> of not matching the uses of macros in global static initializers. [1] %- [2] #define FDECL " [3] &lt;declaration:FUNCTION|declaration:MACRO&gt; [4] #define CALL expression:FUNCTION [5] [6] String curCaller; [7] Set cSet; /* funcs called by curCaller */ [8] %- [10] FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); <ref> [12] </ref> cSet = [13] SetCreate (StrCompare, StrId, NULL); [14] - [16] [CALL:$fcall] - [17] String called = CallName ($fcall); [18] [19] if (called && SetMember (cSet, called)) - [20] SetInsert (cSet, called); [21] printf ("%s: %s"n", curCaller, called); [22] - [24] [25] /* function END */ [26] FDECL:$fdef - SetDestroy (cSet);
Reference: [13] <author> D. C. Atkinson and W. G. Griswold. </author> <title> The design of whole-program analysis tools. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: each. [1] #!/usr/local/bin/mawk -f [2] [3] # initialize regular expressions [4] BEGIN - [5] WS = "[ "t"n]*" [7] IDCC = "[a-zA-Z0-9_]" [8] CALL = ID WS ""(" [9] DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 <ref> [13] </ref> RS=""n"n+" # rec. sep. is blank line [14] - [16] # When inside a procedure definition [17] !OUTSIDE - [18] s = $0 [19] while (s != "") - [20] if ((start = match (s, CALL))) - [21] match (substr (s, start), ID) [22] len = RLENGTH [23] if (!match <p> if kywdq (fn) | opq (fn) then fail @ [5] "( [-&lt;param&gt;-+] ") [- -&lt;atype&gt;-+ ; -+] "- [6] [8] @ if kywdq (cn) | opq (cn) then fail @ [9] "( [ - &lt;arg&gt; [ , ] -+ ] ") [10] @ writeCall ( fn, cn ) @ [11] <ref> [13] </ref> procedure writeCall (fn, cf) [14] static idch [15] initial idch := (&ucase ++ [16] &lcase ++ &digits ++ '_') [17] [18] realfn := (fn ? (tab (upto (idch)), tab (0))) [19] realcf := (cf ? (tab (upto (idch)), tab (0))) [20] return write (realfn, " ", realcf) [21] end [23] <p> This design decision is inappropriate for large programs. Their AST's can be hundreds of megabytes and exceed virtual memory, requiring adaptive methods for handling the AST <ref> [13, 14] </ref>. * The SCRUPLE designers noted that matching on groups of declarations should not be constrained by declaration order, since the declarations are independent. 3 Consequently, SCRUPLE provides wildcards on sets of some classes of syntax. <p> the uses of macros in global static initializers. [1] %- [2] #define FDECL " [3] &lt;declaration:FUNCTION|declaration:MACRO&gt; [4] #define CALL expression:FUNCTION [5] [6] String curCaller; [7] Set cSet; /* funcs called by curCaller */ [8] %- [10] FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); [12] cSet = <ref> [13] </ref> SetCreate (StrCompare, StrId, NULL); [14] - [16] [CALL:$fcall] - [17] String called = CallName ($fcall); [18] [19] if (called && SetMember (cSet, called)) - [20] SetInsert (cSet, called); [21] printf ("%s: %s"n", curCaller, called); [22] - [24] [25] /* function END */ [26] FDECL:$fdef - SetDestroy (cSet); - 4.5 Design
Reference: [14] <author> W. G. Griswold and D. C. Atkinson. </author> <title> Managing the design trade-offs for a program understanding and transformation tool. </title> <journal> Journal of Systems and Software, </journal> <volume> 30(1-2):99-116, </volume> <month> July-August </month> <year> 1995. </year>
Reference-contexts: regular expressions [4] BEGIN - [5] WS = "[ "t"n]*" [7] IDCC = "[a-zA-Z0-9_]" [8] CALL = ID WS ""(" [9] DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 [13] RS=""n"n+" # rec. sep. is blank line <ref> [14] </ref> - [16] # When inside a procedure definition [17] !OUTSIDE - [18] s = $0 [19] while (s != "") - [20] if ((start = match (s, CALL))) - [21] match (substr (s, start), ID) [22] len = RLENGTH [23] if (!match (substr (s, start, len), [24] KYWD)) [25] print <p> (fn) then fail @ [5] "( [-&lt;param&gt;-+] ") [- -&lt;atype&gt;-+ ; -+] "- [6] [8] @ if kywdq (cn) | opq (cn) then fail @ [9] "( [ - &lt;arg&gt; [ , ] -+ ] ") [10] @ writeCall ( fn, cn ) @ [11] [13] procedure writeCall (fn, cf) <ref> [14] </ref> static idch [15] initial idch := (&ucase ++ [16] &lcase ++ &digits ++ '_') [17] [18] realfn := (fn ? (tab (upto (idch)), tab (0))) [19] realcf := (cf ? (tab (upto (idch)), tab (0))) [20] return write (realfn, " ", realcf) [21] end [23] # true if a keyword <p> This design decision is inappropriate for large programs. Their AST's can be hundreds of megabytes and exceed virtual memory, requiring adaptive methods for handling the AST <ref> [13, 14] </ref>. * The SCRUPLE designers noted that matching on groups of declarations should not be constrained by declaration order, since the declarations are independent. 3 Consequently, SCRUPLE provides wildcards on sets of some classes of syntax. <p> global static initializers. [1] %- [2] #define FDECL " [3] &lt;declaration:FUNCTION|declaration:MACRO&gt; [4] #define CALL expression:FUNCTION [5] [6] String curCaller; [7] Set cSet; /* funcs called by curCaller */ [8] %- [10] FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); [12] cSet = [13] SetCreate (StrCompare, StrId, NULL); <ref> [14] </ref> - [16] [CALL:$fcall] - [17] String called = CallName ($fcall); [18] [19] if (called && SetMember (cSet, called)) - [20] SetInsert (cSet, called); [21] printf ("%s: %s"n", curCaller, called); [22] - [24] [25] /* function END */ [26] FDECL:$fdef - SetDestroy (cSet); - 4.5 Design and implementation details A TAWK <p> A preprocessor replaces each pattern variable reference with a lookup in a table. Each action is then compiled as a separate procedure that is invoked whenever its associated pattern successfully matches an input AST. TAWK is built on top of the Ponder toolset <ref> [14] </ref>, which provides facilities for producing AST's from code, as well as the libraries for AST's and the other data types used in the actions.
Reference: [15] <author> M. Marcus. </author> <title> The Penn Treebank Project, </title> <note> preliminary release. Version 0.5; Compact Disc (CD-ROM), </note> <year> 1992. </year>
Reference-contexts: @ [5] "( [-&lt;param&gt;-+] ") [- -&lt;atype&gt;-+ ; -+] "- [6] [8] @ if kywdq (cn) | opq (cn) then fail @ [9] "( [ - &lt;arg&gt; [ , ] -+ ] ") [10] @ writeCall ( fn, cn ) @ [11] [13] procedure writeCall (fn, cf) [14] static idch <ref> [15] </ref> initial idch := (&ucase ++ [16] &lcase ++ &digits ++ '_') [17] [18] realfn := (fn ? (tab (upto (idch)), tab (0))) [19] realcf := (cf ? (tab (upto (idch)), tab (0))) [20] return write (realfn, " ", realcf) [21] end [23] # true if a keyword [24] procedure kywdq <p> Alternatives are explored left-to-right. Every pattern-action pair is tried in turn from top to bottom in the sequence, so several patterns can match. TAWK's pattern matching language was inspired by a somewhat different language called TGREP <ref> [15] </ref>, designed for matching natural language represented in a tree form. We have adapted and extended TGREP's concepts to meet the needs of matching programming language text represented as an AST. The first concept is the notion of node type.
Reference: [16] <author> Guy L. Steele. </author> <title> COMMON LISP, the Language. </title> <publisher> Digital Press, </publisher> <address> Burlington, MA, 2nd edition, </address> <year> 1991. </year>
Reference-contexts: [4] BEGIN - [5] WS = "[ "t"n]*" [7] IDCC = "[a-zA-Z0-9_]" [8] CALL = ID WS ""(" [9] DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 [13] RS=""n"n+" # rec. sep. is blank line [14] - <ref> [16] </ref> # When inside a procedure definition [17] !OUTSIDE - [18] s = $0 [19] while (s != "") - [20] if ((start = match (s, CALL))) - [21] match (substr (s, start), ID) [22] len = RLENGTH [23] if (!match (substr (s, start, len), [24] KYWD)) [25] print fdecl, ": <p> -&lt;atype&gt;-+ ; -+] "- [6] [8] @ if kywdq (cn) | opq (cn) then fail @ [9] "( [ - &lt;arg&gt; [ , ] -+ ] ") [10] @ writeCall ( fn, cn ) @ [11] [13] procedure writeCall (fn, cf) [14] static idch [15] initial idch := (&ucase ++ <ref> [16] </ref> &lcase ++ &digits ++ '_') [17] [18] realfn := (fn ? (tab (upto (idch)), tab (0))) [19] realcf := (cf ? (tab (upto (idch)), tab (0))) [20] return write (realfn, " ", realcf) [21] end [23] # true if a keyword [24] procedure kywdq (nm) [25] return nm == ("if" <p> The only general solution, perhaps, is to substitute a syntactic macro language <ref> [16, 17] </ref>. SCRUPLE does not cope with macros, but it may be able to in some situations. Since patterns are written in concrete syntax, they can be run through the preprocessor, turning the pattern into a form that can be applied to the postprocessed program text. <p> initializers. [1] %- [2] #define FDECL " [3] &lt;declaration:FUNCTION|declaration:MACRO&gt; [4] #define CALL expression:FUNCTION [5] [6] String curCaller; [7] Set cSet; /* funcs called by curCaller */ [8] %- [10] FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); [12] cSet = [13] SetCreate (StrCompare, StrId, NULL); [14] - <ref> [16] </ref> [CALL:$fcall] - [17] String called = CallName ($fcall); [18] [19] if (called && SetMember (cSet, called)) - [20] SetInsert (cSet, called); [21] printf ("%s: %s"n", curCaller, called); [22] - [24] [25] /* function END */ [26] FDECL:$fdef - SetDestroy (cSet); - 4.5 Design and implementation details A TAWK pattern is
Reference: [17] <author> D. Weise and R. </author> <title> Crew. Programmable syntax macros. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 156-65, </pages> <month> July </month> <year> 1993. </year> <journal> SIGPLAN Notices 28(7). </journal>
Reference-contexts: "t"n]*" [7] IDCC = "[a-zA-Z0-9_]" [8] CALL = ID WS ""(" [9] DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 [13] RS=""n"n+" # rec. sep. is blank line [14] - [16] # When inside a procedure definition <ref> [17] </ref> !OUTSIDE - [18] s = $0 [19] while (s != "") - [20] if ((start = match (s, CALL))) - [21] match (substr (s, start), ID) [22] len = RLENGTH [23] if (!match (substr (s, start, len), [24] KYWD)) [25] print fdecl, ": ", [26] substr (s, start, len) [27] <p> @ if kywdq (cn) | opq (cn) then fail @ [9] "( [ - &lt;arg&gt; [ , ] -+ ] ") [10] @ writeCall ( fn, cn ) @ [11] [13] procedure writeCall (fn, cf) [14] static idch [15] initial idch := (&ucase ++ [16] &lcase ++ &digits ++ '_') <ref> [17] </ref> [18] realfn := (fn ? (tab (upto (idch)), tab (0))) [19] realcf := (cf ? (tab (upto (idch)), tab (0))) [20] return write (realfn, " ", realcf) [21] end [23] # true if a keyword [24] procedure kywdq (nm) [25] return nm == ("if" | "while" | "switch" | [26] <p> The only general solution, perhaps, is to substitute a syntactic macro language <ref> [16, 17] </ref>. SCRUPLE does not cope with macros, but it may be able to in some situations. Since patterns are written in concrete syntax, they can be run through the preprocessor, turning the pattern into a form that can be applied to the postprocessed program text. <p> [2] #define FDECL " [3] &lt;declaration:FUNCTION|declaration:MACRO&gt; [4] #define CALL expression:FUNCTION [5] [6] String curCaller; [7] Set cSet; /* funcs called by curCaller */ [8] %- [10] FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); [12] cSet = [13] SetCreate (StrCompare, StrId, NULL); [14] - [16] [CALL:$fcall] - <ref> [17] </ref> String called = CallName ($fcall); [18] [19] if (called && SetMember (cSet, called)) - [20] SetInsert (cSet, called); [21] printf ("%s: %s"n", curCaller, called); [22] - [24] [25] /* function END */ [26] FDECL:$fdef - SetDestroy (cSet); - 4.5 Design and implementation details A TAWK pattern is parsed and converted
Reference: [18] <author> J. I. Gobat and D. C. Atkinson. </author> <title> The FElt system: User's guide and manual. </title> <type> Technical Report CS94-376, </type> <institution> University of Cali-fornia, San Diego, Department of Computer Science and Engineering, </institution> <note> 1994 (revised 1995). Available from the Internet at http://www-cse.ucsd.edu/users/atkinson/FElt/felt.html. </note>
Reference-contexts: = "[a-zA-Z0-9_]" [8] CALL = ID WS ""(" [9] DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 [13] RS=""n"n+" # rec. sep. is blank line [14] - [16] # When inside a procedure definition [17] !OUTSIDE - <ref> [18] </ref> s = $0 [19] while (s != "") - [20] if ((start = match (s, CALL))) - [21] match (substr (s, start), ID) [22] len = RLENGTH [23] if (!match (substr (s, start, len), [24] KYWD)) [25] print fdecl, ": ", [26] substr (s, start, len) [27] s = substr <p> if kywdq (cn) | opq (cn) then fail @ [9] "( [ - &lt;arg&gt; [ , ] -+ ] ") [10] @ writeCall ( fn, cn ) @ [11] [13] procedure writeCall (fn, cf) [14] static idch [15] initial idch := (&ucase ++ [16] &lcase ++ &digits ++ '_') [17] <ref> [18] </ref> realfn := (fn ? (tab (upto (idch)), tab (0))) [19] realcf := (cf ? (tab (upto (idch)), tab (0))) [20] return write (realfn, " ", realcf) [21] end [23] # true if a keyword [24] procedure kywdq (nm) [25] return nm == ("if" | "while" | "switch" | [26] "for" <p> [4] #define CALL expression:FUNCTION [5] [6] String curCaller; [7] Set cSet; /* funcs called by curCaller */ [8] %- [10] FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); [12] cSet = [13] SetCreate (StrCompare, StrId, NULL); [14] - [16] [CALL:$fcall] - [17] String called = CallName ($fcall); <ref> [18] </ref> [19] if (called && SetMember (cSet, called)) - [20] SetInsert (cSet, called); [21] printf ("%s: %s"n", curCaller, called); [22] - [24] [25] /* function END */ [26] FDECL:$fdef - SetDestroy (cSet); - 4.5 Design and implementation details A TAWK pattern is parsed and converted directly into a state machine that <p> requires re-targeting Ponder and then initializing a table that translates from AST node type names (i.e., strings) to their internal representation (i.e., integers). 5 Measurements To assess the precision, accuracy, and speed of the approaches discussed, we ran the call-graph extractors on 50,000 lines of the FElt finite-element programming system <ref> [18] </ref>.
Reference: [19] <author> S. L. Graham, C. B. Haley, and W. N. Joy. </author> <title> Practical LR error recovery. </title> <booktitle> In Proceedings of the SIGPLAN '79 Symposium on Compiler Construction, </booktitle> <pages> pages 168-175, </pages> <year> 1979. </year> <journal> SIGPLAN Notices, </journal> <volume> 14(8). </volume>
Reference-contexts: = ID WS ""(" [9] DEFN = ID WS ""([-]+-" [10] KYWD = "for|while|do|switch|if|typedef" [11] KYWDIC = IDCC "(KYWD)" IDCC # token [12] OUTSIDE = 1 [13] RS=""n"n+" # rec. sep. is blank line [14] - [16] # When inside a procedure definition [17] !OUTSIDE - [18] s = $0 <ref> [19] </ref> while (s != "") - [20] if ((start = match (s, CALL))) - [21] match (substr (s, start), ID) [22] len = RLENGTH [23] if (!match (substr (s, start, len), [24] KYWD)) [25] print fdecl, ": ", [26] substr (s, start, len) [27] s = substr (s, start + len) <p> "( [ - &lt;arg&gt; [ , ] -+ ] ") [10] @ writeCall ( fn, cn ) @ [11] [13] procedure writeCall (fn, cf) [14] static idch [15] initial idch := (&ucase ++ [16] &lcase ++ &digits ++ '_') [17] [18] realfn := (fn ? (tab (upto (idch)), tab (0))) <ref> [19] </ref> realcf := (cf ? (tab (upto (idch)), tab (0))) [20] return write (realfn, " ", realcf) [21] end [23] # true if a keyword [24] procedure kywdq (nm) [25] return nm == ("if" | "while" | "switch" | [26] "for" | "typedef") [27] end [29] # true if an operator <p> #define CALL expression:FUNCTION [5] [6] String curCaller; [7] Set cSet; /* funcs called by curCaller */ [8] %- [10] FDECL:$fdef - /* function BEGIN */ [11] curCaller = FunctionName ($fdef); [12] cSet = [13] SetCreate (StrCompare, StrId, NULL); [14] - [16] [CALL:$fcall] - [17] String called = CallName ($fcall); [18] <ref> [19] </ref> if (called && SetMember (cSet, called)) - [20] SetInsert (cSet, called); [21] printf ("%s: %s"n", curCaller, called); [22] - [24] [25] /* function END */ [26] FDECL:$fdef - SetDestroy (cSet); - 4.5 Design and implementation details A TAWK pattern is parsed and converted directly into a state machine that can <p> We have enhanced the generality of the parsing approach by extending the parser and AST to incorporate common macro idioms. Robustness remains a problem, but a syntax error results in the rejection of only the current file, at most. Moreover, parser error recovery <ref> [19] </ref> can often adequately recover from an error to permit constructing a usable AST for an erroneous construct. Although our approaches to macro matching and action support complement other existing syntactic techniques, other choices represent alternatives to existing techniques.
References-found: 19

