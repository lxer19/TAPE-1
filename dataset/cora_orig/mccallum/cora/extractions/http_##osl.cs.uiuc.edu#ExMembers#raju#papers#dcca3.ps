URL: http://osl.cs.uiuc.edu/ExMembers/raju/papers/dcca3.ps
Refering-URL: http://osl.cs.uiuc.edu/ExMembers/raju/
Root-URL: http://www.cs.uiuc.edu
Email: Email: fagha j frolund j panwar j sturmang@cs.uiuc.edu  
Title: A Linguistic Framework for Dynamic Composition of Dependability Protocols  
Author: Gul Agha, Svend Frtlund, Rajendra Panwar and Daniel Sturman 
Keyword: Programming Languages, Composition of Protocols, Dependable Systems, Software Fault-Tolerance  
Address: 1304 W. Springfield Avenue  Urbana, IL 61801, USA  
Affiliation: Department of Computer Science  University of Illinois at Urbana-Champaign  
Abstract: We present a language framework for describing dependable systems which emphasizes modularity and composition. Dependability and functionality aspects of an application may be described separately providing a separation of design concerns. Futhermore, the dependability protocols of an application may be constructed bottom-up as simple protocols that are composed into more complex protocols. Composition makes it easier to reason about dependability and supports the construction of general reusable dependability schemes. A significant aspect of our language framework is that dependability protocols may be loaded into a running application and installed dynamically. Dynamic installation makes it possible to impose additional dependability protocols on a server as clients with new dependability demands are integrated into a system. Similarly, if a given dependability protocol is only necessary during some critical phase of execution, it may be installed during that period only.
Abstract-found: 1
Intro-found: 1
Reference: [ABB + 86] <author> M. Acceta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: A New Kernel Foundation for UNIX Developement. </title> <booktitle> In USENIX 1986 Summer Conference Proceedings, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: Reflection in an object based system allows customization of the underlying system independently for every object as compared to customization in a micro kernel based system <ref> [ABB + 86] </ref> where changes made to the micro kernel affect all the objects collectively. This flexibility is required for implementing dependability protocols since such protocols are mostly installed on very specific subsets of the objects in a system.
Reference: [Agh86] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Greater or fewer restrictions may be imposed on the meta-level depending on the dependability and security requirements that a given system must meet. 4 3 The Actor Model We illustrate our approach using the Actor model <ref> [Agh86, Agh90] </ref>. It is important to note that the idea of using reflection to describe dependability is not tied to any specific language framework.
Reference: [Agh90] <author> G. Agha. </author> <title> Concurrent Object-Oriented Programming. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 125-141, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Greater or fewer restrictions may be imposed on the meta-level depending on the dependability and security requirements that a given system must meet. 4 3 The Actor Model We illustrate our approach using the Actor model <ref> [Agh86, Agh90] </ref>. It is important to note that the idea of using reflection to describe dependability is not tied to any specific language framework.
Reference: [AW92] <author> G. Agha and K. Wooyoung. </author> <title> Compilation of a Highly Parallel Actor-Based Language. </title> <editor> In U. Banerjee, D. Gelernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Proceedings of the Workshop on Languages and Compilers for Parallel Computing. </booktitle> <publisher> Yale University, Springer-Verlag, </publisher> <year> 1992. </year> <note> LNCS, to be published. </note>
Reference-contexts: There are no differences between the way in which the two-phase commit protocol is installed on C and on the replicated B. 8 Discussion The reflective capabilities described in this paper have been implemented in Hal <ref> [AW92] </ref>. Our work led to the addition of several categories of constructs to Hal. The structure for Maud was built directly into Hal and the underlying system directs messages to dispatcher meta-objects, when sent, and to mail queue meta-objects when received. Additional functions to allow message manipulation were also added.
Reference: [BHG87] <author> P. A. Bernstien, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: The initial system configuration is shown in Figure 2. Assume A initiates a transaction with databases B, and C. These transactions are implemented using a specific commit protocol. The commit protocol is chosen dynamically depending on the kinds of failures (site failures or communication failures <ref> [BHG87] </ref>) that need to be tolerated by the system. Assume that a two-phase commit protocol is implemented by a mail queue called tpcMailq and dispatcher called tpcDis installed at A, B and C. Also assume that A acts as the coordinator [BHG87] of the commit protocol. <p> the kinds of failures (site failures or communication failures <ref> [BHG87] </ref>) that need to be tolerated by the system. Assume that a two-phase commit protocol is implemented by a mail queue called tpcMailq and dispatcher called tpcDis installed at A, B and C. Also assume that A acts as the coordinator [BHG87] of the commit protocol. This scenario is depicted in Figure 5. When A initiates a commit protocol, its tpcDis broadcasts a vote-req message to B and C, and waits for vote messages from them.
Reference: [BJ87] <author> K. P. Birman and T. A. Joseph. </author> <title> Communication Support for Reliable Distributed Computing. In Fault-tolerant Distributed Computing. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: In Argus [LS82], Avalon [DHW88] and Arjuna [PS88], the concept of nested transactions is used to structure distributed systems. Consistency and resilience is ensured by atomic actions whose effect are checkpointed at commit time. The focus in [MPS91], [Coo90] and <ref> [BJ87] </ref> is to provide a set of protocols that represent common communication patterns found in fault tolerant systems. None of the above systems support the factorization of fault tolerance characteristics from the application specific code. In [WL88] and [OOW91], replication can be described separate from the service being replicated.
Reference: [Coo90] <author> E. Cooper. </author> <title> Programming Language Support for Multicast Communication in Distributed Systems. </title> <booktitle> In Tenth International Conference on Distributed Computer Systems, </booktitle> <year> 1990. </year>
Reference-contexts: In Argus [LS82], Avalon [DHW88] and Arjuna [PS88], the concept of nested transactions is used to structure distributed systems. Consistency and resilience is ensured by atomic actions whose effect are checkpointed at commit time. The focus in [MPS91], <ref> [Coo90] </ref> and [BJ87] is to provide a set of protocols that represent common communication patterns found in fault tolerant systems. None of the above systems support the factorization of fault tolerance characteristics from the application specific code.
Reference: [DHW88] <author> D. L. Detlefs, M. P. Herlihy, and J. M. Wing. </author> <title> Inheritance of Synchronization and Recovery Properties in Avalon/C++. </title> <journal> IEEE Computer, </journal> <volume> 21(12) </volume> <pages> 57-69, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: In such cases, composition may not be possible. For example, the composition of the two-phase commit protocol with security mechanisms may not be done naively [JM92]. 2 A number of languages and systems offer support for constructing fault tolerant systems. In Argus [LS82], Avalon <ref> [DHW88] </ref> and Arjuna [PS88], the concept of nested transactions is used to structure distributed systems. Consistency and resilience is ensured by atomic actions whose effect are checkpointed at commit time.
Reference: [FB88] <author> Jacques Ferber and Jean-Pierre Briot. </author> <booktitle> Design of a Concurrent Language for Distributed Artificial Intelligence. In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <volume> volume 2, </volume> <pages> pages 755-762. </pages> <institution> Institute for New Generation Computer Technology, </institution> <year> 1988. </year>
Reference-contexts: A reflective implementation of object migration is reported in [WY90]. Reflection has been used in the Muse Operating System [YMFT91] for dynamically modifying the system behaviour. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in <ref> [FB88] </ref> and [TS89], respectively. In MERING IV, programs may access meta-instances to modify an object or meta-classes to change a class definition.
Reference: [HA92] <author> C. Houck and G. Agha. HAL: </author> <title> A High-level Actor Language and Its Distributed Implementation. </title> <booktitle> In Proceedings of th 21st International Conference on Parallel Processing (ICPP '92), </booktitle> <volume> volume II, </volume> <pages> pages 158-165, </pages> <address> St. Charles, IL, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: An actor can only send messages to its acquaintances, which provides locality. In order to abstract over processor speeds and allow adaptive routing, preservation of message order is not guaranteed. The language used for examples in this paper is Hal <ref> [HA92] </ref>, an evolving high-level actor language which runs on a number of distributed execution platforms. Hal provides two other message passing constructs besides the asynchronous send. The first, SSEND , is a message order preserving send, or sequenced send.
Reference: [JM92] <author> Sushil Jajodia and Catherine D. McCollum. </author> <title> Using Two-Phase Commit for Crash Recovery in Federated Multilevel Secure Database Management Systems. </title> <booktitle> In Proceedings of the 3rd IFIP Working Conference on Dependable Computing for Critical Applications, </booktitle> <pages> pages 209-218, </pages> <address> Mondello, Sicily, Italy, </address> <month> September </month> <year> 1992. </year> <title> IFIP. </title> <type> Preprint. </type>
Reference-contexts: It may not be possible to describe a protocol in general terms. In such cases, composition may not be possible. For example, the composition of the two-phase commit protocol with security mechanisms may not be done naively <ref> [JM92] </ref>. 2 A number of languages and systems offer support for constructing fault tolerant systems. In Argus [LS82], Avalon [DHW88] and Arjuna [PS88], the concept of nested transactions is used to structure distributed systems. Consistency and resilience is ensured by atomic actions whose effect are checkpointed at commit time.
Reference: [LS82] <author> Barbara Liskov and Robert Scheifler. </author> <title> Guardians and Actions: Linguistic Support for Robust, Distributed Programs. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 7-19, </pages> <address> Albuquerque, New Mexico, </address> <month> January </month> <year> 1982. </year> <journal> ACM. </journal> <volume> 14 </volume>
Reference-contexts: In such cases, composition may not be possible. For example, the composition of the two-phase commit protocol with security mechanisms may not be done naively [JM92]. 2 A number of languages and systems offer support for constructing fault tolerant systems. In Argus <ref> [LS82] </ref>, Avalon [DHW88] and Arjuna [PS88], the concept of nested transactions is used to structure distributed systems. Consistency and resilience is ensured by atomic actions whose effect are checkpointed at commit time.
Reference: [Mae87] <author> P. Maes. </author> <title> Computational Reflection. </title> <type> Technical Report 87-2, </type> <institution> Artificial Intelligence Lab--oratory, Vrije University, </institution> <year> 1987. </year>
Reference-contexts: The final section summarizes our conclusions and research directions. 2 Reflection Reflection means that a system can manipulate a causally connected description of itself <ref> [Smi82, Mae87] </ref>. Causal connection implies that changes to the description have an immediate effect on the described object. The causally connected description is called a meta-level. In a reflective system, implementation of objects may be customized within the programming language.
Reference: [MPS91] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> Consul: A communication Substrate for Fault-Tolerant Distributed Programs. </title> <type> Technical report, </type> <institution> University of Arizona, Tuc-son, </institution> <year> 1991. </year>
Reference-contexts: In Argus [LS82], Avalon [DHW88] and Arjuna [PS88], the concept of nested transactions is used to structure distributed systems. Consistency and resilience is ensured by atomic actions whose effect are checkpointed at commit time. The focus in <ref> [MPS91] </ref>, [Coo90] and [BJ87] is to provide a set of protocols that represent common communication patterns found in fault tolerant systems. None of the above systems support the factorization of fault tolerance characteristics from the application specific code. <p> The primary source of cost is that generalized protocols may be used instead of customized protocols which can exploit knowledge of a given application. An example of this cost is the inability of a general replication scheme to take advantage of commutable operations <ref> [MPS91] </ref>. Unfortunately, the cost due to generalizing protocols is difficult to express quantitatively since it depends on the application and the protocol: in some cases, the cost is quite high and, in others, insignificant.
Reference: [OOW91] <author> M. H. Olsen, E. Oskiewicz, and J. P. Warne. </author> <title> A Model for Interface Groups. </title> <booktitle> In Tenth Symposium on Reliable Distributed Systems, </booktitle> <address> Pisa, Italy, </address> <year> 1991. </year>
Reference-contexts: The focus in [MPS91], [Coo90] and [BJ87] is to provide a set of protocols that represent common communication patterns found in fault tolerant systems. None of the above systems support the factorization of fault tolerance characteristics from the application specific code. In [WL88] and <ref> [OOW91] </ref>, replication can be described separate from the service being replicated. Our approach is more flexible since fault tolerance schemes are not only described separately but they can also be attached and detached dynamically.
Reference: [PS88] <author> G. D. Parrington and S. K. Shrivastava. </author> <title> Implementing Concurrency Control in Reliable Distributed Object-Oriented Systems. </title> <booktitle> In Proceedings of the Second European Conference on Object-Oriented Programming, </booktitle> <address> ECOOP88. </address> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: In such cases, composition may not be possible. For example, the composition of the two-phase commit protocol with security mechanisms may not be done naively [JM92]. 2 A number of languages and systems offer support for constructing fault tolerant systems. In Argus [LS82], Avalon [DHW88] and Arjuna <ref> [PS88] </ref>, the concept of nested transactions is used to structure distributed systems. Consistency and resilience is ensured by atomic actions whose effect are checkpointed at commit time.
Reference: [Sch90] <author> F. B. Schneider. </author> <title> The State Machine Approach: A Tutorial. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 448 </volume> <pages> 18-41, </pages> <year> 1990. </year>
Reference-contexts: The type of faults that can be experienced are generally considered to be of two basic types: Byzantine failures or fail-stop failures <ref> [Sch90] </ref>.
Reference: [Smi82] <author> B. C. Smith. </author> <title> Reflection and semantics in a procedural language. </title> <type> Technical Report 272, </type> <institution> Massachusetts Institute of Technology. Laboratory for Computer Science, </institution> <year> 1982. </year>
Reference-contexts: The final section summarizes our conclusions and research directions. 2 Reflection Reflection means that a system can manipulate a causally connected description of itself <ref> [Smi82, Mae87] </ref>. Causal connection implies that changes to the description have an immediate effect on the described object. The causally connected description is called a meta-level. In a reflective system, implementation of objects may be customized within the programming language.
Reference: [TS89] <author> C. Tomlinson and V. Singh. </author> <title> Inheritance and Synchronization with Enabled-Sets. </title> <booktitle> In OOPSLA Proceedings, </booktitle> <year> 1989. </year>
Reference-contexts: A reflective implementation of object migration is reported in [WY90]. Reflection has been used in the Muse Operating System [YMFT91] for dynamically modifying the system behaviour. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in [FB88] and <ref> [TS89] </ref>, respectively. In MERING IV, programs may access meta-instances to modify an object or meta-classes to change a class definition.
Reference: [VT93] <author> Nalini Venkatasubramanian and Carolyn Talcott. </author> <title> A MetaArchitecture for Distributed Resource Management. </title> <booktitle> In Proceedings of the Hawaii International Conference on System Sciences. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> January </month> <year> 1993. </year> <note> To Appear. </note>
Reference-contexts: A formal semantic framework is needed to verify the adherence of Maud components to a given specification. Preliminary work in this area has been done in <ref> [VT93] </ref>. Safety would be addressed by having managers only install meta-objects that conform to some specification. The approach is also flexible and open-ended since many meta-objects may implement a given specification. Besides protecting the meta-level, a manager may initiate the installation of meta-objects.
Reference: [WL88] <author> C. T. Wilkes and R. J. LeBlanc. </author> <title> Distributed Locking: A Mechanism for Constructing Highly Available Objects. </title> <booktitle> In Seventh Symposium on Reliable Distributed Systems, </booktitle> <institution> Ohio State University, Columbus, Ohio, </institution> <year> 1988. </year>
Reference-contexts: The focus in [MPS91], [Coo90] and [BJ87] is to provide a set of protocols that represent common communication patterns found in fault tolerant systems. None of the above systems support the factorization of fault tolerance characteristics from the application specific code. In <ref> [WL88] </ref> and [OOW91], replication can be described separate from the service being replicated. Our approach is more flexible since fault tolerance schemes are not only described separately but they can also be attached and detached dynamically.
Reference: [WY90] <author> T. Watanabe and A. Yonezawa. </author> <title> A Actor-Based Metalevel Arhitecture for Group-Wide Reflection. </title> <editor> In J. W. deBakker, W. P. deRoever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, </booktitle> <pages> pages 405-425. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> LNCS 489. </note>
Reference-contexts: Reflection has been used to address a number of issues in concurrent systems. For example, the scheduling problem of the Time Warp algorithm for parallel discrete event simulation is modeled by means of reflection in [Yon90]. A reflective implementation of object migration is reported in <ref> [WY90] </ref>. Reflection has been used in the Muse Operating System [YMFT91] for dynamically modifying the system behaviour. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in [FB88] and [TS89], respectively.
Reference: [YMFT91] <author> Y. Yokote, A. Mitsuzawa, N. Fujinami, and M. Tokoro. </author> <title> The Muse Object Architecture: </title>
Reference-contexts: For example, the scheduling problem of the Time Warp algorithm for parallel discrete event simulation is modeled by means of reflection in [Yon90]. A reflective implementation of object migration is reported in [WY90]. Reflection has been used in the Muse Operating System <ref> [YMFT91] </ref> for dynamically modifying the system behaviour. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in [FB88] and [TS89], respectively. In MERING IV, programs may access meta-instances to modify an object or meta-classes to change a class definition.
References-found: 23

