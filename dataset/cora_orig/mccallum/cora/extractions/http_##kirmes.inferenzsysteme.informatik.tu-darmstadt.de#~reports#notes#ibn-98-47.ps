URL: http://kirmes.inferenzsysteme.informatik.tu-darmstadt.de/~reports/notes/ibn-98-47.ps
Refering-URL: http://www.inferenzsysteme.informatik.tu-darmstadt.de/~reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: E-mail: fbrauburger, gieslg@informatik.tu-darmstadt.de  
Title: Termination Analysis by Inductive Evaluation  
Author: Jurgen Brauburger and Jurgen Giesl 
Address: Alexanderstrae 10, 64283 Darmstadt, Germany  
Affiliation: FB Informatik, TU Darmstadt,  
Abstract: We present a new approach for automatic termination analysis of functional programs. Several methods have been presented which try to find a well-founded ordering such that the arguments in the recursive calls are smaller than the corresponding inputs. However, previously developed approaches for automated termination analysis often disregard the conditions under which the recursive calls are evaluated. Hence, the existing methods fail for an important class of algorithms where the necessary information for proving termination is `hidden' in the conditions. In this paper we develop the inductive evaluation method which analyzes the auxiliary functions occurring in the conditions of the recursive calls. We also discuss an extension of our method to partial functions in order to determine their domains automatically. The proposed technique proved successful for termination analysis of numerous algorithms in functional as well as imperative programming languages.
Abstract-found: 1
Intro-found: 1
Reference: [AG97] <author> T. Arts and J. Giesl. </author> <title> Proving innermost normalisation automatically. </title> <booktitle> In Proc. </booktitle> <address> RTA-97, Sitges, Spain, </address> <publisher> LNCS 1232, </publisher> <year> 1997. </year>
Reference-contexts: Throughout the paper `verification of a boolean term '' means proving that ' evaluates to true for all instantiations of its variables with data objects. 5 In contrast to conventional termination proofs of term rewriting systems, for functional programs one may use orderings which are not even weakly monotonic, cf. <ref> [AG97] </ref>. In fact, termination of minus cannot be proved by any monotonic well-founded ordering. <p> our example, we will use the first possibility and transform (77) into hz; app (u; v)i hcons (x; y); cons (u; v)i: (81) 10 Note that while the existing methods for the generation of polynomial orderings cannot deal with arbitrary conditions, they can nevertheless handle monotonicity formulas like (75), cf. <ref> [Gie95b, AG97] </ref>.
Reference: [BM79] <author> R. S. Boyer and J S. Moore. </author> <title> A computational logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: A functional program f (x) is terminating if the arguments of each recursive call f (r) decrease w.r.t. a well-founded ordering. A well-known method for termination proofs of lisp functions has been implemented in the nqthm system of R. S. Boyer and J S. Moore <ref> [BM79] </ref>. In their approach, for each recursive call f (r) an induction lemma ! r x is required, which asserts that the argument decreases w.r.t. a well-founded ordering if some condition is satisfied. <p> Then it remains to verify ! where is the condition under which the recursive call f (r) is performed. While in <ref> [BM79] </ref> the user has to supply all induction lemmata, the methods in [Wal94b, Gie95c, GWB98] synthesize a certain class of induction lemmata automatically. <p> To perform the required proofs, we simply applied symbolic evaluation, i.e. we used the defining equations as rewrite rules. In general this verification could require an induction theorem proving system, e.g. <ref> [BM79, ZKK88, Bun + 89, Wal94a, BR95, HS96] </ref>. However, when testing our method on numerous algorithms, we found that in almost all examples the required conjectures could already be proved by symbolic evaluation. <p> Such a term suggests a plausible induction w.r.t. g using y 1 ; : : ; y n as induction variables, cf. e.g. <ref> [BM79, ZKK88, Bun + 89, Wal94a] </ref>. Hence, for the termination hypothesis of minus this heuristic suggests inductive evaluation w.r.t. le using the induction variables x and y. Inductive evaluation is used for algorithms where the conditions of recursive calls have to be analyzed in order to prove termination. <p> In this way we obtained an extremely powerful approach for automated termination analysis which performed successfully on a large collection of benchmarks (including all 82 algorithms from <ref> [BM79] </ref>, all 60 examples from [Wal94b], and all 92 examples in [Gie95b] and [BG96]). See the appendix for a collection of 36 algorithms whose termination behaviour could not be analyzed with any other automatic method up to now, but where inductive evaluation enables termination analysis without user interaction.
Reference: [BR95] <author> A. Bouhoula and M. Rusinowitch. </author> <title> Implicit induction in conditional theories. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 14 </volume> <pages> 189-235, </pages> <year> 1995. </year>
Reference-contexts: To perform the required proofs, we simply applied symbolic evaluation, i.e. we used the defining equations as rewrite rules. In general this verification could require an induction theorem proving system, e.g. <ref> [BM79, ZKK88, Bun + 89, Wal94a, BR95, HS96] </ref>. However, when testing our method on numerous algorithms, we found that in almost all examples the required conjectures could already be proved by symbolic evaluation.
Reference: [BG96] <author> J. Brauburger and J. Giesl. </author> <title> Termination analysis for partial functions. </title> <booktitle> In Proc. 3rd Int. Static Analysis Symp., </booktitle> <address> Aachen, Germany, </address> <note> LNCS 1145, 1996. Extended version appeared as Report IBN-96-33, </note> <institution> TU Darmstadt, </institution> <year> 1996. </year> <note> Available from http://www.inferenzsysteme.informatik. tu-darmstadt.de/~reports/notes/ibn-96-33.ps </note>
Reference-contexts: Thus, evaluation of nextindex (2; 5*6*3*5*7*5*empty; 6) does not halt. 4.1 Termination Predicates To represent subsets of inputs where procedures like nextindex terminate, in <ref> [BG96] </ref> we introduced termination predicates. <p> Our aim is to synthesize termination predicates which return true as often as possible, but of course in general this goal cannot be reached as the domains of functions are undecidable. In <ref> [BG96, GWB98] </ref>, rules for the synthesis of termination predicates are developed. <p> As the constructors also denote total functions, we may neglect their termination predicates. Note that nextindex terminates totally by construction since it is called recursively only if the arguments decrease w.r.t. . 4.2 Inductive Evaluation for Partial Functions The synthesis of termination predicates described in <ref> [BG96] </ref> requires the user to provide a well-founded ordering . Our aim is to get independent from this input by generating suitable polynomial orderings for termination predicates automatically. Here, our goal is to synthesize an ordering which satisfies the termination hypotheses `as often as possible' 6 . <p> In this way we obtained an extremely powerful approach for automated termination analysis which performed successfully on a large collection of benchmarks (including all 82 algorithms from [BM79], all 60 examples from [Wal94b], and all 92 examples in [Gie95b] and <ref> [BG96] </ref>). See the appendix for a collection of 36 algorithms whose termination behaviour could not be analyzed with any other automatic method up to now, but where inductive evaluation enables termination analysis without user interaction. <p> hx; yi 7! x Soundness Predicate function (23) : nat fi nat ! bool (23) (u; v) = true Termination Predicate function le : nat fi nat ! bool le (0; v) = true le (s (u); 0) = true le (s (u); s (v)) = le (u; v) In <ref> [BG96] </ref> we introduced a technique for automated simplification of termination (or soundness) predicate algorithms.
Reference: [Bra97] <author> J. Brauburger. </author> <title> Automatic termination analysis for partial functions using polynomial orderings. </title> <booktitle> In Proc. 4th SAS, </booktitle> <address> Paris, France, </address> <publisher> LNCS 1302, </publisher> <year> 1997. </year>
Reference-contexts: may be applied as the formula :eq (nth (s (u); v*w); z) ! :eq (nth (u; w); z) can be proved by symbolic 6 For algorithms with auxiliary functions in the recursive arguments (instead of the conditions), the techniques developed for total termination [Gie95c] can be adapted to partial functions <ref> [Bra97] </ref>, cf. [GWB98]. 7 This is similar to the approach of [Pro96] where a proof predicate is generated from an unsound induction proof in order to extend faulty conjectures to valid ones. 6 evaluation. <p> Hence we have also to construct a soundness predicate for that kind of unsound transformation. According to <ref> [Bra97] </ref> we construct a soundness predicate fl 2 pp such that fl 2 pp (q) = true implies ((328) ! (325))[r=q] for each natural q.
Reference: [Bun + 89] <author> A. Bundy, F. van Harmelen, J. Hesketh, A. Smaill, and A. Stevens. </author> <title> A rational reconstruction and extension of recursion analysis. </title> <booktitle> In Proc. IJCAI '89, </booktitle> <address> Detroit, USA, </address> <year> 1989. </year>
Reference-contexts: To perform the required proofs, we simply applied symbolic evaluation, i.e. we used the defining equations as rewrite rules. In general this verification could require an induction theorem proving system, e.g. <ref> [BM79, ZKK88, Bun + 89, Wal94a, BR95, HS96] </ref>. However, when testing our method on numerous algorithms, we found that in almost all examples the required conjectures could already be proved by symbolic evaluation. <p> Such a term suggests a plausible induction w.r.t. g using y 1 ; : : ; y n as induction variables, cf. e.g. <ref> [BM79, ZKK88, Bun + 89, Wal94a] </ref>. Hence, for the termination hypothesis of minus this heuristic suggests inductive evaluation w.r.t. le using the induction variables x and y. Inductive evaluation is used for algorithms where the conditions of recursive calls have to be analyzed in order to prove termination.
Reference: [Der87] <author> N. Dershowitz. </author> <title> Termination of rewriting. </title> <journal> J. Symb. Comp., </journal> <volume> 3 </volume> <pages> 69-115, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Proving termination is a central problem in the development of correct software. While most work on the automation of termination proofs has been done for term rewriting systems (for surveys see e.g. <ref> [Der87, Ste95] </ref>) and for logic programs (e.g. [UvG88, Plu90, SD94]), in this paper we consider functional programs. A functional program f (x) is terminating if the arguments of each recursive call f (r) decrease w.r.t. a well-founded ordering.
Reference: [Gie95a] <author> J. Giesl. </author> <title> Generating polynomial orderings for termination proofs. </title> <booktitle> In Proc. </booktitle> <address> RTA-95, Kaiser-slautern, Germany, </address> <publisher> LNCS 914, </publisher> <year> 1995. </year>
Reference-contexts: The above polynomial ordering satisfies the termination hypothesis (1). Consequently, as all polynomial orderings are well founded, termination of le is proved. Techniques to generate suitable polynomial orderings automatically have been developed in <ref> [Ste94, Gie95a] </ref>, for instance. In the following, let t fl and r fl denote tuples of terms t 1 ; : : ; t n and r 1 ; : : ; r n . <p> The methods for the automated generation of polynomial orderings presented in <ref> [Gie95a, Gie95b] </ref> can also generate such rational polynomial orderings. In this way, termination of round 3 can be proved using the following association: 0 7! 0; s (x) 7! 3 2 x + 2. <p> The termination hypothesis of less leaves contains the defined symbol app in its conclusion. To eliminate defined symbols from conclusions (instead of premises), we use the method presented in <ref> [Gie95a, Gie95b, GWB98] </ref> and we refer the reader to these papers for a detailed explanation. In this method there are two rules to eliminate defined symbols from conclusions, viz. generalization and estimation.
Reference: [Gie95b] <author> J. Giesl. </author> <title> Automatisierung von Terminierungsbeweisen fur rekursiv definierte Algorithmen. </title> <type> PhD thesis, </type> <address> Infix-Verlag, St. Augustin, Germany, </address> <year> 1995. </year>
Reference-contexts: As the number of hypotheses is always finite (and small), exhaustive search could be used to determine the inequalities that should be rejected. However, efficiency can be improved if `probably polynomially satisfiable' inequalities are selected by the heuristics developed in <ref> [Gie95b] </ref> which have proved successful in practice. <p> We combined our method to handle auxiliary functions in the conditions with techniques to deal with defined functions in the arguments of recursive calls <ref> [Gie95b, Gie95c, Gie97, GWB98] </ref> and implemented it within the induction theorem prover inka [HS96]. <p> In this way we obtained an extremely powerful approach for automated termination analysis which performed successfully on a large collection of benchmarks (including all 82 algorithms from [BM79], all 60 examples from [Wal94b], and all 92 examples in <ref> [Gie95b] </ref> and [BG96]). See the appendix for a collection of 36 algorithms whose termination behaviour could not be analyzed with any other automatic method up to now, but where inductive evaluation enables termination analysis without user interaction. <p> Premise Elimination in (68)-(70) 21 Polynomial Ordering For this example we need a polynomial ordering with rational (instead of integer) coefficients, cf. <ref> [Gie95b] </ref>. <p> The methods for the automated generation of polynomial orderings presented in <ref> [Gie95a, Gie95b] </ref> can also generate such rational polynomial orderings. In this way, termination of round 3 can be proved using the following association: 0 7! 0; s (x) 7! 3 2 x + 2. <p> The termination hypothesis of less leaves contains the defined symbol app in its conclusion. To eliminate defined symbols from conclusions (instead of premises), we use the method presented in <ref> [Gie95a, Gie95b, GWB98] </ref> and we refer the reader to these papers for a detailed explanation. In this method there are two rules to eliminate defined symbols from conclusions, viz. generalization and estimation. <p> our example, we will use the first possibility and transform (77) into hz; app (u; v)i hcons (x; y); cons (u; v)i: (81) 10 Note that while the existing methods for the generation of polynomial orderings cannot deal with arbitrary conditions, they can nevertheless handle monotonicity formulas like (75), cf. <ref> [Gie95b, AG97] </ref>. <p> However, we will demand that all those tuples of data objects which lead to recursive calls are still mapped to non-negative numbers. In this way, such (possibly non-well-founded) polynomial orderings can still be used for termination proofs, cf. <ref> [Gie95b] </ref>. <p> Estimation of app in (89) and (91). Similar to the estimation of app by an upper bound app, <ref> [Gie95b] </ref> also introduced estimation by lower bounds app. In our example, the heuristics of [Gie95b] suggest to estimate the first argument of tuples by lower bounds and the second argument by upper bounds. <p> Estimation of app in (89) and (91). Similar to the estimation of app by an upper bound app, <ref> [Gie95b] </ref> also introduced estimation by lower bounds app. In our example, the heuristics of [Gie95b] suggest to estimate the first argument of tuples by lower bounds and the second argument by upper bounds. <p> For further details see <ref> [Gie95b] </ref>.) By inductive evaluation and subsequent symbolic evaluation (in the premise and in the conclusion), (132) is transformed into true ! s (minus2 (u; 0)) minus2 (s (u); 0) (135) :le (u; v) ! s (minus2 (u; s (v))) minus2 (s (u); s (v)): (136) Now we continue as usual, i.e.
Reference: [Gie95c] <author> J. Giesl. </author> <title> Termination analysis for functional programs using term orderings. </title> <booktitle> In Proc. 2nd Int. Static Analysis Symp., </booktitle> <address> Glasgow, UK, </address> <publisher> LNCS 983, </publisher> <year> 1995. </year>
Reference-contexts: Then it remains to verify ! where is the condition under which the recursive call f (r) is performed. While in [BM79] the user has to supply all induction lemmata, the methods in <ref> [Wal94b, Gie95c, GWB98] </ref> synthesize a certain class of induction lemmata automatically. The technique in [Wal94b] is restricted to one fixed ordering , but the approach of [Gie95c, GWB98] also allows an automatic generation of suitable well-founded orderings by incorporating techniques from the area of term rewriting systems. <p> While in [BM79] the user has to supply all induction lemmata, the methods in [Wal94b, Gie95c, GWB98] synthesize a certain class of induction lemmata automatically. The technique in [Wal94b] is restricted to one fixed ordering , but the approach of <ref> [Gie95c, GWB98] </ref> also allows an automatic generation of suitable well-founded orderings by incorporating techniques from the area of term rewriting systems. To synthesize an induction lemma for a recursive call f (r) under the condition , these methods analyze the auxiliary functions occurring in the recursive argument r. <p> Hence, in this paper we restrict ourselves to termination hypotheses ! ! where defined symbols may only occur in the condition . For algorithms with defined symbols in the arguments of recursive calls, the technique of the present paper is extended by the calculus of <ref> [Gie95c, Gie97, GWB98] </ref> to eliminate the remaining defined symbols from the conclusion !. 3 In order to detect redundant cases, in each resulting formula (3)-(5), we now check whether the premise is unsatisfiable. <p> In the third case the induction hypothesis may be applied as the formula :eq (nth (s (u); v*w); z) ! :eq (nth (u; w); z) can be proved by symbolic 6 For algorithms with auxiliary functions in the recursive arguments (instead of the conditions), the techniques developed for total termination <ref> [Gie95c] </ref> can be adapted to partial functions [Bra97], cf. [GWB98]. 7 This is similar to the approach of [Pro96] where a proof predicate is generated from an unsound induction proof in order to extend faulty conjectures to valid ones. 6 evaluation. <p> We combined our method to handle auxiliary functions in the conditions with techniques to deal with defined functions in the arguments of recursive calls <ref> [Gie95b, Gie95c, Gie97, GWB98] </ref> and implemented it within the induction theorem prover inka [HS96].
Reference: [Gie97] <author> J. Giesl. </author> <title> Termination of nested and mutually recursive algorithms. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 19 </volume> <pages> 1-29, </pages> <year> 1997. </year>
Reference-contexts: Hence, in this paper we restrict ourselves to termination hypotheses ! ! where defined symbols may only occur in the condition . For algorithms with defined symbols in the arguments of recursive calls, the technique of the present paper is extended by the calculus of <ref> [Gie95c, Gie97, GWB98] </ref> to eliminate the remaining defined symbols from the conclusion !. 3 In order to detect redundant cases, in each resulting formula (3)-(5), we now check whether the premise is unsatisfiable. <p> We combined our method to handle auxiliary functions in the conditions with techniques to deal with defined functions in the arguments of recursive calls <ref> [Gie95b, Gie95c, Gie97, GWB98] </ref> and implemented it within the induction theorem prover inka [HS96].
Reference: [GWB98] <author> J. Giesl, C. Walther, and J. Brauburger. </author> <title> Termination analysis for functional programs. </title> <editor> In W. Bibel and P. Schmitt, editors, </editor> <booktitle> Automated Deduction, </booktitle> <volume> vol. 3. </volume> <publisher> Kluwer, </publisher> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: Then it remains to verify ! where is the condition under which the recursive call f (r) is performed. While in [BM79] the user has to supply all induction lemmata, the methods in <ref> [Wal94b, Gie95c, GWB98] </ref> synthesize a certain class of induction lemmata automatically. The technique in [Wal94b] is restricted to one fixed ordering , but the approach of [Gie95c, GWB98] also allows an automatic generation of suitable well-founded orderings by incorporating techniques from the area of term rewriting systems. <p> While in [BM79] the user has to supply all induction lemmata, the methods in [Wal94b, Gie95c, GWB98] synthesize a certain class of induction lemmata automatically. The technique in [Wal94b] is restricted to one fixed ordering , but the approach of <ref> [Gie95c, GWB98] </ref> also allows an automatic generation of suitable well-founded orderings by incorporating techniques from the area of term rewriting systems. To synthesize an induction lemma for a recursive call f (r) under the condition , these methods analyze the auxiliary functions occurring in the recursive argument r. <p> Hence, in this paper we restrict ourselves to termination hypotheses ! ! where defined symbols may only occur in the condition . For algorithms with defined symbols in the arguments of recursive calls, the technique of the present paper is extended by the calculus of <ref> [Gie95c, Gie97, GWB98] </ref> to eliminate the remaining defined symbols from the conclusion !. 3 In order to detect redundant cases, in each resulting formula (3)-(5), we now check whether the premise is unsatisfiable. <p> This class of algorithms is also used extensively in imperative programming languages. A straightforward approach to prove termination of imperative programs is to transform them into functional ones and to verify termination of the resulting functions, cf. e.g. <ref> [Hen80, GWB98] </ref>. For example, the imperative program `r := 0; while x &gt; y do y := y + 1; r := r + 1 od' is transformed into a function whose termination can be proved analogously to minus. <p> Our aim is to synthesize termination predicates which return true as often as possible, but of course in general this goal cannot be reached as the domains of functions are undecidable. In <ref> [BG96, GWB98] </ref>, rules for the synthesis of termination predicates are developed. <p> applied as the formula :eq (nth (s (u); v*w); z) ! :eq (nth (u; w); z) can be proved by symbolic 6 For algorithms with auxiliary functions in the recursive arguments (instead of the conditions), the techniques developed for total termination [Gie95c] can be adapted to partial functions [Bra97], cf. <ref> [GWB98] </ref>. 7 This is similar to the approach of [Pro96] where a proof predicate is generated from an unsound induction proof in order to extend faulty conjectures to valid ones. 6 evaluation. <p> The handling of partial functions is also necessary for termination analysis of imperative programs, because when translating imperative programs into functional ones, while-loops are often transformed into partial functions, as termination of while-loops often depends on their contexts, cf. <ref> [GWB98] </ref>. 5 Refinements In this section we present extensions of our approach which increase its power considerably. <p> We combined our method to handle auxiliary functions in the conditions with techniques to deal with defined functions in the arguments of recursive calls <ref> [Gie95b, Gie95c, Gie97, GWB98] </ref> and implemented it within the induction theorem prover inka [HS96]. <p> The termination hypothesis of less leaves contains the defined symbol app in its conclusion. To eliminate defined symbols from conclusions (instead of premises), we use the method presented in <ref> [Gie95a, Gie95b, GWB98] </ref> and we refer the reader to these papers for a detailed explanation. In this method there are two rules to eliminate defined symbols from conclusions, viz. generalization and estimation.
Reference: [Gri81] <editor> D. Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1981. </year>
Reference-contexts: For all these examples, termination predicates describing the exact domains of the functions could be synthesized. We also applied our approach to imperative programs by translating them into equivalent functional programs. In this way, in 33 of 45 examples from <ref> [Gri81] </ref> the exact domain could be determined automatically. Examples This appendix contains 37 functional and 21 imperative programs to illustrate the power of our method. For functional procedures marked with fl total termination is provable without inductive evaluation; they are required as auxiliary procedures for the other examples. <p> Hence, to prove total termination of main one needs a method for termination analysis of partial functions. The rest of this section contains 21 imperative procedures from <ref> [Gri81] </ref> whose termination is analyzed using inductive evaluation. For each procedure we describe its semantics. Then we mention the functional procedures resulting from its translation and continue termination analysis like in the previous section. 38 fibonacci ([Gri81] p. 147) For n 1, the imperative procedure fibonacci computes in a the n-th
Reference: [Hen80] <author> P. Henderson. </author> <title> Functional Programming. </title> <publisher> Prentice-Hall, </publisher> <address> London, </address> <year> 1980. </year>
Reference-contexts: This class of algorithms is also used extensively in imperative programming languages. A straightforward approach to prove termination of imperative programs is to transform them into functional ones and to verify termination of the resulting functions, cf. e.g. <ref> [Hen80, GWB98] </ref>. For example, the imperative program `r := 0; while x &gt; y do y := y + 1; r := r + 1 od' is transformed into a function whose termination can be proved analogously to minus. <p> For a formal definition and an automation of this translation see e.g. <ref> [Hen80] </ref>. Note that in general the auxiliary functions resulting from such a translation are partial even if the original imperative procedure terminates totally. The reason is that in imperative procedures, termination of while-loops often depends on their contexts, i.e. on the preconditions that hold before entering the loop.
Reference: [HS96] <author> D. Hutter and C. Sengler. INKA: </author> <title> The next generation. </title> <booktitle> In Proc. </booktitle> <address> CADE-13, New Brunswick, USA, </address> <publisher> LNAI 1104, </publisher> <year> 1996. </year>
Reference-contexts: To perform the required proofs, we simply applied symbolic evaluation, i.e. we used the defining equations as rewrite rules. In general this verification could require an induction theorem proving system, e.g. <ref> [BM79, ZKK88, Bun + 89, Wal94a, BR95, HS96] </ref>. However, when testing our method on numerous algorithms, we found that in almost all examples the required conjectures could already be proved by symbolic evaluation. <p> We combined our method to handle auxiliary functions in the conditions with techniques to deal with defined functions in the arguments of recursive calls [Gie95b, Gie95c, Gie97, GWB98] and implemented it within the induction theorem prover inka <ref> [HS96] </ref>. In this way we obtained an extremely powerful approach for automated termination analysis which performed successfully on a large collection of benchmarks (including all 82 algorithms from [BM79], all 60 examples from [Wal94b], and all 92 examples in [Gie95b] and [BG96]).
Reference: [KZ95] <author> D. Kapur and H. Zhang. </author> <title> An overview of Rewrite Rule Laboratory (RRL). </title> <journal> J. Computer Math. Appl., </journal> <volume> 29 </volume> <pages> 91-114, </pages> <year> 1995. </year>
Reference: [Lan79] <author> D.S. Lankford. </author> <title> On proving term rewriting systems are noetherian. </title> <institution> Memo MTP-3, Math. Dept., Louisiana Tech. Univ., Ruston, USA, </institution> <year> 1979. </year>
Reference-contexts: For example, termination of le can be proved by using a suitable polynomial ordering <ref> [Lan79] </ref>. A polynomial ordering is defined by mapping each n-ary constructor to an n-ary polynomial with integer coefficients. Then for two data objects r and t, we have r t iff the number corresponding to r is smaller than the number corresponding to t.
Reference: [MW78] <author> Z. Manna and R. Waldinger. </author> <title> Is `sometimes' sometimes better than `always'. </title> <journal> Comm. of the ACM, </journal> <volume> 21(2) </volume> <pages> 159-172, </pages> <year> 1978. </year>
Reference-contexts: v + 1; minus2 (x; y) 7! x; hu; vi 7! u Soundness Predicate function (126) : nat fi nat ! bool (126) (y; x) = true 31 Termination Predicate function mod : nat fi nat ! bool mod (x; y) = true 25 gcd1 The functional procedure gcd1 from <ref> [MW78] </ref> computes the greatest common divisor of two naturals. function gcd1 : nat fi nat ! nat gcd1 (0; y) = y Termination Hypothesis hmod (y; s (v)); s (v)i hs (v); yi (141) Transformation 1. No (direct) inductive evaluation is needed for the termination hypothesis (126) of gcd1.
Reference: [NN96] <author> F. Nielson and H. R. Nielson. </author> <title> Operational semantics of termination types. </title> <journal> Nordic Journal of Computing, </journal> <volume> 3(2) </volume> <pages> 144-187, </pages> <year> 1996. </year>
Reference-contexts: The reason is that minus calls another algorithm, viz. le. In contrast to (1), the inequality ht 1 ; s (t 2 )i ht 1 ; t 2 i in minus' termination hypothesis does not have 1 See <ref> [NN96, PS97, Sen96] </ref> for extensions of termination analysis to higher-order languages, languages with lazy evaluation strategy, and to non-free algebraic data types. 2 We use Greek letters to denote boolean terms and often refer to them as `formulas', where :; ^; _, and ! are pre-defined boolean functions with obvious semantics.
Reference: [PS97] <author> S. E. Panitz and M. Schmidt-Schau. </author> <title> TEA: Automatically proving termination of programs in a non-strict higher-order functional language. </title> <booktitle> In Proc. 4th Int. Static Analysis Symp., </booktitle> <address> Paris, France, </address> <publisher> LNCS 1302, </publisher> <year> 1997. </year>
Reference-contexts: The reason is that minus calls another algorithm, viz. le. In contrast to (1), the inequality ht 1 ; s (t 2 )i ht 1 ; t 2 i in minus' termination hypothesis does not have 1 See <ref> [NN96, PS97, Sen96] </ref> for extensions of termination analysis to higher-order languages, languages with lazy evaluation strategy, and to non-free algebraic data types. 2 We use Greek letters to denote boolean terms and often refer to them as `formulas', where :; ^; _, and ! are pre-defined boolean functions with obvious semantics.
Reference: [Plu90] <author> L. Plumer. </author> <title> Termination proofs for logic programs. </title> <publisher> LNAI 446, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Proving termination is a central problem in the development of correct software. While most work on the automation of termination proofs has been done for term rewriting systems (for surveys see e.g. [Der87, Ste95]) and for logic programs (e.g. <ref> [UvG88, Plu90, SD94] </ref>), in this paper we consider functional programs. A functional program f (x) is terminating if the arguments of each recursive call f (r) decrease w.r.t. a well-founded ordering. A well-known method for termination proofs of lisp functions has been implemented in the nqthm system of R. S.
Reference: [Pro96] <author> M. Protzen. </author> <title> Patching faulty conjectures. </title> <booktitle> In Proc. </booktitle> <address> CADE-13, </address> <publisher> LNAI 1104, </publisher> <address> New Brunswick, USA, </address> <year> 1996. </year>
Reference-contexts: z) ! :eq (nth (u; w); z) can be proved by symbolic 6 For algorithms with auxiliary functions in the recursive arguments (instead of the conditions), the techniques developed for total termination [Gie95c] can be adapted to partial functions [Bra97], cf. [GWB98]. 7 This is similar to the approach of <ref> [Pro96] </ref> where a proof predicate is generated from an unsound induction proof in order to extend faulty conjectures to valid ones. 6 evaluation.
Reference: [SD94] <author> D. De Schreye and S. Decorte. </author> <title> Termination of logic programs: The never-ending story. </title> <journal> Journal of Logic Programming, </journal> 19/20:199-260, 1994. 
Reference-contexts: 1 Introduction Proving termination is a central problem in the development of correct software. While most work on the automation of termination proofs has been done for term rewriting systems (for surveys see e.g. [Der87, Ste95]) and for logic programs (e.g. <ref> [UvG88, Plu90, SD94] </ref>), in this paper we consider functional programs. A functional program f (x) is terminating if the arguments of each recursive call f (r) decrease w.r.t. a well-founded ordering. A well-known method for termination proofs of lisp functions has been implemented in the nqthm system of R. S.
Reference: [Sen96] <author> C. Sengler. </author> <title> Termination of algorithms over non-freely generated data types. </title> <booktitle> In Proc. </booktitle> <address> CADE-13, New Brunswick, USA, </address> <publisher> LNAI 1104, </publisher> <year> 1996. </year>
Reference-contexts: The reason is that minus calls another algorithm, viz. le. In contrast to (1), the inequality ht 1 ; s (t 2 )i ht 1 ; t 2 i in minus' termination hypothesis does not have 1 See <ref> [NN96, PS97, Sen96] </ref> for extensions of termination analysis to higher-order languages, languages with lazy evaluation strategy, and to non-free algebraic data types. 2 We use Greek letters to denote boolean terms and often refer to them as `formulas', where :; ^; _, and ! are pre-defined boolean functions with obvious semantics.
Reference: [Ste94] <author> J. Steinbach. </author> <title> Generating polynomial orderings. </title> <journal> IPL, </journal> <volume> 49 </volume> <pages> 85-93, </pages> <year> 1994. </year>
Reference-contexts: The above polynomial ordering satisfies the termination hypothesis (1). Consequently, as all polynomial orderings are well founded, termination of le is proved. Techniques to generate suitable polynomial orderings automatically have been developed in <ref> [Ste94, Gie95a] </ref>, for instance. In the following, let t fl and r fl denote tuples of terms t 1 ; : : ; t n and r 1 ; : : ; r n .
Reference: [Ste95] <author> J. Steinbach. </author> <title> Simplification orderings: History of results. </title> <journal> Fundam. Informaticae, </journal> <volume> 24 </volume> <pages> 47-87, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction Proving termination is a central problem in the development of correct software. While most work on the automation of termination proofs has been done for term rewriting systems (for surveys see e.g. <ref> [Der87, Ste95] </ref>) and for logic programs (e.g. [UvG88, Plu90, SD94]), in this paper we consider functional programs. A functional program f (x) is terminating if the arguments of each recursive call f (r) decrease w.r.t. a well-founded ordering.
Reference: [UvG88] <author> J. D. Ullman and A. van Gelder. </author> <title> Efficient tests for top-down termination of logical rules. </title> <journal> Journal of the ACM, </journal> <volume> 35(2) </volume> <pages> 345-373, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Proving termination is a central problem in the development of correct software. While most work on the automation of termination proofs has been done for term rewriting systems (for surveys see e.g. [Der87, Ste95]) and for logic programs (e.g. <ref> [UvG88, Plu90, SD94] </ref>), in this paper we consider functional programs. A functional program f (x) is terminating if the arguments of each recursive call f (r) decrease w.r.t. a well-founded ordering. A well-known method for termination proofs of lisp functions has been implemented in the nqthm system of R. S.
Reference: [Wal94a] <author> C. Walther. </author> <title> Mathematical induction. </title> <editor> In D. M. Gabbay, C. J. Hogger, and J. A. Robinson, editors, </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming, </booktitle> <volume> vol. 2. </volume> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: To perform the required proofs, we simply applied symbolic evaluation, i.e. we used the defining equations as rewrite rules. In general this verification could require an induction theorem proving system, e.g. <ref> [BM79, ZKK88, Bun + 89, Wal94a, BR95, HS96] </ref>. However, when testing our method on numerous algorithms, we found that in almost all examples the required conjectures could already be proved by symbolic evaluation. <p> Such a term suggests a plausible induction w.r.t. g using y 1 ; : : ; y n as induction variables, cf. e.g. <ref> [BM79, ZKK88, Bun + 89, Wal94a] </ref>. Hence, for the termination hypothesis of minus this heuristic suggests inductive evaluation w.r.t. le using the induction variables x and y. Inductive evaluation is used for algorithms where the conditions of recursive calls have to be analyzed in order to prove termination. <p> We also use a rule Inverse Weakening to eliminate a conjunct from the premise of a termination hypotheses, cf. <ref> [Wal94a] </ref>. This rule is often needed before Inductive Evaluation to enable the application of the induction hypothesis.
Reference: [Wal94b] <author> C. Walther. </author> <title> On proving the termination of algorithms by machine. </title> <journal> Artificial Intelligence, </journal> <volume> 71(1) </volume> <pages> 101-157, </pages> <year> 1994. </year>
Reference-contexts: Then it remains to verify ! where is the condition under which the recursive call f (r) is performed. While in [BM79] the user has to supply all induction lemmata, the methods in <ref> [Wal94b, Gie95c, GWB98] </ref> synthesize a certain class of induction lemmata automatically. The technique in [Wal94b] is restricted to one fixed ordering , but the approach of [Gie95c, GWB98] also allows an automatic generation of suitable well-founded orderings by incorporating techniques from the area of term rewriting systems. <p> Then it remains to verify ! where is the condition under which the recursive call f (r) is performed. While in [BM79] the user has to supply all induction lemmata, the methods in [Wal94b, Gie95c, GWB98] synthesize a certain class of induction lemmata automatically. The technique in <ref> [Wal94b] </ref> is restricted to one fixed ordering , but the approach of [Gie95c, GWB98] also allows an automatic generation of suitable well-founded orderings by incorporating techniques from the area of term rewriting systems. <p> In this way we obtained an extremely powerful approach for automated termination analysis which performed successfully on a large collection of benchmarks (including all 82 algorithms from [BM79], all 60 examples from <ref> [Wal94b] </ref>, and all 92 examples in [Gie95b] and [BG96]). See the appendix for a collection of 36 algorithms whose termination behaviour could not be analyzed with any other automatic method up to now, but where inductive evaluation enables termination analysis without user interaction.
Reference: [ZKK88] <author> H. Zhang, D. Kapur, and M. S. Krishnamoorthy. </author> <title> A mechanizable induction principle for equational specifications. </title> <booktitle> In Proc. </booktitle> <address> CADE-9, Argonne, USA, </address> <publisher> LNCS 310, </publisher> <year> 1988. </year> <month> 81 </month>
Reference-contexts: To perform the required proofs, we simply applied symbolic evaluation, i.e. we used the defining equations as rewrite rules. In general this verification could require an induction theorem proving system, e.g. <ref> [BM79, ZKK88, Bun + 89, Wal94a, BR95, HS96] </ref>. However, when testing our method on numerous algorithms, we found that in almost all examples the required conjectures could already be proved by symbolic evaluation. <p> Such a term suggests a plausible induction w.r.t. g using y 1 ; : : ; y n as induction variables, cf. e.g. <ref> [BM79, ZKK88, Bun + 89, Wal94a] </ref>. Hence, for the termination hypothesis of minus this heuristic suggests inductive evaluation w.r.t. le using the induction variables x and y. Inductive evaluation is used for algorithms where the conditions of recursive calls have to be analyzed in order to prove termination.
References-found: 30

