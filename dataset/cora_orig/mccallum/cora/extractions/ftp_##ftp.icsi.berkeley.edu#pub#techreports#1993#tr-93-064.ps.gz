URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1993/tr-93-064.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1993.html
Root-URL: http://www.icsi.berkeley.edu
Email: E-mail: szyper@icsi.berkeley.edu. ICSI, E-mail: om@icsi.berkeley.edu.  E-mail: murer@icsi.berkeley.edu.  
Title: Engineering a Programming Language: The Type and Class System of  
Author: Sather Clemens Szypersky Stephen Omohundro Stephan Murer 
Address: Switzerland.  
Affiliation: ICSI and Eidgenossische Technische Hochschule (ETH), Zurich,  
Note: ICSI,  
Date: November 1993  
Pubnum: TR-93-064  
Abstract: Sather 1.0 is a programming language whose design has resulted from the interplay of many criteria. It attempts to support a powerful object-oriented paradigm without sacrificing either the computational performance of traditional procedural languages or support for safety and correctness checking. Much of the engineering effort went into the design of the class and type system. This paper describes some of these design decisions and relates them to approaches taken in other languages. We particularly focus on issues surrounding inheritance and subtyping and the decision to explicitly separate them in Sather. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. Keene, G. Kiczales, and D. A. Moon. </author> <title> The common lisp object system specification. </title> <type> Technical Report 88-002R, X3J13, </type> <month> June </month> <year> 1988. </year> <note> Also in special issue of SIGPLAN Notices 23 (Sep. 1988) and Lisp and Symbolic Computation (Jan. </note> <year> 1989). </year>
Reference-contexts: The user selects between conflicting features using the scope resolution operator "::". 4. Form composite union of features: Create one single feature for each conflicting feature by algorith mically resolving the conflict. CLOS <ref> [1] </ref> follows this approach by linearizing the class hierarchy. 1. to 3. are explicit conflict resolution methods, 4. is an implicit method.
Reference: [2] <author> Gilad Bracha and William R. Cook. </author> <title> Mixin-based inheritance. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming, Systems, and Applications and European Conferance on Object-Oriented Programming (OOPSLA/ECOOP'90), </booktitle> <address> Ottawa, Canada, </address> <month> October </month> <year> 1990. </year> <note> Also in SIGPLAN Notices, 25:10, </note> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: Section 2.3). Multiple subclassing is much less common in Sather programs than multiple subtyping. Nevertheless, there are situations where application programmers prefer to use multiple subclassing. It is used in the mixin programming style used extensively in CLOS <ref> [2] </ref>. ICSIM, the ICSI neural network simulator, uses this style to let the user configure the properties of neuron sites. Sites are subsets of a neuron's connections with identical properties.
Reference: [3] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <type> Technical report, </type> <institution> DEC Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Statically-checked strong typing is fundamental to achieving both the performance and the safety goals of Sather. Type safety is ensured because of a conformance requirement on the interfaces of types <ref> [3] </ref>. If the type A conforms to the type B, then the interface of A is required to conform to the interface of B. This means that for each signature in B's interface there is a conforming signature in A's interface.
Reference: [4] <author> Craig Chambers. </author> <title> The Cecil language specification and rationale. </title> <type> Technical Report 93-03-05, </type> <institution> Department of Computer Science, University of Washington, </institution> <address> Seattle, WA, </address> <month> March </month> <year> 1993. </year>
Reference-contexts: A class A is called a subclass of a class B if A's implementation is based in part on B's implementation. Code reuse in this sense differs from the use of traditional library routines in two important ways. First, the inherited code 3 The language Cecil <ref> [4] </ref> uses multi-methods to allow multiple covariantly typed parameters in a type-safe way. Some disadvantages of multi-methods are discussed in section 2.7. 2 has direct access to the internal representation of the reusing class. Second, the inherited code may make calls on self. <p> In Emerald, however, the result is a significant burden on the programmer. Often, subtyping and subclassing do go along in parallel, and Emerald requires separate specification even for this common case. Later language designs, such as Sather 1.0 and Cecil <ref> [4] </ref>, attempt to provide more convenient ways to support the common case. Since Cecil is based on prototype objects, quite similar to Self, its code inheritance is not based on classes. Still, Cecil's counterpart to subclassing has the default behavior of also introducing a subtype. <p> Form composite union of features: Create one single feature for each conflicting feature by algorith mically resolving the conflict. CLOS [1] follows this approach by linearizing the class hierarchy. 1. to 3. are explicit conflict resolution methods, 4. is an implicit method. Cecil <ref> [4] </ref> takes an intermediate stance between 3. and 4. by imposing only a partial ordering on classes, and requiring any remaining 8 conflicts to be resolved explicitly by the programmer.
Reference: [5] <author> William R. Cook. </author> <title> A proposal for making eiffel type safe. </title> <booktitle> In Proceedings of the Third European Conference on Object-Oriented Programming (ECOOP'89), </booktitle> <pages> pages 57-70, </pages> <address> Nottingham, England, 1989. </address> <publisher> Cambridge University Press. </publisher>
Reference-contexts: One of the most fundamental aspects of the Sather 1.0 design is its type system. Earlier versions of the language were strongly typed, but it was not possible to statically check a system for type correctness. Eiffel has the same problem <ref> [5] </ref>, and attempts to solve it by introducing system-level type-checking [17]. This is a conservative system-wide global check. A system which satisfies the check will be type safe but many legal programs are rejected. Adding new classes to a system can cause previously correct code to become incorrect. <p> This approach is adopted as a compromise in many languages, including the original version of Sather and Eiffel [17]. This violates the requirement of local type checkability. In the original Eiffel design this was a safety loop-hole <ref> [5] </ref>. The latest version of Eiffel requires "system-level type checking", which gives up on local type checkability and sometimes rejects dynamically type-safe programs. Because of these problems, [6] suggested that subtyping should be clearly separated from subclassing. Emerald [11] is one of the few languages that actually implemented this separation.
Reference: [6] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Proceedings of the ACM Conference on Principles of Programming Languages (POPL'90), </booktitle> <pages> pages 125-135. </pages> <publisher> ACM Press. Addison-Wesley, </publisher> <year> 1990. </year> <month> 13 </month>
Reference-contexts: This violates the requirement of local type checkability. In the original Eiffel design this was a safety loop-hole [5]. The latest version of Eiffel requires "system-level type checking", which gives up on local type checkability and sometimes rejects dynamically type-safe programs. Because of these problems, <ref> [6] </ref> suggested that subtyping should be clearly separated from subclassing. Emerald [11] is one of the few languages that actually implemented this separation. In Emerald, however, the result is a significant burden on the programmer.
Reference: [7] <author> Mahesh Dodani and Chung-Sin Tsai. </author> <title> ACTS: A type system for object-oriented programming based on abstract and concrete classes. </title> <booktitle> In Proceedings of the Sixth European Conference on Object-Oriented Programming (ECOOP'92), </booktitle> <pages> pages 309-328, </pages> <address> Utrecht, Netherlands, </address> <year> 1992. </year>
Reference-contexts: Abstract classes can have descendants in the type graph, but cannot be instantiated as objects. Concrete classes are always leaf-nodes in the subtype graph, but can be instantiated. This approach is similar to the type system formally defined in <ref> [7] </ref>. Abstract classes may provide partial implementations to be inherited by subclasses, while concrete classes are required to fully implement their type. Sather code inheritance is explained in Section 3. All Sather variables are statically typed.
Reference: [8] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Also, because of the separation between subclassing from subtyping, code can be inherited in the opposite direction from subtyping if desired. 2.3 Separating Subtyping and Subclassing Traditionally, object-oriented languages are either untyped - e.g. Smalltalk [10] or Self [27] or tightly bind classes and types - e.g. C++ <ref> [8] </ref>, Eiffel [17] Modula-3 [21], or Oberon-2 [19]. (In contrast to Oberon-2, Oberon [23] keeps the dispatching of implementation variants separate from subtyping issues, essentially by not providing methods at all. Instead, Oberon relies entirely on procedure variables to implement late binding.
Reference: [9] <author> Richard P. Gabriel, Jon L White, and Daniel G. Bobrow. </author> <title> CLOS: Integrating object-oriented and functional programming. </title> <journal> Communications of the ACM, </journal> <volume> 34(9) </volume> <pages> 29-38, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Two routines or iters are said to conflict if they have the same name, the same number and types of arguments, and both either have or do not have a return value. Reference <ref> [9] </ref> describes four ways to cope with inheritance conflicts: 1. Disallow conflicts: Signal an error in the case of a conflict. 2. Resolve conflicts by explicit selection: Require the user to make a selection in case of a conflict. This is Sather's approach, as described below. 3.
Reference: [10] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80, The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: Also, because of the separation between subclassing from subtyping, code can be inherited in the opposite direction from subtyping if desired. 2.3 Separating Subtyping and Subclassing Traditionally, object-oriented languages are either untyped - e.g. Smalltalk <ref> [10] </ref> or Self [27] or tightly bind classes and types - e.g. C++ [8], Eiffel [17] Modula-3 [21], or Oberon-2 [19]. (In contrast to Oberon-2, Oberon [23] keeps the dispatching of implementation variants separate from subtyping issues, essentially by not providing methods at all.
Reference: [11] <author> Norman Hutchinson. </author> <title> Emerald: An Object-Oriented Language for Distributed Programming. </title> <type> PhD thesis, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <address> Seattle, WA, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: In the original Eiffel design this was a safety loop-hole [5]. The latest version of Eiffel requires "system-level type checking", which gives up on local type checkability and sometimes rejects dynamically type-safe programs. Because of these problems, [6] suggested that subtyping should be clearly separated from subclassing. Emerald <ref> [11] </ref> is one of the few languages that actually implemented this separation. In Emerald, however, the result is a significant burden on the programmer. Often, subtyping and subclassing do go along in parallel, and Emerald requires separate specification even for this common case.
Reference: [12] <author> Kathleen Jensen and Niklaus Wirth. </author> <title> PASCAL: User Manual and Report. </title> <publisher> Springer-Verlag, 2d ed. corr. </publisher> <address> print edition, </address> <year> 1978. </year>
Reference-contexts: While expressive and powerful, certain formulations are difficult to implement efficiently. Hence, many non-functional programming languages provide more lightweight but much less powerful facilities. Pascal <ref> [12] </ref> introduced procedure parameters, but no procedure variables. This allowed implementations to strictly adhere to a stack discipline, but prevented the use of procedures as first-class values in data structures.
Reference: [13] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1978. </year>
Reference-contexts: This allowed implementations to strictly adhere to a stack discipline, but prevented the use of procedures as first-class values in data structures. In Modula-2 [29] this was changed to allow for procedure variables, but the restriction was added that only global procedures can be assigned. C <ref> [13] </ref> has function pointers with a similar semantics.
Reference: [14] <author> B.B. Kristensen, O.L. Madsen, B. Moeller-Pedersen, and Kristen Nygaard. </author> <title> The BETA programming language. In B.D. </title> <editor> Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Not separating these concepts properly leads to several problems, however. One approach requires that every subclass relationship obeys the rules of type-safe subtyping. This leads to contravariant typing of routine arguments. It has been argued that this eliminates several important opportunities for code reuse <ref> [18, 14] </ref>. Another approach introduces subclasses which are subtypes by declaration but not in terms of the interface which is supported. This approach is adopted as a compromise in many languages, including the original version of Sather and Eiffel [17]. This violates the requirement of local type checkability.
Reference: [15] <author> Chu-Cheow Lim and Andreas Stolcke. </author> <title> Sather language design and performance evaluation. </title> <type> Technical Report TR-91-034, </type> <institution> International Computer Science Institute, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: The initial "0.1" release of the compiler, debugger, class library, and development environment were made available by anonymous FTP 1 in May, 1991 and it was quickly retrieved by several hundred sites. This version achieved our desired efficiency goals <ref> [15] </ref> and was used for several projects. Our experience with it and feedback from other users has led to the design of Sather 1.0. This improves certain aspects of the initial version and incorporates a number of new language constructs.
Reference: [16] <author> Boris Magnusson. </author> <title> Code reuse considered harmful. </title> <journal> Journal of Object Oriented Programming, </journal> <volume> 4(3), </volume> <month> November </month> <year> 1991. </year>
Reference-contexts: Second, the inherited code may make calls on self. Such calls may call other inherited operations or operations explicitly defined in the new class. This intricate tangling of new and old code is powerful but complexity-prone <ref> [16] </ref>. As with subtyping, Sather allows multiple subclassing: A class can be subclass of multiple classes, i.e. it can reuse portions of the implementations of multiple classes. Multiple subclassing introduces many complications that require careful attention. Most languages combine multiple subtyping with multiple subclassing into multiple inheritance.
Reference: [17] <author> Bertrand Meyer. </author> <title> Eiffel The Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Earlier versions of the language were strongly typed, but it was not possible to statically check a system for type correctness. Eiffel has the same problem [5], and attempts to solve it by introducing system-level type-checking <ref> [17] </ref>. This is a conservative system-wide global check. A system which satisfies the check will be type safe but many legal programs are rejected. Adding new classes to a system can cause previously correct code to become incorrect. <p> Smalltalk [10] or Self [27] or tightly bind classes and types - e.g. C++ [8], Eiffel <ref> [17] </ref> Modula-3 [21], or Oberon-2 [19]. (In contrast to Oberon-2, Oberon [23] keeps the dispatching of implementation variants separate from subtyping issues, essentially by not providing methods at all. Instead, Oberon relies entirely on procedure variables to implement late binding. <p> Another approach introduces subclasses which are subtypes by declaration but not in terms of the interface which is supported. This approach is adopted as a compromise in many languages, including the original version of Sather and Eiffel <ref> [17] </ref>. This violates the requirement of local type checkability. In the original Eiffel design this was a safety loop-hole [5]. The latest version of Eiffel requires "system-level type checking", which gives up on local type checkability and sometimes rejects dynamically type-safe programs.
Reference: [18] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Not separating these concepts properly leads to several problems, however. One approach requires that every subclass relationship obeys the rules of type-safe subtyping. This leads to contravariant typing of routine arguments. It has been argued that this eliminates several important opportunities for code reuse <ref> [18, 14] </ref>. Another approach introduces subclasses which are subtypes by declaration but not in terms of the interface which is supported. This approach is adopted as a compromise in many languages, including the original version of Sather and Eiffel [17]. This violates the requirement of local type checkability.
Reference: [19] <author> Hanspeter Mossenbock and Niklaus Wirth. </author> <title> The programming language Oberon-2. Structured Programming, </title> <type> 12(4), </type> <year> 1991. </year>
Reference-contexts: Smalltalk [10] or Self [27] or tightly bind classes and types - e.g. C++ [8], Eiffel [17] Modula-3 [21], or Oberon-2 <ref> [19] </ref>. (In contrast to Oberon-2, Oberon [23] keeps the dispatching of implementation variants separate from subtyping issues, essentially by not providing methods at all. Instead, Oberon relies entirely on procedure variables to implement late binding. Nevertheless, Oberon still does not completely separate subtyping from subclassing, cf.
Reference: [20] <author> Stephan Murer, Stephen Omohundro, and Clemens A. Szyperski. Sather iters: </author> <title> Object-oriented iteration abstraction. </title> <type> Technical Report TR-92-xxx, </type> <institution> International Computer Science Institute, </institution> <year> 1993. </year>
Reference-contexts: Sather supports both routines which perform a single operation and iters <ref> [20] </ref> which encapsulate iteration abstractions 2 . 1 From ftp.icsi.berkeley.edu, directory pub/sather/ 2 There is some additional information in signatures which are associated with iters which we do not describe here. 1 * Each type has an interface which consists of the signatures of the operations that may be applied to <p> This provides a natural organization principle and is responsible for the encapsulation of functionality into types. The interface of a type encapsulates the 4 We do not describe iters here because it would take us too far afield and they have been described elsewhere <ref> [20] </ref>. 5 abstraction defined by that type. With multi-methods code does not naturally belong to a particular type. Sather deals with multi-method situations by using "typecase" statements.
Reference: [21] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Smalltalk [10] or Self [27] or tightly bind classes and types - e.g. C++ [8], Eiffel [17] Modula-3 <ref> [21] </ref>, or Oberon-2 [19]. (In contrast to Oberon-2, Oberon [23] keeps the dispatching of implementation variants separate from subtyping issues, essentially by not providing methods at all. Instead, Oberon relies entirely on procedure variables to implement late binding. Nevertheless, Oberon still does not completely separate subtyping from subclassing, cf.
Reference: [22] <author> Stephen Omohundro. </author> <title> Sather provides nonproprietary access to object-oriented programming. </title> <journal> Computers in Physics, </journal> <volume> 6(5) </volume> <pages> 444-449, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Sather is an object-oriented language developed at the International Computer Science Institute <ref> [22] </ref>. It has a clean and simple syntax, parameterized classes, object-oriented dispatch, statically-checkable strong typing, multiple subtyping, multiple code inheritance, and garbage collection. It is especially aimed at complex, performance-critical applications. Such applications are in need of both reusable components and high computational efficiency.
Reference: [23] <author> Martin Reiser and Niklaus Wirth. </author> <title> Programming in Oberon. Steps Beyond Pascal and Modula. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Smalltalk [10] or Self [27] or tightly bind classes and types - e.g. C++ [8], Eiffel [17] Modula-3 [21], or Oberon-2 [19]. (In contrast to Oberon-2, Oberon <ref> [23] </ref> keeps the dispatching of implementation variants separate from subtyping issues, essentially by not providing methods at all. Instead, Oberon relies entirely on procedure variables to implement late binding. Nevertheless, Oberon still does not completely separate subtyping from subclassing, cf.
Reference: [24] <author> Heinz W. Schmidt and Benedict Gomes. ICSIM: </author> <title> An object-oriented connectionist simulator. </title> <type> Technical Report TR-91-048, </type> <institution> International Computer Science Institute, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: This improves certain aspects of the initial version and incorporates a number of new language constructs. The language design process has been intimately coupled with the design and implementation of libraries and applications. A particularly demanding application is the extensible ICSI connectionist network simulator: ICSIM <ref> [24] </ref>. The examples in this paper are taken from the actual code and structure of the Sather libraries and applications to make them realistic. The design effort was continually a balance between the needs of applications and constraints on language design, such as simplicity and orthogonality.
Reference: [25] <author> Alan Snyder. </author> <title> Encapsulation and Inheritance in object-oriented programming languages. </title> <booktitle> In Proceedings of the First ACM Conference on Object-Oriented Programming, Systems, and Applications (OOPSLA'86), </booktitle> <pages> pages 38-45, </pages> <address> Portland, OR, </address> <month> November </month> <year> 1986. </year> <note> Also in SIGPLAN Notices, 21:11, </note> <month> Nov. </month> <year> 1986. </year>
Reference-contexts: Cecil [4] takes an intermediate stance between 3. and 4. by imposing only a partial ordering on classes, and requiring any remaining 8 conflicts to be resolved explicitly by the programmer. We agree with <ref> [25] </ref> that CLOS-style linearization of the inheritance graphs may lead to unexpected method lookups, and result in faulty and hard to debug programs. Sather, therefore, adopts an explicit conflict resolution scheme in which the programmer has to explicitly choose in case of conflicts.
Reference: [26] <author> Clemens A. Szyperski. </author> <title> Import is not Inheritance why we need both: Modules and Classes. </title> <booktitle> In Proceedings of the Sixth European Conference on Object-Oriented Programming (ECOOP'92), </booktitle> <address> Utrecht, The Netherlands, </address> <month> June </month> <year> 1992. </year> <month> 14 </month>
Reference-contexts: Possible solutions tend to either restrict the usefulness of parameterized classes, or to introduce a complicated apparatus to specify 9 sufficiently strong bounds on the parameters. Explicit support for expressing subsystem boundaries, such as modules <ref> [26] </ref>, might be a useful extension to Sather.
Reference: [27] <author> David Ungar and Randall B. Smith. </author> <title> Self: The power of simplicity. </title> <booktitle> In Proceedings of the Second ACM Conference on Object-Oriented Programming, Systems, and Applications (OOPSLA'87), </booktitle> <address> Orlando, FL, </address> <month> October </month> <year> 1987. </year> <note> Also in SIGPLAN Notices, 22:12, </note> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: Also, because of the separation between subclassing from subtyping, code can be inherited in the opposite direction from subtyping if desired. 2.3 Separating Subtyping and Subclassing Traditionally, object-oriented languages are either untyped - e.g. Smalltalk [10] or Self <ref> [27] </ref> or tightly bind classes and types - e.g. C++ [8], Eiffel [17] Modula-3 [21], or Oberon-2 [19]. (In contrast to Oberon-2, Oberon [23] keeps the dispatching of implementation variants separate from subtyping issues, essentially by not providing methods at all.
Reference: [28] <author> U.S. </author> <title> Department of Defence. Ada Reference Manual: Proposed Standard Document, </title> <month> July </month> <year> 1980. </year>
Reference-contexts: Direct-called routines are Sather's version of plain procedures in Pascal, class methods in Smalltalk, and static member functions in C++. 2.8 Parameterized Classes Sather allows the definition of a family of classes parameterized by types. This is a similar mechanism to the generic packages of Ada <ref> [28] </ref> and templates in the newer versions of C++. Sather type parameters have associated type constraints. The values specified for the type parameters are required to be subtypes of these constraint types. The supertyping feature introduced in Section 2.1 is quite useful for defining such constraints.
Reference: [29] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer-Verlag, </publisher> <year> 1982. </year> <month> 15 </month>
Reference-contexts: Hence, many non-functional programming languages provide more lightweight but much less powerful facilities. Pascal [12] introduced procedure parameters, but no procedure variables. This allowed implementations to strictly adhere to a stack discipline, but prevented the use of procedures as first-class values in data structures. In Modula-2 <ref> [29] </ref> this was changed to allow for procedure variables, but the restriction was added that only global procedures can be assigned. C [13] has function pointers with a similar semantics.
References-found: 29

