URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/reuse/jcss97.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@db.toronto.edu  
Title: Reusing and Modifying Rulebases by Predicate Substitution  
Author: Anthony J. Bonner Tomasz Imielinski 
Web: www.cs.toronto.edu/~bonner/papers.html#reuse  
Note: Published in the Journal of Computer and System Sciences (JCSS), 54(1):136-166, February 1997. Special issue on the Eleventh ACM Symposium on Principles of Database Systems (PODS'92). This and related papers are available at the following web page:  Work supported in part by an Operating Grant from the Natural Sciences and Engineering Research Council of Canada and by a Connaught Grant from the  
Address: Toronto, Ontario, Canada M5S 3G4  New Brunswick, NJ 08903, United States  
Affiliation: University of Toronto Department of Computer Science  Rutgers University Department of Computer Science  University of Toronto.  
Abstract: We propose a method for reusing and modifying a deductive database. The need for such techniques occurs when new rulebased applications differ only slightly from existing ones or when an application is to be incrementally updated. Such techniques are particularly important when reprogramming is expensive or unreliable. In order to facilitate reuse, we extend deductive database systems by the concept of predicate substitution. In this way, during query evaluation, not only variables, but also predicates can be substituted. We provide a proof theory and a model theory for this language, including a fixpoint semantics. In addition, we show that substitution increases the expressive power of Datalog: not only does its data complexity increase from PTIME to EXPTIME, but substitution also allows large sets of Datalog rules to be succinctly expressed. In fact, finite rulebases with substitution can express infinite rulebases without substitution. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K.R. Apt and M.H. Van Emden. </author> <title> Contributions to the Theory of Logic Programming. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 841-862, </pages> <year> 1982. </year>
Reference-contexts: Extending this idea a bit, if fi [] is a ground instance of a unit rule in S y , then so is fi. 3. In the fixpoint semantics of logic programming <ref> [1, 18] </ref>, each Horn rulebase, R, has an associated operator, T R . This operator takes a set of ground atoms, I, as input and returns another set of ground atoms, T R (I), as output. <p> This is so because infinite rulebases do not change the essential properties of the operator T R : it remains monotonic and continuous. The Tarski Fixpoint Theorem [16], which is at the heart of the fixpoint semantics, can thus be applied in the usual way <ref> [1, 18] </ref>. 3 Keeping these observations in mind, we proceed to prove the only if direction of the lemma. The main idea is to treat S y [ DB as a classical Horn rulebase and to exploit its associated operator, T S y [DB . <p> Since this is true for any model R of S, it follows that S; DB j= fi. 2 4 Fixpoint Semantics This section develops the fixpoint semantics of Horn rules with predicate substitution, following the tradition of classical logic programming <ref> [1, 18] </ref>. A main result is that a Horn rulebase with substitution has a unique minimal model. As in classical Horn logic, the minimal model can be viewed as the user's "intended model", a model that he could have written if he had the time, space and inclination. <p> However, this subsection shows that we need only use a specific finite subset of R y . The key idea is the degree of a predicate with substitution. 6 UPPER COMPLEXITY BOUNDS 43 Definition 6.2 (Degree of Substitution) If ff is an atomic formula, and <ref> [ 1 ] </ref>:::[ i ] are predicate substitutions, then ff [ 1 ]:::[ i ] is a predicate with substitution of degree i. Thus, the atom A has degree 0, the predicate A [P=Q] has degree 1, the predicate A [P=Q][P=Q] has degree 2, etc. <p> The key idea is the degree of a predicate with substitution. 6 UPPER COMPLEXITY BOUNDS 43 Definition 6.2 (Degree of Substitution) If ff is an atomic formula, and <ref> [ 1 ] </ref>:::[ i ] are predicate substitutions, then ff [ 1 ]:::[ i ] is a predicate with substitution of degree i. Thus, the atom A has degree 0, the predicate A [P=Q] has degree 1, the predicate A [P=Q][P=Q] has degree 2, etc. <p> Q, and at most n choices for each of the y's, for a total of at most m 2 n p choices, or at most m 2 n k . * Each predicate with substitution in inst C (R y j i1 ) is ground and has the form ff <ref> [ 1 ] </ref>[ 2 ]:::[ i1 ], where ff is a ground atomic formula.
Reference: [2] <author> P.A. Bernstein. </author> <title> Synthesizing third normal form relations from functional dependencies. </title> <journal> ACM Transactions on Database Systems (TODS), </journal> <volume> 1(4) </volume> <pages> 277-298, </pages> <year> 1976. </year>
Reference-contexts: From Definition 5.7, 7 Ullman, for instance, describes an algorithm due to Bernstein that takes linear time <ref> [17, 2] </ref>. 7 LOWER COMPLEXITY BOUNDS 47 the main task in computing T S;C (R) is inferring expressions of the form R y ` c fi j fl.
Reference: [3] <author> A.J. Bonner and T. Imielinski. </author> <title> The Reuse and Modification of Rulebases by Predicate Substitution. </title> <booktitle> In Proceedings of the International Conference on Extending Database Technology (EDBT), </booktitle> <pages> pages 437-451, </pages> <address> Venice, Italy, </address> <month> March 26-30 </month> <year> 1990. </year> <note> Springer-Verlag. Published as volume 416 of Lecture Notes in Computer Science. </note>
Reference-contexts: Together with the EXPTIME upper-bound of Section 6, it proves that Datalog with predicate substitution is EXPTIME-complete. Predicate substitution therefore increases the computational power of Datalog, which is only PTIME-complete. A concrete illustration of this power is given in <ref> [3] </ref>, where Datalog with predicate substitution is used to solve the propositional satisfiability problem. EXPTIME completeness holds both for Datalog with full substitution and for Datalog with basic substitution.
Reference: [4] <author> A.K. Chandra and D. Harel. </author> <title> Structure and Complexity of Relational Queries. </title> <journal> Journal of Computer and System Sciences (JCSS), </journal> <volume> 25(1) </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: We therefore spend some time studying the complexity of such inferences. Because we are dealing with data complexity, we can assume that our language contains only finitely many predicate symbols, each of a fixed arity <ref> [4, 19] </ref>.
Reference: [5] <author> A.K. Chandra, D. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the ACM, </journal> <volume> 28 </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference-contexts: The same lower bound therefore holds for Datalog with full substitution. Theorem 7.1 The data complexity of Datalog with basic predicate substitution is EXPTIME-hard. To prove Theorem 7.1, we use Datalog with basic substitution to encode the computations of an alternating Turing machine <ref> [5] </ref>. Alternating machines are a generalization of non-deterministic machines. Like non-deterministic machines, they can have many possible transitions at each point in a computation; but they may require that all transitions be successful, not just one. <p> By encoding an arbitrary alternating PSPACE machine, we show 7 LOWER COMPLEXITY BOUNDS 48 that the data complexity of Datalog with basic substitution is complete for APSPACE. Theorem 7.1 follows since APSPACE = EXPTIME <ref> [5] </ref>. To state the main result precisely, let M be an alternating PSPACE machine. Without loss of generality, we assume that M has a single tape. We encode this machine as a database DB (M ). <p> From this, we conclude that the data complexity of Datalog with basic substitution is EXPTIME-hard. This result follows immediately by letting M be a machine that recognizes a EXPTIME-complete language. Examples of such languages are given in <ref> [5] </ref>. Section 7.2 describes the construction of DB (M ), DB (s) and S.
Reference: [6] <author> B.F. Chellas. </author> <title> Modal Logic: an Introduction. </title> <publisher> Cambridge University Press, </publisher> <year> 1980. </year>
Reference-contexts: One definition is used to prove soundness of the proof theory, and the other is used to prove completeness (in Sections 3.2 and 3.3). In our model theory, an interpretation is a classical Horn rulebase. These interpretations can be compared to modal structures <ref> [6] </ref>. This is possible because a classical rulebase can be thought of semantically as a set of classical models, instead of syntactically as a set of rules. In modal logic, an interpretation has a set of states.
Reference: [7] <author> W. Chen, M. Kifer, and D.S. Warren. Hilog: </author> <title> A First-Order Semantics for Higher-Order Logic Programming Constructs. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming (NACLP), </booktitle> <pages> pages 1090-1114. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference: [8] <author> C.S. Kwok and M. Sergot. </author> <title> Implicit Definiton of Logic Programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <pages> pages 374-385, </pages> <year> 1988. </year>
Reference: [9] <author> J.M. McCarthy and P.J. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <volume> volume 4, </volume> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year> <note> Reprinted in Readings in Artificial Intelligence, </note> <year> 1981, </year> <title> Tioga Publ. </title> <publisher> Co. </publisher>
Reference-contexts: Of course, during any step of a computation, most characters in a configuration do not change. Thus f (x; y; z) = y as long as x, y and z represent tape characters, not control states. This is an instance of the frame problem of Artificial Intelligence <ref> [9] </ref>. This problem does not concern us here however, since it is handled by the function f . Note in particular that f is finite and depends only on the machine M , not on the input s.
Reference: [10] <author> L.T. McCarty. </author> <title> A Language for Legal Discourse. I. Basic Features. </title> <booktitle> In Proceedings of the Second International Conference on Artificial Intelligence and Law, </booktitle> <pages> pages 180-189. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Such systems have a variety of applications, such as computer-based medical and legal consultation systems. Kowalski and Sergot, for instance, have encoded the British Nationality Act in Prolog [15], and McCarty has developed systems for reasoning about tax law, especially corporate tax law and estate tax law <ref> [10, 14] </ref>. As laws are amended, such systems have to be updated. For instance, sections of the income tax act might be amended to treat residents as citizens. In this case, every occurrence of the predicate "citizen" could be replaced by a new predicate meaning "citizen or resident".
Reference: [11] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences (JCSS), </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference: [12] <author> A. Mycroft. </author> <title> Polymorphic type schemes and recursive definitions. </title> <editor> In M. Paul and B. Robinet, editors, </editor> <booktitle> Proceedings of the International Symposium on Programming, number 167 in Lecture Notes in Computer Science, </booktitle> <pages> pages 217-228. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1984. </year>
Reference: [13] <author> A. Mycroft and R.A. O'Keefe. </author> <title> A polymorphic type system for Prolog. </title> <journal> Artificial Intelligence, </journal> <volume> 23(3) </volume> <pages> 295-307, </pages> <year> 1984. </year>
Reference: [14] <author> D.A. Schlobohm and L.T. McCarty. EPS-II: </author> <title> Estate planning with prototypes. </title> <booktitle> In Proceedings of the Second International Conference on Artificial Intelligence and Law, </booktitle> <pages> pages 1-10. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1989. </year> <note> REFERENCES 55 </note>
Reference-contexts: Such systems have a variety of applications, such as computer-based medical and legal consultation systems. Kowalski and Sergot, for instance, have encoded the British Nationality Act in Prolog [15], and McCarty has developed systems for reasoning about tax law, especially corporate tax law and estate tax law <ref> [10, 14] </ref>. As laws are amended, such systems have to be updated. For instance, sections of the income tax act might be amended to treat residents as citizens. In this case, every occurrence of the predicate "citizen" could be replaced by a new predicate meaning "citizen or resident".
Reference: [15] <author> M.J. Sergot, F. Sadri, R.A. Kowalski, F. Kriwaczek, P. Hammond, and H.T. Cory. </author> <title> The British Nationality Act as a logic program. </title> <journal> Communications of the ACM, </journal> <volume> 29(5), </volume> <year> 1986. </year>
Reference-contexts: In addition, rules with substitution seem well suited to the reuse and modification of expert database systems. Such systems have a variety of applications, such as computer-based medical and legal consultation systems. Kowalski and Sergot, for instance, have encoded the British Nationality Act in Prolog <ref> [15] </ref>, and McCarty has developed systems for reasoning about tax law, especially corporate tax law and estate tax law [10, 14]. As laws are amended, such systems have to be updated. For instance, sections of the income tax act might be amended to treat residents as citizens.
Reference: [16] <author> A. Tarski. </author> <title> A Lattice-Theoretical Fixpoint Theorem and its Applications. </title> <journal> Pacific Journal of Mathematics, </journal> <volume> 5 </volume> <pages> 285-309, </pages> <year> 1955. </year>
Reference-contexts: This property remains true even if R is infinite. This is so because infinite rulebases do not change the essential properties of the operator T R : it remains monotonic and continuous. The Tarski Fixpoint Theorem <ref> [16] </ref>, which is at the heart of the fixpoint semantics, can thus be applied in the usual way [1, 18]. 3 Keeping these observations in mind, we proceed to prove the only if direction of the lemma. <p> Thus every rule in T S (R 2 ) is also in T S (R 1 ). 2 Since T S is a monotonic operator on a complete lattice, it has a least fixpoint, as stated in the following lemma. This result is due to Tarski <ref> [16] </ref>. Theorem 4.7 (Least Fixpoint) The operator T S has a least fixpoint lfp (T S ). <p> The main result of this section is that this sequence converges to the least fixpoint of T S , as stated in the next lemma. This result follows from the monotonicity and continuity of the operator T S , as originally shown by Tarski <ref> [16] </ref>. Theorem 4.12 T fl S (fg) lfp (T S ) To start a least fixpoint computation, we must compute T S (fg). This is a relatively easy computation. As the next lemma shows, T S (fg) extracts the classical Horn rules from S.
Reference: [17] <author> J.D. Ullman. </author> <title> Principles of Database Systems. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, Maryland, </address> <year> 1982. </year>
Reference-contexts: From Definition 5.7, 7 Ullman, for instance, describes an algorithm due to Bernstein that takes linear time <ref> [17, 2] </ref>. 7 LOWER COMPLEXITY BOUNDS 47 the main task in computing T S;C (R) is inferring expressions of the form R y ` c fi j fl.
Reference: [18] <author> M.H. Van Emden and R.A. Kowalski. </author> <title> The Semantics of Predicate Logic as a Programming Language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: Extending this idea a bit, if fi [] is a ground instance of a unit rule in S y , then so is fi. 3. In the fixpoint semantics of logic programming <ref> [1, 18] </ref>, each Horn rulebase, R, has an associated operator, T R . This operator takes a set of ground atoms, I, as input and returns another set of ground atoms, T R (I), as output. <p> This is so because infinite rulebases do not change the essential properties of the operator T R : it remains monotonic and continuous. The Tarski Fixpoint Theorem [16], which is at the heart of the fixpoint semantics, can thus be applied in the usual way <ref> [1, 18] </ref>. 3 Keeping these observations in mind, we proceed to prove the only if direction of the lemma. The main idea is to treat S y [ DB as a classical Horn rulebase and to exploit its associated operator, T S y [DB . <p> Since this is true for any model R of S, it follows that S; DB j= fi. 2 4 Fixpoint Semantics This section develops the fixpoint semantics of Horn rules with predicate substitution, following the tradition of classical logic programming <ref> [1, 18] </ref>. A main result is that a Horn rulebase with substitution has a unique minimal model. As in classical Horn logic, the minimal model can be viewed as the user's "intended model", a model that he could have written if he had the time, space and inclination.
Reference: [19] <author> M. Vardi. </author> <title> The Complexity of Relational Query Languages. </title> <booktitle> In Proceedings of the ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 137-146, </pages> <year> 1982. </year>
Reference-contexts: We therefore spend some time studying the complexity of such inferences. Because we are dealing with data complexity, we can assume that our language contains only finitely many predicate symbols, each of a fixed arity <ref> [4, 19] </ref>.
References-found: 19

