URL: http://www.cs.toronto.edu/~david/dissertation.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/cv.html
Root-URL: 
Title: FOUNDATIONS OF TEMPORAL QUERY LANGUAGES  
Author: by DAVID TOMAN 
Degree: A DISSERTATION submitted in partial fulfillment of the requirements for the degree DOCTOR OF PHILOSOPHY  Approved by: Dr. Jan Chomicki Major Professor  
Date: 1992  1995  
Address: Brno, Czech Republic,  
Affiliation: Mgr., Masaryk University,  Department of Computing and Information Sciences College of Engineering KANSAS STATE UNIVERSITY Manhattan, Kansas  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Abiteboul, S., Herr, L., Van den Bussche, J. </author> <title> Temporal Connectives versus Explicit Timestamps in Temporal Query Languages (unpublished report). A preliminary version in Proc. </title> <booktitle> International Workshop of Temporal Databases, </booktitle> <address> Zurich, Switzerland, </address> <year> 1995. </year>
Reference-contexts: Definition 3.9). The semantics is also defined in the same way as in Definition 3.11 with a small "fix" to the base case: Embed (r i (x 1 ; : : : ; x v i )) = R i (t 0 <ref> [1] </ref>; x 1 ; : : : ; x v i ): The game for k-dimensional temporal logic is similar to the game for FOTL. The only difference is that for every temporal move we always pick k-tuples of elements of sort T instead of a single element. <p> Such sets cannot be represented over the data domain (as the theory of equality can finitely encode only finite and cofinite sets. A recent result <ref> [1] </ref> that separates FOTL with the since and until connectives from 2-FOL in the case of finite (sufficiently large) linear orders supports our conjecture. However [1] uses a counting argument in the proof and thus it does not generalize to arbitrary linear orders. <p> A recent result <ref> [1] </ref> that separates FOTL with the since and until connectives from 2-FOL in the case of finite (sufficiently large) linear orders supports our conjecture. However [1] uses a counting argument in the proof and thus it does not generalize to arbitrary linear orders. Also, the relationship between this work and various sets of temporal connectives defined in [42] is not clear. Bibliographical Notes Temporal logic with the connectives since and until was introduced in [56].
Reference: [2] <author> Abiteboul, S., Hull, R., Viannu, V. </author> <title> Foundations of Databases. </title> <publisher> Addison Wesley, </publisher> <year> 1995. </year>
Reference: [3] <author> Abramsky, S., Hankin, C. </author> <title> Abstract Interpretation of Declarative Languages. </title> <publisher> Ellis Hor-wood, </publisher> <year> 1987. </year>
Reference-contexts: c &lt; y : c 2 Zg|gap-order constraints with possibly negative size of the gap [73] or the linear arithmetic constraints [60]. 6.2 Abstract Interpretation Another interesting application of constraints can be found in the area of programming languages analysis, especially those analysis that are based on the Abstract Interpretation <ref> [3, 32] </ref>. The main idea behind this technique is to execute a given program with respect to its formal semantics and a set of abstract values, rather than with respect to the concrete values the program is designed to work on.
Reference: [4] <author> Aho, A. V.,Sethi, R., Ullman, J. D. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: The advantage of using the constraint approach is that it provides the correctness proofs of the whole analysis (provided we have a correct abstractions for the atomic values and operations). This approach can be applied to many techniques used for compiler optimization, e.g., the data-flow analysis <ref> [4] </ref> or the closure analysis [81]. 75 6.3 Other Formalisms There are few other extensions of Datalog with constraints.
Reference: [5] <author> Aho, A. V., Ullman, J. D. </author> <title> Universality of data retrieval languages. </title> <booktitle> In Proc. ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. 110-117, </pages> <year> 1979. </year>
Reference-contexts: A forthcoming survey of constraint query languages [78] from (which figure 6.1 was borrowed) discusses the individual results in detail. 76 Domain Constraints Relational Calculus Datalog Datalog : D = AC 0 1 [58] PTIME 1;4 <ref> [5, 17] </ref> PTIME 1;4 [6, 19] LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60, 36] [60] [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5
Reference: [6] <author> Apt, K. R., Blair, H., Walker, A. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In Minker, J. (ed.) </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pp 89-148, </pages> <publisher> Mor-gan Kaufman, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: A forthcoming survey of constraint query languages [78] from (which figure 6.1 was borrowed) discusses the individual results in detail. 76 Domain Constraints Relational Calculus Datalog Datalog : D = AC 0 1 [58] PTIME 1;4 [5, 17] PTIME 1;4 <ref> [6, 19] </ref> LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60, 36] [60] [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME
Reference: [7] <author> Ait-Kaci, H. </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction. </title> <publisher> MIT-Press 1991. </publisher>
Reference-contexts: Finally, there is a vast amount of articles on the various implementation techniques for Logic Programming languages based on resolution. Many of the ideas that are used in modern compilers of such languages can be found in <ref> [7] </ref>. 99 Chapter 8 Conclusion In this dissertation, we have investigated several questions concerning the design and implementation of Temporal Databases (and other databases intended to handle inherently infinite information).
Reference: [8] <author> Bancilhon F., Maier D., Sagiv Y., Ullman J. D. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proc. ACM Symposium on Principles of Database Systems, </booktitle> <year> 1986. </year>
Reference-contexts: However, such strategies fail to consider the information contained in a partially instantiated query (i.e., they are not goal-oriented). There are two major approaches to solving this problem in the framework of standard Datalog: 1. Rewrite the program using the Magic Set Transformation (MST) <ref> [8, 68] </ref> and subse quently evaluate the transformed program bottom-up, and 2. Adopt a top-down evaluation strategy [29, 92] based on the resolution principle [65]. In this section we consider mainly the top-down resolution-based method. <p> In the case of Datalog (i.e., the constraint class generated from the set fx = a : a 2 Ag) the MST C transformation reduces to the standard MST for Datalog <ref> [8] </ref>. Definition 7.14 (Adornment) Let G be an atom of arity k. An adornment A for this atom is a string over fb; f g of length k.
Reference: [9] <author> Bancilhon F., Ramakrishnan, R. </author> <title> An Amateur's Introduction to Recursive Query Processing Strategies. </title> <booktitle> In Proc. of ACM SIGMOD '86 , 16-52, </booktitle> <year> 1986. </year>
Reference-contexts: An in depth analysis of the bottom-up evaluation can be found in the second volume of Ullman's 98 book [100]. An overview of different deductive query evaluation strategies with brief descrip-tion of each of the methods can be also found in <ref> [9] </ref>. Here both the top-down and bottom-up strategies are discussed and their relative performance is analyzed. An introduction to the top-down query evaluation (and the area of Logic Programming in general) can be found in [65].
Reference: [10] <author> Birkhoff, G., MacLane, S. </author> <title> Algebra. </title> <publisher> The MacMillan Co., </publisher> <year> 1967. </year>
Reference-contexts: The size of this set is clearly exponential in the size of the input database as n + P n1 The fact, that the program generates all the constraints, follows immediately from the following proposition: Proposition 5.32 (The cyclic primary decomposition theorem <ref> [10] </ref>) Any finite Abelian group is isomorphic to a finite product of cyclic groups of prime power orders, and the list of the prime power orders is unique up to permutation. and the fact that the growth rate of the sequence of primes is approximately n log n [82]; every element <p> Most of the results about integers can be easily found in books on number theory, e.g., [48, 104] or [82] (if you read Polish). Other useful results about cyclic groups Z n can be found in books on group theory and modern algebra in general, e.g., <ref> [10] </ref>. 73 Chapter 6 Other Constraint Classes This section surveys several other known constraint classes, and summarizes their properties.
Reference: [11] <author> Berman, L. </author> <title> Precise bounds for Presburger arithmetic and the reals with addition. </title> <booktitle> In Proc. 18th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pp. 95-99, </pages> <year> 1977. </year>
Reference-contexts: P (Z) [87] [76] N,Z 1S NC PSPACE-comp PSPACE-comp [74] [23] [23] R &lt;; + NC undec. undec. [37] ) undec. undec. <ref> [71, 11] </ref> N,Z lrp in PTIME undec. undec. [55] R +; fl NC undec. undec. [60, 14, 72] Z +; fl undec. undec. undec. [46] 1 safe queries [100]; the answers have to be finite relations. 2 inflationary semantics. 3 syntactically restricted stratified Datalog : ; cf.
Reference: [12] <author> Baudinet, M., Chomicki, J., Wolper, P. </author> <title> Temporal Deductive Databases. In Temporal Databases: Theory, Design, And Implementation, Tansel, </title> <editor> A. et al. (editors). </editor> <publisher> Benjamin Cummings 1993. </publisher>
Reference-contexts: We prove the correctness of the evaluation over such encoding and show a sufficient condition for termination of query evaluation. We also discuss a general method for combining different classes of constraints in the framework of Datalog. 4.1 Introduction Generalized databases <ref> [12, 55, 60] </ref> are infinite databases that can be represented using finite sets of generalized (or constraint ) tuples. A number of query languages over such databases have been studied. <p> Note also that for periodicity constraints alone negation is not a problem: the constraint of the form x 6 k y + c can be introduced without any problems (cf. Section 5.3). Expressiveness. In <ref> [12] </ref> the expressiveness of a number of deductive and constraint query languages is discussed. However, only monadic programs are considered. It is interesting to see, whether the expressiveness of query languages defined in this section can also be formally characterized. Efficient Implementation. Periodicity constraints define non-convex sets.
Reference: [13] <author> Baudinet, M., Nezette, M., Wolper P. </author> <title> On the Representation of Infinite Temporal Data and Queries. </title> <booktitle> 10th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pp 280-290, </pages> <year> 1991. </year>
Reference-contexts: Also, the unary successor symbol is used in the deductive layer on top of the database. Our approach allows a representation of the infinite relations to be stored directly in the database. Another extension of Datalog was proposed in <ref> [13] </ref>. This extension combines linear repeating points, order constraints, and unlimited use of successor 72 function. The resulting language is very expressive|termination of query evaluation in this language cannot be guaranteed. Summarizing: [73, 75] cannot handle periodicity constraints, [55] cannot handle recursion, [23, 24] cannot handle ordering, and [13] does not <p> proposed in <ref> [13] </ref>. This extension combines linear repeating points, order constraints, and unlimited use of successor 72 function. The resulting language is very expressive|termination of query evaluation in this language cannot be guaranteed. Summarizing: [73, 75] cannot handle periodicity constraints, [55] cannot handle recursion, [23, 24] cannot handle ordering, and [13] does not guarantee termination. Our language is thus another step towards a tractable and expressive query language for temporal databases. Bibliographical Notes The work on the combination of Datalog rules with integer order constraints was pursued in [73]. Integer based constraint queries have also been proposed in [55].
Reference: [14] <author> Ben-Or, M., Kozen, D., Reif, J. </author> <title> The Complexity of elementary Algebra and Geometry. </title> <journal> JCSS , 32 </journal> <pages> 251-264, </pages> <year> 1986. </year>
Reference-contexts: P (Z) [87] [76] N,Z 1S NC PSPACE-comp PSPACE-comp [74] [23] [23] R &lt;; + NC undec. undec. [37] ) undec. undec. [71, 11] N,Z lrp in PTIME undec. undec. [55] R +; fl NC undec. undec. <ref> [60, 14, 72] </ref> Z +; fl undec. undec. undec. [46] 1 safe queries [100]; the answers have to be finite relations. 2 inflationary semantics. 3 syntactically restricted stratified Datalog : ; cf. Section 5.5 4 data complexity. 5 for a fixed set of modulo factors (cf. Chapter 5).
Reference: [15] <author> Bohlen, M. H., Chomicki, J., Snodgrass, R. T., Toman, D. </author> <title> Querying TSQL2 Databases with Temporal Logic. </title> <note> To appear in Proc. EDBT'96. </note>
Reference: [16] <author> Bol, R, Degerstedt, L. </author> <title> The Underlying Search for Magic Templates and Tabulation. </title> <booktitle> Proc. International Conference on Logic Programming, </booktitle> <year> 1993. </year>
Reference: [17] <author> Chandra, A. K., Harel, D. </author> <title> Computable Queries for Relational Data Bases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21 </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: A forthcoming survey of constraint query languages [78] from (which figure 6.1 was borrowed) discusses the individual results in detail. 76 Domain Constraints Relational Calculus Datalog Datalog : D = AC 0 1 [58] PTIME 1;4 <ref> [5, 17] </ref> PTIME 1;4 [6, 19] LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60, 36] [60] [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 <p> A forthcoming survey of constraint query languages [78] from (which figure 6.1 was borrowed) discusses the individual results in detail. 76 Domain Constraints Relational Calculus Datalog Datalog : D = AC 0 1 [58] PTIME 1;4 [5, 17] PTIME 1;4 [6, 19] LOGSPACE 1 <ref> [17] </ref> Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60, 36] [60] [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME DEXPTIME DEXPTIME B m
Reference: [18] <author> Chandra, A. K., Harel, D. </author> <title> Structure and Complexity of Relational Queries. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25 </volume> <pages> 156-178, </pages> <year> 1982. </year>
Reference: [19] <author> Chandra, A. K., Harel, D. </author> <title> Horn Clause Queries and Generalizations. </title> <journal> J. Logic Programming, </journal> <volume> 2(1) </volume> <pages> 1-15, </pages> <year> 1985. </year>
Reference-contexts: A forthcoming survey of constraint query languages [78] from (which figure 6.1 was borrowed) discusses the individual results in detail. 76 Domain Constraints Relational Calculus Datalog Datalog : D = AC 0 1 [58] PTIME 1;4 [5, 17] PTIME 1;4 <ref> [6, 19] </ref> LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60, 36] [60] [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME
Reference: [20] <author> Chomicki J. </author> <title> Temporal Query Languages: a Survey. </title> <booktitle> Proc. International Conference on Temporal Logic, </booktitle> <address> July 1994, Bonn, Germany, </address> <publisher> Springer-Verlag (LNAI 827), </publisher> <pages> pp. 506-534. </pages>
Reference-contexts: Algebras for capturing first-order logic can be found in [49]. A thorough discussion of the application of these methods to temporal databases can be found in a survey of temporal databases and query languages <ref> [20] </ref>. 17 Chapter 3 Expressive Power Queries over temporal databases involve references to time. We study differences between two approaches of including such references into a first-order query language (e.g., relational calculus): explicit (using typed variables and quantifiers) vs. implicit (using a finite set of modal connectives).
Reference: [21] <author> Chomicki J. </author> <title> History-less Checking of Dynamic Integrity Constraints. </title> <booktitle> IEEE International Conference on Data Engineering, </booktitle> <address> Phoenix, AZ, </address> <year> 1992. </year>
Reference-contexts: Despite this drawback, FOTL was used as a basis of temporal query languages [99] or for specification of temporal integrity constraints <ref> [21, 22, 25, 26, 64] </ref>. The main reason for this choice is a simpler and more efficient implementation that does not generalize to full FOTL.
Reference: [22] <author> Chomicki J. </author> <title> Efficient Checking of Temporal Integrity Constraints Using Bounded History Encoding. </title> <journal> In ACM Transactions on Database Systems, </journal> <volume> (20) 2, </volume> <pages> pp. 149-186. </pages> <year> 1995. </year>
Reference-contexts: Despite this drawback, FOTL was used as a basis of temporal query languages [99] or for specification of temporal integrity constraints <ref> [21, 22, 25, 26, 64] </ref>. The main reason for this choice is a simpler and more efficient implementation that does not generalize to full FOTL.
Reference: [23] <author> Chomicki, J., Imielinski, T. </author> <title> Temporal Deductive Databases and Infinite Objects. </title> <booktitle> Proc. 7th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pp 61-73, </pages> <year> 1988. </year>
Reference-contexts: This arrangement provides a potentially more general framework, which could be adapted to combinations of other constraint languages over the integers. Another approach comes from the area of temporal databases. In <ref> [23, 24] </ref> Datalog was extended with a limited use of the successor function symbol (the use is restricted to a single distinguished argument in each literal). This way it is possible to represent infinite periodic sets of integers using Horn rules. <p> Another extension of Datalog was proposed in [13]. This extension combines linear repeating points, order constraints, and unlimited use of successor 72 function. The resulting language is very expressive|termination of query evaluation in this language cannot be guaranteed. Summarizing: [73, 75] cannot handle periodicity constraints, [55] cannot handle recursion, <ref> [23, 24] </ref> cannot handle ordering, and [13] does not guarantee termination. Our language is thus another step towards a tractable and expressive query language for temporal databases. Bibliographical Notes The work on the combination of Datalog rules with integer order constraints was pursued in [73]. <p> The use of the successor symbols is confined to a single distinguished argument in the individual literals of the program. Such arrangement guarantees termination of all queries <ref> [23] </ref>. * Datalog over sequences [66]. This paper introduces an extension of Datalog with interpreted function symbols for manipulating sequences. A syntactic restriction on the class of queries guarantees termination of query evaluation. <p> P (Z) [87] [76] N,Z 1S NC PSPACE-comp PSPACE-comp [74] <ref> [23] </ref> [23] R &lt;; + NC undec. undec. [37] ) undec. undec. [71, 11] N,Z lrp in PTIME undec. undec. [55] R +; fl NC undec. undec. [60, 14, 72] Z +; fl undec. undec. undec. [46] 1 safe queries [100]; the answers have to be finite relations. 2 inflationary semantics. <p> P (Z) [87] [76] N,Z 1S NC PSPACE-comp PSPACE-comp [74] <ref> [23] </ref> [23] R &lt;; + NC undec. undec. [37] ) undec. undec. [71, 11] N,Z lrp in PTIME undec. undec. [55] R +; fl NC undec. undec. [60, 14, 72] Z +; fl undec. undec. undec. [46] 1 safe queries [100]; the answers have to be finite relations. 2 inflationary semantics. 3
Reference: [24] <author> Chomicki, J., Imielinski, T. </author> <title> Finite Representation of Infinite Query Answers, </title> <journal> In ACM Transactions on Database Systems, </journal> <pages> pp. 181-223, (18) 2, </pages> <year> 1993. </year>
Reference-contexts: This arrangement provides a potentially more general framework, which could be adapted to combinations of other constraint languages over the integers. Another approach comes from the area of temporal databases. In <ref> [23, 24] </ref> Datalog was extended with a limited use of the successor function symbol (the use is restricted to a single distinguished argument in each literal). This way it is possible to represent infinite periodic sets of integers using Horn rules. <p> Another extension of Datalog was proposed in [13]. This extension combines linear repeating points, order constraints, and unlimited use of successor 72 function. The resulting language is very expressive|termination of query evaluation in this language cannot be guaranteed. Summarizing: [73, 75] cannot handle periodicity constraints, [55] cannot handle recursion, <ref> [23, 24] </ref> cannot handle ordering, and [13] does not guarantee termination. Our language is thus another step towards a tractable and expressive query language for temporal databases. Bibliographical Notes The work on the combination of Datalog rules with integer order constraints was pursued in [73].
Reference: [25] <author> Chomicki, J.,N iwinski, D. </author> <title> On the Feasibility of Checking Temporal Integrity Constraints. </title> <booktitle> Proc. 12th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pp 202-213, </pages> <year> 1993. </year> <note> (full version to appear in JCSS). </note>
Reference-contexts: Despite this drawback, FOTL was used as a basis of temporal query languages [99] or for specification of temporal integrity constraints <ref> [21, 22, 25, 26, 64] </ref>. The main reason for this choice is a simpler and more efficient implementation that does not generalize to full FOTL.
Reference: [26] <author> Chomicki, J., Toman, D. </author> <title> Implementing Temporal Integrity Constraints Using an Active DBMS. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, Special section on Temporal and Real-time Databases, </journal> <volume> Vol. 7, No. 4, </volume> <year> 1995. </year>
Reference-contexts: Despite this drawback, FOTL was used as a basis of temporal query languages [99] or for specification of temporal integrity constraints <ref> [21, 22, 25, 26, 64] </ref>. The main reason for this choice is a simpler and more efficient implementation that does not generalize to full FOTL.
Reference: [27] <author> Clifford J., Croker A. </author> <title> The Historical Relational Data Model (HRDM) and Algebra based on Lifespans. </title> <booktitle> In Proceedings of the International Conference on Data Engineering, </booktitle> <pages> pages 528-537, </pages> <address> Los Angeles, CA, </address> <month> February </month> <year> 1987. </year>
Reference-contexts: The first-order query languages can be divided into two main categories: 1. query languages based on a two-sorted version of relational calculus, e.g., TSQL2 [84] or TQUEL [83], and 2. query languages based on an extension of the relational calculus or algebra by temporal operators, e.g, HRDM's historical relational algebra <ref> [27] </ref>, temporal relational algebra [99], etc. These two approaches have been often considered equivalent in expressive power, e.g., in [99], where the temporal relational algebra based on an extension of the relational calculus by temporal operators has been proposed as a basis for first-order completeness of temporal query languages.
Reference: [28] <author> Clifford J., Croker A., Tuzhilin A. </author> <title> On Completeness of Historical Relational Query Languages. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 19, No. 1, </volume> <pages> pp. 64-116, </pages> <year> 1994. </year>
Reference: [29] <author> Clocksin, W. F., Mellish, C.S. </author> <title> Programming in Prolog. </title> <publisher> Springer Verlag 1987. </publisher> <pages> 103 </pages>
Reference-contexts: There are two major approaches to solving this problem in the framework of standard Datalog: 1. Rewrite the program using the Magic Set Transformation (MST) [8, 68] and subse quently evaluate the transformed program bottom-up, and 2. Adopt a top-down evaluation strategy <ref> [29, 92] </ref> based on the resolution principle [65]. In this section we consider mainly the top-down resolution-based method. However, the MST transformation for the constraint deductive query languages is also introduced for comparison purposes. <p> Adopt a top-down evaluation strategy [29, 92] based on the resolution principle [65]. In this section we consider mainly the top-down resolution-based method. However, the MST transformation for the constraint deductive query languages is also introduced for comparison purposes. It is well-known that the standard top-down strategies, e.g., SLD-resolution <ref> [29] </ref>, despite their efficiency, have a major drawback as query evaluation procedures: they lead to nonterminating computations even in the situations, where the bottom-up algorithms are guaranteed to terminate. Note also that breadth-first traversal of a SLD-tree does not guarantee termination in general.
Reference: [30] <author> Codd, E. F. </author> <title> A relational model of data for large shared data banks. </title> <journal> Comm. of the ACM , 13(6) </journal> <pages> 377-387, </pages> <year> 1970. </year>
Reference: [31] <author> Codd, E. F. </author> <title> Relational completeness of database sublanguages. In Rustin, R.(ed.) </title> <booktitle> Courant Computer Science Symposium 6: Data Base Systems, </booktitle> <pages> pp. 65-98, </pages> <publisher> Prentice-Hall, </publisher> <year> 1972. </year>
Reference: [32] <author> Cousot P., Cousot R. </author> <title> Abstract Interpretation Frameworks. </title> <journal> J. of Logic and Computation, </journal> <pages> 2-4, </pages> <year> 1992. </year>
Reference-contexts: c &lt; y : c 2 Zg|gap-order constraints with possibly negative size of the gap [73] or the linear arithmetic constraints [60]. 6.2 Abstract Interpretation Another interesting application of constraints can be found in the area of programming languages analysis, especially those analysis that are based on the Abstract Interpretation <ref> [3, 32] </ref>. The main idea behind this technique is to execute a given program with respect to its formal semantics and a set of abstract values, rather than with respect to the concrete values the program is designed to work on.
Reference: [33] <author> Enderton, H. B. </author> <title> A Mathematical Introduction to Logic. </title> <publisher> Academic Press, </publisher> <year> 1972. </year>
Reference: [34] <author> Ehrenfeucht, A. </author> <title> An application of games to the completeness problem for formalized theories. </title> <journal> Fund. Math., </journal> <volume> 49 </volume> <pages> 129-141, </pages> <year> 1961. </year>
Reference-contexts: In Section 3.5 we find concrete examples of structures that are distinguishable by a M-formula but not distinguishable by any T -formula. 3.3 Ehrenfeucht-Frasse Games To show the separation of L from M we use a technique originally developed to capture the expressive power of the first-order logic|the Ehrenfeucht-Frasse Games <ref> [34, 38] </ref>. <p> Notation 3.14 The winning strategy for Player II defines an equivalence relation on the first-order structures for every n 0. We write A ~ n B if Player II has a winning strategy for all rounds of the Ehrenfeucht-Frasse game of length n. Proposition 3.15 (Ehrenfeucht <ref> [34] </ref>) Let A and B be first-order structures of the same signature. Then A ~ n B iff 8' 2 L n (A j= ' () B j= ') where L n is the set of all first order sentences with at most n nested quantifiers (cf. Definition 3.25).
Reference: [35] <author> Ershov, I. ,L. </author> <title> Mathematical logic. </title> <address> Moscow, Mir, </address> <year> 1984. </year>
Reference-contexts: introduction to these concepts can be found in virtually any book on mathematical logic, e.g., [67] or <ref> [35] </ref>. Algebras for capturing first-order logic can be found in [49]. A thorough discussion of the application of these methods to temporal databases can be found in a survey of temporal databases and query languages [20]. 17 Chapter 3 Expressive Power Queries over temporal databases involve references to time. <p> Then : C R := C2R defines the constraint complement of R and D n kRk = k: C Rk P r o o f: Immediate from Definition 4.23, Definition 4.23, and DeMorgan laws <ref> [35, 67] </ref>. 6 I.e., queries, specified by formulas, containing only ^; _; 9. 54 Note that for every generalized relation the previous lemma gives an algorithm for comput-ing the complement, as R contains only finitely many constraints C and thus we can iterate the constraint conjunction over them.
Reference: [36] <author> Ferrante, J., Geiser, J. R. </author> <title> An Efficient Decision Procedure for the Theory of Rational Order. </title> <journal> Theoretical Computer Science, </journal> <volume> 4 </volume> <pages> 227-233, </pages> <year> 1977. </year>
Reference-contexts: [78] from (which figure 6.1 was borrowed) discusses the individual results in detail. 76 Domain Constraints Relational Calculus Datalog Datalog : D = AC 0 1 [58] PTIME 1;4 [5, 17] PTIME 1;4 [6, 19] LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE <ref> [60, 36] </ref> [60] [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME DEXPTIME DEXPTIME B m = B m PTIME (9 only) p 2 -hard undec. [60] [60] P
Reference: [37] <author> J. Ferrante, C. Rackoff. </author> <title> A Decision Procedure for the First Order Theory of Real Addition with Order. </title> <journal> SIAM J. Comp, </journal> <volume> 4:1:69-76, </volume> <year> 1975. </year>
Reference-contexts: P (Z) [87] [76] N,Z 1S NC PSPACE-comp PSPACE-comp [74] [23] [23] R &lt;; + NC undec. undec. <ref> [37] </ref> ) undec. undec. [71, 11] N,Z lrp in PTIME undec. undec. [55] R +; fl NC undec. undec. [60, 14, 72] Z +; fl undec. undec. undec. [46] 1 safe queries [100]; the answers have to be finite relations. 2 inflationary semantics. 3 syntactically restricted stratified Datalog : ; cf.
Reference: [38] <author> Fraisse, R. </author> <title> Sur les classifications des systemes de relations. </title> <type> Publ. </type> <institution> Sci. Univ. Alger , 1:1, </institution> <year> 1954. </year>
Reference-contexts: In Section 3.5 we find concrete examples of structures that are distinguishable by a M-formula but not distinguishable by any T -formula. 3.3 Ehrenfeucht-Frasse Games To show the separation of L from M we use a technique originally developed to capture the expressive power of the first-order logic|the Ehrenfeucht-Frasse Games <ref> [34, 38] </ref>.
Reference: [39] <author> Gabbay D. </author> <title> Expressive Functional Completeness in Tense Logic. </title> <editor> In Monnich U. </editor> <booktitle> Aspects of Philosophical Logic, </booktitle> <pages> 91-117, </pages> <year> 1981. </year>
Reference-contexts: This result has been established by Kamp [56] for complete linear orders, later extended by Stavi [88] for all linear orders, and reproven several times using various proof techniques, e.g, <ref> [39, 50] </ref>. In this section we show that this correspondence does not generalize to the relationship between the First-order Temporal Logic (FOTL) and the Two-sorted First-order Logic (2-FOL). <p> The definition of the temporal connectives is purely syntactical and depends only on the chosen temporal domain. The semantics of the connectives is defined by a translation to 2-FOL (cf. Definition 3.11). This approach differs from the usual definition of such connectives given in <ref> [39] </ref> or [40], that is based on the intended semantics and uses truth tables. Definition 3.6 (Temporal Connective) Let fl be the signature of the temporal domain and where X i are predicate variables and 2 fl. <p> We show that for a standard choice of the data domain being the set of uninterpreted constants with equality and a standard choice of a linearly ordered temporal domain: * the propositional temporal logic has an expressively complete set of temporal connec tives <ref> [39, 50, 56, 88] </ref>, but * there is no finite set of temporal connectives expressively complete in the first-order case.
Reference: [40] <author> Gabbay D. </author> <title> The Declarative Past and Imperative Future: Executable Temporal Logic for Interactive Systems. </title> <editor> In Banieqbal B., Barringer B., and Pnuelli A. (ed.) </editor> <booktitle> Temporal Logic in Specification, </booktitle> <volume> vol. 398, </volume> <publisher> pp.409-448, Springer Verlag, LNCS 398, </publisher> <year> 1989. </year>
Reference-contexts: The definition of the temporal connectives is purely syntactical and depends only on the chosen temporal domain. The semantics of the connectives is defined by a translation to 2-FOL (cf. Definition 3.11). This approach differs from the usual definition of such connectives given in [39] or <ref> [40] </ref>, that is based on the intended semantics and uses truth tables. Definition 3.6 (Temporal Connective) Let fl be the signature of the temporal domain and where X i are predicate variables and 2 fl.
Reference: [41] <author> Gabbay D., Pnueli A., Shelah S., Stavi J. </author> <title> On the Temporal Analysis of Fairness. </title> <booktitle> Proc. ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1980. </year>
Reference-contexts: In addition to the separation of FOTL from 2-FOL we show several other results, especially: 1. Expressive equivalence of the future temporal logic and the full temporal logic, i.e., with both future and past temporal connectives <ref> [41] </ref> does not generalize to the first order case. 2. Expressive completeness cannot be achieved using more general temporal logic, e.g., the many-dimensional first-order temporal logic [42]. Note also that we restrict our attention solely to the first-order languages. <p> Note that these two logics are expressively equivalent in the propositional case <ref> [41] </ref>. Lemma 3.39 Let (Q + ; &lt;; 0) be a dense linear order with a left endpoint (0). Let J Q + be a non-trivial open interval and f I m;n : I ! S m n [ f;g be dense over S m n .
Reference: [42] <author> Gabbay D., Hodkinson I., Reynolds M. </author> <title> Temporal Logic. </title> <journal> Mathematical Foundations and Computational Aspects. </journal> <volume> Vol. 1. </volume> <booktitle> Oxford Logic Guides 28, </booktitle> <publisher> Oxford Science Publications, </publisher> <year> 1994. </year>
Reference-contexts: Expressive equivalence of the future temporal logic and the full temporal logic, i.e., with both future and past temporal connectives [41] does not generalize to the first order case. 2. Expressive completeness cannot be achieved using more general temporal logic, e.g., the many-dimensional first-order temporal logic <ref> [42] </ref>. Note also that we restrict our attention solely to the first-order languages. <p> Definition 3.7 If every quantification in a temporal connective ! 2 (fl) is of the form 9t i :((t 0 ; t i ) ^ O) then ! is a -restricted temporal connective. 22 Example 3.8 We can express the usual temporal connectives given in <ref> [42] </ref> in the temporal signature h&lt;i of linear orders as follows: X 1 until X 2 4 2X 1 = 9t 1 :t 0 &lt; t 1 ^ X 1 4 Similarly we can express the past temporal connectives since, 3, and 1: X 1 since X 2 4 3X 1 <p> Note that a closed temporal logic formula still has one free variable of sort T that represents the initial temporal context (cf. the semantic definition of the temporal logic in section 3.2 or <ref> [42] </ref>). Besides the rules of the game itself we need to define the winning condition for the game for temporal logic. <p> Section 3.5). This is due to the limitation on the number of temporal contexts passed to the individual subformulas of a FOTL formula. In <ref> [42] </ref> many-dimensional propositional temporal logics are studied. These logics can be easily modified to many-dimensional first-order temporal logics (k-FOTL, where k is the dimension of the logic). The main idea behind this approach is to allow k temporal contexts in all the temporal (sub-)formulas. <p> This result follows immediately from Proposition 3.1 and the observation that every temporal connective can be decomposed into embedded applications of the since and until connectives (as the temporal connectives can be thought of as formulas in propositional temporal logic). <ref> [42] </ref> introduces several propositional logics complete for the particular choice of k &gt; 1. 3.7 Conclusion In this chapter we have defined a model-theoretical game that captures the expressive power of k-FOTL in a very general setting|the definition is independent of the underlying signatures and theories. <p> However [1] uses a counting argument in the proof and thus it does not generalize to arbitrary linear orders. Also, the relationship between this work and various sets of temporal connectives defined in <ref> [42] </ref> is not clear. Bibliographical Notes Temporal logic with the connectives since and until was introduced in [56]. <p> There has been a substantial interest in temporal and modal logics in the specification/verification community. A whole volume of the Oxford Logic Guides <ref> [42] </ref> is dedicated to the study of various aspects of temporal logic.
Reference: [43] <author> Gabbay D., McBrien P. </author> <title> Temporal Logic & Historical Databases. </title> <booktitle> Proc. International Conference on VLDB, </booktitle> <year> 1991. </year>
Reference: [44] <author> Gantmakher, F. R. </author> <title> The theory of matrices. </title> <address> New York, </address> <publisher> Chelsea Pub. Co. </publisher> <year> 1959. </year>
Reference: [45] <author> Gao, H., Warren, D. S. </author> <title> A Powerful Evaluation Strategy For CLP Programs. </title> <booktitle> Proc. Intl. Workshop on Principles and Practice of Constraint Programming, </booktitle> <year> 1993. </year>
Reference-contexts: However, the propagation of constraints at the time of goal resolution is reduced. The soundness and completeness properties are preserved by Lemma 7.8. The termination is guaranteed similarly to Theorem 7.11. In <ref> [45] </ref> the following version of this modification was presented: Action/Node Children Conditions Query projection body (G; B 1 ; : : : ; B k ; C) ! goal (G; B 1 ; true; B 2 ; : : : ; B k ; C) none 87 In this case, there <p> This dramatically increases the expressive power of the query language while preserving the termination and efficiency. 2. The other direction is pursued in the area of Logic Programming: In <ref> [45, 54, 63] </ref> top-down evaluation for constraint logic programs is proposed. However, in all cases, general constraint-solving procedures are used. Thus these methods are not directly useful for query evaluation in constraint databases as the termination cannot be guaranteed. The closest to our work is [45]. <p> However, in all cases, general constraint-solving procedures are used. Thus these methods are not directly useful for query evaluation in constraint databases as the termination cannot be guaranteed. The closest to our work is <ref> [45] </ref>. However, the method proposed there allows only propagation of constants (i.e., constraints of the form x = a); the constraint part of the query is essentially computed bottom-up. Our approach allows full propagation of all possible constraints during the whole evaluation process.
Reference: [46] <author> K. </author> <title> Godel. Uber formal unentscheidbare Satze der Principia Mathematica und ver-wandter Systeme I. </title> <journal> Monatshefte fur Mathematic und Physik. </journal> <volume> vol. 38, </volume> <pages> 173-198, </pages> <year> 1931. </year> <month> 104 </month>
Reference-contexts: P (Z) [87] [76] N,Z 1S NC PSPACE-comp PSPACE-comp [74] [23] [23] R &lt;; + NC undec. undec. [37] ) undec. undec. [71, 11] N,Z lrp in PTIME undec. undec. [55] R +; fl NC undec. undec. [60, 14, 72] Z +; fl undec. undec. undec. <ref> [46] </ref> 1 safe queries [100]; the answers have to be finite relations. 2 inflationary semantics. 3 syntactically restricted stratified Datalog : ; cf. Section 5.5 4 data complexity. 5 for a fixed set of modulo factors (cf. Chapter 5).
Reference: [47] <editor> Gunter, C. </editor> <booktitle> Foundations of Programming Languages, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: The domains of the abstract values are much simpler and often finite. Moreover, all the domains of the abstract values are designed in a way that the analysis always terminates. The semantics of programming languages can be given in the natural form given in, e.g., <ref> [47, 80] </ref>, using a set of inference rules.
Reference: [48] <author> Hardy, G. H. </author> <title> An Introduction to the Theory of Numbers. </title> <publisher> Oxford University Press, </publisher> <year> 1979. </year>
Reference-contexts: We say that # satisfies G (# j= G) if We call G a satisfiable periodicity graph if there exists an assignment # such that # j= G. To combine constraints over the same variables we use the following Proposition <ref> [48] </ref>: Proposition 5.5 (Chinese Remainder Theorem) If gcd (k 1 ; k 2 ) divides jc 1 c 2 j then there exists a unique c such that x k 1 (y + c 1 ) ^ x k 2 (y + c 2 ) () x lcm (k 1 ;k <p> Bibliographical Notes The work on the combination of Datalog rules with integer order constraints was pursued in [73]. Integer based constraint queries have also been proposed in [55]. Most of the results about integers can be easily found in books on number theory, e.g., <ref> [48, 104] </ref> or [82] (if you read Polish). Other useful results about cyclic groups Z n can be found in books on group theory and modern algebra in general, e.g., [10]. 73 Chapter 6 Other Constraint Classes This section surveys several other known constraint classes, and summarizes their properties.
Reference: [49] <editor> Henkin, L., Monk, J. D., Tarski, A. Cylindric Algebras. </editor> <publisher> North Holland, </publisher> <year> 1971. </year>
Reference-contexts: introduction to these concepts can be found in virtually any book on mathematical logic, e.g., [67] or [35]. Algebras for capturing first-order logic can be found in <ref> [49] </ref>. A thorough discussion of the application of these methods to temporal databases can be found in a survey of temporal databases and query languages [20]. 17 Chapter 3 Expressive Power Queries over temporal databases involve references to time.
Reference: [50] <author> Immerman N., Kozen D. </author> <title> Definability with Bounded Number of Variables. </title> <booktitle> Information and Computation 83, </booktitle> <address> pp.121-139, </address> <year> 1989. </year>
Reference-contexts: This result has been established by Kamp [56] for complete linear orders, later extended by Stavi [88] for all linear orders, and reproven several times using various proof techniques, e.g, <ref> [39, 50] </ref>. In this section we show that this correspondence does not generalize to the relationship between the First-order Temporal Logic (FOTL) and the Two-sorted First-order Logic (2-FOL). <p> We show that for a standard choice of the data domain being the set of uninterpreted constants with equality and a standard choice of a linearly ordered temporal domain: * the propositional temporal logic has an expressively complete set of temporal connec tives <ref> [39, 50, 56, 88] </ref>, but * there is no finite set of temporal connectives expressively complete in the first-order case. <p> Are there other (nontrivial) restrictions (especially on the temporal domain) that also guarantee both the closure and completeness? 3.8 Related Work The separation is proven using a modification of the Ehrenfeucht-Frasse Games to capture the properties of Temporal Logic. In <ref> [50] </ref> pebble games have been used to show expressivity results for the monadic logic over linear orders. However, our results and techniques are different, as we are interested in the first-order temporal logics (and the corresponding 2-FOL). The method introduced in [50] is no longer sufficient as it cannot handle unrestricted <p> In <ref> [50] </ref> pebble games have been used to show expressivity results for the monadic logic over linear orders. However, our results and techniques are different, as we are interested in the first-order temporal logics (and the corresponding 2-FOL). The method introduced in [50] is no longer sufficient as it cannot handle unrestricted quantification over the data sort. In [57] a restricted version of 2-FOTL was presented introducing the now connective that allows one to reset the temporal context of a subformula to the original evaluation point.
Reference: [51] <author> Jaffar J., Maher, M. J. </author> <title> Constraint Logic Programming: A Survey. </title> <journal> J. Logic Programming 1994, </journal> <volume> 19. 20 </volume> <pages> 503-581. </pages>
Reference-contexts: This definition is similar to the definition of Constraint Domain <ref> [51] </ref>. However, C contains only satisfiable constraints. The elements of C are used as a finite representation of (possibly infinite) relations in a constraint database: Similarly to Definition 2.13 we have Notation 4.2 Let C 2 C. Let kCk denote the set of valuations 2 such that j= C. <p> We have extracted the common underlying ideas and shown general properties of the abstracted model. A similar approach can be found in <ref> [51] </ref> for the general constraint logic programming languages. Besides few technical differences (our constraint class is defined semantically, while in [51] the constraint domain is generated by a syntactic closure), our main aim is to show termination of deductive queries, which is not an issue for general constraint programming languages: they <p> We have extracted the common underlying ideas and shown general properties of the abstracted model. A similar approach can be found in <ref> [51] </ref> for the general constraint logic programming languages. Besides few technical differences (our constraint class is defined semantically, while in [51] the constraint domain is generated by a syntactic closure), our main aim is to show termination of deductive queries, which is not an issue for general constraint programming languages: they are extensions of the general-purpose logic programming languages that can be easily shown to be Turing-complete. <p> However, in the Logic Programming community, the area of Constraint Logic Programming has been an active area of research for many years. A survey of the results, implementation techniques, and applications can be found in <ref> [51] </ref>. The main difference between the database approach and the Logic Programming approach is that the former uses quantifier elimination while the later uses resolution as the basis for query evaluation/computation. A comprehensive reference for quantifier elimination in various theories is [62].
Reference: [52] <author> Jensen, C. S., Snodgrass, R. </author> <title> Temporal Specialization and Generalization. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <year> 1993. </year>
Reference: [53] <author> Jaffar, J., Lassez, J. L. </author> <title> Constraint Logic Programming. </title> <booktitle> Proc. 14th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp 111-119, </pages> <year> 1987. </year>
Reference-contexts: In this section we study generalized Datalog programs (function-free logic programs) that operate on constraint tuples instead of ground atoms. This idea comes from the area of constraint logic programming <ref> [53] </ref> and allows declarative specification of problems that are not solvable using the standard Datalog framework (e.g., reasoning about infinite periodic sets of integers).
Reference: [54] <author> Johnson, M. </author> <title> Memoization in Constraint Logic Programming. </title> <booktitle> Proc. Intl. Workshop on Principles and Practice of Constraint Programming, </booktitle> <year> 1993. </year>
Reference-contexts: This dramatically increases the expressive power of the query language while preserving the termination and efficiency. 2. The other direction is pursued in the area of Logic Programming: In <ref> [45, 54, 63] </ref> top-down evaluation for constraint logic programs is proposed. However, in all cases, general constraint-solving procedures are used. Thus these methods are not directly useful for query evaluation in constraint databases as the termination cannot be guaranteed. The closest to our work is [45].
Reference: [55] <author> Kabanza, F., Stevenne, J-M., Wolper, P. </author> <title> Handling Infinite Temporal Data. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> (51) 1, </volume> <pages> 149-186, </pages> <year> 1995. </year>
Reference-contexts: We prove the correctness of the evaluation over such encoding and show a sufficient condition for termination of query evaluation. We also discuss a general method for combining different classes of constraints in the framework of Datalog. 4.1 Introduction Generalized databases <ref> [12, 55, 60] </ref> are infinite databases that can be represented using finite sets of generalized (or constraint ) tuples. A number of query languages over such databases have been studied. <p> The correctness of the evaluation and the termination of it is guaranteed for all classes of constraints that are constraint-compact. 4.7 Related Work This chapter is based on a generalization of the concepts present in the specific results on various concrete constraint query languages, e.g., <ref> [55, 60, 96, 100] </ref>. We have extracted the common underlying ideas and shown general properties of the abstracted model. A similar approach can be found in [51] for the general constraint logic programming languages. <p> It is easy to see that the variable y was successfully eliminated and the resulting constraint is a disjunction of conjunctions of periodicity and gap-order constraints. This idea is used for the projection operation needed in the TP ;&lt; operator; a similar idea was used in <ref> [55] </ref>; our procedure is simpler due to a different representation of constraints, especially we can omit the normalization (in the sense of [55]) of constraint tuples 3 . 3 The normalization in [55] is different from Definition 5.12 and requires whole relations to be normalized 68 qe (y,(G; H)) = if <p> This idea is used for the projection operation needed in the TP ;&lt; operator; a similar idea was used in <ref> [55] </ref>; our procedure is simpler due to a different representation of constraints, especially we can omit the normalization (in the sense of [55]) of constraint tuples 3 . 3 The normalization in [55] is different from Definition 5.12 and requires whole relations to be normalized 68 qe (y,(G; H)) = if indegree (y) = 0 then return f (G fyg; H fyg)g else let x be a node such that (x; y) 2 <p> is used for the projection operation needed in the TP ;&lt; operator; a similar idea was used in <ref> [55] </ref>; our procedure is simpler due to a different representation of constraints, especially we can omit the normalization (in the sense of [55]) of constraint tuples 3 . 3 The normalization in [55] is different from Definition 5.12 and requires whole relations to be normalized 68 qe (y,(G; H)) = if indegree (y) = 0 then return f (G fyg; H fyg)g else let x be a node such that (x; y) 2 E H and n be the number of nodes, such <p> However, this approach works only for convex sets. Thus, the periodicity constraints call for new storage management techniques. 5.6 Related Work There are other proposals that introduce classes of infinite integer relations into query languages. Datalog with (gap-)order constraints was introduced in [73]. In <ref> [55] </ref> the relational calculus over generalized relational databases with order constraints and linear repeating points was studied (a linear repeating point has the form fc + knjn 2 Zg for some fixed integers c and k and is just a different notation for a periodicity constraint). <p> Another extension of Datalog was proposed in [13]. This extension combines linear repeating points, order constraints, and unlimited use of successor 72 function. The resulting language is very expressive|termination of query evaluation in this language cannot be guaranteed. Summarizing: [73, 75] cannot handle periodicity constraints, <ref> [55] </ref> cannot handle recursion, [23, 24] cannot handle ordering, and [13] does not guarantee termination. Our language is thus another step towards a tractable and expressive query language for temporal databases. Bibliographical Notes The work on the combination of Datalog rules with integer order constraints was pursued in [73]. <p> Our language is thus another step towards a tractable and expressive query language for temporal databases. Bibliographical Notes The work on the combination of Datalog rules with integer order constraints was pursued in [73]. Integer based constraint queries have also been proposed in <ref> [55] </ref>. Most of the results about integers can be easily found in books on number theory, e.g., [48, 104] or [82] (if you read Polish). <p> P (Z) [87] [76] N,Z 1S NC PSPACE-comp PSPACE-comp [74] [23] [23] R &lt;; + NC undec. undec. [37] ) undec. undec. [71, 11] N,Z lrp in PTIME undec. undec. <ref> [55] </ref> R +; fl NC undec. undec. [60, 14, 72] Z +; fl undec. undec. undec. [46] 1 safe queries [100]; the answers have to be finite relations. 2 inflationary semantics. 3 syntactically restricted stratified Datalog : ; cf.
Reference: [56] <author> Kamp J.A.W. </author> <title> Tense Logic and the Theory of Linear Order. </title> <type> PhD thesis, </type> <institution> University of California, </institution> <address> Los Angeles, </address> <year> 1968. </year>
Reference-contexts: This result has been established by Kamp <ref> [56] </ref> for complete linear orders, later extended by Stavi [88] for all linear orders, and reproven several times using various proof techniques, e.g, [39, 50]. <p> We show that for a standard choice of the data domain being the set of uninterpreted constants with equality and a standard choice of a linearly ordered temporal domain: * the propositional temporal logic has an expressively complete set of temporal connec tives <ref> [39, 50, 56, 88] </ref>, but * there is no finite set of temporal connectives expressively complete in the first-order case. <p> Also, the relationship between this work and various sets of temporal connectives defined in [42] is not clear. Bibliographical Notes Temporal logic with the connectives since and until was introduced in <ref> [56] </ref>. Prior to that, 4 Note that all the databases used in our proofs are finitely representable. 5 I.e., its complement is infinite. 44 temporal logic was studied as a form of modal logics on unlabeled transition systems, whose transition relation is an order [69].
Reference: [57] <author> Kamp J.A.W. </author> <title> On the Formal Properties of `now'. </title> <type> Theoria 37 </type> <pages> 227-273, </pages> <year> 1971. </year>
Reference-contexts: Also, from the previous results and <ref> [57] </ref>, we know that Future-FOTL FOTL FOTL (now) 2-FOTL On the other hand, the hierarchy of k-FOTL approximates 2-FOL: Theorem 3.46 Let be a 2-FOL formula. Then there is a natural number k and a k-FOTL formula ' such that '. <p> However, our results and techniques are different, as we are interested in the first-order temporal logics (and the corresponding 2-FOL). The method introduced in [50] is no longer sufficient as it cannot handle unrestricted quantification over the data sort. In <ref> [57] </ref> a restricted version of 2-FOTL was presented introducing the now connective that allows one to reset the temporal context of a subformula to the original evaluation point. This logic was also shown to be strictly stronger than FOTL. However, the technique used in [57] does not apply to temporal databases|the <p> In <ref> [57] </ref> a restricted version of 2-FOTL was presented introducing the now connective that allows one to reset the temporal context of a subformula to the original evaluation point. This logic was also shown to be strictly stronger than FOTL. However, the technique used in [57] does not apply to temporal databases|the proof of the fact is carried out over first-order structures that cannot be finitely encoded as the contents of the database relation (s) is an infinite and coinfinite 5 at every time instant. <p> There has been a substantial interest in temporal and modal logics in the specification/verification community. A whole volume of the Oxford Logic Guides [42] is dedicated to the study of various aspects of temporal logic. However, with the exception of <ref> [57] </ref>, almost all the effort is spent on propositional logics and the corresponding monadic first-order counterparts, which are not very useful in the area of temporal databases. 45 Chapter 4 Constraint Databases One of the leading approaches to finite encodings of classes of infinite databases is the use of constraints|quantifier-free characteristic
Reference: [58] <author> Kanellakis, P. C., Goldin, D. Q. </author> <title> Constraint Programming and Database Query Languages. </title> <booktitle> In Proc. 2nd TACS , 1994. </booktitle>
Reference-contexts: form bottom-up evaluation procedure for C ;&lt;Z = C &lt;Z [ C Z was developed including all the necessary operations on the constraint class as required by Definition 4.3. * We can also incorporate the dense order constraints over Q by a slight modification of constraint operations well defined in <ref> [60, 58] </ref>. * The set-order constraints were introduced in [76], and * The boolean algebra constraints in [60], All the above constraint classes are constraint-compact. Other constraint classes. <p> A forthcoming survey of constraint query languages [78] from (which figure 6.1 was borrowed) discusses the individual results in detail. 76 Domain Constraints Relational Calculus Datalog Datalog : D = AC 0 1 <ref> [58] </ref> PTIME 1;4 [5, 17] PTIME 1;4 [6, 19] LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60, 36] [60] [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 <p> forthcoming survey of constraint query languages [78] from (which figure 6.1 was borrowed) discusses the individual results in detail. 76 Domain Constraints Relational Calculus Datalog Datalog : D = AC 0 1 <ref> [58] </ref> PTIME 1;4 [5, 17] PTIME 1;4 [6, 19] LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60, 36] [60] [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME DEXPTIME DEXPTIME B m = B m PTIME (9 only) p
Reference: [59] <author> Kanellakis, P. C., Ramaswamy, S., Vengroff, D. E., Vitter, J. S. </author> <title> Indexing for Data Models with Constraints and Classes. </title> <booktitle> Proc. ACM Symposium on Principles of Database Systems, </booktitle> <pages> pp 233-243, </pages> <year> 1993. </year>
Reference-contexts: Storage and access methods. To achieve an efficient implementation of constraint databases, new storage management techniques have to be developed: Access methods suitable 97 for fast retrieval of the stored information, efficient updates of generalized relations, indexing techniques <ref> [59] </ref>, etc. Benchmarks. The performance of various implementations of Logic Programming languages (e.g., Prolog) is often judged by the performance on a standard benchmarks (e.g., nrev). We propose to develop similar suite of benchmarks for measuring the performance of query evaluation methods for constraint databases.
Reference: [60] <author> Kanellakis, P. C., Kuper, G. M., Revesz, P.Z. </author> <title> Constraint Query Languages, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> (51) 1, </volume> <pages> 26-52, </pages> <year> 1995. </year>
Reference-contexts: We prove the correctness of the evaluation over such encoding and show a sufficient condition for termination of query evaluation. We also discuss a general method for combining different classes of constraints in the framework of Datalog. 4.1 Introduction Generalized databases <ref> [12, 55, 60] </ref> are infinite databases that can be represented using finite sets of generalized (or constraint ) tuples. A number of query languages over such databases have been studied. <p> The correctness of the evaluation and the termination of it is guaranteed for all classes of constraints that are constraint-compact. 4.7 Related Work This chapter is based on a generalization of the concepts present in the specific results on various concrete constraint query languages, e.g., <ref> [55, 60, 96, 100] </ref>. We have extracted the common underlying ideas and shown general properties of the abstracted model. A similar approach can be found in [51] for the general constraint logic programming languages. <p> Bibliographical Notes The work on constraint representation of infinite sets of elements was originated in the area of databases in <ref> [60] </ref>. However, in the Logic Programming community, the area of Constraint Logic Programming has been an active area of research for many years. A survey of the results, implementation techniques, and applications can be found in [51]. <p> However, only monadic programs are considered. It is interesting to see, whether the expressiveness of query languages defined in this section can also be formally characterized. Efficient Implementation. Periodicity constraints define non-convex sets. In this respect they differ from most common constraint languages. <ref> [60] </ref> describes how to adapt interval management techniques for the use with constraint databases. However, this approach works only for convex sets. Thus, the periodicity constraints call for new storage management techniques. 5.6 Related Work There are other proposals that introduce classes of infinite integer relations into query languages. <p> form bottom-up evaluation procedure for C ;&lt;Z = C &lt;Z [ C Z was developed including all the necessary operations on the constraint class as required by Definition 4.3. * We can also incorporate the dense order constraints over Q by a slight modification of constraint operations well defined in <ref> [60, 58] </ref>. * The set-order constraints were introduced in [76], and * The boolean algebra constraints in [60], All the above constraint classes are constraint-compact. Other constraint classes. <p> the necessary operations on the constraint class as required by Definition 4.3. * We can also incorporate the dense order constraints over Q by a slight modification of constraint operations well defined in [60, 58]. * The set-order constraints were introduced in [76], and * The boolean algebra constraints in <ref> [60] </ref>, All the above constraint classes are constraint-compact. Other constraint classes. <p> There are also constraint classes, where all the constraint operations are defined, but which are not constraint-compact, e.g., the class generated from the set fx + c &lt; y : c 2 Zg|gap-order constraints with possibly negative size of the gap [73] or the linear arithmetic constraints <ref> [60] </ref>. 6.2 Abstract Interpretation Another interesting application of constraints can be found in the area of programming languages analysis, especially those analysis that are based on the Abstract Interpretation [3, 32]. <p> [78] from (which figure 6.1 was borrowed) discusses the individual results in detail. 76 Domain Constraints Relational Calculus Datalog Datalog : D = AC 0 1 [58] PTIME 1;4 [5, 17] PTIME 1;4 [6, 19] LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE <ref> [60, 36] </ref> [60] [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME DEXPTIME DEXPTIME B m = B m PTIME (9 only) p 2 -hard undec. [60] [60] P <p> (which figure 6.1 was borrowed) discusses the individual results in detail. 76 Domain Constraints Relational Calculus Datalog Datalog : D = AC 0 1 [58] PTIME 1;4 [5, 17] PTIME 1;4 [6, 19] LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60, 36] <ref> [60] </ref> [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME DEXPTIME DEXPTIME B m = B m PTIME (9 only) p 2 -hard undec. [60] [60] P (D) ; <p> figure 6.1 was borrowed) discusses the individual results in detail. 76 Domain Constraints Relational Calculus Datalog Datalog : D = AC 0 1 [58] PTIME 1;4 [5, 17] PTIME 1;4 [6, 19] LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60, 36] <ref> [60] </ref> [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME DEXPTIME DEXPTIME B m = B m PTIME (9 only) p 2 -hard undec. [60] [60] P (D) ; c <p> 2;4 LOGSPACE [60, 36] <ref> [60] </ref> [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME DEXPTIME DEXPTIME B m = B m PTIME (9 only) p 2 -hard undec. [60] [60] P (D) ; c 2; c 62 PTIME (9 only) DEXPTIME-comp undec. <p> LOGSPACE [60, 36] <ref> [60] </ref> [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME DEXPTIME DEXPTIME B m = B m PTIME (9 only) p 2 -hard undec. [60] [60] P (D) ; c 2; c 62 PTIME (9 only) DEXPTIME-comp undec. <p> P (Z) [87] [76] N,Z 1S NC PSPACE-comp PSPACE-comp [74] [23] [23] R &lt;; + NC undec. undec. [37] ) undec. undec. [71, 11] N,Z lrp in PTIME undec. undec. [55] R +; fl NC undec. undec. <ref> [60, 14, 72] </ref> Z +; fl undec. undec. undec. [46] 1 safe queries [100]; the answers have to be finite relations. 2 inflationary semantics. 3 syntactically restricted stratified Datalog : ; cf. Section 5.5 4 data complexity. 5 for a fixed set of modulo factors (cf. Chapter 5). <p> In addition, the top-down evaluation allows the use of compilation techniques, developed for compilers of logic programming languages, which can make the query evaluation very efficient. 7.1 Introduction We propose a new method for evaluating deductive queries over constraint databases. (cf. Chapter 4 and <ref> [60] </ref>). The evaluation of queries in constraint databases is different from the one used in standard database systems. The constraints are used as the actual representation of the data stored in the database rather than as mere restrictions of the contents of otherwise ground relations.
Reference: [61] <author> Kemp, D. B., Stuckey, P. J. </author> <title> Analysis based constraint query optimization. </title> <booktitle> Proc. International Conference on Logic Programming, </booktitle> <year> 1993. </year>
Reference-contexts: There are two main directions of this research: 1. The first direction has its roots in the (deductive) database community: In <ref> [61, 68, 86, 89] </ref> techniques for pushing constraints present in the query are proposed. However, the goal of these methods is to preprocess the query, i.e., the goal and the rules, with respect to the given constraints, for a subsequent bottom-up evaluation.
Reference: [62] <author> Kreisel, G., Krivine, J. L. </author> <title> The elimination of quantifiers. Elements of Mathematical Logic, </title> <publisher> North-Holland, </publisher> <year> 1967. </year>
Reference-contexts: The main difference between the database approach and the Logic Programming approach is that the former uses quantifier elimination while the later uses resolution as the basis for query evaluation/computation. A comprehensive reference for quantifier elimination in various theories is <ref> [62] </ref>. A recent survey of constraint databases and query languages can be found in [78]. 7 Another approach is to use syntactic restriction on Datalog : clauses to guarantee termination for a restricted class of queries, e.g., restricting the constraints in the complemented relation to unary ones [77].
Reference: [63] <author> Lim, P., Stuckey, P.J. </author> <title> A Constraint Logic Programming Shell. </title> <booktitle> PLILP 1990. </booktitle>
Reference-contexts: This dramatically increases the expressive power of the query language while preserving the termination and efficiency. 2. The other direction is pursued in the area of Logic Programming: In <ref> [45, 54, 63] </ref> top-down evaluation for constraint logic programs is proposed. However, in all cases, general constraint-solving procedures are used. Thus these methods are not directly useful for query evaluation in constraint databases as the termination cannot be guaranteed. The closest to our work is [45].
Reference: [64] <author> Lipeck U.W., Saake, G. </author> <title> Monitoring Dynamic Integrity Constraints Based on Temporal Logic. </title> <journal> Information Systems, </journal> <volume> 12(2) </volume> <pages> 255-269, </pages> <year> 1987. </year>
Reference-contexts: Despite this drawback, FOTL was used as a basis of temporal query languages [99] or for specification of temporal integrity constraints <ref> [21, 22, 25, 26, 64] </ref>. The main reason for this choice is a simpler and more efficient implementation that does not generalize to full FOTL.
Reference: [65] <author> Lloyd, J. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <month> 105 </month>
Reference-contexts: There are two major approaches to solving this problem in the framework of standard Datalog: 1. Rewrite the program using the Magic Set Transformation (MST) [8, 68] and subse quently evaluate the transformed program bottom-up, and 2. Adopt a top-down evaluation strategy [29, 92] based on the resolution principle <ref> [65] </ref>. In this section we consider mainly the top-down resolution-based method. However, the MST transformation for the constraint deductive query languages is also introduced for comparison purposes. <p> Here both the top-down and bottom-up strategies are discussed and their relative performance is analyzed. An introduction to the top-down query evaluation (and the area of Logic Programming in general) can be found in <ref> [65] </ref>. Finally, there is a vast amount of articles on the various implementation techniques for Logic Programming languages based on resolution.
Reference: [66] <author> Mecca, G., Bonner, A. </author> <title> Sequences, Datalog, and Transducers. </title> <booktitle> in Proc. 14th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems,pp. </booktitle> <pages> 23-35, </pages> <year> 1995. </year>
Reference-contexts: The use of the successor symbols is confined to a single distinguished argument in the individual literals of the program. Such arrangement guarantees termination of all queries [23]. * Datalog over sequences <ref> [66] </ref>. This paper introduces an extension of Datalog with interpreted function symbols for manipulating sequences. A syntactic restriction on the class of queries guarantees termination of query evaluation. Bibliographical Notes The individual results for the various constraint classes can be found using the references in Figure 6.1.
Reference: [67] <author> Mendelson, E. </author> <title> Introduction to mathematical logic. </title> <publisher> Princeton, </publisher> <address> N.J., </address> <publisher> Van Nostrand 1964. </publisher>
Reference-contexts: introduction to these concepts can be found in virtually any book on mathematical logic, e.g., <ref> [67] </ref> or [35]. Algebras for capturing first-order logic can be found in [49]. <p> Then : C R := C2R defines the constraint complement of R and D n kRk = k: C Rk P r o o f: Immediate from Definition 4.23, Definition 4.23, and DeMorgan laws <ref> [35, 67] </ref>. 6 I.e., queries, specified by formulas, containing only ^; _; 9. 54 Note that for every generalized relation the previous lemma gives an algorithm for comput-ing the complement, as R contains only finitely many constraints C and thus we can iterate the constraint conjunction over them.
Reference: [68] <author> Mumick, I. S. </author> <title> Query Optimization in Deductive and Relational Databases. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1991. </year>
Reference-contexts: However, such strategies fail to consider the information contained in a partially instantiated query (i.e., they are not goal-oriented). There are two major approaches to solving this problem in the framework of standard Datalog: 1. Rewrite the program using the Magic Set Transformation (MST) <ref> [8, 68] </ref> and subse quently evaluate the transformed program bottom-up, and 2. Adopt a top-down evaluation strategy [29, 92] based on the resolution principle [65]. In this section we consider mainly the top-down resolution-based method. <p> There are two main directions of this research: 1. The first direction has its roots in the (deductive) database community: In <ref> [61, 68, 86, 89] </ref> techniques for pushing constraints present in the query are proposed. However, the goal of these methods is to preprocess the query, i.e., the goal and the rules, with respect to the given constraints, for a subsequent bottom-up evaluation.
Reference: [69] <author> Prior, A. </author> <title> Time and Modality. </title> <publisher> Oxford University Press, </publisher> <year> 1957. </year>
Reference-contexts: Prior to that, 4 Note that all the databases used in our proofs are finitely representable. 5 I.e., its complement is infinite. 44 temporal logic was studied as a form of modal logics on unlabeled transition systems, whose transition relation is an order <ref> [69] </ref>. There has been a substantial interest in temporal and modal logics in the specification/verification community. A whole volume of the Oxford Logic Guides [42] is dedicated to the study of various aspects of temporal logic.
Reference: [70] <author> Ramakrishnan, R. </author> <title> Magic Templates. A spellbinding approach to logic programs. </title> <journal> J. Logic Programming 1991, </journal> <volume> 11 </volume> <pages> 189-216. </pages>
Reference-contexts: Arguments adorned by f are removed. For simplicity, only left-to-right SIPS 6 is used (rule 3 of the previous definition). This corresponds to the selection rule used in Constraint Memoing. In both cases, different 6 Sideways Information Passing Style. 89 selection rules may improve the efficiency of query evaluation <ref> [70] </ref>. However, in the case of MST, the SIPS is fixed during the program transformation phase and there are technical difficulties with combining different SIPS in one program. <p> Analysis of binding patterns. Similar to the MST transformation, the queries can be analyzed to determine the flow of information in clause bodies <ref> [70] </ref>. This is a considerably more complicated task in the presence of constraints: it is no longer sufficient to focus on single variables; the relationships between groups of variables have to be considered (as noted in Section 7.4).
Reference: [71] <author> Reddy, C.R., Loveland D.W. </author> <title> Presburger Arithmetic with Bounded Quantifier Alternation. </title> <booktitle> Proc. ACM Symp. on Theory of Comp., </booktitle> <pages> 320-325, </pages> <year> 1978. </year>
Reference-contexts: P (Z) [87] [76] N,Z 1S NC PSPACE-comp PSPACE-comp [74] [23] [23] R &lt;; + NC undec. undec. [37] ) undec. undec. <ref> [71, 11] </ref> N,Z lrp in PTIME undec. undec. [55] R +; fl NC undec. undec. [60, 14, 72] Z +; fl undec. undec. undec. [46] 1 safe queries [100]; the answers have to be finite relations. 2 inflationary semantics. 3 syntactically restricted stratified Datalog : ; cf.
Reference: [72] <author> Renegar, J. </author> <title> On the Computational Complexity and Geometry of the First-order Theory of the Reals. </title> <journal> Journal of Symbolic Computation, parts I-III, </journal> <volume> 13(3) </volume> <pages> 255-330, </pages> <year> 1992 </year>
Reference-contexts: P (Z) [87] [76] N,Z 1S NC PSPACE-comp PSPACE-comp [74] [23] [23] R &lt;; + NC undec. undec. [37] ) undec. undec. [71, 11] N,Z lrp in PTIME undec. undec. [55] R +; fl NC undec. undec. <ref> [60, 14, 72] </ref> Z +; fl undec. undec. undec. [46] 1 safe queries [100]; the answers have to be finite relations. 2 inflationary semantics. 3 syntactically restricted stratified Datalog : ; cf. Section 5.5 4 data complexity. 5 for a fixed set of modulo factors (cf. Chapter 5).
Reference: [73] <author> Revesz, P. Z. </author> <title> A Closed Form for Datalog Queries with Integer Order. </title> <booktitle> Proc. 3rd International Conference on Database Theory, </booktitle> <pages> pp 187-201, </pages> <publisher> Springer-Verlag LNCS 470, </publisher> <year> 1990. </year>
Reference-contexts: Figure 4.1 shows an example of a naive evaluation procedure for first-order queries over a constraint database. The following definition states a fundamental property of the constraint classes on which the termination proofs of bottom-up query evaluation procedures are implicitly based <ref> [73, 85, 96, 100] </ref>. Definition 4.4 (Constraint-compact Class of Constraints) Let C be a constraint class. <p> Such sets are quite useful for encoding and storing information about periodic activities in the temporal databases, such as schedules or experimental data. In addition, we show how these kinds of constraints can be combined with other classes of constraints over integers|the gap-order constraints <ref> [73] </ref> and the equality constraints. Example 5.1 A simple example of a Datalog program that uses integer constraints is a database of airline connections between cities (cf. figure 5.1). <p> Such language can be used as a simple but very expressive query language over temporal databases. The evaluation for the gap-order constraints is based on the results in <ref> [73, 75] </ref>. The proposed bottom-up evaluation procedure has polynomial data complexity. <p> In this section we consider the possibility of combining different classes of constraints over the same domain, in our case integers. 5.4.1 Gap-order constraints First we combine the constraint language developed so far with Datalog &lt;Z |Datalog with gap-order constraints <ref> [73, 75] </ref>. 65 Definition 5.33 (Gap-order constraint) Let u; l be integers, c a nonnegative integer, and x; y; : : : be variables over integers. <p> Then a finite conjunction of formulas of the form l &lt; x, x &lt; u, and x + c &lt; y is called a gap-order constraint. Conjunctions of gap-order constraints can be efficiently represented using gap graphs <ref> [73] </ref> (directed acyclic graphs where nodes represent variables and the lower and the upper bounds of constraints, and directed labeled edges represent gaps, i.e., the minimal integer distances between nodes). For this representation we also have all the necessary operations for closed-form bottom-up evaluation [73]. <p> be efficiently represented using gap graphs <ref> [73] </ref> (directed acyclic graphs where nodes represent variables and the lower and the upper bounds of constraints, and directed labeled edges represent gaps, i.e., the minimal integer distances between nodes). For this representation we also have all the necessary operations for closed-form bottom-up evaluation [73]. We show that the combination of these two approaches still has a closed-form evaluation procedure and the complexity bounds do not increase. <p> Section 5.2 and <ref> [73, 75] </ref>). However, Theorem 5.35 Consistency checking of a conjunction of a periodicity graph with a gap graph is NP-complete. P r o o f: By reduction of 3SAT to satisfiability of conjunctions of constraints of the form x k (y + c) and x + c &lt; y. <p> Fortunately: Theorem 5.36 Consistency checking of a conjunction of a periodicity graph constructed from simple periodicity constraints only and a gap graph can be computed in PTIME. P r o o f: By generalization of the consistency checking procedure given in <ref> [73] </ref>; the algorithm computes the length of every path from the lower bound to the upper bound of the gap-graph by adding the gap sizes on the edges of the path. <p> Corollary 5.44 The bottom-up evaluation of any Datalog Z;&lt;Z program terminates. To show a polynomial bound for the tuple recognition procedure for Datalog Z;&lt;Z programs we use the same technique: the tuple recognition runs in PTIME (follows from Theorem 5.29 and complexity of the TEST algorithm in <ref> [73] </ref>) 5 . 5.4.4 Equality constraints So far we have not mentioned the most natural class of constraints on integers|the equality constraints, which are needed to include the "standard" Datalog over integers. In [73] the equality constraints are handled by adding extra information to the gap-graphs. <p> the tuple recognition runs in PTIME (follows from Theorem 5.29 and complexity of the TEST algorithm in <ref> [73] </ref>) 5 . 5.4.4 Equality constraints So far we have not mentioned the most natural class of constraints on integers|the equality constraints, which are needed to include the "standard" Datalog over integers. In [73] the equality constraints are handled by adding extra information to the gap-graphs. In the case of Datalog Z it can be done in the same way; in all cases we need some mechanism to represent a single constraint of the form x = y. <p> However, this approach works only for convex sets. Thus, the periodicity constraints call for new storage management techniques. 5.6 Related Work There are other proposals that introduce classes of infinite integer relations into query languages. Datalog with (gap-)order constraints was introduced in <ref> [73] </ref>. In [55] the relational calculus over generalized relational databases with order constraints and linear repeating points was studied (a linear repeating point has the form fc + knjn 2 Zg for some fixed integers c and k and is just a different notation for a periodicity constraint). <p> Another extension of Datalog was proposed in [13]. This extension combines linear repeating points, order constraints, and unlimited use of successor 72 function. The resulting language is very expressive|termination of query evaluation in this language cannot be guaranteed. Summarizing: <ref> [73, 75] </ref> cannot handle periodicity constraints, [55] cannot handle recursion, [23, 24] cannot handle ordering, and [13] does not guarantee termination. Our language is thus another step towards a tractable and expressive query language for temporal databases. <p> Our language is thus another step towards a tractable and expressive query language for temporal databases. Bibliographical Notes The work on the combination of Datalog rules with integer order constraints was pursued in <ref> [73] </ref>. Integer based constraint queries have also been proposed in [55]. Most of the results about integers can be easily found in books on number theory, e.g., [48, 104] or [82] (if you read Polish). <p> The evaluation remains unchanged as we use more general evaluation mechanism. * The incorporation of more interesting constraints, e.g., the constraints over integers Z, has been discussed in Chapter 5: the gap-order constraints <ref> [73] </ref> are generated from the set Similarly the periodicity constraints are generated from C Z = fx k c : c &lt; k; k 2 C 0 g In Chapter 5 and [96] a closed form bottom-up evaluation procedure for C ;&lt;Z = C &lt;Z [ C Z was developed including <p> Other constraint classes. There are also constraint classes, where all the constraint operations are defined, but which are not constraint-compact, e.g., the class generated from the set fx + c &lt; y : c 2 Zg|gap-order constraints with possibly negative size of the gap <ref> [73] </ref> or the linear arithmetic constraints [60]. 6.2 Abstract Interpretation Another interesting application of constraints can be found in the area of programming languages analysis, especially those analysis that are based on the Abstract Interpretation [3, 32]. <p> However, neither of them seems to address all three requirements. The first approach is based on the fixpoint (bottom-up) evaluation of the rules. (cf. Chapter 4). Here the first condition is usually met, e.g., for Datalog [100], Datalog with 79 integer constraints in Chapter 5 and <ref> [73, 96] </ref>, and sets [85]. However, the classes of allowed constraints are restricted to guarantee termination. Also, the evaluation process is not goal-oriented and thus the evaluation of the partially instantiated queries is quite inefficient 1 . The other approach is based on top-down resolution-based method. <p> Note the essential use of constraint projection that allows to determine the relevant constraint for every atom. Also, the SLG-resolution can handle negation using several additional rules. However, presence of negation together with constraints often leads to non-termination <ref> [73] </ref>. Thus, our current proposal allows only positive programs. Adding negation is briefly discussed in Section 7.6. <p> The soundness and completeness proof is based on the reduction to the fixpoint computation on ground instances. However, to prove the termination of query evaluation (in both the bottom-up and top-down cases) a finite encoding of a potentially infinite result of the evaluation is needed (cf. Chapter 4 and <ref> [73, 96] </ref>). Theorem 7.11 (Termination) If the class C is constraint-compact then the SLG C evaluation terminates for all queries (G; C; P ). P r o o f: Let C be a constraint-compact class of constraints. Then: 86 1.
Reference: [74] <author> Revesz, P. </author> <title> Constraint Query Languages. </title> <type> PhD Dissertation, </type> <institution> Brown University, </institution> <year> 1991. </year>
Reference-contexts: Calculus Datalog Datalog : D = AC 0 1 [58] PTIME 1;4 [5, 17] PTIME 1;4 [6, 19] LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60, 36] [60] [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] <ref> [74] </ref> DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME DEXPTIME DEXPTIME B m = B m PTIME (9 only) p 2 -hard undec. [60] [60] P (D) ; c 2; c 62 PTIME (9 only) DEXPTIME-comp undec. <p> P (Z) [87] [76] N,Z 1S NC PSPACE-comp PSPACE-comp <ref> [74] </ref> [23] [23] R &lt;; + NC undec. undec. [37] ) undec. undec. [71, 11] N,Z lrp in PTIME undec. undec. [55] R +; fl NC undec. undec. [60, 14, 72] Z +; fl undec. undec. undec. [46] 1 safe queries [100]; the answers have to be finite relations. 2 inflationary
Reference: [75] <author> Revesz, P. Z. </author> <title> A Closed Form Evaluation for Datalog Queries with Integer (Gap)-Order Constraints. </title> <journal> Theoretical Computer Science, </journal> <volume> vol. 116, no. 1, </volume> <pages> 117-149, </pages> <year> 1993. </year>
Reference-contexts: Such language can be used as a simple but very expressive query language over temporal databases. The evaluation for the gap-order constraints is based on the results in <ref> [73, 75] </ref>. The proposed bottom-up evaluation procedure has polynomial data complexity. <p> In this section we consider the possibility of combining different classes of constraints over the same domain, in our case integers. 5.4.1 Gap-order constraints First we combine the constraint language developed so far with Datalog &lt;Z |Datalog with gap-order constraints <ref> [73, 75] </ref>. 65 Definition 5.33 (Gap-order constraint) Let u; l be integers, c a nonnegative integer, and x; y; : : : be variables over integers. <p> Section 5.2 and <ref> [73, 75] </ref>). However, Theorem 5.35 Consistency checking of a conjunction of a periodicity graph with a gap graph is NP-complete. P r o o f: By reduction of 3SAT to satisfiability of conjunctions of constraints of the form x k (y + c) and x + c &lt; y. <p> Another extension of Datalog was proposed in [13]. This extension combines linear repeating points, order constraints, and unlimited use of successor 72 function. The resulting language is very expressive|termination of query evaluation in this language cannot be guaranteed. Summarizing: <ref> [73, 75] </ref> cannot handle periodicity constraints, [55] cannot handle recursion, [23, 24] cannot handle ordering, and [13] does not guarantee termination. Our language is thus another step towards a tractable and expressive query language for temporal databases. <p> 76 Domain Constraints Relational Calculus Datalog Datalog : D = AC 0 1 [58] PTIME 1;4 [5, 17] PTIME 1;4 [6, 19] LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60, 36] [60] [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME <ref> [75] </ref> non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME DEXPTIME DEXPTIME B m = B m PTIME (9 only) p 2 -hard undec. [60] [60] P (D) ; c 2; c 62 PTIME (9 only) DEXPTIME-comp undec. <p> D = AC 0 1 [58] PTIME 1;4 [5, 17] PTIME 1;4 [6, 19] LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60, 36] [60] [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME <ref> [75] </ref> non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME DEXPTIME DEXPTIME B m = B m PTIME (9 only) p 2 -hard undec. [60] [60] P (D) ; c 2; c 62 PTIME (9 only) DEXPTIME-comp undec.
Reference: [76] <author> Revesz, P. Z. </author> <title> Datalog Queries of Set Constraint Databases. </title> <booktitle> In Proc. 5th International Conference on Database Theory, </booktitle> <pages> 423-438, </pages> <year> 1995. </year>
Reference-contexts: &lt;Z [ C Z was developed including all the necessary operations on the constraint class as required by Definition 4.3. * We can also incorporate the dense order constraints over Q by a slight modification of constraint operations well defined in [60, 58]. * The set-order constraints were introduced in <ref> [76] </ref>, and * The boolean algebra constraints in [60], All the above constraint classes are constraint-compact. Other constraint classes. <p> Datalog : D = AC 0 1 [58] PTIME 1;4 [5, 17] PTIME 1;4 [6, 19] LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60, 36] [60] [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] [74] DEXPTIME-hard <ref> [76] </ref> undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME DEXPTIME DEXPTIME B m = B m PTIME (9 only) p 2 -hard undec. [60] [60] P (D) ; c 2; c 62 PTIME (9 only) DEXPTIME-comp undec. P (Z) [87] [76] N,Z 1S NC PSPACE-comp <p> 3 [77] [74] DEXPTIME-hard <ref> [76] </ref> undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME DEXPTIME DEXPTIME B m = B m PTIME (9 only) p 2 -hard undec. [60] [60] P (D) ; c 2; c 62 PTIME (9 only) DEXPTIME-comp undec. P (Z) [87] [76] N,Z 1S NC PSPACE-comp PSPACE-comp [74] [23] [23] R &lt;; + NC undec. undec. [37] ) undec. undec. [71, 11] N,Z lrp in PTIME undec. undec. [55] R +; fl NC undec. undec. [60, 14, 72] Z +; fl undec. undec. undec. [46] 1 safe queries [100]; the answers have
Reference: [77] <author> Revesz, P. </author> <title> Safe Stratified Datalog with Integer Order Programs. </title> <booktitle> In Proc. First International Conference on Constraint Programming, </booktitle> <editor> Montanari U., Rossi F. eds., </editor> <publisher> Springer-Verlag LNCS 976, </publisher> <address> Cassis, France, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: A recent survey of constraint databases and query languages can be found in [78]. 7 Another approach is to use syntactic restriction on Datalog : clauses to guarantee termination for a restricted class of queries, e.g., restricting the constraints in the complemented relation to unary ones <ref> [77] </ref>. Note that the restriction on the syntactic shape of the Datalog : programs often implies the constraint-compactness under such a limited version of complementation. 55 Chapter 5 Constraint Classes over Integers This chapter introduces a generalization of Datalog operating on periodicity and gap-order constraints over the set of integers. <p> There is a limited version of negation that can be included in the language without such penalty. In <ref> [77] </ref> a syntactic subclass of Datalog :;&lt;Z was introduced, for which termination can be shown. <p> Relational Calculus Datalog Datalog : D = AC 0 1 [58] PTIME 1;4 [5, 17] PTIME 1;4 [6, 19] LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60, 36] [60] [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 <ref> [77] </ref> [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 [96] PTIME 4;5 DEXPTIME DEXPTIME DEXPTIME B m = B m PTIME (9 only) p 2 -hard undec. [60] [60] P (D) ; c 2; c 62 PTIME (9 only) DEXPTIME-comp undec. <p> Here we run into problems with termination of all Datalog C queries (cf. Figure 6.1). However, in <ref> [77] </ref> a syntactic subclass of Datalog C queries for Datalog :;&lt;Z was introduced, for which termination is guaranteed.
Reference: [78] <author> Revesz, P. </author> <title> Constraint Query Languages. A Survey. </title> <type> (unpublished manuscript), </type> <year> 1995. </year>
Reference-contexts: A comprehensive reference for quantifier elimination in various theories is [62]. A recent survey of constraint databases and query languages can be found in <ref> [78] </ref>. 7 Another approach is to use syntactic restriction on Datalog : clauses to guarantee termination for a restricted class of queries, e.g., restricting the constraints in the complemented relation to unary ones [77]. <p> A syntactic restriction on the class of queries guarantees termination of query evaluation. Bibliographical Notes The individual results for the various constraint classes can be found using the references in Figure 6.1. A forthcoming survey of constraint query languages <ref> [78] </ref> from (which figure 6.1 was borrowed) discusses the individual results in detail. 76 Domain Constraints Relational Calculus Datalog Datalog : D = AC 0 1 [58] PTIME 1;4 [5, 17] PTIME 1;4 [6, 19] LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60,
Reference: [79] <author> Rosenstein J.G. </author> <title> Linear Orderings. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1982. </year>
Reference-contexts: To show that P is not first-order definable property it is sufficient to show 1. A n 2 P and B n 62 P for all n 0, and Example 3.17 (Characterization of Linear Orders) This technique can be used to show the well-known characterization of finite linear orders <ref> [79] </ref>: Let L m be a finite linear order of length m. <p> Thus, L &gt;a m ~ k1 L &gt;b m ~ k1 L &lt;b n . The result now follows by induction on k. The complete proof can be found in <ref> [79] </ref>. In particular, we can show that there is no formula '(R) = true if R contains an even number of tuples, false otherwise Clearly, to express this query we would need a first-order formula that distinguishes L 2 k and L 2 k 1 for every k &gt; 0. <p> Theorem 3.30). Except for the additional rules, the game for temporal logic is the same as the Ehrenfeucht-Frasse game for first-order logic <ref> [79] </ref>. The first rule enforces the sort compatibility of the individual moves in the game|this is a natural requirement for the many-sorted structures (we can assume that the relations are empty if the arguments do not match the required sorts).
Reference: [80] <author> Schmidt, D. A. </author> <title> The Structure of Typed Programming Languages, </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, MA, </address> <year> 1994. </year>
Reference-contexts: The domains of the abstract values are much simpler and often finite. Moreover, all the domains of the abstract values are designed in a way that the analysis always terminates. The semantics of programming languages can be given in the natural form given in, e.g., <ref> [47, 80] </ref>, using a set of inference rules.
Reference: [81] <author> Schmidt, D. A. </author> <title> Natural-Semantics-Based Abstract Interpretation. </title> <booktitle> In Proc. Static Analysis Symposium 1995, </booktitle> <publisher> Springer LNCS 983. </publisher>
Reference-contexts: This approach can be applied to many techniques used for compiler optimization, e.g., the data-flow analysis [4] or the closure analysis <ref> [81] </ref>. 75 6.3 Other Formalisms There are few other extensions of Datalog with constraints.
Reference: [82] <author> Sierpinski, W. </author> <title> Teoria Liczb, Part II, </title> <address> Warszaw, </address> <year> 1959. </year>
Reference-contexts: decomposition theorem [10]) Any finite Abelian group is isomorphic to a finite product of cyclic groups of prime power orders, and the list of the prime power orders is unique up to permutation. and the fact that the growth rate of the sequence of primes is approximately n log n <ref> [82] </ref>; every element of Z P is isomorphic to the product of the appropriate elements in the individual groups Z p i . <p> Bibliographical Notes The work on the combination of Datalog rules with integer order constraints was pursued in [73]. Integer based constraint queries have also been proposed in [55]. Most of the results about integers can be easily found in books on number theory, e.g., [48, 104] or <ref> [82] </ref> (if you read Polish). Other useful results about cyclic groups Z n can be found in books on group theory and modern algebra in general, e.g., [10]. 73 Chapter 6 Other Constraint Classes This section surveys several other known constraint classes, and summarizes their properties.
Reference: [83] <author> Snodgrass R. T. </author> <title> The Temporal Query Language TQuel. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2) </volume> <pages> 247-298, </pages> <month> June </month> <year> 1987. </year> <month> 106 </month>
Reference-contexts: The first-order query languages can be divided into two main categories: 1. query languages based on a two-sorted version of relational calculus, e.g., TSQL2 [84] or TQUEL <ref> [83] </ref>, and 2. query languages based on an extension of the relational calculus or algebra by temporal operators, e.g, HRDM's historical relational algebra [27], temporal relational algebra [99], etc.
Reference: [84] <author> Snodgrass R.T., </author> <title> editor. The TSQL2 Temporal Query Language. </title> <publisher> Kluwer Academic Pub--lishers, </publisher> <address> 674+xxiv pages, </address> <year> 1995. </year>
Reference-contexts: The first-order query languages can be divided into two main categories: 1. query languages based on a two-sorted version of relational calculus, e.g., TSQL2 <ref> [84] </ref> or TQUEL [83], and 2. query languages based on an extension of the relational calculus or algebra by temporal operators, e.g, HRDM's historical relational algebra [27], temporal relational algebra [99], etc.
Reference: [85] <author> Srivastava, D., Ramakrishnan, R., Revesz, P. Z. </author> <title> Constraint Objects. </title> <booktitle> Proc. Intl. Workshop on Principles and Practice of Constraint Programming, </booktitle> <pages> 218-228, </pages> <year> 1994. </year>
Reference-contexts: Figure 4.1 shows an example of a naive evaluation procedure for first-order queries over a constraint database. The following definition states a fundamental property of the constraint classes on which the termination proofs of bottom-up query evaluation procedures are implicitly based <ref> [73, 85, 96, 100] </ref>. Definition 4.4 (Constraint-compact Class of Constraints) Let C be a constraint class. <p> The first approach is based on the fixpoint (bottom-up) evaluation of the rules. (cf. Chapter 4). Here the first condition is usually met, e.g., for Datalog [100], Datalog with 79 integer constraints in Chapter 5 and [73, 96], and sets <ref> [85] </ref>. However, the classes of allowed constraints are restricted to guarantee termination. Also, the evaluation process is not goal-oriented and thus the evaluation of the partially instantiated queries is quite inefficient 1 . The other approach is based on top-down resolution-based method.
Reference: [86] <author> Srivastava, D., Ramakrishnan, R. </author> <title> Pushing Constraint Selections. </title> <journal> J. Logic Programming 1993:16:361-414, </journal> <year> 1993. </year>
Reference-contexts: There are two main directions of this research: 1. The first direction has its roots in the (deductive) database community: In <ref> [61, 68, 86, 89] </ref> techniques for pushing constraints present in the query are proposed. However, the goal of these methods is to preprocess the query, i.e., the goal and the rules, with respect to the given constraints, for a subsequent bottom-up evaluation.
Reference: [87] <author> Srivastava, D., Ramakrishnan, R., Revesz, P. </author> <title> Constraint Objects. </title> <booktitle> In Proc. 2nd Workshop on Principles and Practice of Constraint Programming, </booktitle> <pages> 274-284, </pages> <year> 1994. </year>
Reference-contexts: P (Z) <ref> [87] </ref> [76] N,Z 1S NC PSPACE-comp PSPACE-comp [74] [23] [23] R &lt;; + NC undec. undec. [37] ) undec. undec. [71, 11] N,Z lrp in PTIME undec. undec. [55] R +; fl NC undec. undec. [60, 14, 72] Z +; fl undec. undec. undec. [46] 1 safe queries [100]; the answers
Reference: [88] <author> Stavi J. </author> <title> Functional Completeness over Rationals. </title> <type> Unpublished, </type> <institution> Bar-Ilan University, Ramat-Gan, Israel, </institution> <year> 1979. </year>
Reference-contexts: This result has been established by Kamp [56] for complete linear orders, later extended by Stavi <ref> [88] </ref> for all linear orders, and reproven several times using various proof techniques, e.g, [39, 50]. In this section we show that this correspondence does not generalize to the relationship between the First-order Temporal Logic (FOTL) and the Two-sorted First-order Logic (2-FOL). <p> We show that for a standard choice of the data domain being the set of uninterpreted constants with equality and a standard choice of a linearly ordered temporal domain: * the propositional temporal logic has an expressively complete set of temporal connec tives <ref> [39, 50, 56, 88] </ref>, but * there is no finite set of temporal connectives expressively complete in the first-order case.
Reference: [89] <author> Stuckey, P. J., Sudarashan, S. </author> <title> Compiling Query Constraints. </title> <booktitle> Proc. ACM Symposium on Principles of Database Systems, </booktitle> <year> 1994. </year>
Reference-contexts: There are two main directions of this research: 1. The first direction has its roots in the (deductive) database community: In <ref> [61, 68, 86, 89] </ref> techniques for pushing constraints present in the query are proposed. However, the goal of these methods is to preprocess the query, i.e., the goal and the rules, with respect to the given constraints, for a subsequent bottom-up evaluation.
Reference: [90] <author> Swift, T., Warren, D. S. </author> <title> Analysis of SLG-WAM Evaluation of Definite Programs. </title> <booktitle> Proc. 1994 International Logic Programming Symposium, </booktitle> <publisher> MIT Press, </publisher> <year> 1994, </year> <pages> 219-235. </pages>
Reference-contexts: The other approach is based on top-down resolution-based method. Here the second and third conditions are usually met. However, termination for all queries is often sacrificed (an exception is <ref> [90] </ref>, where no constraints are allowed) in order to improve the expressiveness and efficiency. These methods can also take full advantage of compilation techniques developed for other logic programming languages, e.g., [91, 103]. This greatly improves the practical efficiency of query evaluation [90] in the case of Datalog. <p> all queries is often sacrificed (an exception is <ref> [90] </ref>, where no constraints are allowed) in order to improve the expressiveness and efficiency. These methods can also take full advantage of compilation techniques developed for other logic programming languages, e.g., [91, 103]. This greatly improves the practical efficiency of query evaluation [90] in the case of Datalog. We show that similar results can be achieved in the case of constraint databases as well. In this chapter we try to combine the advantages of both the approaches. <p> This has been observed in several papers, e.g., [92, 93] and an alternative to SLD-resolution was proposed under various names. The main idea consists of remembering sets of answers for already resolved subgoals. This method also guarantees termination for function-free logic programs <ref> [90] </ref>. We extend this method to constraint deductive queries while preserving the termination and complexity bounds of bottom-up evaluation. 7.3 Top-down evaluation for Datalog C In Chapter 4 the bottom-up evaluation of Datalog C was defined in terms of elementary operations over a specific class of constraints.
Reference: [91] <author> Swift, T., Warren, D. S. </author> <title> An Abstract Machine for SLG Resolution: Definite Programs. </title> <booktitle> Proc. 1994 International Logic Programming Symposium, </booktitle> <publisher> MIT Press, </publisher> <pages> 633-652, </pages> <year> 1994. </year>
Reference-contexts: However, termination for all queries is often sacrificed (an exception is [90], where no constraints are allowed) in order to improve the expressiveness and efficiency. These methods can also take full advantage of compilation techniques developed for other logic programming languages, e.g., <ref> [91, 103] </ref>. This greatly improves the practical efficiency of query evaluation [90] in the case of Datalog. We show that similar results can be achieved in the case of constraint databases as well. In this chapter we try to combine the advantages of both the approaches. <p> The performance of Constraint Memoing can be boosted by utilizing the compilation techniques developed in <ref> [91] </ref> and performance similar to ground Datalog can be expected. Future research in this area will focus on following issues: Compilation of constraints. To achieve an efficient implementation of Constraint Mem-oing, data structures for efficient representation of the constraints have to be developed.
Reference: [92] <author> Swift, T., Warren, D. S., Chen, W. </author> <title> Operational semantics of SLG evaluation. </title> <type> Tech. report, </type> <institution> SUNY at Stony Brook, </institution> <year> 1994. </year>
Reference-contexts: There are two major approaches to solving this problem in the framework of standard Datalog: 1. Rewrite the program using the Magic Set Transformation (MST) [8, 68] and subse quently evaluate the transformed program bottom-up, and 2. Adopt a top-down evaluation strategy <ref> [29, 92] </ref> based on the resolution principle [65]. In this section we consider mainly the top-down resolution-based method. However, the MST transformation for the constraint deductive query languages is also introduced for comparison purposes. <p> Note also that breadth-first traversal of a SLD-tree does not guarantee termination in general. The drawback is caused by the occurrence of infinite paths in SLD search trees. This has been observed in several papers, e.g., <ref> [92, 93] </ref> and an alternative to SLD-resolution was proposed under various names. The main idea consists of remembering sets of answers for already resolved subgoals. This method also guarantees termination for function-free logic programs [90]. <p> This section shows how a top-down query evaluation procedure (SLG-resolution <ref> [92] </ref>) can be refined using the same operations to handle constraint queries. This approach allows us to build a very efficient top-down evaluation procedure for every class of constraints that has a closed form bottom-up evaluation procedure. Moreover, the termination property of the bottom-up algorithm is preserved.
Reference: [93] <author> Tamaki, H., Sato, T. </author> <title> OLD-Resolution with Tabulation. </title> <booktitle> Proc. 3-rd International Conference on Logic Programming, </booktitle> <pages> 84-98, </pages> <year> 1986. </year>
Reference-contexts: Note also that breadth-first traversal of a SLD-tree does not guarantee termination in general. The drawback is caused by the occurrence of infinite paths in SLD search trees. This has been observed in several papers, e.g., <ref> [92, 93] </ref> and an alternative to SLD-resolution was proposed under various names. The main idea consists of remembering sets of answers for already resolved subgoals. This method also guarantees termination for function-free logic programs [90].
Reference: [94] <author> Tansel A., Clifford J., Gadia S., Jajodia S., Segev A., Snodgrass R. </author> <title> Temporal Databases. Theory, Design, and Implementation. </title> <publisher> Benjamin Cummings 1993. </publisher>
Reference-contexts: The main reason for this choice is a simpler and more efficient implementation that does not generalize to full FOTL. The design of an expressively complete Temporal Relational Algebra requires an unbounded number of temporal attributes in the relations to guarantee completeness and preserve closure of products <ref> [94] </ref>. However, such solution does not allow to store the intermediate results needed to evaluate the query in a uniform temporal database as auxiliary relations. In addition to the separation of FOTL from 2-FOL we show several other results, especially: 1. <p> This is a natural requirement imposed on virtually all practical temporal databases <ref> [94] </ref>, e.g., on the timestamp relations in TSQL2 or TQUEL. 19 The rest of the chapter is organized as follows: Section 3.2 introduces the formal def-inition of the temporal database and first-order temporal query languages over such databases.
Reference: [95] <author> Tarski, A. </author> <title> Sur les ensembles definissables de nombres reels, </title> <journal> Fundamenta Mathematicae, </journal> <volume> 17 </volume> <pages> 210-239, </pages> <note> 1931 (English translation in Logics, Semantics, Metamathematics, second edition, Hackett, </note> <year> 1983). </year>
Reference: [96] <author> Toman, D., Chomicki, J., Rogers D. S. </author> <title> Datalog with Integer Periodicity Constraints. </title> <booktitle> Proc. 1994 International Logic Programming Symposium, </booktitle> <pages> 189-203, </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: However, while in the case of ground tuples, represented using equality constraints, the constraint projection returns always only one constraint (tuple), in the case of more general constraints (e.g., Definitions 5.38 or <ref> [96] </ref>) the constraint projection may return a set containing more than one tuple. The last operation, constraint subsumption, is used to eliminate redundant answers 4 and reduces to checking equality in the case of ground tuples. <p> Figure 4.1 shows an example of a naive evaluation procedure for first-order queries over a constraint database. The following definition states a fundamental property of the constraint classes on which the termination proofs of bottom-up query evaluation procedures are implicitly based <ref> [73, 85, 96, 100] </ref>. Definition 4.4 (Constraint-compact Class of Constraints) Let C be a constraint class. <p> The correctness of the evaluation and the termination of it is guaranteed for all classes of constraints that are constraint-compact. 4.7 Related Work This chapter is based on a generalization of the concepts present in the specific results on various concrete constraint query languages, e.g., <ref> [55, 60, 96, 100] </ref>. We have extracted the common underlying ideas and shown general properties of the abstracted model. A similar approach can be found in [51] for the general constraint logic programming languages. <p> more interesting constraints, e.g., the constraints over integers Z, has been discussed in Chapter 5: the gap-order constraints [73] are generated from the set Similarly the periodicity constraints are generated from C Z = fx k c : c &lt; k; k 2 C 0 g In Chapter 5 and <ref> [96] </ref> a closed form bottom-up evaluation procedure for C ;&lt;Z = C &lt;Z [ C Z was developed including all the necessary operations on the constraint class as required by Definition 4.3. * We can also incorporate the dense order constraints over Q by a slight modification of constraint operations well <p> 17] PTIME 1;4 [6, 19] LOGSPACE 1 [17] Q 6=; ; &lt; AC 0 [58] PTIME 4 PTIME 2;4 LOGSPACE [60, 36] [60] [60] Z 6=; ; &lt;; &lt; k NC in DEXPTIME [75] non-elem. 3 [77] [74] DEXPTIME-hard [76] undec. [75] N,Z k PTIME [105] (9 only) PTIME 4;5 <ref> [96] </ref> PTIME 4;5 DEXPTIME DEXPTIME DEXPTIME B m = B m PTIME (9 only) p 2 -hard undec. [60] [60] P (D) ; c 2; c 62 PTIME (9 only) DEXPTIME-comp undec. <p> However, neither of them seems to address all three requirements. The first approach is based on the fixpoint (bottom-up) evaluation of the rules. (cf. Chapter 4). Here the first condition is usually met, e.g., for Datalog [100], Datalog with 79 integer constraints in Chapter 5 and <ref> [73, 96] </ref>, and sets [85]. However, the classes of allowed constraints are restricted to guarantee termination. Also, the evaluation process is not goal-oriented and thus the evaluation of the partially instantiated queries is quite inefficient 1 . The other approach is based on top-down resolution-based method. <p> The soundness and completeness proof is based on the reduction to the fixpoint computation on ground instances. However, to prove the termination of query evaluation (in both the bottom-up and top-down cases) a finite encoding of a potentially infinite result of the evaluation is needed (cf. Chapter 4 and <ref> [73, 96] </ref>). Theorem 7.11 (Termination) If the class C is constraint-compact then the SLG C evaluation terminates for all queries (G; C; P ). P r o o f: Let C be a constraint-compact class of constraints. Then: 86 1.
Reference: [97] <author> Toman, D., Niwinski, D. </author> <title> First-Order Temporal Queries Inexpressible in Temporal Logic. Presented at the Workshop on Theory of Constraint Databases, </title> <note> PODS 1995. (TR UNL-CSE-95-08). To appear in Proc. EDBT'96. </note>
Reference: [98] <author> Toman, D. </author> <title> Top-Down beats Bottom-Up for Constraint Based Extensions of Datalog. </title> <booktitle> Proc. 1995 International Logic Programming Symposium, </booktitle> <pages> 98-112, </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference: [99] <author> Tuzhilin A., Clifford J. </author> <title> A Temporal Relational Algebra as a Basis for Temporal Completeness. </title> <booktitle> Proc. International Conference on VLDB, </booktitle> <year> 1990. </year> <month> 107 </month>
Reference-contexts: can be divided into two main categories: 1. query languages based on a two-sorted version of relational calculus, e.g., TSQL2 [84] or TQUEL [83], and 2. query languages based on an extension of the relational calculus or algebra by temporal operators, e.g, HRDM's historical relational algebra [27], temporal relational algebra <ref> [99] </ref>, etc. These two approaches have been often considered equivalent in expressive power, e.g., in [99], where the temporal relational algebra based on an extension of the relational calculus by temporal operators has been proposed as a basis for first-order completeness of temporal query languages. <p> of relational calculus, e.g., TSQL2 [84] or TQUEL [83], and 2. query languages based on an extension of the relational calculus or algebra by temporal operators, e.g, HRDM's historical relational algebra [27], temporal relational algebra <ref> [99] </ref>, etc. These two approaches have been often considered equivalent in expressive power, e.g., in [99], where the temporal relational algebra based on an extension of the relational calculus by temporal operators has been proposed as a basis for first-order completeness of temporal query languages. <p> Despite this drawback, FOTL was used as a basis of temporal query languages <ref> [99] </ref> or for specification of temporal integrity constraints [21, 22, 25, 26, 64]. The main reason for this choice is a simpler and more efficient implementation that does not generalize to full FOTL.
Reference: [100] <author> Ullman J. D. </author> <title> Principles of Database and Knowledge-base Systems, </title> <booktitle> Vol. 1,2. Computer Science Systems, </booktitle> <year> 1989. </year>
Reference-contexts: Figure 4.1 shows an example of a naive evaluation procedure for first-order queries over a constraint database. The following definition states a fundamental property of the constraint classes on which the termination proofs of bottom-up query evaluation procedures are implicitly based <ref> [73, 85, 96, 100] </ref>. Definition 4.4 (Constraint-compact Class of Constraints) Let C be a constraint class. <p> The answer relation is then the generalized relation R = fC 0 1 ; : : : ; C 0 49 4.3 Closed-form Bottom-up Evaluation The usual approach to query evaluation for Datalog C is a variation on the bottom-up evaluation algorithm <ref> [100] </ref>. In its simplest form a bottom-up evaluation algorithm is defined as follows: Definition 4.7 (Interpretation) Let R (x 1 ; : : :; x k ) be an atom and C 2 C a constraint such that F V (C) F V (R). <p> However, the TP operator has to operate on infinite ground interpretations. This arrangement also shows how other evaluation procedures based on the TP operator can be utilized for constraint query evaluation, e.g., the semi-naive bottom-up evaluation (cf. Chapter 7 or <ref> [100] </ref>). To show termination of Algorithm 4.10 we need: 51 Theorem 4.13 (Termination) Let C be a constraint-compact class of constraints. Then Algorithm 4.10 terminates for every query. P r o o f: By contradiction: assume that Algorithm 4.10 does not terminate. <p> This can be easily seen, as every positive existential query can be written as a non-recursive Datalog C program <ref> [100] </ref>. However, to use this methodology to evaluate all first-order queries over the constraint databases we need to extend the definition of the constraint class by allowing some sort of complementation: Definition 4.23 (Constraint Class closed under complementation) Let C be a constraint class. <p> The correctness of the evaluation and the termination of it is guaranteed for all classes of constraints that are constraint-compact. 4.7 Related Work This chapter is based on a generalization of the concepts present in the specific results on various concrete constraint query languages, e.g., <ref> [55, 60, 96, 100] </ref>. We have extracted the common underlying ideas and shown general properties of the abstracted model. A similar approach can be found in [51] for the general constraint logic programming languages. <p> P (Z) [87] [76] N,Z 1S NC PSPACE-comp PSPACE-comp [74] [23] [23] R &lt;; + NC undec. undec. [37] ) undec. undec. [71, 11] N,Z lrp in PTIME undec. undec. [55] R +; fl NC undec. undec. [60, 14, 72] Z +; fl undec. undec. undec. [46] 1 safe queries <ref> [100] </ref>; the answers have to be finite relations. 2 inflationary semantics. 3 syntactically restricted stratified Datalog : ; cf. Section 5.5 4 data complexity. 5 for a fixed set of modulo factors (cf. Chapter 5). <p> However, neither of them seems to address all three requirements. The first approach is based on the fixpoint (bottom-up) evaluation of the rules. (cf. Chapter 4). Here the first condition is usually met, e.g., for Datalog <ref> [100] </ref>, Datalog with 79 integer constraints in Chapter 5 and [73, 96], and sets [85]. However, the classes of allowed constraints are restricted to guarantee termination. Also, the evaluation process is not goal-oriented and thus the evaluation of the partially instantiated queries is quite inefficient 1 . <p> Application of program transformation techniques does not solve this problem in general. 2 Even in cases when termination cannot be guaranteed, the algorithm reduces the possibility of non termination. 80 7.2 Goal-oriented Evaluation Strategies There are several standard improvements to the naive bottom-up query evaluation algorithm, e.g., the semi-naive Algorithm <ref> [100] </ref>. However, such strategies fail to consider the information contained in a partially instantiated query (i.e., they are not goal-oriented). There are two major approaches to solving this problem in the framework of standard Datalog: 1. <p> However, the method proposed there allows only propagation of constants (i.e., constraints of the form x = a); the constraint part of the query is essentially computed bottom-up. Our approach allows full propagation of all possible constraints during the whole evaluation process. In <ref> [100] </ref> the bottom-up approach equipped with a query transformation phase is shown to be no worse than the top-down approach for restricted classes of Datalog programs over ground relations. <p> Bibliographical Notes An introduction to the topic of query processing can be found from many sources. An in depth analysis of the bottom-up evaluation can be found in the second volume of Ullman's 98 book <ref> [100] </ref>. An overview of different deductive query evaluation strategies with brief descrip-tion of each of the methods can be also found in [9]. Here both the top-down and bottom-up strategies are discussed and their relative performance is analyzed.
Reference: [101] <author> Vardi, M. Y. </author> <title> The Complexity of Relational Query Languages. </title> <booktitle> In ACM SIGACT Symposium on Theory of Computing, </booktitle> <pages> pp 137-146, </pages> <year> 1982. </year>
Reference: [102] <author> Vardi M.Y. </author> <title> A Temporal Fixpoint Calculus. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1988. </year>
Reference-contexts: Expressive completeness cannot be achieved using more general temporal logic, e.g., the many-dimensional first-order temporal logic [42]. Note also that we restrict our attention solely to the first-order languages. Thus any higher-order properties (e.g., the property relations even cardinality given in <ref> [102] </ref>) are not expressible in either 2-FOL or FOTL. 1 Assuming closure with respect to the database schema, where all the temporal relations, including derived ones, have exactly one temporal attribute or, in general, a bounded number of such attributes.
Reference: [103] <author> Warren, D. H. D. </author> <title> An Abstract Prolog Instruction Set, </title> <type> Tech. Report 309, </type> <institution> SRI International, AI Center, Palo Alto, </institution> <year> 1983. </year>
Reference-contexts: However, termination for all queries is often sacrificed (an exception is [90], where no constraints are allowed) in order to improve the expressiveness and efficiency. These methods can also take full advantage of compilation techniques developed for other logic programming languages, e.g., <ref> [91, 103] </ref>. This greatly improves the practical efficiency of query evaluation [90] in the case of Datalog. We show that similar results can be achieved in the case of constraint databases as well. In this chapter we try to combine the advantages of both the approaches. <p> Also, the constraints specify complex relations between individual variables, which is not possible in the standard approach. Development of such a representation enables building of very efficient query evaluation engines based on partial evaluation of the atomic constraints in a given class, similar to the WAM abstract code <ref> [103] </ref>. Analysis of binding patterns. Similar to the MST transformation, the queries can be analyzed to determine the flow of information in clause bodies [70].
Reference: [104] <author> Weil, A. </author> <title> Basic number theory. </title> <publisher> 3ed. Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: Bibliographical Notes The work on the combination of Datalog rules with integer order constraints was pursued in [73]. Integer based constraint queries have also been proposed in [55]. Most of the results about integers can be easily found in books on number theory, e.g., <ref> [48, 104] </ref> or [82] (if you read Polish). Other useful results about cyclic groups Z n can be found in books on group theory and modern algebra in general, e.g., [10]. 73 Chapter 6 Other Constraint Classes This section surveys several other known constraint classes, and summarizes their properties.

References-found: 104

