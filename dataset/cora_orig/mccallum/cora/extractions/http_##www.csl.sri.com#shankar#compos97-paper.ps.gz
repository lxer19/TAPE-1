URL: http://www.csl.sri.com/shankar/compos97-paper.ps.gz
Refering-URL: http://www.csl.sri.com/shankar/
Root-URL: 
Email: shankar@csl.sri.com  
Phone: Phone: +1 (415) 859-5272 Fax: +1 (415) 859-2844  
Title: Lazy Compositional Verification  
Author: Natarajan Shankar 
Web: URL: http://www.csl.sri.com/~shankar/  
Address: Menlo Park CA 94025 USA  
Affiliation: Computer Science Laboratory SRI International  
Abstract: Existing methodologies for the verification of concurrent systems are effective for reasoning about global properties of small systems. For large systems, these approaches become expensive both in terms of computational and human effort. A compositional verification methodology can reduce the verification effort by allowing global system properties to be derived from local component properties. For this to work, each component must be viewed as an open system interacting with a well-behaved environment. Much of the emphasis in compositional verification has been on the assume-guarantee paradigm where component properties are verified contingent on properties that are assumed of the environment. We highlight an alternate paradigm called lazy composition where the component properties are proved by composing the component with an abstract environment. We present the main ideas underlying lazy composition along with illustrative examples, and contrast it with the assume-guarantee approach. The main advantage of lazy composition is that the proof that one component meets the expectations of the other components, can be delayed till sufficient detail has been added to the design.
Abstract-found: 1
Intro-found: 1
Reference: [AH96] <author> Rajeev Alur and Thomas A. Henzinger. </author> <title> Reactive modules. </title> <booktitle> In Proceedings, 11 th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 207-218, </pages> <address> New Brunswick, New Jersey, 27-30 July 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Kupferman and Vardi [KV96] analyze the complexity of various linear and branching-time variants of modular model checking. Alur and Hen-zinger <ref> [AH96] </ref> give an assume-guarantee rule for proving language containment in the context of the synchronous composition of a form of Mealy machines called reactive modules. 3 Lazy Composition Lazy composition differs from the assume-guarantee approach in several respects. 9 1. Components are not treated as blackboxes.
Reference: [AL93] <author> Martn Abadi and Leslie Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <year> 1993. </year>
Reference-contexts: Compositional Verification Using the Assume-Guarantee Approach. The assume-guarantee approach originally proposed by Jones [Jon83] and Misra and Chandy [MC81] is perhaps the most widely studied compositional verification 7 technique for concurrent systems. The presentation of this approach given below is adapted from Abadi, Lamport, and Plotkin <ref> [AL93, AL95, AP93] </ref> and Col-lette [Col94]. An assume-guarantee specification of a a component property is given as a pair (A; C) consisting of an assumption property A and a guarantee property C. To capture (A; C) is defined as A + .
Reference: [AL95] <author> Martn Abadi and Leslie Lamport. </author> <title> Conjoining specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(3) </volume> <pages> 507-534, </pages> <year> 1995. </year> <month> 22 </month>
Reference-contexts: Compositional Verification Using the Assume-Guarantee Approach. The assume-guarantee approach originally proposed by Jones [Jon83] and Misra and Chandy [MC81] is perhaps the most widely studied compositional verification 7 technique for concurrent systems. The presentation of this approach given below is adapted from Abadi, Lamport, and Plotkin <ref> [AL93, AL95, AP93] </ref> and Col-lette [Col94]. An assume-guarantee specification of a a component property is given as a pair (A; C) consisting of an assumption property A and a guarantee property C. To capture (A; C) is defined as A + . <p> 1 and P 2 are specified to allow environment transitions, the composition of P 1 and P 2 includes all the interleavings of P 1 and P 2 actions, but also contains computations with simultaneous P 1 and P 2 actions. 4 The main compositionality rule in the assume-guarantee method <ref> [AL95] </ref> is stated in Theorem 1. Theorem 1. P i j= A i . C i ; for i = 1; 2 1 ^ C S j= A . (C 1 ^ C 2 . <p> Blackbox assume-guarantee specifications can be independently refined to yield implementations in terms of smaller blackbox components. Abadi and Lamport <ref> [AL95] </ref> give a decomposition rule for showing that P 0 kQ 0 refines P kQ when P 0 refines P and Q 0 refines Q. <p> Composition is not necessarily conjunction. Conjunction can be used to define the interleaving composition of two asynchronous transition systems by a suitably chosen global constraint (see <ref> [AL95] </ref> and Footnote 4). Instead of encoding composition using conjunction, we regard the definition of the precise notion of composition as something that is fixed by the model of computation and not by the inference rule for composition. <p> This examples has been frequently used with minor variations in the compositionality literature <ref> [Col93, AL95] </ref>. A single (bounded or unbounded) FIFO buffer component shown in Figure 3 consists of a buffer variable b that contains a queue of values, and the input and output variables in and out which contain values or are empty, i.e., contain a distinguished value ?. <p> Given the definition of composition extended with fairness conditions, the definitions of the operations and fi remain unchanged from Section 3. The property preservation results claimed in Theorem 2 also holds in the presence of fairness conditions. 5 Abadi and Lamport <ref> [AL95] </ref> state this constraint differently by requiring each r i to be a possible program action.
Reference: [AP93] <author> Martn Abadi and Gordon D. Plotkin. </author> <title> A logical view of composition. </title> <journal> The--oretical Computer Science, </journal> <volume> 114(1) </volume> <pages> 3-30, </pages> <year> 1993. </year>
Reference-contexts: Compositional Verification Using the Assume-Guarantee Approach. The assume-guarantee approach originally proposed by Jones [Jon83] and Misra and Chandy [MC81] is perhaps the most widely studied compositional verification 7 technique for concurrent systems. The presentation of this approach given below is adapted from Abadi, Lamport, and Plotkin <ref> [AL93, AL95, AP93] </ref> and Col-lette [Col94]. An assume-guarantee specification of a a component property is given as a pair (A; C) consisting of an assumption property A and a guarantee property C. To capture (A; C) is defined as A + .
Reference: [AS85] <author> B. Alpern and F. B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21(4) </volume> <pages> 181-185, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: Safety Properties. A safety property informally asserts that nothing bad happens during a computation. Let [i] represent the finite prefix consisting of the first i states (0) : : : (i 1) of . A safety property <ref> [AS85] </ref> is one that excludes an infinite sequence exactly when it excludes all extensions [i] ffi of some finite prefix [i] of . This means that safety properties are falsified by some finite prefix of a sequence.
Reference: [Bar85] <author> H. Barringer. </author> <title> A Survey of Verification Techniques for Parallel Programs, </title> <booktitle> volume 191 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference: [BSW69] <author> K. A. Bartlett, R. A. Scantlebury, and P. T. Wilkinson. </author> <title> A note on reliable full-duplex transmission over half-duplex links. </title> <journal> Communications of the ACM, 12(5):260, </journal> <volume> 261, </volume> <month> May </month> <year> 1969. </year>
Reference-contexts: Thus lazy composition modularizes the global reasoning by identifying suitable abstractions for the environment of each component. 21 7.1 Other Applications of Lazy Composition We have employed lazy composition in the verification of the safety properties of an N -process mutual exclusion algorithm [Sha97] and the alternating-bit communication protocol <ref> [BSW69] </ref>. These verifications have been carried out using PVS [ORS92]. The mutual exclusion algorithm has been verified using a combination of induction, abstraction, and model checking.
Reference: [CES86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Martn Abadi and Leslie Lamport prompt and helpful in their responses to various technical queries and with feedback on earlier drafts. Fig. 1. Even number generator process algebras [Hoa85,Mil80], and verification methods [Bar85,dBdRR90,dB-dRR94, Sha93a] based on deduction [Eme90, Lam94, MP92, CM88] and model checking <ref> [CES86, Kur93, Hol91] </ref>. While these techniques are effective on small examples|mutual exclusion, basic cache consistency algorithms, and simple communication protocols|the difficult problem of scaling these techniques up to large and realistic systems has remained largely unsolved.
Reference: [CM88] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1988. </year>
Reference-contexts: Martn Abadi and Leslie Lamport prompt and helpful in their responses to various technical queries and with feedback on earlier drafts. Fig. 1. Even number generator process algebras [Hoa85,Mil80], and verification methods [Bar85,dBdRR90,dB-dRR94, Sha93a] based on deduction <ref> [Eme90, Lam94, MP92, CM88] </ref> and model checking [CES86, Kur93, Hol91]. While these techniques are effective on small examples|mutual exclusion, basic cache consistency algorithms, and simple communication protocols|the difficult problem of scaling these techniques up to large and realistic systems has remained largely unsolved. <p> Examples of such logics include Manna and Pnueli's LTL [MP92] with the temporal operators fl (next-time), 2 (always), and 3 (eventually). Properties expressed in LTL that use the fl operator are not necessarily stuttering invariant. - Chandy and Misra's Unity <ref> [CM88] </ref> with operators invariant, stable, unless, until, and leadsto which are applied to state predicates so that temporal formulas are not nested. Unity properties are stuttering invariant.
Reference: [CMP94] <author> Edward Chang, Zohar Manna, and Amir Pnueli. </author> <title> Compositional verification of real-time systems. </title> <booktitle> In Proceedings, Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 458-465, </pages> <address> Paris, France, 4-7 July 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [Col93] <author> P. Collette. </author> <title> Application of the composition principle to Unity-like specifications. </title> <editor> In M.-C. Gaudel and J.-P. Jouannaud, editors, </editor> <booktitle> Proceedings of TAPSOFT '93, volume 668 of Lecture Notes in Computer Science, </booktitle> <pages> pages 230-242, </pages> <address> Berlin, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This examples has been frequently used with minor variations in the compositionality literature <ref> [Col93, AL95] </ref>. A single (bounded or unbounded) FIFO buffer component shown in Figure 3 consists of a buffer variable b that contains a queue of values, and the input and output variables in and out which contain values or are empty, i.e., contain a distinguished value ?.
Reference: [Col94] <author> Pierre Collette. </author> <title> An explanatory presentation of composition rules for assumption-commitment specifications. </title> <journal> Information Processing Letters, </journal> <volume> 50(1) </volume> <pages> 31-35, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: The assume-guarantee approach originally proposed by Jones [Jon83] and Misra and Chandy [MC81] is perhaps the most widely studied compositional verification 7 technique for concurrent systems. The presentation of this approach given below is adapted from Abadi, Lamport, and Plotkin [AL93, AL95, AP93] and Col-lette <ref> [Col94] </ref>. An assume-guarantee specification of a a component property is given as a pair (A; C) consisting of an assumption property A and a guarantee property C. To capture (A; C) is defined as A + .
Reference: [dBdRR90] <editor> J. W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors. </editor> <title> Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, </title> <booktitle> volume 430 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference: [dBdRR94] <editor> J. W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors. </editor> <title> A Decade of Concurrency: Reflections and Perspectives, </title> <booktitle> volume 803 of Lecture Notes in Computer Science, </booktitle> <address> Noordewijkerhout, The Netherlands, 1994. </address> <publisher> Springer Verlag. </publisher>
Reference: [Eme90] <author> E. Allen Emerson. </author> <title> Temporal and modal logic. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 16, </booktitle> <pages> pages 995-1072. </pages> <publisher> Elsevier and MIT press, </publisher> <address> Amster-dam, The Netherlands, and Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Martn Abadi and Leslie Lamport prompt and helpful in their responses to various technical queries and with feedback on earlier drafts. Fig. 1. Even number generator process algebras [Hoa85,Mil80], and verification methods [Bar85,dBdRR90,dB-dRR94, Sha93a] based on deduction <ref> [Eme90, Lam94, MP92, CM88] </ref> and model checking [CES86, Kur93, Hol91]. While these techniques are effective on small examples|mutual exclusion, basic cache consistency algorithms, and simple communication protocols|the difficult problem of scaling these techniques up to large and realistic systems has remained largely unsolved.
Reference: [GL94] <author> Orna Grumberg and David E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: Verification approaches based on model checking also fail to scale up gracefully since the global state space that has to be explored can grow exponentially in the number of components <ref> [GL94] </ref>. The purpose of a compositional verification approach is therefore to shift the burden of verification from the global level to the local, component level so that global properties are established by composing together independently verified component properties. <p> We can then apply premise 3 with the definitions of the connectives + . and . to obtain 2 C. There are some approaches to modular verification based on model checking that employ a weak form of assume-guarantee reasoning. In the work of Grumberg and Long <ref> [GL94] </ref>, assume-guarantee properties (A; C) are treated as implications A C and not A + . C.
Reference: [Hoa85] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall International Series in Computer Science. Prentice Hall, </publisher> <address> Hemel Hempstead, UK, </address> <year> 1985. </year>
Reference-contexts: For asynchronous composition, one takes the interleaving of the atomic actions of each component, whereas for synchronous composition, i.e., globally clocked systems, one takes the conjunction of the atomic actions. Other formalisms that have asynchronously operating components with synchronous communication, e.g., CSP <ref> [Hoa85] </ref>, can be modelled by means of a suitable definition of composition. 3. Environment assumptions are specified as abstract components not properties. One difficulty with environment assumptions as properties is that they apply to both the environment and the component.
Reference: [Hol91] <author> G. J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Martn Abadi and Leslie Lamport prompt and helpful in their responses to various technical queries and with feedback on earlier drafts. Fig. 1. Even number generator process algebras [Hoa85,Mil80], and verification methods [Bar85,dBdRR90,dB-dRR94, Sha93a] based on deduction [Eme90, Lam94, MP92, CM88] and model checking <ref> [CES86, Kur93, Hol91] </ref>. While these techniques are effective on small examples|mutual exclusion, basic cache consistency algorithms, and simple communication protocols|the difficult problem of scaling these techniques up to large and realistic systems has remained largely unsolved.
Reference: [Hoo91] <author> J. Hooman. </author> <title> Specification and Compositional Verification of Real-Time Systems, </title> <booktitle> volume 558 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference: [Jon83] <author> C. B. Jones. </author> <title> Tentative steps toward a development method for interfering programs. </title> <journal> ACM TOPLAS, </journal> <volume> 5(4) </volume> <pages> 596-619, </pages> <year> 1983. </year> <month> 23 </month>
Reference-contexts: Such program-based proof methods can be quite restrictive when compared to the use of high-level behavioral specifications as given by asynchronous transition systems. Compositional Verification Using the Assume-Guarantee Approach. The assume-guarantee approach originally proposed by Jones <ref> [Jon83] </ref> and Misra and Chandy [MC81] is perhaps the most widely studied compositional verification 7 technique for concurrent systems. The presentation of this approach given below is adapted from Abadi, Lamport, and Plotkin [AL93, AL95, AP93] and Col-lette [Col94].
Reference: [Jos90] <author> B. Josko. </author> <title> Verifying the correctness of AADL modules using model check-ing. </title> <editor> In de Bakker et al. </editor> <booktitle> [dBdRR90], </booktitle> <pages> pages 386-400. </pages>
Reference-contexts: If C is a CTL or CTL* formula, then the situation is more complicated since the implication A C is not a well formed CTL or CTL* state formula, and furthermore, it does not capture the intended meaning of A as an assumption <ref> [Jos90] </ref> which is that C must hold on the computation tree whose paths have been pruned according to A. Then, A can be chosen as a 8CTL formula that characterizes the subtree of the computation tree that meets the assumption.
Reference: [Kur93] <author> R.P. Kurshan. </author> <title> Automata-Theoretic Verification of Coordinating Processes. </title> <publisher> Princeton University Press, </publisher> <address> Princeton, NJ, </address> <year> 1993. </year>
Reference-contexts: Martn Abadi and Leslie Lamport prompt and helpful in their responses to various technical queries and with feedback on earlier drafts. Fig. 1. Even number generator process algebras [Hoa85,Mil80], and verification methods [Bar85,dBdRR90,dB-dRR94, Sha93a] based on deduction [Eme90, Lam94, MP92, CM88] and model checking <ref> [CES86, Kur93, Hol91] </ref>. While these techniques are effective on small examples|mutual exclusion, basic cache consistency algorithms, and simple communication protocols|the difficult problem of scaling these techniques up to large and realistic systems has remained largely unsolved.
Reference: [KV96] <author> O. Kupferman and M. Y. Vardi. </author> <title> Module checking. </title> <editor> In R. Alur and T. A. Henzinger, editors, </editor> <booktitle> Computer-Aided Verification96, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 75-86. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: For the case of 8CTL assumptions and synchronous Moore machine composition, Grumberg and Long give a way of compiling the assumption A into a tableau automaton A T so that P kA T j= C iff P j= A C. Kupferman and Vardi <ref> [KV96] </ref> analyze the complexity of various linear and branching-time variants of modular model checking.
Reference: [Lam94] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM TOPLAS, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Martn Abadi and Leslie Lamport prompt and helpful in their responses to various technical queries and with feedback on earlier drafts. Fig. 1. Even number generator process algebras [Hoa85,Mil80], and verification methods [Bar85,dBdRR90,dB-dRR94, Sha93a] based on deduction <ref> [Eme90, Lam94, MP92, CM88] </ref> and model checking [CES86, Kur93, Hol91]. While these techniques are effective on small examples|mutual exclusion, basic cache consistency algorithms, and simple communication protocols|the difficult problem of scaling these techniques up to large and realistic systems has remained largely unsolved. <p> Unity properties are stuttering invariant. Lamport's temporal logic of actions <ref> [Lam94] </ref> which drops the next-time operator from linear-time temporal logic but allows temporal operators to range over actions, i.e., binary relations over states. TLA is designed to admit only stuttering invariant properties. In the examples below, we restrict ourselves to some simple operators for defining properties. <p> With some constraint on the environment actions, one can actually verify reasonably interesting local properties of a component. For example, in TLA <ref> [Lam94] </ref>, the next-state relation of a component is written as [N ] f which holds of a pair of states s, s 0 when N (s; s 0 ) _ f (s 0 ) = f (s).
Reference: [LT87] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proceedings of the sixth Annual Symposium on Principles of Distributed Computing, </booktitle> <address> New York, </address> <pages> pages 137-151. </pages> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: The state function f typically projects out the local variables of the component so that the environment transitions must not affect the values of these variables. In Lynch and Tuttle's I/O automata <ref> [LT87] </ref>, a component is an input-enabled automaton with its own local state so that any component properties established with respect to this interpretation remain globally valid even in composition with other components.
Reference: [MC81] <author> Jayadev Misra and K. Mani Chandy. </author> <title> Proofs of networks of processes. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 7(4) </volume> <pages> 417-426, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: Such program-based proof methods can be quite restrictive when compared to the use of high-level behavioral specifications as given by asynchronous transition systems. Compositional Verification Using the Assume-Guarantee Approach. The assume-guarantee approach originally proposed by Jones [Jon83] and Misra and Chandy <ref> [MC81] </ref> is perhaps the most widely studied compositional verification 7 technique for concurrent systems. The presentation of this approach given below is adapted from Abadi, Lamport, and Plotkin [AL93, AL95, AP93] and Col-lette [Col94].
Reference: [Mil80] <author> R. Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference: [MP92] <author> Zohar Manna and Amir Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems, Volume 1: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference-contexts: Martn Abadi and Leslie Lamport prompt and helpful in their responses to various technical queries and with feedback on earlier drafts. Fig. 1. Even number generator process algebras [Hoa85,Mil80], and verification methods [Bar85,dBdRR90,dB-dRR94, Sha93a] based on deduction <ref> [Eme90, Lam94, MP92, CM88] </ref> and model checking [CES86, Kur93, Hol91]. While these techniques are effective on small examples|mutual exclusion, basic cache consistency algorithms, and simple communication protocols|the difficult problem of scaling these techniques up to large and realistic systems has remained largely unsolved. <p> The above notions of computation and property are typical of the use of linear-time temporal logics for stating and proving properties of closed systems. Examples of such logics include Manna and Pnueli's LTL <ref> [MP92] </ref> with the temporal operators fl (next-time), 2 (always), and 3 (eventually).
Reference: [OG76] <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: We have already seen the example of the adder component of Figure 1 which can be shown to always output even numbers when given odd number inputs by its environment. The Owicki-Gries Method. The Owicki-Gries method <ref> [OG76] </ref> is the first attempt at a component-wise decomposition of the verification problem. <p> Assume-guarantee specifications are more appropriate for writing blackbox characterizations of open components rather than for compositional verification where the point is to achieve a useful decomposition of the verification task. The advantage of lazy composition with respect to non-compositional, global reasoning as characterized by the Owicki-Gries approach <ref> [OG76] </ref> is that it combines the simplicity of global reasoning with the economy of using an abstract characterization of the environment rather than the actual components in the environment. This abstract characterization can be used to prove a number of component properties.
Reference: [ORS92] <author> S. Owre, J. M. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <editor> In Deepak Kapur, editor, </editor> <booktitle> 11th International Conference on Automated Deduction (CADE), volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 748-752, </pages> <address> Saratoga, NY, June 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: These verifications have been carried out using PVS <ref> [ORS92] </ref>. The mutual exclusion algorithm has been verified using a combination of induction, abstraction, and model checking. The algorithm uses a Boolean turn variable for each process to arbitrate access to successive rounds of competition using 2-process mutual exclusion, for eventual access to the critical section. <p> This approach has several advantages over the assume-guarantee paradigm. We have formalized lazy composition verification within PVS <ref> [ORS92] </ref> and verified several medium-scale examples with this approach. We do not yet have any conclusive evidence that the method scales up to larger systems. Lazy composition can be adapted to models other than asynchronous transition systems by suitably altering the definitions of composition, conjunction, and refinement.
Reference: [PJ91] <author> P. K. Pandya and M. Joseph. </author> <title> P-A logic | a compositional proof system for distributed programs. </title> <journal> Distributed Computing, </journal> <volume> 5(1) </volume> <pages> 37-54, </pages> <year> 1991. </year>
Reference: [Pnu84] <author> A. Pnueli. </author> <title> In transition from global to modular temporal reasoning about programs. </title> <editor> In K. R. Apt, editor, </editor> <booktitle> Logic and Models of Concurrent Systems, NATO-ASI, </booktitle> <pages> pages 123-144. </pages> <publisher> Springer Verlag, </publisher> <year> 1984. </year>
Reference-contexts: The assume-guarantee paradigm is the best studied approach to compositional verification <ref> [AL93,AL95,AP93,CMP94,Col93,Hoo91,Jon83,MC81,PJ91, Pnu84, Sta85, XCC94, XdRH97, Zwi89] </ref>. In this approach, a property of a component is stated as a pair (A; C) consisting of a guarantee property C that the component will satisfy provided the environment to the component satisfies the assumption property A.
Reference: [Sch87] <author> Fred B. Schneider. </author> <title> Decomposing properties into safety and liveness using predicate logic. </title> <type> Technical Report 87-874, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, NY, </address> <month> October </month> <year> 1987. </year>
Reference-contexts: This is a contradiction since every infinite sequence must be in A L or A S . Thus every property A can be expressed as the conjunction of a safety property A S and a liveness property A L <ref> [Sch87] </ref>. Stuttering Invariance. A set of sequences A is stuttering invariant if whenever [i + 1] ffi 2 A then [i + 1] ffi (i) ffi 2 A.
Reference: [Sha93a] <author> A. Udaya Shankar. </author> <title> An introduction to assertional reasoning for concurrent systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(3) </volume> <pages> 225-262, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Martn Abadi and Leslie Lamport prompt and helpful in their responses to various technical queries and with feedback on earlier drafts. Fig. 1. Even number generator process algebras [Hoa85,Mil80], and verification methods <ref> [Bar85,dBdRR90,dB-dRR94, Sha93a] </ref> based on deduction [Eme90, Lam94, MP92, CM88] and model checking [CES86, Kur93, Hol91]. While these techniques are effective on small examples|mutual exclusion, basic cache consistency algorithms, and simple communication protocols|the difficult problem of scaling these techniques up to large and realistic systems has remained largely unsolved.
Reference: [Sha93b] <author> N. Shankar. </author> <title> A lazy approach to compositional verification. </title> <type> Technical Report SRI-CSL-93-8, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Much of the research has been devoted to the development of formalisms such as temporal logics [Eme90,Lam94,MP92,CM88] and ? Supported by the Air Force Office of Scientific Research under contract F49620-95-C0044 and by the National Science Foundation under contract CCR-9509931 and CCR-9300444. Based on earlier work <ref> [Sha93b] </ref> funded by Naval Research Laboratory (NRL) under contract N00015-92-C-2177. Connie Heitmeyer, Ralph Jeffords, and Pierre Collette gave useful feeback on the work cited above. John Rushby, Sam Owre, and Nikolaj Bjtrner provided detailed comments on drafts of this paper. <p> It is obviously not easy to anticipate all the potential constraints that might be placed on a component by the other components in a system. The lazy composition approach advocated in this paper builds on conventional techniques while avoiding the difficulties associated with the assume-guarantee approach <ref> [Sha93b] </ref>. Lazy composition works at the level of the specification of component behavior.
Reference: [Sha97] <author> N. Shankar. </author> <title> Machine-assisted verification using theorem proving and model checking. </title> <editor> In Manfred Broy and Birgit Scheider, editors, </editor> <booktitle> Mathematical Methods in Program Development, volume 158 of NATO ASI Series F: Computer and Systems Science, </booktitle> <pages> pages 499-528. </pages> <publisher> Springer, </publisher> <year> 1997. </year>
Reference-contexts: Thus lazy composition modularizes the global reasoning by identifying suitable abstractions for the environment of each component. 21 7.1 Other Applications of Lazy Composition We have employed lazy composition in the verification of the safety properties of an N -process mutual exclusion algorithm <ref> [Sha97] </ref> and the alternating-bit communication protocol [BSW69]. These verifications have been carried out using PVS [ORS92]. The mutual exclusion algorithm has been verified using a combination of induction, abstraction, and model checking.
Reference: [Sta85] <author> E. W. Stark. </author> <title> A proof technique for rely/guarantee properties. </title> <editor> In S. N. Maheshwari, editor, </editor> <booktitle> Foundations of Software Technology and Theoretical Computer Science, volume 206 of Lecture Notes in Computer Science, </booktitle> <pages> pages 369-391. </pages> <publisher> Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The assume-guarantee paradigm is the best studied approach to compositional verification <ref> [AL93,AL95,AP93,CMP94,Col93,Hoo91,Jon83,MC81,PJ91, Pnu84, Sta85, XCC94, XdRH97, Zwi89] </ref>. In this approach, a property of a component is stated as a pair (A; C) consisting of a guarantee property C that the component will satisfy provided the environment to the component satisfies the assumption property A.
Reference: [XCC94] <author> Q.-W. Xu, A. Cau, and P. Collette. </author> <title> On unifying assumption-commitment style proof rules for concurrency. </title> <editor> In B. Jonsson and J. Parrow, editors, CONCUR'94, </editor> <booktitle> volume 836 of Lecture Notes in Computer Science, </booktitle> <pages> pages 267-282. </pages> <publisher> Springer Verlag, </publisher> <year> 1994. </year> <month> 24 </month>
Reference-contexts: The assume-guarantee paradigm is the best studied approach to compositional verification <ref> [AL93,AL95,AP93,CMP94,Col93,Hoo91,Jon83,MC81,PJ91, Pnu84, Sta85, XCC94, XdRH97, Zwi89] </ref>. In this approach, a property of a component is stated as a pair (A; C) consisting of a guarantee property C that the component will satisfy provided the environment to the component satisfies the assumption property A.
Reference: [XdRH97] <author> Q.-W. Xu, W.-P. de Roever, and J.-F. </author> <title> He. The rely-guarantee method for verifying shared variable concurrent programs. </title> <journal> Formal Aspects of Computing, </journal> <volume> 9(2) </volume> <pages> 149-174, </pages> <year> 1997. </year>
Reference-contexts: The assume-guarantee paradigm is the best studied approach to compositional verification <ref> [AL93,AL95,AP93,CMP94,Col93,Hoo91,Jon83,MC81,PJ91, Pnu84, Sta85, XCC94, XdRH97, Zwi89] </ref>. In this approach, a property of a component is stated as a pair (A; C) consisting of a guarantee property C that the component will satisfy provided the environment to the component satisfies the assumption property A.
Reference: [Zwi89] <author> J. Zwiers. </author> <title> Compositionality, Concurrency and Partial Correctness, </title> <booktitle> volume 321 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1989. </year> <month> 25 </month>
Reference-contexts: The assume-guarantee paradigm is the best studied approach to compositional verification <ref> [AL93,AL95,AP93,CMP94,Col93,Hoo91,Jon83,MC81,PJ91, Pnu84, Sta85, XCC94, XdRH97, Zwi89] </ref>. In this approach, a property of a component is stated as a pair (A; C) consisting of a guarantee property C that the component will satisfy provided the environment to the component satisfies the assumption property A.
References-found: 40

