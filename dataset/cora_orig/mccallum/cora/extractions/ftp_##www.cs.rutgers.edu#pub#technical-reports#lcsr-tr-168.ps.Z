URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-168.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Title: A Safe Approximate Algorithm for Interprocedural Pointer Aliasing  
Author: William Landi Barbara G. Ryder 
Abstract: Aliasing occurs at some program point during execution when two or more names exist for the same location. In a language which allows pointers, the problem of determining the set of pairs of names at a program point which may refer to the same location during program execution is N P-hard. We present an algorithm which safely approximates Interprocedural May Alias in the presence of pointers. This algorithm has been implemented in a prototype analysis tool for C programs. fl The research reported here was supported, in part, by Siemens Research Corporation and NSF grant CCR 8920078. y Department of Computer Science, Rutgers University, New Brunswick, NJ 08903 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: An ICFG is intuitively, the union of the control flow graphs (CFGs) 3 <ref> [1] </ref> for each procedure, with calls connected to the procedures they invoke. <p> Object names provide ways to refer to objects in a program. An object name is a variable and a (possibly empty) sequence of dereferences and field accesses. A syntax-directed definition <ref> [1] </ref> for object names is in Figure 2. Because we have prohibited casting, we are only interested in object names which do not have type error.
Reference: [2] <author> J. Banning. </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> In Conference Record of the Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 29-41, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: When this execution path traverses more than one procedure, we are solving the Interprocedural May Alias Problem. While the calculation of aliases for FORTRAN is well understood <ref> [2, 6, 7, 17] </ref>, if general pointers are added as a language construct, the problem of computing aliases becomes N P-hard and no good approximation algorithms exist. Moreover, aliases complicate most data flow analysis problems, and the absence of alias information can prevent many optimizations.
Reference: [3] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 25, No 6. </volume>
Reference-contexts: This method seems unsuitable for an implementation and is reminiscent of the work of Sharir and Pnueli [18]. A related area of research is the work done by the compiling community on conflict detection in recursive structures <ref> [3, 8, 9, 11, 16] </ref>. A conflict occurs between two statements when one statement writes a location and the other accesses (reads or writes) the same location, thus preventing the possibility of those statements being executed in parallel (i.e., in arbitrary order). <p> We use a solution that is roughly analogous to k-limited as defined by Jones and Muchnick [10]. Less naive schemes have be developed <ref> [3, 8, 9, 16] </ref>, but we have yet to examine their suitability for our purposes. Object names provide ways to refer to objects in a program. An object name is a variable and a (possibly empty) sequence of dereferences and field accesses.
Reference: [4] <author> A. Chow and A. Rudmik. </author> <title> The design of a data flow analyzer. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 106-113, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: Our analysis generally reports that almost all variables could be modified. This is because Weihl's algorithm does not give information of sufficient precision to be useful for this problem. Some empirical observations on the precision of Weihl's algorithm can be found in [14]. Chow and Rudmik <ref> [4] </ref> also presented an algorithm for finding aliases in the presence of pointers.
Reference: [5] <author> B. G. Cooper. </author> <title> Ambitious data flow analysis of procedural programs. </title> <type> Master's thesis, </type> <institution> University of Minnesota, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Their algorithm suffers because they treat interprocedural alias as an intraprocedural problem; that is, they do not consider that when a procedure returns, control passes to the call site which invoked 3 it, and they handle local variables incorrectly. Benjamin Cooper <ref> [5] </ref> has developed an algorithm which uses explicit path information in the form of alias histories to insure (for interprocedural paths) that a procedure returns to the call site that invoked it. This method seems unsuitable for an implementation and is reminiscent of the work of Sharir and Pnueli [18].
Reference: [6] <author> K. Cooper. </author> <title> Analyzing aliases of reference formal parameters. </title> <booktitle> In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 281-290, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: When this execution path traverses more than one procedure, we are solving the Interprocedural May Alias Problem. While the calculation of aliases for FORTRAN is well understood <ref> [2, 6, 7, 17] </ref>, if general pointers are added as a language construct, the problem of computing aliases becomes N P-hard and no good approximation algorithms exist. Moreover, aliases complicate most data flow analysis problems, and the absence of alias information can prevent many optimizations.
Reference: [7] <author> K. Cooper and K. Kennedy. </author> <title> Fast interprocedural alias analysis. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-59, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: When this execution path traverses more than one procedure, we are solving the Interprocedural May Alias Problem. While the calculation of aliases for FORTRAN is well understood <ref> [2, 6, 7, 17] </ref>, if general pointers are added as a language construct, the problem of computing aliases becomes N P-hard and no good approximation algorithms exist. Moreover, aliases complicate most data flow analysis problems, and the absence of alias information can prevent many optimizations.
Reference: [8] <author> L. J. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <booktitle> In Proceedings of the 1989 International Conference on Parallel Processing, </booktitle> <pages> pages 49-56, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: This method seems unsuitable for an implementation and is reminiscent of the work of Sharir and Pnueli [18]. A related area of research is the work done by the compiling community on conflict detection in recursive structures <ref> [3, 8, 9, 11, 16] </ref>. A conflict occurs between two statements when one statement writes a location and the other accesses (reads or writes) the same location, thus preventing the possibility of those statements being executed in parallel (i.e., in arbitrary order). <p> We use a solution that is roughly analogous to k-limited as defined by Jones and Muchnick [10]. Less naive schemes have be developed <ref> [3, 8, 9, 16] </ref>, but we have yet to examine their suitability for our purposes. Object names provide ways to refer to objects in a program. An object name is a variable and a (possibly empty) sequence of dereferences and field accesses.
Reference: [9] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 28-40, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: This method seems unsuitable for an implementation and is reminiscent of the work of Sharir and Pnueli [18]. A related area of research is the work done by the compiling community on conflict detection in recursive structures <ref> [3, 8, 9, 11, 16] </ref>. A conflict occurs between two statements when one statement writes a location and the other accesses (reads or writes) the same location, thus preventing the possibility of those statements being executed in parallel (i.e., in arbitrary order). <p> We use a solution that is roughly analogous to k-limited as defined by Jones and Muchnick [10]. Less naive schemes have be developed <ref> [3, 8, 9, 16] </ref>, but we have yet to examine their suitability for our purposes. Object names provide ways to refer to objects in a program. An object name is a variable and a (possibly empty) sequence of dereferences and field accesses.
Reference: [10] <author> N. Jones and S. Muchnick. </author> <title> Flow analysis and optimization of lisp-like structures. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 102-131. </pages> <publisher> Prentice Hall, </publisher> <year> 1979. </year>
Reference-contexts: Any aliasing algorithm will have to represent all possible objects by a finite (polynomial) number of objects. We use a system of k-limiting similar to that defined by Jones and Muchnick <ref> [10] </ref>. There is a second source of approximation illustrated by the following scenario. <p> Thus, any practical alias algorithm will have to represent the set of all possible objects and the alias relationships between those objects with a (small) finite data structure. We use a solution that is roughly analogous to k-limited as defined by Jones and Muchnick <ref> [10] </ref>. Less naive schemes have be developed [3, 8, 9, 16], but we have yet to examine their suitability for our purposes. Object names provide ways to refer to objects in a program. An object name is a variable and a (possibly empty) sequence of dereferences and field accesses. <p> Thus, for k = 1, p-&gt;f 1 -&gt;f 2 would be represented by p-&gt;f 1 (and not by flp). We will borrow Jones and Muchnick <ref> [10] </ref> terminology and call this k-limiting, even though they k-limit dynamic structures while we k-limit object names because the two processes are analogous.
Reference: [11] <author> N. D. Jones and S. S. Muchnick. </author> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: This method seems unsuitable for an implementation and is reminiscent of the work of Sharir and Pnueli [18]. A related area of research is the work done by the compiling community on conflict detection in recursive structures <ref> [3, 8, 9, 11, 16] </ref>. A conflict occurs between two statements when one statement writes a location and the other accesses (reads or writes) the same location, thus preventing the possibility of those statements being executed in parallel (i.e., in arbitrary order).
Reference: [12] <author> H. Korth and A. Silberschatz. </author> <title> Database System Concepts. </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1986. </year>
Reference-contexts: We do not do this because, even for single level pointers, this would require at least O (n fl v 4 ) space. 8 The solution we choose is to do dynamic hashing. We use the dynamic hashing scheme presented in <ref> [12] </ref> (except we did not implement table shrinking as, for our purposes, this is never needed) giving us constant time operations in the average case. We implement the needed operations as follows: * Set may-hold ([(node;AA); PA]) to f alse for all possible node,AA, and PA.
Reference: [13] <author> W. Landi. </author> <title> Interprocedural Aliasing in the Presence of Pointers. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <year> 1991. </year> <note> in preparation. </note>
Reference-contexts: Fortunately, it is only necessary to consider AA (sets of aliases) with cardinality less than or equal to one <ref> [13] </ref>. In the second step, we use Conditional May Alias to solve for May Alias using a simple fixed point calculation. This algorithm is precise under the standard assumptions of data flow analysis (i.e., up to symbolic execution). <p> Currently, we are testing our algorithm on small C programs <ref> [13] </ref>. We believe it will be shown a practical and efficient technique. 41 Appendix A: Dictionary of Functions address type (type) returns the type of the objects which can point to type. (Section 2.2) alias consequences (alias) is the set of all aliases that are implied by alias.
Reference: [14] <author> W. Landi and B. G. Ryder. </author> <title> Aliasing with and without pointers: A problem taxonomy. </title> <institution> Center for Computer Aids for Industrial Productivity Technical Report CAIP-TR-125, Rutgers University, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: Unfortunately his algorithm is very imprecise. In fact on a simple program (straight line code) which has O (n) aliases, where n is the number of variables in the program, Weihl reports O (n 2 ) aliases <ref> [14] </ref>. We have solved the modification side effect problem on several C programs using Weihl's algorithm to determine the aliases. Our analysis generally reports that almost all variables could be modified. This is because Weihl's algorithm does not give information of sufficient precision to be useful for this problem. <p> Our analysis generally reports that almost all variables could be modified. This is because Weihl's algorithm does not give information of sufficient precision to be useful for this problem. Some empirical observations on the precision of Weihl's algorithm can be found in <ref> [14] </ref>. Chow and Rudmik [4] also presented an algorithm for finding aliases in the presence of pointers.
Reference: [15] <author> W. Landi and B. G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: We do allow arrays and pointer arithmetic, however we deal with these on a very simple and naive level. 2.1 Interprocedural Control Flow Graph We represent programs by interprocedural control flow graphs, (ICFGs) originally presented in <ref> [15] </ref>. An ICFG is intuitively, the union of the control flow graphs (CFGs) 3 [1] for each procedure, with calls connected to the procedures they invoke. <p> As in <ref> [15] </ref> we will represent aliases by unordered pairs of object names (for example, hv; flpi). The order is unimportant because the alias relation is symmetric. While for the single level pointer case this is adequate, now because of k-limiting of object names it is not. <p> This means that if x is a local variable of procedure P , then the x in P before a recursive call is not visible after the call, since at execution time it is a different instantiation. 3 The may-hold Relation 3.1 Conditional May Alias: Definition In <ref> [15] </ref>, we present a two step algorithm for finding Interprocedural May Alias on programs that have single level pointers as the only mechanism for creating aliases. <p> Thus any single assumption can safely be considered as the only assumption. Thus, 12 we will continue to deal with sets of assumed aliases of size one or less, but this will now be an approximation. The second obstacle is one of practicality. As the algorithm is described in <ref> [15] </ref>, we must compute holds ([(node;AA); PA]) for every possible triple: node in the ICFG, AA, and PA. <p> To insure efficiency, we will present our algorithm differently than in <ref> [15] </ref>. We will calculate holds in a demand driven fashion so that we will only concern ourselves with holds ([(node; AA); PA]) which have the value true. <p> Consider the following example (where q is global to P but r is not and q,r, and f are all type "int *"): 9 In <ref> [15] </ref> we referred to this by "". 17 * fi call P (q) ? * fi entry P (f) store 1 : q ? s store 2 : f @ @R s non visible bind (call P (q) ,;) = fhflq; flfig bind (call P (q) ,hflq; flri) = ( (hflq; <p> Effects on corresponding entry node (entry) While holds (as defined in <ref> [15] </ref>) had the nice property that the holds relations which were true at a call node did not affect the hold relations at the entry of the called procedure, this is not true for may-hold since it requires the existence of a path to the entry node with certain characteristics whereas <p> ha; bi 2 bind call (hc; di) and back-bind 0 call (ha; non visiblei ; o) = hc; di iff ha; non visiblei 2 bind call (hc; di) where the non visible is the non visible object name o. explanation of why those rules are valid see Section 3.2 of <ref> [15] </ref>). may-hold is a simple encoding of these rules with a few minor modifications. The holds rules are still valid for may-hold because may-hold is basically holds with the added restriction that the assumed alias must hold on some path the the entry node of the procedure of interest.
Reference: [16] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <month> July </month> <year> 1988. </year> <journal> SIGPLAN NOTICES, </journal> <volume> Vol. 23, No. </volume> <pages> 7. </pages>
Reference-contexts: This method seems unsuitable for an implementation and is reminiscent of the work of Sharir and Pnueli [18]. A related area of research is the work done by the compiling community on conflict detection in recursive structures <ref> [3, 8, 9, 11, 16] </ref>. A conflict occurs between two statements when one statement writes a location and the other accesses (reads or writes) the same location, thus preventing the possibility of those statements being executed in parallel (i.e., in arbitrary order). <p> We use a solution that is roughly analogous to k-limited as defined by Jones and Muchnick [10]. Less naive schemes have be developed <ref> [3, 8, 9, 16] </ref>, but we have yet to examine their suitability for our purposes. Object names provide ways to refer to objects in a program. An object name is a variable and a (possibly empty) sequence of dereferences and field accesses.
Reference: [17] <author> E. M. Myers. </author> <title> A precise interprocedural data flow algorithm. </title> <booktitle> In Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 219-230, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: When this execution path traverses more than one procedure, we are solving the Interprocedural May Alias Problem. While the calculation of aliases for FORTRAN is well understood <ref> [2, 6, 7, 17] </ref>, if general pointers are added as a language construct, the problem of computing aliases becomes N P-hard and no good approximation algorithms exist. Moreover, aliases complicate most data flow analysis problems, and the absence of alias information can prevent many optimizations.
Reference: [18] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 189-234. </pages> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: This method seems unsuitable for an implementation and is reminiscent of the work of Sharir and Pnueli <ref> [18] </ref>. A related area of research is the work done by the compiling community on conflict detection in recursive structures [3, 8, 9, 11, 16].
Reference: [19] <author> W. E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables and label variables. </title> <type> Master's thesis, </type> <institution> M.I.T., </institution> <month> June </month> <year> 1980. </year>
Reference-contexts: Both of these facts indicate that existing FORTRAN alias algorithms are not extensible to handle pointers. Related Work Weihl devised an algorithm for finding aliases in the presence of pointers <ref> [19, 20] </ref>. Unfortunately his algorithm is very imprecise. In fact on a simple program (straight line code) which has O (n) aliases, where n is the number of variables in the program, Weihl reports O (n 2 ) aliases [14]. <p> Our algorithm is program point-specific and thus more precise than Weihl's algorithm <ref> [19] </ref>. We currently have a prototype implementation in C for analyzing C programs. 2 Problem Representation The Source Language Our algorithm finds aliases for a language that is a subset of C.
Reference: [20] <author> W. E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables and label variables. </title> <booktitle> In Conference Record of the Seventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <month> January </month> <year> 1980. </year> <month> 51 </month>
Reference-contexts: Both of these facts indicate that existing FORTRAN alias algorithms are not extensible to handle pointers. Related Work Weihl devised an algorithm for finding aliases in the presence of pointers <ref> [19, 20] </ref>. Unfortunately his algorithm is very imprecise. In fact on a simple program (straight line code) which has O (n) aliases, where n is the number of variables in the program, Weihl reports O (n 2 ) aliases [14].
References-found: 20

