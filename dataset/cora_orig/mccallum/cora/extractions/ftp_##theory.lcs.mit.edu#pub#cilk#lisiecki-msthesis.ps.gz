URL: ftp://theory.lcs.mit.edu/pub/cilk/lisiecki-msthesis.ps.gz
Refering-URL: http://theory.lcs.mit.edu/~cilk/papers.html
Root-URL: 
Title: Macro-Level Scheduling in the Cilk Network of Workstations Environment  
Author: by Philip Andrew Lisiecki 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degrees of Bachelor of Science in Computer Science and Engineering and Master of Engineering in Electrical Engineering and Computer Science at the  c Philip Andrew Lisiecki, MCMXCVI. All rights reserved. The author hereby grants to MIT permission to reproduce and distribute publicly paper and electronic copies of this thesis document in whole or in part, and to grant others the right to do so. Author  Certified by Charles E. Leiserson Professor of Computer Science and Engineering Thesis Supervisor Accepted by F. R. Morganthaler Chairman, Department Committee on Graduate Theses  
Date: May 1996  May 24, 1996  
Affiliation: MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Robert Blumofe. </author> <title> Managing Storage for Multithreaded Computations. </title> <type> PhD dissertation, </type> <institution> Mas sachusetts Institute of Technology, </institution> <year> 1995. </year>
Reference-contexts: Each job has a "micro-level" scheduler, or microscheduler, that uses this varying set of workstations, assigned by the macrosched-uler, to execute its single parallel job. This thesis presents a macroscheduler which was designed and implemented for use with the Cilk Network of Workstations (Cilk-NOW) microscheduler <ref> [1, 2] </ref>. Other research in scheduling on networks of workstations tends to focus on only one of these two levels of scheduling. Systems such as Piranha [5] focus on running a single job in parallel, using an oversimplified model to balance jobs among processors.
Reference: [2] <author> Robert Blumofe and David S. Park. </author> <title> Scheduling large-scale parallel computations on networks of workstations. </title> <booktitle> In Proceedings of the Third International Symposium on High Performance Distributed Computing, </booktitle> <address> San Francisco, California, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: Each job has a "micro-level" scheduler, or microscheduler, that uses this varying set of workstations, assigned by the macrosched-uler, to execute its single parallel job. This thesis presents a macroscheduler which was designed and implemented for use with the Cilk Network of Workstations (Cilk-NOW) microscheduler <ref> [1, 2] </ref>. Other research in scheduling on networks of workstations tends to focus on only one of these two levels of scheduling. Systems such as Piranha [5] focus on running a single job in parallel, using an oversimplified model to balance jobs among processors.
Reference: [3] <author> Robert D. Blumofe, Christopher F. Joerg, Bradley C. Kuszmaul, Charles E. Leiserson, Keith H. Randall, and Yuli Zhou. Cilk: </author> <title> An efficient multithreaded runtime system. </title> <booktitle> In Proceedings of the Fifth ACM SIGPLAN Symposium on Principal and Practice of Parallel Programming., </booktitle> <address> Santa Barbara, California, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: Monitoring the parallelism in a Cilk-NOW job might be accomplished by tracking steal attempts, whose rate is related to total communication, which in turn is closely related to the amount of work and the critical path length the job <ref> [3] </ref>. The steal rate might be used to estimate the average parallelism of a job. This information must then be integrated with the scheduling algorithm in such a way that jobs can grow rapidly when they need more processors, but not grow when the current supply of processors suffices.
Reference: [4] <author> Eric A. Brewer and Robert Blumofe. Strata: </author> <title> A multi-layer communications library. </title> <institution> M.I.T. Laboratory for Computer Science, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Small messages are sent directly as active messages, and so do not incur any overhead beyond a size comparison. This layering is reminiscent of that used by the Strata communications library <ref> [4] </ref>. 2 The active message implementation utilized by the macroscheduler works on top of UNIX's socket interface, and so does not achieve the maximal theoretical throughput. 22 secure active message data. verification overhead on each message, and realizing that different workstations might not load a program at the same address, or
Reference: [5] <author> David Gelernter and David Kaminsky. </author> <title> Supercomputer with recycled garbage: Preliminary experience with Piranha. </title> <type> Technical report, </type> <institution> Yale University, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: This thesis presents a macroscheduler which was designed and implemented for use with the Cilk Network of Workstations (Cilk-NOW) microscheduler [1, 2]. Other research in scheduling on networks of workstations tends to focus on only one of these two levels of scheduling. Systems such as Piranha <ref> [5] </ref> focus on running a single job in parallel, using an oversimplified model to balance jobs among processors. <p> Several indications, such as idle times and load averages, lend themselves to determining workstation idleness. These indicators, which have been used successfully in systems such as Piranha <ref> [5] </ref>, must be combined with conditions on when they are applicable to form a useful and flexible set of idleness criteria. <p> macroscheduler's notion of idleness "predicates," and finally, I present experimental evidence that networks of workstations managed in this way present a useful computational resource. 5.1 Detecting idleness This section discusses how idle times, the number of users, and load averages each provide some information about the idleness of a workstation <ref> [5] </ref>. Used in combination, they can gather large amounts of processing time which is practically transparent to the users of the workstations.
Reference: [6] <author> Jospeh A. Kaplan and Michael I. Nelson. </author> <title> A comparison of queueing, cluster and distributed computing systems. </title> <type> Technical report, </type> <institution> National Air and Space Administration, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: Systems such as Piranha [5] focus on running a single job in parallel, using an oversimplified model to balance jobs among processors. Other systems, such as Condor focus only on running single-processor, nonparallel batch jobs on an idle workstation. (See <ref> [6] </ref> for a comparison of various batch job systems.) The former approach neglects the practicality that multiple users may want to exploit the network of workstations to accomplish their work, while the latter approach fails 7 to utilize a significant portion of idle workstations when the number of jobs is not
Reference: [7] <author> Steven P. Miller, B. Clifford Neuman, Jeffrey I. Schiller, and Jermoe H. Saltzer. </author> <title> Kerberos au thentication and authorization system. </title> <type> Athena technical plan, </type> <institution> M.I.T. Project Athena, </institution> <month> October </month> <year> 1988. </year>
Reference-contexts: Because different installations use different protocols to administer remote execution, the macroscheduler must be easily adaptable to a variety of different authentication schemes, such as the standard UNIX rsh protocol [8, chs 9&14] or Kerberos <ref> [7] </ref>. Different authentication schemes present different demands and use different fundamental security models.
Reference: [8] <author> W. Richard Stevens. </author> <title> UNIX Network Programming. </title> <publisher> Prentice Hall Software Series. Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1990. </year> <month> 39 </month>
Reference-contexts: For this reason, the macroscheduler must be at least as secure as the machine's remote execution (rsh) protocol. Because different installations use different protocols to administer remote execution, the macroscheduler must be easily adaptable to a variety of different authentication schemes, such as the standard UNIX rsh protocol <ref> [8, chs 9&14] </ref> or Kerberos [7]. Different authentication schemes present different demands and use different fundamental security models.
Reference: [9] <author> W. Richard Stevens. </author> <title> Advanced Programming in the UNIX Environment. </title> <publisher> Addison-Wesley Pro fessional Computing Series. Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1992. </year>
Reference: [10] <author> T. von Eicken, D. E. Culler, S. C. Goldstein, and K. E. Schauser. </author> <title> Active messages: a mechanism for integrated communication and computation. </title> <booktitle> In Proceedings of the 19th International Symp. on Computer Architecture, </booktitle> <address> Gold Coast, Australia, </address> <month> May </month> <year> 1992. </year> <month> 40 </month>
Reference-contexts: The desired degree of security is that which a given system uses to authenticate its remote execution (rsh) protocol. To provide this security, I have created an abstraction on top of active messages <ref> [10] </ref> called "secure" active messages which offers a quick, point-to-point, secure communication mechanism, which is then used to implement the various protocols in the macroscheduler. Fairness. The macroscheduler should allocate processors "fairly" among the jobs present. Here, "fairness" means that each job should have an equal share of the processors. <p> Theoretically, such a protocol could be implemented with a minimum of buffer copying, etc., providing an extremely low overhead messaging system. 2 <ref> [10] </ref> In order to make active messages secure, function addresses cannot be passed directly over the network without being confirmed for correctness at the receiving end.
References-found: 10

