URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-92-15.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: Sorting and Searching With a Faulty Comparison Oracle  
Author: Philip M. Long 
Note: I gratefully acknowledge the support of a UCSC Chancellor's dissertation-year Fellowship.  
Address: Santa Cruz, CA 95064  
Affiliation: Board of Studies in Computer and Information Sciences University of California at Santa Cruz  
Pubnum: UCSC-CRL-92-15  
Email: Email address: plong@cs.ucsc.edu.  
Date: November 9, 1992  
Abstract: We study sorting and searching using a comparison oracle that "lies." First, we prove that an algorithm of Rivest, Meyer, Kleitman, Winklmann and Spencer for searching in an n-element list using a comparison oracle that lies E times requires at most O(log n + E) comparisons, improving the best previously known bound of log n + E log log n + O(E log E). A lower bound, easily obtained from their results, establishes that the number of comparisons used by their algorithm is within a constant factor of optimal. We apply their search algorithm to obtain an algorithm for sorting an n element list with E lies that requires at most O(n log n + En) comparisons, improving on the algorithm of Lakshmanan, Ravikumar and Ganesan, which required at most O(n log n + En + E 2 ) comparisons. A lower bound proved by Lakshmanan, Raviku-mar and Ganesan establishes that the number of comparisons used by our sorting algorithm is optimal to within a constant factor. 
Abstract-found: 1
Intro-found: 1
Reference: [AD91] <author> J.A. Aslam and A. Dhagat. </author> <title> Searching in the presence of linearly bounded errors. </title> <booktitle> Proceedings of the 23rd ACM Symposium on the Theory of Computation, </booktitle> <year> 1991. </year>
Reference-contexts: comparison oracle has been studied under at least two other assumptions about the generation of the faults, including that they are generated independently at random [Pel89, FPRU90], and that there is a constant r such that for each i, at most ir of the first i comparisons are answered incorrectly <ref> [Pel89, AD91] </ref>. 2 Approximating P d i In this section, we state and, for completeness, prove, a useful approximation to P d m The following form of the Hoeffding bounds will be useful.
Reference: [Ang88] <author> D. Angluin. </author> <title> Queries and concept learning. </title> <journal> Machine Learning, </journal> <volume> 2 </volume> <pages> 319-342, </pages> <year> 1988. </year>
Reference-contexts: For those familiar with the Computational Learning Theory literature, as noted by Goldman, Rivest and Schapire [GRS89], another interpretation of the sorting problem is as the problem of learning a total order on n elements using Angluin's "membership queries" <ref> [Ang88] </ref>. Our sorting result can therefore be interpreted as determining (to within a constant factor) the number of membership queries required for learning a total order, when a bounded number of the membership queries are answered incorrectly.
Reference: [BEHW89] <author> A. Blumer, A. Ehrenfeucht, D. Haussler, and M.K. Warmuth. </author> <title> Learnability and the Vapnik-Chervonenkis dimension. </title> <journal> JACM, </journal> <volume> 36(4) </volume> <pages> 929-965, </pages> <year> 1989. </year> <note> 6 References </note>
Reference-contexts: Their approximation improves on the usual approximation of (em=d) d <ref> [BEHW89] </ref> when d is large relative to m, which is useful for this application. Note that if E 2 (log n), the En term in our sorting bound of O (n log n + En) dominates.
Reference: [CW92] <author> N. </author> <title> Cesa-Bianchi and M.K. </title> <type> Warmuth. Personal communication, </type> <year> 1992. </year>
Reference-contexts: 1)n 1 comparisons are necessary and 1 In this paper, we follow usual convention of denoting the base 2 logarithm by log and the natural logarithm by ln. 2 Bounds of O (log n + E) on the first minimum of this theorem were obtained independently by Cesa-Bianchi and Warmuth <ref> [CW92] </ref> while working on another application. 2 2. Approximating P d m sufficient to simply find the maximum of n elements using a comparison oracle that lies E times.
Reference: [FPRU90] <author> U. Feige, D. Peleg, P. Raghavan, and E. Upfal. </author> <title> Computing with unreliable information. </title> <booktitle> Proceedings of the 22nd ACM Symposium on the Theory of Computation, </booktitle> <year> 1990. </year>
Reference-contexts: In addition to the aforementioned previous work, sorting and searching with a faulty comparison oracle has been studied under at least two other assumptions about the generation of the faults, including that they are generated independently at random <ref> [Pel89, FPRU90] </ref>, and that there is a constant r such that for each i, at most ir of the first i comparisons are answered incorrectly [Pel89, AD91]. 2 Approximating P d i In this section, we state and, for completeness, prove, a useful approximation to P d m The following form
Reference: [GRS89] <author> S.A. Goldman, R.L. Rivest, and R.E. Schapire. </author> <title> Learning binary relations and total orders. </title> <booktitle> Proceedings of the 30th Annual Symposium on the Foundations of Computer Science, </booktitle> <year> 1989. </year>
Reference-contexts: Thus, for moderately large E, our sorting result can be viewed as knocking off a log factor from what can be obtained trivially. For those familiar with the Computational Learning Theory literature, as noted by Goldman, Rivest and Schapire <ref> [GRS89] </ref>, another interpretation of the sorting problem is as the problem of learning a total order on n elements using Angluin's "membership queries" [Ang88].
Reference: [LRG91] <author> K.B. Lakshmanan, B. Ravikumar, and K. Ganesan. </author> <title> Coping with erroneous information while sorting. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40(9) </volume> <pages> 1081-1084, </pages> <year> 1991. </year>
Reference-contexts: is a subroutine to determine where each insertion is to take place, requires at most O (n log n + En) comparisons to sort n keys with E "lies," improving on the bound of O (n log n + En + E 2 ) proved by Lakshmanan, Ravikumar and Ganesan <ref> [LRG91] </ref> for a closely related algorithm when E grows faster than n. A lower bound of (n log n + En) comparisons proved in that paper establishes the fact that our modification of their algorithm is within a constant factor of optimal. <p> Thus, if E 2 (log n), only a constant factor more comparisons are required to sort n elements than to simply output their maximum. It is also perhaps worth repeating the observation in <ref> [LRG91] </ref> that any O (n log n) sorting algorithm can be trivially modified to cope with E lies by repeating each comparison 2E + 1 times, obtaining an algorithm that uses O (En log n) comparisons.
Reference: [Pel89] <author> A. Pelc. </author> <title> Searching with known error probability. </title> <journal> Theoretical Computer Science, </journal> <volume> 63 </volume> <pages> 185-202, </pages> <year> 1989. </year>
Reference-contexts: In addition to the aforementioned previous work, sorting and searching with a faulty comparison oracle has been studied under at least two other assumptions about the generation of the faults, including that they are generated independently at random <ref> [Pel89, FPRU90] </ref>, and that there is a constant r such that for each i, at most ir of the first i comparisons are answered incorrectly [Pel89, AD91]. 2 Approximating P d i In this section, we state and, for completeness, prove, a useful approximation to P d m The following form <p> comparison oracle has been studied under at least two other assumptions about the generation of the faults, including that they are generated independently at random [Pel89, FPRU90], and that there is a constant r such that for each i, at most ir of the first i comparisons are answered incorrectly <ref> [Pel89, AD91] </ref>. 2 Approximating P d i In this section, we state and, for completeness, prove, a useful approximation to P d m The following form of the Hoeffding bounds will be useful.
Reference: [Pol84] <author> D. Pollard. </author> <title> Convergence of Stochastic Processes. </title> <publisher> Springer Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Theorem 2 (c.f., <ref> [Pol84] </ref>): Let Y 1 ; :::; Y m be independent, identically distributed f0; 1g valued random variables such that for each i, Pr (Y i = 1) = p.
Reference: [RGL87] <author> B. Ravikumar, K. Ganesan, </author> <title> and K.B. Lakshmanan. On selecting the largest element in spite of erroneous information. </title> <booktitle> Proceedings of STACS87, Lecture Notes in Computer Science, </booktitle> <volume> 247, </volume> <year> 1987. </year>
Reference-contexts: Note that if E 2 (log n), the En term in our sorting bound of O (n log n + En) dominates. This is especially interesting in light of the result of Ravikumar, Ganesan and Lakshmanan <ref> [RGL87] </ref>, which says that (E + 1)n 1 comparisons are necessary and 1 In this paper, we follow usual convention of denoting the base 2 logarithm by log and the natural logarithm by ln. 2 Bounds of O (log n + E) on the first minimum of this theorem were obtained
Reference: [RMK + 80] <author> R.L. Rivest, A.R. Meyer, D.J. Kleitman, K. Winklmann, and J. Spencer. </author> <title> Coping with errors in binary search procedures. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 20 </volume> <pages> 396-404, </pages> <year> 1980. </year>
Reference-contexts: 1 Introduction Rivest, Meyer, Kleitman, Winklmann, and Spencer <ref> [RMK + 80] </ref> described an algorithm for finding an element k in f1; :::; ng using questions of the form "is k a?" for a chosen by the algorithm, when up to E of their algorithm's questions were answered incorrectly. <p> A lower bound of (n log n + En) comparisons proved in that paper establishes the fact that our modification of their algorithm is within a constant factor of optimal. The <ref> [RMK + 80] </ref> paper contained a detailed proof of the following theorem, which is the starting point of our analysis. 2 Theorem 1 ([RMK + 80]): For any nonnegative integer E and positive integer n, let Q (n; E) denote the number of comparison questions necessary in the worst case to <p> We begin by describing a modification of binary insertion sort that uses the robust binary search algorithm of <ref> [RMK + 80] </ref> to determine where to insert. Pseudo-code for this algorithm is given in Figure 4.1. The following follows trivially from the results of the previous section. 5. <p> Pseudo-code for this algorithm is given in Figure 4.1. The following follows trivially from the results of the previous section. 5. Acknowledgements 5 algorithm robust-insertion-sort (A,E,n) array A; (n elements in A) integer E; integer n; for i = 2 to n begin use <ref> [RMK + 80] </ref> to determine where A [i] should be inserted in A [1]; :::; A [i 1], assuming at most E lies (during this search), say it is before A [k]; insert A [i] before A [k]; end; Theorem 6: The algorithm robust-insertion-sort correctly sorts an array of n elements
References-found: 11

