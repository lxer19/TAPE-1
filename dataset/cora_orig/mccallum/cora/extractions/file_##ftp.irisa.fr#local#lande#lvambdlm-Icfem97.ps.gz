URL: file://ftp.irisa.fr/local/lande/lvambdlm-Icfem97.ps.gz
Refering-URL: http://www.irisa.fr/lande/LeMetayer.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: lionel.van.aertryck@aql.fr, marc.benveniste@aql.fr  lemetayer@irisa.fr  
Title: CASTING: a Formally Based Software Test Generation Method  
Author: Lionel Van Aertryck and Marc Benveniste Daniel Le Metayer INRIA/IRISA 
Date: november 1997,  
Note: Published in IEEE International Conference on Formal Engineering Methods (ICFEM'97), first edition. 12-14  
Address: rue de la chataigneraie, BP 127 F35513 Cesson-Sevigne Cedex, France  F35042 Rennes Cedex, France  Japan.  
Affiliation: Alliance Qualite Logiciel  Campus Universitaire de Beaulieu  Hiroshima,  
Abstract: In this paper, we present CASTING, a Computer Assisted Software Test engineering method. The method, supported by a prototype tool, generates realistic software test suites in a formal and semi-automatic way. Based on a two-layer modular architecture, CASTING is not tied to any particular style of input. Initially designed to engineer functional test suites from formal specifications, CASTING can easily be instantiated to accept other formal description levels, seamlessly supporting the main industrial testing techniques, ranging from functional testing to structural testing. A simple process scheduler specification is used in this paper to illustrate the interaction facilities of CASTING and to provide a sample of the resulting test suites. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.-R. </author> <title> Abrial. The B-Book: Assigning Programs to Meanings Cambridge University Press, </title> <year> 1996. </year>
Reference-contexts: Dick and A. Faivre [7]: a process scheduler. This example is worked out using an instantiation of CASTING to the Abstract Machine Notation (AMN), which is the B Formal Development Method notation <ref> [1] </ref>. * Related work is briefly discussed in section 4. * Section 5 summarizes the expected contribution of CASTING to industrial testing practice, describes its current status and suggests further work. 2.
Reference: [2] <author> Boris Beizer. </author> <title> Software Testing Techniques, </title> <publisher> Van Nostrand Reinhold, </publisher> <address> New York, </address> <publisher> 2nd ed., </publisher> <year> 1990. </year>
Reference-contexts: 1. Introduction It is well known that testing accounts for a large part of the cost of development and maintenance of software <ref> [2] </ref>. Therefore, the design of tools to assist in the testing phase and to make it more efficient should be a primary goal of the software engineering community. Testing involves a variety of tasks including test suite generation, test driving, test output checking, non regression testing. . .
Reference: [3] <author> G. Bochmann and A. Petrenko. </author> <title> Protocol Testing: Review of Methods and Relevance for Software Testing Proceedings of the 1994 International Symposium on Software Testing and Analysis, </title> <publisher> ACM Press. </publisher>
Reference-contexts: This is not always the case in practice, which means that extra actions may be needed to distinguish between states. Inspiration can be taken in the domain of pro tocol testing <ref> [3] </ref> where a similar problem occurs. * Assigning a general meaning to the set of testing hypotheses: until now, testing hypotheses are just given to the tester as a sufficient information to evaluate the efficiency of the test suites produced.
Reference: [4] <author> G. Bernot, M.-C. Gaudel and B. Marre. </author> <title> Software Testing Based on Formal Specifications: A Theory and a Tool, </title> <journal> Software Engineering Journal, </journal> <month> November </month> <year> 1991. </year>
Reference-contexts: Hence, testing any one value of that set is equivalent to testing any other value of the set. G. Bernot, M-C. Gaudel and B. Marre have given a thorough presentation of test hypotheses <ref> [4, 8] </ref>. The hypotheses represent the conditions that the software must satisfy for the set of test cases to be complete. In other words, weak test hypotheses characterize large sets of test cases. <p> We sketch the distinctive features of the most significant ones. G. Bernot, M-C. Gaudel and B. Marre have stressed the significance of test hypotheses, both from the theoretical and the practical points of view <ref> [4, 8] </ref>. They apply their theory of tests to the production of test sets (and the corresponding hypotheses) from algebraic specifications. The production rules are expressed in Horn clause logic with a search strategy which can be parameterized by the user. The method is implemented in a system called LOFT.
Reference: [5] <author> P.T Breuer and J.P. Bowen. A PREttier Compiler-Compiler: </author> <title> Generating higher order parsers in C. </title> <type> Technical Report PRG-TR-20-92, </type> <institution> Oxford University Computing Laboratory, </institution> <address> Wolfson Building, Parks Road, Oxford, UK, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: Conclusion A first version of CASTING taking as input B specifications is currently under completion. The main technical options for the realisation of the tool are the following: * The B parser and the testing strategies are built using the PreCC parser generator <ref> [5] </ref>. PreCC takes as input BNF grammars, which may contain inherited and synthesised attributes, and produces parsers source code (ANSI C). A BNF grammar is available for the AMN. * Ilog Solver 1 is used to solve the constraints generated by the system.
Reference: [6] <author> P. Deransart, M. Jourdan and B. Lorho. </author> <title> Attribute grammars, Definitions, Systems and Bibliography LNCS 323, </title> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Both the syntax of the input formalism and the extraction rules are conveniently defined using an attribute grammar <ref> [6] </ref>. The administrator formally defines the extraction rule attached to each non-terminal of the input formalism grammar. Synthesised attributes are used to build and to collect the test case specifications and the associated test hypotheses.
Reference: [7] <author> J. Dick and A. Faivre. </author> <title> Automating the generation and sequencing of test case from model-based specifications FME'93 Industrial Strength Formal Methods, </title> <publisher> LNCS 670, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Our presentation is organised as follows: * Section 2 describes the main features of CASTING and explains its two-layer architecture. * Section 3 illustrates the method with a very simple example taken from a paper of J. Dick and A. Faivre <ref> [7] </ref>: a process scheduler. <p> formulas and variables, whose effect is to prevent further decomposition of the corresponding domains. 3 An example: Test cases generation for a process scheduler specified in B This section presents the instantiation of CASTING to B through the use of a simple example: a process scheduler (inspired from an article <ref> [7] </ref> of J. Dick and A. Faivre). 3.1 The B specification of the process scheduler The text of the specification is presented in Figure 2. <p> J. Dick and A. Faivre describe a tool <ref> [7] </ref> which computes a partition of the domains of the operations of a VDM spec 9 ification. The basic technique consists in reducing the spec-ification of operations into their disjunctive normal form. <p> This partition can serve as a basis for the construction of a finite state automaton which can then be used to derive test suites (but no mechanization of these phases is described). Some of the test cases produced by <ref> [7] </ref> are spurious ones with respect to the uniformity hypothesis. We do not produce these cases because our method is based on the notion of operation rather than that of state. <p> We do not produce these cases because our method is based on the notion of operation rather than that of state. In that perspective, we do not have to consider all the possible states of the system and apply all the operations to them as was done in <ref> [7] </ref>. One important departure of our framework with respect to previous proposals is the fact that the core of the system is independent of the form of the input text.
Reference: [8] <author> M.-C Gaudel. </author> <title> Testing can be formal too, </title> <booktitle> TAPSOFT'95: Theory and Practice of Software Development, 6th International Joint Conference CAAP/FASE,LNCS 915, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Aarhus, Denmark, </address> <month> May </month> <year> 1995. </year> <month> 10 </month>
Reference-contexts: In the first case, the user issues a give up order; otherwise he can impose the value of some variables to guide the solving process. Each test case is formally bound to a clearly defined set of uniformity test hypotheses <ref> [8] </ref>. Intuitively, a uniformity hypothesis may be defined as a set of values that lead to an identical observable behavior of the system under test. Hence, testing any one value of that set is equivalent to testing any other value of the set. G. Bernot, M-C. Gaudel and B. <p> Hence, testing any one value of that set is equivalent to testing any other value of the set. G. Bernot, M-C. Gaudel and B. Marre have given a thorough presentation of test hypotheses <ref> [4, 8] </ref>. The hypotheses represent the conditions that the software must satisfy for the set of test cases to be complete. In other words, weak test hypotheses characterize large sets of test cases. <p> We sketch the distinctive features of the most significant ones. G. Bernot, M-C. Gaudel and B. Marre have stressed the significance of test hypotheses, both from the theoretical and the practical points of view <ref> [4, 8] </ref>. They apply their theory of tests to the production of test sets (and the corresponding hypotheses) from algebraic specifications. The production rules are expressed in Horn clause logic with a search strategy which can be parameterized by the user. The method is implemented in a system called LOFT.
References-found: 8

