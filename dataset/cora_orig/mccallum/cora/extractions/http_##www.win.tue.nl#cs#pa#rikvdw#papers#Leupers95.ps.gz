URL: http://www.win.tue.nl/cs/pa/rikvdw/papers/Leupers95.ps.gz
Refering-URL: http://www.win.tue.nl/cs/pa/rikvdw/bibl.html
Root-URL: http://www.win.tue.nl
Email: email: leupersjmarwedel@ls12.informatik.uni-dortmund.de  
Title: Time-constrained Code Compaction for DSPs  
Author: Rainer Leupers, Peter Marwedel 
Address: XII, 44221 Dortmund, Germany  
Affiliation: University of Dortmund, Dept. of Computer Science  
Abstract: DSP algorithms in most cases are subject to hard real-time constraints. In case of programmable DSP processors, meeting those constraints must be ensured by appropriate code generation techniques. For processors offering instruction-level parallelism, the task of code generation includes code compaction. The exact timing behavior of a DSP program is only known after compaction. Therefore, real-time constraints should be taken into account during the compaction phase. While most known DSP code generators rely on rigid heuristics for that phase, this paper proposes a novel approach to local code compaction based on an Integer Programming model, which obeys exact timing constraints. Due to a general problem formulation, the model also obeys encoding restrictions and possible side effects. 1 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> DSP56156 User's Manual, Motorola Inc. </author> <year> 1992 </year>
Reference-contexts: Code generation for DSPs is complicated by the fact that a moderate to high degree of potential parallelism is offered by contemporary DSP instruction sets. The Motorola DSP56156 <ref> [1] </ref> for instance performs up to three register transfers per cycle. Exploitation of available 1 This work has been partially supported by the European Union, ESPRIT project 9138 (CHIPS).
Reference: [2] <author> C. Liem, T. May, P. Paulin: </author> <title> Instruction-set matching and selection for DSP and ASIP code generation, </title> <booktitle> Eu-ropean Design & Test Conference (ED & TC), </booktitle> <year> 1994 </year>
Reference-contexts: Compilers for DSPs have to cope with highly irregular datapaths, highly specialized instruction sets, and peculiarities in the instruction formats. Furthermore, a certain degree of retargetability is desirable. Recent approaches to DSP code generation include <ref> [2, 3, 4, 5, 6] </ref>. An overview of the state-of-the-art is to be found in [7]. In those approaches, however, timing constraints are neglected. Instead, focus is on retargetability and code optimization. Due to the problem complexity, heuristics are applied for solving the subtasks of code generation, including code compaction.
Reference: [3] <author> A. Fauth, A. Knoll: </author> <title> Translating signal flowcharts into microcode for custom digital signal processors, </title> <booktitle> Proc. </booktitle> <address> ICSP, </address> <year> 1993 </year>
Reference-contexts: Compilers for DSPs have to cope with highly irregular datapaths, highly specialized instruction sets, and peculiarities in the instruction formats. Furthermore, a certain degree of retargetability is desirable. Recent approaches to DSP code generation include <ref> [2, 3, 4, 5, 6] </ref>. An overview of the state-of-the-art is to be found in [7]. In those approaches, however, timing constraints are neglected. Instead, focus is on retargetability and code optimization. Due to the problem complexity, heuristics are applied for solving the subtasks of code generation, including code compaction.
Reference: [4] <author> B. Wess: </author> <title> Optimizing signal flow graph compilers for digital signal processors, </title> <booktitle> Proc. </booktitle> <month> ICSPAT </month> <year> 1994 </year>
Reference-contexts: Compilers for DSPs have to cope with highly irregular datapaths, highly specialized instruction sets, and peculiarities in the instruction formats. Furthermore, a certain degree of retargetability is desirable. Recent approaches to DSP code generation include <ref> [2, 3, 4, 5, 6] </ref>. An overview of the state-of-the-art is to be found in [7]. In those approaches, however, timing constraints are neglected. Instead, focus is on retargetability and code optimization. Due to the problem complexity, heuristics are applied for solving the subtasks of code generation, including code compaction.
Reference: [5] <author> J. Van Praet, G. Goossens, D. Lanneer, H. De Man: </author> <title> Instruction set definition and instruction selection for ASIPs, </title> <booktitle> 7th Int. Symp. on High-Level Synthesis, </booktitle> <year> 1994 </year>
Reference-contexts: Compilers for DSPs have to cope with highly irregular datapaths, highly specialized instruction sets, and peculiarities in the instruction formats. Furthermore, a certain degree of retargetability is desirable. Recent approaches to DSP code generation include <ref> [2, 3, 4, 5, 6] </ref>. An overview of the state-of-the-art is to be found in [7]. In those approaches, however, timing constraints are neglected. Instead, focus is on retargetability and code optimization. Due to the problem complexity, heuristics are applied for solving the subtasks of code generation, including code compaction.
Reference: [6] <author> R. Leupers, R. Niemann, P. Marwedel: </author> <title> Methods for retargetable DSP code generation, </title> <booktitle> IEEE Workshop on VLSI Signal Processing, </booktitle> <year> 1994 </year>
Reference-contexts: Compilers for DSPs have to cope with highly irregular datapaths, highly specialized instruction sets, and peculiarities in the instruction formats. Furthermore, a certain degree of retargetability is desirable. Recent approaches to DSP code generation include <ref> [2, 3, 4, 5, 6] </ref>. An overview of the state-of-the-art is to be found in [7]. In those approaches, however, timing constraints are neglected. Instead, focus is on retargetability and code optimization. Due to the problem complexity, heuristics are applied for solving the subtasks of code generation, including code compaction.
Reference: [7] <author> P. Marwedel, G. Goossens (eds.): </author> <title> Code generation for embedded processors, </title> <publisher> Kluwer Academic Publishers, to appear: </publisher> <month> June </month> <year> 1995 </year>
Reference-contexts: Furthermore, a certain degree of retargetability is desirable. Recent approaches to DSP code generation include [2, 3, 4, 5, 6]. An overview of the state-of-the-art is to be found in <ref> [7] </ref>. In those approaches, however, timing constraints are neglected. Instead, focus is on retargetability and code optimization. Due to the problem complexity, heuristics are applied for solving the subtasks of code generation, including code compaction.
Reference: [8] <author> R. K. Gupta, G. De Micheli: </author> <title> Constrained software generation for hardware-software systems, </title> <booktitle> 3rd Int. Workshop on Hardware/Software Codesign, </booktitle> <year> 1994 </year>
Reference-contexts: This implies that a given problem does not necessarily have a solution. The problem of time-constrained software generation has also been addressed in the context of HW/SW co-design. The technique described in <ref> [8] </ref> uses a very rough estimation of machine program execution times, making simplifying assumptions about the available instruction set. While such an approach makes sense from a "system-level" point of view, it is unlikely to succeed in actual code generation.
Reference: [9] <author> P. Chou, G. Borriello: </author> <title> Software scheduling in the co-synthesis of reactive real-time systems, </title> <booktitle> 31st Design Automation Conference, </booktitle> <year> 1994, </year> <pages> pp. 1-4 </pages>
Reference-contexts: While such an approach makes sense from a "system-level" point of view, it is unlikely to succeed in actual code generation. A constructive system-level technique for software scheduling in presence of real-time constraints has been reported in <ref> [9] </ref>. In Timmer's approach [10], both time and resource constraints are exploited during code generation. Due to a sophisticated execution interval analysis, the technique efficiently produces very high quality code. However, code generation is currently limited towards restrictive instruction for-mats.
Reference: [10] <author> A. H. Timmer, M. T. J. Strik, J. L. van Meerbergen, J. A. G. Jess: </author> <title> Conflict Modelling and Instruction Scheduling in Code Generation for In-House DSP Cores, </title> <booktitle> 32nd Design Automation Conference, </booktitle> <year> 1995 </year>
Reference-contexts: While such an approach makes sense from a "system-level" point of view, it is unlikely to succeed in actual code generation. A constructive system-level technique for software scheduling in presence of real-time constraints has been reported in [9]. In Timmer's approach <ref> [10] </ref>, both time and resource constraints are exploited during code generation. Due to a sophisticated execution interval analysis, the technique efficiently produces very high quality code. However, code generation is currently limited towards restrictive instruction for-mats. <p> The presented IP model provides means of handling those peculiarities. Further research is necessary on integration of code compaction and other phases of retargetable code generation. Furthermore, an a priori reduction of the search space as used by Timmer <ref> [10] </ref> would be favorable in order to decrease run time. Acknowledgement The authors would like to thank Birger Landwehr for his helpful comments on Integer Programming issues.
Reference: [11] <author> T. Wilson, G. Grewal, D. K. Banerji: </author> <title> An integrated approach to retargetable code generation, </title> <booktitle> 7th Int. Symp. on High-Level Synthesis, </booktitle> <year> 1994 </year>
Reference-contexts: Due to a sophisticated execution interval analysis, the technique efficiently produces very high quality code. However, code generation is currently limited towards restrictive instruction for-mats. A more versatile code generation system that actually considers exact program execution times on a given processor was presented in <ref> [11] </ref>. In that system, code generation is based on an Integer Program (IP) formulation of the problem, a technique that has also become quite popular in the area of high-level synthesis (see e.g. [12, 13]). In fact, the approach described in [11] tries to integrate several of the code generation subtasks <p> execution times on a given processor was presented in <ref> [11] </ref>. In that system, code generation is based on an Integer Program (IP) formulation of the problem, a technique that has also become quite popular in the area of high-level synthesis (see e.g. [12, 13]). In fact, the approach described in [11] tries to integrate several of the code generation subtasks (including code compaction) into a single Integer Program resulting in optimal programs or time-constrained programs, respectively. <p> We do not explicitly consider minimum timing constraints, since in code generation those constraints usually can be met by inserting "no-operations". In extension to the work described in <ref> [11] </ref> which basically considers resource conflicts and dependencies between microoperations during compaction, our model also handles encoding restrictions and operations having side effects, i.e. the control code for one register transfer may also trigger other different register transfers. <p> The next section gives a detailed definition of the code compaction problem. Section 3 shows how one problem instance can be transformed into an IP. Experimental results are given in section 4, and the paper ends with some concluding remarks. 2 Problem definition As in <ref> [11] </ref> we concentrate on local code compaction, i.e. within basic blocks. <p> Like IP models in the area of high-level synthesis, it is intended to work on small to medium size subproblems, whose solutions can be combined to a global one as proposed in <ref> [11] </ref>. For instance, a large DSP algorithm with a timing constraint T could be subdivided into smaller blocks for each of which an exact solution for a "small" timing constraint is determined.
Reference: [12] <author> C. H. Gebotys, M. I. Elmasry: </author> <title> Global optimization approach for architectural synthesis, </title> <journal> IEEE Trans. on CAD, </journal> <volume> Vol. 12, No. 9, </volume> <year> 1993 </year>
Reference-contexts: In that system, code generation is based on an Integer Program (IP) formulation of the problem, a technique that has also become quite popular in the area of high-level synthesis (see e.g. <ref> [12, 13] </ref>). In fact, the approach described in [11] tries to integrate several of the code generation subtasks (including code compaction) into a single Integer Program resulting in optimal programs or time-constrained programs, respectively.
Reference: [13] <author> B. Landwehr, P. Marwedel, R. Doemer: </author> <title> Optimum simultaneous scheduling, allocation, and resource binding based on integer programming, </title> <address> Euro-DAC, </address> <year> 1994 </year>
Reference-contexts: In that system, code generation is based on an Integer Program (IP) formulation of the problem, a technique that has also become quite popular in the area of high-level synthesis (see e.g. <ref> [12, 13] </ref>). In fact, the approach described in [11] tries to integrate several of the code generation subtasks (including code compaction) into a single Integer Program resulting in optimal programs or time-constrained programs, respectively.
Reference: [14] <author> Davidson, D. Landskov, B. D. Shriver, P. W. Mallet: </author> <title> Some experiments in local microcode compaction for horizontal machines, </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. 30, No. 7, </volume> <year> 1981 </year>
Reference-contexts: With the appearance of VLIW machines, local microcode compaction became a popular research topic, and a number of heuristic algorithms have been developed, since the problem was shown to be NP-complete. An extensive experimental study <ref> [14] </ref> revealed that some of these heuristics very often find solutions close to the optimum within polynomial time. In the area of DSP, however, code optimality is not always necessary. Any machine program that satisfies a given timing constraint is a valid solution.
Reference: [15] <author> L. Nowak: </author> <title> Graph Based Retargetable Microcode Compilation in the MIMOLA Design System, </title> <booktitle> 20th Annual Microprogramming Workshop (MICRO-20), </booktitle> <year> 1987, </year> <pages> pp. 126-132 </pages>
Reference-contexts: The concept of versions is also used in the MSSQ code generator <ref> [15] </ref>. Considering only control code requirements for an assignment allows for mapping resource conflicts to instruction conflicts. As a consequence, no explicit information about resource usage of assignments has to be maintained.
Reference: [16] <institution> TMS320C2x User's Guide, Rev. B, Texas Instruments, </institution> <year> 1990 </year>
Reference-contexts: Preserving the semantical correctness of an assignment sequence during compaction in general is further complicated by the presence of side effects of register transfers. As an example we consider the TMS320C25 DSP <ref> [16] </ref>. A possible register transfer in the TMS320C25 is to multiply register TR with a data memory value and to store the result in register PR. However, there exist different versions to perform this operation (table 1). The multiply (MPY) instruction does just the multiplication.
Reference: [17] <author> R. Leupers, P. Marwedel: </author> <title> A BDD-based frontend for retargetable compilers, </title> <booktitle> European Design & Test Conference (ED & TC), </booktitle> <year> 1995 </year>
Reference-contexts: Packing a NOP version n wl into a control step t ensures that location w remains its state during that step. Although not being "real instructions", NOP versions for a location w are quite easy to obtain by inverting the sum of all versions that write to w. Reference <ref> [17] </ref> describes how all versions can be extracted from a processor model given in an HDL.
References-found: 17

