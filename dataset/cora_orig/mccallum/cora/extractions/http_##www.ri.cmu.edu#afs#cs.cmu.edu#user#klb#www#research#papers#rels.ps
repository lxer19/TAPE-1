URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/user/klb/www/research/papers/rels.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/user/klb/www/research/biblio.html
Root-URL: 
Email: klbaker+@cmu.edu  
Title: Implementing a Constraint-based Relative Clause Grammar  
Author: Kathryn L. Baker 
Note: DRAFT  
Date: January 24, 1997  
Address: Pittsburgh, PA 15213, USA  
Affiliation: Computational Linguistics Program Carnegie Mellon University  
Abstract: I describe an implementation of the constraint-based English relative clause grammar in [7], in which the universal constraints of the grammar are constraints on phrase types, rather than general conditional constraints on phrasal signs. I use the Attribute Logic Engine (ALE) [4], a grammar utility and logic programming environment based on the logic of typed feature structures [3]. The typed multiple inheritance hierarchy can be quite easily modelled in ALE. The constraints on types which are not reliant upon daughters are implemented directly as type constraints. Constraints which affect mother and daughter are implemented procedural attachments in phrase-structure rules, and so control of enforcing constraints on the relative clause types falls to the user. The X-bar component of the grammar, its set of rules, is no different than that in a basic HPSG grammar [2], with the resolution of specific phrase types localized in procedures. Eager type promotion, e.g. setting the value of the rel set as early as possible, limits the number of edges in the chart, which facilitates debugging. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Kathryn L. Baker. </author> <title> Delayed evaluation of linguistic constraints. </title> <type> PhD. Thesis Proposal, </type> <institution> Carnegie Mellon University, </institution> <year> 1996. </year>
Reference-contexts: This approach involves delaying some evaluations until subsumption is proven or disproven. This work is being undertaken as a modification to ALE in <ref> [1] </ref>. Here, the test for satisfaction of a constraint by the antecedent is to check whether descriptions are subsumed. Relative clause type constraints, which are the bulk of the work in [7] are implemented as definite clause attachments on phrase structure rules.
Reference: [2] <author> Kathryn L. Baker and Gerald Penn. </author> <title> An Implementational Perspective on HPSG. </title> <type> Unpublished Manuscript, </type> <institution> Carnegie Mellon University, </institution> <year> 1997. </year>
Reference-contexts: In this way I retain the advantages of phrase structure parsing while immediately obtaining the desired subtype once the procedural attachments on the rule have succeeded. As I have found in my implementation, the dtrs feature can be quite easily eliminated. Earlier work <ref> [2] </ref> found that having daughters in a phrase structure rule can lead to expensive and unnecessary copying. I have implemented the maximal relative clause types for Wh Rel clauses, wh subject rel clause, finite wh filler rel clause, and infinitive wh filler rel clause. <p> It is important for ALE because when unification is performed on two types, 2 it prevents having to select which minimal common subtype to use, thereby improving efficiency <ref> [2] </ref>. Because not all of the hierarchy in [7] follows this direction, certain non-maximal subtypes have been added in the implementation. <p> Complement Extraction is done via the Complement Extraction Lexical Rule (CELR) which is implemented as in <ref> [2] </ref>. 5 One lexical rule was added to facilitate the cooccurrence of the proper values of mod and rel with the feature mc (main clause). This is the noun mod lexical rule. The basic lexical entry for a verb is mc+, with mod:none and an empty rel set. <p> These are shown in figure 2. Otherwise, there is a bottom-up bias to resolving many synsem values, such as the ones on comps lists, which are lexically unspecified; these are best resolved in ALE using procedural attachments <ref> [2] </ref>. What is needed is a control strategy to enforce when the checking of type constraints occurs, on top of the declarative statement given by HPSG that principles such as the Subcat or Valence Principle should somehow hold true.
Reference: [3] <author> Bob Carpenter. </author> <title> The Logic of Typed Feature Structures with Applications to Unification-based Grammars, Logic Programming and Constraint Resolution, </title> <booktitle> volume 32 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> New York, </address> <year> 1992. </year>
Reference: [4] <author> Bob Carpenter and Gerald Penn. </author> <title> Compiling typed attribute-value logic grammars. </title> <editor> In Harry Bunt and Masaru Tomita, editors, </editor> <booktitle> Recent Advances in Parsing Technologies, </booktitle> <volume> volume 2. </volume> <publisher> Kluwer, </publisher> <year> 1996. </year> <month> 14 </month>
Reference: [5] <editor> Carl Pollard and Ivan A. Sag. Information-based Syntax and Se--mantics, </editor> <volume> Vol. 1. </volume> <booktitle> Number 13 in Lecture Notes. </booktitle> <publisher> CSLI Publications, Stanford University, </publisher> <year> 1987. </year> <institution> Distributed by University of Chicago Press. </institution>
Reference-contexts: 1 Introduction In standard Head-Driven Phrase Structure Grammar (HPSG) <ref> [5, 6] </ref>, schemata are descriptions of feature structures of type phrase. The constituent structures that phrases may take are identifiable (as in [6, 1 chapter9]) as subtypes of the type headed struc, a classification of the types of non-head daughters that a phrase may take.
Reference: [6] <author> Carl Pollard and Ivan A. Sag. </author> <title> Head-Driven Phrase Structure Grammar. </title> <publisher> University of Chicago Press, </publisher> <address> Chicago, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction In standard Head-Driven Phrase Structure Grammar (HPSG) <ref> [5, 6] </ref>, schemata are descriptions of feature structures of type phrase. The constituent structures that phrases may take are identifiable (as in [6, 1 chapter9]) as subtypes of the type headed struc, a classification of the types of non-head daughters that a phrase may take. <p> 1 Introduction In standard Head-Driven Phrase Structure Grammar (HPSG) [5, 6], schemata are descriptions of feature structures of type phrase. The constituent structures that phrases may take are identifiable (as in <ref> [6, 1 chapter9] </ref>) as subtypes of the type headed struc, a classification of the types of non-head daughters that a phrase may take. The work of [7] moves HPSG in a direction away from the conceptualization of Immediate Dominance schemata as parse trees for the statement of X-bar theory.
Reference: [7] <author> Ivan Sag. </author> <title> English relative clause constructions. </title> <type> Unpublished manuscript, </type> <institution> Stanford University, </institution> <month> June </month> <year> 1996. </year> <month> 15 </month>
Reference-contexts: The constituent structures that phrases may take are identifiable (as in [6, 1 chapter9]) as subtypes of the type headed struc, a classification of the types of non-head daughters that a phrase may take. The work of <ref> [7] </ref> moves HPSG in a direction away from the conceptualization of Immediate Dominance schemata as parse trees for the statement of X-bar theory. <p> I have implemented the maximal relative clause types for Wh Rel clauses, wh subject rel clause, finite wh filler rel clause, and infinitive wh filler rel clause. In the theory of <ref> [7] </ref>, the values of the head:mod feature and the rel value of the relevant daughter (subj for subject relative clauses and filler for non-subject relatives) are expressed as constraints on those relative clause types. I also have two types of non-Wh relative clause, bare rel clause and infinitive rel clause. <p> It is important for ALE because when unification is performed on two types, 2 it prevents having to select which minimal common subtype to use, thereby improving efficiency [2]. Because not all of the hierarchy in <ref> [7] </ref> follows this direction, certain non-maximal subtypes have been added in the implementation. For example, in [7], the consistent types head nexus phrase and rel clause have multiple most general unifiers (MGUs) for Wh relatives: finite wh filler rel clause, infinitive wh filler rel clause, and wh subject rel clause. <p> Because not all of the hierarchy in <ref> [7] </ref> follows this direction, certain non-maximal subtypes have been added in the implementation. For example, in [7], the consistent types head nexus phrase and rel clause have multiple most general unifiers (MGUs) for Wh relatives: finite wh filler rel clause, infinitive wh filler rel clause, and wh subject rel clause. <p> sub []. inter_cl sub []. subj_rel_cl sub [wh_subj_rel_cl,bare_rel_cl]. wh_subj_rel_cl sub []. bare_rel_cl sub []. rel_cl sub [wh_rel_cl,non_wh_rel_cl,subj_rel_cl]. wh_rel_cl sub [wh_subj_rel_cl,wh_fill_rel_cl]. wh_fill_rel_cl sub [fin_wh_fill_rel_cl,inf_wh_fill_rel_cl]. fin_wh_fill_rel_cl sub []. inf_wh_fill_rel_cl sub []. non_wh_rel_cl sub [bare_rel_cl,inf_rel_cl]. inf_rel_cl sub []. non_clause sub [hd_rel_ph]. hd_rel_ph sub []. 4 3 Lexicon and Lexical Rules The work of <ref> [7] </ref> introduces lexical amalgamation of the nonlocal slash, rel, and que values. The value of the one of these features for sort word is the disjoint union of the values of that feature for all of the valence arguments. <p> mc:plus), subj:Subj, comps:Comps, spr:Spr, marking:Marking), cont:Cont, conx:Conx), non_loc:slash:e_set), qstore:Qstore) **&gt; (word, subcat:Subcat, synsem:(loc:(cat:(head:(verb, mod:loc:cat:head:noun, vform:Vform, aux:Aux, inv:minus, mc:minus), subj:Subj, comps:Comps, spr:Spr, marking:Marking), cont:Cont, conx:Conx), % make rel value empty or not for non wh rels. %% now, overgenerates. non_loc:slash:e_set), qstore:Qstore) morphs X becomes X. 4 Type Constraints The grammar of <ref> [7] </ref> consists of a hierarchy of types and a set of con straints on those types. Some constraints can be implemented as type constraints, reflecting the paper directly; most are implemented as pro cedural attachments on phrase structure rules. <p> This work is being undertaken as a modification to ALE in [1]. Here, the test for satisfaction of a constraint by the antecedent is to check whether descriptions are subsumed. Relative clause type constraints, which are the bulk of the work in <ref> [7] </ref> are implemented as definite clause attachments on phrase structure rules. The subtypes of relative clauses that fall under a particular phrase type are resolved within the phrase structure rule for that type. <p> The slip and whip are the slash and wh Inheritance Principles <ref> [7] </ref>. These are default principles such that the mother inherits the slash, rel and que values of its head daughter. In my implementation, I call the procedures slip and whip in the default contexts, and do not call them elsewhere. <p> Per <ref> [7] </ref>, the prediction that lex+ would make is that infinitival relatives never follow a wh relative clause, and in addition that only one infinitival relative is possible per NP. The constraint on vform is a type constraint. <p> This is the way that the semantics of the relative clause is determined in a relative head-adjunct construction. Whereas this is a constraint on head rel adjunct phrase in <ref> [7] </ref>, I have put the constraint directly into a definite clause for the semantics principle, which constrains the semantics of the mother.
References-found: 7

