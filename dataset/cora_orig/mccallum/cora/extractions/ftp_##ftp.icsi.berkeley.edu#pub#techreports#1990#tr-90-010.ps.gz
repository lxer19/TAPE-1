URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1990/tr-90-010.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1990.html
Root-URL: http://www.icsi.berkeley.edu
Title: L 0 A Testbed for Miniature Language Acquisition  
Phone: 1-415-642-4274 FAX 1-415-643-7684  
Author: Susan Hollbach Weber Andreas Stolcke 
Date: July 1990  
Address: I 1947 Center Street Suite 600 Berkeley, California 94704  
Affiliation: INTERNATIONAL COMPUTER SCIENCE INSTITUTE  
Pubnum: TR-90-010  
Abstract: L 0 constitutes a recent effort in Cognitive Science to build a natural language acquisition system for a limited visual domain. As a preparatory step towards addressing the issue of learning in this domain, we have built a set of tools for rapid prototyping and experimentation in the areas of language processing, image processing, and knowledge representation. The special focus of our work was the integration of these different components into a flexible system which would allow us to better understand the domain given by L 0 and experiment with alternative approaches to the problems it poses. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> William F. Clocksin and Christopher S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer, </publisher> <address> 2nd edition, </address> <year> 1984. </year>
Reference-contexts: By default the Prolog system automatically compiles DCG rules into Horn clauses, which, when interpreted as standard Prolog clauses, implement a top-down, left-to-right parsing algorithm. We won't dwell on the details of this translation process; a good account can be found in <ref> [1] </ref>.
Reference: [2] <author> Jerome A. Feldman, George Lakoff, Andreas Stolcke, and Susan Hollbach Weber. </author> <title> Miniature language acquisition: A touchstone for cognitive science. </title> <type> Technical Report TR-90-009, </type> <institution> International Computer Science Institute, </institution> <month> March </month> <year> 1990. </year> <booktitle> To appear in the Proceedings of the 12th Annual Conference of the Cognitive Science Society. </booktitle>
Reference-contexts: Figure 1 shows an example of an input picture, along with several partial descriptions in various languages of the picture's content. The task is to learn the grammar and semantics of the natural language, by observing the correspondences between the input pictures and their accompanying texts in that language <ref> [2] </ref>. Since the project is undertaken from a computer science perspective, the end result envisioned for the project is a system that can learn the syntax and semantics of any natural language as it pertains to the given picture description task. The task is `theory-free' and admits any implementation. <p> Although Prolog is not very efficient for the very low-level parts of our image-processing component (cf. section 2), this is tolerable since low-level vision is not the focus of our current efforts on L 0 . 1.3 Design decisions The MLA task as framed in <ref> [2] </ref> imposes few restrictions on the final form of the language understanding system. For example, given a picture, the system could be required to generate a complete linguistic description in the language of choice.
Reference: [3] <author> Ray Jackendorff. </author> <title> X-bar syntax. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1977. </year>
Reference-contexts: This is a formalization of the linguistic intuition that the NP figures as the grammatical subject of the sentence. The second equation then specifies that everything else in a sentence's head is inherited from the VP's head. The feature name head is historically motivated by X-bar theory <ref> [3] </ref>, were VPs are considered the `heads' of S's. Similar relationships (and corresponding rules) relate VP and V, NP and N, PP and P, etc. The last three equations state the combination of -expressions via function application discussed in section 3.1.2.
Reference: [4] <author> Ronald M. Kaplan and Joan Bresnan. </author> <title> Lexical functional grammar: A formal system for grammatical representation. </title> <editor> In Joan Bresnan, editor, </editor> <booktitle> The Mental Representation of Grammatical Relations, </booktitle> <pages> pages 173-281. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1982. </year>
Reference-contexts: Currently this translation process is sentence-based, i.e. each sentence generates one query. Since eventually we want to be able to handle a larger number of different languages, for both analysis and generation, we needed a theoretically well-founded and sufficiently powerful computational formalism. We chose a variant of unification-based grammar <ref> [4; 5; 12] </ref>, as our linguistic framework.
Reference: [5] <author> Martin Kay. </author> <title> Functional unification grammar: A formalism for machine translation. </title> <booktitle> In Proceedings of the 10th International Conference on Computational Linguistics, </booktitle> <pages> pages 75-78, </pages> <address> Stanford, Calif., </address> <month> July </month> <year> 1984. </year> <month> 28 </month>
Reference-contexts: Currently this translation process is sentence-based, i.e. each sentence generates one query. Since eventually we want to be able to handle a larger number of different languages, for both analysis and generation, we needed a theoretically well-founded and sufficiently powerful computational formalism. We chose a variant of unification-based grammar <ref> [4; 5; 12] </ref>, as our linguistic framework.
Reference: [6] <author> Richard Montague. </author> <title> The proper treatment of quantification in ordinary English. </title> <editor> In K. J. J. Hintikka, J. M. E. Moravcsik, and P. Suppes, editors, </editor> <booktitle> Approaches to Natural Language. Proceedings of the 1970 Stanford Workshop on Grammar and Semantics, </booktitle> <pages> pages 221-242. </pages> <publisher> Reidel, </publisher> <address> Dordrecht, Boston, </address> <year> 1973. </year>
Reference-contexts: It is however required by the query language to enable backtracking over all objects in the database when evaluating a query.) The purpose of using -expressions to describe semantics is that combining semantics can be formulated in terms of function applications of -expressions to other expressions. Following Montague's <ref> [6] </ref> approach we have NPs translate into s which are applied to verb meanings (and not vice versa). This is not only necessary to handle quantification properly, but also turns to be useful in the treatment of the various semantics of noun phrase coordinations, as discussed in section 3.2.
Reference: [7] <author> Fernando C. N. Pereira and Stuart M. Shieber. </author> <title> Prolog and Natural-Language Analysis. </title> <booktitle> Number 10 in CSLI Lecture Notes Series. Center for the Study of Language and Information, </booktitle> <address> Stanford, Ca., </address> <year> 1987. </year>
Reference-contexts: in a corresponding German sentence.) This type of scope ambiguity is quite independent of the one discussed above; rather it is analogous to the one found in sentences like all circles are above a triangle A method for generating all possible quantifier scopes in such cases can be found in <ref> [7] </ref>, and has been adapted for the L 0 testbed. It is likely that human parsing is to some extent guided by the pragmatic context. <p> We won't dwell on the details of this translation process; a good account can be found in [1]. It is important to note, however, that DCG is a declarative formalism which can be interpreted by several alternative parsing strategies. (See Pereira & Shieber <ref> [7] </ref> for an thorough discussion of DCG parsing algorithms.) For convenience we have built on top of the DCG implementation provided by the standard Prolog systems, although top-down, left-to-right interpretation of DCG rules via backtracking is not an optimal parsing method. <p> Unifications are undone via backtracking over X === Y. The next sections describe how this operator can be combined with DCG to give a full implementation of unification grammars. 3.3.3 Representing -expressions Our representation of -expressions follows closely the approach given by Pereira & Shieber <ref> [7] </ref>. A -function x:p (x) is represented as a Prolog term X^P where X is a Prolog variable and P is a term containing that variable.
Reference: [8] <author> Fernando C. N. Pereira and David H. D. Warren. </author> <title> Definite clause grammars compared with augmented transition networks. </title> <type> Technical report, </type> <institution> Department of Artificial Intelligence, University of Edinburgh, Edinburgh, </institution> <address> Scotland, </address> <year> 1978. </year>
Reference-contexts: This section explains in some detail how both these components can be realized quite elegantly in Prolog, as well as how the mapping (or `attachment') of f-structures to c-structures is accomplished. 3.3.1 Definite Clause Grammars Prolog incorporates a standard extension to implement phrase-structure grammars, known as Definite Clause Grammar (DCG) <ref> [8] </ref>. As a consequence the context-free part a unification grammar rule can readily be written as a DCG grammar rule in Prolog. In the case of rule (1) above this is simply s --&gt; np, vp. Likewise rules (3) and (2) become 24 pp --&gt; p, np. p --&gt; [embaixo,de].
Reference: [9] <author> Fred Popowich. </author> <title> A tree unification grammar-based natural language processor. </title> <type> Technical Report CSS-IS TR 89-08, </type> <institution> Centre for Systems Science, Simon Fraser University, Burnaby, B.C., Canada, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: It would be possible in principle to rewrite an f-structure based unification grammar to use terms instead of f-structures and use term unification directly. 5 This is feasible in certain special cases, such as when the f-structures are restricted to tree-structures <ref> [9] </ref>. In our case, however, this would yield extremely unwieldy structures, at the expense of readability and the envisioned flexibility of a rapid-prototyping system. The alternative approach is to implement f-structures as Prolog data structures and define the unification operator explicitly.
Reference: [10] <author> Terry Regier. </author> <title> Spatial Semantics. Dissertation proposal, </title> <institution> Computer Science Division, University of California, Berkeley, </institution> <address> Ca., </address> <year> 1990. </year>
Reference-contexts: This simplistic approach is not very robust <ref> [10] </ref>, but it suffices for our present purposes. 9 The predicate above (trajector; landmark) is defined to be in (trajector; rAbove (landmark)). Below, leftof and rightof are defined similarly. Area is computed from the boundary description, regardless of whether the object shape is one of the predefined primitives or not.
Reference: [11] <author> Aristides A. G. Requicha. </author> <title> Representations for rigid solids: Theory, methods and systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 12(4), </volume> <month> December </month> <year> 1980. </year>
Reference-contexts: The one crucial representational issue avoided in the above discussion is the form taken by the object boundary description. Two options were considered. The first option is to perform two dimensional solid modeling operations on the objects as defined by their control points. A Constructive Solid Geometry <ref> [11] </ref> scheme with circles squares and triangles as the primitive shapes is the obvious approach to this task.
Reference: [12] <author> Stuart M. Shieber. </author> <title> An Introduction to Unification-Based Approaches to Grammar. Number 4 in CSLI Lecture Note Series. Center for Study of Language and Information, </title> <institution> Stanford, Calif., </institution> <year> 1986. </year>
Reference-contexts: We chose Prolog as the implementation language for our testbed, for the following reasons: * Prolog's backtracking and unification mechanisms provide suitable support for the implemen tation of unification grammars <ref> [12] </ref>. * Interfacing between components is simplified due to the declarative nature of Prolog programming. If the nature of task is suitable, bidirectional interfaces can be implemented with 2 relative ease. <p> Currently this translation process is sentence-based, i.e. each sentence generates one query. Since eventually we want to be able to handle a larger number of different languages, for both analysis and generation, we needed a theoretically well-founded and sufficiently powerful computational formalism. We chose a variant of unification-based grammar <ref> [4; 5; 12] </ref>, as our linguistic framework. <p> Secondly, they constrain rule applications by requiring that the structures being equated be unifiable, i.e. have compatible features and sub-features. This provides an elegant account of grammatical phenomena such as agreement, coreference, control, etc. (for an overview of applications of unification in linguistic description see <ref> [12] </ref>). The equations for pred we have given above show another important aspect of our formalism. <p> Add features present in only one of the lists to the other list by further instantiating the respective tail variable. 2. For features present in both lists, unify the values recursively. 5 In fact DCG can be characterized as a special variant of general unification grammars <ref> [12] </ref>. 25 3. After all features have been processed like this, (Prolog-)unify the two tail variables. The last step ensures that whatever further unifications are performed on either of the two structures, any additions to the structure will be shared with all other structures that have been unified previously.
Reference: [13] <author> Andreas Stolcke. </author> <title> Learning feature-based semantics with simple recurrent networks. </title> <type> Technical Report TR-90-015, </type> <institution> International Computer Science Institute, Berkeley, </institution> <address> Ca., </address> <month> April </month> <year> 1990. </year>
Reference-contexts: For example, the language processing component described in section 3 does not only handle sentence analysis as required by the testbed system, but also handles generation of sentence-semantics pairs as training patterns for a connectionist approach to the L 0 task <ref> [13] </ref>. * The high-level nature of Prolog is generally supportive of rapid prototyping of various concepts for test purposes. For language and image processing in particular, Prolog's built-in control structures allowed implementations which are simple and elegant, if not optimal.
Reference: [14] <author> L. A. Zadeh. </author> <title> Fuzzy sets. </title> <journal> Information and Control, </journal> <volume> 8 </volume> <pages> 338-353, </pages> <month> June </month> <year> 1966. </year>
Reference-contexts: We consider our current implementation to be an approximation of such a system, which would require a fuzzified version of both the query language and the inference component, while retaining the overall structure (and the language processing component in particular). It is not clear, however, that Fuzzy Logic <ref> [14; 15] </ref> or any other proposed approximate reasoning formalism would yield the correct results in the L 0 domain. 2.2 Linguistic input processing Thus queries to the system are phrased in terms of data structures and predicates, where the predicates are defined by functions.
Reference: [15] <author> Lotfi A. Zadeh. </author> <title> Fuzzy languages and their relation to human and machine intelligence. </title> <booktitle> In Proceedings of the Conference on Man and Computer, </booktitle> <address> Bordeaux, France, </address> <month> June </month> <year> 1970, </year> <pages> pages 130-165. </pages> <editor> S. Karger, </editor> <address> Basel, </address> <year> 1972. </year>
Reference-contexts: We consider our current implementation to be an approximation of such a system, which would require a fuzzified version of both the query language and the inference component, while retaining the overall structure (and the language processing component in particular). It is not clear, however, that Fuzzy Logic <ref> [14; 15] </ref> or any other proposed approximate reasoning formalism would yield the correct results in the L 0 domain. 2.2 Linguistic input processing Thus queries to the system are phrased in terms of data structures and predicates, where the predicates are defined by functions.
References-found: 15

