URL: ftp://ftp.cs.toronto.edu/pub/kbms/coocs95.ps.Z
Refering-URL: ftp://ftp.cs.toronto.edu/pub/kbms/readme.html
Root-URL: 
Email: E-mail: dp@ai.toronto.edu  
Title: Simulation and Analysis of Business Processes Using GOLOG  
Author: Dimitris Plexousakis 
Address: Toronto, Ontario, M5S 1A4, Canada  
Affiliation: Department of Computer Science University of Toronto  
Abstract: This paper describes a novel approach to simulating and analyzing business processes using GOLOG, a high-level logic programming language suitable for defining complex behaviors and capable of simulating action execution. The language is based on an extended version of the situation calculus and incorporates a formal theory of action. Business processes can be viewed as actions (physical or perceptual) that affect the state of affairs or an agent's knowledge of this state. Using GOLOG, business processes can be specified, synthesized and tested for feasibility and consistency. The theoretical framework behind GOLOG includes a solution to the frame problem for perceptual and complex actions, as well as, a formal method for process analysis. The latter uses a solution to the ramification problem for proving the satisfaction or violation of constraints. In case this is not possible, the method proposes strengthenings to the processes' pre- and post-conditions, so that any implementation that meets the process specification, provably guarantees that constraints will not be violated. In this manner, business process reengineering can be assisted by a formal analysis and simulation tool for testing the consistency of the process model. 
Abstract-found: 1
Intro-found: 1
Reference: [BMR93] <author> A. Borgida, J. Mylopoulos, and R. Reiter. </author> <title> And nothing else changes: The Frame Problem in Procedure Specifications. </title> <booktitle> In Proceedings of the 15th Int. Conference on Software Engineering, </booktitle> <year> 1993. </year>
Reference-contexts: An extension of this solution has been used for proving transaction safety in temporal deductive databases in [PM95]. Perceptual actions are dealt with in [LLL + 94]. <ref> [BMR93] </ref> depicts how the frame problem becomes particularly acute in object-oriented specifications where transactions are inherited and specialized from superclasses to subclasses. <p> In the area of information systems development and in process modeling in particular, the frame and ramification problems have traditionally been either ignored or bypassed by means of explicit assumptions (see, e.g., [DDBDP94], [HL88]). In <ref> [BMR93] </ref>, a systematic solution to the frame and ramification problems for determinate transaction specifications is presented. We will employ this solution for strengthening process specifications at design time to guarantee the maintenance of constraints by any implementation that meets the specifications. <p> ) ^ borrows 0 (br; bk; dt) ^ javailable [dt] 0 j = javailable [dt]j 1 ^ jrequested [dt] 0 j = jrequested [dt]j 1 ^ jcheckedOut [dt] 0 j = jcheckedOut [dt]j + 1)) (1) From the direct effect axioms we can systematically generate positive and negative effect axioms <ref> [BMR93] </ref> for every predicate P that occurs in post ff .
Reference: [CKO92] <author> B. Curtis, M. Kellner, and J. </author> <title> Over. Process Modelling. </title> <journal> Communications of the ACM, </journal> <volume> 35(9) </volume> <pages> 75-90, </pages> <year> 1992. </year>
Reference-contexts: GOLOG can also support the process enactment phase, where activity plans can be scheduled. Then the viability of the synthesized plans can be tested. For the purposes of this paper we will adopt a func 1 tional/behavioral representation of processes <ref> [CKO92] </ref>. We will focus on the sequencing of process elements or their iterations, as well as necessary and sufficient conditions for process execution. These will be exploited for proving properties of processes within a formal framework.
Reference: [DDBD94] <author> E. Dubois, P. Du Bois, and F. Dubru. </author> <title> Animating Formal Requirements Specifications of Cooperative Information Systems. </title> <booktitle> In Proceedings of the 2nd International Conference on Cooperative Information Systems, </booktitle> <pages> pages 101-112, </pages> <year> 1994. </year>
Reference-contexts: The successor-state axioms can then be compiled automatically for the effect axioms. Figure 5 contains part of an initial specification of the library management example in GOLOG. The simulation is rather simplistic at this stage, as compared to other simulation tools (e.g., <ref> [DDBD94] </ref>), which do not perform theorem proving or plan generation. The interpreter returns a complete trace of the execution of processes, showing the actions that took place since the initial situation.
Reference: [DDBDP94] <author> E. Dubois, P. Du Bois, F. Dubru, and M. Petit. </author> <title> Agent-Oriented Requirements Engineering a Case Study Using the Albert Language. </title> <booktitle> In Proceedings of the 4th International Working Conference on Dynamic Modelling and Information Systems, </booktitle> <year> 1994. </year>
Reference-contexts: There's a growing requirement to represent processes through which work is achieved. Process representation thus becomes a vital issue in redesigning work and allocating responsibilities. Many languages aiming to assist in the requirements engineering activity of information systems development have been proposed (see for instance RML [Gre84], Albert <ref> [DDBDP94] </ref>, KAOS [vLDM94] and Telos [MBJK90]); few of them though provide a solid theoretical basis for reasoning about processes. <p> In the area of information systems development and in process modeling in particular, the frame and ramification problems have traditionally been either ignored or bypassed by means of explicit assumptions (see, e.g., <ref> [DDBDP94] </ref>, [HL88]). In [BMR93], a systematic solution to the frame and ramification problems for determinate transaction specifications is presented. We will employ this solution for strengthening process specifications at design time to guarantee the maintenance of constraints by any implementation that meets the specifications.
Reference: [DvLF93] <author> A. Dardenne, A. van Lamsweerde, and S. Fickas. </author> <title> Goal-Directed Requirements Acquisition. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 20(1) </volume> <pages> 3-50, </pages> <year> 1993. </year>
Reference-contexts: We limit ourselves to presenting action specifications in an abstract language. We assume that actions are specified in terms of precondition/postcondition pairs, where both of these conditions are specified in a variant of first-order predicate calculus. The idea for the example below is borrowed from <ref> [DvLF93] </ref> although the specifications presented here are different. In this section we only give an initial specification of representative actions and objects. Primed predicates or function terms will denote the respective (truth) values in the state resulting from the action execution.
Reference: [Ell80] <editor> C. Ellis. Office Streamlining. In N. Naffah, editor, </editor> <booktitle> Integrated Office Systems, </booktitle> <pages> pages 111-125. </pages> <publisher> North Holland, </publisher> <year> 1980. </year>
Reference-contexts: This creates additional requirements, specifically for modeling actions that only involve acquiring or communicating knowledge or information. Reasoning about properties of business processes, such as, e.g., invariance or consistency with respect to a set of constraints, deadlock or communication bottleneck detection <ref> [Ell80] </ref>, requires that actions of the above sort be formalized in addition to actions whose effect it is to change the state of affairs in the domain modeled.
Reference: [Fin88] <author> J. </author> <title> Finger. Exploiting Constraints in Design Synthesis. </title> <type> Technical Report STAN-CS-88-1204, </type> <institution> Stanford University, </institution> <year> 1988. </year>
Reference-contexts: In this paper, we argue that a formal method for analyzing the consistency of process specifications with respect to constraints can be devised by using a solution to the well-known in AI frame [McC69] and ramification <ref> [Fin88] </ref> problems. Given a set of action specifications, the problem of succinctly stating that "nothing else changes" except the aspects of the state explicitly specified, has been called the frame problem. The ramification problem amounts to devising a way to avoid having to specify indirect effects of actions explicitly. <p> We only sketch the solution and apply it to our working example. More details can be found in [Rei91], [LR92], [Pin94] and [PM95]. A ramification of a goal is a condition that is inevitably true if the goal is true <ref> [Fin88] </ref>. This definition is amenable to different interpretations in different world models. If the world model in question is expressed as a first-order theory, then the concept of ramifications can be captured by first-order entailment. <p> From the semi-decidability of first-order entailment, it follows that the problem of finding ramifications is, in its generality, intractable. Tractability can be achieved by restricting the class of goals for which ramifications are sought. For instance, the task is tractable for the case of ordered conjunctive goals <ref> [Fin88] </ref>. Furthermore, not all derivable ramifications may be useful for simplifying the task of proving a goal. For that, the generator may be guided to derive only "useful" ramifications by providing appropriate input clauses.
Reference: [Gre84] <author> Sol Greenspan. </author> <title> Requirements Modeling: A Knowledge Representation Approach to Software Requirements Definition. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1984. </year>
Reference-contexts: There's a growing requirement to represent processes through which work is achieved. Process representation thus becomes a vital issue in redesigning work and allocating responsibilities. Many languages aiming to assist in the requirements engineering activity of information systems development have been proposed (see for instance RML <ref> [Gre84] </ref>, Albert [DDBDP94], KAOS [vLDM94] and Telos [MBJK90]); few of them though provide a solid theoretical basis for reasoning about processes.
Reference: [Ham94] <author> Walter Hamscher. </author> <title> AI in Business Process Reengineering. </title> <journal> AI Magazine, </journal> <volume> 15(4), </volume> <year> 1994. </year> <note> Report on the AAAI Workshop. </note>
Reference-contexts: 1 Introduction The role of Artificial Intelligence (AI) in Business Process Reengineering (BPR) is two-fold: AI can provide both the enabling technology for automatically reengineering processes and tools to support process redesign by the user <ref> [Ham94] </ref>. The majority of attempts to put AI to work in BPR have insisted on the first of these roles. It remains a challenging issue to develop tools for evaluating and for assisting the production of designs. There's a growing requirement to represent processes through which work is achieved.
Reference: [HL88] <author> K. Huff and V. Lesser. </author> <title> A Plan-based Intelligent Assistant that Supports the Software Development Process. </title> <booktitle> In Proceedings of SIGSOFT-88, </booktitle> <pages> pages 97-106, </pages> <year> 1988. </year>
Reference-contexts: Unlike other areas of process modeling, e.g., software process modeling <ref> [HL88] </ref>, business process modeling attempts to capture phenomena enacted by humans rather than machines. This creates additional requirements, specifically for modeling actions that only involve acquiring or communicating knowledge or information. <p> In the area of information systems development and in process modeling in particular, the frame and ramification problems have traditionally been either ignored or bypassed by means of explicit assumptions (see, e.g., [DDBDP94], <ref> [HL88] </ref>). In [BMR93], a systematic solution to the frame and ramification problems for determinate transaction specifications is presented. We will employ this solution for strengthening process specifications at design time to guarantee the maintenance of constraints by any implementation that meets the specifications.
Reference: [Kar94] <author> Dimitris Karagiannis. </author> <title> Towards Business Process Management Systems, </title> <booktitle> 1994. Tutorial at the 2nd Int. Conference on Cooperative Information Systems. </booktitle>
Reference-contexts: However, GOLOG can be coupled with a requirements modeling language and function within the simulation and analysis component of a business process management system (BPMS) <ref> [Kar94] </ref>. GOLOG can also support the process enactment phase, where activity plans can be scheduled. Then the viability of the synthesized plans can be tested. For the purposes of this paper we will adopt a func 1 tional/behavioral representation of processes [CKO92].
Reference: [LLL + 94] <author> Y. Lesperance, H. Levesque, F. Lin, D. Marcu, R. Reiter, and R. Scherl. </author> <title> A Logical Approach to High-Level Robot Programming </title> - 
Reference-contexts: GOLOG <ref> [LLL + 94] </ref> provides a theoretical platform for reasoning about both physical and perceptual actions, i.e., actions whose effect it is to change an agent's knowledge of the state of affairs. GOLOG was initially conceived as a language for high-level robot programming. <p> An extension of this solution has been used for proving transaction safety in temporal deductive databases in [PM95]. Perceptual actions are dealt with in <ref> [LLL + 94] </ref>. [BMR93] depicts how the frame problem becomes particularly acute in object-oriented specifications where transactions are inherited and specialized from superclasses to subclasses. <p> jcheckedOut [dt]j + 1 end Action Issue-Reminder (br,bk,dt) Precondition: 9d (borrows (br; bk; d) ^ (today () d &gt; 2w) ^ :9d 0 ((d &lt; d 0 &lt; today ()) ^ reminderIssued (br; bk; d 0 ))) Postcondition: reminderIssued 0 (br; bk; dt) end 2 Situation Calculus and GOLOG GOLOG <ref> [LLL + 94] </ref> is a novel programming language that is suitable for defining and executing complex actions. The language was initially conceived for high-level robot control and is the result of extending the situation calculus with perceptual and complex actions, including non-determinate ones. <p> Finally, in appendix A we show how knowledge producing actions are taken into account <ref> [LLL + 94] </ref>. The succesor state axioms in this case only state that a particular predicate or function term becomes known as a result of a knowledge producing action taking place.
References-found: 12

