URL: http://www.cs.umn.edu/Research/softeng/paper/psinrea.ps
Refering-URL: http://www.cs.umn.edu/Research/softeng/
Root-URL: http://www.cs.umn.edu
Email: rsanjai-@cs.umn.edu  
Title: The Role of Program Slicing in Ripple Effect Analysis  
Author: Yamin Wang, Wei-Tek Tsai, Xiaoping Chen, Sanjai Rayadurgam wangy, tsai, xpchen, 
Address: Minneapolis, MN 55455  
Affiliation: Department of Computer Science University of Minnesota  
Abstract: Ripple Effect Analysis (REA) is an iterative process used to ensure consistency and integrity after changes are made to software. Many techniques, including program slicing, have been proposed to be used in this process with varying degrees of success. This paper shows how program slicing can be used in the REA process. Specifically this paper demonstrates the need of both forward and backward slicing in REA under different kinds of program changes. It also discusses the limitations of traditional program slicing techniques and shows how they can be overcome by employing a generalized program slicing technique. This paper also defines operations on program slices and show their usage in REA. A prototype supporting REA on COBOL programs has been implemented and data obtained by experimenting t he tool on industrial COBOL code are presented. The data show the size of typical program slices and the importance of focusing on direct ripples in the REA process. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> 18 </institution>
Reference: [Arnold 93] <author> R. S. Arnold and Shawn A. Bohner, </author> <title> Impact Analysis - Towards a Framework for Comparison, </title> <booktitle> Proceedings of International Conference on Software Maintenance, </booktitle> <year> 1993, </year> <pages> pp. 292-301. </pages>
Reference-contexts: Many techniques [Horwitz 86, Rome 86, Gallagher 91, McCabe 92, Joiner 93, Ning 94, Onoma 95] have been proposed to aid the automation of this step. <ref> [Arnold 93] </ref> list several alternative approaches (see Table 1). The usefulness of program slicing in the REA process and its comparative advantage over other techniques have been noted in [Arnold 93]. Program slicing extracts parts of a program that are related to a given point in the program. <p> 86, Gallagher 91, McCabe 92, Joiner 93, Ning 94, Onoma 95] have been proposed to aid the automation of this step. <ref> [Arnold 93] </ref> list several alternative approaches (see Table 1). The usefulness of program slicing in the REA process and its comparative advantage over other techniques have been noted in [Arnold 93]. Program slicing extracts parts of a program that are related to a given point in the program. The related parts are identified using both data and control dependence information.
Reference: [Chen 94] <author> X. P. Chen, W. T. Tsai, J. K. Joiner, H. Gandamaneni and J. Sun, </author> <title> Automatic Variable Classification for COBOL Programs, </title> <institution> TR-94-15, Computer Science Department, University of Minnesota, </institution> <year> 1994. </year>
Reference: [Ferrante 87] <author> J. Ferrante, K. J. Ottenstein and J. D. Warren, </author> <title> The Program Dependence Graph and its Use in Optimization, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 9, </volume> <month> July </month> <year> 1987, </year> <pages> pp. 319-349. </pages>
Reference: [Gallagher 91] <author> K. B. Gallagher and J. R. Lyle, </author> <title> Using Program Slicing in Software Maintenance, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 17, </volume> <year> 1991, </year> <pages> pp. 751-761. </pages>
Reference: [Joiner 93] <author> J. K. Joine r an d W. </author> <title> T . Tsa i, Ripple Effect Analysis, Program Slicing and Dependence Analysis, </title> <institution> TR-93-84, Computer Science Department, University of Minnesota, </institution> <year> 1993. </year>
Reference-contexts: This may in turn require additional changes. The phenomenon of a change to one part of an artifact affecting other related parts is called ripple effect and the iterative process of analyzing and eliminating side effects due to changes is called ripple effect analysis (REA) <ref> [Yau 78, Joiner 93] </ref>. The notion of ripple effect, though originally studied in the context of software programs, can be extended to all software artifacts including specifications, design and test cases [Joiner 93]. Also it 2 can be extended to span different artifacts across different phases of software life cycle. <p> The notion of ripple effect, though originally studied in the context of software programs, can be extended to all software artifacts including specifications, design and test cases <ref> [Joiner 93] </ref>. Also it 2 can be extended to span different artifacts across different phases of software life cycle. This paper focuses on REA on software programs only. When no more additional changes ... For each additional change ... <p> However, step 2 which identifies potentially affected areas can be automated depending on the formalism of the language used in the artifact and the techniques needed <ref> [Joiner 93] </ref>. Many techniques [Horwitz 86, Rome 86, Gallagher 91, McCabe 92, Joiner 93, Ning 94, Onoma 95] have been proposed to aid the automation of this step. [Arnold 93] list several alternative approaches (see Table 1).
Reference: [Horowitz 86] <author> E . Hor owi t z a nd R . Williamson, SODOS: </author> <title> A Software Document Support Environment Its Definition, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-12, No. 8, </volume> <month> Aug. </month> <year> 1986, </year> <pages> pp. 849-859. </pages>
Reference: [Horwitz 90] <author> S. Horwitz, T. Reps and D. Binkley, </author> <title> Interprocedural Slicing Using Dependence Graphs, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 12, </volume> <year> 1990, </year> <pages> pp. 26-60. </pages>
Reference-contexts: It starts with a slicing criterion specified as a tuple C=&lt;i, V&gt;, where i is a program statement and V is a set of variables, and produces a program slice, which is a set of statements that might affect the values of variables in the set V at statement i. <ref> [Horwitz 90] </ref> restricted the variables in V to be those referred (either 4 defined or used) in the statement i. A slice under the above definition is also known as backward program slice.
Reference: [Huang 95] <author> H. Huang, W. T. Tsai, S. Bhattacharya, X. P. Chen, Y. Wang, and J. Sun, </author> <title> Business Rule Extraction from Legacy Code, </title> <type> TR 95-034, </type> <institution> Computer Science Dept., University of Minnesota, </institution> <year> 1995. </year>
Reference: [Huang 96] <author> H. Huang, W. T. Tsai and S. Subramanian, </author> <title> Generalized Program Slicing for Software Maintenance, </title> <institution> Computer Science Department, University of Minnesota, </institution> <year> 1996. </year>
Reference-contexts: We also define some set-theoretic operations on program slices and explain their usefulness in REA. We further explore the limitations of traditional program slicing and propose the use of a generalized program slicing 3 technique <ref> [Huang 96] </ref> in REA. One of the drawbacks, confirmed by the data that are collected from sample industrial COBOL program, is the relatively large size of the slice produced by traditional program slicing in comparison to the total size of the parts requiring changes. <p> This assumes that one has a technique to distinguish the direct ripples from induced ripples, and the number of direct ripples is small compared to the total number of potential ripples which consists of both direct and induced ripples. Generalized program slicing technique <ref> [Huang 96] </ref> 12 briefly discussed in section 5.1, can be used to identify the direct ripples. Section 5.2 provides some experimental data which support the second assumption. 5.1. <p> When program slicing is used in the REA process, the ripple set obtained can be large due to the inclusion of both direct and induced ripples. To overcome the limitations of program slicing, <ref> [Huang 96] </ref> proposed a generalized program slicing technique, which redefines the slicing criterion: A generalized slicing criterion is a tuple C=&lt;i, V, Cons, d&gt;, where i: a program statement; V: a set of variables; Cons: a set of constraints; and d: the slicing direction, either backward or forward.
Reference: [McCabe 92] <author> McCabe & Associates, Inc., </author> <title> Battlemap Analysis Tool Reference Manual, </title> <publisher> McCabe & Associates, Inc., </publisher> <address> Twin Knolls Professional Park, 5501 Twin Knolls Road, Columbia, MD, </address> <month> Dec. </month> <year> 1992. </year>
Reference: [Ning 94] <author> J. Q. Ning, A. Engberts and W. Kozaczynski, </author> <title> Automated Support for Legacy Code Understanding, </title> <journal> Communications of the ACM, </journal> <volume> Vol. 37, No. 5, </volume> <month> May </month> <year> 1994, </year> <pages> pp. 50-57. 19 </pages>
Reference-contexts: Typically, only forward slicing, which traces control and data dependence in the forward direction, is performed to identify the affected parts <ref> [Ning 94] </ref>. This paper shows that forward slicing alone is not sufficient and that a backward slicing operation must also be performed to identify the affected parts in step 2 of REA. We also define some set-theoretic operations on program slices and explain their usefulness in REA.
Reference: [Onoma 95] <author> A. K. Onoma, W. T. Tsai, F. Tsunoda, H. Suganuma and S. Subramanian, </author> <title> "Software Maintenance - Industrial Experience", </title> <journal> Journal of Software Maintenance, </journal> <volume> Vol. 7, </volume> <month> Dec. </month> <year> 1995, </year> <pages> pp. 333-375 </pages>
Reference-contexts: One can also use the intersection of program slices to determine the program segments that are affected by every individual change. In regression testing, one may wish to determine the parts of the code which are not affected by the given changes <ref> [Onoma 95] </ref>, and this can be done by obtaining the complement of the union of the related program slices. In other words, these set-theoretic operations can be defined on program slices, and they are useful in software maintenance.
Reference: [Rome 86] <institution> Rome Air Development Center, Automated Life Cycle Impact Analysis System, RADC-TR-86-197, Air Force Systems Command, Griffiss Air Force Base, Rome, </institution> <address> NY, </address> <month> December </month> <year> 1986. </year>
Reference: [Weiser 84] <author> M. Weiser, </author> <title> Program Slicing, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 10, </volume> <month> July </month> <year> 1994, </year> <pages> pp. 352-357. </pages>
Reference-contexts: Section 6 illustrates the REA concepts with an example. Appendix A discusses various program changes and Appendix B describes our prototype implementation. 2. Program Slicing Program slicing was initially introduced as a technique of decomposing a program based on data and control flow information <ref> [Weiser 84] </ref>. It was proposed to be used in debugging and maintenance activities that call for understanding of program behavior.
Reference: [Yau 78] <author> S. S. Yau, J. S. Collofello and T. MacGregor, </author> <title> Ripple Effect Analysis of Software Maintenance, </title> <booktitle> Proceedings of IEEE COMPSAC, </booktitle> <year> 1978, </year> <pages> pp. 60-65. </pages>
Reference-contexts: This may in turn require additional changes. The phenomenon of a change to one part of an artifact affecting other related parts is called ripple effect and the iterative process of analyzing and eliminating side effects due to changes is called ripple effect analysis (REA) <ref> [Yau 78, Joiner 93] </ref>. The notion of ripple effect, though originally studied in the context of software programs, can be extended to all software artifacts including specifications, design and test cases [Joiner 93]. Also it 2 can be extended to span different artifacts across different phases of software life cycle.
Reference: [Zima 91] <author> H. Zima and B. Chapman, </author> <title> Supercompilers for Parallel and Vector Computers, </title> <publisher> Addison-Wesley, </publisher> <address> Wokingham, England, </address> <year> 1991. </year>
References-found: 17

