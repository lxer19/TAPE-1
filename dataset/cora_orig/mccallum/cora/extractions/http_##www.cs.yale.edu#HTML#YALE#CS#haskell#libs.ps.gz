URL: http://www.cs.yale.edu/HTML/YALE/CS/haskell/libs.ps.gz
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/haskell/
Root-URL: http://www.cs.yale.edu
Title: A Standard Library Proposal for Haskell 1.3 Version 3 DRAFT DRAFT DRAFT  
Author: Alastair Reid John Peterson 
Date: September 6, 1995  
Affiliation: Yale  
Pubnum: Haskell Project  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> L Augustsson, W Burton, and M Jones. </author> <title> Thoughts on 1.3. Haskell 1.3 committee mailing list, </title> <month> May </month> <year> 1994. </year>
Reference-contexts: libraries are based on the libraries provided with HBC. * The Grasp/Aqua team at Glasgow | many of the other libraries are based on the libraries provided with GHC. * The Haskell 1.3 committee | this proposal draws on discussions in the committee mailing list about the Haskell Prelude (especially <ref> [1] </ref>). * Andy Gill (Glasgow) has contributed a design for LibBitSet (section 4.17) (as well as many individual functions).
Reference: [2] <author> L Augustsson, M Rittri, and D Synek. </author> <title> On generating unique names. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(1) </volume> <pages> 117-123, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: We consider this to be a feature since it is not clear that being able to access the random state would be at all useful without also knowing how much of the supply tree had been evaluated (see <ref> [2] </ref> for yourself). Portability The algorithm used to calculate random numbers must be precisely specified to ensure portability. Making the algorithm available for public scrutiny also increases the chance of discovering fatal flaws in the choice of generator. <p> let rs = iterate nextRand r in &gt; -- return (map (fromRandomState l h) rs) &gt; &gt; randomSupply :: Random r =&gt; r -&gt; r -&gt; IO (Supply r) &gt; -- randomSupplyIO l h = randomListIO l h &gt;>= initialSupply 4 NEW LIBRARIES 29 4.16 Supply Augustsson, Rittri and Synek <ref> [2] </ref> describe an implementation of efficient splittable name supplies. This is useful for many purposes inside a compiler | it is also very useful when used in conjunction with a random number generator (section 4.15). We make two small changes to the design: 1.
Reference: [3] <author> RS Bird and PL Wadler. </author> <title> Introduction to Functional Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: [a] -- sort using &lt;= &gt; -- sort = sortBy (&lt;=) &gt; sortBy :: (a-&gt;a->Bool) -&gt; [a] -&gt; [a] -- sort using supplied &lt;= predicate 4.5.2 Subsequences The following operations on subsequences of lists occasionally prove useful. (prefixes, suffixes, subsequences and permutations are called inits, tails, subs and perms in <ref> [3] </ref>.) &gt; prefixes, suffixes :: [a] -&gt; [[a]] &gt; suffixes :: [a] -&gt; [[a]] &gt; subsequences, permutations :: [a] -&gt; [[a]] &gt; &gt; isPrefixOf, isSuffixOf :: Eq a =&gt; [a] -&gt; [a] -&gt; Bool &gt; isSubsequenceOf, isPermutationOf :: Eq a =&gt; [a] -&gt; [a] -&gt; Bool &gt; &gt; isPrefixOfBy, isSuffixOfBy ::
Reference: [4] <author> J Horning, B Kalsow, P McJones, and G Nelson. </author> <title> Some useful Modula-3 interfaces. </title> <type> Technical Report 113, </type> <institution> Digital Systems Research Centre, </institution> <month> December </month> <year> 1993. </year>
Reference: [5] <author> John Hughes. </author> <title> Lazy memo-functions. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <year> 1985. </year>
Reference-contexts: These are not quite powerful enough to implement Hughes' lazy memo-functions <ref> [5] </ref>.
Reference: [6] <author> G Hutton. </author> <title> Higher-order functions for parsing. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(3) </volume> <pages> 323-343, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: There is an obvious monad associated with parsers, which avoids having to think of too many new names. The other names are loosely based on Hutton's. This still leaves a choice of interfaces based on how general we wish to be. 1. Hutton <ref> [6] </ref> describes a set of combinators for parsers based on (a type isomorphic to) ReadS. As well as tying us to the lex function (which is gratuitiously inefficient), this requires us to wrap ReadS in a newtype to allow use of constructor classes.
Reference: [7] <author> MP Jones. </author> <title> A system of constructor classes: overloading and implicit higher-order polymor-phism. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <year> 1993. </year>
Reference-contexts: This is used for matrices (section 4.18) to allow special instances to be defined for two-dimensional matrices without incurring the overhead of defining a new datatype. Constructor Classes <ref> [7] </ref> allow functions to be overloaded with respect to type constructors (ie not just types). This is used to define a monad class which is used to simplify the parsing library (sections 4.8 and 4.13).
Reference: [8] <editor> SL Peyton Jones and PL Wadler. </editor> <title> Imperative functional programming. </title> <booktitle> In Principles of Programming Languages, </booktitle> <pages> pages 71-84. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1993. </year>
Reference-contexts: Implementers might also like to provide compiler and runtime flags to disable tracing. 5.2 NonStdIO Both Glasgow and Yale provide the following operations. &gt; unsafePerformIO :: IO a -&gt; a &gt; unsafeInterleaveIO :: IO a -&gt; IO a These are described in <ref> [8] </ref> where they are called performIO and delayIO respectively. These allow programmers to break the monad abstraction (hence their names) but they are extremely useful when used carefully.
Reference: [9] <author> John Launchbury and Simon L Peyton Jones. </author> <title> Lazy functional state threads. </title> <booktitle> In Programming Languages Design and Implementation, </booktitle> <year> 1994. </year>
Reference-contexts: The Glasgow interface is slightly more flexible than the above instead of threading variables into the IO monad, they are part of the State Transformer monad <ref> [9] </ref>. This monad requires some use of rank-2 polymorphism within the typechecker | complicating implementation outside Glasgow. Apart from being more flexible, the only difference is that the types MutableVar and MutableArray have an extra type parameter which is used to distinguish variables from dif ferent threads. 2.
Reference: [10] <author> JT O'Donnell. </author> <title> Bidirectional fold and scan. </title> <booktitle> In Draft Proceedings of Glasgow Functional Programming Workshop, pages XX1 - XX6. Glasgow Functional Programming Group, </booktitle> <month> July </month> <year> 1993. </year>
Reference-contexts: They were called "mapping scans" in <ref> [10] </ref>. 4.5.4 Duplicates The following operations are useful in conjunction with sort for removing duplicates. &gt; groupBy :: (a -&gt; a -&gt; Bool) -&gt; [a] -&gt; [[a]] &gt; groupBy eq [] = [] &gt; groupBy eq (x:xs) = let (ys,zs) = span (eq x) xs in (x:ys) : groupBy eq zs
Reference: [11] <author> A Reid and J Peterson. </author> <title> Designing the standard Haskell libraries (position paper). </title> <booktitle> In Haskell Workshop, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: This document is a first attempt at defining a set of standard libraries for including in Haskell 1.3. Earlier versions of this document discussed various design issues such as naming conventions, criteria for standardising a given module, etc. This discussion is now available as a separate document <ref> [11] </ref>. The first part of this document consists of libraries that we consider worthy of standardisation (section 4); the second consists of libraries that we do not propose adding to the standard: section 5 describes libraries which everyone provides but make language theoreticians shudder.
Reference: [12] <author> GL Steele. </author> <title> Common Lisp | The Language. </title> <publisher> Digital Press, </publisher> <address> 2 edition, </address> <year> 1994. </year>
Reference-contexts: The solution adopted in Common LISP <ref> [12] </ref> is to introduce a new type random-state which may be copied, written to a file, read from a file and "randomly initialised" (eg by consulting time of day clock). Reading and writing the state to a file is provided to enable reproducible results. <p> That is, when arithmetic shifting a negative number to the right, the number will be filled with 1's. See <ref> [12] </ref> for discussion. * We should add a bit-testing method to test whether a specific bit is set. New from Andy Gill. (Doesn't address 2's complement issue.) A couple of points: 1.
Reference: [13] <author> PL Wadler. </author> <title> How to replace failure by a list of successes. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <year> 1985. </year>
Reference-contexts: The obvious trick of performing eta-expansion won't work if the type Parser is abstract. 2. Because of the exception handling, parsers built using parser combinators are often strict | they have to do an entire parse before they can return any part of the result. Wadler <ref> [13] </ref> describes how to turn parsing exceptions into errors to overcome this problem. (From memory), he uses: noFail :: Parser [a] b -&gt; Parser [a] b noFail p i = let (a,i'):rs = p i in (a,i'):rs The final proposal must provide this function! 4 NEW LIBRARIES 26 4.14 Binary Haskell
Reference: [14] <author> PL Wadler. </author> <title> Comprehending monads. </title> <booktitle> In Proc ACM Conference on Lisp and Functional Programming, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: :: Monad m =&gt; [m a] -&gt; m [a] &gt; accumulateR :: Monad m =&gt; [m a] -&gt; m [a] &gt; sequenceL :: Monad m =&gt; [m a] -&gt; m () &gt; sequenceR :: Monad m =&gt; [m a] -&gt; m () Note: the accumulate functions are called map in <ref> [14] </ref>. &gt; apply :: Monad m =&gt; (a -&gt; m b) -&gt; (m a -&gt; m b) &gt; (@@) :: Monad m =&gt; (a -&gt; m b) -&gt; (c -&gt; m a) -&gt; (c -&gt; m b) &gt; mapL :: Monad m =&gt; (a -&gt; m b) -&gt; ([a] -&gt; m
References-found: 14

