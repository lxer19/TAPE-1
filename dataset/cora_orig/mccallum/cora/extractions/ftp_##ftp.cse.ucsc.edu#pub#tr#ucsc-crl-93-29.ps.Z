URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-93-29.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: A Class of Synchronization Operations that Permit Efficient Race Detection  
Author: D. P. Helmbold, C. E. McDowell 
Keyword: trace analysis, race detection, debugging, parallel programming, event ordering  
Address: Santa Cruz, CA 95064  
Affiliation: Board of Studies in Computer and Information Sciences University of California, Santa Cruz  
Date: August 2, 1993  
Pubnum: UCSC-CRL-93-29  
Abstract: We present an efficient algorithm for "precisely" determining the possible alternate orderings of events from a program trace for a class of synchronization operations. The class includes, post and wait without clear, a restricted form of semaphores, and message passing where the sender names the receiver. The ordering information is precise in that a race detection system could be built using the ordering information such that if the program does not contain any data races for a given input, no races will be reported, and if the the program does contain data races, at least one of those races will be reported. 
Abstract-found: 1
Intro-found: 1
Reference: [CS88] <author> D. Callahan and J. Subhlok. </author> <title> Static analysis of low-level synchronization. </title> <booktitle> In Proc. Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 100-111, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Each receive in task R is replaced by V (R). Each Send-to (R) is replaced by V (R). The resulting program will be an SRP-program and the result then follows from Lemma 5.1. 6 Conclusions and Further Work Because so many questions regarding races and event orderings are intractable <ref> [CS88, NM90] </ref>, it is important to precisely identify those questions that can be answered in polynomial time.
Reference: [HMW93] <author> D. P. Helmbold, C. E. McDowell, and J. Z. Wang. </author> <title> Determining possible event orders by analyzing sequential traces. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <note> 1993. Also UCSC Tech. Rep. UCSC-CRL-91-36. </note>
Reference-contexts: In order to improve the accuracy of race detection it appears necessary to consider alternative executions when analyzing a trace. The approach of our work and others <ref> [NM91, NG92, HMW93] </ref> is to compute a partial order representing the order in which the events from a trace did or might have occurred. This ordering information can be combined with memory access information to perform either on-the-fly or post-mortem race detection. <p> This straight line program is inferred from the original program and the trace. We introduced the inferred program to characterize the guaranteed orderings in a previous paper <ref> [HMW93] </ref>, and we will use it again in this paper. <p> By Lemma 3.4 all traces of P 0 contain the same events, contradicting the assumption that e 0 62 T 0 . 4. Our Algorithm 5 In <ref> [HMW93] </ref> we proved that if e 1 e 2 in the inferred program P T then whenever e 2 !e 1 in some trace T 0 of P , there is a race in P that happens before either e 1 or e 2 .
Reference: [LKN93] <author> H-I. Lu, P. N. Klein, and R. H. B. Netzer. </author> <title> Detecting race conditions in parallel programs that use one semaphore. </title> <type> Technical report, </type> <institution> Brown Univ., </institution> <year> 1993. </year>
Reference-contexts: Thus the only must-have-happened-before relationships are between events executed by the same task. Another example is the use of a single semaphore. Programs that use only one semaphore are not monotonically synchronized but a polynomial algorithm for computing precise ordering information has been found <ref> [LKN93] </ref>. An interesting open question is if there is a more interesting non-monotonic set of synchronization operations where the must-have-happened-before relation can be exactly and efficiently computed (for straight line programs). 10 6.
Reference: [NG92] <author> R. H. B. Netzer and S. Ghosh. </author> <title> Efficient race condition detection for shared-memory programs with Post/Wait synchronization. </title> <booktitle> In Proc. International Conf. on Parallel Processing, </booktitle> <year> 1992. </year>
Reference-contexts: In order to improve the accuracy of race detection it appears necessary to consider alternative executions when analyzing a trace. The approach of our work and others <ref> [NM91, NG92, HMW93] </ref> is to compute a partial order representing the order in which the events from a trace did or might have occurred. This ordering information can be combined with memory access information to perform either on-the-fly or post-mortem race detection. <p> Recently, Netzer and Ghosh showed how to compute a "precise guaranteed ordering graph" in polynomial time for programs using post and wait synchronization (without clears) <ref> [NG92] </ref>. Their ordering graph is precise in that a race detection system that relies on this ordering information can be constructed such that: 1. <p> This class includes: * post/wait synchronization without clears <ref> [NG92] </ref>, * message passing where the receiver is named by the sender, and * semaphores when all P (X) operations for a particular semaphore X occur in the same task. Netzer and Ghosh define a maximal valid execution [NG92] for an event e which is a maximal sequence of post and <p> This class includes: * post/wait synchronization without clears <ref> [NG92] </ref>, * message passing where the receiver is named by the sender, and * semaphores when all P (X) operations for a particular semaphore X occur in the same task. Netzer and Ghosh define a maximal valid execution [NG92] for an event e which is a maximal sequence of post and wait events from an inferred program that satisfies the post/wait semantics and could precede the event e. <p> Theorem 3.5 (below) gives us an easy way to determine the must-have-happened-before relation for a MSSL program. For each event, form the modified program and compare their traces. This idea was used by Netzer and Ghosh <ref> [NG92] </ref> and is exploited by our algorithms in the next section. Lemma 3.4: Every trace of a MSSL program contains the same events. Proof: Follows directly from the definition. <p> P on input I takes the same branches as taken by P T , trace T 0 must also be a trace of P T which contradicts e f in P T . 4 Our Algorithm The basic algorithm is quite similar to the one presented by Netzer and Ghosh <ref> [NG92] </ref>. It is a direct consequence of the observation captured in Theorem 3.5. It essentially finds what Netzer and Ghosh called the maximal valid execution sequence for each event and then adds the appropriate edges to the Guaranteed Ordering Graph. The algorithm considers each task in turn. <p> The worst running time can be reduced to O (nt) if a clever data structure can be used to identify the unblocked events which are about to be executed without iterating through the tasks. One way to do this for post/wait synchronization was presented in <ref> [NG92] </ref>. <p> We have shown that if every straight line program using a set of synchronization operations always ends in the same state (monotonic synchronization), then the must-have-happened-before relation for any such program can be efficiently computed. This extends 6. Conclusions and Further Work 9 the results of Netzer and Ghosh <ref> [NG92] </ref>, who show how to efficiently compute the must-have-happened-before relation for straight line programs using post/wait synchronization (without clear). Although few real programs are straight line, the execution trace of any program allows one to infer a straight line program.
Reference: [NM90] <author> R. H. B. Netzer and B. P. Miller. </author> <title> On the complexity of event ordering for shared-memory parallel program executions. </title> <booktitle> In Proc. International Conf. on Parallel Processing, </booktitle> <volume> volume II, </volume> <pages> pages 93-97, </pages> <year> 1990. </year>
Reference-contexts: Each receive in task R is replaced by V (R). Each Send-to (R) is replaced by V (R). The resulting program will be an SRP-program and the result then follows from Lemma 5.1. 6 Conclusions and Further Work Because so many questions regarding races and event orderings are intractable <ref> [CS88, NM90] </ref>, it is important to precisely identify those questions that can be answered in polynomial time.
Reference: [NM91] <author> R. H. B. Netzer and B. P. Miller. </author> <title> Improving the accuracy of data race detection. </title> <journal> SIGPLAN Notices (Proc. PPOPP), </journal> <volume> 26(7) </volume> <pages> 133-144, </pages> <year> 1991. </year>
Reference-contexts: In order to improve the accuracy of race detection it appears necessary to consider alternative executions when analyzing a trace. The approach of our work and others <ref> [NM91, NG92, HMW93] </ref> is to compute a partial order representing the order in which the events from a trace did or might have occurred. This ordering information can be combined with memory access information to perform either on-the-fly or post-mortem race detection.
Reference: [NR88] <author> I. Nudler and L. Rudolph. </author> <title> Tools for efficient development of efficient parallel programs. </title> <booktitle> In First Israeli Conference on Computer Systems Engineering, </booktitle> <year> 1988. </year>
Reference-contexts: We end the section with a proof that our algorithm can be used to satisfy the two requirements of precise guaranteed ordering graphs mentioned in the introduction. 1 Tasks can be identified across executions by a simple lexicographic method such as the English half of an English-Hebrew label <ref> [NR88] </ref>. 2 pred (e) is the event preceding event e in the same task. If e is the first event in the task then pred (e) = ; and ; for one trace corresponds to ; for all other traces. 4 3.
References-found: 7

