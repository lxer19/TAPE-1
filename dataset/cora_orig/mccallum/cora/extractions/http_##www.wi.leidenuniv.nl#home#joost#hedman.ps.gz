URL: http://www.wi.leidenuniv.nl/home/joost/hedman.ps.gz
Refering-URL: http://www.wi.leidenuniv.nl/home/joost/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fEric.Hedman,Kaisa.Sereg@abo.fi  joost@cs.leidenuniv.nl  
Phone: 2  
Title: Coordinating Action Systems  
Author: Eric J. Hedman Joost N. Kok and Kaisa Sere P. O. Box , RA 
Address: Lemminkainengatan 14, fin-20520 Abo, Finland  Netherlands  
Affiliation: 1 Turku Centre for Computer Science Department of Computer Science, Abo Akademi University  Department of Computer Science, Leiden University  Leiden, The  
Abstract: We develop an action systems based approach that supports the separation of design of the functional or computation aspects of a system under construction from the coordination and synchronization issues. The computation aspects are modelled as nondeterministic actions that work in parallel with the coordination actions, which impose some control on this nondeterministic part. We define a special form of action systems that models this type of coordination activity. Certain forms of real time scheduling and coordination as well as exception handling are shown to be special cases of our approach. We show how the coordinators can be stepwise brought about from a high-level specification of the target system and how the reasoning about their behaviours is carried out separately from the computation aspects of the system within the refinement calculus.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Los Alamos, California, </address> <year> 1986. </year>
Reference-contexts: For Gamma programs [8] for instance a construct called scheduler is introduced [11]. The purpose of a scheduler is to restrict the nondeterminism present in a Gamma program. Another construct is the rtsynchronizer [19], which is a special form of an actor <ref> [1] </ref>. Often there have been difficulties in incorporating the new constructs into a formal framework. For example, there is no formal semantics given to the rtsynchronizers neither do they come with a methodology to reason about them or develop systems that involve them.
Reference: 2. <author> R. J. R. </author> <title> Back. On the Correctness of Refinement Steps in Program Development. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Helsinki, Helsinki, Finland, </institution> <year> 1978. </year> <note> Report A-1978-4. </note>
Reference: 3. <author> R. J. R. </author> <title> Back. Refinement calculus, part II: Parallel and reactive programs. </title> <editor> In J. W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness. </title> <booktitle> Proceedings. 1989, volume 430 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: We have for instance that a reactive component does not terminate by itself: termination is a global property of the composed action system. More on these topics can be found elsewhere <ref> [3] </ref>. Prioritizing Composition. Let the action systems A and B be as above.
Reference: 4. <author> R. J. R. Back and R. Kurki-Suonio. </author> <title> Decentralization of process nets with centra-lized control. </title> <booktitle> In Proc. of the 2nd ACM SIGACT-SIGOPS Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 131-142, </pages> <year> 1983. </year>
Reference-contexts: The main contribution of this paper is to show how coordination can be modelled within an existing formal framework where both computation and coordination aspects are treated equally and uniformly. We formalize our ideas within the action systems formalism. The action system formalism <ref> [4] </ref> is a state based approach to distributed computing. A set of guarded actions share some state variables and may act on those variables. The two main development techniques we use on action systems are refinement and prioritized decomposition.
Reference: 5. <author> R.J.R. Back and K. Sere. </author> <title> Stepwise refinement of action systems. </title> <journal> Structured Programming, </journal> <volume> 12 </volume> <pages> 17-30, </pages> <year> 1991. </year>
Reference: 6. <author> R. J. R. Back and K. Sere. </author> <title> From modular systems to action systems. </title> <booktitle> Proc. of Formal Methods Europe'94, </booktitle> <address> Spain, </address> <month> October </month> <year> 1994. </year> <booktitle> Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The definition of procedures (with formal parameters) for action systems is studied more detailed elsewhere <ref> [6] </ref>. Enabledness of an Action. The actions contain arbitrary program statements. A statement that establishes any postcondition is said to be miraculous. We take the view that a statement S is only enabled in those initial states in which it behaves nonmiraculously, i.e. for which :wp (S; false) holds. <p> 0 ; y 0 ; do B od ]j : x , and C b= j [ proc q fl ; var c; zfl := c 0 ; z 0 ; do C od ]j : x : This development method for action systems, originally proposed by Back and Sere <ref> [6] </ref>, is also applicable to prioritized programs in a slightly different form [20].
Reference: 7. <author> R. J. R. Back and J. von Wright. </author> <title> Trace Refinement of Action Systems In B. Jonsson, </title> <editor> J. Parrow, editors, </editor> <booktitle> CONCUR '94: Concurrency Theory. Proceedings. 1994, volume 836 of Lecture Notes in Computer Science, </booktitle> <pages> pages 367-384. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The design and reasoning about action systems is carried out within the refinement calculus [2,5,17,18] that is based on the use of predicate transformers [14]. The main refinement technique used here is data refinement <ref> [7] </ref>. We show how the coordination part can be stepwise developed from a high-level task description of a system within the refinement calculus. The advantage we gain is that we are able to reason in a structured way about the two aspects, functionality and coordination, within the same framework. <p> The restriction we impose is that all actions are (finitely) conjunctive, hence excluding angelic nondeterminism <ref> [7] </ref>: wp (A; P ^ Q) = wp (A; P) ^ wp (A; Q) : All of the above operators are conjunctive or preserve conjunctivity. Conjuncti-vity implies monotonicity: (P ) Q) ) (wp (A; P) ) wp (A; Q)) : Definition of Procedures.
Reference: 8. <author> J.-P. Ban^atre and D. Le Metayer. </author> <title> Programming by multiset transformation. </title> <journal> Communications of the ACM, </journal> <volume> 36(1) </volume> <pages> 98-111, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Recently, several languages and models for coordinating the work of independent agents have been proposed in the literature [9]. Many researchers have designed dedicated languages for coordination, separate from the language to model computation [12]. For Gamma programs <ref> [8] </ref> for instance a construct called scheduler is introduced [11]. The purpose of a scheduler is to restrict the nondeterminism present in a Gamma program. Another construct is the rtsynchronizer [19], which is a special form of an actor [1].
Reference: 9. <author> N. Carriero and D. Gelernter. </author> <title> Coordination languages and their significance. </title> <journal> Communications of the ACM, </journal> <volume> 35(2) </volume> <pages> 97-107, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Recently, several languages and models for coordinating the work of independent agents have been proposed in the literature <ref> [9] </ref>. Many researchers have designed dedicated languages for coordination, separate from the language to model computation [12]. For Gamma programs [8] for instance a construct called scheduler is introduced [11]. The purpose of a scheduler is to restrict the nondeterminism present in a Gamma program.
Reference: 10. <author> K. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Additionally, parallel decomposition allows us to split an action system into parallel sub-systems by partitioning state variables and actions. Action systems are related to the unity programs of Chandy and Misra <ref> [10] </ref>. Reasoning about unity programs is done within an associated temporal logic. This relies heavily on the underlying fairness assumption in the execution model. For some applications this is convenient, but not always. No such assumptions are made for action systems.
Reference: 11. <author> M. Chaudron and E. de Jong. </author> <title> Towards a Compositional Method for Coordinating Gamma Programs. </title> <booktitle> In [12]. </booktitle>
Reference-contexts: 1 Introduction Recently, several languages and models for coordinating the work of independent agents have been proposed in the literature [9]. Many researchers have designed dedicated languages for coordination, separate from the language to model computation [12]. For Gamma programs [8] for instance a construct called scheduler is introduced <ref> [11] </ref>. The purpose of a scheduler is to restrict the nondeterminism present in a Gamma program. Another construct is the rtsynchronizer [19], which is a special form of an actor [1]. Often there have been difficulties in incorporating the new constructs into a formal framework.
Reference: 12. <editor> P. Ciancarini and C. Hankin, editors. Coordination'96: </editor> <booktitle> Coordination Languages and Models, volume 1061 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Recently, several languages and models for coordinating the work of independent agents have been proposed in the literature [9]. Many researchers have designed dedicated languages for coordination, separate from the language to model computation <ref> [12] </ref>. For Gamma programs [8] for instance a construct called scheduler is introduced [11]. The purpose of a scheduler is to restrict the nondeterminism present in a Gamma program. Another construct is the rtsynchronizer [19], which is a special form of an actor [1].
Reference: 13. <author> H.C. Cunningham and G.C. Roman. </author> <title> A unity-style programming logic for a shared dataspace language. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(3) </volume> <pages> 365-376, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Reasoning about unity programs is done within an associated temporal logic. This relies heavily on the underlying fairness assumption in the execution model. For some applications this is convenient, but not always. No such assumptions are made for action systems. Gamma and Swarm <ref> [13] </ref> programs also work on a set of actions that are intended to be executed in a nondeterministic fashion. At first sight the philosophy behind design approaches like unity and action systems does not seem to support the coordination paradigm with its separation of computation from coordination.
Reference: 14. <author> E. W. Dijkstra. </author> <title> A Discipline of Programming. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1976. </year>
Reference-contexts: The design and reasoning about action systems is carried out within the refinement calculus [2,5,17,18] that is based on the use of predicate transformers <ref> [14] </ref>. The main refinement technique used here is data refinement [7]. We show how the coordination part can be stepwise developed from a high-level task description of a system within the refinement calculus. <p> Furthermore, each procedure and action may have local variables of its own. Actions are taken to be atomic, meaning that only their input-output beha-viour is of interest. They can be arbitrary sequential statements. Their behaviour can therefore be described by the weakest precondition predicate transformer of Dijkstra <ref> [14] </ref>, where wp (A; P) is the weakest precondition such that action A terminates in a state satisfying predicate P.
Reference: 15. <author> H. J. M. Goeman, J. N. Kok, K. Sere, and R. T. Udink. </author> <title> Coordination in the Impunity Framework. </title> <booktitle> In [12]. </booktitle>
Reference-contexts: Moreover, we can develop and refine these two lines independently of each other due to the com-positionality of our (de-)composition operators. This paper extends our previous work on coordination <ref> [15] </ref> into several directions. Earlier we showed how a typical communication medium for coordination, the tuple space, is added into a unity like language, Impunity [21], and how this form of communication is used with a unity style refinement. <p> The former approach to coordination is the usual action systems approach where the coordination is not separated from the rest of the system. This form was also studied in our earlier work <ref> [15] </ref>. We will here concentrate on the latter form of coordination. Coordinators. A typical action system to be coordinated has some autonomous activity of its own, below modelled by the action A. <p> Since shared variables is the typical way to achieve asynchronous communi-catinon in our framework we can realize such a tuple space by declaring (and exporting) one or more variables of suitable type. The tuple space can be defined explicitly as was proposed earlier for Impunity <ref> [15] </ref>. In the examples below we assume the existence of a tuple space, i.e. variable of type bag, that all the reactive components have access to. Furthermore, a tuple will have the form hti where t denotes its contents.
Reference: 16. <author> H. J. M. Goeman, J. N. Kok, K. Sere, and R. T. Udink. </author> <title> Coordination in the ImpUnity Framework. </title> <type> TUCS Technical Report No 50, </type> <month> October </month> <year> 1996. </year> <institution> Turku, Finland. </institution>
Reference-contexts: Below we give two different examples of coordinators derived within this framework. For the sake of brevity we omit the details of the refinement steps and only present the results. A Phone System. In an earlier study <ref> [16] </ref> we developed an Impunity specification for a system of phones. The initial specification was given in a unity style.
Reference: 17. <author> C. C. Morgan. </author> <title> The specification statement. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 403-419, </pages> <month> July </month> <year> 1988. </year>
Reference: 18. <author> J. M. Morris. </author> <title> A theoretical basis for stepwise refinement and the programming calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 9 </volume> <pages> 287-306, </pages> <year> 1987. </year>
Reference: 19. <author> S. Ren and G. Agha. </author> <title> A Modular Approach for Programming Distributed Real-Time Systems. </title> <booktitle> In Hand-Out, European Educational Forum, School on Embedded Systems, </booktitle> <month> November </month> <year> 1996, </year> <note> Veldhoven, NL. </note>
Reference-contexts: Many researchers have designed dedicated languages for coordination, separate from the language to model computation [12]. For Gamma programs [8] for instance a construct called scheduler is introduced [11]. The purpose of a scheduler is to restrict the nondeterminism present in a Gamma program. Another construct is the rtsynchronizer <ref> [19] </ref>, which is a special form of an actor [1]. Often there have been difficulties in incorporating the new constructs into a formal framework. <p> The examples show only the coordination aspects of the problem at hand. They are inspired by similar examples on rtsynchronizers that were studied during a recent research school on Embedded Systems in Veldhoven, The Netherlands <ref> [19] </ref>. Event Coordination. In the first example we have two action systems that model the left and right hands of a robot.
Reference: 20. <author> E. Sekerinski and K. Sere. </author> <title> A theory of prioritizing composition. </title> <journal> The Computer Journal. </journal> <note> To appear. </note>
Reference-contexts: Refinement allows us to replace abstract state variables with more concrete representations such that the beha-viour of the refined action system satisfies the behaviour of the abstract action system. The recently introduced prioritizing composition between actions and action systems <ref> [20] </ref> turns out to be a convenient way of expressing coordination policies. Additionally, parallel decomposition allows us to split an action system into parallel sub-systems by partitioning state variables and actions. Action systems are related to the unity programs of Chandy and Misra [10]. <p> exclude each other, the prioritizing composition and choice coincide: A==B = A [] B if gdA ) :gdB : Furthermore, the prioritizing composition of actions distributes over choice to the right: A==(B [] C) = (A==B) [] (A==C) : Other properties of this operator are studied by Sekerinski and Sere <ref> [20] </ref>. Parallel Composition. <p> and C b= j [ proc q fl ; var c; zfl := c 0 ; z 0 ; do C od ]j : x : This development method for action systems, originally proposed by Back and Sere [6], is also applicable to prioritized programs in a slightly different form <ref> [20] </ref>.
Reference: 21. <author> R.T. Udink. </author> <title> Program Refinement in unity-like Environments. </title> <type> PhD Thesis, </type> <institution> Utre-cht University, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: This paper extends our previous work on coordination [15] into several directions. Earlier we showed how a typical communication medium for coordination, the tuple space, is added into a unity like language, Impunity <ref> [21] </ref>, and how this form of communication is used with a unity style refinement. Here we extend this by considering coordination as a language construct and propose a general strategy to derive coordinators or schedulers.
References-found: 21

