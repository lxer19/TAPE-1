URL: http://www.cs.man.ac.uk/~kung-kiu/pub/ase97.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: pf@cs.bilkent.edu.tr  kung-kiu@cs.man.ac.uk  ornaghi@dsi.unimi.it  
Title: Correct-schema-guided Synthesis of Steadfast Programs  
Author: Pierre Flener Kung-Kiu Lau Mario Ornaghi 
Address: 06533 Bilkent, Ankara, Turkey  Manchester M13 9PL, UK  20135 Milano, Italy  
Affiliation: Dept of Computer Science Bilkent University  Dept of Computer Science University of Manchester  DSI Univ. degli studi di Milano  
Abstract: It can be argued that for (semi-)automated software development, program schemas are indispensable, since they capture not only structured program design principles, but also domain knowledge, both of which are of crucial importance for hierarchical program synthesis. Most researchers represent schemas purely syntactically (as higher-order expressions). This means that the knowledge captured by a schema is not formalised. We take a semantic approach and show that a schema can be formalised as an open (first-order) logical theory that contains an open logic program. By using a special kind of correctness for open programs, called steadfastness, we can define and reason about the correctness of schemas. We also show how to use correct schemas to synthesise steadfast programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Deville. </author> <title> Logic Programming: Systematic Program Development. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: A program relation must be an s-symbol, i.e. it must have a specification. A model-theoretic definition of correctness of open programs in a framework, called steadfastness, is given in [11]. Here, we give a less abstract, but more conventional definition (for a comparison, see <ref> [1, 12] </ref>). In this paper, for simplicity, we only give definitions and results that work for definite programs. Nevertheless they extend to normal programs, under suitable termination assumptions.
Reference: [2] <author> P. Flener and Y. Deville. </author> <title> Logic program synthesis from incomplete specifications. </title> <journal> J. Symbolic Computation 15(5-6):775-805, </journal> <month> May/June </month> <year> 1993. </year>
Reference-contexts: Synthesis of Steadfast Programs In the rest of the paper, we show how we can use correct schemas to guide the synthesis of steadfast programs. Schemas have been successfully used to guide the synthesis of programs <ref> [16, 17, 2] </ref>. The benefit of such guidance is a reduced search space, because the synthesiser, at a given moment, only tries to construct a program that fits a given schema. This is feasible because a schema fixes the data-flow and restricts the relationships between its open relations.
Reference: [3] <author> P. Flener and K.-K. Lau. </author> <title> Program Schemas as Steadfast Programs and their Usage in Deductive Synthesis. </title> <type> Tech Rep BU-CEIS-9705, </type> <institution> Bilkent University, </institution> <year> 1997. </year>
Reference-contexts: A Sample Synthesis We now show how all these considerations can be put together in order to synthesise a program from the sort specification of Example 2.2. See <ref> [3] </ref> for more details. We are in LIST (E lem; ) and we want a steadfast sorting program with termination requirement P C t (sort (L ! S)). Note that, since sort is functional, this entails total correctness.
Reference: [4] <author> P. Flener, K.-K. Lau, and M. Ornaghi. </author> <title> On correct program schemas. </title> <editor> In N.E. Fuchs, editor, </editor> <booktitle> Proc. </booktitle> <address> LOP-STR'97, </address> <publisher> Springer-Verlag, forthcoming. </publisher>
Reference-contexts: In this section, we discuss steadfastness and correct program schemas, but due to lack of space we can only give a brief summary (a more detailed account with examples can be found in <ref> [4] </ref>). 2.1. Specification Frameworks Definition 2.1 A specification framework F () with parameters consists of a (many-sorted) signature and a set of first-order axioms for the symbols of . The parameters belong to . The axioms for the parameters are called p-axioms. <p> The notion of constraint even follows naturally from, or fits naturally into, our view of schemas as open frameworks. Example 2.3 Figure 1 gives a divide-and-conquer schema DC, for which one can prove the following theorem <ref> [4] </ref>. Theorem 2.1 The schema DC is correct, i.e. it contains a steadfast template. This theorem is related to the one given by Smith [16] for a divide-and-conquer schema in functional programming. The innovations here are that we use specification frameworks and that we can thus also consider open programs. <p> B o L ^ perm (A; C) ^ ord (C) ^perm (B; D) ^ ord (D) ^ perm (L; S) ^ ord (S) which simplifies into compose (h; C; D; S) $ S = Cj (h:D) (S catcons ) We leave open how these simplifications can be done (but see <ref> [4] </ref>). Our objective here is just to show the feasibility of schema-guided synthesis of steadfast (open) programs, not the details of how to actually do it.
Reference: [5] <author> J.A. Goguen and J. Meseguer. </author> <title> Unifying functional, object-oriented and relational programming with logical semantics. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-477. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Following the tradition of algebraic ADTs [14, 18], initial models have also been proposed for logic programs <ref> [5, 6] </ref>. We have preferred isoinitial models to properly deal with negation (see also the primal models proposed in [7]). In general, a framework may have no isoinitial model. Hence the following adequacy condition: Definition 2.2 A closed framework F is adequate if it has a reachable isoinitial model.
Reference: [6] <author> W. Hodges. </author> <title> Logical features of Horn clauses. In D.M. </title> <editor> Gabbay, C.J. Hogger, and J.A. Robinson, editors, </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming, Volume 1: Logical Foundations, </booktitle> <pages> pages 449-503, </pages> <publisher> Oxford University Press, </publisher> <year> 1993. </year>
Reference-contexts: Following the tradition of algebraic ADTs [14, 18], initial models have also been proposed for logic programs <ref> [5, 6] </ref>. We have preferred isoinitial models to properly deal with negation (see also the primal models proposed in [7]). In general, a framework may have no isoinitial model. Hence the following adequacy condition: Definition 2.2 A closed framework F is adequate if it has a reachable isoinitial model.
Reference: [7] <author> G. Jager. </author> <title> Annotations on the consistency of the Closed World Assumption. </title> <editor> J. </editor> <booktitle> Logic Programming 8(3) </booktitle> <pages> 229-248, </pages> <year> 1990. </year>
Reference-contexts: Following the tradition of algebraic ADTs [14, 18], initial models have also been proposed for logic programs [5, 6]. We have preferred isoinitial models to properly deal with negation (see also the primal models proposed in <ref> [7] </ref>). In general, a framework may have no isoinitial model. Hence the following adequacy condition: Definition 2.2 A closed framework F is adequate if it has a reachable isoinitial model. A typical closed framework is (first-order) Peano arithmetic NAT , using the well-known axiomatisation, including the first-order induction schema.
Reference: [8] <author> I. Kraan, D. Basin, and A. Bundy. </author> <title> Logic program synthesis via proof planning. </title> <editor> In K.-K. Lau and T. Clement, editors, </editor> <booktitle> Proc. LOPSTR'92, </booktitle> <pages> pages 1-14. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: At the same time, other strategies for the divide-and-conquer schema also need to be developed. Eventually, we plan a proof-of-concept implementation of the outlined synthesiser (and the adjunct proof system). Since schema-guided synthesis involves a fair amount of theorem-proving-like tasks, the notion of proof plans <ref> [8] </ref> and their use in directing synthesis will be worth investigating. Acknowledgements This work was partially supported by the European Union HCM Project on Logic Program Synthesis and Transformation, contract no. 93/414, and by the British Council, Ankara, Turkey.
Reference: [9] <author> K.-K. Lau and S. D. Prestwich. </author> <title> Synthesis of a family of recursive sorting procedures. </title> <editor> In V. Saraswat and K. Ueda, editors, </editor> <booktitle> Proc. ILPS'91, </booktitle> <pages> pages 641-658. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: We omit them here, but after adding their result programs to the template, one could get the classical Quick-sort program, which is steadfast, by Theorem 2.1. Other choices at Step 3 would lead to other sorting programs, such as insertion-sort, merge-sort, etc (as shown in <ref> [9] </ref> for instance). 4.
Reference: [10] <author> K.-K. Lau and M. Ornaghi. </author> <title> On specification frameworks and deductive synthesis of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. LOP-STR/META'94, </booktitle> <pages> pages 104-121. </pages> <publisher> LNCS 883, Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: T is formalised as an open (first-order) logic program in the context of the problem domain, characterised as a first-order axiomatisation called a specification framework F <ref> [10, 11] </ref>. F endows the schema S with a formal semantics, and enables us to define and reason about its correctness. In particular, we define a special kind of correctness for open programs such as templates, that we call steadfastness.
Reference: [11] <author> K.-K. Lau and M. Ornaghi. </author> <title> The relationship between logic programs and specifications: The subset example revisited. </title> <editor> J. </editor> <booktitle> Logic Programming 30(3) </booktitle> <pages> 239-257, </pages> <year> 1997. </year>
Reference-contexts: T is formalised as an open (first-order) logic program in the context of the problem domain, characterised as a first-order axiomatisation called a specification framework F <ref> [10, 11] </ref>. F endows the schema S with a formal semantics, and enables us to define and reason about its correctness. In particular, we define a special kind of correctness for open programs such as templates, that we call steadfastness. <p> In programs, constant and function symbols may only be constructors. A program relation must be an s-symbol, i.e. it must have a specification. A model-theoretic definition of correctness of open programs in a framework, called steadfastness, is given in <ref> [11] </ref>. Here, we give a less abstract, but more conventional definition (for a comparison, see [1, 12]). In this paper, for simplicity, we only give definitions and results that work for definite programs. Nevertheless they extend to normal programs, under suitable termination assumptions.
Reference: [12] <author> K.-K. Lau, M. Ornaghi, and S.- A. </author> <title> Tarnlund. Steadfast logic programs. </title> <journal> J. Logic Programming, </journal> <note> submitted. </note>
Reference-contexts: A program relation must be an s-symbol, i.e. it must have a specification. A model-theoretic definition of correctness of open programs in a framework, called steadfastness, is given in [11]. Here, we give a less abstract, but more conventional definition (for a comparison, see <ref> [1, 12] </ref>). In this paper, for simplicity, we only give definitions and results that work for definite programs. Nevertheless they extend to normal programs, under suitable termination assumptions.
Reference: [13] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1987. </year>
Reference-contexts: The notion of correctness applied to schemas and the use of correct schemas in synthesising steadfast programs are the main novel themes of this paper. Our general approach follows that of the pioneering work of Smith in functional programming [16]. Although we focus on the logic programming paradigm (see <ref> [13] </ref> for basic terminology), our ultimate goal is to extend it to a general paradigm with suitable logic semantics. 2. <p> elemi (T; j; a)); nocc (x; nil) = 0; a = b ! nocc (a; b L) = nocc (a; L) + 1; :a = b ! nocc (a; b L) = nocc (a; L); PAXS: ...total ordering axioms for ... where C-AXS (nil; ) contains Clark's Equality Theory (see <ref> [13] </ref>) for the list constructors and nil, and the first-order induction schema H (nil) ^ (8a; J : H (J ) ! H (a J )) ! 8L : H (L); the function nocc (a; L) gives the number of occurrences of a in L, and elemi (L; i; a) means
Reference: [14] <author> D. Sannella and A. Tarlecki. </author> <title> Essential concepts of algebraic specification and program development. </title> <booktitle> Formal Aspects of Computer Science, </booktitle> <publisher> forthcoming. </publisher>
Reference-contexts: A model i is reachable if its elements can be represented by ground terms; a reachable model of F is isoinitial iff ground quantifier-free formulas are true in it whenever they are true in every model of F . Following the tradition of algebraic ADTs <ref> [14, 18] </ref>, initial models have also been proposed for logic programs [5, 6]. We have preferred isoinitial models to properly deal with negation (see also the primal models proposed in [7]). In general, a framework may have no isoinitial model.
Reference: [15] <author> D.R. Smith. </author> <title> Derived preconditions and their use in program synthesis. </title> <editor> In D.W. Loveland, editor, </editor> <booktitle> Proc. CADE'82, </booktitle> <pages> pages 172-193. </pages>
Reference-contexts: Such theorems could be either hand-crafted (and mechanically verified), or generated by forward reasoning. The work of Smith <ref> [15, 16] </ref> shows that deriving an antecedent A of a formula F (i.e., such that A ! F is valid) is a generalisation both of formula simplification (find a weakest antecedent of minimal syntactic complexity) and of conventional theorem proving (find true as antecedent).
Reference: [16] <author> D.R. Smith. </author> <title> Top-down synthesis of divide-and-conquer algorithms. </title> <booktitle> Artificial Intelligence 27(1) </booktitle> <pages> 43-96, </pages> <year> 1985. </year>
Reference-contexts: The notion of correctness applied to schemas and the use of correct schemas in synthesising steadfast programs are the main novel themes of this paper. Our general approach follows that of the pioneering work of Smith in functional programming <ref> [16] </ref>. Although we focus on the logic programming paradigm (see [13] for basic terminology), our ultimate goal is to extend it to a general paradigm with suitable logic semantics. 2. <p> P r is called the template of S (), whereas the p-axioms and the p-specifications are called the constraints of S (). A schema S covers a program P if (S and) its template can be instantiated into P . Most researchers, with the laudable exception of Smith <ref> [16, 17] </ref>, define a schema to be just a template. Such definitions are thus merely syntactic, providing only a pattern of place-holders, but not the semantics of the template, the semantics of the programs it covers, or the interactions between these place-holders. <p> Example 2.3 Figure 1 gives a divide-and-conquer schema DC, for which one can prove the following theorem [4]. Theorem 2.1 The schema DC is correct, i.e. it contains a steadfast template. This theorem is related to the one given by Smith <ref> [16] </ref> for a divide-and-conquer schema in functional programming. The innovations here are that we use specification frameworks and that we can thus also consider open programs. Also, we could eliminate Smith's Strong Problem Reduction Principle by endeavouring to achieve these objectives. 3. <p> Synthesis of Steadfast Programs In the rest of the paper, we show how we can use correct schemas to guide the synthesis of steadfast programs. Schemas have been successfully used to guide the synthesis of programs <ref> [16, 17, 2] </ref>. The benefit of such guidance is a reduced search space, because the synthesiser, at a given moment, only tries to construct a program that fits a given schema. This is feasible because a schema fixes the data-flow and restricts the relationships between its open relations. <p> Smith's work <ref> [16] </ref>), as a pre-computed (finite) sequence of synthesis steps, for a given schema. A strategy has two phases, stating first which parameter (s) to arbitrarily instantiate, and next which specifications to set up, based on a pre-computed propagation of these instantiation (s). <p> Once correct programs have been synthesised from these new specifications (using the synthesiser all over again), they can be composed into a correct program for the originally specified relation, according to the schema. There can be several strategies for a given schema (e.g., Smith <ref> [16] </ref> gives three strategies for a divide-and-conquer schema), depending on which parameter (s) are instantiated first. Synthesis is thus a recursive problem reduction process followed by a recursive solution composition process, where the problems are specifications and the solutions are programs [16]. <p> be several strategies for a given schema (e.g., Smith <ref> [16] </ref> gives three strategies for a divide-and-conquer schema), depending on which parameter (s) are instantiated first. Synthesis is thus a recursive problem reduction process followed by a recursive solution composition process, where the problems are specifications and the solutions are programs [16]. Problem reduction (which is the step case of synthesis) stops when a sufficiently simple problem is reached, i.e. a specification that reduces to another specification for which a program is known and can thus be re used (this is the base case of synthesis). 3.1. <p> The proof for T = P C t (r (x ! y)) goes similarly, consid ering partial instead of total correctness. 2 This theorem is more general than the combination of Hoare's two consequence rules, since conditions F and G need not be true (as inspired by Smith <ref> [16] </ref>), and since we cover total correctness (rather than just partial correctness, as Hoare and Smith do). This will turn out crucial for synthesis, namely when the input condition of a specification is incompletely known. <p> However, here we have only laid the theoretical foundations; much more needs to be done in order to apply the results to the implementation of a practical system for (semi-)automated software development. At the schema-guided synthesis level, our work is very strongly influenced by Smith's pioneering work <ref> [16] </ref> in functional programming in the early 1980s. <p> Such theorems could be either hand-crafted (and mechanically verified), or generated by forward reasoning. The work of Smith <ref> [15, 16] </ref> shows that deriving an antecedent A of a formula F (i.e., such that A ! F is valid) is a generalisation both of formula simplification (find a weakest antecedent of minimal syntactic complexity) and of conventional theorem proving (find true as antecedent).
Reference: [17] <author> D.R. Smith. KIDS: </author> <title> A semiautomatic program development system. </title> <journal> IEEE Trans. Software Engineering 16(9) </journal> <pages> 1024-1043, </pages> <year> 1990. </year>
Reference-contexts: This is amply borne out by user-guided program development systems that have been successfully applied in practice, e.g. KIDS <ref> [17] </ref>. Informally, a program schema is an abstraction (in a given problem domain) of a class of actual programs, in the sense that it represents their data-flow and control-flow, but does not contain (all) their actual computations or (all) their actual data structures. <p> P r is called the template of S (), whereas the p-axioms and the p-specifications are called the constraints of S (). A schema S covers a program P if (S and) its template can be instantiated into P . Most researchers, with the laudable exception of Smith <ref> [16, 17] </ref>, define a schema to be just a template. Such definitions are thus merely syntactic, providing only a pattern of place-holders, but not the semantics of the template, the semantics of the programs it covers, or the interactions between these place-holders. <p> Synthesis of Steadfast Programs In the rest of the paper, we show how we can use correct schemas to guide the synthesis of steadfast programs. Schemas have been successfully used to guide the synthesis of programs <ref> [16, 17, 2] </ref>. The benefit of such guidance is a reduced search space, because the synthesiser, at a given moment, only tries to construct a program that fits a given schema. This is feasible because a schema fixes the data-flow and restricts the relationships between its open relations. <p> Another important objective is to identify templates and constraints for other design methodologies than divide-and-conquer, and to develop corresponding strategies. Once again, Smith <ref> [17] </ref> has shown the way, namely by capturing a vast class of search methodologies in a global-search schema and seven corresponding strategies. At the same time, other strategies for the divide-and-conquer schema also need to be developed.
Reference: [18] <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: A model i is reachable if its elements can be represented by ground terms; a reachable model of F is isoinitial iff ground quantifier-free formulas are true in it whenever they are true in every model of F . Following the tradition of algebraic ADTs <ref> [14, 18] </ref>, initial models have also been proposed for logic programs [5, 6]. We have preferred isoinitial models to properly deal with negation (see also the primal models proposed in [7]). In general, a framework may have no isoinitial model. <p> Definition 2.3 An open framework F () is adequate if, for every adequate closed framework G, the instance F ()[G] is an adequate closed framework. A more general notion of instance can be given, involving renamings (see also the pushout approach in algebraic ADTs <ref> [18] </ref>). However, it can be shown that F () is adequate according to Definition 2.3 iff it is adequate considering the more general notion of instance. Therefore we can use our simpler definition, without loss of generality.
References-found: 18

