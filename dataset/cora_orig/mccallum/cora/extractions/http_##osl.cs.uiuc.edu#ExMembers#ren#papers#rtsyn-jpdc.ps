URL: http://osl.cs.uiuc.edu/ExMembers/ren/papers/rtsyn-jpdc.ps
Refering-URL: http://osl.cs.uiuc.edu/ExMembers/ren/
Root-URL: http://www.cs.uiuc.edu
Email: Email: f ren j agha g@cs.uiuc.edu  Email: miyabi@hrl.hitachi.co.jp  
Title: A Modular Approach for Programming Distributed Real-Time Systems  
Author: Shangping Ren Gul A. Agha Masahiko Saito Brian Nielsen, Daniel Sturman, Mark Astley, Rajendra Panwar, James 
Note: The authors thank  Waldby and other members of the Open Systems Laboratory who have provided helpful suggestions and discussion.  
Address: 1304 W. Springfield Avenue Urbana, IL 61801, USA  1-1, Omika-cho 7-chome, Hitachi-shi Ibaraki-ken, 319-12 Japan  
Affiliation: Department of Computer Science  Hitachi Research Laboratory  
Abstract: fl The research described has been made possible in part by support from the Office of Naval Research (ONR contract numbers N00014-90-J-1899 and N00014-93-1-0273), by an Incentives for Excellence Award from the Digital Equipment Corporation Faculty Program, by Hitachi, and by the National Science Foundation (NSF CCR 93-12495). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aristotle | Physica | Laterza. Bari, </author> <year> 1991. </year>
Reference-contexts: Because events at different actors may happen concurrently, the causal order is only partial. The transitive closure of local arrival orders and the causal order is called the combined ordering. Obviously, the combined order is also a partial order. 3.2 Actors in Real-Time What is `time' ? Aristotle <ref> [1] </ref> considered philosophical aspects of time, such as: discreteness versus density, absolute (past, present, future) versus relative (before, concurrent with, after) orderings, and primitive entities of time (instants, intervals, events).
Reference: [2] <author> Ada95 6.0 reference manual. </author> <type> Technical report, </type> <address> Internet's Public Ada Library, </address> <year> 1995. </year>
Reference-contexts: The delayed time is relative to the time when the delay statement is executed. However, Ada semantics does not enforce non-preemptive execution of statements, and hence delay can only guarantee a minimal task suspension. Precise periodic task execution cannot even be specified in an Ada program <ref> [31, 2] </ref>. Later versions of Ada, such as Ada95, have enhanced the delay construct and provided the delay until statement, which allows the programmer to specify an absolute delay time. Again, the semantics for both constructs only guarantee the lower bound of the delayed time.
Reference: [3] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: On the other hand, real-time constraints may require progress based on predicted behavior. While a formal semantics for RT-synchronizers remains to be defined, some recent work has made progress in that direction [27]. 3 Real-Time Actor Model 3.1 Actor Model The Actor model, developed by Hewitt [22] and Agha <ref> [3] </ref>, provides a uniform abstract representation of distributed systems. Actors are encapsulated concurrent objects that interact with each other by sending buffered, asynchronous messages [3, 6, 7]. Memory chips, control devices, actuators, subprograms, and entire computers may be thought of as actors. <p> Actors are encapsulated concurrent objects that interact with each other by sending buffered, asynchronous messages <ref> [3, 6, 7] </ref>. Memory chips, control devices, actuators, subprograms, and entire computers may be thought of as actors. In other words, all components of distributed real-time systems can be uniformly abstracted as actors; the model is independent of the hardware platform used to implement it. <p> By default, communication is asynchronous; synchronous communication can be defined via abstraction <ref> [3, 4] </ref>. * new dynamically creates actors. The new operator takes an actor behavior as a parameter and returns the address of a newly created actors with the specified behavior. 6 * ready marks the end of processing the current message.
Reference: [4] <author> G. Agha. </author> <title> Concurrent object-oriented programming. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 125-141, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: By default, communication is asynchronous; synchronous communication can be defined via abstraction <ref> [3, 4] </ref>. * new dynamically creates actors. The new operator takes an actor behavior as a parameter and returns the address of a newly created actors with the specified behavior. 6 * ready marks the end of processing the current message. <p> One of the software architectures suitable for implementing a system of actors (and by implication, any systems of distributed objects) with real-time scheduling, fault-tolerance and complex communication such as broadcast and multi-cast, is computational reflection <ref> [26, 4, 5] </ref>. Reflection is the model where an object can manipulate a causally connected description (i.e. meta-object) of itself. A change of the meta-object results in a change of implementation or behavior of the object.
Reference: [5] <author> G. Agha, S. Frtlund, W. Kim, R. Panwar, A. Patterson, and D. Sturman. </author> <title> Abstraction and modularity mechanisms for concurrent computing. </title> <journal> IEEE Parallel and Distributed Technology: Systems and Applications, </journal> (2):3-14, 1993. 
Reference-contexts: For our purpose, there are two weaknesses in this work. First, timing requirements are intermixed with application code within methods. Second, concurrency is not supported. Concurrent object-oriented programming is an active area of research interest <ref> [8, 14, 5] </ref>. A number of real-time languages are based on concurrent object-oriented languages. Ishikawa et al. proposed a concurrent object-oriented programming language called RTC++ [23]. In RTC++, temporally constrained objects (called real-time objects) are distinguished from ordinary unconstrained objects. <p> One of the software architectures suitable for implementing a system of actors (and by implication, any systems of distributed objects) with real-time scheduling, fault-tolerance and complex communication such as broadcast and multi-cast, is computational reflection <ref> [26, 4, 5] </ref>. Reflection is the model where an object can manipulate a causally connected description (i.e. meta-object) of itself. A change of the meta-object results in a change of implementation or behavior of the object.
Reference: [6] <author> G. Agha, I. A. Mason, S. F. Smith, and C. .L. Talcott. </author> <title> Towards a theory of actor computation. </title> <booktitle> In The Third International Conference on Concurrency Theory (CONCUR'92), </booktitle> <pages> pages 565-579. </pages> <publisher> Springer Verlag, </publisher> <month> August </month> <year> 1992. </year> <note> LNCS 630. </note>
Reference-contexts: Actors are encapsulated concurrent objects that interact with each other by sending buffered, asynchronous messages <ref> [3, 6, 7] </ref>. Memory chips, control devices, actuators, subprograms, and entire computers may be thought of as actors. In other words, all components of distributed real-time systems can be uniformly abstracted as actors; the model is independent of the hardware platform used to implement it.
Reference: [7] <author> G. Agha, I. A. Mason, S. F. Smith, and C. L. Talcott. </author> <title> A foundation for actor computation. </title> <journal> Journal of Functional Programming, </journal> <note> 1996. to appear. 19 </note>
Reference-contexts: Actors are encapsulated concurrent objects that interact with each other by sending buffered, asynchronous messages <ref> [3, 6, 7] </ref>. Memory chips, control devices, actuators, subprograms, and entire computers may be thought of as actors. In other words, all components of distributed real-time systems can be uniformly abstracted as actors; the model is independent of the hardware platform used to implement it.
Reference: [8] <editor> G. Agha, P. Wegner, and A. Yonezawa, editors. </editor> <booktitle> Research Directions in Concur--rent Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: For our purpose, there are two weaknesses in this work. First, timing requirements are intermixed with application code within methods. Second, concurrency is not supported. Concurrent object-oriented programming is an active area of research interest <ref> [8, 14, 5] </ref>. A number of real-time languages are based on concurrent object-oriented languages. Ishikawa et al. proposed a concurrent object-oriented programming language called RTC++ [23]. In RTC++, temporally constrained objects (called real-time objects) are distinguished from ordinary unconstrained objects.
Reference: [9] <author> M. Aksit and L. M. J. Bergmans. </author> <title> Composing and reusing synchronization and real-time specification. </title> <booktitle> In The Object-Oriented Real-Time Systems (OORTS) Workshop, </booktitle> <pages> pages 13-22, </pages> <address> San Antonio, Texas, </address> <month> October </month> <year> 1995. </year> <note> to appear in OOPS Messeuger, ACM SIGPLAN. </note>
Reference-contexts: Thus, synchronization within individual objects is needed. Finally, RTC++, does not support inter-object timing constraints. From a linguistic point of view, the cleanest approach thus far may be that of real-time filters, introduced in the work of Aksit et al. <ref> [10, 9] </ref>. Real-time filters extend an object's interface to include input filters and output filters. An out-going message must pass through a series of zero or more output filters before being sent to its target. Similarly, an incoming message passes through input filters before being received by the object.
Reference: [10] <author> M. Aksit, J. Bosch, and W. Sterren. </author> <title> Real-time specification inheritance anomalies and real-time filters. </title> <booktitle> In Proceedings of ECOOP'94, </booktitle> <pages> pages 386-407. </pages> <publisher> Springer Verlag, </publisher> <month> July </month> <year> 1994. </year> <note> LNCS 821. </note>
Reference-contexts: Thus, synchronization within individual objects is needed. Finally, RTC++, does not support inter-object timing constraints. From a linguistic point of view, the cleanest approach thus far may be that of real-time filters, introduced in the work of Aksit et al. <ref> [10, 9] </ref>. Real-time filters extend an object's interface to include input filters and output filters. An out-going message must pass through a series of zero or more output filters before being sent to its target. Similarly, an incoming message passes through input filters before being received by the object.
Reference: [11] <author> J. F. Allen. </author> <title> Maintaining knowledge about temporal intervals. </title> <journal> Communications of the ACM, </journal> <volume> 26(11), </volume> <year> 1983. </year>
Reference-contexts: These same concerns arise in computer science <ref> [11, 30] </ref> and engineering because of the need for synchronization among different computational units. We assume that time is a dense domain; both absolute and relative orderings are defined; and instants are the primitive entities of time.
Reference: [12] <author> J. Armstrong, R. Virding, and M. Williams. </author> <title> Concurrent Programming in Erlang. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Temporal constraints are specified relative to message acceptance. The filter mechanism helps make complicated programs more manageable. However, a potential difficulty with the filters approach is an inability to abstractly specify timing constraints for a group of distributed objects. The concurrent programming language Erlang <ref> [12] </ref> is based on parallel process model and intended for soft real-time systems. Erlang programs essentially obey actor semantics: e.g., there is no shared memory and all interaction between processes is by asynchronous message passing.
Reference: [13] <author> O. Babaoglu and K. Marzullo. </author> <title> Consistent global states of distributed systems: Fundamental concepts and mechanisms. </title> <editor> In Sape Mullender, editor, </editor> <booktitle> Distributed Systems, </booktitle> <pages> pages 55-94. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: Second, method execution on each actor is atomic and non-preemptive. Finally, method execution time is subsumed by communication and scheduling delay. These assumptions are realistic and implementable (cf. <ref> [24, 13, 21] </ref>). With these assumptions, our real-time computational model is simplified in two ways. First, because local clocks are synchronized, a global clock in the system is obtained.
Reference: [14] <author> D. Caromel. </author> <title> Toward a method of object-oriented concurrent programming. </title> <journal> Communications of the ACM, </journal> <volume> 36(9) </volume> <pages> 90-102, </pages> <year> 1993. </year>
Reference-contexts: For our purpose, there are two weaknesses in this work. First, timing requirements are intermixed with application code within methods. Second, concurrency is not supported. Concurrent object-oriented programming is an active area of research interest <ref> [8, 14, 5] </ref>. A number of real-time languages are based on concurrent object-oriented languages. Ishikawa et al. proposed a concurrent object-oriented programming language called RTC++ [23]. In RTC++, temporally constrained objects (called real-time objects) are distinguished from ordinary unconstrained objects.
Reference: [15] <author> W. Clinger. </author> <title> Foundation of actor semantics. </title> <type> Technical Report AI-TR-633, </type> <institution> MIT, </institution> <month> 81. </month>
Reference-contexts: After ready is exe- cuted, the actor may process the next message in its mail queue. In the actor model, an event is defined as the invocation of a message at an actor; thus all events in the model are arrival events <ref> [15] </ref>. Events are instantaneous and obey: (1) local arrival orders and (2) a causal order . Each actor is modeled as a single threaded unit: it is invoked by one message at a time. Hence, the message arrival order at each individual actor is linear, or total. <p> Intuitions about time and computation constrain what structures are possible for the combined ordering (defined earlier). Given these intuitions, global time is realizable, as shown by Clinger <ref> [15] </ref>: 7 (Strong) Axiom of Realizability There exists a one-to-one mapping g from the events E into a set of real numbers without cluster points which preserves the combined ordering.
Reference: [16] <author> J. Lehoczky et al. </author> <title> Enhancing aperiodic responsiveness in a hard real-time. </title> <booktitle> In Proc. IEEE Real-Time Systems Symp., </booktitle> <year> 1987. </year>
Reference-contexts: This release time, which is agreed by all participating objects, is imposed on the local scheduling phase. In the scheduling phase, we use the synchronized sporadic server approach to make scheduling more flexible. Synchronized sporadic servers are an extension of the sporadic server policy <ref> [16] </ref> which provides good responsiveness for aperiodic tasks. Since we are assuming that local clocks are synchronized, the sporadic servers will be activated simultaneously on each node if they are scheduled to execute at the same wall clock time. We regard actors invoked by barrier messages as aperiodic tasks.
Reference: [17] <author> S. Frtlund and G. Agha. </author> <title> A language framework for multi-object coordination. </title> <booktitle> In Proceedings of ECOOP 1993, volume 707 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: However, the after constraint is hard coded with 5 the basic receive primitive inside each module in Erlang, which makes it impossible to modify timing constraints independently with other functional code. Our work builds on the earlier work of Frtlund and Agha <ref> [17, 18] </ref> who developed synchronizers to provide a declarative specification of coordination constraints on groups of actors. However, the semantics of RTsynchronizers is quite different. Synchronizers can enforce qualitative temporal ordering and indivisible (atomic) scheduling of multiple invocations at a group of objects.
Reference: [18] <author> Svend Frtlund. </author> <title> Coordinating Distributed Objects: An Actor-Based Approach to Synchronization. </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: However, the after constraint is hard coded with 5 the basic receive primitive inside each module in Erlang, which makes it impossible to modify timing constraints independently with other functional code. Our work builds on the earlier work of Frtlund and Agha <ref> [17, 18] </ref> who developed synchronizers to provide a declarative specification of coordination constraints on groups of actors. However, the semantics of RTsynchronizers is quite different. Synchronizers can enforce qualitative temporal ordering and indivisible (atomic) scheduling of multiple invocations at a group of objects. <p> Synchronizers can enforce qualitative temporal ordering and indivisible (atomic) scheduling of multiple invocations at a group of objects. On the other hand, RTsynchronizers specify quantitative constraints. Moreover, the two sorts of constraints require very different implementation. Synchronizers are conservative, they can merely suspend invocations until constraints are met <ref> [18] </ref>. On the other hand, real-time constraints may require progress based on predicted behavior.
Reference: [19] <author> G. Goos and J. Hartmanis (ed.). </author> <title> The Programming Language Ada Reference Manual, </title> <month> February </month> <year> 1983. </year>
Reference-contexts: Section 6 discusses implementation of RTsynchronizer in detail. Section 7 restates our main results and outlines future work. 2 Related Work Perhaps, the most commonly used language for real-time programming is Ada. Ada was designed for the U.S. Department of Defense and is intended for critical real-time software design <ref> [19] </ref>. The predefined library package CALENDAR in Ada provides programmers with wall-clock time. The only time related language construct in Ada is delay . The delayed time is relative to the time when the delay statement is executed.
Reference: [20] <author> A. S. Grimshaw, A. Silberman, and J. .W. S. Liu. </author> <title> Real-time mentat at programming language and architecture. </title> <booktitle> In IEEE Globecom'89, </booktitle> <year> 1989. </year>
Reference-contexts: Besides these disadvantages, time-related statements are 4 mixed with ordinary statements, which makes real-time program design, modifica-tion and reuse difficult. Some researchers have proposed integrating timing constraints with sequential objects <ref> [20, 32, 25] </ref>. For instance, the real-time programming language Flex [25] extends C++ with a control block language construct, which may reside in the body of methods; timing constraints are specified in the control block. For our purpose, there are two weaknesses in this work.
Reference: [21] <author> V. Hadzilacos and S. Toueg. </author> <title> Fault-tolerant broadcasts and related problems. </title> <editor> In Sape Mullender, editor, </editor> <booktitle> Distributed Systems, </booktitle> <pages> pages 97-138. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year> <month> 20 </month>
Reference-contexts: Second, method execution on each actor is atomic and non-preemptive. Finally, method execution time is subsumed by communication and scheduling delay. These assumptions are realistic and implementable (cf. <ref> [24, 13, 21] </ref>). With these assumptions, our real-time computational model is simplified in two ways. First, because local clocks are synchronized, a global clock in the system is obtained.
Reference: [22] <author> C. Hewitt. </author> <title> Viewing control structures as patterns of passing messages. </title> <journal> Journal of Artificial Intelligence, </journal> <volume> 8(3) </volume> <pages> 323-364, </pages> <year> 1977. </year>
Reference-contexts: On the other hand, real-time constraints may require progress based on predicted behavior. While a formal semantics for RT-synchronizers remains to be defined, some recent work has made progress in that direction [27]. 3 Real-Time Actor Model 3.1 Actor Model The Actor model, developed by Hewitt <ref> [22] </ref> and Agha [3], provides a uniform abstract representation of distributed systems. Actors are encapsulated concurrent objects that interact with each other by sending buffered, asynchronous messages [3, 6, 7]. Memory chips, control devices, actuators, subprograms, and entire computers may be thought of as actors.
Reference: [23] <author> Yutaka Ishikawa, Hideyuki Tokuda, and Clifford W. Mercer. </author> <title> Object-oriented real-time language design: Constructs for timing constraints. </title> <booktitle> In Proceedings OOPSLA/ECOOP '90, </booktitle> <pages> pages 289-298, </pages> <month> October </month> <year> 1990. </year> <journal> Published as ACM SIG-PLAN Notices, </journal> <volume> volume 25, number 10. </volume>
Reference-contexts: 1 Introduction Real-time programming languages typically intermix constructs for specifying timing constraints with those for specifying a computation. A number of researchers have proposed the use of an object-oriented paradigm for specifying of real-time constraints <ref> [25, 23, 32] </ref>; they propose to encapsulate timing constraints the same way objects hide the implementation of an abstract data type. <p> Second, concurrency is not supported. Concurrent object-oriented programming is an active area of research interest [8, 14, 5]. A number of real-time languages are based on concurrent object-oriented languages. Ishikawa et al. proposed a concurrent object-oriented programming language called RTC++ <ref> [23] </ref>. In RTC++, temporally constrained objects (called real-time objects) are distinguished from ordinary unconstrained objects. The distinction between real-time objects and ordinary objects means that objects with the same logical behavior but different temporal constraints require separate specifications. Timing constraints in RTC++ may be specified as parts of method declarations.
Reference: [24] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7), </volume> <month> July </month> <year> 1978. </year>
Reference-contexts: Second, method execution on each actor is atomic and non-preemptive. Finally, method execution time is subsumed by communication and scheduling delay. These assumptions are realistic and implementable (cf. <ref> [24, 13, 21] </ref>). With these assumptions, our real-time computational model is simplified in two ways. First, because local clocks are synchronized, a global clock in the system is obtained.
Reference: [25] <author> K. Lin and J. W. Liu. </author> <title> Flex: A language for real-time systems programming. </title> <type> Technical Report 1634, </type> <institution> UIUC, </institution> <year> 1990. </year>
Reference-contexts: 1 Introduction Real-time programming languages typically intermix constructs for specifying timing constraints with those for specifying a computation. A number of researchers have proposed the use of an object-oriented paradigm for specifying of real-time constraints <ref> [25, 23, 32] </ref>; they propose to encapsulate timing constraints the same way objects hide the implementation of an abstract data type. <p> Besides these disadvantages, time-related statements are 4 mixed with ordinary statements, which makes real-time program design, modifica-tion and reuse difficult. Some researchers have proposed integrating timing constraints with sequential objects <ref> [20, 32, 25] </ref>. For instance, the real-time programming language Flex [25] extends C++ with a control block language construct, which may reside in the body of methods; timing constraints are specified in the control block. For our purpose, there are two weaknesses in this work. <p> Besides these disadvantages, time-related statements are 4 mixed with ordinary statements, which makes real-time program design, modifica-tion and reuse difficult. Some researchers have proposed integrating timing constraints with sequential objects [20, 32, 25]. For instance, the real-time programming language Flex <ref> [25] </ref> extends C++ with a control block language construct, which may reside in the body of methods; timing constraints are specified in the control block. For our purpose, there are two weaknesses in this work. First, timing requirements are intermixed with application code within methods. Second, concurrency is not supported.
Reference: [26] <editor> Pattie Maes. </editor> <title> Concepts and experiments in computational reflection. </title> <booktitle> In Proceedings OOPSLA '87, </booktitle> <pages> pages 147-155, </pages> <month> December </month> <year> 1987. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 22, number 12. </volume>
Reference-contexts: One of the software architectures suitable for implementing a system of actors (and by implication, any systems of distributed objects) with real-time scheduling, fault-tolerance and complex communication such as broadcast and multi-cast, is computational reflection <ref> [26, 4, 5] </ref>. Reflection is the model where an object can manipulate a causally connected description (i.e. meta-object) of itself. A change of the meta-object results in a change of implementation or behavior of the object.
Reference: [27] <author> B. Nielsen and G. Agha. </author> <title> Semantics for an actor-based real-time language. </title> <booktitle> In Fourth International Workshop on Parallel and Distributed Real-Time Systems, </booktitle> <address> Honolulu, </address> <month> April </month> <year> 1996. </year> <note> (to be published). </note>
Reference-contexts: Synchronizers are conservative, they can merely suspend invocations until constraints are met [18]. On the other hand, real-time constraints may require progress based on predicted behavior. While a formal semantics for RT-synchronizers remains to be defined, some recent work has made progress in that direction <ref> [27] </ref>. 3 Real-Time Actor Model 3.1 Actor Model The Actor model, developed by Hewitt [22] and Agha [3], provides a uniform abstract representation of distributed systems. Actors are encapsulated concurrent objects that interact with each other by sending buffered, asynchronous messages [3, 6, 7].
Reference: [28] <author> O. Nierstrasz and M. Papathomas. </author> <title> Viewing objects as patterns of communicating agents. </title> <booktitle> In OOPSLA '90 Proceedings, </booktitle> <year> 1990. </year>
Reference: [29] <author> M. Saito and G. Agha. </author> <title> A modular approach to real-time synchronization. </title> <booktitle> In Object-Oriented Real-Time Systems Workshop, </booktitle> <pages> pages 13-22, </pages> <address> San Antonio, Texas, </address> <month> October </month> <year> 1995. </year> <note> to appear in OOPS Messeuger, ACM SIGPLAN. </note>
Reference-contexts: Although we focus on real-time synchronization, our methodology is applicable to other synchronization patterns with timing constraints. Notice that our focus is on the issues related to the interaction between different schedulers (residing in an actor or a group of actors) to generate schedules satisfying the quantitative synchronization constraints <ref> [29] </ref>. Our approach is to divide synchronization into two phases: a negotiation phase and a local scheduling phase. In the negotiation phase, all participating objects communicate with one another to determine the time at which they are going to resume their message invocation.
Reference: [30] <author> F. A. Schreiber. </author> <title> Is time a real time? an overview of time ontology in informatics. </title> <editor> In W. A. Halang and A. D. Stoyenko, editors, </editor> <title> Real Time Computing. </title> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: These same concerns arise in computer science <ref> [11, 30] </ref> and engineering because of the need for synchronization among different computational units. We assume that time is a dense domain; both absolute and relative orderings are defined; and instants are the primitive entities of time.
Reference: [31] <author> S. Tucker Taft. </author> <title> Ada 9x: From abstraction-oriented to object-oriented. </title> <booktitle> In Proceedings OOPSLA '93, ACM SIGPLAN Notices, </booktitle> <pages> pages 127-143, </pages> <month> October </month> <year> 1993. </year> <title> Published as Proceedings OOPSLA '93, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> volume 28, number 10. </volume>
Reference-contexts: The delayed time is relative to the time when the delay statement is executed. However, Ada semantics does not enforce non-preemptive execution of statements, and hence delay can only guarantee a minimal task suspension. Precise periodic task execution cannot even be specified in an Ada program <ref> [31, 2] </ref>. Later versions of Ada, such as Ada95, have enhanced the delay construct and provided the delay until statement, which allows the programmer to specify an absolute delay time. Again, the semantics for both constructs only guarantee the lower bound of the delayed time.
Reference: [32] <author> Kazunori Takashio and Mario Tokoro. DROL: </author> <title> An object-oriented programming language for distributed real-time systems. </title> <booktitle> In Proceedings OOPSLA '92, ACM SIGPLAN Notices, </booktitle> <pages> pages 276-297, </pages> <month> October </month> <year> 1992. </year> <title> Published as Proceedings OOPSLA '92, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> volume 27, number 10. </volume>
Reference-contexts: 1 Introduction Real-time programming languages typically intermix constructs for specifying timing constraints with those for specifying a computation. A number of researchers have proposed the use of an object-oriented paradigm for specifying of real-time constraints <ref> [25, 23, 32] </ref>; they propose to encapsulate timing constraints the same way objects hide the implementation of an abstract data type. <p> Besides these disadvantages, time-related statements are 4 mixed with ordinary statements, which makes real-time program design, modifica-tion and reuse difficult. Some researchers have proposed integrating timing constraints with sequential objects <ref> [20, 32, 25] </ref>. For instance, the real-time programming language Flex [25] extends C++ with a control block language construct, which may reside in the body of methods; timing constraints are specified in the control block. For our purpose, there are two weaknesses in this work.

References-found: 32

