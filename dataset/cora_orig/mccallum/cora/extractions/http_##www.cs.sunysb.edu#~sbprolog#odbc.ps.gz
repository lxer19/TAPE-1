URL: http://www.cs.sunysb.edu/~sbprolog/odbc.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~sbprolog/xsb-page.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: XSB-ODBC Interface Programmer's Manual  
Author: Lily Dong 
Note: Contents  
Date: December 1, 1997  
Abstract-found: 0
Intro-found: 1
Reference: [Drax 92] <author> Christoph Draxler. </author> <title> Prolog to SQL compiler, Version 1.0. </title> <type> Technical Report, </type> <institution> CIS Centre for Information and Speech Processing Ludwig-Maximilians-University, Munich, </institution> <year> 1992. </year>
Reference-contexts: Caching compiler generated SQL statements with bind variables and efficient cursor management for cached statements * A powerful Prolog / SQL compiler based on <ref> [Drax 92] </ref>. * Full source code availability for feature enforcement * Independence from database schema by employing relation level * Performance as SQL by employing view level * No mode specification is required for optimized view compilation We use the Hospital database as our example to illustrate the usage of XSB-ODBC <p> All arguments are standard Prolog terms. ARG1, ARG2, ..., ARGndefines the attributes to be retrieved from the database, while DatabaseGoal defines the selection restrictions and join conditions. The compiler is a simple extension of <ref> [Drax 92] </ref> which generates SQL queries with bind variables and handles NULL values as described in Section 12.3.6 of [XSB 98]. It allows negation, the expression of arithmetic functions, and higher-order constructs such as grouping, sorting, and aggregate functions. Database goals are translated according to the following rules from [Drax 92]: <p> of <ref> [Drax 92] </ref> which generates SQL queries with bind variables and handles NULL values as described in Section 12.3.6 of [XSB 98]. It allows negation, the expression of arithmetic functions, and higher-order constructs such as grouping, sorting, and aggregate functions. Database goals are translated according to the following rules from [Drax 92]: * Disjunctive goals translate to distinct SQL queries connected through the UNION operator. * Goal conjunctions translate to joins. 2 USING THE INTERFACE 5 * Negated goals translate to negated EXISTS subqueries. * Variables with single occurrences in the body are not translated. * Free variables translate to grouping <p> For more examples and implementation details see <ref> [Drax 92] </ref>. In the following, we show the definition of a simple join view between the two database predicates Room and Floor. Assuming the declarations: | ?- odbc_import ('Room'('RoomNo','CostPerDay','Capacity','FId'),room). | ?- odbc_import ('Floor'('FId','','FName'),floor). use | ?- odbc_query (rule1 (RoomNo,FName), (room (RoomNo,_,FId),floor (FId,FName))). yes | ?- rule1 (RoomNo,FloorName).
Reference: [XSB 98] <author> K. Sagonas, T. Swift, D.S. Warren, J. Freire, P. Rao. </author> <title> The XSB Programmer's Manual: </title> <type> Version 1.8. </type> <institution> SUNY at Stony Brook, </institution> <year> 1998. </year>
Reference-contexts: For example: | ?- test (TId, 'X-Ray', L, P). generates the query: SELECT rel1.TId, rel1.TName, rel1.Length, rel1.Price FROM Test rel1 WHERE rel1.TName = ? ; | ?- test ('NULL'( ), 'X-Ray', L, P). generates: (See Section 12.3.6 of <ref> [XSB 98] </ref>) SELECT NULL , rel1.TName, rel1.Length, rel1.Price FROM Test rel1 WHERE rel1.TId IS NULL AND rel1.TName = ? ; During the execution of this query the bind variable ? will be bound to 'X-Ray'. <p> ARG1, ARG2, ..., ARGndefines the attributes to be retrieved from the database, while DatabaseGoal defines the selection restrictions and join conditions. The compiler is a simple extension of [Drax 92] which generates SQL queries with bind variables and handles NULL values as described in Section 12.3.6 of <ref> [XSB 98] </ref>. It allows negation, the expression of arithmetic functions, and higher-order constructs such as grouping, sorting, and aggregate functions. <p> Note that any call to room ins/7 should have all its arguments bound. See Section 12.3.6 of <ref> [XSB 98] </ref> for information about NULL value handling. The first argument of odbc delete/2 predicate is the declared delete predicate and the second argument is the imported data source relation with the condition for requested deletes, if any. The condition is limited to simple comparisons. <p> Please refer to Section 12.3.6 of <ref> [XSB 98] </ref> for details. 2.11 Interface Flags Users are given the option to monitor the SQL queries generated by the interface and their execution status by using the predicate db flag/3. The first parameter indicates the function to be changed. <p> Hence the guidelines for XSB-ORACLE interface application developers are also for XSB-ODBC interface application developers. Please refer to Sections 12.5 and 12.3 of <ref> [XSB 98] </ref> for datails. 4 Error messages ERR - DB: Connection failed For some reason the attempt to connect to data source failed. * Diagnosis: Try to see if the data source has been registered with MicroSoft ODBC Administrator, the username and password are correct and MAXCURSORNUM is not set to <p> REFERENCES 12 * Diagnosis: Check the SQL statement. If our interface generated the erroneous statement please contact us at xsb-contact@cs.sunysb.edu. ERR - DB: No more cursors left Interface run out of non-active cursors either because of a leak (See Section 12.3 of <ref> [XSB 98] </ref>) or no more free cursors left. * Diagnosis: System fails always with this error. odbc transaction (rollback) or odbc transaction (commit) should resolve this by freeing all cursors.
References-found: 2

