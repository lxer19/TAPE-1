URL: http://c.gp.cs.cmu.edu:5103/afs/cs/project/vit/ftp/SAMeDL_Rationale.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/gz/www/Zelesnik.html
Root-URL: http://www.cs.cmu.edu
Title: Rationale for SQL Ada Module Description Language SAMeDL Version 2.0  
Author: Gary J. Chastek Marc H. Graham Gregory Zelesnik 
Date: October 1992  
Note: CMU/SEI-92-TR-16  
Abstract: Technical Report 
Abstract-found: 1
Intro-found: 1
Reference: [ada 83] <institution> Reference Manual for the Ada Programming Language. Ada Joint Program Office, </institution> <month> January </month> <year> 1983. </year>
Reference-contexts: Together these documents present a complete explanation of the Ada SQL binding [Chastek 90] and [Graham 89]. These documents presuppose the Ada and SQL standards <ref> [ada 83] </ref> [ansiinteg 89]. CMU/SEI-92-TR-16 1 1.1. <p> This is not the case today. The software engineering process to which Ada is addressed "is becoming ever more decentralized and distributed. Consequently, the ability to assemble a program from independently produced software components [was] a central idea in [the] design [of Ada]." <ref> [ada 83] </ref>, 1.3 (4). The process is partially modeled in Figure 1-3. There is no such thing as the database program in that figure. Rather, there is a collection of independently written, separately compilable software modules, some of which implement the database services needed by the application. <p> But the rules of Ada in <ref> [ada 83] </ref>, Section 3.4, will not generate the "cross product" function. 32 CMU/SEI-92-TR-16 by the subprogram derivation rules from functions, procedures and operations defined in SQL_Int. The function Null_SQL_Int, returning an object of type Weight_Type with the property that Is_Null (Null_SQL_Int)=true. <p> The numeric standard base domains generate their assignment procedures in the generic sub-package of each standard support package. This was done to facilitate range checking of 12 The rules of Ada require that any overloading of "=" return a boolean result. (See <ref> [ada 83] </ref>, Section 6.7.) CMU/SEI-92-TR-16 33 null bearing types. The Assign procedure for Weight_Type objects will enforce the range constraint defined for Weight_Not_Null. <p> Some of those interpretations may be user-defined, some will be predefined. The SAMeDL does not have a means for users to define operator parameter profiles; therefore, the SAMeDL rules allow just those expressions which use only the so-called predefined operators of Ada, ( <ref> [ada 83] </ref>, Section 4.5 (6) ). An operator is predefined for a SAMeDL domain if that operator is predefined for Ada types of the same data class as the domain. There is a subtle, but easily explained, divergence from this interpretation of rule 3 in the SAMeDL. <p> There is a subtle, but easily explained, divergence from this interpretation of rule 3 in the SAMeDL. Ada predefines multiplication and division of any fixed point type and the 16 Ada is specifically stated to be case insensitive <ref> [ada 83] </ref>, 2.3 (3). SQL allows only upper case letters in identifiers [ansiinteg 89], 5.3. 42 CMU/SEI-92-TR-16 predefined type Standard.Integer [ada 83], 4.5.5 (7). The SAMeDL has no domain that can play the role of Standard.Integer. <p> Ada predefines multiplication and division of any fixed point type and the 16 Ada is specifically stated to be case insensitive <ref> [ada 83] </ref>, 2.3 (3). SQL allows only upper case letters in identifiers [ansiinteg 89], 5.3. 42 CMU/SEI-92-TR-16 predefined type Standard.Integer [ada 83], 4.5.5 (7). The SAMeDL has no domain that can play the role of Standard.Integer. Therefore, the SAMeDL allows multiplication and division of any fixed point type by integer literals or named numbers, effectively replacing the predefined type Standard.Integer with the anonymous domain, universal_integer.
Reference: [ANSI2 86] <institution> (Working Draft) Database Language SQL Addendum-2 American National Standards Institute X3H2, </institution> <year> 1986. </year>
Reference-contexts: The SQL standard contains embedded interfaces for six programming languages, including Ada, which are in concept identical to the interfaces first proposed more than twenty years ago <ref> [ANSI2 86] </ref>. Much has been written about the disadvantages of embedding SQL into Ada [Donaho 87] [Boyd 87] [Brykczynski2 87] [Engle 87] [Vasilescu 90]. These authors have recognized that this embedding creates a new language.
Reference: [ansiinteg 89] <institution> Database Language - SQL with Integrity Enhancement American National Standards Institute, </institution> <year> 1989. X3.15-1989. </year>
Reference-contexts: Together these documents present a complete explanation of the Ada SQL binding [Chastek 90] and [Graham 89]. These documents presuppose the Ada and SQL standards [ada 83] <ref> [ansiinteg 89] </ref>. CMU/SEI-92-TR-16 1 1.1. <p> The Ada SQL interface should support the portability of all application programmer written code among target hardware, operating systems, Ada compilers and SQL engines. Portability is made more difficult by the minimalist nature of the current SQL standard <ref> [ansiinteg 89] </ref>. Most if not probably all DBMS offer functionality not covered by the standard. Shared data - interoperability: There are multi language shops which have a large investment in non Ada SQL applications which they will not be willing to discard. <p> The SAME's concept of modularity is based directly on the concept of modularity to be found in the SQL standard. (See Chapter 7 of <ref> [ansiinteg 89] </ref>.) The process of Figure 1-2 is non-modular. The process assumes a single program containing both application logic, written in a programming language, and database logic, written in a data sublanguage encoded in some fashion. <p> An abstract module produces both Ada and SQL texts. Schema modules contain the data definition language (DDL) of the SAMeDL, i.e., definitions of tables, views, privileges and constraints. The syntax and the semantics of these definitions are taken almost entirely from the SQL standard <ref> [ansiinteg 89] </ref>. From the SAMeDL's perspective, the interesting information is the assignment of a domain to each database column. The distinctions made by this list clearly indicate that the tripartite division is natural. <p> The use of use clauses is restricted to context clauses and may only reference definitional modules. SQL has no notion resembling use; any schema used in a module other than the schema named in the authorization clause ( <ref> [ansiinteg 89] </ref>, 7.1) must be explicitly referenced. This treatment of schemas is carried directly into the SAMeDL. Unlike Ada, SAMeDL modules are not considered to be nested within any larger unit. <p> It does not appear at that location in SQL <ref> [ansiinteg 89] </ref>, 5.20. It was added to the SAMeDL for internal consistency. 7 The number is three. <p> Ada predefines multiplication and division of any fixed point type and the 16 Ada is specifically stated to be case insensitive [ada 83], 2.3 (3). SQL allows only upper case letters in identifiers <ref> [ansiinteg 89] </ref>, 5.3. 42 CMU/SEI-92-TR-16 predefined type Standard.Integer [ada 83], 4.5.5 (7). The SAMeDL has no domain that can play the role of Standard.Integer. <p> The values in the insert-values list and the columns in the insert-column list are associated by position, and each value must be compatible with the data type of its associated column. (See <ref> [ansiinteg 89] </ref>, Section 8.7.) The SAMeDL places further restrictions upon the insert-values list in an insert-values statement. The insert-values list is restricted to contain only static values and column names, where a static value is either a literal, a constant reference, or the keyword "null".
Reference: [Baer 90] <author> Baer, D., Sum, K. </author> <title> SQL_ArmAda An Ada-Appropriate Interface to SQL. </title> <type> Technical Report CCI-90-2-4, </type> <institution> Competence Center Informatik, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: The following list gives examples in four of the six categories of the intermediate layers. We know of no examples in the remaining categories. Abstract Modular. The SAMeDL is an abstract, modular interface. Abstract Other. Ada/SQL [Brykczynski1 86]; SQL_ARMAda <ref> [Baer 90] </ref>. These are discussed in Section 1.3.2. Concrete Modular. The SQL module language [Melton2 92]. Concrete Embedded. Embedded SQL, discussed in Section 1.3.1 below. The following sections describe these examples. The discussion begins with the traditional solution, embedded SQL. <p> The binding of Ada and SQL should provide the full capabilities of both languages. (Italics added.) CMU/SEI-92-TR-16 5 6 CMU/SEI-92-TR-16 1.3.2. All-Ada Bindings There have been a number of proposals made which accomplish an Ada SQL interface entirely within Ada [Brykczynski1 86] [Lock 90] <ref> [Baer 90] </ref> [Rosen 90]. These proposals are very different and resemble each other only in that they use Ada and the Ada compiler as the only tools with which to implement the interface. <p> For example, the language in [Brykczynski1 86], which is designed to resemble SQL, must spell select without the `t' and all with three `l's to avoid the use of an Ada reserved word. The proposal of <ref> [Baer 90] </ref> encodes the table definition given in standard SQL by: CREATE TABLE Parts Name CHARACTER (16) NOT NULL UNIQUE Number CHARACTER (8) NOT NULL UNIQUE Description CHARACTER (240) in the following Ada record type declaration: type PARTS_ROW is record NAME : NAME_COLUMN.NOT_NULL := UNIQUE; NUMBER : NUMBER_COLUMN.NOT_NULL := UNIQUE; DESCRIPTION <p> Name CHARACTER (16) NOT NULL UNIQUE Number CHARACTER (8) NOT NULL UNIQUE Description CHARACTER (240) in the following Ada record type declaration: type PARTS_ROW is record NAME : NAME_COLUMN.NOT_NULL := UNIQUE; NUMBER : NUMBER_COLUMN.NOT_NULL := UNIQUE; DESCRIPTION : DESCRIPTION_COLUMN.WITH_NULL; end record; (Note: The complete declaration of the table parts in <ref> [Baer 90] </ref> requires 4 package instantiationsone for each column and one for the tableand six other type declarations.) This encoding succeeds at giving the database columns application-oriented types, CMU/SEI-92-TR-16 7 NAME_COLUMN instead of CHARACTER (16), for example, by abusing an available Ada construct, the record type former, so that it can <p> The code written by the user of [Lock 90] is compiled and executed; the output of that execution is Ada code which is compiled and then used by the application code for DBMS services. The proposal in <ref> [Baer 90] </ref> resolves that problem by postulating an "SQL DML generator" which translates compilable (but unnatural) Ada code into compilable SQL. The fundamental objection to SQL interfaces done entirely in Ada is simply that Ada is not well suited to play the role of a database description and manipulation language. <p> The proposal in [Brykczynski1 86] follows this usage, which is inherently unsafe; it is very easy for programs to misinterpret or fail to examine the indicator parameter, misinterpreting the data. Both <ref> [Baer 90] </ref> and [Lock 90] and SAMeDL encapsulate the parameter and the nullness indicator into an abstract type for which nullness cannot be ignored. Strong, application typing: Standard SQL is weakly typed; it will not allow arithmetic on character strings, but is otherwise permissive. <p> The all-Ada solutions tend to encode database exceptional conditions as specific, pre-defined (i.e., not user defined) Ada exceptions. [Brykczynski1 86] declares three exceptions for dealing with three particular conditions, one of which is end-of-table. It is unclear what it does with hard I/O errors, for example. <ref> [Baer 90] </ref> follows much the same course.
Reference: [Boyd 87] <author> Boyd, S. </author> <title> SQL and Ada: The SQL Module Option. </title> <type> Technical Report, COMPASS, Wakefield, </type> <address> MA, </address> <year> 1987. </year>
Reference-contexts: The SQL standard contains embedded interfaces for six programming languages, including Ada, which are in concept identical to the interfaces first proposed more than twenty years ago [ANSI2 86]. Much has been written about the disadvantages of embedding SQL into Ada [Donaho 87] <ref> [Boyd 87] </ref> [Brykczynski2 87] [Engle 87] [Vasilescu 90]. These authors have recognized that this embedding creates a new language.
Reference: [Brykczynski1 86] <author> Brykczynski, B. R., Friedman, F. </author> <title> Preliminary Version: Ada/SQL: A Standard, Portable, Ada-DBMS Interface. </title> <type> Technical Report P-1944, </type> <institution> Institute for Defense Analyses, </institution> <address> Alexandria, VA, </address> <month> July </month> <year> 1986. </year>
Reference-contexts: The following list gives examples in four of the six categories of the intermediate layers. We know of no examples in the remaining categories. Abstract Modular. The SAMeDL is an abstract, modular interface. Abstract Other. Ada/SQL <ref> [Brykczynski1 86] </ref>; SQL_ARMAda [Baer 90]. These are discussed in Section 1.3.2. Concrete Modular. The SQL module language [Melton2 92]. Concrete Embedded. Embedded SQL, discussed in Section 1.3.1 below. The following sections describe these examples. The discussion begins with the traditional solution, embedded SQL. <p> Ada software using the embedding is significantly impaired. ... The binding of Ada and SQL should provide the full capabilities of both languages. (Italics added.) CMU/SEI-92-TR-16 5 6 CMU/SEI-92-TR-16 1.3.2. All-Ada Bindings There have been a number of proposals made which accomplish an Ada SQL interface entirely within Ada <ref> [Brykczynski1 86] </ref> [Lock 90] [Baer 90] [Rosen 90]. These proposals are very different and resemble each other only in that they use Ada and the Ada compiler as the only tools with which to implement the interface. <p> SQL supports only the storage of scalar types and fixed length strings. The proposal in [Whitaker 87] also requires that operations, e.g., string comparisons, have their Ada meaning wherever they appear. The implementation described in <ref> [Brykczynski1 86] </ref> of the ideas in [Whitaker 87] does not attempt to support database storage of complex or varying length objects. Further, the definition of string comparison found in [Brykczynski1 86] is the SQL definition, not the Ada definition. These deviations from the philosophy of [Whitaker 87] are unavoidable. <p> The implementation described in <ref> [Brykczynski1 86] </ref> of the ideas in [Whitaker 87] does not attempt to support database storage of complex or varying length objects. Further, the definition of string comparison found in [Brykczynski1 86] is the SQL definition, not the Ada definition. These deviations from the philosophy of [Whitaker 87] are unavoidable. The central goal of any Ada SQL interface design is to enable Ada applications to use COTS software; SQL is just a means to that end. <p> For example, the language in <ref> [Brykczynski1 86] </ref>, which is designed to resemble SQL, must spell select without the `t' and all with three `l's to avoid the use of an Ada reserved word. <p> It serves only to express in compilable but distorted Ada what can already be described in perfectly straightforward SQL. (Note: The SAMeDL data description language (DDL) is the SQL DDL with small alterations. See Section 3.3.5.) The implementations of the all-Ada interfaces generally have performance problems. The approach in <ref> [Brykczynski1 86] </ref> makes every application program depend upon the entire database definition, thereby causing excessive re-compilation as the database schema evolves. (The "fix" for this problem is an Application Scanner [Brykczynski3 88], 600 pages of Ada code.) The system described in [Lock 90] eliminates the run time excesses of [Brykczynski1 86] <p> in <ref> [Brykczynski1 86] </ref> makes every application program depend upon the entire database definition, thereby causing excessive re-compilation as the database schema evolves. (The "fix" for this problem is an Application Scanner [Brykczynski3 88], 600 pages of Ada code.) The system described in [Lock 90] eliminates the run time excesses of [Brykczynski1 86] by increasing the length of the edit-compile-test loop. The code written by the user of [Lock 90] is compiled and executed; the output of that execution is Ada code which is compiled and then used by the application code for DBMS services. <p> The proposal in <ref> [Brykczynski1 86] </ref> follows this usage, which is inherently unsafe; it is very easy for programs to misinterpret or fail to examine the indicator parameter, misinterpreting the data. <p> The standard does not specify the encoding of error conditions as status parameter values. The status parameters are easy to misinterpret or ignore. The all-Ada solutions tend to encode database exceptional conditions as specific, pre-defined (i.e., not user defined) Ada exceptions. <ref> [Brykczynski1 86] </ref> declares three exceptions for dealing with three particular conditions, one of which is end-of-table. It is unclear what it does with hard I/O errors, for example. [Baer 90] follows much the same course.
Reference: [Brykczynski2 87] <author> Brykczynski, B. R. </author> <title> Methods of Binding Ada to SQL: A General Discussion. </title> <type> Technical Report, </type> <institution> Institute for Defense Analyses, </institution> <address> Alexandria, VA, </address> <year> 1987. </year>
Reference-contexts: The SQL standard contains embedded interfaces for six programming languages, including Ada, which are in concept identical to the interfaces first proposed more than twenty years ago [ANSI2 86]. Much has been written about the disadvantages of embedding SQL into Ada [Donaho 87] [Boyd 87] <ref> [Brykczynski2 87] </ref> [Engle 87] [Vasilescu 90]. These authors have recognized that this embedding creates a new language.
Reference: [Brykczynski3 88] <author> Brykczynski, B. R., Friedman, F., Heatwole, K., Hilliard, F. </author> <title> An Ada/SQL Application Scanner. </title> <type> Technical Report M-460, </type> <institution> Institute for Defense Analyses, </institution> <address> Alexandria, VA, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: See Section 3.3.5.) The implementations of the all-Ada interfaces generally have performance problems. The approach in [Brykczynski1 86] makes every application program depend upon the entire database definition, thereby causing excessive re-compilation as the database schema evolves. (The "fix" for this problem is an Application Scanner <ref> [Brykczynski3 88] </ref>, 600 pages of Ada code.) The system described in [Lock 90] eliminates the run time excesses of [Brykczynski1 86] by increasing the length of the edit-compile-test loop.
Reference: [Castor 87] <author> Castor, V. L. Letter to Donald Deutsch. </author> <year> 1987. </year>
Reference-contexts: These authors have recognized that this embedding creates a new language. In particular, the Ada Board, speaking through the Director of the Ada Joint Program Office in a letter to the American SQL standards committee (ANSI X3H2) in April of 1987 <ref> [Castor 87] </ref>, recommended that an embedding of SQL into Ada not proceed to standardization.
Reference: [Chastek 90] <author> Chastek, Gary, Graham, Marc H., Zelesnik, Gregory. </author> <title> The SQL Ada Module Description Language - SAMeDL. </title> <type> Technical Report CMU/SEI-90-TR-26, </type> <institution> ADA255781, Software Engineering Institute, Carnegie Mellon University, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: The SQL Ada Module Description Language, the SAMeDL, has been designed to fill this gap. This document describes the SAMeDL and explains the ideas on which it is based. A complete description of the SAMeDL can be found in <ref> [Chastek 90] </ref>. The SAMeDL is designed to facilitate the construction of Ada database applications that conform to the SQL Ada Module Extensions (SAME) architecture as described in [Graham 89]. Together these documents present a complete explanation of the Ada SQL binding [Chastek 90] and [Graham 89]. <p> complete description of the SAMeDL can be found in <ref> [Chastek 90] </ref>. The SAMeDL is designed to facilitate the construction of Ada database applications that conform to the SQL Ada Module Extensions (SAME) architecture as described in [Graham 89]. Together these documents present a complete explanation of the Ada SQL binding [Chastek 90] and [Graham 89]. These documents presuppose the Ada and SQL standards [ada 83] [ansiinteg 89]. CMU/SEI-92-TR-16 1 1.1. <p> Figure 1-5 contains the corresponding Ada package specification. Both figures are taken from [Graham 89] and reference the Parts-Supplier database also used as the basis for the examples in the SAMeDL manual [Date 75] <ref> [Chastek 90] </ref>. (The Ada package Example_Definitions is a domain package in the terminology of [Graham 89], and represents a definitional module in the terminology of [Chastek 90], containing the type definitions needed to declare the procedure parameters.) The question is: what information not present in the SQL module is needed to <p> figures are taken from [Graham 89] and reference the Parts-Supplier database also used as the basis for the examples in the SAMeDL manual [Date 75] <ref> [Chastek 90] </ref>. (The Ada package Example_Definitions is a domain package in the terminology of [Graham 89], and represents a definitional module in the terminology of [Chastek 90], containing the type definitions needed to declare the procedure parameters.) The question is: what information not present in the SQL module is needed to produce the Ada package? Among the missing information are the types of the parameters to the procedures. <p> The rules and mechanisms do differ slightly depending on the class of the parameter. The default name of an Ada parameter derived from a SAMeDL input parameter is the name of the parameter. That default may be overridden using the named attribute. (See <ref> [Chastek 90] </ref>, Section 5.6.) As is discussed in Section 2.3, input parameter names may conflict with column names. These conflicts can be eliminated by renaming the input parameter. The named attribute may be used to set the name of the parameter in the Ada interface irrespective of any conflicts. <p> If the select parameter contains any operators, including the selector dot (`.'), then there is no default component name and one must be supplied using the named attribute. (See <ref> [Chastek 90] </ref>, Section 5.7.) Attempts to provide de CMU/SEI-92-TR-16 21 fault names for slightly more complex expressions break down quickly. It was therefore deemed preferable not to make the attempt. The default name of a row record component derived from an insert_column_specification is the name of the corresponding column. <p> This may be overridden using the named attribute. As SQL column names are limited in length, it may be desirable to give the Ada component a more mean ingful, self-documenting name. (See <ref> [Chastek 90] </ref>, Section 5.8.) Row record parameters have two sources of default names. The procedure taking a row record may specify a user written record declaration as effectively giving the type of the row record parameter. (See [Chastek 90], Section 5.9.) That record declaration may supply a default parameter name in <p> desirable to give the Ada component a more mean ingful, self-documenting name. (See <ref> [Chastek 90] </ref>, Section 5.8.) Row record parameters have two sources of default names. The procedure taking a row record may specify a user written record declaration as effectively giving the type of the row record parameter. (See [Chastek 90], Section 5.9.) That record declaration may supply a default parameter name in a named phrase. (See [Chastek 90], Section 4.1.6.) If it does not, or if the procedure does not specify such a record declaration, then the default is Row. <p> The procedure taking a row record may specify a user written record declaration as effectively giving the type of the row record parameter. (See <ref> [Chastek 90] </ref>, Section 5.9.) That record declaration may supply a default parameter name in a named phrase. (See [Chastek 90], Section 4.1.6.) If it does not, or if the procedure does not specify such a record declaration, then the default is Row. Whatever the default, it may be overridden with an into (or from) clause. <p> Like row record parameters, status parameters have two sources of default names. The status map referenced in the status clause that attaches the status parameter to the procedure may specify a default for the parameter name using the named phrase. (See <ref> [Chastek 90] </ref>, Section 4.1.9.) If it does not, the default name is Status. In either case, the status clause may use the named phrase to override the default. (See [Chastek 90], Section 5.13.) The type of a row record component or input parameter is one of the types defined by the <p> that attaches the status parameter to the procedure may specify a default for the parameter name using the named phrase. (See <ref> [Chastek 90] </ref>, Section 4.1.9.) If it does not, the default name is Status. In either case, the status clause may use the named phrase to override the default. (See [Chastek 90], Section 5.13.) The type of a row record component or input parameter is one of the types defined by the domain of the parameter or component. The not null phrase, borrowed from SQL, is the means by which the module specifier selects one of the types so defined. <p> As a consequence of the definitions in <ref> [Chastek 90] </ref>, Section 3.2, the context clause: with A as B; with B as A; is legal, although perverse. It sets B as the name of the module A and A as the name of the module B. <p> As these names are part of the module programmer's external obligations, the SQL treatment of these names is preserved in the SAMeDL. It is for that reason that the treatment of references in <ref> [Chastek 90] </ref>, Section 3.4, distinguishes "defining locations" from "reference locations" and treats an identifier prefix as a whole, rather than as component wise. The order of the rules in [Chastek 90], Section 3.4, implements a nesting of declarations or "hiding" discipline essentially that of Ada, but simplified by the lack of <p> It is for that reason that the treatment of references in <ref> [Chastek 90] </ref>, Section 3.4, distinguishes "defining locations" from "reference locations" and treats an identifier prefix as a whole, rather than as component wise. The order of the rules in [Chastek 90], Section 3.4, implements a nesting of declarations or "hiding" discipline essentially that of Ada, but simplified by the lack of user-specified nesting. <p> This removes the ambiguity between column and parameter names. The SAMeDL does not use colons with parameter names. 24 CMU/SEI-92-TR-16 Were there no such parameter, the identifier would be invalid. (See <ref> [Chastek 90] </ref>, Section 3.4, prefix rule 2.a.i, full name rule 1.c.) The constant A in the module Duplicate cannot be referenced from the procedure Duplicate. This is very nearly the situation in Ada, except that the constant A could be referenced as Standard.Duplicate.A were the SAMeDL modules Ada packages. <p> The support package contains the Ada type, procedure, and function declarations needed by the corresponding standard base domain. Note that the support packages, such as SQL_Int_Pkg, and the other packages listed in the Guideline and the SAMeDL manual are only suggestions [Graham 89] <ref> [Chastek 90] </ref>. Users of the SAME and the SAME description language are free to use other support packages, provided only that their treatment of missing information is safe. 3.2.1. <p> Such a 10 domain can be declared in a SAMeDL definition or abstract module by the syntax: domain Weight is new SAMeDL_Standard.SQL_Int (First =&gt; 0, Last => SAMeDL_System.Max_SQL_Int); The domain pattern for the base domain SQL_Int (see Appendix C.1 of the Reference Manual <ref> [Chastek 90] </ref>) causes the following Ada code to appear in the specification of the Ada package corresponding to the module containing that definition. (See Section 5.2 for a discussion of patterns in base domain declarations.) type Weight_Not_Null is new SQL_Int_Pkg.SQL_Int_Not_Null range 0 .. <p> These take operands of type Weight_Type and 12 return a result of type Boolean_with_Unknown defined in SQL_Boolean_Pkg. (See <ref> [Chastek 90] </ref>, Appendix C.) The meaning of these functions is given by the following piece of pseudo-code. if either operand is null, then return UNKNOWN else return the result of applying the operator to the operands; end if; Overloadings of the comparison operators including = (and /=). <p> Their format is discussed in Section 3.3.2. 3.3.1. Declaration Format A SAMeDL declaration is either a module, base domain specification, base domain body, domain, subdomain, cursor, procedure, cursor procedure, constant, record, enumeration, exception, status map, table, privilege, or view declaration. (See <ref> [Chastek 90] </ref>, Sections 3.2, 4.1, 5.1, 4.2, 4.2.1, and 4.2.2.) The syntax of a declaration is exactly that of SQL whenever that declaration has little or no effect upon the generated Ada, environment, or interface. <p> For example, a domain declaration requires a reference to a base domain and an optional parameter association list. (See <ref> [Chastek 90] </ref>, Section 4.1.4.) As there is no declaration body, the end and optional repetition of the declaration name are also omitted. Exception declarations simply declare that an identifier is an exception, with no other information necessary. <p> Scalar Declarations A SAMeDL scalar declaration is the special subclass of SAMeDL declarations that associate a domain with the object declared. These are constant declarations, record component declarations, column definitions, and parameter declarations. (See <ref> [Chastek 90] </ref>, Sections 4.1.5, 4.1.6, 4.2.1, and 5.6.) These declarations are of the form: Name of the declaration, where applicable. Optional named phrase. Domain reference. Optional keywords not null. Adherence to this format is loose. <p> <ref> [Chastek 90] </ref>, Sections 4.1.5, 4.1.6, 4.2.1, and 5.6.) These declarations are of the form: Name of the declaration, where applicable. Optional named phrase. Domain reference. Optional keywords not null. Adherence to this format is loose. Column definitions maintain a strong SQL flavor while parameter declarations adopt an Ada-like style. (See [Chastek 90], Section 5.6.) However, certain general rules apply to the named phrase, and the combination of the domain reference and the keywords not null. (See Section 3.3.3 for a discussion of the named phrase.) The Ada type of the object declared by a scalar declaration is determined by the domain <p> For row record parameters, the default names of the components are given by the corresponding select parameters. A select parameter in the SAMeDL is a value expression (see Section 4.1), followed by the optional named phrase and not null phrase. (See <ref> [Chastek 90] </ref>, Section 5.7.) The named phrase allows the SAMeDL programmer to assign a meaningful name to a select parameter and thereby name its corresponding row record component. (See Section 4.2.) The named phrase is necessary when a value expression has no obvious associated name; it may be desirable when the <p> Neither EMPSAL nor EMPBENS accurately describes total compensation. There is no way for the SAMeDL to infer a meaningful name, as it might were the column EMPCOMP (defined as total employee compensation) in the table 14 Types declared by domain instantiations are named by the base domain patterns. (See <ref> [Chastek 90] </ref>, Section 4.1.4.) 38 CMU/SEI-92-TR-16 S. Thus, the SAMeDL programmer must supply a meaningful name for such "complex" se- lect parameters via the named phrase. <p> The Ada application, however, may not consider EMPNO a meaningful or desirable name: the named phrase allows the SAMeDL programmer to assign a more meaningful name, in this case Employee_Number. Named phrases also serve this purpose in insert column specifications. (See <ref> [Chastek 90] </ref>, Section 5.8.) 3.3.4. Constants Constants are a convenience that allows the SAMeDL user to assign a name, and optionally a domain, to a frequently used static expression. There is no notion of a constant declaration in SQL. <p> An Ada constant declaration is generated from each SAMeDL constant declaration. That Ada constant will have the value of the SAMeDL constant declaration's static expression, as determined by the rules of SQL, not Ada. (See <ref> [Chastek 90] </ref>, Section 4.1.5.) This provides for one semantics for value expressions in the SAMeDL; whether a value expression appears in a select parameter list or as a static expression in a constant declaration, its value is determined by the rules of SQL. (See Section 4.1.) This also provides the Ada <p> Type conversions are essential in any strongly typed language, but SQL is not strongly typed and has no such operations. When defining the SQL semantics of a SAMeDL domain conversion, there is no alternative to the choice made by the SAMeDL, which is to erase the conversion. (See <ref> [Chastek 90] </ref>, Section 5.10, SQL Semantics rule 3.) Insofar as an Ada type conversion has no semantic effect (i.e., is the identity operation on values, as when one integer type is converted to another with identical subtype constraints), this presents no difficulty. <p> In order to ensure that the author of these expressions thinks about what they mean, a warning message must be issued for any conversion which would not be the identity in Ada. (See <ref> [Chastek 90] </ref>, Section 5.10, Recursive Cases, rule 2.a.i.) These conversions are generally ones that lose accuracy, as when a floating point number is converted to an integer. We are now in a position to explain the difference in the Ada and SAMeDL treatment of fixed multiplication and division. <p> In assignment contexts, SQL will perform a limited class of data conversions. These are precisely the cases which are allowed by the SAMeDL. (See <ref> [Chastek 90] </ref>, Section 3.5.) 4.2. Using Row Records and Into and Insert-From Clauses Data received from, or transmitted to, an SQL database is represented by a sequence of individual parameters in SQL. <p> If no into clause had been specified in the SAMeDL procedure Part_Name, the following Ada would have been generated: type Row_Type is record Part_Number : Part_Number_Type; end record; procedure Part_Name (Row : in out Row_Type); The SAMeDL user may supply a reference to a SAMeDL record declaration (see <ref> [Chastek 90] </ref>, Section 4.1.6) in the into or insert-from clause of the associated procedure. In this case, no Ada record declaration is generated as a result of the Part_Name declaration. <p> An interactive application encountering a storage overflow problem may wish to recover gracefully in order to maintain dialogue with the user; a batch application may be willing to abort immediately. The classification mechanism must be flexible enough to account for these differences. CMU/SEI-92-TR-16 49 The status map (see <ref> [Chastek 90] </ref>, Section 4.1.9) is the mechanism by which the SAMeDL allows the user to specify and utilize SQLCODE classification schemes. A status map is attached to a procedure via a status clause. (See [Chastek 90], Section 5.13.) Each procedure may therefore have its own status classification scheme. <p> CMU/SEI-92-TR-16 49 The status map (see <ref> [Chastek 90] </ref>, Section 4.1.9) is the mechanism by which the SAMeDL allows the user to specify and utilize SQLCODE classification schemes. A status map is attached to a procedure via a status clause. (See [Chastek 90], Section 5.13.) Each procedure may therefore have its own status classification scheme. Although a DBMS may have hundreds of error codes, so that there are in principle trillions of classification schemes, in practice there are no more than handful of useful status maps. <p> There are several issues with respect to user-definable base domains that must be addressed by the SAMeDL implementor. The standard options specified in the language reference manual (see <ref> [Chastek 90] </ref>, Section 4.1.2) are necessary for the definition of the SAMeDL language; in practice, other options may be necessary. For example, the SAMeDL processor may require base domain options that specify: Name of the Ada support package. <p> While the syntax and semantics of an extension is implementation-defined, the SAMeDL Language Reference Manual states that "any portion of an extension whose semantics may be expressed in standard SAMeDL shall be expressed in standard SAMeDL syntax." (See <ref> [Chastek 90] </ref>.) For example, database data returned from extended procedures or cursors should be returned to the application in record objects. The vendor is strongly urged to use syntax and semantics in the spirit of the SAMeDL when adding extensions. <p> However a vendor may implement the SAMeDL extension for predicates such as an outer join, the operands (in the above example SUPPLIERS.SCITY and PARTS.PCITY) must obey the strict typing discipline specified by <ref> [Chastek 90] </ref>, Section 5.11. Notice that the SAMeDL allows extended input parameters with an out mode.
Reference: [Chastek2 91] <author> Chastek, Gary J., Graham, Marc H., and Zelesnik, Gregory. </author> <title> Rationale for SQAL Ada Module Description Language SAMeDL. </title> <type> Technical Report CMU/SEI-91-TR-4, </type> <institution> ADA235780, Software Engineering Institute, Carnegie Mellon University, </institution> <month> March </month> <year> 1991. </year>
Reference: [Cobol 78] <institution> COBOL Journal of Development. Materiel Data Management Center, </institution> <year> 1978. </year> <note> Earlier versions appeared in 1973 and 1968. CMU/SEI-92-TR-16 57 </note>
Reference-contexts: Embedded SQL Traditionally, application programming languages were given access to a DBMS via what has been called a "data sublanguage." (See Chapter 3 of [Date 75].) The earliest example of such a sublanguage to be standardized was the extension to COBOL often called the CODASYL DBMS <ref> [Cobol 78] </ref>. A sublanguage is a collection of statement kinds, often called verbs or operations but given in a syntax suitable for describing programming constructs (e.g., BNF). The addition of such syntax to COBOL, for example, results effectively in a new language.
Reference: [Darnovsky 87] <author> Darnovsky, M., Bowman, J. </author> <title> TRANSACT-SQL User's Guide. Sybase, </title> <publisher> Inc., </publisher> <year> 1987. </year>
Reference-contexts: Extended predicates must also preserve the strong typing rules of the SAMeDL. For example, Sybase's TRANSACT-SQL (see <ref> [Darnovsky 87] </ref>) supports an outer join that combines two tables to create an new relation.
Reference: [Date 75] <author> Date, C. J. </author> <title> An Introduction to Database Systems, First Edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1975. </year>
Reference-contexts: Finally, modular solutions, both abstract and concrete, are described. The proposals are then rated against the criteria and issues in Section 1.2. 4 CMU/SEI-92-TR-16 1.3.1. Embedded SQL Traditionally, application programming languages were given access to a DBMS via what has been called a "data sublanguage." (See Chapter 3 of <ref> [Date 75] </ref>.) The earliest example of such a sublanguage to be standardized was the extension to COBOL often called the CODASYL DBMS [Cobol 78]. A sublanguage is a collection of statement kinds, often called verbs or operations but given in a syntax suitable for describing programming constructs (e.g., BNF). <p> Figure 1-5 contains the corresponding Ada package specification. Both figures are taken from [Graham 89] and reference the Parts-Supplier database also used as the basis for the examples in the SAMeDL manual <ref> [Date 75] </ref> [Chastek 90]. (The Ada package Example_Definitions is a domain package in the terminology of [Graham 89], and represents a definitional module in the terminology of [Chastek 90], containing the type definitions needed to declare the procedure parameters.) The question is: what information not present in the SQL module is
Reference: [Dewar 89] <author> Dewar, R. B. K. </author> <title> Database Language - Embedded SQL X3.168-1989 American National Standards Institute, </title> <year> 1989. </year>
Reference-contexts: Basic, atomic, or scalar types: These are the machine representation oriented types of the two languages. The task of reconciling the representations of scalar types shared by the two systems (e.g., how many bits are there in a database integer?) has been accomplished by the ANSI SQL standard <ref> [Dewar 89] </ref>. But what of the types not shared such as DECIMAL in SQL, or enumeration in Ada? Should the interface support both, either, or neither? 2 CMU/SEI-92-TR-16 What about operations on the shared types? For example, Ada and SQL use different rules for string comparisons. <p> The all-Ada proposals have received no support from the DBMS community. Atomic types: The SQL standard interface for Ada supports neither enumeration nor decimal data types <ref> [Dewar 89] </ref>. The all-Ada proposals generally support enumeration, but not decimal arithmetic. In both cases, data is handled by SQL rules in the DBMS and Ada rules in the application. <p> The idea is that, from a standard SQL module, it may be possible to derive the package specifications and bodies of the abstract modules defined by the SAME. The abstract module specifications differ from the specifications defined by SQL primarily in the parameter profiles; in <ref> [Dewar 89] </ref>, the SQL procedures have parameters whose types are restricted to the primitive types defined by SQL, whereas the abstract module procedures have application-oriented abstract types. <p> What is needed is a set of Ada type declarations which exactly describe the SQL data types. These declarations appear in the Ada package template SQL_Standard, shown in Figure 3-1. This package is now part of the ANSI SQL standard as amended <ref> [Dewar 89] </ref>. The unspecified values in the SQL_Standard template are filled in with values specific to the DBMS. <p> Standard_Map signals end of table by returning false. (See Section 4.5 and <ref> [Dewar 89] </ref>, Section 8.6.) 4.5. Standard Post Processing Standard post processing is a central feature of the SAMeDL. Its goal is to ensure a uniform, user-specified treatment of the DBMS status parameter, SQLCODE.
Reference: [Donaho 87] <author> Donaho, J. E. D., Davis, G. K. </author> <title> Ada-Embedded SQL: the Options. Ada Letters VII(3):60-72, </title> <month> May June </month> <year> 1987. </year>
Reference-contexts: The SQL standard contains embedded interfaces for six programming languages, including Ada, which are in concept identical to the interfaces first proposed more than twenty years ago [ANSI2 86]. Much has been written about the disadvantages of embedding SQL into Ada <ref> [Donaho 87] </ref> [Boyd 87] [Brykczynski2 87] [Engle 87] [Vasilescu 90]. These authors have recognized that this embedding creates a new language.
Reference: [Engle 87] <author> Engle, C., Firth, R., Graham, Marc H., Wood, W. G. </author> <title> Interfacing Ada and SQL. </title> <type> Technical Report CMU/SEI-87-TR-48, </type> <institution> ADA199634, Software Engineering Institute, Carnegie Mellon University, </institution> <month> December </month> <year> 1987. </year>
Reference-contexts: Properties of An Acceptable Solution The problem as stated allows for a myriad of solutions and a myriad of solutions has indeed been proposed. This section describes the issues by which any solution may be judged. It is based on the discussion in <ref> [Engle 87] </ref>. There are requirements that any solution must meet in order to be considered acceptable. This list presents the requirements. Portability: A primary purpose of standards promulgation is the provision of portability for user written software. <p> The SQL standard contains embedded interfaces for six programming languages, including Ada, which are in concept identical to the interfaces first proposed more than twenty years ago [ANSI2 86]. Much has been written about the disadvantages of embedding SQL into Ada [Donaho 87] [Boyd 87] [Brykczynski2 87] <ref> [Engle 87] </ref> [Vasilescu 90]. These authors have recognized that this embedding creates a new language. <p> SQL_Standard The fundamental feature of any Ada SQL interface is the ability to move data across the interface in a "reasonable" way. In <ref> [Engle 87] </ref>, reasonable is defined as direct: every value stored in the database can be represented as the value of some application object without run time data conversion. What is needed is a set of Ada type declarations which exactly describe the SQL data types.
Reference: [Graham 89] <author> Graham, Marc H. </author> <title> Guidelines for the Use of the SAME. </title> <type> Technical Report CMU/SEI-89-TR-16, </type> <institution> ADA228027, Software Engineering Institute, Carnegie Mellon University, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: A complete description of the SAMeDL can be found in [Chastek 90]. The SAMeDL is designed to facilitate the construction of Ada database applications that conform to the SQL Ada Module Extensions (SAME) architecture as described in <ref> [Graham 89] </ref>. Together these documents present a complete explanation of the Ada SQL binding [Chastek 90] and [Graham 89]. These documents presuppose the Ada and SQL standards [ada 83] [ansiinteg 89]. CMU/SEI-92-TR-16 1 1.1. <p> The SAMeDL is designed to facilitate the construction of Ada database applications that conform to the SQL Ada Module Extensions (SAME) architecture as described in <ref> [Graham 89] </ref>. Together these documents present a complete explanation of the Ada SQL binding [Chastek 90] and [Graham 89]. These documents presuppose the Ada and SQL standards [ada 83] [ansiinteg 89]. CMU/SEI-92-TR-16 1 1.1. <p> This ensures that failure conditions will not be ignored or lost. 1.4. Why a New Language? The SAMeDL was designed to facilitate the construction of Ada DBMS applications constructed in conformance with the SAME guidelines <ref> [Graham 89, Moore 89] </ref>. Those guidelines require application-oriented typing at the application interface, but they do not require strong, application typing of the SQL statements themselves. <p> Figure 1-5 contains the corresponding Ada package specification. Both figures are taken from <ref> [Graham 89] </ref> and reference the Parts-Supplier database also used as the basis for the examples in the SAMeDL manual [Date 75] [Chastek 90]. (The Ada package Example_Definitions is a domain package in the terminology of [Graham 89], and represents a definitional module in the terminology of [Chastek 90], containing the type <p> Figure 1-5 contains the corresponding Ada package specification. Both figures are taken from <ref> [Graham 89] </ref> and reference the Parts-Supplier database also used as the basis for the examples in the SAMeDL manual [Date 75] [Chastek 90]. (The Ada package Example_Definitions is a domain package in the terminology of [Graham 89], and represents a definitional module in the terminology of [Chastek 90], containing the type definitions needed to declare the procedure parameters.) The question is: what information not present in the SQL module is needed to produce the Ada package? Among the missing information are the types of the parameters <p> That is indicative of the SAMeDL design philosophy. 1.5. Fundamental Concepts of the SAMeDL The primary design goal for the SAMeDL is the partial automation of the creation of Ada DBMS applications conforming to the SAME architecture of <ref> [Graham 89] </ref>. In particular, the requirements for the SAMeDL include support for: Modular program construction; separate compilation. Application oriented, strong typing. Within the description of the database interaction (i.e., within the SAMeDL); and At the application interface. 3 The SAMeDL module does not generate the Ada package exactly. <p> Specifically, a base domain encapsulates: The Ada types and operations necessary to represent and manipulate database objects as they are realized in the Ada application. The SQL data type, called the dbms type, to be used with SQL parameters at the database interface <ref> [Graham 89] </ref>. The base domain parameters which supply information needed to derive a domain from the base domain. The data class which governs the use of literals with objects of domains derived from the base domain. <p> The operations that one needs to associate with the abstract type depend upon how objects of that type might typically be used. One approach, called the minimalist (see <ref> [Graham 89] </ref>), views such an object merely as a value repository. The processing of that object, say of Weight_Type, involves a test for nullness, and if the object is not null, an extraction of its value into a different object which is guaranteed not to be null. <p> The support package contains the Ada type, procedure, and function declarations needed by the corresponding standard base domain. Note that the support packages, such as SQL_Int_Pkg, and the other packages listed in the Guideline and the SAMeDL manual are only suggestions <ref> [Graham 89] </ref> [Chastek 90]. Users of the SAME and the SAME description language are free to use other support packages, provided only that their treatment of missing information is safe. 3.2.1.
Reference: [Ichbiah 90] <author> Ichbiah, J. </author> <title> Public Comments. June 1990. </title> <booktitle> ISO/WG9 meeting. </booktitle>
Reference-contexts: 1. Overview The lack of an acceptable standard interface between the programming language Ada and the database language SQL is "the greatest impediment to the further spread of Ada" <ref> [Ichbiah 90] </ref>. The SQL Ada Module Description Language, the SAMeDL, has been designed to fill this gap. This document describes the SAMeDL and explains the ideas on which it is based. A complete description of the SAMeDL can be found in [Chastek 90].
Reference: [idms 78] <institution> IDMS DML Programmer's Reference Guide. Cullinane Corporation, </institution> <year> 1978. </year>
Reference-contexts: SQL is a data manipulation language in which the intended results are described, the algorithm which produces the result being left to the DBMS. To avoid the expense of creating an entire compiler, the early implementations of data sub-languages produced so-called pre-compilers <ref> [idms 78] </ref> [quel 76] [sysr 76]. These pre-compilers remove operations in the data sublanguage from the program text and replace them with text legal in the base language, generally with procedure calls. The process is diagrammed in Figure 1-2.
Reference: [Lock 90] <institution> User's Manual for a Prototype Binding of ANSI-Standard SQL to Ada Supporting the SAME Methodolgy. Software Technology for Adaptable, Reliable Systems (STARS) Program, </institution> <year> 1990. </year>
Reference-contexts: The binding of Ada and SQL should provide the full capabilities of both languages. (Italics added.) CMU/SEI-92-TR-16 5 6 CMU/SEI-92-TR-16 1.3.2. All-Ada Bindings There have been a number of proposals made which accomplish an Ada SQL interface entirely within Ada [Brykczynski1 86] <ref> [Lock 90] </ref> [Baer 90] [Rosen 90]. These proposals are very different and resemble each other only in that they use Ada and the Ada compiler as the only tools with which to implement the interface. <p> The approach in [Brykczynski1 86] makes every application program depend upon the entire database definition, thereby causing excessive re-compilation as the database schema evolves. (The "fix" for this problem is an Application Scanner [Brykczynski3 88], 600 pages of Ada code.) The system described in <ref> [Lock 90] </ref> eliminates the run time excesses of [Brykczynski1 86] by increasing the length of the edit-compile-test loop. The code written by the user of [Lock 90] is compiled and executed; the output of that execution is Ada code which is compiled and then used by the application code for DBMS <p> as the database schema evolves. (The "fix" for this problem is an Application Scanner [Brykczynski3 88], 600 pages of Ada code.) The system described in <ref> [Lock 90] </ref> eliminates the run time excesses of [Brykczynski1 86] by increasing the length of the edit-compile-test loop. The code written by the user of [Lock 90] is compiled and executed; the output of that execution is Ada code which is compiled and then used by the application code for DBMS services. <p> The proposal in [Brykczynski1 86] follows this usage, which is inherently unsafe; it is very easy for programs to misinterpret or fail to examine the indicator parameter, misinterpreting the data. Both [Baer 90] and <ref> [Lock 90] </ref> and SAMeDL encapsulate the parameter and the nullness indicator into an abstract type for which nullness cannot be ignored. Strong, application typing: Standard SQL is weakly typed; it will not allow arithmetic on character strings, but is otherwise permissive. <p> It is unclear what it does with hard I/O errors, for example. [Baer 90] follows much the same course. The SAMeDL, along with <ref> [Lock 90] </ref>, supports the concept of a "status map," which translates the DBMS-defined status parameter values to application-defined status parameter values (for a status parameter over a user-defined enumeration type) for whichever exceptional conditions the application expects, e.g., end-of-table. (A status map may also cause user defined exceptions to be raised.)
Reference: [Luckham 87] <author> Luckham, D. C. ANNA, </author> <title> A Language for Annotating Ada Programs: Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: This seemingly impossible task can, in fact, be achieved through the use of structured comments. Structured comments are a device which has found some acceptance in the Ada community for adding information to an Ada program without violating Ada language rules. The trick is used by Byron and <ref> [Luckham 87] </ref>, among others. The idea is to encode information needed by a tool for generating Abstract Module procedures into a comment.
Reference: [Melton 90] <editor> Melton, J., ed. </editor> <title> (ISO working draft) Database Language SQL2. </title> <booktitle> International Organization for Standardization and American National Standards Institute X3H2, </booktitle> <year> 1990. </year>
Reference-contexts: CMU/SEI-92-TR-16 53 The implementor should note that an SQL implementation which employs a nonstandard SQL syntax does not require an extension to SAMeDL; the SAMeDL processor can simply generate the nonstandard SQL. Also, if an extended function or operation is addressed in 19 SQL2 (see <ref> [Melton 90] </ref>), it is suggested that the implementor use SQL2 as a guide. This may ease portability problems and make extension of the an SQL-based SAMeDL processor to an SQL2-based processor easier should SQL2 be accepted as a standard.
Reference: [Melton2 92] <editor> Melton, J., ed. </editor> <booktitle> Database Language SQL2. International Organization for Standardization, </booktitle> <year> 1992. </year> <note> 58 CMU/SEI-92-TR-16 </note>
Reference-contexts: We know of no examples in the remaining categories. Abstract Modular. The SAMeDL is an abstract, modular interface. Abstract Other. Ada/SQL [Brykczynski1 86]; SQL_ARMAda [Baer 90]. These are discussed in Section 1.3.2. Concrete Modular. The SQL module language <ref> [Melton2 92] </ref>. Concrete Embedded. Embedded SQL, discussed in Section 1.3.1 below. The following sections describe these examples. The discussion begins with the traditional solution, embedded SQL. It then describes the solutions, called "Abstract Other" above, that have been proposed specifically for Ada.
Reference: [Moore 89] <author> Moore, J. W. </author> <title> Conformance Criteria for the SAME Approach to Binding Ada Programs to SQL August 1989. </title> <note> Special Report, CMU/SEI-89-SR-14. </note>
Reference-contexts: This ensures that failure conditions will not be ignored or lost. 1.4. Why a New Language? The SAMeDL was designed to facilitate the construction of Ada DBMS applications constructed in conformance with the SAME guidelines <ref> [Graham 89, Moore 89] </ref>. Those guidelines require application-oriented typing at the application interface, but they do not require strong, application typing of the SQL statements themselves.
Reference: [quel 76] <author> Stonebraker, M., Wong, E., Kreps, P., and Held, G. </author> <title> The Design and Implementation of INGRES. </title> <journal> ACM Transactions on Database Systems 1(3) </journal> <pages> 189-222, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: SQL is a data manipulation language in which the intended results are described, the algorithm which produces the result being left to the DBMS. To avoid the expense of creating an entire compiler, the early implementations of data sub-languages produced so-called pre-compilers [idms 78] <ref> [quel 76] </ref> [sysr 76]. These pre-compilers remove operations in the data sublanguage from the program text and replace them with text legal in the base language, generally with procedure calls. The process is diagrammed in Figure 1-2.
Reference: [Rosen 90] <author> Rosen, J. P. </author> <title> Ada to SQL-Database Binding (Draft Proposal). </title> <year> 1990. </year>
Reference-contexts: The binding of Ada and SQL should provide the full capabilities of both languages. (Italics added.) CMU/SEI-92-TR-16 5 6 CMU/SEI-92-TR-16 1.3.2. All-Ada Bindings There have been a number of proposals made which accomplish an Ada SQL interface entirely within Ada [Brykczynski1 86] [Lock 90] [Baer 90] <ref> [Rosen 90] </ref>. These proposals are very different and resemble each other only in that they use Ada and the Ada compiler as the only tools with which to implement the interface.
Reference: [SQLIB1 90] <author> ANSI X3H2. </author> <note> SQL Information Bulletin Nbr 1. </note> <year> 1990. </year>
Reference-contexts: Duplicate.A . . . . . . The identifier Duplicate.A in the procedure Duplicate references the input parameter. 8 The ANSI SQL standardization committee, X3H2, modified the SQL standard in January of 1990 (see <ref> [SQLIB1 90] </ref>) by adding a colon to the front of parameter names. The use of a module language parameter in the SQL module language now has the same lexical form as the use of a variable in embedded SQL. This removes the ambiguity between column and parameter names.
Reference: [sysr 76] <author> Astrahan, M. M .et al. </author> <title> System R: Relational Approach to Database Management. </title> <journal> ACM Transactions on Database Systems 1(2) </journal> <pages> 97-137, </pages> <month> June </month> <year> 1976. </year>
Reference-contexts: SQL is a data manipulation language in which the intended results are described, the algorithm which produces the result being left to the DBMS. To avoid the expense of creating an entire compiler, the early implementations of data sub-languages produced so-called pre-compilers [idms 78] [quel 76] <ref> [sysr 76] </ref>. These pre-compilers remove operations in the data sublanguage from the program text and replace them with text legal in the base language, generally with procedure calls. The process is diagrammed in Figure 1-2.
Reference: [Vasilescu 90] <author> Vasilescu, E. N. </author> <title> Approaches in Interfacing Ada and SQL (Draft). </title> <year> 1990. </year>
Reference-contexts: The SQL standard contains embedded interfaces for six programming languages, including Ada, which are in concept identical to the interfaces first proposed more than twenty years ago [ANSI2 86]. Much has been written about the disadvantages of embedding SQL into Ada [Donaho 87] [Boyd 87] [Brykczynski2 87] [Engle 87] <ref> [Vasilescu 90] </ref>. These authors have recognized that this embedding creates a new language.
Reference: [Whitaker 87] <author> Whitaker, W. A. </author> <title> Requirements for an SQL Binding to Ada. </title> <month> November </month> <year> 1987. </year>
Reference-contexts: Most (but not all) of the all-Ada proposals have as a high level goal the imposition of Ada-like typing on the DBMS. Some proposals go so far as to require the interface to allow objects of any Ada type, including variant records and unconstrained arrays, in the database <ref> [Whitaker 87] </ref>. SQL supports only the storage of scalar types and fixed length strings. The proposal in [Whitaker 87] also requires that operations, e.g., string comparisons, have their Ada meaning wherever they appear. The implementation described in [Brykczynski1 86] of the ideas in [Whitaker 87] does not attempt to support database <p> Some proposals go so far as to require the interface to allow objects of any Ada type, including variant records and unconstrained arrays, in the database <ref> [Whitaker 87] </ref>. SQL supports only the storage of scalar types and fixed length strings. The proposal in [Whitaker 87] also requires that operations, e.g., string comparisons, have their Ada meaning wherever they appear. The implementation described in [Brykczynski1 86] of the ideas in [Whitaker 87] does not attempt to support database storage of complex or varying length objects. <p> records and unconstrained arrays, in the database <ref> [Whitaker 87] </ref>. SQL supports only the storage of scalar types and fixed length strings. The proposal in [Whitaker 87] also requires that operations, e.g., string comparisons, have their Ada meaning wherever they appear. The implementation described in [Brykczynski1 86] of the ideas in [Whitaker 87] does not attempt to support database storage of complex or varying length objects. Further, the definition of string comparison found in [Brykczynski1 86] is the SQL definition, not the Ada definition. These deviations from the philosophy of [Whitaker 87] are unavoidable. <p> The implementation described in [Brykczynski1 86] of the ideas in <ref> [Whitaker 87] </ref> does not attempt to support database storage of complex or varying length objects. Further, the definition of string comparison found in [Brykczynski1 86] is the SQL definition, not the Ada definition. These deviations from the philosophy of [Whitaker 87] are unavoidable. The central goal of any Ada SQL interface design is to enable Ada applications to use COTS software; SQL is just a means to that end. <p> that the SQL statement, no matter how encoded by the programmer, will be executed by the COTS DBMS, and it is impossible for the interface to affect that interpretation. (If use of COTS were not the issue, it would certainly be possible to build a DBMS satisfying the requirements of <ref> [Whitaker 87] </ref>.) The all-Ada solutions generally resort to tricks to accomplish their objectives entirely within Ada. For example, the language in [Brykczynski1 86], which is designed to resemble SQL, must spell select without the `t' and all with three `l's to avoid the use of an Ada reserved word.
Reference: [Zave 89] <author> Zave, </author> <note> P. </note>
Reference-contexts: Ada SQL program construction should be treated as an example of mul-tiparadigm programming, a method by which software engineers "build systems using as many paradigms as [they] need, each paradigm handling those aspects of the system for which it is best suited" <ref> [Zave 89] </ref>. All-Ada solutions deliberately obfuscate the distinction between the programming language and database language paradigms; embedded solutions simply ignore it, leaving the task of reconciling the two paradigms to the programmer. The SAME and the SAMeDL treat the Ada and SQL paradigms as equal partners in application construction.
References-found: 32

