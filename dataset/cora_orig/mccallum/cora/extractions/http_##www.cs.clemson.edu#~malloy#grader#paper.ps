URL: http://www.cs.clemson.edu/~malloy/grader/paper.ps
Refering-URL: http://www.cs.clemson.edu/~malloy/grader.html
Root-URL: http://www.cs.clemson.edu
Title: Integrating a GUI into a Command Driven Application  
Author: Shannon Hughes, Brian A. Malloy and John D. McGregor 
Address: Clemson, SC 29634  
Affiliation: Computer Science Dept Clemson University  
Abstract: There are many applications in use today that are driven by a command line interface rather than a graphical interface. Most of these applications are robust, popular and proven in general usage. The convenience and ease of use that a graphical interface provides might make these applications available to a wider range of users. Previous approaches to integrating a graphical interface into command driven software have focused on using a variation of a pipe to negotiate communication between two processes. The advantage of using a pipe is that communication can be established without knowledge of the source code for the command driven application; the disadvantages of using a pipe are that the linkage can be slow and, for some large applications, the system may stall. In this work, we describe a technique that exploits ostreams and subtyping to integrate a graphical interface into a command driven application. The technique that we propose does not create a new process to construct the communication linkage nor does it require a sentinel to terminate the linkage. We use the technique to integrate a graphical interface into legacy code, a grader program, that maintains a list of student grades. The grader program is coded in C++, exploits the Command and Envelope-Letter patterns and uses the standard library containers, algorithms and iterators to implement much of its functionality. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. O. Coplien. </author> <title> Advanced C++, Programming Styles and Idioms. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: The command 7 the grader program. This framework combines the Command pattern [3] and the Envelope-Letter pattern <ref> [1] </ref>. and data frameworks were included in the original command driven interface; the graphical framework was added after the command interface was fully implemented. <p> summarizes the classes in each of the frameworks; we detail the first two frameworks in this section and the graphical framework in Section 6. 5.1 The Command Framework The classes in the command framework are summarized in Figure 4; this framework combines the Command pattern [3] and the Envelope-Letter pattern <ref> [1] </ref>. The Command pattern [3] permits a request for service to be encapsulated as an object so that the object requesting the service, in this case GradeSheet, can issue the request without knowledge about the operation being requested. <p> The class shown on the right of side of Figure 4, class GenCommand, is the envelope for the Envelope-Letter pattern <ref> [1] </ref>. The Envelope-Letter pattern can provide more polymorphism and run-time support than inheritance with virtual functions alone [1]. The letter can be thought of as being in the envelope's employ, logically encapsulated inside the envelope. <p> The class shown on the right of side of Figure 4, class GenCommand, is the envelope for the Envelope-Letter pattern <ref> [1] </ref>. The Envelope-Letter pattern can provide more polymorphism and run-time support than inheritance with virtual functions alone [1]. The letter can be thought of as being in the envelope's employ, logically encapsulated inside the envelope. We use the constructor of the envelope class, the GenCommand class, to instantiate letters in response to the identification of a request made by the user through the Menu class. <p> Thus, the constructor for GenCommand contains a case statement that instantiates a letter and this instantiation is encapsulated in the constructor of the envelope. Coplien refers to this idiom as a virtual constructor <ref> [1] </ref>. The instance of the letter is returned to GradeSheet, which invokes execute () for the requested grader command. 5.2 The Data Framework and the Standard Library list is represented by standard library containers as a list of vectors.
Reference: [2] <author> W. L. Crowe. </author> <title> A pseudo-terminal class for unix. </title> <journal> C/C++ Users Journal, </journal> <pages> pages 21-29, </pages> <month> March </month> <year> 1998. </year>
Reference-contexts: a graphical interface into legacy code have focused on using a variation of a pipe to negotiate the communication between two processes where the master process is the graphical interface and the slave process is the command driven application; the vehicle of communication between the two processes is a file <ref> [2, 4] </ref>. The advantage of this approach is that, in most cases, the communication can 1 be established without knowledge of the source code of the command driven application. <p> If the MS-DOS program returns a large output, the program may hang in an infinite loop unless the source program is altered to return a unique string after returning the output; the string is used to signal completion of the output sent. Reference <ref> [2] </ref> presents an approach that uses a pseudo terminal to integrate a legacy application into a Unix graphical user environment. A pseudo-terminal is a pair of devices, or files; one device behaves as a master and the other as a slave.
Reference: [3] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The command 7 the grader program. This framework combines the Command pattern <ref> [3] </ref> and the Envelope-Letter pattern [1]. and data frameworks were included in the original command driven interface; the graphical framework was added after the command interface was fully implemented. <p> The figure summarizes the classes in each of the frameworks; we detail the first two frameworks in this section and the graphical framework in Section 6. 5.1 The Command Framework The classes in the command framework are summarized in Figure 4; this framework combines the Command pattern <ref> [3] </ref> and the Envelope-Letter pattern [1]. The Command pattern [3] permits a request for service to be encapsulated as an object so that the object requesting the service, in this case GradeSheet, can issue the request without knowledge about the operation being requested. <p> each of the frameworks; we detail the first two frameworks in this section and the graphical framework in Section 6. 5.1 The Command Framework The classes in the command framework are summarized in Figure 4; this framework combines the Command pattern <ref> [3] </ref> and the Envelope-Letter pattern [1]. The Command pattern [3] permits a request for service to be encapsulated as an object so that the object requesting the service, in this case GradeSheet, can issue the request without knowledge about the operation being requested.
Reference: [4] <author> D. Klementief. </author> <title> A windows shell for legacy ms-dos applications. </title> <journal> C/C++ Users Journal, </journal> <pages> pages 71-74, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: a graphical interface into legacy code have focused on using a variation of a pipe to negotiate the communication between two processes where the master process is the graphical interface and the slave process is the command driven application; the vehicle of communication between the two processes is a file <ref> [2, 4] </ref>. The advantage of this approach is that, in most cases, the communication can 1 be established without knowledge of the source code of the command driven application. <p> The disadvantages of the technique are that the I/O in the command driven application must be limited to stdin, stdout and stderr and the linkage can be slow and, for some large applications, the system may stall <ref> [4] </ref>. In this paper, we present a technique that exploits ostreams and subtyping to integrate a graphical interface into a command driven application. <p> next section, and in Section 3.2 we discuss previous approaches to constructing software to manage grades. 3 a sort window. 3.1 Approaches to Incorporating Graphical Interfaces into Legacy Code There have been three important approaches to integrating a graphical interface into legacy applications that have been reported in the literature <ref> [4, 10, 12] </ref>. All three of these approaches use a pipe as the communication interface between the legacy application and the graphical interface; we review two of these approaches in this section. A pipe is a file abstraction that provides a first-in, first-out data stream [10]. <p> A pipe is similar to a fifo queue where a write operation appends data to the end of the pipe and a read operation removes data from the head of the pipe. Implementations of pipes typically use the file system although some recent implementations use sockets. Reference <ref> [4] </ref> presents an approach that uses anonymous pipes to link an MS-DOS program to a Windows program. Anonymous pipes are typically used to direct communication between a parent and child process; however, the technique presented in reference [4] permits the linkage to be accomplished without knowledge of the source code of <p> Reference <ref> [4] </ref> presents an approach that uses anonymous pipes to link an MS-DOS program to a Windows program. Anonymous pipes are typically used to direct communication between a parent and child process; however, the technique presented in reference [4] permits the linkage to be accomplished without knowledge of the source code of the MS-DOS program. <p> After the input pipe linkage has been established, all input to the MS-DOS program will be from the pipe rather than the console or keyboard. An output link is established in analogous fashion. The technique presented in reference <ref> [4] </ref> can be used to create a Windows shell for a legacy MS-DOS program without rewriting the MS-DOS program or even having the source code available for recompilation. The disadvantages of the technique are as follows: 1.
Reference: [5] <author> J. A. Koomen. Grader software. koomen@cs.rochester.edu, </author> <year> 1988. </year>
Reference-contexts: GRADER III can be used to maintain grades, automate test grading and recording and to calculate and submit final grades. GRADER III runs on a mainframe system and does not include a graphical interface. The grader program in reference <ref> [5] </ref> is written in Pascal and incorporates much of the functionality of the the grader program presented in the current work. The Pascal program does not include a graphical interface. Finally, reference [6] presents a grader program constructed using the Java Development Kit.
Reference: [6] <author> L. Li and B. Malloy. </author> <title> A platform independent grader program using the java development kit (jdk). </title> <type> Technical Report 78-CS-023, </type> <institution> Clemson University, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: The grader program in reference [5] is written in Pascal and incorporates much of the functionality of the the grader program presented in the current work. The Pascal program does not include a graphical interface. Finally, reference <ref> [6] </ref> presents a grader program constructed using the Java Development Kit. This program includes a graphical interface and is platform independent.
Reference: [7] <author> J. Rumbaugh, M Blaha, W. Premerlani, F Eddy, and W. Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: An ostream is a mechanism for organizing and maintaining sequences of characters [8]; subtyping entails construction of a derived class that refines the behavior of the parent class <ref> [7] </ref>. The technique that we propose does not create a new process to construct the communication linkage and does not require the use of a sentinel to terminate the linkage. Further, our technique is not limited to communication through stdin, stdout or stderr.
Reference: [8] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: In this paper, we present a technique that exploits ostreams and subtyping to integrate a graphical interface into a command driven application. An ostream is a mechanism for organizing and maintaining sequences of characters <ref> [8] </ref>; subtyping entails construction of a derived class that refines the behavior of the parent class [7]. The technique that we propose does not create a new process to construct the communication linkage and does not require the use of a sentinel to terminate the linkage.
Reference: [9] <institution> Michigan State University. </institution> <note> Grader III user's guide. http://deptwww.msu.edu/dept/soweb/gr3guide.html, 1998. </note>
Reference-contexts: Also, the performance of pseudo-terminals can be sluggish. 3.2 Previous Work in Constructing Grading Programs There are numerous examples of application software for maintaininging grades. The most noteworthy of these is GRADER III at Michigan State University <ref> [9] </ref>. GRADER III is an instructional assessment system that combines grade-keeping, test analysis and student feedback in a single system. GRADER III is intended to be one facet of a carefully planned system whereby the student is required to meet a series of 5 goals and objectives.
Reference: [10] <author> U. Vahalia. </author> <title> UNIX Internals: The New Frontiers. </title> <publisher> Prentice-Hall, </publisher> <year> 1996. </year>
Reference-contexts: next section, and in Section 3.2 we discuss previous approaches to constructing software to manage grades. 3 a sort window. 3.1 Approaches to Incorporating Graphical Interfaces into Legacy Code There have been three important approaches to integrating a graphical interface into legacy applications that have been reported in the literature <ref> [4, 10, 12] </ref>. All three of these approaches use a pipe as the communication interface between the legacy application and the graphical interface; we review two of these approaches in this section. A pipe is a file abstraction that provides a first-in, first-out data stream [10]. <p> All three of these approaches use a pipe as the communication interface between the legacy application and the graphical interface; we review two of these approaches in this section. A pipe is a file abstraction that provides a first-in, first-out data stream <ref> [10] </ref>. A pipe is created by a pipe system call that returns a read or write descriptor. A pipe is similar to a fifo queue where a write operation appends data to the end of the pipe and a read operation removes data from the head of the pipe.
Reference: [11] <author> Bruce Wampler. </author> <title> The v c++ gui framework. </title> <address> http://www.objectcentral.com. </address>
Reference-contexts: The grader program is coded in C++ and exploits the Command pattern and the Envelope-Letter pattern, and uses the standard library containers, algorithms and iterators to implement much of its functionality 1 . The graphical interface that we integrate into grader uses the V C++ GUI toolkit <ref> [11] </ref>, a public domain package that supports most popular graphical objects found in GUI environments and performs on multiple platforms including Linux, Unix and Windows 95. The remainder of this paper is organized as follows. <p> We will not discuss those classes that comprise the V package; the interested reader can find details of these classes in the V Reference Manual <ref> [11] </ref>. Class GraderApp, depicted in Figure 7, is derived from the V class vApp; GraderApp contains function AppMain whose actions create the top level window that represents the graphical interface for the application currently in use.
Reference: [12] <author> D. A. Young. </author> <title> The X Window System Programming and Applications with Xt: </title> <address> OSF/Motif Edition. </address> <publisher> Prentice-Hall, </publisher> <year> 1997. </year> <note> ISBN: 0-13-497074-8. 16 </note>
Reference-contexts: next section, and in Section 3.2 we discuss previous approaches to constructing software to manage grades. 3 a sort window. 3.1 Approaches to Incorporating Graphical Interfaces into Legacy Code There have been three important approaches to integrating a graphical interface into legacy applications that have been reported in the literature <ref> [4, 10, 12] </ref>. All three of these approaches use a pipe as the communication interface between the legacy application and the graphical interface; we review two of these approaches in this section. A pipe is a file abstraction that provides a first-in, first-out data stream [10].
References-found: 12

