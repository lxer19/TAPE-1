URL: http://www.cs.wustl.edu/~schmidt/TAO.ps.gz
Refering-URL: http://www.cs.wustl.edu/~levine/research/cv.html
Root-URL: 
Email: fschmidt,levine,sumedhg@cs.wustl.edu  
Title: The Design of the TAO Real-Time Object Request Broker  
Author: Douglas C. Schmidt, David L. Levine, and Sumedh Mungee 
Note: This article will appear in the Computer Communications Journal, Summer,  
Date: October 11, 1997  1997.  
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science, Washington University  
Abstract: Many real-time application domains can benefit from flexible and open distributed architectures, such as those defined by the CORBA specification. CORBA is an architecture for distributed object computing being standardized by the OMG. Although CORBA is well-suited for conventional request/response applications, CORBA implementations are not yet suited for real-time applications due to the lack of key quality of service (QoS) features and performance optimizations. This paper makes three contributions to the design of real-time CORBA systems. First, the paper describes the design of TAO, which is our high-performance, real-time CORBA 2.0 compliant implementation that runs on a range of OS platforms with real-time features including VxWorks, Chorus, So-laris 2.x, and Windows NT. Second, it presents TAO's real-time scheduling service that can provide QoS guarantees for deterministic real-time CORBA applications. Finally, the paper presents performance measurements that demonstrate the effects of priority inversion and non-determinism in conventional CORBA implementations and how these hazards are avoided in TAO. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.0 ed., </editor> <month> July </month> <year> 1995. </year>
Reference-contexts: In addition to requir fl This work was supported in part by NSF grant NCR-9628218, DARPA contract 9701516, Boeing, Siemens, and US Sprint. ing QoS guarantees, these applications must be flexible and reusable. The Common Object Request Broker Architecture (CORBA) <ref> [1] </ref> is an emerging standard for distributed object computing (DOC) middleware. DOC middleware resides between clients and servers and simplifies application development by providing a uniform view of heterogeneous network and OS layers. <p> In addition, DOC middleware eliminates many tedious, error-prone, and non-portable aspects of developing and maintaining distributed applications by automating common network programming tasks such as object location, object activation, parameter marshaling, fault recovery, and security. At the heart of DOC middleware are Object Request Brokers (ORBs), such as CORBA <ref> [1] </ref>, DCOM [2], and Java RMI [3]. ORBs facilitate the development of flexible and reusable object-oriented distributed services and applications in heterogeneous distributed environments. Advances in DOC technology have occurred at a time when deregulation and global competition are motivating the need for increased software productivity and quality. <p> For servers executing remotely, CORBA 2.0-compliant <ref> [1] </ref> ORB Cores communicate via the General Inter-ORB Protocol (GIOP) and the Internet Inter-ORB Protocol (IIOP), which runs atop the TCP transport protocol. <p> Therefore, ORB endsystems must provide a range of communication protocols that can be customized and optimized for specific application requirements and network/endsystem environments. Section 2.3 outlines TAO's real-time enhancements and optimizations to the CORBA General Inter-ORB Protocol (GIOP) <ref> [1] </ref>, which specifies the request format and transmission protocol that enables interoperability among heterogeneous ORBs. Optimized real-time request demultiplexing and dispatching: ORB endsystems must demultiplex and dispatch incoming client requests to the appropriate operation of a servant. <p> The standard ORB interoperability protocol is known as the General Inter-ORB Protocol (GIOP). GIOP is most commonly implemented with the Internet Inter-ORB Protocol (IIOP) <ref> [1] </ref>, which runs over TCP/IP. An ORB is not limited to running over IIOP and TCP transports, however. For instance, while TCP can transfer GIOP requests reliably, its flow control and congestion control algorithms may preclude its use as a real-time protocol.
Reference: [2] <author> D. </author> <title> Box, Understanding COM. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1997. </year>
Reference-contexts: At the heart of DOC middleware are Object Request Brokers (ORBs), such as CORBA [1], DCOM <ref> [2] </ref>, and Java RMI [3]. ORBs facilitate the development of flexible and reusable object-oriented distributed services and applications in heterogeneous distributed environments. Advances in DOC technology have occurred at a time when deregulation and global competition are motivating the need for increased software productivity and quality.
Reference: [3] <author> A. Wollrath, R. Riggs, and J. Waldo, </author> <title> A Distributed Object Model for the Java System, </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 9, </volume> <month> November/December </month> <year> 1996. </year>
Reference-contexts: At the heart of DOC middleware are Object Request Brokers (ORBs), such as CORBA [1], DCOM [2], and Java RMI <ref> [3] </ref>. ORBs facilitate the development of flexible and reusable object-oriented distributed services and applications in heterogeneous distributed environments. Advances in DOC technology have occurred at a time when deregulation and global competition are motivating the need for increased software productivity and quality.
Reference: [4] <institution> Object Management Group, </institution> <note> Specification of the Portable Object Adapter (POA), OMG Document orbos/97-05-15 ed., </note> <month> June </month> <year> 1997. </year>
Reference-contexts: While current CORBA implementations are typically limited to a single Object Adapter per ORB, recent CORBA portability enhancements <ref> [4] </ref> define the Portable Object Adapter (POA), which can support multiple POAs per ORB. 1.2 Limitations with CORBA for Real-time Ap plications Our experience using CORBA on telecommunication [5], avionics [6], and medical imaging projects [7] indicates that it is well-suited for conventional request/response applications with best-effort QoS requirements.
Reference: [5] <author> D. C. Schmidt, </author> <title> A Family of Design Patterns for Application-level Gateways, </title> <journal> The Theory and Practice of Object Systems (Special Issue on Patterns and Pattern Languages), </journal> <volume> vol. 2, no. 1, </volume> <year> 1996. </year>
Reference-contexts: While current CORBA implementations are typically limited to a single Object Adapter per ORB, recent CORBA portability enhancements [4] define the Portable Object Adapter (POA), which can support multiple POAs per ORB. 1.2 Limitations with CORBA for Real-time Ap plications Our experience using CORBA on telecommunication <ref> [5] </ref>, avionics [6], and medical imaging projects [7] indicates that it is well-suited for conventional request/response applications with best-effort QoS requirements.
Reference: [6] <author> T. H. Harrison, D. L. Levine, and D. C. Schmidt, </author> <title> The Design and Performance of a Real-time CORBA Event Service, </title> <booktitle> in Proceedings of OOPSLA '97, </booktitle> <address> (Atlanta, GA), </address> <publisher> ACM, </publisher> <month> October </month> <year> 1997. </year>
Reference-contexts: While current CORBA implementations are typically limited to a single Object Adapter per ORB, recent CORBA portability enhancements [4] define the Portable Object Adapter (POA), which can support multiple POAs per ORB. 1.2 Limitations with CORBA for Real-time Ap plications Our experience using CORBA on telecommunication [5], avionics <ref> [6] </ref>, and medical imaging projects [7] indicates that it is well-suited for conventional request/response applications with best-effort QoS requirements. <p> For instance, video conferencing groupware [24] may require high throughput with statistical real-time latency deadlines. In contrast, an operational flight control platform for avionics <ref> [6] </ref> may require rate-based periodic processing with strict real-time deadlines. QoS specification is not addressed by the current CORBA specification, though there is an OMG special interest group (SIG) devoted to this topic. <p> TAO's Object Adapter can be configured to implement custom mechanisms that dispatch client requests according to application-specific real-time scheduling policies. To provide a guaranteed share of the CPU among application operations <ref> [23, 6] </ref>, TAO's Object Adapter uses the real-time Scheduling Service described in Section 3. One of the strategies provided by TAO's Object Adapter is variant of periodic rate monotonic scheduling implemented with real-time threads and real-time upcalls (RTUs). <p> In addition, the Service Con-figurator pattern [36] allows new algorithms to be configured in dynamically, (i.e. at runtime). On platforms with C++ compilers that optimize virtual function calls, the overhead of this flexibility is negligible <ref> [6] </ref>. 2.4.2 Demultiplexing Optimizations A standard GIOP-compliant client request contains the identity of its remote object and remote operation. The standard remote object is represented by an object ID (which is an octet sequence) and the remote operation is represented as a string. <p> A second perfect hashing function is then used to locate the operation. In the worst-case, servant and operation lookups require constant time. Perfect hashing is applicable when the keys to be hashed are known a priori. In many deterministic real-time systems (such as avionic mission control systems <ref> [6] </ref>), the servants and operations can be configured statically and it is possible to use perfect hashing to locate servants and operations. <p> This section provides in-depth coverage of the key features and steps required to implement real-time scheduling in CORBA. TAO is designed to support real-time applications with both deterministic and statistical QoS requirements. Deterministic real-time applications, such as avionics mission control systems <ref> [6] </ref>, must meet periodic deadlines. Statistical real-time applications, such as teleconferencing and video-on-demand, can tolerate minor fluctuations in scheduling and reliability guarantees, but nonetheless require QoS guarantees. Deterministic real-time systems are more amenable to conventional scheduling analysis techniques. Therefore, they are the focus of the work presented in this section. <p> This division of the Scheduling Service interface into application and privileged sections is shown in Figure 13. The privileged interface is only used by common services. For example, the Event Channel in TAO's Real-time Event Service <ref> [6] </ref> registers operations with the Off-line Scheduling Service; by application-level schedulable operations that do not use the Event Channel; and by TAO's real-time Object Adapter, which accesses these interfaces to determine client request dispatch priorities. <p> is a significant problem in these ORBs, and thus they are unsuitable for applications with deterministic real-time requirements. 4.1.3 Results for TAO's Real-time Event Channel To illustrate how TAO addresses the priority inversion problems discussed above, we performed an experiment similar to the above with the TAO Real-time Event Channel <ref> [6] </ref>. 22 As discussed in Section 3, the Event Channel currently implements several key features of TAO's Real-time Object Adapter (ROA), such as real-time dispatching of requests (events), and real-time scheduling of clients/servants (suppliers/consumers).
Reference: [7] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging, </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 9, </volume> <month> November/December </month> <year> 1996. </year>
Reference-contexts: implementations are typically limited to a single Object Adapter per ORB, recent CORBA portability enhancements [4] define the Portable Object Adapter (POA), which can support multiple POAs per ORB. 1.2 Limitations with CORBA for Real-time Ap plications Our experience using CORBA on telecommunication [5], avionics [6], and medical imaging projects <ref> [7] </ref> indicates that it is well-suited for conventional request/response applications with best-effort QoS requirements. However, CORBA is not yet suited for performance-sensitive, real-time applications for the following reasons: * Lack of QoS specification interfaces: The CORBA 2.0 standard does not provide interfaces to specify end-to-end QoS requirements. <p> As a result, it is hard to develop portable and efficient real-time applications that behave deterministically when ORB endsystem and network resources are temporarily unavailable. * Lack of performance optimizations: Existing ORBs incur significant throughput <ref> [7] </ref> and latency [11] overhead.
Reference: [8] <author> R. Rajkumar, L. Sha, and J. P. Lehoczky, </author> <title> Real-Time Synchronization Protocols for Multiprocessors, </title> <booktitle> in Proceedings of the Real-Time Systems Symposium, </booktitle> <address> (Huntsville, Alabama), </address> <month> Decem-ber </month> <year> 1988. </year>
Reference-contexts: For instance, most ORBs use a FIFO strategy for scheduling and dispatching client requests. However, FIFO strategies can yield unbounded priority inversions <ref> [8, 9] </ref>, which occur when a lower priority request blocks the execution of a higher priority request for an indefinite period. In addition, ORBs do not control servant execution, e.g., they do not terminate servants that consume excess resources. Thus, existing ORBs typically depend on ad hoc resource allocation. <p> For instance, research on QoS for ATM networks has focused largely on policies for allocating bandwidth on a per-connection basis [20]. Likewise, research on real-time operating systems has focused largely on avoiding priority inversions and non-determinism in synchronization and scheduling mechanisms for multi-threaded applications <ref> [8] </ref>. Determining how to map the insights and mechanisms produced by QoS work at the network and OS layers onto an OO programming model is a key challenge when adding QoS support to ORB middleware [42, 10]. This subsection describes the real-time OO programming model used by TAO.
Reference: [9] <author> S. Khanna and et. al., </author> <title> Realtime Scheduling in SunOS 5.0, </title> <booktitle> in Proceedings of the USENIX Winter Conference, </booktitle> <pages> pp. 375390, </pages> <publisher> USENIX Association, </publisher> <year> 1992. </year>
Reference-contexts: For instance, most ORBs use a FIFO strategy for scheduling and dispatching client requests. However, FIFO strategies can yield unbounded priority inversions <ref> [8, 9] </ref>, which occur when a lower priority request blocks the execution of a higher priority request for an indefinite period. In addition, ORBs do not control servant execution, e.g., they do not terminate servants that consume excess resources. Thus, existing ORBs typically depend on ad hoc resource allocation. <p> Real-time I/O Subsystem: Some operating systems (such as Solaris and Windows NT) now support real-time scheduling. For example, Solaris 2.x provides a real-time scheduling class <ref> [9] </ref> that attempts to bound the time required to dispatch threads in this thread class. However, general-purpose operating systems do not provide real-time I/O subsystems. <p> Then, the higher priority, runnable thread can be dispatched onto the available CPU. Our analysis, based on rate monotonic analysis, assumes fixed priority, i.e., the operating system does not unilaterally change the priority of a thread. TAO currently runs on a variety of operating systems (e.g., VxWorks, Solaris 2.x <ref> [9] </ref>, and Windows NT) that provide fixed priority real-time scheduling. Thus, from the point of view of an Object Adapter, the priority of each thread is constant. <p> It is hard to eliminate priority inversion completely; if it cannot be avoided, bounded priority inversion is desirable. This means that the amount of time a higher priority task is waiting due to a lower priority task must have a tight upper bound. <ref> [9] </ref> describes one approach to control priority inversion, using priority inheritance. Priority inheritance temporarily increases the priority of a lower priority task when the system detects that a higher priority task cannot proceed due to dependencies on a lower priority task.
Reference: [10] <author> V. Fay-Wolfe, J. K. Black, B. Thuraisingham, and P. Krupp, </author> <title> Real-time Method Invocations in Distributed Environments, </title> <type> Tech. Rep. 95-244, </type> <institution> University of Rhode Island, Department of Computer Science and Statistics, </institution> <year> 1995. </year>
Reference-contexts: For instance, although the CORBA general inter-operability protocol (GIOP) supports asynchronous messaging, no standard programming language mapping yet exists for transmitting client requests asynchronously. Likewise, the CORBA 2.0 specification does not require an ORB to notify clients when transport layer flow control occurs, nor does it support timed operations <ref> [10] </ref>. As a result, it is hard to develop portable and efficient real-time applications that behave deterministically when ORB endsystem and network resources are temporarily unavailable. * Lack of performance optimizations: Existing ORBs incur significant throughput [7] and latency [11] overhead. <p> The distributed scheduling problem is not addressed in this article; it is a topic for future research. 3.2 Specifying QoS Requirements in TAO using Real-time IDL Schemas Invoking operations on objects is the primary collaboration mechanism between components in an object-oriented system <ref> [10] </ref>. However, QoS research at the network and OS layers has not addressed key requirements and usage characteristics of OO middleware. For instance, research on QoS for ATM networks has focused largely on policies for allocating bandwidth on a per-connection basis [20]. <p> Determining how to map the insights and mechanisms produced by QoS work at the network and OS layers onto an OO programming model is a key challenge when adding QoS support to ORB middleware <ref> [42, 10] </ref>. This subsection describes the real-time OO programming model used by TAO. <p> Wolfe, et al, are developing a real-time CORBA system at the US Navy Research and Development Laboratories (NRaD) and the University of Rhode Island (URI) [52]. The system supports expression and enforcement of dynamic end-to-end timing constraints through timed distributed operation invocations (TDMIs) <ref> [10] </ref>. A TDMI corresponds to TAO's RT Operation; an RT Environment structure contains QoS parameters similar to those in TAO's RT Info.
Reference: [11] <author> A. Gokhale and D. C. Schmidt, </author> <title> Evaluating Latency and Scalability of CORBA Over High-Speed ATM Networks, </title> <booktitle> in Proceedings of the International Conference on Distributed Computing Systems, </booktitle> <address> (Baltimore, Maryland), </address> <publisher> IEEE, </publisher> <month> May </month> <year> 1997. </year>
Reference-contexts: As a result, it is hard to develop portable and efficient real-time applications that behave deterministically when ORB endsystem and network resources are temporarily unavailable. * Lack of performance optimizations: Existing ORBs incur significant throughput [7] and latency <ref> [11] </ref> overhead.
Reference: [12] <author> E. Eide, K. Frei, B. Ford, J. Lepreau, and G. Lindstrom, </author> <month> Flick: </month>
Reference-contexts: These overheads stem from non-optimized presentation layer conversions and monolithic presentation code that copies data excessively <ref> [12] </ref> and overflows processor caches [13]; internal message buffering strategies that produce non-uniform behavior for different message sizes [14]; inefficient demultiplexing and dispatching algorithms [15]; long chains of intra-ORB virtual method calls [16]; and lack of integration with underlying real-time OS and network QoS mechanisms [17]. <p> In contrast, interpreted marshaling code is slower, but more compact. Section 2.5 outlines how TAO supports worst-case guarantees for both interpreted and compiled marshaling operations via a highly optimized GIOP protocol engine that contains a number of innovative compiler techniques <ref> [12] </ref> and optimization principles [13]. Optimized memory management: On modern RISC hardware, data copying consumes a significant amount of CPU, memory, and I/O bus resources. Likewise, dynamic memory management incurs a significant performance penalty due to heap fragmentation and locking overhead. <p> In TAO, presentation layer processing is performed by client-side stubs and server-side skeletons that are generated automatically by Flick <ref> [12] </ref>, which is a highly-optimizing IDL compiler.
References-found: 12

