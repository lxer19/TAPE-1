URL: http://www.cs.toronto.edu/~vassos/research/publications/CH97/paper.ps.gz
Refering-URL: http://www.cs.toronto.edu/~vassos/research/list-of-publications.html
Root-URL: 
Email: vinay@ai.sri.com  vassos@db.toronto.edu  
Title: Safe Locking Policies for Dynamic Databases  
Author: Vinay K. Chaudhri Vassos Hadzilacos 
Keyword: Concurrency Control, Correctness Issues  
Date: January 13, 1998  
Address: 333 Ravenswood Avenue Menlo Park, CA 94025 USA  Toronto, ON M5S 1A4 Canada  
Affiliation: SRI International  Department of Computer Science University of Toronto  
Abstract: Yannakakis showed that a locking policy is not safe if and only if it allows a canonical nonserializable schedule of transactions in which all transactions except one are executed serially [Yan82]. In the present paper, we study the generalization of this result to a dynamic database, that is, a database that may undergo insertions and deletions of entities. We illustrate the utility of this generalization by applying it to obtain correctness proofs of three locking policies that handle dynamic databases. fl This is an revised version of a paper with the same title that was published in the Proceedings of the Fourteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems May 22-25, 1995. The work presented in the paper was done while the first author was at University of Toronto, where it was supported by the University of Toronto, the Information Technology Research Center of Ontario, the Natural Science and Engineering Research Council of Canada and the Institute of Robotics and Intelligent Systems. 
Abstract-found: 1
Intro-found: 1
Reference: [AA90] <author> D. Agrawal and A. El Abbadi. </author> <title> Locks with Constrained Sharing. </title> <booktitle> In 9TH ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 85-93, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: We used the generalized canonical schedules to prove the correctness of three locking policies: DDAG policy, dynamic tree policy and altruistic locking policy. This work can be extended in several directions. The same technique could be used to analyze other locking policies <ref> [AA90, dFRH94] </ref>. Furthermore, the generalization of these results to a dynamic hypergraph policy [Yan82] and incorporating recovery considerations in it [SWY93] remain problems for future research. Acknowledgements We thank the anonymous referees for their suggestions.
Reference: [BHG87] <author> Philip A. Bernstein, Vassos Hadzilacos, and Nathan Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Welssley Publishing Company, </publisher> <year> 1987. </year> <month> 29 </month>
Reference-contexts: In the dynamic settling, the notion of structural state is needed to 1 The notion of serializability that we use here is known as conflict serializability. Other related notions have also been defined and a discussion of different notions of serializability can be found elsewhere <ref> [Pap86, BHG87] </ref>. 6 formalize the sensible interleavings of transactions in terms of proper schedules. 3 Theorem on Canonical Schedules In this section we state and prove the theorem on canonical nonserializable schedules.
Reference: [Cha95] <author> Vinay K Chaudhri. </author> <title> Transaction Synchronization in Knowledge Bases: Concepts, Realiza--tion and Quantitative Evaluation. </title> <type> PhD thesis, </type> <institution> University of Toronto, Toronto, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: We assume that an ACCESS operation represents a READ immediately followed by a WRITE. A more general version of the policy that works for both shared and exclusive locks and for general graphs may be found elsewhere <ref> [Cha95] </ref>. We first define some properties of directed graphs that are necessary for specifying our algorithm. A root of a directed graph is a node with no predecessors. <p> We assume that the transactions ensure that these properties are always maintained. We also assume that once an object has been deleted from the database, it may not be inserted into it again. More discussion on this assumption can be found elsewhere <ref> [Cha95] </ref>. Locking Rules for a Transaction T L1. Before a transaction T performs any INSERT, DELETE or ACCESS operation on a node A (an edge (A; B)), T locks A (both A and B). L2. A node that is being inserted can be locked at any time. L3. <p> We found that Theorem 1 not only has general applicability but it leads to simpler proofs. The results presented in this paper are based on the first author's doctoral dissertation <ref> [Cha95] </ref> and contribute towards a larger goal: to design concurrency control techniques for highly structured databases (or knowledge bases). The results on the performance evaluation of the DDAG policy have been published elsewhere [CHMS94]. Details of implementation considerations can be found in the dissertation itself [Cha95]. <p> the first author's doctoral dissertation <ref> [Cha95] </ref> and contribute towards a larger goal: to design concurrency control techniques for highly structured databases (or knowledge bases). The results on the performance evaluation of the DDAG policy have been published elsewhere [CHMS94]. Details of implementation considerations can be found in the dissertation itself [Cha95]. In summary, in this paper, we generalized Yannakakis' canonical nonserializable schedules theorem to dynamic databases. We showed that the shape of the serializability graph of a canonical nonserializable schedule in dynamic databases is more complex than in static databases.
Reference: [CHMS94] <author> Vinay K Chaudhri, Vassos Hadzilacos, John Mylopoulos, and Ken Sevcik. </author> <title> Quantitative Evaluation of a Transaction Facility for a Knowledge Base Management System. </title> <booktitle> In Proceedings of the Third International Conference on Knowledge Management, </booktitle> <pages> pages 122-131, </pages> <address> Gaithersberg, MD, </address> <year> 1994. </year>
Reference-contexts: The results presented in this paper are based on the first author's doctoral dissertation [Cha95] and contribute towards a larger goal: to design concurrency control techniques for highly structured databases (or knowledge bases). The results on the performance evaluation of the DDAG policy have been published elsewhere <ref> [CHMS94] </ref>. Details of implementation considerations can be found in the dissertation itself [Cha95]. In summary, in this paper, we generalized Yannakakis' canonical nonserializable schedules theorem to dynamic databases.
Reference: [CM86] <author> Albert Croker and David Maier. </author> <title> A Dynamic Tree-Locking Protocol. </title> <booktitle> In Proceedings of the International Conference in Data Engineering, </booktitle> <pages> pages 49-56, </pages> <address> Los Angeles, CA, </address> <year> 1986. </year>
Reference-contexts: the correctness of three locking policies (1) the Dynamic Directed Acyclic Graph (DDAG) policy which is an extension of the tree policy [SK80, KS83] and was designed for use in knowledge based applications, (2) Altruistic Locking [SGMS94] that was designed to deal with long-lived transactions, and (3) Dynamic Tree Policy <ref> [CM86] </ref> that allows transactions to dynamically define the structure (partial order on the entities) of a database. It is interesting to note that these locking policies were developed in quite different contexts. The rest of this paper is organized as follows. <p> Hence the assumed canonical nonserializable schedule does not exist and the altruistic locking policy is safe. 2 6 Dynamic Tree Policy The Dynamic Tree (DTR) Policy was proposed to allow a changing set of partial orders to be defined over the objects in a database <ref> [CM86] </ref>. Thus, instead of assuming that we are given a directed graph corresponding to the database, the DTR policy defines a forest for itself depending, in part, on the entities that a transaction wishes to access. We call the forest defined by the DTR policy a database forest.
Reference: [dFRH94] <author> Fernando de Ferreira Rezende and Theo Harder. </author> <title> A Lock Method for KBMSs Using Abstraction Relationships' Semantics. </title> <booktitle> In Proceedings of the Third International Conference on Knowledge Management, </booktitle> <pages> pages 112-121, </pages> <year> 1994. </year>
Reference-contexts: We used the generalized canonical schedules to prove the correctness of three locking policies: DDAG policy, dynamic tree policy and altruistic locking policy. This work can be extended in several directions. The same technique could be used to analyze other locking policies <ref> [AA90, dFRH94] </ref>. Furthermore, the generalization of these results to a dynamic hypergraph policy [Yan82] and incorporating recovery considerations in it [SWY93] remain problems for future research. Acknowledgements We thank the anonymous referees for their suggestions.
Reference: [EGLT76] <author> K. Eswaran, J. Gray, R. Lorie, and I. Traiger. </author> <title> The Notions of Consistency and Predicate Locks in Database Systems. </title> <journal> Communications of the ACM, </journal> <volume> 19(9) </volume> <pages> 624-633, </pages> <year> 1976. </year>
Reference-contexts: It is well known that S is serializable if and only if D (S) is acyclic <ref> [EGLT76] </ref>. A transaction system t is safe if any legal and proper schedule of t is serializable. A locking policy P is a relation between transactions and locked transactions such that P (T; T ) holds only if transaction T is a subsequence of a well-formed locked transaction T .
Reference: [KS83] <author> Z. M. Kedem and A. Silberschatz. </author> <title> Locking Protocols: From Exclusive to Shared Locks. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 30(4) </volume> <pages> 787-804, </pages> <year> 1983. </year>
Reference-contexts: Specifically, in this paper, we use this technique to prove the correctness of three locking policies (1) the Dynamic Directed Acyclic Graph (DDAG) policy which is an extension of the tree policy <ref> [SK80, KS83] </ref> and was designed for use in knowledge based applications, (2) Altruistic Locking [SGMS94] that was designed to deal with long-lived transactions, and (3) Dynamic Tree Policy [CM86] that allows transactions to dynamically define the structure (partial order on the entities) of a database.
Reference: [Pap86] <author> Christos Papadimitriou. </author> <title> The Theory of Database Concurrency Control. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1986. </year>
Reference-contexts: In the dynamic settling, the notion of structural state is needed to 1 The notion of serializability that we use here is known as conflict serializability. Other related notions have also been defined and a discussion of different notions of serializability can be found elsewhere <ref> [Pap86, BHG87] </ref>. 6 formalize the sensible interleavings of transactions in terms of proper schedules. 3 Theorem on Canonical Schedules In this section we state and prove the theorem on canonical nonserializable schedules.
Reference: [SGMS94] <author> Kenneth Salem, Hector Garcia-Molina, and Jeannie Shands. </author> <title> Altruistic Locking. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(1) </volume> <pages> 117-164, </pages> <year> 1994. </year>
Reference-contexts: Specifically, in this paper, we use this technique to prove the correctness of three locking policies (1) the Dynamic Directed Acyclic Graph (DDAG) policy which is an extension of the tree policy [SK80, KS83] and was designed for use in knowledge based applications, (2) Altruistic Locking <ref> [SGMS94] </ref> that was designed to deal with long-lived transactions, and (3) Dynamic Tree Policy [CM86] that allows transactions to dynamically define the structure (partial order on the entities) of a database. It is interesting to note that these locking policies were developed in quite different contexts. <p> This contradicts the fact that (T 0 0 0 (by the choice of T i ). Therefore, B m is a descendant of A fl in G m , completing the induction step. 2 5 Altruistic Locking Altruistic locking was developed to deal with long-lived transactions <ref> [SGMS94] </ref>. We first define the rules of the altruistic locking policy for a database that undergoes insertions and deletions of entities [SGMS94]. We consider the basic version of altruistic locking in which all locks are exclusive. <p> B m is a descendant of A fl in G m , completing the induction step. 2 5 Altruistic Locking Altruistic locking was developed to deal with long-lived transactions <ref> [SGMS94] </ref>. We first define the rules of the altruistic locking policy for a database that undergoes insertions and deletions of entities [SGMS94]. We consider the basic version of altruistic locking in which all locks are exclusive. As in the previous section we assume that an ACCESS operation represents a READ immediately followed by a WRITE. The instant when a transaction acquires its last lock is known as its locked point. <p> The disadvantage is that rule AL2 can be too restrictive, because to take advantage of the pre-release of locks a transaction has to be completely in the wake of another transaction. This may be relaxed, but only at the cost of several additional assumptions <ref> [SGMS94] </ref>. We now prove the correctness of altruistic locking using Theorem 1. Theorem 3 The altruistic locking policy is safe. Proof. Suppose, for contradiction, that the altruistic locking policy is not safe.
Reference: [SK80] <author> A. Silberschatz and Z. M. Kedem. </author> <title> Consistency in Hierarchical Database Systems. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 27(1) </volume> <pages> 72-80, </pages> <year> 1980. </year>
Reference-contexts: Specifically, in this paper, we use this technique to prove the correctness of three locking policies (1) the Dynamic Directed Acyclic Graph (DDAG) policy which is an extension of the tree policy <ref> [SK80, KS83] </ref> and was designed for use in knowledge based applications, (2) Altruistic Locking [SGMS94] that was designed to deal with long-lived transactions, and (3) Dynamic Tree Policy [CM86] that allows transactions to dynamically define the structure (partial order on the entities) of a database. <p> For example, in a system storing information about complex objects, the part-subpart relationship is a directed graph in which each node represents an object and an edge represents a part-of relationship between two objects. To take advantage of the graph-like structure of such systems, we extended the DAG policy <ref> [SK80, Yan82] </ref> to the Dynamic Directed Acyclic Graph (DDAG) policy which can deal with general Dynamic Acyclic Graphs. In the present paper, we consider the case when only exclusive locks are used. We assume that an ACCESS operation represents a READ immediately followed by a WRITE.
Reference: [SWY93] <author> H.-J. Schek, G. Weikum, and H. Ye. </author> <title> Towards a Unified Theory of Concurrency Control and Recovery. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 300-311, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: This work can be extended in several directions. The same technique could be used to analyze other locking policies [AA90, dFRH94]. Furthermore, the generalization of these results to a dynamic hypergraph policy [Yan82] and incorporating recovery considerations in it <ref> [SWY93] </ref> remain problems for future research. Acknowledgements We thank the anonymous referees for their suggestions.
Reference: [Yan82] <author> Mihalis Yannakakis. </author> <title> A Theory of Safe Locking Policies in Database Systems. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 29(3) </volume> <pages> 718-740, </pages> <month> July </month> <year> 1982. </year> <month> 30 </month>
Reference-contexts: Yannakakis showed that a locking policy is not safe if and only if there exists a canonical nonserializable schedule in which all transactions except one are executed serially <ref> [Yan82] </ref>. This characterization is useful in proving the correctness of a wide range of locking policies: it restricts the schedules that a policy must avoid to a small and highly structured set. <p> We assume that a transaction locks an entity at most once, because a locking policy that allows a transaction to lock an entity twice is trivially unsafe <ref> [Yan82] </ref>. A partial schedule of a set of locked transactions fT 1 ,: : :,T m g is a prefix of any schedule of these transactions. The main difference between the model described above and that used by Yannakakis [Yan82] is the distinction between the structural and value states of the <p> allows a transaction to lock an entity twice is trivially unsafe <ref> [Yan82] </ref>. A partial schedule of a set of locked transactions fT 1 ,: : :,T m g is a prefix of any schedule of these transactions. The main difference between the model described above and that used by Yannakakis [Yan82] is the distinction between the structural and value states of the database. In the case of a static database, this distinction is not necessary, because the database is always in the same structural state. <p> Due to the serial nature of this schedule, it is much easier to reason with it as compared to an arbitrary schedule. The key difference between the above theorem and its analogue for static databases <ref> [Yan82] </ref> derives from the fact that the properness of schedules does not now come for "free": Special precautions must be taken to ensure that the canonical nonserializable schedule is, indeed, proper. This difference influences the theorem in two ways. <p> For example, in a system storing information about complex objects, the part-subpart relationship is a directed graph in which each node represents an object and an edge represents a part-of relationship between two objects. To take advantage of the graph-like structure of such systems, we extended the DAG policy <ref> [SK80, Yan82] </ref> to the Dynamic Directed Acyclic Graph (DDAG) policy which can deal with general Dynamic Acyclic Graphs. In the present paper, we consider the case when only exclusive locks are used. We assume that an ACCESS operation represents a READ immediately followed by a WRITE. <p> This work can be extended in several directions. The same technique could be used to analyze other locking policies [AA90, dFRH94]. Furthermore, the generalization of these results to a dynamic hypergraph policy <ref> [Yan82] </ref> and incorporating recovery considerations in it [SWY93] remain problems for future research. Acknowledgements We thank the anonymous referees for their suggestions.
References-found: 13

