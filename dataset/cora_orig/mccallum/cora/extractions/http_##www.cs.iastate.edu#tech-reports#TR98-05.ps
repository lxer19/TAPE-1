URL: http://www.cs.iastate.edu/tech-reports/TR98-05.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Design and Implementation of the Larch/C++ Type System  
Author: Matthew W. Markland 
Keyword: Specification languages; Larch; LSL; Larch/C++; type systems.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: TR #98-05 June 1998  
Abstract: 1997 CR Categories: D.1.5 [Programming Techniques] Object-oriented Programming; D.2.1 [Software Engineering] Requirements/Specifications | languages, Larch, tools; D.3.3 [Programming Languages] Language Constructs and Features | modules, packages; F.3.1 [Logics and Meanings of Programs] Specifying and Verifying and Reasoning about Programs | assertions, pre- and post-conditions, specification techniques, LSL; F.3.3 [Logics and Meanings of Programs] Studies of Program Constructs | type structure. c fl Copyright 1998 by Matthew W. Markland. All rights reserved.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Kurt Bischoff. </author> <title> Ox: Users Reference Manual. </title> <address> IA, </address> <year> 1993. </year>
Reference-contexts: The majority of the Larch/C++ Checker's implementation lies within the lexer, the parser, and the support code. The lexer and parser are built using an attribute grammar system called Ox <ref> [1] </ref>. The Checker does not take full advantage of Ox, but the syntax for the creation and access of attributes for rules in Ox can be clearer than the equivalent expressions in yacc.
Reference: [2] <author> Hans J Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> Sept </month> <year> 1988. </year>
Reference-contexts: This includes implementations of dynamic strings, debugging code, interfaces to the environment, and other functions. These classes and functions are used throughout the whole of the system. Finally, not mentioned in the above list but still very important to the Larch/C++ Checker is the Boehm-Demers-Weiser Conservative Garbage Collector <ref> [2] </ref>. All reclamation of allocated storage is handled by the garbage collector. This is important because the code makes heavy use of pointers and dynamic allocation of objects. 5.2 Support for C++ namespace The Draft C++ Standard [3] contains definitions for many new language constructs. One of these is namespace.
Reference: [3] <institution> Working Paper for Draft Proposed International Standard for Information Systems Programming Language C++, </institution> <month> April </month> <year> 1995. </year> <month> 86 </month>
Reference-contexts: Support for Larch Shared Language Constructs fl Modification of the LSL Checker to follow Unix conventions and use less memory. fl Development of an interface between the existing Larch/C++ Checker and the LSL Checker. Support for the Evolving C++ Language Standard fl Support for Draft ANSI Standard C++ <ref> [3] </ref> language con structs. fl Support for translation of C++ declarations into Larch/C++ sorts. The paper begins with a background section that introducing formal methods, specification, and the Larch/C++ behavioral interface specification language. Following the general introduction, the type systems of the Larch Shared Language and C++ are described briefly. <p> All reclamation of allocated storage is handled by the garbage collector. This is important because the code makes heavy use of pointers and dynamic allocation of objects. 5.2 Support for C++ namespace The Draft C++ Standard <ref> [3] </ref> contains definitions for many new language constructs. One of these is namespace. The namespace construct was added to C++ to allow for an additional level of scoping for names. Before names-paces, the possibility existed for vendors to supply libraries of code that would have name conflicts.
Reference: [4] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1990. </year>
Reference-contexts: Although not a complete description, it should serve as an introduction for people unfamiliar with it. The section is based upon the C++ Annotated Reference Manual 16 <ref> [4] </ref> which should be referred to for a complete description of the C++ type system. The C++ type system is based upon the C type system with a few additions. There are two broad categories of types, fundamental types and derived types.
Reference: [5] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> MA, </address> <year> 1995. </year>
Reference-contexts: Another area for future work is an examination of the structure of the Larch/C++ source code. Perhaps the application of design patterns could create a clearer, less cluttered design. One place where this could be applied is in the creation of an class based on the iterator pattern <ref> [5] </ref> to handle the iteration of the sets of arrow sorts. Another place in the code that could stand a redesign is the TmpFile classes. The current system could be improved by rewriting the base TmpFile class so that it inherits from the class fstream.
Reference: [6] <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: Larch/C++ adds syntax to C++ to allow the specification of complex C++ structures, the inheritance of specifications, and the clear specification of the interface to a class. Larch/C++ is a two-tiered specification language. Specifications consist of Larch Shared Language (LSL) <ref> [6] </ref> traits which describe the abstract models, and interface specifications which formalize the behavioral contracts. 3 This two-tiered approach allows for the clear separation of the definition of the abstract model and its vocabulary from the actual details of the programming language modeled by the interface language. <p> If the abstract models were written in a language closer to the actual implementation, it would be more difficult to reuse the same model in a specification for an implementation written in a different language. 2.2.1 The Larch Shared Language The Larch Shared Language <ref> [6] </ref> allows an user to supply basic semantic information, and a specialized vocabulary for describing abstract values. The basic unit of LSL is the trait. Traits contain information on sorts, which are like types in a programming language, and operators which define various operations upon these sorts. <p> Since the Larch/C++ language depends upon LSL to supply abstractions, it was important to learn how the LSL type system works. Unfortunately, little has been written on the LSL type system. Neither the technical report on LSL [7] nor the Larch book <ref> [6] </ref> offered any details. What was available was the LSL Checker [11]. The LSL Checker is a tool that will perform semantic and syntactic checks on LSL traits. Since the LSL Checker provides type checking of traits, it serves as an operational definition of the LSL type system.
Reference: [7] <author> John V. Guttag, James J. Horning, and Andres Modet. </author> <title> Report on the Larch Shared Language: Version 2.3. </title> <type> Technical Report 58, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> April </month> <year> 1990. </year> <title> Order from src-report@src.dec.com. </title>
Reference-contexts: Since the Larch/C++ language depends upon LSL to supply abstractions, it was important to learn how the LSL type system works. Unfortunately, little has been written on the LSL type system. Neither the technical report on LSL <ref> [7] </ref> nor the Larch book [6] offered any details. What was available was the LSL Checker [11]. The LSL Checker is a tool that will perform semantic and syntactic checks on LSL traits. <p> This led to the development of a flex-based lexer for this input. Starting from the token definitions in LCLint's signature file and the information in the LSL technical report <ref> [7] </ref>, a set of regular expressions was developed to represent the tokens. The major difficulty here was that some characters had multiple meanings depending upon context.
Reference: [8] <author> Gary T. Leavens. </author> <note> Larch/C++ Reference Manual. Version 5.6. ftp://ftp.cs.iastate.edu/pub/larchc++/lcpp.ps.gz or http://www.cs.iastate.edu/~leavens/larchc++.html, June 1997. </note>
Reference-contexts: 1 Introduction The goal of Larch/C++ <ref> [8] </ref> is to give the programmer a formal specification language that is expressive and useful in practice. The work described in this paper focuses on the addition of type checking capabilities to the Larch/C++ Checker. <p> After a user has described the behavior in terms of the interfaces, solutions to the problem may then be designed based upon the formal contract defined by the model. 2.2 Introduction to Larch/C++ Larch/C++ <ref> [8] </ref> is a model-based, formal specification language tailored for the specification of the behavior of C++ program modules or application program interfaces (API's). <p> The basic unit of LSL is the trait. Traits contain information on sorts, which are like types in a programming language, and operators which define various operations upon these sorts. Figure 1 illustrates the LSL portion of a specification for a simple counter <ref> [8] </ref>. This particular trait illustrates four common parts that are in many traits. The includes statement allows for a trait to build upon and reuse previously written traits. All of the information from the traits listed in this statement are available in the following sections of the current trait. <p> These values are independent of any implementation of Counter. 2.2.2 The Larch/C++ Specification Language the counter modeled by the previous trait <ref> [8] </ref>. <p> Since there is no equivalent to parametric polymorphism in LSL, the uses clause, when combined with renaming, is used to "instantiate" a trait with the correct sort. An example of this is the SimpleSet specification from the Larch/C++ Manual, Section 8.2 <ref> [8] </ref>. Figure 10 is an example of this for a simple set class implemented via templates. There is one template argument, a class Elem, which will be the elements of the set. The specifier needs to create an abstract model that can be used with this trait. <p> We use the name sort here because the system is closely related to the LSL system. The rules presented in this section are based upon the concrete syntax for Function Specifications in Larch/C++, contained in Appendix A of the Larch/C++ Reference Manual <ref> [8] </ref>. Some of the concrete rules have had their names abbreviated in the formal rules to allow for easier presentation. An abstract syntax grammar has also been created to allow for easier presentation of the rules themselves. <p> To do this, Larch/C++ has a formal model that describes the relationship between objects and their values. This is described in Section 2.8 of the Reference Manual <ref> [8] </ref>. Most of the time, a C++ declaration will create an object containing an abstract value. The state of the variable "associates to each object, an abstract value." [8, page 21]. State functions allow a specifier to extract the abstract value for a variable for a specific state. <p> This is described in Section 2.8 of the Reference Manual [8]. Most of the time, a C++ declaration will create an object containing an abstract value. The state of the variable "associates to each object, an abstract value." <ref> [8, page 21] </ref>. State functions allow a specifier to extract the abstract value for a variable for a specific state. For example, the C++ declaration int i; creates an object with the following sort. <p> For example, the C++ declaration int i; creates an object with the following sort. Obj [int] A state function, when applied to i, returns the value for the state, which has sort int. Please refer to the Reference Manual <ref> [8, Section 6.2.1] </ref> for more details. strip and selobjs, defined below, allow for the extraction of abstract values. strip (ConstObj [T]) = T strip (Obj [T]) = T strip (fS 1 ; : : : ; S n g) = fstrip (S 1 ); : : : ; strip (S n <p> fBoolg If E 0 is as described in the text. [EQ] E ` OP lsl 1 EQ OP lsl 2 : fBoolg if jff " fij = 1 4.2.7 Miscellaneous Rules In Larch/C++ higher-order functions are functions which either take pointers to functions as arguments, or return pointers to functions <ref> [8] </ref>. The rule [HOC] in Figure 30 is the rule for the higher-order-comparison used in the specification of higher-order functions. The function-interface (FI ) is used to create a new type environment, E 0 , from the formal parameters of the function interface. <p> The function-interface (FI ) is used to create a new type environment, E 0 , from the formal parameters of the function interface. Then the fun-spec-body (FSB ) is sort checked in accordance with the rule presented earlier. Please see the Reference Manual <ref> [8, Section 6.12] </ref> for more information on higher-order functions. 4.2.8 Literal Rules Figures 31 and 32 illustrate the sort rules for some of the literals. They are divided into the Larch/C++ basic sorts and the special C++ literals. <p> These rules show that the basic building blocks have the specific sorts dictated by C++. The rule [LIT2] serves as a model for the formulation of sorts for the unsigned types. For a complete list, please see the Reference Manual <ref> [8, Chapter 11] </ref>. 4.2.9 Storage Rules In Larch/C++ storage references are used in the modifies clause, and in a few other places. The storage reference rules illustrated in Figures 33 and 34 show how these references interact with the sort system. Rule [SRL4] is the most complex of the rules. <p> The constraints in the side condition are there because of the definition of storage references. For more information on the semantics of storage references, see the Reference Manual <ref> [8, Section 6.2.3.3 and following] </ref>. 5 Implementation of the System As mentioned in the Introduction, the development process for type checking in the Larch/C++ Checker has occurred in many pieces. <p> The string is built as expected, bottom up, as the parse is conducted. The system handles template types, like the type Set&lt;int&gt; above, by translating the &lt;&gt; symbols into legal [] symbols. The system can do this because Larch/C++ requires that template types have equivalent sorts <ref> [8, Page 20] </ref>.However, C++ allows for complex expressions as template arguments. How should the system handle those? The answer is, it does not. The TooComplex attribute is used to keep track of the simplicity of the template arguments. <p> This interaction between the sorts of the abstract values and the sorts of the enclosing objects can make it difficult to automatically generate sorts. Examples of declarations and their equivalent sorts taken from the Reference Manual <ref> [8, Chapter 5 and Section 6.1.8.1] </ref> are illustrated in Figures 48 and 49. Notice that the same form of declaration may have a different sort depending upon whether it is a declaration of a variable or a declaration of a formal parameter. <p> In Larch/C++, as in C++, type specifiers contain a type name and an associated qualifier (either const or volatile). int, unsigned int, enum color, and const int, are all examples of valid type specifiers <ref> [8] </ref>. Declarators contain the names of the items being declared along with a list of qualifiers that provide additional information. Figure 50 lists the qualifiers as presented in the Larch/C++ Reference Manual [8]. <p> const or volatile). int, unsigned int, enum color, and const int, are all examples of valid type specifiers <ref> [8] </ref>. Declarators contain the names of the items being declared along with a list of qualifiers that provide additional information. Figure 50 lists the qualifiers as presented in the Larch/C++ Reference Manual [8]. After it was realized that the type specifier and declarator information was enough to build sorts, the question became, at what point during a parse is this information complete and available? It turns out that the key was within the function Declare. <p> The other declaration qualifiers work in a similar way, building the correct sorts for themselves based upon the definitions in the Reference Manual <ref> [8] </ref>. As the algorithm cycles through the list of qualifiers, it builds the sort from the inside out. Once the basic declaration qualifier code was built, another abnormality was discovered in testing.
Reference: [9] <author> John R. Levine, Tony Mason, and Doug Brown. </author> <title> lex and yacc. </title> <publisher> O'Reilly and Associates, Inc., </publisher> <address> CA, </address> <year> 1992. </year>
Reference-contexts: Thus the lexer always returns LBRACKET and RBRACKET in this case. When the lexer reaches a new-line character, it knows that it has reached the end of a complete signature. At this point it switches to a start state where square brackets are OPENSYMs and CLOSESYMs. Please see <ref> [9] </ref> for more details on the use of start states. The initial testing of the operator signature parser revealed a minor problem. The system was consistently returning parse errors for input that looked correct.
Reference: [10] <author> MIT/LCS. </author> <note> LCLint checker, version 1.4a. http://larch-www.lcs.mit.edu:8001/larch/lclint/, June 1997. </note>
Reference-contexts: This appeared to be a time sink, however. It was decided to see how other languages in the Larch family handled this interface. 5.3.1 Interface to the LSL Checker After examining an early implementation for the LCLint tool <ref> [10] </ref>, it was realized that the LSL Checker handles the renaming of traits in includes clauses, and will generate the needed information about the trait operations 60 via the -syms option. Reusing this functionality would save time and effort. Thus, an interface to the LSL Checker was needed. <p> This requires some sort of interface between the Larch/C++ Checker and the LSL Checker. The interface used owes a lot of its basic design to the interface used by LCLint 1.4a <ref> [10] </ref>. The LCLint tool generates a temporary trait file that contains an includes statement for the trait information. It then uses the Standard C system call to run the LSL Checker over that file, redirecting the Checker's output into another temporary file. <p> These special cases make the code for the translation more complex. 76 Declaration Sort of x (used as global) ------------ ------------------------- const int &const x; ConstObj [int] const int *const x; ConstObj [Ptr [ConstObj [int]]] const int x [3][4]; Arr [Arr [ConstObj [int]]] int *x <ref> [10] </ref>; Arr [Obj [Ptr [Obj [int]]]] struct IntList - int val; IntList *next; -; IntList x; ConstObj [IntList] const IntList x; ConstObj [Const [IntList]] int (*x)(int i); Obj [Ptr [ConstObj [cpp_function]]] int (* const x)(int i); ConstObj [Ptr [ConstObj [cpp_function]]] int (*x [10])(int i); Arr [Obj [Ptr [ConstObj [cpp_function]]]] At first,
Reference: [11] <author> MIT/LCS. </author> <note> LSL checker, version 3.1beta3. http://larch-www.lcs.mit.edu:8001/larch/lsl.html, June 1997. </note>
Reference-contexts: Unfortunately, little has been written on the LSL type system. Neither the technical report on LSL [7] nor the Larch book [6] offered any details. What was available was the LSL Checker <ref> [11] </ref>. The LSL Checker is a tool that will perform semantic and syntactic checks on LSL traits. Since the LSL Checker provides type checking of traits, it serves as an operational definition of the LSL type system.
Reference: [12] <author> David A. Schmidt. </author> <title> The Structure of Typed Programming Languages. </title> <publisher> MIT Press, </publisher> <address> MA, </address> <year> 1994. </year>
Reference-contexts: This is the name conflict resolution algorithm in action. A second way to merge two complex type environments together is called shadow union. Shadow union ,represented by the [ symbol <ref> [12] </ref>, is used to describe the complex type environment created by combining two environments from different scopes. In essence, it embodies how names are hidden due to the scoping system by the name lookup algorithm.
Reference: [13] <author> David A. Watt. </author> <title> Programming Language Concepts and Paradigms. </title> <publisher> Pren-tice Hall, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: The work described in this paper focuses on the addition of type checking capabilities to the Larch/C++ Checker. In this context a type is a set of values that exhibit uniform behavior under a set of associated operations <ref> [13] </ref>. <p> This is an example of context-dependent overload resolution. Context-dependent overloading means that the context in which the function or variable appears is used to help uniquely identify its sort <ref> [13] </ref>.
Reference: [14] <author> Jeannette M. Wing. </author> <title> A specifier's introduction to formal methods. </title> <journal> Computer, </journal> <volume> 23(9) </volume> <pages> 8-24, </pages> <month> September </month> <year> 1990. </year> <month> 87 </month>
Reference-contexts: This functionality is then formalized in a description of the sort rules for Larch/C++. Finally the details of the implementation of the functionality mentioned above are presented. 2 Background 2.1 Formal Methods The information in this section is based upon Wing's paper <ref> [14] </ref>. Formal methods define processes that are used for software development. Built upon a mathematical basis, these processes are designed to reveal ambiguities, incompleteness, and inconsistencies in software as it is developed.
References-found: 14

