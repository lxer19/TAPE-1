URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-90-957/CS-TR-90-957.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-90-957/
Root-URL: http://www.cs.wisc.edu
Email: schuh@cs.wisc.edu  
Title: Persistence in E Revisited Implementation Experiences  
Author: Dan Schuh, Michael Carey, and David Dewitt 
Address: Madison, WI 57306  
Affiliation: Computer Sciences Department University of Wisconsin  
Abstract: This paper discusses the design and implementation of the E Persistent Virtual Machine (EPVM), an interpreter that provides support for persistent data access in the current version of the E programming language. Included are descriptions of both the EPVM interface and the major implementation tactics employed within EPVM. A novel pointer swizzling scheme that has been investigated in the context of E and EPVM is also described. Finally, a performance analysis of the key EPVM primitives is presented.
Abstract-found: 1
Intro-found: 1
Reference: [Atki83] <author> M. Atkinson, M., et. al, </author> <title> "Algorithms for a Persistent Heap," </title> <journal> Software Practice & Experience, </journal> <volume> Vol. 13, </volume> <year> 1983. </year>
Reference-contexts: Finally, we also showed that pointer swizzling techniques can improve performance markedly, even given the indirect nature of the EXODUS storage manager interface. The approach that we have described here is somewhat similar in flavor to the abstract machine approach used in the implementations of PS-Algol and Napier <ref> [Atki83, Dear88] </ref>, but EPVM is much more limited in scope. The abstract machines for PS-Algol and Napier implement many aspects of their languages, and they interact much more strongly with the language type systems and programming environments. EPVM is primarily restricted to providing access to persistent storage.
Reference: [Care89a] <author> M. Carey et. al, </author> <title> "The EXODUS Extensible DBMS Project: An Overview," in Readings in Object-Oriented Databases, </title> <editor> S. Zdonik and D. Maier, eds., Morgan-Kaufman, </editor> <year> 1989. </year>
Reference-contexts: 1. INTRODUCTION This paper discusses the current implementation of access to persistent data in the E programming language. E is a persistent, object-oriented programming language that was developed as an extension of C++ [Stro86] for use in the EXODUS project at the University of Wisconsin <ref> [Care89a] </ref>. The E language was originally designed for use in constructing database management system software; an overview of the design and motivation for E can be found in [Rich89a]. Basically, three main innovative features distinguish E from C++: persistent data, generator classes, and iterator functions.
Reference: [Care89b] <author> M. Carey et. al, </author> <title> "Storage Management for Objects in EXODUS," in Object-Oriented Concepts, Databases, and Applications, </title> <editor> W. Kim and F. Lochovsky, eds., </editor> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: We begin with a brief overview of addressing issues as they apply to ESM storage objects, and follow with detailed descriptions of the key routines used to pin, unpin, and modify objects in the buffer pool. Further details can be found in <ref> [Care89b] </ref>. 2.1. Addressing There are two forms of persistent object addresses that concern us here. The first is the (permanent) address of an object stored on disk, and the second is the (temporary) address of an object in main memory.
Reference: [Cock84] <author> W. Cockshott, et. al, </author> <title> "Persistent Object Management System," </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 14, </volume> <year> 1984. </year>
Reference-contexts: Pointer Swizzling The general idea of ``pointer swizzling'' is to maintain two distinct forms for addressing persistent objects, one for disk-resident objects and another for memory-resident objects <ref> [Cock84, Maie86] </ref>. Pointers are transformed back and forth during the course of program execution.
Reference: [Dear88] <author> A. Dearle, </author> <title> On the Construction of Persistent Programming Environments, </title> <type> Ph.D. Thesis, </type> <institution> Computational Science Dept., University of St. </institution> <address> Andrews, St. Andrews, Scotland, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: Finally, we also showed that pointer swizzling techniques can improve performance markedly, even given the indirect nature of the EXODUS storage manager interface. The approach that we have described here is somewhat similar in flavor to the abstract machine approach used in the implementations of PS-Algol and Napier <ref> [Atki83, Dear88] </ref>, but EPVM is much more limited in scope. The abstract machines for PS-Algol and Napier implement many aspects of their languages, and they interact much more strongly with the language type systems and programming environments. EPVM is primarily restricted to providing access to persistent storage.
Reference: [Maie86] <author> D. Maier, </author> <title> "Why Object-Oriented Databases Can Succeed Where Others Have Failed," </title> <booktitle> Proc. of the 1st Int'l. Workshop on Object-Oriented Database Systems, </booktitle> <address> Pacific Grove, CA, </address> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: Pointer Swizzling The general idea of ``pointer swizzling'' is to maintain two distinct forms for addressing persistent objects, one for disk-resident objects and another for memory-resident objects <ref> [Cock84, Maie86] </ref>. Pointers are transformed back and forth during the course of program execution.
Reference: [Rich89a] <author> J. Richardson, M. Carey, and D. Schuh, </author> <title> The Design of the E Programming Language, </title> <type> Technical Report No. 824, </type> <institution> Computer Sciences Dept., University of Wisconsin, </institution> <month> Feb. </month> <year> 1989. </year>
Reference-contexts: The E language was originally designed for use in constructing database management system software; an overview of the design and motivation for E can be found in <ref> [Rich89a] </ref>. Basically, three main innovative features distinguish E from C++: persistent data, generator classes, and iterator functions. Support for persistent data allows program-level data objects to be transparently used across multiple executions of a program without requiring explicit input and output operations. <p> Persistence of an object in E is dependent on a combination of the static type of a declared object and on the storage class or method of allocation of the object <ref> [Rich89a, Rich89b] </ref>. In particular, E uses a dual type system with a concept of database (db) types to statically distinguish the types of objects that may possibly persist from those types that describe objects that are sure to be transient.
Reference: [Rich89b] <author> J. Richardson and M. Carey, </author> <title> "Persistence in the E Language: Issues and Implementation," </title> <journal> Software Practice & Experience, </journal> <volume> Vol. 19, </volume> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: The design and initial implementation of persistence in E, which was the basis for persistent data in E 1.2, is discussed in <ref> [Rich89b] </ref>. A substantially improved approach to persistence for E 1.2, based on compile-time analysis of E programs, is described in [Rich90]. The topic of this paper is a new approach that is currently employed in E 2.0. The current approach is based on an underlying interpreter for persistent object accesses. <p> Persistence of an object in E is dependent on a combination of the static type of a declared object and on the storage class or method of allocation of the object <ref> [Rich89a, Rich89b] </ref>. In particular, E uses a dual type system with a concept of database (db) types to statically distinguish the types of objects that may possibly persist from those types that describe objects that are sure to be transient.
Reference: [Rich90] <author> J. Richardson, </author> <title> "Compiled Item Faulting," </title> <booktitle> Proc. of the 4th Int'l. Workshop on Persistent Object Systems, </booktitle> <address> Martha's Vineyard, MA, </address> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: The design and initial implementation of persistence in E, which was the basis for persistent data in E 1.2, is discussed in [Rich89b]. A substantially improved approach to persistence for E 1.2, based on compile-time analysis of E programs, is described in <ref> [Rich90] </ref>. The topic of this paper is a new approach that is currently employed in E 2.0. The current approach is based on an underlying interpreter for persistent object accesses. <p> It is also interesting to compare EPVM to the approach taken by Richardson in the 1.2 E compiler <ref> [Rich90] </ref>. In 1.2 E, the compiler generated explicit pin and unpin calls to establish the user descriptors corresponding to each pointer value used by an E program to access data.
Reference: [Shek90] <author> E. Shekita and M. Zwilling, "Cricket: </author> <title> A Mapped Persistent Object Store," </title> <booktitle> Proc. of the 4th Int'l. Workshop on Persistent Object Systems, </booktitle> <address> Martha's Vineyard, MA, </address> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: Even our pointer swizzling costs did not come close to memory access costs. In contrast, a virtual memory based approach offers the possibility of performing accesses to persistent storage with a relatively small marginal cost per accessed object <ref> [Shek90] </ref>. However, such approaches have other problems, such as address space limitations and the difficulty of managing a shared, persistent address space. We feel that the approach shown here may prove to be a reasonable compromise, and it also offers a flexible environment for further research.
Reference: [Stro86] <author> Stroustrup, B., </author> <title> The C++ Programming Language, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year> <month> -15 </month>
Reference-contexts: 1. INTRODUCTION This paper discusses the current implementation of access to persistent data in the E programming language. E is a persistent, object-oriented programming language that was developed as an extension of C++ <ref> [Stro86] </ref> for use in the EXODUS project at the University of Wisconsin [Care89a]. The E language was originally designed for use in constructing database management system software; an overview of the design and motivation for E can be found in [Rich89a].
References-found: 11

