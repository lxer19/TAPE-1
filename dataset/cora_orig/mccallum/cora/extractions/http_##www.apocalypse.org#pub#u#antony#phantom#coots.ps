URL: http://www.apocalypse.org/pub/u/antony/phantom/coots.ps
Refering-URL: http://swarm.cs.wustl.edu/~picco/papers/biblio/phantom.bib.html
Root-URL: 
Title: An Interpreted Language for Distributed Programming  
Author: Antony Courtney 
Address: College Dublin Ireland  
Affiliation: Department of Computer Science Trinity  
Abstract: The emerging trend in writing distributed applications is to use an object-based RPC system with a statically compiled, object-oriented language. While such a programming environment is adequate for many tasks, object-based RPC systems and statically compiled languages also have certain intrinsic limitations. These limitations become significant when writing applications which are both distributed and interactive (e.g. network information browsers, distributed conferencing systems and collaborative work tools). This paper discusses these limitations, and presents the design of Phantom, a new intepreted language for distributed programming. Phantom provides many features found in object-based RPC systems and statically compiled languages, including automatic marshalling, transparent remote procedure call, secure authentication and concurrency support. In addition to these traditional features, Phantom's interpreted nature permits the use of certain programming techniques, such as true object migration, remote evaluation, and dynamic extensibility, which are of increasing importance for distributed programming, but which are not available in statically compiled languages and RPC systems. The integration of these features in a single, coherent programming language makes whole new classes of distributed, interactive applications possible.
Abstract-found: 1
Intro-found: 1
Reference: [BL94] <author> Tim Berners-Lee. </author> <title> Internet RFC 1738: Uniform Resource Locators (URL). </title> <note> URL: http://www.cis.ohio-state.edu/htbin/rfc/rfc1738.html, December 1994. </note>
Reference-contexts: The first is a generic client program (such as might be launched as an "external viewer" from a WWW browser), and the second is a specific application server with which the client can communicate. The generic client uses the information in a Uniform Resource Locator (URL) <ref> [BL94] </ref> to obtain a reference to a remote application server. Once the client has obtained a reference to the application server, it obtains an autonomous agent from the sever: a procedure received from the remote site which the client executes locally.
Reference: [BLC93] <author> Tim Berners-Lee and Daniel W. Connolly. </author> <title> Hypertext Markup Language: A Representation of Textual Information and Metainformation for Retrieval and Interchange. </title> <note> URL: http://info.cern.ch/hypertext/WWW/MarkUp/HTML.html, 1993. </note>
Reference-contexts: This application has two parts. There is a client part, which displays the visual image of the current view of the frog, and allows the user to change this view by setting various parameters. In the current implementation, the client part is an HTML <ref> [BLC93] </ref> form, which is displayed and managed by the user's WWW browser program. There is also a server part, which runs on a remote, high-performance computer and renders the three-dimensional image of the current view of the frog.
Reference: [BLCGP92] <author> Tim Berners-Lee, R. Cailliau, J-F Groff, and B. Pollermann. </author> <title> World-Wide Web: The Information Universe. </title> <journal> Electronic Networking: Research, Applications and Policy, </journal> <volume> 2(1) </volume> <pages> 52-58, </pages> <month> Spring </month> <year> 1992. </year>
Reference-contexts: An illustrative example of these limitations comes from the World-Wide Web (WWW) <ref> [BLCGP92] </ref>. A typical example of an interactive application for WWW is Lawrence Berkeley Laboratory's "Interactive Frog Dissection Kit" [RJN94], an educational program which uses three dimensional volume rendering to allow a user to graphically explore the anatomical structures of a virtual frog.
Reference: [BST89] <author> Henri E. Bal, Jennifer G. Steiner, and Andrew S. Tanenbaum. </author> <title> Programming Languages for Distributed Computing Systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3), </volume> <month> September </month> <year> 1989. </year>
Reference-contexts: While none of the above features is compelling in itself, their integration in a single, simple language provides a powerful environment for constructing distributed applications. 2 Related Work Distributed programming languages are not a new idea. An excellent overview of other distributed programming languages is given in <ref> [BST89] </ref>, which includes a bibliography of over 200 papers on nearly 100 different languages. Despite the number and variety of these other distributed programming languages, most other distributed languages are intended for harnessing the power of a network of processors as a single parallel processing engine.
Reference: [Car95] <author> Luca Cardelli. </author> <title> A Language with Distributed Scope. </title> <booktitle> In Principles of Programming Languages, </booktitle> <month> January </month> <year> 1995. </year> <note> URL: http://www.research.digital.com/SRC/Obliq/Obliq.html. </note>
Reference-contexts: Furthermore, most other distributed programming languages do not provide any mechanism for transmission of code across sites. The only language we are aware of which provides facilities for transparent distribution of both program code and data is Obliq <ref> [Car95] </ref>. The distribution model of Phantom uses the same basic model as Obliq. However, there are a number of aspects of Phantom which differentiate it from Obliq: * Phantom is strongly typed (using structural type equivalence). <p> Phantom objects have attributes (containing state information), a number of methods (for performing operations), and support single-inheritance. Phantom uses a class-based object model (rather than prototypes, as in Obliq <ref> [Car95] </ref> or Self [US87]). While classes are more verbose than prototypes, we feel that classes provide for a cleaner separation between the interface and implementation of objects, and scale better for large applications. Objects are the focus of communication in Phantom. <p> While this violates location transparency to some degree, we feel that only the programmer can make reasonable decisions about when and where to migrate objects. 3.2 Distribution Model The distribution model of Phantom borrows heavily from the distributed lexical scoping semantics of Obliq <ref> [Car95] </ref>. The basic concepts are illustrated in figure 2. 2 These network addresses take the form of global location addresses, described in section 3.2. A network connects a number of sites.
Reference: [Cur92] <author> Pavel Curtis. </author> <title> LambdaMOO Programmer's Manual. </title> <type> Technical report, </type> <institution> Xerox Corporation, Palo Alto Research Centre, </institution> <month> October </month> <year> 1992. </year> <note> URL: ftp://parcftp.xerox.com/ProgrammersManual.ps. </note>
Reference-contexts: The most compelling of these ideas is a graphical, extensible distributed conferencing system. This will involve implementing a distributed version of LambdaMOO <ref> [Cur92] </ref> in Phantom. LambdaMOO is a "text-based virtual reality" which uses its own interpreted, object-oriented language to provide a general-purpose, dynamically extensible conferencing environment. However, LambdaMOO is totally centralised, and there are fundamental security problems in extending LambdaMOO (in its present form) to a distributed implementation.
Reference: [Fab74] <author> Robert S. Fabry. </author> <title> Capability-Based Addressing. </title> <journal> Communications of the ACM, </journal> <volume> 17 </volume> <pages> 403-412, </pages> <month> July </month> <year> 1974. </year>
Reference-contexts: The relative location address part of a global location address is a 128-bit key generated by the site which owns the location, rather than just a pointer into the interpreter's memory space. Because this key space is large and sparsely populated, the key acts as a software capability <ref> [Fab74] </ref> for locations in the interpreter's memory space.
Reference: [Gro92] <author> The Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <year> 1992. </year>
Reference-contexts: 1 Motivation 1.1 Object-based RPC and Static Compilation The current trend in programming distributed systems is to use a statically compiled, object-oriented language (such as C++ [Str92]), augmented with an object-based RPC system and associated runtime library (such as CORBA <ref> [Gro92] </ref> or ILU [JSS94]). With an object-based RPC system, the programmer specifies the interface to network-accesible objects using an interface definition language (IDL). A protocol compiler compiles the IDL specification to generate client and server stub routines which are linked with the programmer's application code.
Reference: [IEE91] <author> IEEE. Std. </author> <year> 1178-1990. </year> <title> IEEE Standard for the Scheme Programming Language. </title> <institution> Institute of Electrical and Electronic Engineers, </institution> <year> 1991. </year>
Reference-contexts: Phantom also includes support for implicit declarations, dynamically-sized lists, and general purpose higher-order functions. These features are modelled on their counterparts in other interpreted languages (such as Scheme <ref> [IEE91] </ref> and Python [Ros92]). 3.1 Object Model Phantom supports object-oriented programming, in a manner similar to Modula-3. Phantom objects have attributes (containing state information), a number of methods (for performing operations), and support single-inheritance. Phantom uses a class-based object model (rather than prototypes, as in Obliq [Car95] or Self [US87]).
Reference: [IEE92] <author> IEEE. </author> <title> P1003.4a/D6 Threads Extension for Portable Operating Systems (Draft 6). </title> <institution> Institute of Electrical and Electronic Engineers, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: Each location has a location address, which uniquely identifies the location within the interpreter's memory space, and holds a value. Each Phantom program executes as a number of threads within the interpreter. Threads are provided through a library which implements the POSIX pthreads specification <ref> [IEE92] </ref>. Two data structures are associated with each thread: 1. A representation of the program code which the thread is executing. In the current implementation, the interpreter uses a sequence of byte codes for a virtual stack machine for this purpose. 2.
Reference: [JSS94] <author> Bill Janssen, Mike Spreitzer, and Denis Severson. </author> <title> Inter-Language Unification, 1.6.4. </title> <type> Technical Report P94-00058, </type> <institution> Xerox Corporation, Palo Alto Research Centre, </institution> <month> May </month> <year> 1994. </year> <note> URL: http://ftp.parc.xerox.com/pub/ilu/ilu.html. </note>
Reference-contexts: 1 Motivation 1.1 Object-based RPC and Static Compilation The current trend in programming distributed systems is to use a statically compiled, object-oriented language (such as C++ [Str92]), augmented with an object-based RPC system and associated runtime library (such as CORBA [Gro92] or ILU <ref> [JSS94] </ref>). With an object-based RPC system, the programmer specifies the interface to network-accesible objects using an interface definition language (IDL). A protocol compiler compiles the IDL specification to generate client and server stub routines which are linked with the programmer's application code.
Reference: [Nel91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: These are all features of the programming language Modula-3 <ref> [Nel91] </ref>. Where possible, Phantom borrows Modula-3's syntax and semantics. Phantom extends Modula-3's object model (by adding the concepts of ownership and access control ), and omits many of Modula-3's more complex features (such as reference types and generics) which would complicate Phantom's distributed semantics.
Reference: [Ous94] <author> John K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: However, there are a number of aspects of Phantom which differentiate it from Obliq: * Phantom is strongly typed (using structural type equivalence). The adherence to strong typing provides a level of static error checking which is not provided in most other interpreted languages (including Obliq, Tcl <ref> [Ous94] </ref> and Python [Ros92]). As examples will illustrate, Phantom provides type-safe implicit declarations, which limit the overhead of strong typing in an interpreted language. * Phantom uses a class-based object model, rather than prototypes. <p> encourages the seperation of interface from implementation of object types. * Syntactically, Phantom more closely resembles Modula-3. * Phantom provides a simple access control and authentication mechanism at the language level. * The Phantom interpreter is implemented purely in ANSI C, and provides a library interface to the Tk toolkit <ref> [Ous94] </ref>. Although we chose to design a new language, producing a novel new programming language is not the goal of the project. We tried hard to borrow proven mechanisms from other languages and systems rather than invent our own.
Reference: [RJN94] <author> David W. Robertson, William Johnston, and Wing Nip. </author> <title> Virtual Frog Dissection: Interactive 3D Graphics via the Web. </title> <booktitle> In Proceedings of the Second International WWW Conference, </booktitle> <year> 1994. </year> <note> URL: http://george.lbl.gov/ITG.hm.pg.docs/dissect/info.html. </note>
Reference-contexts: An illustrative example of these limitations comes from the World-Wide Web (WWW) [BLCGP92]. A typical example of an interactive application for WWW is Lawrence Berkeley Laboratory's "Interactive Frog Dissection Kit" <ref> [RJN94] </ref>, an educational program which uses three dimensional volume rendering to allow a user to graphically explore the anatomical structures of a virtual frog. A screen-shot of the program is shown in figure 1. This application has two parts.
Reference: [Ros92] <author> Guido Van Rossum. </author> <title> Python Language Reference Manual. </title> <journal> software documentation, </journal> <year> 1992. </year>
Reference-contexts: The adherence to strong typing provides a level of static error checking which is not provided in most other interpreted languages (including Obliq, Tcl [Ous94] and Python <ref> [Ros92] </ref>). As examples will illustrate, Phantom provides type-safe implicit declarations, which limit the overhead of strong typing in an interpreted language. * Phantom uses a class-based object model, rather than prototypes. <p> Phantom also includes support for implicit declarations, dynamically-sized lists, and general purpose higher-order functions. These features are modelled on their counterparts in other interpreted languages (such as Scheme [IEE91] and Python <ref> [Ros92] </ref>). 3.1 Object Model Phantom supports object-oriented programming, in a manner similar to Modula-3. Phantom objects have attributes (containing state information), a number of methods (for performing operations), and support single-inheritance. Phantom uses a class-based object model (rather than prototypes, as in Obliq [Car95] or Self [US87]).
Reference: [RT74] <author> Dennis M. Ritchie and Ken Thompson. </author> <title> The UNIX Time-Sharing System. </title> <journal> Communications of the ACM, </journal> <volume> 17(7) </volume> <pages> 365-375, </pages> <month> July </month> <year> 1974. </year>
Reference-contexts: For distribution, Phantom uses the distributed lexical scoping semantics of Obliq. For access control, Phantom uses a model which is similar to permissions in the UNIX file system <ref> [RT74] </ref>. 3 The Phantom Language: Concepts and Techniques The Phantom language supports a number of modern imperative programming features, including: interfaces, objects, threads, garbage collection and exceptions. These are all features of the programming language Modula-3 [Nel91]. Where possible, Phantom borrows Modula-3's syntax and semantics.
Reference: [SG90] <author> James W. Stamos and David K. Gifford. </author> <title> Implementing Remote Evaluation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(7), </volume> <month> July </month> <year> 1990. </year>
Reference-contexts: However, object-based RPC systems and statically compiled languages also have some significant deficiencies. For purposes of this paper, the most significant deficiency is that object-based RPC systems do not provide any mechanism for sending code across sites. This excludes certain distributed programming techniques (such as Remote Evaluation <ref> [SG90] </ref>) and, as the following example will illustrate, also places severe limitations on both the dynamic extensibility and performance of interactive applications. 1.2 An Example from the World-Wide Web The limitations of object-based RPC systems and statically compiled languages become significant when writing applications which support both remote network access and
Reference: [Str92] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> second edition, </address> <year> 1992. </year>
Reference-contexts: 1 Motivation 1.1 Object-based RPC and Static Compilation The current trend in programming distributed systems is to use a statically compiled, object-oriented language (such as C++ <ref> [Str92] </ref>), augmented with an object-based RPC system and associated runtime library (such as CORBA [Gro92] or ILU [JSS94]). With an object-based RPC system, the programmer specifies the interface to network-accesible objects using an interface definition language (IDL).
Reference: [US87] <author> David Ungar and Randall B. Smith. </author> <title> Self: The Power of Simplicity. </title> <journal> ACM Sigplan Notices, </journal> <volume> 2(12), </volume> <year> 1987. </year>
Reference-contexts: Phantom objects have attributes (containing state information), a number of methods (for performing operations), and support single-inheritance. Phantom uses a class-based object model (rather than prototypes, as in Obliq [Car95] or Self <ref> [US87] </ref>). While classes are more verbose than prototypes, we feel that classes provide for a cleaner separation between the interface and implementation of objects, and scale better for large applications. Objects are the focus of communication in Phantom.
Reference: [WABL93] <author> Edward Wobber, Martin Abadi, Mike Burrows, and Butler Lampson. </author> <title> Authentication in the Taos Operating System. </title> <type> Technical Report 117, </type> <institution> Digital Equipment Corportation, Systems Research Centre, </institution> <month> Decemeber </month> <year> 1993. </year>
Reference-contexts: For large-scale applications, which have more sophisticated security requirements, we plan to augment the language-level primitives with a library that provides complex principals, access control lists and encryption, in a manner similar to Taos <ref> [WABL93] </ref>. 3.5.3 Global Location Addresses and Security A global location address is the handle used by an interpreter to access locations stored in the memory space of remote sites.
References-found: 20

