URL: ftp://theory.cs.uni-bonn.de/pub/reports/cs-reports/1995/85139-cs.ps.gz
Refering-URL: http://cs.uni-bonn.de/info5/publications/CS-1995-en.html
Root-URL: http://cs.uni-bonn.de
Title: Alphabet Independent Optimal Parallel Search for Three-Dimensional Patterns (Revised Version)  
Author: Marek Karpinski Wojciech Rytter 
Note: Supported in part by the Int. Computer Science Institute, Berkeley, by the DFG Grant KA 673/4-1, and by the ESPRIT BR Grants 7097 and ECUS 030, e-mail: marekcs.uni-bonn.de Supported in part by the DFG Grant  
Affiliation: Department of Computer Science, University of Bonn  Institute of Informatics, Warsaw University  
Abstract: We give an alphabet-independent optimal parallel algorithm for the searching phase of three-dimensional pattern-matching. All occurrences of a three dimensional pattern P of shape m fi m fi m in a text T of shape n fi n fi n are to be found. Our algorithm works in log m time with O(N= log(m)) processors on a CREW PRAM, where N = n 3 . Some ideas from [3] are used. We explore classification of two-dimensional periodicities of faces of the cubic pattern. Some projection techniques are developed to deal with three dimensions. The nonperiodicity implies some sparseness properties, while periodicity implies other special useful properties (i.e. monotonicity) of the set of occurrences. Both types of properties are used in deriving our algorithm. The search phase is preceded by the preprocessing phase (computation of the witness table). Our main results concern the searching phase, however we present shortly a new approach to the second phase also. Usefulness of the dictionaries of basic factors (DBF 's), see [9], in the computation of the three dimensional witness table is presented. Our algorithms can be easily adjusted to the case of unequally sided patterns. A preliminary version of this paper was presented in [15] 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.Amir, G.Benson, </author> <title> Two dimensional periodicity in rectangular arrays. </title> <booktitle> in Proc. 2nd ACM Symp. on Discrete Algorithms, </booktitle> <year> (1992) </year> <month> 440-452 </month>
Reference-contexts: If there is no such entry then it equals n + 1. The row minima problem consists in computing the row minima vector fi A for a strongly monotone zero-one array. Example For the array A presented below we have: fi A = <ref> [1; 3; 3; 4; 5; 6] </ref> A = 6 6 6 6 6 4 1 1 0 0 0 0 1 1 1 0 0 0 1 1 1 1 1 0 7 7 7 7 7 5 Observation If A is strongly monotone then the row minima vector is monotone <p> We say that is row-monotonic if the weights of points in are increasing in each row or are decreasing in each row of the face H. Analogously define column-monotonicity of . If the two-dimensional pattern is line- or radiant-periodic then it is known, see <ref> [1] </ref>, that any set of consistent candidates in the 2D-text is monotonic in an unweighted-sense. This means that one of the coordinates is a monotonic function of the second one. Assume that P is radiant-periodic or line-periodic w.r.t. each of its faces. Then the property above holds for all faces.
Reference: [2] <author> A.Amir, G.Benson, M.Farach. </author> <title> Alphabet independent two dimensional matching, </title> <booktitle> in Proc. 24th ACM Symp. on Theory of COmputation, </booktitle> <year> (1992) </year> <month> 59-68. </month>
Reference-contexts: The main role of the preprocessing is the computation of the so called witness table, which will be defined later. Let be the underlying alphabet. In two dimensions there are two approaches to compute this table efficiently: use the suffix trees (see <ref> [2] </ref>), which is a factor log jj slower than linear time, and the linear time alphabet independent algorithms of [11] and [7]. The alphabet independent algorithms are extremely complicated. They would be even more complicated in three dimensions. <p> Our model of parallel computations is the Concurrent Read Exclusive Write Parallel Access Machine (PRAM, in short), see [12]. In the paper we concentrate on the first phase of the pattern-matching: the searching phase. Amir, Benson and Farah were the first to give alphabet-independent linear time searching phase, see <ref> [2] </ref>. They have also given in [3] an alphabet-independent searching in logM time with O (N= log (M )) processors of a CREW PRAM. We refer to this algorithm as the algorithm ABF . The algorithm ABF needs only the witness table from the preprocessing phase. <p> Obviously two distinct symbols cannot both match the same symbol, hence one of them disagree and the corresponding candidate point is removed. We refer the reader to <ref> [2] </ref> and [8] for the details about the dueling. We introduce also the relation j c of consistency between pairs of positions. We write x j c y if x y is a period of P . <p> Subphase (II): Realize Goal 2. Subphase (II) is rather simple compared with (I), and can be done for three dimensions essentially in the same way as for two dimensions, see <ref> [2] </ref> and [7]. Lemma 2.1 Assume we have a valid consistent set C of positions in a given window W . Then we can find all occurrences starting in W in O (log M ) time with O (M= log (M )) processors of a CREW PRAM. <p> The computation of such patterns essentially reduces to the calculation of runs of consecutive 1's, or to the computation of the first "0" (which is easy in parallel). The reduction to the unary case works in three dimensions essentially in the same way as in two dimensions, see <ref> [2] </ref>. For each position x 2 T we find any element y of C which "covers" this position. This means that the pattern placed at y contains the position x. <p> Then the computation is reduced to the pattern-matching problem for unary patterns. This is reduced to several applications of an algorithm computing the longest runs of ones. We refer to <ref> [2] </ref>. * By a (planar) face of a given cube we mean a set of its points with one of the coordinates fixed. The faces can be external faces or internal faces of the cube. <p> We consider all (global) periods of P parallel to H, i.e. the vectors of the type x y, where x; y 2 H. We can classify these periods (with respect to H) in the same way as periodicities in two dimensions. We refer to <ref> [2] </ref> for definitions of periodicity types. So the face H can be: nonperiodic, lattice periodic, radiant periodic or line periodic. We say also that P has a given (one of four possible) periodicity type with respect to the face H. <p> The lattice-periodicity means here that there is a short period parallel to H in quadrant (I) and a short period in quadrant (II), and these vectors are different, see <ref> [2] </ref> and [8] for details. Denote by H k = f (x 1 ; x 2 ; x 3 ) 2 W : x 3 = kg. Let C k = H k " C.
Reference: [3] <author> A.Amir, G.Benson, M.Farach. </author> <title> Parallel two dimensional matching in logarithmic time. </title> <booktitle> in Proc. 5th ACM Symp. on Parallel Algorithms and Architectures (1993), </booktitle> <pages> 79-85. </pages>
Reference-contexts: In the paper we concentrate on the first phase of the pattern-matching: the searching phase. Amir, Benson and Farah were the first to give alphabet-independent linear time searching phase, see [2]. They have also given in <ref> [3] </ref> an alphabet-independent searching in logM time with O (N= log (M )) processors of a CREW PRAM. We refer to this algorithm as the algorithm ABF . The algorithm ABF needs only the witness table from the preprocessing phase. <p> The following claim says that if a two-dimensional m fi m pattern P 0 is lattice periodic then witnesses for all nonperiodic short vectors can be found in Center (P 0 ). The proof was essentially presented in <ref> [3] </ref>. Roughly speaking, if a 2-dimensional face is lattice-periodic then all points corresponding to periods form a kind of a net, and we can move through this net any point to an equivalent point in the central part of the face. <p> The coordinates of the points x 0 ; y 0 can be computed in constant time by a simple arithmetics. We omit the details and refer to <ref> [3] </ref>. Claim A Assume a 2-dimensional pattern P 0 is lattice-periodic. <p> If there is no such entry then it equals n + 1. The row minima problem consists in computing the row minima vector fi A for a strongly monotone zero-one array. Example For the array A presented below we have: fi A = <ref> [1; 3; 3; 4; 5; 6] </ref> A = 6 6 6 6 6 4 1 1 0 0 0 0 1 1 1 0 0 0 1 1 1 1 1 0 7 7 7 7 7 5 Observation If A is strongly monotone then the row minima vector is monotone
Reference: [4] <institution> An efficient parallel algorithm for the row minima of a totally monotone array, </institution> <note> Journal of Algorithms 13:2 (1992) 394-413 </note>
Reference-contexts: We can make duels between all of them in one parallel step with O (m 2 ) processors. This completes the proof. * 3.2 The row minima problem for special monotone arrays We use a simple version of a row minima problem, see <ref> [4] </ref>, for special monotone arrays. The processing of the radiant-periodic (the most difficult) case in the next subsection is reduced to this problem. Assume we have an m fi m zero-one matrix A. <p> If there is no such entry then it equals n + 1. The row minima problem consists in computing the row minima vector fi A for a strongly monotone zero-one array. Example For the array A presented below we have: fi A = <ref> [1; 3; 3; 4; 5; 6] </ref> A = 6 6 6 6 6 4 1 1 0 0 0 0 1 1 1 0 0 0 1 1 1 1 1 0 7 7 7 7 7 5 Observation If A is strongly monotone then the row minima vector is monotone <p> There are altogether O (m= log (m)) such subsquares. Each of them can be easily processed by one processor in logarithmic time. It is similar to the algorithm from <ref> [4] </ref>, however the situation here is simpler due to the applicability of binary search. This completes the proof. * 3.3 Projections and weighted 2-dimensional points It will be more convenient to deal with 2-dimensional objects, instead on 3-dimensional.
Reference: [5] <author> T.J.Baker, </author> <title> A technique for extending rapid exact-match string matching to arrays of more than one dimension. </title> <journal> SIAM J. Comp. </journal> <month> 7 </month> <year> (1978) </year> <month> 533-541. </month>
Reference-contexts: If there is no such entry then it equals n + 1. The row minima problem consists in computing the row minima vector fi A for a strongly monotone zero-one array. Example For the array A presented below we have: fi A = <ref> [1; 3; 3; 4; 5; 6] </ref> A = 6 6 6 6 6 4 1 1 0 0 0 0 1 1 1 0 0 0 1 1 1 1 1 0 7 7 7 7 7 5 Observation If A is strongly monotone then the row minima vector is monotone
Reference: [6] <author> R.S.Bird. </author> <title> Two dimensional pattern matching. </title> <journal> Inf. Proc. letters 6, </journal> <year> (1977) </year> <month> 168-170. </month>
Reference-contexts: If there is no such entry then it equals n + 1. The row minima problem consists in computing the row minima vector fi A for a strongly monotone zero-one array. Example For the array A presented below we have: fi A = <ref> [1; 3; 3; 4; 5; 6] </ref> A = 6 6 6 6 6 4 1 1 0 0 0 0 1 1 1 0 0 0 1 1 1 1 1 0 7 7 7 7 7 5 Observation If A is strongly monotone then the row minima vector is monotone
Reference: [7] <author> R.Cole, M.Crochemore, Z.Galil, L.Gasieniec, R.Hariharan, S.Muthukrishnan, K.Park, W.Rytter. </author> <title> Optimally fast parallel algorithms for preprocessing and pattern matching in one and two dimensions. </title> <booktitle> in Proc. 34th IEEE Symp. on Foundations of Computer Science (1993) 248-258. </booktitle>
Reference-contexts: Let be the underlying alphabet. In two dimensions there are two approaches to compute this table efficiently: use the suffix trees (see [2]), which is a factor log jj slower than linear time, and the linear time alphabet independent algorithms of [11] and <ref> [7] </ref>. The alphabet independent algorithms are extremely complicated. They would be even more complicated in three dimensions. On the other hand if is large then we can replace log jj by log m. We show a simple approach through the dictionary of basic factors (DBF, in short). <p> We refer to this algorithm as the algorithm ABF . The algorithm ABF needs only the witness table from the preprocessing phase. An O (1) time optimal algorithm was given recently in <ref> [7] </ref>, however it needs additional data structure from the preprocessing phase: so called deterministic sample. 2 Periodicities, Witnesses and Duels Our algorithm for the 3-dimensional matching is based on properties of the structure of 2-dimensional periodicities. <p> Subphase (II): Realize Goal 2. Subphase (II) is rather simple compared with (I), and can be done for three dimensions essentially in the same way as for two dimensions, see [2] and <ref> [7] </ref>. Lemma 2.1 Assume we have a valid consistent set C of positions in a given window W . Then we can find all occurrences starting in W in O (log M ) time with O (M= log (M )) processors of a CREW PRAM. <p> Then a valid consistent set of positions on a given face can be computed by applying the algorithm ABF , or the algorithm from <ref> [7] </ref>. This shows the following result. Lemma 2.2 Assume that the witness table W IT has been already precomputed.
Reference: [8] <author> M.Crochemore, W.Rytter. </author> <title> Text algorithms, </title> <publisher> Oxford University Press, </publisher> <address> New York (1994) </address>
Reference-contexts: Obviously two distinct symbols cannot both match the same symbol, hence one of them disagree and the corresponding candidate point is removed. We refer the reader to [2] and <ref> [8] </ref> for the details about the dueling. We introduce also the relation j c of consistency between pairs of positions. We write x j c y if x y is a period of P . <p> The lattice-periodicity means here that there is a short period parallel to H in quadrant (I) and a short period in quadrant (II), and these vectors are different, see [2] and <ref> [8] </ref> for details. Denote by H k = f (x 1 ; x 2 ; x 3 ) 2 W : x 3 = kg. Let C k = H k " C. <p> One could try to apply in this situation the two-dimensional algorithm ABF. Unfortunately it doesn't work in a straightforward way. The algorithm ABF is based on some partial transitivity properties of the consistency relation, see also <ref> [8] </ref>. These properties are here more complicated due to weights which correspond to the third dimension ( and which cannot be neglected). 3.4 Radiant-periodic and line-periodic cases Let = project H (C). <p> Other implications are symmetric. Observe that x j c y and u j c v, due to the fact that they are pairs of points on the same lines and due to the property (2) of . We refer the reader to <ref> [8] </ref>, pages 258-260, for the properties of partial transitivity of the relation j c in the 2-dimensional case. The implication above is satisfied in the 2-dimensional case, if the weights are disregarded.
Reference: [9] <author> M.Crochemore, W.Rytter. </author> <title> Usefullness of the Karp-Miller- Rosenberg algorithm in parallel computations on strings and arrays. </title> <note> Theoretical Computer Science 88 (1991) 59-62. </note>
Reference-contexts: We show a simple approach through the dictionary of basic factors (DBF, in short). This is a useful data structure introduced in [14]. It has received the name DBF and its usefulness in the design of string algorithms was shown in <ref> [9] </ref>. The advantage of the DBF is that it can be very easily extended to the three dimensional situation. For large alphabets the complexity of the DBF approach is not inferior to that of the suffix trees. <p> Hence our 3-dimensional searching algorithm can be implemented on a CRCW P RAM as an optimal O (log log m)-time algorithm. 14 4 Preprocessing the pattern: the DBF approach. The dictionary of basic factors (DBF , in short) is a useful data structure in text algorithms, see <ref> [9] </ref> for details about DBF and its applications. The DBF approach gains simplicity at the expense of a small increase in time. It gives a (nonoptimal) O (log (M )) time algorithm using O (M ) processors of a CRCW PRAM. <p> The names are integers in the range 1 : : : jjSjj and two words of the same length are equal (as strings) if and only if their names are the same. The following fact was shown in <ref> [9] </ref>. Lemma 4.1 DBF (S) can be computed in log jjSjj time with O (jjSjj) processors of a CRCW P RAM . <p> We can do it with one processor per each position i in logarithmic time by a kind of a binary search, see <ref> [9] </ref> for details. Each position has one processor (assigned to this position) which finds a witness (if there is any) in log m time. 2D-matching: assume we are to compute the witness table for a 2D-pattern P . Consider a fixed k-th column of P . We linearize the problem.
Reference: [10] <author> Z.Galil. </author> <title> Optimal parallel algorithms for string matching. </title> <note> Information and Control 67 (1985) 144-157. </note>
Reference-contexts: Proof: We can decompose the cube P into smaller subcubes if P is 1D-periodic. These smaller subcubes will be 1D-nonperiodic. The same argument as reducing periodic to nonperiodic case in one dimensional matching can be applied, see <ref> [10] </ref>. * Due to lemma 2.3 we can assume that P is 1D-nonperiodic. Let us make duels between positions on each line in W parallel to some edge of the cube W . There are O (m) positions on one line.
Reference: [11] <author> Z.Galil, K.Park. </author> <title> Truly alphabet independent two dimensional matching, </title> <booktitle> in Proc. 34th IEEE Symp. on Foundations of Computer Science , (1992) 247-256. </booktitle>
Reference-contexts: Let be the underlying alphabet. In two dimensions there are two approaches to compute this table efficiently: use the suffix trees (see [2]), which is a factor log jj slower than linear time, and the linear time alphabet independent algorithms of <ref> [11] </ref> and [7]. The alphabet independent algorithms are extremely complicated. They would be even more complicated in three dimensions. On the other hand if is large then we can replace log jj by log m. We show a simple approach through the dictionary of basic factors (DBF, in short). <p> The DBF approach gains simplicity at the expense of a small increase in time. It gives a (nonoptimal) O (log (M )) time algorithm using O (M ) processors of a CRCW PRAM. However the alphabet-independent optimal preprocessing is very complex even in the case of two dimensions, see <ref> [11] </ref>. For large alphabets the DBF 's give asymptotically the same complexity as the (alphabet-dependent) suffix trees approach (but avoids suffix trees and is simpler). However the basic advantage of the DBF approach is simplicity of dealing with three (or more) dimensions.
Reference: [12] <author> A.Gibbons, W.Rytter. </author> <title> Efficient parallel algorithms. </title> <publisher> Cambridge University Press (1988) </publisher>
Reference-contexts: In the three dimensional case the DBF works in much simpler way as the suffix trees approach. Our model of parallel computations is the Concurrent Read Exclusive Write Parallel Access Machine (PRAM, in short), see <ref> [12] </ref>. In the paper we concentrate on the first phase of the pattern-matching: the searching phase. Amir, Benson and Farah were the first to give alphabet-independent linear time searching phase, see [2].
Reference: [13] <author> R.Karp, R.Miller, A.Rosenberg. </author> <title> Rapid identification of repeated patterns in strings, trees and arrays. </title> <booktitle> in Proc. ACM Symp. on Theory of Computation, </booktitle> <year> (1972) </year> <month> 125-136. </month>
Reference: [14] <author> R.Karp, M.O.Rabin. </author> <title> Efficient randomized pattern matching algorithms. </title> <journal> IBM Journal of Res. and Dev. </journal> <month> 31 </month> <year> (1987) </year> <month> 249-260. </month>
Reference-contexts: They would be even more complicated in three dimensions. On the other hand if is large then we can replace log jj by log m. We show a simple approach through the dictionary of basic factors (DBF, in short). This is a useful data structure introduced in <ref> [14] </ref>. It has received the name DBF and its usefulness in the design of string algorithms was shown in [9]. The advantage of the DBF is that it can be very easily extended to the three dimensional situation.
Reference: [15] <author> M.Karpinski, W.Rytter. </author> <title> Alphabet independent optimal parallel search for 3-dimensional patterns, preliminary version. in Combinatorial Pattern Matching, </title> <editor> eds. M.Crochemore, D.Gusfield, </editor> <publisher> Springer-Varlag LNCS 807, </publisher> <year> (1994) </year> <month> 125-135 </month>
Reference: [16] <author> U.Vishkin. </author> <title> Optimal pattern matching in strings. </title> <note> Information and Control 67 (1985) 91-113. 17 </note>
References-found: 16

