URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1995/GIT-CC-95-41.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.95.html
Root-URL: 
Title: Scenario-Based Analysis of Software Architecture  
Author: Rick Kazman Gregory Abowd Len Bass, Paul Clements 
Keyword: Software Architecture; Software Analysis Methods; Software Quality, Soft ware Architecture Analysis, Applications of Scenarios  
Date: October 29, 1995  
Address: Waterloo, Ontario  Atlanta, Georgia  Pittsburgh, Pennsylvania  
Affiliation: Department of Computer Science, University of Waterloo  College of Computing, Georgia Institute of Technology  Software Engineering Institute, Carnegie Mellon University  
Pubnum: Technical report GIT-CC-95-41  
Abstract: Software architecture is one of the most important tools for designing and understanding a system, whether that system is in preliminary design, active deployment, or maintenance. Scenarios are important tools for exercising an architecture in order to gain information about a systems fitness with respect to a set of desired quality attributes. This paper presents a set of experiential case studies illustrating the methodological use of scenarios to gain architecture-level understanding and predictive insight into large, real-world systems in various domains. A structured method for scenario-based architectural analysis is presented, using scenarios to analyze architectures with respect to achieving quality attributes. Finally, lessons and morals are presented, drawn from the growing body of experience in applying scenario-based architectural analysis techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Atwood, J. </author> <title> The Systems Analyst, </title> <publisher> Hayden, </publisher> <year> 1977. </year>
Reference-contexts: This exercise was not an easy one to complete, even with full cooperation from customer and supplier. All along we have known that a good scenario-based analysis relies on domain expertise, but we learned C1 C4 C5 D3 C7 C9 C10 <ref> [1] </ref> C: init_ops [2] D: bxr_parms [3] C: invoke_bxr [4] D: get_ids [6] C: invoke_ccj [7] D: ccj_parms C1 Passive data Computation Components Active data C7 C8 C4 C6 D2 Connections Control ( ) Data ( ) Layer 1 Layer 2 Layer 3 Layer 4 12 in this exercise that there <p> During the process of describing the architecture, scenarios were continually developed that represented the various stakeholder roles in the system. For WRCS these roles were: users, developers, maintainers, and system administrators. Scenario enumeration is simply a particular form of requirements elicitation and analysis <ref> [1] </ref>. These scenarios were developed in discussion with all the stake-holders in the system, in order to try to characterize all current and projected uses of the system. The scenarios formed the basis for all further architectural evaluation.
Reference: [2] <author> Clements, P., Bass, L., Kazman, R., Abowd, G., </author> <title> Predicting Software Quality by Architecture Level Evaluation, </title> <booktitle> 5th International Conference on Software Quality, </booktitle> <address> (Austin, TX), </address> <month> October </month> <year> 1995, </year> <note> to appear. </note>
Reference-contexts: We per formed a SAAM evaluation on KWIC to determine if we could reproduce similar results as have been previously published. We actually found that our own analysis provided much more rationale for de ciding between solutions to this problem than was previously published <ref> [2] </ref>. 4. Embedded audio system An automotive company which develops their own embedded audio sys tems used a scenario-based technique during the design of the next generation of audio systems. 5. Visual debuggers A SAAM evaluation comparing two public domain visual debuggers. <p> This exercise was not an easy one to complete, even with full cooperation from customer and supplier. All along we have known that a good scenario-based analysis relies on domain expertise, but we learned C1 C4 C5 D3 C7 C9 C10 [1] C: init_ops <ref> [2] </ref> D: bxr_parms [3] C: invoke_bxr [4] D: get_ids [6] C: invoke_ccj [7] D: ccj_parms C1 Passive data Computation Components Active data C7 C8 C4 C6 D2 Connections Control ( ) Data ( ) Layer 1 Layer 2 Layer 3 Layer 4 12 in this exercise that there is a skill
Reference: [3] <author> Dardenne, A., </author> <title> On the Use of Scenarios in Requirements Acquisition, </title> <institution> CIS-TR-93-17, Depart 24 ment of Computer and Information Science, University of Oregon, </institution> <year> 1993. </year>
Reference-contexts: This exercise was not an easy one to complete, even with full cooperation from customer and supplier. All along we have known that a good scenario-based analysis relies on domain expertise, but we learned C1 C4 C5 D3 C7 C9 C10 [1] C: init_ops [2] D: bxr_parms <ref> [3] </ref> C: invoke_bxr [4] D: get_ids [6] C: invoke_ccj [7] D: ccj_parms C1 Passive data Computation Components Active data C7 C8 C4 C6 D2 Connections Control ( ) Data ( ) Layer 1 Layer 2 Layer 3 Layer 4 12 in this exercise that there is a skill for generating an
Reference: [4] <author> Dean, T., Cordy, </author> <title> A Syntactic Theory of Software Architecture, </title> <journal> Transactions on Software Engi neering, </journal> <volume> 21(4), </volume> <month> April </month> <year> 1995, </year> <pages> 302-313. </pages>
Reference-contexts: All along we have known that a good scenario-based analysis relies on domain expertise, but we learned C1 C4 C5 D3 C7 C9 C10 [1] C: init_ops [2] D: bxr_parms [3] C: invoke_bxr <ref> [4] </ref> D: get_ids [6] C: invoke_ccj [7] D: ccj_parms C1 Passive data Computation Components Active data C7 C8 C4 C6 D2 Connections Control ( ) Data ( ) Layer 1 Layer 2 Layer 3 Layer 4 12 in this exercise that there is a skill for generating an architectural description of
Reference: [5] <author> Dijkstra, E. W. </author> <title> The structure of the T.H.E. </title> <journal> multiprogramming system,Communications of the ACM, </journal> <volume> 18(8), </volume> <year> 1968, </year> <pages> 453-457. </pages>
Reference-contexts: Issues in software architecture are, by and large, not new. They date back at least to 1968 when Dijkstra pointed out it pays to consider how to structure a computer program, in addition to making it compute the correct answer <ref> [5] </ref>. People who build large computer-based systems have been considering the allocation of function onto configurations for a long time.
Reference: [6] <author> Garlan, D., Shaw, M. </author> <title> An Introduction to Software Architecture. Advances in Software Engineer ing and Knowledge Engineering, Volume I, </title> <publisher> World Scientific Publishing, </publisher> <year> 1993. </year>
Reference-contexts: All along we have known that a good scenario-based analysis relies on domain expertise, but we learned C1 C4 C5 D3 C7 C9 C10 [1] C: init_ops [2] D: bxr_parms [3] C: invoke_bxr [4] D: get_ids <ref> [6] </ref> C: invoke_ccj [7] D: ccj_parms C1 Passive data Computation Components Active data C7 C8 C4 C6 D2 Connections Control ( ) Data ( ) Layer 1 Layer 2 Layer 3 Layer 4 12 in this exercise that there is a skill for generating an architectural description of a large system
Reference: [7] <author> Gough, P., Fodemski, F., Higgins, S., Ray, S., </author> <title> Scenarios - an Industrial Case Study and Hyper media Enhancements, </title> <booktitle> Proceedings of the Second IEEE International Symposium on Requirements Engineering, </booktitle> <address> York, England, </address> <month> March, </month> <year> 1995, </year> <pages> 10-17. </pages>
Reference-contexts: To represent contexts, we use scenarios. 1.3 Scenarios Scenarios have been widely used and documented as a technique during requirements elicitation, especially with respect to the operator of the system ([3], <ref> [7] </ref>). They have also been widely used during design as a method of comparing design alternatives. Experience also shows that programmers use them to understand an already-built system, by asking how the system responds (component by component) to a particular input or operational situation. <p> All along we have known that a good scenario-based analysis relies on domain expertise, but we learned C1 C4 C5 D3 C7 C9 C10 [1] C: init_ops [2] D: bxr_parms [3] C: invoke_bxr [4] D: get_ids [6] C: invoke_ccj <ref> [7] </ref> D: ccj_parms C1 Passive data Computation Components Active data C7 C8 C4 C6 D2 Connections Control ( ) Data ( ) Layer 1 Layer 2 Layer 3 Layer 4 12 in this exercise that there is a skill for generating an architectural description of a large system that is clear <p> The tasks which we present here are a subset of the tasks which were elicited from the WRCS domain expert. In total we studied 15 tasks, 6 of which are presented here. A complete evaluation of a complex system would involve dozens of scenarios <ref> [7] </ref>. Component Calls ( ) Components Connections diff ctrls win31 report wrcs fmext fntext pvcs2rcs sccs2rcs hook diff bindiff nwcalls nwspxipx nwnlm mcext vbext bcext msarn200 main visdiff 17 User: 1. Compare binary file representations. Compare binary files generated by other products. <p> Direct scenarios, and their interactions are interesting only insofar as the indicate a components potential complexity. The mapping of scenarios onto the structural description serves two purposes: it aids in validating scenario interaction (a difficult process without this step, as <ref> [7] </ref> describes); and it guides the process of architectural evaluation, as we will now show. For the sake of exposition, consider the mapping of three hypothetical indirect scenarios 11, 12, and 13 22 onto a part of WRCSs architecture, as shown in Figure 10.
Reference: [8] <author> Henry, S., Kafura, D. </author> <title> Software Structure Metrics Based on Information Flow,IEEE Transac tions on Software Engineering, </title> <address> SE-7(5), </address> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: High scenario interaction reveal a poor isolation of functionality in a particular component of a design, giving a clear guideline on where to focus the designer's subsequent attention. As we shall show in section 4, the amount of scenario interaction is related to met-rics such as structural complexity <ref> [8] </ref>, coupling, and cohesion [9], and so it is likely to be strongly correlated with number of defects in the final product. Table 3 shows the number of changes required in each module of the system.
Reference: [9] <author> Heyliger, G., </author> <title> Coupling, </title> <journal> Encyclopedia of Software Engineering, J. Marciniak (ed.), </journal> <pages> 220-228. </pages>
Reference-contexts: As we shall show in section 4, the amount of scenario interaction is related to met-rics such as structural complexity [8], coupling, and cohesion <ref> [9] </ref>, and so it is likely to be strongly correlated with number of defects in the final product. Table 3 shows the number of changes required in each module of the system.
Reference: [10] <author> Jacobson, I., Christerson, M., Jonsson, P. and Overgaard, G. </author> <title> Object-Oriented Software Engineer ing: A Use Case Driven Approach. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: The solution to this problem was to create ow diagrams for each direct scenario, similar to the ow diagrams from Jacobson et al.s object-oriented use-case development method <ref> [10] </ref>. The ow diagrams were created with an existing customer-developed tool for documenting use cases. Each column in the diagram represents an architectural component. An arrow between columns represents either a ow of information (labelled D in the diagram for data connection) or a control relationship (labelled C).
Reference: [11] <author> Kazman, R., Bass, L., Abowd, G., Webb, M., SAAM: </author> <title> A Method for Analyzing the Properties of Software Architectures, </title> <booktitle> Proceedings of ICSE 16, </booktitle> <address> Sorrento, Italy, </address> <month> May </month> <year> 1994, </year> <pages> 81-90. </pages>
Reference-contexts: SAAM was originally developed to enable comparison of competing architectural solutions <ref> [11] </ref>. As a result of our experience with architectural analysis, the prescribed steps of SAAM have evolved. Not all of our experience with architectural analysis has strictly followed the method prescribed by SAAM, nor has it always been the case that we were comparing competing candidate architectures. <p> We have pursued a number of other industrial and academic case studies in scenario-based analysis as SAAM was maturing: 1. User interface development environments The first published SAAM case study comparing three academic UI development environments <ref> [11] </ref>. 2.
Reference: [12] <author> Kazman, R., Bass, L., </author> <title> Toward Deriving Software Architectures from Quality Attributes, </title> <address> CMU/ SEI-94-TR-10, </address> <institution> Software Engineering Institute, Carnegie Mellon University, </institution> <year> 1994. </year>
Reference: [13] <author> Kazman, R., Bass, L., Abowd, G., and Clements, P., </author> <title> An Architectural Analysis Case Study: Inter net Information Systems, </title> <booktitle> Proceedings, First International Workshop on Software-Intensive Systems, </booktitle> <address> Seattle, </address> <month> April </month> <year> 1995. </year> <note> (Also available as CMU-CS-TR-95-151, </note> <institution> School of Computer Sci ence, Carnegie Mellon University, Pittsburgh). </institution>
Reference-contexts: Internet information systems We have performed a full SAAM study of a collection of Internet-based information systems (WAIS, WWW, Harvest) in an attempt to understand how architectural dif ferences have evolved over the past few years and whether they have successfully supported the ex pected uses of these systems <ref> [13] </ref>. 3. Key word in context A small architectural case study first presented by Parnas and used in several places as a classic comparison of different architectural style approaches to the same problem.
Reference: [14] <author> Mettala, E., Graham, M. (eds.), </author> <title> The Domain-Specific Software Architecture Program, </title> <address> CMU/ SEI-92-SR-9, </address> <institution> Software Engineering Institute, Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: An architecture is the key artifact in achieving successful product line engineering, the disciplined structured development of a family of similar systems with less effort, expense, and risk than developing each system independently <ref> [14] </ref>. Architecture is usually the first artifact to be examined when a programmer (particularly a mainte nance programmer) unfamiliar with the system begins to work on it.
Reference: [15] <author> Parnas, </author> <title> D, On the design and development of program families, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-2(1), </volume> <year> 1976, </year> <pages> 1-9. </pages>
Reference-contexts: As the manifestation of early design decisions, the architecture represents those design decisions that are hardest to change <ref> [15] </ref> and hence are deserving of the most careful consideration. An architecture is the key artifact in achieving successful product line engineering, the disciplined structured development of a family of similar systems with less effort, expense, and risk than developing each system independently [14].
Reference: [16] <author> Parnas, D., </author> <title> On the criteria for decomposing systems into modules,Communications of the ACM, </title> <type> 15(12), </type> <month> December </month> <year> 1972, </year> <pages> 1053-1058. </pages>
Reference-contexts: We also say a high-level configuration rather than the high-level configuration, because a system can be composed of more than type of component; each decomposition will therefore have its own configuration. For instance, a system may be composed of a set of modules in the sense of Parnas <ref> [16] </ref>, and also a set of cooperating sequential processes, each of which resides in one or more modules. Both viewpoints are valid, and both are architectural in nature. But they carry different information.
Reference: [17] <editor> Shaw, M., </editor> <booktitle> Larger Scale Systems Require Higher-Level Abstractions,Proceedings of Fifth International Workshop on Software Specification and Design, IEEE Computer Society, 1989, </booktitle> <volume> 143 146. </volume>
Reference: [18] <author> Tichy, W. </author> <title> RCSA System for Version Control, </title> <journal> SoftwarePractice & Experience, </journal> <volume> 15(7), </volume> <month> July </month> <year> 1985, </year> <pages> 637-654. </pages>
Reference-contexts: Upgrade to a faster processor 4 4 Migrate to X-Window System 4 4 4 4 Table 1: Change Scenarios and their Scope 15 3.3 The WRCS System 3.3.1 System context/purpose In this section we will discuss the application of SAAM to a commercially available revision control system, based upon RCS <ref> [18] </ref>, which we will call WRCS. WRCS provides the functionality to allow developers of projects the ability to create archives, compare files, check files in and out, create releases, back up to old versions of files, and so on.
Reference: [19] <author> Weiss, D., Parnas, D., </author> <title> Active Design Reviews: </title> <booktitle> Principles and Practices, Proceedings, Eighth International Conference on Software Engineering, </booktitle> <year> 1985, </year> <pages> 132-136. </pages>
Reference-contexts: The result was a set of active design reviews <ref> [19] </ref> in which the participants were pro-active, each in his or her own area. The purpose of the change scenarios was to assess the system design against appropriate, rather than arbitrary modifications.
References-found: 19

