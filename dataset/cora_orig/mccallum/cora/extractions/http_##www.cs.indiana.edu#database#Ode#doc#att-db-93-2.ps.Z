URL: http://www.cs.indiana.edu/database/Ode/doc/att-db-93-2.ps.Z
Refering-URL: http://www.cs.indiana.edu/database/Ode/doc/
Root-URL: http://www.cs.indiana.edu
Title: THE O++ DATABASE PROGRAMMING LANGUAGE: IMPLEMENTATION AND EXPERIENCE  
Author: Rakesh Agrawal Shaul Dar Narain Gehani 
Address: San Jose, California Madison, Wisconsin Murray Hill, New Jersey  
Affiliation: IBM Almaden Research Center University of Wisconsin AT&T Bell Laboratories  
Abstract: Ode is a database system and environment based on the object paradigm. The database is defined, queried and manipulated using the database programming language O++, which is based on C++. The O++ compiler translates O++ programs into C++ programs which contain calls to the Ode object manager. The current O++ implementation provides facilities for creating and manipulating persistent objects, and for associatively accessing these objects. We describe the implementation of O++: the Ode object manager, the translation of the database facilities in O++, and our experience. C++ has emerged as the de facto standard language for software development, and database systems based on C++ have attracted much attention. We provide a detailed description of our implementation with the hope that this paper will serve as a reference for implementors of database systems based on C++. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> ``Vbase Technical Notes'', ONTOS Inc., Burlington, </institution> <address> MA, </address> <year> 1987. </year> <title> [2] ``ONTOS Object Database (Release 2.0) Data Sheet'', </title> <publisher> ONTOS, Inc., </publisher> <address> Burlington, MA, </address> <month> Nov. </month> <year> 1989. </year> <title> [3] ``Product Profile'', </title> <publisher> Versant Object Technology Co., </publisher> <address> Menlo Park, CA, </address> <year> 1990. </year> <title> [4] ``ObjectStore User Guide, Release 1.1.1 for Unix-Based Systems,'', Object Design Inc,, </title> <address> Burlington, MA, </address> <month> Sept </month> <year> 1991. </year> <title> [5] ``Objectivity/DB (Release 2.0)'', Objectivity, </title> <publisher> Inc., </publisher> <address> Menlo Park, CA, </address> <month> Sep. </month> <year> 1992. </year>
Reference-contexts: The object is also written component-wise. Volatile pointers are neither written nor read. Thus, the vtable and vbase pointers set by the new operator are not overwritten. The hidden pointer problem was also identified in Vbase <ref> [1] </ref> and E [28]. The approach taken in Vbase was to make the vtables persistent objects. In E, the compiler generates a unique type tag for every ``dbclass'' having virtual functions, and every instance of such a class contains this tag.
Reference: [6] <author> R. Agrawal and N. H. Gehani, </author> <title> ``Rationale for the Design of Persistence and Query Processing Facilities in the Database Programming Language O++'', </title> <booktitle> 2nd Int'l Workshop on Database Programming Languages, </booktitle> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: 1. INTRODUCTION Ode <ref> [6, 7, 9, 18] </ref> is a database system and environment based on the object paradigm. Ode offers one integrated data model for both database and general purpose manipulation. <p> We discuss related work in Section 6, and conclude with a summary in Section 7. - 2 - 2. A BRIEF REVIEW OF O++ We briefly review the features of O++ that have been implemented in the current version of ofront. The reader is referred to <ref> [6, 7] </ref> for complete details of O++. We assume that the reader is familiar with C++ [17]. 2.1 Creation and Manipulation of Persistent Objects The O++ object model is based on the C++ object model as defined by the class facility. Classes support data encapsulation and multiple inheritance.
Reference: [7] <author> R. Agrawal and N. H. Gehani, </author> <title> ``Ode (Object Database and Environment): The Language and the Data Model'', </title> <booktitle> Proc. ACM-SIGMOD 1989 Int'l Conf. Management of Data, </booktitle> <address> Portland, Oregon, </address> <month> May-June </month> <year> 1989, </year> <pages> 36-45. </pages>
Reference-contexts: 1. INTRODUCTION Ode <ref> [6, 7, 9, 18] </ref> is a database system and environment based on the object paradigm. Ode offers one integrated data model for both database and general purpose manipulation. <p> We discuss related work in Section 6, and conclude with a summary in Section 7. - 2 - 2. A BRIEF REVIEW OF O++ We briefly review the features of O++ that have been implemented in the current version of ofront. The reader is referred to <ref> [6, 7] </ref> for complete details of O++. We assume that the reader is familiar with C++ [17]. 2.1 Creation and Manipulation of Persistent Objects The O++ object model is based on the C++ object model as defined by the class facility. Classes support data encapsulation and multiple inheritance.
Reference: [8] <author> R. Agrawal, N. H. Gehani and J. Srinivasan, </author> <title> ``OdeView: The Graphical Interface to Ode'', </title> <booktitle> Proc. ACM-SIGMOD 1990 Int'l Conf. on Management of Data, </booktitle> <year> 1990, </year> <pages> 34-43. </pages>
Reference: [9] <author> R. Agrawal, S. J. Buroff, N. H. Gehani and D. Shasha, </author> <title> ``Object Versioning in Ode'', </title> <booktitle> Proc. IEEE 7th Int'l Conf. Data Engineering, </booktitle> <address> Tokyo, Japan, </address> <month> Feb. </month> <year> 1991. </year>
Reference-contexts: 1. INTRODUCTION Ode <ref> [6, 7, 9, 18] </ref> is a database system and environment based on the object paradigm. Ode offers one integrated data model for both database and general purpose manipulation. <p> Gehani. Continuing work on O++ includes the investigation of performance related issues, - 10 - such as optimization [24], and the incorporation of new facilities into the language. These include support for large objects, versions <ref> [9] </ref>, constraints and triggers [18]. We are also studying the use of a persistent type catalog to store information about types of objects in an Ode Database. The design of such a catalog is an interesting open research problem. 8. ACKNOWLEDGMENTS We appreciate the helpful comments of J. Richardson, J.
Reference: [10] <author> S. J. Buroff and D. Shasha, </author> <title> ``A Persistence Library for C++'', </title> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, New Jersey, </address> <year> 1989. </year>
Reference-contexts: There were three main reasons for writing the object manager in C++ instead of in C: 1. C++ would simplify the task of writing the object manager. 2. C++ programmers could use the object manager directly by calling library functions <ref> [10] </ref>. 3. Code generated by ofront to use the object manager interface would be much simpler. 5.1 Using C++ Multiple inheritance, as supported by C++, is essential for our implementation. O++ classes are transformed into C++ classes, which amongst other things, have class PersBase as a base class.
Reference: [11] <author> P. Butterworth, A. Otis and J. Stein, </author> <title> ``The GemStone Object Database Management System'', </title> <journal> Comm. ACM 34, </journal> <month> 10 (October </month> <year> 1991), </year> <pages> 64-77. </pages>
Reference-contexts: For example, here is the prototype of function member: friend int member (Set s, ...); We extract the second argument to member using the C++ variable argument mechanism, stdarg. 6. RELATED WORK Several database systems with object-oriented features have been implemented recently, including DASDBS [30], Exodus [13], Gemstone <ref> [11] </ref>, Iris [34], O 2 [16], Orion [22], Postgres [32], and Starburst [25]. New storage managers have been built to meet the needs of object-oriented database systems. Examples of such storage managers include Exodus [12], Mneme [26], and ObServer [20].
Reference: [12] <author> M. J. Carey, D. J. DeWitt, J. E. Richardson and E. J. Shekita, </author> <title> ``Storage Management for Objects in EXODUS'', in Object-Oriented Concepts and Databases, </title> <editor> W. Kim and F.H. Lochovsky (ed.), </editor> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: New storage managers have been built to meet the needs of object-oriented database systems. Examples of such storage managers include Exodus <ref> [12] </ref>, Mneme [26], and ObServer [20]. An important consideration in implementing object-oriented systems is the mechanism by which persistent objects residing on secondary storage migrate in and out of main memory during program execution. A related issue is the semantics of object ids.
Reference: [13] <author> M. J. Carey, D. J. DeWitt, G. Graefe, D. M. Haight, J. E. Richardson, D. H. Schuh, E. J. Shekita and S. L. Vandenberg, </author> <title> ``The EXODUS Extensible DBMS Project: An Overview'', in Readings in Object-Oriented Database Systems, </title> <editor> S. Zdonik and D. Maier (ed.), </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: For example, here is the prototype of function member: friend int member (Set s, ...); We extract the second argument to member using the C++ variable argument mechanism, stdarg. 6. RELATED WORK Several database systems with object-oriented features have been implemented recently, including DASDBS [30], Exodus <ref> [13] </ref>, Gemstone [11], Iris [34], O 2 [16], Orion [22], Postgres [32], and Starburst [25]. New storage managers have been built to meet the needs of object-oriented database systems. Examples of such storage managers include Exodus [12], Mneme [26], and ObServer [20].
Reference: [14] <author> W. P. Cockshot, M. P. Atkinson, K. J. Chisholm, P. J. Bailey and R. Morrison, </author> <title> ``Persistent Object Management System'', </title> <journal> Software Practice and Experience 14, </journal> <volume> 1 (1984), </volume> <pages> 49-71. </pages>
Reference-contexts: Gemstone, Orion, and ObServer, for example, use logical object ids, whereas O 2 Exodus use physical object ids. The ``object-faulting'' model for determining when to move objects from disk to main memory was pioneered by PS-Algol <ref> [14] </ref>. In this model, different formats are used for pointers to persistent and transient objects. Each pointer dereference is checked to determine the pointer format.
Reference: [15] <author> S. Dar, N. H. Gehani and H. V. Jagadish, ``CQL++: </author> <title> An SQL for a C++ Based Object-Oriented DBMS'', </title> <booktitle> Proc. of Int'l Conf. on Extending Database Technology, </booktitle> <address> Vienna, Austria, </address> <month> Mar. </month> <year> 1992. </year>
Reference: [16] <editor> O. Deux et al., </editor> <title> ``The O 2 System'', </title> <journal> Comm. ACM 34, </journal> <month> 10 (October </month> <year> 1991), </year> <pages> 34-49. </pages>
Reference-contexts: RELATED WORK Several database systems with object-oriented features have been implemented recently, including DASDBS [30], Exodus [13], Gemstone [11], Iris [34], O 2 <ref> [16] </ref>, Orion [22], Postgres [32], and Starburst [25]. New storage managers have been built to meet the needs of object-oriented database systems. Examples of such storage managers include Exodus [12], Mneme [26], and ObServer [20].
Reference: [17] <author> M. A. Ellis and B. Stroustrup, </author> <title> The Annotated C++ Reference Manual, </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Ode offers one integrated data model for both database and general purpose manipulation. The database is defined, queried, and manipulated using the database programming language O++, which is an upward-compatible extension of the object-oriented programming language C++ <ref> [17] </ref>. O++ extends C++ with capabilities suitable for database applications. It provides facilities for creating persistent and versioned objects, organizing persistent objects into clusters, defining and manipulating sets, iterating over sets and clusters, and specifying constraints and triggers. We have recently completed the implementation of the first release of O++. <p> A BRIEF REVIEW OF O++ We briefly review the features of O++ that have been implemented in the current version of ofront. The reader is referred to [6, 7] for complete details of O++. We assume that the reader is familiar with C++ <ref> [17] </ref>. 2.1 Creation and Manipulation of Persistent Objects The O++ object model is based on the C++ object model as defined by the class facility. Classes support data encapsulation and multiple inheritance. O++ visualizes memory as consisting of two parts: volatile and persistent. <p> THE ODE OBJECT MANAGER The Ode object manager provides low-level facilities for creating and manipulating persistent objects. The object manager library is implemented as a set of C++ classes. Several of these classes are designed as ``template'' (generic) classes (classes parametrized with types) <ref> [17] </ref>. Due to the unavailability of templates at the time of implementation, the object manager library uses macros to implement generic versions of these classes. The object manager views the global database as a collection of local databases called ``cluster groups''. A cluster group consists of a set of clusters.
Reference: [18] <author> N. H. Gehani and H. V. Jagadish, </author> <title> ``Ode as an Active Database: Constraints and Triggers'', </title> <booktitle> Proc. 17th Int'l Conf. Very Large Data Bases, </booktitle> <address> Barcelona, Spain, </address> <year> 1991, </year> <pages> 327-336. </pages>
Reference-contexts: 1. INTRODUCTION Ode <ref> [6, 7, 9, 18] </ref> is a database system and environment based on the object paradigm. Ode offers one integrated data model for both database and general purpose manipulation. <p> Gehani. Continuing work on O++ includes the investigation of performance related issues, - 10 - such as optimization [24], and the incorporation of new facilities into the language. These include support for large objects, versions [9], constraints and triggers <ref> [18] </ref>. We are also studying the use of a persistent type catalog to store information about types of objects in an Ode Database. The design of such a catalog is an interesting open research problem. 8. ACKNOWLEDGMENTS We appreciate the helpful comments of J. Richardson, J. Kiernan and A. Biliris.
Reference: [19] <author> A. Goldberg and D. Robson, </author> <title> Smalltalk-80: The Language and its Implementation, </title> <publisher> Addison-Wesley, </publisher> <year> 1981. </year>
Reference-contexts: A separate template class Pers is used for creating clusters of predefined types. 2. If it did, then these functions could be written once as member functions of the base class PersBase. Some object oriented languages (e.g., Smalltalk <ref> [19] </ref>) do provide this capability. In these languages, a class is itself an object of a (meta) class and an object of such a class makes type information available via its methods (member functions). 3.
Reference: [20] <author> M. F. Hornick and S. B. Zdonik, </author> <title> ``A Shared Segmented Memory System for an Object-Oriented Database'', </title> <journal> ACM Trans. Office Information Systems 5, </journal> <month> 1 (Jan. </month> <year> 1987), </year> <pages> 70-95. </pages>
Reference-contexts: New storage managers have been built to meet the needs of object-oriented database systems. Examples of such storage managers include Exodus [12], Mneme [26], and ObServer <ref> [20] </ref>. An important consideration in implementing object-oriented systems is the mechanism by which persistent objects residing on secondary storage migrate in and out of main memory during program execution. A related issue is the semantics of object ids. An object id can be ``physical'' or ``logical'' [21].
Reference: [21] <author> S. N. Khoshafian and G. P. Copeland, </author> <title> ``Object Identity'', </title> <booktitle> Proc. OOPSLA '86, </booktitle> <address> Portland, Oregon, </address> <month> Sept. </month> <year> 1986, </year> <pages> 406-416. </pages>
Reference-contexts: An important consideration in implementing object-oriented systems is the mechanism by which persistent objects residing on secondary storage migrate in and out of main memory during program execution. A related issue is the semantics of object ids. An object id can be ``physical'' or ``logical'' <ref> [21] </ref>. Logical object ids offer greater flexibility in reorganizing data on disk, but require an extra indirection step. Gemstone, Orion, and ObServer, for example, use logical object ids, whereas O 2 Exodus use physical object ids.
Reference: [22] <author> W. Kim, J. F. Garza, N. Ballou and D. Woelk, </author> <title> ``Architecture of the Orion Next Generation Database System'', </title> <journal> IEEE Trans. Knowledge and Data Engineering 2, </journal> <month> 1 (Mar. </month> <year> 1990), </year> . 
Reference-contexts: RELATED WORK Several database systems with object-oriented features have been implemented recently, including DASDBS [30], Exodus [13], Gemstone [11], Iris [34], O 2 [16], Orion <ref> [22] </ref>, Postgres [32], and Starburst [25]. New storage managers have been built to meet the needs of object-oriented database systems. Examples of such storage managers include Exodus [12], Mneme [26], and ObServer [20].
Reference: [23] <author> C. Lamb, G. Landis, J. Orenstein and D. Weinreb, </author> <title> ``The ObjectStore Database System'', </title> <journal> Comm. ACM 34, </journal> <month> 10 (October </month> <year> 1991), </year> <pages> 50-63. </pages>
Reference-contexts: The concatenation and the shields ensure that the functions synthesized by ofront for class Type will not be multiply defined. 5.2.3 Sets: Many database programming languages provide data structures not provided in the base language. For example, O++, E [28], and ObjectStore's extended C++ interface <ref> [23] </ref> provide set type constructors, which are not provided by C++. O++ sets are implemented by translating them into objects of class Set: class Set - int size; //size of an element int max; //no. elem. allocated int num; //current no. of elem. char *objects; //ptr to elements public: ... <p> An object is passivated by storing the object on disk and invalidating its memory address. Commercial C++ based object-oriented database systems have been implemented amongst others at Object Design, Objectivity, ONTOS, and Versant Object Technology <ref> [2-5, 23] </ref>. Objectivity, ONTOS, and Versant provide C++ library interfaces for application development, whereas Object Design's ObjectStore supports both library interface and a DML preprocessor interface based on cfront [4]. The DML preprocessor recognizes C++ extensions and generates C code.
Reference: [24] <author> D. G. Lieuwen and D. J. DeWitt, </author> <title> ``A Transformation-Based Approach to Optimizing Loops in Database Programming Languages'', </title> <booktitle> Proc. ACM-SIGMOD 1992 Int'l Conf. on Management of Data, </booktitle> <month> June </month> <year> 1992, </year> <pages> 91-100. </pages>
Reference-contexts: Release 1.1 of O++, implementing the core functionality of the language, can be obtained from N. Gehani. Continuing work on O++ includes the investigation of performance related issues, - 10 - such as optimization <ref> [24] </ref>, and the incorporation of new facilities into the language. These include support for large objects, versions [9], constraints and triggers [18]. We are also studying the use of a persistent type catalog to store information about types of objects in an Ode Database.
Reference: [25] <author> G. M. Lohman, B. Lindsay, H. Pirahesh and K. B. Schiefer, </author> <title> ``Extensions to Starburst: Objects, Types, Functions, and Rules'', </title> <journal> Comm. ACM 34, </journal> <month> 10 (October </month> <year> 1991), </year> <pages> 94-109. </pages>
Reference-contexts: RELATED WORK Several database systems with object-oriented features have been implemented recently, including DASDBS [30], Exodus [13], Gemstone [11], Iris [34], O 2 [16], Orion [22], Postgres [32], and Starburst <ref> [25] </ref>. New storage managers have been built to meet the needs of object-oriented database systems. Examples of such storage managers include Exodus [12], Mneme [26], and ObServer [20].
Reference: [26] <author> J. E. B. Moss, </author> <title> ``Design of the Mneme Persistent Object Store,'', </title> <address> TOIS 8, </address> <month> 2 (April </month> <year> 1990), </year> <pages> 103-139. </pages>
Reference-contexts: New storage managers have been built to meet the needs of object-oriented database systems. Examples of such storage managers include Exodus [12], Mneme <ref> [26] </ref>, and ObServer [20]. An important consideration in implementing object-oriented systems is the mechanism by which persistent objects residing on secondary storage migrate in and out of main memory during program execution. A related issue is the semantics of object ids. An object id can be ``physical'' or ``logical'' [21]. <p> Associated with the cluster group is a table that holds the disk address of every object in that cluster group. In addition, this object table stores the memory addresses of the objects currently in the buffer pool (a similar object table was used in Mneme <ref> [26] </ref>). The object number component of an object id serves as an index into the object table. An object is activated by reading the object from the disk and recording its memory address in the object table.
Reference: [27] <author> J. E. B. Moss, </author> <title> ``Working with Persistent Objects: To Swizzle or Not to Swizzle'', </title> <type> COINS Technical Report, </type> <month> May </month> <year> 1990. </year>
Reference-contexts: In this model, different formats are used for pointers to persistent and transient objects. Each pointer dereference is checked to determine the pointer format. If the pointer is in ``persistent'' format, the object is read into memory and the faulting pointer is ``swizzled'' <ref> [27, 35] </ref> to point to the memory address of the object. When an object is written back to disk, any swizzled pointers in this object are restored to the persistent format. E initially departed from this object-faulting model and used a ``load-store'' model [28].
Reference: [28] <author> J. E. Richardson and M. J. Carey, </author> <title> ``Persistence in the E Language: Issues and Implementation'', </title> <note> SoftwarePractice & Experience 19, 12 (Dec. </note> <year> 1989), </year> <pages> 1115-1150. </pages>
Reference-contexts: Commercial C++ based object-oriented database systems have been implemented amongst others at Object Design, Objectivity, ONTOS, and Versant Object Technology [2-5]. However, only sketchy details of their implementation are available. Closely related to the work presented in this paper is the implementation of the E compiler <ref> [28, 29, 31, 33] </ref>. Later in the paper, we compare our implementation approach with these and other systems. The organization of the rest of the paper is as follows. In Section 2, we briefly review O++. The object manager is described in Section 3. <p> We therefore decided to base ofront on the C++ compiler cfront, because we wanted to avoid duplicating the work done by cfront. We considered two alternative strategies for implementing the ofront: 1. Extend cfront to accept O++ and generate C code. For example, the E compiler <ref> [28] </ref> implemented at the University of Wisconsin follows this approach. 2. Extend cfront to accept O++ and modify it to generate C++ code. The first alternative would have been simpler to implement we would only need to make cfront recognize the O++ extensions and generate the appropriate code. <p> The object is also written component-wise. Volatile pointers are neither written nor read. Thus, the vtable and vbase pointers set by the new operator are not overwritten. The hidden pointer problem was also identified in Vbase [1] and E <ref> [28] </ref>. The approach taken in Vbase was to make the vtables persistent objects. In E, the compiler generates a unique type tag for every ``dbclass'' having virtual functions, and every instance of such a class contains this tag. <p> The concatenation and the shields ensure that the functions synthesized by ofront for class Type will not be multiply defined. 5.2.3 Sets: Many database programming languages provide data structures not provided in the base language. For example, O++, E <ref> [28] </ref>, and ObjectStore's extended C++ interface [23] provide set type constructors, which are not provided by C++. <p> When an object is written back to disk, any swizzled pointers in this object are restored to the persistent format. E initially departed from this object-faulting model and used a ``load-store'' model <ref> [28] </ref>. In this model, calls to the storage manager to perform I/O are scheduled by the compiler: before manipulating persistent data, the program must first load it into a buffer, and when the program terminates, it must release the buffer space.
Reference: [29] <author> J. R. Richardson, </author> <title> ``Compiled Item Faulting: A New Technique for Managing I/O in a Persistent Language'', </title> <booktitle> 4th Int'l Workshop on Persistent Object Systems, </booktitle> <address> Martha's Vineyard, MA, </address> <month> Sept </month> <year> 1990, </year> <month> 3-16.. </month>
Reference-contexts: Commercial C++ based object-oriented database systems have been implemented amongst others at Object Design, Objectivity, ONTOS, and Versant Object Technology [2-5]. However, only sketchy details of their implementation are available. Closely related to the work presented in this paper is the implementation of the E compiler <ref> [28, 29, 31, 33] </ref>. Later in the paper, we compare our implementation approach with these and other systems. The organization of the rest of the paper is as follows. In Section 2, we briefly review O++. The object manager is described in Section 3.
Reference: [30] <author> H. J. Schek, H. B. Paul, M. H. Scholl and G. Weikum, </author> <title> ``The DASDBS Project: Objectives, Experiences, and Future Prospects'', </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <month> March </month> <year> 1990, </year> <pages> 25-43. </pages>
Reference-contexts: For example, here is the prototype of function member: friend int member (Set s, ...); We extract the second argument to member using the C++ variable argument mechanism, stdarg. 6. RELATED WORK Several database systems with object-oriented features have been implemented recently, including DASDBS <ref> [30] </ref>, Exodus [13], Gemstone [11], Iris [34], O 2 [16], Orion [22], Postgres [32], and Starburst [25]. New storage managers have been built to meet the needs of object-oriented database systems. Examples of such storage managers include Exodus [12], Mneme [26], and ObServer [20].
Reference: [31] <author> D. H. Schuh, M. J. Carey and D. J. DeWitt, </author> <title> ``Persistence in E Revisited Implementation Experiences'', </title> <booktitle> Proc. 4th Int'l Workshop on Persistent Object Systems 2, </booktitle> <month> 1 (September </month> <year> 1990), </year> . 
Reference-contexts: Commercial C++ based object-oriented database systems have been implemented amongst others at Object Design, Objectivity, ONTOS, and Versant Object Technology [2-5]. However, only sketchy details of their implementation are available. Closely related to the work presented in this paper is the implementation of the E compiler <ref> [28, 29, 31, 33] </ref>. Later in the paper, we compare our implementation approach with these and other systems. The organization of the rest of the paper is as follows. In Section 2, we briefly review O++. The object manager is described in Section 3. <p> If the data has been written, the program must inform the buffer manager that the data is dirty. The current implementation of E <ref> [31] </ref> has switched to the object-faulting model. The address of a persistent object comprises a physical object id and an offset. The location of an object in main memory is stored in a data structure called ``user descriptor''.
Reference: [32] <author> M. Stonebraker and G. Kemnitz, </author> <title> ``The POSTGRES Next-Generation Database Management System'', </title> <journal> Comm. ACM 34, </journal> <month> 10 (October </month> <year> 1991), </year> <pages> 78-93. </pages>
Reference-contexts: RELATED WORK Several database systems with object-oriented features have been implemented recently, including DASDBS [30], Exodus [13], Gemstone [11], Iris [34], O 2 [16], Orion [22], Postgres <ref> [32] </ref>, and Starburst [25]. New storage managers have been built to meet the needs of object-oriented database systems. Examples of such storage managers include Exodus [12], Mneme [26], and ObServer [20].
Reference: [33] <author> S. J. White and D. J. DeWitt, </author> <title> ``A Performance Study of Alternative Object Faulting and Pointer Swizzling Strategies'', </title> <booktitle> VLDB 92, </booktitle> <address> Vancouver, BC, Canada, </address> <month> Aug. </month> <year> 1992.. </year>
Reference-contexts: Commercial C++ based object-oriented database systems have been implemented amongst others at Object Design, Objectivity, ONTOS, and Versant Object Technology [2-5]. However, only sketchy details of their implementation are available. Closely related to the work presented in this paper is the implementation of the E compiler <ref> [28, 29, 31, 33] </ref>. Later in the paper, we compare our implementation approach with these and other systems. The organization of the rest of the paper is as follows. In Section 2, we briefly review O++. The object manager is described in Section 3. <p> A limited form of pointer swizzling has been implemented by the EPVM, which avoids the double indirection for local pointer variables. A later design of object faulting and pointer swizzling in E has been presented in <ref> [33] </ref>. An O++ persistent pointer is a logical object id that contains, amongst other things, a pointer to the cluster group (database) that the object belongs to, and an object number.
Reference: [34] <author> K. Wilkinson, P. Lyngbaek and W. Hasan, </author> <title> ``The Iris Architecture and Implementation'', </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <month> March </month> <year> 1990, </year> <pages> 63-75. </pages>
Reference-contexts: RELATED WORK Several database systems with object-oriented features have been implemented recently, including DASDBS [30], Exodus [13], Gemstone [11], Iris <ref> [34] </ref>, O 2 [16], Orion [22], Postgres [32], and Starburst [25]. New storage managers have been built to meet the needs of object-oriented database systems. Examples of such storage managers include Exodus [12], Mneme [26], and ObServer [20].
Reference: [35] <author> P. R. Wilson, </author> <title> ``Pointer Swizzling at Page Fault Time: Efficiently Supporting Huge Address Spaces on Standard Hardware'', </title> <institution> University of Illinois at Chicago Technical Report UIC-EECS-90-6, </institution> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: In this model, different formats are used for pointers to persistent and transient objects. Each pointer dereference is checked to determine the pointer format. If the pointer is in ``persistent'' format, the object is read into memory and the faulting pointer is ``swizzled'' <ref> [27, 35] </ref> to point to the memory address of the object. When an object is written back to disk, any swizzled pointers in this object are restored to the persistent format. E initially departed from this object-faulting model and used a ``load-store'' model [28].
References-found: 31

