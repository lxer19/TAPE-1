URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/iwarp/archive/fx-papers/popl93.ps
Refering-URL: http://www.cs.cmu.edu/~fx/papers.html
Root-URL: 
Title: Evicted Variables and the Interaction of Global Register Allocation and Symbolic Debugging approaches to determine
Author: Ali-Reza Adl-Tabatabai and Thomas Gross 
Address: Pittsburgh, Pennsylvania 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Note: To appear in the Proceedings of POPL'93 The Twentieth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, Jan 1993, Charleston, SC  ent  
Abstract: A symbolic debugger allows a user to display the values of program variables at a breakpoint. However, problems arise if the program is translated by an optimizing compiler. This paper addresses the effects of global register allocation and assignment: a register assigned to a variable V may not be holding V 's value at a breakpoint since the register can also be assigned to other variables. We define the problem of determining whether a variable is in its assigned register as the residence problem. Prior work on debugging of optimized code has focused on the currency problem; detecting whether a variable's run-time value is the expected value. Determining residence is a more serious problem than currency detection. We present a data flow algorithm that accurately computes a variable's residency, by determining when a variable becomes evicted from its register. We measure the effectiveness of differ Supported in part by the Defense Advanced Research Projects Agency, Information Science and Technology Office, under the title Research on Parallel Computing, ARPA Order No. 7330. Work furnished in connection with this research is provided under prime contract MDA972-90-C-0035 issued by DARPA/CMO to Carnegie Mellon University. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the U.S. Government. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Adl-Tabatabai. </author> <title> Symbolic debugging of optimized C code. </title> <institution> Unpublished draft from School of Computer Science, Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: transformations complicate the retrieval of values by violating the conditions above; either a variable is inaccessible because the debugger determines the variable has no residence, or a variable is resident, but its value is noncurrent because the variable's actual value is not the same (or may not be the same <ref> [1] </ref>) as its expected value. This paper focuses on the problem of detecting nonresident variables. 2.2 Example Consider the source and object codes shown in Figure 1 (a) - (b). In this example, variable c has been assigned register r3, while d and f have both been assigned register r4. <p> Note that this moves the definition of x into different basic blocks and results in multiple source definitions. This has ramifications on the noncurrency detection algorithms which now have to address global code re-ordering <ref> [1] </ref>. If there exists a reaching definition D that is not post-dominated by S, as shown in Figure 5 (b), D cannot be considered a source definition of x. <p> Register assignments are recorded in a table that maps register assigned variables to physical registers. This information is used by our algorithms to detect nonresident and noncurrent variables (details of our algorithm for detecting noncurrent variables are described in <ref> [1] </ref>). These algorithms can be performed either in the compiler for the debugger, or in the debugger. For our experiments, these algorithms were implemented in a separate program that gathers statistics. <p> We also considered a breakpoint model where only instruction that can generate a fault are considered as breakpoints. The results for both models are close; more details can be found in <ref> [1] </ref>. Note that these models capture the state of the user program for each machine instruction in the object code and not for each source-level statement in the user program.
Reference: [2] <author> A. V. Aho, R. Sethi, and Ullman J. D. </author> <title> Compilers. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: If no definition of a user variable V reaches a point S in the source, then V is uninitialized whenever the program breaks at S. This dataflow problem is known as reaching definitions <ref> [2] </ref>. Note that the debugger cannot help in the case that definitions reach on some but not all paths to S.
Reference: [3] <author> T. Bemmerl and R. Wismueller. </author> <title> Quellcode debugging von global optimierten programmen. </title> <booktitle> Presented at 1992 Dagstuhl Seminar, </booktitle> <month> Feb. </month> <year> 1992. </year> <note> (in German). </note>
Reference-contexts: Copperman ([8], [7]), proposes a method of detecting noncurrent variables using global data flow analysis but does not consider nonresident variables. A similar approach has been proposed by Bemmerl <ref> [3] </ref>. In another work, Copperman and McDowell point out that Hennessy's model does not consider values held in registers [10]. However, they still consider the problem at the intermediate representation level without reference to registers.
Reference: [4] <author> G. Brooks, G. Hansen, and S. Simmons. </author> <title> A new approach to debugging optimized code. </title> <booktitle> In Proc. SIG-PLAN'92 Conf. on PLDI, </booktitle> <pages> pages 1-11. </pages> <publisher> ACM SIG-PLAN, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: The debugger can only inform the user that the requested variable has been optimized away (i.e., the variable is unavailable), as is done in DOC [11] and CXdb <ref> [4] </ref>. An approach to dealing with noncurrent and nonresident variables is to recover a variable's expected value from the actual values of other variables and temporaries [12]. E.g., at a breakpoint at I 5 , the debugger may infer that a's expected value is in r3. <p> With the exception of the DOC [11] and CXdb <ref> [4] </ref> debuggers, previous research has overlooked the problem of nonresident variables. Hennessy's work [12] and later refinements of Wall et. al [14] deal with detection and recovery of noncurrent variables in the presence of local optimizations and code generation using DAGs. <p> According to Copperman and McDowell [10], DOC reports a variable as inaccessible after its last use. CXdb <ref> [4] </ref> is another system that detects nonresidency using the live range approach [13]. 7 Results To compare the problems caused by nonresidency with those caused by noncurrency, and to evaluate the effectiveness of using data flow analysis, we have implemented our approach using the iWarp C compiler (pre-release version 2.7).
Reference: [5] <author> G. J. Chaitin. </author> <title> Register allocation and spilling via graph coloring. </title> <booktitle> In Proc. of the SIGPLAN 1982 Symposium on Compiler Construction, </booktitle> <pages> pages 98-105, </pages> <month> June </month> <year> 1982. </year> <journal> In SIGPLAN Notices, v. </journal> <volume> 17, </volume> <editor> n. </editor> <volume> 6. </volume>
Reference-contexts: Such values include variables, temporaries, and constants, but since we are concerned with source-level debugging, we do not mention temporaries or constants any further. Our model of register allocation is similar in style to Chaitin's <ref> [5] </ref> and is based on the optimizing compiler that we have used in our empirical studies. In our model, a variable is either promoted to a register (selected to reside in a register) or given a home location in memory. <p> Variables that have home locations in memory (including those that are spilled to memory) are always resident, since their storage locations are not shared with other variables. Register assigned variables, however, may be nonresident since a register is usually assigned to many variables. Coalescing, also known as subsumption <ref> [5] </ref>, eliminates copy operations. This optimization coalesces two variables whose live ranges do not interfere and are connected by a copy operation. <p> an in struction are related by the following data flow equation: EvictReachOut (I) = (EvictIn (I) [ EvictReachGen (I)) n EvictReachKill (I) Function calls kill the contents of caller saved registers and therefore evict all variables that are assigned caller saved registers. 5 The effects of coalescing Coalescing or subsumption <ref> [5] </ref> is an optimization that eliminates copy operations by assigning the same physical register to the source and destination operands of a copy operation. Coalescing affects debugging when the eliminated copy operation is a source definition I V (S) of a variable V .
Reference: [6] <author> F. C. Chow and J. L. Hennessy. </author> <title> A priority-based coloring approach to register allocation. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 12 </volume> <pages> 501-535, </pages> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: Register assignment binds physical registers to register promoted variables, and in our compiler, register assignment happens after instruction scheduling. A register is assigned for exclusive use by a variable during the variable's live range <ref> [6] </ref>, which consists of instruction ranges between definitions and last uses of the variable. If spilling is required during register assignment, the whole live range of a variable is spilled to memory. Loads and stores are added to the schedule to access spilled variables.
Reference: [7] <author> M. Copperman. </author> <title> Debugging optimized code: Currentness determination with data flow. </title> <booktitle> In Proc. Supercomputer Debugging Workshop '92, </booktitle> <address> Dallas, </address> <month> October </month> <year> 1992. </year> <title> Los Alamos National Laboratory. . 0.5 1.5 2.5 3.5 Number Register Promoted Variables Register assigned variables Nonresident variables, residence determined by live range Nonresident variables, residence determined by live range and reaching dataflow for uninitialized variables Nonresident variables, residence determined by dataflow for eviction Nonresident variables, residence determined by dataflow for eviction and reaching dataflow for uninitialized variables 0 4 8 12 Number Register Promoted Variables 0 2 4 6 Number Register Promoted Variables (a) (b) eqntott, and (c) espresso. </title>
Reference-contexts: However, code generators in modern compilers typically are tightly tuned to the instruction-level parallelism and storage hierarchy of the target architecture, as modern architectures rely on instruction scheduling and register allocation for performance. Copperman ([8], <ref> [7] </ref>), proposes a method of detecting noncurrent variables using global data flow analysis but does not consider nonresident variables. A similar approach has been proposed by Bemmerl [3]. In another work, Copperman and McDowell point out that Hennessy's model does not consider values held in registers [10].
Reference: [8] <author> M. Copperman. </author> <title> Debugging optimized code with out being misled. </title> <type> Technical Report 92-01, </type> <institution> UC Santa Cruz, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Section 7 reports the results of using our approach on some sample programs, and Section 8 presents our conclusions. 2 Debugging optimized code Our debugger model is the same as that used by a number of other researchers (see e.g. <ref> [8] </ref>). The debugger supports the base operations of setting control breakpoints, inspecting data, and resuming execution after a breakpoint. Control breakpoints are either synchronous, such as source level breakpoints, or asynchronous, such as program faults or user interrupts. <p> In this paper, we only address the data value problem of re trieving source level values from the run-time state of a halted program. Our work assumes that breakpoints can occur anywhere in the object code and hence applies to both synchronous and asynchronous breakpoints. See <ref> [8] </ref> or [15] for a discussion of flow related issues. 2.1 Retrieving source values In response to a query of a variable V 's value at a source breakpoint location S, the user expects the value from the latest source assignment to V , relative to S. <p> This value is the expected value of V <ref> [8] </ref>. The debugger either presents V 's expected value or detects and reports that V 's expected value cannot be presented. If a value cannot be presented, the debugger may provide additional guidance to the user by conveying how optimizations have affected source values. <p> If the debugger determines that V is accessible in a storage location, V is called resident, otherwise V is called nonresident. The storage location where V is accessible is called V 's residence, and the value in V 's residence is called V 's actual value <ref> [8] </ref>. 2. V 's actual value must be the same as V 's expected value. If V 's residence holds V 's expected value, V is called current, otherwise V is called noncurrent [12]. <p> This approach was adopted in the DOC debugger [11]. Copperman <ref> [8] </ref> gives suggestions about what information should be presented to the user. In the case of a nonresident variable, however, no actual value exists that can be presented to the user.
Reference: [9] <author> M. Copperman and C. McDowell. </author> <title> Detecting unex pected data values in optimized code. </title> <type> Technical Re port 90-56, </type> <institution> UC Santa Cruz, </institution> <month> October </month> <year> 1990. </year>
Reference: [10] <author> M. Copperman and C. McDowell. </author> <title> A further note on Hennessy's Symbolic debugging of optimized code. </title> <type> Technical Report 92-24, </type> <institution> UC Santa Cruz, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Copperman ([8], [7]), proposes a method of detecting noncurrent variables using global data flow analysis but does not consider nonresident variables. A similar approach has been proposed by Bemmerl [3]. In another work, Copperman and McDowell point out that Hennessy's model does not consider values held in registers <ref> [10] </ref>. However, they still consider the problem at the intermediate representation level without reference to registers. They suggest that allowing multiple assignments to a variable within a basic block addresses this problem. However, this does not handle the case of nonresidence caused by register re-use. <p> According to Copperman and McDowell <ref> [10] </ref>, DOC reports a variable as inaccessible after its last use.
Reference: [11] <author> D. S. Coutant, S. Meloy, and M. Ruscetta. </author> <title> Doc: A practical approach to source-level debugging of globally optimized code. </title> <booktitle> In Proc. SIGPLAN 1988 Conf. on PLDI, </booktitle> <pages> pages 125-134. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: Furthermore, a separate data flow analysis phase in the debugger for tracking a variable's run-time location significantly improves the number of variables accessible by the debugger; an overly conservative approach to tracking a variable's run-time location (as presented in <ref> [11] </ref>) misses many opportunities. The following section discusses the problem of debugging optimized code. Section 3 describes our global register allocation model. Section 4 discusses approaches to detecting nonresident variables and describes our solution. <p> This approach was adopted in the DOC debugger <ref> [11] </ref>. Copperman [8] gives suggestions about what information should be presented to the user. In the case of a nonresident variable, however, no actual value exists that can be presented to the user. <p> The debugger can only inform the user that the requested variable has been optimized away (i.e., the variable is unavailable), as is done in DOC <ref> [11] </ref> and CXdb [4]. An approach to dealing with noncurrent and nonresident variables is to recover a variable's expected value from the actual values of other variables and temporaries [12]. E.g., at a breakpoint at I 5 , the debugger may infer that a's expected value is in r3. <p> The advantage of this approach is that live range information is computed at compile time by the compiler's register assignment phase. E.g., in the DOC debugger <ref> [11] </ref>, the address ranges of instructions in a variable's live range are recorded in the range record data structure at the same time as the interference graph is built by the register assigner. <p> With the exception of the DOC <ref> [11] </ref> and CXdb [4] debuggers, previous research has overlooked the problem of nonresident variables. Hennessy's work [12] and later refinements of Wall et. al [14] deal with detection and recovery of noncurrent variables in the presence of local optimizations and code generation using DAGs. <p> However, they still consider the problem at the intermediate representation level without reference to registers. They suggest that allowing multiple assignments to a variable within a basic block addresses this problem. However, this does not handle the case of nonresidence caused by register re-use. DOC <ref> [11] </ref> is the first system that we are aware off that deals with multiple storage locations for variables. DOC tackles this problem by computing the location and currency of a variable in the compiler; this information is then passed to the debugger in range records. <p> The range of object code addresses during which a range record is valid is also specified in the record. The description in <ref> [11] </ref> states that range records of a register promoted variable span only the variable's live range but the paper does not indicate how the debugger responds to a user query of a register promoted variable at breakpoints outside of the variable's live range, e.g., at a breakpoint before the variable has
Reference: [12] <author> J. L. Hennessy. </author> <title> Symbolic debugging of optimized code. </title> <journal> ACM TOPLAS, </journal> <volume> 4(3):323 - 344, </volume> <month> July </month> <year> 1982. </year>
Reference-contexts: A symbolic debugger for optimized code must detect these values and respond appropriately to a user query. The problems encountered by a symbolic debugger of optimized code have received considerable attention in the past. Starting with Hennessy <ref> [12] </ref>, a number of studies [14,10,8,3,11] have investigated the detection and recovery of noncurrent variables, variables whose values are inconsistent with what the user expects from inspecting the source. This paper discusses a more fundamental problem that a symbolic debugger has to handle: detection of nonresident variables. <p> V 's actual value must be the same as V 's expected value. If V 's residence holds V 's expected value, V is called current, otherwise V is called noncurrent <ref> [12] </ref>. A nonresident variable does not have an actual value, hence currency can not apply to such a variable. In unoptimized code, a variable has a home location whose value always matches the variable's expected value at a breakpoint. <p> An approach to dealing with noncurrent and nonresident variables is to recover a variable's expected value from the actual values of other variables and temporaries <ref> [12] </ref>. E.g., at a breakpoint at I 5 , the debugger may infer that a's expected value is in r3. Recovering values in globally optimized code is difficult (see [12] for a discussion of the scenarios when recovery can be attempted), and the effectiveness of recovery in practice is unknown. 2.4 <p> with noncurrent and nonresident variables is to recover a variable's expected value from the actual values of other variables and temporaries <ref> [12] </ref>. E.g., at a breakpoint at I 5 , the debugger may infer that a's expected value is in r3. Recovering values in globally optimized code is difficult (see [12] for a discussion of the scenarios when recovery can be attempted), and the effectiveness of recovery in practice is unknown. 2.4 Uninitialized variables When the user inspects a variable, the variable's expected value may be immaterial because the variable has not been initialized during the execution of the program. <p> With the exception of the DOC [11] and CXdb [4] debuggers, previous research has overlooked the problem of nonresident variables. Hennessy's work <ref> [12] </ref> and later refinements of Wall et. al [14] deal with detection and recovery of noncurrent variables in the presence of local optimizations and code generation using DAGs. The model of [12] assumes that all variables have home locations in memory and does not consider values held in registers. <p> Hennessy's work <ref> [12] </ref> and later refinements of Wall et. al [14] deal with detection and recovery of noncurrent variables in the presence of local optimizations and code generation using DAGs. The model of [12] assumes that all variables have home locations in memory and does not consider values held in registers.
Reference: [13] <author> S. Simmons. </author> <type> Personal communication. </type> <year> 1992. </year>
Reference-contexts: According to Copperman and McDowell [10], DOC reports a variable as inaccessible after its last use. CXdb [4] is another system that detects nonresidency using the live range approach <ref> [13] </ref>. 7 Results To compare the problems caused by nonresidency with those caused by noncurrency, and to evaluate the effectiveness of using data flow analysis, we have implemented our approach using the iWarp C compiler (pre-release version 2.7).
Reference: [14] <author> D. Wall, A. Srivastava, and F. Templin. </author> <title> A note on Hennessy's Symbolic debugging of optimized code. </title> <journal> ACM TOPLAS, </journal> <volume> 7(1) </volume> <pages> 176-181, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: With the exception of the DOC [11] and CXdb [4] debuggers, previous research has overlooked the problem of nonresident variables. Hennessy's work [12] and later refinements of Wall et. al <ref> [14] </ref> deal with detection and recovery of noncurrent variables in the presence of local optimizations and code generation using DAGs. The model of [12] assumes that all variables have home locations in memory and does not consider values held in registers.
Reference: [15] <author> P. Zellweger. </author> <title> An interactive high-level debugger for control-flow optimized programs. </title> <booktitle> In Proc. of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging, </booktitle> <pages> pages 159 171. </pages> <publisher> ACM, </publisher> <year> 1983. </year>
Reference-contexts: Our model does not allow the compiler to insert extra code to make debugging easier. For example, the compiler does not insert path determiners <ref> [15] </ref> into the object to determine the execution path leading to a breakpoint, even though such knowledge allows the debugger to perform better analysis while retrieving source values. <p> In this paper, we only address the data value problem of re trieving source level values from the run-time state of a halted program. Our work assumes that breakpoints can occur anywhere in the object code and hence applies to both synchronous and asynchronous breakpoints. See [8] or <ref> [15] </ref> for a discussion of flow related issues. 2.1 Retrieving source values In response to a query of a variable V 's value at a source breakpoint location S, the user expects the value from the latest source assignment to V , relative to S. <p> Detecting and reporting uninitialized variables can reduce the number of variables that are reported as nonresident or noncurrent and provides additional information to the user. In the absence of support provided by the run-time system (e.g., path determiners <ref> [15] </ref>) or the architecture (e.g., memory tags), detecting uninitialized variables requires that the debugger obtains program flow analysis information from the compiler. If no definition of a user variable V reaches a point S in the source, then V is uninitialized whenever the program breaks at S.
Reference: [16] <author> P. Zellweger. </author> <title> Interactive Source-Level Debugging of Optimized Programs. </title> <type> PhD thesis, </type> <institution> University of Cal ifornia, Berkeley, </institution> <month> May </month> <year> 1984. </year> <note> Published as Xerox PARC Technical Report CSL-84-5. </note>
Reference-contexts: Problems related to the former are known as code location problems, while those related to the latter are known as data value problems <ref> [16] </ref>. In this paper, we only address the data value problem of re trieving source level values from the run-time state of a halted program. Our work assumes that breakpoints can occur anywhere in the object code and hence applies to both synchronous and asynchronous breakpoints. <p> If a value cannot be presented, the debugger may provide additional guidance to the user by conveying how optimizations have affected source values. Thus we assume the debugger exhibits truthful <ref> [16] </ref>. A variable's expected value is not always retrievable from the run-time state of an optimized program. Two conditions must be satisfied to retrieve a variable V 's expected value at a breakpoint: 1.
References-found: 16

