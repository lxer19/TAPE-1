URL: ftp://ftp.cs.dartmouth.edu/TR/TR96-287.ps.Z
Refering-URL: http://www.cs.dartmouth.edu/reports/abstracts/TR96-287/
Root-URL: http://www.cs.dartmouth.edu
Title: Implementation and Analysis of Software Based Fault Isolation  
Author: Scott M. Silver 
Keyword: Senior Honors Thesis  
Affiliation: Dartmouth College  
Abstract: Dartmouth Computer Science Technical Report PCS-TR96-287 June 1996 Abstract Extensible applications rely upon user-supplied, untrusted modules to extend their functionality. To remain reliable, applications must isolate themselves from user modules. One method places each user module in a separate address space (process), which uses hardware virtual memory support to isolate the user process. Costly inter-process communication, however, prohibits frequent communication between the application and the untrusted module. We implemented and analyzed a software method for isolating an application from user modules. The technique uses a single address space. We provide a logical address space and per-module access to system resources for each module. Our software technique is a two-step process. First, we augment a modules code so that it cannot access any address outside of an assigned range. Second, we prevent the module from using system calls to access resources outside of its fault domain. This method for software isolation has two particular advantages over processes. First, for frequently communicating modules, we significantly reduce context switch time. Thus, we demonstrate near-optimal inter-module communication using software fault isolation. Second, our software-based techniques provide an efficient and expedient solution in situations where only one address space is available (e.g., kernel, or a single address-space operating system). This document was created with FrameMaker 4.0.4 
Abstract-found: 1
Intro-found: 1
Reference: <institution> Implementation and Analysis of Software Based Fault Isolation 10.0 References </institution>
Reference: [adl-t:omnimobile] <author> Ali-Reza Adl-Tabatabai, Geoff Langdale, Steven Lucco, and Robert Wahbe. </author> <title> Efficient Language-Independent Mobile Programs. </title> <booktitle> PLDI: ACM SIGPLAN Conference on Programming Languages, Design and Implementation May 1996. </booktitle>
Reference: [aburto:bench] <author> Al Aburto. </author> <title> Benchmark suite. </title> <publisher> &lt;ftp:// ftp.nosc.mil/pub/aburto&gt; </publisher>
Reference-contexts: The value for sandboxing overhead includes the the reserved register overhead. Positive values indicate that the benchmark ran slower. In general, oating point benchmarks slowed down less than integer benchmarks. We used Al Aburtos set of widely used benchmarks <ref> [aburto:bench] </ref>. Table 1 contains various anomalies. For example, flops1 reports that the sandboxed version was actually 7.58% faster than non-sandboxed code. In many cases the code with a reduced register executed faster than the normal code. In each of these cases the result was nominal and not statistically significant.
Reference: [bershad:lrpc] <author> Brian Bershad, Thomas Anderson, Edward Lazowska, and Henry Levy. </author> <title> Lightweight Remote Procedure Call. </title> <journal> ACM Transactions on Computer Systems , 8(1), </journal> <month> February </month> <year> 1990. </year>
Reference-contexts: An RPC requires: copying arguments from caller to callee, a trap into the kernel, a context switch, copying the return value, and another context switch. Even the fastest RPC is several orders of magnitude slower than a function call <ref> [bershad:lrpc] </ref>. In this paper, we explore recent methods for creating and maintaining software-enforced fault domains [wahbe:sfi]. We remove the requirement for separate address spaces by creating logical fault domains within a single address space provided by a single process. <p> Many researchers have tried to increase RPC performance <ref> [bershad:lrpc, birrel:rpc] </ref>. RPCs are bound by the hardware limit of two context switches, and two kernel traps. Implementations such as LRPC have approached the hardware limit, thus suggesting another method for performing RPC [bershad:lrpc]. <p> Many researchers have tried to increase RPC performance [bershad:lrpc, birrel:rpc]. RPCs are bound by the hardware limit of two context switches, and two kernel traps. Implementations such as LRPC have approached the hardware limit, thus suggesting another method for performing RPC <ref> [bershad:lrpc] </ref>. Some operating systems use type safe languages, trusted compilers and trusted linkers to make untrusted modules secure [bershad:spin]. For example, SPIN uses a type safe language for modules linked into the kernel.
Reference: [bershad:spin] <author> Brian N. Bershad, Craig Chambers, Susan Egg-ers, Chris Maeda, Dylan McNamee, Przemys law Pardyak, Stefan Savage, and Emin Gun Sirer. </author> <title> SPIN: An extensible microkernel for application-specific operating system services. </title> <booktitle> ACM Operating Systems Review January 1995. </booktitle>
Reference-contexts: Another method involves creating a trusted compiler that cryptographically signs the sandboxed module with a private key. Since the public key of the compiler is known, authentication will only succeed if the module has not been modified. This method is used in the SPIN operating system <ref> [bershad:spin] </ref>. By using public key encryption and a compiler to sandbox a module, it is easier to create a more platform-independent sandboxer. A sandboxer created by modifying a compiler also makes it possible to use later optimization stages of the compiler. <p> RPCs are bound by the hardware limit of two context switches, and two kernel traps. Implementations such as LRPC have approached the hardware limit, thus suggesting another method for performing RPC [bershad:lrpc]. Some operating systems use type safe languages, trusted compilers and trusted linkers to make untrusted modules secure <ref> [bershad:spin] </ref>. For example, SPIN uses a type safe language for modules linked into the kernel. Although this adequately protects the kernel, and provides good performance, it limits the extension of the operating system to languages not normally used for operating system development (such as Modula-3).
Reference: [bershad:spin2] <author> Brian Bershad, Stefan Savage, Przemyslaw Par-dyak, Emin Gun Sirer, Marc E. Fiuczynski, David Becker, Craig Chambers, and Susan Egg-ers. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles , December 1995. </booktitle>
Reference: [birrell:rpc] <author> Andrew D. Birrell and Bruce Jay Nelson. </author> <title> Implementing remote procedure calls. </title> <note> ACM Transactions on Computer Systems February 1984. </note>
Reference: [colusa:omniware] <author> Colusa Software. </author> <title> Colusa Software White Paper. Omniware: A Universal Substrate for Mobile Code </title>
Reference: [digital:proc] <author> Digital Equipment Corporation. </author> <title> Digital Unix 3.2 /proc Manual Page. References Implementation and Analysis of Software Based Fault Isolation </title>
Reference: [engler:exokernel] <author> Dawson R. Engler, M. Frans Kaashoek, and James W. O'Toole Jr. Exokernel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles , December 1995. </booktitle>
Reference-contexts: Although this adequately protects the kernel, and provides good performance, it limits the extension of the operating system to languages not normally used for operating system development (such as Modula-3). In addition, many other researchers are working on extensible operating systems <ref> [osdi:panel, engler:exokernel, seltzer:case] </ref>. The Omniware system compiles source files to its own Omniware virtual machine (OmniwareVM) and runtime [colusa:omniware, adl-t:omnimo Conclusion Implementation and Analysis of Software Based Fault Isolation bile].
Reference: [garfinkel:pgp] <author> Simson Garfinkel. PGP: Pretty Good Privacy OReilly & Associates, </author> <month> March </month> <year> 1995. </year>
Reference-contexts: To sign modules, we need to augment our trusted compiler to use a public key encryption system such as <ref> [garfinkel:pgp] </ref>. The method of using procfs to trap system calls requires an extra con text switch for each system call. This is not necessary if we modify the untrusted module to call RPCs in place of system calls.
Reference: [gosling:java] <author> James Gosling and Henry McGilton. </author> <title> The Java language: A white paper .. Sun Microsystems, </title> <year> 1994. </year>
Reference: [hpp:blackw] <institution> Home Page Press, Inc. http://www.hpp.com. Black Widows - Sun Declares War. </institution>
Reference: [may:powerpc] <author> Cathy May, Ed Silha, Rick Simpson, and Hank Warren. </author> <title> The PowerPC Architecture: A Specification for a New Family of RISC Processors Morgan Kaufmann Publishers, </title> <publisher> Inc., </publisher> <year> 1994. </year>
Reference-contexts: Unfortunately many platforms that support direct addressing limit the number of bits available for the direct jump (because it is assembled into the instruction), thus limiting the distance in memory of the RPC sending stub from the target RPC receiving stub <ref> [may:powerpc] </ref>. To gain the full range of addressable memory on a given CPU or if the given CPU does not support direct jumps or branches, another technique is necessary. The technique has two pieces. First, we require a jump table.
Reference: [mccaine:packet] <author> Steven McCanne and Van Jacobsen. </author> <title> The BSD Packet Filter: A New Architecture for User-Level Packet Capture. </title> <booktitle> In Proceedings of the 1993 Winter USENIX Conference , January 1993. </booktitle>
Reference: [moto:68k] <author> Motorola Inc. </author> <title> Programmers Reference Manual. </title>
Reference-contexts: On other platforms various CPU specific instructions must also be protected. For example, on a 68000 running MacOS, both the A-line and F-line exception handlers must be rerouted through an access controlling function. A-line and F-line instructions provide access to operating system services <ref> [moto:68k] </ref>. Multiple fault domains existing in one address space allows for near-optimal RPC performance. An RPC is a transfer of control from one fault domain to another.
Reference: [osdi:panel] <author> Panel: </author> <title> Radical Operating Systems Structures For Extensibility. </title> <booktitle> In Proceedings of the USENIX Association, First Symposium on Operating Systems Design and Implementation 1994. </booktitle>
Reference-contexts: Although this adequately protects the kernel, and provides good performance, it limits the extension of the operating system to languages not normally used for operating system development (such as Modula-3). In addition, many other researchers are working on extensible operating systems <ref> [osdi:panel, engler:exokernel, seltzer:case] </ref>. The Omniware system compiles source files to its own Omniware virtual machine (OmniwareVM) and runtime [colusa:omniware, adl-t:omnimo Conclusion Implementation and Analysis of Software Based Fault Isolation bile].
Reference: [seltzer:case] <author> Margo Seltzer, Chris Small, and Keith Smith. </author> <title> The case for extensible operating systems. </title> <type> Technical Report TR-16-95, </type> <institution> Harvard University 1995. </institution>
Reference-contexts: Although this adequately protects the kernel, and provides good performance, it limits the extension of the operating system to languages not normally used for operating system development (such as Modula-3). In addition, many other researchers are working on extensible operating systems <ref> [osdi:panel, engler:exokernel, seltzer:case] </ref>. The Omniware system compiles source files to its own Omniware virtual machine (OmniwareVM) and runtime [colusa:omniware, adl-t:omnimo Conclusion Implementation and Analysis of Software Based Fault Isolation bile].
Reference: [sgi:proc] <institution> Silicon Graphics. </institution> <note> IRIX 5.3 /proc Manual Page. </note>
Reference-contexts: It is the most system dependent piece of the fault-isolation system. There are two main pieces to the runtime. First, we need a method to trap system calls and modify an untrusted modules memory. Our solution uses the /proc file sys tem <ref> [dig:proc, sgi:proc] </ref>. The /proc file system provides exclusive access to an untrusted modules memory, and also allows the trapping of its system calls. We leverage our system on top of the system runtime shared object services (i.e., shared libraries).
Reference: [sites:alpha] <author> Richard L. </author> <title> Sites. Alpha Architecture Reference Manual . Digital Press, 1992. References Implementation and Analysis of Software Based Fault Isolation </title>
Reference: [stall:gcc] <author> Richard Stallman. </author> <title> GCC Users and Programmers Manual . Free Software Foundation, </title> <year> 1995 </year>
Reference: [wahbe:sfi] <author> Robert Wahbe, Steven Lucco, Thomas E. Anderson, and Susan L. Graham. </author> <title> Efficient Software-Based Fault Isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles , pages 203-216, </booktitle> <year> 1993. </year>
Reference-contexts: Using multiple processes for multiple untrusted modules often yields unacceptable performance for frequently communicating modules, due to the high cost of inter-process communication and context switches. In addition, inter-process control transfer which is inherent in most process communication, does not necessarily scale with a processors integer performance <ref> [wahbe:sfi] </ref>. The cost of an RPC for frequently communicating domains is prohibitive. An RPC requires: copying arguments from caller to callee, a trap into the kernel, a context switch, copying the return value, and another context switch. <p> Even the fastest RPC is several orders of magnitude slower than a function call [bershad:lrpc]. In this paper, we explore recent methods for creating and maintaining software-enforced fault domains <ref> [wahbe:sfi] </ref>. We remove the requirement for separate address spaces by creating logical fault domains within a single address space provided by a single process. On a UNIX-like operating system, two sets of resources need to be pro tected: memory and everything else. <p> To reduce the complexity of the check, we restrict the domain of the target address to a contiguous segment of memory. Thus, in a simple implementation, we need two extra variables to either hold fence posts of the segment or base and bounds addresses. nique is called segment matching <ref> [wahbe:sfi] </ref>. Notice that this technique requires 4 instructions. FIGURE 3. Pseudo code for segment matching. We compare the address contained in the target register (r0), to beginning and end of the segment (contained in rBeginning and rEnd). <p> This technique is called sandboxing <ref> [wahbe:sfi] </ref> segment the top bits of all addresses, called the segment identifier, are constant. If we simply set the top bits of each target address to the segment identifier we guarantee that the address must be in that segment. <p> The total reserved register count is 5: one dedicated code register, one dedicated data register, one clear segment mask, one set code segment mask, and one set data segment mask. The result of reserving 5 registers on a RISC architecture with at least 32 registers is marginal <ref> [wahbe:sfi] </ref>. On older CISC architectures, however, such as the Intel x86 with only 8 general-purpose registers, the penalty might be too great. A module can be sandboxed at runtime or at compile time. If the module is sandboxed at runtime, then the sandboxer can be highly architecture dependent. <p> At load time, we simply verify the signature of the compiler and execute the module. Wahbe et. al. present a method for verification at runtime <ref> [wahbe:sfi] </ref>. 4.0 Implementation The current implementation of our software-based fault isolation system is designed for the DEC Alpha under Digital Unix 3.2 (formerly OSF). The primary goal of this design is to explore the possibility of a portable sandboxer and runtime. We implemented two versions. <p> Each RPC took no arguments and returned no value. For comparison, we compared the execution time for void function calls determined by Wahbe, et al <ref> [wahbe:sfi] </ref>. Function performance performance provides a lower bound on the performance of an RPC. In addition, we timed the round trip cost of sending a byte between two processes using the pipe mechanism. <p> single address space operating systems such as the MacOS, (3) extensible applications, such as databases, which require user modules to handle user defined types (on UNIX-type operating systems). 7.0 Related Work Much of the original theory presented in this paper was created by Robert Wahbe, et. al. in their paper <ref> [wahbe:sfi] </ref>. Many researchers have tried to increase RPC performance [bershad:lrpc, birrel:rpc]. RPCs are bound by the hardware limit of two context switches, and two kernel traps. Implementations such as LRPC have approached the hardware limit, thus suggesting another method for performing RPC [bershad:lrpc].
References-found: 22

