URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-94-2-2.ps.Z
Refering-URL: http://www.cs.man.ac.uk/cstechrep/Abstracts/UMCS-94-2-2.html
Root-URL: http://www.cs.man.ac.uk
Title: Accelerated Ray Tracing on the KSR1 Virtual Shared-Memory Parallel Computer  
Author: M.J. Keates R.J. Hubbold 
Affiliation: Computer Science University of Manchester  
Pubnum: Technical Report UMCS-94-2-2  
Abstract-found: 0
Intro-found: 1
Reference: [Badouel90] <author> Didier Badouel, Kadi Bouatouch and Thierry Priol, </author> <title> Ray Tracing on Distributed Memory Parallel Computers: Strategies for Distributing Computations and Data, </title> <booktitle> Course Notes for Course 28, ACM Siggraph, </booktitle> <year> 1990, </year> <pages> pp. 185-198. </pages>
Reference-contexts: A comprehensive list of references on ray tracing, including acceleration methods and parallel processing can be found in [Speer92] and a good overview of ray tracing on parallel computers has been published by Badouel et al <ref> [Badouel90] </ref>. 2.1 Acceleration techniques The main techniques for accelerating ray tracing capitalise on the property of spatial coherence. Most of them use some kind of spatial subdivision, in which data structures are built to represent regions of the scene.
Reference: [Badouel92] <author> Didier Badouel and Thierry Priol, </author> <title> An Efficient Parallel Ray Tracing Scheme for Highly Parallel Architectures, Advances in Computer Graphics, R.L. </title> <editor> Grimsdale and A. Kaufman (Eds), </editor> <publisher> Springer-Verlag, </publisher> <year> 1992, </year> <pages> pp. 93-106. </pages>
Reference-contexts: After an initial data transfer has taken place, subsequent neighbouring rays, processed on the same processor, can access the same data without any further transfers. A generalisation of this approach was used by Badouel et al <ref> [Badouel92] </ref>, who implemented a virtual shared-memory management system, in software, for a distributed-memory, 64-processor Intel iPSC2. Their results are the best we have seen reported for such machines.
Reference: [Cleary86] <author> Cleary J. G., Wyvill B. M., Birtwistle G. M. and Vatti R., </author> <title> Multiprocessor Ray Tracing, </title> <journal> Computer Graphics Forum, </journal> <volume> 5 (1), </volume> <year> 1986, </year> <pages> pp. 3-12. </pages>
Reference-contexts: For example, for anti-aliased images output to film it is common to trace many millions of primary rays, leading to tens of millions of rays in total. Static partitioning schemes also frequently exhibit poor load balancing due to the different amounts of computation performed by each processor <ref> [Cleary86] </ref>, [Kobayashi88]. An alternative to static scheduling is dynamic parallelism, where the work of the processors is adjusted dynamically to improve load balance. The commonest approach to dynamic load balancing is to use a processor farm.
Reference: [Cleary88] <author> Cleary J. G. and Wyvill G., </author> <title> Analysis of an Algorithm for Fast Ray Tracing Using Uniform Space Subdivision, </title> <journal> The Visual Computer, </journal> <volume> 4 (2), </volume> <year> 1988, </year> <pages> pp. 65-83. </pages>
Reference-contexts: This is normally a simple incremental algorithm based on digital differential analyser (DDA) principles, or a variant of Bresenham's line drawing algorithm, and can therefore be made fast <ref> [Cleary88] </ref>. The major advantage of the whole approach is its simplicity. Its disadvantages are that the gridcell data structure grows rapidly as the cell size reduces, and the data structure is poorly balanced for models which have uneven spatial distribution.
Reference: [Dippe84] <author> Dippe M. and Swensen J., </author> <title> An Adaptive Subdivision Algorithm and Parallel Architecture for Realistic Image Synthesis, </title> <booktitle> ACM Computer Graphics 18 (3), </booktitle> <month> July </month> <year> 1984, </year> <pages> pp. 149-158. </pages>
Reference-contexts: An alternative subdivision scheme uses non-equally sized sub-regions, which is slightly more complicated to implement and has largely been superseded by the next technique <ref> [Dippe84] </ref>. 3 Hierarchical bounding volumes are constructed by creating a bounding volume for each ob-ject in a scene, and then clustering these volumes to form a tree data structure [Kay86].
Reference: [Fuchs80] <author> Fuchs H., </author> <title> On Visible Surface Generation by A Priori Tree Structure, </title> <booktitle> ACM Computer Graphics 14 (3), </booktitle> <month> July </month> <year> 1980, </year> <pages> pp. 124-133. </pages>
Reference-contexts: Objects which are cut by a plane must be subdivided into parts lying on each side of the plane. This method is not widely used for ray tracing, but has proved popular for hidden surface removal and geometric modelling <ref> [Fuchs80] </ref>. The application of acceleration techniques leads to a dramatic improvement in performance.
Reference: [Fujimoto86] <author> Fujimoto A., Tanaka T. and Iwata K., </author> <title> ARTS : Accelerated Ray Tracing System, </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 6 (4), </volume> <year> 1986, </year> <pages> pp. 16-26. </pages>
Reference-contexts: Since we are generally interested in the closest intersection to the ray origin, this checking is best done in depth order along the ray. Four main variants exist: Uniform subdivision (or gridcell) in which the total model space is subdivided into a regular 3D grid of cells <ref> [Fujimoto86] </ref>. For each cell, a list of objects which intersect the cell is built, and a ray traversal algorithm is employed to work out which cells are intersected by the current ray. <p> Octtree subdivision attempts to overcome the last problem namely the potentially large size of the data structures, and poor spatial distribution by recursively subdividing the model space, usually by binary division in each dimension [Glassner84], <ref> [Fujimoto86] </ref>, [Spackman90]. Starting with the whole model space, subdivision continues until some minimum number of objects remain in each sub-region, or some number of levels of recursion is reached.
Reference: [Frank93] <author> Frank S., Burkhardt III H. and Rothnie J., </author> <title> The KSR1: Bridging the gap between shared memory and MPPs, </title> <booktitle> Proceedings Compcon '93, IEEE, </booktitle> <month> February </month> <year> 1993, </year> <pages> pp. 285-294. </pages>
Reference-contexts: In the next section we describe the machine we have used in an attempt to avoid these problems. 3 The Kendall Square Research KSR1 3.1 KSR1 architecture The KSR1 is a distributed-memory parallel computer whose hardware supports a shared-memory programming model <ref> [Frank93] </ref>. This shared view of memory is implemented via a paged, virtual-memory addressing scheme. Because the novel memory management lies at the heart of the architecture, the processing elements (PEs) of the KSR1 are custom-designed.
Reference: [Glassner84] <author> Glassner A. S., </author> <title> Space Subdivision for Fast Ray Tracing, </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 4 (10), </volume> <year> 1984, </year> <pages> pp. 15-22. </pages>
Reference-contexts: Octtree subdivision attempts to overcome the last problem namely the potentially large size of the data structures, and poor spatial distribution by recursively subdividing the model space, usually by binary division in each dimension <ref> [Glassner84] </ref>, [Fujimoto86], [Spackman90]. Starting with the whole model space, subdivision continues until some minimum number of objects remain in each sub-region, or some number of levels of recursion is reached.
Reference: [Goldsmith87] <author> Goldsmith J. and Salmon J., </author> <title> Automatic Creation of Object Hierarchies for Ray Tracing, </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 7 (5), </volume> <year> 1987, </year> <pages> pp. 14-20. </pages>
Reference-contexts: The preprocessing step needed to construct bounding boxes and to cluster them to build the tree can be time consuming and the ray/box intersection tests are more expensive than the ray traversal algorithms of the gridcell and octtree methods <ref> [Goldsmith87] </ref>. Binary space partitioning (BSP) is another hierarchical subdivison method in which the space occupied by the model is divided by a plane. Objects are then tagged according to which side of the plane they lie on.
Reference: [Green91] <author> Stuart Green, </author> <title> Parallel Processing for Computer Graphics, </title> <publisher> Pitman, </publisher> <year> 1991. </year>
Reference-contexts: In practice, this method leads to quite a large amount of message passing, which eventually limits its performance. A more general approach was devised by Green, based on a caching scheme for model data <ref> [Green91] </ref>. Here, parts of the model are passed between processors upon demand. The method capitalises on the coherency of neighbouring rays, which frequently intersect the same objects.
Reference: [Haines87] <author> Haines E. A., </author> <title> A Proposal for Standard Graphics Environments, </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 7 (11), </volume> <year> 1987, </year> <pages> pp. 3-5. </pages>
Reference-contexts: The ray tracer supports polygons and quadrics with cutting planes. It has an object-oriented structure which permits new classes of primitives and associated methods to be added easily. Model data is read from standard input, normally in the NFF format <ref> [Haines87] </ref>, although other formats are also supported. The acceleration technique we chose was the regular gridcell. The main reasons for this choice were: It is simple to implement.
Reference: [Kay86] <author> Kay T. L. and Kajiya J. T., </author> <title> Ray Tracing Complex Scenes, </title> <journal> Computer Graphics, </journal> <volume> 13 (2), </volume> <year> 1986, </year> <pages> pp. 158-64. </pages>
Reference-contexts: scheme uses non-equally sized sub-regions, which is slightly more complicated to implement and has largely been superseded by the next technique [Dippe84]. 3 Hierarchical bounding volumes are constructed by creating a bounding volume for each ob-ject in a scene, and then clustering these volumes to form a tree data structure <ref> [Kay86] </ref>. This approach is popular, because it has the hierarchical advantages of the octtree method it is good at representing models with large variations in local complexity with the added advantage that the subdivisions in the structure are tailored to the objects in the scene.
Reference: [Kobayashi88] <author> Kobayashi H., Nishimura S., Kubota H., Nakamura T. and Shigei Y., </author> <title> Load Balancing Strategies for a Parallel Ray Tracing System Based on Constant Subdivision, </title> <journal> The Visual Computer, </journal> <volume> 4 (4), </volume> <year> 1988, </year> <pages> pp. 197-209. 21 </pages>
Reference-contexts: For example, for anti-aliased images output to film it is common to trace many millions of primary rays, leading to tens of millions of rays in total. Static partitioning schemes also frequently exhibit poor load balancing due to the different amounts of computation performed by each processor [Cleary86], <ref> [Kobayashi88] </ref>. An alternative to static scheduling is dynamic parallelism, where the work of the processors is adjusted dynamically to improve load balance. The commonest approach to dynamic load balancing is to use a processor farm.
Reference: [Kolb91] <author> Kolb Craig E., </author> <title> Rayshade User's Guide and Reference Manual, </title> <institution> Yale University, Department of Mathematics, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: We have used these facilities to analyse the behaviour of our ray tracer. 4 The KRT ray tracer The ray tracer is called KRT (KSR Ray Tracer), and is written in C. Rather than use a public domain program such as Rayshade <ref> [Kolb91] </ref>, we decided to use our own code, as we could design and adapt this more readily to suit the KSR1's architecture. The ray tracer supports polygons and quadrics with cutting planes. It has an object-oriented structure which permits new classes of primitives and associated methods to be added easily.
Reference: [Muller91] <author> Muller S., </author> <title> A Parallelised Intersection Calculation for Radiosity and Ray Tracing, </title> <institution> Fraunhofer Institut fur Graphische Datenverarbeitung, </institution> <type> Darmstadt Technical Report, </type> <year> 1992. </year>
Reference-contexts: One approach to data distribution is to use the hierarchical bounding volume technique to subdivide the model space, and then to distribute the resulting tree data structure across the available processors [Scherson88], <ref> [Muller91] </ref>. The tree is divided into upper and lower levels, 5 with the upper-level nodes distributed to all processors and sub-branches of the lower levels distributed uniformly across the processors. Clearly there is a relationship here between the topology of the tree and the number of processors available. <p> It is worth noting that the shared-memory programming paradigm of the KSR makes recursive algorithms very easy to implement; this can be far from the case for message passing machines using large models <ref> [Muller91] </ref>. The single processor time on the KSR1 is between three and four times that of the HP for most scenes. The HP is nominally rated at 76.7 MIPS and 23.7 Mflops, whilst the KSR1 peak figures are 20 and 40 respectively.
Reference: [Nieh92] <author> Nieh J. and Levoy M., </author> <title> Volume Rendering on Scalable Shared-Memory MIMD Architectures, </title> <booktitle> Proc. ACM Workshop on Volume Visualization, </booktitle> <year> 1992, </year> <pages> pp. 17-24. </pages>
Reference-contexts: It is interesting to note that the modified processor farm algorithm which we are proposing is very similar to one used by Nieh and Levoy for volume rendering on the DASH machine <ref> [Nieh92] </ref>. In fact, our approach was devised independently, and for different reasons. Nieh and Levoy used it as a way to minimise dynamic data communication; we are using it to avoid shared variable contention.
Reference: [Plunkett85] <author> Plunkett D. J. and Bailey M. J., </author> <title> The Vectorization of a Ray Tracing Algorithm for Improved Execution Speed, </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 5 (8), </volume> <year> 1985, </year> <pages> pp. 52-60. </pages>
Reference-contexts: Unfortunately, because the same instructions must be executed by every processor, it is very difficult to use acceleration methods, making this type of architecture unattractive <ref> [Plunkett85] </ref>. On multiple instruction/multiple data (MIMD) architectures, there is considerably greater flexibility, as all processors can execute independently. With static geometric parallelism the problem is partitioned between processors before rendering begins. Using a gridcell, regions can be subdivided and each processor assigned a subregion.
Reference: [POSIX] <editor> IEEE POSIX Draft Standard, </editor> <title> Threads Extension for Portable Operating Systems, </title> <publisher> (P1003.4a). </publisher>
Reference-contexts: One of these is the X Window System, which our software currently uses for displaying images. Parallelism on the KSR1 is controlled by using pthreads, which are lightweight processes. The KSR1 pthread interface is based on the IEEE POSIX draft standard <ref> [POSIX] </ref>. A group of pthreads forms a task which shares a single virtual address space, unlike processes which only share data through explicit system calls. Thus pthreads trade data security for low overheads. Although fairly cheap to create, pthreads are generally best used with fairly coarse-grained parallel computations.
Reference: [Scherson88] <author> Scherson I. D. and Caspary E., </author> <title> Multiprocessing for Ray Tracing : A Hierarchical Self-Balancing Approach, </title> <journal> The Visual Computer, </journal> <volume> 4 (4), </volume> <year> 1988, </year> <pages> pp. 188-96. </pages>
Reference-contexts: One approach to data distribution is to use the hierarchical bounding volume technique to subdivide the model space, and then to distribute the resulting tree data structure across the available processors <ref> [Scherson88] </ref>, [Muller91]. The tree is divided into upper and lower levels, 5 with the upper-level nodes distributed to all processors and sub-branches of the lower levels distributed uniformly across the processors. Clearly there is a relationship here between the topology of the tree and the number of processors available.
Reference: [Spackman90] <author> Spackman J. </author> <title> N., </title> <institution> University of Bath Computer Science Technical Report 90-33, </institution> <year> 1990, </year> <type> (also Phd. Thesis). </type>
Reference-contexts: Octtree subdivision attempts to overcome the last problem namely the potentially large size of the data structures, and poor spatial distribution by recursively subdividing the model space, usually by binary division in each dimension [Glassner84], [Fujimoto86], <ref> [Spackman90] </ref>. Starting with the whole model space, subdivision continues until some minimum number of objects remain in each sub-region, or some number of levels of recursion is reached. <p> There is evidence that, in the general case, the gridcell performs at least as well as other methods <ref> [Spackman90] </ref>. As mentioned previously, it is poor for models which have very uneven spatial distribution. We will return to this point later.
Reference: [Spackman91] <author> Spackman J. N. and Willis P. J., </author> <title> The SMART Navigation of a Ray through an Oct-tree, </title> <journal> Computers and Graphics, </journal> <volume> 15 (2), </volume> <year> 1991, </year> <pages> pp. 185-194. </pages>
Reference-contexts: This approach is good at representing models with large amounts of local detail in some parts and large spaces in others, and it can skip large, empty spaces fast. It requires a more complex traversal algorithm, but efficient solutions to this do exist <ref> [Spackman91] </ref>. Octtrees are sensitive to pathological cases which generate large data structures for quite simple scenes. For example, a number of large planar objects, such as the walls of a room, passing through a scene close to a subdivision boundary can cause repeated subdivision.
Reference: [Speer92] <author> Speer L. R. </author> <title> An Updated Cross-Indexed Guide to the Ray Tracing Literature, </title> <journal> Computer Graphics, </journal> <volume> 26 (1), </volume> <year> 1992, </year> <pages> pp. 41-72. </pages>
Reference-contexts: A comprehensive list of references on ray tracing, including acceleration methods and parallel processing can be found in <ref> [Speer92] </ref> and a good overview of ray tracing on parallel computers has been published by Badouel et al [Badouel90]. 2.1 Acceleration techniques The main techniques for accelerating ray tracing capitalise on the property of spatial coherence.
Reference: [Williams93] <author> Williams J.G., Murta A.D. and Howard T.L.J., </author> <title> Modelling Rodin's Thinker: A case study combining PHIGS and ray tracing, </title> <booktitle> Proceedings First Bilkent Computer Graphics Conference, </booktitle> <institution> Ankara, Turkey, </institution> <month> July </month> <year> 1993, </year> <month> pp.243-254. </month>
Reference-contexts: A statue surrounded by large mirrors. It contains 3,036 primitives and 2 light sources, and is shown in Figure 10. This model has a fairly uneven spatial distribution with a large number of polygons around the head. A description of the origin of this model can be found in <ref> [Williams93] </ref>. 4. An Office. This scene is the most complex of those tested and contains over 100,000 polygons and 5 light sources. It can be seen in Figure 11. This too has a very uneven spatial distribution.
Reference: [Whitted80] <author> Whitted T., </author> <title> An Improved Illumination Model for Shaded Display, </title> <journal> CACM, </journal> <volume> 23(6), </volume> <month> June </month> <year> 1980, </year> <note> pp.343-349. 22 </note>
Reference-contexts: One line of enquiry has been the derivation of techniques for speeding up ray/object intersection tests, since naive ray tracers typically spend most of their time in this activity <ref> [Whitted80] </ref>. A second theme to emerge is the use of parallel machines, with the particular goal of achieving linear speed-up with increasing numbers of processors.
References-found: 25

