URL: http://www-cad.eecs.berkeley.edu/research/hsis/papers/technical/formalmethods93.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/research/hsis/index.html
Root-URL: 
Title: Abstract  
Abstract: We present a formal verification environment for hardware based on symbolic computations. The hardware is described using our concurrency model, called the combinational/sequential concurrency model, a powerful modeling scheme with close ties to hardware. Because non-determinism is allowed, sometimes unwanted behavior is introduced. To remove this, fairness constraints are used. Having specified the model, the user can then prove properties of the design using either CTL or edge-Rabin automata. In this paper, we present our concurrency model, and algorithms for language containment checking, fair CTL model checking, early failure detection, and hierarchical verification. 
Abstract-found: 1
Intro-found: 1
Reference: [Bry86] <author> R. E. Bryant, </author> <title> Graph Based Algorithms for Boolean Function Manipulation, </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference: [Bur92] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. Dill, L. J. </author> <title> Hwang Symbolic Model Checking: 10 20 states and beyond, </title> <booktitle> Information and Computation, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: The first step in detection of fair SCCs finds all SCCs of the graph. Unfortunately, this operation is very time-consuming (on large graphs), even when BDDs are used ([Hoj92]). <ref> [Bur92] </ref> first presented a BDD-based algorithm for a subset of fair CTL, where the fairness constraint is of the form . In this paper, we present an algorithm for full fair CTL, which uses the fair reachable state computation of section 4 as a subroutine.
Reference: [Cho74] <author> Y. Choueka, </author> <title> Theories of Automata on w-Tapes: A Simplified Approach, </title> <journal> Journal of Computer and System Sciences 8, </journal> <pages> 117-141, </pages> <year> 1974. </year>
Reference: [Cla86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications, </title> <journal> ACM Transactions on Programming Languages and Systems. </journal> <volume> 8(2), pp.244-263, </volume> <year> 1986. </year>
Reference: [Eme87] <author> E. A. Emerson, C. L. Lei, </author> <title> Modalities for Model Checking: Branching Time Logic Strikes Back, </title> <booktitle> Science of Computer Program ming 8, </booktitle> <pages> 275-306, </pages> <publisher> Elsevier Science Publishers, </publisher> <year> 1987. </year>
Reference-contexts: We present several algorithms for computing the fair reachable states, which are based on ideas of <ref> [Eme87] </ref> on how to translate fair CTL formulas into m-calculus. There are many ways to compute this set ([Hoj92]), but only one is presented here. <p> An accepting run according to fairness constraints is called a fair path. In this section, we present an algorithm for this task. Our algorithm is a modification of the Emerson-Lei computation, presented in <ref> [Eme87] </ref>, and re-formulated in the language containment environment by [Tou91]. [Hoj92] presented several other ways of computing this set. In what follows, let be a graph, the set of its vertices, a subset of its vertices, and its transition function. <p> Definition A general fairness constraint is any Boolean combination of and . A canonical fairness constraint (CFC) is a fairness constraint of the form , where and are atomic propositions. Lemma (<ref> [Eme87] </ref>) Any general fairness constraint can be expressed as a CFC; but, the translation may be exponential. However, [Eme87] argues that most practical fairness constraints can be represented efficiently using CFCs. In practice, usually a subset of the CFCs is supported, e.g. , where is one of the two infinitary operators. <p> The truth of is determined at a state s by only considering the paths which satisfy the fairness constraint (these paths are called fair paths). 5.3 Fair CTL Model Checking <ref> [Eme87] </ref> introduced Fair CTL and gave an algorithm to model check fair CTL formulas. This algorithm relied on finding a fair strongly connected component of the graph, i.e. a SCC which completely contains a fair path. The first step in detection of fair SCCs finds all SCCs of the graph. <p> Since the sum of a set of 's is just equivalent to , only one suffices. It remains to answer whether allowing more 's will sacrifice efficiency. <ref> [Eme87] </ref> basically answered this question (they were looking at a slightly different problem). Theorem The problem of determining whether the language of an automaton with acceptance conditions of the form is empty, is NP-complete (in the number of states and fairness constraints). Proof (sketch) The problem is in NP. <p> The answer is a set of states which can be traversed infinitely often, such that all fairness constraints are satisfied. Just guess this set of states, and check that this set is contained in or for all . To prove the problem is NP-complete, just use the reduction of <ref> [Eme87] </ref>, which was employed to show the fair state problem with fairness constraints of the above type is NP-complete. [Eme87] reduces 3SAT to a graph with fairness constraints of the above type. Now, the language of the automaton is non-empty iff the original formula is satisfiable (QED). <p> Just guess this set of states, and check that this set is contained in or for all . To prove the problem is NP-complete, just use the reduction of <ref> [Eme87] </ref>, which was employed to show the fair state problem with fairness constraints of the above type is NP-complete. [Eme87] reduces 3SAT to a graph with fairness constraints of the above type. Now, the language of the automaton is non-empty iff the original formula is satisfiable (QED).
Reference: [Har90] <author> Z. Har'El and R. P. Kurshan, </author> <title> Software for Analytical Development of Communication Protocols, </title> <journal> AT&T Journal, </journal> <month> Jan </month> <year> 1990, </year> <pages> 45-59. </pages>
Reference: [Eme90] <author> E. A. Emerson, </author> <title> Temporal and Modal Logic, </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <editor> editor J. van Leeuwen, </editor> <publisher> Elsevier Science Publishers B.V., </publisher> <pages> pp. 995-1072, </pages> <year> 1990. </year>
Reference-contexts: At the highest level are non-deterministic w--automata, such as non-deterministic Buchi automata ([Cho74]). The set of languages defined by these automata is known as the w-regular languages. Linear Temporal Logic (LTL) is another method to specify string properties. LTL is properly contained in w-regular languages. <ref> [Eme90] </ref> gives a survey of such expressiveness results. 2. Language Properties. These are properties of the languages, not expressible as string properties. For example, one might wish to verify that if strings x and y are in the language then string z is also in the language.
Reference: [Hoj92] <author> Ramin Hojati, Herve Touati, Robert P. Kurshan, Robert K. Brayton, </author> <title> Efficient w-Regular Language Containment, Computer-Aided Verification, </title> <year> 1992. </year>
Reference-contexts: Parts of the design are then refined. If these refinements do not add behavior, then the properties proved using LC at high-levels of abstraction are guaranteed to hold at the lower levels. Much of the material and ideas presented here has appeared in conference papers, <ref> [Hoj92] </ref>, [Hoj93a], and [Hoj93c]. Most of the algorithms described have been implemented in our verification tool, HSIS, being developed at University of California, Berkeley. An important part of our environment are additional debugging techniques which are not addressed here. <p> An accepting run according to fairness constraints is called a fair path. In this section, we present an algorithm for this task. Our algorithm is a modification of the Emerson-Lei computation, presented in [Eme87], and re-formulated in the language containment environment by [Tou91]. <ref> [Hoj92] </ref> presented several other ways of computing this set. In what follows, let be a graph, the set of its vertices, a subset of its vertices, and its transition function. Definition A cyclic strongly connected component (CSCC) of is an SCC of which contains at least one cycle. <p> Based on this paradigm, the first software tool for automatic verification of finite-state systems using language containment was built ([Har90]). The advent of BDDs allows for handling very large state spaces. <ref> [Hoj92] </ref> and [Hoj93b] gave various efficient BDD-based algorithms for language containment and debugging in the L-environment. In this section, we introduce a new language containment based formal verification environment, which contains the L-environment as a subset. <p> The full set of algorithms described in this paper have been or are being implemented in the Berkeleys verification and synthesis program, HSIS. Acknowledgment This paper is a composite and extension of the material in references <ref> [Hoj92] </ref>, [Hoj93a], and [Hoj93c]. We gratefully acknowledge the many contributions of our co-authors, R. Kurshan, T. Shiple, V. Singhal, and H. Touati. In addition, the generous guidance of R. Kurshan over the last three years is much appreciated.
Reference: [Hoj93a] <author> R. Hojati, Thomas P. Shiple, R. K. Brayton, R. P. Kurshan, </author> <title> A Unified Approach to Language Containment and Fair CTL Model Checking, </title> <booktitle> Proceedings of Design Automation Conference, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Parts of the design are then refined. If these refinements do not add behavior, then the properties proved using LC at high-levels of abstraction are guaranteed to hold at the lower levels. Much of the material and ideas presented here has appeared in conference papers, [Hoj92], <ref> [Hoj93a] </ref>, and [Hoj93c]. Most of the algorithms described have been implemented in our verification tool, HSIS, being developed at University of California, Berkeley. An important part of our environment are additional debugging techniques which are not addressed here. <p> The full set of algorithms described in this paper have been or are being implemented in the Berkeleys verification and synthesis program, HSIS. Acknowledgment This paper is a composite and extension of the material in references [Hoj92], <ref> [Hoj93a] </ref>, and [Hoj93c]. We gratefully acknowledge the many contributions of our co-authors, R. Kurshan, T. Shiple, V. Singhal, and H. Touati. In addition, the generous guidance of R. Kurshan over the last three years is much appreciated.
Reference: [Hoj93b] <author> R. Hojati, R. K. Brayton, R. P. Kurshan, </author> <title> BDD-Based Debugging of Design Using Language Containment and Fair CTL, </title> <booktitle> Proceedings of the Conference on Computer-Aided Verification, </booktitle> <address> Elounda, Crete, Greece, </address> <note> To appear, </note> <month> June </month> <year> 1993. </year>
Reference-contexts: An important part of our environment are additional debugging techniques which are not addressed here. These attempt to feed back to the user a succinct error trace which is used to more easily locate a bug. Interested readers are referred to <ref> [Hoj93b] </ref>. The papers ow is as follows. Section 2 presents the preliminaries, including the combinational/sequential concurrency model. Section 3 describes how fairness constraints are described. Section 4 presents algorithms for computing fair reachable states. Section 5 and 6, give algorithms for MC and LC respectively. <p> Based on this paradigm, the first software tool for automatic verification of finite-state systems using language containment was built ([Har90]). The advent of BDDs allows for handling very large state spaces. [Hoj92] and <ref> [Hoj93b] </ref> gave various efficient BDD-based algorithms for language containment and debugging in the L-environment. In this section, we introduce a new language containment based formal verification environment, which contains the L-environment as a subset. <p> The problem of extending quick failure checks to ACTL formulas remains open. Remark One important topic not dealt with in this paper is debugging. When early failure detection is used, not all fair states are found. Hence, a debugger must be able to deal with partial information. <ref> [Hoj93b] </ref> discusses techniques for finding errors F S i ( ) i i S i T i i i I R D s F S f s F R S R S s P s f S R f g s R f AGf= x s p f AXf using partial
Reference: [Hoj93c] <author> R. Hojati, Vigyan Singhal, R. K. Brayton, </author> <title> Edge-Streett/Edge-Rabin Automata Environment for Formal Verification Using Language Containment, </title> <booktitle> Submitted to the International Conference on Computer-AIded Design, </booktitle> <year> 1993. </year>
Reference-contexts: Parts of the design are then refined. If these refinements do not add behavior, then the properties proved using LC at high-levels of abstraction are guaranteed to hold at the lower levels. Much of the material and ideas presented here has appeared in conference papers, [Hoj92], [Hoj93a], and <ref> [Hoj93c] </ref>. Most of the algorithms described have been implemented in our verification tool, HSIS, being developed at University of California, Berkeley. An important part of our environment are additional debugging techniques which are not addressed here. <p> Since the language emptiness check for Streett automata is done in polynomial-time, the next natural extension to our environment makes the language emptiness check, which is the most important operation in formal verification, NP-complete. This gives the eSeR-environment a sense of maximality. Remark <ref> [Hoj93c] </ref> discusses several compactness issues of the eSeR-environment. <p> The full set of algorithms described in this paper have been or are being implemented in the Berkeleys verification and synthesis program, HSIS. Acknowledgment This paper is a composite and extension of the material in references [Hoj92], [Hoj93a], and <ref> [Hoj93c] </ref>. We gratefully acknowledge the many contributions of our co-authors, R. Kurshan, T. Shiple, V. Singhal, and H. Touati. In addition, the generous guidance of R. Kurshan over the last three years is much appreciated.
Reference: [Kam91] <author> T. Kam, R. Brayton. </author> <title> Multi-valued Decision Diagrams, </title> <institution> Electronics Research Laboratory, University of California, Berkeley, </institution> <note> Memorandum No. UCB/ERL, M90/125, </note> <year> 1990. </year>
Reference: [Kur87a] <author> R. P. Kurshan, </author> <title> Complementing Deterministic Buchi Automata in Polynomial Time, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> volume 35, </volume> <year> 1987, </year> <pages> 59-71. </pages>
Reference-contexts: If is non-deterministic, then the procedure is more expensive. [Saf92] proposed an (exponential) algorithm for determin-izing a non-deterministic Streett automaton, which returns a deterministic Rabin automata. One can translate an edge-Streett automaton into a Streett automaton, using techniques similar to the node-recur transform of <ref> [Kur87a] </ref>.
Reference: [Kur87b] <author> R. P. Kurshan, </author> <title> Reducibility in Analysis of Coordination, </title> <booktitle> In LNCIS, </booktitle> <volume> volume 103, </volume> <pages> pages 19-39, </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: The usual method to verify that , where and are the languages of the system and property respectively, is by checking that is empty (known as language emptiness check). However, complementing an w-automaton is a PSPACE-complete problem, and the best known algorithms have exponential complexity ([Sis87], [Saf89]). <ref> [Kur87b] </ref> introduced an environment, where the acceptance conditions of the system and the property are complementary.
Reference: [Kur92] <author> R. P. Kurshan, </author> <title> Automata-Theoretic Verification of Coordinating Processes, </title> <institution> UC Berkeley notes, </institution> <year> 1992. </year>
Reference-contexts: This means that the language of the lower level implementation must be contained in the language of the higher level specification. Since systems are specified using edge-Streett automata, this means that we need to check language containment between two edge-Streett automata. <ref> [Kur92] </ref> presents an algorithm for language containment of two L-processes (this comes up in the L-environment because of use of homomorphic reductions). We present an algorithm with the same avor for our problem. Assume two edge-Streett automata and are given, where is deterministic.
Reference: [Rab72] <author> M. O. Rabin, </author> <title> Automata on Infinite Objects and Church's Problem, </title> <booktitle> Regional Conference Series in Mathematics, volume 13, 1972, </booktitle> <publisher> American Mathematical Society, </publisher> <address> Providence, Rhode Island, </address> <pages> 19-39. </pages>
Reference-contexts: Because of presence of fairness constraints, this process is referred to as fair CTL model checking (MC). To verify a property expressed using edge-Rabin automata (a minor extension of Rabin automata <ref> [Rab72] </ref>), we use language containment (LC), which is the process of verifying the language of a sys s s An Environment for Formal Verification Based On Symbolic Computations Ramin Hojati Robert K. Brayton University of California, Berkeley tem is contained in the language of a property.
Reference: [Saf89] <author> Shmuel Safra, </author> <title> Complexity of Automata on Infinite Objects, </title> <institution> The Weizmann Institute of Science, </institution> <month> March </month> <year> 1989. </year>
Reference-contexts: The usual method to verify that , where and are the languages of the system and property respectively, is by checking that is empty (known as language emptiness check). However, complementing an w-automaton is a PSPACE-complete problem, and the best known algorithms have exponential complexity ([Sis87], <ref> [Saf89] </ref>). [Kur87b] introduced an environment, where the acceptance conditions of the system and the property are complementary.
Reference: [Saf92] <author> S. Safra, </author> <title> Exponential Determinization for w-Automata with Strong-Fairness Acceptance Condition, </title> <booktitle> STOC, </booktitle> <year> 1992. </year>
Reference-contexts: Since, these fairness constraint are given by the user, we expect to be small. Remark One can also use the algorithm reported in <ref> [Saf92] </ref> for the above task. Given a deterministic Streett automaton with states and CFCs, [Saf92]'s algorithm returns a deterministic Rabin automaton with states and CFCs accepting the same language. <p> states and CFCs, <ref> [Saf92] </ref>'s algorithm returns a deterministic Rabin automaton with states and CFCs accepting the same language. Although this algorithm is exponential in , if is small, as it is expected to be in practice, this algorithm may be practical. If is non-deterministic, then the procedure is more expensive. [Saf92] proposed an (exponential) algorithm for determin-izing a non-deterministic Streett automaton, which returns a deterministic Rabin automata. One can translate an edge-Streett automaton into a Streett automaton, using techniques similar to the node-recur transform of [Kur87a].
Reference: [Str82] <author> R. S. Streett, </author> <title> Propositional Dynamic Logic of Looping and Converse is Elementary Decidable, </title> <journal> Information and Control, </journal> <volume> volume 54, </volume> <year> 1982, </year> <pages> 121-141. </pages>
Reference-contexts: Hence, for us a hardware system consists of a model of the hardware plus a set of fairness constraints. Although we allow the user to specify the fairness constraints in various forms, internally, they are translated into edge-Streett automata (a minor extension of Streett automata <ref> [Str82] </ref>). Having specified the system, the next step is the verification of properties. For verification, one can use Computation Tree Logic (CTL) ([Cla86]) formulas, or edge-Rabin automata. To verify a property expressed in CTL, model checking is used, which is the process of verifying a system satisfies a logical formula.
Reference: [Tou90] <author> H. J.Touati, H. Savoj, B. Lin, R. K. Brayton, A. S. Vincentelli, </author> <title> Implicit State Enumeration of Finite State Machines Using BDDs, </title> <booktitle> Proc. of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pp. 130-133, </pages> <month> Nov. </month> <year> 1990. </year>
Reference: [Tou91] <author> H. Touati, R. Kurshan, R. Brayton. </author> <title> Testing Language Containment of w-Automata Using BDDs, </title> <booktitle> International Workshop on Formal Methods in VLSI Design, </booktitle> <year> 1991. </year>
Reference-contexts: An accepting run according to fairness constraints is called a fair path. In this section, we present an algorithm for this task. Our algorithm is a modification of the Emerson-Lei computation, presented in [Eme87], and re-formulated in the language containment environment by <ref> [Tou91] </ref>. [Hoj92] presented several other ways of computing this set. In what follows, let be a graph, the set of its vertices, a subset of its vertices, and its transition function. Definition A cyclic strongly connected component (CSCC) of is an SCC of which contains at least one cycle.
Reference: [Var86] <author> M. Y. Vardi and P. L. Wolper, </author> <title> An Automata-Theoretic Approach to Program Verification, </title> <booktitle> Logic in Computer Science, </booktitle> <pages> 332-334, </pages> <year> 1986. </year>
Reference-contexts: The above scheme for doing formal verification first appeared in literature in <ref> [Var86] </ref>. [Var86] suggested specifying both the system and the property using Buchi automata, and went on to give an algorithm for language containment in this environment. <p> The above scheme for doing formal verification first appeared in literature in <ref> [Var86] </ref>. [Var86] suggested specifying both the system and the property using Buchi automata, and went on to give an algorithm for language containment in this environment.
References-found: 22

