URL: ftp://ftp.cs.monash.edu.au/publications/1995/kelly1.ps.gz
Refering-URL: http://www.cs.monash.edu.au/~kelly/publications/group.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Phone: 2  
Title: An Optimizing Compiler for CLP(R)  
Author: Andrew D. Kelly Andrew Macdonald Kim Marriott Harald Stndergaard Peter J. Stuckey Roland H.C. Yap ; 
Address: 3168, Australia.  Melbourne, Parkville 3052, Australia.  
Affiliation: 1 Dept. of Computer Science, Monash University, Clayton  Dept. of Computer Science, The University of  
Abstract: The considerable expressive power and flexibility gained by combining constraint programming with logic programming is not without cost. Implementations of constraint logic programming (CLP) languages must include expensive constraint solving algorithms tailored to specific domains, such as trees, Booleans, or real numbers. The performance of many current CLP compilers and interpreters does not encourage the widespread use of CLP. We outline an optimizing compiler for CLP(R), a CLP language which extends Prolog by allowing linear arithmetic constraints. The compiler uses sophisticated global analyses to determine the applicability of different program transformations. Two important components of the compiler, the analyzer and the optimizer, work in continual interaction in order to apply semantics-preserving transformations to the source program. A large suite of transformations are planned. Currently the compiler applies three powerful transformations, namely "solver bypass", "dead variable elimination" and "nofail constraint detection". We explain these optimizations and their place in the overall compiler design and show how they lead to performance improvements on a set of benchmark programs.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> H. At-Kaci. </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The current implementation of CLP (R) is a compiler. It translates into code for an abstract machine, the CLAM. This machine is an extension of the Prolog WAM architecture (see for example At-Kaci <ref> [1] </ref>) to deal with arithmetic constraints. Because the constraint solvers deal principally with linear constraints, the main arithmetic instructions in the CLAM construct the data structures representing linear arithmetic forms. These data structures are in a form which can be used directly by the constraint solvers.
Reference: 2. <author> T. Armstrong, K. Marriott, P. Schachte and H. Stndergaard. </author> <title> Boolean functions for dependency analysis: Algebraic properties and efficient representation. </title> <editor> In B. Le Charlier, editor, </editor> <title> Static Analysis: </title> <booktitle> Proc. First Int. Symp. (Lecture Notes in Computer Science 864), </booktitle> <pages> pages 266-280. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Currently the analyzer works on descriptions which are tuples of 6 different domains. The first description domain, P os, consists of Boolean functions which capture groundness information about variables and definite dependencies among variables, see for example <ref> [2] </ref>. For example the function X ^ (Y ! Z) indicates that the variable X is constrained to take a unique value, and that if Y is ever constrained to a unique value, then so is Z. Our implementation uses ROBDDs to represent the Boolean functions.
Reference: 3. <author> F. Bueno, M. Garca de la Banda and M. Hermenegildo. </author> <title> Effectiveness of global analysis in strict independence-based automatic parallelization. </title> <booktitle> In Logic Programming: Proc. 1994 Int. Symp., </booktitle> <pages> pages 320-336. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: This is the first implementation of a constraint logic programming system that makes use of global analysis and performs optimizations of arithmetic constraint solving. Only one other logic programming compiler that we are aware of uses such complex analysis domains and transformations (the &-Prolog compiler <ref> [3] </ref>). It is also the only system we are aware of which splits predicate definitions to allow more optimization, although using a completely different splitting strategy. The proposed compiler includes several optimizations which the current implementation does not provide and which we intend to implement.
Reference: 4. <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Proc. Fourth Ann. ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 238-252. </pages> <publisher> ACM Press, </publisher> <year> 1977. </year>
Reference-contexts: In particular, the CLAM emulator is an extension of that used in the first-generation CLP (R) compiler. We now discuss the three main components of the compiler (see also Figure 1). The Analyzer Analysis is formalized in terms of abstract interpretation <ref> [4] </ref>.
Reference: 5. <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation and application to logic programs. </title> <journal> Journal of Logic Programming 13 (2&3): </journal> <pages> 103-179, </pages> <year> 1992. </year>
Reference-contexts: However, if we replace the possibly infinite sets of constraints by conservative "approximations" or "descriptions" then we may obtain a dataflow analysis which works in finite time. This is the idea behind abstract interpretation of logic programs and constraint logic programs <ref> [5, 13] </ref>. As an example consider the mortgage program from Section 3. If this program is analyzed for the class of calls in which the first three arguments are bound to a number then the following annotated program results.
Reference: 6. <author> S. Debray. </author> <title> Static inference of modes and data dependencies in logic programs. </title> <booktitle> ACM Transactions on Programming Languages and Systems 11 (3): </booktitle> <pages> 418-450, </pages> <year> 1989. </year>
Reference-contexts: Our implementation uses ROBDDs to represent the Boolean functions. The second description domain, F ree, captures information about "freeness". It is based on the descriptions used by Debray <ref> [6] </ref> for the optimization of Prolog unification. Each description consists of a list of definitely free variables and an equivalence relation which captures possible "aliasing" between free variables.
Reference: 7. <author> J. Jaffar and M. Maher. </author> <title> Constraint logic programming: A survey. </title> <journal> Journal of Logic Programming 19/20: </journal> <pages> 503-581, </pages> <year> 1994. </year>
Reference-contexts: We assume the reader is familiar with constraint logic programming in general and with constraint logic programming over real arithmetic constraints in particular. A good introduction to CLP is to be found in <ref> [7] </ref> and a detailed introduction to CLP (R) can be found in [9]. In Section 2 we discuss the existing compiler and abstract machine CLAM.
Reference: 8. <author> J. Jaffar, S. Michaylov, P. Stuckey and R. Yap. </author> <title> An abstract machine for CLP(R). </title> <booktitle> Proc. ACM Conf. Programming Language Design and Implementation, </booktitle> <pages> pages 128-139. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: We are working towards a second generation implementation which overcomes the efficiency problems of current technology. The main innovation in the compiler is the incorporation of powerful program transformations and associated sophisticated global analysis which determines information about various kinds of interaction among constraints. Our earlier studies <ref> [10, 8, 15, 12, 14] </ref> have indicated that a suite of transformation techniques can lead to an order of magnitude improvement in execution time or space for particular classes of programs. Our implementation verifies this. <p> The constraint solving hierarchy used in the interpreter is retained but is more effective since some run-time decisions in the interpreter can now be shifted to compile-time. To give a flavor of the CLAM (see <ref> [8] </ref> for details), let us describe the compilation of the constraint 5 + X = Y . Assume that X is a new variable and the equation store contains Y = Z + 3:14. <p> There are many more interesting and valuable optimizations that we plan to incorporate in the compiler, requiring more analysis domains and considerable implementation effort, among them future redundancy, constraint removal, mutual exclusion and determinacy [15]. Code Generator and Emulator The code generator maps the CLIC code into CLAM <ref> [8] </ref> instructions which are executed by the CLAM emulator. The original CLP (R) compiler also produced CLAM code, but used only a core set. The new compiler makes use of extended CLAM instructions for achieving the optimizations that are made possible by global analysis.
Reference: 9. <author> J. Jaffar, S. Michaylov, P. Stuckey and R. Yap. </author> <title> The CLP(R) language and system. </title> <booktitle> ACM Transactions on Programming Languages and Systems 14 (3): </booktitle> <pages> 339-395, </pages> <year> 1992. </year>
Reference-contexts: We assume the reader is familiar with constraint logic programming in general and with constraint logic programming over real arithmetic constraints in particular. A good introduction to CLP is to be found in [7] and a detailed introduction to CLP (R) can be found in <ref> [9] </ref>. In Section 2 we discuss the existing compiler and abstract machine CLAM.
Reference: 10. <author> N. Jtrgensen, K. Marriott and S. Michaylov. </author> <title> Some global compile-time optimizations for CLP(R). </title> <editor> In V. Saraswat and K. Ueda, editors, </editor> <booktitle> Logic Programming: Proc. 1991 Int. Symp., </booktitle> <pages> pages 420-434. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: We are working towards a second generation implementation which overcomes the efficiency problems of current technology. The main innovation in the compiler is the incorporation of powerful program transformations and associated sophisticated global analysis which determines information about various kinds of interaction among constraints. Our earlier studies <ref> [10, 8, 15, 12, 14] </ref> have indicated that a suite of transformation techniques can lead to an order of magnitude improvement in execution time or space for particular classes of programs. Our implementation verifies this.
Reference: 11. <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental evaluation of a generic abstract interpretation algorithm for Prolog. </title> <booktitle> ACM Transactions on Programming Languages and Systems 16 (1): </booktitle> <pages> 35-101, </pages> <year> 1994. </year>
Reference-contexts: To facilitate the rich variety of analyses required in the compiler, the analyzer is a generic tool similar to other analysis engines, such as PLAI [16] and GAIA <ref> [11] </ref> developed for Prolog. The core of the analyzer is an algorithm for efficient fixpoint computation. Efficiency is obtained by keeping track of which parts of a program must be reexamined when a success pattern is updated.
Reference: 12. <author> A. Macdonald, P. Stuckey and R. Yap. </author> <title> Redundancy of variables in CLP(R). </title> <booktitle> In Logic Programming: Proc. 1993 Int. Symp., </booktitle> <pages> pages 75-93. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: We are working towards a second generation implementation which overcomes the efficiency problems of current technology. The main innovation in the compiler is the incorporation of powerful program transformations and associated sophisticated global analysis which determines information about various kinds of interaction among constraints. Our earlier studies <ref> [10, 8, 15, 12, 14] </ref> have indicated that a suite of transformation techniques can lead to an order of magnitude improvement in execution time or space for particular classes of programs. Our implementation verifies this. <p> The description consists of a tuple of the four descriptions: P os, F ree, CallAlive and Shar. The descriptions N onLin 3 Note that this is a simplification of the approach of <ref> [12] </ref> and T ype have been omitted for simplicity as they are not significant for this example.
Reference: 13. <author> K. Marriott and H. Stndergaard. </author> <title> Analysis of constraint logic programs. </title> <editor> In S. De-bray and M. Hermenegildo, </editor> <booktitle> Logic Programming: Proc. North American Conf. </booktitle> <year> 1990, </year> <pages> pages 531-547. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: However, if we replace the possibly infinite sets of constraints by conservative "approximations" or "descriptions" then we may obtain a dataflow analysis which works in finite time. This is the idea behind abstract interpretation of logic programs and constraint logic programs <ref> [5, 13] </ref>. As an example consider the mortgage program from Section 3. If this program is analyzed for the class of calls in which the first three arguments are bound to a number then the following annotated program results.
Reference: 14. <author> K. Marriott, H. Stndergaard, P. Stuckey and R. Yap. </author> <title> Optimizing compilation for CLP(R). </title> <editor> In G. Gupta, editor, </editor> <booktitle> Proc. Seventeenth Australian Computer Science Conf., Australian Computer Science Comm. </booktitle> <volume> 16 (1): </volume> <pages> 551-560, </pages> <year> 1994. </year>
Reference-contexts: We are working towards a second generation implementation which overcomes the efficiency problems of current technology. The main innovation in the compiler is the incorporation of powerful program transformations and associated sophisticated global analysis which determines information about various kinds of interaction among constraints. Our earlier studies <ref> [10, 8, 15, 12, 14] </ref> have indicated that a suite of transformation techniques can lead to an order of magnitude improvement in execution time or space for particular classes of programs. Our implementation verifies this. <p> Characteristics of programs in the test suite 6 Conclusion The current compiler is a partial implementation of the compiler proposed in <ref> [14] </ref>. The results demonstrate that global analysis and optimization can significantly improve the performance of CLP languages. Even without complete run-time support for the optimizations we gain considerably in terms of space and time of execution.
Reference: 15. <author> K. Marriott and P. Stuckey. </author> <title> The 3 R's of optimizing constraint logic programs: Refinement, removal and reordering. </title> <booktitle> Proc. Twentieth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 334-344. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: We are working towards a second generation implementation which overcomes the efficiency problems of current technology. The main innovation in the compiler is the incorporation of powerful program transformations and associated sophisticated global analysis which determines information about various kinds of interaction among constraints. Our earlier studies <ref> [10, 8, 15, 12, 14] </ref> have indicated that a suite of transformation techniques can lead to an order of magnitude improvement in execution time or space for particular classes of programs. Our implementation verifies this. <p> There are many more interesting and valuable optimizations that we plan to incorporate in the compiler, requiring more analysis domains and considerable implementation effort, among them future redundancy, constraint removal, mutual exclusion and determinacy <ref> [15] </ref>. Code Generator and Emulator The code generator maps the CLIC code into CLAM [8] instructions which are executed by the CLAM emulator. The original CLP (R) compiler also produced CLAM code, but used only a core set.
Reference: 16. <author> K. Muthukumar and M. Hermenegildo. </author> <title> Compile-time derivation of variable dependency using abstract interpretation. </title> <journal> Journal of Logic Programming 13 (2&3): </journal> <pages> 315-347, </pages> <year> 1992. </year>
Reference-contexts: To facilitate the rich variety of analyses required in the compiler, the analyzer is a generic tool similar to other analysis engines, such as PLAI <ref> [16] </ref> and GAIA [11] developed for Prolog. The core of the analyzer is an algorithm for efficient fixpoint computation. Efficiency is obtained by keeping track of which parts of a program must be reexamined when a success pattern is updated.
Reference: 17. <author> H. Stndergaard. </author> <title> An application of abstract interpretation of logic programs: Occur check reduction. </title> <editor> In B. Robinet and R. Wilhelm, editors, </editor> <booktitle> Proc. ESOP 86 (Lecture Notes in Computer Science 213), </booktitle> <pages> pages 327-338. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: For these reasons the analyzer has two more description domains which provide information about dead variables. The fourth description domain, Shar, captures information about possible sharing of variables between Prolog terms. It is based on descriptions introduced by Stndergaard <ref> [17] </ref> for eliminating occur checks in Prolog. The description consists of a possible sharing relation for variables. Consider again the goal Y = f (X); p (X); Y = f (Z); q (Z).
Reference: 18. <author> A. Taylor. </author> <title> LIPS on a MIPS: Results from a Prolog compiler for a RISC. </title> <editor> In D. Warren and P. Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. Seventh Int. Conf., </booktitle> <pages> pages 174-185. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Our implementation verifies this. Our compiler also continues a line of experimental Prolog compilers which have made use of global program analysis to great advantage, see Taylor <ref> [18] </ref> and van Roy [19]. However, we achieve even larger performance improvements because linear arithmetic constraint solving is significantly more expensive than unification, and the scope for improvement in the handling of constraints is correspondingly greater.
Reference: 19. <author> P. van Roy and A. Despain. </author> <title> The benefits of global dataflow analysis for an optimizing Prolog compiler. </title> <editor> In S. Debray and M. Hermenegildo, editors, </editor> <booktitle> Logic Programming: Proc. North American Conf. </booktitle> <year> 1990, </year> <pages> pages 501-515. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Our implementation verifies this. Our compiler also continues a line of experimental Prolog compilers which have made use of global program analysis to great advantage, see Taylor [18] and van Roy <ref> [19] </ref>. However, we achieve even larger performance improvements because linear arithmetic constraint solving is significantly more expensive than unification, and the scope for improvement in the handling of constraints is correspondingly greater.
References-found: 19

