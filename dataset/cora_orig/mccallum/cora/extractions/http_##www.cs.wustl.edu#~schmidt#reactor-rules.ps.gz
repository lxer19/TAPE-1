URL: http://www.cs.wustl.edu/~schmidt/reactor-rules.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/ACE-papers.html
Root-URL: http://www.cs.wustl.edu
Email: fschmidt,irfang@cs.wustl.edu  
Title: The Design and Use of the ACE Reactor An Object-Oriented Framework for Event Demultiplexing  
Author: Douglas C. Schmidt and Irfan Pyarali 
Address: St. Louis 63130 1  
Affiliation: Department of Computer Science Washington University,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, </editor> <booktitle> eds.), </booktitle> <pages> pp. 529545, </pages> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: 1 Introduction This article describes the design and implementation of the Reactor pattern <ref> [1] </ref> contained in the ACE framework [2]. The Reactor pattern handles service requests that are delivered concurrently to an application by one or more clients. Each service of the application is implemented by a separate event handler that contains one or more methods responsible for processing service-specific requests. <p> ACE_ERROR_RETURN ((LM_ERROR, "usage: %d" "time1 time2"n"), 1); ACE_Time_Value curtime = ACE_OS::gettimeofday (); ACE_Time_Value timer1 = curtime + ACE_Time_Value (ACE_OS::atoi (argv <ref> [1] </ref>)); ACE_Time_Value timer2 = curtime + ACE_Time_Value (ACE_OS::atoi (argv [2])); if (timer1 &gt; timer2) ACE_DEBUG ((LM_DEBUG, "timer 1 is greater"n")); else if (timer2 &gt; timer1) ACE_DEBUG ((LM_DEBUG, "timer 2 is greater"n")); else ACE_DEBUG ((LM_DEBUG, "timers are equal"n")); return 0; - The code shown above is portable to all OS platforms. <p> Set the program name with the logger. ACE_LOG_MSG-&gt;open (argv [0]); // Ensure correct usage. if (argc != 2) ACE_ERROR_RETURN ((LM_ERROR, "usage: %n port-number"), -1); // 2. Create an addr and an acceptor. ACE_INET_Addr port (ACE_OS::atoi (argv <ref> [1] </ref>)); Logging_Acceptor acceptor (ACE_Reactor::instance (), port); // 3. Loop forever, handling client requests. for (;;) ACE_Reactor::instance ()-&gt;handle_events (); /* NOTREACHED */ return 0; - In Step 1, an ACE Log Msg is created to direct any log ging records generated by the server to its own standard error stream. <p> ACE_Time_Value delay = ACE_OS::atoi (argv <ref> [1] </ref>); ACE_Time_Value interval = ACE_OS::atoi (argv [2]); // Schedule the timer. ACE_Reactor::instance ()-&gt;schedule_timer (&handler, (const void *) argv [0], delay, interval); // Run the event loop. for (;;) ACE_Reactor::instance ()-&gt;handle_events (); /* NOTREACHED */ - A common mistake is to pass an absolute time value to schedule timer. <p> ACE_Reactor::instance ()-&gt;schedule_timer (&handler, (const void *) argv [0], delay, interval); // Run the event loop. for (;;) ACE_Reactor::instance ()-&gt;handle_events (); /* NOTREACHED */ - A common mistake is to pass an absolute time value to schedule timer. For instance, consider a different example: ACE_Time_Value delay = ACE_OS::atoi (argv <ref> [1] </ref>); delay += ACE_OS::gettimeofday (); // Callback every following 10 seconds.
Reference: [2] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: 1 Introduction This article describes the design and implementation of the Reactor pattern [1] contained in the ACE framework <ref> [2] </ref>. The Reactor pattern handles service requests that are delivered concurrently to an application by one or more clients. Each service of the application is implemented by a separate event handler that contains one or more methods responsible for processing service-specific requests. <p> This paper is organized as follows: Section 2 describes the primary features in the ACE Reactor framework; Section 3 outlines the OO design of the ACE Reactor implementation <ref> [2] </ref>; Section 4 examines several examples that demonstrate how the ACE Reactor simplifies the development of concurrent, event-driven network applications; Section 5 describes design rules to follow when using the ACE Reactor to develop event-driven applications; and Section 6 presents concluding remarks. 2 Features of the ACE Reactor The ACE Reactor <p> ACE_ERROR_RETURN ((LM_ERROR, "usage: %d" "time1 time2"n"), 1); ACE_Time_Value curtime = ACE_OS::gettimeofday (); ACE_Time_Value timer1 = curtime + ACE_Time_Value (ACE_OS::atoi (argv [1])); ACE_Time_Value timer2 = curtime + ACE_Time_Value (ACE_OS::atoi (argv <ref> [2] </ref>)); if (timer1 &gt; timer2) ACE_DEBUG ((LM_DEBUG, "timer 1 is greater"n")); else if (timer2 &gt; timer1) ACE_DEBUG ((LM_DEBUG, "timer 2 is greater"n")); else ACE_DEBUG ((LM_DEBUG, "timers are equal"n")); return 0; - The code shown above is portable to all OS platforms. <p> ACE_Time_Value delay = ACE_OS::atoi (argv [1]); ACE_Time_Value interval = ACE_OS::atoi (argv <ref> [2] </ref>); // Schedule the timer. ACE_Reactor::instance ()-&gt;schedule_timer (&handler, (const void *) argv [0], delay, interval); // Run the event loop. for (;;) ACE_Reactor::instance ()-&gt;handle_events (); /* NOTREACHED */ - A common mistake is to pass an absolute time value to schedule timer.
Reference: [3] <author> W. R. Stevens, </author> <title> UNIX Network Programming, Second Edition. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: The ACE Reactor combines the demultiplexing of input and output (I/O) events with other types of events, such as timers and signals. At the core of the ACE Reactor implementation is a synchronous event demultiplexer, such as select <ref> [3] </ref> or WaitForMultipleObjects [4]. When the demulti-plexer indicates the occurrence of designated events, the ACE Reactor automatically dispatches the method (s) of pre-registered event handlers, which perform application-specified services in response to the events.
Reference: [4] <author> H. Custer, </author> <title> Inside Windows NT. </title> <address> Redmond, Washington: </address> <publisher> Mi-crosoft Press, </publisher> <year> 1993. </year>
Reference-contexts: The ACE Reactor combines the demultiplexing of input and output (I/O) events with other types of events, such as timers and signals. At the core of the ACE Reactor implementation is a synchronous event demultiplexer, such as select [3] or WaitForMultipleObjects <ref> [4] </ref>. When the demulti-plexer indicates the occurrence of designated events, the ACE Reactor automatically dispatches the method (s) of pre-registered event handlers, which perform application-specified services in response to the events. <p> When a timer managed by this mechanism expires, the 2 On Win32 the ACE Reactor can also handle synchronization events, such as transitioning from the non-signaled to signaled state with Win32 mutexes <ref> [4] </ref>. 3 // Handle portability issues. #elif defined (ACE_HAS_WIN32) typedef HANDLE ACE_HANDLE; #if defined (UNIX) typedef int ACE_HANDLE; #endif /* UNIX */ typedef u_long ACE_Reactor_Mask; class ACE_Event_Handler - public: // These values can be bitwise "or'd" together to // instruct the &lt;ACE_Reactor&gt; to check for // multiple events on a single <p> For example, Web servers require watch-dog timers that release resources if clients do not send an HTTP request within a specific time interval after they connect. Likewise, daemon configuration frameworks like the Windows NT Service Control Manager <ref> [4] </ref> require services under their control to peri odically report their current status via heartbeat messages, which can be used to restart services that have terminated abnormally. The ACE Timer Queue class provides mechanisms that allow applications to register time-based concrete event handlers that derive from ACE Event Handler.
Reference: [5] <author> D. C. Schmidt and C. Cleeland, </author> <title> Applying Patterns to Develop Extensible ORB Middleware, </title> <journal> IEEE Communications Magazine, </journal> <note> to appear 1999. </note>
Reference-contexts: Higher-level policies defined by applications to process events Higher-level policies performed by application-specified concrete event handlers include connection establishment strategies, data encoding and decoding, and processing of service requests from clients. For instance, the TAO <ref> [5] </ref> CORBA ORB uses the Reactor framework to separate its low-level event demultiplexing mechanisms from its higher-level policies for GIOP connection management and protocol processing [5]. Increase reuse: The ACE Reactor's demultiplexing and dispatching mechanisms can be reused by many network applications. <p> For instance, the TAO <ref> [5] </ref> CORBA ORB uses the Reactor framework to separate its low-level event demultiplexing mechanisms from its higher-level policies for GIOP connection management and protocol processing [5]. Increase reuse: The ACE Reactor's demultiplexing and dispatching mechanisms can be reused by many network applications. By reusing, rather than reinventing, these mechanisms, developers can concentrate on higher-level application-specific event handler policies, rather than wrestling repeatedly with low-level event demultiplexing and dispatching mechanisms.
Reference: [6] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The ACE Reactor shields applications from portability differences between the underlying event demultiplexing mechanisms. As illustrated in Figure 6, the ACE Reactor exports the same interface to applications, regardless of the native OS APIs. Moreover, the ACE Reactor uses design patterns like Bridge <ref> [6] </ref> to enhance its internal portability. Thus, porting the ACE Reactor from select to WaitForMultipleObjects required only localized changes to the framework [7]. Thread-safety: The Reactor framework is fully thread-safe. Therefore multiple threads can safely share a single ACE Reactor. <p> The ACE Reactor's destructor and close methods deallocate these objects. In addition, to support the common use-case of one event loop per application process, there is a static instance method that returns a pointer to a singleton ACE Reactor, which is created and managed by the Singleton pattern <ref> [6] </ref>. 2 class ACE_Reactor - public: enum - DEFAULT_SIZE = FD_SETSIZE -; // = Singleton access point. static ACE_Reactor *instance (void); // = Initialization and termination methods. // Initialize a Reactor instance that may // contain &lt;size&gt; entries (&lt;restart&gt; indicates // to restart system calls after interrupts). <p> The ACE Reactor interface consists of virtual methods. Therefore, it can be extended via inheritance. The most common way to extend ACE Reactor is not to subclass it, however. Instead, the Bridge pattern <ref> [6] </ref> is used to decouple the ACE Reactor interface from its ACE Reactor Impl subclass implementations, as shown in Figure 6. The implementation of ACE Reactor Impl subclasses differ across OS platforms. However, the method names and overall functionality provided by the ACE Reactor interface remains the same. <p> it possible to minimize the amount of state required to handle many clients that are connected simultaneously to the same event handler. * Implicitly pass the handle: This approach uses the other register handler method on the ACE Reactor: int register_handler (ACE_Event_Handler *event_handler, ACE_Reactor_Mask mask); In this case, a double-dispatch <ref> [6] </ref> is performed by the ACE Reactor to obtain the underlying ACE HANDLE from the concrete event handler via its get handle method.
Reference: [7] <author> D. C. Schmidt and P. Stephenson, </author> <title> Experiences Using Design Patterns to Evolve System Software Across Diverse OS Platforms, </title> <booktitle> in Proceedings of the 9 th European Conference on Object-Oriented Programming, </booktitle> <address> (Aarhus, Denmark), </address> <publisher> ACM, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: Moreover, the ACE Reactor uses design patterns like Bridge [6] to enhance its internal portability. Thus, porting the ACE Reactor from select to WaitForMultipleObjects required only localized changes to the framework <ref> [7] </ref>. Thread-safety: The Reactor framework is fully thread-safe. Therefore multiple threads can safely share a single ACE Reactor. Likewise, multiple ACE Reactors can run in separate threads within a process. The Reactor framework provides the necessary synchronization mechanisms to prevent race conditions and intra-class method deadlock [8].
Reference: [8] <author> D. C. Schmidt, </author> <title> Transparently Parameterizing Synchronization Mechanisms into a Concurrent Distributed Application, </title> <journal> C++ Report, </journal> <volume> vol. 6, </volume> <month> July/August </month> <year> 1994. </year>
Reference-contexts: Thread-safety: The Reactor framework is fully thread-safe. Therefore multiple threads can safely share a single ACE Reactor. Likewise, multiple ACE Reactors can run in separate threads within a process. The Reactor framework provides the necessary synchronization mechanisms to prevent race conditions and intra-class method deadlock <ref> [8] </ref>. Efficient demultiplexing: The ACE Reactor performs its event demultiplexing and dispatching logic efficiently. For instance, the select-based ACE Reactor uses the ACE Handle Set class described in Section 3.2 to avoid examining fd set bitmasks one bit at a time.
Reference: [9] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Asynchronous Completion Token: an Object Behavioral Pattern for Efficient Asynchronous Event Handling, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: This method is passed both (1) the current time and (2) the void * asynchronous completion token (ACT) <ref> [9] </ref>, which was passed as a parameter to schedule timer when the event handler was scheduled originally. When any handle * hook method in a concrete event handler returns &lt; 0, the ACE Reactor automatically invokes that handler's handle close cleanup method. <p> The timer id is used by the cancel method to remove an event handler before it expires. If a non-NULL act is passed to cancel it is set to the asyn chronous completion token (ACT) <ref> [9] </ref> passed in by the appli cation when the timer was originally scheduled. This makes it possible to delete dynamically allocated ACTs to avoid memory leaks. By default, the ACE Timer Queue used by the ACE Reactor is implemented as a heap.
Reference: [10] <author> R. E. Barkley and T. P. Lee, </author> <title> A Heap-Based Callout Implementation to Meet Real-Time Needs, </title> <booktitle> in Proceedings of the USENIX Summer Conference, </booktitle> <pages> pp. 213222, </pages> <publisher> USENIX Association, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: Implementing timers with heaps is particularly useful for real-time applications <ref> [10] </ref> and middleware [11] that require predictable and low-latency timer operations. The ACE Timer Queue heap consists of tuples that contain an ACE Time Value, ACE Event Handler *, and void *.
Reference: [11] <author> D. C. Schmidt, D. L. Levine, and S. Mungee, </author> <title> The Design and Performance of Real-Time Object Request Brokers, </title> <journal> Computer Communications, </journal> <volume> vol. 21, </volume> <pages> pp. 294324, </pages> <month> Apr. </month> <year> 1998. </year>
Reference-contexts: Implementing timers with heaps is particularly useful for real-time applications [10] and middleware <ref> [11] </ref> that require predictable and low-latency timer operations. The ACE Timer Queue heap consists of tuples that contain an ACE Time Value, ACE Event Handler *, and void *. <p> ACE Event Handler pointers and an array of handles are allocated and used internally to store the registered concrete event handlers. 4 Distributed Logging Service Exam ple The Reactor framework is intended to simplify the development of event-driven applications, such as Web servers [14, 15] and CORBA Object Request Brokers <ref> [11] </ref>. This section describes the design and implementation of a distributed logging service that illustrates how to use the ACE Reactor. 4.1 Overview A distributed logging service keeps records diagnostic information sent from one or more applications in a central location.
Reference: [12] <author> D. E. Comer and D. L. Stevens, </author> <title> Internetworking with TCP/IP Vol II: Design, Implementation, and Internals. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Each ACE Time Value in the heap is stored in absolute time units, e.g., as generated by the ACE OS gettimeofday API. Virtual methods are used in the ACE Timer Queue interface. Thus, applications can extend the default ACE implementation to support alternative data structures, such as delta-lists <ref> [12] </ref> or timing wheels [13]. Delta-lists store time in relative units represented as offsets or deltas from the earliest ACE Time Value at the front of the list.
Reference: [13] <author> G. Varghese and T. Lauck, </author> <title> Hashed and Hierarchical Timing Wheels: Data Structures for the Efficient Implementation of a Timer Facility, </title> <booktitle> in The Proceedings of the 11 th Symposium on Operating System Principles, </booktitle> <month> November </month> <year> 1987. </year>
Reference-contexts: Virtual methods are used in the ACE Timer Queue interface. Thus, applications can extend the default ACE implementation to support alternative data structures, such as delta-lists [12] or timing wheels <ref> [13] </ref>. Delta-lists store time in relative units represented as offsets or deltas from the earliest ACE Time Value at the front of the list. Timing wheels use a circular buffer that makes it possible to start, stop, and maintain timers within the range of the wheel in O (1) time.
Reference: [14] <author> J. Hu, S. Mungee, and D. C. Schmidt, </author> <title> Principles for Developing and Measuring High-performance Web Servers over ATM, </title> <booktitle> in Proceeedings of INFOCOM '98, </booktitle> <month> March/April </month> <year> 1998. </year>
Reference-contexts: Instead, a single array of ACE Event Handler pointers and an array of handles are allocated and used internally to store the registered concrete event handlers. 4 Distributed Logging Service Exam ple The Reactor framework is intended to simplify the development of event-driven applications, such as Web servers <ref> [14, 15] </ref> and CORBA Object Request Brokers [11]. This section describes the design and implementation of a distributed logging service that illustrates how to use the ACE Reactor. 4.1 Overview A distributed logging service keeps records diagnostic information sent from one or more applications in a central location.
Reference: [15] <author> J. Hu, I. Pyarali, and D. C. Schmidt, </author> <title> Measuring the Impact of Event Dispatching and Concurrency Models on Web Server Performance Over High-speed Networks, </title> <booktitle> in Proceedings of the 2 nd Global Internet Conference, IEEE, </booktitle> <month> November </month> <year> 1997. </year>
Reference-contexts: Instead, a single array of ACE Event Handler pointers and an array of handles are allocated and used internally to store the registered concrete event handlers. 4 Distributed Logging Service Exam ple The Reactor framework is intended to simplify the development of event-driven applications, such as Web servers <ref> [14, 15] </ref> and CORBA Object Request Brokers [11]. This section describes the design and implementation of a distributed logging service that illustrates how to use the ACE Reactor. 4.1 Overview A distributed logging service keeps records diagnostic information sent from one or more applications in a central location.
Reference: [16] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year>
Reference-contexts: The logging service described below allows clients to send log records to a central logging server, as shown in Figure 7. The logging service combines the event demultiplex-ing and dispatching features of the ACE Reactor together with the C++ socket wrappers described in <ref> [16] </ref>. <p> Likewise, the PEER ACCEPTOR template parameter is replaced by the ACE SOCK Acceptor class. The ACE SOCK * instantiated types are part of a C++ socket wrapper <ref> [16] </ref> that encapsulates the socket interface and allows data to be transmitted reliably between peer processes. By using parameterized types, the classes that perform IPC can be any network programming interface that conforms to the API used by the ACE Acceptor. <p> Extending the ACE Reactor to support this alternative demultiplexing implementation did not require modifications to its public interface. One consequence of the use of OO in the Reactor framework is that it uses dynamic binding extensively. <ref> [16] </ref> discusses why avoiding dynamic binding is often advisable when designing thin C++ wrappers for sockets. On some compilers, the overhead resulting from indirect virtual table dispatching may be fairly high. In such cases, developers may need to refrain from using dynamic binding extensively.
Reference: [17] <author> D. L. Presotto and D. M. Ritchie, </author> <title> Interprocess Communication in the Ninth Edition UNIX System, UNIX Research System Papers, </title> <booktitle> Tenth Edition, </booktitle> <volume> vol. 2, no. 8, </volume> <pages> pp. 523530, </pages> <year> 1990. </year>
Reference-contexts: When invoked by an application, the logging interface formats and timestamps the logging records and writes them to a well-known STREAM pipe <ref> [17] </ref>. A client logging daemon is responsible for processing these records, as described next. Client logging daemon: The client logging daemon runs on every host machine participating in the distributed logging service.
Reference: [18] <author> G. Booch, </author> <title> Object Oriented Analysis and Design with Applications (2 nd Edition). </title> <address> Redwood City, California: Ben-jamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: This output can be redirected to various devices such as printers, persistent storage repositories, or network management consoles. Several C++ class components appear in the logging service architecture. The inheritance and template parameterization relationships between the various components are illustrated in Figure 9 using Booch notation <ref> [18] </ref>.
Reference: [19] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Initializing Communication Services, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: These components are discussed in Section 3. Connection-related components: These generic templates implement the Acceptor-Connector pattern <ref> [19] </ref>, which provides a reusable connection factory. The ACE Acceptor implements the Acceptor component in this pattern it accepts network connections from remote clients and creates ACE Svc Handlers that process data exchanged with the connected client. These components are discussed in Section 4.2.1. <p> These components are discussed in Section 4.2.2. Using this highly-decoupled OO decomposition enhances the design and extensibility of the server logging daemon. Each component is described below. 4.2.1 Connection-related Components The following classes are used to implement the Acceptor component in the Acceptor-Connector pattern <ref> [19] </ref>. The Acceptor component decouples the (1) passive connection establishment and service initialization from (2) the processing performed by the two endpoints of a service once they are connected and initialized. <p> In turn, the SVC HANDLER class must know how to process data exchanged with the client. The ACE Acceptor class implementation is shown in First, it dynamically creates a new SVC HANDLER object, 3 This is a simplified version of the ACE Acceptor. For a complete implementation see <ref> [19] </ref>. 8 Event Handler Logging Acceptor Logging_Handler ACE_SOCK_Acceptor Logging Handler ACE_SOCK_Stream ACE_Null_Synch ACE Handler ACE Acceptor SVC_HANDLER PEER_ACCEPTOR PEER_STREAM SYNCH_STRAT PEER ACCEPTOR A F R A E W R K M N T S N E C T I O - T E D M N T S P P L
Reference: [20] <author> D. C. Schmidt and T. Suda, </author> <title> Transport System Architecture Services for High-Performance Communications Systems, </title> <journal> IEEE Journal on Selected Areas in Communication, </journal> <volume> vol. 11, </volume> <pages> pp. 489506, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Furthermore, the ACE Reactor is typically used to develop distributed applications. The major sources of overhead in distributed systems result from activities like caching, latency, network/host interface hardware, presentation-level formatting, memory-to-memory copying, and process management <ref> [20] </ref>. Therefore, the additional indirection caused by dynamic binding is typically insignificant by comparison [21].
Reference: [21] <author> A. Koenig, </author> <title> When Not to Use Virtual Functions, </title> <journal> C++ Journal, </journal> <volume> vol. 2, no. 2, </volume> <year> 1992. </year>
Reference-contexts: Furthermore, the ACE Reactor is typically used to develop distributed applications. The major sources of overhead in distributed systems result from activities like caching, latency, network/host interface hardware, presentation-level formatting, memory-to-memory copying, and process management [20]. Therefore, the additional indirection caused by dynamic binding is typically insignificant by comparison <ref> [21] </ref>. In addition, good C++ compilers can optimize virtual method overhead away completely via the use of adjustor thunks [22]. 5 Design Rules for Using the Reactor Effectively The ACE Reactor is a powerful framework for demulti-plexing events and dispatching event handlers.
Reference: [22] <author> T. H. Harrison, D. L. Levine, and D. C. Schmidt, </author> <title> The Design and Performance of a Real-time CORBA Event Service, </title> <booktitle> in Proceedings of OOPSLA '97, </booktitle> <address> (Atlanta, GA), </address> <publisher> ACM, </publisher> <month> October </month> <year> 1997. </year>
Reference-contexts: Therefore, the additional indirection caused by dynamic binding is typically insignificant by comparison [21]. In addition, good C++ compilers can optimize virtual method overhead away completely via the use of adjustor thunks <ref> [22] </ref>. 5 Design Rules for Using the Reactor Effectively The ACE Reactor is a powerful framework for demulti-plexing events and dispatching event handlers. Like other frameworks, however, learning to use the ACE Reactor takes time and effort.
Reference: [23] <author> P. S. Inc., </author> <title> Purify User's Guide. </title> <institution> PureAtria Software Inc., </institution> <year> 1996. </year>
Reference-contexts: These problems are hard to track down without the use of a memory error detection tool like Purify <ref> [23] </ref>, which catches some, but not all, of the following lifetime-related problems: 5.4.1 Use Non-dynamically Allocated Event Handlers Sparingly Context: Certain types of applications, such as embedded real-time systems, try to minimize the use of dynamic memory, e.g., to make system performance more predictable.
Reference: [24] <author> D. C. Schmidt, </author> <title> An OO Encapsulation of Lightweight OS Concurrency Mechanisms in the ACE Toolkit, </title> <type> Tech. Rep. </type> <institution> WUCS-95-31, Washington University, St. Louis, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: Example: When the ACE Reactor dispatches a call-back to an event handler's handle * method it holds an ACE Token for the duration of the callback. This ACE Token is defined as a recursive mutex <ref> [24] </ref>, which keeps track of the identify of the thread that holds the mu-tex in order to avoid self-deadlock.
Reference: [25] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year> <month> 21 </month>
Reference-contexts: // ... // This call will return -1 // since the new thread of // control doesn't ``own'' this // &lt;reactor_&gt; instance. reactor_.handle_events (); - private: ACE_Reactor reactor_; -; Since My Server inherits from ACE Task, calling its activate method will make the My Server object become an Active Object <ref> [25] </ref>, which runs its svc hook method entry point in a separate thread of control. Therefore, the handle events method will fail since it still thinks the owner of this ACE Reactor is the original thread that initialized it.
References-found: 25

