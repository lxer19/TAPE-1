URL: http://www-cad.eecs.berkeley.edu/~orna/publications/cav95.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~orna/pub.html
Root-URL: 
Email: Email: orna@eecs.berkeley.edu  
Title: Augmenting Branching Temporal Logics with Existential Quantification over Atomic Propositions  
Author: Orna Kupferman 
Date: June 4, 1997  
Address: Berkeley CA 94720-1770, U.S.A.  
Affiliation: EECS Department UC Berkeley  
Abstract: In temporal-logic model checking, we verify the correctness of a program with respect to a desired behavior by checking whether a structure that models the program satisfies a temporal logic formula that specifies this behavior. One of the ways to overcome the expressiveness limitation of temporal logics is to augment them with quantification over atomic propositions. In this paper we consider the extension of branching temporal logics with existential quantification over atomic propositions. Once we add existential quantification to a branching temporal logic, it becomes sensitive to unwinding. That is, unwinding a structure into an infinite tree does not preserve the set of formulas it satisfies. Accordingly, we distinguish between two semantics, two practices as specification languages, and two versions of the model-checking problem for such a logic. One semantics refers to the structure that models the program, and the second semantics refers to the infinite computation tree that the program induces. We examine the complexity of the model-checking problem in the two semantics for the logics CTL and CTL ? augmented with existential quantification over atomic propositions. Following the cheerless results that we get, we examine also the program complexity of model checking; i.e., the complexity of this problem in terms of the program, assuming the formula is fixed. We show that while fixing the formula dramatically reduces model-checking complexity in the tree semantics, its influence on the structure semantics is poor. fl This research was supported in part by the Office of Naval Research Young Investigator award N00014-95-1-0520, by the National Science Foundation CAREER award CCR-9501708, by the National Science Foundation grant CCR-9504469, by the Air Force Office of Scientific Research contract F49620-93-1-0056, by the Army Research Office MURI grant DAAH-04-96-1-0341, by the Advanced Research Projects Agency grant NAG2-892, and by the Semiconductor Research Corporation contract 95-DC-324.036. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> I. Beer, S. Ben-David, D. Geist, R. Gewirtzman, and M. Yoeli. </author> <title> Methodology and system for practical formal verification of reactive hardware. </title> <booktitle> In Proc. 6th Workshop on Computer Aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 182-193, </pages> <address> Stanford, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Nevertheless, we found in the literature unawareness to this sensitivity. We show that existential quantification increases the expressive power of CTL and CTL ? , in both semantics. In particular, existential quantification in the tree semantics is strong enough to replace satellites. A satellite, as introduced in <ref> [1] </ref>, is a small finite state machine, linked to a design to be verified. It can read the design at any moment and it records particular events of interest, for possible use in the specification of the design. A concept similar to satellites is introduced in [19] as observer processes.
Reference: [2] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <editor> In D. L. Dill, editor, </editor> <booktitle> Computer Aided Verification, Proc. 6th Int. Conference, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 142-155, </pages> <address> Stanford, California, June 1994. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: Recent methods and heuristics such as BDDs [3, 4], modular model checking [7, 13], partial-order techniques, [29], on the fly model checking <ref> [8, 2] </ref>, and others, cope successfully with the known "state explosion" problem and give rise to model checking not only as a lovely theoretical issue, but also as a practical tool used for formal verification. Model-checking methods consider two types of temporal logics: linear and branching [17]. <p> Our main results are summarized in the table below. Quantification with Quantification with No Quantification structure semantics tree semantics CTL model linear time NP-complete EXPTIME-complete checking [6] [Theorem 4.1] [Theorem 4.2] program NLOGSPACE-complete NP-complete P-complete complexity <ref> [2] </ref> [HK94, Theorem 5.1] [Theorem 5.2] CTL ? model PSPACE-complete PSPACE-complete 2EXPTIME-complete checking [10] [Theorem 4.1] [Theorem 4.2] program NLOGSPACE-complete NP-complete P-complete complexity [2] [Theorem 5.1] [Theorem 5.2] Examining our results, we conclude the following. <p> Quantification with Quantification with No Quantification structure semantics tree semantics CTL model linear time NP-complete EXPTIME-complete checking [6] [Theorem 4.1] [Theorem 4.2] program NLOGSPACE-complete NP-complete P-complete complexity <ref> [2] </ref> [HK94, Theorem 5.1] [Theorem 5.2] CTL ? model PSPACE-complete PSPACE-complete 2EXPTIME-complete checking [10] [Theorem 4.1] [Theorem 4.2] program NLOGSPACE-complete NP-complete P-complete complexity [2] [Theorem 5.1] [Theorem 5.2] Examining our results, we conclude the following. First, in the structure semantics, existential quantification takes the model-checking problem for CTL from P to NP-complete.
Reference: [3] <author> R.E. Bryant. </author> <title> Graph-based algorithms for boolean-function manipulation. </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-35(8), </volume> <year> 1986. </year>
Reference-contexts: In model checking, we verify the correctness of a program with respect to a desired behavior by checking whether the program, modeled as a Kripke structure, satisfies (is a model of ) the temporal logic formula that specifies this behavior. Recent methods and heuristics such as BDDs <ref> [3, 4] </ref>, modular model checking [7, 13], partial-order techniques, [29], on the fly model checking [8, 2], and others, cope successfully with the known "state explosion" problem and give rise to model checking not only as a lovely theoretical issue, but also as a practical tool used for formal verification.
Reference: [4] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <journal> Information and Computation, </journal> <volume> 98(2) </volume> <pages> 142-170, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: In model checking, we verify the correctness of a program with respect to a desired behavior by checking whether the program, modeled as a Kripke structure, satisfies (is a model of ) the temporal logic formula that specifies this behavior. Recent methods and heuristics such as BDDs <ref> [3, 4] </ref>, modular model checking [7, 13], partial-order techniques, [29], on the fly model checking [8, 2], and others, cope successfully with the known "state explosion" problem and give rise to model checking not only as a lovely theoretical issue, but also as a practical tool used for formal verification.
Reference: [5] <author> A.K. Chandra, D.C. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 28(1) </volume> <pages> 114-133, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: Proof: Since the algorithms given in the proof of Theorem 4.2 are polynomial in the size of K, membership in P is immediate. We prove hardness in P by reducing the Alternating Graph Accessibility problem, proved to be P-complete in <ref> [15, 5] </ref>, to model checking of a fixed EQCTL t formula. In the Alternating Graph Accessibility problem, we are given a directed graph G = hV; Ei, a partition E [ U of V , and two designated vertices s and t.
Reference: [6] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: For example, the branching temporal logics CTL and CTL ? have, respectively, EXPTIME and 2EXPTIME 2 complete satisfiability bounds [12, 26, 11, 9] and have, respectively, linear-time and PSPACE--complete bounds for their model checking problems <ref> [6, 10] </ref>. <p> Our main results are summarized in the table below. Quantification with Quantification with No Quantification structure semantics tree semantics CTL model linear time NP-complete EXPTIME-complete checking <ref> [6] </ref> [Theorem 4.1] [Theorem 4.2] program NLOGSPACE-complete NP-complete P-complete complexity [2] [HK94, Theorem 5.1] [Theorem 5.2] CTL ? model PSPACE-complete PSPACE-complete 2EXPTIME-complete checking [10] [Theorem 4.1] [Theorem 4.2] program NLOGSPACE-complete NP-complete P-complete complexity [2] [Theorem 5.1] [Theorem 5.2] Examining our results, we conclude the following. <p> to check whether a Kripke structure K satisfies an EQCTL formula 9p 1 : : : p n , we guess a Kripke structure K 0 that differs from K in at most the labeling of p 1 : : : p n , and then check, in linear time <ref> [6] </ref>, whether K 0 satisfies the CTL formula . To prove hardness in NP, we do a reduction from SAT.
Reference: [7] <author> E.M. Clarke, D.E. Long, and K.L. McMillan. </author> <title> Compositional model checking. </title> <booktitle> In Proc. 4th IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 353-362, </pages> <year> 1989. </year> <month> 14 </month>
Reference-contexts: Recent methods and heuristics such as BDDs [3, 4], modular model checking <ref> [7, 13] </ref>, partial-order techniques, [29], on the fly model checking [8, 2], and others, cope successfully with the known "state explosion" problem and give rise to model checking not only as a lovely theoretical issue, but also as a practical tool used for formal verification.
Reference: [8] <author> C. Courcoubetis, M.Y. Vardi, P. Wolper, and M. Yannakakis. </author> <title> Memory efficient algorithms for the verification of temporal properties. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 1 </volume> <pages> 275-288, </pages> <year> 1992. </year>
Reference-contexts: Recent methods and heuristics such as BDDs [3, 4], modular model checking [7, 13], partial-order techniques, [29], on the fly model checking <ref> [8, 2] </ref>, and others, cope successfully with the known "state explosion" problem and give rise to model checking not only as a lovely theoretical issue, but also as a practical tool used for formal verification. Model-checking methods consider two types of temporal logics: linear and branching [17].
Reference: [9] <author> E.A. Emerson and C. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proceedings of the 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <address> White Plains, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: Here, naturally enough, comes the question of complexity. The satisfiability problem for a branching temporal logic L is usually harder than its model-checking problem. For example, the branching temporal logics CTL and CTL ? have, respectively, EXPTIME and 2EXPTIME 2 complete satisfiability bounds <ref> [12, 26, 11, 9] </ref> and have, respectively, linear-time and PSPACE--complete bounds for their model checking problems [6, 10]. <p> Here, following [11], we have that A D; is a Rabin tree automaton with 2 2 j j states and 2 j j pairs. By <ref> [9] </ref>, checking the nonemptiness of L (A K;S )"L (A D; ) can then be done in time poly (jKj fl 2 2 j'j ). <p> It is easy to see that if is satisfiable then ' is satisfiable too. For the second direction, we need the finite model property of CTL. The proof of (2) is similar, using the 2EXPTIME bounds for CTL ? <ref> [26, 11, 9] </ref>. 12 5 Program Complexity of Model Checking In the previous section, we presented some cheerless results concerning the model-checking complexity of branching temporal logics augmented with existential quantification over atomic propositions. In this section we consider the program complexity of model checking for these logics.
Reference: [10] <author> E.A. Emerson and C.-L. Lei. </author> <title> Modalities for model checking: Branching time logic strikes back. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-96, </pages> <address> New Orleans, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: For example, the branching temporal logics CTL and CTL ? have, respectively, EXPTIME and 2EXPTIME 2 complete satisfiability bounds [12, 26, 11, 9] and have, respectively, linear-time and PSPACE--complete bounds for their model checking problems <ref> [6, 10] </ref>. <p> Our main results are summarized in the table below. Quantification with Quantification with No Quantification structure semantics tree semantics CTL model linear time NP-complete EXPTIME-complete checking [6] [Theorem 4.1] [Theorem 4.2] program NLOGSPACE-complete NP-complete P-complete complexity [2] [HK94, Theorem 5.1] [Theorem 5.2] CTL ? model PSPACE-complete PSPACE-complete 2EXPTIME-complete checking <ref> [10] </ref> [Theorem 4.1] [Theorem 4.2] program NLOGSPACE-complete NP-complete P-complete complexity [2] [Theorem 5.1] [Theorem 5.2] Examining our results, we conclude the following. First, in the structure semantics, existential quantification takes the model-checking problem for CTL from P to NP-complete. <p> formula ~ over the propositions p 1 : : : p n is satisfiable if and only if the EQCTL formula 9p 1 : : : p n ~ is satisfied in a one-state frame. (2) Both membership and hardness in PSPACE follow from being CTL ? model checking PSPACE-complete <ref> [10] </ref>. While hardness is immediate, Savitch's Theorem [23] is required for the membership. 1 K 5 4 3 2,01,4 1,2 2,1 3,13,0 2,2 0 1 4,44,3 4,1 4 .
Reference: [11] <author> E.A. Emerson and A. P. Sistla. </author> <title> Deciding branching time logic. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Theory of Computing, </booktitle> <address> Washington, </address> <month> April </month> <year> 1984. </year>
Reference-contexts: Here, naturally enough, comes the question of complexity. The satisfiability problem for a branching temporal logic L is usually harder than its model-checking problem. For example, the branching temporal logics CTL and CTL ? have, respectively, EXPTIME and 2EXPTIME 2 complete satisfiability bounds <ref> [12, 26, 11, 9] </ref> and have, respectively, linear-time and PSPACE--complete bounds for their model checking problems [6, 10]. <p> Theorems 3.1 and 3.2 clearly hold also with respect to EQCTL ? . Insensitivity to the sensitivity of EQCTL and EQCTL ? to unwinding hides also when com paring these logics with tree automata <ref> [11] </ref>. Indeed, EQCTL ? t is as expressive as symmetric pair automata on infinite binary trees. Nevertheless, the translation of EQCTL ? t into 2S2, which is the base of this equivalence, does not hold for EQCTL ? . <p> Here, following <ref> [11] </ref>, we have that A D; is a Rabin tree automaton with 2 2 j j states and 2 j j pairs. By [9], checking the nonemptiness of L (A K;S )"L (A D; ) can then be done in time poly (jKj fl 2 2 j'j ). <p> It is easy to see that if is satisfiable then ' is satisfiable too. For the second direction, we need the finite model property of CTL. The proof of (2) is similar, using the 2EXPTIME bounds for CTL ? <ref> [26, 11, 9] </ref>. 12 5 Program Complexity of Model Checking In the previous section, we presented some cheerless results concerning the model-checking complexity of branching temporal logics augmented with existential quantification over atomic propositions. In this section we consider the program complexity of model checking for these logics.
Reference: [12] <author> M.J. Fischer and R.E. Ladner. </author> <title> Propositional dynamic logic of regular programs. </title> <journal> J. of Computer and Systems Sciences, </journal> <volume> 18 </volume> <pages> 194-211, </pages> <year> 1979. </year>
Reference-contexts: Here, naturally enough, comes the question of complexity. The satisfiability problem for a branching temporal logic L is usually harder than its model-checking problem. For example, the branching temporal logics CTL and CTL ? have, respectively, EXPTIME and 2EXPTIME 2 complete satisfiability bounds <ref> [12, 26, 11, 9] </ref> and have, respectively, linear-time and PSPACE--complete bounds for their model checking problems [6, 10]. <p> By [27], the later can be checked in time poly (jKj fl 2 j'j ). For proving hardness in EXPTIME, we reduce the satisfiability problem for CTL, proved to be EXPTIME-hard in <ref> [12] </ref>, to EQCTL t model checking. For every m 1, let K m denote the frame hf1; : : :; mg; f1; : : :; mg fi f1; : : : ; mg; 1i. The frame K 4 is presented in Figure 1.
Reference: [13] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <booktitle> In Proc. 2nd Conferance on Concurrency Theory, volume 527 of Lecture Notes in Computer Science, </booktitle> <pages> pages 250-265. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Recent methods and heuristics such as BDDs [3, 4], modular model checking <ref> [7, 13] </ref>, partial-order techniques, [29], on the fly model checking [8, 2], and others, cope successfully with the known "state explosion" problem and give rise to model checking not only as a lovely theoretical issue, but also as a practical tool used for formal verification.
Reference: [14] <author> J.Y. Halpern and B. Kapron. </author> <title> Zero-one laws for modal logic. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 69 </volume> <pages> 157-193, </pages> <year> 1994. </year>
Reference-contexts: In this section we consider the program complexity of model checking for these logics. Theorem 5.1 (1) <ref> [14] </ref> The program complexity of EQCTL model checking is NP-complete. (2) The program complexity of EQCTL ? model checking is NP-complete. Proof: (1) Membership in NP is immediate. In [14], Halpern and Kapron reduce satisfiability of CNF formulas to model checking of a fixed formula ' in 1 1 (9xMDL). <p> In this section we consider the program complexity of model checking for these logics. Theorem 5.1 (1) <ref> [14] </ref> The program complexity of EQCTL model checking is NP-complete. (2) The program complexity of EQCTL ? model checking is NP-complete. Proof: (1) Membership in NP is immediate. In [14], Halpern and Kapron reduce satisfiability of CNF formulas to model checking of a fixed formula ' in 1 1 (9xMDL). Whatever the logic 1 1 (9xMDL) is 1 , the formula ' is equivalent to an EQCTL formula.
Reference: [15] <author> N. Immerman. </author> <title> Number of quantifiers is better than number of tape cells. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 22(3) </volume> <pages> 384-406, </pages> <year> 1981. </year>
Reference-contexts: Proof: Since the algorithms given in the proof of Theorem 4.2 are polynomial in the size of K, membership in P is immediate. We prove hardness in P by reducing the Alternating Graph Accessibility problem, proved to be P-complete in <ref> [15, 5] </ref>, to model checking of a fixed EQCTL t formula. In the Alternating Graph Accessibility problem, we are given a directed graph G = hV; Ei, a partition E [ U of V , and two designated vertices s and t.
Reference: [16] <author> O. Kupferman and A. Pnueli. </author> <title> Once and for all. </title> <booktitle> In Proc. 10th IEEE Symposium on Logic in Computer Science, </booktitle> <address> San Diego, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Note that the quantified proposition q labels a node iff s holds in its predecessor node. In fact, by <ref> [16] </ref>, existential quantification is sufficient to express any occurrence of events in the past that can be expressed by linear temporal logic. In addition, we can use existential quantification to count y modulo z. The way we use formulas in the structure semantics is different. <p> Symmetrically, we can model check an infinite computation tree using, say, automata-theoretic methods, and adopt the result for all Kripke structures that can be unwound into this tree. Augmenting CTL with past-time modalities, it becomes sensitive to unwinding. Since past-time modalities can be expressed by existential quantification <ref> [16] </ref>, we have the following: Theorem 3.1 EQCTL is sensitive to unwinding.
Reference: [17] <author> L. Lamport. </author> <title> Sometimes is sometimes "not never" on the temporal logic of programs. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-185, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Model-checking methods consider two types of temporal logics: linear and branching <ref> [17] </ref>. In linear temporal logics, each moment in time has a unique possible future. Accordingly, linear temporal logic formulas are interpreted over a path in a Kripke structure and refer to a single computation of a program.
Reference: [18] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107, </pages> <address> New Orleans, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: Lichtenstein and Pnueli argued that when analyzing the complexity of model checking, a distinction should be made between complexity in the size of the input structure and complexity in the size of the input formula; it is the complexity in size of the structure that is typically the computational bottleneck <ref> [18] </ref>. Following this approach, we consider also the program complexity [27] of model checking for these logics; i.e., the complexity of this problem in terms of the size of the input Kripke structure, assuming the formula is fixed. Our main results are summarized in the table below.
Reference: [19] <author> D.E. </author> <title> Long. Model checking, abstraction and compositional verification. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, Pittsburgh, </institution> <year> 1993. </year>
Reference-contexts: It can read the design at any moment and it records particular events of interest, for possible use in the specification of the design. A concept similar to satellites is introduced in <ref> [19] </ref> as observer processes. For example, we can define a satellite Raise (s) which detects cycles in which the signal s is raised. Satellites overcome the expressiveness limitations of CTL and are used successfully as a part of the formal-verification system in IBM Haifa.
Reference: [20] <author> S. Pinter and P. Wolper. </author> <title> A temporal logic for reasoning about partially ordered computations. </title> <booktitle> In Proc. 3rd ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 28-37, </pages> <address> Vancouver, </address> <month> August </month> <year> 1984. </year>
Reference-contexts: In addition, we can use existential quantification to count y modulo z. The way we use formulas in the structure semantics is different. There, formulas describe a single computation which is a partially ordered set <ref> [20] </ref>.
Reference: [21] <author> A. Pnueli. </author> <title> The temporal semantics of concurrent programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 45-60, </pages> <year> 1981. </year>
Reference-contexts: 1 Introduction Temporal logics, which are modal logics that enable the description of occurrence of events in time, serve as a classical tool for specifying behaviors of concurrent programs <ref> [21] </ref>. The appropriateness of temporal logics follows from the fact that finite-state programs can be modeled by finite propositional Kripke structures, whose properties can be specified using propositional temporal logic. This yields fully-algorithmic methods for synthesis and for reasoning about the correctness of programs.
Reference: [22] <author> A. Pnueli and R. Rosner. </author> <title> On the synthesis of a reactive module. </title> <booktitle> In Proceedings of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin, </address> <month> Januery </month> <year> 1989. </year>
Reference-contexts: Naturally, there is a trade-off between the expressive power of the logic and the complexity of its model-checking problem: the more a logic is expressive, the more expensive its model checking is. Adding quantification over atomic propositions increases the expressive power of temporal logics <ref> [24, 25, 22] </ref>. In this paper, we consider the extension of branching temporal logics with existential quantification.
Reference: [23] <author> W.J. Savitch. </author> <title> Relationship between nondeterministic and deterministic tape complexities. </title> <journal> J. on Computer and System Sciences, </journal> <volume> 4 </volume> <pages> 177-192, </pages> <year> 1970. </year>
Reference-contexts: While hardness is immediate, Savitch's Theorem <ref> [23] </ref> is required for the membership. 1 K 5 4 3 2,01,4 1,2 2,1 3,13,0 2,2 0 1 4,44,3 4,1 4 .
Reference: [24] <author> A.P. Sistla. </author> <title> Theoretical issues in the design of distributed and concurrent systems. </title> <type> PhD thesis, </type> <institution> Harward University, </institution> <address> Cambridge, MA, </address> <year> 1983. </year> <month> 15 </month>
Reference-contexts: Naturally, there is a trade-off between the expressive power of the logic and the complexity of its model-checking problem: the more a logic is expressive, the more expensive its model checking is. Adding quantification over atomic propositions increases the expressive power of temporal logics <ref> [24, 25, 22] </ref>. In this paper, we consider the extension of branching temporal logics with existential quantification.
Reference: [25] <author> A.P. Sistla, M.Y. Vardi, and P. Wolper. </author> <title> The complementation problem for Buchi automata with applications to temporal logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 49 </volume> <pages> 217-237, </pages> <year> 1987. </year>
Reference-contexts: Naturally, there is a trade-off between the expressive power of the logic and the complexity of its model-checking problem: the more a logic is expressive, the more expensive its model checking is. Adding quantification over atomic propositions increases the expressive power of temporal logics <ref> [24, 25, 22] </ref>. In this paper, we consider the extension of branching temporal logics with existential quantification.
Reference: [26] <author> M.Y. Vardi and L. Stockmeyer. </author> <title> Improved upper and lower bounds for modal logics of programs. </title> <booktitle> In Proc 17th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 240-251, </pages> <year> 1985. </year>
Reference-contexts: Here, naturally enough, comes the question of complexity. The satisfiability problem for a branching temporal logic L is usually harder than its model-checking problem. For example, the branching temporal logics CTL and CTL ? have, respectively, EXPTIME and 2EXPTIME 2 complete satisfiability bounds <ref> [12, 26, 11, 9] </ref> and have, respectively, linear-time and PSPACE--complete bounds for their model checking problems [6, 10]. <p> By [9], checking the nonemptiness of L (A K;S )"L (A D; ) can then be done in time poly (jKj fl 2 2 j'j ). To prove hardness of EQCTL ? t model checking in 2EXPTIME, we reduce satisfiability of CTL ? , proved to be 2EXPTIME-hard in <ref> [26] </ref>, to EQCTL ? t model checking. Since a CTL ? formula is satisfiable iff it is satisfied in a tree of branching degree j j, the same reduction that works for EQCTL t works also here. <p> It is easy to see that if is satisfiable then ' is satisfiable too. For the second direction, we need the finite model property of CTL. The proof of (2) is similar, using the 2EXPTIME bounds for CTL ? <ref> [26, 11, 9] </ref>. 12 5 Program Complexity of Model Checking In the previous section, we presented some cheerless results concerning the model-checking complexity of branching temporal logics augmented with existential quantification over atomic propositions. In this section we consider the program complexity of model checking for these logics.
Reference: [27] <author> M.Y. Vardi and P. Wolper. </author> <title> Automata-theoretic techniques for modal logics of programs. </title> <journal> Journal of Computer and System Science, </journal> <volume> 32(2) </volume> <pages> 182-21, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Following this approach, we consider also the program complexity <ref> [27] </ref> of model checking for these logics; i.e., the complexity of this problem in terms of the size of the input Kripke structure, assuming the formula is fixed. Our main results are summarized in the table below. <p> Given a set D IN and an EQCTL t formula ' = 9p 1 : : : p n , let A D; be a Buchi tree automaton that accepts exactly all the tree models of with branching degrees in D. By <ref> [27] </ref>, such A D; of size O (jDj fl 2 j j ) exists. <p> Taking D as the set of branching degrees in T K and taking S = fp 1 : : : p n g, we get that K j= t ' iff L (A K;S ) " L (A D; ) 6= ;. By <ref> [27] </ref>, the later can be checked in time poly (jKj fl 2 j'j ). For proving hardness in EXPTIME, we reduce the satisfiability problem for CTL, proved to be EXPTIME-hard in [12], to EQCTL t model checking.
Reference: [28] <author> P. Wolper. </author> <title> Temporal logic can be more expressive. </title> <journal> Information and Control, </journal> <volume> 56(1-2):72-99, </volume> <year> 1983. </year>
Reference-contexts: As opposed to ' 1 , the formula ' 2 enables states which can be reached from the initial state by both an even and an odd number of transitions can be labeled with q. As CTL can not specify G2 (p) <ref> [28] </ref>, we have the following: Theorem 3.2 EQCTL and EQCTL t are both strictly more expressive than CTL. Theorems 3.1 and 3.2 clearly hold also with respect to EQCTL ? .
Reference: [29] <author> P. Wolper and P. Godefroid. </author> <title> Partial-order methods for temporal verification. </title> <booktitle> In Proc. 4th Confer-ance on Concurrency Theory, volume 715 of Lecture Notes in Computer Science, </booktitle> <pages> pages 233-246, </pages> <address> Hildesheim, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. 16 </note>
Reference-contexts: Recent methods and heuristics such as BDDs [3, 4], modular model checking [7, 13], partial-order techniques, <ref> [29] </ref>, on the fly model checking [8, 2], and others, cope successfully with the known "state explosion" problem and give rise to model checking not only as a lovely theoretical issue, but also as a practical tool used for formal verification.
References-found: 29

