URL: http://www.cs.jhu.edu/techreps/1998/1998.04.ps
Refering-URL: http://www.cs.jhu.edu/techreps/1998/index.html
Root-URL: http://www.cs.jhu.edu
Email: Email: hongxia@cs.jhu.edu, sullivan@cs.jhu.edu, masson@cs.jhu.edu  
Phone: Phone: (410)-516-8710 Fax: (410)-516-6134  
Title: Certifying Generic Branch-and-Bound Computations  
Author: Hongxia Jin Gregory F. Sullivan Gerald M. Masson 
Address: Baltimore, MD 21218  
Affiliation: Computer Science Dept., Johns Hopkins Univ.,  
Abstract: Computationally intensive problems provide a major motivation for developing techniques for certifying answers. The execution of intensive computations can suffer from faults in hardware and errors in software which remain dormant during less intensive computations. We have conducted an investigation of problems which are amenable to the powerful and widely used `branch-and-bound' strategy. This strategy can be used to solve difficult problems such as, the well known NP-hard Traveling Salesman problem, and the Knapsack problem. We show how the certification-trail method can productively be applied to efficiently and substantially raise the confidence in the correctness of results generated by branch-and-bound programs. We apply the method to a generic branch-and-bound algorithm and prove the correctness of the three algorithms which are designated the original, primary, and certifier algorithms. We also present experimental results for two examples which demonstrate that the certifier computation is ten to one-hundred times faster than the primary computation. This means that dramatic time savings are possible when building reliable software using the described method. fl This research was supported by NSF grant CCR-9319945
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anderson, T., and Lee, P., </author> <title> Fault Tolerance: Principle and Practices, </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, NJ, </address> <year> 1981. </year>
Reference: [2] <author> Avizienis, A., and Kelly, J., </author> <title> "Fault tolerance by design diversity: concepts and experiments," </title> <journal> Computer, </journal> <volume> vol. 17, </volume> <pages> pp. 67-80, </pages> <month> Aug., </month> <year> 1984. </year>
Reference: [3] <author> Avizienis, A., </author> <title> "The N-version approach to fault tolerant software," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. 11, </volume> <pages> pp. 1491-1501, </pages> <month> Dec., </month> <year> 1985 </year>
Reference: [4] <author> Blum, M., and Kannan, S., </author> <title> "Designing programs that check their work", </title> <booktitle> Proceedings of the 1989 ACM Symposium on Theory of Computing, </booktitle> <pages> pp. 86-97, </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference: [5] <author> Blum, M., and Wasserman, H., </author> <title> "Reflections on the Pentium Division Bug", </title> <journal> IEEE Trans. on Computers, pp. </journal> <volume> 385-393, vol. 45, </volume> <month> April, </month> <year> 1996. </year>
Reference: [6] <author> Chen, L., and Avizienis A., </author> <title> "N-version programming: a fault tolerant approach to reliability of software operation," </title> <booktitle> Digest of the 1978 Fault Tolerant Computing Symposium, </booktitle> <address> pp.3-9, </address> <publisher> IEEE Computer Society Press, </publisher> <year> 1978 </year>
Reference: [7] <author> Craig, R., </author> <title> Personal communication. A C code implementation of a Traveling Salesman Problem algorithm based on a Pascal implementation described in the textbook "Discrete Optimization Algorithms: with Pascal Programs", by Syslo, </title> <editor> M., Deo, N., and Kowalik, J.S., </editor> <publisher> Prentice-Hall, </publisher> <year> 1983. </year>
Reference: [8] <author> Garey, M. R., and Johnson, D. S., </author> <title> Computers and Intractability W. </title> <editor> H. </editor> <publisher> Freeman and Company, </publisher> <address> San Francisco, CA, </address> <year> 1979. </year>
Reference-contexts: Problems whose solutions involve the exploration of a massive search space are often compu-tationally intensive. In this paper, we will present experimental results for programs which solve the Traveling Salesman problem [17][7], and the Single Knapsack problem [12]. These problems are each NP-hard <ref> [8] </ref> and the programs which solve them each use a branch-and-bound strategy to efficiently investigate a large search space and to find an optimal solution. This paper has three main parts. First, we present a generic branch-and-bound algorithm and prove it correct.
Reference: [9] <author> Huang, K.-H., and Abraham, J., </author> <title> "Algorithm-based fault tolerance for matrix operations," </title> <journal> IEEE Trans. on Computers, pp. </journal> <volume> 518-529, vol. C-33, </volume> <month> June, </month> <year> 1984. </year>
Reference: [10] <author> Lee, Y. H. and Shin, K. G., </author> <title> "Design and evaluation of a fault-tolerant multiprocessor using hardware recovery blocks," </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. C-33, </volume> <pages> pp. 113-124, </pages> <month> Feb. </month> <year> 1984. </year>
Reference: [11] <author> Papadimitriou, C. H. and Steiglitz, K., </author> <title> "Some Complexity Results for the Traveling Salesman Problem", </title> <booktitle> Proceedings of the Eighth ACM Symposium on Theory of Computing, </booktitle> <pages> pp. 1-9, </pages> <publisher> ACM Press, </publisher> <year> 1976. </year>
Reference: [12] <author> Rifkin, Adam, </author> <title> 0-1 Knapsack Algorithm Solution Example branch and bound program used in course Computer Science 138a California Institute of Technology, </title> <note> 1994, http://csvax.cs.caltech.edu/%7Ecs138/138a/examples/knapsack/. </note>
Reference-contexts: Problems whose solutions involve the exploration of a massive search space are often compu-tationally intensive. In this paper, we will present experimental results for programs which solve the Traveling Salesman problem [17][7], and the Single Knapsack problem <ref> [12] </ref>. These problems are each NP-hard [8] and the programs which solve them each use a branch-and-bound strategy to efficiently investigate a large search space and to find an optimal solution. This paper has three main parts. First, we present a generic branch-and-bound algorithm and prove it correct. <p> A branch-and-bound strategy can be used to solve this problem. The original code we based our experiment on was written for a class at the California Institute of Technology <ref> [12] </ref>. The splitting operation takes a subproblem and splits it into exactly two subproblems. In one sub-problem, a chosen element must be in the knapsack, and in the other subproblem the chosen element must not be in the knapsack. The bounding operation is based on an upper-bound calculation.
Reference: [13] <author> Randell, B., </author> <title> "System structure for software fault tolerance," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. 1, </volume> <pages> pp. 220-232, </pages> <month> June, </month> <year> 1975. </year>
Reference-contexts: 1 Introduction A variety of techniques have been developed to help detect, and in some cases correct, errors and faults which are manifested during the execution of computer software, e.g., N-version programming [6][2][3], recovery blocks <ref> [13] </ref>, algorithm-based techniques [9][14], checkers [4][5], and certification trails [15][16]. The need for such techniques is particularly acute when com-putationally intensive tasks are performed. Such tasks often thoroughly exercise hardware and software modules, and thus are more likely to produce novel and unanticipated difficulties during execution.
Reference: [14] <author> Roy-Chowdhury, A., and Banerjee, P., </author> <title> "Algorithm-based fault location and recovery for matrix computations on multiprocessor systems," </title> <journal> IEEE Trans. on Computers, pp. </journal> <volume> 1239-1247, vol. 45, </volume> <month> November, </month> <year> 1996. </year>
Reference: [15] <author> Sullivan, G. F., Wilson, D., and Masson, G. M., </author> <title> "Certification of Computational Results", </title> <journal> IEEE Trans. on Computers, pp. </journal> <volume> 833-847, Vol. 44, </volume> <year> 1995. </year> <month> 20 </month>
Reference-contexts: For the generic algorithms presented here we assume that the two functions lower bound primary and lower bound certifier together form a certification-trail solution to the problem defined by the lower bound function. Therefore by the definition of certification trail <ref> [15] </ref> we have the following two properties: (1) 8 A 2 subproblem 9 lowbound 2 problem value 9 lowbnd cert trail 2 lower bnd trail lower bound primary (A) = (lowbound, lowbnd cert trail) and lower bound certifier (A, lowbnd cert trail) = lowbound and lower bound (A) = lowbound. (2)
Reference: [16] <author> Sullivan, </author> <title> G.F., and Masson, G.M., "Certification Trails for Data Structures," </title> <booktitle> Digest of the 1991 Fault Tolerant Computing Symposium, </booktitle> <pages> pp. 240-247, </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference: [17] <author> Syslo, M., Deo, N., and Kowalik, J. S., </author> <title> Discrete Optimization Algorithms: with Pascal Programs Prentice-Hall, </title> <address> Englewood Cliffs, NJ, </address> <year> 1983. </year>
Reference: [18] <author> Wilson, D., Sullivan, G. F., and Masson, G., </author> <title> "Certification Trails and Software Design for Testability", </title> <booktitle> Proceedings of the 1993 International Test Conference, </booktitle> <pages> pp. 200-209, </pages> <publisher> International Test Conference IEEE Computer Society Press, </publisher> <month> October </month> <year> 1993. </year> <month> 21 </month>
References-found: 18

