URL: ftp://ftp.cs.virginia.edu/pub/techreports/IPC-91-10.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Abstract-found: 0
Intro-found: 1
Reference: [Com79] <author> D. Comer, </author> <title> The Ubiquitous B-Tree, </title> <journal> Computing Surveys 11,2 (June 1979), </journal> <pages> 121-137. </pages>
Reference-contexts: An object is decomposed into a set of elementary regions, such that each element is uniquely identified by a single z value. Then the individual (z_value , object_id ) pairs are inserted into a B-tree <ref> [Com79] </ref>. The ordered sequence of all (z_value , object_id ) pairs at the lowest-level of the B-tree is termed GF-sequence. Spatial search proceeds by a similar decomposition of the search region and by performing a prefix-matching search for each z value obtained.
Reference: [Fae79] <author> R. Fagin and et.al., </author> <title> Extendible Hashing---A Fast Access Method for Dynamic Files, </title> <journal> Trans. Database Systems 4,3 (Sep. </journal> <year> 1979), </year> <pages> 315-344. </pages>
Reference-contexts: The storage utilization of blocks in a Q 0 -tree and its total storage overhead can be estimated by viewing the blocks of Q 0 -trees as leaves in paginated binary tries (i.e. binary tries whose leaves are blocks of data) with n items. Then from <ref> [Fae79, OrP89] </ref> it directly follows that the expected storage utilization of blocks in a Q 0 -tree asymptotically converges to ln 2 ~ ~ 0.693 as in B-trees [Yao78].
Reference: [Fre60] <author> E. </author> <title> Fredkin, </title> <booktitle> Many-way Information Retrieval, Comm. of the ACM 3(1960), </booktitle> <pages> 490-500. </pages>
Reference-contexts: However, pixels 1000 and 1001 comprise the simple rectangle denoted by the locational code 100. 2.1. Region Quadtrees The recursive D-dimensional decomposition of an image can be expressed as a tree (or more precisely, a trie <ref> [Fre60] </ref>) with the degree 2 D , i.e. with each interior node possessing exactly 2 D sons.
Reference: [Gar82] <author> I. </author> <title> Gargantini, An Effective Way to Represent Quadtrees, </title> <journal> Comm. of the ACM 25,12 (Dec. </journal> <year> 1982), </year> <pages> 905-910. </pages>
Reference-contexts: In this representation only the locational codes for leaves corresponding to the non-empty regions need to be retained. (This representation is identical to the GF-sequence of Orenstein when objects do not overlap in space.) Some variations on this scheme make the length field implicit <ref> [Gar82] </ref>. The spatial search is accomplished by traversing the structure as achieved by a modular arithmetic or by manipulating letters (bits) in the locational codes. This, of course, entails a substantial computational overhead.
Reference: [GuB91] <author> O. Gunther and J. Bilmes, </author> <title> Tree-Based Access Methods for Spatial Databases: Implementation and Performance Evaluation, </title> <journal> IEEE Trans. Knowledge and Data Engineering 3,3 (Sep. </journal> <year> 1991). </year>
Reference-contexts: All of these methods base their search on a form of bounding rectangle. But, to minimize the number of false drops and hopefully increase the processing efficiency, different representations of spatial extent should be considered. One promising method is the cell tree <ref> [GuB91] </ref>, which allows objects with arbitrary shapes, but requires their decomposition into convex cells both for storage and for search purposes. Convex pieces of a single object must be inserted in the structure individually. <p> The situation is reversed when considering the lengths of individual entries. Q 0 -trees need at most 6 bytes per entry, zkd B-trees usually 8 bytes, while for cell trees a typical entry length of 20 bytes was reported <ref> [GuB91] </ref>. Considering all this we can contrast anticipated behavior of Q 0 -trees and zkd B-trees in different situations.
Reference: [Gut84] <author> A. Guttman, R-trees: </author> <title> A Dynamic Index Structure for Spatial Searching, </title> <booktitle> Proc. ACM SIGMOD Conf. on Management of Data, </booktitle> <address> Boston, MA, </address> <year> 1984, </year> <pages> 47-57. </pages>
Reference-contexts: In addition to its sensitivity to input distributions, this method has an apparent memory-management problem, arising from its need to keep the linear scales in memory. A new method, called hB-trees [LoS90], which is a combination of transformation and clipping schemes, provides better resolution of these problems. R-trees <ref> [Gut84] </ref> are a representative example of an overlapping-region scheme. Like B-trees, it is a hierarchical collection of nodes, yielding efficient main memory management. Leaf nodes contain vectors describing the bounding rectangles of D-dimensional objects in space.
Reference: [KaE80] <author> E. Kawaguchi and T. Endo, </author> <title> On a Method of Binary Picture Representation and Its Application to Data Compression, </title> <journal> IEEE Trans. Pattern Anal. Mach. Intell. </journal> <month> 2,1 (Jan. </month> <year> 1980), </year> <pages> 27-35. </pages>
Reference-contexts: This, of course, entails a substantial computational overhead. The second approach to represent a quadtrie is in terms of a traversal of its nodes, usually depth-first <ref> [KaE80] </ref>. Let us treat the leaves as being "W-leaves" (if they correspond to empty, i.e. white regions) or "B-leaves" (otherwise). An interior node can be denoted with an "I". Then the depth-first traversal of the quadtree of Figure 2-2 (a) produces: IIBBBBIWWBWIBBWWB.
Reference: [KEM83] <author> E. Kawaguchi, T. Endo and J. Matsunaga, </author> <title> Depth-First Expression Viewed from Digital Picture Processing, </title> <journal> IEEE Trans. Pattern Anal. Mach. Intell. </journal> <month> 5,4 (July </month> <year> 1983), </year> <pages> 373-384. </pages>
Reference-contexts: Then the depth-first traversal of the quadtree of Figure 2-2 (a) produces: IIBBBBIWWBWIBBWWB. Equivalently, the 0-order traversal of the bintree yields: IIIBIBBIWIBWIIBWB. Although very compact, either encoding significantly complicates the operations on the representation, including the spatial search which tends to be very expensive <ref> [KEM83] </ref>. 11 2.2. The Q 0 -Representation We now introduce a new, efficient linear representation of quadtrees (more precisely, bin-trees), called Q 0 -representation (Q standing for quadtree and subscript 0 for 0-order traversal), which can be viewed as a combination of both the leaf-encoding and the traversal representation schemes.
Reference: [Lit80] <author> W. Litwin, </author> <title> Linear Virtual Hashing: A New Tool For Files and Tables Implementation, </title> <booktitle> Proc. 6th Conf. on VLDB, </booktitle> <address> Montreal, Canada, </address> <month> Oct. </month> <year> 1980, </year> <pages> 212-223. </pages>
Reference-contexts: Clipping schemes based on multidimensional hashing often use known hashing methods as their paradigms, such as PLOP-hashing [SeK88] which is based on linear hashing <ref> [Lit80] </ref>. The essence of these methods is that they partition a D-dimensional space into D-dimensional slices by a set of hyperplanes parallel to the axes. The bounding rectangle of an object can intersect several hyperplanes and its parts may lie in different slices.
Reference: [LoS90] <author> D. Lomet and B. Salzberg, </author> <title> The hB-Tree: A Multi-Attribute Access Method with Good Guaranteed Performance, </title> <journal> Trans. </journal> <note> Database Systems 15,4 (Dec. </note> <year> 1990), </year> <pages> 625-658. </pages>
Reference-contexts: In addition to its sensitivity to input distributions, this method has an apparent memory-management problem, arising from its need to keep the linear scales in memory. A new method, called hB-trees <ref> [LoS90] </ref>, which is a combination of transformation and clipping schemes, provides better resolution of these problems. R-trees [Gut84] are a representative example of an overlapping-region scheme. Like B-trees, it is a hierarchical collection of nodes, yielding efficient main memory management.
Reference: [NHS84] <author> J. Nievergelt, H. Hinterberger and K. C. Sevcik, </author> <title> The Grid File: An Adaptable, Symmetric Multikey File Structure, </title> <journal> Trans. Database Systems 9,1 (Mar. </journal> <year> 1984), </year> <pages> 38-71. </pages>
Reference-contexts: But, the common problem of all spatial-search schemes based on enclosing-rectangle approximations is the increased number of false drops, or access of blocks not containing relevant data. We next examine selected methods within each of these three groups using minimal enclosing rectangles. Grid files <ref> [NHS84] </ref> are a transformation method which maps each rectangle to a point in a higher-dimensional space. The structure requires a D-dimensional array of pointers to disk blocks kept on secondary storage, which is called a grid directory.
Reference: [OrM84] <author> J. A. Orenstein and T. Merret, </author> <title> A Class of Data Structures for Associative Searching, </title> <booktitle> Proc. ACM SIGACT News-SIGMOD Conf. Principles Database Sys., </booktitle> <address> Waterloo, Canada, </address> <year> 1984, </year> <pages> 181-190. </pages>
Reference-contexts: As in R-trees, a query may need to examine multiple branches of the tree hierarchy for a single cell of the search region. This can lead to a recursive type of search which is generally less preferred than a range search. Orenstein and Merret <ref> [OrM84] </ref> proposed a high-precision spatial access method, called zkd B-trees, based on the so-called z order of points in the D-dimensional space. Each point is 4 associated with a string, called its z value , obtained by interleaving bits of the coordinates of the point given in their binary form.
Reference: [Ore89] <author> J. A. Orenstein, </author> <title> Redundancy in Spatial Databases, </title> <booktitle> Proc. ACM SIGMOD Conf. Management of Data, </booktitle> <address> Portland, OR, </address> <year> 1989, </year> <pages> 295-305. </pages>
Reference-contexts: In essence, the process can be viewed as one of "inserting" pairs (lcode i , object_id ) for each lcode i in the sequence lcodes for the given object. The effect is to introduce redundancy, similar to the one found in cell trees and zkd B-trees <ref> [Ore89] </ref>, in order to achieve higher search performance. The actual algorithm for "inserting" the pair (lcode , object_id ) is given in Figure 5-1. <p> This boils down to the question on how much redundancy should be included in the spatial structure. As noted by Orenstein <ref> [Ore89] </ref>, methods based on z ordering, i.e. Morton ordering (and a Q 0 -tree is one of them), are unique in the sense that they can effectively control redundancy. <p> The simplest way of doing this is to constrain the degree of resolution, i.e. to constrain the process of decomposition of the spatial objects into smaller pieces, thus trading accuracy for space efficiency. All of the methods for controlling redundancy proposed in <ref> [Ore89, Ore90] </ref> are applicable for Q 0 -trees as well, but their effects might be somewhat different from those observed for zkd B-trees. Real experimental studies should be conducted to determine which strategy to redundancy in Q 0 -trees works best.
Reference: [Ore90] <author> J. A. Orenstein, </author> <title> A Comparison of Spatial Query Processing Techniques for Native and Parameter Spaces, </title> <booktitle> Proc. ACM SIGMOD Conf. Management of Data, </booktitle> <address> Atlantic City, NJ, </address> <year> 1990, </year> <pages> 343-352. </pages>
Reference-contexts: The simplest way of doing this is to constrain the degree of resolution, i.e. to constrain the process of decomposition of the spatial objects into smaller pieces, thus trading accuracy for space efficiency. All of the methods for controlling redundancy proposed in <ref> [Ore89, Ore90] </ref> are applicable for Q 0 -trees as well, but their effects might be somewhat different from those observed for zkd B-trees. Real experimental studies should be conducted to determine which strategy to redundancy in Q 0 -trees works best.
Reference: [OrP88] <author> R. Orlandic and J. L. Pfaltz, </author> <title> Compact 0-Complete Trees, </title> <booktitle> Proc. 14th VLDB Conf., </booktitle> <address> Long Beach, CA, </address> <month> Aug. </month> <year> 1988, </year> <pages> 372-381. </pages>
Reference-contexts: However, the pairs we described are sufficient to perform spatial search. We will call d i the depth value of the entry e i , and o i will hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 3 Recording the depths of 1-nodes relative to a 0-order traversal can also be used to compress ordinary B-trees <ref> [OrP88] </ref>. 13 be referred to as its object list. 4 Since, only R log 2 (M + 1) J bits are needed to represent a depth value, for 2-dimensional images and the resolution degree of up to K = 31 a 6-bit depth field would suffice. <p> Further compression of the Q 0 -representation can be achieved by eliminating the empty 1-leaves from the bintree, thereby creating a 0-complete binary tree <ref> [OrP88, Orl89] </ref>. This will not affect the processing algorithms on the representation. Nevertheless, we will omit any more discussion of this in order to retain an intuitive notion of bintrees which is likely to be clearer to the reader. <p> The sequence B is appended with a value M +1 to ensure successful termination of the search algorithm. A complete description of the algorithm, borrowed from <ref> [OrP88] </ref> where its correctness proof also appears, is given in figure 3-5. We call the search procedure search_block for the reasons which will become clear when we discuss hierarchical Q 0 -representations. This also applies to the use of the parameter f irst . <p> As noted in section 2, some empty 0-leaves can safely be removed to create a 0-complete bintree. This will have little affect on processing algorithms; only the update procedures must be modified slightly (in fact simplified). Further details can be found in <ref> [OrP88, Orl89] </ref>. 35 of zkd B-trees and Q 0 -trees. Their processing algorithms are also more complex. But generally, one would expect fewer entries in cell trees than in either of the other two methods.
Reference: [OrP89] <author> R. Orlandic and J. L. Pfaltz, </author> <title> Analysis of Compact 0-Complete Trees: A New Access Method to Large Databases, </title> <booktitle> in Proc. 7th FCT Conf., </booktitle> <address> Szeged, Hungary, </address> <publisher> Springer-Verlag, </publisher> <address> Berlin-Heidelberg-New York, </address> <month> Aug. </month> <year> 1989, </year> <pages> 362-371. </pages>
Reference-contexts: The storage utilization of blocks in a Q 0 -tree and its total storage overhead can be estimated by viewing the blocks of Q 0 -trees as leaves in paginated binary tries (i.e. binary tries whose leaves are blocks of data) with n items. Then from <ref> [Fae79, OrP89] </ref> it directly follows that the expected storage utilization of blocks in a Q 0 -tree asymptotically converges to ln 2 ~ ~ 0.693 as in B-trees [Yao78].
Reference: [Orl89] <author> R. Orlandic, </author> <title> Design, Analysis and Applications of Compact 0-Complete Trees, </title> <type> PhD Dissertation, </type> <institution> Univ. of Virginia, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: The case when d i = d i -1 need not be considered because no two consecutive 1-nodes can appear at the same level in a bintree. A formal proof of the rule (2.2) is given in <ref> [Orl89] </ref>. <p> Further compression of the Q 0 -representation can be achieved by eliminating the empty 1-leaves from the bintree, thereby creating a 0-complete binary tree <ref> [OrP88, Orl89] </ref>. This will not affect the processing algorithms on the representation. Nevertheless, we will omit any more discussion of this in order to retain an intuitive notion of bintrees which is likely to be clearer to the reader. <p> Using the equivalence between the bintrees and their Q 0 -representations, it is possible to give formal proofs of correctness of these algorithms, similar to the ones given in <ref> [Orl89] </ref>. This is a major reason for developing both bintrees and Q 0 representations in tandem. To add a new spatial object to an existing Q 0 -representation one can simply construct the Q 0 -sequence of its image and take the union of the two representations. <p> The rule (5.1) does not guarantee that the blocks will be split into equal parts, but it is a close approximation of even splitting of blocks which yields reasonably good storage utilization <ref> [Orl89] </ref>. As in zkd B-trees and cell trees, the insertion of a new spatial object in a Q 0 -tree must be preceded by its decomposition into constituent parts. <p> As noted in section 2, some empty 0-leaves can safely be removed to create a 0-complete bintree. This will have little affect on processing algorithms; only the update procedures must be modified slightly (in fact simplified). Further details can be found in <ref> [OrP88, Orl89] </ref>. 35 of zkd B-trees and Q 0 -trees. Their processing algorithms are also more complex. But generally, one would expect fewer entries in cell trees than in either of the other two methods.
Reference: [ROG88] <author> D. Rhind, S. Openshaw and N. Green, </author> <title> The Analysis of Geographical Data: Data Rich, Technology Adequate, Theory Poor, </title> <booktitle> Proc. 4th Conf. SSDBM, in Lecture Notes in Computer Science 339(June 1988), </booktitle> <pages> 427-454, </pages> <publisher> Springer Verlag. </publisher> <pages> 40 </pages>
Reference-contexts: In this context, as in image processing, the actual representation of spatial objects plays a crucial role. A variety of different representations have been considered <ref> [ROG88] </ref>. The simplest representation uses the approximation of complex objects by its minimal enclosing rectangles whose sides are parallel to the axes of the data space. It has the advantage of low storage overhead; but at the expense of decreased precision.
Reference: [Rob81] <author> J. T. Robinson, </author> <title> The k-D-B-Tree: A Search Structure for Large Multidimansional Dynamic Indexes, </title> <booktitle> Proc. ACM SIGMOD Conf. on Management of Data, </booktitle> <address> Ann Arbor, MI, </address> <year> 1981, </year> <pages> 10-18. </pages>
Reference-contexts: One may end up searching a large portion of the file for a single query. 3 Clipping methods are usually extensions of transformation, overlapping-region, or exact--match retrieval methods. For example, R + -trees [SRF87] are a variant of R-trees and the k-D-B-tree clipping method <ref> [Rob81] </ref>; while multi-level grid files [SiW88] represent a clipping variant of grid files. Clipping schemes based on multidimensional hashing often use known hashing methods as their paradigms, such as PLOP-hashing [SeK88] which is based on linear hashing [Lit80].
Reference: [Sam84] <author> H. Samet, </author> <title> The Quadtree and Related Hierarchical Data Structures, </title> <journal> Computing Surveys 16,2 (June 1984), </journal> <pages> 187-260. </pages>
Reference-contexts: More complex vector representations of enclosing polygons with arbitrary sides have also been considered. On the other extreme, we have exhaustive pixel-by-pixel representations, which are precise but extremely inefficient in terms of their storage requirements. Quadtrees and octtrees <ref> [Sam84] </ref> reduce this overhead by decomposing objects into constituent squares or cubes, respectively, with variable size. Many spatial retrieval algorithms assume the simplest spatial representation of objects using minimal enclosing rectangles. <p> K . Observe that the locational code of a quadrant Q is a proper prefix of the locational codes of all squares enclosed by Q. The 16 pixels of the image space have also been numbered in what is called Morton order (or Morton matrix) <ref> [Sam84] </ref>. The Morton order is obtained by simply interpreting each locational code as a binary integer. 2 Regions in the image space which can be uniquely identified by a single locational code need not necessarily be square. <p> This structure is called region quadtree. An intensive discus-sion of 2D-region quadtrees, including other forms of quadtrees (e.g. PR quadtree, edge quadtree, etc.), is given in <ref> [Sam84] </ref>. By region quadtrees, however, we will mean not only 2-dimensional quadtrees, but 3-dimensional octtrees, etc., as well. Figure 2-2 (a) shows the region quadtree of the image of Figure 2-1 (b). <p> A clear advantage of quadtrees over the original raster representation is its potential for greatly reduced storage overhead. In addition, it supports set operations (union, difference and intersection), searching, scaling based on the power of 2, windowing, rotation, and other transformations <ref> [Sam84] </ref>, whose computational cost is proportional to the number of nodes in the tree rather than the number of pixels in the image. Moreover, it preserves locations of arbitrarily shaped objects in space needed for spatial search. Region quadtrees need not be represented as tries of degree 2 D . <p> In general, trie structures have been well analyzed and the problems of their efficient implementation and compression have received considerable attention. Quadtrees and bintrees are no exception. As pointed out by Samet <ref> [Sam84] </ref>, there are two principal ways to represent quadtrees in a linear, pointerless fashion. The first approach treats the trie as a collection of leaf nodes. Let us disregard for a while the lists of objects associated with the leaves of the quadtree.
Reference: [SeK88] <author> B. Seeger and H. Kriegel, </author> <title> Techniques for Design and Implementation of Efficient Spatial Access Methods, </title> <booktitle> Proc. 14th VLDB Conf., </booktitle> <address> Long Beach, CA, </address> <month> Aug. </month> <year> 1988, </year> <pages> 360-371. </pages>
Reference-contexts: for these applications require the ability to search efficiently for D-dimensional objects which: (1) contain a specified point in space (point query); (2) intersect a specified region in space (region intersection); (3) enclose a region in space (region enclosure); or (4) are enclosed by a region in space (region containment) <ref> [SeK88] </ref>. In this context, as in image processing, the actual representation of spatial objects plays a crucial role. A variety of different representations have been considered [ROG88]. <p> Quadtrees and octtrees [Sam84] reduce this overhead by decomposing objects into constituent squares or cubes, respectively, with variable size. Many spatial retrieval algorithms assume the simplest spatial representation of objects using minimal enclosing rectangles. As noted in <ref> [SeK88] </ref>, they can be organized into three groups: (1) transformation techniques handle spatial queries by mapping each object to a single point in a multidimensional space; (2) overlapping-region schemes use hierarchical organization of overlapping rectangles, where each higher-level rectangle encloses several low-level regions; and (3), clipping methods perform decomposition of rectangles <p> For example, R + -trees [SRF87] are a variant of R-trees and the k-D-B-tree clipping method [Rob81]; while multi-level grid files [SiW88] represent a clipping variant of grid files. Clipping schemes based on multidimensional hashing often use known hashing methods as their paradigms, such as PLOP-hashing <ref> [SeK88] </ref> which is based on linear hashing [Lit80]. The essence of these methods is that they partition a D-dimensional space into D-dimensional slices by a set of hyperplanes parallel to the axes. The bounding rectangle of an object can intersect several hyperplanes and its parts may lie in different slices.
Reference: [SRF87] <author> T. Sellis, N. Roussopoulos and C. Faloutsos, </author> <title> The R+-Tree: A Dynamic Index for Multi-Dimensional Objects, </title> <booktitle> Proc. 13th Conf. on VLDB, </booktitle> <address> Brighton, England, </address> <year> 1987, </year> <pages> 507-518. </pages>
Reference-contexts: One may end up searching a large portion of the file for a single query. 3 Clipping methods are usually extensions of transformation, overlapping-region, or exact--match retrieval methods. For example, R + -trees <ref> [SRF87] </ref> are a variant of R-trees and the k-D-B-tree clipping method [Rob81]; while multi-level grid files [SiW88] represent a clipping variant of grid files. Clipping schemes based on multidimensional hashing often use known hashing methods as their paradigms, such as PLOP-hashing [SeK88] which is based on linear hashing [Lit80].
Reference: [SiW88] <author> H. W. Six and P. Widmayer, </author> <title> Spatial Searching in Geometric Databases, </title> <booktitle> Proc. Conf. on Data Engineering, </booktitle> <year> 1988. </year>
Reference-contexts: One may end up searching a large portion of the file for a single query. 3 Clipping methods are usually extensions of transformation, overlapping-region, or exact--match retrieval methods. For example, R + -trees [SRF87] are a variant of R-trees and the k-D-B-tree clipping method [Rob81]; while multi-level grid files <ref> [SiW88] </ref> represent a clipping variant of grid files. Clipping schemes based on multidimensional hashing often use known hashing methods as their paradigms, such as PLOP-hashing [SeK88] which is based on linear hashing [Lit80].
Reference: [Tam84] <author> M. </author> <title> Tamminen, </title> <journal> Comment on Quad- and Oct-trees, Comm. of the ACM 27,3 (Mar. </journal> <year> 1984), </year> <pages> 248-249. </pages>
Reference-contexts: Moreover, it preserves locations of arbitrarily shaped objects in space needed for spatial search. Region quadtrees need not be represented as tries of degree 2 D . An alternative organization is that of a bintree <ref> [Tam84] </ref>, obtained by inserting binary locational codes of the simple homogeneous rectangles of the image into a binary trie. As in binary tries in general, every arc in a bintree is implicitly labeled by either a 0 or a 1.
Reference: [Wan91] <author> F. Wang, </author> <title> Relational-Linear Quadtree Approach for Two-Dimensional Spatial Representation and Manipulation, </title> <journal> IEEE Trans. Knowledge and Data Engineering 3,1 (Mar. </journal> <year> 1991), </year> <pages> 118-122. </pages>
Reference: [Yao78] <author> A. C. Yao, </author> <title> Random 3-2 Trees, </title> <journal> Acta Inf. </journal> <month> 2,9 </month> <year> (1978), </year> <month> 159-170. </month> <title> 41 Table of Contents 1. Introduction ................................................................................................... 2 2. Image Representation ................................................................................... 6 2.1. Region Quadtrees ................................................................................... 8 2.2. The Q 0 -Representation ........................................................................... 12 3. Image Operations .......................................................................................... 15 3.1. Set Operations Union, Intersection, Difference ................................ 16 3.2. Pixel Search ........................................................................................... 20 4. Hierarchical Representation and General Spatial Search ............................. 22 5. Image Updates .............................................................................................. 29 6. Performance Evaluation ................................................................................ 31 6.1. Basic Parameters .................................................................................... 33 6.2. Qualitative Comparisons ........................................................................ 34 6.3. Controlling Representational Redundancy ............................................ 36 7. Summary and Discussion .............................................................................. 37 42 </title>
Reference-contexts: Then from [Fae79, OrP89] it directly follows that the expected storage utilization of blocks in a Q 0 -tree asymptotically converges to ln 2 ~ ~ 0.693 as in B-trees <ref> [Yao78] </ref>.
References-found: 26

