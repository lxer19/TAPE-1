URL: ftp://ftp.research.microsoft.com/users/palarson/icde94_pl.ps
Refering-URL: http://www.research.microsoft.com/~palarson/publications.htm
Root-URL: http://www.research.microsoft.com
Title: Exploiting Uniqueness in Query Optimization  
Author: G. N. Paulley Per -Ake Larson 
Address: Waterloo, Ontario, Canada N2L 3G1  
Affiliation: Department of Computer Science University of Waterloo  
Abstract: Consider an sql query that specifies duplicate elimination via a Distinct clause. Because duplicate elimination often requires an expensive sort of the query result, it is often worthwhile to identify unnecessary Distinct clauses and avoid the sort altogether. We prove a necessary and sufficient condition for deciding if a query requires duplicate elimination. The condition exploits knowledge about keys, table constraints, and query predicates. Because the condition cannot always be tested efficiently, we offer a practical algorithm that tests a simpler, sufficient condition. We consider applications of this condition for various types of queries, and show that we can exploit this condition in both relational and non-relational database systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Stefano Ceri and Georg Gottlob. </author> <title> Translating sql into relational algebra: Optimization, semantics, and equivalence of sql queries. </title> <journal> ieee Trans. on Soft. Eng., </journal> <volume> 11(4) </volume> <pages> 324-345, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: BETWEEN 1 AND 499)) defines OEM-PNO as a candidate key; any instance of PARTS may have only one tuple with OEM-PNO = NULL. 2.2 An algebra for SQL queries As a shorthand notation for our subset of sql, we define an algebra whose operations are defined by sql statements themselves <ref> [1, 24] </ref>. By doing so, we avoid the need to show the semantic equivalence between our algebra and sql. Note that `conventional' relational algebra transformations do not necessarily apply to this algebra, which is based on multisets. <p> Kim [11] originally suggested rewriting correlated, nested queries as joins to avoid nested-loop execution strategies. Subsequently, several researchers corrected and extended Kim's work, particularly in the aspects of grouping and aggregation <ref> [1, 6, 7, 10, 17] </ref>. None of this work explicitly addresses applicability of these techniques in other database environments; as our examples show, nested loops remain an attractive execution strategy, under certain conditions, with a variety of database architectures.
Reference: [2] <author> Stefano Ceri and Jennifer Widom. </author> <title> Deriving production rules for incremental view maintenance. </title> <booktitle> In Proc. vldb 17, </booktitle> <pages> pages 577-589, </pages> <address> Barcelona, </address> <year> 1991. </year>
Reference-contexts: Maier's chase computation uses functional and join dependencies to transform tableaux. Darwen [3] reiterates Klug's work, and gives an exponential algorithm for generating derived fds. Darwen concentrates on deriving candidate keys for arbitrary algebraic expressions and their applications, notably view updatability and join optimization. Ceri and Widom <ref> [2] </ref> discuss derived key dependencies with respect to updating materialized views. They define these dependencies in terms of an algorithm for deducing bound columns, nearly identical to our Algorithm 1 except for a test for disjunctive clauses.
Reference: [3] <author> Hugh Darwen. </author> <title> The role of functional dependence in query decomposition. In Relational Database Writings 1989-1991, </title> <booktitle> chapter 10, </booktitle> <pages> pages 133-154. </pages> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Maier [15] describes query modification techniques with respect to minimizing the number of rows in tableaux, which is equivalent to minimizing the number of joins in relational algebra. Maier's chase computation uses functional and join dependencies to transform tableaux. Darwen <ref> [3] </ref> reiterates Klug's work, and gives an exponential algorithm for generating derived fds. Darwen concentrates on deriving candidate keys for arbitrary algebraic expressions and their applications, notably view updatability and join optimization. Ceri and Widom [2] discuss derived key dependencies with respect to updating materialized views.
Reference: [4] <author> C. J. Date. </author> <title> An Introduction to Database Systems, volume 1. </title> <publisher> Addison-Wesley, </publisher> <address> fifth edition, </address> <year> 1990. </year>
Reference-contexts: First, case tools often generate queries using `generic' query templates. These templates specify Distinct as a conservative approach to handling duplicate rows. Second, some practitioners <ref> [4] </ref> encourage users to always specify Distinct, again as a conservative approach to simplify query semantics. We feel that recognizing redundant Distinct clauses is an important optimization, since it can avoid a costly sort.
Reference: [5] <author> C. J. Date. </author> <title> Relational Database Writings 1985-1989. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: However, `traditional' dependency theory ignores three-valued logic; only recently have researchers adequately documented the formal semantics of three-valued logic within sql <ref> [5, 18, 22] </ref>. Because the iso standard permits Null values in any attributes of a candidate key, Null values may exist on both the left- and right-hand sides of a key dependency in both base and derived tables.
Reference: [6] <author> Umeshwar Dayal. </author> <title> Of nests and trees: A unified approach to processing queries that contain nested sub-queries, aggregates, and quantifiers. </title> <booktitle> In Proc. vldb 13, </booktitle> <pages> pages 197-208, </pages> <address> Brighton, England, </address> <year> 1987. </year>
Reference-contexts: In this section, we identify three important query transformations: detection of unnecessary duplicate elimination, conversion of a subquery to a join, and conversion of an intersection to a subquery. Other researchers have described these query transformations elsewhere <ref> [6, 11, 17, 19] </ref> but with relatively little formalism. Later, in Section 6, we show the applicability of these transformations in nonrelational environments. 5.1 Unnecessary duplicate elimination We believe that many queries contain unnecessary Distinct clauses, for two reasons. First, case tools often generate queries using `generic' query templates. <p> In the next section, we document semantic transformations of join queries|in hierarchical and object-oriented database systems|to show the wide applicability of semantic query optimization. 6 Exploiting uniqueness in nonrelational systems Several researchers <ref> [6, 7, 10, 11, 19, 23] </ref> have studied ways to rewrite nested queries as joins to avoid a nested-loops execution plan. <p> Kim [11] originally suggested rewriting correlated, nested queries as joins to avoid nested-loop execution strategies. Subsequently, several researchers corrected and extended Kim's work, particularly in the aspects of grouping and aggregation <ref> [1, 6, 7, 10, 17] </ref>. None of this work explicitly addresses applicability of these techniques in other database environments; as our examples show, nested loops remain an attractive execution strategy, under certain conditions, with a variety of database architectures.
Reference: [7] <author> Richard A. Ganski and Harry K. T. Wong. </author> <title> Optimization of nested queries revisited. </title> <booktitle> In Proc. acm sigmod Conference, </booktitle> <pages> pages 23-33, </pages> <address> San Francisco, </address> <month> May </month> <year> 1987. </year> <institution> [8] ibm Corporation. </institution> <note> ims/esa Version 3 General Information, first edition, </note> <month> June </month> <year> 1989. </year> <title> ibm Order Number GC26-4275-0. </title>
Reference-contexts: In the next section, we document semantic transformations of join queries|in hierarchical and object-oriented database systems|to show the wide applicability of semantic query optimization. 6 Exploiting uniqueness in nonrelational systems Several researchers <ref> [6, 7, 10, 11, 19, 23] </ref> have studied ways to rewrite nested queries as joins to avoid a nested-loops execution plan. <p> Kim [11] originally suggested rewriting correlated, nested queries as joins to avoid nested-loop execution strategies. Subsequently, several researchers corrected and extended Kim's work, particularly in the aspects of grouping and aggregation <ref> [1, 6, 7, 10, 17] </ref>. None of this work explicitly addresses applicability of these techniques in other database environments; as our examples show, nested loops remain an attractive execution strategy, under certain conditions, with a variety of database architectures.
Reference: [9] <institution> International Standards Organization. </institution> <note> Information Technology|Database Language sql 2 Draft Report, December 1990. iso Committee iso/iec jtc1/sc21. </note>
Reference-contexts: Section 6 summarizes related research, and Section 7 presents a summary and lists some directions for future work. 2 Class of SQL queries considered In this paper, we consider a subset of sql2 <ref> [9] </ref> queries for which our semantic query optimization techniques, described below, may be beneficial. Following the sql2 standard, queries corresponding to query specifications consist of only the algebraic operators selection, projection, and extended Cartesian product.
Reference: [10] <author> Werner Kiessling. </author> <title> On semantic reefs and efficient processing of correlation queries with aggregates. </title> <booktitle> In Proc. vldb 11, </booktitle> <pages> pages 241-249, </pages> <address> Stockholm, </address> <year> 1985. </year>
Reference-contexts: In the next section, we document semantic transformations of join queries|in hierarchical and object-oriented database systems|to show the wide applicability of semantic query optimization. 6 Exploiting uniqueness in nonrelational systems Several researchers <ref> [6, 7, 10, 11, 19, 23] </ref> have studied ways to rewrite nested queries as joins to avoid a nested-loops execution plan. <p> Kim [11] originally suggested rewriting correlated, nested queries as joins to avoid nested-loop execution strategies. Subsequently, several researchers corrected and extended Kim's work, particularly in the aspects of grouping and aggregation <ref> [1, 6, 7, 10, 17] </ref>. None of this work explicitly addresses applicability of these techniques in other database environments; as our examples show, nested loops remain an attractive execution strategy, under certain conditions, with a variety of database architectures. <p> Although testing the conditions for transformation is np-complete, our algorithm detects a large subclass of queries for which the transformations are valid. Our approach takes into account static constraints, as defined by the sql2 standard, and explicitly handles the `semantic reefs' <ref> [10] </ref> referred to by Kiessling|duplicate rows and three-valued logic|which continue to complicate optimization strategies. Our original motivation was to find ways to expand the strategy space for optimizing sql queries|particularly nested queries and joins|against relational views of ims databases.
Reference: [11] <author> Won Kim. </author> <title> On optimizing an sql-like nested query. </title> <journal> acm tods, </journal> <volume> 7(3), </volume> <year> 1982. </year>
Reference-contexts: In this section, we identify three important query transformations: detection of unnecessary duplicate elimination, conversion of a subquery to a join, and conversion of an intersection to a subquery. Other researchers have described these query transformations elsewhere <ref> [6, 11, 17, 19] </ref> but with relatively little formalism. Later, in Section 6, we show the applicability of these transformations in nonrelational environments. 5.1 Unnecessary duplicate elimination We believe that many queries contain unnecessary Distinct clauses, for two reasons. First, case tools often generate queries using `generic' query templates. <p> This query satisfies the conditions in Theorem 1, and, consequently, Distinct in the Select clause is unnecessary. 5.2 Subquery to join Both Kim <ref> [11] </ref> and Pirahesh et al. [19] devote a great deal of effort to the rewriting of correlated, positive existential subqueries as joins. Their rationale is to avoid processing the query with a naive nested-loop strategy. <p> In the next section, we document semantic transformations of join queries|in hierarchical and object-oriented database systems|to show the wide applicability of semantic query optimization. 6 Exploiting uniqueness in nonrelational systems Several researchers <ref> [6, 7, 10, 11, 19, 23] </ref> have studied ways to rewrite nested queries as joins to avoid a nested-loops execution plan. <p> The idea is to restrict the search in the PARTS class to only those instances that correspond to a SUPPLIER instance whose supplier number matches the range predicate. 7 Related work Semantic transformation of sql queries using our uniqueness condition is a form of semantic query optimization [12]. Kim <ref> [11] </ref> originally suggested rewriting correlated, nested queries as joins to avoid nested-loop execution strategies. Subsequently, several researchers corrected and extended Kim's work, particularly in the aspects of grouping and aggregation [1, 6, 7, 10, 17].
Reference: [12] <author> Jonathan J. King. </author> <title> Query Optimization by Semantic Reasoning. </title> <publisher> umi Research Press, </publisher> <year> 1984. </year>
Reference-contexts: The idea is to restrict the search in the PARTS class to only those instances that correspond to a SUPPLIER instance whose supplier number matches the range predicate. 7 Related work Semantic transformation of sql queries using our uniqueness condition is a form of semantic query optimization <ref> [12] </ref>. Kim [11] originally suggested rewriting correlated, nested queries as joins to avoid nested-loop execution strategies. Subsequently, several researchers corrected and extended Kim's work, particularly in the aspects of grouping and aggregation [1, 6, 7, 10, 17].
Reference: [13] <author> Anthony Klug. </author> <title> Calculating constraints on relational expressions. </title> <journal> acm tods, </journal> <volume> 5(3) </volume> <pages> 260-290, </pages> <year> 1980. </year>
Reference-contexts: A significant contribution of Negri et al. is the notion of query equivalence classes for syntactically different, yet semantically equivalent, sql queries. Several authors discuss the properties of derived functional dependencies in two-valued logic. Klug <ref> [13] </ref> studies the problem of derived fds in two-valued relational algebra expressions with the operators projection, selection, restriction, cross-product, union, and difference.
Reference: [14] <author> Per -Ake Larson. </author> <title> Relational Access to ims Databases: Gateway Structure and Join Processing. </title> <institution> University of Waterloo, </institution> <month> December </month> <year> 1990. </year> <type> Unpublished manuscript, </type> <pages> 70 pages. </pages>
Reference-contexts: Queries that cannot be directly translated by the data access layer| which executes the iterative program|require facilities of the post-processing layer that can perform more complex operations, like sorting, but at increased cost <ref> [14] </ref>. Therefore, nested-loop strategies, which require only the data access layer, may often be cheaper to execute. Example 10 Consider the select-project-parent/child join query SELECT ALL S.* FROM SUPPLIER S, PARTS P WHERE S.SNO = P.SNO AND P.PNO = :PARTNO which lists all suppliers for a particular part.
Reference: [15] <author> David Maier. </author> <title> The Theory of Relational Databases. </title> <publisher> Computer Science Press, </publisher> <year> 1983. </year>
Reference-contexts: Maier <ref> [15] </ref> describes query modification techniques with respect to minimizing the number of rows in tableaux, which is equivalent to minimizing the number of joins in relational algebra. Maier's chase computation uses functional and join dependencies to transform tableaux.
Reference: [16] <author> R[okia] Missaoui and R[obert] Godin. </author> <title> Semantic query optimization using generalized functional dependencies. </title> <institution> Rapport de Recherche 98, Universite du Quebec a Montreal, </institution> <address> Montreal, Quebec, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: In our future work, we will study the basis of these new tradeoffs. For example, we wish to study the possibility of * using query transformations based on true-interpreted predicates, which expand the number of ex ecution strategies for certain sql expressions; * utilizing inclusion dependencies <ref> [16] </ref> to prune query graphs, thus implementing King's notion of join elimination; * expanding the suite of sql queries considered here|some relevant work on Group By is still un derway [24].
Reference: [17] <author> M. Muralikrishna. </author> <title> Improved unnesting algorithms for join aggregate sql queries. </title> <booktitle> In Proc. vldb 18, </booktitle> <pages> pages 91-102, </pages> <address> Vancouver, bc, </address> <year> 1992. </year>
Reference-contexts: In this section, we identify three important query transformations: detection of unnecessary duplicate elimination, conversion of a subquery to a join, and conversion of an intersection to a subquery. Other researchers have described these query transformations elsewhere <ref> [6, 11, 17, 19] </ref> but with relatively little formalism. Later, in Section 6, we show the applicability of these transformations in nonrelational environments. 5.1 Unnecessary duplicate elimination We believe that many queries contain unnecessary Distinct clauses, for two reasons. First, case tools often generate queries using `generic' query templates. <p> Kim [11] originally suggested rewriting correlated, nested queries as joins to avoid nested-loop execution strategies. Subsequently, several researchers corrected and extended Kim's work, particularly in the aspects of grouping and aggregation <ref> [1, 6, 7, 10, 17] </ref>. None of this work explicitly addresses applicability of these techniques in other database environments; as our examples show, nested loops remain an attractive execution strategy, under certain conditions, with a variety of database architectures.
Reference: [18] <author> M. Negri, G. Pelagatti, and L. Sbattella. </author> <title> Formal se-mantics of sql queries. </title> <journal> acm tods, </journal> <volume> 16(3) </volume> <pages> 513-534, </pages> <year> 1991. </year>
Reference-contexts: However, `traditional' dependency theory ignores three-valued logic; only recently have researchers adequately documented the formal semantics of three-valued logic within sql <ref> [5, 18, 22] </ref>. Because the iso standard permits Null values in any attributes of a candidate key, Null values may exist on both the left- and right-hand sides of a key dependency in both base and derived tables. <p> In sql2, the result depends on the context: within Where and Having clauses, the comparison is unknown; within Group By and Order By-and particularly duplicate elimination via Select DISTINCT|the comparison is true. To incorporate three-valued logic semantics into fds, we adopt the interpretation and Null comparison operators of reference <ref> [18] </ref>. Table 2 describes their semantics. <p> Much of the earlier work in semantic transformations ignored sql's three-valued logic and the presence of Null values. To help better understand these problems, Negri et al. <ref> [18] </ref> and von Bultzingsloewen [22] defined formal semantics for sql using an extended relational calculus, although neither paper tackled the problems of duplicates. A significant contribution of Negri et al. is the notion of query equivalence classes for syntactically different, yet semantically equivalent, sql queries.
Reference: [19] <author> Hamid Pirahesh, Joseph M. Hellerstein, and Waqar Hasan. </author> <title> Extensible/rule based query rewrite optimization in starburst. </title> <booktitle> In Proc. acm sigmod Conference, </booktitle> <pages> pages 39-48, </pages> <address> San Diego, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: In this section, we identify three important query transformations: detection of unnecessary duplicate elimination, conversion of a subquery to a join, and conversion of an intersection to a subquery. Other researchers have described these query transformations elsewhere <ref> [6, 11, 17, 19] </ref> but with relatively little formalism. Later, in Section 6, we show the applicability of these transformations in nonrelational environments. 5.1 Unnecessary duplicate elimination We believe that many queries contain unnecessary Distinct clauses, for two reasons. First, case tools often generate queries using `generic' query templates. <p> This query satisfies the conditions in Theorem 1, and, consequently, Distinct in the Select clause is unnecessary. 5.2 Subquery to join Both Kim [11] and Pirahesh et al. <ref> [19] </ref> devote a great deal of effort to the rewriting of correlated, positive existential subqueries as joins. Their rationale is to avoid processing the query with a naive nested-loop strategy. Instead, they convert the query to a join so that the optimizer can consider alternate join methods. <p> A subtle difficulty with the transformation of intersection query expressions to subqueries arises because the equivalence of tuples, normally handled by the intersection operator that treats NULL = NULL, is now moved into a Where clause. Pirahesh et al. <ref> [19] </ref> do not handle this situation adequately in their paper (Rule 8); they transform the query without considering possibly NULL keys. <p> Using a primary key makes the transformation in Example 5 of reference <ref> [19] </ref> correct. <p> Subsequent conversion of the Exists sub-query to a join is possible <ref> [19] </ref> if the tests for Nulls are maintained 1 . <p> In the next section, we document semantic transformations of join queries|in hierarchical and object-oriented database systems|to show the wide applicability of semantic query optimization. 6 Exploiting uniqueness in nonrelational systems Several researchers <ref> [6, 7, 10, 11, 19, 23] </ref> have studied ways to rewrite nested queries as joins to avoid a nested-loops execution plan. <p> In our approach, however, our formal proofs take into account other static constraints and explicitly handle the existence of Null values; our algorithm is simply a sufficient condition for determining candidate keys. Pirahesh, Hellerstein, and Wasan <ref> [19] </ref> draw paral lels between optimization of sql subqueries in rela-tional systems and the optimization of path queries in object-oriented systems. Their work in starburst focuses on rewriting complex Select statements as select-project-join queries.
Reference: [20] <author> Eugene Shekita. </author> <title> High-performance implementation techniques for next-generation database systems. </title> <type> Tech. Rep. 1026, </type> <institution> University of Wisconsin at Madison, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: The nested version halts the search immediately once dl/i finds a match. 6.2 Object-oriented systems In some object-oriented database systems, physical object identifiers (oids) take the place of foreign keys; both exodus and O 2 take this approach <ref> [20] </ref>. <p> 3.) This pointer scheme does not effectively support select-project-join queries in which the selection predicate on the parent class (for example, SUPPLIER) is more restrictive than the predicate on a subordinate class, because the most efficient way to process this type of join would require pointers in the opposite direction <ref> [20] </ref>.
Reference: [21] <author> Jeffrey D. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> Volume 1. </volume> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: We call such fds derived functional dependencies. Similarly, a kd that holds in a derived table is a derived key dependency. We represent the fd `A functionally determines B' with the standard notation A ! B <ref> [21] </ref>. The following example illustrates derived fds.
Reference: [22] <author> Gunter von Bultzingsloewen. </author> <title> Translating and optimizing sql queries having aggregates. </title> <booktitle> In Proc. vldb 13, </booktitle> <pages> pages 235-243, </pages> <address> Brighton, England, </address> <year> 1987. </year>
Reference-contexts: However, `traditional' dependency theory ignores three-valued logic; only recently have researchers adequately documented the formal semantics of three-valued logic within sql <ref> [5, 18, 22] </ref>. Because the iso standard permits Null values in any attributes of a candidate key, Null values may exist on both the left- and right-hand sides of a key dependency in both base and derived tables. <p> Much of the earlier work in semantic transformations ignored sql's three-valued logic and the presence of Null values. To help better understand these problems, Negri et al. [18] and von Bultzingsloewen <ref> [22] </ref> defined formal semantics for sql using an extended relational calculus, although neither paper tackled the problems of duplicates. A significant contribution of Negri et al. is the notion of query equivalence classes for syntactically different, yet semantically equivalent, sql queries.
Reference: [23] <author> Eugene Wong and Karel Youssefi. </author> <title> Decomposition|A strategy for query processing. </title> <journal> acm tods, </journal> <volume> 1(3) </volume> <pages> 223-241, </pages> <year> 1976. </year>
Reference-contexts: In the next section, we document semantic transformations of join queries|in hierarchical and object-oriented database systems|to show the wide applicability of semantic query optimization. 6 Exploiting uniqueness in nonrelational systems Several researchers <ref> [6, 7, 10, 11, 19, 23] </ref> have studied ways to rewrite nested queries as joins to avoid a nested-loops execution plan.
Reference: [24] <author> W. P. Yan and Per -Ake Larson. </author> <title> Performing group by before join. </title> <booktitle> In Proc. Tenth ieee Int. Conf. on Data Engineering, </booktitle> <address> Houston, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: BETWEEN 1 AND 499)) defines OEM-PNO as a candidate key; any instance of PARTS may have only one tuple with OEM-PNO = NULL. 2.2 An algebra for SQL queries As a shorthand notation for our subset of sql, we define an algebra whose operations are defined by sql statements themselves <ref> [1, 24] </ref>. By doing so, we avoid the need to show the semantic equivalence between our algebra and sql. Note that `conventional' relational algebra transformations do not necessarily apply to this algebra, which is based on multisets. <p> based on true-interpreted predicates, which expand the number of ex ecution strategies for certain sql expressions; * utilizing inclusion dependencies [16] to prune query graphs, thus implementing King's notion of join elimination; * expanding the suite of sql queries considered here|some relevant work on Group By is still un derway <ref> [24] </ref>.
References-found: 23

