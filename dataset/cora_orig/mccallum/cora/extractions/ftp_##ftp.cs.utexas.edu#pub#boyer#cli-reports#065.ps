URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/065.ps
Refering-URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/index.html
Root-URL: 
Phone: (512) 322-9951  
Title: A Mechanical Formalization of Several Fairness Notions  
Author: David M. Goldschlag 
Note: This work was supported in part at Computational Logic, Inc., by the Defense Advanced Research Projects Agency, ARPA Order 7406, and ONR Contract N00014-88-C-0454. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Defense Advanced Research Projects Agency, the Office of Naval Research, or the U.S. Government.  
Address: 1717 W. 6th St. Suite 290 Austin, Texas 78703  
Affiliation: Computational Logic Inc.  
Date: 65 March, 1991  
Pubnum: Technical Report  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Bowen Alpern and Fred B. Schneider. </author> <title> "Defining Liveness". </title> <booktitle> Information Processing Letters 21 (1985), </booktitle> <pages> 181-185. </pages>
Reference-contexts: The interesting properties of concurrent programs are safety and liveness (progress). Safety properties are those that state that something bad will never happen [2]; examples are invariant properties such as mutual exclusion and freedom from deadlock. Liveness properties state that something good will eventually happen <ref> [1] </ref>; examples are termination and freedom from starvation.
Reference: 2. <author> Bowen Alpern, Alan J. Demers, and Fred B. Schneider. </author> <title> "Safety Without Stuttering". </title> <booktitle> Information Processing Letters 23 (1986), </booktitle> <pages> 177-180. </pages>
Reference-contexts: Proof rules for the fairness notions will be theorems permitting the proof of correctness properties. The interesting properties of concurrent programs are safety and liveness (progress). Safety properties are those that state that something bad will never happen <ref> [2] </ref>; examples are invariant properties such as mutual exclusion and freedom from deadlock. Liveness properties state that something good will eventually happen [1]; examples are termination and freedom from starvation.
Reference: 3. <author> K.R. Apt, N. Francez, and S. Katz. </author> <title> "Appraising Fairness in Distributed Languages". </title> <booktitle> Distributed Computing 2 (August 1988), </booktitle> <pages> 226-241. </pages>
Reference-contexts: This was demonstrated by the mechanically verified proof of a solution to the dining philosophers program whose correctness depended upon strong fairness and deadlock freedom. Mechanical verification increases the trust one may place in a proof. <ref> [3] </ref> presents three criteria for judging new fairness notions. They are: Feasibility: For every program, some fair computation does exist. Furthermore, it should be possible to extend every partial computation to a fair one (so the scheduler is implementable).
Reference: 4. <author> R.J.R. Back and J. von Wright. </author> <title> Refinement Concepts Formalized in Higher Order Logic. In Programming Concepts and Methods, </title> <editor> M. Broy and C. B. Jones, Eds., </editor> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: Other researchers have embedded one logic within another mechanized logic in order to prove soundness and provide mechanized support for the new logic. Hoare logic was embedded in LCF in [23], Dijsktra's weakest preconditions were embedded in HOL in <ref> [4] </ref>, while CSP was embedded in HOL in [9]. These mechanized theories have not been used to mechanically prove the correctness of other programs.
Reference: 5. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: In the second case, completeness depends upon whether the proof rules in the literature are sufficient. However, the proof system is sound, since the restricted operational semantics justifies the new proof rules. The mechanization presented here is an encoding of the Unity logic on the Boyer-Moore prover <ref> [5, 6] </ref>. Proofs in this system resemble Unity hand proofs, but are longer, since all concepts are defined from first principles. This proof system is semi-automatic since complex proofs are guided by the user. Mechanical verification provides greater trust in the correctness of a proof.
Reference: 6. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: In the second case, completeness depends upon whether the proof rules in the literature are sufficient. However, the proof system is sound, since the restricted operational semantics justifies the new proof rules. The mechanization presented here is an encoding of the Unity logic on the Boyer-Moore prover <ref> [5, 6] </ref>. Proofs in this system resemble Unity hand proofs, but are longer, since all concepts are defined from first principles. This proof system is semi-automatic since complex proofs are guided by the user. Mechanical verification provides greater trust in the correctness of a proof. <p> Section 8 summarizes related work and offers some concluding remarks. 2. The Boyer-Moore Prover 2.1 The Boyer-Moore Logic This proof system is specified in the Nqthm version of the Boyer-Moore logic <ref> [6, 7] </ref>. Nqthm is a quantifier free first order logic that permits recursive definitions. It also defines an interpreter function for the quotation of terms in the logic. Nqthm uses a prefix syntax similar to pure Lisp.
Reference: 7. <author> R. S. Boyer and J S. Moore. </author> <title> The Addition of Bounded Quantification and Partial Functions to A Computational Logic and Its Theorem Prover. </title> <type> Tech. </type> <institution> Rept. ICSCA-CMP-52, Institute for Computer Science, University of Texas at Austin, </institution> <month> January, </month> <year> 1988. </year> <note> To appear in the Journal of Automated Reasoning, 1988. Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703.. </address>
Reference-contexts: Section 8 summarizes related work and offers some concluding remarks. 2. The Boyer-Moore Prover 2.1 The Boyer-Moore Logic This proof system is specified in the Nqthm version of the Boyer-Moore logic <ref> [6, 7] </ref>. Nqthm is a quantifier free first order logic that permits recursive definitions. It also defines an interpreter function for the quotation of terms in the logic. Nqthm uses a prefix syntax similar to pure Lisp. <p> All theorems presented here were mechanically verified by the Boyer-Moore prover enhanced with Kaufmann's proof checker [15]. 1 Actually, this quote mechanism is a facility of the Lisp reader [24]. 2 This simple definition is only true for total functions but is sufficient for this paper <ref> [7] </ref>. 3 2.3 Definitions with Quantifiers It is often useful to be able to include quantifiers in the body of a definition. Since the Boyer-Moore logic does not define quantifiers, the quantifiers must be removed by a technique called skolemization.
Reference: 8. <author> R.S. Boyer, D. Goldschlag, M. Kaufmann, J S. Moore. </author> <title> Functional Instantiation in First Order Logic. </title> <type> Tech. </type> <institution> Rept. </institution> <month> 44, </month> <title> Computational Logic, </title> <publisher> Inc., </publisher> <address> 1717 West Sixth Street, Suite 290 Austin, TX 78703, </address> <month> May, </month> <year> 1989. </year> <booktitle> Published in proceedings of the 1989 Workshop on Programming Logic, Programming Methodology Group, </booktitle> <institution> University of Goteborg, West Germany. </institution>
Reference-contexts: To ensure the consistency of the constraints, one must demonstrate that they are satisfiable. Therefore, the constrain event also requires the presentation of one old function symbol as a model for each new function symbol; the constraints, with each new symbol substituted by its model, must be provable <ref> [8] </ref>. There is no logical connection between the new symbols and their models, however; providing the models is simply a soundness guarantee. All extensions to the Boyer-Moore logic presented in this paper were added using either the definitional principle or the constrain mechanism.
Reference: 9. <author> Albert Camilleri. </author> <title> "Reasoning in CSP via the HOL Theorem Prover". </title> <journal> IEEE Transactions on Software Engineering SE-16 (September 1990). </journal>
Reference-contexts: Other researchers have embedded one logic within another mechanized logic in order to prove soundness and provide mechanized support for the new logic. Hoare logic was embedded in LCF in [23], Dijsktra's weakest preconditions were embedded in HOL in [4], while CSP was embedded in HOL in <ref> [9] </ref>. These mechanized theories have not been used to mechanically prove the correctness of other programs.
Reference: 10. <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison Wesley, </publisher> <address> Massachusetts, </address> <year> 1988. </year>
Reference-contexts: 1. Introduction This paper presents a mechanical formalization of three fairness notions and one safety assumption. This formalization extends the mechanization of Chandy and Misra's Unity logic <ref> [10] </ref> described in [13, 14] and permits the mechanical verification of concurrent programs under assumptions of unconditional, weak, and strong [11], and the safety assumption of deadlock freedom. Deadlock freedom guarantees that no deadlock occurs during the computation. Fairness abstractions are useful for reasoning about computations of non-deterministic programs. <p> For notational convenience, other quantified formulas are occasionally used in this paper (and were translated manually). In these cases, the quantifier symbols " and $ are used instead. 3. The Operational Semantics The operational semantics of concurrency used here is based on the transition system model <ref> [19, 20, 10] </ref>. A transition system is a set of statements that effect transitions on the system state. A computation is the sequence of states generated by the composition of an infinite sequence of transitions on an initial state.
Reference: 11. <author> Nissim Francez. </author> <title> Fairness. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: 1. Introduction This paper presents a mechanical formalization of three fairness notions and one safety assumption. This formalization extends the mechanization of Chandy and Misra's Unity logic [10] described in [13, 14] and permits the mechanical verification of concurrent programs under assumptions of unconditional, weak, and strong <ref> [11] </ref>, and the safety assumption of deadlock freedom. Deadlock freedom guarantees that no deadlock occurs during the computation. Fairness abstractions are useful for reasoning about computations of non-deterministic programs. Assuming a fairness notion may permit delaying consideration of certain implementation issues at early stages of program design.
Reference: 12. <author> S.J. Garland, J.V. Guttag, J.J. Horning. </author> <title> "Debugging Larch Shared Language Specifications". </title> <journal> IEEE Transactions on Software Engineering SE-16, </journal> <month> 9 (September </month> <year> 1990). </year>
Reference-contexts: Lamport has encoded the proof rules from his Temporal Logic of Actions [18] for weak and strong fairness on LP <ref> [12] </ref> and has used the system to verify a program. This operational semantics of concurrency presented here provides justification for both unconditional and weak fairness and for a subset of the Unity logic, by providing a model for an arbitrary weakly fair trace.
Reference: 13. <author> David M. Goldschlag. </author> <title> Mechanizing Unity. In Programming Concepts and Methods, </title> <editor> M. Broy and C. B. Jones, Eds., </editor> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: 1. Introduction This paper presents a mechanical formalization of three fairness notions and one safety assumption. This formalization extends the mechanization of Chandy and Misra's Unity logic [10] described in <ref> [13, 14] </ref> and permits the mechanical verification of concurrent programs under assumptions of unconditional, weak, and strong [11], and the safety assumption of deadlock freedom. Deadlock freedom guarantees that no deadlock occurs during the computation. Fairness abstractions are useful for reasoning about computations of non-deterministic programs.
Reference: 14. <author> David M. Goldschlag. </author> <title> "Mechanically Verifying Concurrent Programs with the Boyer-Moore Prover". </title> <journal> IEEE Transactions on Software Engineering SE-16, </journal> <month> 9 (September </month> <year> 1990). </year>
Reference-contexts: 1. Introduction This paper presents a mechanical formalization of three fairness notions and one safety assumption. This formalization extends the mechanization of Chandy and Misra's Unity logic [10] described in <ref> [13, 14] </ref> and permits the mechanical verification of concurrent programs under assumptions of unconditional, weak, and strong [11], and the safety assumption of deadlock freedom. Deadlock freedom guarantees that no deadlock occurs during the computation. Fairness abstractions are useful for reasoning about computations of non-deterministic programs.
Reference: 15. <author> M. Kaufmann. </author> <title> A User's Manual for an Interactive Enhancement to the Boyer-Moore Theorem Prover. </title> <type> Tech. </type> <institution> Rept. ICSCA-CMP-60, Institute for Computing Science, University of Texas at Austin, Austin, </institution> <address> TX 78712, </address> <year> 1987. </year> <note> Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703. </address>
Reference-contexts: Furthermore, the admissibility of these definitions and constraints was mechanically checked using the Boyer-Moore prover. This guarantees that the resulting logic is a conservative extension of the Boyer-Moore logic, and is therefore sound. All theorems presented here were mechanically verified by the Boyer-Moore prover enhanced with Kaufmann's proof checker <ref> [15] </ref>. 1 Actually, this quote mechanism is a facility of the Lisp reader [24]. 2 This simple definition is only true for total functions but is sufficient for this paper [7]. 3 2.3 Definitions with Quantifiers It is often useful to be able to include quantifiers in the body of a
Reference: 16. <author> Matt Kaufmann. DEFN-SK: </author> <title> An Extension of the Boyer-Moore Theorem Prover to Handle First-Order Quantifiers. </title> <type> Tech. </type> <institution> Rept. </institution> <month> 43, </month> <title> Computational Logic, </title> <publisher> Inc., </publisher> <month> May, </month> <year> 1989. </year> <note> Draft. </note>
Reference-contexts: Since the Boyer-Moore logic does not define quantifiers, the quantifiers must be removed by a technique called skolemization. If the definition is not recursive, adding the skolemized definition preserves the theory's consistency <ref> [16] </ref>. As a convenience, one may abbreviate nested FORALL's by putting all consecutive universally quantified variables in a list. Therefore, (FORALL X (FORALL Y (EQUAL X Y))) may be abbreviated to (FORALL (X Y) (EQUAL X Y)). Nested EXISTS's may be shortened similarly.
Reference: 17. <author> Leslie Lamport. </author> <title> "A Simple Approach to Specifying Concurrent Systems". </title> <booktitle> Communications of the ACM 32 (1989), </booktitle> <pages> 32-45. </pages>
Reference-contexts: The next sections present an operational characterization of an arbitrary computation. 3.1 A Concurrent Program A program is a list of statements. Each statement is a relation from previous states to next states <ref> [17] </ref>. We define the function N so the term (N OLD NEW E) is true if and only if NEW is a possible successor state to OLD under the transition specified by statement E. The actual definition of N is not important until one considers a particular program.
Reference: 18. <author> Leslie Lamport. </author> <title> A Temporal Logic of Actions. </title> <type> Tech. </type> <institution> Rept. Research Report 57, DEC Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> April, </month> <year> 1990. </year>
Reference-contexts: This proof rule is consistent with the rest of this theory because there exists a model for the function STRONGLY-FAIR satisfying this constraint: any unary function that is always false. Completeness and appropriateness is justified by the correctness of the supporting literature. <ref> [19, 18] </ref> It may appear that this proof rule requires circular reasoning: it proves one LEADS-TO property by appealing to another. <p> Other researchers 11 emphasize this point by requiring that the LEADS-TO property in the hypothesis be proved with respect to a smaller program: the original less the key statement. <ref> [18] </ref> 5.4 Deadlock Freedom Deadlock freedom guarantees lack of deadlock in the computation. Deadlock occurs when a statement which ought to be able to execute remains disabled. More precisely, a deadlocked condition is a stable condition that disables some program statement. <p> Lamport has encoded the proof rules from his Temporal Logic of Actions <ref> [18] </ref> for weak and strong fairness on LP [12] and has used the system to verify a program.
Reference: 19. <author> Zohar Manna and Amir Pnueli. </author> <title> "Adequate Proof Principles for Invariance and Liveness Properties of Concurrent Programs". </title> <booktitle> Science of Computer Programming 4 (1984), </booktitle> <pages> 257-289. 20 </pages>
Reference-contexts: For notational convenience, other quantified formulas are occasionally used in this paper (and were translated manually). In these cases, the quantifier symbols " and $ are used instead. 3. The Operational Semantics The operational semantics of concurrency used here is based on the transition system model <ref> [19, 20, 10] </ref>. A transition system is a set of statements that effect transitions on the system state. A computation is the sequence of states generated by the composition of an infinite sequence of transitions on an initial state. <p> This proof rule is consistent with the rest of this theory because there exists a model for the function STRONGLY-FAIR satisfying this constraint: any unary function that is always false. Completeness and appropriateness is justified by the correctness of the supporting literature. <ref> [19, 18] </ref> It may appear that this proof rule requires circular reasoning: it proves one LEADS-TO property by appealing to another. <p> Completeness and appropriateness is justified by the correctness of the supporting literature. [19, 18] It may appear that this proof rule requires circular reasoning: it proves one LEADS-TO property by appealing to another. A clever answer is found in <ref> [19] </ref>: We can disregard the key statement when proving the LEADS-TO property in the hypothesis, since if it is ultimately scheduled effectively, we can ignore the LEADS-TO property in the hypothesis (since Q is then reached), and if it not scheduled effectively, we can ignore it when deducing that hypothesis (since
Reference: 20. <author> Z. Manna and A. Pnueli. </author> <title> Verification of Concurrent Programs: The Temporal Framework. In The Correctness Problem in Computer Science, </title> <editor> R. S. Boyer and J S. Moore, Eds., </editor> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: For notational convenience, other quantified formulas are occasionally used in this paper (and were translated manually). In these cases, the quantifier symbols " and $ are used instead. 3. The Operational Semantics The operational semantics of concurrency used here is based on the transition system model <ref> [19, 20, 10] </ref>. A transition system is a set of statements that effect transitions on the system state. A computation is the sequence of states generated by the composition of an infinite sequence of transitions on an initial state.
Reference: 21. <author> Jayadev Misra. </author> <title> Auxiliary Variables. </title> <booktitle> Tech. Rept. Notes on UNITY: </booktitle> <pages> 15-90, </pages> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <month> July, </month> <year> 1990. </year>
Reference-contexts: Such properties are important, as they represent generalizations of the notion of fixed points in the computation. (Unity specifies such properties using UNLESS and LEADS-TO and adding auxiliary variables to the program <ref> [21] </ref>.) In our example, we will show that deadlock, which is a stable property, is, under certain hypotheses, eventually reached in the computation. Since deadlock freedom guarantees that deadlock is avoided, the hypotheses must be false. This is a key step in the correctness proof.
Reference: 22. <author> David M. Russinoff. </author> <title> Verifying Concurrent Programs with the Boyer-Moore Prover. </title> <type> Tech. </type> <institution> Rept. Forthcoming, MCC, Austin, Texas, </institution> <year> 1990. </year>
Reference-contexts: These mechanized theories have not been used to mechanically prove the correctness of other programs. Manna's and Pnueli's framework for proving both invariance and eventuality properties, under weak fairness, were formalized on the Boyer-Moore prover in <ref> [22] </ref>; this system was used to verify an example program computing binomial coefficients and several other programs. Lamport has encoded the proof rules from his Temporal Logic of Actions [18] for weak and strong fairness on LP [12] and has used the system to verify a program.
Reference: 23. <author> S. </author> <title> Sokolowski. "Soundness of Hoare's Logic: an Automatic Proof Using LCF". </title> <booktitle> TOPLAS 9 (1987), </booktitle> <pages> 100-120. </pages>
Reference-contexts: At the most abstract level, deadlock situations would be identified, and then assumed to be avoided. Other researchers have embedded one logic within another mechanized logic in order to prove soundness and provide mechanized support for the new logic. Hoare logic was embedded in LCF in <ref> [23] </ref>, Dijsktra's weakest preconditions were embedded in HOL in [4], while CSP was embedded in HOL in [9]. These mechanized theories have not been used to mechanically prove the correctness of other programs.
Reference: 24. <author> G. L. Steele, Jr. </author> <title> Common Lisp The Language. </title> <publisher> Digital Press, </publisher> <address> 30 North Avenue, Burlington, MA 01803, </address> <year> 1984. </year> <title> Table of Contents </title>
Reference-contexts: This guarantees that the resulting logic is a conservative extension of the Boyer-Moore logic, and is therefore sound. All theorems presented here were mechanically verified by the Boyer-Moore prover enhanced with Kaufmann's proof checker [15]. 1 Actually, this quote mechanism is a facility of the Lisp reader <ref> [24] </ref>. 2 This simple definition is only true for total functions but is sufficient for this paper [7]. 3 2.3 Definitions with Quantifiers It is often useful to be able to include quantifiers in the body of a definition.
Reference: 1. <institution> Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 </institution>
Reference-contexts: The interesting properties of concurrent programs are safety and liveness (progress). Safety properties are those that state that something bad will never happen [2]; examples are invariant properties such as mutual exclusion and freedom from deadlock. Liveness properties state that something good will eventually happen <ref> [1] </ref>; examples are termination and freedom from starvation.




Reference: 6. <institution> More Specification Predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 </institution>
Reference-contexts: In the second case, completeness depends upon whether the proof rules in the literature are sufficient. However, the proof system is sound, since the restricted operational semantics justifies the new proof rules. The mechanization presented here is an encoding of the Unity logic on the Boyer-Moore prover <ref> [5, 6] </ref>. Proofs in this system resemble Unity hand proofs, but are longer, since all concepts are defined from first principles. This proof system is semi-automatic since complex proofs are guided by the user. Mechanical verification provides greater trust in the correctness of a proof. <p> Section 8 summarizes related work and offers some concluding remarks. 2. The Boyer-Moore Prover 2.1 The Boyer-Moore Logic This proof system is specified in the Nqthm version of the Boyer-Moore logic <ref> [6, 7] </ref>. Nqthm is a quantifier free first order logic that permits recursive definitions. It also defines an interpreter function for the quotation of terms in the logic. Nqthm uses a prefix syntax similar to pure Lisp.

Reference: 8. <institution> Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 i </institution>
Reference-contexts: To ensure the consistency of the constraints, one must demonstrate that they are satisfiable. Therefore, the constrain event also requires the presentation of one old function symbol as a model for each new function symbol; the constraints, with each new symbol substituted by its model, must be provable <ref> [8] </ref>. There is no logical connection between the new symbols and their models, however; providing the models is simply a soundness guarantee. All extensions to the Boyer-Moore logic presented in this paper were added using either the definitional principle or the constrain mechanism.
References-found: 27

