URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/sequence.datalog/dbpl95.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: mecca@infokit.dis.uniroma1.it  bonner@db.toronto.edu  
Title: Finite Query Languages for Sequence Databases  
Author: Giansalvatore Mecca Anthony J. Bonner 
Web: URL: http://www.cs.toronto.edu/~bonner/papers.html#sequence-datalog  
Note: Appears in Proceedings of the Fifth International Workshop on Database Program ming Languages (DBPL), September 6-8, 1995, Gubbio, Umbria, Italy. This and related papers are available at the following  Research partially supported by MURST and Consiglio Nazionale delle Ricerche (CNR). Research partially supported by an operating grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).  
Address: Via Salaria, 113 00198 Roma, Italy  Toronto, Ontario Canada M5S 1A4  
Affiliation: Universita di Roma "La Sapienza" Dipartimento di Informatica e Sistemistica  University of Toronto Department of Computer Science  
Abstract: This paper develops a query language for sequence databases, such as genome databases and text databases. Unlike relational data, queries over sequential data can easily produce infinite answer sets, since the universe of sequences is infinite, even for a finite alphabet. The challenge is to develop query languages that are both highly expressive and finite. This paper develops such a language. It is a subset of a recently developed logic called Sequence Datalog [22]. Sequence Datalog distinguishes syntactically between subsequence extraction and sequence construction. Extraction creates sequences of bounded length, and leads to safe recursion; while construction can create sequences of arbitrary length, and leads to unsafe recursion. In this paper, we develop syntactic restrictions for Sequence Datalog that allow sequence construction but preserve finiteness. The main idea is to use safe recursion to control and limit unsafe recursion. The main results are a finite language, called Weakly Constructive Sequence Datalog, and a characterization of its complexity and expressive power. Although finite, the new language is highly expressive, since its data complexity is complete for the elementary functions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <journal> Journal of Comp. and Syst. Sci., </journal> <volume> 43(1), </volume> <year> 1991. </year>
Reference-contexts: We say that a variable, X, is guarded in a clause if X occurs in the body of the clause as an argument of some predicate. Otherwise, we say that X is unguarded. For example, X is guarded in p (X <ref> [1] </ref>) q (X), whereas it is unguarded in p (X) q (X [1]). Because of the active domain semantics, variables in Sequence Datalog clauses need not be guarded. The semantics of rules is formalized in [20] in terms of least fixpoints. <p> Otherwise, we say that X is unguarded. For example, X is guarded in p (X <ref> [1] </ref>) q (X), whereas it is unguarded in p (X) q (X [1]). Because of the active domain semantics, variables in Sequence Datalog clauses need not be guarded. The semantics of rules is formalized in [20] in terms of least fixpoints. <p> length k is at most P 2 k , that is, k (k+1) 2 + 1. answer (X) R (X); abc n (X [1:N 1 ]; X [N 1 + 1:N 2 ]; X [N 2 + 1:end]): abc n (*; *; *) true. abc n (X; Y; Z) X <ref> [1] </ref> = a; Y [1] = b; Z [1] = c; abc n (X [2:end]; Y [2:end]; Z [2:end]). The formula answer (X) is true iff X is a sequence in R and it is possible to split X in three parts such that abc n is true. <p> most P 2 k , that is, k (k+1) 2 + 1. answer (X) R (X); abc n (X [1:N 1 ]; X [N 1 + 1:N 2 ]; X [N 2 + 1:end]): abc n (*; *; *) true. abc n (X; Y; Z) X <ref> [1] </ref> = a; Y [1] = b; Z [1] = c; abc n (X [2:end]; Y [2:end]; Z [2:end]). The formula answer (X) is true iff X is a sequence in R and it is possible to split X in three parts such that abc n is true. <p> , that is, k (k+1) 2 + 1. answer (X) R (X); abc n (X [1:N 1 ]; X [N 1 + 1:N 2 ]; X [N 2 + 1:end]): abc n (*; *; *) true. abc n (X; Y; Z) X <ref> [1] </ref> = a; Y [1] = b; Z [1] = c; abc n (X [2:end]; Y [2:end]; Z [2:end]). The formula answer (X) is true iff X is a sequence in R and it is possible to split X in three parts such that abc n is true. <p> For example, given the sequence abcd, we want the sequence aabbccdd. We call these sequences echo sequences. The easiest way to define echo sequences is with the following program: answer (X; Y ) R (X); echo (X; Y ): echo (*; *) true. echo (X; X <ref> [1] </ref> * X [1] * Z) echo (X [2:end]; Z). The first rule retrieves every sequence in relation R and its echo, by invoking the predicate echo (X; Y ). The last two rules specify what an echo sequence is. <p> For example, given the sequence abcd, we want the sequence aabbccdd. We call these sequences echo sequences. The easiest way to define echo sequences is with the following program: answer (X; Y ) R (X); echo (X; Y ): echo (*; *) true. echo (X; X <ref> [1] </ref> * X [1] * Z) echo (X [2:end]; Z). The first rule retrieves every sequence in relation R and its echo, by invoking the predicate echo (X; Y ). The last two rules specify what an echo sequence is.
Reference: [2] <author> K.R. Apt and M.H. Van Emden. </author> <title> Contributions to the Theory of Logic Programming. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 841-862, </pages> <year> 1982. </year>
Reference-contexts: Because of the active domain semantics, variables in Sequence Datalog clauses need not be guarded. The semantics of rules is formalized in [20] in terms of least fixpoints. As in classical logic programming <ref> [28, 2, 19] </ref>, each Sequence Datalog program, P , has an associated operator, T P , that maps databases to databases. Each application of T P may create new atoms, which may contain new sequences. The operator T P is monotonic and continuous and has a least fixpoint [20].
Reference: [3] <author> M. Atkinson, F. Bancilhon, D. DeWitt, K. Dit-trich, D. Maier and Z. Zdonik. </author> <title> The object oriented database manifesto. </title> <booktitle> In DOOD, </booktitle> <year> 1989. </year>
Reference-contexts: 1 Introduction It is widely accepted that relational databases do not provide enough support for many of today's advanced applications. In some cases, object-oriented databases <ref> [3] </ref> are the right solution. However, in other cases, such as genome databases [12] and text databases [14], there is still a need for more flexibility in data representation and manipulation. In these applications, much of the data has an inherently sequential structure.
Reference: [4] <editor> P. Atzeni, editor. LOGIDATA+: </editor> <title> Deductive Databases with Complex Objects. </title> <publisher> LNCS 701 - Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: If s 1 ; s 2 are sequence terms, then s 1 * s 2 is a constructive sequence term. Thus, if S 1 and S 2 are sequence variables, and N is an index variable, then S 1 <ref> [4] </ref>, S 1 [1:N ], and ccgt * S 1 [1:end 1] * S 2 are all sequence terms. The semantics of terms is formalized in [20]. Constructive sequence terms have a semantics of concatenation; e:g:, abc * def = abcdef .
Reference: [5] <author> F. Bancilhon and R. Ramakrishnan. </author> <title> An Amateur's Introduction to Recursive Query Processing Strategies. </title> <booktitle> In ACM SIGMOD, </booktitle> <year> 1986. </year>
Reference-contexts: Recall that a rule is linear iff the predicate in the head is mutually recursive with the predicate of at most one atom in the body <ref> [5] </ref>. Actually, we require more than mere linearity, since we disallow mutual recursion through construction. 4 Thus, the predicate symbol in the head of a recursive constructive rule must also occur in the body of the rule. We call this restricted linear recursion through construction.
Reference: [6] <author> S. Bellantoni and S. Cook. </author> <title> A new recursion-theoretic characterization of the polytime functions. </title> <booktitle> In ACM STOC, </booktitle> <year> 1992. </year>
Reference: [7] <author> A. J. Bonner. </author> <title> Hypothetical Datalog: complexity and expressibility. </title> <journal> Theoretical Computer Science, </journal> <volume> 76, </volume> <year> 1990. </year>
Reference: [8] <author> V. Breazu-Tannen, P. Buneman and S. Naqvi. </author> <title> Structural recursion as a query language. </title> <booktitle> In DBPL, </booktitle> <year> 1991. </year>
Reference: [9] <author> V. Breazu-Tannen, P. Buneman and L. Wong. </author> <title> Naturally embedded query languages. </title> <booktitle> In ICDT, </booktitle> <year> 1992. </year>
Reference: [10] <author> A. K. Chandra and D. Harel. </author> <title> Computable queries for relational databases. </title> <journal> Journal of Comp. and Syst. Sci., </journal> <volume> 21, </volume> <year> 1980. </year>
Reference-contexts: Given a sequence query, Q, and a database, db, the result of evaluating Q over db is denoted Q (db). Similarly, a sequence function [11] is a partial mapping from fl to itself. A sequence function is computable if it is partial recursive. Usually, a notion of genericity <ref> [10] </ref> is introduced for queries. The notion can be extended to sequence queries in a natural way. We say that a sequence query Q is computable [10] if it is generic and partial recursive. <p> A sequence function is computable if it is partial recursive. Usually, a notion of genericity <ref> [10] </ref> is introduced for queries. The notion can be extended to sequence queries in a natural way. We say that a sequence query Q is computable [10] if it is generic and partial recursive. Sequence functions can be thought of as queries from a database, finput ( in )g, containing a single sequence tuple, to a database, foutput ( out )g, containing a single sequence tuple.
Reference: [11] <author> L. S. Colby, E. L. Robertson, L. V. Saxton and D. Van Gucht. </author> <title> A query language for list based complex objects. </title> <booktitle> In ACM PODS, </booktitle> <year> 1994. </year>
Reference-contexts: Given a sequence query, Q, and a database, db, the result of evaluating Q over db is denoted Q (db). Similarly, a sequence function <ref> [11] </ref> is a partial mapping from fl to itself. A sequence function is computable if it is partial recursive. Usually, a notion of genericity [10] is introduced for queries. The notion can be extended to sequence queries in a natural way.
Reference: [12] <institution> Communications of the ACM. </institution> <note> Special issue on the Human Genome project. vol.34, n.11. </note> <month> November </month> <year> 1991. </year>
Reference-contexts: 1 Introduction It is widely accepted that relational databases do not provide enough support for many of today's advanced applications. In some cases, object-oriented databases [3] are the right solution. However, in other cases, such as genome databases <ref> [12] </ref> and text databases [14], there is still a need for more flexibility in data representation and manipulation. In these applications, much of the data has an inherently sequential structure. This has several implications for database management systems.
Reference: [13] <author> S. Ginsburg and X. Wang. </author> <title> Pattern matching by RS-Operations: Towards a unified approach to querying sequenced data. </title> <booktitle> In ACM PODS, </booktitle> <year> 1992. </year>
Reference-contexts: For example, the contiguous subsequences of the sequence abc are: *; a; b; c; ab; bc; abc. We now describe an extension of the relational model, in the spirit of <ref> [13, 15] </ref>. The model allows for tuples containing sequences of elements, instead of just constant symbols. A relation of arity k over is a finite subset of the k-fold cartesian product of fl with itself. A database over is a finite set of relations over .
Reference: [14] <author> G. H. Gonnet. </author> <title> Text dominated databases: Theory, practice and experience. </title> <booktitle> Tutorial presented at ACM PODS, </booktitle> <year> 1994. </year>
Reference-contexts: 1 Introduction It is widely accepted that relational databases do not provide enough support for many of today's advanced applications. In some cases, object-oriented databases [3] are the right solution. However, in other cases, such as genome databases [12] and text databases <ref> [14] </ref>, there is still a need for more flexibility in data representation and manipulation. In these applications, much of the data has an inherently sequential structure. This has several implications for database management systems.
Reference: [15] <author> G. Grahne, M. Nykanen and E. Ukkonen. </author> <title> Reasoning about strings in databases. </title> <booktitle> In ACM PODS, </booktitle> <year> 1994. </year>
Reference-contexts: For example, the contiguous subsequences of the sequence abc are: *; a; b; c; ab; bc; abc. We now describe an extension of the relational model, in the spirit of <ref> [13, 15] </ref>. The model allows for tuples containing sequences of elements, instead of just constant symbols. A relation of arity k over is a finite subset of the k-fold cartesian product of fl with itself. A database over is a finite set of relations over .
Reference: [16] <author> S. Grumbach and T. Milo. </author> <title> An algebra for POM-SETS. </title> <booktitle> In ICDT, </booktitle> <year> 1995. </year>
Reference: [17] <author> N. Immerman. </author> <title> Relational queries computable in polynomial time. </title> <journal> Information and Control, </journal> <volume> 68, </volume> <year> 1986. </year>
Reference: [18] <author> N. Immerman, S. Patnaik and D. Stemple. </author> <title> The expressiveness of a family of finite set languages. </title> <booktitle> In ACM PODS, </booktitle> <year> 1991. </year>
Reference: [19] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming, Second Edition. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Moreover, if s 1 and s 2 are sequence terms, then s 1 = s 2 and s 1 6= s 2 are also atoms. From atoms, we build rules, facts and clauses in the usual way <ref> [19] </ref>. The head and body of a clause, fl, are denoted head (fl) and body (fl), respectively. A clause that contains a constructive term in its head is called a constructive clause. <p> Because of the active domain semantics, variables in Sequence Datalog clauses need not be guarded. The semantics of rules is formalized in [20] in terms of least fixpoints. As in classical logic programming <ref> [28, 2, 19] </ref>, each Sequence Datalog program, P , has an associated operator, T P , that maps databases to databases. Each application of T P may create new atoms, which may contain new sequences. The operator T P is monotonic and continuous and has a least fixpoint [20].
Reference: [20] <author> G. Mecca and A. J. Bonner. </author> <note> In preparation. </note> <year> 1995. </year>
Reference-contexts: In [22], we developed a logic called Sequence Datalog for querying sequence databases. Two safe subsets of the logic were defined, based on a new computational model called Generalized Sequence Transducers <ref> [20] </ref>. These machines are a simple yet powerful device for computing sequence mappings. In [22], we showed how networks of these machines could be expressed in Sequence Datalog. Moreover, any Sequence Datalog program constructed in this way is guaranteed to be safe and finite. <p> It uses a simple data model that extends the relational model by allowing tuples of sequences in relations, instead of just tuples of constant symbols. This section provides an informal overview of the syntax and semantics of Sequence Datalog. A formal development can be found in <ref> [20] </ref>. To manipulate sequences, SequenceDatalog has two interpreted function symbols for constructing complex terms, one for concatenating sequences and one for extracting subsequences. <p> Thus, if S 1 and S 2 are sequence variables, and N is an index variable, then S 1 [4], S 1 [1:N ], and ccgt * S 1 [1:end 1] * S 2 are all sequence terms. The semantics of terms is formalized in <ref> [20] </ref>. Constructive sequence terms have a semantics of concatenation; e:g:, abc * def = abcdef . Indexed sequence terms have a semantics of subsequence extraction; e:g:, abcdef [2:5] = bcde and abcdef [4:end] = def . <p> For example, X is guarded in p (X [1]) q (X), whereas it is unguarded in p (X) q (X [1]). Because of the active domain semantics, variables in Sequence Datalog clauses need not be guarded. The semantics of rules is formalized in <ref> [20] </ref> in terms of least fixpoints. As in classical logic programming [28, 2, 19], each Sequence Datalog program, P , has an associated operator, T P , that maps databases to databases. Each application of T P may create new atoms, which may contain new sequences. <p> Each application of T P may create new atoms, which may contain new sequences. The operator T P is monotonic and continuous and has a least fixpoint <ref> [20] </ref>. This paper develops conditions under which the least fixpoint is finite. In such cases, we say that P has a finite semantics.
Reference: [21] <author> G. Mecca and A. J. Bonner. </author> <title> Domain Bounded Recursion. </title> <note> In preparation. </note> <year> 1995. </year>
Reference-contexts: As mentioned earlier, only items 3 and 4 in this definition are strictly necessary. The others serve to simplify the development. (A more general treatment will soon be available in <ref> [21] </ref>.) Example 4.3 [Continued Shu*ing] Consider the predicate shu*e in Example 4.1. There are two recursive constructive rules this program, fl 2 and fl 3 . Both are restricted linear. and both have one constructive argument in the head.
Reference: [22] <author> G. Mecca and A. J. Bonner. </author> <title> Sequences, Datalog and Transducers. </title> <note> To appear in ACM PODS, </note> <year> 1995. </year>
Reference-contexts: The researcher thus faces an interesting challenge: on the one hand, the language should provide powerful primitives for restructuring sequences; on the other hand, the expressive power of the language should be carefully limited, to avoid infinite computations. In <ref> [22] </ref>, we developed a logic called Sequence Datalog for querying sequence databases. Two safe subsets of the logic were defined, based on a new computational model called Generalized Sequence Transducers [20]. These machines are a simple yet powerful device for computing sequence mappings. In [22], we showed how networks of these <p> In <ref> [22] </ref>, we developed a logic called Sequence Datalog for querying sequence databases. Two safe subsets of the logic were defined, based on a new computational model called Generalized Sequence Transducers [20]. These machines are a simple yet powerful device for computing sequence mappings. In [22], we showed how networks of these machines could be expressed in Sequence Datalog. Moreover, any Sequence Datalog program constructed in this way is guaranteed to be safe and finite. <p> We are interested in studying finite programs, that is, programs that have a finite semantics over every input database. However, as is typical of powerful logics, the finiteness property for Sequence Datalog programs is in general undecidable <ref> [22] </ref>. Thus, our aim is to develop subsets of the logic that are finite. In [22], we took what might be called a "semantic" approach, defining finite subsets in terms of abstract computing devices, called generalized sequence transducers. <p> However, as is typical of powerful logics, the finiteness property for Sequence Datalog programs is in general undecidable <ref> [22] </ref>. Thus, our aim is to develop subsets of the logic that are finite. In [22], we took what might be called a "semantic" approach, defining finite subsets in terms of abstract computing devices, called generalized sequence transducers. In this paper, we take a syntactic approach, defining finite subsets in terms of syntactic restrictions.
Reference: [23] <author> C. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Theorem 2 Every Weakly Constructive Sequence Datalog program is finite; that is, it has a finite semantics (least fixpoint) for every database. Although finite, Weakly Constructive Sequence Datalog is highly expressive. To see this, we first introduce the class of elementary sequence functions <ref> [23] </ref>. These are defined in terms of the hyper-exponential functions, hyp i (n), which are defined recursively as follows: * hyp 0 (n) = n hyp i is called the hyper-exponential function of level i.
Reference: [24] <author> J. Richardson. </author> <title> Supporting lists in a data model (A timely approach). </title> <booktitle> In VLDB, </booktitle> <year> 1992. </year>
Reference: [25] <author> D. B. </author> <title> Searls. String Variable Grammars: a logic grammar formalism for DNA sequences. </title> <type> Tech. Report, </type> <institution> University of Pennsylvania School of Medicine, </institution> <year> 1993. </year>
Reference: [26] <author> D. Stott Parker, E. Simon and P. Valduriez. </author> <title> SVP a model capturing sets, streams and parallelism. </title> <booktitle> In VLDB, </booktitle> <year> 1992. </year>
Reference: [27] <author> The Committee for Advanced DBMS functions. </author> <title> Third-generation database system manifesto. </title> <booktitle> In SIGMOD Record, </booktitle> <volume> 19(3), </volume> <year> 1990. </year>
Reference: [28] <author> M.H. Van Emden and R.A. Kowalski. </author> <title> The Semantics of Predicate Logic as a Programming Language, </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: Because of the active domain semantics, variables in Sequence Datalog clauses need not be guarded. The semantics of rules is formalized in [20] in terms of least fixpoints. As in classical logic programming <ref> [28, 2, 19] </ref>, each Sequence Datalog program, P , has an associated operator, T P , that maps databases to databases. Each application of T P may create new atoms, which may contain new sequences. The operator T P is monotonic and continuous and has a least fixpoint [20].
Reference: [29] <author> M. Vardi. </author> <title> The complexity of relational query languages. </title> <booktitle> In ACM STOC, </booktitle> <year> 1982. </year>
Reference-contexts: A sequence query language cannot express complex queries over sequence databases if it cannot express complex sequence functions. In short, function expressibility is necessary for query expressibility. This paper addresses the complexity of sequence functions, and the data complexity <ref> [29] </ref> of sequence queries. Given a sequence function, f , the complexity of f is defined in the usual way, as the complexity of computing f (), measured with respect to the length of the sequence .
References-found: 29

