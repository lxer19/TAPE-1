URL: ftp://ftp.irisa.fr/local/lande/pf-lisp94.ps.Z
Refering-URL: http://www.irisa.fr/lande/fradet/Fradet.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fradet@irisa.fr  
Title: Collecting More Garbage  
Author: Pascal Fradet Inria/Irisa 
Note: Lisp 94 6/94  1994 ACM 0-89791-643-3/94/006..$3.50 Abstract  
Address: 35042 Rennes Cedex, France  Orlando, Florida USA  
Affiliation: Campus de Beaulieu,  
Abstract: Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association of Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. We present a method, adapted to polymorphically typed functional languages, to detect and collect more garbage than existing GCs. It can be applied to strict or lazy higher order languages and to several garbage collection schemes. Our GC exploits the information on utility of arguments provided by polymorphic types of functions. It is able to detect garbage that is still referenced from the stack and may collect useless parts of otherwise useful data structures. We show how to partially collect shared data structures and to extend the type system to infer more precise information. We also present how this technique can plug several common forms of space leaks. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Aditya and A. Caro. </author> <title> Compiler-directed type reconstruction for polymorphic languages. </title> <booktitle> In Proc. of the ACM Conf. on Func. Prog. and Comp. Arch., </booktitle> <pages> pp. 74-82, </pages> <year> 1993. </year>
Reference-contexts: There are cases involving higher-order polymorphic functions where types cannot be completely reconstructed during garbage collection. A solution is to generate explicit tagging when necessary <ref> [1] </ref>. These tags are taken as extra arguments by functions and will be propagated at run time. 3 Collecting More Garbage 3.1 The basic method Our collecting method is based on the same technique as tag-less garbage collection. <p> Contrary to tagless garbage collection, we do not attempt to completely reconstruct the types of acces * We assume for now a language with no polymorphic comparison operators ; they are considered in section 3.3. <ref> [1] </ref> [[3];[4]] return address corresponding return address corresponding to the first recursive call to to the call append (append [[1];[2]] [[3];[4]]) sible objects ; we rather try to minimally instantiate polymor-phic types. A return address can be seen as a continuation of the form lx 1 . lx n .lr. <p> All the sublists (<ref> [1] </ref>, [2],[3],[4]) have been collected and the new heap contains only two cons cells and a nil. o lr.length r lx.lr.cons x r [1] [[3];[4]] List a fi Int a fi List a fi List a 3.2 Formalization We represent a stack of activation records as applications of closed functional expressions: (lx 1 . lx m .lr. <p> P represents printable values and we assume that types of programs (i.e. stacks) belong to P. We use the following conventions: a,b,c,d,e V b B t,s T p P The stack in Example 2 can be represented by the expression of type Int f 1 (f 2 <ref> [1] </ref> (f 2 [2] [[3];[4]])) with f 1 lr.length r and f 2 lx.lr.cons x r The intuition that polymorphic functions do not need the complete structure of their arguments for proper execution is formalized by Reynolds abstraction or parametricity theorem [24]. <p> So, activation records, higher-order functions and unevaluated arguments, which are all represented by closures, involve preliminary unifications. Example 3 Let us return to our previous example stack f 1 (f 2 <ref> [1] </ref> (f 2 [2] [[3];[4]])) with f 1 (lr.length r):List afiInt and f 2 lx.lr.cons x r gc Int stack = f 1 (gc List a (f 2 [1] (f 2 [2] [[3];[4]]))) (gc2) | - f 1 :List afiInt = f 1 (f 2 (gc a [1]) (gc List a <p> Example 3 Let us return to our previous example stack f 1 (f 2 <ref> [1] </ref> (f 2 [2] [[3];[4]])) with f 1 (lr.length r):List afiInt and f 2 lx.lr.cons x r gc Int stack = f 1 (gc List a (f 2 [1] (f 2 [2] [[3];[4]]))) (gc2) | - f 1 :List afiInt = f 1 (f 2 (gc a [1]) (gc List a (f 2 [2] [[3];[4]]))) (gc2) | - f 2 :afiList afiList a = f 1 (f 2 ^ (f 2 (gc a [2]) (gc List a [[3];[4]]))) (gc1),(gc2) <p> 1 (f 2 <ref> [1] </ref> (f 2 [2] [[3];[4]])) with f 1 (lr.length r):List afiInt and f 2 lx.lr.cons x r gc Int stack = f 1 (gc List a (f 2 [1] (f 2 [2] [[3];[4]]))) (gc2) | - f 1 :List afiInt = f 1 (f 2 (gc a [1]) (gc List a (f 2 [2] [[3];[4]]))) (gc2) | - f 2 :afiList afiList a = f 1 (f 2 ^ (f 2 (gc a [2]) (gc List a [[3];[4]]))) (gc1),(gc2) = f 1 (f 2 ^ (f 2 ^ ((gc a [3]).(gc List a [[4]]))))) (gc1),(gc4) = f 1
Reference: [2] <author> A.W. Appel. </author> <title> Runtimes tags arent necessary. </title> <journal> Lisp and Symb. Comp., </journal> <volume> 2, </volume> <pages> pp. 153-162, </pages> <year> 1989. </year>
Reference-contexts: We use the following conventions: a,b,c,d,e V b B t,s T p P The stack in Example 2 can be represented by the expression of type Int f 1 (f 2 [1] (f 2 <ref> [2] </ref> [[3];[4]])) with f 1 lr.length r and f 2 lx.lr.cons x r The intuition that polymorphic functions do not need the complete structure of their arguments for proper execution is formalized by Reynolds abstraction or parametricity theorem [24]. <p> So, activation records, higher-order functions and unevaluated arguments, which are all represented by closures, involve preliminary unifications. Example 3 Let us return to our previous example stack f 1 (f 2 [1] (f 2 <ref> [2] </ref> [[3];[4]])) with f 1 (lr.length r):List afiInt and f 2 lx.lr.cons x r gc Int stack = f 1 (gc List a (f 2 [1] (f 2 [2] [[3];[4]]))) (gc2) | - f 1 :List afiInt = f 1 (f 2 (gc a [1]) (gc List a (f 2 [2] <p> Example 3 Let us return to our previous example stack f 1 (f 2 [1] (f 2 <ref> [2] </ref> [[3];[4]])) with f 1 (lr.length r):List afiInt and f 2 lx.lr.cons x r gc Int stack = f 1 (gc List a (f 2 [1] (f 2 [2] [[3];[4]]))) (gc2) | - f 1 :List afiInt = f 1 (f 2 (gc a [1]) (gc List a (f 2 [2] [[3];[4]]))) (gc2) | - f 2 :afiList afiList a = f 1 (f 2 ^ (f 2 (gc a [2]) (gc List a [[3];[4]]))) (gc1),(gc2) = f 1 <p> <ref> [2] </ref> [[3];[4]])) with f 1 (lr.length r):List afiInt and f 2 lx.lr.cons x r gc Int stack = f 1 (gc List a (f 2 [1] (f 2 [2] [[3];[4]]))) (gc2) | - f 1 :List afiInt = f 1 (f 2 (gc a [1]) (gc List a (f 2 [2] [[3];[4]]))) (gc2) | - f 2 :afiList afiList a = f 1 (f 2 ^ (f 2 (gc a [2]) (gc List a [[3];[4]]))) (gc1),(gc2) = f 1 (f 2 ^ (f 2 ^ ((gc a [3]).(gc List a [[4]]))))) (gc1),(gc4) = f 1 (f 2 ^ (f 2 ^ <p> (gc List a (f 2 [1] (f 2 <ref> [2] </ref> [[3];[4]]))) (gc2) | - f 1 :List afiInt = f 1 (f 2 (gc a [1]) (gc List a (f 2 [2] [[3];[4]]))) (gc2) | - f 2 :afiList afiList a = f 1 (f 2 ^ (f 2 (gc a [2]) (gc List a [[3];[4]]))) (gc1),(gc2) = f 1 (f 2 ^ (f 2 ^ ((gc a [3]).(gc List a [[4]]))))) (gc1),(gc4) = f 1 (f 2 ^ (f 2 ^ [^;^])) (gc1),(gc4),(gc5) If the stack was f 1 (f 3 f 4 [(1,2);(3,4)]) with f 3 lf.ll.map f l :
Reference: [3] <author> A.W. Appel. </author> <title> A runtime system. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3, </volume> <pages> pp. 343-380, </pages> <year> 1990. </year>
Reference-contexts: This compiler transforms expressions into functional terms which can be seen as a stack-based machine code. It can compile strict or lazy languages ; its standard GC is a simple stop&copy and pointers are distinguished from values using a tag bit (as in the SML New Jersey compiler <ref> [3] </ref>). We saw in section 6 that some low level information (like updates or stack layout during a recursive call) must be taken into account in the type information. We choose to perform a new type inference on the functional machine code produced by our compiler.
Reference: [4] <author> H.G. Baker. </author> <title> Unify and conquer (garbage, updating, aliasing, </title> ) <booktitle> in functional languages. In Proc. of the ACM Conf. on Lisp and Functional Programming, </booktitle> <pages> pp. 218-226, </pages> <year> 1990. </year>
Reference-contexts: In the best cases those analyses detect what a traditional GC would detect at run time. We see this approach and ours as complementary. The most common optimization allowed by Hindley/ Milner type system is to avoid run time checks. In <ref> [4] </ref>, Baker shows how to use ML-like type inference for sharing analysis. We have shown in this paper that polymorphic types can also be used to improve garbage collection.
Reference: [5] <author> Y. Bekkers, O. Ridoux and L. Ungaro. </author> <title> Dynamic memory management for sequential logic programming languages. </title> <booktitle> In Proc. of Work. on Memory Management, </booktitle> <volume> LNCS 637, </volume> <pages> pp. 82-102, </pages> <year> 1992. </year>
Reference-contexts: In [27], Wadler suggests an extension specific to tuples and we saw in section 6 how this is done in our approach. There also exist garbage collectors, adapted to non-deterministic languages, which detect and collect the useless binding values of useful logic variables <ref> [5] </ref>. Compile-time garbage collection is a static analysis which detects points in the program where part of the store can be collected [17][19]. This information can then be used to reallocate old store. It reduces store use and therefore reduces garbage collection overhead.
Reference: [6] <author> D.E. Britton. </author> <title> Heap Storage Management for the Programming Language Pascal. </title> <type> Masters Thesis, </type> <institution> University of Arizona, </institution> <year> 1975. </year>
Reference-contexts: The advantage of removing tags is that it saves space and that overhead is placed on garbage collection rather than on normal execution. This method is easy to implement for Pascal-like languages where every variable has a fixed type <ref> [6] </ref>. Tag-free garbage collection gets more complicated with polymorphically typed languages [2][11]. A polymorphic function is usually implemented by a single code and the template associated with its activation record contains polymorphic types.
Reference: [7] <author> C.J. </author> <title> Cheney. A nonrecursive list compacting algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 13(11), </volume> <pages> pp. 677-678, </pages> <year> 1970. </year>
Reference: [8] <author> J. Cohen, </author> <title> Garbage collection of linked data structures. </title> <journal> Computing Surveys, </journal> <volume> Vol. 13, 3, </volume> <year> 1981. </year>
Reference-contexts: It only uses unification which has a linear time complexity. However, types can be of exponential length and, for those pathological cases, the type annotations generated by the compiler should be approximated (e.g using T as in section 3.3). This approach can be used with several garbage collection schemes <ref> [8] </ref>: a mark&sweep GC does not mark structures associated with type variables whereas a stop&copy GC does not copy them. The method mixing reference counts with classical garbage collection (usually performed as a last resort) can also benefit from it. In this case, the first scan can be avoided.
Reference: [9] <author> P. Fradet and D. Le Mtayer. </author> <title> Compilation of functional languages by program transformation. </title> <journal> ACM Trans. on Prog. Lang. and Sys., </journal> <volume> 13(1), </volume> <pages> pp. 21-51, </pages> <year> 1991. </year>
Reference-contexts: This method does not entail any overhead at run time and other kinds of leaks (e.g. related to lists) can also be plugged. 7 Implementation issues We are currently integrating this extension into our transformation based compiler <ref> [9] </ref>. This compiler transforms expressions into functional terms which can be seen as a stack-based machine code. It can compile strict or lazy languages ; its standard GC is a simple stop&copy and pointers are distinguished from values using a tag bit (as in the SML New Jersey compiler [3]).
Reference: [10] <author> D.P. Friedman and D.S. Wise. </author> <title> Garbage collecting a heap which includes a scatter table. </title> <journal> Inf. Proc. Letters, </journal> <volume> 5(6), </volume> <pages> pp. 161-164, </pages> <year> 1976. </year>
Reference: [11] <author> B. Goldberg. </author> <title> Tag-free garbage collection for strongly typed programming languages. </title> <booktitle> In Proc. of the ACM SIGPLAN91 Symp. on Prog. Lang. Design and Implementation,pp.165-176, </booktitle> <year> 1991. </year>
Reference-contexts: We benefit from run time information by exploring the stack which describes a more specific program and the heap which provides exact sharing information. We are not aware of any other general approach to collect useless reachable structures. In <ref> [11] </ref>, Goldberg mentions that a tagless GC could use a live variable analysis to collect dead variables of activation records. In our framework, this is done by reclaiming roots associated with type variables.
Reference: [12] <author> B. Goldberg and M. Gloger. </author> <title> Polymorphic type reconstruction for garbage collection without tags. </title> <booktitle> In Proc. of the ACM Conf. on Lisp and Func. Prog., </booktitle> <pages> pp. 53-65, </pages> <year> 1992. </year>
Reference-contexts: The GC traces and copies the local variable according to its type (List Int) and continues the exploration of the stack. o This method is described in <ref> [12] </ref>. There are cases involving higher-order polymorphic functions where types cannot be completely reconstructed during garbage collection. A solution is to generate explicit tagging when necessary [1].
Reference: [13] <author> F. Henglein. </author> <title> Type inference with polymorphic recursion. </title> <journal> ACM Trans. on Prog. Lang. and Sys., </journal> <volume> 15(2), </volume> <pages> pp. 253-289, </pages> <year> 1993. </year>
Reference-contexts: If the function has type s using the classic type inference, the type t inferred now is such that st. Satisfying such inequalities is closely related to the semiunification problem (i.e. finding a substitution, called a semiunifier, S such that SsSt for all inequalities) <ref> [13] </ref>. Since we consider programs already typed by the Hindley/Milner system, this problem, undecidable in general, becomes tractable. The relation is defined only on unifiable types, so our systems of inequations are unifiable and therefore semiunifiable. Constraint sets are satisfied using the following rules. <p> This is actually a simplified version of the algorithm described in <ref> [13] </ref>. It has been proved that for semiunifiable ine-quations this algorithm terminates and finds a most general semiunifier. A simpler alternative is to unify the lhs and rhs of constraints of the form atfit and aList t instead of introducing fresh variables.
Reference: [14] <author> G. Huet. </author> <title> Rsolution dquations dans les lan-gages dordre 1, </title> <institution> 2,w. Thse de doctorat dtat, Universit de Paris VII, </institution> <year> 1976. </year>
Reference-contexts: Recursive data types are noted explicitly using the operator m. For example, List a becomes (mt. nil + cons a t). To unify recursive data types we have to replace standard unification by unification of rational trees <ref> [14] </ref> (both have the same complexity).
Reference: [15] <author> J. Hughes. </author> <title> The design and implementation of programming languages. D. </title> <type> Phil. Thesis, </type> <institution> Oxford University, </institution> <year> 1983. </year>
Reference-contexts: In order to deal with shared closures the unification of any type with U yields U. Tuples. Another class of space leaks has been described by Hughes <ref> [15] </ref>. In lazy functions returning tuples, the result, say r, is often retained in expressions such as (fst r) or (snd r). Hughes showed that some of these functions are inherently leaky, no matter how they are expressed.
Reference: [16] <author> J. Hughes. </author> <title> Lazy memo-functions. </title> <booktitle> In Proc. of the ACM Conf. on Func. Prog. and Comp. Arch., pp.129-146, LNCS 201, </booktitle> <year> 1985. </year>
Reference: [17] <author> K. Inoue, H. Seki and H. Yagi. </author> <title> Analysis of functional programs to detect run-time garbage cells. </title> <journal> ACM Trans. on Prog. Lang. and Sys., </journal> <volume> 10(4), </volume> <pages> pp. </pages> <year> 555-578,1988. </year>
Reference: [18] <author> R. Jones. </author> <title> Tail recursion without space leaks. </title> <journal> Journal of Func. Progr., </journal> <volume> 2 (1), </volume> <pages> pp. 73-79, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: Updatable Closures. A similar problem occurs in implemen-tations of lazy languages. During the evaluation of a closure, a pointer on the closure is kept in order to update it later by its value. The same technique of blackholing is needed to avoid space leaks <ref> [18] </ref>. Here, we make the update explicit using an operator updt with type Ufibfib; U being a special type associated with the pointer needed for the update and b the type of the result. Structures with types U are not traced but the GC replaces them by a blackhole closure. <p> Structures with types U are not traced but the GC replaces them by a blackhole closure. This closure serves to retain enough space for the update and to detect certain forms of non-termination if it is accessed before the update <ref> [18] </ref>. In order to deal with shared closures the unification of any type with U yields U. Tuples. Another class of space leaks has been described by Hughes [15]. In lazy functions returning tuples, the result, say r, is often retained in expressions such as (fst r) or (snd r).
Reference: [19] <author> S.B. Jones and D. Le Mtayer. </author> <title> Compile-time garbage collection by sharing analysis. </title> <booktitle> In Proc. of the ACM Conf. on Func. Prog. and Comp. Arch., </booktitle> <address> pp.54-74, </address> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference: [20] <author> H.G. Mairson. </author> <title> Deciding ML typability is complete for deterministic exponential time. </title> <booktitle> In Proc. of the 17 th ACM Conf. on Princ. of Prog. Languages, </booktitle> <pages> pp. 382-401, </pages> <year> 1990. </year>
Reference-contexts: Pointers on useless structures are replaced by a special constant (the ^ of section 3). The GC process is not directly concerned by the bad worst case complexity of ML-like type inference <ref> [20] </ref>. It only uses unification which has a linear time complexity. However, types can be of exponential length and, for those pathological cases, the type annotations generated by the compiler should be approximated (e.g using T as in section 3.3).
Reference: [21] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> J. Comput. Syst. Sci. </journal> <volume> 17, </volume> <pages> pp. 348-375, </pages> <year> 1978. </year>
Reference-contexts: This technique places no overhead on normal execution. It can be applied to strict or lazy higher order languages and can be used to improve different kinds of GCs (stop&copy, mark&sweep, ). The key property exploited here is parametricity [24][28], a theorem satisfied by Hindley/Milner polymorphic type system <ref> [21] </ref>. Parametricity can be applied to deduce information on the utility of arguments from the polymorphic type of a function. For example, the function length : List afiInt can be reduced regardless of the actual elements of the list. This property is just an instance of Wadlers free theorems [28].
Reference: [22] <author> P. Mishra and U.S. Reddy. </author> <title> Declaration-free type checking. </title> <booktitle> In Proc. of the ACM Conf. on Princ. of Prog. Languages, </booktitle> <pages> pp. 7-21, </pages> <year> 1985. </year>
Reference-contexts: : case xs in nil : 0 cons y ys : y + f ys The type inferred for f is (mt. nil + cons a (nil + cons Int t))fiInt and elements occurring at odd places in the list may be re claimed. p This extension is related to <ref> [22] </ref> which aims at inferring types without explicit type declarations. Their type inference produces accurate types and we could make use of them.
Reference: [23] <editor> S.L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1987. </year>
Reference: [24] <author> J.C. Reynolds. </author> <title> Types, abstraction, and parametric polymorphism. </title> <booktitle> In Proc. of Information Processing 83, </booktitle> <pages> pp. 513-523, </pages> <year> 1983. </year>
Reference-contexts: the expression of type Int f 1 (f 2 [1] (f 2 [2] [[3];[4]])) with f 1 lr.length r and f 2 lx.lr.cons x r The intuition that polymorphic functions do not need the complete structure of their arguments for proper execution is formalized by Reynolds abstraction or parametricity theorem <ref> [24] </ref>. Wadler has shown in [28] how to use parametricity to derive theorems from types. Actually those theorems are just what we need to justify our approach.
Reference: [25] <author> H. Shorr and W.M. Waite. </author> <title> An efficient machine-independent procedure for garbage collection in various list structures. </title> <journal> Communications of the ACM, </journal> <volume> 10, </volume> <pages> pp. 501-506, </pages> <year> 1967. </year>
Reference-contexts: The tracing of structures according to type information is a depth-first traversal using Shorr-Waite algorithm which uses a link reversal technique to avoid the need for a stack <ref> [25] </ref>. Pointers on useless structures are replaced by a special constant (the ^ of section 3). The GC process is not directly concerned by the bad worst case complexity of ML-like type inference [20]. It only uses unification which has a linear time complexity.
Reference: [26] <author> R. Tarjan. </author> <title> Depth-first search and linear graph algorithms. </title> <journal> Siam J. Comp., </journal> <volume> 1, </volume> <pages> pp. 146-160, </pages> <year> 1972. </year>
Reference-contexts: Implementations based on graph reduction sometimes implement recursion (combinator Y) using cycles. This would require an extension of the partial collection process. We have not investigated this issue thoroughly, however two trivial solutions come to mind. The strong components of a graph can be computed in linear time <ref> [26] </ref>. We can then use our technique on the reduced graph (whose vertices are the strong components).
Reference: [27] <author> P. Wadler. </author> <title> Fixing some space leaks with a garbage collector. </title> <journal> Software Practice and Experience, </journal> <volume> 17(9), </volume> <pages> pp. 595-608, </pages> <year> 1987. </year>
Reference-contexts: In lazy functions returning tuples, the result, say r, is often retained in expressions such as (fst r) or (snd r). Hughes showed that some of these functions are inherently leaky, no matter how they are expressed. One solution, proposed by Wadler <ref> [27] </ref>, is to modify the GC to perform the simplification rules fst (x,y)=x and snd (x,y)=y. In our approach, space leaks treated by Wadlers technique are naturally avoided. The type of fst (resp. snd) being (a,b)fia (resp.(a,b)fib), our GC will reclaim its second (resp. first) argument. Tables. <p> We are not aware of any other general approach to collect useless reachable structures. In [11], Goldberg mentions that a tagless GC could use a live variable analysis to collect dead variables of activation records. In our framework, this is done by reclaiming roots associated with type variables. In <ref> [27] </ref>, Wadler suggests an extension specific to tuples and we saw in section 6 how this is done in our approach. There also exist garbage collectors, adapted to non-deterministic languages, which detect and collect the useless binding values of useful logic variables [5].
Reference: [28] <author> P. Wadler. </author> <title> Theorems for free! In Proc. </title> <booktitle> of the ACM Conf. on Func. Progr. and Comp. Arch., </booktitle> <pages> pp. 347-359, </pages> <year> 1989. </year>
Reference-contexts: Parametricity can be applied to deduce information on the utility of arguments from the polymorphic type of a function. For example, the function length : List afiInt can be reduced regardless of the actual elements of the list. This property is just an instance of Wadlers free theorems <ref> [28] </ref>. It holds for all functions of this type and allows a garbage collector to collect the elements of their list argument. Although our goals are different, our technique shares many common points with tagless garbage collection which we quickly review in section 2. <p> Wadler has shown in <ref> [28] </ref> how to use parametricity to derive theorems from types. Actually those theorems are just what we need to justify our approach. <p> Property 4 For all closed stack of type p stack = gc p stack Proof. [sketch] For brevity sake, we do not redescribe the parametricity property, how to read types as relations and to derive theorems ; the reader is referred to <ref> [28] </ref>. In our case we fix the functions (relations) corresponding to types variables to be lx.^. <p> The polymorphism comes here from the polymorphic equality operator in member which has type "a. afiafiBool but does need the value of its arguments. Polymorphic comparison operators cannot be defined in the pure polymorphic l-calculus and parametricity does not hold with such operators. In <ref> [28] </ref> Wadler gives polymorphic equality a special type, " = a. afiafiBool, and enforces that function a associated with the type variable a respects equality (i.e. x=y iff a x = a y).
Reference: [29] <author> P.R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <booktitle> In Proc. of Work. on Memory Management, </booktitle> <volume> LNCS 637, </volume> <pages> pp. 1-42, </pages> <year> 1992. </year>
References-found: 29

