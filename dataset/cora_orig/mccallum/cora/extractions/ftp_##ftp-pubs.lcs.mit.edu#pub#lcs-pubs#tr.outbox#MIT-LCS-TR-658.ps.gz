URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-658.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/tr600.html
Root-URL: 
Title: Increasing Cross-Domain Call Batching using Promises and Batched Control Structures  
Author: Quinton Y. Zondervan 
Address: 545 Technology Square Cambridge, Massachusetts 02139  
Affiliation: Massachusetts Institute of Technology Laboratory for Computer Science  
Note: c Massachusetts Institute of Technology 1994. All rights reserved. This work was supported by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research under contract N00014-91-J-4136.  
Date: June 1995  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> B. Bershad, T. Anderson, E. Lazowska, and H. Levy. </author> <title> Lightweight remote procedure call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1), </volume> <month> February </month> <year> 1990. </year>
Reference-contexts: However, crossing a domain boundary can be expensive. If the client and server are distinct processes running on the same machine, each call requires a context switch, which is much slower than a direct function call <ref> [1] </ref>. When the client and server are running on separate machines, and need to communicate across a network, the cost of a context switch is even worse. In previous work, Bogle [3] presented a mechanism, called batched futures, for sending calls to the server in batches.
Reference: [2] <author> Andrew P. Black and Norman Hutchinson. </author> <title> Typechecking polymorphism in Emerald. </title> <type> Technical Report 91/1, </type> <institution> Digital Equipment Corporation, Cambridge Research Laboratory, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: The keyword yields is used instead of returns in the case of an iterator. Type hierarchy Theta allows subtyping. In Theta, a subtype S must have all the methods of its supertype T with compatible signatures <ref> [16, 2, 4] </ref>, plus perhaps some additional methods.
Reference: [3] <author> P. Bogle. </author> <title> Reducing cross-domain call overhead using batched futures. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1994. </year>
Reference-contexts: When the client and server are running on separate machines, and need to communicate across a network, the cost of a context switch is even worse. In previous work, Bogle <ref> [3] </ref> presented a mechanism, called batched futures, for sending calls to the server in batches. Normally, each call is sent to the server and evaluated. Results are either handles which are references to object stored at the server, or basic values such as integers or booleans. <p> This is accomplished by providing a veneer <ref> [3] </ref> for each programming language. The veneer extends the language with the necessary procedures to interact with Thor. Several veneers have been implemented for Thor, including C, C++, Emacs Lisp, Perl, TCL [3] and Modula3 [10]. <p> This is accomplished by providing a veneer <ref> [3] </ref> for each programming language. The veneer extends the language with the necessary procedures to interact with Thor. Several veneers have been implemented for Thor, including C, C++, Emacs Lisp, Perl, TCL [3] and Modula3 [10]. In the remainder of this thesis we will limit our discussion to the C++ veneer, but the concepts explained here are not limited to the C++ veneer. The veneer provides the client with an interface to Thor. The interface is implemented by a library of procedures. <p> In addition, the C++ veneer maintains a mapping between handles and stub objects, which are C++ objects that mimic corresponding Thor objects. In the remainder of this section we will describe the stub object mechanism in more detail. For a more general discussion of veneers, see <ref> [3] </ref>. 2.4.1 Veneer stubs The veneer manages the set of handles currently referred to by the client. In the C++ veneer, these handles are encapsulated in stub objects, which mimic the Thor objects they represent. The veneer also provides a stub procedure for each Thor routine or method. <p> In chapter 5, we present a new mechanism for calling iterators. 2.5 Discussion The invocation mechanism described in this chapter is inefficient. Each call made by the client requires a round-trip communication with the Frontend, which is expensive. The next chapter describes a mechanism, batched futures <ref> [3] </ref>, which reduces the overhead by amortizing the cost of a domain crossing across several calls which are sent to the Frontend in a batch. <p> The remainder of the thesis describes two mechanisms for increasing the average batch size, and thus improving the overall performance. 18 Chapter 3 Batched Futures Batched futures <ref> [3] </ref> is a mechanism that allows cross domain calls to the server to be batched. Batching calls improves performance, because the cost of a domain crossing between the client and the server is amortized over the number of calls in a batch. <p> The final call indicates that the result of calling the first method on future f n should be returned to the client. 3.2 Implementation This section contains a brief description of the batched futures implementation. A complete description of the implementation can be found in <ref> [3] </ref>. <p> If the promise is a value, the Frontend treats it as it would treat a normal basic value argument. If it is a future, the corresponding value is looked up in the future table F, and used as the argument to the actual call. 4.4 Experimental Results In <ref> [3] </ref>, Bogle uses his performance model to describe the expected impact of promises on the performance of the 2b traversal of the OO7 benchmark [5].
Reference: [4] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 138-164, </pages> <year> 1988. </year> <note> Also in Readings in Object-Oriented Database Systems, </note> <editor> S. Zdonik and D. Maier, eds., </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: The keyword yields is used instead of returns in the case of an iterator. Type hierarchy Theta allows subtyping. In Theta, a subtype S must have all the methods of its supertype T with compatible signatures <ref> [16, 2, 4] </ref>, plus perhaps some additional methods.
Reference: [5] <author> Michael J. Carey, David J. DeWitt, and Jeffrey F. Naughton. </author> <title> The OO7 benchmark. </title> <booktitle> In Proceedings of the 1993 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 12-21, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Futures are remapped only when the future index reaches a threshold value because it is a little more efficient to remap a large number of futures at once. 3.3 Discussion Bogle's result showed that on a real benchmark, such as OO7 <ref> [5] </ref>, the average batch size (batching factor) is about 2.33, which is rather low. Consequently, the speedup achieved by using batched futures was only about 1.7. <p> a future, the corresponding value is looked up in the future table F, and used as the argument to the actual call. 4.4 Experimental Results In [3], Bogle uses his performance model to describe the expected impact of promises on the performance of the 2b traversal of the OO7 benchmark <ref> [5] </ref>.
Reference: [6] <author> M. Castro. </author> <title> Object invocation performance in thor. Programming Methodology Group Memo to appear, </title> <institution> Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA, </address> <year> 1995. </year>
Reference-contexts: Rewriting the code as suggested by Bogle yielded exactly the predicted batching factor of 3.47. However, since Bogle's measurements, the Thor invocation mechanism has been optimized, yielding about a factor of 2 improvement in performance <ref> [6] </ref>. The domain crossing overhead, t d has been substantially decreased, thus reducing the total benefit achieved from increased batching. versus the running time of the same traversal modified to use promises as well. The running time for the batched futures version was 13.95 seconds.
Reference: [7] <author> Mark Day. </author> <title> Client Cache Management in a Distributed Object Database. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1995. </year> <month> Forthcoming. </month>
Reference-contexts: The client communicates with the Frontend using a language specific veneer. Veneers are described in section 2.4. 2.3 The Frontend Each Frontend is dedicated to a single client application. Objects accessed by the client are fetched from the OR and cached at the Frontend <ref> [7] </ref>. The interface presented to the client by the Frontend includes the following commands: * lookup wellknown This command takes a string as its only arguments.
Reference: [8] <author> Mark Day et al. </author> <title> Theta Reference Manual. Programming Methodology Group Laboratory for Computer Science, </title> <publisher> MIT, </publisher> <address> Cambridge, MA, </address> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: An exception indicates that the normal return values could not be computed. 13 Types The operations that can be performed on an object are determined by its type. Thor types are specified and implemented in Theta <ref> [8] </ref>, a new object-oriented programming language being developed specifically for Thor. A type consists of a set of method signatures. <p> Chapter 8 describes a mechanism for terminating a batched while or for loop using an analog of the break statement in C. 5.2.5 Assignment Both the syntax and semantics of BCS are designed to mimic the corresponding language constructs in Theta <ref> [8] </ref>. However, unlike Theta, the BCS language is not a compiled language in its own right, but instead is implemented as a bunch of procedures that can be called by the client to annotate the batch (Chapter 6). This places certain limitations on how the BCS mechanism can be used.
Reference: [9] <author> J. Goodenough. </author> <title> Exception handling: Issues and a proposed notation. </title> <journal> Communications of the ACM, </journal> <volume> 18 </volume> <pages> 683-696, </pages> <month> December </month> <year> 1975. </year>
Reference: [10] <author> B. Helfinstine. </author> <title> A Modula-3 veneer for Thor, </title> <year> 1994. </year>
Reference-contexts: This is accomplished by providing a veneer [3] for each programming language. The veneer extends the language with the necessary procedures to interact with Thor. Several veneers have been implemented for Thor, including C, C++, Emacs Lisp, Perl, TCL [3] and Modula3 <ref> [10] </ref>. In the remainder of this thesis we will limit our discussion to the C++ veneer, but the concepts explained here are not limited to the C++ veneer. The veneer provides the client with an interface to Thor. The interface is implemented by a library of procedures.
Reference: [11] <author> B. Liskov et al. </author> <title> CLU reference manual. </title> <editor> In Goos and Hartmanis, editors, </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 114. </volume> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: The latter kind of loop makes use of a server iterator. An iterator is a special kind of routine that produces multiple results; it yields the results one-at-a-time and is used in a for loop that does an iteration for each yielded value <ref> [11] </ref>. <p> A method is invoked on an object of its type. A routine is a stand-alone procedure, not associated with any type. Iterators In addition to procedures, Thor supports iterators, introduced in the CLU programming language <ref> [11] </ref>. Rather than returning a single value, an iterator yields a new value each time it is called. Iterators are called from within a special for construct. Both routines and methods can be iterators. Object references A reference to a Thor object is called a handle. <p> This work is similar to Remote Evaluation (REV) [17] in that it allows a client program to send small "sub-programs" to be evaluated at the server. However, in Stamos' work, both client and server were written in the same programming language, CLU <ref> [11] </ref>. One of the goals of Thor is to allow clients written in different programming languages to share the same objects. In REV, the operations invoked by the client must either be exported by the server or provided by the shipped code itself.
Reference: [12] <author> B. Liskov, R. Gruber, P. Johnson, and L. Shrira. </author> <title> A highly available object repository for use in a heterogeneous distributed system. </title> <booktitle> In Proceedings of the Fourth International Workshop on Persistent Object Systems Design, Implementation and Use, </booktitle> <pages> pages 255-266, </pages> <address> Martha's Vineyard, MA, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: Chapter 6: Describes the implementation of Batched Control Structures. * Chapter 7: Presents performance results for Batched Control Structures * Chapter 8: Describes some possible extensions to the work presented in this thesis, and gives some conclusions. 12 Chapter 2 Thor Client Interface The context for this work is Thor <ref> [12] </ref>, a new object-oriented database system that provides persistent and highly available storage for its objects. The first half of this chapter describes some of the relevant features of Thor and the basic system architecture.
Reference: [13] <author> B. Liskov and L. Shrira. </author> <title> Promises: Linguistic support for efficient asynchronous procedure calls in distributed systems. </title> <booktitle> In Proceedings of the ACM SIGPLAN '88 Conference on Programming Languages Design and Implementation. ACM, </booktitle> <month> June </month> <year> 1988. </year> <month> 63 </month>
Reference-contexts: Like regular references, it can be a future for the result of a call. In addition, a promise can be initialized to refer to a particular value. To get the actual value the promise refers to, the promise is claimed. Promises were first described in Mercury call streams <ref> [13] </ref>. However, a Mercury promise must be claimed before it can be used as an argument to a subsequent call. A Thor promise does not have to be claimed before it is used as an argument.
Reference: [14] <author> Andrew C. Myers. </author> <title> Fast object operations in a persistant programming system. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: This is done by computing an integer offset that depends on the relationship in the type hierarchy between the object's actual type and the type expected by the method. A complete description of offsets and their use can be found in <ref> [14] </ref>. For each call sent by the client, the offset has to be computed for all the arguments before the method is called. In the common case the actual type and the expected type are identical, and computing the offset is trivial.
Reference: [15] <author> T. Anderson R. Wahbe, S. Lucco and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> Proc. Fourteenth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 203-216, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: (p->X ()); p-&gt;Set_x (p->Y ()); p-&gt;Set_y (temp->Get ()); END_PROCEDURE To call the batched procedure, the client calls the invoke procedure function provided by the veneer: th_point p = ...; invoke_procedure (``swap'', p); 8.3 Comparrison with Sandboxing An alternative to providing safety without running in separate protection domains is presented in <ref> [15] </ref>. This mechanism, software-based fault isolation, popularly called "sandbox-ing," inserts software bounds into unsafe client code to guarantee that the client does not 61 access memory outside its designated area. It reduces the per call overhead by eliminating the need for a domain crossing on each call.
Reference: [16] <author> C. Schaffert et al. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In Proceedings of the ACM Conference on Object Oriented Systems, Languages and Applications, </booktitle> <address> Portland, OR, </address> <month> Septem-ber </month> <year> 1986. </year>
Reference-contexts: The keyword yields is used instead of returns in the case of an iterator. Type hierarchy Theta allows subtyping. In Theta, a subtype S must have all the methods of its supertype T with compatible signatures <ref> [16, 2, 4] </ref>, plus perhaps some additional methods.
Reference: [17] <author> J.W. Stamos and D.K. Gifford. </author> <title> Remote evaluation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 537-565, </pages> <month> October </month> <year> 1990. </year> <month> 64 </month>
Reference-contexts: BCS was used to illustrate not only the possible increase in the batching factor, but also the reduced overhead associated with each call to Thor when using BCS. This work is similar to Remote Evaluation (REV) <ref> [17] </ref> in that it allows a client program to send small "sub-programs" to be evaluated at the server. However, in Stamos' work, both client and server were written in the same programming language, CLU [11].
References-found: 17

