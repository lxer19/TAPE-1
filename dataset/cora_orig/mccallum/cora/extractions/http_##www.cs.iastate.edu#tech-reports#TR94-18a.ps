URL: http://www.cs.iastate.edu/tech-reports/TR94-18a.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: The Behavior-Realization Adjunction and Generalized Homomorphic Relations  
Author: Gary T. Leavens and Don Pigozzi Gary T. Leavens and Don Pigozzi, 
Keyword: behavior, realization, observable equivalence, simulation, generalized relation, abstract data type, model theory. 1994 CR Categories: D.3.3 [Programming Languages] Language Constructs Abstract data types; F.3.2 [Logics and Meanings of Programs] Semantics of Programming Languages algebraic approaches to semantics; F.3.2 [Mathematical Logic and Formal Languages] Mathematical Logic model theory.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa Sate University  M S-T E X  
Note: TR #94-18 September 1994  Submitted for publication. c  1994. All rights reserved.  Typeset by A  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> P. </author> <title> America, Designing an Object-Oriented Programming Language with Behavioural Subtyp-ing, </title> <booktitle> Foundations of Object-Oriented Languages, </booktitle> <address> REX School/Workshop, Noordwijkerhout, The Netherlands, </address> <note> May/June 1990 (J. </note> <editor> W. de Bakker and W. P. de Roever and G. Rozen-berg, eds.), </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 489, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991, </year> <pages> pp. 60-90. </pages>
Reference-contexts: These ideas are vague, but we do not have the space to pursue them further here. Future work. The main future work we plan is to use our results to study behavioral subtyping <ref> [1] </ref> [9]. In earlier work [11] we gave a sufficient algebraic condition for legal behavioral subtyping by using standard homomorphic relations.
Reference: 2. <author> Garrett Birkhoff, </author> <title> Lattice theory, Third Edition, </title> <journal> American Mathematical Societ Colloquium Publications, </journal> <volume> vol. 25, </volume> <publisher> American Mathematical Society, </publisher> <address> New York, </address> <year> 1967. </year>
Reference-contexts: It follows directly from Lems. 3.5 (i),(iv) and 3.7 (ii),(iii) that BE and RE @ form a Galois connection when viewed as mappings between the poset of standard relations and the dual poset of generalized relations (see e.g. Birkhoff <ref> [2] </ref>, p.124). The operators RE and BE @ also form a Galois connection. Like all posets, the standard and generalized relations between A and B can be viewed as simple categories, i.e., categories in which there is at most one arrow between any pair of objects.
Reference: 3. <author> V. Giarratana and F. Gimona and U. Montanari, </author> <title> Observability Concepts in Abstract Data Type Specifications, </title> <booktitle> Mathematical Foundations of Computer Science 1976, Proceedings 5th Symposium, </booktitle> <editor> Gdansk (A. Mazurkiewicz, ed.), </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 45, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1976, </year> <pages> pp. 576-587. </pages>
Reference-contexts: The most interesting technical details, however, involve how to compare an implementation algebra to a paradigm, once a paradigm is selected from the collection available. Several authors have studied such notions previously (including <ref> [3] </ref> [6] [15] [16] | see Section 8 of [19] for a survey). For our purposes the most important technique is that of Schoett [16].
Reference: 4. <author> Joseph A. Goguen, </author> <title> Realization is Universal, Math. </title> <booktitle> Systems Theory 6 (1973), </booktitle> <pages> 359-374. </pages>
Reference-contexts: We note that hierarchy conditions, as in the Set example above, are important for faithful investigations of implementation notions for programming, where the objects of the programming language's built-in types, and their behavior, are fixed by the language. (Goguen and Meseguer call these "modules" [5] or "machines" <ref> [4] </ref>.) As in a programming language, only the basic ADT is visible to the programmer; that is, only data from the basic ADT can be used as input-output for programs. <p> Formally we think of standard relations as the "behavior" of generalized relations and generalized relations as the "realization" of standard ones <ref> [4] </ref>. To explain, suppose A and B are models of our specification, a is an element of A and b and element of B of the same type. <p> In this section we discuss the more distantly related, but inspirational, work of Goguen and Meseguer. Our decision to formulate our results as a behavior-realization adjunction was influenced by Goguen's <ref> [4] </ref> categorical theory of automata [4] and its subsequent extension to general modules by Goguen and Meseguer [5, 6]. But the relationship between our theory of behavior, realization, and the associated adjunction and the corresponding theory of Goguen and Meseguer is complicated. <p> In this section we discuss the more distantly related, but inspirational, work of Goguen and Meseguer. Our decision to formulate our results as a behavior-realization adjunction was influenced by Goguen's <ref> [4] </ref> categorical theory of automata [4] and its subsequent extension to general modules by Goguen and Meseguer [5, 6]. But the relationship between our theory of behavior, realization, and the associated adjunction and the corresponding theory of Goguen and Meseguer is complicated. <p> That is, only (5.1) has as its input and output visible data; technically, it is a H-procedure where H is a visible type context. According to <ref> [4] </ref> the behavior of A is the mapping E (A) : A fl Input ! A Output defined by E (A)(a 1 a n ) = Return A (S A 0 fl A a 1 fl A fl A a n ): Input , let H = fx 1 :Input; : <p> Moreover, if we extend E to a mapping of morphisms by setting E (f ) = hf Input ; f Output i, then E is a (forgetful) functor from Mach to Beh. Goguen <ref> [4] </ref> restricts his attention mainly to the subcategories M and B, of Mach and Beh respectively, all of whose morphisms have surjective input components. According to Goguen, an automaton A realizes a behavior f if E (A) = f .
Reference: 5. <author> Joseph Goguen and Jose Meseguer, </author> <title> Universal Realization, Persistent Interconnection and Implementation of Abstract Modules, </title> <booktitle> Proceedings, 9th International Conference on Automata, Languages and Programming (M. </booktitle> <editor> Nielsen and E.M. Schmidt, eds.), </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 140, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1982, </year> <pages> pp. 265-281. </pages>
Reference-contexts: The initial [7] and final [18] algebra approaches, are ways to choose a paradigm that is a unique (up to isomorphism). However, the application of such an approach to incomplete specifications that are hierarchical over some primitive types is misguided and does not work <ref> [5] </ref> [20]. As an example, imagine an ADT Set with an operation choose. <p> We note that hierarchy conditions, as in the Set example above, are important for faithful investigations of implementation notions for programming, where the objects of the programming language's built-in types, and their behavior, are fixed by the language. (Goguen and Meseguer call these "modules" <ref> [5] </ref> or "machines" [4].) As in a programming language, only the basic ADT is visible to the programmer; that is, only data from the basic ADT can be used as input-output for programs. <p> In this section we discuss the more distantly related, but inspirational, work of Goguen and Meseguer. Our decision to formulate our results as a behavior-realization adjunction was influenced by Goguen's [4] categorical theory of automata [4] and its subsequent extension to general modules by Goguen and Meseguer <ref> [5, 6] </ref>. But the relationship between our theory of behavior, realization, and the associated adjunction and the corresponding theory of Goguen and Meseguer is complicated.
Reference: 6. <author> Joseph Goguen and Jose Meseguer, Initiality, </author> <title> Induction and Computability, Algebraic Methods in Semantics (Maurice Nivat and John Reynolds, </title> <editor> eds.), </editor> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1985, </year> <pages> pp. 459-541. </pages>
Reference-contexts: The most interesting technical details, however, involve how to compare an implementation algebra to a paradigm, once a paradigm is selected from the collection available. Several authors have studied such notions previously (including [3] <ref> [6] </ref> [15] [16] | see Section 8 of [19] for a survey). For our purposes the most important technique is that of Schoett [16]. <p> In this section we discuss the more distantly related, but inspirational, work of Goguen and Meseguer. Our decision to formulate our results as a behavior-realization adjunction was influenced by Goguen's [4] categorical theory of automata [4] and its subsequent extension to general modules by Goguen and Meseguer <ref> [5, 6] </ref>. But the relationship between our theory of behavior, realization, and the associated adjunction and the corresponding theory of Goguen and Meseguer is complicated.
Reference: 7. <author> J. A. Goguen and J. W. Thatcher and E. G. Wagner, </author> <title> An Initial Algebra Approach to the Specification, Correctness and Implementation of Abstract Data Types, Current Trends in Programming Methodology (Raymond T. Yeh, </title> <editor> ed.), </editor> <volume> vol. 4, </volume> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1978, </year> <pages> pp. 80-149. </pages> <address> BEHAVIOR-REALIZATION ADJUNCTION 41 </address>
Reference-contexts: especially interested in specifications that are incomplete and not term-generated. (For us, a complete specification is one for which all its models are behaviorally equivalent.) We shall also assume that a candidate implementation has already been adapted to the interface (signature) required ("derived" in the sense of Section 5.5 of <ref> [7] </ref>). What is known about the soundness and completeness of techniques for proving that a candidate implementation of an ADT is correct? We shall restrict ourselves Leavens's work is supported in part by National Science Foundation Grant CCR-9108654. <p> These paradigms collectively span the permitted behaviors, and one must choose a paradigm and then make a comparison with the candidate implementation. We first motivate the need for a collection of paradigms, and then discuss techniques for making the comparison. The initial <ref> [7] </ref> and final [18] algebra approaches, are ways to choose a paradigm that is a unique (up to isomorphism). However, the application of such an approach to incomplete specifications that are hierarchical over some primitive types is misguided and does not work [5] [20].
Reference: 8. <author> J. Guttag and J. J. Horning, </author> <title> The Algebraic Specification of Abstract Data Types, </title> <journal> Acta Infor-matica 10 (1978), </journal> <volume> no. 1, </volume> <pages> 27-52. </pages>
Reference-contexts: SPEC is sufficiently complete if is is term-generated and, for every well-typed ground - term t of visible type, there exists a ground VIS -term s of the same type such that t A = s Aj VIS for every A 2 SPEC <ref> [8] </ref>. 2 Relations Between Algebras The simulation of one -algebra by another is formalized as a binary relation between the carriers of the two algebras with certain special properties. We consider two kinds of relations between algebras that give rise to two kinds of simulation.
Reference: 9. <author> Gary T. Leavens, </author> <title> Modular Specification and Verification of Object-Oriented Programs, </title> <journal> IEEE Software 8 (July, 1991), </journal> <volume> no. 4, </volume> <pages> 72-80. </pages>
Reference-contexts: These ideas are vague, but we do not have the space to pursue them further here. Future work. The main future work we plan is to use our results to study behavioral subtyping [1] <ref> [9] </ref>. In earlier work [11] we gave a sufficient algebraic condition for legal behavioral subtyping by using standard homomorphic relations.
Reference: 10. <author> Gary T. Leavens and Krishna Kishore Dhara, </author> <title> Blended Algebraic and Denotational Semantics for ADT Languages with Mutable Objects, </title> <institution> Department of Computer Science, Iowa State University, </institution> <note> TR #93-21b. Available by anonymous ftp from ftp.cs.iastate.edu and by e-mail from alamanc@cs.iastate.edu (1994). </note>
Reference-contexts: We also plan to make such an extension to higher-order terms in the presence of nondeterminism and subtyping, as was done in [11]. Another extension planned is to adapt our results to the study of ADTs with mutable objects (i.e., objects with time-varying state). In <ref> [10] </ref>, we describe algebraic models of ADTs with mutable objects, and give relations between states over such models that are preserved by simple programs. A state over such a model consists 40 GARY T.
Reference: 11. <author> Gary T. Leavens and Don Pigozzi, </author> <title> Typed Homomorphic Relations Extended with Subtypes, Mathematical Foundations of Programming Semantics '91 (S. </title> <editor> Brookes, ed.), </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 598, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1992, </year> <pages> pp. 144-167. </pages>
Reference-contexts: This problem is the original motivation for our study of "programs" with nonvisible inputs. Our previous work on subtyping <ref> [11] </ref> did handle behaviorally incomplete specifications and the comparison of nonvisible data. As mentioned above, our approach is to take a loose semantics for such specifications, and to use just not one, but many paradigmatic models. <p> See also <ref> [11] </ref>. 16 GARY T. LEAVENS AND DON PIGOZZI (ii) Let T 2 TYPE and a 2 A T . <p> These ideas are vague, but we do not have the space to pursue them further here. Future work. The main future work we plan is to use our results to study behavioral subtyping [1] [9]. In earlier work <ref> [11] </ref> we gave a sufficient algebraic condition for legal behavioral subtyping by using standard homomorphic relations. <p> It should be relatively straightforward to extend the results in this paper to higher-order terms, using logical relations. We also plan to make such an extension to higher-order terms in the presence of nondeterminism and subtyping, as was done in <ref> [11] </ref>. Another extension planned is to adapt our results to the study of ADTs with mutable objects (i.e., objects with time-varying state). In [10], we describe algebraic models of ADTs with mutable objects, and give relations between states over such models that are preserved by simple programs.
Reference: 12. <author> Saunders Mac Lane, </author> <title> Categories for the Working Mathematician, Graduate Texts in Mathematics, </title> <journal> vol. </journal> <volume> 5, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1971. </year>
Reference-contexts: (ii), BE (G) BE RE @ (R ) R. (ii) is proved similarly using Lem. 3.7 (i) and (iv). fl In category-theoretic terms Thm. 3.9 (i) says that BE is a left adjoint of RE @ and RE @ is a right adjoint of BE. (See for instance Mac Lane <ref> [12] </ref>.) In the sequel we focus on the adjunction of Thm. 3.9 (i), which will be used repeatedly; it is referred to simply as the basic adjunction. 5 The basic adjunction can be paraphrased in the following way.
Reference: 13. <author> Tobias Nipkow, </author> <title> Non-deterministic Data Types: Models and Implementations, </title> <journal> Acta Informat-ica 22 (March, 1986), </journal> <volume> no. 6, </volume> <pages> 629-661. </pages>
Reference-contexts: A we mean the TYPE-indexed subset BE () := hBE () T : T 2 TYPEi of A, where BE () T := f a 2 A T : a = [[ t : T ]] A , where t : T is an H-procedure g. 4 For example Nipkow <ref> [13] </ref> considers a much more expressive class of programs in his investigations of the behavior of nondeterministic ADTs, whose procedures return sets of possible results. See also [11]. 16 GARY T. LEAVENS AND DON PIGOZZI (ii) Let T 2 TYPE and a 2 A T .
Reference: 14. <author> John C. Reynolds, </author> <title> Using Category Theory to Design Implicit Conversions and Generic Operators, Semantics-Directed Compiler Generation, </title> <booktitle> Proceedings of a Workshop, Aarhus, </booktitle> <editor> Denmark (N. D. Jones, ed.), </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 94, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1980, </year> <pages> pp. 211-258. </pages>
Reference-contexts: We also introduce the necessary notation and terminology. The syntactic interface of a collection of abstract data types is formally described by a signature. These signatures allow for the overloading of operations <ref> [14] </ref>. Let N = f 0; 1; 2; : : :g be the set of natural numbers. Definition 1.1 (signature).
Reference: 15. <author> Donald Sannella and Andrzej Tarlecki, </author> <title> On Observational Equivalence and Algebraic Specification, </title> <journal> Journal of Computer and System Sciences 34 (April/June, 1987), </journal> <volume> no. 2/3, </volume> <pages> 150-178. </pages>
Reference-contexts: The most interesting technical details, however, involve how to compare an implementation algebra to a paradigm, once a paradigm is selected from the collection available. Several authors have studied such notions previously (including [3] [6] <ref> [15] </ref> [16] | see Section 8 of [19] for a survey). For our purposes the most important technique is that of Schoett [16].
Reference: 16. <author> Oliver Schoett, </author> <title> Behavioural Correctness of Data Representations, </title> <booktitle> Science of Computer Programming 14 (June, 1990), </booktitle> <volume> no. 1, </volume> <pages> 43-57. </pages>
Reference-contexts: The most interesting technical details, however, involve how to compare an implementation algebra to a paradigm, once a paradigm is selected from the collection available. Several authors have studied such notions previously (including [3] [6] [15] <ref> [16] </ref> | see Section 8 of [19] for a survey). For our purposes the most important technique is that of Schoett [16]. <p> Several authors have studied such notions previously (including [3] [6] [15] <ref> [16] </ref> | see Section 8 of [19] for a survey). For our purposes the most important technique is that of Schoett [16]. Schoett casts the problem as one of showing that a partial algebra A can be used in place of the paradigm, a partial algebra B, without exhibiting surprising behavior. <p> We showed that this technique was sound: it guarantees that there can be no surprising behavior. By considering the case where there is no subtyping, our results can be seen as an adaptation of Schoett's <ref> [16] </ref> to handle incomplete specifications, and they give a sound technique for reasoning about the implementation of incompletely specified ADTs. However, we did not know whether the technique was complete, i.e., if the absence of surprising behavior guarantees the ability to prove that an implementation of an ADT is correct. <p> Now applying first the equivalence (3.2) and then the basic adjunction we get BE (G) j VIS = I iff BE (G) I fl iff G RE @ (I fl ): (ii) follows similarly from the local version of the basic adjunction. fl According to Schoett <ref> [16] </ref>, members A and B of SPEC are behaviorally equivalent if every visible environment is VIS-behaviorally equivalent to itself when viewed as an environment of A and then of B; that is, iff for every visible type context H (i.e., H ` x : T only if T 2 VIS) the <p> The equivalence of the two conditions in part (i) is Cor. 3.15. We note that the condition (ii) of Def. 3.16 is essentially identical to Schoett's weaker notion of behavioral equivalence. We formalize it separately: Definition 3.17 (weak VIS-behavioral equivalence <ref> [16] </ref>). Let A; B 2 SPEC. A and B are weakly VIS-behaviorally equivalent iff the behavior of I + is VIS-identical, i.e., BE (I + )j VIS = I. Weak VIS-behavioral equivalence refers only to the behavior of visible environments. Proposition 3.18. Let A; B 2 SPEC. <p> Our intention is to characterize these notions algebraically, with the expectation that this will lead to useful abstract reasoning techniques about the implementation of ADTs. Schoett <ref> [16] </ref> obtains such an algebraic characterization for the visible part of the dual realization relation RE @ (I fl ) in terms of the notion of a homomorphic relation (Def. 2.4), and hence, by extension, a characterization of weak VIS-behavior equivalence in terms of weak bisimulation. <p> We now have the machinery in place to prove Schoett's algebraic characterization of weak VIS-behavioral equivalence (Def. 3.17). Recall the definition of weak bisimulation (Def. 2.12). Theorem 4.9 (Schoett <ref> [16] </ref>). Let A; B 2 SPEC. Then A and B are weakly VIS-behaviorally equivalent iff there exists a weak bisumulation between A and B. Proof. Assume A and B are weakly VIS-behaviorally equivalent, i.e., assume that BE (I + ) j VIS = I. <p> Discussion In this section we discuss related work, future work, and offer some conclusions. Related work. In the main body of the paper we discuss the relation of our work to the work on Schoett <ref> [16] </ref>. In this section we discuss the more distantly related, but inspirational, work of Goguen and Meseguer. Our decision to formulate our results as a behavior-realization adjunction was influenced by Goguen's [4] categorical theory of automata [4] and its subsequent extension to general modules by Goguen and Meseguer [5, 6].
Reference: 17. <author> Philip Wadler and Stephen Blott, </author> <title> How to make ad-hoc Polymorphism less ad hoc, </title> <booktitle> Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin, Texas, </address> <publisher> ACM, </publisher> <address> New York, </address> <year> 1989, </year> <pages> pp. 60-76. </pages>
Reference-contexts: Existing objects of one of these subtypes can be treated as if they were collections. This is analogous to the way that objects having the type of a formal type parameter are be treated in parameterized code <ref> [17] </ref>. It is also apparent from this example why it is important to be able to compare nonvisible data.
Reference: 18. <author> Mitchell Wand, </author> <title> Final Algebra Semantics and Data Type Extensions, </title> <journal> Journal of Computer and System Sciences 19 (1979), </journal> <volume> no. 1, </volume> <pages> 27-44. </pages>
Reference-contexts: These paradigms collectively span the permitted behaviors, and one must choose a paradigm and then make a comparison with the candidate implementation. We first motivate the need for a collection of paradigms, and then discuss techniques for making the comparison. The initial [7] and final <ref> [18] </ref> algebra approaches, are ways to choose a paradigm that is a unique (up to isomorphism). However, the application of such an approach to incomplete specifications that are hierarchical over some primitive types is misguided and does not work [5] [20].
Reference: 19. <author> Martin Wirsing, </author> <title> Algebraic Specification, </title> <booktitle> Handbook of Theoretical Computer Science (J. </booktitle> <editor> van Leewen, ed.), </editor> <volume> vol. </volume> <editor> B: </editor> <title> Formal Models and Semantics, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990, </year> <pages> pp. 675-788. </pages>
Reference-contexts: The most interesting technical details, however, involve how to compare an implementation algebra to a paradigm, once a paradigm is selected from the collection available. Several authors have studied such notions previously (including [3] [6] [15] [16] | see Section 8 of <ref> [19] </ref> for a survey). For our purposes the most important technique is that of Schoett [16]. Schoett casts the problem as one of showing that a partial algebra A can be used in place of the paradigm, a partial algebra B, without exhibiting surprising behavior.
Reference: 20. <author> Martin Wirsing and Peter Pepper and Helmut Partsch and Walter Dosch and Manfred Broy, </author> <title> On Hierarchies of Abstract Data Types, </title> <journal> Acta Informatica 20 (1983), </journal> <volume> no. 1, </volume> <pages> 1-33. </pages> <institution> Department of Computer Science, Iowa State University, Ames, Iowa 50011-1040 USA E-mail address: leavens@cs.iastate.edu Department of Mathematics, Iowa State University, Ames, Iowa 50011 USA E-mail address: dpigozzi@iastate.edu </institution>
Reference-contexts: The initial [7] and final [18] algebra approaches, are ways to choose a paradigm that is a unique (up to isomorphism). However, the application of such an approach to incomplete specifications that are hierarchical over some primitive types is misguided and does not work [5] <ref> [20] </ref>. As an example, imagine an ADT Set with an operation choose. <p> choose states merely that the result is a member of the set, if as usual we require operations to be functions, and if we further require models to be hierarchical over the element type, then there will be many observably distinct models of Set, and no initial or final models <ref> [20] </ref>. This is why we allow for a collection of paradigms, instead of insisting on a single paradigm.
References-found: 20

