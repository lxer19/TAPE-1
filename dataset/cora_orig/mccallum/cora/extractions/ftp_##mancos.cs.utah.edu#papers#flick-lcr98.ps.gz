URL: ftp://mancos.cs.utah.edu/papers/flick-lcr98.ps.gz
Refering-URL: ftp://mancos.cs.utah.edu/papers/flick-lcr98-abs.html
Root-URL: 
Email: flick@cs.utah.edu  
Title: Flexible and Optimized IDL Compilation for Distributed Applications (Extended Abstract) compiler, and are using it
Author: Eric Eide Jay Lepreau 
Date: May 2830, 1998.  
Note: IDL  To appear in the Fourth Workshop on Languages, Compilers, and  '98),  
Web: http://www.cs.utah.edu/projects/flux/flick/  
Address: 3190 MEB, Salt Lake City, Utah 84112  Pittsburgh, PA,  
Affiliation: University of Utah Department of Computer Science  
Abstract: The author of a distributed system is often faced with a dilemma when writing the system's communication code. If the code is written by hand (e.g., using Active Messages) or partly by hand (e.g., using MPI) then the speed of the application may be maximized, but the human effort required to implement and maintain the system is greatly increased. On the other hand, if the code is generated using a high-level tool (e.g., a CORBA IDL compiler) then programmer effort will be reduced, but the performance of the application may be intolerably poor. The tradeoff between system performance and development effort arises because existing communication middleware is inefficient, imposes excessive presentation layer overhead, and therefore fails to make much of the underlying network performance available to application code. Moreover, there is often a mismatch between the desired communication style of the application (e.g., asynchronous message passing) and the communication style of the code produced by an IDL compiler (synchronous remote procedure call). We believe that this need not be the case, but that established optimizing compiler technology can be applied and extended to attack these domain-specific problems. We have shown this to be the case for classical client/server applications and believe it also to be true for applications with more varied communication patterns. We have implemented Flick, a flexible and optimizing This research was supported in part by the Defense Advanced Re- search Projects Agency, monitored by the Department of the Army under contract number DABT6394C0058, and Rome Laboratory, Air Force Materiel Command, USAF, under agreement number F306029620269. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright annotation hereon. applications. Flick produces optimized code for marshaling and unmarshaling data; experiments show that Flick- generated stubs can marshal data between 2 and 17 times as fast as stubs produced by other IDL compilers. Further, because Flick is implemented as a kit of components, it is possible to extend the compiler to produce stylized code for many different application interfaces and underlying transport layers. For example, in this paper we outline a novel approach for producing stubs for a global memory service. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> ACCETTA, M., BARON, R., BOLOSKY, W., GOLUB, D., RASHID, R., TEVANIAN, A., AND YOUNG, M. </author> <title> Mach: A new kernel foundation for UNIX develop-ment. </title> <booktitle> In Proc. of the Summer 1986 USENIX Conf. </booktitle> <month> (June </month> <year> 1986), </year> <pages> pp. 93112. </pages>
Reference-contexts: 1 Introduction Modern computer networks are becoming increasingly fast, and modern operating systems are now supporting efficient, lightweight communication mechanisms such as shared memory-based intra-node communication channels <ref> [1] </ref>, highly optimized kernel IPC paths [11, 21], and new inter-node communication models such as active messages [29] and sender-based protocols [5, 28]. <p> Sun RPC) [26], and MIG [24] IDLs. Flick compiles an interface specification in any of these languages through a series of intermediate representations to produce optimized CORBA-, rpcgen- [27], or MIG- style C stubs communicating via TCP, Mach <ref> [1] </ref> messages, Trapeze [2] messages, or Fluke [14] kernel IPC.
Reference: [2] <author> ANDERSON, D., CHASE, J., GADDE, S., GALLATIN, A., YOCUM, K., AND FEELEY, M. </author> <title> Cheating the I/O bottleneck: Network storage with Trapeze/Myrinet. </title> <booktitle> In Proc. of the USENIX 1998 Technical Conf. </booktitle> <address> (New Orleans, LA, </address> <month> July </month> <year> 1998). </year>
Reference-contexts: Sun RPC) [26], and MIG [24] IDLs. Flick compiles an interface specification in any of these languages through a series of intermediate representations to produce optimized CORBA-, rpcgen- [27], or MIG- style C stubs communicating via TCP, Mach [1] messages, Trapeze <ref> [2] </ref> messages, or Fluke [14] kernel IPC. Section 2 summarizes the structure of Flick, and Section 3 describes how Flick is being extended to create specialized communication stubs for one distributed application: Khazana [6], a global memory service. 2 as three separate compiler passes which communicate through intermediate files.
Reference: [3] <author> AUERBACH, J. S., AND RUSSELL, J. R. </author> <title> The Concert signature representation: IDL as an intermediate language. </title> <booktitle> In Proc. of the Workshop on Interface Definition Languages (Jan. </booktitle> <year> 1994), </year> <pages> pp. 112. </pages>
Reference-contexts: These are discussed in our earlier paper on Flick [10]. In summary, these other IDL compilers are either not very functional and not flexible (Mach's MIG compiler), or they generate very slow code (e.g., ILU [20]). Like Flick, the Concert/C distributed programming system <ref> [3] </ref> quite fully develops the concept of flexible presentation. In Concert, the primary purpose of this separation is to handle the vagaries of RPC mapping to different target languages, striving for a minimal contract in order to achieve maximal interoperability between target languages.
Reference: [4] <author> BIRRELL, A. D., AND NELSON, B. J. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems 2, </journal> <month> 1 (Feb. </month> <year> 1984). </year>
Reference-contexts: IDL compiler will generate the following stub prototypes for the read and write operations: 1 FS_content *FS_read (FS obj, CORBA_char *filename); void FS_write (FS obj, CORBA_char *filename, FS_content *data); The IDL compiler will also output implementations of the FS read and FS write stubs that implement remote procedure call (RPC) <ref> [4] </ref> or remote method invocation (RMI) semantics: the client that invokes FS read or FS write will block until the server replies to the client's request. From the client's point of view, the FS read and FS write functions behave like normal, local procedure calls.
Reference: [5] <author> BUZZARD, G., JACOBSON, D., MACKEY, M., MAROVICH, S., AND WILKES, J. </author> <title> An implementation of the Hamlyn sender-managed interface architecture. </title> <booktitle> In Proc. of the Second Symp. on Operating Systems Design and Implementation (Seattle, </booktitle> <address> WA, Oct. 1996), </address> <publisher> USENIX Assoc., </publisher> <pages> pp. 245259. </pages>
Reference-contexts: 1 Introduction Modern computer networks are becoming increasingly fast, and modern operating systems are now supporting efficient, lightweight communication mechanisms such as shared memory-based intra-node communication channels [1], highly optimized kernel IPC paths [11, 21], and new inter-node communication models such as active messages [29] and sender-based protocols <ref> [5, 28] </ref>. As Clark and Tennenhouse predicted in 1990 [8], these improvements in low-level communication systems have moved the performance bottlenecks for distributed applications out of the network and operating system layers and into the applications themselves [18, 19].
Reference: [6] <author> CARTER, J., RANGANATHAN, A., AND SUSARLA, S. Khazana: </author> <title> An infrastructure for building distributed ser-vices. </title> <booktitle> In Proc. of the Eighteenth International Conf. on Distributed Computing Systems (May 1998). </booktitle>
Reference-contexts: Section 2 summarizes the structure of Flick, and Section 3 describes how Flick is being extended to create specialized communication stubs for one distributed application: Khazana <ref> [6] </ref>, a global memory service. 2 as three separate compiler passes which communicate through intermediate files. <p> This section presents one such application and describes a novel presentation style for CORBA IDL that we are implementing within Flick, thus allowing Flick to accommodate the application in a way that traditional IDL compilers cannot. The application is Khazana <ref> [6] </ref>, a global memory service being developed by Carter et al. at the University of Utah. Khazana is a middleware layer for distributed applications that provides the abstraction of a distributed, persistent, globally shared store in which applications may save state.
Reference: [7] <author> CHANDY, K. M., AND KESSELMAN, C. </author> <title> CC++: A declarative concurrent object oriented programming notation. </title> <type> Tech. Rep. </type> <institution> CS-TR-92-01, California Institute of Technology, </institution> <month> Mar. </month> <year> 1993. </year>
Reference-contexts: This level of control is also required in order to provide a migration path for existing applications already written to other communication models such as MPI [22]. For parallel applications, there are a large number of specialized programming languages such as CC++ <ref> [7] </ref>, Fortran M [15], and Split-C [9]. In most of these cases the language handles marshaling and unmarshaling of parameters.
Reference: [8] <author> CLARK, D. D., AND TENNENHOUSE, D. L. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> 5 In Proc. of the SIGCOMM '90 Symp. </booktitle> <year> (1990), </year> <pages> pp. 200 208. </pages>
Reference-contexts: As Clark and Tennenhouse predicted in 1990 <ref> [8] </ref>, these improvements in low-level communication systems have moved the performance bottlenecks for distributed applications out of the network and operating system layers and into the applications themselves [18, 19]. It is now possible to write high- performance, distributed applications that efficiently utilize network bandwidth.
Reference: [9] <author> CULLER, D. E., DUSSEAU, A., GOLDSTEIN, S. C., KRISHNAMURTHY, A., LUMETTA, S., VON EICKEN, T., AND YELICK, K. </author> <title> Parallel programming in Split-C. </title> <booktitle> In Proceedings of Supercomputing '93 (Portland, </booktitle> <address> OR, </address> <month> Nov. </month> <year> 1993), </year> <pages> pp. 262273. </pages>
Reference-contexts: This level of control is also required in order to provide a migration path for existing applications already written to other communication models such as MPI [22]. For parallel applications, there are a large number of specialized programming languages such as CC++ [7], Fortran M [15], and Split-C <ref> [9] </ref>. In most of these cases the language handles marshaling and unmarshaling of parameters.
Reference: [10] <author> EIDE, E., FREI, K., FORD, B., LEPREAU, J., AND LINDSTROM, G. Flick: </author> <title> A flexible, optimizing IDL compiler. </title> <booktitle> In Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation (Las Vegas, </booktitle> <address> NV, </address> <month> June </month> <year> 1997), </year> <pages> pp. 4456. </pages>
Reference-contexts: To explore these ideas we have implemented Flick <ref> [10] </ref>, the Flexible IDL Compiler Kit. Flick is a toolkit of compiler components that may be specialized for particular IDLs, stub styles, and transport systems. Flick currently has front ends that parse the CORBA [23], ONC RPC (a.k.a. Sun RPC) [26], and MIG [24] IDLs. <p> Flick also exploits opportunities to copy objects with efficient copy routines; for example, arrays of integers may be copied with memcpy when Flick is able to determine that no byte-swapping or other presentation layer conversion is required. Previous experiments with Flick <ref> [10] </ref> show that Flick-generated stubs can marshal data between 2 and 17 times as fast as stubs generated by other IDL compilers. <p> To address these and similar performance issues, several attempts have been made to improve the code generated by IDL compilers. These are discussed in our earlier paper on Flick <ref> [10] </ref>. In summary, these other IDL compilers are either not very functional and not flexible (Mach's MIG compiler), or they generate very slow code (e.g., ILU [20]). Like Flick, the Concert/C distributed programming system [3] quite fully develops the concept of flexible presentation.
Reference: [11] <author> ENGLER, D. R., KAASHOEK, M. F., AND O'TOOLE JR., J. Exokernel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Proc. of the 15th ACM Symp. on Operating Systems Principles (Copper Mountain, </booktitle> <publisher> CO, </publisher> <month> Dec. </month> <year> 1995), </year> <pages> pp. 251266. </pages>
Reference-contexts: 1 Introduction Modern computer networks are becoming increasingly fast, and modern operating systems are now supporting efficient, lightweight communication mechanisms such as shared memory-based intra-node communication channels [1], highly optimized kernel IPC paths <ref> [11, 21] </ref>, and new inter-node communication models such as active messages [29] and sender-based protocols [5, 28].
Reference: [12] <author> FORD, B., HIBLER, M., AND LEPREAU, J. </author> <title> Using annotated interface definitions to optimize RPC. </title> <type> Tech. Rep. </type> <institution> UUCS-95-014, University of Utah Department of Computer Science, </institution> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: Those prototypes conform to the CORBA specification for mapping IDL constructs onto the C programming language. However, that mapping is not the only possible mapping, nor it is necessarily the most useful one. Previ- ous experiments <ref> [12, 13] </ref>, for example, have shown that by modifying the mapping from IDL to stub, a programmer can adapt the stubs to better meet the needs of a particular system. Section 3 will explore this idea further. <p> How- ever, this separation is not leveraged for optimizations. In 4 requests and replies, efficient message forwarding, and saving intermediate results. earlier work <ref> [12, 13] </ref> we concentrated on leveraging Flick's explicit separation of presentation from interface in order to produce application-specialized stubs.
Reference: [13] <author> FORD, B., HIBLER, M., AND LEPREAU, J. </author> <title> Using an-notated interface definitions to optimize RPC. </title> <booktitle> In Proc. of the 15th ACM Symp. on Operating Systems Principles (1995), </booktitle> <address> p. </address> <note> 232. Poster. </note>
Reference-contexts: Those prototypes conform to the CORBA specification for mapping IDL constructs onto the C programming language. However, that mapping is not the only possible mapping, nor it is necessarily the most useful one. Previ- ous experiments <ref> [12, 13] </ref>, for example, have shown that by modifying the mapping from IDL to stub, a programmer can adapt the stubs to better meet the needs of a particular system. Section 3 will explore this idea further. <p> How- ever, this separation is not leveraged for optimizations. In 4 requests and replies, efficient message forwarding, and saving intermediate results. earlier work <ref> [12, 13] </ref> we concentrated on leveraging Flick's explicit separation of presentation from interface in order to produce application-specialized stubs.
Reference: [14] <author> FORD, B., HIBLER, M., LEPREAU, J., TULLMANN, P., BACK, G., AND CLAWSON, S. </author> <title> Microkernels meet recursive virtual machines. </title> <booktitle> In Proc. of the Second Symp. on Operating Systems Design and Implementation (Seattle, </booktitle> <address> WA, Oct. 1996), </address> <publisher> USENIX Assoc., </publisher> <pages> pp. 137151. </pages>
Reference-contexts: Sun RPC) [26], and MIG [24] IDLs. Flick compiles an interface specification in any of these languages through a series of intermediate representations to produce optimized CORBA-, rpcgen- [27], or MIG- style C stubs communicating via TCP, Mach [1] messages, Trapeze [2] messages, or Fluke <ref> [14] </ref> kernel IPC. Section 2 summarizes the structure of Flick, and Section 3 describes how Flick is being extended to create specialized communication stubs for one distributed application: Khazana [6], a global memory service. 2 as three separate compiler passes which communicate through intermediate files.
Reference: [15] <author> FOSTER, I. T., AND CHANDY, K. M. </author> <title> Fortran M: A language for modular parallel programming. </title> <journal> Journal of Parallel and Distributed Computing 25, </journal> <month> 1 (Feb. </month> <year> 1995). </year>
Reference-contexts: This level of control is also required in order to provide a migration path for existing applications already written to other communication models such as MPI [22]. For parallel applications, there are a large number of specialized programming languages such as CC++ [7], Fortran M <ref> [15] </ref>, and Split-C [9]. In most of these cases the language handles marshaling and unmarshaling of parameters.
Reference: [16] <author> FOSTER, I. T., KESSELMAN, C., AND TUECKE, S. </author> <title> The Nexus task-parallel runtime system. </title> <booktitle> In Proceedings of First International Workshop on Parallel Processing (1994), </booktitle> <pages> pp. 457462. </pages>
Reference-contexts: There are also a large number of parallel runtime systems providing various levels of abstraction and functionality, such as MPI, PVM [17], and Nexus <ref> [16] </ref>. Typically, these systems require the programmer to write the marshaling code by hand, although they do abstract away byte-swapping in order to accommodate heterogeneous machines. We believe these provide an attractive target for optimizations provided by Flick.
Reference: [17] <author> GEIST, G., AND SUNDERAM, V. </author> <title> The PVM sys-tem: Supercomputer level concurrent computation on a heterogenous network of workstations. </title> <booktitle> In Sixth Annual Distributed-Memory Computer Conference (1991), </booktitle> <pages> pp. 258261. </pages>
Reference-contexts: There are also a large number of parallel runtime systems providing various levels of abstraction and functionality, such as MPI, PVM <ref> [17] </ref>, and Nexus [16]. Typically, these systems require the programmer to write the marshaling code by hand, although they do abstract away byte-swapping in order to accommodate heterogeneous machines. We believe these provide an attractive target for optimizations provided by Flick.
Reference: [18] <author> GOKHALE, A., AND SCHMIDT, D. C. </author> <title> Measuring the performance of communication middleware on highspeed networks. Computer Communication Review 26, </title> <address> 4 (Oct. </address> <year> 1996). </year>
Reference-contexts: As Clark and Tennenhouse predicted in 1990 [8], these improvements in low-level communication systems have moved the performance bottlenecks for distributed applications out of the network and operating system layers and into the applications themselves <ref> [18, 19] </ref>. It is now possible to write high- performance, distributed applications that efficiently utilize network bandwidth. However, in order to realize the benefits of modern communication networks, the authors of parallel and distributed applications are generally forced to write their applications' communication code by hand. <p> Traditionally, however, this benefit has come at a cost: poor optimization of the IDL- derived code. The code generated by existing IDL compilers like rpcgen contains a great deal of overhead; Schmidt et al. <ref> [18] </ref> and others have quantified this overhead for a number of existing CORBA implementations. <p> This will reduce the application writers' burden and eliminate what is currently an error-prone process, without compromising application performance. 4 Related Work Recent work by Schmidt et al. <ref> [18, 25] </ref> has quantified the impact of presentation layer overhead for rpcgen and two commercial CORBA implementations. On average, due to inefficiencies at the presentation and transport layers, compiler-generated stubs achieved only 1680% of the throughput of hand-coded stubs.
Reference: [19] <author> GOKHALE, A., AND SCHMIDT, D. C. </author> <title> Optimizing the performance of the CORBA Internet Inter-ORB Protocol over ATM. </title> <type> Tech. Rep. </type> <institution> WUCS9709, Washington University Department of Computer Science, </institution> <address> St. Louis, MO, </address> <year> 1997. </year>
Reference-contexts: As Clark and Tennenhouse predicted in 1990 [8], these improvements in low-level communication systems have moved the performance bottlenecks for distributed applications out of the network and operating system layers and into the applications themselves <ref> [18, 19] </ref>. It is now possible to write high- performance, distributed applications that efficiently utilize network bandwidth. However, in order to realize the benefits of modern communication networks, the authors of parallel and distributed applications are generally forced to write their applications' communication code by hand.
Reference: [20] <author> JANSSEN, B., AND SPREITZER, M. </author> <title> ILU 2.0alpha8 Reference Manual. </title> <institution> Xerox Corporation, </institution> <month> May </month> <year> 1996. </year> <month> ftp://ftp.parc.xerox.com/pub/ilu/ilu.html. </month>
Reference-contexts: These are discussed in our earlier paper on Flick [10]. In summary, these other IDL compilers are either not very functional and not flexible (Mach's MIG compiler), or they generate very slow code (e.g., ILU <ref> [20] </ref>). Like Flick, the Concert/C distributed programming system [3] quite fully develops the concept of flexible presentation.
Reference: [21] <author> LIEDTKE, J. </author> <title> Improving IPC by kernel design. </title> <booktitle> In Proc. of the 14th ACM Symp. on Operating Systems Principles (Asheville, </booktitle> <address> NC, </address> <month> Dec. </month> <year> 1993). </year>
Reference-contexts: 1 Introduction Modern computer networks are becoming increasingly fast, and modern operating systems are now supporting efficient, lightweight communication mechanisms such as shared memory-based intra-node communication channels [1], highly optimized kernel IPC paths <ref> [11, 21] </ref>, and new inter-node communication models such as active messages [29] and sender-based protocols [5, 28].
Reference: [22] <author> MESSAGE PASSING INTERFACE FORUM. </author> <title> MPI-2: Extensions to the Message-Passing Interface, </title> <month> July </month> <year> 1997. </year> <note> http://www.mpi-forum.org/. </note>
Reference-contexts: This level of control is also required in order to provide a migration path for existing applications already written to other communication models such as MPI <ref> [22] </ref>. For parallel applications, there are a large number of specialized programming languages such as CC++ [7], Fortran M [15], and Split-C [9]. In most of these cases the language handles marshaling and unmarshaling of parameters.
Reference: [23] <author> OBJECT MANAGEMENT GROUP. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.0 ed., </editor> <month> July </month> <year> 1995. </year>
Reference-contexts: The stubs output by the IDL compiler hide the details of communication and allow the client and server to interact through a procedural interface. For example, consider the following CORBA <ref> [23] </ref> IDL specification of a simple file server: interface FS - typedef sequence&lt;octet&gt; content; content read (in string filename); void write (in string filename, in content data); -; Given this interface, a CORBA IDL compiler will generate the following stub prototypes for the read and write operations: 1 FS_content *FS_read (FS <p> To explore these ideas we have implemented Flick [10], the Flexible IDL Compiler Kit. Flick is a toolkit of compiler components that may be specialized for particular IDLs, stub styles, and transport systems. Flick currently has front ends that parse the CORBA <ref> [23] </ref>, ONC RPC (a.k.a. Sun RPC) [26], and MIG [24] IDLs.
Reference: [24] <institution> OPEN SOFTWARE FOUNDATION AND CARNEGIE MELLON UNIVERSITY. </institution> <type> Mach 3 Server Writer's Guide. </type> <address> Cambridge, MA, </address> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: Flick is a toolkit of compiler components that may be specialized for particular IDLs, stub styles, and transport systems. Flick currently has front ends that parse the CORBA [23], ONC RPC (a.k.a. Sun RPC) [26], and MIG <ref> [24] </ref> IDLs. Flick compiles an interface specification in any of these languages through a series of intermediate representations to produce optimized CORBA-, rpcgen- [27], or MIG- style C stubs communicating via TCP, Mach [1] messages, Trapeze [2] messages, or Fluke [14] kernel IPC.
Reference: [25] <author> SCHMIDT, D. C., HARRISON, T., AND AL-SHAER, E. </author> <title> Object-oriented components for high-speed net-work programming. </title> <booktitle> In Proceedings of the First Conference on Object-Oriented Technologies and Systems (Monterey, </booktitle> <address> CA, June 1995), </address> <publisher> USENIX Assoc. </publisher>
Reference-contexts: This will reduce the application writers' burden and eliminate what is currently an error-prone process, without compromising application performance. 4 Related Work Recent work by Schmidt et al. <ref> [18, 25] </ref> has quantified the impact of presentation layer overhead for rpcgen and two commercial CORBA implementations. On average, due to inefficiencies at the presentation and transport layers, compiler-generated stubs achieved only 1680% of the throughput of hand-coded stubs.
Reference: [26] <author> SRINIVASAN, R. </author> <title> RPC: Remote procedure call proto-col specification version 2. </title> <type> Tech. Rep. RFC 1831, </type> <institution> Sun Microsystems, Inc., </institution> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: To explore these ideas we have implemented Flick [10], the Flexible IDL Compiler Kit. Flick is a toolkit of compiler components that may be specialized for particular IDLs, stub styles, and transport systems. Flick currently has front ends that parse the CORBA [23], ONC RPC (a.k.a. Sun RPC) <ref> [26] </ref>, and MIG [24] IDLs. Flick compiles an interface specification in any of these languages through a series of intermediate representations to produce optimized CORBA-, rpcgen- [27], or MIG- style C stubs communicating via TCP, Mach [1] messages, Trapeze [2] messages, or Fluke [14] kernel IPC.
Reference: [27] <author> SUN MICROSYSTEMS, INC. </author> <title> ONC+ Developer's Guide, </title> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: Flick currently has front ends that parse the CORBA [23], ONC RPC (a.k.a. Sun RPC) [26], and MIG [24] IDLs. Flick compiles an interface specification in any of these languages through a series of intermediate representations to produce optimized CORBA-, rpcgen- <ref> [27] </ref>, or MIG- style C stubs communicating via TCP, Mach [1] messages, Trapeze [2] messages, or Fluke [14] kernel IPC.
Reference: [28] <author> SWANSON, M. R., AND STOLLER, L. B. </author> <title> Direct de-posit: A basic user-level protocol for carpet clusters. </title> <type> Tech. Rep. </type> <institution> UUCS-95-003, University of Utah Department of Computer Science, </institution> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Modern computer networks are becoming increasingly fast, and modern operating systems are now supporting efficient, lightweight communication mechanisms such as shared memory-based intra-node communication channels [1], highly optimized kernel IPC paths [11, 21], and new inter-node communication models such as active messages [29] and sender-based protocols <ref> [5, 28] </ref>. As Clark and Tennenhouse predicted in 1990 [8], these improvements in low-level communication systems have moved the performance bottlenecks for distributed applications out of the network and operating system layers and into the applications themselves [18, 19].
Reference: [29] <author> VON EICKEN, T., CULLER, D. E., GOLDSTEIN, S. C., AND SCHAUSER, K. E. </author> <title> Active messages: A mechanism for integrated communication and compu-tation. </title> <booktitle> In Proc. of the 19th International Symp. on Computer Architecture (May 1992), </booktitle> <pages> pp. 256266. 6 </pages>
Reference-contexts: 1 Introduction Modern computer networks are becoming increasingly fast, and modern operating systems are now supporting efficient, lightweight communication mechanisms such as shared memory-based intra-node communication channels [1], highly optimized kernel IPC paths [11, 21], and new inter-node communication models such as active messages <ref> [29] </ref> and sender-based protocols [5, 28]. As Clark and Tennenhouse predicted in 1990 [8], these improvements in low-level communication systems have moved the performance bottlenecks for distributed applications out of the network and operating system layers and into the applications themselves [18, 19].
References-found: 29

