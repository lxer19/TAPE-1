URL: file://ftp.cs.ucsd.edu/pub/rich/papers/power4.ps
Refering-URL: http://www.cs.ucsd.edu/users/rich/publications.html
Root-URL: http://www.cs.ucsd.edu
Title: Compiler Enforced Cache Coherence Using a Functional Language  
Author: Rich Wolski David Cann 
Address: 1110 Bayfield Dr.  San Diego Colorado Springs, CO 80935 La Jolla, CA 92093  
Affiliation: Department of Cray Computer Corporation Computer Science and Engineering  University of California,  
Abstract: The cost of hardware cache-coherence, both in terms of execution delay and operational cost, is substantial for scalable systems. Fortunately, compiler generated cache management can reduce program serialization due to cache-contention and increase execution performance. It can also reduce the cost of parallel systems by eliminating the need for more expensive hardware support. In this paper, we use Sisal functional language system as a vehicle to implement and investigate automatic, compiler based cache management. We describe our implementation of Sisal for the IBM Power/4. The Power/4, briefly available as a product, represents an early attempt to build a shared-memory machine that relies strictly on the language system for cache-coherence. We discuss the issues associated with deterministic execution and program correctness on a system without hardware coherence, and demonstrate how Sisal (as a functional language) is able to address those issues. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Cann, D. </author> <title> Graph transformation algorithms for array memory optimization in applicative languages. </title> <type> Tech. Rep. </type> <institution> CS-89-108, Colorado State University, </institution> <address> Fort Collins, CO, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: In the next section, we briefly describe the IBM Power/4. Section 3 details some of the problems associated with software cache management and how we address them using OSC (the Optimizing Sisal Com--piler) <ref> [1] </ref>. In Section 4, we detail and analyze our results in terms of two scientific programs: RICARD and SIMPLE. We discuss both the relative performance (speedup) and the execution time of each program, and identify sources of execution overhead.
Reference: [2] <author> Cann, D. </author> <title> Retire fortran? a debate rekindled. </title> <journal> Communications of the ACM 35, </journal> <month> 8 (August </month> <year> 1992), </year> <pages> 81-89. </pages>
Reference-contexts: If machines are to be built in the future without hardware coherence, functional programming can drastically reduce the cost of programming them. Sisal is a good choice for such an implementation as it has been shown to achieve excellent shared-memory execution performance for scientific programs on other systems <ref> [2] </ref>. In the next section, we briefly describe the IBM Power/4. Section 3 details some of the problems associated with software cache management and how we address them using OSC (the Optimizing Sisal Com--piler) [1].
Reference: [3] <author> Choi, L., and Yew, P.-C. </author> <title> A compiler-directed cache coherence scheme with improved intertask locality. </title> <booktitle> In Proceedings of Supercomputing 1994 (1994), </booktitle> <pages> pp. 773-782. </pages>
Reference-contexts: While the Power/4 is no longer commercially available, it represents an early example of a shared-memory, cache-based architecture without hardware coherence. 3 Software Cache Coherence Previous work in software cache management proposes to reduce or eliminate entirely the need for hardware coherence mechanisms <ref> [4, 6, 3] </ref>. A purely software based approach requires the compiler and run-time system to explicitly address the problems of stale data and false sharing in order to generate deterministic programs.
Reference: [4] <author> Cytron, R., Karlovsky, S., and McAuiliffe, K. </author> <title> Automatic management of programmable caches. </title> <booktitle> In Proceedings of the 1988 International Conference on Parallel Processing (August 1988), </booktitle> <pages> pp. 229-238. </pages>
Reference-contexts: 1 Introduction The cost of hardware cache-coherence, both in terms of execution delay and operational cost, is substantial for scalable systems <ref> [4] </ref>. Parallel work must stop while the caches are adjusted. [8]. Furthermore, as cache-coherent systems scale in size, the time associated with each consistency operation also increases. Small, bus-based systems can typically resolve a cache-miss in 5 to 50 processor cycles. <p> While the Power/4 is no longer commercially available, it represents an early example of a shared-memory, cache-based architecture without hardware coherence. 3 Software Cache Coherence Previous work in software cache management proposes to reduce or eliminate entirely the need for hardware coherence mechanisms <ref> [4, 6, 3] </ref>. A purely software based approach requires the compiler and run-time system to explicitly address the problems of stale data and false sharing in order to generate deterministic programs.
Reference: [5] <institution> Lawrence Livermore National Laboratory Computer Research Group. </institution> <note> Streams and Iterations in a Single Assignment Language, Version 1.2. </note> <institution> Livermore, </institution> <address> CA, </address> <month> March </month> <year> 1985. </year>
Reference-contexts: In this paper, we investigate the use of a functional language as a vehicle for implementing automatic, compiler-based cache management. We describe an implementation of Sisal (Streams and Iterations in a Single Assignment Language) <ref> [5] </ref> for the IBM Power/4. The Power/4 supports shared memory, but relies strictly on the language system to enforce cache-coherence. Functional languages are attractive for such a system as they are easily analyzable for parallelism and data dependence.
Reference: [6] <author> Nguyen, T., Mounes-Toussi, F., Lilja, D., and Li, Z. </author> <title> A compiler-assisted scheme for adaptive cache coherence enforcement. </title> <journal> IFIP Transactions A (Computer Science and Technology) A-50 (August 1994), </journal> <pages> 69-78. </pages>
Reference-contexts: While the Power/4 is no longer commercially available, it represents an early example of a shared-memory, cache-based architecture without hardware coherence. 3 Software Cache Coherence Previous work in software cache management proposes to reduce or eliminate entirely the need for hardware coherence mechanisms <ref> [4, 6, 3] </ref>. A purely software based approach requires the compiler and run-time system to explicitly address the problems of stale data and false sharing in order to generate deterministic programs.
Reference: [7] <author> Raneletti, J. </author> <title> Graph transformation algorithms for array memory optimization in applicative languages. </title> <type> Tech. Rep. </type> <institution> UCRL-53832, Lawrence Livermore National Laboratory, Livermore, </institution> <address> CA, </address> <month> November </month> <year> 1987. </year>
Reference-contexts: The elemental data type for the outer vector is therefore a memory pointer, the size of which is known at compile time. The other form of interference comes from the build-in-place optimizations specified in <ref> [7] </ref>. These optimizations will cause contiguous memory to be pre-allocated for data structures that are built separately and then concatenated.
Reference: [8] <author> Yen, W., Yen, W., and Fu, K.-S. </author> <title> Data coherence problems in a multicache system. </title> <journal> IEEE Transactions on Computers 34 (1985), </journal> <pages> 56-65. </pages>
Reference-contexts: 1 Introduction The cost of hardware cache-coherence, both in terms of execution delay and operational cost, is substantial for scalable systems [4]. Parallel work must stop while the caches are adjusted. <ref> [8] </ref>. Furthermore, as cache-coherent systems scale in size, the time associated with each consistency operation also increases. Small, bus-based systems can typically resolve a cache-miss in 5 to 50 processor cycles.
References-found: 8

