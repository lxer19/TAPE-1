URL: ftp://cse.ogi.edu/pub/dsrg/HOPE/swft.ps.Z
Refering-URL: http://www.cse.ogi.edu/~crispin/
Root-URL: http://www.cse.ogi.edu
Email: hanan@csd.uwo.ca  
Title: Language Support for the Application-Oriented Fault Tolerance Paradigm presence of failures. When a node fails,
Author: Hanan L. Lutfiyya and Crispin Cowan 
Keyword: Optimistic recovery protocols  Key Words: Distributed Systems, Application-Oriented Fault Tolerance, Assertions, Recovery  
Note: allow fail-stop applications running on distributed systems to be rolled back and re-started in the  supported in part by the National Sciences and Engineering Research Council of Canada (NSERC) under contract number OGP0138180-S365A2, and in part, from the University of Western Ontario NSERC internal funding under contract number Z001A8-S365A1.  
Date: February 20, 1995  
Address: Ontario London, Ont. N6A 5B7 CANADA  
Affiliation: Department of Computer Science University of Western  
Abstract: The application-oriented fault tolerance paradigm is an approach to providing run-time assurance for a distributed environment based on the use of executable assertions inserted into a program for monitoring the run-time behaviour of the program and ensuring that at actual run time that the program state is consistent with the logical state specified in the assertion. Failure of an executable assertion indicates that a fault of some kind has occurred. l This paper describes a set of language primitives that provide for the convenient specification of executable assertions in combination with an optimistic recovery protocol. Failure of an executable assertion rolls back the application to a consistent state prior to the fault, and either re-executes the application, or proceeds with alternative software that addresses the fault. Software that suitably responds to different kinds of faults allows the application programmer to create distributed programs capable of handling transient, fail-stop and Byzantine faults. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Bhargava and S.R. Lian. </author> <title> Independent checkpointing and concurrent rollback for recovery. </title> <booktitle> Proceedings of the IEEE Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 3-12, </pages> <year> 1988. </year>
Reference-contexts: Possible rollback propagation in case of a fault is handled by searching for a consistent system state based on the dependency information. Several optimistic recovery protocols have been proposed <ref> [1, 14, 15, 16, 31] </ref>, but few have even been implemented [4, 11]. These protocols allow separate components of a distributed system to asynchronously checkpoint their state while retaining the ability to recover the whole system to a consistent state.
Reference: [2] <author> N. Carriero and D. Gelernter. </author> <title> Linda in Context. </title> <journal> Communications of the ACM, </journal> <volume> 31(4) </volume> <pages> 444-458, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: HOPE is not a complete programming language, but rather is a programming model for optimism, embodied as a set of primitives designed to be embedded in some other programming language, similar to Linda <ref> [2] </ref>. There are very few restrictions on the kinds of distributed systems in which HOPE can be embedded. HOPE can be embedded in any system providing concurrent processes that communicate with messages.
Reference: [3] <author> Crispin Cowan. </author> <title> Optimistic Replication in HOPE. </title> <booktitle> In Proceedings of the 1992 CAS Conference, </booktitle> <pages> pages 269-282, </pages> <address> Toronto, Ontario, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: The software is freely available [6]. 5 4 The HOPE Programming Model HOPE is a set of primitives designed for expressing optimism. Optimism is a technique that has been used to overcome the latency in network communications [19], replication <ref> [3, 12, 32] </ref>, fault tolerance [31], and discrete event simulation [13]. HOPE is not a complete programming language, but rather is a programming model for optimism, embodied as a set of primitives designed to be embedded in some other programming language, similar to Linda [2].
Reference: [4] <author> Crispin Cowan. </author> <title> Optimistic Programming in PVM. </title> <booktitle> In Proceedings of the 2nd PVM User's Group Meeting, </booktitle> <institution> Oak Ridge, TN, </institution> <month> May </month> <year> 1994. </year> <month> 16 </month>
Reference-contexts: Possible rollback propagation in case of a fault is handled by searching for a consistent system state based on the dependency information. Several optimistic recovery protocols have been proposed [1, 14, 15, 16, 31], but few have even been implemented <ref> [4, 11] </ref>. These protocols allow separate components of a distributed system to asynchronously checkpoint their state while retaining the ability to recover the whole system to a consistent state. <p> There is an operational semantics for the HOPE primitives, as well as theorems proving that use of the HOPE primitives provides the expected and desirable effects, including preventing the domino effect (see Theorem 6.2). Finally, unlike many optimistic systems, HOPE has actually been implemented <ref> [4, 9] </ref>. The implementation is layered on top of the PVM message passing system, and runs entirely in user-mode, so no operating system changes are necessary. The software is freely available [6]. 5 4 The HOPE Programming Model HOPE is a set of primitives designed for expressing optimism. <p> This ensures that the HOPE messages are transparent to the user processes. The HOPE programming model has been formally specified [7], and has been implemented on top of the PVM system <ref> [4, 10] </ref>. The prototype supports asynchronous checkpoint and rollback of UNIX processes within the PVM distributed programming environment, and automates dependency tracking among the processes.
Reference: [5] <author> Crispin Cowan. </author> <title> A Programming Model for Optimism. </title> <type> PhD thesis, </type> <institution> University of Western Ontario, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: From this point, the application can resume execution, hopefully avoiding the transient fault and running to correct completion. We chose to build our primitives for recoverable executable assertions based on the HOPE general programming model for optimism <ref> [5] </ref>. HOPE allows for the specification of arbitrary optimistic assumptions, while automating checkpointing, rollback, and dependency tracking. HOPE offers several important advantages over traditional optimistic recovery protocols. Most optimistic recovery protocols guard against the fail-stop failure of a node in a distributed system. <p> Specifying a partial order allows an application to execute statements concurrently that might otherwise have to be executed sequentially, allowing the application to increase its concurrency, and potentially its performance, while also detecting faults that result in invalid execution sequences [8]. HOPE has been formally specified <ref> [5, 7] </ref>. There is an operational semantics for the HOPE primitives, as well as theorems proving that use of the HOPE primitives provides the expected and desirable effects, including preventing the domino effect (see Theorem 6.2). Finally, unlike many optimistic systems, HOPE has actually been implemented [4, 9]. <p> This allows the application to take recovery actions for other than a transient fault. 6 Preserving Consistency In this section, we will show that the HOPE primitives preserve consistency. We will first describe consistency. We will then show that, by using theorems developed in other work <ref> [5, 7] </ref>, that the rollback mechanism provided by the HOPE primitives preserve consistency. 6.1 Defining Consistency In a distributed system, processes communicate by exchanging messages. Messages generated by the sending process may trigger events at the receiving process. <p> Similarly, each assumption identifier X records the set of intervals that depend on X in X:DOM . The formal semantics of HOPE are defined over this model and produce the following theorems. Proofs can be found in <ref> [5, 7] </ref>. The following lemma shows that for all intervals and assumption identifiers, if an interval A records that it is dependent on an assumption identifier X, then the assumption identifier X also records that A is dependent on X. This lemma is used in proving subsequent theorems.
Reference: [6] <author> Crispin Cowan. </author> <title> HOPE: Hopefully Optimistic Programming Environment. Prototype implementation, </title> <note> avialable via FTP from ftp://ftp.csd.uwo.ca/pub/src/hope.tar.Z, </note> <month> January </month> <year> 1995. </year>
Reference-contexts: Finally, unlike many optimistic systems, HOPE has actually been implemented [4, 9]. The implementation is layered on top of the PVM message passing system, and runs entirely in user-mode, so no operating system changes are necessary. The software is freely available <ref> [6] </ref>. 5 4 The HOPE Programming Model HOPE is a set of primitives designed for expressing optimism. Optimism is a technique that has been used to overcome the latency in network communications [19], replication [3, 12, 32], fault tolerance [31], and discrete event simulation [13]. <p> The prototype supports asynchronous checkpoint and rollback of UNIX processes within the PVM distributed programming environment, and automates dependency tracking among the processes. Performance studies of this prototype system have been done [9], and the prototype is available for testing <ref> [6] </ref>. 8 Summary and Future Work We have presented language constructs that allow us to produce fault-tolerant applications. We showed how the constructs can be used to construct fault-tolerant programs that handle transient faults by re-executing a specified number of times.
Reference: [7] <author> Crispin Cowan and Hanan Lutfiyya. </author> <title> Formal Semantics for Expressing Optimism: The Meaning of HOPE. </title> <note> Submitted for review, </note> <month> January </month> <year> 1995. </year>
Reference-contexts: Specifying a partial order allows an application to execute statements concurrently that might otherwise have to be executed sequentially, allowing the application to increase its concurrency, and potentially its performance, while also detecting faults that result in invalid execution sequences [8]. HOPE has been formally specified <ref> [5, 7] </ref>. There is an operational semantics for the HOPE primitives, as well as theorems proving that use of the HOPE primitives provides the expected and desirable effects, including preventing the domino effect (see Theorem 6.2). Finally, unlike many optimistic systems, HOPE has actually been implemented [4, 9]. <p> This allows the application to take recovery actions for other than a transient fault. 6 Preserving Consistency In this section, we will show that the HOPE primitives preserve consistency. We will first describe consistency. We will then show that, by using theorems developed in other work <ref> [5, 7] </ref>, that the rollback mechanism provided by the HOPE primitives preserve consistency. 6.1 Defining Consistency In a distributed system, processes communicate by exchanging messages. Messages generated by the sending process may trigger events at the receiving process. <p> Similarly, each assumption identifier X records the set of intervals that depend on X in X:DOM . The formal semantics of HOPE are defined over this model and produce the following theorems. Proofs can be found in <ref> [5, 7] </ref>. The following lemma shows that for all intervals and assumption identifiers, if an interval A records that it is dependent on an assumption identifier X, then the assumption identifier X also records that A is dependent on X. This lemma is used in proving subsequent theorems. <p> The messages sent to user processes are intercepted by the message passing system and given to the HOPE modules attached to each user process for processing. This ensures that the HOPE messages are transparent to the user processes. The HOPE programming model has been formally specified <ref> [7] </ref>, and has been implemented on top of the PVM system [4, 10]. The prototype supports asynchronous checkpoint and rollback of UNIX processes within the PVM distributed programming environment, and automates dependency tracking among the processes.
Reference: [8] <author> Crispin Cowan, Hanan Lutfiyya, and Mike Bauer. </author> <title> Increasing Concurrency Through Optimism: A Reason for HOPE. </title> <booktitle> In Proceedings of the 1994 ACM Computer Science Conference, </booktitle> <pages> pages 218-225, </pages> <address> Phoenix, Arizona, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: Specifying a partial order allows an application to execute statements concurrently that might otherwise have to be executed sequentially, allowing the application to increase its concurrency, and potentially its performance, while also detecting faults that result in invalid execution sequences <ref> [8] </ref>. HOPE has been formally specified [5, 7]. There is an operational semantics for the HOPE primitives, as well as theorems proving that use of the HOPE primitives provides the expected and desirable effects, including preventing the domino effect (see Theorem 6.2).
Reference: [9] <author> Crispin Cowan, Hanan Lutfiyya, and Mike Bauer. </author> <title> Performance Benefits of Optimistic Programming: A Measure of HOPE. </title> <note> Submitted for review, </note> <month> January </month> <year> 1995. </year>
Reference-contexts: There is an operational semantics for the HOPE primitives, as well as theorems proving that use of the HOPE primitives provides the expected and desirable effects, including preventing the domino effect (see Theorem 6.2). Finally, unlike many optimistic systems, HOPE has actually been implemented <ref> [4, 9] </ref>. The implementation is layered on top of the PVM message passing system, and runs entirely in user-mode, so no operating system changes are necessary. The software is freely available [6]. 5 4 The HOPE Programming Model HOPE is a set of primitives designed for expressing optimism. <p> The prototype supports asynchronous checkpoint and rollback of UNIX processes within the PVM distributed programming environment, and automates dependency tracking among the processes. Performance studies of this prototype system have been done <ref> [9] </ref>, and the prototype is available for testing [6]. 8 Summary and Future Work We have presented language constructs that allow us to produce fault-tolerant applications. We showed how the constructs can be used to construct fault-tolerant programs that handle transient faults by re-executing a specified number of times.
Reference: [10] <author> Al Geist, Adam Geguelin, Jack Dongarra, Wicheng Jiang, Robert Manchek, and Vaidy Sunderam. </author> <title> PVM: Parallel Virtual Machine, a Users' Guide and Tutorial for Networked Parallel Computing. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1995. </year>
Reference-contexts: This ensures that the HOPE messages are transparent to the user processes. The HOPE programming model has been formally specified [7], and has been implemented on top of the PVM system <ref> [4, 10] </ref>. The prototype supports asynchronous checkpoint and rollback of UNIX processes within the PVM distributed programming environment, and automates dependency tracking among the processes.
Reference: [11] <author> Arthur Goldberg, Ajei Gopal, Kong Li, Rob Strom, and David F. Bacon. </author> <title> Transparent Recovery of Mach Applications. </title> <booktitle> In First USENIX Mach Workshop, </booktitle> <address> Burlington, VT, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: Possible rollback propagation in case of a fault is handled by searching for a consistent system state based on the dependency information. Several optimistic recovery protocols have been proposed [1, 14, 15, 16, 31], but few have even been implemented <ref> [4, 11] </ref>. These protocols allow separate components of a distributed system to asynchronously checkpoint their state while retaining the ability to recover the whole system to a consistent state.
Reference: [12] <author> Arthur P. Goldberg. </author> <title> Optimistic Algorithms for Distributed Transparent Process Replication. </title> <type> PhD thesis, </type> <institution> University of California at Los Angeles, </institution> <year> 1991. </year> <note> (UCLA Tech. Report CSD-910050). </note>
Reference-contexts: The software is freely available [6]. 5 4 The HOPE Programming Model HOPE is a set of primitives designed for expressing optimism. Optimism is a technique that has been used to overcome the latency in network communications [19], replication <ref> [3, 12, 32] </ref>, fault tolerance [31], and discrete event simulation [13]. HOPE is not a complete programming language, but rather is a programming model for optimism, embodied as a set of primitives designed to be embedded in some other programming language, similar to Linda [2].
Reference: [13] <author> D. Jefferson. </author> <title> Virtual Time. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(7) </volume> <pages> 404-425, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: The software is freely available [6]. 5 4 The HOPE Programming Model HOPE is a set of primitives designed for expressing optimism. Optimism is a technique that has been used to overcome the latency in network communications [19], replication [3, 12, 32], fault tolerance [31], and discrete event simulation <ref> [13] </ref>. HOPE is not a complete programming language, but rather is a programming model for optimism, embodied as a set of primitives designed to be embedded in some other programming language, similar to Linda [2].
Reference: [14] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Recovery in Distributed Systems using Optimistic Message Logging and Checkpointing. </title> <journal> J. Algorithms, </journal> <volume> 11(3) </volume> <pages> 462-491, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Possible rollback propagation in case of a fault is handled by searching for a consistent system state based on the dependency information. Several optimistic recovery protocols have been proposed <ref> [1, 14, 15, 16, 31] </ref>, but few have even been implemented [4, 11]. These protocols allow separate components of a distributed system to asynchronously checkpoint their state while retaining the ability to recover the whole system to a consistent state.
Reference: [15] <author> T.T.Y. Juang and S. Venkatesan. </author> <title> Efficient Algorithm for Crash Recovery in Distributed Systems. </title> <booktitle> In 10th Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 349-361, </pages> <year> 1990. </year>
Reference-contexts: Possible rollback propagation in case of a fault is handled by searching for a consistent system state based on the dependency information. Several optimistic recovery protocols have been proposed <ref> [1, 14, 15, 16, 31] </ref>, but few have even been implemented [4, 11]. These protocols allow separate components of a distributed system to asynchronously checkpoint their state while retaining the ability to recover the whole system to a consistent state.
Reference: [16] <author> K. H. Kim, J.H. You, and A. Abouelnaga. </author> <title> A scheme for coordinated execution of independently designed recvoerable distributed processes. </title> <booktitle> Proceedings of the IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 130-135, </pages> <year> 1986. </year>
Reference-contexts: Possible rollback propagation in case of a fault is handled by searching for a consistent system state based on the dependency information. Several optimistic recovery protocols have been proposed <ref> [1, 14, 15, 16, 31] </ref>, but few have even been implemented [4, 11]. These protocols allow separate components of a distributed system to asynchronously checkpoint their state while retaining the ability to recover the whole system to a consistent state.
Reference: [17] <author> R. Koo and S. Toueg. </author> <title> Checkpointing and rollback recovery for distributed systems. </title> <journal> IEEE Transactions of Software Engineering, </journal> <volume> SE-13(2):21-31, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: In this section, we will describe these approaches and their relationship to our work. Coordinated checkpointing schemes <ref> [17, 22, 23, 29] </ref> synchronize computation with check-pointing by coordinating processes during a checkpointing session in order to maintain a consistent recovery line. The entire computation is halted so that a consistent checkpoint can be made of all processes in the system.
Reference: [18] <author> J. Kuhl and S. Reddy. </author> <title> Fault-tolerance considerations in large, </title> <booktitle> multiple-processor systems. Computer, </booktitle> <pages> pages 56-67, </pages> <month> March </month> <year> 1986. </year> <month> 17 </month>
Reference-contexts: used to ensure that the program state, in the actual run-time environment, is consistent with the logical state specified in the assertion; if not, then an error has occurred and a reliable communication of this diagnostic information is provided to the system such that reconfiguration and recovery can take place <ref> [18] </ref>. The work of [27] showed the applicability of executable assertions for detecting errors that are the result of Byzantine [20] faults.
Reference: [19] <author> H.T. Kung and John T. Robinson. </author> <title> On Optimistic Methods for Concurrency Control. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(2) </volume> <pages> 213-226, </pages> <month> June </month> <year> 1981. </year>
Reference-contexts: The software is freely available [6]. 5 4 The HOPE Programming Model HOPE is a set of primitives designed for expressing optimism. Optimism is a technique that has been used to overcome the latency in network communications <ref> [19] </ref>, replication [3, 12, 32], fault tolerance [31], and discrete event simulation [13]. HOPE is not a complete programming language, but rather is a programming model for optimism, embodied as a set of primitives designed to be embedded in some other programming language, similar to Linda [2].
Reference: [20] <author> L. Lamport, R. Shostak, and M. Pease. </author> <title> The byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: The work of [27] showed the applicability of executable assertions for detecting errors that are the result of Byzantine <ref> [20] </ref> faults. Later work [24, 25, 26] concentrated on methods for deriving and evaluating executable assertions, that represent assertions dependent on the local states of multiple processes, in a distributed fashion. However, no work has been done on integrating the error-detecting technique provided by executable assertions with recovery. <p> If the fault was permanent, then rollback should engage suitable alternative software to accommodate the fault. The ability to induce particular actions after rollback will make it possible to deal with other types of faults such as Byzantine (i.e malicious) faults <ref> [20] </ref> as well as fail-stop faults. Section 2 provides further details on the evaluation of executable assertions. Section 3 surveys recovery protocols.
Reference: [21] <author> Leslie Lamport. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Formally, we define the time slice to be the "before" set, so we use Lamport's ("happened before") relation <ref> [21] </ref> to define a finite set fi of events having the following property: if e 2 fi and f e then f 2 fi 12 A time slice fi is earlier than a time slice fi 0 if fi fi 0 .
Reference: [22] <author> Juan Leon. </author> <title> Fail-Safe PVM (3.2). </title> <booktitle> In Proceedings of the 2nd PVM User's Group Meeting, </booktitle> <institution> Oak Ridge, TN, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: In this section, we will describe these approaches and their relationship to our work. Coordinated checkpointing schemes <ref> [17, 22, 23, 29] </ref> synchronize computation with check-pointing by coordinating processes during a checkpointing session in order to maintain a consistent recovery line. The entire computation is halted so that a consistent checkpoint can be made of all processes in the system.
Reference: [23] <author> K. Li, F. Naughton, and J.S. Plank. </author> <title> Checkpointing multicomputer applications. </title> <booktitle> Proceedings of the IEEE Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <year> 1991. </year>
Reference-contexts: In this section, we will describe these approaches and their relationship to our work. Coordinated checkpointing schemes <ref> [17, 22, 23, 29] </ref> synchronize computation with check-pointing by coordinating processes during a checkpointing session in order to maintain a consistent recovery line. The entire computation is halted so that a consistent checkpoint can be made of all processes in the system.
Reference: [24] <author> H. Lutfiyya, M. Schollmeyer, and B. McMillin. </author> <title> Formal generation of executable assertions for a fault-tolerant bitonic sort. Responsive Computer Systems Dependable Computing and Fault Tolerance, </title> <publisher> Springer-Verlag, </publisher> <editor> H.Kopetz and Y. </editor> <booktitle> Kakuda eds, </booktitle> <pages> pages 71-96, </pages> <year> 1992. </year>
Reference-contexts: The work of [27] showed the applicability of executable assertions for detecting errors that are the result of Byzantine [20] faults. Later work <ref> [24, 25, 26] </ref> concentrated on methods for deriving and evaluating executable assertions, that represent assertions dependent on the local states of multiple processes, in a distributed fashion. However, no work has been done on integrating the error-detecting technique provided by executable assertions with recovery.
Reference: [25] <author> H. Lutfiyya, A. Su, and B. McMillin. </author> <title> Fault-tolerant distributed database lock managers. Formal Methods in Programming and Their Applications, </title> <publisher> Springer-Verlag, </publisher> <editor> Dines Bjorner, Manfred Broy, and Igor Pottosin eds, </editor> <address> pages 363-376, </address> <year> 1993. </year>
Reference-contexts: The work of [27] showed the applicability of executable assertions for detecting errors that are the result of Byzantine [20] faults. Later work <ref> [24, 25, 26] </ref> concentrated on methods for deriving and evaluating executable assertions, that represent assertions dependent on the local states of multiple processes, in a distributed fashion. However, no work has been done on integrating the error-detecting technique provided by executable assertions with recovery.
Reference: [26] <author> B. McMillin and E. Arrowsmith. </author> <title> How to program in CCSP. User Manual 93-30, </title> <institution> University of MO - Rolla, Department of Computer Science, </institution> <year> 1993. </year>
Reference-contexts: The work of [27] showed the applicability of executable assertions for detecting errors that are the result of Byzantine [20] faults. Later work <ref> [24, 25, 26] </ref> concentrated on methods for deriving and evaluating executable assertions, that represent assertions dependent on the local states of multiple processes, in a distributed fashion. However, no work has been done on integrating the error-detecting technique provided by executable assertions with recovery.
Reference: [27] <author> B. McMillin and L. Ni. </author> <title> Reliable distributed sorting through the application-oriented fault tol erance paradigm. </title> <journal> IEEE Trans. of Parallel and Distributed Computing, </journal> <volume> 3(4) </volume> <pages> 411-420, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction The application-oriented fault tolerance paradigm <ref> [27] </ref> is a promising approach to providing run-time assurance for the distributed environment. It provides an approach to choosing executable assertions from the software specification. <p> The work of <ref> [27] </ref> showed the applicability of executable assertions for detecting errors that are the result of Byzantine [20] faults. Later work [24, 25, 26] concentrated on methods for deriving and evaluating executable assertions, that represent assertions dependent on the local states of multiple processes, in a distributed fashion.
Reference: [28] <author> B. Randall. </author> <title> System structure for software fault tolerance. </title> <journal> IEEE Transactions of Software Engineering, </journal> <volume> SE-1(2):220-232, </volume> <year> 1975. </year>
Reference-contexts: In section 5, we showed how we can use HOPE to specify the execution of alternative code. Future work will include studying how to use the ability to specify the execution of alternative code. We will examine both software fault tolerance (design diversity) <ref> [28] </ref>, and hardware fault tolerance where the system is probed to determine the type of failure and determine a suitable action. In addition, we will study the overhead of the HOPE system for creating these fault-tolerant distributed applications.
Reference: [29] <author> B. Randell. </author> <title> System Structure for Software Fault Tolerance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 1(2) </volume> <pages> 226-232, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: In this section, we will describe these approaches and their relationship to our work. Coordinated checkpointing schemes <ref> [17, 22, 23, 29] </ref> synchronize computation with check-pointing by coordinating processes during a checkpointing session in order to maintain a consistent recovery line. The entire computation is halted so that a consistent checkpoint can be made of all processes in the system.
Reference: [30] <editor> D.P. Siewiorek and R.S. Swarz. </editor> <booktitle> The Theory and Practice of Reliable System Design. </booktitle> <publisher> Digital Press, </publisher> <year> 1982. </year>
Reference-contexts: Transient faults are faults of limited duration, caused by temporary malfunction of the system or due to some external interference. The importance of transient faults comes from their relatively frequent occurrence. Several experimental studies <ref> [30] </ref> have shown that the rate of occurrence of transient faults is 20 to 100 times higher than for permanent faults. Since transient faults do not cause permanent damage to the hardware, computations can be rolled back to a previous fault-free state and re-executed.
Reference: [31] <author> R.E. Strom and S. Yemini. </author> <title> Optimistic Recovery in Distributed Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: Possible rollback propagation in case of a fault is handled by searching for a consistent system state based on the dependency information. Several optimistic recovery protocols have been proposed <ref> [1, 14, 15, 16, 31] </ref>, but few have even been implemented [4, 11]. These protocols allow separate components of a distributed system to asynchronously checkpoint their state while retaining the ability to recover the whole system to a consistent state. <p> The software is freely available [6]. 5 4 The HOPE Programming Model HOPE is a set of primitives designed for expressing optimism. Optimism is a technique that has been used to overcome the latency in network communications [19], replication [3, 12, 32], fault tolerance <ref> [31] </ref>, and discrete event simulation [13]. HOPE is not a complete programming language, but rather is a programming model for optimism, embodied as a set of primitives designed to be embedded in some other programming language, similar to Linda [2].
Reference: [32] <author> P. Triantafillou and D.J. Taylor. </author> <title> A New Paradigm for High Availability and Efficiency in Replicated and Distributed Databases. </title> <booktitle> In 2nd IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 136-143, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: The software is freely available [6]. 5 4 The HOPE Programming Model HOPE is a set of primitives designed for expressing optimism. Optimism is a technique that has been used to overcome the latency in network communications [19], replication <ref> [3, 12, 32] </ref>, fault tolerance [31], and discrete event simulation [13]. HOPE is not a complete programming language, but rather is a programming model for optimism, embodied as a set of primitives designed to be embedded in some other programming language, similar to Linda [2].
Reference: [33] <author> S. Yau and R. Cheung. </author> <title> Design of self-checking software. </title> <booktitle> Proc. Int'l Conf. on Reliability Software, </booktitle> <pages> pages 450-457, </pages> <month> April </month> <year> 1975. </year> <month> 18 </month>
Reference-contexts: 1 Introduction The application-oriented fault tolerance paradigm [27] is a promising approach to providing run-time assurance for the distributed environment. It provides an approach to choosing executable assertions from the software specification. These executable assertions assertions <ref> [33] </ref>, in the form of source language statements, are to be inserted into a program for monitoring the run-time behavior of the program and ensuring that at each testable stage of a calculation, all tested processors conform to the program's specification, design, and implementation.
References-found: 33

