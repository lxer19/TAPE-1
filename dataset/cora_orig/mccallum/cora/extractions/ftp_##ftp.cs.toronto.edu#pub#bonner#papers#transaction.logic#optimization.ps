URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/transaction.logic/optimization.ps
Refering-URL: http://www.cs.toronto.edu/~bonner/papers.html
Root-URL: http://www.cs.toronto.edu
Title: for his useful comments on the weaknesses  spent some of their valuable time  
Author: Prof. A. O. Mendelzon, Dimitris Plexousakis and Thodoros Topaloglou My lab and office-mates, George, Dimitra, Makis, Anna, Roni, Kari, Robert, Paul, 
Degree: of the thesis.  proofreading this thesis and suggesting technical improvements.  
Affiliation: Computer Science Department.  
Note: Acknowledgements First and foremost, I would like to thank my supervisor, Prof. A. Bonner, for his guidance, advice and supervision towards the completion of this thesis. I am also indebted to my second reader,  Weijun, and Franscois provided a peaceful and stimulating working environment. This thesis would have been impossible to complete, without the generous financial support of the  Last, but not least, I thank my parents, for I owe them my intellectual and moral stature. iv  
Abstract: I am most indebted to my barbecue and bouzouki night colleagues, and friends for life, George Charalabopoulos together with whom I strove towards the accomplishment of our goals Nick Liodakis, Dimitris Plexousakis, Voula Dakanali Plexousaki, and Thodoros Topaloglou, for being a constant source of support and advise. 
Abstract-found: 1
Intro-found: 1
Reference: [AV88] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural and Declarative Database Update Languages. </title> <booktitle> In Proc. 7th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, </booktitle> <pages> pages 240-250, </pages> <month> March </month> <year> 1988. </year>
Reference: [AvE82] <author> K. R. Apt and M. H. van Emden. </author> <title> Contributions to the theory of Logic Programming. </title> <journal> Journal of ACM, </journal> <volume> 29(3) </volume> <pages> 841-862, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Overview of Classical Horn Logic 10 answers for the query with regard to P . In the sequel, we outline the existing computational approaches for query processing. 2.2.1 Bottom-Up Evaluation The bottom-up approach (also known as forward chaining) corresponds to the fixpoint semantics of Horn logic <ref> [vEK76, AvE82, Llo87] </ref>. The computed fixpoint corresponds to that portion of the program that is relevant to the query. Computation starts by selecting the relevant clauses and predicates. 1 Bottom-up methods are iterative. Each iteration step, n, proceeds as follows: Each predicate denotes an extensional or intensional database relation. <p> The process is repeated until the goal list becomes empty (success), or no new unifying rules can be found (failure). The most well-known framework for top-down evaluation methods is SLD resolution <ref> [AvE82, Llo87] </ref>. Intuitively, a top-down answer procedure involves the construction of a tree-like search space and a method to traverse it seeking answers for the query. The procedure manipulates tuples or small sets of tuples. The most common search spaces are SLD-trees [AvE82, Llo87] and Rule/Goal trees [Ull89b]. 2.2.3 Top-Down vs <p> framework for top-down evaluation methods is SLD resolution <ref> [AvE82, Llo87] </ref>. Intuitively, a top-down answer procedure involves the construction of a tree-like search space and a method to traverse it seeking answers for the query. The procedure manipulates tuples or small sets of tuples. The most common search spaces are SLD-trees [AvE82, Llo87] and Rule/Goal trees [Ull89b]. 2.2.3 Top-Down vs Bottom-Up In the following we make a brief comparison of top-down and bottom-up methods. A detailed discussion appears in [Ull89b]. Completeness and Termination Bottom-up evaluation always converges to the least fixpoint, and it terminates whenever the latter is finite. <p> In this chapter we develop two theoretical frameworks for top-down evaluation methods that satisfy this requirement. In particular, we extend SLD resolution <ref> [AvE82] </ref> and SLD-AL resolution [Vie87, Vie88, Vie89] to SLD T R and SLD-AL T R resolution, respectively. SLD resolution is probably the most widely used framework for query processing in Horn logic, because of its efficiency and its completeness property (e.g., [Llo87]). <p> Top-down proof procedures are based on the resolution inference rule [Rob65]. SLD resolution is a refinement of this rule, first described by Kowalski [Kow74]. The name "SLD resolution" was given in <ref> [AvE82] </ref>, and stands for Linear resolution with Selection function for Definite clauses. In this section we define SLD T R resolution by extending SLD resolution to account for transaction execution on paths. <p> This path is a possible execution path. In the following we formalize the above discussion. We first define SLD T R derivations, extending the definition of SLD derivations in <ref> [AvE82] </ref>. Definition 6.1 ( SLD T R derivations) Let P = (B; P; D 0 ) be a definite T R -program, N a negative clause, and D 0 ; D 1 ; : : : a database sequence.
Reference: [BK93] <author> Anthony J. Bonner and Michael Kifer. </author> <title> Transaction Logic Programming. </title> <type> Technical Report CSRI-270, </type> <institution> Computer Systems Research Institute, University of Toronto, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: A instance of a previously processed goal consumes the facts generated by that goal and uses them in inferences. Chapter 3 Transaction Logic Programming This chapter introduces Transaction Logic. We outline the semantics of the logic and give the main definitions. The interested reader is referred to <ref> [BK93] </ref> for an in-depth development. Section 3.1 is brief introduction to the main characteristics of T R . Section 3.2 specifies the structure and the syntax of T R programs. Section 3.3 introduces Horn-T R , an important fragment of the logic, which is an extension of classical Horn-clause logic. <p> Furthermore, since a transaction may query any database state on its path of execution, the variable substitutions do not depend only on the initial database state. Transaction execution in T R is defined via the notion of executional entailment <ref> [BK93] </ref>. Definition 3.9 (Executional Entailment ) Let B be a transition base and P be a transaction base. Let ff be a closed transaction formula, and let D 0 ; D 1 ; : : : ; D n be a sequence of databases (first-order formulae). <p> They give rise, however, to different proof procedures. Bonner and Kifer 4. Semantics of Definite T R Programs 38 <ref> [BK93] </ref> describe two proof systems based on these two interpretations. Fixpoint concepts cast more light on the semantics of definite T R programs, and they provide another link between the declarative and procedural semantics. <p> Elementary updates on derived data do not take into account the rules of the transaction base. Example 5.6 (Updates on derived data/Bulk updates) Updates of the form [r := q] are called bulk updates <ref> [BK93] </ref>. The update [r := q] copies the contents of the relation for q into the relation for r. Previous contents of the relation for r are lost. <p> As we will see, the success path structure of P is equal to the least Herbrand model of P , M P . 6.1.2 Soundness of SLD T R resolution The following lemma in <ref> [BK93] </ref> lists some properties of executional entailment, which we use to prove the soundness of SLD T R resolution. 6. Top-Down Execution of Definite T R Programs 92 Lemma 6.1 (Basic Properties of Executional Entailment [BK93]) For any transition base B, any transaction base P, any database sequence D 0 ; <p> , M P . 6.1.2 Soundness of SLD T R resolution The following lemma in <ref> [BK93] </ref> lists some properties of executional entailment, which we use to prove the soundness of SLD T R resolution. 6. Top-Down Execution of Definite T R Programs 92 Lemma 6.1 (Basic Properties of Executional Entailment [BK93]) For any transition base B, any transaction base P, any database sequence D 0 ; : : : ; D n , and any transaction formulae ff and fi, the following statements are all true: 1. <p> Their comparison for deterministic transactions is an open problem. Chapter 7 Conclusions and Directions for Further Research In the preceding chapters we cast light on the semantics of Horn-T R programs, complementing the analysis of Bonner and Kifer <ref> [BK93] </ref>, and investigated the evaluation of these programs. We showed that existing evaluation methods for classical Horn logic can be extended in a natural way to Horn-T R , providing frameworks for both bottom-up and top-down evaluation. <p> Second, we provided a fixpoint semantics, which casts more light on the meaning of Horn-T R programs, and proved it to be equivalent to the model-theoretic semantics. These results enhance the theoretical foundation of <ref> [BK93] </ref> for transaction execu tion. * The investigation of bottom-up evaluation methods for Horn-T R programs. The objectives were the achievement of good performance and the exploitation of existing technology for bottom-up evaluation of classical Horn programs.
Reference: [BLV93] <author> P. Bayer, A. Lefebvre, and L. Vieille. </author> <title> Architecture and Design of the EKS Deductive Database System. </title> <note> Submitted to the special issue of the VLDB Journal on Prototypes of Deductive Database Systems, </note> <year> 1993. </year>
Reference: [BMSU87] <author> F. Bancilhon, D. Maier, U. Sagiv, and J. D. Ullman. </author> <title> Magic Sets and Other Strange Ways to Implement Logic Programs. </title> <booktitle> In Proc. 5th ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <year> 1987. </year>
Reference-contexts: The objective is to simulate the top-down evaluation of the original program through bottom-up evaluation, so that computation is limited to relevant data. The fundamental method for general Horn programs is the Magic Sets method <ref> [RLK86, BMSU87, Ull89b] </ref>, and its extensions [Ull89b, Sek89, Ram88]. A plethora of specialized methods for increased performance appears in the literature [BMSU87, Ull89b]. Run-time methods Run-time methods are also referred to as memoing methods [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89]. <p> The fundamental method for general Horn programs is the Magic Sets method [RLK86, BMSU87, Ull89b], and its extensions [Ull89b, Sek89, Ram88]. A plethora of specialized methods for increased performance appears in the literature <ref> [BMSU87, Ull89b] </ref>. Run-time methods Run-time methods are also referred to as memoing methods [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89]. The concept is to remember (memo) previously computed answers and reuse them when needed. The search space consists of a network of producers and consumers. <p> We show that we can add such control into bottom-up evaluation of Horn-T R programs through existing rule rewriting techniques. Before we discuss the necessity for adding top-down control, and show how this can be accomplished through existing rule rewriting methods, we describe the Magic Sets transformation method <ref> [BMSU87, Ull89b] </ref>, which is the most general of these methods. The Magic Sets Transformation We will use a classical example to explain the basic principles of the method.
Reference: [BR87] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of magic. </title> <booktitle> In Proc. 6th ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <year> 1987. </year> <pages> 135 136 </pages>
Reference-contexts: Overview of Classical Horn Logic 13 Compile-time methods Compile-time methods transform a logic program with respect to a query, so that a more efficient program is generated and evaluated in a bottom-up fashion. Transformation involves rule rewriting, based on a sideways information passing strategy (sip) and a control strategy <ref> [BR87, vG86] </ref>. Sip determines how information (variable bindings) about some subgoals in a rule is used to evaluate other subgoals in the rule, and the control strategy implements this (possibly using other optimizations as well).
Reference: [BR88] <author> F. Bancilhon and R. Ramakrishnan. </author> <title> Perfomance Evaluation of Data Intensive Logic Programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 439-511. </pages> <publisher> Morgan Kaufman, </publisher> <year> 1988. </year>
Reference-contexts: Section 2.2 describes three different approaches for query evaluation, namely bottom-up, top-down and combinations of these. It also makes a short comparison of these approaches. An elaborate presentation of evaluation methods appears in [Ull89b], and a detailed comparison of certain methods in <ref> [BR88] </ref>. 2.1 Notation and Informal Semantics In what follows we assume that the reader is familiar with the basics of first-order logic [End72]. [Llo87] is a detailed exposition of Horn logic.
Reference: [Bra91] <author> I. Bratko. </author> <title> Prolog programming for artificial intelligence. </title> <publisher> Addison-Wesley, </publisher> <address> Wokingham, England, 2nd edition, </address> <year> 1991. </year>
Reference-contexts: This is particularly true in the presence of cyclic data and updates, and unfortunately, it is true even for queries. This is the reason that SLD refutation procedures are not necessarily complete. Prolog <ref> [Bra91] </ref>, for instance, might get caught in a infinite branch of an SLD tree, and fail to terminate or return all answers to a given query.
Reference: [CKRP73] <author> A. Colmerauer, H. Kanoui, P. Roussel, and R. Pasero. </author> <title> Un Systeme de Communication Homme-Machine en Francais, 1973. </title> <institution> Groupe de Recherche en Intelligence Artificielle, Universite d' Aix-Marseille. </institution>
Reference-contexts: 1. Introduction 5 transactions. Chapter 7 draws conclusions and provides guidelines for future research. Chapter 2 Overview of Classical Horn Logic Classical Horn logic [Llo87] emerged from Kowalski [Kow74] and Colmerauer's <ref> [CKRP73] </ref> idea that logic can be used as a programming language, and since then has served as the basis for many declarative programming languages. This has been achieved through the assignment of procedural semantics to Horn logic, which allows users to execute programs.
Reference: [Die87] <author> S. W. Dietrich. </author> <title> Extension tables: memo relations in logic programming. </title> <booktitle> In Proc. 1987 Symp. on Logic Programming, </booktitle> <pages> pages 264-272. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1987. </year>
Reference-contexts: The fundamental method for general Horn programs is the Magic Sets method [RLK86, BMSU87, Ull89b], and its extensions [Ull89b, Sek89, Ram88]. A plethora of specialized methods for increased performance appears in the literature [BMSU87, Ull89b]. Run-time methods Run-time methods are also referred to as memoing methods <ref> [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89] </ref>. The concept is to remember (memo) previously computed answers and reuse them when needed. The search space consists of a network of producers and consumers. The computation proceeds in a top-down fashion, resolving goals and producing answers. <p> SLD resolution is probably the most widely used framework for query processing in Horn logic, because of its efficiency and its completeness property (e.g., [Llo87]). SLD proof procedures, however, are not necessarily complete (e.g., [Llo87]). SLD-AL resolution is one of the approaches proposed as alternatives to SLD resolution <ref> [MS81, Loz85, vG86, TS86, Die87, Vie87, Vie88, Vie89] </ref>. SLD-AL resolution extends SLD resolution to guarantee completeness for proof procedures in the finite, function-free case, and allows for optimizations that account for the best-known query evaluation methods [Vie88, Vie89]. <p> Recognizing the similarity of sub-queries in SLD trees, one could avoid some infinite branches. Furthermore, new occurrences of a subgoal could be resolved against existing answers of that subgoal, to cut down on computation. The above two ideas form the basis of the memoing techniques in classical Horn logic <ref> [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89] </ref>. The latest ad 6. Top-Down Execution of Definite T R Programs 108 vance in memoing techniques is SLD-AL resolution, proposed by Vieille as an extension of SLD resolution [Vie87, Vie88, Vie89].
Reference: [Elk90] <author> Charles Elkan. </author> <title> Independence of Logic Queries and Updates. </title> <booktitle> In Proc. 9th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, </booktitle> <pages> pages 154-160, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: In Horn-T R , however, ordering flexibility is limited due to the presence of updates. Updates create dependencies between transactions. We give the definition of independence for transactions analogously to the definition of independence of queries and updates in <ref> [Elk90] </ref>. Definition 5.3 (Independence) We call a transaction, t 1 , independent of another transaction, t 2 , if t 2 cannot change the result of t 1 . We call transactions t 1 ; : : : ; t n independent, if each one is independent of the others. <p> Bottom-Up Execution of Definite T R Programs 71 If transactions t 1 ; : : : ; t n are independent, then their execution yields the same final result for any order. Otherwise, t 1 and t 2 must be serialized. Unfortunately, independence of queries and updates is undecidable <ref> [Elk90] </ref>. Therefore, transaction independence is also undecidable. Deciding independence of subgoals in rule bodies is an important issue for our work, for the following reasons. Assume that t 1 and t 2 are two not independent transactions.
Reference: [End72] <author> H. B. Enderton. </author> <title> A mathematical introduction to logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1972. </year>
Reference-contexts: It also makes a short comparison of these approaches. An elaborate presentation of evaluation methods appears in [Ull89b], and a detailed comparison of certain methods in [BR88]. 2.1 Notation and Informal Semantics In what follows we assume that the reader is familiar with the basics of first-order logic <ref> [End72] </ref>. [Llo87] is a detailed exposition of Horn logic. Horn Clauses A clause (or rule) is a pair of sets of atomic formulae written as ff 1 & : : : & ff m fi 1 & : : : & fi n ; m; n 0: 2.
Reference: [GMN84] <author> H. Gallaire., J. Minker, and J. M. Nicholas. </author> <title> Logic and databases: a deductive approach. </title> <journal> ACM Computing Surveys, </journal> <volume> 16(2), </volume> <month> June </month> <year> 1984. </year>
Reference: [GMS93] <author> A. Gupta, I. S. Mumick, and V. S. Subrahmanian. </author> <title> Maintaining Views Incrementally. </title> <booktitle> ACM SIGMOD Int. Conf. On Management of Data, </booktitle> <pages> pages 157-166, </pages> <year> 1993. </year>
Reference-contexts: Thus, instead of evaluating a derived predicate from the very beginning for each of its database inputs, it would be advantageous to propagate the changes from stored relations to that derived relation. This is similar to incremental view maintenance (e.g., <ref> [GMS93] </ref>). Bottom-up processing works well for queries; it is challenging to investigate whether bottom-up evaluation can be embedded in a top-down evaluation method. Queries do not change database states. In effect, they do not affect the control for rejecting alternative paths.
Reference: [GN87] <author> M. Genesereth and N. Nilsson. </author> <booktitle> Logical Foundations of Artificial Intelligence. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1987. </year> <month> 137 </month>
Reference: [KM90] <author> H. Katsuno and A. O. Mendelzon. </author> <title> On the Difference between Updating a Knowledge Base and Revising it. </title> <type> Technical Report KRR-TR-90-6, </type> <institution> Department of Computer Science, University of Toronto, Toronto, </institution> <year> 1990. </year>
Reference-contexts: Elementary updates are treated as a parameter of the logic. The rationale behind this approach is that changes to logical theories belong to several classes with distinct semantics. For example, researchers distinguish between change recording updates and revisions (e.g., <ref> [Win88, KM90] </ref>). One can therefore distinguish several update operators. T R can easily be augmented with new update operators by inserting appropriate axioms into the transition base, with no modifications to the model or the proof theory of the logic.
Reference: [Kow74] <author> R. A. Kowalski. </author> <title> Predicate Logic as a Programming Language. </title> <booktitle> In Information Processing 74, </booktitle> <pages> pages 569-574, </pages> <year> 1974. </year>
Reference-contexts: 1. Introduction 5 transactions. Chapter 7 draws conclusions and provides guidelines for future research. Chapter 2 Overview of Classical Horn Logic Classical Horn logic [Llo87] emerged from Kowalski <ref> [Kow74] </ref> and Colmerauer's [CKRP73] idea that logic can be used as a programming language, and since then has served as the basis for many declarative programming languages. This has been achieved through the assignment of procedural semantics to Horn logic, which allows users to execute programs. <p> Top-down proof procedures are based on the resolution inference rule [Rob65]. SLD resolution is a refinement of this rule, first described by Kowalski <ref> [Kow74] </ref>. The name "SLD resolution" was given in [AvE82], and stands for Linear resolution with Selection function for Definite clauses. In this section we define SLD T R resolution by extending SLD resolution to account for transaction execution on paths.
Reference: [Llo87] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1987. </year>
Reference-contexts: 1. Introduction 5 transactions. Chapter 7 draws conclusions and provides guidelines for future research. Chapter 2 Overview of Classical Horn Logic Classical Horn logic <ref> [Llo87] </ref> emerged from Kowalski [Kow74] and Colmerauer's [CKRP73] idea that logic can be used as a programming language, and since then has served as the basis for many declarative programming languages. This has been achieved through the assignment of procedural semantics to Horn logic, which allows users to execute programs. <p> It also makes a short comparison of these approaches. An elaborate presentation of evaluation methods appears in [Ull89b], and a detailed comparison of certain methods in [BR88]. 2.1 Notation and Informal Semantics In what follows we assume that the reader is familiar with the basics of first-order logic [End72]. <ref> [Llo87] </ref> is a detailed exposition of Horn logic. Horn Clauses A clause (or rule) is a pair of sets of atomic formulae written as ff 1 & : : : & ff m fi 1 & : : : & fi n ; m; n 0: 2. <p> Overview of Classical Horn Logic 10 answers for the query with regard to P . In the sequel, we outline the existing computational approaches for query processing. 2.2.1 Bottom-Up Evaluation The bottom-up approach (also known as forward chaining) corresponds to the fixpoint semantics of Horn logic <ref> [vEK76, AvE82, Llo87] </ref>. The computed fixpoint corresponds to that portion of the program that is relevant to the query. Computation starts by selecting the relevant clauses and predicates. 1 Bottom-up methods are iterative. Each iteration step, n, proceeds as follows: Each predicate denotes an extensional or intensional database relation. <p> The process is repeated until the goal list becomes empty (success), or no new unifying rules can be found (failure). The most well-known framework for top-down evaluation methods is SLD resolution <ref> [AvE82, Llo87] </ref>. Intuitively, a top-down answer procedure involves the construction of a tree-like search space and a method to traverse it seeking answers for the query. The procedure manipulates tuples or small sets of tuples. The most common search spaces are SLD-trees [AvE82, Llo87] and Rule/Goal trees [Ull89b]. 2.2.3 Top-Down vs <p> framework for top-down evaluation methods is SLD resolution <ref> [AvE82, Llo87] </ref>. Intuitively, a top-down answer procedure involves the construction of a tree-like search space and a method to traverse it seeking answers for the query. The procedure manipulates tuples or small sets of tuples. The most common search spaces are SLD-trees [AvE82, Llo87] and Rule/Goal trees [Ull89b]. 2.2.3 Top-Down vs Bottom-Up In the following we make a brief comparison of top-down and bottom-up methods. A detailed discussion appears in [Ull89b]. Completeness and Termination Bottom-up evaluation always converges to the least fixpoint, and it terminates whenever the latter is finite. <p> In this chapter we discuss program semantics from two different, though interrelated, viewpoints, namely a model-theoretic and a proof-theoretic viewpoint. In Section 4.1 we define the model-theoretic semantics of definite Horn-T R programs in analogy to the definition of the model-theoretic semantics of classical definite programs <ref> [Llo87] </ref>. In Section 4.2 we define the proof-theoretic semantics of definite programs through fixpoints, and we prove it to be equivalent to the model-theoretic semantics. <p> As shown by Proposition 4.2 below, the intersection of all Herbrand models of P is a model. This property is analogous to the model intersection property for classical Horn programs <ref> [Llo87] </ref>. We prove that this model consists precisely of those facts that can be proven using the rules and elementary transitions in P . <p> Let s 2 N = T N i . Then, for each model M i , I path i (&lt;s&gt;) 2 s. Since s corresponds to a database mentioned in the transition base, s is closed under first-order semantic structure intersection <ref> [Llo87] </ref>. Thus, T I path i (&lt;s&gt;) 2 s, that is, I path (&lt;s&gt;) 2 s. Unfortunately, the union of two path structures may not be a valid path structure. For example, assume that a database, D, consists of the single rule ff fi & fl. <p> This result increases our understanding of the meaning of definite T R programs. Furthermore, it will form the basis of a bottom-up evaluation method for these programs. We first provide some preliminaries on fixpoints. A detailed presentation and the proofs of all propositions appear in <ref> [Llo87] </ref>. <p> For each model m 2 s, there is a Herbrand path structure, M, such that I M path (&lt;s&gt;) = m. Hence, the intersection T I path M (&lt;s&gt;) is over all models of the database D. By the model intersection property for classical Horn programs <ref> [Llo87] </ref>, we have that I path ? (&lt;s&gt;) is the least model of D. Clearly, I path ? () = fg, if the length of is greater than one. <p> In particular, we extend SLD resolution [AvE82] and SLD-AL resolution [Vie87, Vie88, Vie89] to SLD T R and SLD-AL T R resolution, respectively. SLD resolution is probably the most widely used framework for query processing in Horn logic, because of its efficiency and its completeness property (e.g., <ref> [Llo87] </ref>). SLD proof procedures, however, are not necessarily complete (e.g., [Llo87]). SLD-AL resolution is one of the approaches proposed as alternatives to SLD resolution [MS81, Loz85, vG86, TS86, Die87, Vie87, Vie88, Vie89]. <p> SLD resolution is probably the most widely used framework for query processing in Horn logic, because of its efficiency and its completeness property (e.g., <ref> [Llo87] </ref>). SLD proof procedures, however, are not necessarily complete (e.g., [Llo87]). SLD-AL resolution is one of the approaches proposed as alternatives to SLD resolution [MS81, Loz85, vG86, TS86, Die87, Vie87, Vie88, Vie89]. <p> : : : ff s1 & ff s & ff s+1 : : : ] rest ) 1 : : : n : 6.1.3 Completeness of SLD T R resolution We prove the completeness of SLD T R resolution based on the respective proof for of SLD resolution given in <ref> [Llo87] </ref>. Lemma 6.2 (Mgu Lemma for SLD T R resolution) Let P be a definite T R program and N a definite goal. Suppose that N has an unrestricted SLD T R refutation on a path, . <p> there exists a substitution fl such that 1 ; : : : ; n = 0 1 ; : : : ; 0 Proof Noting that the most general unifier is the only unifier for an atom and a head of an elementary transition, the result is proved as in <ref> [Llo87] </ref>. 6. Top-Down Execution of Definite T R Programs 96 Lemma 6.3 (Lifting Lemma for SLD T R resolution) Let P be a definite T R program, N a definite goal, and a substitution. Suppose there exists an SLD T R refutation of N on a path, . <p> the SLD T R refutation of N , and 0 n are the mgu's from the SLD T R refutation of N , then there exists a substitution, fl, such that 1 ; : : : ; n = 0 1 ; : : : ; 0 Proof As in <ref> [Llo87] </ref>. Theorem 6.2 The success path structure of a definite program P is equal to its least Herbrand model. Proof Let I path and I M P path be the mappings of the success path structure and the least Herbrand model of P , respectively. <p> Then, there exists an SLD T R refutation of ff on , such that the substitution of the computed answer is the identity. Proof As in <ref> [Llo87] </ref>. The major completeness result follows. 1 If fl is a serial conjunction, this order is from left to right. If shu*e operators appear in fl, the order might be different. 6. <p> One selection function might lead to a failed derivation, while another leads to a successful one. In SLD resolution, refutation procedures are independent of the selection function, i.e., any choice of selection function leads to a complete search space <ref> [Llo87] </ref>. This is true, because queries do not have side effects. This property reduces the search space, and allows SLD refutation procedures to focus on the search strategy. For these reasons, we would like SLD T R refutation procedures to have this property. This is not hard to achieve. <p> Experienced Prolog programmers know how to write programs to prevent Prolog's interpreter from getting stuck in an infinite branch, but this is not always possible <ref> [Llo87, Ull89b] </ref>. In Horn-T R , this is particularly true for updating transactions, because it is the nature of updates that does not allow much flexibility in writing a program. Thus, for some programs, any top-down search procedure based on SLD T R resolution fails to terminate. <p> search strategy, if (; ) is a correct partial answer for N , there exists a computed answer, (oe; ), for N and a substitution, fl, such that = oefl. 2 This definition of fairness is more appropriate than the definition of fairness of search strategies for SLD trees in <ref> [Llo87] </ref>, since SLD trees are defined statically, while SLD-AL T R trees are defined by specifying the way they are constructed. 6. Top-Down Execution of Definite T R Programs 124 A coarse characterization of search strategies for SLD-AL T R resolution divides them into 2-phase and 1-phase.
Reference: [Loz85] <author> E. L. Lozinskii. </author> <title> Evaluating queries in a deductive database by generating. </title> <booktitle> In Proc. 9th IJCAI, </booktitle> <pages> pages 173-177, </pages> <year> 1985. </year>
Reference-contexts: The fundamental method for general Horn programs is the Magic Sets method [RLK86, BMSU87, Ull89b], and its extensions [Ull89b, Sek89, Ram88]. A plethora of specialized methods for increased performance appears in the literature [BMSU87, Ull89b]. Run-time methods Run-time methods are also referred to as memoing methods <ref> [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89] </ref>. The concept is to remember (memo) previously computed answers and reuse them when needed. The search space consists of a network of producers and consumers. The computation proceeds in a top-down fashion, resolving goals and producing answers. <p> SLD resolution is probably the most widely used framework for query processing in Horn logic, because of its efficiency and its completeness property (e.g., [Llo87]). SLD proof procedures, however, are not necessarily complete (e.g., [Llo87]). SLD-AL resolution is one of the approaches proposed as alternatives to SLD resolution <ref> [MS81, Loz85, vG86, TS86, Die87, Vie87, Vie88, Vie89] </ref>. SLD-AL resolution extends SLD resolution to guarantee completeness for proof procedures in the finite, function-free case, and allows for optimizations that account for the best-known query evaluation methods [Vie88, Vie89]. <p> Recognizing the similarity of sub-queries in SLD trees, one could avoid some infinite branches. Furthermore, new occurrences of a subgoal could be resolved against existing answers of that subgoal, to cut down on computation. The above two ideas form the basis of the memoing techniques in classical Horn logic <ref> [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89] </ref>. The latest ad 6. Top-Down Execution of Definite T R Programs 108 vance in memoing techniques is SLD-AL resolution, proposed by Vieille as an extension of SLD resolution [Vie87, Vie88, Vie89].
Reference: [MS81] <author> D. McKay and S. Shapiro. </author> <title> Using active connection graphs for reasoning with recursive rules. </title> <booktitle> In Proceedings 7th IJCAI, </booktitle> <pages> pages 368-374, </pages> <year> 1981. </year>
Reference-contexts: The fundamental method for general Horn programs is the Magic Sets method [RLK86, BMSU87, Ull89b], and its extensions [Ull89b, Sek89, Ram88]. A plethora of specialized methods for increased performance appears in the literature [BMSU87, Ull89b]. Run-time methods Run-time methods are also referred to as memoing methods <ref> [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89] </ref>. The concept is to remember (memo) previously computed answers and reuse them when needed. The search space consists of a network of producers and consumers. The computation proceeds in a top-down fashion, resolving goals and producing answers. <p> SLD resolution is probably the most widely used framework for query processing in Horn logic, because of its efficiency and its completeness property (e.g., [Llo87]). SLD proof procedures, however, are not necessarily complete (e.g., [Llo87]). SLD-AL resolution is one of the approaches proposed as alternatives to SLD resolution <ref> [MS81, Loz85, vG86, TS86, Die87, Vie87, Vie88, Vie89] </ref>. SLD-AL resolution extends SLD resolution to guarantee completeness for proof procedures in the finite, function-free case, and allows for optimizations that account for the best-known query evaluation methods [Vie88, Vie89]. <p> Recognizing the similarity of sub-queries in SLD trees, one could avoid some infinite branches. Furthermore, new occurrences of a subgoal could be resolved against existing answers of that subgoal, to cut down on computation. The above two ideas form the basis of the memoing techniques in classical Horn logic <ref> [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89] </ref>. The latest ad 6. Top-Down Execution of Definite T R Programs 108 vance in memoing techniques is SLD-AL resolution, proposed by Vieille as an extension of SLD resolution [Vie87, Vie88, Vie89].
Reference: [NK88] <author> S. Naqvi and R. Krishnamurthy. </author> <title> Database updates in logic programming. </title> <booktitle> In Proc. 7th ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems, </booktitle> <pages> pages 251-262, </pages> <month> March </month> <year> 1988. </year>
Reference: [NT89] <author> S. Naqvi and S. Tsur. </author> <title> A Logical Language for Data and Kowledge Bases. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference: [Ram88] <author> R. Ramakrishnan. </author> <title> Magic Templates: A Spelling Approach to Logic Programs. </title> <booktitle> In Proc. 5th International Conference and Symp. on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <year> 1988. </year>
Reference-contexts: The objective is to simulate the top-down evaluation of the original program through bottom-up evaluation, so that computation is limited to relevant data. The fundamental method for general Horn programs is the Magic Sets method [RLK86, BMSU87, Ull89b], and its extensions <ref> [Ull89b, Sek89, Ram88] </ref>. A plethora of specialized methods for increased performance appears in the literature [BMSU87, Ull89b]. Run-time methods Run-time methods are also referred to as memoing methods [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89]. The concept is to remember (memo) previously computed answers and reuse them when needed.
Reference: [Rei92] <author> R. Reiter. </author> <title> On Specifying Database Updates. </title> <type> Technical Report KRR-TR-92-3, </type> <institution> Department of Computer Science, University of Toronto, Toronto, </institution> <year> 1992. </year>
Reference: [RFV83] <author> J. D. Ullman R. Fagin and M. Y. Vardi. </author> <title> On the Semantics of Updates in Databases. </title> <booktitle> In Proc. of the 2nd ACM Symp. on the Principles of Database Systems, </booktitle> <pages> pages 16-33, </pages> <month> April </month> <year> 1983. </year> <month> 138 </month>
Reference: [RLK86] <author> J. Rohmer, R. Lescouer, and J. M. Kerisit. </author> <title> The Alexander Method A Technique for the Processing of Recursive Axioms in Deductive Databases. </title> <journal> New Generation Computing, </journal> <volume> 4(3) </volume> <pages> 273-285, </pages> <year> 1986. </year>
Reference-contexts: The objective is to simulate the top-down evaluation of the original program through bottom-up evaluation, so that computation is limited to relevant data. The fundamental method for general Horn programs is the Magic Sets method <ref> [RLK86, BMSU87, Ull89b] </ref>, and its extensions [Ull89b, Sek89, Ram88]. A plethora of specialized methods for increased performance appears in the literature [BMSU87, Ull89b]. Run-time methods Run-time methods are also referred to as memoing methods [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89].
Reference: [Rob65] <author> J. A. Robinson. </author> <title> A machine oriented logic based on the resolution principle. </title> <journal> Journal of ACM, </journal> <volume> 12(1) </volume> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: According to this approach, a rule, ff fi, is regarded as a procedure definition, where ff is the name of the procedure, and fi is its body. A query is considered to be a list of procedure calls. The notion of execution is materialized by Robinson's resolution principle <ref> [Rob65] </ref>. A goal is resolved with a clause whose head unifies (i.e., matches) with the goal, that is, it is replaced with the body of the clause by applying the unifying substitution to the rule and to the goal list. <p> Top-down proof procedures are based on the resolution inference rule <ref> [Rob65] </ref>. SLD resolution is a refinement of this rule, first described by Kowalski [Kow74]. The name "SLD resolution" was given in [AvE82], and stands for Linear resolution with Selection function for Definite clauses.
Reference: [Sek89] <author> H. Seki. </author> <title> On the Power of Alexander Templates. </title> <booktitle> In Proc. 8th ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems, </booktitle> <pages> pages 150-159, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: The objective is to simulate the top-down evaluation of the original program through bottom-up evaluation, so that computation is limited to relevant data. The fundamental method for general Horn programs is the Magic Sets method [RLK86, BMSU87, Ull89b], and its extensions <ref> [Ull89b, Sek89, Ram88] </ref>. A plethora of specialized methods for increased performance appears in the literature [BMSU87, Ull89b]. Run-time methods Run-time methods are also referred to as memoing methods [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89]. The concept is to remember (memo) previously computed answers and reuse them when needed.
Reference: [Shm87] <author> O. Shmueli. </author> <title> Decidability and Expressiveness Aspects of Logic Queries. </title> <booktitle> In Proc. 6th ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems, </booktitle> <pages> pages 237-249, </pages> <year> 1987. </year>
Reference-contexts: Specifically, we cannot decide if there is a subset of a set of given rules that computes the same answer for a given query as the original set <ref> [Shm87] </ref>. In fact, relevance is a runtime notion, and for each query, relevant data are those produced during a top-down evaluation of the goal. As a result, we select potentially relevant rules. 2.
Reference: [TS86] <author> H. Tamaki and T. Sato. </author> <title> OLD Resolution with Tabulation. </title> <booktitle> In Proc. 3rd Int. Conf. on Logic Programming, </booktitle> <pages> pages 84-98, </pages> <year> 1986. </year>
Reference-contexts: The fundamental method for general Horn programs is the Magic Sets method [RLK86, BMSU87, Ull89b], and its extensions [Ull89b, Sek89, Ram88]. A plethora of specialized methods for increased performance appears in the literature [BMSU87, Ull89b]. Run-time methods Run-time methods are also referred to as memoing methods <ref> [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89] </ref>. The concept is to remember (memo) previously computed answers and reuse them when needed. The search space consists of a network of producers and consumers. The computation proceeds in a top-down fashion, resolving goals and producing answers. <p> SLD resolution is probably the most widely used framework for query processing in Horn logic, because of its efficiency and its completeness property (e.g., [Llo87]). SLD proof procedures, however, are not necessarily complete (e.g., [Llo87]). SLD-AL resolution is one of the approaches proposed as alternatives to SLD resolution <ref> [MS81, Loz85, vG86, TS86, Die87, Vie87, Vie88, Vie89] </ref>. SLD-AL resolution extends SLD resolution to guarantee completeness for proof procedures in the finite, function-free case, and allows for optimizations that account for the best-known query evaluation methods [Vie88, Vie89]. <p> Recognizing the similarity of sub-queries in SLD trees, one could avoid some infinite branches. Furthermore, new occurrences of a subgoal could be resolved against existing answers of that subgoal, to cut down on computation. The above two ideas form the basis of the memoing techniques in classical Horn logic <ref> [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89] </ref>. The latest ad 6. Top-Down Execution of Definite T R Programs 108 vance in memoing techniques is SLD-AL resolution, proposed by Vieille as an extension of SLD resolution [Vie87, Vie88, Vie89]. <p> Top-Down Execution of Definite T R Programs 126 A Multistage Depth-first Strategy A Multistage depth-first strategy is proposed in <ref> [TS86] </ref> to handle function symbols. We define a multistage depth-first strategy for SLD-AL T R resolution below, modifying slightly the definition given in [TS86]. We show that the multistage depth-first strategy guarantees completeness when all branches are finite. <p> Top-Down Execution of Definite T R Programs 126 A Multistage Depth-first Strategy A Multistage depth-first strategy is proposed in <ref> [TS86] </ref> to handle function symbols. We define a multistage depth-first strategy for SLD-AL T R resolution below, modifying slightly the definition given in [TS86]. We show that the multistage depth-first strategy guarantees completeness when all branches are finite.
Reference: [Ull89a] <author> J. D. Ullman. </author> <booktitle> Principles of Database and Knowledge Base Systems, </booktitle> <volume> volume 1. </volume> <publisher> Computer Science Press, </publisher> <address> Rockville, Maryland, </address> <year> 1989. </year>
Reference-contexts: The iterative process terminates when no new facts are generated for any relation. A final stage selects the facts that comprise the answer to the query. The method just described may generate the same facts several times using the same derivation paths. It is thus called Naive Evaluation <ref> [Ull89a] </ref>. A more efficient method uses the differentials of the sets of facts to generate new facts, and is called Semi-naive Evaluation [Ull89a]. 1 This selection cannot be made optimally. <p> The method just described may generate the same facts several times using the same derivation paths. It is thus called Naive Evaluation <ref> [Ull89a] </ref>. A more efficient method uses the differentials of the sets of facts to generate new facts, and is called Semi-naive Evaluation [Ull89a]. 1 This selection cannot be made optimally. Specifically, we cannot decide if there is a subset of a set of given rules that computes the same answer for a given query as the original set [Shm87]. <p> Assumptions In what follows, we make the following assumptions. First, we are dealing with safe rules <ref> [Ull89a] </ref>. This is because unsafe rules create infinite relations from finite ones. For example, a rule with a variable, X, in the head, that does not appear in the body, is not safe; X may take on an infinite set of values. <p> For example, a rule with a variable, X, in the head, that does not appear in the body, is not safe; X may take on an infinite set of values. Second, for simplicity we do not deal with function symbols. Function symbols can be treated in standard ways <ref> [Ull89a, Ull89b] </ref>. Finally, we assume that for each intensional predicate, p, all rules for p are rectified [Ull89a]. <p> Second, for simplicity we do not deal with function symbols. Function symbols can be treated in standard ways [Ull89a, Ull89b]. Finally, we assume that for each intensional predicate, p, all rules for p are rectified <ref> [Ull89a] </ref>. This means that all their heads are identical, of the form p (X 1 ; : : : ; X n ), for distinct variables X 1 ; : : : ; X n . Any program can be rewritten to satisfy our assumption [Ull89a]. <p> rules for p are rectified <ref> [Ull89a] </ref>. This means that all their heads are identical, of the form p (X 1 ; : : : ; X n ), for distinct variables X 1 ; : : : ; X n . Any program can be rewritten to satisfy our assumption [Ull89a]. Terminology In the rest of this thesis, we use the term "path" to refer to both sequences of states and sequences of databases. The model theory of T R defines satisfiability on sequences of database states (paths), whereas execution, defined through the notion of executional 5. <p> The sets of relations for each fi i , i = 1; : : : ; n, are used to construct the set of relations for the rule body. This is achieved through relational algebra operations <ref> [Ull89a] </ref>. The following example is an informal explanation of how the construction of these relations takes place. Example 5.3 Consider again the rule (r1) f ae (qa) emp (X; qa) del:emp (X; qa) f ae (qa): in Example 5.1. <p> DEL : EMP qa john D 0 D 10 jack D 0 D 11 jack D 10 D 2 john D 11 D 2 : : : F AE 1 2 : : : = 1 jack D 10 D 2 john D 11 D 2 : : : In <ref> [Ull89a] </ref> an algorithm is given for computing the relation for a safe Datalog 1 rule body, using relational algebra operations. The algorithm handles both ordinary and built-in goals. Its input is a rule, r, and a set of relations, R 1 ; : : : ; R n . <p> The only difference is that we compute a set of relations for each rule body. Thus, both the Naive and Semi-naive evaluation methods <ref> [Ull89a] </ref> are applicable. In brief, we start with a set of stored relations, R 1 ; : : : ; R n , and a set of sets of derived relations, P 1 ; : : : ; P m . The latter are initially empty. <p> In classical Horn logic, bottom-up evaluation of a given query is done with respect to the relevant portion of the program. This portion is determined by inspecting the dependency graph of the program <ref> [Ull89a] </ref>. The dependency graph of a program, P , is a graph whose nodes are the ordinary predicates. There is an arc from a predicate, p, to a predicate, q, if there is a rule with a subgoal whose predicate is p and with a head whose predicate is q.
Reference: [Ull89b] <author> J. D. Ullman. </author> <booktitle> Principles of Database and Knowledge Base Systems, </booktitle> <volume> volume 2. </volume> <publisher> Computer Science Press, </publisher> <address> Rockville, Maryland, </address> <year> 1989. </year>
Reference-contexts: Section 2.1 gives the basic syntax and informal semantics of Horn logic. Section 2.2 describes three different approaches for query evaluation, namely bottom-up, top-down and combinations of these. It also makes a short comparison of these approaches. An elaborate presentation of evaluation methods appears in <ref> [Ull89b] </ref>, and a detailed comparison of certain methods in [BR88]. 2.1 Notation and Informal Semantics In what follows we assume that the reader is familiar with the basics of first-order logic [End72]. [Llo87] is a detailed exposition of Horn logic. <p> Intuitively, a top-down answer procedure involves the construction of a tree-like search space and a method to traverse it seeking answers for the query. The procedure manipulates tuples or small sets of tuples. The most common search spaces are SLD-trees [AvE82, Llo87] and Rule/Goal trees <ref> [Ull89b] </ref>. 2.2.3 Top-Down vs Bottom-Up In the following we make a brief comparison of top-down and bottom-up methods. A detailed discussion appears in [Ull89b]. Completeness and Termination Bottom-up evaluation always converges to the least fixpoint, and it terminates whenever the latter is finite. <p> The procedure manipulates tuples or small sets of tuples. The most common search spaces are SLD-trees [AvE82, Llo87] and Rule/Goal trees <ref> [Ull89b] </ref>. 2.2.3 Top-Down vs Bottom-Up In the following we make a brief comparison of top-down and bottom-up methods. A detailed discussion appears in [Ull89b]. Completeness and Termination Bottom-up evaluation always converges to the least fixpoint, and it terminates whenever the latter is finite. Contrary to this, top-down methods may get stuck in loops and not terminate, or may fail to return a complete set of answers. <p> The objective is to simulate the top-down evaluation of the original program through bottom-up evaluation, so that computation is limited to relevant data. The fundamental method for general Horn programs is the Magic Sets method <ref> [RLK86, BMSU87, Ull89b] </ref>, and its extensions [Ull89b, Sek89, Ram88]. A plethora of specialized methods for increased performance appears in the literature [BMSU87, Ull89b]. Run-time methods Run-time methods are also referred to as memoing methods [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89]. <p> The objective is to simulate the top-down evaluation of the original program through bottom-up evaluation, so that computation is limited to relevant data. The fundamental method for general Horn programs is the Magic Sets method [RLK86, BMSU87, Ull89b], and its extensions <ref> [Ull89b, Sek89, Ram88] </ref>. A plethora of specialized methods for increased performance appears in the literature [BMSU87, Ull89b]. Run-time methods Run-time methods are also referred to as memoing methods [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89]. The concept is to remember (memo) previously computed answers and reuse them when needed. <p> The fundamental method for general Horn programs is the Magic Sets method [RLK86, BMSU87, Ull89b], and its extensions [Ull89b, Sek89, Ram88]. A plethora of specialized methods for increased performance appears in the literature <ref> [BMSU87, Ull89b] </ref>. Run-time methods Run-time methods are also referred to as memoing methods [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89]. The concept is to remember (memo) previously computed answers and reuse them when needed. The search space consists of a network of producers and consumers. <p> For example, a rule with a variable, X, in the head, that does not appear in the body, is not safe; X may take on an infinite set of values. Second, for simplicity we do not deal with function symbols. Function symbols can be treated in standard ways <ref> [Ull89a, Ull89b] </ref>. Finally, we assume that for each intensional predicate, p, all rules for p are rectified [Ull89a]. <p> In this way, joins become more massive, i.e., they are computed on larger relations. However, the cost of joins in the first case is higher than the cost of computing a small number of massive joins, in the second case <ref> [Ull89b] </ref>. 5. Bottom-Up Execution of Definite T R Programs 73 5.3 Adding Top-Down Functionality Bottom-up processing exhibits two kinds of data flow. The first is sideways binding passing from one subgoal to another, carried out by joins. The other is bottom-up binding passing, from a rule body to its head. <p> We show that we can add such control into bottom-up evaluation of Horn-T R programs through existing rule rewriting techniques. Before we discuss the necessity for adding top-down control, and show how this can be accomplished through existing rule rewriting methods, we describe the Magic Sets transformation method <ref> [BMSU87, Ull89b] </ref>, which is the most general of these methods. The Magic Sets Transformation We will use a classical example to explain the basic principles of the method. <p> Bottom-Up Execution of Definite T R Programs 75 The new program to be evaluated bottom-up consists of the rules r3, r4, r1 0 and r2 0 . The Magic Sets technique described in <ref> [Ull89b] </ref> transforms a program with respect to a given query. The new program evaluates bottom-up the given query more effectively than the original. The Magic Sets transformation requires that the binding pattern for each predicate is unique, with respect to this query (the unique binding property [Ull89b]). <p> Sets technique described in <ref> [Ull89b] </ref> transforms a program with respect to a given query. The new program evaluates bottom-up the given query more effectively than the original. The Magic Sets transformation requires that the binding pattern for each predicate is unique, with respect to this query (the unique binding property [Ull89b]). A program that does not have this property can be rewritten to have it [Ull89b]. The method creates two sets of predicates, namely magic predicates and supplementary predicates. <p> The Magic Sets transformation requires that the binding pattern for each predicate is unique, with respect to this query (the unique binding property <ref> [Ull89b] </ref>). A program that does not have this property can be rewritten to have it [Ull89b]. The method creates two sets of predicates, namely magic predicates and supplementary predicates. As discussed in Example 5.9, for each IDB predicate, p, a magic predicate m p is created, whose arguments are the bound arguments of p (p has the unique binding property). <p> This program can be simplified significantly. Ullman <ref> [Ull89b] </ref> describes an algorithm for simplifying rules produced by the Magic Sets transformation. We can apply those simplifications that retain the supplementary predicates that are input sources for elementary updates. <p> Experienced Prolog programmers know how to write programs to prevent Prolog's interpreter from getting stuck in an infinite branch, but this is not always possible <ref> [Llo87, Ull89b] </ref>. In Horn-T R , this is particularly true for updating transactions, because it is the nature of updates that does not allow much flexibility in writing a program. Thus, for some programs, any top-down search procedure based on SLD T R resolution fails to terminate. <p> A breadth-first procedure is guaranteed to return all answers to the top goal eventually, but it tends 6. Top-Down Execution of Definite T R Programs 104 to compute the same local answers repeatedly. Furthermore, breadth-first search is undesirable due to its large demand for memory <ref> [Ull89b] </ref>. Assume now that we construct the SLD T R tree by using the e-subgoals for selected atoms. Then it is not hard to see that the tree is finite if and only if the data graph is acyclic.
Reference: [vEK76] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The Semantics of Predicate Logic as a Programming Language. </title> <journal> Journal of ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <month> October </month> <year> 1976. </year>
Reference-contexts: Overview of Classical Horn Logic 10 answers for the query with regard to P . In the sequel, we outline the existing computational approaches for query processing. 2.2.1 Bottom-Up Evaluation The bottom-up approach (also known as forward chaining) corresponds to the fixpoint semantics of Horn logic <ref> [vEK76, AvE82, Llo87] </ref>. The computed fixpoint corresponds to that portion of the program that is relevant to the query. Computation starts by selecting the relevant clauses and predicates. 1 Bottom-up methods are iterative. Each iteration step, n, proceeds as follows: Each predicate denotes an extensional or intensional database relation.
Reference: [vG86] <author> A. van Gelder. </author> <title> A Message Passing Framework for Logical Query Evaluation. </title> <booktitle> ACM SIGMOD Int. Conf. On Management of Data, </booktitle> <pages> pages 155-165, </pages> <year> 1986. </year>
Reference-contexts: Overview of Classical Horn Logic 13 Compile-time methods Compile-time methods transform a logic program with respect to a query, so that a more efficient program is generated and evaluated in a bottom-up fashion. Transformation involves rule rewriting, based on a sideways information passing strategy (sip) and a control strategy <ref> [BR87, vG86] </ref>. Sip determines how information (variable bindings) about some subgoals in a rule is used to evaluate other subgoals in the rule, and the control strategy implements this (possibly using other optimizations as well). <p> SLD resolution is probably the most widely used framework for query processing in Horn logic, because of its efficiency and its completeness property (e.g., [Llo87]). SLD proof procedures, however, are not necessarily complete (e.g., [Llo87]). SLD-AL resolution is one of the approaches proposed as alternatives to SLD resolution <ref> [MS81, Loz85, vG86, TS86, Die87, Vie87, Vie88, Vie89] </ref>. SLD-AL resolution extends SLD resolution to guarantee completeness for proof procedures in the finite, function-free case, and allows for optimizations that account for the best-known query evaluation methods [Vie88, Vie89].
Reference: [Vie87] <author> L. Vieille. </author> <title> Database-Complete Proof Procedures Based on SLD Resolution. </title> <booktitle> In Proc. 4th Int. Conf. on Logic Programming, </booktitle> <pages> pages 74-103, </pages> <month> May </month> <year> 1987. </year> <month> 139 </month>
Reference-contexts: The fundamental method for general Horn programs is the Magic Sets method [RLK86, BMSU87, Ull89b], and its extensions [Ull89b, Sek89, Ram88]. A plethora of specialized methods for increased performance appears in the literature [BMSU87, Ull89b]. Run-time methods Run-time methods are also referred to as memoing methods <ref> [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89] </ref>. The concept is to remember (memo) previously computed answers and reuse them when needed. The search space consists of a network of producers and consumers. The computation proceeds in a top-down fashion, resolving goals and producing answers. <p> In this chapter we develop two theoretical frameworks for top-down evaluation methods that satisfy this requirement. In particular, we extend SLD resolution [AvE82] and SLD-AL resolution <ref> [Vie87, Vie88, Vie89] </ref> to SLD T R and SLD-AL T R resolution, respectively. SLD resolution is probably the most widely used framework for query processing in Horn logic, because of its efficiency and its completeness property (e.g., [Llo87]). SLD proof procedures, however, are not necessarily complete (e.g., [Llo87]). <p> SLD resolution is probably the most widely used framework for query processing in Horn logic, because of its efficiency and its completeness property (e.g., [Llo87]). SLD proof procedures, however, are not necessarily complete (e.g., [Llo87]). SLD-AL resolution is one of the approaches proposed as alternatives to SLD resolution <ref> [MS81, Loz85, vG86, TS86, Die87, Vie87, Vie88, Vie89] </ref>. SLD-AL resolution extends SLD resolution to guarantee completeness for proof procedures in the finite, function-free case, and allows for optimizations that account for the best-known query evaluation methods [Vie88, Vie89]. <p> Recognizing the similarity of sub-queries in SLD trees, one could avoid some infinite branches. Furthermore, new occurrences of a subgoal could be resolved against existing answers of that subgoal, to cut down on computation. The above two ideas form the basis of the memoing techniques in classical Horn logic <ref> [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89] </ref>. The latest ad 6. Top-Down Execution of Definite T R Programs 108 vance in memoing techniques is SLD-AL resolution, proposed by Vieille as an extension of SLD resolution [Vie87, Vie88, Vie89]. <p> The latest ad 6. Top-Down Execution of Definite T R Programs 108 vance in memoing techniques is SLD-AL resolution, proposed by Vieille as an extension of SLD resolution <ref> [Vie87, Vie88, Vie89] </ref>. SLD-AL resolution has been recognized as a powerful framework for query processing, and it is therefore worth investigating how to extend it to Horn-T R .
Reference: [Vie88] <author> L. Vieille. </author> <title> From QSQ Towards QoSaQ: Global Optimization of Recursive Queries. </title> <booktitle> In Proc. 2nd Int. Conf. on Expert Database Systems, </booktitle> <pages> pages 421-434, </pages> <year> 1988. </year>
Reference-contexts: The fundamental method for general Horn programs is the Magic Sets method [RLK86, BMSU87, Ull89b], and its extensions [Ull89b, Sek89, Ram88]. A plethora of specialized methods for increased performance appears in the literature [BMSU87, Ull89b]. Run-time methods Run-time methods are also referred to as memoing methods <ref> [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89] </ref>. The concept is to remember (memo) previously computed answers and reuse them when needed. The search space consists of a network of producers and consumers. The computation proceeds in a top-down fashion, resolving goals and producing answers. <p> In this chapter we develop two theoretical frameworks for top-down evaluation methods that satisfy this requirement. In particular, we extend SLD resolution [AvE82] and SLD-AL resolution <ref> [Vie87, Vie88, Vie89] </ref> to SLD T R and SLD-AL T R resolution, respectively. SLD resolution is probably the most widely used framework for query processing in Horn logic, because of its efficiency and its completeness property (e.g., [Llo87]). SLD proof procedures, however, are not necessarily complete (e.g., [Llo87]). <p> SLD resolution is probably the most widely used framework for query processing in Horn logic, because of its efficiency and its completeness property (e.g., [Llo87]). SLD proof procedures, however, are not necessarily complete (e.g., [Llo87]). SLD-AL resolution is one of the approaches proposed as alternatives to SLD resolution <ref> [MS81, Loz85, vG86, TS86, Die87, Vie87, Vie88, Vie89] </ref>. SLD-AL resolution extends SLD resolution to guarantee completeness for proof procedures in the finite, function-free case, and allows for optimizations that account for the best-known query evaluation methods [Vie88, Vie89]. <p> SLD-AL resolution is one of the approaches proposed as alternatives to SLD resolution [MS81, Loz85, vG86, TS86, Die87, Vie87, Vie88, Vie89]. SLD-AL resolution extends SLD resolution to guarantee completeness for proof procedures in the finite, function-free case, and allows for optimizations that account for the best-known query evaluation methods <ref> [Vie88, Vie89] </ref>. SLD-AL T R resolution extends SLD T R resolution in an analogous way. Section 6.1 defines SLD T R resolution, and proves its soundness and completeness. It also shows that SLD T R proof procedures suffer from similar problems as their SLD 85 6. <p> Recognizing the similarity of sub-queries in SLD trees, one could avoid some infinite branches. Furthermore, new occurrences of a subgoal could be resolved against existing answers of that subgoal, to cut down on computation. The above two ideas form the basis of the memoing techniques in classical Horn logic <ref> [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89] </ref>. The latest ad 6. Top-Down Execution of Definite T R Programs 108 vance in memoing techniques is SLD-AL resolution, proposed by Vieille as an extension of SLD resolution [Vie87, Vie88, Vie89]. <p> The latest ad 6. Top-Down Execution of Definite T R Programs 108 vance in memoing techniques is SLD-AL resolution, proposed by Vieille as an extension of SLD resolution <ref> [Vie87, Vie88, Vie89] </ref>. SLD-AL resolution has been recognized as a powerful framework for query processing, and it is therefore worth investigating how to extend it to Horn-T R . <p> Conclusions and Directions for Further Research 134 * Elimination of redundancy in SLD-AL T R trees. It is of interest to extend existing techniques for reducing the search space, such as local and global optimization for SLD-AL trees <ref> [Vie88, Vie89] </ref>, to SLD-AL T R trees. Heuristics should also be devised for pruning those branches that do not yield answers on the chosen execution path, to optimize non-deterministic execution. * Rule changes and non-determinism in bottom-up evaluation.
Reference: [Vie89] <author> L. Vieille. </author> <title> Recursive Query Processing: The Power of Logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 1-53, </pages> <year> 1989. </year>
Reference-contexts: The fundamental method for general Horn programs is the Magic Sets method [RLK86, BMSU87, Ull89b], and its extensions [Ull89b, Sek89, Ram88]. A plethora of specialized methods for increased performance appears in the literature [BMSU87, Ull89b]. Run-time methods Run-time methods are also referred to as memoing methods <ref> [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89] </ref>. The concept is to remember (memo) previously computed answers and reuse them when needed. The search space consists of a network of producers and consumers. The computation proceeds in a top-down fashion, resolving goals and producing answers. <p> In this chapter we develop two theoretical frameworks for top-down evaluation methods that satisfy this requirement. In particular, we extend SLD resolution [AvE82] and SLD-AL resolution <ref> [Vie87, Vie88, Vie89] </ref> to SLD T R and SLD-AL T R resolution, respectively. SLD resolution is probably the most widely used framework for query processing in Horn logic, because of its efficiency and its completeness property (e.g., [Llo87]). SLD proof procedures, however, are not necessarily complete (e.g., [Llo87]). <p> SLD resolution is probably the most widely used framework for query processing in Horn logic, because of its efficiency and its completeness property (e.g., [Llo87]). SLD proof procedures, however, are not necessarily complete (e.g., [Llo87]). SLD-AL resolution is one of the approaches proposed as alternatives to SLD resolution <ref> [MS81, Loz85, vG86, TS86, Die87, Vie87, Vie88, Vie89] </ref>. SLD-AL resolution extends SLD resolution to guarantee completeness for proof procedures in the finite, function-free case, and allows for optimizations that account for the best-known query evaluation methods [Vie88, Vie89]. <p> SLD-AL resolution is one of the approaches proposed as alternatives to SLD resolution [MS81, Loz85, vG86, TS86, Die87, Vie87, Vie88, Vie89]. SLD-AL resolution extends SLD resolution to guarantee completeness for proof procedures in the finite, function-free case, and allows for optimizations that account for the best-known query evaluation methods <ref> [Vie88, Vie89] </ref>. SLD-AL T R resolution extends SLD T R resolution in an analogous way. Section 6.1 defines SLD T R resolution, and proves its soundness and completeness. It also shows that SLD T R proof procedures suffer from similar problems as their SLD 85 6. <p> Recognizing the similarity of sub-queries in SLD trees, one could avoid some infinite branches. Furthermore, new occurrences of a subgoal could be resolved against existing answers of that subgoal, to cut down on computation. The above two ideas form the basis of the memoing techniques in classical Horn logic <ref> [MS81, Loz85, TS86, Die87, Vie87, Vie88, Vie89] </ref>. The latest ad 6. Top-Down Execution of Definite T R Programs 108 vance in memoing techniques is SLD-AL resolution, proposed by Vieille as an extension of SLD resolution [Vie87, Vie88, Vie89]. <p> The latest ad 6. Top-Down Execution of Definite T R Programs 108 vance in memoing techniques is SLD-AL resolution, proposed by Vieille as an extension of SLD resolution <ref> [Vie87, Vie88, Vie89] </ref>. SLD-AL resolution has been recognized as a powerful framework for query processing, and it is therefore worth investigating how to extend it to Horn-T R . <p> In order to succeed, however, the first 50 occurrences of ir (1; Z) in the infinite branch are constructed, and then the second rule is applied once. 6.2.4 SLD-AL T R trees For SLD-AL T R tree construction we adopt the approach taken in <ref> [Vie89] </ref>. When constructing an SLD-AL T R tree, we apply the AL-technique only to a subset of the predicates of the language, called the r-predicates. This class includes all recursive predicates. A goal (lemma) built on an r-predicate is called an r-subgoal (r-lemma). <p> Then, the maximal depth is bounded by the maximal size of S, and the number of nodes for each depth, d, is bounded by l d <ref> [Vie89] </ref>. The result follows then immediately from the boundness of S. 6.2.5 Search Strategies Search strategies for SLD-AL T R resolution determine at each step of the SLD-AL T R tree construction which node to resolve and which clause or lemma to resolve it with. <p> A search strategy is fair if any potential resolution is selected after a finite number of steps <ref> [Vie89] </ref>. 2 When a local selection function is used and the search strategy is fair, SLD-AL T R resolution is complete. Specifically, we conjecture the following theorem. Theorem 6.5 (Completeness of SLD-AL T R resolution) Let P be a definite program, and N a definite goal. <p> They are therefore particularly suited to non-deterministic transactions. The most interesting results concern SLD-AL T R resolution: We showed that SLD-AL T R resolution leads to complete and terminating proof procedures, for a certain class of programs. Furthermore, SLD-AL T R resolution has great optimizations potential. In <ref> [Vie89] </ref> Vieille develops techniques for eliminating redundancy in SLD-AL trees, and shows that they are powerful enough to account for the best known recursive query evaluation methods. These techniques can be extended to SLD-AL T R resolution. We draw the conclusion that top-down evaluation beats bottom-up for non-deterministic transactions. <p> Conclusions and Directions for Further Research 134 * Elimination of redundancy in SLD-AL T R trees. It is of interest to extend existing techniques for reducing the search space, such as local and global optimization for SLD-AL trees <ref> [Vie88, Vie89] </ref>, to SLD-AL T R trees. Heuristics should also be devised for pruning those branches that do not yield answers on the chosen execution path, to optimize non-deterministic execution. * Rule changes and non-determinism in bottom-up evaluation.
Reference: [Win88] <author> M. Winslett. </author> <title> A Model-Based Approach to Updating Databases with Incomplete Information. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(2) </volume> <pages> 167-196, </pages> <year> 1988. </year>
Reference-contexts: Elementary updates are treated as a parameter of the logic. The rationale behind this approach is that changes to logical theories belong to several classes with distinct semantics. For example, researchers distinguish between change recording updates and revisions (e.g., <ref> [Win88, KM90] </ref>). One can therefore distinguish several update operators. T R can easily be augmented with new update operators by inserting appropriate axioms into the transition base, with no modifications to the model or the proof theory of the logic.
References-found: 38

