URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/SRC-121.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/
Root-URL: http://www.cs.berkeley.edu
Title: Syntax with Lexical Scoping  
Author: Luca Cardelli, Florian Matthes, and Martn Abadi 
Address: 130 Lytton Avenue Palo Alto, California 94301  
Affiliation: Systems Research Center  
Note: Extensible  
Date: February 21, 1994  
Abstract: SRC Research Report 121 
Abstract-found: 1
Intro-found: 1
Reference: [ASU87] <author> A.V. Aho, R. Sethi, and J.D. </author> <title> Ullmann. </title> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1987. </year>
Reference-contexts: New grammar definitions should be checked to avoid problems typical of macro definitions [KR77], such as grammar ambiguity, non-termination of macro expansion, and generation of illegal syntax trees. Our checking is done at grammar-definition time and includes standard grammar analysis <ref> [ASU87] </ref> to avoid the first two problems. To address the third problem, we develop a typing discipline on productions (see subsection 4.1). A more subtle source of difficulties associated with incremental grammar definition is the binding structure of the target language.
Reference: [BA92] <author> A. Bove and L. Arbilla. </author> <title> A Confluent Calculus of Macro Expansion and Evaluation. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 278-287, </pages> <year> 1992. </year>
Reference-contexts: Moreover, while Griffin discusses abstract translations, we provide a specific grammar definition technique and an efficient parsing algorithm. Parsing is efficient because it is LL (1) and because it avoids the creation of intermediate parse trees, producing abstract syntax trees that do not require normalization. Bove and Arbilla <ref> [BA92] </ref> discuss how to use explicit substitutions to implement syntax extensions. Theirs is an elegant idea that may be exploited in systems where the target compiler supports explicit substitutions.
Reference: [BTBN91] <author> V. Breazu-Tannen, P. Buneman, and S. Naqvi. </author> <title> Structural Recursion as a Query Language. In Database Programming Languages: Bulk Types and Persistent Data. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Syntax extensions have a variety of applications in database programming. For example, embedded query notations like the relational calculus, the relational algebra, iteration statements, or set comprehensions can be introduced as abstractions defined from primitive iteration constructs <ref> [OBBT89, BTBN91, Tri91, MS91] </ref>. Transactions can be introduced as stylized patterns for side-effect control and exception handling. Similarly, structured form definitions in user interface code can be represented as abstractions over low-level routines for data formatting, input, and validation. <p> Similarly, query languages typically impose restrictions to rule out side-effecting operations or calls to user-defined functions in selection and join predicates [SQL87]. Some query languages require static bindings to function identifiers (disallowing higher-order functions or dynamic method dispatch) [SFL83], and some disallow lambda abstractions within quantified expressions <ref> [BTBN91] </ref>. Finally, recursive queries or views are often subject to stratification constraints [Naq89]. The next section gives an overview of the issues that must be addressed by a formalism for language extensions and restrictions. In section 3 we introduce extensible grammars by examples.
Reference: [Car93] <author> L. Cardelli. </author> <title> An Implementation of F &lt;: </title> . <type> Research Report 97, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <year> 1993. </year>
Reference-contexts: The form of extensible grammars discussed in this paper was invented during the implementation of a polymorphically typed lambda calculus <ref> [Car93] </ref>. Here, we develop extensible grammars in a more general context and describe them in more detail. We motivate and illustrate the use of extensible grammars with examples from various domains, but we emphasize the application of extensible grammars for database programming.
Reference: [Chr90] <author> H. Christiansen. </author> <title> A Survey of Adaptable Grammars. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(11) </volume> <pages> 25-44, </pages> <year> 1990. </year>
Reference-contexts: In the early work on language extensibility [Gal74, Sta75], both syntax and semantics could be modified arbitrarily, sometimes with disastrous effects <ref> [Chr90] </ref>. Traditional macro facilities allow only syntax extensions. We have already discussed some of the defects of macros. Several recent works propose improvements on macros. Linguistic reflection [SMM91, SSS + 92, SSF92, Kir92] in persistent programming languages has been used to add high-level (query) notations to strongly-typed programming languages.
Reference: [Dow90] <author> G. Dowek. </author> <title> Naming and Scoping in a Mathematical Vernacular. </title> <institution> Rapport de Recherche 1283, INRIA, Rocquencourt, </institution> <year> 1990. </year>
Reference-contexts: These renamings have to be performed by the target-language compiler in t to establish bindings to global variable identifiers (see subsection 3.3). 24 6 Comparison with Related Work Extensibility has been studied previously in the context of programming languages and theorem provers <ref> [Dow90] </ref>. In the early work on language extensibility [Gal74, Sta75], both syntax and semantics could be modified arbitrarily, sometimes with disastrous effects [Chr90]. Traditional macro facilities allow only syntax extensions. We have already discussed some of the defects of macros. Several recent works propose improvements on macros.
Reference: [Gal74] <author> B. Galler. </author> <title> Extensible Languages. </title> <booktitle> Information Processing, </booktitle> <pages> pages 313-316, </pages> <year> 1974. </year>
Reference-contexts: In the early work on language extensibility <ref> [Gal74, Sta75] </ref>, both syntax and semantics could be modified arbitrarily, sometimes with disastrous effects [Chr90]. Traditional macro facilities allow only syntax extensions. We have already discussed some of the defects of macros. Several recent works propose improvements on macros.
Reference: [Gri88] <author> T. Griffin. </author> <title> Notational Definition|A Formal Account. </title> <booktitle> In Proceedings of the Third Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 372-383, </pages> <year> 1988. </year>
Reference-contexts: Syntax extensions provide syntactic sugar for problem-specific abstraction. Syntax extensions have long been used in Lisp systems; recent work has 1 focused on avoiding variable captures (see section 6). Notational definitions make sense not only in programming but also in mathematics, in particular in logical frameworks <ref> [Gri88] </ref>. Syntax extensions have a variety of applications in database programming. For example, embedded query notations like the relational calculus, the relational algebra, iteration statements, or set comprehensions can be introduced as abstractions defined from primitive iteration constructs [OBBT89, BTBN91, Tri91, MS91]. <p> Hygienic macros employ a multi-pass time-stamping algorithm to prevent variable capture; this algorithm is different from our one-pass renaming algorithm. Furthermore, we do not handle quotation and antiquotation in the style of Lisp. Griffin <ref> [Gri88] </ref> has enumerated desirable properties of notational definitions and has studied their formalization. Unlike Griffin, who translates notations to combinator form, we are able to handle variables bound to non-local binders in patterns.
Reference: [KFFD92] <author> E. Kohlbecker, D.P. Friedman, M. Felleisen, and B. Duba. </author> <title> Hygienic Macro Expansion. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1992. </year>
Reference-contexts: Instead, we can freely intermix new and old syntax without special quotations; it is also possible to remove existing keywords by redefining non-terminals with the :== operator. Hygienic macros <ref> [KFFD92, Koh86] </ref> have goals similar to those of our extensible grammars; these macros also work on the abstract syntax and avoid binding anomalies. However, these macros account only for explicit (parameterized) macro calls and not for more liberal keyword-based syntax extensions.
Reference: [Kir92] <author> G.N.C. Kirby. </author> <title> Persistent Programming with Strongly Typed Linguistic Reflection. </title> <type> FIDE Technical Report Series FIDE/92/40, </type> <institution> FIDE Project Coordinator, Department of Computing Sciences, University of Glasgow, </institution> <year> 1992. </year>
Reference-contexts: In the early work on language extensibility [Gal74, Sta75], both syntax and semantics could be modified arbitrarily, sometimes with disastrous effects [Chr90]. Traditional macro facilities allow only syntax extensions. We have already discussed some of the defects of macros. Several recent works propose improvements on macros. Linguistic reflection <ref> [SMM91, SSS + 92, SSF92, Kir92] </ref> in persistent programming languages has been used to add high-level (query) notations to strongly-typed programming languages.
Reference: [Koh86] <author> E.E. Kohlbecker. </author> <title> Syntactic Extensions in the Programming Language LISP. </title> <type> PhD thesis, </type> <institution> Indiana University, </institution> <year> 1986. </year>
Reference-contexts: Instead, we can freely intermix new and old syntax without special quotations; it is also possible to remove existing keywords by redefining non-terminals with the :== operator. Hygienic macros <ref> [KFFD92, Koh86] </ref> have goals similar to those of our extensible grammars; these macros also work on the abstract syntax and avoid binding anomalies. However, these macros account only for explicit (parameterized) macro calls and not for more liberal keyword-based syntax extensions.
Reference: [KR77] <author> B.W. Kernighan and D.M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <year> 1977. </year>
Reference-contexts: The definition of an SQL-like grammar in our formalism is given in subsection 3.4. Extensible grammars require extensible parsers. That is, a parser has to be dynamically extensible to handle programmer-defined object languages. New grammar definitions should be checked to avoid problems typical of macro definitions <ref> [KR77] </ref>, such as grammar ambiguity, non-termination of macro expansion, and generation of illegal syntax trees. Our checking is done at grammar-definition time and includes standard grammar analysis [ASU87] to avoid the first two problems. To address the third problem, we develop a typing discipline on productions (see subsection 4.1).
Reference: [Mat93] <editor> F. Matthes. Persistente Objektsysteme: Integrierte Datenbanken-twicklung und Programmerstellung. </editor> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> (In German.) 33 </note>
Reference-contexts: We also present a soundness result for the type system with respect to the evaluation semantics. In section 5 we describe the implementation of an extensible parser module for the Tycoon database environment <ref> [Mat93] </ref>. Finally, section 6 is a comparison with other approaches to syntax extension. 2 2 Overview The syntax extension formalism described in this paper assumes the scenario depicted in figure 1. <p> ff ` p 0 : B * g; L; ff ` hsi p 0 ) hfli p 0 then E; L; ff ` p 0 : B. 5 An Extensible Parser Package Extensible grammars as described in this paper were developed in the context of the Tycoon database programming environment <ref> [Mat93] </ref>.
Reference: [MR92] <author> M. Mauny and D. Rauglaudre. </author> <title> Parsers in ML. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1992. </year>
Reference-contexts: Furthermore, we are not aware of work in the context of linguistic reflection to handle correctly the problematic binding situations sketched in subsection 3.3. Some non-persistent language implementations, like CAML and SML, integrate YACC or a similar parser generator that allows them to introduce new syntax <ref> [MR92] </ref>. If the new syntax is to be mixed with the old one, the new syntax must be quoted in some way. Instead, we can freely intermix new and old syntax without special quotations; it is also possible to remove existing keywords by redefining non-terminals with the :== operator.
Reference: [MS91] <author> F. Matthes and J.W. Schmidt. </author> <title> Bulk Types: Built-In or Add-On? In Database Programming Languages: Bulk Types and Persistent Data. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Syntax extensions have a variety of applications in database programming. For example, embedded query notations like the relational calculus, the relational algebra, iteration statements, or set comprehensions can be introduced as abstractions defined from primitive iteration constructs <ref> [OBBT89, BTBN91, Tri91, MS91] </ref>. Transactions can be introduced as stylized patterns for side-effect control and exception handling. Similarly, structured form definitions in user interface code can be represented as abstractions over low-level routines for data formatting, input, and validation.
Reference: [Naq89] <author> S.A. Naqvi. </author> <title> Stratification as a Design Principle in Logical Query Languages. </title> <booktitle> In Proceedings of the Second International Workshop on Database Programming Languages, </booktitle> <year> 1989. </year>
Reference-contexts: Some query languages require static bindings to function identifiers (disallowing higher-order functions or dynamic method dispatch) [SFL83], and some disallow lambda abstractions within quantified expressions [BTBN91]. Finally, recursive queries or views are often subject to stratification constraints <ref> [Naq89] </ref>. The next section gives an overview of the issues that must be addressed by a formalism for language extensions and restrictions. In section 3 we introduce extensible grammars by examples.
Reference: [OBBT89] <author> A. Ohori, P. Buneman, and V. Breazu-Tannen. </author> <title> Database Programming in Machiavelli|A Polymorphic Language with Static Type Inference. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 46-57, </pages> <year> 1989. </year>
Reference-contexts: Syntax extensions have a variety of applications in database programming. For example, embedded query notations like the relational calculus, the relational algebra, iteration statements, or set comprehensions can be introduced as abstractions defined from primitive iteration constructs <ref> [OBBT89, BTBN91, Tri91, MS91] </ref>. Transactions can be introduced as stylized patterns for side-effect control and exception handling. Similarly, structured form definitions in user interface code can be represented as abstractions over low-level routines for data formatting, input, and validation. <p> The reduction of query notations into a single canonical iteration construct has been exploited in the literature to simplify the type checking of database programming languages <ref> [OBBT89] </ref>, the code generation for query expressions [Tri91], and the verification of functional database programs [SS91, SSS88]. The following examples demonstrate that extensible grammars provide sufficient expressive power to define the syntax of typical database query languages as well as their translation into lambda calculus.
Reference: [PT93] <author> B. Pierce and D. Turner. </author> <title> Object-Oriented Programming without Recursive Types. </title> <booktitle> In Proceedings of the 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 299-312, </pages> <year> 1993. </year>
Reference-contexts: At the type level, data modeling constructs like classes, objects, and binary relationships can be viewed as syntactic sugar for more complex type expressions involving recursive types, record types, function types, or abstract data types <ref> [SSS + 92, SSS88, PT93] </ref>. Syntax restrictions introduce intentional limitations on the expressiveness or orthogonality of a core language. One rationale behind restrictions is to facilitate meta-level reasoning and optimizations tailored to a particular application domain. In addition, syntax restrictions can serve to enforce the use of subsets of languages.
Reference: [SFL83] <author> J.M. Smith, S. Fox, and T. Landers. ADAPLEX: </author> <title> Rationale and Reference Manual (2nd ed.). </title> <type> Technical Report, </type> <institution> Computer Corporation of America, </institution> <year> 1983. </year>
Reference-contexts: Similarly, query languages typically impose restrictions to rule out side-effecting operations or calls to user-defined functions in selection and join predicates [SQL87]. Some query languages require static bindings to function identifiers (disallowing higher-order functions or dynamic method dispatch) <ref> [SFL83] </ref>, and some disallow lambda abstractions within quantified expressions [BTBN91]. Finally, recursive queries or views are often subject to stratification constraints [Naq89]. The next section gives an overview of the issues that must be addressed by a formalism for language extensions and restrictions.
Reference: [SMM91] <author> D. Stemple, R. Morrison, and Atkinson M. </author> <title> Type-safe Linguistic Reflection. </title> <booktitle> In Database Programming Languages: Bulk Types and Persistent Data, </booktitle> <pages> pages 357-362. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1991. </year>
Reference-contexts: In the early work on language extensibility [Gal74, Sta75], both syntax and semantics could be modified arbitrarily, sometimes with disastrous effects [Chr90]. Traditional macro facilities allow only syntax extensions. We have already discussed some of the defects of macros. Several recent works propose improvements on macros. Linguistic reflection <ref> [SMM91, SSS + 92, SSF92, Kir92] </ref> in persistent programming languages has been used to add high-level (query) notations to strongly-typed programming languages.
Reference: [SQL87] <author> ISO. </author> <title> Standard ISO 9075, </title> <booktitle> Information processing systems|Database language SQL, </booktitle> <year> 1987. </year>
Reference-contexts: Furthermore, user-defined types frequently do not have first-class status, and in particular they may not appear as arguments to collection-type constructors. Similarly, query languages typically impose restrictions to rule out side-effecting operations or calls to user-defined functions in selection and join predicates <ref> [SQL87] </ref>. Some query languages require static bindings to function identifiers (disallowing higher-order functions or dynamic method dispatch) [SFL83], and some disallow lambda abstractions within quantified expressions [BTBN91]. Finally, recursive queries or views are often subject to stratification constraints [Naq89].
Reference: [SS91] <author> D. Stemple and T. Sheard. </author> <title> A Recursive Base for Database Programming Primitives. </title> <booktitle> In Proceedings of the Kiev East/West Workshop on Next Generation Database Technology, volume 504 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The reduction of query notations into a single canonical iteration construct has been exploited in the literature to simplify the type checking of database programming languages [OBBT89], the code generation for query expressions [Tri91], and the verification of functional database programs <ref> [SS91, SSS88] </ref>. The following examples demonstrate that extensible grammars provide sufficient expressive power to define the syntax of typical database query languages as well as their translation into lambda calculus. This translation preserves the usual scoping rules defined for these query languages.
Reference: [SSF92] <author> D. Stemple, T. Sheard, and L. Fegaras. </author> <title> Linguistic Reflection: A Bridge from Programming to Database Languages. </title> <booktitle> In Proceedings 25th Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 46-55, </pages> <year> 1992. </year>
Reference-contexts: In the early work on language extensibility [Gal74, Sta75], both syntax and semantics could be modified arbitrarily, sometimes with disastrous effects [Chr90]. Traditional macro facilities allow only syntax extensions. We have already discussed some of the defects of macros. Several recent works propose improvements on macros. Linguistic reflection <ref> [SMM91, SSS + 92, SSF92, Kir92] </ref> in persistent programming languages has been used to add high-level (query) notations to strongly-typed programming languages.
Reference: [SSS88] <author> D. Stemple, A. Socorro, and T. Sheard. </author> <title> Formalizing Objects for Databases using ADABTPL. </title> <booktitle> In Advances in Object-Oriented Database Systems, </booktitle> <pages> pages 110-172, </pages> <year> 1988. </year>
Reference-contexts: At the type level, data modeling constructs like classes, objects, and binary relationships can be viewed as syntactic sugar for more complex type expressions involving recursive types, record types, function types, or abstract data types <ref> [SSS + 92, SSS88, PT93] </ref>. Syntax restrictions introduce intentional limitations on the expressiveness or orthogonality of a core language. One rationale behind restrictions is to facilitate meta-level reasoning and optimizations tailored to a particular application domain. In addition, syntax restrictions can serve to enforce the use of subsets of languages. <p> The reduction of query notations into a single canonical iteration construct has been exploited in the literature to simplify the type checking of database programming languages [OBBT89], the code generation for query expressions [Tri91], and the verification of functional database programs <ref> [SS91, SSS88] </ref>. The following examples demonstrate that extensible grammars provide sufficient expressive power to define the syntax of typical database query languages as well as their translation into lambda calculus. This translation preserves the usual scoping rules defined for these query languages.
Reference: [SSS + 92] <author> D. Stemple, R.B. Stanton, T. Sheard, P. Philbrow, R. Morrison, G.N.C. Kirby, L. Fegaras, R.L. Cooper, R.C.H. Connor, M.P. Atkin-son, and S. Alagic. </author> <title> Type-Safe Linguistic Reflection: A Generator 34 Technology. </title> <institution> Research Report CS/92/6, University of St. Andrews, Department of Computing Science, </institution> <year> 1992. </year>
Reference-contexts: At the type level, data modeling constructs like classes, objects, and binary relationships can be viewed as syntactic sugar for more complex type expressions involving recursive types, record types, function types, or abstract data types <ref> [SSS + 92, SSS88, PT93] </ref>. Syntax restrictions introduce intentional limitations on the expressiveness or orthogonality of a core language. One rationale behind restrictions is to facilitate meta-level reasoning and optimizations tailored to a particular application domain. In addition, syntax restrictions can serve to enforce the use of subsets of languages. <p> In the early work on language extensibility [Gal74, Sta75], both syntax and semantics could be modified arbitrarily, sometimes with disastrous effects [Chr90]. Traditional macro facilities allow only syntax extensions. We have already discussed some of the defects of macros. Several recent works propose improvements on macros. Linguistic reflection <ref> [SMM91, SSS + 92, SSF92, Kir92] </ref> in persistent programming languages has been used to add high-level (query) notations to strongly-typed programming languages.
Reference: [Sta75] <author> T. A. Standish. </author> <title> Extensibility in Language Design. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 10(7) </volume> <pages> 18-21, </pages> <year> 1975. </year>
Reference-contexts: In the early work on language extensibility <ref> [Gal74, Sta75] </ref>, both syntax and semantics could be modified arbitrarily, sometimes with disastrous effects [Chr90]. Traditional macro facilities allow only syntax extensions. We have already discussed some of the defects of macros. Several recent works propose improvements on macros.
Reference: [Tri91] <author> P. Trinder. </author> <title> Comprehensions, a Query Notation for DBPLs. In Database Programming Languages: Bulk Types and Persistent Data. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Syntax extensions have a variety of applications in database programming. For example, embedded query notations like the relational calculus, the relational algebra, iteration statements, or set comprehensions can be introduced as abstractions defined from primitive iteration constructs <ref> [OBBT89, BTBN91, Tri91, MS91] </ref>. Transactions can be introduced as stylized patterns for side-effect control and exception handling. Similarly, structured form definitions in user interface code can be represented as abstractions over low-level routines for data formatting, input, and validation. <p> function succ (x); begin return x + 1 end ) begin return plus (x,1) end In a database programming setting, OL n could be a language with SQL-like query notations that is translated into a lambda calculus, OL n1 , with primitive operations on a collection type (nil, cons, iter) <ref> [Tri91] </ref>: select x.a iter (X)(nil)(fun (x)fun (z) from x in X ) if p (x) then cons (x.a)(z) else z) where p (x) Incremental grammar definitions are discussed in more detail in subsections 3.2 and 3.3. The definition of an SQL-like grammar in our formalism is given in subsection 3.4. <p> The reduction of query notations into a single canonical iteration construct has been exploited in the literature to simplify the type checking of database programming languages [OBBT89], the code generation for query expressions <ref> [Tri91] </ref>, and the verification of functional database programs [SS91, SSS88]. The following examples demonstrate that extensible grammars provide sufficient expressive power to define the syntax of typical database query languages as well as their translation into lambda calculus. This translation preserves the usual scoping rules defined for these query languages.
Reference: [WC93] <author> D. Weise and R. </author> <title> Crew. Programmable Syntax Macros. </title> <journal> ACM SIG-PLAN Notices, </journal> <volume> 28(6) </volume> <pages> 156-165, </pages> <year> 1993. </year>
Reference-contexts: Recent work has extended AST macro manipulation to syntactically complex languages. For example, Weise and Crew use a full C language extended with patterns as a preprocessor for the C language <ref> [WC93] </ref>; their macros have syntactic types (our sorts) that guarantee the generation of well-formed AST's. We have achieved considerable flexibility in the manipulation of complex languages, but without resorting to a computationally complete macro language.
Reference: [WG85] <author> W.M. Waite and G. Goos. </author> <title> Compiler Construction. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <month> 35 </month>
Reference-contexts: ` hx :: s; ii T 1 : p 1 j T 2 : p 2 ) hs 0 ; i 0 i t The computation of the director sets is accomplished by standard algorithms developed for non-incremental LL (1) parsers in time linear to the size of the grammar <ref> [WG85] </ref>.
References-found: 29

