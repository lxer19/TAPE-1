URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/dbj/www/ftp/Rice-COMP-TR90-125.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/dbj/www/ft.html
Root-URL: http://www.cs.cmu.edu
Phone: (713) 527-4834  
Title: A Simple Algorithm for Finding the Maximum Recoverable System State in Optimistic Rollback Recovery Methods  
Author: David B. Johnson Peter J. Keleher Willy Zwaenepoel 
Note: This research was supported in part by the National Science Foundation under grants CCR-8716914 and CDA-8619893, and by the Office of Naval Research under contract ONR N00014-88-K-0140.  
Date: July 1990  
Address: COMP TR90-125  P.O. Box 1892 Houston, Texas 77251-1892  
Affiliation: Rice  Department of Computer Science Rice University  
Abstract-found: 0
Intro-found: 1
Reference: [Bhargava88] <author> Bharat Bhargava and Shy-Renn Lian. </author> <title> Independent checkpointing and concurrent rollback for recovery|An optimistic approach. </title> <booktitle> In Proceedings of the Seventh Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 3-12. </pages> <publisher> IEEE Computer Society, </publisher> <month> October </month> <year> 1988. </year>
Reference-contexts: In a system using checkpointing alone to provide fault tolerance <ref> [Koo87, Chandy85, Bhargava88] </ref>, which need not assume deterministic process execution, a process state can be restored only if it has been recorded in a checkpoint. After a failure, the system must be restored to a consistent system state. <p> To be able to recover a system state, all of its individual process states must be able to be restored. A consistent system state in which each process state can be restored is thus called a recoverable system state. Optimistic rollback recovery methods <ref> [Strom85, Strom88, Johnson88, Sistla89, Bhargava88] </ref> in general record the recovery information asynchronously, assuming that a suitable recoverable system state can be constructed for use during recovery. This paper presents a simple algorithm for finding the maximum recoverable system state at any time in a system using optimistic rollback recovery. <p> The relative simplicity of the algorithm presented here also makes it attractive. We have not yet specifically quantified the circumstances under which each of these two algorithms may be preferable. Bhargava and Lian describe an optimistic rollback recovery method using checkpointing alone, without message logging <ref> [Bhargava88] </ref>. Processes maintain a checkpoint number and an input information table, roughly serving the role of our state interval indices and dependency vectors. Each message sent includes the current checkpoint number of the sender. <p> For example, the algorithm can be used in deterministic systems using a fault-tolerance method based on optimistic message log 10 ging and checkpointing [Strom85, Strom88, Johnson88, Sistla89, Johnson89], and in nondeterminis-tic systems using optimistic checkpointing alone <ref> [Bhargava88] </ref>.
Reference: [Borg89] <author> Anita Borg, Wolfgang Blau, Wolfgang Graetsch, Ferdinand Herrmann, and Wolfgang Oberle. </author> <title> Fault tolerance under UNIX. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(1) </volume> <pages> 1-24, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: 1 Introduction In a distributed system using rollback recovery, information saved on stable storage during failure-free execution allows certain states of each process to be restored after a failure. For example, in a system using message logging and checkpointing <ref> [Powell83, Johnson87, Borg89, Strom85, Strom88, Johnson88, Sistla89] </ref>, in which all process execution between received messages is assumed to be deterministic, a process state can be restored only if all messages received by the process since its previous checkpoint have been logged. <p> For example, with pessimistic message logging and checkpointing methods <ref> [Powell83, Johnson87, Borg89] </ref>, the maximum recoverable system state is simply composed of the most recent state interval of each process for which all previously received messages have been logged.
Reference: [Chandy85] <author> K. Mani Chandy and Leslie Lamport. </author> <title> Distributed snapshots: Determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: In a system using checkpointing alone to provide fault tolerance <ref> [Koo87, Chandy85, Bhargava88] </ref>, which need not assume deterministic process execution, a process state can be restored only if it has been recorded in a checkpoint. After a failure, the system must be restored to a consistent system state. <p> After a failure, the system must be restored to a consistent system state. Essentially, a system state is consistent if it could have occurred during the preceding execution of the system from its initial state, regardless of the relative speeds of individual processes <ref> [Chandy85] </ref>. This ensures that the total execution of the system is equivalent to some possible failure-free execution. To be able to recover a system state, all of its individual process states must be able to be restored. <p> For example, with pessimistic message logging and checkpointing methods [Powell83, Johnson87, Borg89], the maximum recoverable system state is simply composed of the most recent state interval of each process for which all previously received messages have been logged. With pessimistic check-pointing methods <ref> [Koo87, Chandy85] </ref>, a complete global checkpoint of the system is maintained by the checkpointing protocol, such that the checkpoints of all process in this global checkpoint form a consistent system state. The most recent global checkpoint is thus the maximum recoverable system state.
Reference: [Cheriton83] <author> David R. Cheriton and Willy Zwaenepoel. </author> <title> The distributed V kernel and its performance for diskless workstations. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 129-140. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1983. </year>
Reference-contexts: Section 3 presents our algorithm for finding the maximum recoverable system state, and Section 4 describes our experience with the implementation of this algorithm under the V-System <ref> [Cheriton83, Cheriton88] </ref>. Related work is discussed in Section 5, and in Section 6, we present conclusions. 2 System Model The model presented in this section is an extension of our model for reasoning about systems using message logging and checkpointing [Johnson88, Johnson89]. <p> system state D represented by MAXREC must be a recoverable system state, and must therefore be the maximum recoverable system state that currently exists. 4 Implementation Experience We have implemented the algorithm shown in Figure 3 in a system using optimistic message logging and checkpointing [Johnson89], running under the V-System <ref> [Cheriton83, Cheriton88] </ref>. Each machine runs a logging server and a checkpoint server process. The kernel saves messages as they are received in a buffer in the volatile memory of the local logging server. <p> We have implemented the algorithm in a system using optimistic message logging and check-pointing, running under the V-System <ref> [Cheriton83, Cheriton88] </ref>. A shared network file server is used to record all information for stable storage, and the algorithm is executed on that server. The algorithm is restartable if the file server should fail, since all information used by the algorithm has previously been recorded on stable storage.
Reference: [Cheriton88] <author> David R. Cheriton. </author> <title> The V distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 314-333, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Section 3 presents our algorithm for finding the maximum recoverable system state, and Section 4 describes our experience with the implementation of this algorithm under the V-System <ref> [Cheriton83, Cheriton88] </ref>. Related work is discussed in Section 5, and in Section 6, we present conclusions. 2 System Model The model presented in this section is an extension of our model for reasoning about systems using message logging and checkpointing [Johnson88, Johnson89]. <p> system state D represented by MAXREC must be a recoverable system state, and must therefore be the maximum recoverable system state that currently exists. 4 Implementation Experience We have implemented the algorithm shown in Figure 3 in a system using optimistic message logging and checkpointing [Johnson89], running under the V-System <ref> [Cheriton83, Cheriton88] </ref>. Each machine runs a logging server and a checkpoint server process. The kernel saves messages as they are received in a buffer in the volatile memory of the local logging server. <p> We have implemented the algorithm in a system using optimistic message logging and check-pointing, running under the V-System <ref> [Cheriton83, Cheriton88] </ref>. A shared network file server is used to record all information for stable storage, and the algorithm is executed on that server. The algorithm is restartable if the file server should fail, since all information used by the algorithm has previously been recorded on stable storage.
Reference: [Johnson87] <author> David B. Johnson and Willy Zwaenepoel. </author> <title> Sender-based message logging. </title> <booktitle> In The Seventeenth Annual International Symposium on Fault-Tolerant Computing: Digest of Papers, </booktitle> <pages> pages 14-19. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: 1 Introduction In a distributed system using rollback recovery, information saved on stable storage during failure-free execution allows certain states of each process to be restored after a failure. For example, in a system using message logging and checkpointing <ref> [Powell83, Johnson87, Borg89, Strom85, Strom88, Johnson88, Sistla89] </ref>, in which all process execution between received messages is assumed to be deterministic, a process state can be restored only if all messages received by the process since its previous checkpoint have been logged. <p> For example, with pessimistic message logging and checkpointing methods <ref> [Powell83, Johnson87, Borg89] </ref>, the maximum recoverable system state is simply composed of the most recent state interval of each process for which all previously received messages have been logged.
Reference: [Johnson88] <author> David B. Johnson and Willy Zwaenepoel. </author> <title> Recovery in distributed systems using optimistic message logging and checkpointing. </title> <booktitle> In Proceedings of the Seventh Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 171-181. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1988. </year> <note> To appear in Journal of Algorithms, </note> <month> September </month> <year> 1990. </year> <month> 11 </month>
Reference-contexts: 1 Introduction In a distributed system using rollback recovery, information saved on stable storage during failure-free execution allows certain states of each process to be restored after a failure. For example, in a system using message logging and checkpointing <ref> [Powell83, Johnson87, Borg89, Strom85, Strom88, Johnson88, Sistla89] </ref>, in which all process execution between received messages is assumed to be deterministic, a process state can be restored only if all messages received by the process since its previous checkpoint have been logged. <p> To be able to recover a system state, all of its individual process states must be able to be restored. A consistent system state in which each process state can be restored is thus called a recoverable system state. Optimistic rollback recovery methods <ref> [Strom85, Strom88, Johnson88, Sistla89, Bhargava88] </ref> in general record the recovery information asynchronously, assuming that a suitable recoverable system state can be constructed for use during recovery. This paper presents a simple algorithm for finding the maximum recoverable system state at any time in a system using optimistic rollback recovery. <p> With this model, we show that in any system using optimistic rollback recovery, there is always a unique maximum recoverable system state, extending our previous result for deterministic systems using message logging and checkpointing <ref> [Johnson88] </ref>. Section 3 presents our algorithm for finding the maximum recoverable system state, and Section 4 describes our experience with the implementation of this algorithm under the V-System [Cheriton83, Cheriton88]. <p> Related work is discussed in Section 5, and in Section 6, we present conclusions. 2 System Model The model presented in this section is an extension of our model for reasoning about systems using message logging and checkpointing <ref> [Johnson88, Johnson89] </ref>. It is based on the notion of dependency between the states of processes that results from communication between those processes. <p> The proof of this is shown in our previous work with this model <ref> [Johnson88] </ref>, and is omitted here for brevity. Since the set of recoverable system states forms a lattice, there is always a unique maximum recoverable system state, which is simply the least upper bound of all recoverable system states that have occurred. <p> The information recorded on stable storage, making process state intervals stable, must be saved until it is guaranteed not to be needed for any possible future failure recovery in the system <ref> [Strom85, Johnson88] </ref>, and thus the current maximum recoverable system state never decreases. The distinction between deterministic and nondeterministic systems is captured in the respective definitions of process state intervals, and does not affect the rest of the model. <p> the current maximum recoverable system state is also important during failure-free execution, in order to allow output to the "outside world" (such as writing information on the user's display terminal) to be committed, and to be able to remove old recovery information from stable storage that is no longer needed <ref> [Strom85, Johnson88] </ref>. The algorithm presented here guarantees to find the maximum possible recoverable system state at any time. The algorithm requires no additional communication in the system, and requires little storage for execution. <p> One algorithm tags each message sent with a transitive dependency vector as in Strom and Yemini's system, whereas the other algorithm tags each message only with the sender's current state interval index as in our previous work <ref> [Johnson88] </ref>. To find the maximum recoverable system state, each process sends information about its message logging progress to all other processes, after which their second algorithm also exchanges additional messages, essentially to distribute the complete transitive dependency information. <p> Also, whereas our system uses the process checkpoints to advance the maximum recoverable system state, their algorithm does not make use of these stable process state intervals. The algorithm presented here is similar to the algorithm published in our earlier work with optimistic message logging and checkpointing <ref> [Johnson88] </ref>. That algorithm incrementally determines the maximum recoverable system state from the previously known maximum. If no new recoverable system state exists after some new process state interval becomes stable, that new state interval is added to a number of "defer" sets to be rechecked later. <p> For example, the algorithm can be used in deterministic systems using a fault-tolerance method based on optimistic message log 10 ging and checkpointing <ref> [Strom85, Strom88, Johnson88, Sistla89, Johnson89] </ref>, and in nondeterminis-tic systems using optimistic checkpointing alone [Bhargava88].
Reference: [Johnson89] <author> David B. Johnson. </author> <title> Distributed System Fault Tolerance Using Message Logging and Checkpointing. </title> <type> Ph.D. thesis, </type> <institution> Rice University, Houston, Texas, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: Related work is discussed in Section 5, and in Section 6, we present conclusions. 2 System Model The model presented in this section is an extension of our model for reasoning about systems using message logging and checkpointing <ref> [Johnson88, Johnson89] </ref>. It is based on the notion of dependency between the states of processes that results from communication between those processes. <p> The system state D represented by MAXREC must be a recoverable system state, and must therefore be the maximum recoverable system state that currently exists. 4 Implementation Experience We have implemented the algorithm shown in Figure 3 in a system using optimistic message logging and checkpointing <ref> [Johnson89] </ref>, running under the V-System [Cheriton83, Cheriton88]. Each machine runs a logging server and a checkpoint server process. The kernel saves messages as they are received in a buffer in the volatile memory of the local logging server. <p> For example, the algorithm can be used in deterministic systems using a fault-tolerance method based on optimistic message log 10 ging and checkpointing <ref> [Strom85, Strom88, Johnson88, Sistla89, Johnson89] </ref>, and in nondeterminis-tic systems using optimistic checkpointing alone [Bhargava88].
Reference: [Koo87] <author> Richard Koo and Sam Toueg. </author> <title> Checkpointing and rollback-recovery for distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(1):23-31, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: In a system using checkpointing alone to provide fault tolerance <ref> [Koo87, Chandy85, Bhargava88] </ref>, which need not assume deterministic process execution, a process state can be restored only if it has been recorded in a checkpoint. After a failure, the system must be restored to a consistent system state. <p> For example, with pessimistic message logging and checkpointing methods [Powell83, Johnson87, Borg89], the maximum recoverable system state is simply composed of the most recent state interval of each process for which all previously received messages have been logged. With pessimistic check-pointing methods <ref> [Koo87, Chandy85] </ref>, a complete global checkpoint of the system is maintained by the checkpointing protocol, such that the checkpoints of all process in this global checkpoint form a consistent system state. The most recent global checkpoint is thus the maximum recoverable system state.
Reference: [Powell83] <author> Michael L. Powell and David L. Presotto. </author> <title> Publishing: A reliable broadcast communication mechanism. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 100-109. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1983. </year>
Reference-contexts: 1 Introduction In a distributed system using rollback recovery, information saved on stable storage during failure-free execution allows certain states of each process to be restored after a failure. For example, in a system using message logging and checkpointing <ref> [Powell83, Johnson87, Borg89, Strom85, Strom88, Johnson88, Sistla89] </ref>, in which all process execution between received messages is assumed to be deterministic, a process state can be restored only if all messages received by the process since its previous checkpoint have been logged. <p> For example, with pessimistic message logging and checkpointing methods <ref> [Powell83, Johnson87, Borg89] </ref>, the maximum recoverable system state is simply composed of the most recent state interval of each process for which all previously received messages have been logged.
Reference: [Sistla89] <author> A. Prasad Sistla and Jennifer L. Welch. </author> <title> Efficient distributed recovery using message logging. </title> <booktitle> In Proceedings of the Eighth Annual ACM Symposium on Principles of Distributed Computing. ACM, </booktitle> <month> August </month> <year> 1989. </year>
Reference-contexts: 1 Introduction In a distributed system using rollback recovery, information saved on stable storage during failure-free execution allows certain states of each process to be restored after a failure. For example, in a system using message logging and checkpointing <ref> [Powell83, Johnson87, Borg89, Strom85, Strom88, Johnson88, Sistla89] </ref>, in which all process execution between received messages is assumed to be deterministic, a process state can be restored only if all messages received by the process since its previous checkpoint have been logged. <p> To be able to recover a system state, all of its individual process states must be able to be restored. A consistent system state in which each process state can be restored is thus called a recoverable system state. Optimistic rollback recovery methods <ref> [Strom85, Strom88, Johnson88, Sistla89, Bhargava88] </ref> in general record the recovery information asynchronously, assuming that a suitable recoverable system state can be constructed for use during recovery. This paper presents a simple algorithm for finding the maximum recoverable system state at any time in a system using optimistic rollback recovery. <p> Thus, if the maximum recoverable system state advances due to a process checkpoint before previously received messages have been logged, those messages need never be logged. Sistla and Welch have proposed two alternative recovery algorithms based on optimistic message logging <ref> [Sistla89] </ref>. One algorithm tags each message sent with a transitive dependency vector as in Strom and Yemini's system, whereas the other algorithm tags each message only with the sender's current state interval index as in our previous work [Johnson88]. <p> For example, the algorithm can be used in deterministic systems using a fault-tolerance method based on optimistic message log 10 ging and checkpointing <ref> [Strom85, Strom88, Johnson88, Sistla89, Johnson89] </ref>, and in nondeterminis-tic systems using optimistic checkpointing alone [Bhargava88].
Reference: [Strom85] <author> Robert E. Strom and Shaula Yemini. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: 1 Introduction In a distributed system using rollback recovery, information saved on stable storage during failure-free execution allows certain states of each process to be restored after a failure. For example, in a system using message logging and checkpointing <ref> [Powell83, Johnson87, Borg89, Strom85, Strom88, Johnson88, Sistla89] </ref>, in which all process execution between received messages is assumed to be deterministic, a process state can be restored only if all messages received by the process since its previous checkpoint have been logged. <p> To be able to recover a system state, all of its individual process states must be able to be restored. A consistent system state in which each process state can be restored is thus called a recoverable system state. Optimistic rollback recovery methods <ref> [Strom85, Strom88, Johnson88, Sistla89, Bhargava88] </ref> in general record the recovery information asynchronously, assuming that a suitable recoverable system state can be constructed for use during recovery. This paper presents a simple algorithm for finding the maximum recoverable system state at any time in a system using optimistic rollback recovery. <p> The information recorded on stable storage, making process state intervals stable, must be saved until it is guaranteed not to be needed for any possible future failure recovery in the system <ref> [Strom85, Johnson88] </ref>, and thus the current maximum recoverable system state never decreases. The distinction between deterministic and nondeterministic systems is captured in the respective definitions of process state intervals, and does not affect the rest of the model. <p> the current maximum recoverable system state is also important during failure-free execution, in order to allow output to the "outside world" (such as writing information on the user's display terminal) to be committed, and to be able to remove old recovery information from stable storage that is no longer needed <ref> [Strom85, Johnson88] </ref>. The algorithm presented here guarantees to find the maximum possible recoverable system state at any time. The algorithm requires no additional communication in the system, and requires little storage for execution. <p> During failure recovery, the running time of the algorithm is negligible relative to the time required to restore the processes from their checkpoints and to replay the logged messages to the recovering processes. 5 Related Work Strom and Yemini introduced the notion of optimistic message logging and checkpointing <ref> [Strom85, Strom88] </ref>. Each process in their system maintains a transitive dependency vector, recording the transitive closure of the dependencies represented by our dependency vectors. A copy of the sender's dependency vector is included with each message sent, and is then merged with the receiver's vector when the message is received. <p> For example, the algorithm can be used in deterministic systems using a fault-tolerance method based on optimistic message log 10 ging and checkpointing <ref> [Strom85, Strom88, Johnson88, Sistla89, Johnson89] </ref>, and in nondeterminis-tic systems using optimistic checkpointing alone [Bhargava88].
Reference: [Strom88] <author> Robert E. Strom, David F. Bacon, and Shaula A. Yemini. </author> <title> Volatile logging in n-fault-tolerant distributed systems. </title> <booktitle> In The Eighteenth Annual International Symposium on Fault-Tolerant Computing: Digest of Papers, </booktitle> <pages> pages 44-49. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1988. </year> <month> 12 </month>
Reference-contexts: 1 Introduction In a distributed system using rollback recovery, information saved on stable storage during failure-free execution allows certain states of each process to be restored after a failure. For example, in a system using message logging and checkpointing <ref> [Powell83, Johnson87, Borg89, Strom85, Strom88, Johnson88, Sistla89] </ref>, in which all process execution between received messages is assumed to be deterministic, a process state can be restored only if all messages received by the process since its previous checkpoint have been logged. <p> To be able to recover a system state, all of its individual process states must be able to be restored. A consistent system state in which each process state can be restored is thus called a recoverable system state. Optimistic rollback recovery methods <ref> [Strom85, Strom88, Johnson88, Sistla89, Bhargava88] </ref> in general record the recovery information asynchronously, assuming that a suitable recoverable system state can be constructed for use during recovery. This paper presents a simple algorithm for finding the maximum recoverable system state at any time in a system using optimistic rollback recovery. <p> During failure recovery, the running time of the algorithm is negligible relative to the time required to restore the processes from their checkpoints and to replay the logged messages to the recovering processes. 5 Related Work Strom and Yemini introduced the notion of optimistic message logging and checkpointing <ref> [Strom85, Strom88] </ref>. Each process in their system maintains a transitive dependency vector, recording the transitive closure of the dependencies represented by our dependency vectors. A copy of the sender's dependency vector is included with each message sent, and is then merged with the receiver's vector when the message is received. <p> For example, the algorithm can be used in deterministic systems using a fault-tolerance method based on optimistic message log 10 ging and checkpointing <ref> [Strom85, Strom88, Johnson88, Sistla89, Johnson89] </ref>, and in nondeterminis-tic systems using optimistic checkpointing alone [Bhargava88].
References-found: 13

