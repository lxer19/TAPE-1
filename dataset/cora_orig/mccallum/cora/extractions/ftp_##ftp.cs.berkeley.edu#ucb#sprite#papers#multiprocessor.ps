URL: ftp://ftp.cs.berkeley.edu/ucb/sprite/papers/multiprocessor.ps
Refering-URL: http://www.cs.berkeley.edu/projects/sprite/sprite.papers.html
Root-URL: http://www.cs.berkeley.edu
Email: -jhh,ouster-@sprite.Berkeley.EDU  
Title: Performance Measurements of a Multiprocessor Sprite Kernel  
Author: John H. Hartman John K. Ousterhout 
Address: Berkeley, CA 94720  
Affiliation: University of California at Berkeley Computer Science Division Electrical Engineering and Computer Sciences University of California  
Abstract: This report presents performance measurements made of the Sprite operating system running on a multiprocessor. A variety of micro- and macro-benchmarks were run while varying the number of processors in the system, and both the elapsed time and the contention for kernel locks were recorded. A number of interesting conclusions are drawn from the results. First, the macro-benchmarks show acceptable performance on systems of up to five processors. Total system throughput increases almost linearly with the system size. Projections of the lock contention measurements show that the maximum performance will be reached with about seven processors in the system. Second, it is often difficult to predict the effect of a benchmark on particular kernel locks. It was anticipated that different benchmarks would saturate different kernel monitor locks. After running the benchmarks it was found that a single master lock was the biggest kernel bottleneck, and that one of the micro-benchmarks had saturated a different lock than the one at which it was targeted. The kernel locking structure has become so complex as the system has evolved that it is hard to determine cause and effect relationships. Third, although the kernel contains many locks, only a few of them are performance bottlenecks. Performance measurements such as those presented here allow the relevant parts of the kernel to be redesigned to eliminate the bottlenecks. Such a redesign is needed to allow the system to scale gracefully beyond about seven processors. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. J. Bach and S. J. Buroff, </author> <title> Multiprocessor UNIX Operating Systems, </title> <journal> AT&T Bell Laboratories Technical Journal 63, </journal> <month> 8 (October </month> <year> 1984), </year> <pages> 1733-1749. </pages>
Reference-contexts: Kernel locks In order for a multi-threaded kernel to function correctly it must contain mechanisms for providing both mutual exclusion and synchronization between threads. Other efforts to design multiprocessor operating systems have used semaphores <ref> [1, 3, 8] </ref>. Semaphores are appealing because they can provide both mutual exclusion and synchronization, eliminating the need for separate mechanisms. Sprite, however, uses monitor-style locking and condition variables to provide these services. There are two basic types of locks in the Sprite kernel: monitor locks and master locks.
Reference: 2. <author> A. Boor, </author> <title> PMake -- A Tutorial, Unpublished, </title> <address> June 1, </address> <year> 1988. </year>
Reference-contexts: Macro-benchmarks 5.1.1. PmakeInd The pmakeInd benchmark is intended to be representative of a multi-user environment with multiple independent compilations taking place. PmakeInd recompiles Csh from its sources using the Pmake program. Pmake is similar to the UNIX "make" utility, except that it runs the compilations in parallel whenever possible <ref> [2] </ref>. The pmakeInd benchmark runs a separate instance of Pmake on each processor and each instance uses separate copies of the sources. This eliminates the Pmake program and contention for the source files as causes of performance degradation.
Reference: 3. <author> E. W. Dijkstra,, </author> <title> Hierarchical Ordering of Sequential Processes., </title> <booktitle> in Operating Systems Techniques, </booktitle> <year> 1972, </year> <pages> 72-93. </pages>
Reference-contexts: Kernel locks In order for a multi-threaded kernel to function correctly it must contain mechanisms for providing both mutual exclusion and synchronization between threads. Other efforts to design multiprocessor operating systems have used semaphores <ref> [1, 3, 8] </ref>. Semaphores are appealing because they can provide both mutual exclusion and synchronization, eliminating the need for separate mechanisms. Sprite, however, uses monitor-style locking and condition variables to provide these services. There are two basic types of locks in the Sprite kernel: monitor locks and master locks.
Reference: 4. <author> M. D. Hill, S. J. Eggers, J. R. Larus, G. S. Taylor, G. Adams, B. K. Bose, G. A. Gibson, P. M. Hansen, J. Keller, S. I. Kong, C. G. Lee, D. Lee, J. M. Pendleton, S. A. Ritchie, D. A. Wood, B. G. Zorn, P. N. Hilfinger, D. Hodges, R. H. Katz, J. Ousterhout and D. A. Patterson, </author> <title> SPUR: A VLSI Multiprocessor Workstation, </title> <institution> Computer Science Division Technical Report UCB/Computer Science Dpt. </institution> <month> 86/273, December </month> <year> 1985. </year>
Reference-contexts: Details of the hardware are only provided to allow comparisons to be made to more familiar machines. At the time of this study the only multiprocessor that Sprite supported was the SPUR multiprocessor <ref> [4] </ref>. SPUR is a RISC microprocessor developed at Berkeley as part of a project to study the impact of adding symbolic processing support and multiprocessing to RISC architectures. Individual SPUR processor boards can be combined to form a shared-memory multiprocessor.
Reference: 5. <author> C. A. R. Hoare, </author> <title> Monitors: An Operating System Structuring Concept, </title> <journal> Vol. </journal> <volume> 17, </volume> <month> October </month> <year> 1974. </year>
Reference-contexts: Sprite, however, uses monitor-style locking and condition variables to provide these services. There are two basic types of locks in the Sprite kernel: monitor locks and master locks. Monitor locks are used to implement monitors <ref> [5] </ref>, with semantics similar to those in Mesa [6]. Monitor locks are acquired at the start of a procedure and released at the end. If a process tries to lock a monitor lock and another process has it locked already, then the process is put to sleep.
Reference: 6. <author> B. W. Lampson and D. D. Redell, </author> <title> Experiences with Processes and Monitors in Mesa., </title> <journal> Communications of the ACM 23, </journal> <volume> 2 (February, </volume> <year> 1980), </year> <pages> 105-117. </pages>
Reference-contexts: Sprite, however, uses monitor-style locking and condition variables to provide these services. There are two basic types of locks in the Sprite kernel: monitor locks and master locks. Monitor locks are used to implement monitors [5], with semantics similar to those in Mesa <ref> [6] </ref>. Monitor locks are acquired at the start of a procedure and released at the end. If a process tries to lock a monitor lock and another process has it locked already, then the process is put to sleep. <p> The coarsest granularity locks in the kernel are single locks that are used to protect sections of code. Locks used in this manner are referred to as code locks. If the lock is a monitor lock then the resulting construction is similar to the monitored modules described in <ref> [6] </ref>. An example of this style of use is the monitor lock around the Sprite virtual memory system. There is a single monitor lock that must be grabbed whenever a routine in the virtual memory system is called, thus synchronizing access to the virtual memory system as a whole.
Reference: 7. <author> J. Ousterhout, A. Cherenson, F. Douglis, M. Nelson and B. Welch, </author> <title> The Sprite Network Operating System, </title> <booktitle> IEEE Computer 21, </booktitle> <month> 2 (Feb. </month> <year> 1988), </year> <pages> 23-36. - 13 </pages> - 
Reference-contexts: 1. Introduction Sprite is a network operating system being developed at Berkeley <ref> [7] </ref>. From its inception Sprite has been designed to run on a multiprocessor. To avoid performance bottlenecks due to kernel contention, the kernel is multi-threaded to allow more than one processor to execute kernel code at the same time.
Reference: 8. <author> U. Sinkewicz, </author> <title> A Strategy for SMP Ultrix, </title> <booktitle> Usenix Conference Proceedings, </booktitle> <month> June </month> <year> 1988, </year> <pages> 203-212. </pages>
Reference-contexts: Kernel locks In order for a multi-threaded kernel to function correctly it must contain mechanisms for providing both mutual exclusion and synchronization between threads. Other efforts to design multiprocessor operating systems have used semaphores <ref> [1, 3, 8] </ref>. Semaphores are appealing because they can provide both mutual exclusion and synchronization, eliminating the need for separate mechanisms. Sprite, however, uses monitor-style locking and condition variables to provide these services. There are two basic types of locks in the Sprite kernel: monitor locks and master locks.

References-found: 8

