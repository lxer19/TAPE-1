URL: http://www.cse.psu.edu/~weyer/conf8.ps
Refering-URL: http://www.cse.psu.edu/~weyer/
Root-URL: http://www.cse.psu.edu
Title: Annotated Structure Shape Graphs for  
Abstract: Analysis of Prolog 
Abstract-found: 1
Intro-found: 1
Reference: [BGW92] <author> B. Burton, G. Gudjonsson, and W. Winsborough. </author> <title> An algorithm for computing alternating closure. </title> <type> Technical Report CS-92-15, </type> <institution> Penn State, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: A second analysis that was designed to overcome this efficiency problem forgoes all structure shape information and as a result executes very quickly <ref> [BGW92] </ref>. For many programs, that analyzer successfully identifies opportunities to apply memory management optimizations. Unfortunately, for many other programs, structure shape information is essential.
Reference: [CBC93] <author> J.D. Choi, M.G. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interproce--dural computation of pointer-induced aliases and side-effects. </title> <booktitle> POPL, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: This sort of may-share or may-alias information is fundamental to determining whether a structure cell is live, and is the subject of our study and others, including <ref> [CBC93, LH88] </ref>. The program analysis presented in this paper uses an abstract domain that consists of an-notated graphs referred to as Structure Shape Graphs, or SSGs. These graphs approximate heap states, capturing both structure shape and structure sharing.
Reference: [CWZ90] <author> D.R. Chase, M. Wegman, and F.K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> PLDI, </booktitle> <pages> pages 20-22, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: We present the first abstract interpretation that models unification over such a domain. (b) The number of nodes in an SSG is bounded by the number of constructor occurrences in the program <ref> [JM82, CWZ90] </ref>. We allocate one node in an SSG for each occurrence of each constructor in the program. 3 i. The number of constructor occurrences in a program determines an upper bound on the graph size. ii. <p> impossible to tell whether the actual heap is Heap 1, which has real sharing, or whether in fact it is Heap 2, with the apparent sharing merely 4 A weak update to a graph is one in which arcs or nodes may be added, but not replaced, moved, or deleted <ref> [CWZ90] </ref>. Heap 1 X Y val X Y val val Heap 2 X Y Structure Shape Graph val g/1 Fig. 1. An SSG that represents more than one possible heap state. resulting from a folding operation on the SSG. The difference determines whether the structure-reuse optimization is safe. <p> A promising line of investigation is presented in [Deu94]. It remains to be seen whether that approach is well suited to supporting structure liveness in the presence of the unification operation. Abstract analysis methods that use SSGs have been proposed for imperative languages <ref> [CWZ90] </ref>. These methods may benefit from using the annotations proposed here by increasing the ratio of strong updates to weak updates. In the logic programming context, previous graph-based analyses have used type graphs [JB92], rather than SSGs.
Reference: [Deu94] <author> A. Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> PLDI, </booktitle> <pages> pages 230-241, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Alternative analysis methods employ domains that capture structure shape information (e.g., [Hei92]) or sharing information (e.g., <ref> [Deu94] </ref>), but not both. Heintz's work has many attractive features, including elegance, modularity, and efficiency. However, the set constraint approach appears unable to approach the power of abstract interpretation to infer control-flow based information such as structure liveness. This appears to make it unsuitable for supporting update-in-place transformations. <p> However, the set constraint approach appears unable to approach the power of abstract interpretation to infer control-flow based information such as structure liveness. This appears to make it unsuitable for supporting update-in-place transformations. A promising line of investigation is presented in <ref> [Deu94] </ref>. It remains to be seen whether that approach is well suited to supporting structure liveness in the presence of the unification operation. Abstract analysis methods that use SSGs have been proposed for imperative languages [CWZ90].
Reference: [GW93] <author> G. Gudjonsson and W. Winsborough. </author> <title> Update in place: Overview of the siva project. </title> <editor> In Dale Miller, editor, </editor> <booktitle> ILPS, </booktitle> <pages> pages 94-113. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: The binding information may be used in conjunction with liveness information to allow an optimizing compiler to generate specialized code. The compiler optimizations that our analyzer supports include compile-time garbage collection (CTGC) [MJMB89] and update-in-place (UIP) <ref> [GW93] </ref>. These optimizations produce specialized code for sections of the program where storage cells are accessed for the last time. The specialized code reuses the dead storage cells, rather than relying on the garbage collector to reclaim them. <p> The specialized code reuses the dead storage cells, rather than relying on the garbage collector to reclaim them. Because all memory management is handled internally in Prolog, these optimizations can have a significant impact on performance <ref> [GW93] </ref>. They go a long way toward addressing a fundamental performance problem incurred by purely declarative languages, which eschew destructive assignment. <p> The final analyzer will be incorporated into the SIVA project <ref> [GW93] </ref>, which applies transformations to Prolog programs to obtain update-in-place memory reuse. The unification operation has been implemented in 5000 lines of C code, and has been tested on short sequences of unifications that model simple programs.
Reference: [Hei92] <author> N. Heintze. </author> <title> Practical aspects of set based analysis. </title> <editor> In Krzysztok Apt, editor, </editor> <booktitle> JICSLP, </booktitle> <pages> pages 765-779. </pages> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Alternative analysis methods employ domains that capture structure shape information (e.g., <ref> [Hei92] </ref>) or sharing information (e.g., [Deu94]), but not both. Heintz's work has many attractive features, including elegance, modularity, and efficiency. However, the set constraint approach appears unable to approach the power of abstract interpretation to infer control-flow based information such as structure liveness.
Reference: [JB92] <author> G. Janssens and M. Bruynooghe. </author> <title> Deriving descriptions of possible values of program variables by means of abstract interpretation. </title> <journal> Journal of Logic Programming, </journal> 13(2&3):205-258, July 1992. 
Reference-contexts: Previous static analyses designed to infer structure liveness properties of Prolog programs have met with qualified success. An early analysis by Mulkers et al. [MWB90, MWB94] obtained impressive precision by using the structure-shape information provided by type graph analysis <ref> [JB92] </ref>. However, the analyzer also inherited serious efficiency problems: It runs out of memory on medium sized programs. This can be attributed at least in part to the fact that type graphs provide a separate representation for the structure to which each variable is bound. <p> Abstract analysis methods that use SSGs have been proposed for imperative languages [CWZ90]. These methods may benefit from using the annotations proposed here by increasing the ratio of strong updates to weak updates. In the logic programming context, previous graph-based analyses have used type graphs <ref> [JB92] </ref>, rather than SSGs. Type graphs by themselves do not express structure sharing, making them unsuitable for supporting update-in-place transformations. Additional structure-sharing information can be layered on top of type graphs, as done in [MWB90, MWB94].
Reference: [JM81] <editor> N.D. Jones and S. Muchnick. </editor> <title> Flow analysis and optimzation of lisp-like structures. </title> <editor> In S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: To this end, we use a domain that consists of very compact graphs. The principal features of this domain are as follows. 1. Structure shape graphs are used to represent shape and sharing. (a) Shared structure in the heap is represented by shared structure in the SSG <ref> [JM81] </ref>. We present the first abstract interpretation that models unification over such a domain. (b) The number of nodes in an SSG is bounded by the number of constructor occurrences in the program [JM82, CWZ90].
Reference: [JM82] <editor> N.D. Jones and S. Muchnick. </editor> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> POPL, </booktitle> <pages> pages 66-74, </pages> <year> 1982. </year>
Reference-contexts: We present the first abstract interpretation that models unification over such a domain. (b) The number of nodes in an SSG is bounded by the number of constructor occurrences in the program <ref> [JM82, CWZ90] </ref>. We allocate one node in an SSG for each occurrence of each constructor in the program. 3 i. The number of constructor occurrences in a program determines an upper bound on the graph size. ii.
Reference: [Kag93] <author> A. Kagedal. </author> <title> Improvements in compile-time analysis for ground prolog. </title> <editor> In M. Bruynooghe, J. Penjam, editors, PLILP. </editor> <publisher> LNCS 714, Springer-Verlag, </publisher> <month> August </month> <year> 1993. </year>
Reference-contexts: However, the resulting analysis is excessively costly, in large part because type graphs do not allow sufficient sharing of substructure in their own representations. The related, but much simpler, problem of analyzing the ground subset of Prolog for the same application has been studied in [Klu88] and <ref> [Kag93] </ref>. Acknowledgement William Winsborough was partially supported by NSF CCR-9210975.
Reference: [Klu88] <author> F. Kluzniak. </author> <title> Compile-time garbage collection for ground Prolog. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> ICSLP, </booktitle> <pages> pages 1490-1505. </pages> <publisher> MIT Press, </publisher> <month> August </month> <year> 1988. </year>
Reference-contexts: However, the resulting analysis is excessively costly, in large part because type graphs do not allow sufficient sharing of substructure in their own representations. The related, but much simpler, problem of analyzing the ground subset of Prolog for the same application has been studied in <ref> [Klu88] </ref> and [Kag93]. Acknowledgement William Winsborough was partially supported by NSF CCR-9210975.
Reference: [LH88] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> PLDI, </booktitle> <pages> pages 21-34, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: This sort of may-share or may-alias information is fundamental to determining whether a structure cell is live, and is the subject of our study and others, including <ref> [CBC93, LH88] </ref>. The program analysis presented in this paper uses an abstract domain that consists of an-notated graphs referred to as Structure Shape Graphs, or SSGs. These graphs approximate heap states, capturing both structure shape and structure sharing.
Reference: [LV92] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental evaluation of a generic abstract interpretation algorithm for prolog (extended abstract). </title> <booktitle> Fourth IEEE International Conference on Computer Languages, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: A complete discussion can be found in [Wey96]. 5 Results The annotations discussed in this paper are being incorporated in a prototype abstract analyzer for Prolog using the framework of <ref> [LV92, VCL94] </ref>. The sharing Old Sharing a ds a a ns a a ms a none a recognizes one new pointer only.
Reference: [MJMB89] <author> A. Marien, G. Janssens, A. Mulkers, and M. Bruynooghe. </author> <title> The impact of abstract interpretation: An experiment in code generation. </title> <editor> In G. Levi and M. Martelli, editors, ICLP. </editor> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: The binding information may be used in conjunction with liveness information to allow an optimizing compiler to generate specialized code. The compiler optimizations that our analyzer supports include compile-time garbage collection (CTGC) <ref> [MJMB89] </ref> and update-in-place (UIP) [GW93]. These optimizations produce specialized code for sections of the program where storage cells are accessed for the last time. The specialized code reuses the dead storage cells, rather than relying on the garbage collector to reclaim them.
Reference: [MWB90] <author> A. Mulkers, W. Winsborough, and M. Bruynooghe. </author> <title> Analysis of shared data structures for compile-time garbage collection in logic programs. </title> <editor> In D. H. D. Warren and P. Szeredi, editors, ICLP. </editor> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: These graphs approximate heap states, capturing both structure shape and structure sharing. Previous static analyses designed to infer structure liveness properties of Prolog programs have met with qualified success. An early analysis by Mulkers et al. <ref> [MWB90, MWB94] </ref> obtained impressive precision by using the structure-shape information provided by type graph analysis [JB92]. However, the analyzer also inherited serious efficiency problems: It runs out of memory on medium sized programs. <p> A set of pointers referencing the same cell is represented by a set of arcs pointing to the same node. Thus, SSGs provide a better visualization of sharing. In type-graph based models <ref> [MWB90, MWB94] </ref>, structures that share in the heap are each represented by their own type graph structure (the nodes of which are linked by a binary may-share relation to indicate that they may represent the same heap cell). 2. <p> In the logic programming context, previous graph-based analyses have used type graphs [JB92], rather than SSGs. Type graphs by themselves do not express structure sharing, making them unsuitable for supporting update-in-place transformations. Additional structure-sharing information can be layered on top of type graphs, as done in <ref> [MWB90, MWB94] </ref>. However, the resulting analysis is excessively costly, in large part because type graphs do not allow sufficient sharing of substructure in their own representations. The related, but much simpler, problem of analyzing the ground subset of Prolog for the same application has been studied in [Klu88] and [Kag93].
Reference: [MWB94] <author> A. Mulkers, W. Winsborough, and M. Bruynooghe. </author> <title> Live-structure data-flow analysis for Prolog. </title> <journal> TOPLAS, </journal> <volume> 16, </volume> <year> 1994. </year>
Reference-contexts: These graphs approximate heap states, capturing both structure shape and structure sharing. Previous static analyses designed to infer structure liveness properties of Prolog programs have met with qualified success. An early analysis by Mulkers et al. <ref> [MWB90, MWB94] </ref> obtained impressive precision by using the structure-shape information provided by type graph analysis [JB92]. However, the analyzer also inherited serious efficiency problems: It runs out of memory on medium sized programs. <p> A set of pointers referencing the same cell is represented by a set of arcs pointing to the same node. Thus, SSGs provide a better visualization of sharing. In type-graph based models <ref> [MWB90, MWB94] </ref>, structures that share in the heap are each represented by their own type graph structure (the nodes of which are linked by a binary may-share relation to indicate that they may represent the same heap cell). 2. <p> In the logic programming context, previous graph-based analyses have used type graphs [JB92], rather than SSGs. Type graphs by themselves do not express structure sharing, making them unsuitable for supporting update-in-place transformations. Additional structure-sharing information can be layered on top of type graphs, as done in <ref> [MWB90, MWB94] </ref>. However, the resulting analysis is excessively costly, in large part because type graphs do not allow sufficient sharing of substructure in their own representations. The related, but much simpler, problem of analyzing the ground subset of Prolog for the same application has been studied in [Klu88] and [Kag93].
Reference: [PW78] <author> M. S. Patterson and M. N. Wegman. </author> <title> Linear unification. </title> <journal> Journal of computer and system sciences, </journal> <volume> 16 </volume> <pages> 158-167, </pages> <year> 1978. </year>
Reference-contexts: ns a 2 ) j= (a 1 r a 2 ) ) (a 2 r a 1 ); r 2 fds; ns; msg 3 Modeling Unification Concrete unification of terms can be modeled by constructing an equivalence relation over subterms that are required to be identical by the unification problem <ref> [PW78] </ref>. The equivalence classes induced by this relation provide a basis for stating the safety requirement of an abstract unification operation over SSGs.
Reference: [VCL94] <author> P. Van Hentenryck, A. Cortesi, and B. Le Charlier. </author> <title> Type analysis of prolog using type graphs. </title> <booktitle> PLDI, </booktitle> <year> 1994. </year>
Reference-contexts: A complete discussion can be found in [Wey96]. 5 Results The annotations discussed in this paper are being incorporated in a prototype abstract analyzer for Prolog using the framework of <ref> [LV92, VCL94] </ref>. The sharing Old Sharing a ds a a ns a a ms a none a recognizes one new pointer only.
Reference: [Wey96] <author> G. Weyer. </author> <title> Structure shape graphs with explicit sharing for prolog-like languages. </title> <type> Master's thesis, </type> <institution> Dept of Computer Science and Engineering, Penn State, </institution> <month> May </month> <year> 1996. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: A complete discussion can be found in <ref> [Wey96] </ref>. 5 Results The annotations discussed in this paper are being incorporated in a prototype abstract analyzer for Prolog using the framework of [LV92, VCL94]. The sharing Old Sharing a ds a a ns a a ms a none a recognizes one new pointer only. <p> In one extreme case, the analyzer running time was reduced by a ratio of 45:1. Typical cases demonstrated more modest improvements of about 2:1. The correctness of the abstract unification operation used in the implementation has been proven <ref> [Wey96] </ref>. The proof begins by defining a formal graphical model of heap states, which are referred to as Term Environment Graphs. Concrete unification is defined over these graphs. Abstract unification is then proven to model concrete unification in a manner that preserves recognition.
References-found: 19

