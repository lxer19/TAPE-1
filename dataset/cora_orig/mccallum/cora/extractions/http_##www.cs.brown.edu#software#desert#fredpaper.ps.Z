URL: http://www.cs.brown.edu/software/desert/fredpaper.ps.Z
Refering-URL: http://www.cs.brown.edu/software/desert/description.html
Root-URL: http://www.cs.brown.edu/
Email: spr@cs.brown.edu  
Phone: (401)-863-7641, fax: (401)-863-7657  
Title: Program Editing in a Software Development Environment (DRAFT)  Goals for a Program Editor  
Author: Steven P. Reiss 
Address: Providence, RI 02912  
Affiliation: Department of Computer Science Brown University  
Date: August 3, 1995 1  
Note: Program Editing in a Software Development Environment  1.0  
Abstract: This paper describes an approach to program editing that is suitable for a modern software development environment. Program editing involves editing whole programs and not just files. Our approach uses the data integration facilities of the Desert environment to combine information about the overall system with that of the file being edited. It is built on top of the commercial word processing tool, FrameMaker, to provide high-quality presentations of both text and graphics. It uses an API to provide both insets supporting different tools for non-textual software artifacts (e.g user interfaces, class diagrams, and visualizations) and formatted program text. The API does minimal incremental parsing to enable the proper formatting and to relate the text being editing to the rest of the system being developed. The key components in a software development environment are the editors that allow the developer to modify the different software artifacts. Multiple editors are typically provided: graphical editors for modifying design diagrams, direct manipulation tools for building user interfaces, text editors for writing code, word processing systems for producing documentation, etc. Our goal in developing a new editor for a programming environment was to integrate these different editors as much as possible, providing a common framework to handle all software artifacts. At the same time we wanted to provide enhanced services to the programmer through the editor. Our primary goal was to provide a true program editor. A program editor must be designed for editing programs, not files. This does not mean that it is a syntax-directed editor. Rather it implies that the editor must be aware that the file being edited is only one small part of a much larger system. The devel 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> James Archer, Jr. and Richard Conway, </author> <title> COPE: a cooperative programming environment, </title> <note> Cornell TR81-459 (June 1981). </note>
Reference-contexts: This implied that we wanted to parse the resultant code as it was entered. While parsing on a keystroke basis is not new it was done in the early 1980s in the COPE system at Cornell <ref> [1] </ref> doing it outside of a syntax-directed editor, without direct control over the users input, in the context of a powerful word processing system, and in a language-independent manner is new. Parsing presented several challenges. The first was obtaining the text to parse.
Reference: 2. <author> Ronald M. Baecker and Aaron Marcus, </author> <title> Human Factors and Typography for More Readable Programs, </title> <publisher> Addison-Wesley (1990). </publisher>
Reference-contexts: Although workstations have been used for programming for over twelve years, most program editing is still done in a simple, single-font, single color, text editor. Although studies have shown that using different presentation styles can enhance program readability and understandability <ref> [2] </ref>, little has been done to take advantage of this for standard editing. All this had to be done using an open system. We needed an editor that would be consistent with current software artifacts. <p> The second objective is to allow the editor to format the text to make it more readable along the lines proposed in <ref> [2] </ref>. This Program Editing in a Software Development Environment August 3, 1995 6 required token-based formatting and required the editor to distinguish between tokens representing different types of objects. It also required identifying and isolat ing block and in-line comments.
Reference: 3. <author> Robert A. Ballance, Susan L. Graham, and Michael L. Van De Vanter, </author> <title> The Pan language-based editing system for integrated development environments, </title> <booktitle> ACM Software Engineering Notes Vol. </booktitle> <pages> 15(6) pp. </pages> <month> 77-93 (December </month> <year> 1990). </year>
Reference-contexts: Programmer-knowledgable editors such as the programmers apprentice have also been proposed [20]. These attempt to use artificial intelligence techniques to provide direction to the programmer. More recently, the Pan system attempts to use sophisticated semantic knowledge to provide programmer feedback <ref> [3] </ref>. Neither of these semantic approaches has been demonstrated as practical for realistically-sized programs. More popular for programming are language-knowledgable editors such as emacs [10]. These editors know enough about the language being edited to do automatic indentation and simple error checking (such as parenthesis balancing).
Reference: 4. <author> Norman M. Delisle, David E. Menicosy, and Mayer D. Schwartz, </author> <title> Viewing a programming environment as a single tool, </title> <journal> SIGPLAN Notices Vol. </journal> <pages> 19(5) pp. </pages> <month> 49-56 (May </month> <year> 1984). </year>
Reference: 5. <author> Alan Demers, Thomas Reps, and Tim Teitelbaum, </author> <title> Incremental evaluation for attribute grammars with application to syntax-directed editors, </title> <booktitle> Proc. 8th ACM Symposium on Principles of Programming Languages (1981). </booktitle>
Reference-contexts: Multimedia insets are supported both by HTTP and by FrameMaker. Another related topic is incremental parsing and semantic analysis. Incremental parsing typically shows how to extend standard parsing techniques to support incrementality [9]. A variety of techniques have been proposed for incremental semantic analysis, including attributed grammars <ref> [5] </ref>, model-based functions [13],unification [17], and functions [11]. All of these techniques attempt to preserve full semantic information and depend on having the full program available and error-free. Our simplified techniques provide the information needed for editing without the cost of maintaining the more detailed information needed by a compiler.
Reference: 6. <author> Veronique Donzeau-Gouge, Gerard Heut, Gilles Kahn, and Bernard Lang, </author> <title> Programming environments based on structured editors: the MENTOR Experience, in Interactive Programming Environments, </title> <editor> ed. D. R. Barstow, H. E. Shrobe and E. Sandewall,McGraw-Hill, </editor> <address> New York (1984). </address>
Reference: 7. <author> Robert J. Ellison and Barbara J. Staudt, </author> <title> The evolution of the GANDALF System, </title> <journal> Journal of Systems and Software Vol. </journal> <month> 5(2)(May </month> <year> 1985). </year>
Reference: 8. <author> James C. Ferrans, David W. Hurst, Michael A. Sennet, Burton M. Covnot, Wenguang Ji, Peter Kajka, and Wei Ouyang, HyperWeb: </author> <title> a framework for hypermedia-based environments, </title> <journal> Software Engineering Notices Vol. </journal> <pages> 17(5) pp. </pages> <month> 1-10 (December </month> <year> 1992). </year>
Reference-contexts: Another area of related work involves the use of hypertext editors for programming. This is becoming more common with the advent of HTTP and editors built for the world-wide web <ref> [8] </ref>. These editors allow the user to create implicit or explicit links between the various parts of the program. Our approach can provide similar facilities, using the hypertext capabilities of FrameMaker for explicit links and the internal data structures and external database to provide implicit links.
Reference: 9. <author> Carlo Ghezzi and Dino Mandrioli, </author> <title> Augmenting parsers to support incrementality, </title> <journal> JACM Vol. </journal> <pages> 27(3) pp. </pages> <month> 564-579 (July </month> <year> 1980). </year>
Reference-contexts: Multimedia insets are supported both by HTTP and by FrameMaker. Another related topic is incremental parsing and semantic analysis. Incremental parsing typically shows how to extend standard parsing techniques to support incrementality <ref> [9] </ref>. A variety of techniques have been proposed for incremental semantic analysis, including attributed grammars [5], model-based functions [13],unification [17], and functions [11]. All of these techniques attempt to preserve full semantic information and depend on having the full program available and error-free.
Reference: 10. <author> James Gosling, </author> <title> Unix Emacs, Carnegie-Mellon Computer Science Department (August 1982). Program Editing in a Software Development Environment August 3, </title> <year> 1995 </year> <month> 17 </month>
Reference-contexts: More recently, the Pan system attempts to use sophisticated semantic knowledge to provide programmer feedback [3]. Neither of these semantic approaches has been demonstrated as practical for realistically-sized programs. More popular for programming are language-knowledgable editors such as emacs <ref> [10] </ref>. These editors know enough about the language being edited to do automatic indentation and simple error checking (such as parenthesis balancing). The primary example of such an editor is emacs.
Reference: 11. <author> Gail E. Kaiser, </author> <title> Semantics for Structure Editing Environments, </title> <type> Ph.D. Dissertation, </type> <institution> Carnegie-Mellon University (1985). </institution>
Reference-contexts: Another related topic is incremental parsing and semantic analysis. Incremental parsing typically shows how to extend standard parsing techniques to support incrementality [9]. A variety of techniques have been proposed for incremental semantic analysis, including attributed grammars [5], model-based functions [13],unification [17], and functions <ref> [11] </ref>. All of these techniques attempt to preserve full semantic information and depend on having the full program available and error-free. Our simplified techniques provide the information needed for editing without the cost of maintaining the more detailed information needed by a compiler.
Reference: 12. <author> N. Ramsey, </author> <title> Literate programming: weaving a language-independent WEB, </title> <journal> CACM Vol. </journal> <pages> 32(9) pp. </pages> <month> 1051-1055 (September </month> <year> 1989). </year>
Reference-contexts: These provide the ability to automatically format the code, highlighting keywords, etc. as the user types. Our editor interface provides many of these capabilities in an open, multiple-language environment. Other work that is related to ours includes work on literate programming <ref> [12] </ref>. This is a general attempt to use a single file for both documentation and code. A preprocessor extracts the code from the file when compilation is needed. Other processors can extract documentation, function headers, or other relevant information.
Reference: 13. <author> Steven P. Reiss, </author> <title> An approach to incremental compilation, </title> <booktitle> Proc. SIGPLAN 84 Symposium on Compiler Construction, </booktitle> <month> (June </month> <year> 1984). </year>
Reference: 14. <author> Steven P. Reiss, </author> <title> PECAN: program development systems that support multiple views, </title> <journal> IEEE Trans. Soft. Eng. </journal> <volume> Vol. </volume> <pages> SE-11 pp. </pages> <month> 276-284 (March </month> <year> 1985). </year>
Reference: 15. <author> Steven P. Reiss, </author> <title> FIELD: A Friendly Integrated Environment for Learning and Development, </title> <publisher> Kluwer (1994). </publisher>
Reference-contexts: It also needs to use the environment both to understand the overall program and to allow the user to initiate commands in other tools from the editor. Most of the editors interaction is based on control integration and our experiences with the FIELD environment <ref> [15] </ref>. The editor defines a set of messages that can be sent to it by other tools to cause it to display a particular file and line. It defines messages that add a file-line pair to the current stack of gotos.
Reference: 16. <author> Steven P. Reiss, </author> <title> An engine for the 3D visualization of program information, </title> <journal> Journal of Visual Languages, </journal> <note> (To appear in 1995). </note>
Reference-contexts: The utility of insets or live-links goes beyond special purpose editors for software artifacts. We also use insets to provide visualizations of the users program as part of the source files. This is done by providing an inset-based interface to our program visualization tools <ref> [16] </ref>. Our editor interface provides a common front end for a variety of different inset editors. The front end manages two files for each interface. The first file is the input file to the tool, i.e. a file representing the software artifact.
Reference: 17. <author> Gregor Snelting and Wolfgang Henhapl, </author> <title> Unification in many-sorted algebras as a device for incremental semantic analysis, </title> <booktitle> Proc. 13th ACM POPL, </booktitle> <pages> pp. </pages> <month> 229-235 (January </month> <year> 1986). </year>
Reference-contexts: Another related topic is incremental parsing and semantic analysis. Incremental parsing typically shows how to extend standard parsing techniques to support incrementality [9]. A variety of techniques have been proposed for incremental semantic analysis, including attributed grammars [5], model-based functions [13],unification <ref> [17] </ref>, and functions [11]. All of these techniques attempt to preserve full semantic information and depend on having the full program available and error-free. Our simplified techniques provide the information needed for editing without the cost of maintaining the more detailed information needed by a compiler.
Reference: 18. <author> Tim Teitelbaum and Thomas Reps, </author> <title> The Cornell program synthesizer: a syntax-directed programming environment, </title> <journal> CACM Vol. </journal> <pages> 24(9) pp. </pages> <month> 563-573 (September </month> <year> 1981). </year>
Reference: 19. <author> W. Teitelman, </author> <title> A tour through Cedar, </title> <booktitle> IEEE Software Vol. </booktitle> <pages> 1(2) pp. </pages> <month> 44-73 (April </month> <year> 1984). </year>
Reference-contexts: Our approach is closer to that used in the Cedar Mesa environment where the Cedar editor used the document structure and document tags to Program Editing in a Software Development Environment August 3, 1995 14 distinguish code and comments in the same document <ref> [19] </ref>. Our approach also provides these capabilities in an open environment, not depending on a single language or compilers that are aware of the documents structures. Another area of related work involves the use of hypertext editors for programming.
Reference: 20. <author> Richard C. Waters, </author> <title> The programmers apprentice: knowledge based program editing, in Interactive Programming Environments, </title> <editor> ed. D. R. Barstow, H. E. Shrobe and E. Sandewall,McGraw-Hill, </editor> <address> New York (1984). </address>
Reference-contexts: Programmer-knowledgable editors such as the programmers apprentice have also been proposed <ref> [20] </ref>. These attempt to use artificial intelligence techniques to provide direction to the programmer. More recently, the Pan system attempts to use sophisticated semantic knowledge to provide programmer feedback [3]. Neither of these semantic approaches has been demonstrated as practical for realistically-sized programs.
References-found: 20

