URL: http://www.cs.princeton.edu/~jlk/deet/deet.ps.gz
Refering-URL: http://www.cs.princeton.edu/~jlk/resh.html
Root-URL: http://www.cs.princeton.edu
Email: fdrh;jlkg@cs.princeton.edu  
Title: A Simple and Extensible Graphical Debugger  
Author: David R. Hanson and Jeffrey L. Korn 
Address: 35 Olden St., Princeton, NJ 08544  
Affiliation: Department of Computer Science, Princeton University,  
Abstract: deet is a simple but powerful debugger for ANSI C and Java. It differs from conventional debuggers in that it is machine-independent, graphical, programmable, distributed, extensible, and small. Low-level operations are performed by communicating with a nub, which is a small set of machine-dependent functions that are embedded in the target program at compile-time, or are implemented on top of existing debuggers. deet has a set of commands that communicate with the target's nub. The target and deet communicate by passing messages through a pipe or socket, so they can be on a different machines. deet is implemented in tksh, an extension of the Korn shell that provides the graphical facilities of Tcl/Tk. Users can browse source files, set break-points, watch variables, and examine data structures by pointing and clicking. Additional facilities, like conditional breakpoints, can be written in either Tcl or the shell. Most debuggers are large and complicated, deet is less than 1,500 lines of shell plus a few hundred lines of machine-specific nub code. It is thus easy to understand, modify, and extend. We describe an implementation of the nub API for Java and an implementation that is layered on top of gdb. We have also implemented a version of gdb using the nub API, which demonstrates the modularity of the design. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Arnold and J. Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: For example, a more efficient, machine-specific nub could be used in place of cdb's machine-independent nub; or a better or more familiar user interface could be used. To demonstrate this flexibility, we've implemented three alternative versions of deet's pieces: a version of the nub for Java <ref> [1] </ref>, a nub that works by communicating with gdb, and a replacement for the user-interface component that emulates gdb's command-line interface. These limited experiments also reveal strengths and weaknesses in the nub-based design. <p> The nub interface is machine-independent, so it cannot provide these public void frameCmd (RemoteThread t, String args []) throws Exception - if (args.length == 2) - int oldFrame = t.getCurrentFrameIndex (); int newFrame = Integer.parseInt (args <ref> [1] </ref>); try - if (oldFrame &lt; newFrame) t.up (newFrame-oldFrame); else if (oldFrame &gt; newFrame) t.down (oldFrame-newFrame); catch (ArrayIndexOutOfBoundsException e) - outputError (); - else RemoteStackFrame s = t.getCurrentFrame (); RemoteClass c = s.getRemoteClass (); outputItem (t.getCurrentFrameIndex ()); outputItem (c.getName () + "." + s.getMethodName ()); outputItem (c.getSourceFileName ()); outputItem (s.getLineNumber ());
Reference: [2] <author> M. Bolsky and D. Korn. </author> <title> The New KornShell Command and Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> Upper Saddle River, NJ, </address> <note> second edition, </note> <year> 1995. </year>
Reference-contexts: The user-interface part is written in tksh, a version of the new Korn shell <ref> [2, 7] </ref> that has been extended to support Tcl [12]. The target program is controlled by a nub, which provides debugging primitives, as detailed below. deet's implementation of and interaction with the nub is also written in tksh.
Reference: [3] <author> C. W. Fraser and D. R. Hanson. </author> <title> A Retargetable C Compiler: Design and Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Menlo Park, CA, </address> <year> 1995. </year>
Reference-contexts: Nevertheless, its implementation is sur prisingly simple. Its complete source is approximately 2,500 lines of shell and C. 2 Using deet deet's features are best explained by seeing it in action. First, the target program is compiled by lcc <ref> [3] </ref> with the appropriate debugging option to embed the nub in the target: $ lcc -Wf-g4 wf.c lookup.c Here and in the displays below, slanted type identifies user input.
Reference: [4] <author> M. Golan and D. R. Hanson. </author> <title> DUELa very high-level debugging language. </title> <booktitle> In Proceedings of the Winter USENIX Technical Conference, </booktitle> <pages> pages 107 117, </pages> <address> San Diego, CA, </address> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: Another approach would have been to modify gdb's code, but past experience shows that modifying gdb is a painstaking process <ref> [4] </ref>. Using tksh makes the approach illustrated in Figure 10 much simpler: the implementation takes only about 500 lines. The only nub feature that was not possible to implement with gdb was setting breakpoints on any expres sion. Some nub functions were relatively easy to implement, but not efficiently. <p> For example, programmers throw C expressions at gdb to browse the state of a buggy target. The advantage of this approach is that programmers don't have to learn another language to use the debugger. But, as Acid [15] and Duel <ref> [4] </ref> demonstrate, exploring a program's state is fundamentally different than writing the function frame - # [num] [[ $1 != "" ]] && deet_frame $1 2&gt; /dev/null set -- $(deet_frame) typeset num=$1 name=$2 file=$3 line=$4 char=$5 typeset params="$(deet_sym -params)" p result result="#$num $name (" eval set -A parm $params for p
Reference: [5] <author> D. R. Hanson. </author> <title> Variable associations in SNOBOL4. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 6(2):245254, </volume> <month> Apr. </month> <year> 1976. </year>
Reference-contexts: For these uses, deet provides linkvar name, which creates a new shell variable that is essentially an alias for the target variable name. linkvar is implemented with discipline functions, which are similar to trapped variables in SNOBOL4 <ref> [5] </ref>. A discipline function is a shell function that is associated with a variable, and that function is invoked whenever the variable is read or written.
Reference: [6] <author> D. R. Hanson and M. Raghavachari. </author> <title> A machine-independent debugger. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 26(11):12771299, </volume> <month> Nov. </month> <year> 1996. </year>
Reference-contexts: Thus, programmers can modify and extend both parts of deet by writing tksh code. 3.1 Cdb and deet deet is based on cdb <ref> [6] </ref>. cdb is a machine independent debugger that eliminates machine dependencies by adding a small amount of information into the target program at compile time. cdb communicates with the target through a nuba small machine-independent interface that constitutes the core functionality of the debugger, as suggested by Figure 4. <p> C code would be, because it's written in a high-level language. deet can also can be modified during a debugging session to suit specific applications. 3.2 The Nub Interface The nub interface is designed to be as small as possible while supporting the fundamental debugging operations common to all debuggers <ref> [6] </ref>. Figure 5 summarizes the complete API. The nub does not support high-level facilities, such as expression evaluation or specific symbol-table formats, because these facilities can be implemented by other interfaces or by debuggers themselves. <p> If the second argument specifies a condition for the breakpoint, it's stored as the value for the breakpoint array entry. Finally, the source window (if it exists) is updated to highlight the set breakpoint. The nub interface can set and remove breakpoints, but it cannot single-step the target <ref> [6] </ref>. deet's step function implements single-stepping by setting and removing breakpoints: function step - if [[ $cdbMode != "step" ]]; then deet_breakpoint -set "" 0 0 fi cdbMode=step cdbgo # resume execution - Calling deet breakpoint with null values for the file, line number, and character number sets every breakpoint.
Reference: [7] <author> D. G. Korn. ksh: </author> <title> An extensible high level language. </title> <booktitle> In Proceedings of the Very High Level Languages Symposium (VHLL), </booktitle> <pages> pages 129146, </pages> <address> Santa Fe, NM, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: The user-interface part is written in tksh, a version of the new Korn shell <ref> [2, 7] </ref> that has been extended to support Tcl [12]. The target program is controlled by a nub, which provides debugging primitives, as detailed below. deet's implementation of and interaction with the nub is also written in tksh.
Reference: [8] <author> J. L. Korn. Tksh: </author> <title> A Tcl library for KornShell. </title> <booktitle> In Proceedings of the USENIX Tcl/Tk Workshop, </booktitle> <pages> pages 149159, </pages> <address> Monterey, CA, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: Users can perform most debugging actions by pointing and clicking, and data structures can be displayed graphically. The GUI is written with Tk [12]. deet is also programmable: Its capabilities can be extended by writing in either Tcl or in tksh, a variant of the Korn shell <ref> [8] </ref>. Nearly all of deet's implementation is machine-independent. It uses a small nub that provides facilities for communicating with the debugger and controlling the target. The nub-based approach permits deet to debug a target running on another machine.
Reference: [9] <author> E. Koutsofios and S. C. </author> <title> North. Applications of graph visualization. </title> <booktitle> In Proceedings of Graphics Interface 1994 Conference, </booktitle> <pages> pages 235245, </pages> <address> Banff, Canada, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: This feature is similar to that provided by the Data Display Debugger (ddd) [16], but the implementation is much simpler, because deet uses existing tools instead of building its own facilities. deet runs dotty, a program for drawing directed graphs <ref> [9] </ref>, to draw the graph, sending it the appropriate input for the data structure of interest. Figure 7 shows an example of dotty's output.
Reference: [10] <author> P. Maybee. NeD: </author> <title> The network extensible debugger. </title> <booktitle> In Proceedings of the Winter USENIX Technical Conference, </booktitle> <pages> pages 145153, </pages> <address> San Antonio, TX, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: If type represents int, deet type returns "int". Similarly, if type represents T *, E [n], or a structure type, deet type returns, respectively, the type identifier for T , n and the type identifier for E, and a list of names and type identifiers for the fields. NeD <ref> [10] </ref> is another debugger built on a set of debugging primitives. This set is larger than the set of nub functions and the NeD primitives are at a somewhat higher level. NeD's primitives are written in Tcl extended with a set of debugging functions.
Reference: [11] <institution> Microsoft Corp., Redmond, WA. Microsoft Visual C++, Reference Volume II, </institution> <year> 1993. </year>
Reference-contexts: pointers, the value of the referent is displayed; for structures and unions, the values of the fields are displayed. deet also displays the values of variables in balloon help pop-up windows when the cursor is left on top of the variables for sufficient time, similar to Microsoft's Visual C++ debugger <ref> [11] </ref>. A variable can be modified by clicking Modify in the variable window, which prompts the user to enter a new value. A variable may also be watched, which causes its value to be displayed in the variable window and updated as execution passes each potential breakpoint.
Reference: [12] <author> J. K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1994. </year>
Reference-contexts: It provides both textual and graphical interfaces to make it easy to use. Users can perform most debugging actions by pointing and clicking, and data structures can be displayed graphically. The GUI is written with Tk <ref> [12] </ref>. deet is also programmable: Its capabilities can be extended by writing in either Tcl or in tksh, a variant of the Korn shell [8]. Nearly all of deet's implementation is machine-independent. It uses a small nub that provides facilities for communicating with the debugger and controlling the target. <p> The user-interface part is written in tksh, a version of the new Korn shell [2, 7] that has been extended to support Tcl <ref> [12] </ref>. The target program is controlled by a nub, which provides debugging primitives, as detailed below. deet's implementation of and interaction with the nub is also written in tksh.
Reference: [13] <author> N. Ramsey and D. R. Hanson. </author> <title> A retargetable debugger. </title> <booktitle> Proceedings of the SIGPLAN'92 Conference on Programming Language Design and Implementation, SIGPLAN Notices, </booktitle> <address> 27(7):2231, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: enough features to support ddd. gdb features that were not implemented include: * Debugging a target that is already running, which gdb can on machines where this is possible. * Invoking target functions from the debugger; the nub doesn't support this feature, because a separate evaluation facility can support it <ref> [13] </ref>. * Examining core dumps; this feature could be supported by writing a nub specifically for browsing core dumps. * Interrupting a running target. * Handling signals. 7 Discussion deet's front end runs on any machine on which tksh runs, which currently includes virtually all UNIX variants, Windows NT and Windows
Reference: [14] <author> R. M. Stallman and R. H. Pesch. </author> <title> Using GDB: A guide to the GNU source-level debugger, GDB version 4.0. </title> <type> Technical report, </type> <institution> Free Software Foundation, </institution> <address> Cambridge, MA, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Other examples include setting conditional breakpoints and automating program testing. Debuggers that support programming facilities do exist, but often the language is idiosyncratic to either the debugger or the source language, or both, and hard to learn. Most debuggers are large and complex programs; for example, gdb <ref> [14] </ref> is about 150,000 lines of C. This complexity has some unfortunate consequences. First, debuggers are often themselves buggy, because, like any large program, their complexity and size makes them prone to errors and to inconsistent behaviors on different platforms.
Reference: [15] <author> P. Winterbottom. </author> <title> Acid: A debugger built from a language. </title> <booktitle> In Proceedings of the Winter USENIX Technical Conference, </booktitle> <pages> pages 211222, </pages> <address> San Fran-cisco, CA, </address> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: For example, programmers throw C expressions at gdb to browse the state of a buggy target. The advantage of this approach is that programmers don't have to learn another language to use the debugger. But, as Acid <ref> [15] </ref> and Duel [4] demonstrate, exploring a program's state is fundamentally different than writing the function frame - # [num] [[ $1 != "" ]] && deet_frame $1 2&gt; /dev/null set -- $(deet_frame) typeset num=$1 name=$2 file=$3 line=$4 char=$5 typeset params="$(deet_sym -params)" p result result="#$num $name (" eval set -A parm
Reference: [16] <author> A. Zeller and D. L utkehaus. </author> <title> DDD a free graphical front-end for UNIX debuggers. </title> <journal> SIGPLAN Notices, </journal> <volume> 31(1):2227, </volume> <month> January </month> <year> 1996. </year>
Reference-contexts: An important advantage using a shell as the debugging language is that the shell can use any external tool. For example, it's relatively easy to extend deet to display linked data structures graphically as directed graphs. This feature is similar to that provided by the Data Display Debugger (ddd) <ref> [16] </ref>, but the implementation is much simpler, because deet uses existing tools instead of building its own facilities. deet runs dotty, a program for drawing directed graphs [9], to draw the graph, sending it the appropriate input for the data structure of interest.
References-found: 16

