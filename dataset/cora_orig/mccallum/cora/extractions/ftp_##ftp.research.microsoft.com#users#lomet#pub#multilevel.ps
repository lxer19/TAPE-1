URL: ftp://ftp.research.microsoft.com/users/lomet/pub/multilevel.ps
Refering-URL: http://www.research.microsoft.com/db/phoenix/
Root-URL: http://www.research.microsoft.com
Title: MLR: A Recovery Method for Multi-level Systems  
Author: David B. Lomet 
Address: One Kendall Sq., Bldg. 700 Cambridge, MA 02139  
Affiliation: Digital Equipment Corp. Cambridge Research Lab  
Abstract: To achieve high concurrency in a database system has meant building a system that copes well with important special cases. Recent work on multi-level systems suggests a systematic way of providing high concur-rency. A multi-level system using locks permits restrictive low level locks of a subtransaction to be replaced with less restrictive high level locks when a sub-transaction commits, hence enhancing concurrency. This is possible because sub-transactions can be undone by executing high level compensation actions rather than by restoring a prior lower level state. We describe a recovery scheme, called Multi-Level Recovery (MLR) that logs this high level undo operation with the commit record for the subtransaction that it compensates, posting log records to only a single log. A variant of the method copes with nested transactions, and both nested and multi-level transactions can be treated in a unified fashion. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Beeri, C., Bernstein, P., Goodman, N., Lai, M., and Shasha, D. </author> <title> A concurrency control theory for nested transactions. </title> <booktitle> Proc. </booktitle> <month> PODC (August </month> <year> 1983) </year> <month> 45-62. </month>
Reference-contexts: Theoretical work was reported in <ref> [1, 10, 13] </ref>, and special cases were described in [6, 9, 17, 14]. An implementation of multi-level system recovery, restricted to two levels, is described in [20]. Here we briefly characterize multi-level systems.
Reference: [2] <author> Beeri, C., Schek, H.-J., and Weikum, G. </author> <title> Multilevel transaction management, </title> <booktitle> theoretical art or practical need? Lecture Notes in Computer Science, </booktitle> <volume> vol 303, </volume> <publisher> Springer-Verlag, </publisher> <year> 1988, </year> <pages> 135-154. </pages>
Reference-contexts: a tree structure change [15, 12]. * The ARIES recovery method [14] logs operations that update disk pages, but are re-interpreted (if necessary) during recovery to undo a record update even if the record has moved to a different page. 1.2 Explicit Multi-Level Systems Multi-level transactions were made explicit in <ref> [18, 19, 2] </ref>. Theoretical work was reported in [1, 10, 13], and special cases were described in [6, 9, 17, 14]. An implementation of multi-level system recovery, restricted to two levels, is described in [20]. Here we briefly characterize multi-level systems. <p> Hence, an abort within an OP i+1 operation can and must be recovered by execution of lower level compensation operations. 2.2 Concurrency Control Concurrency control requirements for recovery are nicely characterized in <ref> [2] </ref> as: "Recovery actions must participate in concurrency control protocols, just like ordinary actions." We assume that locking is used so as to ensure serializability and recoverability. <p> There should be fewer conflicts with the LOCK i+1 s than with the LOCK i s. The locking protocol above is an instance of an order preserving conflict based scheduler. In <ref> [2] </ref>, these schedulers were shown to correctly serialize multilevel systems.
Reference: [3] <author> Bernstein, P., Hadzilacos, V., and Goodman, N. </author> <title> Concurrency Control and Recovery in Database Systems, </title> <publisher> Addison Wesley (Reading, </publisher> <address> MA) 1987. </address>
Reference-contexts: 1 Introduction 1.1 Precursor Multi-level Methods Most of our understanding of concurrency control and recovery, e.g. two phase locking [5], serializability theory <ref> [3] </ref>, and before-image/after-image recovery [9] is based on treating disjoint resources in a uniform "single level" way. But, when examined in detail, database systems support multiple levels of abstraction and exploit the levels to improve concurrency.
Reference: [4] <author> Bernstein, P., Hsu, M. and Mann, B. </author> <title> Implementing Recoverable Requests Using Queues. </title> <booktitle> Proc. ACM SIGMOD Conf. </booktitle> <month> (June </month> <year> 1989) </year> <month> 112-122. </month>
Reference-contexts: The ordering can be made palindromic by commutativity, i.e. operations on disjoint resources commute. One example of the use of the layered abstraction technique is for building recoverable queues <ref> [4] </ref> on top of a database system. MLR solves two significant problems that arise in this. 1. Once an element is enqueued/dequeued from the queue, the low level database locks for these operations can be released. Only enqueue or de-queue locks need be retained, which can be defined to commute.
Reference: [5] <author> Eswaran, K., Gray, J., Lorie, R., Traiger, I. </author> <title> The notions of consistency and predicate locks in a database system. </title> <note> Comm ACM 19,11 (Nov 1975) 624-633. </note>
Reference-contexts: 1 Introduction 1.1 Precursor Multi-level Methods Most of our understanding of concurrency control and recovery, e.g. two phase locking <ref> [5] </ref>, serializability theory [3], and before-image/after-image recovery [9] is based on treating disjoint resources in a uniform "single level" way. But, when examined in detail, database systems support multiple levels of abstraction and exploit the levels to improve concurrency.
Reference: [6] <author> Garcia-Molina, H. </author> <title> Using semantic knowledge for transaction processing in a distributed database. </title> <note> ACM TODS 8,2 (June 1983) 186-213. </note>
Reference-contexts: Theoretical work was reported in [1, 10, 13], and special cases were described in <ref> [6, 9, 17, 14] </ref>. An implementation of multi-level system recovery, restricted to two levels, is described in [20]. Here we briefly characterize multi-level systems. We begin by describing "layers" of a multi-layer system, and then distinguish two kinds of layers, a "multi-level" layer and a nested transaction layer.
Reference: [7] <author> Garcia-Molina, H. and Salem, K. Sagas. </author> <booktitle> Proc. ACM SIGMOD Conf. </booktitle> <address> (June, 1987), San Fran-cisco, CA, </address> <pages> 249-259. </pages>
Reference-contexts: An ML layer implementor can determine the durability of the layer's transactions. Durability can be a declarative part of each layer's definition and can be enforced by the ML framework. For example, MLR can be used in a system that supports sagas <ref> [8, 7] </ref>. Transactions of a saga must be durable. But sagas need not be serializable. Com-pensatability is sufficient, and this may need substantially weaker locks. Traditionally, no locks are held between constituent transactions. Saga compensation is assumed to be possible regardless of other system activity.
Reference: [8] <author> Gray, J. </author> <title> The transaction concept: virtues and limitations. </title> <booktitle> Proc. VLDB Conf. (Sept. 1981) Cannes, France, </booktitle> <pages> 144-154. </pages>
Reference-contexts: An ML layer implementor can determine the durability of the layer's transactions. Durability can be a declarative part of each layer's definition and can be enforced by the ML framework. For example, MLR can be used in a system that supports sagas <ref> [8, 7] </ref>. Transactions of a saga must be durable. But sagas need not be serializable. Com-pensatability is sufficient, and this may need substantially weaker locks. Traditionally, no locks are held between constituent transactions. Saga compensation is assumed to be possible regardless of other system activity.
Reference: [9] <author> Gray, J., McJones, P., Blasgen, M., Lindsay, B., Lorie, R., Price, T., Putzulo, F., Traiger, I. </author> <title> The recovery manager of the System R database manager. </title> <note> ACM Computing Surveys 13,2 (June 1981) 223-242. </note>
Reference-contexts: 1 Introduction 1.1 Precursor Multi-level Methods Most of our understanding of concurrency control and recovery, e.g. two phase locking [5], serializability theory [3], and before-image/after-image recovery <ref> [9] </ref> is based on treating disjoint resources in a uniform "single level" way. But, when examined in detail, database systems support multiple levels of abstraction and exploit the levels to improve concurrency. <p> Theoretical work was reported in [1, 10, 13], and special cases were described in <ref> [6, 9, 17, 14] </ref>. An implementation of multi-level system recovery, restricted to two levels, is described in [20]. Here we briefly characterize multi-level systems. We begin by describing "layers" of a multi-layer system, and then distinguish two kinds of layers, a "multi-level" layer and a nested transaction layer. <p> L 0 is the only level for which OC is needed as of the time of a crash. Several approaches have been used. For example, System R <ref> [9] </ref> achieved RSS operation consistency by installing RSS operation consistent shadows during checkpoints. However, maximum flexibility in checkpointing and buffer management is achieved by having the OP 0 s act on single blocks that can be atomicly written to disk. <p> Systems where transactions need to acquire locks during rollback and that lack a subtransaction capability must make sure that a rolling back trans action is not itself subject to further rollback. System R <ref> [9] </ref> is an example. In special cases, it releases "low level" locks before commit, and then needs to re-acquire them should the transaction roll back.
Reference: [10] <author> Korth, H., Levy, E. and Silberschatz, A. </author> <title> A formal approach to recovery by compensating transactions. </title> <booktitle> Proc. VLDB Conf. </booktitle> <month> (August, </month> <year> 1990) </year> <month> Bris-bane, </month> <pages> 95-106. </pages>
Reference-contexts: Theoretical work was reported in <ref> [1, 10, 13] </ref>, and special cases were described in [6, 9, 17, 14]. An implementation of multi-level system recovery, restricted to two levels, is described in [20]. Here we briefly characterize multi-level systems.
Reference: [11] <author> Lomet, D. </author> <title> Recovery for shared disk systems using multiple redo logs. </title> <note> DEC Tech Report CRL90/4 (Oct 1990), </note> <institution> Cambridge Research Lab, </institution> <address> Cambridge, MA. </address>
Reference-contexts: An easy way to do this is to write a state identifier <ref> [11] </ref> in each block, write the state identifier seen by an operation in the log record for the operation, and increase the value of the state identifier to a new unique value as a consequence of executing the operation.
Reference: [12] <author> Lomet, D. and Salzberg, B. </author> <title> Concurrency and recovery for index trees. </title> <note> draft report (Dec 1990). </note>
Reference-contexts: ACM SIGMOD - 6/92/CA,USA c fl1992 ACM 0-89791-522-4/92/0005/0185...$1.50 Below are a few of the multi-level cases exploited by some existing systems. * Mutual exclusion via a semaphore guarantees atomicity of page writes. * B-tree concurrency methods hold locks on index nodes only for the duration of a tree structure change <ref> [15, 12] </ref>. * The ARIES recovery method [14] logs operations that update disk pages, but are re-interpreted (if necessary) during recovery to undo a record update even if the record has moved to a different page. 1.2 Explicit Multi-Level Systems Multi-level transactions were made explicit in [18, 19, 2].
Reference: [13] <author> Lynch, N. </author> <title> Multilevel atomicity- a new correctness criterion for database concurrency control. </title> <note> ACM TODS 8,4 (December 1983) 484-502. </note>
Reference-contexts: Theoretical work was reported in <ref> [1, 10, 13] </ref>, and special cases were described in [6, 9, 17, 14]. An implementation of multi-level system recovery, restricted to two levels, is described in [20]. Here we briefly characterize multi-level systems.
Reference: [14] <author> Mohan, C., Haderle, D., Lindsay, B., Pirahesh, H., and Schwarz, P. </author> <title> ARIES: A transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging. </title> <note> ACM TODS (to appear) and IBM Research Report RJ6649 (Jan 1989), </note> <institution> IBM Almaden Research Center, </institution> <address> San Jose, CA. </address>
Reference-contexts: 0-89791-522-4/92/0005/0185...$1.50 Below are a few of the multi-level cases exploited by some existing systems. * Mutual exclusion via a semaphore guarantees atomicity of page writes. * B-tree concurrency methods hold locks on index nodes only for the duration of a tree structure change [15, 12]. * The ARIES recovery method <ref> [14] </ref> logs operations that update disk pages, but are re-interpreted (if necessary) during recovery to undo a record update even if the record has moved to a different page. 1.2 Explicit Multi-Level Systems Multi-level transactions were made explicit in [18, 19, 2]. <p> Theoretical work was reported in [1, 10, 13], and special cases were described in <ref> [6, 9, 17, 14] </ref>. An implementation of multi-level system recovery, restricted to two levels, is described in [20]. Here we briefly characterize multi-level systems. We begin by describing "layers" of a multi-layer system, and then distinguish two kinds of layers, a "multi-level" layer and a nested transaction layer.
Reference: [15] <author> Mohan, C. and Levine, F. ARIES/IM: </author> <title> an efficient and high concurrency index management method using write-ahead logging. </title> <institution> IBM Research Report RJ 6846 (Aug 1989), IBM Almaden Research Center, </institution> <address> San Jose, CA. </address>
Reference-contexts: ACM SIGMOD - 6/92/CA,USA c fl1992 ACM 0-89791-522-4/92/0005/0185...$1.50 Below are a few of the multi-level cases exploited by some existing systems. * Mutual exclusion via a semaphore guarantees atomicity of page writes. * B-tree concurrency methods hold locks on index nodes only for the duration of a tree structure change <ref> [15, 12] </ref>. * The ARIES recovery method [14] logs operations that update disk pages, but are re-interpreted (if necessary) during recovery to undo a record update even if the record has moved to a different page. 1.2 Explicit Multi-Level Systems Multi-level transactions were made explicit in [18, 19, 2].
Reference: [16] <author> Rothermel, K. and Mohan, C. ARIES/NT: </author> <title> A recovery method based on write-ahead logging for nested transactions. </title> <booktitle> Proc. VLDB Conf. (August, </booktitle> <address> 1989) Amsterdam, Netherlands, </address> <pages> 337-346. </pages>
Reference-contexts: Our recovery method, called MLR, is reminiscent of ARIES/NT <ref> [16] </ref> and enjoys many of the same desirable features of that scheme. MLR copes correctly with both nested transactions (NTs) and with multi-level transactions (MLTs). It uses a single log for all levels, and thus presents a unified way of dealing with all levels.
Reference: [17] <author> Traiger, I. </author> <booktitle> Trends in systems aspects of database management. Proc. ICOD Conf., </booktitle> <address> Cambridge, MA (1983) </address>
Reference-contexts: Theoretical work was reported in [1, 10, 13], and special cases were described in <ref> [6, 9, 17, 14] </ref>. An implementation of multi-level system recovery, restricted to two levels, is described in [20]. Here we briefly characterize multi-level systems. We begin by describing "layers" of a multi-layer system, and then distinguish two kinds of layers, a "multi-level" layer and a nested transaction layer.
Reference: [18] <author> Weikum, G. and Schek, H.-J. </author> <booktitle> Architectural issues of transaction management in multi-layered systems. Proc. VLDB Conf. </booktitle> <month> (August, </month> <year> 1984), </year> <month> Sin-gapore, </month> <pages> 454-465. </pages>
Reference-contexts: a tree structure change [15, 12]. * The ARIES recovery method [14] logs operations that update disk pages, but are re-interpreted (if necessary) during recovery to undo a record update even if the record has moved to a different page. 1.2 Explicit Multi-Level Systems Multi-level transactions were made explicit in <ref> [18, 19, 2] </ref>. Theoretical work was reported in [1, 10, 13], and special cases were described in [6, 9, 17, 14]. An implementation of multi-level system recovery, restricted to two levels, is described in [20]. Here we briefly characterize multi-level systems. <p> We denote operations at a level L i as OP i s. We require here that all operations of a layer be at the same level, i.e. that the leveling be uniform, as it would be in a hierarchy of "virtual machines" as described in <ref> [18] </ref>. (In section 6, we discuss briefly a "layers of abstraction" generalization that does not require this uniformity of level.) Lowest level operations are defined to be L 0 . (Table 1 contains a list of the notation used in this paper.) 1.3 Our Effort In this paper we present an
Reference: [19] <author> Weikum, G. </author> <title> A theoretical foundation of multilevel concurrency control. </title> <booktitle> Proc. ACM PODS Conf. </booktitle> <address> (March 1986) Cambridge, MA. </address> <pages> 31-42. </pages>
Reference-contexts: a tree structure change [15, 12]. * The ARIES recovery method [14] logs operations that update disk pages, but are re-interpreted (if necessary) during recovery to undo a record update even if the record has moved to a different page. 1.2 Explicit Multi-Level Systems Multi-level transactions were made explicit in <ref> [18, 19, 2] </ref>. Theoretical work was reported in [1, 10, 13], and special cases were described in [6, 9, 17, 14]. An implementation of multi-level system recovery, restricted to two levels, is described in [20]. Here we briefly characterize multi-level systems.
Reference: [20] <author> Weikum, G., Hasse, C., Broessler, P., and Muth, P. </author> <title> Multi-level recovery. </title> <booktitle> Proc. ACM PODS Conf., </booktitle> <address> Nashville, Tenn (April, </address> <year> 1990). </year>
Reference-contexts: Theoretical work was reported in [1, 10, 13], and special cases were described in [6, 9, 17, 14]. An implementation of multi-level system recovery, restricted to two levels, is described in <ref> [20] </ref>. Here we briefly characterize multi-level systems. We begin by describing "layers" of a multi-layer system, and then distinguish two kinds of layers, a "multi-level" layer and a nested transaction layer.
References-found: 20

