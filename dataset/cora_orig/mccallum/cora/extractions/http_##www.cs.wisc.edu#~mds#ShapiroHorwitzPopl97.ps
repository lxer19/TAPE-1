URL: http://www.cs.wisc.edu/~mds/ShapiroHorwitzPopl97.ps
Refering-URL: http://www.cs.wisc.edu/~mds/mds.html
Root-URL: 
Email: horwitzg@cs.wisc.edu  
Title: Fast and Accurate Flow-Insensitive Points-To Analysis area: algorithm uses the first as a subroutine. Its
Author: Marc Shapiro and Susan Horwitz 
Note: Electronic mail: fmds,  The paper makes two contributions to work in this  The second  those of Steensgaard's algorithm. In practice, it appears to This work was supported in part by the National Science Foundation under grant CCR-8958530, and by the Defense Advanced Research Projects Agency under ARPA Order No. 8856 (monitored by the Office of Naval Research under contract N00014-92-J-1937).  
Address: 1210 West Dayton Street, Madison, WI 53706 USA  
Affiliation: Computer Sciences Department, University of Wisconsin-Madison  
Abstract: In order to analyze a program that involves pointers, it is necessary to have (safe) information about what each pointer points to. There are many different approaches to computing points-to information. This paper addresses techniques for flow- and context-insensitive in-terprocedural analysis of stack-based storage. * The first contribution is a set of experiments that explore the trade-offs between techniques previously defined by Lars Andersen and Bjarne Steens-gaard. The former has a cubic worst-case running time, while the latter is essentially linear. However, the former may be much more precise than the latter. We have found that in practice, Ander-sen's algorithm is consistently more precise than Steensgaard's. For small programs, there is very little difference in the times required by the two approaches; however, for larger programs, Ander-sen's algorithm can be much slower than Steens gaard's. * The second contribution is the definition of two new algorithms. The first algorithm can be "tuned" so that its worst-case time and space requirements, as well as its accuracy range from those of Steens-gaard to those of Andersen. We have experimented with several versions of this algorithm; one version provided a significant increase in accuracy over Steensgaard's algorithm, while keeping the running time within a factor of two. 
Abstract-found: 1
Intro-found: 1
Reference: [ABS94] <author> T. Austin, S. Breach, and G. Sohi. </author> <title> Efficient detection of all pointer and array access errors. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 290-301, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: The study used 61 C programs including Gnu Unix utilities, Spec benchmarks, and programs used for benchmarking by Landi [LRZ93] and by Austin <ref> [ABS94] </ref>. The tables in Figures 4 and 5 give the number of lines of preprocessed source code (with blank lines removed) for each test program.
Reference: [AHU74] <author> A.V. Aho, J.E. Hopcroft, and J.D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: In particular, whenever two variables v 1 and v 2 are both in the points-to set of some variable x, the nodes that represent v 1 and v 2 are merged (using fast union-find data structures <ref> [AHU74] </ref>). This can lead to two kinds of imprecision: 1. All points-to sets that contain v 1 will also contain v 2 (and vice versa). 2. Everything in the points-to set of v 1 will also be in the points-to set of v 2 (and vice versa).
Reference: [And94] <author> L. O. Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <month> May </month> <year> 1994. </year> <type> (DIKU report 94/19). </type>
Reference-contexts: The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive. Flow-sensitive analysis (e.g.: [LR92] [CBC93] [EGH94]) takes into account the order in which statements are executed, while flow-insensitive analysis (e.g.: [Wei80] [BCCH94] <ref> [And94] </ref> [Ste96b] [ZRL96] ), assumes that statements can be executed in any order. <p> This paper addresses techniques for flow- and context-insensitive analysis of stack-based storage. Even within this somewhat limited context there is a range of approaches that trade precision for speed. At one end is the algorithm defined by Andersen <ref> [And94] </ref>, 2 which may require O (n 3 ) time, where n is the size of the program. At the other end is the algorithm defined by Steensgaard [Ste96b], which runs in almost linear time, but which may produce less precise results than Ander-sen's analysis.
Reference: [BCCH94] <author> M. Burke, P. Carini, J.D. Choi, and M. Hind. </author> <title> Flow-insensitive interprocedural alias analysis in the presence of pointers. </title> <editor> In K. Pingali, U. Banerjee, D. Galernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing: Proceedings of the 7th International Workshop, volume 892 of Lecture Notes in Computer Science, </booktitle> <pages> pages 234-250, </pages> <address> Ithaca, NY, </address> <month> August </month> <year> 1994. </year> <note> Springer-Verlag. </note>
Reference-contexts: The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive. Flow-sensitive analysis (e.g.: [LR92] [CBC93] [EGH94]) takes into account the order in which statements are executed, while flow-insensitive analysis (e.g.: [Wei80] <ref> [BCCH94] </ref> [And94] [Ste96b] [ZRL96] ), assumes that statements can be executed in any order. <p> One can think of both Andersen's and Steensgaard's approaches as building a graph (sometimes called a storage shape graph [CWZ90] or an alias graph <ref> [BCCH94] </ref>) that represents the points-to relationships among the program's variables. The important difference between the two approaches has to do with the out-degree of the graph; Andersen allows each node to have an arbitrary number of out-edges, while Steensgaard allows only one out-edge.
Reference: [CBC93] <author> J.-D. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side-effects. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <year> 1993. </year>
Reference-contexts: Some have addressed tracking heap-allocated storage (e.g.: [JM81] [HPR89] [Hen90] [Deu90] [CWZ90] [Deu94] [GH96] [SRW96] ), while others have concentrated on stack-based storage. The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive. Flow-sensitive analysis (e.g.: [LR92] <ref> [CBC93] </ref> [EGH94]) takes into account the order in which statements are executed, while flow-insensitive analysis (e.g.: [Wei80] [BCCH94] [And94] [Ste96b] [ZRL96] ), assumes that statements can be executed in any order.
Reference: [CWZ90] <author> D.R. Chase, M. Wegman, and F. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <year> 1990. </year>
Reference-contexts: There has been a great deal of work on techniques for computing points-to information. Some have addressed tracking heap-allocated storage (e.g.: [JM81] [HPR89] [Hen90] [Deu90] <ref> [CWZ90] </ref> [Deu94] [GH96] [SRW96] ), while others have concentrated on stack-based storage. The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive. <p> One can think of both Andersen's and Steensgaard's approaches as building a graph (sometimes called a storage shape graph <ref> [CWZ90] </ref> or an alias graph [BCCH94]) that represents the points-to relationships among the program's variables. The important difference between the two approaches has to do with the out-degree of the graph; Andersen allows each node to have an arbitrary number of out-edges, while Steensgaard allows only one out-edge.
Reference: [Deu90] <author> A. Deutsch. </author> <title> On determining lifetime and aliasing of dynamically allocated data in higher-order functional specifications. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 157-168, </pages> <month> Jan-uary </month> <year> 1990. </year>
Reference-contexts: There has been a great deal of work on techniques for computing points-to information. Some have addressed tracking heap-allocated storage (e.g.: [JM81] [HPR89] [Hen90] <ref> [Deu90] </ref> [CWZ90] [Deu94] [GH96] [SRW96] ), while others have concentrated on stack-based storage. The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive.
Reference: [Deu94] <author> A. Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 230-241, </pages> <year> 1994. </year>
Reference-contexts: There has been a great deal of work on techniques for computing points-to information. Some have addressed tracking heap-allocated storage (e.g.: [JM81] [HPR89] [Hen90] [Deu90] [CWZ90] <ref> [Deu94] </ref> [GH96] [SRW96] ), while others have concentrated on stack-based storage. The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive.
Reference: [EGH94] <author> M. Emami, R. Ghiya, and L. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <year> 1994. </year>
Reference-contexts: Some have addressed tracking heap-allocated storage (e.g.: [JM81] [HPR89] [Hen90] [Deu90] [CWZ90] [Deu94] [GH96] [SRW96] ), while others have concentrated on stack-based storage. The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive. Flow-sensitive analysis (e.g.: [LR92] [CBC93] <ref> [EGH94] </ref>) takes into account the order in which statements are executed, while flow-insensitive analysis (e.g.: [Wei80] [BCCH94] [And94] [Ste96b] [ZRL96] ), assumes that statements can be executed in any order.
Reference: [GH96] <author> R. Ghiya and L.J. Hendren. </author> <title> Is it a tree, a dag, or a cyclic graph? A shape analysis for heap-directed pointers in C. </title> <booktitle> In ACM Symposium on Principles of Programming Languages. ACM, </booktitle> <address> New York, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: There has been a great deal of work on techniques for computing points-to information. Some have addressed tracking heap-allocated storage (e.g.: [JM81] [HPR89] [Hen90] [Deu90] [CWZ90] [Deu94] <ref> [GH96] </ref> [SRW96] ), while others have concentrated on stack-based storage. The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive.
Reference: [Hen90] <author> L. Hendren. </author> <title> Parallelizing Programs with Recursive Data Structures. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> Jan </month> <year> 1990. </year>
Reference-contexts: There has been a great deal of work on techniques for computing points-to information. Some have addressed tracking heap-allocated storage (e.g.: [JM81] [HPR89] <ref> [Hen90] </ref> [Deu90] [CWZ90] [Deu94] [GH96] [SRW96] ), while others have concentrated on stack-based storage. The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive.
Reference: [HPR89] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 28-40, </pages> <year> 1989. </year>
Reference-contexts: There has been a great deal of work on techniques for computing points-to information. Some have addressed tracking heap-allocated storage (e.g.: [JM81] <ref> [HPR89] </ref> [Hen90] [Deu90] [CWZ90] [Deu94] [GH96] [SRW96] ), while others have concentrated on stack-based storage. The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive.
Reference: [JM81] <editor> N.D. Jones and S.S. Muchnick. </editor> <title> Flow analysis and optimization of Lisp-like structures. </title> <editor> In S.S. Much-nick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 4, </volume> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: There has been a great deal of work on techniques for computing points-to information. Some have addressed tracking heap-allocated storage (e.g.: <ref> [JM81] </ref> [HPR89] [Hen90] [Deu90] [CWZ90] [Deu94] [GH96] [SRW96] ), while others have concentrated on stack-based storage. The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive.
Reference: [LR92] <author> W. Landi and B. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In SIG-PLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Some have addressed tracking heap-allocated storage (e.g.: [JM81] [HPR89] [Hen90] [Deu90] [CWZ90] [Deu94] [GH96] [SRW96] ), while others have concentrated on stack-based storage. The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive. Flow-sensitive analysis (e.g.: <ref> [LR92] </ref> [CBC93] [EGH94]) takes into account the order in which statements are executed, while flow-insensitive analysis (e.g.: [Wei80] [BCCH94] [And94] [Ste96b] [ZRL96] ), assumes that statements can be executed in any order.
Reference: [LRZ93] <author> W. Landi, B. Ryder, and S. Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 56-67, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The study used 61 C programs including Gnu Unix utilities, Spec benchmarks, and programs used for benchmarking by Landi <ref> [LRZ93] </ref> and by Austin [ABS94]. The tables in Figures 4 and 5 give the number of lines of preprocessed source code (with blank lines removed) for each test program.
Reference: [Ruf95] <author> E. Ruf. </author> <title> Context-sensitive alias analysis reconsidered. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 13-22, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: analysis takes into account the fact that a function must return to the site of the most recent call, while context-insensitive analysis propagates information from a call site, through the called function, and back to all call sites. (An interest-ing pair of papers that address this issue are [WL95] and <ref> [Ruf95] </ref>.) Flow and context sensitivity generally provide more precise results, but can also be more costly in terms of time and/or space. This paper addresses techniques for flow- and context-insensitive analysis of stack-based storage.
Reference: [SRW96] <author> M. Sagiv, T. Reps, and R. Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <booktitle> In ACM Symposium on Principles of Programming Languages. ACM, </booktitle> <address> New York, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: There has been a great deal of work on techniques for computing points-to information. Some have addressed tracking heap-allocated storage (e.g.: [JM81] [HPR89] [Hen90] [Deu90] [CWZ90] [Deu94] [GH96] <ref> [SRW96] </ref> ), while others have concentrated on stack-based storage. The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive.
Reference: [Ste96a] <author> B. Steensgaard. </author> <title> Points-to analysis by type inference of programs with structures and unions. </title> <booktitle> In International Conference on Compiler Construction, </booktitle> <month> April </month> <year> 1996. </year>
Reference-contexts: Calls to library routines other than malloc are treated like calls to functions with empty bodies 5 . Structures, unions, and arrays are all treated as single objects; i.e., an assignment to any field (any array element) is treated as an assignment to the object. (Recent work by Steensgaard <ref> [Ste96a] </ref> has addressed extensions to distinguish among the components of structured objects.) Tests were carried out on a Sparc 20/71 with 256 MB of RAM. The study used 61 C programs including Gnu Unix utilities, Spec benchmarks, and programs used for benchmarking by Landi [LRZ93] and by Austin [ABS94].
Reference: [Ste96b] <author> B. Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive. Flow-sensitive analysis (e.g.: [LR92] [CBC93] [EGH94]) takes into account the order in which statements are executed, while flow-insensitive analysis (e.g.: [Wei80] [BCCH94] [And94] <ref> [Ste96b] </ref> [ZRL96] ), assumes that statements can be executed in any order. <p> At one end is the algorithm defined by Andersen [And94], 2 which may require O (n 3 ) time, where n is the size of the program. At the other end is the algorithm defined by Steensgaard <ref> [Ste96b] </ref>, which runs in almost linear time, but which may produce less precise results than Ander-sen's analysis. The first contribution of this paper is a set of experiments that explore the actual trade-offs between An-dersen's and Steensgaard's approaches.
Reference: [Tar83] <author> R. Tarjan. </author> <title> Data structures and network flow algorithms. </title> <booktitle> volume CMBS44 of Regional Conference Series in Applied Mathematics. </booktitle> <publisher> SIAM, </publisher> <year> 1983. </year>
Reference-contexts: case, for out-degree k, this algorithm uses O (k 2 N ) space and O (k 2 n ff (k 2 n; k 2 n) log k N ) time, where ff is the (very slowly growing) inverse Ackermann's function that arises in the context of fast union/find data structures <ref> [Tar83] </ref>, N is the number of variables, and n is the size of the program. 3 Thus, for a fixed value of k, its asymptotic complexity is slightly worse (by a factor of log N ) than that of Steensgaard's algorithm.
Reference: [Wei80] <author> W.E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables, and label variables. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <year> 1980. </year>
Reference-contexts: The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive. Flow-sensitive analysis (e.g.: [LR92] [CBC93] [EGH94]) takes into account the order in which statements are executed, while flow-insensitive analysis (e.g.: <ref> [Wei80] </ref> [BCCH94] [And94] [Ste96b] [ZRL96] ), assumes that statements can be executed in any order.
Reference: [WL95] <author> R. Wilson and M. Lam. </author> <title> Efficient context-sensitive pointer analysis for C programs. </title> <booktitle> In SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Similarly, context-sensitive analysis takes into account the fact that a function must return to the site of the most recent call, while context-insensitive analysis propagates information from a call site, through the called function, and back to all call sites. (An interest-ing pair of papers that address this issue are <ref> [WL95] </ref> and [Ruf95].) Flow and context sensitivity generally provide more precise results, but can also be more costly in terms of time and/or space. This paper addresses techniques for flow- and context-insensitive analysis of stack-based storage.
Reference: [ZRL96] <author> S. Zhang, B. G. Ryder, and W. Landi. </author> <title> Program decomposition for pointer-induced aliasing analysis. </title> <type> Technical report, </type> <institution> Rutgers University LCSR-TR-259, </institution> <year> 1996. </year>
Reference-contexts: The latter can be further classified as flow-sensitive or flow-insensitive, and as context-sensitive or context-insensitive. Flow-sensitive analysis (e.g.: [LR92] [CBC93] [EGH94]) takes into account the order in which statements are executed, while flow-insensitive analysis (e.g.: [Wei80] [BCCH94] [And94] [Ste96b] <ref> [ZRL96] </ref> ), assumes that statements can be executed in any order.
References-found: 23

