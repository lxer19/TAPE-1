URL: http://www.research.microsoft.com/~rehof/popl97.ps
Refering-URL: http://www.research.microsoft.com/~rehof/publications.html
Root-URL: http://www.research.microsoft.com
Email: rehof@diku.dk  
Title: Minimal Typings in Atomic Subtyping  
Author: Jakob Rehof 
Address: Denmark  
Affiliation: DIKU, Department of Computer Science University of Copenhagen,  
Abstract: This paper studies the problem of simplifying typings and the size-complexity of most general typings in typed programming languages with atomic subtyping. We define a notion of minimal typings relating all typings which are equivalent with respect to instantiation. The notion of instance is that of Fuh and Mishra [13], which supports many interesting simplifications. We prove that every typable term has a unique minimal typing, which is the logically most succinct among all equivalent typings. We study completeness properties, with respect to our notion of minimality, of well-known simplification techniques. Drawing upon these results, we prove a tight exponential lower bound for the worst case dag-size of constraint sets as well as of types in most general typings. To the best of our knowledge, the best previously proven lower bound was linear. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference: [2] <author> A.V. Aho, R. Garey, and J.D. Ullman. </author> <title> The transitive reduction of a directed graph. </title> <journal> SIAM Journal of Computing, </journal> <volume> 1(2) </volume> <pages> 131-137, </pages> <month> June </month> <year> 1972. </year>
Reference-contexts: on atomic constraint sets: C ffi = C n (fA A j A A 2 Cg [ C fl = transitive closure of C C = fC 0 j (C 0 ) fl = C fl g In case C is acyclic, C is the transitive reduction of C (see <ref> [2] </ref>), which uniquely satisfies (C ) fl = C fl and whenever (C 0 ) fl = C fl then C C 0 .
Reference: [3] <author> A. Aiken and E.L. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings FPCA '93, Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pages 31-42, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Moreover, systems of subtyping are becoming increasingly used in non-standard ways in type based program analysis, where program properties of a typed language are automatically extracted from the program text using inference algorithms, e.g., <ref> [3, 4, 16] </ref>. In all cases, subtyping adds expressiveness to a type system by allowing an expression to have several types depending on the context in which it occurs.
Reference: [4] <author> A. Aiken, E.L. Wimmers, </author> <title> and T.K. Lakshman. Soft typing with conditional types. </title> <booktitle> In Proc. 21st Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL), </booktitle> <address> Portland, Oregon. </address> <publisher> ACM Press, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: Moreover, systems of subtyping are becoming increasingly used in non-standard ways in type based program analysis, where program properties of a typed language are automatically extracted from the program text using inference algorithms, e.g., <ref> [3, 4, 16] </ref>. In all cases, subtyping adds expressiveness to a type system by allowing an expression to have several types depending on the context in which it occurs.
Reference: [5] <author> A. Aiken, E.L. Wimmers, and J. Palsberg. </author> <title> Optimal representations of polymorphic types with subtyping. </title> <type> Technical Report UCB/CSD-96-909, </type> <institution> University of Cal-ifornia, Berkeley, </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: The problem has generated a significant amount of work which aims at simplifying constraints in the typings generated by type inference algorithms; works addressing the subtype simplification problem include <ref> [13, 10, 19, 30, 11, 26, 32, 12, 5] </ref>. As is argued in [5], simplification is beneficial for at least three reasons: first, it may speed up type inference, second, it makes types more readable, and, third, it makes the information content of a typing more explicit. <p> The problem has generated a significant amount of work which aims at simplifying constraints in the typings generated by type inference algorithms; works addressing the subtype simplification problem include [13, 10, 19, 30, 11, 26, 32, 12, 5]. As is argued in <ref> [5] </ref>, simplification is beneficial for at least three reasons: first, it may speed up type inference, second, it makes types more readable, and, third, it makes the information content of a typing more explicit. <p> For more examples consult works on subtype simplification, such as <ref> [13, 10, 19, 30, 11, 17, 26, 32, 5] </ref>. t 2 = fff fl; fl fig; ; ` P x:x : ff ! fi t 4 = ;; ; ` P x:x : ff ! ff The next example is taken from [13]: Example 3.3 Let comp be the composition combinator <p> More subtle notions of instance and soundness are possible, for example such that are given by semantic concepts rather than the syntactic notion of instance used here. Recent works taking this approach to simplification include 3 <ref> [32, 26, 5] </ref>. <p> As far as we know, our notion of minimality is the first purely logical notion, which relates all typings in a given equivalence class, independently of particular transformations. Recent work by Pottier [26], by Trifonov and Smith [32] and by Aiken, Wimmers and Palsberg <ref> [5] </ref> introduce more powerful notions of simplification for polymorphic constrained types, based on semantic subtyping and entailment relations. Moreover, the paper by Aiken, Wimmers and Palsberg initiates a systematic study of completeness properties of simplification procedures.
Reference: [6] <author> H.P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <year> 1984. </year>
Reference: [7] <author> H.P. Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In S. Abramsky, D.M. Gabbay, and T.S.E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume II, </volume> <pages> pages 117-309. </pages> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Subtyping is a fundamental idea in type systems for programming languages, which can in principle be integrated into standard type systems and type inference for languages such as, e.g., the simply typed lambda calculus <ref> [7] </ref>, ML [22], Haskell [18], Miranda [33] as well as being a basic notion in typed object oriented languages, see e.g.[15, 11, 1]. Type inference algorithms infer type information from programs without requiring programmers to insert explicit type declarations in the program and discovers many programming errors at compile time.
Reference: [8] <author> Marcin Benke. </author> <title> Efficient type reconstruction in the presence of inheritance. </title> <booktitle> In Mathematical Foundations of Computer Science (MFCS), </booktitle> <pages> pages 272-280. </pages> <publisher> Springer Verlag, LNCS 711, </publisher> <year> 1993. </year>
Reference-contexts: -SAT is NP-complete (P -SAT is: given atomic constraint set C over P , determine if C is satisfiable in P .) This result holds for P = n-crown, for all n 2, and it has been used by several researchers in the study of the complexity of subtype inference <ref> [31, 21, 8, 9] </ref>. 6 A related phenomenon is noticed by Pottier [26] for simplification with recursive types.
Reference: [9] <author> Marcin Benke. </author> <title> Some complexity bounds for subtype inequalities. </title> <type> Technical Report TR 95-20 (220), </type> <institution> Warsaw University, Institute of Informatics, Warsaw University, Poland, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: -SAT is NP-complete (P -SAT is: given atomic constraint set C over P , determine if C is satisfiable in P .) This result holds for P = n-crown, for all n 2, and it has been used by several researchers in the study of the complexity of subtype inference <ref> [31, 21, 8, 9] </ref>. 6 A related phenomenon is noticed by Pottier [26] for simplification with recursive types.
Reference: [10] <author> P. Curtis. </author> <title> Constrained quantification in polymorphic type analysis. </title> <type> Technical Report CSL-90-1, </type> <note> Xerox Parc, </note> <month> February </month> <year> 1990. </year>
Reference-contexts: The problem has generated a significant amount of work which aims at simplifying constraints in the typings generated by type inference algorithms; works addressing the subtype simplification problem include <ref> [13, 10, 19, 30, 11, 26, 32, 12, 5] </ref>. As is argued in [5], simplification is beneficial for at least three reasons: first, it may speed up type inference, second, it makes types more readable, and, third, it makes the information content of a typing more explicit. <p> For more examples consult works on subtype simplification, such as <ref> [13, 10, 19, 30, 11, 17, 26, 32, 5] </ref>. t 2 = fff fl; fl fig; ; ` P x:x : ff ! fi t 4 = ;; ; ` P x:x : ff ! ff The next example is taken from [13]: Example 3.3 Let comp be the composition combinator
Reference: [11] <author> J. Eifrig, S. Smith, and V. Trifonov. </author> <title> Sound polymorphic type inference for objects. </title> <booktitle> In Proceedings OOPSLA '95, </booktitle> <year> 1995. </year>
Reference-contexts: The problem has generated a significant amount of work which aims at simplifying constraints in the typings generated by type inference algorithms; works addressing the subtype simplification problem include <ref> [13, 10, 19, 30, 11, 26, 32, 12, 5] </ref>. As is argued in [5], simplification is beneficial for at least three reasons: first, it may speed up type inference, second, it makes types more readable, and, third, it makes the information content of a typing more explicit. <p> For more examples consult works on subtype simplification, such as <ref> [13, 10, 19, 30, 11, 17, 26, 32, 5] </ref>. t 2 = fff fl; fl fig; ; ` P x:x : ff ! fi t 4 = ;; ; ` P x:x : ff ! ff The next example is taken from [13]: Example 3.3 Let comp be the composition combinator
Reference: [12] <author> M. F-ahndrich and A. Aiken. </author> <title> Making set-constraint program analyses scale. In Workshop on Set Constraints, </title> <address> Cambridge MA, </address> <year> 1996. </year>
Reference-contexts: The problem has generated a significant amount of work which aims at simplifying constraints in the typings generated by type inference algorithms; works addressing the subtype simplification problem include <ref> [13, 10, 19, 30, 11, 26, 32, 12, 5] </ref>. As is argued in [5], simplification is beneficial for at least three reasons: first, it may speed up type inference, second, it makes types more readable, and, third, it makes the information content of a typing more explicit.
Reference: [13] <author> Y. Fuh and P. Mishra. </author> <title> Polymorphic subtype inference: Closing the theory-practice gap. </title> <booktitle> In Proc. Int'l J't Conf. on Theory and Practice of Software Development, </booktitle> <pages> pages 167-183, </pages> <address> Barcelona, Spain, March 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The presence of such assumptions are necessitated by the desire to have most general (principal) typings, which summarize all possible typings for a given term. A form of subtyping which is logically simple and natural, yet expressive enough to be interesting, is atomic subtyping <ref> [23, 24, 13, 14] </ref> where only subtyping relations between atoms (type variables or constants) can occur in typings. <p> However, even though several type inference algorithms have appeared for atomic subtyping (e.g., <ref> [24, 13, 14] </ref>), it is generally recognized that major obstacles remain for subtype inference to become practicable in a large scale setting. <p> The problem has generated a significant amount of work which aims at simplifying constraints in the typings generated by type inference algorithms; works addressing the subtype simplification problem include <ref> [13, 10, 19, 30, 11, 26, 32, 12, 5] </ref>. As is argued in [5], simplification is beneficial for at least three reasons: first, it may speed up type inference, second, it makes types more readable, and, third, it makes the information content of a typing more explicit. <p> In this paper we give a positive answer to the first question, and we use this result to answer the second question by determining the worst case size of both constraint sets and types in principal typings relative to the instance relation defined by Fuh and Mishra in <ref> [13] </ref>. More specifically, the paper contains the following results: 1. We define a notion of minimal typings for atomic sub typing and show that every typable term has a unique minimal typing. <p> Intuitively, a minimal typing is a log-ically most succinct presentation of all possible equivalent typings for a term, where equivalence is defined in terms of the instance relation defined in <ref> [13] </ref>. Surprisingly, no such notion has, to our knowledge, been studied previously. The instance relation of [13] is important, because it is natural and powerful enough to validate pragmatically important simplifications. <p> Intuitively, a minimal typing is a log-ically most succinct presentation of all possible equivalent typings for a term, where equivalence is defined in terms of the instance relation defined in <ref> [13] </ref>. Surprisingly, no such notion has, to our knowledge, been studied previously. The instance relation of [13] is important, because it is natural and powerful enough to validate pragmatically important simplifications. The notion of minimality is surprisingly strong, and therefore the result that minimal typings exist can be used to derive non-trivial properties about the type system (see below.) 2. <p> Having an independent notion of minimality we can ask whether known simplification techniques are complete for minimization (computing minimal typings.) We give completeness and incompleteness results for the simplification techniques introduced in <ref> [13] </ref>. We show that minimization under the instance relation of [13] cannot be computed in polynomial time, unless P = NP. Among other things, this supports the claim that quite powerful simplifications can be captured in the framework studied here. 3. <p> Having an independent notion of minimality we can ask whether known simplification techniques are complete for minimization (computing minimal typings.) We give completeness and incompleteness results for the simplification techniques introduced in <ref> [13] </ref>. We show that minimization under the instance relation of [13] cannot be computed in polynomial time, unless P = NP. Among other things, this supports the claim that quite powerful simplifications can be captured in the framework studied here. 3. <p> Among other things, this supports the claim that quite powerful simplifications can be captured in the framework studied here. 3. We prove, perhaps the main result of the paper, a tight exponential lower bound for the size of most general typings relative to the instance relation of <ref> [13] </ref>. This is a non-trivial result, because the instance relation used validates quite powerful simplifications. To the best of our knowledge, the best previous result is the linear lower bound proven in [17] for a whole class of so-called sound instance relations. <p> To the best of our knowledge, the best previous result is the linear lower bound proven in [17] for a whole class of so-called sound instance relations. Our result shows that there is an intrinsic limit to what simplification under instance relations not stronger than that of <ref> [13] </ref> can ever achieve. The proof uses new techniques and draws in an essential way upon results mentioned under both items 1 and 2 above. It is perhaps worth stressing that the lower bound result is still interesting, even if one considers stronger instance relations than the one adopted here. <p> In this case, the result can be viewed as a lower bound for a subclass of sound simplifications, namely those which can be validated under the instance relation of <ref> [13] </ref>. This remark is further clarified in Section 3 below. The remainder of this paper is organized as follows. Section 2 introduces the type system, which appears in Appendix A, and Section 2 also contains some additional technical preliminaries. <p> We consider typing judgements t of the form t = C; ` P M : t in the standard system of atomic subtyping studied in, e.g., [23], [24], <ref> [13] </ref>, [14]. The type system is a proof system for deriving such judgements, and it is given in Appendix A for reference. <p> We sometimes write the application of a finite substitution in reverse order, as in Cfff 7! Ag. 3 Instance relation and sound simplifications The following definition gives the instance relation as defined by Fuh and Mishra in <ref> [13] </ref>. There the relation is called lazy instance, here it is just called the instance relation. Alternative instance relations are mentioned below. <p> For more examples consult works on subtype simplification, such as <ref> [13, 10, 19, 30, 11, 17, 26, 32, 5] </ref>. t 2 = fff fl; fl fig; ; ` P x:x : ff ! fi t 4 = ;; ; ` P x:x : ff ! ff The next example is taken from [13]: Example 3.3 Let comp be the composition combinator <p> examples consult works on subtype simplification, such as [13, 10, 19, 30, 11, 17, 26, 32, 5]. t 2 = fff fl; fl fig; ; ` P x:x : ff ! fi t 4 = ;; ; ` P x:x : ff ! ff The next example is taken from <ref> [13] </ref>: Example 3.3 Let comp be the composition combinator defined by comp = f:g:x:f (gx) Then both of the following typings are principal for comp: t 1 = fffi ff; fl; fi g; ; ` P comp : (ff ! fi) ! (fl ! ffi) ! ( ! ) t 2 <p> See <ref> [13, 17] </ref> for comparisons. <p> The proof of the following lemma uses that judgements are consistent. One can then show that it is sound to eliminate cycles in an atomic constraint set, by substituting all elements of a cycle to a single atom (compare also <ref> [13] </ref>.) This leads to Lemma 4.9 If t = C; ` P M : t is fully substituted with C consistent, then C is acyclic. <p> We analyze the so-called G- and S-transformations defined by Fuh and Mishra in <ref> [13] </ref>. The main technical result is Theorem 5.6 below, which shows that under certain restricted conditions, S-simplification is complete for minimization. This result is used in a critical way in the lower bound proof in Section 6. <p> The weaker one is called G-simplification, the stronger one is called G-minimization. They both eliminate internal variables from constraint sets. To recall from <ref> [13] </ref> the definition of G-simplification, let " C (A) = fA j C ` P A A g # C (A) = fA 0 j C ` P A 0 Ag Given variable ff 2 Var (C), we say that ff is G-subsumed by an atom A with respect to C, <p> Note that 1 = 2 and t 1 = t 2 , whenever t 1 7! g t 2 . If t 1 7! g t 2 , then t 1 t 2 , as shown in <ref> [13] </ref>. G-simplification can be regarded as an efficiently computable 5 approximation to a more powerful transformation 5 A low order polynomial time procedure is in [13]. 7! g + called G-minimization, which can be defined as fol-lows. <p> If t 1 7! g t 2 , then t 1 t 2 , as shown in <ref> [13] </ref>. G-simplification can be regarded as an efficiently computable 5 approximation to a more powerful transformation 5 A low order polynomial time procedure is in [13]. 7! g + called G-minimization, which can be defined as fol-lows. <p> Observe that both 7! g and 7! g + are terminating, since the size of Intv (t) shrinks at every reduction step. Normalization with respect to g + is accomplished by the procedure minimize in <ref> [13] </ref>. Fuh and Mishra [13] remark that finding a g + -normal form of a typing t appears to require exhaustive search through Subst (t) in the worst case, which, if true, would mean that G-minimization is exponential in the size of C [P . <p> Observe that both 7! g and 7! g + are terminating, since the size of Intv (t) shrinks at every reduction step. Normalization with respect to g + is accomplished by the procedure minimize in <ref> [13] </ref>. Fuh and Mishra [13] remark that finding a g + -normal form of a typing t appears to require exhaustive search through Subst (t) in the worst case, which, if true, would mean that G-minimization is exponential in the size of C [P . We strengthen this remark technically in Theorem 5.3 below. <p> We then define, following Fuh and Mishra <ref> [13] </ref>, the reduction 7! s on typings: Let t 1 = C 1 ; 1 ` P M : t 1 and t 2 = C 2 ; 2 ` P M : t 2 ; then t 1 7! s t 2 iff &gt; &gt; &lt; (1) ff s A <p> Since it follows from standard type inference algorithms such as those of [24] and <ref> [13] </ref> that a principal atomic typing can be obtained by extracting a set C of (possibly non-atomic) constraints of size linear in the size of the term followed by a match-step which expands and decomposes C to atomic constraints under at most an exponential blow-up, we have Corollary 6.3 For any <p> the techniques presented in this paper can be used to prove exponential lower bounds for at least some of the more powerful frameworks one could naturally suggest. 8 Related work Most closely related to the present work is that of Hoang and Mitchell [17] and that of Fuh and Mishra <ref> [13] </ref>. In [17], the authors prove a linear lower bound on the size of principal typings for a whole class of sound instance relations. <p> The pioneering work by Fuh and Mishra <ref> [13] </ref> on subtype simplification provided important background in the form of their Sand G-transformations. Fuh and Mishra operate with a notion of minimal typings, but their notion is defined in terms of their transformations, and, as shown by our incompleteness results, this notion is distinct from ours.
Reference: [14] <author> Y. Fuh and P. Mishra. </author> <title> Type inference with sub-types. </title> <journal> Theoretical Computer Science (TCS), </journal> <volume> 73 </volume> <pages> 155-175, </pages> <year> 1990. </year>
Reference-contexts: The presence of such assumptions are necessitated by the desire to have most general (principal) typings, which summarize all possible typings for a given term. A form of subtyping which is logically simple and natural, yet expressive enough to be interesting, is atomic subtyping <ref> [23, 24, 13, 14] </ref> where only subtyping relations between atoms (type variables or constants) can occur in typings. <p> However, even though several type inference algorithms have appeared for atomic subtyping (e.g., <ref> [24, 13, 14] </ref>), it is generally recognized that major obstacles remain for subtype inference to become practicable in a large scale setting. <p> We consider typing judgements t of the form t = C; ` P M : t in the standard system of atomic subtyping studied in, e.g., [23], [24], [13], <ref> [14] </ref>. The type system is a proof system for deriving such judgements, and it is given in Appendix A for reference.
Reference: [15] <editor> C.A. Gunter and J.C. Mitchell, editors. </editor> <booktitle> Theoretical Aspects of Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference: [16] <author> F. Henglein and C. Mossin. </author> <title> Polymorphic binding-time analysis. </title> <booktitle> In Proc. European Symposium on Programming (ESOP), </booktitle> <address> Edinburgh, Scotland. </address> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1994. </year> <note> Also DIKU Semantics Report D-198. </note>
Reference-contexts: Moreover, systems of subtyping are becoming increasingly used in non-standard ways in type based program analysis, where program properties of a typed language are automatically extracted from the program text using inference algorithms, e.g., <ref> [3, 4, 16] </ref>. In all cases, subtyping adds expressiveness to a type system by allowing an expression to have several types depending on the context in which it occurs.
Reference: [17] <author> M. Hoang and J.C. Mitchell. </author> <title> Lower bounds on type inference with subtypes. </title> <booktitle> In Proc. 22nd Annual ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 176-185. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: However, even though several type inference algorithms have appeared for atomic subtyping (e.g., [24, 13, 14]), it is generally recognized that major obstacles remain for subtype inference to become practicable in a large scale setting. To quote from <ref> [17] </ref>, "the main problems seem to be that the algorithm is inefficient, and the output, even for relatively simple input expressions, appears excessively long and cumbersome to read". <p> This is a non-trivial result, because the instance relation used validates quite powerful simplifications. To the best of our knowledge, the best previous result is the linear lower bound proven in <ref> [17] </ref> for a whole class of so-called sound instance relations. Our result shows that there is an intrinsic limit to what simplification under instance relations not stronger than that of [13] can ever achieve. <p> For more examples consult works on subtype simplification, such as <ref> [13, 10, 19, 30, 11, 17, 26, 32, 5] </ref>. t 2 = fff fl; fl fig; ; ` P x:x : ff ! fi t 4 = ;; ; ` P x:x : ff ! ff The next example is taken from [13]: Example 3.3 Let comp be the composition combinator <p> The reason is that it may be too costly, in terms of computational complexity, to verify that highly subtle soundness conditions are 3 See also <ref> [17] </ref> where a generic notion of sound instance relation is defined, based on syntactic concepts. 4 We note, for completeness, that [24] uses a less powerful notion of instance (relating fewer typings) which cannot validate many of the simplifications that are sound under . See [13, 17] for comparisons. <p> See <ref> [13, 17] </ref> for comparisons. <p> prove a tight worst case exponential lower bound for the dag-size of both constraint sets and types in principal typings (Theorem 6.2 below.) To the best of our knowledge, the best lower bound previously proven is the linear lower bound for a whole class of sound instance relations shown in <ref> [17] </ref>. The results of Section 4 as well as Theorem 5.6 are important ingredients in the lower bound proof to be presented below. For ! we know (see [20]) that while textual type size can be exponential, dag-size (see, e.g., [20] and [25]Chapter 11.3) is at most linear. <p> problem, and we conjecture that some of the techniques presented in this paper can be used to prove exponential lower bounds for at least some of the more powerful frameworks one could naturally suggest. 8 Related work Most closely related to the present work is that of Hoang and Mitchell <ref> [17] </ref> and that of Fuh and Mishra [13]. In [17], the authors prove a linear lower bound on the size of principal typings for a whole class of sound instance relations. <p> presented in this paper can be used to prove exponential lower bounds for at least some of the more powerful frameworks one could naturally suggest. 8 Related work Most closely related to the present work is that of Hoang and Mitchell <ref> [17] </ref> and that of Fuh and Mishra [13]. In [17], the authors prove a linear lower bound on the size of principal typings for a whole class of sound instance relations.
Reference: [18] <author> P. Hudak and J. Fasel. </author> <title> A gentle introduction to Haskell. </title> <journal> Sigplan Notices, 27(5):Section T, </journal> <year> 1992. </year>
Reference-contexts: 1 Introduction Subtyping is a fundamental idea in type systems for programming languages, which can in principle be integrated into standard type systems and type inference for languages such as, e.g., the simply typed lambda calculus [7], ML [22], Haskell <ref> [18] </ref>, Miranda [33] as well as being a basic notion in typed object oriented languages, see e.g.[15, 11, 1]. Type inference algorithms infer type information from programs without requiring programmers to insert explicit type declarations in the program and discovers many programming errors at compile time.
Reference: [19] <author> S. Kaes. </author> <title> Type inference in the presence of overloading, subtyping and recursive types. </title> <booktitle> In Proc. ACM Conf. on LISP and Functional Programming (LFP), </booktitle> <address> San Francisco, California, </address> <pages> pages 193-204. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1992. </year> <title> also in LISP Pointers, </title> <journal> Vol. V, </journal> <volume> Number 1, </volume> <month> January-March </month> <year> 1992. </year>
Reference-contexts: The problem has generated a significant amount of work which aims at simplifying constraints in the typings generated by type inference algorithms; works addressing the subtype simplification problem include <ref> [13, 10, 19, 30, 11, 26, 32, 12, 5] </ref>. As is argued in [5], simplification is beneficial for at least three reasons: first, it may speed up type inference, second, it makes types more readable, and, third, it makes the information content of a typing more explicit. <p> For more examples consult works on subtype simplification, such as <ref> [13, 10, 19, 30, 11, 17, 26, 32, 5] </ref>. t 2 = fff fl; fl fig; ; ` P x:x : ff ! fi t 4 = ;; ; ` P x:x : ff ! ff The next example is taken from [13]: Example 3.3 Let comp be the composition combinator
Reference: [20] <author> P. Kanellakis, H. Mairson, and J.C. Mitchell. </author> <title> Unification and ML type reconstruction. </title> <editor> In J.-L. Lassez and G. Plotkin, editors, </editor> <booktitle> Computational Logic | Essays in Honor of Alan Robinson. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The results of Section 4 as well as Theorem 5.6 are important ingredients in the lower bound proof to be presented below. For ! we know (see <ref> [20] </ref>) that while textual type size can be exponential, dag-size (see, e.g., [20] and [25]Chapter 11.3) is at most linear. The basic property responsible for this is that the type system of ! imposes enough equality constraints, in the sense of [34], that sharing yields exponential succinctness. <p> The results of Section 4 as well as Theorem 5.6 are important ingredients in the lower bound proof to be presented below. For ! we know (see <ref> [20] </ref>) that while textual type size can be exponential, dag-size (see, e.g., [20] and [25]Chapter 11.3) is at most linear. The basic property responsible for this is that the type system of ! imposes enough equality constraints, in the sense of [34], that sharing yields exponential succinctness. <p> To take a contrasting example, ML is not purely equational, and with its universal quantifier and its succinct let-expressions we get doubly exponential textual size of types and exponential dag-size, in the worst case (see <ref> [20, 25] </ref> with further references.) Subtyping is a system based on inequalities, and, as shown below, this leads to exponential dag-size of typings (constraint sets as well as of types) due to the fact that exponentially many distinct variables may have to be present in a principal typing. <p> It is not difficult to write down a series of lambda terms that will produce types of textual size exponential in the size of the terms. A well known (see <ref> [20, 25] </ref>) series of terms with this property is D n M , the n-fold application of the "duplicator" D = x:hx; xi to M . <p> Strong lower bounds for this class of relations are expectedly harder to obtain than corresponding lower bounds for the framework studied here, since less information is available about instance related typings. Also, the techniques used by Kanellakis, Mairson and Mitchell in <ref> [20] </ref> to analyze type size for simply typed lambda calculus and ML are related to our technique for the lower bound proof in Section 6, but the main part of that proof relies on new techniques tailored for subtyping.
Reference: [21] <author> P. Lincoln and J.C. Mitchell. </author> <title> Algorithmic aspects of type inference with subtypes. </title> <booktitle> In Proc. 19th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programmin Languages (POPL), </booktitle> <address> Albuquerque, New Mexico, </address> <pages> pages 293-304. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: -SAT is NP-complete (P -SAT is: given atomic constraint set C over P , determine if C is satisfiable in P .) This result holds for P = n-crown, for all n 2, and it has been used by several researchers in the study of the complexity of subtype inference <ref> [31, 21, 8, 9] </ref>. 6 A related phenomenon is noticed by Pottier [26] for simplification with recursive types.
Reference: [22] <author> R. Milner, M. Tofte., and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Subtyping is a fundamental idea in type systems for programming languages, which can in principle be integrated into standard type systems and type inference for languages such as, e.g., the simply typed lambda calculus [7], ML <ref> [22] </ref>, Haskell [18], Miranda [33] as well as being a basic notion in typed object oriented languages, see e.g.[15, 11, 1]. Type inference algorithms infer type information from programs without requiring programmers to insert explicit type declarations in the program and discovers many programming errors at compile time.
Reference: [23] <author> J.C. Mitchell. </author> <title> Coercion and type inference (summary). </title> <booktitle> In Proc. 11th ACM Symp. on Principles of Programming Languages (POPL), </booktitle> <pages> pages 175-185, </pages> <year> 1984. </year>
Reference-contexts: The presence of such assumptions are necessitated by the desire to have most general (principal) typings, which summarize all possible typings for a given term. A form of subtyping which is logically simple and natural, yet expressive enough to be interesting, is atomic subtyping <ref> [23, 24, 13, 14] </ref> where only subtyping relations between atoms (type variables or constants) can occur in typings. <p> We consider typing judgements t of the form t = C; ` P M : t in the standard system of atomic subtyping studied in, e.g., <ref> [23] </ref>, [24], [13], [14]. The type system is a proof system for deriving such judgements, and it is given in Appendix A for reference.
Reference: [24] <author> J.C. Mitchell. </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(3) </volume> <pages> 245-285, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: The presence of such assumptions are necessitated by the desire to have most general (principal) typings, which summarize all possible typings for a given term. A form of subtyping which is logically simple and natural, yet expressive enough to be interesting, is atomic subtyping <ref> [23, 24, 13, 14] </ref> where only subtyping relations between atoms (type variables or constants) can occur in typings. <p> However, even though several type inference algorithms have appeared for atomic subtyping (e.g., <ref> [24, 13, 14] </ref>), it is generally recognized that major obstacles remain for subtype inference to become practicable in a large scale setting. <p> Due to space limitations, proofs that are less illuminating had to be left out. They can be found in [29]. 2 Preliminaries We begin with a brief introduction to the system of atomic subtyping, which appears in Appendix A. For a more comprehensive account we refer the reader to <ref> [24] </ref>. <p> We consider typing judgements t of the form t = C; ` P M : t in the standard system of atomic subtyping studied in, e.g., [23], <ref> [24] </ref>, [13], [14]. The type system is a proof system for deriving such judgements, and it is given in Appendix A for reference. <p> The reason is that it may be too costly, in terms of computational complexity, to verify that highly subtle soundness conditions are 3 See also [17] where a generic notion of sound instance relation is defined, based on syntactic concepts. 4 We note, for completeness, that <ref> [24] </ref> uses a less powerful notion of instance (relating fewer typings) which cannot validate many of the simplifications that are sound under . See [13, 17] for comparisons. <p> Before proceeding with the main technical development we recall some standard basic lemmas for atomic subtyping systems (see <ref> [24] </ref>.) We say that two type expressions t and t 0 match if they have the same shape. <p> Once we have completed the constructions, we shall show how to encode them in the "pure" lambda calculus with no additional constructs. We shall consider the form of principal typings of terms. We use the fact, shown in <ref> [24] </ref>, that a principal typing can always be obtained by the following standard procedure: (1) first extract subtyping constraints only at the leaves of the term (i.e., coercions are applied to variables and constants only), and then (2) perform a match-step in which a most general matching substitution (see [24] for <p> in <ref> [24] </ref>, that a principal typing can always be obtained by the following standard procedure: (1) first extract subtyping constraints only at the leaves of the term (i.e., coercions are applied to variables and constants only), and then (2) perform a match-step in which a most general matching substitution (see [24] for details) is applied to the extracted constraint set (the match-step may fail, but if so then the term has no typing with atomic subtyp ing at all) and finally (3) decompose the matching constraints into atomic constraints, using the Decomposition Lemma (any matching set can be decomposed) Once steps <p> Since it follows from standard type inference algorithms such as those of <ref> [24] </ref> and [13] that a principal atomic typing can be obtained by extracting a set C of (possibly non-atomic) constraints of size linear in the size of the term followed by a match-step which expands and decomposes C to atomic constraints under at most an exponential blow-up, we have Corollary 6.3 <p> one can show that (fl) C is satisfiable in 2-crown if and only if D ` ; e C The theorem follows from (fl) by NP- completeness of 2 crown-SAT, since the condition D ` ; e C can be checked in polynomial time by computing transitive closure (see, e.g., <ref> [24] </ref>.) 2 B.3 Proof of Proposition 5.5 We are to prove Proposition 5.5 Let t = C; ` P M : t and t 0 = clos (t).
Reference: [25] <author> J.C. Mitchell. </author> <title> Foundations for Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: To take a contrasting example, ML is not purely equational, and with its universal quantifier and its succinct let-expressions we get doubly exponential textual size of types and exponential dag-size, in the worst case (see <ref> [20, 25] </ref> with further references.) Subtyping is a system based on inequalities, and, as shown below, this leads to exponential dag-size of typings (constraint sets as well as of types) due to the fact that exponentially many distinct variables may have to be present in a principal typing. <p> It is not difficult to write down a series of lambda terms that will produce types of textual size exponential in the size of the terms. A well known (see <ref> [20, 25] </ref>) series of terms with this property is D n M , the n-fold application of the "duplicator" D = x:hx; xi to M .
Reference: [26] <author> F. Pottier. </author> <title> Simplifying subtyping constraints. </title> <booktitle> In Proceedings ICFP '96, International Conference on Functional Programming, </booktitle> <pages> pages 122-133. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1996. </year>
Reference-contexts: The problem has generated a significant amount of work which aims at simplifying constraints in the typings generated by type inference algorithms; works addressing the subtype simplification problem include <ref> [13, 10, 19, 30, 11, 26, 32, 12, 5] </ref>. As is argued in [5], simplification is beneficial for at least three reasons: first, it may speed up type inference, second, it makes types more readable, and, third, it makes the information content of a typing more explicit. <p> For more examples consult works on subtype simplification, such as <ref> [13, 10, 19, 30, 11, 17, 26, 32, 5] </ref>. t 2 = fff fl; fl fig; ; ` P x:x : ff ! fi t 4 = ;; ; ` P x:x : ff ! ff The next example is taken from [13]: Example 3.3 Let comp be the composition combinator <p> More subtle notions of instance and soundness are possible, for example such that are given by semantic concepts rather than the syntactic notion of instance used here. Recent works taking this approach to simplification include 3 <ref> [32, 26, 5] </ref>. <p> P , determine if C is satisfiable in P .) This result holds for P = n-crown, for all n 2, and it has been used by several researchers in the study of the complexity of subtype inference [31, 21, 8, 9]. 6 A related phenomenon is noticed by Pottier <ref> [26] </ref> for simplification with recursive types. Example 5.2 (2-crowns) A 2-crown is the poset with 4 elements 0; 1; 2; 3 ordered as shown below: 1 Let C be the set of internal variables, C = fff fl; fi fl; ff ffi; fi ffig. <p> As far as we know, our notion of minimality is the first purely logical notion, which relates all typings in a given equivalence class, independently of particular transformations. Recent work by Pottier <ref> [26] </ref>, by Trifonov and Smith [32] and by Aiken, Wimmers and Palsberg [5] introduce more powerful notions of simplification for polymorphic constrained types, based on semantic subtyping and entailment relations. Moreover, the paper by Aiken, Wimmers and Palsberg initiates a systematic study of completeness properties of simplification procedures.
Reference: [27] <author> V. Pratt and J. Tiuryn. </author> <title> Satisfiability of inequalities in a poset. </title> <note> Studia Logica (to appear). </note>
Reference-contexts: This poset will play a major role both in the proof of Theorem 5.3 below and in the lower bound proof in Section 6. Pratt and Tiuryn <ref> [27] </ref> studied so-called n-crowns to show that, for some finite posets P , the problem P -SAT is NP-complete (P -SAT is: given atomic constraint set C over P , determine if C is satisfiable in P .) This result holds for P = n-crown, for all n 2, and it <p> Thanks are due to Christian Mossin for a discussion about terms that generate hard constraint sets. Thanks also to Jerzy Tiuryn for helpful comments on [31], to Vaughan Pratt for helpful comments on <ref> [27] </ref> and to my referees and Sergei Soloviev for helpful comments on this paper. [const] C ` P b b 0 ; provided b P b 0 [ref] C ` P t t [trans] C ` P t t 0 C ` P t 0 t 00 C ` P t <p> The details left out are not so difficult to reconstruct from the sketch, but full details are in [29]. We are to prove: Theorem 5.3 If P 6= NP, then G-minimization cannot be computed in polynomial time for any partial order P . Proof. Recall from Example 5.2 (and <ref> [27] </ref>) the poset called 2-crown. In [27] it is shown that the problem 2-crown-SAT (satisfiability of atomic inequalities in 2-crown) is NP-complete. We will show that, if G-minimization could be computed in polynomial time, then 2-crown-SAT could also be solved in polynomial time, independently of the poset P . <p> We are to prove: Theorem 5.3 If P 6= NP, then G-minimization cannot be computed in polynomial time for any partial order P . Proof. Recall from Example 5.2 (and <ref> [27] </ref>) the poset called 2-crown. In [27] it is shown that the problem 2-crown-SAT (satisfiability of atomic inequalities in 2-crown) is NP-complete. We will show that, if G-minimization could be computed in polynomial time, then 2-crown-SAT could also be solved in polynomial time, independently of the poset P .
Reference: [28] <author> D. Prawitz. </author> <title> Natural deduction. </title> <publisher> Almquist & Wiksell, </publisher> <address> Uppsala 1965. </address>
Reference-contexts: made (via valid simplifications) in subtyping. 8 For example, the expression M = (z:hj z (x:y:x); z (x:y:y)ji) hj x; y ji 8 This can be explained in terms of the Curry-Howard isomorphism, because one cannot define logical conjunction as a derived notion from implication in minimal logic (see, e.g., <ref> [28] </ref>.) gets principal typing ;; fx : ff; y : ffg ` P M : (ff ! ff ! fi) ! fi This identification of types will render the lower-bound proof invalid for these encodings.
Reference: [29] <author> J. Rehof. </author> <title> Minimal typings in atomic subtyp-ing. </title> <type> Technical Report D-278, </type> <institution> DIKU, Dept. of Computer Science, University of Copenhagen, Denmark. </institution> <note> Available at http://www.diku.dk/research-groups/ topps/personal/rehof/publications.html, </note> <year> 1996. </year>
Reference-contexts: Section 7 contains some concluding remarks, and Section 8 ends the paper with a discussion of related work. Longer proofs are placed in Appendix B. Due to space limitations, proofs that are less illuminating had to be left out. They can be found in <ref> [29] </ref>. 2 Preliminaries We begin with a brief introduction to the system of atomic subtyping, which appears in Appendix A. For a more comprehensive account we refer the reader to [24]. <p> all n &gt; 0 one has: (a) The set D n = fS k (ff) j 0 k ng satisfies D n Var (C) (c) C ` P S n (ff) S n1 (ff) All three items are proven simultaneously by induction on n &gt; 0 (full details are in <ref> [29] </ref>.) Now, to prove the lemma, consider the set V = fS n (ff) j n 0g By property (a) of our claim above, we have V Var (C), and therefore V is a finite set of variables with S an injection of V into itself (and, by finiteness of V <p> Property (iii) follows by the same reasoning. 2 * fl ffi ff fi B.2 Proof of Theorem 5.3 We sketch the proof of Theorem 5.3. The details left out are not so difficult to reconstruct from the sketch, but full details are in <ref> [29] </ref>. We are to prove: Theorem 5.3 If P 6= NP, then G-minimization cannot be computed in polynomial time for any partial order P . Proof. Recall from Example 5.2 (and [27]) the poset called 2-crown.
Reference: [30] <author> G. S. Smith. </author> <title> Principal type schemes for functional programs with overloading and subtyping. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 23 </volume> <pages> 197-226, </pages> <year> 1994. </year>
Reference-contexts: The problem has generated a significant amount of work which aims at simplifying constraints in the typings generated by type inference algorithms; works addressing the subtype simplification problem include <ref> [13, 10, 19, 30, 11, 26, 32, 12, 5] </ref>. As is argued in [5], simplification is beneficial for at least three reasons: first, it may speed up type inference, second, it makes types more readable, and, third, it makes the information content of a typing more explicit. <p> For more examples consult works on subtype simplification, such as <ref> [13, 10, 19, 30, 11, 17, 26, 32, 5] </ref>. t 2 = fff fl; fl fig; ; ` P x:x : ff ! fi t 4 = ;; ; ` P x:x : ff ! ff The next example is taken from [13]: Example 3.3 Let comp be the composition combinator
Reference: [31] <author> J. Tiuryn. </author> <title> Subtype inequalities. </title> <booktitle> In Proc. 7th Annual IEEE Symp. on Logic in Computer Science (LICS), </booktitle> <address> Santa Cruz, California, </address> <pages> pages 308-315. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: -SAT is NP-complete (P -SAT is: given atomic constraint set C over P , determine if C is satisfiable in P .) This result holds for P = n-crown, for all n 2, and it has been used by several researchers in the study of the complexity of subtype inference <ref> [31, 21, 8, 9] </ref>. 6 A related phenomenon is noticed by Pottier [26] for simplification with recursive types. <p> Acknowledgements Foremostly, I am pleased to acknowledge my great debt to Fritz Henglein, and I am grateful for our countless discussions about type theory. Thanks are due to Christian Mossin for a discussion about terms that generate hard constraint sets. Thanks also to Jerzy Tiuryn for helpful comments on <ref> [31] </ref>, to Vaughan Pratt for helpful comments on [27] and to my referees and Sergei Soloviev for helpful comments on this paper. [const] C ` P b b 0 ; provided b P b 0 [ref] C ` P t t [trans] C ` P t t 0 C ` P
Reference: [32] <author> V. Trifonov and S. Smith. </author> <title> Subtyping constrained types. </title> <booktitle> In Proceedings SAS '96, Static Analysis Symposium, </booktitle> <address> Aachen, Germany, </address> <pages> pages 349-365. </pages> <publisher> Springer, </publisher> <year> 1996. </year> <note> Lecture Notes in Computer Science, vol.1145. </note>
Reference-contexts: The problem has generated a significant amount of work which aims at simplifying constraints in the typings generated by type inference algorithms; works addressing the subtype simplification problem include <ref> [13, 10, 19, 30, 11, 26, 32, 12, 5] </ref>. As is argued in [5], simplification is beneficial for at least three reasons: first, it may speed up type inference, second, it makes types more readable, and, third, it makes the information content of a typing more explicit. <p> For more examples consult works on subtype simplification, such as <ref> [13, 10, 19, 30, 11, 17, 26, 32, 5] </ref>. t 2 = fff fl; fl fig; ; ` P x:x : ff ! fi t 4 = ;; ; ` P x:x : ff ! ff The next example is taken from [13]: Example 3.3 Let comp be the composition combinator <p> More subtle notions of instance and soundness are possible, for example such that are given by semantic concepts rather than the syntactic notion of instance used here. Recent works taking this approach to simplification include 3 <ref> [32, 26, 5] </ref>. <p> As far as we know, our notion of minimality is the first purely logical notion, which relates all typings in a given equivalence class, independently of particular transformations. Recent work by Pottier [26], by Trifonov and Smith <ref> [32] </ref> and by Aiken, Wimmers and Palsberg [5] introduce more powerful notions of simplification for polymorphic constrained types, based on semantic subtyping and entailment relations. Moreover, the paper by Aiken, Wimmers and Palsberg initiates a systematic study of completeness properties of simplification procedures.
Reference: [33] <author> D. Turner. Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <booktitle> In Proc. Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 1-16, </pages> <address> Nancy, France, </address> <year> 1985. </year> <title> Springer. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <pages> 201. </pages>
Reference-contexts: 1 Introduction Subtyping is a fundamental idea in type systems for programming languages, which can in principle be integrated into standard type systems and type inference for languages such as, e.g., the simply typed lambda calculus [7], ML [22], Haskell [18], Miranda <ref> [33] </ref> as well as being a basic notion in typed object oriented languages, see e.g.[15, 11, 1]. Type inference algorithms infer type information from programs without requiring programmers to insert explicit type declarations in the program and discovers many programming errors at compile time.
Reference: [34] <author> M. Wand. </author> <title> A simple algorithm and proof for type inference. </title> <note> Fundamenta Informaticae, X:115-122, </note> <year> 1987. </year>
Reference-contexts: For ! we know (see [20]) that while textual type size can be exponential, dag-size (see, e.g., [20] and [25]Chapter 11.3) is at most linear. The basic property responsible for this is that the type system of ! imposes enough equality constraints, in the sense of <ref> [34] </ref>, that sharing yields exponential succinctness.
References-found: 34

