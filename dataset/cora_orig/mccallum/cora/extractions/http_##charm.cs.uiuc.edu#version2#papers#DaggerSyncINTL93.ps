URL: http://charm.cs.uiuc.edu/version2/papers/DaggerSyncINTL93.ps
Refering-URL: http://charm.cs.uiuc.edu/version2/papers/DaggerSyncINTL93.html
Root-URL: http://www.cs.uiuc.edu
Email: email gursoy@cs.uiuc.edu  email kale@cs.uiuc.edu  
Phone: phone (217) 333-5827  phone (217) 244-0094  
Title: Dagger: Combining the benefits of synchronous and asynchronous communication styles  
Author: Attila Gursoy Laximikant V. Kale 
Address: Urbana IL 61801  Urbana IL 61801  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract: Communication using blocking receives is the commonly used mechanism in parallel programming today. Message driven execution is an alternate mechanism which does not use receive style statements at all. The message driven execution style promotes the overlap of computation and communication: Programs written in this style exhibit increased latency tolerance their performance does not degrade significantly with latency. It also induces com-positionality multiple independently developed modules can be combined correctly without loss of efficiency. However, as the flow of control is not explicit in such programs, they are often difficult to develop and debug. We present a coordination language called Dagger to alleviate this problem. The language has been implemented in the Charm parallel programming system, and runs programs portably on a variety of parallel machines.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G.Agha, </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press. </publisher> <year> 1986. </year>
Reference-contexts: 1 to 4 and stops at 4 beyond 16 processors). 500 1500 2500 3500 1 2 4 8 16 32 64 128 256 time (ms) number of processors Concurrent Reductions blocking-receive 3 3 3 3 3 Dagger + + + 7 Related Work The original Actor model as described in <ref> [1] </ref> is purely message driven. The issue of synchronization within an actor was addressed in [8] which proposed the enable set construct. Using this, one may specify which messages may be processed in the new state.
Reference: [2] <author> W.Dally, and et al. </author> <title> "The J-Machine: A Fine-Grain Concurrent Computer", </title> <booktitle> In IFIP Congress, </booktitle> <year> 1989. </year>
Reference-contexts: Dealing with this latency is therefore a major objective in parallel processing. On the hardware side, this is being addressed by designing architectures that reduce the latency to the minimum. The ALLCACHE architecture of the KSR-1 machine, and the message-processor architecture of J-Machine <ref> [2] </ref> are examples of these attempts as well as the continuous evolution of communication hardware in the traditional architectures of Intel and NCUBE machines. However, physical reality dictates that remote access will always be significantly slower than local access. Software techniques for tolerating latency are therefore essential.
Reference: [3] <author> S.Frolund, G.Agha, </author> <title> "Activation of Concurrent Objects by Message Sets", </title> <type> Internal Report, </type> <institution> University of Illinois at Urbana-Champaign. </institution> <month> 16 </month>
Reference-contexts: Thus,this construct is analogous to our expect statement. However, there is no analogue of a when-block viz. a computation block that can be executed only when a specific group of messages have arrived. A more recent paper <ref> [3] </ref> supports much more complex model which subsumes synchronization of 15 multiple actors depending on message sets. It should be noted that Dagger/Charm provides a programming model that differs from Actors in many ways. The discussion above only focuses on how they deal with message driven execution.
Reference: [4] <author> T.von Eicken, D.E.Culler, S.C.Goldstein, K.E. Schauser, </author> <title> "Active Messages: a Mechanism for Integrated Communication and Computation", </title> <booktitle> Proceedings of the 19 th Int'l Symposium on Computer Architecture, </booktitle> <address> Australia, </address> <month> May </month> <year> 1992, </year> <month> pp256-266. </month>
Reference-contexts: The computation continues in this manner until the solution is reached. Figure 5 shows a dag BOC to carry out this dag branchoffice jacobi - ChareNumType mycid; PeNumType neighbour <ref> [4] </ref>; CONDVAR SEND; entry init : (message MSGINIT *msg); entry NORTH: (message BOUNDARY *north); entry SOUTH: (message BOUNDARY *south); entry WEST : (message BOUNDARY *west); entry EAST : (message BOUNDARY *east); entry CONVERGENCE : (message CONV_MSG *convergence); when init : - MyChareID (&mycid);initialize (); ready (SEND);- when SEND : BOUNDARY *m; <p> It should be noted that Dagger/Charm provides a programming model that differs from Actors in many ways. The discussion above only focuses on how they deal with message driven execution. Recent work on Active messages <ref> [4] </ref> also deals with message driven execution and split phase transactions. The split-C language based on this employs polling for arrival of messages. However the TAM compiler built on Active messages has some similarities to Dagger.
Reference: [5] <author> A.S.Grimshaw, </author> <title> Mentat : An Object Oriented Macro Data Flow System, UIUCDCS-R-88-1440, </title> <type> Ph.D Thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: Counters and flags for synchronizing on arrival of multiple messages are explicitly maintained. However, TAM is meant as the back end for a data flow compiler as opposed to a language meant application programmer. So these inconveniences may not be of much consequences. Macro data flow <ref> [5] </ref> approaches share with us the objective of message driven execution and local synchronization. However, much of the past work in this area has aimed that special purpose hardware. Also, again, these approaches are often meant to be used as a back-end for compilers.
Reference: [6] <author> L.V.Kale, </author> <title> "The Chare Kernel parallel programming language and system", </title> <booktitle> Proceedings of the International Conference on Parallel Processing, </booktitle> <volume> Vol II, </volume> <month> Aug </month> <year> 1990, </year> <month> pp17-25. </month>
Reference: [7] <author> E.Kornkven, </author> <title> "Overlapping Computation and Communication in an Implementation of A Data Parallel Language", </title> <type> Report 92-4, </type> <institution> Parallel Programming Laboratory, Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> Oct </month> <year> 1992. </year>
Reference-contexts: Thus the inconvenience of maintaining the counters and buffers explicitly is not considered significant. These approaches thus are comparable to Charm itself rather than Dagger. Our experience with using Dagger as back-end for a compiler for a data parallel language <ref> [7] </ref> indicates that the dagger might provide more convenient intermediate language than macro data flow. 8 Conclusion We presented a coordination language called Dagger which combines the efficiency of message driven execution with the conceptual simplicity of blocking-receives. Programming in blocking-receive paradigm is easier since it imposes a strict synchronization.
Reference: [8] <author> C.Tomlinson, V.Singh, </author> <title> "Inheritance and Synchronization with Enabled-Sets", </title> <booktitle> ACM OOP-SLA 1989 , pp103-112. </booktitle>
Reference-contexts: The issue of synchronization within an actor was addressed in <ref> [8] </ref> which proposed the enable set construct. Using this, one may specify which messages may be processed in the new state. Any other messages that are received by an actor are buffered until the current enable set includes them. Thus,this construct is analogous to our expect statement.
Reference: [9] <institution> The CHARM(3.0) programming language manual, Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana, IL, </institution> <year> 1992. </year> <month> 17 </month>
Reference-contexts: A number of asynchronous access and update calls are allowed on table entries. Additional information sharing abstractions supported include monotonic variables, writeonce variables and accumulators. Charm also provides a sophisticated module system that facilitates reuse, and large-scale programming for parallel software. Details about these features can be found in <ref> [9] </ref>. chare mult_chare - int count; ChareIDType chareid; int *row,*column; entry init : (message MSG *msg) - count = 2; MyChareID (&chareid); Find (Atable, msg-&gt;row_index, recv_row, &chareid,TBL_NEVER_WAIT); Find (Btable, msg-&gt;column_index,recv_column,&chareid,TBL_NEVER_WAIT); - entry recv_row : (message TBL_MSG *msg) - row = msg-&gt;data; if (--count == 0 ) multiply (row,column); - entry recv_column
References-found: 9

