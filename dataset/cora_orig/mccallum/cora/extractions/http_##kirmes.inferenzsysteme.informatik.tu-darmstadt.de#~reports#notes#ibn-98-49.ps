URL: http://kirmes.inferenzsysteme.informatik.tu-darmstadt.de/~reports/notes/ibn-98-49.ps
Refering-URL: http://www.inferenzsysteme.informatik.tu-darmstadt.de/~reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: E-mail: giesl@informatik.tu-darmstadt.de  
Title: The Critical Pair Lemma: A Case Study for Induction Proofs With Partial Functions  
Author: Jurgen Giesl 
Address: Alexanderstr. 10, 64283 Darmstadt, Germany,  
Affiliation: TU Darmstadt,  
Abstract: In [9] we presented a calculus for automated induction proofs about partial functions. In contrast to previous work, our approach also allows us to derive induction schemes from the recursions of partial (and in particular, non-terminating) algorithms. In this way, existing induction theorem provers can be directly extended to partial functions without changing their logical framework. This report contains a large collection of theorems from the area of term rewriting systems which were proved with our calculus (including Knuth and Bendix' well-known critical pair lemma). These examples demonstrate the power of our approach and they show that induction schemes based on partial functions are indeed needed frequently.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Bouhoula & M. Rusinowitch. </author> <title> Implicit Induction in Conditional Theories. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 14 </volume> <pages> 189-235, </pages> <year> 1995. </year>
Reference-contexts: For example, the well-known unification algorithm unifies by J. A. Robinson [18] is total, but its termination is a "deep theorem" [17] fl Technical Report IBN 98/49, Darmstadt University of Technology. 1 There are two research paradigms for the automation of induction proofs, viz. explicit and implicit induction (e.g. <ref> [1, 11] </ref>), where we only focus on the first one. 1 and none of the current methods for automated termination analysis succeeds with this example. Hence, such functions cannot be handled by (fully) automated theorem provers without the ability of reasoning about possibly partial functions. <p> The reason for using just one data type of termlists (instead of two separate mutually recursive types for terms and termlists) is that our formalization simplifies the proofs considerably. Techniques for automated reasoning about mutually recursive data types and algorithms can for instance be found in <ref> [1, 4, 8, 13] </ref>. The data type tll is used to represent lists of lists of terms.
Reference: [2] <author> R. S. Boyer & J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: 1 Introduction Induction is the essential proof method for the verification of functional programs. For that reason, several techniques 1 have been developed to compute suitable induction relations and to perform induction proofs automatically, cf. e.g. <ref> [2, 5, 12, 20, 21] </ref>. However, most of these techniques are only sound if all occurring functions are total. In [9] we showed that by slightly restricting the prerequisites of these techniques it is nevertheless possible to use them for partial functions, too. <p> def (n; l 1 ; l 2 ) ) def (applytwice (n; l 1 ; l 2 )) (35) 20 4.6 Transitivity of ge (pc) The next conjecture states that ge is transitive. ge (x; y) ^ ge (y; z) ) ge (x; z) (36) This example is used in <ref> [2] </ref> to demonstrate the need for merging induction relations. As described in [9] we can model this technique by using appropriate instantiations of non-induction variables in the induction hypotheses. Hence, the conjecture can easily be proved using (the extension of) Rule 1 00 . <p> For that purpose we use an induction w.r.t. both setdiff (k 3 ; k 2 ) and setdiff (k 3 ; k 1 ) (i.e. we perform an induction w.r.t. setdiff (k 3 ; k 2 ) and change the non-induction variable k 1 appropriately, cf. the merging technique of <ref> [2, 12] </ref>). In the base case (k 3 = empty) the proof is trivial. If k 3 = add (t; l) then we have to regard the different cases. If member (t; k 1 ), then (94) implies member (t; k 2 ).
Reference: [3] <author> J. Brauburger & J. Giesl. </author> <title> Termination Analysis for Partial Functions. </title> <booktitle> In Proc. 3rd SAS, </booktitle> <address> Aachen, Ger-many, </address> <note> LNCS 1145, 1996. Extended version appeared as Technical Report IBN 96/33, </note> <institution> TU Darmstadt, Germany. </institution>
Reference-contexts: Then the difference equivalents (hn; var (m; r)i; hn; ri) and (hn; func (m; s; r)i; hn; appendterm (s; r)i) are equivalent to true. (This ordering and the difference equivalents can easily be generated automatically using the techniques in <ref> [3, 7] </ref>.) Hence, we obtain the following domain predicate function occurs : nat fi term ! bool occurs (n; e) = true occurs (n; var (m; r)) = if (eq (n; m); true; occurs (n; r)) occurs (n; func (m; s; r)) = occurs (n; appendterm (s; r)). <p> Now occurs (n; t) = true can easily be proved by induction w.r.t. occurs . (In fact, the simplification techniques of <ref> [3] </ref> can directly simplify the above algorithm to true resp. the method of [7] can directly prove termination of the total algorithm occurs.) In a similar way one can also prove def (s; t) ) def (subseteq (s; t)): (25) 4.5 Totality of append, member, subseteq list, disjoint list, is empty,
Reference: [4] <author> F. Bronsard, U. S. Reddy, & R. W. Hasker. </author> <title> Induction Using Term Orders. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 16 </volume> <pages> 3-37, </pages> <year> 1996. </year>
Reference-contexts: The reason for using just one data type of termlists (instead of two separate mutually recursive types for terms and termlists) is that our formalization simplifies the proofs considerably. Techniques for automated reasoning about mutually recursive data types and algorithms can for instance be found in <ref> [1, 4, 8, 13] </ref>. The data type tll is used to represent lists of lists of terms.
Reference: [5] <author> A. Bundy, A. Stevens, F. van Harmelen, A. Ireland, & A. Smaill. Rippling: </author> <title> A Heuristic for Guiding Inductive Proofs. </title> <journal> Artificial Intelligence, </journal> <volume> 62 </volume> <pages> 185-253, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Induction is the essential proof method for the verification of functional programs. For that reason, several techniques 1 have been developed to compute suitable induction relations and to perform induction proofs automatically, cf. e.g. <ref> [2, 5, 12, 20, 21] </ref>. However, most of these techniques are only sound if all occurring functions are total. In [9] we showed that by slightly restricting the prerequisites of these techniques it is nevertheless possible to use them for partial functions, too.
Reference: [6] <author> M. Dauchet. </author> <title> Simulation of Turing Machines by a Left-Linear Rewrite Rule. </title> <booktitle> In Proc. </booktitle> <address> RTA '89, Chapel Hill, NC, </address> <publisher> LNCS 355, </publisher> <year> 1989. </year>
Reference-contexts: This algorithm is inherently partial, i.e. it may be non-terminating. Moreover, its domain is undecidable, since its termination corresponds to the termination of a one-rule term rewriting system <ref> [6] </ref>. function rewrites rule list* : tll fi term fi term fi term ! bool rewrites rule list*(empty; s; l; r) = false rewrites rule list*(add (t; k); s; l; r) = if (member (s; add (t; k)); true; if (subseteq list (rewrite rule list (add (t; k); l; r); add
Reference: [7] <author> J. Giesl. </author> <title> Termination Analysis for Functional Programs using Term Orderings. </title> <booktitle> In Proc. 2nd SAS, </booktitle> <address> Glas-gow, Scotland, </address> <publisher> LNCS 983, </publisher> <year> 1995. </year>
Reference-contexts: Then the difference equivalents (hn; var (m; r)i; hn; ri) and (hn; func (m; s; r)i; hn; appendterm (s; r)i) are equivalent to true. (This ordering and the difference equivalents can easily be generated automatically using the techniques in <ref> [3, 7] </ref>.) Hence, we obtain the following domain predicate function occurs : nat fi term ! bool occurs (n; e) = true occurs (n; var (m; r)) = if (eq (n; m); true; occurs (n; r)) occurs (n; func (m; s; r)) = occurs (n; appendterm (s; r)). <p> Now occurs (n; t) = true can easily be proved by induction w.r.t. occurs . (In fact, the simplification techniques of [3] can directly simplify the above algorithm to true resp. the method of <ref> [7] </ref> can directly prove termination of the total algorithm occurs.) In a similar way one can also prove def (s; t) ) def (subseteq (s; t)): (25) 4.5 Totality of append, member, subseteq list, disjoint list, is empty, hasevenlength, apply, onlyconsistsof, applytwice The following conjectures can again be proved by an <p> theorem we proceed in a similar way as in the proof of (24), i.e. we again generate the corresponding domain predicate using a relation which compares pairs of terms by the number of var- and func-occurrences in the first (or second) term. (This relation can easily be generated automatically, cf. <ref> [7] </ref>.) 39 5.4 Definedness of matcher and mgu The next conjecture states that the truth of matches implies the definedness of matcher. matches (s; t) ) def (matcher (s; t)) (180) This conjecture can be generalized to matches aux (s; t; ) ) def (matcher aux (s; t; )) which can
Reference: [8] <author> J. Giesl. </author> <title> Termination of Nested and Mutually Recursive Algorithms. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 19 </volume> <pages> 1-29, </pages> <year> 1997. </year>
Reference-contexts: The reason for using just one data type of termlists (instead of two separate mutually recursive types for terms and termlists) is that our formalization simplifies the proofs considerably. Techniques for automated reasoning about mutually recursive data types and algorithms can for instance be found in <ref> [1, 4, 8, 13] </ref>. The data type tll is used to represent lists of lists of terms.
Reference: [9] <author> J. Giesl. </author> <title> Induction Proofs with Partial Functions. </title> <type> Technical Report IBN 98/48, </type> <institution> TU Darmstadt, Ger-many, </institution> <year> 1998. </year>
Reference-contexts: For that reason, several techniques 1 have been developed to compute suitable induction relations and to perform induction proofs automatically, cf. e.g. [2, 5, 12, 20, 21]. However, most of these techniques are only sound if all occurring functions are total. In <ref> [9] </ref> we showed that by slightly restricting the prerequisites of these techniques it is nevertheless possible to use them for partial functions, too. <p> In this way, this successful method for finding appropriate induction relations automatically can be used for partial functions as well. Hence, with our approach the well-known techniques for automated induction proofs can be directly applied to partial functions. To show that the calculus developed in <ref> [9] </ref> can be used to prove relevant theorems about (possibly) partial functions, in the following case study we apply our calculus to prove prove more than 400 conjectures from the area of term rewriting systems (TRSs). <p> The (possibly) partial functions occurring in these conjectures can be divided into several classes, cf. <ref> [9, Section 7] </ref>. For example, there are partial functions like first, which returns the first element of a list of terms, but which is undefined if the termlist is empty. <p> Moreover, for an automatic transformation of such partial functions into total ones, in general reasoning about partial functions would still be required (cf. the problem with exactness proofs of domain predicates in <ref> [9] </ref>). But for many interesting algorithms their exact domain cannot be determined automatically at all. In particular, as the halting problem is undecidable (and as totality is not even semi-decidable), there are even many important total algorithms where totality cannot be verified automatically. <p> the termlist t with the rule l ! r. (Note that an algorithm like rewrite rule cannot only operate on terms instead of termlists, because to rewrite the term f (t fl ) one has to rewrite the termlist of its arguments t fl .) To simplify the presentation in <ref> [9] </ref>, we omitted the data type tll there. So the algorithm rewrites* from [9] corresponds to the algorithm rewrites list* exists in this report, the algorithm joinable from [9] corresponds to the algorithm joinable list in this report, and the formulation of the critical pair lemma is also slightly different. 3 <p> like rewrite rule cannot only operate on terms instead of termlists, because to rewrite the term f (t fl ) one has to rewrite the termlist of its arguments t fl .) To simplify the presentation in <ref> [9] </ref>, we omitted the data type tll there. So the algorithm rewrites* from [9] corresponds to the algorithm rewrites list* exists in this report, the algorithm joinable from [9] corresponds to the algorithm joinable list in this report, and the formulation of the critical pair lemma is also slightly different. 3 Algorithms 3.1 Basic Algorithms on bool, nat, and term 3.1.1 Negation on bool <p> term f (t fl ) one has to rewrite the termlist of its arguments t fl .) To simplify the presentation in <ref> [9] </ref>, we omitted the data type tll there. So the algorithm rewrites* from [9] corresponds to the algorithm rewrites list* exists in this report, the algorithm joinable from [9] corresponds to the algorithm joinable list in this report, and the formulation of the critical pair lemma is also slightly different. 3 Algorithms 3.1 Basic Algorithms on bool, nat, and term 3.1.1 Negation on bool function not : bool ! bool not (true) = false not (false) = true 3.1.2 <p> )) = false eqterm (func (n 1 ; s 1 ; r 1 ); func (n 2 ; s 2 ; r 2 )) = eq (n 1 ; n 2 ) ^: eqterm (s 1 ; s 1 ) ^: eqterm (r 1 ; r 2 ) As in <ref> [9] </ref>, "t 1 ^: t 2 " abbreviates "if (t 1 ; t 2 ; false)" and "t 1 ^: t 2 ^: : : :" abbreviates "t 1 ^: (t 2 ^: : : :)" to ease readability. 3.1.8 First Element of term function first : term ! term first <p> list (k 1 ; k 2 ); if (subseteq list (rewrite list (k 1 ; R); k 1 ); false; rewrites list* exists (append (k 1 ; rewrite list (k 1 ; R)); k 2 ; R)); true) A modification of this algorithm (which was called rewrites*) was discussed in <ref> [9, Section 7] </ref>. <p> As described in <ref> [9] </ref> we can model this technique by using appropriate instantiations of non-induction variables in the induction hypotheses. Hence, the conjecture can easily be proved using (the extension of) Rule 1 00 . <p> list (k 1 ; k 2 ) ^ rewrites list* exists (k; k 1 ; R) ) rewrites list* exists (k; k 2 ; R) (319) It can easily be proved by induction w.r.t. rewrites list* exists (k; k 1 ; R) using (122). (This proof was also sketched in <ref> [9] </ref>.) Note that in this way we proved inductive truth of this conjecture (instead of just partial truth). <p> Now we perform another induction w.r.t. n and k 1 (this is a structural induction about n, where k 1 is changed as in the algorithm rewrites rule list* exists, cf. the extension of Rule 1 00 and 2 00 by allowing arbitrary instantiations in induction hypotheses <ref> [9] </ref>). If n = 0, then by (136), (290), (292), (96) we know that subseteq list (rewrite rule list (k 1 ; l; r); k 1 ) also holds, i.e. in this case the conjecture is trivial. <p> ) joinable list (k 0 1 ; k 0 The proof is done by induction w.r.t. merged induction relations suggested by joinable list (k 1 ; k 2 ; R) and joinable list (k 0 1 ; k 0 2 ; R), cf. the extensions of Rule 1 00 in <ref> [9] </ref>. If disjoint list (k 0 1 ; k 0 2 ) = false, then the proof is trivial. Otherwise we also have disjoint list (k 1 ; k 2 ) = true (by (122)). <p> Case 2: r = func (n; u; r 0 ); eqterm (first (s); func (n; u; e)) = true; eqterm (first (t); func (n; u; e)) = true The proof for this case is almost identical to Case 1. 2 This formulation is slightly different from the one in <ref> [9, Section 7] </ref>, because in [9] we omitted the data type tll for the sake of brevity. 89 Case 3: r = func (n; u; r 0 ); eqterm (first (s); func (n; u; e)) = true; first is func (t); eq (func name (t); n); eqterm (tail (t); r 0 <p> func (n; u; r 0 ); eqterm (first (s); func (n; u; e)) = true; eqterm (first (t); func (n; u; e)) = true The proof for this case is almost identical to Case 1. 2 This formulation is slightly different from the one in [9, Section 7], because in <ref> [9] </ref> we omitted the data type tll for the sake of brevity. 89 Case 3: r = func (n; u; r 0 ); eqterm (first (s); func (n; u; e)) = true; first is func (t); eq (func name (t); n); eqterm (tail (t); r 0 ); rewrites rule (u; func
Reference: [10] <author> G. Huet. </author> <title> Confluent Reductions: Abstract Properties and Applications to Term Rewriting Systems. </title> <journal> Journal of the ACM 27(4) </journal> <pages> 797-821, </pages> <year> 1980. </year> <month> 92 </month>
Reference-contexts: In particular, with our calculus we can also prove partial truth of a variant of D. E. Knuth and P. B. Bendix' critical pair lemma [14] which states that if all critical pairs of a term rewriting system are joinable, then the system is locally confluent. As stressed in <ref> [10] </ref>, no assumption of termination is necessary for this conjecture. The proof of this fundamental theorem is the last one in our collection and most of the preceding conjectures are needed as lemmata for this proof.
Reference: [11] <author> D. Kapur & D. R. Musser. </author> <title> Proof by Consistency. </title> <journal> Artificial Intelligence, </journal> <volume> 31 </volume> <pages> 125-157, </pages> <year> 1987. </year>
Reference-contexts: For example, the well-known unification algorithm unifies by J. A. Robinson [18] is total, but its termination is a "deep theorem" [17] fl Technical Report IBN 98/49, Darmstadt University of Technology. 1 There are two research paradigms for the automation of induction proofs, viz. explicit and implicit induction (e.g. <ref> [1, 11] </ref>), where we only focus on the first one. 1 and none of the current methods for automated termination analysis succeeds with this example. Hence, such functions cannot be handled by (fully) automated theorem provers without the ability of reasoning about possibly partial functions.
Reference: [12] <author> D. Kapur & M. Subramaniam. </author> <title> New Uses of Linear Arithmetic in Automated Theorem Proving by Induction. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 16 </volume> <pages> 39-78, </pages> <year> 1996. </year>
Reference-contexts: 1 Introduction Induction is the essential proof method for the verification of functional programs. For that reason, several techniques 1 have been developed to compute suitable induction relations and to perform induction proofs automatically, cf. e.g. <ref> [2, 5, 12, 20, 21] </ref>. However, most of these techniques are only sound if all occurring functions are total. In [9] we showed that by slightly restricting the prerequisites of these techniques it is nevertheless possible to use them for partial functions, too. <p> For that purpose we use an induction w.r.t. both setdiff (k 3 ; k 2 ) and setdiff (k 3 ; k 1 ) (i.e. we perform an induction w.r.t. setdiff (k 3 ; k 2 ) and change the non-induction variable k 1 appropriately, cf. the merging technique of <ref> [2, 12] </ref>). In the base case (k 3 = empty) the proof is trivial. If k 3 = add (t; l) then we have to regard the different cases. If member (t; k 1 ), then (94) implies member (t; k 2 ).
Reference: [13] <author> D. Kapur & M. Subramaniam. </author> <title> Automating Induction over Mutually Recursive Functions. </title> <booktitle> In Proc. 5th AMAST, </booktitle> <address> Munich, Germany, </address> <publisher> LNCS 1101, </publisher> <year> 1996. </year>
Reference-contexts: The reason for using just one data type of termlists (instead of two separate mutually recursive types for terms and termlists) is that our formalization simplifies the proofs considerably. Techniques for automated reasoning about mutually recursive data types and algorithms can for instance be found in <ref> [1, 4, 8, 13] </ref>. The data type tll is used to represent lists of lists of terms.
Reference: [14] <author> D. E. Knuth & P. B. Bendix. </author> <title> Simple Word Problems in Universal Algebras. </title> <editor> In J. Leech (ed.), </editor> <booktitle> Computational Problems in Abstract Algebra, </booktitle> <pages> pp. 263-297, </pages> <publisher> Pergamon Press, Oxford, </publisher> <year> 1970. </year>
Reference-contexts: Hence, if one wants to prove any conjecture about such algorithms, one definitely needs a method to deal with partial functions. In particular, with our calculus we can also prove partial truth of a variant of D. E. Knuth and P. B. Bendix' critical pair lemma <ref> [14] </ref> which states that if all critical pairs of a term rewriting system are joinable, then the system is locally confluent. As stressed in [10], no assumption of termination is necessary for this conjecture. <p> Now both these conjectures again follow from (232), (233), (237), (121), (91), and (239). 9.2 Critical Pair Lemma (pc) In this section we prove (a variant of) the critical pair lemma of Knuth and Bendix <ref> [14] </ref> which states that if all critical pairs of a TRS are joinable, then the TRS is locally confluent 2 . trs (R) ^ jcp (R) ^ rewrites (r; s; R) ^ rewrites (r; t; R) ) joinable (s; t; R): (402) By Rule 4 00 , (402) is transformed into
Reference: [15] <author> Z. Manna & R. Waldinger. </author> <title> Deductive Synthesis of the Unification Algorithm. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 1 </volume> <pages> 5-48, </pages> <year> 1981. </year>
Reference-contexts: Hence, such functions cannot be handled by (fully) automated theorem provers without the ability of reasoning about possibly partial functions. In contrast to previous correctness proofs of the unification algorithm (e.g. <ref> [15, 17] </ref>, our calculus can prove its partial correctness by induction w.r.t. unifies without having to verify its termination. But even worse, there are numerous practically relevant partial algorithms whose domain is undecidable, i.e. there does not exist any exact domain predicate.
Reference: [16] <author> T. Nipkow. </author> <title> More Church-Rosser Proofs (in isabelle/hol). </title> <booktitle> In Proc. </booktitle> <address> CADE-13, New Brunswick, NJ, </address> <publisher> LNAI 1104, </publisher> <year> 1996. </year>
Reference-contexts: Our verification of the critical pair lemma required several inductions w.r.t. functions like rewrites* whose domains are undecidable. Thus, our proof differs substantially from other case studies in related areas (e.g. the proofs of the Church-Rosser theorem for the -calculus in <ref> [16, 19] </ref>). In Section 2 we introduce the data types and in Section 3 we give the definitions of all algorithms used. The remaining sections contain theorems proved with our calculus. For a detailed overview the reader is referred to the table of contents at the end of the report.
Reference: [17] <author> L. C. Paulson. </author> <title> Verifying the Unification Algorithm in lcf. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 5 </volume> <pages> 143-169, </pages> <year> 1985. </year>
Reference-contexts: In particular, as the halting problem is undecidable (and as totality is not even semi-decidable), there are even many important total algorithms where totality cannot be verified automatically. For example, the well-known unification algorithm unifies by J. A. Robinson [18] is total, but its termination is a "deep theorem" <ref> [17] </ref> fl Technical Report IBN 98/49, Darmstadt University of Technology. 1 There are two research paradigms for the automation of induction proofs, viz. explicit and implicit induction (e.g. [1, 11]), where we only focus on the first one. 1 and none of the current methods for automated termination analysis succeeds with <p> Hence, such functions cannot be handled by (fully) automated theorem provers without the ability of reasoning about possibly partial functions. In contrast to previous correctness proofs of the unification algorithm (e.g. <ref> [15, 17] </ref>, our calculus can prove its partial correctness by induction w.r.t. unifies without having to verify its termination. But even worse, there are numerous practically relevant partial algorithms whose domain is undecidable, i.e. there does not exist any exact domain predicate.
Reference: [18] <author> J. A. Robinson. </author> <title> A Machine Oriented Logic Based on the Resolution Principle. </title> <journal> Journal of the ACM, </journal> <volume> 12 </volume> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: In particular, as the halting problem is undecidable (and as totality is not even semi-decidable), there are even many important total algorithms where totality cannot be verified automatically. For example, the well-known unification algorithm unifies by J. A. Robinson <ref> [18] </ref> is total, but its termination is a "deep theorem" [17] fl Technical Report IBN 98/49, Darmstadt University of Technology. 1 There are two research paradigms for the automation of induction proofs, viz. explicit and implicit induction (e.g. [1, 11]), where we only focus on the first one. 1 and none
Reference: [19] <author> N. Shankar. </author> <title> A Mechanical Proof of the Church-Rosser Theorem, </title> <journal> Journal of the ACM, </journal> <volume> 35(3) </volume> <pages> 475-522, </pages> <year> 1988. </year>
Reference-contexts: Our verification of the critical pair lemma required several inductions w.r.t. functions like rewrites* whose domains are undecidable. Thus, our proof differs substantially from other case studies in related areas (e.g. the proofs of the Church-Rosser theorem for the -calculus in <ref> [16, 19] </ref>). In Section 2 we introduce the data types and in Section 3 we give the definitions of all algorithms used. The remaining sections contain theorems proved with our calculus. For a detailed overview the reader is referred to the table of contents at the end of the report.
Reference: [20] <author> C. Walther. </author> <title> Mathematical Induction. </title> <editor> In D. M. Gabbay, C. J. Hogger, and J. A. Robinson (eds.), </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming, </booktitle> <volume> vol. 2, </volume> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Induction is the essential proof method for the verification of functional programs. For that reason, several techniques 1 have been developed to compute suitable induction relations and to perform induction proofs automatically, cf. e.g. <ref> [2, 5, 12, 20, 21] </ref>. However, most of these techniques are only sound if all occurring functions are total. In [9] we showed that by slightly restricting the prerequisites of these techniques it is nevertheless possible to use them for partial functions, too.
Reference: [21] <author> H. Zhang, D. Kapur, & M. S. Krishnamoorthy. </author> <title> A Mechanizable Induction Principle for Equational Specifications. </title> <booktitle> In Proc. </booktitle> <address> CADE-9, Argonne, IL, </address> <publisher> LNCS 310, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Induction is the essential proof method for the verification of functional programs. For that reason, several techniques 1 have been developed to compute suitable induction relations and to perform induction proofs automatically, cf. e.g. <ref> [2, 5, 12, 20, 21] </ref>. However, most of these techniques are only sound if all occurring functions are total. In [9] we showed that by slightly restricting the prerequisites of these techniques it is nevertheless possible to use them for partial functions, too.
References-found: 21

