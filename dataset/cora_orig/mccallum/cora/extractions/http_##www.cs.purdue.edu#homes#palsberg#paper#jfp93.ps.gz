URL: http://www.cs.purdue.edu/homes/palsberg/paper/jfp93.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Email: palsberg@daimi.aau.dk  
Title: Correctness of Binding-time Analysis  
Author: Jens Palsberg 
Address: Ny Munkegade, DK-8000 Aarhus C, Denmark  
Affiliation: Computer Science Department, Aarhus University  
Note: Journal of Functional Programming (1993), vol. 3(3), pp. 347-363  
Abstract: In this paper we prove that a weaker condition implies consistency. Our condition is decidable, subsumes the one of Gomard and Jones, and was first studied by Schwartzbach and the present author. Our result implies the correctness of the binding-time analysis of Mogensen, and it indicates the correctness of the core of the binding-time analyses of Bondorf and Consel. We also prove that all partial evaluators will on termination have eliminated all "eliminable"-marked parts of an input which satisfies our condition. This generalizes a result of Gomard. Our development is for the pure -calculus with explicit binding-time annotations. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Barendregt, Henk P. </author> <year> 1981. </year> <title> The lambda calculus: Its syntax and semantics. </title> <publisher> North-Holland. </publisher>
Reference-contexts: In section 5 we state our results, and in section 6 we prove the required lemmas. Finally, in section 7 we conclude. 2 The 2-level -calculus As a basis for discussing the input to binding-time analyses we start by recalling the pure -calculus <ref> (Barendregt, 1981) </ref>. Definition 1 The language of -terms is defined by the grammar: E :: = x (variable) j x:E (abstraction) j E 1 @ E 2 (application) Correctness of Binding-time Analysis 3 An occurrence of (x:E) @ E 0 is called a redex.
Reference: <author> Bondorf, Anders. </author> <year> 1991. </year> <title> Automatic autoprojection of higher order recursive equations. </title> <booktitle> Science of computer programming, </booktitle> <pages> 17(1-3), 3-34. </pages>
Reference: <author> Bondorf, Anders, & Jtrgensen, Jesper. </author> <year> 1993. </year> <title> Efficient analyses for realistic off-line partial evaluation. </title> <journal> Journal of functional programming, </journal> <note> special issue on partial evaluation. </note>
Reference: <author> Consel, Charles. </author> <year> 1990. </year> <title> Binding time analysis for higher order untyped functional languages. </title> <booktitle> Pages 264-272 of: Proc. ACM conference on lisp and functional programming. </booktitle>
Reference: <author> Gomard, Carsten K. </author> <year> 1990. </year> <title> Partial type inference for untyped functional programs. </title> <booktitle> Pages 282-287 of: Proc. ACM conference on lisp and functional programming. </booktitle>
Reference: <author> Gomard, Carsten K. </author> <year> 1991 </year> <month> (November). </month> <title> Program analysis matters. </title> <type> Ph.D. thesis, </type> <institution> DIKU, University of Copenhagen. </institution> <type> DIKU Report 91-17. </type>
Reference-contexts: Partial evaluation then proceeds by attempting to evaluate the eliminable parts. A binding-time analysis is correct if it always produces consistent binding-time information. Consistency prevents partial evaluators from "going wrong". A partial evaluator "goes wrong" if it commits a so-called "projection error" <ref> (Gomard & Jones, 1991) </ref>, that is, if it trusts a part of the program to be of a particular form, of which it is not. A sufficient and decidable condition for consistency, called well-annotatedness, was first presented by Gomard and Jones (1991).
Reference: <author> Gomard, Carsten K., & Jones, Neil D. </author> <year> 1991. </year> <title> A partial evaluator for the untyped lambda-calculus. </title> <journal> Journal of functional programming, </journal> <volume> 1(1), </volume> <pages> 21-69. </pages>
Reference-contexts: Partial evaluation then proceeds by attempting to evaluate the eliminable parts. A binding-time analysis is correct if it always produces consistent binding-time information. Consistency prevents partial evaluators from "going wrong". A partial evaluator "goes wrong" if it commits a so-called "projection error" <ref> (Gomard & Jones, 1991) </ref>, that is, if it trusts a part of the program to be of a particular form, of which it is not. A sufficient and decidable condition for consistency, called well-annotatedness, was first presented by Gomard and Jones (1991).
Reference: <author> Jones, Neil D. </author> <year> 1981. </year> <title> Flow analysis of lambda expressions. </title> <booktitle> Pages 114-128 of: Proc. eighth colloquium on automata, languages, and programming. </booktitle> <publisher> Springer-Verlag (LNCS 115). </publisher>
Reference: <author> Mogensen, </author> <title> Torben . 1992. Self-applicable partial evaluation for pure lambda calculus. </title> <booktitle> Pages 116-121 of: Proc. ACM SIGPLAN workshop on partial evaluation and semantics-based program manipulation. </booktitle>
Reference-contexts: Finally, we would like to prove the correctness of the binding-time analyses of Bondorf (1991), Consel (1990), and Bondorf and Jtrgensen (1993). Mitchell Wand (1993) studied Mogensen's binding-time analysis and partial evaluator for the -calculus <ref> (Mogensen, 1992) </ref>. Wand proved that the partial evaluator is correct, in the sense that if it is given an output from the binding-time analysis, then indeed it produces a specialized program. This result relates to our theorem 26 as follows.
Reference: <author> Nielson, Hanne R., & Nielson, Flemming. </author> <year> 1988. </year> <title> Automatic binding time analysis for a typed -calculus. </title> <booktitle> Science of computer programming, </booktitle> <volume> 10, </volume> <pages> 139-176. </pages> <note> Correctness of Binding-time Analysis 17 Palsberg, </note> <author> Jens, & Schwartzbach, Michael I. </author> <year> 1992. </year> <title> Binding time analysis: Abstract interpretation versus type inference. </title> <note> Submitted for publication. </note>
Reference-contexts: Thus, free variables henceforth correspond to unknown input. The output of a binding-time analysis can be presented as an annotated version of the analyzed term. In the annotated term, all residual abstractions and applications are underlined. The language of annotated terms is usually called a 2-level -calculus <ref> (Nielson & Nielson, 1988) </ref> and is defined as follows.
Reference: <author> Schmidt, David A. </author> <year> 1987. </year> <title> Static properties of partial reduction. Pages 295-305 of: Proc. partial evaluation and mixed computation, Gl. </title> <address> Averns, Denmark. </address>
Reference: <author> Sestoft, Peter. </author> <year> 1989. </year> <title> Replacing function parameters by global variables. </title> <booktitle> Pages 39-53 of: Proc. conference on functional programming languages and computer architecture. </booktitle>
Reference: <author> Shivers, Olin. </author> <year> 1991 </year> <month> (May). </month> <title> Control-flow analysis of higher-order languages. </title> <type> Ph.D. thesis, CMU. </type> <institution> CMU-CS-91-145. </institution>
Reference: <author> Wand, Mitchell. </author> <year> 1993. </year> <title> Specifying the correctness of binding time analysis. </title> <journal> Journal of functional programming, </journal> <note> special issue on partial evaluation. </note>
References-found: 14

