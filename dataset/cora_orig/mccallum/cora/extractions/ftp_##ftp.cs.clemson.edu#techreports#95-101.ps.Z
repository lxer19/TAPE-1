URL: ftp://ftp.cs.clemson.edu/techreports/95-101.ps.Z
Refering-URL: http://www.cs.clemson.edu/html/research/techrpt.shtml
Root-URL: http://www.cs.clemson.edu
Email: steve@cs.clemson.edu  
Title: Engineering  
Author: D. E. Stevenson 
Keyword: Computational Science, Software Engineering, Scientific Programming.  
Address: Clemson, SC USA 29634-1906  
Affiliation: Department of Computer Science Clemson University  
Note: Software Engineering Frontiers in Computational Science and  
Abstract: In 1991, the US Congress passed the High Performance Computing and Communications bill, commonly known as the HPCC bill, enshrining the Grand Challenges as national priorities. The very nature of these problems require the multidisciplinary teamwork of engineers plus computer, mathematical and physical scientists. But many important scientific and engineering problems are solved daily on workstations|these were dubbed the "petty challenges". Both classes of problem are demanding computational systems although quite different from non-scientific systems. We review a philosophical background for CSE, using this development to point out how seemingly innocuous decisions made by engineers and scientists can have disastrous results. Hence, software engineers should see CSE as a professional challenge. Our program is based on studying applications, the algorithms to solve problems arising in those applications, and the mapping of those algorithms to architectures. Using Computing Reviews categories, we outline the subjects required for understanding CSE systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Errett J. Bishop and Douglas Bridges. </author> <title> Constructive Analysis. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The reliance on computation in computational science and engineering opens a very important question: How much of ordinary mathematics is usable in the computational world? The con-structivity question has been addressed, for example <ref> [1] </ref>. Unfortunately, constructivity is not the same thing as "compute on a workstation." As an illustration as to why this question is important, take the recent "discovery" of chaos.
Reference: [2] <institution> Federal Coordinating Council for Science, Engineering and Technology. Grand Challenges 1994: High Performance Computing and Communications. NSF, National Science Foundation, Computer and Information Science and Engineering Directorate, </institution> <address> 1800 G Street N.W., Washington, DC 20550, </address> <year> 1994. </year> <note> May be obtained via e-mail through pubsnote.nsf.gov. </note>
Reference-contexts: The Grand Challenges are engineering and sci entific problems considered vital to the economic wellbeing of the United States. Many of these problems, such as drug design and global climate modeling, have world-wide impact. The current goals of the HPCC are published yearly <ref> [2] </ref>. The Grand Challenges acknowledge what computational practitioners have long known: problems that are analytically intractable are approachable by computational means.
Reference: [3] <author> G. E. Forsythe, M. A. Malcum, and C. B. Moler. </author> <title> Computer Methods for Mathematical Computation. </title> <publisher> Prentice-Hall, </publisher> <year> 1977. </year>
Reference-contexts: Where are all the rest? The ones we usually give our students are not there since Brent is regarded as far superior to any others. Checking numerical texts does not turn up any references to a zero finder by Brent|until you run into a text Forsythe, Malcolm and Moler <ref> [3] </ref>. Routine like Brent's zeroin are often buried in the literature and there is no particular guarantee that a "classically-trained" mathematician or numerical analyst is aware of such routines.
Reference: [4] <author> W. Kahan and J. Palmer. </author> <title> On a proposed floating-point standard. </title> <journal> SIGNUM Newsletter, Special Issue, </journal> <pages> pages 13-21, </pages> <month> October </month> <year> 1979. </year>
Reference: [5] <author> Morris Kline. </author> <title> Mathematics: The Loss of Certainty. </title> <publisher> Oxford University Press, </publisher> <year> 1980. </year>
Reference-contexts: The most important question for the present discussion is the question of computability. Ordinary calculus, as taught to freshmen and sophomores, assumes certain things about existence, leading to impredicative assumptions that are inherently non-computational in nature <ref> [5] </ref>. The reliance on computation in computational science and engineering opens a very important question: How much of ordinary mathematics is usable in the computational world? The con-structivity question has been addressed, for example [1].
Reference: [6] <author> John R. Rice. </author> <title> Academic programs in computational science and engineering. </title> <journal> IEEE Computational Science & Engineering, </journal> <volume> 1(1), </volume> <year> 1994. </year>
Reference-contexts: The Clemson approach (Section 2) recognizes three components to computational science and engineering: applications, algorithms, and architectures. The conduct of computational science and engineering is interdisciplinary and team-oriented. Information concerning the educational aspects of computational science and engineering can be found in <ref> [8, 7, 6] </ref>. In Section 3, we analyze the conduct of computational science and engineering with an eye to determining where software engineering fits. Section 4 looks at system development directly.
Reference: [7] <author> Ahmed Sameh and John Riganati. </author> <title> Computational science & engineering. </title> <journal> IEEE Computer, </journal> <volume> 26(10) </volume> <pages> 8-12, </pages> <year> 1993. </year>
Reference-contexts: The Clemson approach (Section 2) recognizes three components to computational science and engineering: applications, algorithms, and architectures. The conduct of computational science and engineering is interdisciplinary and team-oriented. Information concerning the educational aspects of computational science and engineering can be found in <ref> [8, 7, 6] </ref>. In Section 3, we analyze the conduct of computational science and engineering with an eye to determining where software engineering fits. Section 4 looks at system development directly.
Reference: [8] <author> D. E. Stevenson. </author> <title> Science, computational science, and computer science: At a crossroads. </title> <journal> Comm. ACM, </journal> <volume> 37(12), </volume> <year> 1994. </year>
Reference-contexts: The focus on computation opens an old argument: why do we want to do things numerically, anyway? By extension, what are the ramifications for software development methodologies? We review the Clemson view of computational science and engineering foundations. A more definitive treatment is to be found in <ref> [8] </ref>. The Clemson approach (Section 2) recognizes three components to computational science and engineering: applications, algorithms, and architectures. The conduct of computational science and engineering is interdisciplinary and team-oriented. Information concerning the educational aspects of computational science and engineering can be found in [8, 7, 6]. <p> The Clemson approach (Section 2) recognizes three components to computational science and engineering: applications, algorithms, and architectures. The conduct of computational science and engineering is interdisciplinary and team-oriented. Information concerning the educational aspects of computational science and engineering can be found in <ref> [8, 7, 6] </ref>. In Section 3, we analyze the conduct of computational science and engineering with an eye to determining where software engineering fits. Section 4 looks at system development directly. <p> It is meant to address broad-based concerns and changes in paradigms. A fuller explanation can be found in <ref> [8] </ref>. 2.1 The Environment of Computational Science and Engineering Computational science and engineering is characterized by the use of computation to provide detailed insight into the behavior of complex systems. <p> Computational science and engineering uses computational methods to conduct experiments which are either too expensive or, in fact, impossible to conduct in the real world. Computation is necessary due to the nature of the models: in <ref> [8] </ref>, we justify this need. A simple perusal of the scientific literature clearly shows that computer simulation is enormously fruitful in most fields. The interplay of experiment, traditional theory, and computational modeling has strong, symbiotic results. <p> In our view, computational aspects must be considered during model formulation. The computer is too often seen as capable of very fast computation, but rarely are finite arithmetic, numerical algorithms, architecture, and program construction properly taken into account in scientific formulations <ref> [8] </ref>. The scientist or engineer who avoids these considerations is at a grave disadvantage. In the same way that sloppy experimental technique cannot be tolerated, so too the inappropriate marrying of applications, algorithms, and architectures cannot be tolerated in computational science and engineering. <p> In either case, we call such assumptions physical since they are attempts understand the physical structures. We would expect all assumptions open to validation procedures. On the other hand, we often see assumptions introduced solely for mathematical tractability. We term such assumptions non-physical. In <ref> [8] </ref> we give an example of the insidious nature of non-physical assumptions in the context of the simple pendulum. The lines between physical and non-physical may be blurred, but the distinction is useful. "Classically derived" models are rarely free of non-physical assumptions. <p> The lines between physical and non-physical may be blurred, but the distinction is useful. "Classically derived" models are rarely free of non-physical assumptions. Such models include nonphysical assumptions to produce closed-form solutions. One may therefore be left with a nearly exact solution of approximated|and perhaps unrealistic|models. In <ref> [8] </ref> we actually give an example of how non-physical assumptions completely change the model: in that case, the pendulum is changed to a torsional spring. Anecdotal evidence shows that often these models may give unsatisfactory results when used in a computational setting. <p> Non-computer scientists are also unlikely to have a realistic vision of program development. Computer scientists, on the other hand, are often math-phobic or science-phobic or both. Much more detail is available in <ref> [8] </ref>. All of this leads to difficulties in the development of scientific and engineering models. We have tried to describe those parts of the problem that can be positively impacted by computer scientists and software engineers.
References-found: 8

