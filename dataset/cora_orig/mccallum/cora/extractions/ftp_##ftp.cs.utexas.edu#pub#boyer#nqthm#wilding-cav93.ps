URL: ftp://ftp.cs.utexas.edu/pub/boyer/nqthm/wilding-cav93.ps
Refering-URL: ftp://ftp.cs.utexas.edu/pub/boyer/nqthm/nqthm-bibliography.html
Root-URL: 
Title: A Mechanically Verified Application for a Mechanically Verified Environment  
Author: Matthew Wilding 
Address: 1717 West Sixth Street Suite 290, Austin Texas, USA  Austin  
Affiliation: Computational Logic Inc.,  and The University of Texas at  
Abstract: We have developed a verified application proved to be both effective and efficient. The application generates moves in the puzzle-game Nim and is coded in Piton, a language with a formal semantics and a compiler verified to preserve its semantics on the underlying machine. The Piton compiler is targeted to the FM9001, a recently fabricated verified microprocessor. The Nim program correctness proof makes use of the language semantics that the compiler is proved to implement. Like the Piton compiler proof and FM9001 design proof, the Nim correctness proof is generated using Nqthm, a proof system sometimes known as the Boyer-Moore theorem prover. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Ken Albin, Warren Hunt, and Matthew Wilding. </author> <note> FM9001 fabrication (in preparation). Technical report, Computational Logic, </note> <institution> Inc., </institution> <year> 1993. </year>
Reference-contexts: Recently, the FM9001 was fabricated and has run programs, including the compiled Piton program described in this paper <ref> [1] </ref>. In short, formalized in Nqthm are a language semantics for Piton, a verified compiler to the FM9001, a verified design for the FM9001, and a fabricated chip that implements the FM9001 design.
Reference: 2. <author> William R. Bevier, Warren A. Hunt Jr., J Strother Moore, and William D. Young. </author> <title> An approach to systems verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 411-428, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: The interpreter function serves as a precise specification for the expected behavior of a system component. This general approach to system verification is described fully in <ref> [2] </ref>. Interpreter functions can be complex: Piton has 71 instructions and some high-level features, and the definition of P in the Nqthm logic requires about 50 pages. The FM9001 is a fairly conventional microprocessor with an instruction set somewhat like that on a PDP-11 [9].
Reference: 3. <author> Charles L. Bouton. </author> <title> Nim, a game with a complete mathematical theory. </title> <journal> In Annals of Mathematics, </journal> <volume> volume 3, </volume> <pages> 1901-02. </pages>
Reference-contexts: Let 0-vector be a vector composed entirely of zeroes. Let (GREEN-STATEP state) be an abbreviation for (BIGP state)&gt;0 $ (XOR-BVS state)6=0-vector. Theorem: (GREEN-STATEP state) $ (WSP state). This remarkable property was rediscovered for this project, but has in fact been known at least since 1901 <ref> [3] </ref>. The most obvious proof uses an induction on the search tree. Figure 3 is the search tree for a small Nim state and illustrates the theorem above.
Reference: 4. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: the requirements outlined in Section 3 is discussed in Section 5. [12] describes this project in greater detail and includes the input that causes Nqthm to generate the correctness proof. 2 Background Nqthm is the name of both a logic and an associated theorem proving system that are documented in <ref> [4] </ref>. A large number of mathematical theorems from many disparate domains have been proved using Nqthm. The Nqthm logic is a quantifier-free, first-order logic resembling Pure Lisp. The user inputs definitions and conjectures to the Nqthm theorem prover which, when successful, outputs proofs. Proved conjectures are applied in later proofs. <p> Since Nqthm runs on unverified hardware and is not proved correct in a formal way, however, it is possible that a bug in the implementation of Nqthm or its execution environment has caused us to conclude that a false conjecture is a theorem. <ref> [4] </ref> explores this issue more fully. Although we feel obliged to point out this potential weakness in our work, our experience is that Nqthm-generated proofs are extremely dependable. One interesting domain to which Nqthm has been applied is computer systems verification. <p> Although the straightforward Nqthm logic and suggestive function names convey the intent of these terms, the interested reader is referred to <ref> [4] </ref> for a description of the Nqthm logic, [8] for the definition of functions related to the Piton interpreter, and [12] for the definition of the specification's other defined functions. 3.1 Algorithm Legality We require that the function COMPUTER-MOVE returns valid Nim moves, which is expressed in the Nqthm logic with
Reference: 5. <author> Martin Gardner. </author> <title> Mathematical Puzzles and Diversions. </title> <publisher> Simon and Schuster, </publisher> <address> New York, </address> <year> 1959. </year>
Reference-contexts: The rest of this paper describes the development of a verified application that runs in this environment. 3 A Specification for a Good Nim Program Nim is an ancient mathematical game played with piles of stones by two alternating players <ref> [5] </ref>. On his turn a player removes at least one stone from exactly one pile. The player who removes the final stone loses. We construct a specification for a program that calculates a good Nim move efficiently.
Reference: 6. <author> Warren A. Hunt Jr. </author> <title> Microprocessor design verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 429-460, </pages> <month> December </month> <year> 1989. </year>
Reference: 7. <author> Matt Kaufmann. </author> <title> A user's manual for an interactive enhancement to the Boyer-Moore theorem prover. </title> <type> Technical Report 60, </type> <institution> Institute for Computing Science, University of Texas at Austin, Austin, Texas, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: That is, that the algorithm outlined in Section 4 works. We call proofs of this kind of lemma algorithm proofs. Some lemmas establish bounds on the clock functions. We call proofs of this kind of lemma timing proofs. The timing proofs were done using PC-Nqthm <ref> [7] </ref>, the interactive enhancement to Nqthm. All other proofs require only Nqthm.
Reference: 8. <author> J Strother Moore. </author> <title> A mechanically verified language implementation. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 493-518, </pages> <month> December </month> <year> 1989. </year> <note> Also published as CLI Technical Report 30. </note>
Reference-contexts: The requirement imposed by Nqthm to get every detail of a proof exactly correct is very important in computer systems verification as even the most trivial-seeming mistake can lead to catastrophe. <ref> [8] </ref> describes the implementation of a compiler for the language Piton and the associated mechanically-produced correctness theorem. A formal semantics for Piton, a formal description of the FM9001 microprocessor, and the Piton compiler are introduced as Nqthm functions. <p> Although the straightforward Nqthm logic and suggestive function names convey the intent of these terms, the interested reader is referred to [4] for a description of the Nqthm logic, <ref> [8] </ref> for the definition of functions related to the Piton interpreter, and [12] for the definition of the specification's other defined functions. 3.1 Algorithm Legality We require that the function COMPUTER-MOVE returns valid Nim moves, which is expressed in the Nqthm logic with the term below. (Note that COMPUTER-MOVE is one <p> space. (lessp (plus (nim-piton-ctrl-stk-requirement) (nim-piton-temp-stk-requirement)) 1000) This part of the specification eliminates, for example, a table-driven implementation since there are 2 177 distinct possible Nim states. 3.6 FM9001 Loadability We require that the program work on an FM9001 and that it meet the requirements of the compiler correctness proof of <ref> [8] </ref>. This requires among other things that the compiled Piton programs fit into the FM9001 address space and that the Piton programs be well-formed. The interested reader is referred to [8] for details. This part of the specification allows us to apply the compiler correctness proof. <p> require that the program work on an FM9001 and that it meet the requirements of the compiler correctness proof of <ref> [8] </ref>. This requires among other things that the compiled Piton programs fit into the FM9001 address space and that the Piton programs be well-formed. The interested reader is referred to [8] for details. This part of the specification allows us to apply the compiler correctness proof. This constraint also eliminates some possible undesirable implementations. <p> We call proofs of this kind of lemma timing proofs. The timing proofs were done using PC-Nqthm [7], the interactive enhancement to Nqthm. All other proofs require only Nqthm. The proof that the Piton program meets the specification uses the default arithmetic library [10] and the Piton interpreter definitions <ref> [8] </ref>. (prove-lemma correctnessof-nat-to-bv (rewrite) (implies (and (equal p0 (p-state pc ctrl-stk (cons v temp-stk) prog-segment data-segment max-ctrl-stk-size max-temp-stk-size word-size 'run)) (equal (p-current-instruction p0) '(call nat-to-bv)) (nat-to-bv-input-conditionp p0)) (equal (p p0 (nat-to-bv-clock num)) (p-state (add1-addr pc) ctrl-stk (cons (list 'bitv (nat-to-bv (cadr v) word-size)) temp-stk) prog-segment data-segment max-ctrl-stk-size max-temp-stk-size word-size 'run)))) Fig. <p> We hope to verify more complex software in the future using our mechanical proof tools as we pursue our goal of building error-free computer systems. Programs that work in real-time are particularly attractive since the formalization of a programming language with an interpreter as in <ref> [8] </ref> is well-suited to proving program timing properties. An FM9001 was fabricated and runs a compiled version of the Nim pro-gram. The fabricated FM9001 microprocessor, the Piton compiler, and the Nim program were never tested in a conventional manner during development or after completion.
Reference: 9. <author> Warren A. Hunt Jr. and Bishop Brock. </author> <title> A formal HDL and its use in the FM9001 verification. </title> <journal> Proceedings of the Royal Society, </journal> <month> April </month> <year> 1992. </year>
Reference-contexts: Interpreter functions can be complex: Piton has 71 instructions and some high-level features, and the definition of P in the Nqthm logic requires about 50 pages. The FM9001 is a fairly conventional microprocessor with an instruction set somewhat like that on a PDP-11 <ref> [9] </ref>. Unlike most processors the FM9001 has been specified, designed, and proved correct in the sense that the design is shown to meet the specification.
Reference: 10. <author> Matthew Wilding. </author> <title> Proving Matijasevich's lemma with a default arithmetic strategy. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 7(3), </volume> <month> September </month> <year> 1991. </year>
Reference-contexts: We call proofs of this kind of lemma timing proofs. The timing proofs were done using PC-Nqthm [7], the interactive enhancement to Nqthm. All other proofs require only Nqthm. The proof that the Piton program meets the specification uses the default arithmetic library <ref> [10] </ref> and the Piton interpreter definitions [8]. (prove-lemma correctnessof-nat-to-bv (rewrite) (implies (and (equal p0 (p-state pc ctrl-stk (cons v temp-stk) prog-segment data-segment max-ctrl-stk-size max-temp-stk-size word-size 'run)) (equal (p-current-instruction p0) '(call nat-to-bv)) (nat-to-bv-input-conditionp p0)) (equal (p p0 (nat-to-bv-clock num)) (p-state (add1-addr pc) ctrl-stk (cons (list 'bitv (nat-to-bv (cadr v) word-size)) temp-stk) prog-segment
Reference: 11. <author> Matthew Wilding. </author> <title> A verified nim strategy. Internal Note 249, Computational Logic, </title> <publisher> Inc., </publisher> <month> November </month> <year> 1991. </year>
Reference-contexts: The development of the correctness proof required about 3 man-months. (This does not include time to develop the events of the Piton compiler or arithmetic library or to accomplish an earlier proof related to Nim <ref> [11] </ref>.) Approximately 40% of the man-hours were spent on code correctness proofs, 30% on specification proofs, 20% on algorithm proofs, and 10% on timing proofs.

References-found: 11

