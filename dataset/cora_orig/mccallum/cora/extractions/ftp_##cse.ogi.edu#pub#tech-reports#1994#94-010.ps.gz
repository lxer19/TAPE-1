URL: ftp://cse.ogi.edu/pub/tech-reports/1994/94-010.ps.gz
Refering-URL: ftp://cse.ogi.edu/pub/tech-reports/README.html
Root-URL: http://www.cse.ogi.edu
Email: Bellegar@cse.ogi.edu  
Title: A Transformation System Combining Partial Evaluation with Term Rewriting Revision: 1.1  
Author: Fran~coise Bellegarde, 
Address: PO BOX 91000, Portland, OREGON, 97006.  
Affiliation: Computer Science, Oregon Graduate Institute of Science Technology,  
Abstract: This paper presents a new approach to optimizing functional programs based on combining partial evaluation and rewriting. Programs are composed of higher-order primitives. Partial evaluation is used to eliminate higher-order functions. First-order rewriting is used to process the transformation. Laws about the higher-order primitives that are relevant for the optimizations are automatically extracted from a library and transformed into first-order terms using partial evaluation. Such a combination of a partial evaluation system and an intrinsically first-order rewriting tool allows a form of higher-order rewriting at a first-order level. This way, it is possible to automate deforestation of higher-order programs.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Bellegarde. </author> <title> Program Transformation and Rewriting. </title> <booktitle> In Proceedings of the fourth conference on Rewriting Techniques and Applications, Springer Verlag, Lecture Notes in Computer Science 488, </booktitle> <pages> pages 226-239, </pages> <address> Como, Italy, </address> <year> 1991. </year>
Reference-contexts: Deforestation is a particular instance of this strategy. In the Focus system [11], folding and unfolding are seen as term rewritings. It has been pointed out in [7] how a folding-unfolding strategy can be directed by a completion procedure. Following this idea, the transformation system Astre <ref> [1, 2] </ref> is based on partial completion procedures 1 . Astre takes into account of inductive laws provided by the user during the completion process. All these systems are interactive. However a currently implemented automatic mode of Astre performs automatically a simple 2 deforestation of a program. <p> The theorems used during the transformation process are listed in Figure 3. The details of the manual transformations using these laws can be found in [14]. Let us now consider, a way to automate this transformation using completion and partial evaluation. The system Astre <ref> [1, 2] </ref> based on a partial completion procedure, deals with programs presented by a set of first-order equations. A partial evaluator can automatically convert a class of higher-order programs into first-order ones. <p> For example, consider the function append, that is, the prefix version of the operator @ used in the maxsub example. The definition is: append [] y = y append (a :: x) y = a :: (append x y) A partial evaluation of the term (append <ref> [1; 2; 3] </ref> y), where the first argument of append is the static argument substituted by [1; 2; 3], returns the specialized definition: append1 y = 1 :: (2 :: (3 :: y)) The evaluation involves unfolding the recursive definition of append. <p> The definition is: append [] y = y append (a :: x) y = a :: (append x y) A partial evaluation of the term (append <ref> [1; 2; 3] </ref> y), where the first argument of append is the static argument substituted by [1; 2; 3], returns the specialized definition: append1 y = 1 :: (2 :: (3 :: y)) The evaluation involves unfolding the recursive definition of append.
Reference: [2] <author> F. Bellegarde. Astre, </author> <title> a Transformation System using Completion. </title> <type> Technical Report, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1991. </year>
Reference-contexts: Deforestation is a particular instance of this strategy. In the Focus system [11], folding and unfolding are seen as term rewritings. It has been pointed out in [7] how a folding-unfolding strategy can be directed by a completion procedure. Following this idea, the transformation system Astre <ref> [1, 2] </ref> is based on partial completion procedures 1 . Astre takes into account of inductive laws provided by the user during the completion process. All these systems are interactive. However a currently implemented automatic mode of Astre performs automatically a simple 2 deforestation of a program. <p> The operation ffi is the composition of two functions. This program also assumes that the higher-order operators fold , map, foldr and the function bimax are primitive operations. The function bimax is the maximum function. The operation + is prefixed. For example: foldr + 0 <ref> [2; 3; 4; 3] </ref> = + 2 (+ (3) (+ 4 (+ 3 0))) = 6: The operator fold is similar to foldr , except that it only applies to non empty lists. For example: fold bimax [2; 3; 4; 3] = bimax 2 (bimax (3) (bimax 4 3)) = 4: <p> The operation + is prefixed. For example: foldr + 0 <ref> [2; 3; 4; 3] </ref> = + 2 (+ (3) (+ 4 (+ 3 0))) = 6: The operator fold is similar to foldr , except that it only applies to non empty lists. For example: fold bimax [2; 3; 4; 3] = bimax 2 (bimax (3) (bimax 4 3)) = 4: The function sublists returns all the contiguous sublists of a given list. The function frontlists returns all the sublists that are prefixes of the list. For example: frontlists [2; 3; 4; 3] = [[2; 3; 4; 3]; <p> For example: fold bimax <ref> [2; 3; 4; 3] </ref> = bimax 2 (bimax (3) (bimax 4 3)) = 4: The function sublists returns all the contiguous sublists of a given list. The function frontlists returns all the sublists that are prefixes of the list. For example: frontlists [2; 3; 4; 3] = [[2; 3; 4; 3]; [2; 3; 4]; [2; 3]; [2]; []]: Faithful to the Squiggol method, maxsub takes all the contiguous sublists of the list using sublists, then computes all the sum of the elements of every sublists using map sum, finally computes their maximum using <p> The function frontlists returns all the sublists that are prefixes of the list. For example: frontlists [2; 3; 4; 3] = [[2; 3; 4; 3]; <ref> [2; 3; 4] </ref>; [2; 3]; [2]; []]: Faithful to the Squiggol method, maxsub takes all the contiguous sublists of the list using sublists, then computes all the sum of the elements of every sublists using map sum, finally computes their maximum using fold bimax . <p> The function frontlists returns all the sublists that are prefixes of the list. For example: frontlists [2; 3; 4; 3] = [[2; 3; 4; 3]; [2; 3; 4]; <ref> [2; 3] </ref>; [2]; []]: Faithful to the Squiggol method, maxsub takes all the contiguous sublists of the list using sublists, then computes all the sum of the elements of every sublists using map sum, finally computes their maximum using fold bimax . <p> The function frontlists returns all the sublists that are prefixes of the list. For example: frontlists [2; 3; 4; 3] = [[2; 3; 4; 3]; [2; 3; 4]; [2; 3]; <ref> [2] </ref>; []]: Faithful to the Squiggol method, maxsub takes all the contiguous sublists of the list using sublists, then computes all the sum of the elements of every sublists using map sum, finally computes their maximum using fold bimax . <p> The theorems used during the transformation process are listed in Figure 3. The details of the manual transformations using these laws can be found in [14]. Let us now consider, a way to automate this transformation using completion and partial evaluation. The system Astre <ref> [1, 2] </ref> based on a partial completion procedure, deals with programs presented by a set of first-order equations. A partial evaluator can automatically convert a class of higher-order programs into first-order ones. <p> For example, consider the function append, that is, the prefix version of the operator @ used in the maxsub example. The definition is: append [] y = y append (a :: x) y = a :: (append x y) A partial evaluation of the term (append <ref> [1; 2; 3] </ref> y), where the first argument of append is the static argument substituted by [1; 2; 3], returns the specialized definition: append1 y = 1 :: (2 :: (3 :: y)) The evaluation involves unfolding the recursive definition of append. <p> The definition is: append [] y = y append (a :: x) y = a :: (append x y) A partial evaluation of the term (append <ref> [1; 2; 3] </ref> y), where the first argument of append is the static argument substituted by [1; 2; 3], returns the specialized definition: append1 y = 1 :: (2 :: (3 :: y)) The evaluation involves unfolding the recursive definition of append. <p> This way, the first-order converted program is translated into the first-order set of equations shown in Figure 5. 3 First-Order Transformation The transformation can now begin at a first-order level using the system Astre. Let us run Astre giving the equations in Figure 5. The reader can refer to <ref> [2] </ref> to get a precise idea of the possibilities of the current version of the system. First, Astre turns the set of equations into a rewriting system, directing the equations from left to right automatically and eventually, (if it is required by the user) it verifies its ground convergence. <p> state of our technology is the following: * a translator ML into Schism and a translator Schism to ML which restores the patterns (currently implemented). * the partial evaluator Schism [6] which uses its own (typed) dialect of Scheme as its object language, and * the interactive transformation system Astre <ref> [2] </ref> based on rewriting and completion procedures written in CAML. The mode "automatic Astre" for simple deforestations is cur rently implemented. We have simulated the interaction of these tools to process the sketch of the transformation of the maxsub example.
Reference: [3] <author> J. Bentley. </author> <title> Programming Pearls, </title> <publisher> Addison Wesley, </publisher> <year> 1986. </year>
Reference-contexts: To our knowledge, no general purpose transformation system supports this kind of transformation. 1 Maxsub example We illustrate our transformational approach with a program presented by S. Thompson [14] and first introduced by J. Bentley <ref> [3] </ref>. The problem solved by this program is stated as follows by Thompson: Given a finite list of numbers, find the maximum value for the sum of a (contiguous) sublist of the list. Numbers can be positive as well as negative integers. In his book [15], S. <p> The operation ffi is the composition of two functions. This program also assumes that the higher-order operators fold , map, foldr and the function bimax are primitive operations. The function bimax is the maximum function. The operation + is prefixed. For example: foldr + 0 <ref> [2; 3; 4; 3] </ref> = + 2 (+ (3) (+ 4 (+ 3 0))) = 6: The operator fold is similar to foldr , except that it only applies to non empty lists. For example: fold bimax [2; 3; 4; 3] = bimax 2 (bimax (3) (bimax 4 3)) = 4: <p> The operation + is prefixed. For example: foldr + 0 <ref> [2; 3; 4; 3] </ref> = + 2 (+ (3) (+ 4 (+ 3 0))) = 6: The operator fold is similar to foldr , except that it only applies to non empty lists. For example: fold bimax [2; 3; 4; 3] = bimax 2 (bimax (3) (bimax 4 3)) = 4: The function sublists returns all the contiguous sublists of a given list. The function frontlists returns all the sublists that are prefixes of the list. For example: frontlists [2; 3; 4; 3] = [[2; 3; 4; 3]; <p> For example: fold bimax <ref> [2; 3; 4; 3] </ref> = bimax 2 (bimax (3) (bimax 4 3)) = 4: The function sublists returns all the contiguous sublists of a given list. The function frontlists returns all the sublists that are prefixes of the list. For example: frontlists [2; 3; 4; 3] = [[2; 3; 4; 3]; [2; 3; 4]; [2; 3]; [2]; []]: Faithful to the Squiggol method, maxsub takes all the contiguous sublists of the list using sublists, then computes all the sum of the elements of every sublists using map sum, finally computes their maximum using <p> The function frontlists returns all the sublists that are prefixes of the list. For example: frontlists [2; 3; 4; 3] = <ref> [[2; 3; 4; 3] </ref>; [2; 3; 4]; [2; 3]; [2]; []]: Faithful to the Squiggol method, maxsub takes all the contiguous sublists of the list using sublists, then computes all the sum of the elements of every sublists using map sum, finally computes their maximum using fold bimax . <p> The function frontlists returns all the sublists that are prefixes of the list. For example: frontlists [2; 3; 4; 3] = [[2; 3; 4; 3]; <ref> [2; 3; 4] </ref>; [2; 3]; [2]; []]: Faithful to the Squiggol method, maxsub takes all the contiguous sublists of the list using sublists, then computes all the sum of the elements of every sublists using map sum, finally computes their maximum using fold bimax . <p> The function frontlists returns all the sublists that are prefixes of the list. For example: frontlists [2; 3; 4; 3] = [[2; 3; 4; 3]; [2; 3; 4]; <ref> [2; 3] </ref>; [2]; []]: Faithful to the Squiggol method, maxsub takes all the contiguous sublists of the list using sublists, then computes all the sum of the elements of every sublists using map sum, finally computes their maximum using fold bimax . <p> For example, consider the function append, that is, the prefix version of the operator @ used in the maxsub example. The definition is: append [] y = y append (a :: x) y = a :: (append x y) A partial evaluation of the term (append <ref> [1; 2; 3] </ref> y), where the first argument of append is the static argument substituted by [1; 2; 3], returns the specialized definition: append1 y = 1 :: (2 :: (3 :: y)) The evaluation involves unfolding the recursive definition of append. <p> The definition is: append [] y = y append (a :: x) y = a :: (append x y) A partial evaluation of the term (append <ref> [1; 2; 3] </ref> y), where the first argument of append is the static argument substituted by [1; 2; 3], returns the specialized definition: append1 y = 1 :: (2 :: (3 :: y)) The evaluation involves unfolding the recursive definition of append.
Reference: [4] <author> R. M. Burstall and J. Darlington. </author> <title> A Transformation System For Developing Recursive Programs. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 24, </volume> <pages> pages 44-67, </pages> <year> 1977. </year>
Reference-contexts: This technique is applicable to potentially normalizable terms which are similar to treeless terms. A new automatic way to implement deforestation inside the Haskell's compiler is shown in [9]. General purpose program transformation systems are based on a folding-unfolding strategy a la Burstall and Darlington <ref> [4] </ref>. Deforestation is a particular instance of this strategy. In the Focus system [11], folding and unfolding are seen as term rewritings. It has been pointed out in [7] how a folding-unfolding strategy can be directed by a completion procedure. <p> The operation ffi is the composition of two functions. This program also assumes that the higher-order operators fold , map, foldr and the function bimax are primitive operations. The function bimax is the maximum function. The operation + is prefixed. For example: foldr + 0 <ref> [2; 3; 4; 3] </ref> = + 2 (+ (3) (+ 4 (+ 3 0))) = 6: The operator fold is similar to foldr , except that it only applies to non empty lists. For example: fold bimax [2; 3; 4; 3] = bimax 2 (bimax (3) (bimax 4 3)) = 4: <p> The operation + is prefixed. For example: foldr + 0 <ref> [2; 3; 4; 3] </ref> = + 2 (+ (3) (+ 4 (+ 3 0))) = 6: The operator fold is similar to foldr , except that it only applies to non empty lists. For example: fold bimax [2; 3; 4; 3] = bimax 2 (bimax (3) (bimax 4 3)) = 4: The function sublists returns all the contiguous sublists of a given list. The function frontlists returns all the sublists that are prefixes of the list. For example: frontlists [2; 3; 4; 3] = [[2; 3; 4; 3]; <p> For example: fold bimax <ref> [2; 3; 4; 3] </ref> = bimax 2 (bimax (3) (bimax 4 3)) = 4: The function sublists returns all the contiguous sublists of a given list. The function frontlists returns all the sublists that are prefixes of the list. For example: frontlists [2; 3; 4; 3] = [[2; 3; 4; 3]; [2; 3; 4]; [2; 3]; [2]; []]: Faithful to the Squiggol method, maxsub takes all the contiguous sublists of the list using sublists, then computes all the sum of the elements of every sublists using map sum, finally computes their maximum using <p> The function frontlists returns all the sublists that are prefixes of the list. For example: frontlists [2; 3; 4; 3] = <ref> [[2; 3; 4; 3] </ref>; [2; 3; 4]; [2; 3]; [2]; []]: Faithful to the Squiggol method, maxsub takes all the contiguous sublists of the list using sublists, then computes all the sum of the elements of every sublists using map sum, finally computes their maximum using fold bimax . <p> The function frontlists returns all the sublists that are prefixes of the list. For example: frontlists [2; 3; 4; 3] = [[2; 3; 4; 3]; <ref> [2; 3; 4] </ref>; [2; 3]; [2]; []]: Faithful to the Squiggol method, maxsub takes all the contiguous sublists of the list using sublists, then computes all the sum of the elements of every sublists using map sum, finally computes their maximum using fold bimax . <p> But the partial evaluation of the term (append x <ref> [4; 5; 6] </ref>), where the second argument of append is the static argument substituted by [4; 5; 6], returns the specialized definition: append2 [] = [4; 5; 6] append2 (a :: x) = a :: (append2 x) In this case unfolding the recursion is impossible, only fi-reduction is involved. <p> But the partial evaluation of the term (append x <ref> [4; 5; 6] </ref>), where the second argument of append is the static argument substituted by [4; 5; 6], returns the specialized definition: append2 [] = [4; 5; 6] append2 (a :: x) = a :: (append2 x) In this case unfolding the recursion is impossible, only fi-reduction is involved. <p> But the partial evaluation of the term (append x <ref> [4; 5; 6] </ref>), where the second argument of append is the static argument substituted by [4; 5; 6], returns the specialized definition: append2 [] = [4; 5; 6] append2 (a :: x) = a :: (append2 x) In this case unfolding the recursion is impossible, only fi-reduction is involved.
Reference: [5] <author> W. N. Chin. </author> <title> Automatic Methods for Program Transformation. </title> <type> PhD thesis, </type> <institution> University of London, Imperial College of Science, Technology and Medecine, </institution> <address> London, UK, </address> <year> 1990. </year>
Reference-contexts: Related work Wadler has proposed an algorithm for deforestation in [16]. It works intrinsically on first-order programs though it is extended to higher-order programs by treating higher-order programs as macros. His algorithm performs automatic deforestation on treeless terms. Chin's work on fusion <ref> [5] </ref> applies to higher-order program in general, it skips over terms to which the technique does not apply. More recently, promotion theorems have been applied to normalize programs [12]. This technique is applicable to potentially normalizable terms which are similar to treeless terms. <p> But the partial evaluation of the term (append x <ref> [4; 5; 6] </ref>), where the second argument of append is the static argument substituted by [4; 5; 6], returns the specialized definition: append2 [] = [4; 5; 6] append2 (a :: x) = a :: (append2 x) In this case unfolding the recursion is impossible, only fi-reduction is involved. <p> But the partial evaluation of the term (append x <ref> [4; 5; 6] </ref>), where the second argument of append is the static argument substituted by [4; 5; 6], returns the specialized definition: append2 [] = [4; 5; 6] append2 (a :: x) = a :: (append2 x) In this case unfolding the recursion is impossible, only fi-reduction is involved. <p> But the partial evaluation of the term (append x <ref> [4; 5; 6] </ref>), where the second argument of append is the static argument substituted by [4; 5; 6], returns the specialized definition: append2 [] = [4; 5; 6] append2 (a :: x) = a :: (append2 x) In this case unfolding the recursion is impossible, only fi-reduction is involved. <p> These programs consist of first-order terms and constant or variable-only higher-order primitives. Variable-only higher-order primitives are functions whose higher-order arguments are solely made up of variables in each recursive call to this function. This is called the variable-only criterion by Chin <ref> [5] </ref>. In the context of partial evaluation this criterion ensures that specializing functions with respect to higher-order values always terminates. For example map map f (a :: x) = (f a) :: (map f x) is variable only, so are fold and foldr.
Reference: [6] <author> C. Consel. </author> <title> A tour of Schism: A partial evaluation system for higher-order applicative languages. </title> <type> Research report, </type> <institution> Pacific Software Research Center, Oregon Graduate Institute of Science and Technology, Beaverton, Oregon, USA, </institution> <year> 1992. </year>
Reference-contexts: This process produces a specialized (residual) program [8]. This specialized program when applied to the remaining input value parts (dynamic parts) yields the same result as the original program applied to a complete input. In this paper we are using Schism <ref> [6] </ref> a partial evaluator for pure functional programs. <p> But the partial evaluation of the term (append x <ref> [4; 5; 6] </ref>), where the second argument of append is the static argument substituted by [4; 5; 6], returns the specialized definition: append2 [] = [4; 5; 6] append2 (a :: x) = a :: (append2 x) In this case unfolding the recursion is impossible, only fi-reduction is involved. <p> But the partial evaluation of the term (append x <ref> [4; 5; 6] </ref>), where the second argument of append is the static argument substituted by [4; 5; 6], returns the specialized definition: append2 [] = [4; 5; 6] append2 (a :: x) = a :: (append2 x) In this case unfolding the recursion is impossible, only fi-reduction is involved. <p> But the partial evaluation of the term (append x <ref> [4; 5; 6] </ref>), where the second argument of append is the static argument substituted by [4; 5; 6], returns the specialized definition: append2 [] = [4; 5; 6] append2 (a :: x) = a :: (append2 x) In this case unfolding the recursion is impossible, only fi-reduction is involved. <p> We are currently using the partial evaluator Schism <ref> [6] </ref> for first-order conversion. Schism uses a typed dialect of Scheme as its object language. A translator from ML to Schism is available. Modulo some renaming, the result of partial evaluation of the translated program for maxsub is shown in Figure 4. <p> In this way, we obtain a tool that automatically implement the deforestation of higher-order Squiggol programs. Currently, the state of our technology is the following: * a translator ML into Schism and a translator Schism to ML which restores the patterns (currently implemented). * the partial evaluator Schism <ref> [6] </ref> which uses its own (typed) dialect of Scheme as its object language, and * the interactive transformation system Astre [2] based on rewriting and completion procedures written in CAML. The mode "automatic Astre" for simple deforestations is cur rently implemented.
Reference: [7] <author> N. Dershowitz. </author> <title> Completion and its Applications. Resolution of Equations in Algebraic Structures, </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: General purpose program transformation systems are based on a folding-unfolding strategy a la Burstall and Darlington [4]. Deforestation is a particular instance of this strategy. In the Focus system [11], folding and unfolding are seen as term rewritings. It has been pointed out in <ref> [7] </ref> how a folding-unfolding strategy can be directed by a completion procedure. Following this idea, the transformation system Astre [1, 2] is based on partial completion procedures 1 . Astre takes into account of inductive laws provided by the user during the completion process. All these systems are interactive.
Reference: [8] <author> A. Ershov. </author> <title> Mixed computation: potential applications and problem for study. </title> <journal> Theorical Computer Science, </journal> <volume> Vol. 18, </volume> <pages> pages 41-67, </pages> <year> 1982. </year>
Reference-contexts: This is achieved by using partial evaluation to transform a class of higher-order programs into first-order ones. Partial evaluation aims at specializing a program with respect to part of its input (static parts). This process produces a specialized (residual) program <ref> [8] </ref>. This specialized program when applied to the remaining input value parts (dynamic parts) yields the same result as the original program applied to a complete input. In this paper we are using Schism [6] a partial evaluator for pure functional programs.
Reference: [9] <author> A. Gill, J. Launchbury and S.L. Peyton Jones. </author> <title> A short cut to Deforestation. </title> <booktitle> In Sixth Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pp 223-232, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Indeed, compositions produce many intermediate data structures when computed in an eager (call by value) evaluation. One way to circumvent this problem is to perform deforestation on programs as advocated by Wadler [16]. Deforestation algorithms <ref> [16, 9] </ref>, as well as algorithms based on fl The work reported here was supported in part by a contract with Air Force Material Command (F1928-R-0032) and by a grant from NSF (CCR-9101721). 1 Id: HOA.tex,v 1.1 1994/02/24 17:50:09 bellegar Exp bellegar 2 promotion theorems [12] eliminate these useless intermediate data <p> More recently, promotion theorems have been applied to normalize programs [12]. This technique is applicable to potentially normalizable terms which are similar to treeless terms. A new automatic way to implement deforestation inside the Haskell's compiler is shown in <ref> [9] </ref>. General purpose program transformation systems are based on a folding-unfolding strategy a la Burstall and Darlington [4]. Deforestation is a particular instance of this strategy. In the Focus system [11], folding and unfolding are seen as term rewritings.
Reference: [10] <author> E. Meijer, M. Fokkinga and R. Patterson. </author> <title> Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire. </title> <booktitle> In Conference on Functional Programming and Computer Architecture, Lecture Notes in Computer Science 523, </booktitle> <pages> pages 124-144, </pages> <year> 1991. </year>
Reference-contexts: Introduction The so-called Squiggol <ref> [10] </ref> style for program construction is a high-level programming technique that consists of building a program by composing primitives or other functions while taking into account well-known laws on the primitives. Functions are usually defined according to recursion patterns that are attached to the inductive structure of the data types. <p> Functions are usually defined according to recursion patterns that are attached to the inductive structure of the data types. These recursive patterns can be captured by higher-order functions. For example a particular kind of recursive pattern attached to the recursive data type list called catamorphism <ref> [10] </ref> can be captured by the higher-order primitive foldr. This higher-order primitive is provided in most functional languages. It is called fold in ML and reduce in Common Lisp.
Reference: [11] <author> U. S. Reddy. </author> <title> Transformational derivation of programs using the Focus system. </title> <booktitle> In Symposium Practical Software Development Environments, </booktitle> <pages> pages 163-172, </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1988. </year>
Reference-contexts: A new automatic way to implement deforestation inside the Haskell's compiler is shown in [9]. General purpose program transformation systems are based on a folding-unfolding strategy a la Burstall and Darlington [4]. Deforestation is a particular instance of this strategy. In the Focus system <ref> [11] </ref>, folding and unfolding are seen as term rewritings. It has been pointed out in [7] how a folding-unfolding strategy can be directed by a completion procedure. Following this idea, the transformation system Astre [1, 2] is based on partial completion procedures 1 .
Reference: [12] <author> T. Scheard and L. Fegaras. </author> <title> A fold for All Seasons. </title> <booktitle> Sixth Conference on Functional Programming Lnaguages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pp 233-242, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Deforestation algorithms [16, 9], as well as algorithms based on fl The work reported here was supported in part by a contract with Air Force Material Command (F1928-R-0032) and by a grant from NSF (CCR-9101721). 1 Id: HOA.tex,v 1.1 1994/02/24 17:50:09 bellegar Exp bellegar 2 promotion theorems <ref> [12] </ref> eliminate these useless intermediate data structures, but the optimizations they perform are limited because they do not take into account any particular laws about the operands of the compositions. As described in [17], laws about higher-order polymorphic primitives can be derived for free from their type. <p> His algorithm performs automatic deforestation on treeless terms. Chin's work on fusion [5] applies to higher-order program in general, it skips over terms to which the technique does not apply. More recently, promotion theorems have been applied to normalize programs <ref> [12] </ref>. This technique is applicable to potentially normalizable terms which are similar to treeless terms. A new automatic way to implement deforestation inside the Haskell's compiler is shown in [9]. General purpose program transformation systems are based on a folding-unfolding strategy a la Burstall and Darlington [4]. <p> The normalization algorithm of <ref> [12] </ref> rejects also the deforestation of t which is not potentially normalizable for this algorithm 5 .
Reference: [13] <author> W. Snyder and J. Gallier. </author> <title> Higher order unification revisited: complete sets of transformations. </title> <journal> Journal of Symbolic Computation, </journal> <volume> Vol.8, </volume> <pages> pages 101-140, </pages> <year> 1989. </year> <title> Special issue on Unification. Part two. </title>
Reference-contexts: Let l be (L) # first and r be (R) # first . We want to show that M # first reduces to N # f irst by the rule l ! r. As in <ref> [13] </ref>, we introduce the -expanded form of -term. For example the -expanded form of (map f ffi map g) of type order two is ((map f ffi map g) x) of type order one (or elementary).
Reference: [14] <author> S. Thompson. </author> <title> Functional Programming: Executable Specifications and Program Transformation. </title> <booktitle> In Fifth International Workshop on Software Specification and Design., </booktitle> <publisher> IEEE Press, </publisher> <year> 1989. </year> <note> Id: HOA.tex,v 1.1 1994/02/24 17:50:09 bellegar Exp bellegar 15 </note>
Reference-contexts: To our knowledge, no general purpose transformation system supports this kind of transformation. 1 Maxsub example We illustrate our transformational approach with a program presented by S. Thompson <ref> [14] </ref> and first introduced by J. Bentley [3]. The problem solved by this program is stated as follows by Thompson: Given a finite list of numbers, find the maximum value for the sum of a (contiguous) sublist of the list. Numbers can be positive as well as negative integers. <p> The final result of the transformation is the functional program shown in Figure 2 which is linear. The theorems used during the transformation process are listed in Figure 3. The details of the manual transformations using these laws can be found in <ref> [14] </ref>. Let us now consider, a way to automate this transformation using completion and partial evaluation. The system Astre [1, 2] based on a partial completion procedure, deals with programs presented by a set of first-order equations.
Reference: [15] <author> S. Thompson. </author> <title> Type Theory and Functional Programming, </title> <publisher> Addison Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Bentley [3]. The problem solved by this program is stated as follows by Thompson: Given a finite list of numbers, find the maximum value for the sum of a (contiguous) sublist of the list. Numbers can be positive as well as negative integers. In his book <ref> [15] </ref>, S. Thompson presents formally the derivation of a functional program that achieves the computation described above. It is displayed in Figure 1. This program is quadratic in the length of the list.
Reference: [16] <author> P. Wadler, </author> <title> Deforestation: Transforming programs to eliminate trees. </title> <booktitle> In 2nd European Symposium on Programming ESOP'88, Nancy France, 1988. Lecture Notes in Computer Science 300, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: Indeed, compositions produce many intermediate data structures when computed in an eager (call by value) evaluation. One way to circumvent this problem is to perform deforestation on programs as advocated by Wadler <ref> [16] </ref>. <p> Indeed, compositions produce many intermediate data structures when computed in an eager (call by value) evaluation. One way to circumvent this problem is to perform deforestation on programs as advocated by Wadler [16]. Deforestation algorithms <ref> [16, 9] </ref>, as well as algorithms based on fl The work reported here was supported in part by a contract with Air Force Material Command (F1928-R-0032) and by a grant from NSF (CCR-9101721). 1 Id: HOA.tex,v 1.1 1994/02/24 17:50:09 bellegar Exp bellegar 2 promotion theorems [12] eliminate these useless intermediate data <p> When appropriately defined, laws can constitute a powerful calculus to derive efficient programs from higher-level specifications. The full paper describes an automatic process that uses laws on higher-order primitives to perform an extended form of deforestation. Related work Wadler has proposed an algorithm for deforestation in <ref> [16] </ref>. It works intrinsically on first-order programs though it is extended to higher-order programs by treating higher-order programs as macros. His algorithm performs automatic deforestation on treeless terms. Chin's work on fusion [5] applies to higher-order program in general, it skips over terms to which the technique does not apply. <p> However G is constant-only because its functional argument in the recursive call is a constant. The variable-only criteria is different from the restrictions given to higher-order functions that can be defined using higher-order macros as advocated in <ref> [16] </ref>: the functional arguments of these higher-order primitives must be fixed or unchanged across recursion. This criteria excludes mapTwo and H but includes G. <p> Let us consider now the transformation process. The main function maxsub is defined in a Squiggol way by composition of functions and not inductively. The term t = fold1 (map1 (sublists l)) is a candidate for a deforestation <ref> [16] </ref>. Deforestation algorithm of P.

References-found: 16

