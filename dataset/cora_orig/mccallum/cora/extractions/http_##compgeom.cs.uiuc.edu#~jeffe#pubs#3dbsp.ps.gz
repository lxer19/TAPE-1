URL: http://compgeom.cs.uiuc.edu/~jeffe/pubs/3dbsp.ps.gz
Refering-URL: http://compgeom.cs.uiuc.edu/~jeffe/pubs/3dbsp.html
Root-URL: http://www.cs.uiuc.edu
Title: Kinetic Binary Space Partitions for Intersecting Segments and Disjoint Triangles (Extended Abstract)  
Author: Pankaj K. Agarwal Jeff Erickson Leonidas J. Guibas 
Abstract: We describe randomized algorithms for efficiently maintaining a binary space partition of continuously moving, possibly intersecting, line segments in the plane, and of continuously moving but disjoint triangles in space. Our two-dimensional BSP has depth O(log n) and size O(n log n + k) and can be constructed in expected O(n log 2 n + k log n) time, where k is the number of intersecting pairs. We can detect combinatorial changes to our BSP caused by the motion of the segments, and we can update our BSP in expected O(log n) time per change. Our three-dimensional BSP has depth O(log n), size O(n log 2 n+k 0 ), construction time O(n log 3 n+k 0 log n), and update time O(log 2 n) (all expected), where k 0 is the number of intersections between pairs of edges in the xy-projection of the triangles. Under reasonable assumptions about the motion of the segments or triangles, the expected number of number of combinatorial changes to either BSP is O(mn s (n)), where m is the number of moving objects and s (n) is the maximum length of an (n; s) Davenport-Schinzel sequence for some constant s. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. K. Agarwal, L. J. Guibas, T. M. Murali, and J. S. Vitter. </author> <title> Cylindrical static and kinetic binary space partitions. </title> <booktitle> Proc. 13th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pp. 39-48, </pages> <year> 1997. </year>
Reference-contexts: We explicitly take advantage of the continuity of the motion of the objects involved so as to update the BSP only when actual events cause the BSP to change combinatorially. Such an approach was first used in a recent paper by Agarwal et al. <ref> [1] </ref> to maintain the BSP of a set of disjoint segments in the plane. In this paper we extend their approach to efficiently maintain a BSP for the considerably more complex case of disjoint triangles in IR 3 . <p> The previous best-known algorithms for triangles are by Agarwal et al. <ref> [1] </ref>. <p> In Section 3 we show that our static algorithms can be used to maintain the BSP of a set of moving segments or triangles. As in <ref> [1] </ref>, we assume that the segment motions are oblivious to the random bits used by the algorithm. Following Basch et al. [5], we also assume that each moving segment has a posted flight plan that gives full or partial information about its current motion. <p> The kinetic structure we propose for intersecting segments in the plane brings to light several important and subtle issues that did not arise in the disjoint segment context of <ref> [1] </ref>: intersections among the segments have to be detected and maintained; vertical threads from intersection points need to be propagated and their cost analyzed; when a segment becomes vertical during the motion, the entire ordering of intersection points on it flips, thus creating an event that can be expensive to process <p> Point cuts in B, and other cuts that do not meet the plane, do not contribute to Bj p . We easily observe that Bj p is a cylindrical BSP of the disjoint segments Sj p , exactly as described by Agarwal et al. <ref> [1] </ref> and in the previous section. <p> We will refer to these critical events as vertex, intersection, and edge events, respectively. We will call a segment rotating through a vertical line a flip event. Following <ref> [1] </ref>, we say that a node w of B is transient if the parent of w is associated with a point cut and w contains no vertices or intersection points, so the subtree rooted at w contains only edge cuts. <p> Three of the four cases already occur when the segments are disjoint, and were described and analyzed by Agarwal et al. <ref> [1] </ref>. <p> However, like earlier algorithms <ref> [1, 19, 23] </ref>, there are inputs for which our algorithm will build a BSP of quadratic size, even when a linear-size BSP is possible.
Reference: [2] <author> J. M. Airey. </author> <title> Increasing Update Rates in the Building Walkthrough System with Automatic Model-space Subdivision and Potentially Visible Set Calculations. </title> <type> Ph.D. thesis, </type> <institution> Dept. of Computer Science, University of North Carolina, Chapel Hill, </institution> <year> 1990. </year>
Reference-contexts: The efficiency of many BSP-based algorithms depends critically on the number of nodes in the tree. This dependence has motivated several algorithms for constructing BSPs of small size; see <ref> [2, 6, 11, 19, 20, 23, 24] </ref>. Most of the work to date on BSPs has dealt with static objects. In practice, however, the set of objects changes over time | some objects move along continuous paths, some new objects are added, and some old objects are removed.
Reference: [3] <author> M. J. Atallah. </author> <title> Some dynamic computational geometry problems. </title> <journal> Comput. Math. Appl. </journal> <volume> 11 </volume> <pages> 1171-1181, </pages> <year> 1985. </year>
Reference-contexts: A more effective approach is to regard BSP as a kinetic data structure, as introduced by Basch et al. [5]. (See <ref> [3, 12, 18] </ref> for some other weaker models for solving kinetic problems. 1 ) In the kinetic view each moving object follows a posted flight plan or path. <p> In Section 2 we present a randomized algorithm to construct a BSP for a set S of n stationary (possibly intersecting) segments in the plane. The algorithm constructs a BSP of expected size O (n log n+k) in expected 1 Atallah <ref> [3] </ref> and Ottmann and Wood [18] study kinetic geometric problems in an off-line setting, and Kahan [12] studies some problems under the assumption that the speed of the objects is bounded.
Reference: [4] <author> C. Ballieux. </author> <title> Motion planning using binary space partitions. </title> <type> Tech. Rep. </type> <institution> Inf/src/93-25, Utrecht University, </institution> <year> 1993. </year>
Reference-contexts: Besides these two important applications, BSPs have been used for many other problems in graphics (including ray tracing [16] and shadow generation [7, 8]), solid modeling [15, 24], geometric data repair [14], robotics <ref> [4] </ref>, etc.
Reference: [5] <author> J. Basch, L. Guibas, and J. Hershberger. </author> <title> Data structures for mobile data. </title> <booktitle> Proc. 8th ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pp. 747-756, </pages> <year> 1997. </year>
Reference-contexts: A more effective approach is to regard BSP as a kinetic data structure, as introduced by Basch et al. <ref> [5] </ref>. (See [3, 12, 18] for some other weaker models for solving kinetic problems. 1 ) In the kinetic view each moving object follows a posted flight plan or path. <p> In Section 3 we show that our static algorithms can be used to maintain the BSP of a set of moving segments or triangles. As in [1], we assume that the segment motions are oblivious to the random bits used by the algorithm. Following Basch et al. <ref> [5] </ref>, we also assume that each moving segment has a posted flight plan that gives full or partial information about its current motion. Based on these flight plans, we maintain a priority queue of upcoming events that change the combinatorial structure of our BSP.
Reference: [6] <author> T. Cassen, K. R. Subramanian, and Z. Michalewicz. </author> <title> Near-optimal construction of partitioning trees by evolutionary techniques. </title> <booktitle> Proc. Graphics Interface '95, </booktitle> <pages> pp. 263-271, </pages> <year> 1995. </year>
Reference-contexts: The efficiency of many BSP-based algorithms depends critically on the number of nodes in the tree. This dependence has motivated several algorithms for constructing BSPs of small size; see <ref> [2, 6, 11, 19, 20, 23, 24] </ref>. Most of the work to date on BSPs has dealt with static objects. In practice, however, the set of objects changes over time | some objects move along continuous paths, some new objects are added, and some old objects are removed.
Reference: [7] <author> N. Chin and S. Feiner. </author> <title> Near real-time shadow generation using BSP trees. </title> <journal> Comput. Graph. </journal> <volume> 23 </volume> <pages> 99-106, </pages> <year> 1989. </year> <note> Proc. SIGGRAPH '89. </note>
Reference-contexts: Besides these two important applications, BSPs have been used for many other problems in graphics (including ray tracing [16] and shadow generation <ref> [7, 8] </ref>), solid modeling [15, 24], geometric data repair [14], robotics [4], etc.
Reference: [8] <author> N. Chin and S. Feiner. </author> <title> Fast object-precision shadow generation for areal light sources using BSP trees. </title> <journal> Com-put. Graph. </journal> <volume> 25 </volume> <pages> 21-30, </pages> <month> Mar. </month> <year> 1992. </year> <booktitle> Proc. 1992 Sympos. Interactive 3D Graphics. </booktitle>
Reference-contexts: Besides these two important applications, BSPs have been used for many other problems in graphics (including ray tracing [16] and shadow generation <ref> [7, 8] </ref>), solid modeling [15, 24], geometric data repair [14], robotics [4], etc.
Reference: [9] <author> Y. Chrysanthou. </author> <title> Shadow Computation for 3D Interaction and Animation. </title> <type> Ph.D. thesis, </type> <institution> Queen Mary and Westfield College, University of London, </institution> <year> 1996. </year>
Reference-contexts: Extant work in the graphics community on maintaining a BSP of moving objects is all based on discretizing time into short intervals. At these discrete times the moving objects are deleted from the BSP and re-inserted in their new positions; see, for example, <ref> [17, 25, 9] </ref>. Such approaches suffer from the fundamental problem that it is difficult to know how to choose the correct length of the discretization interval.
Reference: [10] <author> J. D. Foley, A. van Dam, S. K. Feiner, J. F. Hughes, and Phillips. </author> <title> Introduction to Computer Graphics. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1993. </year>
Reference-contexts: Given a set of objects, a viewpoint, and an image plane, the hidden-surface-removal problem asks for computing the scene visible from the viewpoint on the image plane. A simple and widely used algorithm for hidden surface removal is the so-called painter's algorithm <ref> [10] </ref>, which draws the objects on the fl Center for Geometric Computing, Computer Science Department, Duke University, Box 90129, Durham, NC 27708-0129, agarwal@cs.duke.edu, http://www.cs.duke.edu/ ~ agarwal. Research supported by National Science Foundation grant CCR-93-01259, by U.S.
Reference: [11] <author> H. Fuchs, Z. M. Kedem, and B. Naylor. </author> <title> On visible surface generation by a priori tree structures. </title> <journal> Comput. Graph. </journal> <volume> 14 </volume> <pages> 124-133, </pages> <year> 1980. </year> <note> Proc. SIGGRAPH '80. </note>
Reference-contexts: In a typical setting one wants to draw the same set of objects repeatedly from different viewpoints, which calls for a data structure to store these objects so that a depth order from a given viewpoint can be computed quickly. Fuchs et al. <ref> [11] </ref> introduced the binary space partition (BSP), based on earlier work by Schumacker et al. [21], as a data structure for computing a depth order from a viewpoint. <p> The efficiency of many BSP-based algorithms depends critically on the number of nodes in the tree. This dependence has motivated several algorithms for constructing BSPs of small size; see <ref> [2, 6, 11, 19, 20, 23, 24] </ref>. Most of the work to date on BSPs has dealt with static objects. In practice, however, the set of objects changes over time | some objects move along continuous paths, some new objects are added, and some old objects are removed.
Reference: [12] <author> S. Kahan. </author> <title> A model for data in motion. </title> <booktitle> Proc. 23th Annu. ACM Sympos. Theory Comput., </booktitle> <pages> pp. 267-277, </pages> <year> 1991. </year>
Reference-contexts: A more effective approach is to regard BSP as a kinetic data structure, as introduced by Basch et al. [5]. (See <ref> [3, 12, 18] </ref> for some other weaker models for solving kinetic problems. 1 ) In the kinetic view each moving object follows a posted flight plan or path. <p> The algorithm constructs a BSP of expected size O (n log n+k) in expected 1 Atallah [3] and Ottmann and Wood [18] study kinetic geometric problems in an off-line setting, and Kahan <ref> [12] </ref> studies some problems under the assumption that the speed of the objects is bounded.
Reference: [13] <author> R. Motwani and P. Raghavan. </author> <title> Randomized Algorithms. </title> <publisher> Cambridge University Press, </publisher> <address> New York, NY, </address> <year> 1995. </year>
Reference-contexts: Let X be the number of edge cuts that see p from above. Since X is the sum of independent indicator variables and = E [X] H n , by Chernoff's bound, Pr [X &gt; ff] &lt; e ff1 for any constant ff <ref> [13, p.68] </ref>. In particular, for any constant c, we can choose ff so that Pr [X &gt; ffH n ] &lt; n c . Similarly, we can bound the number of edge cuts that see p from below.
Reference: [14] <author> T. M. Murali and T. A. Funkhouser. </author> <title> Consistent solid and boundary representations from arbitrary polygonal data. </title> <booktitle> Proc. 1997 Sympos. Interactive 3D Graphics, </booktitle> <year> 1997. </year>
Reference-contexts: Besides these two important applications, BSPs have been used for many other problems in graphics (including ray tracing [16] and shadow generation [7, 8]), solid modeling [15, 24], geometric data repair <ref> [14] </ref>, robotics [4], etc.
Reference: [15] <author> B. Naylor, J. A. Amanatides, and W. Thibault. </author> <title> Merging BSP trees yields polyhedral set operations. </title> <journal> Comput. Graph. </journal> <volume> 24 </volume> <pages> 115-124, </pages> <month> Aug. </month> <year> 1990. </year> <note> Proc. SIGGRAPH '90. </note>
Reference-contexts: Besides these two important applications, BSPs have been used for many other problems in graphics (including ray tracing [16] and shadow generation [7, 8]), solid modeling <ref> [15, 24] </ref>, geometric data repair [14], robotics [4], etc.
Reference: [16] <author> B. Naylor and W. Thibault. </author> <title> Application of BSP trees to ray-tracing and CSG evaluation. </title> <type> Technical Report GIT-ICS 86/03, </type> <institution> Georgia Institute of Tech., School of Information and Computer Science, </institution> <month> Feb. </month> <year> 1986. </year>
Reference-contexts: Besides these two important applications, BSPs have been used for many other problems in graphics (including ray tracing <ref> [16] </ref> and shadow generation [7, 8]), solid modeling [15, 24], geometric data repair [14], robotics [4], etc.
Reference: [17] <author> B. F. Naylor. </author> <title> Interactive solid geometry via partitioning trees. </title> <booktitle> Proc. Graphics Interface '92, </booktitle> <pages> pp. 11-18, </pages> <year> 1992. </year>
Reference-contexts: Extant work in the graphics community on maintaining a BSP of moving objects is all based on discretizing time into short intervals. At these discrete times the moving objects are deleted from the BSP and re-inserted in their new positions; see, for example, <ref> [17, 25, 9] </ref>. Such approaches suffer from the fundamental problem that it is difficult to know how to choose the correct length of the discretization interval.
Reference: [18] <author> T. Ottmann and D. Wood. </author> <title> Dynamical sets of points. Comput. Vision Graph. </title> <journal> Image Process. </journal> <volume> 27 </volume> <pages> 157-166, </pages> <year> 1984. </year>
Reference-contexts: A more effective approach is to regard BSP as a kinetic data structure, as introduced by Basch et al. [5]. (See <ref> [3, 12, 18] </ref> for some other weaker models for solving kinetic problems. 1 ) In the kinetic view each moving object follows a posted flight plan or path. <p> In Section 2 we present a randomized algorithm to construct a BSP for a set S of n stationary (possibly intersecting) segments in the plane. The algorithm constructs a BSP of expected size O (n log n+k) in expected 1 Atallah [3] and Ottmann and Wood <ref> [18] </ref> study kinetic geometric problems in an off-line setting, and Kahan [12] studies some problems under the assumption that the speed of the objects is bounded.
Reference: [19] <author> M. S. Paterson and F. F. Yao. </author> <title> Efficient binary space partitions for hidden-surface removal and solid modeling. </title> <journal> Discrete Comput. Geom. </journal> <volume> 5 </volume> <pages> 485-503, </pages> <year> 1990. </year>
Reference-contexts: The efficiency of many BSP-based algorithms depends critically on the number of nodes in the tree. This dependence has motivated several algorithms for constructing BSPs of small size; see <ref> [2, 6, 11, 19, 20, 23, 24] </ref>. Most of the work to date on BSPs has dealt with static objects. In practice, however, the set of objects changes over time | some objects move along continuous paths, some new objects are added, and some old objects are removed. <p> It is a challenging open problem to construct in polynomial time a BSP whose size is close to optimal (say, within a constant factor). Neither the algorithms by Agarwal et al. nor the original algorithm by Paterson and Yao <ref> [19] </ref> is suitable for a kinetic data structure because a small motion of one of the objects may cause many or non-local changes to the BSP. In Section 3 we show that our static algorithms can be used to maintain the BSP of a set of moving segments or triangles. <p> Since each interior node is associated with a cut, the size of B is twice the number of cuts made by our algorithm. There are clearly 2n vertex cuts and 2k intersection cuts in B. As Paterson and Yao observe <ref> [19] </ref>, the number of edge cuts contributed by a segment s i is one more than the number of point cuts that cross s i . Thus, to compute the size of B, it suffices to count the segments crossed by each point cut. Lemma 2.1. <p> However, like earlier algorithms <ref> [1, 19, 23] </ref>, there are inputs for which our algorithm will build a BSP of quadratic size, even when a linear-size BSP is possible.
Reference: [20] <author> M. S. Paterson and F. F. Yao. </author> <title> Optimal binary space partitions for orthogonal objects. </title> <journal> J. </journal> <volume> Algorithms 13 </volume> <pages> 99-113, </pages> <year> 1992. </year>
Reference-contexts: The efficiency of many BSP-based algorithms depends critically on the number of nodes in the tree. This dependence has motivated several algorithms for constructing BSPs of small size; see <ref> [2, 6, 11, 19, 20, 23, 24] </ref>. Most of the work to date on BSPs has dealt with static objects. In practice, however, the set of objects changes over time | some objects move along continuous paths, some new objects are added, and some old objects are removed.
Reference: [21] <author> R. A. Schumacker, R. Brand, M. Gilliland, and W. Sharp. </author> <title> Study for applying computer-generated images to visual simulation. </title> <type> Tech. Rep. </type> <institution> AFHRL-TR-69-14, U.S. Air Force Human Resources Laboratory, </institution> <year> 1969. </year>
Reference-contexts: Fuchs et al. [11] introduced the binary space partition (BSP), based on earlier work by Schumacker et al. <ref> [21] </ref>, as a data structure for computing a depth order from a viewpoint. Binary space partitions are also used to filter out a small subset of the input objects that comprises those visible from a given viewpoint.
Reference: [22] <author> M. Sharir and P. K. Agarwal. </author> <title> Davenport-Schinzel Sequences and Their Geometric Applications. </title> <publisher> Cambridge University Press, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: an event is only O ( s+2 (n)), where the constant s is the maximum number of times that two arcs in ij intersect, and s+2 (n) is the maximum (a) (b) (a) (b) shaded cells are transient; darker cells are leaves. length of an (n; s+ 2) Davenport-Schinzel sequence <ref> [22] </ref>, a (very) slightly superlinear function of n. Summing over all pairs i; j, the total number of events is only O (n 2 s+2 (n)).
Reference: [23] <author> S. J. Teller. </author> <title> Visibility Computations in Densely Occluded Polyhedral Environments. </title> <type> Ph.D. thesis, </type> <institution> Dept. of Computer Science, University of California, Berkeley, </institution> <year> 1992. </year>
Reference-contexts: Even algorithms that rely on a hardware z-buffer cannot render very large scenes (composed of millions of polygons) in real time, so filtering a small superset of objects visible from a given viewpoint is a critical step in obtaining fast rendering algorithms <ref> [23] </ref>. Besides these two important applications, BSPs have been used for many other problems in graphics (including ray tracing [16] and shadow generation [7, 8]), solid modeling [15, 24], geometric data repair [14], robotics [4], etc. <p> The efficiency of many BSP-based algorithms depends critically on the number of nodes in the tree. This dependence has motivated several algorithms for constructing BSPs of small size; see <ref> [2, 6, 11, 19, 20, 23, 24] </ref>. Most of the work to date on BSPs has dealt with static objects. In practice, however, the set of objects changes over time | some objects move along continuous paths, some new objects are added, and some old objects are removed. <p> However, like earlier algorithms <ref> [1, 19, 23] </ref>, there are inputs for which our algorithm will build a BSP of quadratic size, even when a linear-size BSP is possible.
Reference: [24] <author> W. C. Thibault and B. F. Naylor. </author> <title> Set operations on polyhedra using binary space partitioning trees. </title> <journal> Com-put. Graph. </journal> <volume> 21 </volume> <pages> 153-162, </pages> <year> 1987. </year> <note> Proc. SIGGRAPH '87. </note>
Reference-contexts: Besides these two important applications, BSPs have been used for many other problems in graphics (including ray tracing [16] and shadow generation [7, 8]), solid modeling <ref> [15, 24] </ref>, geometric data repair [14], robotics [4], etc. <p> The efficiency of many BSP-based algorithms depends critically on the number of nodes in the tree. This dependence has motivated several algorithms for constructing BSPs of small size; see <ref> [2, 6, 11, 19, 20, 23, 24] </ref>. Most of the work to date on BSPs has dealt with static objects. In practice, however, the set of objects changes over time | some objects move along continuous paths, some new objects are added, and some old objects are removed.
Reference: [25] <author> E. Torres. </author> <title> Optimization of the binary space partition algorithm (BSP) for the visualization of dynamic scenes. </title> <booktitle> Eurographics '90, </booktitle> <pages> pp. 507-518, </pages> <year> 1990. </year>
Reference-contexts: Extant work in the graphics community on maintaining a BSP of moving objects is all based on discretizing time into short intervals. At these discrete times the moving objects are deleted from the BSP and re-inserted in their new positions; see, for example, <ref> [17, 25, 9] </ref>. Such approaches suffer from the fundamental problem that it is difficult to know how to choose the correct length of the discretization interval.
References-found: 25

