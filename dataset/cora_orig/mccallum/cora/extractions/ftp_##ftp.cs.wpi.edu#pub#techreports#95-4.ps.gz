URL: ftp://ftp.cs.wpi.edu/pub/techreports/95-4.ps.gz
Refering-URL: http://cs.wpi.edu/Resources/techreports/index.html
Root-URL: 
Title: Self-Modifying Finite Automata Power and Limitations  
Author: by John N. Shutt 
Address: 100 Institute Road, Worcester, Massachusetts 01609-2280  
Affiliation: WORCESTER POLYTECHNIC INSTITUTE Computer Science Department  
Date: December 1995  
Pubnum: WPI-CS-TR-95-4  
Abstract: Computer Science Technical Report Series 
Abstract-found: 1
Intro-found: 1
Reference: [GS66] <author> S. Ginsburg and E. H. Spanier. </author> <title> Finite-turn pushdown automata. </title> <journal> SIAM J. Control, </journal> <volume> 4(3) </volume> <pages> 429-453, </pages> <month> Aug. </month> <year> 1966. </year>
Reference-contexts: This result will now be extended to the entire class of ultralinear languages. Basic definitions in the following treatment are adapted from <ref> [GS66] </ref>. Context-free grammars will be written in the form G = hV; ; P; Si, where V is the set of nonterminals, the set of terminals, P the set of productions, and S 2 V the start symbol of G.
Reference: [Har78] <author> M. Harrison. </author> <title> Introduction to Formal Language Theory. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1978. </year> <month> 31 </month>
Reference-contexts: This follows immediately from a construction in [RS93]. Figure 6 of that paper depicts a two-register first-order machine that accepts the set of all strings over fa; bg with the same number of a's and b's; this language is known to be context-free but not ultralinear <ref> [Har78] </ref>. 2 6 The pumping lemma In [RS93, RS95b], it is conjectured that Conjecture 6.1 (First-order register complexity classes) For every integer r 1, there exist languages with first-order register complexity r (that is, register complexity r in the class of all first-order SMFAs). 2 If true, this would separate the
Reference: [RS93] <author> R. Rubinstein and J. Shutt. </author> <title> Self-modifying finite automata. </title> <institution> Technical Re--port WPI-CS-TR-93-11, Worcester Polytechnic Institute, Worcester, </institution> <address> MA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: 1 Introduction The Self-Modifying Finite Automaton (SMFA) is a model of computation introduced in <ref> [RS93, RS94, RS95b] </ref>. SMFAs are similar to standard finite automata, but changes to the transition set are allowed during a computation. Formal definitions appear in [RS95a]. <p> This follows immediately from a construction in <ref> [RS93] </ref>. <p> Figure 6 of that paper depicts a two-register first-order machine that accepts the set of all strings over fa; bg with the same number of a's and b's; this language is known to be context-free but not ultralinear [Har78]. 2 6 The pumping lemma In <ref> [RS93, RS95b] </ref>, it is conjectured that Conjecture 6.1 (First-order register complexity classes) For every integer r 1, there exist languages with first-order register complexity r (that is, register complexity r in the class of all first-order SMFAs). 2 If true, this would separate the first-order SMFA languages into an infinite hierarchy. <p> These results extend and augment results previously presented in <ref> [RS93, RS94, RS95a, RS95b] </ref>. The treatment of number of SMFA registers as a complexity measure was proposed. <p> First proposed in <ref> [RS93] </ref>, the conjecture states that the first-order register complexity of fw r+1 j w 2 Lg is r for some regular L. The conjecture was shown to be true for r 2, but false for r 3.
Reference: [RS94] <author> R. Rubinstein and J. Shutt. </author> <title> Self-modifying finite automata. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> Technology and Foundations: Information Processing '94 Vol. I: Proc. 13th IFIP World Computer Congress, </booktitle> <pages> pages 493-498, </pages> <address> Amsterdam, 1994. </address> <publisher> North-Holland. </publisher>
Reference-contexts: 1 Introduction The Self-Modifying Finite Automaton (SMFA) is a model of computation introduced in <ref> [RS93, RS94, RS95b] </ref>. SMFAs are similar to standard finite automata, but changes to the transition set are allowed during a computation. Formal definitions appear in [RS95a]. <p> Formal definitions appear in [RS95a]. A weakly restricted form of SMFAs has been shown to be Turing powerful [RS95a], and strongly restricted forms have been shown to accept the class of metalin-ear languages, as well as some other classes of context-free and even non-context-free languages <ref> [RS94, RS95b] </ref>. This paper further investigates the computational power of SMFAs. Results presented establish lower or upper bounds on the computational power of various classes of SMFAs. <p> These results extend and augment results previously presented in <ref> [RS93, RS94, RS95a, RS95b] </ref>. The treatment of number of SMFA registers as a complexity measure was proposed.
Reference: [RS95a] <author> R. Rubinstein and J. Shutt. </author> <title> Self-modifying finite automata | basic definitions and results. </title> <type> Technical Report WPI-CS-TR-95-2, </type> <institution> Worcester Polytechnic Institute, Worcester, </institution> <address> MA, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: 1 Introduction The Self-Modifying Finite Automaton (SMFA) is a model of computation introduced in [RS93, RS94, RS95b]. SMFAs are similar to standard finite automata, but changes to the transition set are allowed during a computation. Formal definitions appear in <ref> [RS95a] </ref>. A weakly restricted form of SMFAs has been shown to be Turing powerful [RS95a], and strongly restricted forms have been shown to accept the class of metalin-ear languages, as well as some other classes of context-free and even non-context-free languages [RS94, RS95b]. <p> SMFAs are similar to standard finite automata, but changes to the transition set are allowed during a computation. Formal definitions appear in <ref> [RS95a] </ref>. A weakly restricted form of SMFAs has been shown to be Turing powerful [RS95a], and strongly restricted forms have been shown to accept the class of metalin-ear languages, as well as some other classes of context-free and even non-context-free languages [RS94, RS95b]. This paper further investigates the computational power of SMFAs. <p> Other important developments including the property of path determinism, and the consideration of number of registers as a complexity measure. 2 Preliminaries All the definitions and conventions of <ref> [RS95a] </ref> are assumed here without repetition. For any alphabet X, X = X [ fg. The following additional definitions and conventions are adopted henceforth. <p> Self-deletion is unordered, so there is nothing more to be usefully said about the order of the deletion function. The need for this convention did not arise in <ref> [RS95a] </ref> because SMFAs with self-delete were only peripherally mentioned there. Note particularly that the above conventions pertain to SMFAs, not SMAs. Any definition or result that explicitly addresses "SMAs" entails no implicit assumptions about the properties of modification functions. <p> the most universally applicable distinctions between classes of automata is that between deterministic and nondeterministic: Does the machine always have to proceed in a certain way, or is there sometimes more than one way to go? Interestingly, even the definition of determinism for SMFAs | conspicuous by its absence from <ref> [RS95a] </ref> | is not altogether straightforward. An ordinary finite automaton, or even an ordinary Turing machine, is deterministic iff its transition function is single-valued. Since the transition function is both fixed and finite, it is always immediately obvious whether or not the machine is deterministic. <p> M is lookahead n path-deterministic up to trivial transitions iff every reachable configuration of M is lookahead n path-deterministic up to trivial transitions. 2 6 3.3 Turing power In <ref> [RS95a] </ref>, it was proven that SMFAs are Turing powerful. Specifically, given a deterministic Turing machine M , an SMFA was constructed that simulates M . The register complexity of the construction was not particularly remarked on. This result is repeated below, with register complexity specifically noted. <p> Also, if M is deterministic, modifying N to always select the first allowable 17 transition found does not alter the language accepted or the space complexity, but does render N deterministic, hence L (M ) is deterministic context-sensitive. 2 5 Finite-order SMFAs Recall from <ref> [RS95a] </ref> that, formally, an SMA is defined as a 9-tuple, while practically, when the SMA is without deletion, the deletion function is usually omitted, leaving an 8-tuple. In the special case of finite-order SMFAs, the action set and addition function can also be omitted as follows, leaving a 6-tuple. <p> Definition 5.1 (Normal form of actions) Suppose M is an SMA, A the action set of M . For each a 2 A, let norm (a) be the closed-form standard representation of a (defined in <ref> [RS95a] </ref> Convention 3.7), if any. Then an action a 2 A is in normal form iff a = norm (a). <p> If G is metalinear, it has a two-set ultralinear decomposition V 0 = V fSg, V 1 = fSg. Theorem 5.9 (Ultralinear languages) Every ultralinear language is accepted by some single-register first-order SMFA. 2 The following proof adapts and extends the proof in <ref> [RS95a] </ref> that every linear language is accepted by some first-order SMFA. Proof. Suppose L is an ultralinear language over alphabet . Let G = hV; ; P; Si be an ultralinear grammar that generates L, and V 0 ; V n an ultralinear decomposition of G. <p> These results extend and augment results previously presented in <ref> [RS93, RS94, RS95a, RS95b] </ref>. The treatment of number of SMFA registers as a complexity measure was proposed.
Reference: [RS95b] <author> R. Rubinstein and J. Shutt. </author> <title> Self-modifying finite automata: An introduction. </title> <journal> Information Processing Letters, </journal> <volume> 56(4) </volume> <pages> 185-190, </pages> <month> November </month> <year> 1995. </year> <month> 32 </month>
Reference-contexts: 1 Introduction The Self-Modifying Finite Automaton (SMFA) is a model of computation introduced in <ref> [RS93, RS94, RS95b] </ref>. SMFAs are similar to standard finite automata, but changes to the transition set are allowed during a computation. Formal definitions appear in [RS95a]. <p> Formal definitions appear in [RS95a]. A weakly restricted form of SMFAs has been shown to be Turing powerful [RS95a], and strongly restricted forms have been shown to accept the class of metalin-ear languages, as well as some other classes of context-free and even non-context-free languages <ref> [RS94, RS95b] </ref>. This paper further investigates the computational power of SMFAs. Results presented establish lower or upper bounds on the computational power of various classes of SMFAs. <p> a tuple, the action set and addition function are usually omitted, so that the automaton is a 6-tuple M = h; Q 0 ; R; S; F; ffi 0 i rather than an 8-tuple M = h; Q 0 ; R; A; S; F; ffi 0 ; ffi. 2 In <ref> [RS95b] </ref>, the tuple representation of SMFAs also omits the register set, leaving a 5-tuple. The explicit register set will be retained here, because in all but single register machines, the registers are explicitly named in the normal-form actions. <p> The SMFA N constructed as above satisfies the theorem. 2 Convention 5.5 (single-addition) Hereafter to the end of the paper, all SMFAs with self-delete are assumed single addition except where explicitly otherwise stated. 2 5.2 Ultralinear languages In <ref> [RS95b] </ref>, it was proved that all metalinear languages are accepted by single-register first-order SMFAs. This result will now be extended to the entire class of ultralinear languages. Basic definitions in the following treatment are adapted from [GS66]. <p> The machine constructed to accept L (S) establishes the theorem. 2 It is not known whether any single-register first-order SMFA can accept a context-free, non-ultralinear language. (Single-register first-order SMFAs to accept non-context-free languages are commonplace; see for example <ref> [RS95b] </ref>.) However, Theorem 5.10 (Non-ultralinear context-free languages) There exists a first-order SMFA with two registers that accepts a non-ultralinear context-free language. 2 Proof. This follows immediately from a construction in [RS93]. <p> Figure 6 of that paper depicts a two-register first-order machine that accepts the set of all strings over fa; bg with the same number of a's and b's; this language is known to be context-free but not ultralinear [Har78]. 2 6 The pumping lemma In <ref> [RS93, RS95b] </ref>, it is conjectured that Conjecture 6.1 (First-order register complexity classes) For every integer r 1, there exist languages with first-order register complexity r (that is, register complexity r in the class of all first-order SMFAs). 2 If true, this would separate the first-order SMFA languages into an infinite hierarchy. <p> These results extend and augment results previously presented in <ref> [RS93, RS94, RS95a, RS95b] </ref>. The treatment of number of SMFA registers as a complexity measure was proposed.
References-found: 6

