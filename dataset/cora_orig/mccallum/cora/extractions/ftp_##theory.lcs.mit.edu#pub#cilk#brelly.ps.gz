URL: ftp://theory.lcs.mit.edu/pub/cilk/brelly.ps.gz
Refering-URL: http://theory.lcs.mit.edu/~cilk/abstracts/brelly.html
Root-URL: 
Title: Detecting Data Races in Cilk Programs that Use Locks k T a(V;V time and O(n
Author: Guang-Ien Cheng Mingdong Feng Charles E. Leiserson Keith H. Randall Andrew F. Stark Cilk_unlock(&B); Cilk_lock_init(&A); Cilk_unlock(&A); Cilk_lock_init(&B); Cilk_unlock(&A); printf("%d", 
Keyword: Algorithm, Cilk, data race, debugging, multithreading, parallel programming, race detection.  
Date: June 1998.  0;  
Address: 545 Technology Square, Cambridge, Massachusetts 02139, USA.  Singapore, 10 Lower Kent Ridge Road, Republic of Singapore 119260.  
Affiliation: MIT Laboratory for Computer Science,  Department of Information Systems and Computer Science, National University of  
Note: O(n  This research was supported in part by the Defense Advanced Research Projects Agency (DARPA) under Grants N00014-94-1-0985 and F30602-97-1-0270. To appear in Proceedings of the Tenth Annual ACM Symposium on Parallel Algorithms and Architectures (SPAA), Puerto Val-larta,  
Abstract: When two parallel threads holding no locks in common access the same memory location and at least one of the threads modifies the location, a data race occurs, which is usually a bug. This paper describes the algorithms and strategies used by a debugging tool, called the Nondeterminator-2, which checks for data races in programs coded in the Cilk multithreaded language. Like its predecessor, the Nondeterminator, which checks for simple determinacy races, the Nondeterminator-2 is a debugging tool, not a verifier, since it checks for data races only in the computation generated by a serial execution of the program on a given input. We give an algorithm, ALL-SETS, that determines whether the computation generated by a serial execution of a Cilk program on a given input contains a race. For a program that runs serially in time T , accesses V shared memory locations, uses a total of n locks, and holds at most k t n locks simultaneously, ALL-SETS runs in Since ALL-SETS may be too inefficient in the worst case, we propose a much more efficient algorithm which can be used to detect races in programs that obey the umbrella locking discipline, a programming methodology that is more flexible than similar disciplines proposed in the literature. We present an algorithm, BRELLY, which detects violations of the umbrella discipline in O(kT a(V;V )) time using O(kV ) space. We also prove that any abelian Cilk program, one whose critical sections commute, produces a determinate final state if it is deadlock free and if it generates any computation which is data-race free. Thus, the Nondeterminator-2's two algorithms can verify the determinacy of a deadlock-free abelian program running on a given input. Figure 1: A Cilk program with a data race. Cilk [3, 4, 6, 15, 20] is a multithreaded parallel language based on C being developed at the MIT Laboratory for Computer Science. The spawn statement in a Cilk program creates a parallel subprocedure, and the sync statement provides control synchronization to ensure that all spawned subprocedures have completed. The function Cilk lock() acquires a specified lock, and Cilk unlock() releases a currently held lock. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Barnes and P. Hut. </author> <title> A hierarchical O(N log N) force-calculation algorithm. </title> <booktitle> Nature, </booktitle> <address> 324:446449, </address> <year> 1986. </year>
Reference-contexts: Thus, for this application, the maximum number of locks held by a thread is k = 2, and L is at most the maximum degree of any vertex. n-body: An n-body gravity simulation using the Barnes-Hut algorithm <ref> [1] </ref>. In one phase of the program, parallel threads race to build various parts of an octtree data structure. Each part is protected by an associated lock, and the first thread to acquire that lock builds that part of the structure.
Reference: [2] <author> Philippe Bekaert, Frank Suykens de Laet, and Philip Dutre. Ren-derpark, </author> <year> 1997. </year> <note> Available on the Internet from http://www.cs. kuleuven.ac./cwis/research/graphics/RENDERPARK/. </note>
Reference-contexts: This algorithm is analogous to the typical way a hash table is accessed in parallel. For this program, we have k = L = 1. rad: A 3-dimensional radiosity renderer running on a maze scene. The original 75-source-file C code was developed in Bel-gium by Bekaert et. al. <ref> [2] </ref>. We used Cilk to parallelize its scene geometry calculations. Each surface in the scene has its own lock, as does each patch of the surface.
Reference: [3] <author> Robert D. Blumofe. </author> <title> Executing Multithreaded Programs Efficiently. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, </institution> <month> September </month> <year> 1995. </year>
Reference: [4] <author> Robert D. Blumofe, Christopher F. Joerg, Bradley C. Kuszmaul, Charles E. Leiserson, Keith H. Randall, and Yuli Zhou. Cilk: </author> <title> An efficient multithreaded runtime system. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 37(1):5569, </volume> <month> August </month> <year> 1996. </year>
Reference: [5] <author> Robert D. Blumofe, Christopher F. Joerg, Bradley C. Kuszmaul, Charles E. Leiserson, Keith H. Randall, and Yuli Zhou. Cilk: </author> <title> An efficient multithreaded runtime system. </title> <booktitle> In Proceedings of the Fifth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP), pages 207216, </booktitle> <address> Santa Barbara, California, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: We view the abstract execution machine for Cilk as a (sequentially consistent [21]) shared memory together with a collection of interpreters, each with some private state. (See <ref> [5, 8, 17] </ref> for examples of multithreaded implementations similar to this model.) Interpreters are dynamically created during execution by each spawn statement. The ith such child of an interpreter is given a unique interpreter name by appending i to its parent's name.
Reference: [6] <author> Cilk-5.1 Reference Manual. </author> <note> Available on the Internet from http:// theory.lcs.mit.edu/~cilk. </note>
Reference-contexts: Each leaf is labeled with a code fragment that accesses x, with the lock set for that access shown above the code fragment. e 2 in a left-to-right depth-first treewalk of the parse tree. The series relation is transitive. Release 5.1 of Cilk <ref> [6] </ref> provides the user with mutual-exclusion locks, including the command Cilk lock () to acquire a specified lock and Cilk unlock () to release a currently held lock. Any number of locks may be held simultaneously.
Reference: [7] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Each part is protected by an associated lock, and the first thread to acquire that lock builds that part of the structure. As the program never holds more than one lock at a time, we have k = L = 1. bucket: A bucket sort <ref> [7, Section 9.4] </ref>. Parallel threads acquire the lock associated with a bucket before adding elements to it. This algorithm is analogous to the typical way a hash table is accessed in parallel.
Reference: [8] <author> David E. Culler, Anurag Sah, Klaus Erik Schauser, Thorsten von Eicken, and John Wawrzynek. </author> <title> Fine-grain parallelism with minimal hardware support: A compiler-controlled threaded abstract machine. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <pages> pages 164175, </pages> <address> Santa Clara, California, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: We view the abstract execution machine for Cilk as a (sequentially consistent [21]) shared memory together with a collection of interpreters, each with some private state. (See <ref> [5, 8, 17] </ref> for examples of multithreaded implementations similar to this model.) Interpreters are dynamically created during execution by each spawn statement. The ith such child of an interpreter is given a unique interpreter name by appending i to its parent's name.
Reference: [9] <author> Anne Dinning and Edith Schonberg. </author> <title> An empirical comparison of monitoring algorithms for access anomaly detection. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles & Practice of Parallel Programming (PPoPP), </booktitle> <pages> pages 110. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [12, 18, 23, 26], while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [9, 10, 13, 14, 22, 29] </ref>, by binary rewriting [32], or by augmenting the machine's cache coherence protocol [24, 30]. The race-detection algorithms in this paper are based on the Non-determinator [13], which finds determinacy races in Cilk programs that do not use locks.
Reference: [10] <author> Anne Dinning and Edith Schonberg. </author> <title> Detecting access anomalies in programs with critical sections. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 8596. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [12, 18, 23, 26], while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [9, 10, 13, 14, 22, 29] </ref>, by binary rewriting [32], or by augmenting the machine's cache coherence protocol [24, 30]. The race-detection algorithms in this paper are based on the Non-determinator [13], which finds determinacy races in Cilk programs that do not use locks. <p> Tighter, more complicated bounds on ALL-SETS will be given in Section 2. In previous work, Dinning and Schonberg's lock-covers algorithm <ref> [10] </ref> also detects all data races in a computation. The ALL SETS algorithm improves the lock-covers algorithm by generalizing the data structures and techniques from the original Nondetermina-tor to produce better time and space bounds. <p> For abelian programs, therefore, ALL-SETS and BRELLY can verify the determinacy of the program on a given input. Our results on abelian programs formalize and generalize the claims of Dinning and Schonberg <ref> [10, 11] </ref>, who argue that for internally deterministic programs, checking a single computation suffices to detect all races in the program. The remainder of this paper is organized as follows. Section 2 presents the ALL-SETS algorithm, and Section 3 presents the BRELLY algorithm. <p> False reports are not a problem when the program being debugged is abelian, but programmers would like to know whether an ostensibly abelian program is actually abelian. Dinning and Schonberg give a conservative compile-time algorithm to check if a program is internally deterministic <ref> [10] </ref>, and we have given thought to how the abelian property might likewise be conservatively checked. The parallelizing compiler techniques of Rinard and Diniz [31] may be applicable. We are currently investigating versions of ALL-SETS and BRELLY that correctly detect races even when parallelism is allowed within critical sections.
Reference: [11] <author> Anne Carolyn Dinning. </author> <title> Detecting Nondeterminism in Shared Memory Parallel Programs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, </institution> <address> New York University, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: For abelian programs, therefore, ALL-SETS and BRELLY can verify the determinacy of the program on a given input. Our results on abelian programs formalize and generalize the claims of Dinning and Schonberg <ref> [10, 11] </ref>, who argue that for internally deterministic programs, checking a single computation suffices to detect all races in the program. The remainder of this paper is organized as follows. Section 2 presents the ALL-SETS algorithm, and Section 3 presents the BRELLY algorithm.
Reference: [12] <author> Perry A. Emrath, Sanjoy Ghosh, and David A. Padua. </author> <title> Event synchronization analysis for debugging parallel programs. </title> <booktitle> In Supercomputing '91, </booktitle> <pages> pages 580588, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Since static debuggers cannot fully understand the semantics of programs, however, most race detectors 1 are dynamic tools in which potential races are detected at runtime by executing the program on a given input. Some dynamic race detectors perform a post-mortem analysis based on program execution traces <ref> [12, 18, 23, 26] </ref>, while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler [9, 10, 13, 14, 22, 29], by binary rewriting [32], or by augmenting the machine's cache coherence protocol [24, 30].
Reference: [13] <author> Mingdong Feng and Charles E. Leiserson. </author> <title> Efficient detection of de-terminacy races in Cilk programs. </title> <booktitle> In Proceedings of the Ninth Annual ACM Symposium on Parallel Algorithms and Architectures (SPAA), </booktitle> <pages> pages 111, </pages> <address> Newport, Rhode Island, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [12, 18, 23, 26], while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [9, 10, 13, 14, 22, 29] </ref>, by binary rewriting [32], or by augmenting the machine's cache coherence protocol [24, 30]. The race-detection algorithms in this paper are based on the Non-determinator [13], which finds determinacy races in Cilk programs that do not use locks. <p> On-the-fly debuggers directly instrument memory accesses via the compiler [9, 10, 13, 14, 22, 29], by binary rewriting [32], or by augmenting the machine's cache coherence protocol [24, 30]. The race-detection algorithms in this paper are based on the Non-determinator <ref> [13] </ref>, which finds determinacy races in Cilk programs that do not use locks. The Nondeterminator executes a Cilk program serially on a given input, maintaining an efficient SP-bags data structure to keep track of the logical series/parallel relationships between threads. <p> Lines 13 check to see if a data race has occurred and report any violations. Lines 511 then add the current locker to the lockers shadow space and prune redundant lockers. Before proving the correctness of ALL-SETS, we restate two important lemmas from <ref> [13] </ref>. Lemma 1 Suppose that three threads e 1 , e 2 , and e 3 execute in order in a serial, depth-first execution of a Cilk program, and suppose that e 1 e 2 and e 1 k e 3 . <p> Not shown are the updates to H, the set of currently held set of locks, which occur whenever locks are acquired or released. To determine whether the currently executing thread is in series or parallel with previously executed threads, BRELLY uses the SP-bags data structure from <ref> [13] </ref>. that do not belong to the current lock set H (lines 710) or whose nonlockers are in parallel with the current thread (lines 1113).
Reference: [14] <author> Yaacov Fenster. </author> <title> Detecting parallel access anomalies. </title> <type> Master's thesis, </type> <institution> Hebrew University, </institution> <month> March </month> <year> 1998. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [12, 18, 23, 26], while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [9, 10, 13, 14, 22, 29] </ref>, by binary rewriting [32], or by augmenting the machine's cache coherence protocol [24, 30]. The race-detection algorithms in this paper are based on the Non-determinator [13], which finds determinacy races in Cilk programs that do not use locks.
Reference: [15] <author> Matteo Frigo, Keith H. Randall, and Charles E. Leiserson. </author> <booktitle> The implementation of the Cilk-5 multithreaded language. In Proceedings of the ACM SIGPLAN '98 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1998. </year> <note> To appear. </note>
Reference: [16] <author> Andrew V. Goldberg and Robert E. Tarjan. </author> <title> A new approach to the maximum flow problem. </title> <booktitle> In Proceedings of the Eighteenth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 136146, </pages> <address> Berkeley, California, </address> <month> 2830 May </month> <year> 1986. </year>
Reference-contexts: According to Theorem 9, the worst-case slowdown factor for BRELLY is about Q (k). In order to compare our experimental results with the theoretical bounds, we characterize our four test programs in terms of the parameters k and L: 3 maxflow: A maximum-flow code based on Goldberg's push-relabel method <ref> [16] </ref>. Each vertex in the graph contains a lock. Parallel threads perform simple operations asynchronously on graph edges and vertices.
Reference: [17] <author> Michael Halbherr, Yuli Zhou, and Chris F. Joerg. </author> <title> MIMD-style parallel programming with continuation-passing threads. </title> <booktitle> In Proceedings of the 2nd International Workshop on Massive Parallelism: Hardware, Software, and Applications, </booktitle> <address> Capri, Italy, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: We view the abstract execution machine for Cilk as a (sequentially consistent [21]) shared memory together with a collection of interpreters, each with some private state. (See <ref> [5, 8, 17] </ref> for examples of multithreaded implementations similar to this model.) Interpreters are dynamically created during execution by each spawn statement. The ith such child of an interpreter is given a unique interpreter name by appending i to its parent's name.
Reference: [18] <author> David P. Helmbold, Charles E. McDowell, and Jian-Zhong Wang. </author> <title> Analyzing traces with anonymous synchronization. </title> <booktitle> In Proceedings of the 1990 International Conference on Parallel Processing, </booktitle> <address> pages II70 II77, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Since static debuggers cannot fully understand the semantics of programs, however, most race detectors 1 are dynamic tools in which potential races are detected at runtime by executing the program on a given input. Some dynamic race detectors perform a post-mortem analysis based on program execution traces <ref> [12, 18, 23, 26] </ref>, while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler [9, 10, 13, 14, 22, 29], by binary rewriting [32], or by augmenting the machine's cache coherence protocol [24, 30].
Reference: [19] <author> Richard C. Holt. </author> <title> Some deadlock properties of computer systems. </title> <journal> Computing Surveys, </journal> <volume> 4(3):179196, </volume> <month> September </month> <year> 1972. </year>
Reference-contexts: A locking discipline is a programming methodology that dictates a restriction on the use of locks. For example, many programs adopt the discipline of acquiring locks in a fixed order so as to avoid deadlock <ref> [19] </ref>. Similarly, the umbrella locking discipline precludes data races. It requires that each location be protected by the same lock within every parallel subcomputation of the computation.
Reference: [20] <author> Christopher F. Joerg. </author> <title> The Cilk System for Parallel Multithreaded Computing. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, </institution> <month> January </month> <year> 1996. </year>
Reference: [21] <author> Leslie Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):690691, </volume> <month> September </month> <year> 1979. </year>
Reference-contexts: In order to study the determinacy of abelian programs, we first give a formal multithreaded machine model that more precisely describes an actual execution of a Cilk program. We view the abstract execution machine for Cilk as a (sequentially consistent <ref> [21] </ref>) shared memory together with a collection of interpreters, each with some private state. (See [5, 8, 17] for examples of multithreaded implementations similar to this model.) Interpreters are dynamically created during execution by each spawn statement.
Reference: [22] <author> John Mellor-Crummey. </author> <title> On-the-fly detection of data races for programs with nested fork-join parallelism. </title> <booktitle> In Proceedings of Supercomputing'91, </booktitle> <pages> pages 2433. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [12, 18, 23, 26], while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [9, 10, 13, 14, 22, 29] </ref>, by binary rewriting [32], or by augmenting the machine's cache coherence protocol [24, 30]. The race-detection algorithms in this paper are based on the Non-determinator [13], which finds determinacy races in Cilk programs that do not use locks.
Reference: [23] <author> Barton P. Miller and Jong-Deok Choi. </author> <title> A mechanism for efficient debugging of parallel programs. </title> <booktitle> In Proceedings of the 1988 ACM SIG-PLAN Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 135144, </pages> <address> Atlanta, Georgia, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: Since static debuggers cannot fully understand the semantics of programs, however, most race detectors 1 are dynamic tools in which potential races are detected at runtime by executing the program on a given input. Some dynamic race detectors perform a post-mortem analysis based on program execution traces <ref> [12, 18, 23, 26] </ref>, while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler [9, 10, 13, 14, 22, 29], by binary rewriting [32], or by augmenting the machine's cache coherence protocol [24, 30].
Reference: [24] <author> Sang Lyul Min and Jong-Deok Choi. </author> <title> An efficient cache-based access anomaly detection scheme. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <pages> pages 235244, </pages> <address> Palo Alto, California, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: On-the-fly debuggers directly instrument memory accesses via the compiler [9, 10, 13, 14, 22, 29], by binary rewriting [32], or by augmenting the machine's cache coherence protocol <ref> [24, 30] </ref>. The race-detection algorithms in this paper are based on the Non-determinator [13], which finds determinacy races in Cilk programs that do not use locks.
Reference: [25] <author> Greg Nelson, K. Rustan M. Leino, James B. Saxe, and Raymie Stata. </author> <title> Extended static checking home page, </title> <note> 1996. Available on the Internet from http://www.research.digital.com/SRC/ esc/Esc.html. </note>
Reference-contexts: Since a data race is usually a bug, automatic data-race detection has been studied extensively. Static race detectors <ref> [25] </ref> can sometimes determine whether a program will ever produce a data race when run on all possible inputs.
Reference: [26] <author> Robert H. B. Netzer and Sanjoy Ghosh. </author> <title> Efficient race condition detection for shared-memory programs with post/wait synchronization. </title> <booktitle> In Proceedings of the 1992 International Conference on Parallel Processing, </booktitle> <address> St. Charles, Illinois, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Since static debuggers cannot fully understand the semantics of programs, however, most race detectors 1 are dynamic tools in which potential races are detected at runtime by executing the program on a given input. Some dynamic race detectors perform a post-mortem analysis based on program execution traces <ref> [12, 18, 23, 26] </ref>, while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler [9, 10, 13, 14, 22, 29], by binary rewriting [32], or by augmenting the machine's cache coherence protocol [24, 30].
Reference: [27] <author> Robert H. B. Netzer and Barton P. Miller. </author> <title> On the complexity of event ordering for shared-memory parallel program executions. </title> <booktitle> In Proceedings of the 1990 International Conference on Parallel Processing, pages II: </booktitle> <volume> 9397, </volume> <month> August </month> <year> 1990. </year>
Reference-contexts: Since the problem of exactly finding feasible data races is computation-ally difficult, 1 attention has naturally focused on the easier (but still difficult) problem of finding apparent data races. 1 Even in simple models, finding feasible data races is NP-hard <ref> [27] </ref>. 2 For some classes of programs, however, a feasible data race on a given input exists if and only if an apparent data race exists in every computation for that input.
Reference: [28] <author> Robert H. B. Netzer and Barton P. Miller. </author> <title> What are race conditions? ACM Letters on Programming Languages and Systems, </title> <address> 1(1):7488, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: Thus, although the umbrella discipline is more flexible than Eraser's discipline, it is more restrictive than what a general data-race detection algorithm, such as ALL-SETS, permits. Most dynamic race detectors, like ALL-SETS and BRELLY, attempt to find, in the terminology of Netzer and Miller <ref> [28] </ref>, apparent data racesthose that appear to occur in a computation according to the parallel control constructsrather than feasible data racesthose that can actually occur during program execution. The distinction arises, because operations in critical sections may affect program control depending on the way threads are scheduled.
Reference: [29] <author> Itzhak Nudler and Larry Rudolph. </author> <title> Tools for the efficient development of efficient parallel programs. </title> <booktitle> In Proceedings of the First Israeli Conference on Computer Systems Engineering, </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [12, 18, 23, 26], while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [9, 10, 13, 14, 22, 29] </ref>, by binary rewriting [32], or by augmenting the machine's cache coherence protocol [24, 30]. The race-detection algorithms in this paper are based on the Non-determinator [13], which finds determinacy races in Cilk programs that do not use locks.
Reference: [30] <author> Dejan Perkovic and Peter Keleher. </author> <title> Online data-race detection via coherency guarantees. </title> <booktitle> In Proceedings of the Second USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <address> Seat-tle, Washington, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: On-the-fly debuggers directly instrument memory accesses via the compiler [9, 10, 13, 14, 22, 29], by binary rewriting [32], or by augmenting the machine's cache coherence protocol <ref> [24, 30] </ref>. The race-detection algorithms in this paper are based on the Non-determinator [13], which finds determinacy races in Cilk programs that do not use locks. <p> In previous work, Dinning and Schonberg's lock-covers algorithm [10] also detects all data races in a computation. The ALL SETS algorithm improves the lock-covers algorithm by generalizing the data structures and techniques from the original Nondetermina-tor to produce better time and space bounds. Perkovic and Keleher <ref> [30] </ref> offer an on-the-fly race-detection algorithm that piggybacks on a cache-coherence protocol for lazy release consistency.
Reference: [31] <author> Martin C. Rinard and Pedro C. Diniz. </author> <title> Commutativity analysis: A new analysis framework for parallelizing compilers. </title> <booktitle> In Proceedings of the 1996 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 5467, </pages> <address> Philadelphia, Pennsylva-nia, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Dinning and Schonberg give a conservative compile-time algorithm to check if a program is internally deterministic [10], and we have given thought to how the abelian property might likewise be conservatively checked. The parallelizing compiler techniques of Rinard and Diniz <ref> [31] </ref> may be applicable. We are currently investigating versions of ALL-SETS and BRELLY that correctly detect races even when parallelism is allowed within critical sections. A more ambitious goal is to detect potential deadlocks by dynamically detecting the user's accordance with a flexible locking discipline that precludes deadlocks.
Reference: [32] <author> Stefan Savage, Michael Burrows, Greg Nelson, Patric Sobalvarro, and Thomas Anderson. Eraser: </author> <title> A dynamic race detector for multi-threaded programs. </title> <booktitle> In Proceedings of the Sixteenth ACM Symposium on Operating Systems Principles (SOSP), </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [12, 18, 23, 26], while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler [9, 10, 13, 14, 22, 29], by binary rewriting <ref> [32] </ref>, or by augmenting the machine's cache coherence protocol [24, 30]. The race-detection algorithms in this paper are based on the Non-determinator [13], which finds determinacy races in Cilk programs that do not use locks. <p> If a program obeys the umbrella discipline, a data race cannot occur, because parallel accesses are always protected by the same lock. The BRELLY algorithm detects violations of the umbrella locking discipline. Savage et al. <ref> [32] </ref> originally suggested that efficient debugging tools can be developed by requiring programs to obey a locking discipline. Their Eraser tool enforces a simple discipline in which any shared variable is protected by a single lock throughout the course of the program execution.
Reference: [33] <author> Robert Endre Tarjan. </author> <title> Applications of path compression on balanced trees. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 26(4):690715, </volume> <month> October </month> <year> 1979. </year> <month> 12 </month>
Reference-contexts: This execution order mirrors that of normal C programs: every subcomputation that is spawned executes completely before the procedure that spawned it continues. While executing the program, SP-BAGS maintains an SP-bags data structure based on Tarjan's nearly linear-time least-common-ancestors algorithm <ref> [33] </ref>. The SP 2 The Nondeterminator-2 can still be used with programs for which this assumption does not hold, but the race detector prints a warning, and some races may be missed.
References-found: 33

