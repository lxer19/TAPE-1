URL: http://www.eecs.umich.edu/HPS/pub/bac_ics93.ps
Refering-URL: http://www.eecs.umich.edu/HPS/hps_branchpred.html
Root-URL: http://www.cs.umich.edu
Title: Increasing the Instruction Fetch Rate via Multiple Branch Prediction and a Branch Address Cache  
Author: Tse-Yu Yeh, Deborah T. Marr, Yale N. Patt 
Address: Ann Arbor, Michigan 48109  
Affiliation: Tokyo, Japan.  Department of Electrical Engineering and Computer Science The University of Michigan  
Date: 67 76, July 19 23, 1993,  
Note: The 7th ACM International Conference on Supercomputing pp.  
Abstract: High performance computer implementation today is increasingly directed toward parallelism in the hardware. Superscalar machines, where the hardware can issue more than one instruction each cycle, are being adopted by more implementations. As the trend toward wider issue rates continues, so too must the ability to fetch more instructions each cycle. Although compilers can improve the situation by increasing the size of basic blocks, hardware mechanisms to fetch multiple possibly non-consecutive basic blocks are also needed. Viable mechanisms for fetching multiple non-consecutive basic blocks have not been previously investigated. We present a mechanism for predicting multiple branches and fetching multiple non-consecutive basic blocks each cycle which is both viable and effective. We measured the effectiveness of the mechanism in terms of the IPC f, the number of instructions fetched per clock for a machine front-end. For one, two, and three basic blocks, the IPC f of integer benchmarks went from 3.0 to 4.2 and 4.9, respectively. For floating point benchmarks, the IPC f went from from 6.6 to 7.1 and 8.9. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.E. Smith, </author> <title> "A Study of Branch Prediction Strategies", </title> <booktitle> Proceedings of the 8th International Symposium on Computer Architecture, </booktitle> <month> (May </month> <year> 1981), </year> <month> pp.135-148. </month>
Reference: [2] <author> J. Lee and A. J. Smith, </author> <title> "Branch Prediction Strategies and Branch Target Buffer Design", </title> <booktitle> IEEE Computer, </booktitle> <month> (Jan. </month> <year> 1984), </year> <month> pp.6-22. </month>
Reference: [3] <author> R. Colwell, R. Nix, J. O'Donnell, D. Papworth, and P. Rodman, </author> <title> "A VLIW Architecture for a Trace Scheduling Compiler," </title> <booktitle> Proc of the 2nd Intl Conf on Architectural Support for Programming Languages and Operating Systems, </booktitle> <month> (Oct. </month> <year> 1987), </year> <pages> pp. 180-192. </pages>
Reference-contexts: The optimal solution may be to combine both. The first alternative is being researched and implemented in today's advanced compilers. One approach is to enlarge the basic block into traces <ref> [3] </ref> or into superblocks [11]. Another approach is to exploit predicate execution to schedule instruction execution along multiple execution paths [4].
Reference: [4] <author> B.R. Rau, D. Yen, W. Yen, and R. Towle, </author> <title> "The Cy-dra 5 Departmental Supercomputer Design Philosophies, Decisions, and Trade-offs," </title> <booktitle> IEEE Computer, </booktitle> <month> (Jan. </month> <year> 1989), </year> <pages> pp. 12-35. </pages>
Reference-contexts: The first alternative is being researched and implemented in today's advanced compilers. One approach is to enlarge the basic block into traces [3] or into superblocks [11]. Another approach is to exploit predicate execution to schedule instruction execution along multiple execution paths <ref> [4] </ref>. The disadvantage 0 of predicate execution is that execution bandwidth is wasted on instructions whose results are discarded, and instruction fetch bandwidth is wasted on instructions which will not be executed.
Reference: [5] <author> M. Butler, T-Y Yeh, Y.N. Patt, M. Alsup, H. Scales, and M. Shebanow, </author> <title> "Instruction Level Parallelism is Greater Than Two", </title> <booktitle> Proceedings of the 18th International Symposium on Computer Architecture, </booktitle> <month> (May </month> <year> 1991), </year> <pages> pp. 276-286. </pages>
Reference: [6] <author> T-Y Yeh and Y.N. Patt, </author> <title> "Two-Level Adaptive Branch Prediction", </title> <booktitle> The 24th ACM/IEEE Intl Sym and Wk-shop on Microarchitecture , (Nov. </booktitle> <year> 1991), </year> <pages> pp. 51-61. </pages>
Reference-contexts: For floating point benchmarks, the improvement is 8% and 35%. This paper is organized in 6 sections. Section 2 summarizes some related work. Our multiple branch prediction algorithm is based on the Two-level Adaptive Branch Predictor <ref> [6, 7, 10] </ref>. The Two-level Adaptive i Branch Predictor achieves an average of 97% accuracy for a single branch prediction. Also, an instruction supply mechanism [9] to do back-to-back branch predictions and supply up to one basic block per instruction cache fetch is briefly reviewed. <p> Section 3.3 discusses the instruction cache design issues. Section 4 describes the simulation model, and the benchmarks used, and Section 5 shows our simulation results. Finally, Section 6 concludes the paper. 2 Related Work 2.1 Two-level Adaptive Branch Predictor Yeh and Patt <ref> [6, 7, 10] </ref> introduced several implementations of the Two-level Adaptive Branch Predictor, each with somewhat different cost vs. prediction accuracies. The average prediction accuracy on the SPEC89 benchmarks was shown to be 97 percent. <p> One important result was that each of the different Two-level Adaptive Branch Prediction schemes can achieve the same accuracy by varying its configuration. The following is a brief overview of a few schemes. The interested reader is referred to <ref> [6, 7, 10] </ref> for more details. The Two-level Adaptive Branch Predictor uses two structures, a Branch History Register (BHR) and a Pattern History Table (PHT), as shown in Figure 1. The Branch History Register is used to record the history of taken and not taken branches.
Reference: [7] <author> T-Y Yeh and Y.N. </author> <title> Patt "Alternative Implementations of Two-Level Adaptive Branch Prediction," </title> <booktitle> Proceedings of the 19th International Symposium on Computer Architecture, </booktitle> <month> (May </month> <year> 1992), </year> <pages> pp. 124-134. </pages>
Reference-contexts: For floating point benchmarks, the improvement is 8% and 35%. This paper is organized in 6 sections. Section 2 summarizes some related work. Our multiple branch prediction algorithm is based on the Two-level Adaptive Branch Predictor <ref> [6, 7, 10] </ref>. The Two-level Adaptive i Branch Predictor achieves an average of 97% accuracy for a single branch prediction. Also, an instruction supply mechanism [9] to do back-to-back branch predictions and supply up to one basic block per instruction cache fetch is briefly reviewed. <p> Section 3.3 discusses the instruction cache design issues. Section 4 describes the simulation model, and the benchmarks used, and Section 5 shows our simulation results. Finally, Section 6 concludes the paper. 2 Related Work 2.1 Two-level Adaptive Branch Predictor Yeh and Patt <ref> [6, 7, 10] </ref> introduced several implementations of the Two-level Adaptive Branch Predictor, each with somewhat different cost vs. prediction accuracies. The average prediction accuracy on the SPEC89 benchmarks was shown to be 97 percent. <p> One important result was that each of the different Two-level Adaptive Branch Prediction schemes can achieve the same accuracy by varying its configuration. The following is a brief overview of a few schemes. The interested reader is referred to <ref> [6, 7, 10] </ref> for more details. The Two-level Adaptive Branch Predictor uses two structures, a Branch History Register (BHR) and a Pattern History Table (PHT), as shown in Figure 1. The Branch History Register is used to record the history of taken and not taken branches. <p> Therefore the PHT has 2 k entries, each entry containing a 2-bit up-down saturating counter to record the execution history of the last several times the corresponding pattern occurred in the BHR. <ref> [7] </ref> showed that the 2-bit up-down saturating counter was sufficient in keeping pattern history to give highly accurate branch predictions. Prediction decision logic interprets the two pattern history bits to make a branch prediction.
Reference: [8] <author> S-T Pan, K. So, and J.T. Rahmeh, </author> <title> "Improving the Accuracy of Dynamic Branch Prediction Using Branch Correlation," </title> <booktitle> Proceedings of the 5th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <month> (Oct. </month> <year> 1992), </year> <pages> pp. 76-84. </pages>
Reference-contexts: Based on the source of the first-level branch history, Two-level Adaptive Branch Prediction has three classes of variations: global history schemes, per-address history schemes, and per-set history schemes. Global history schemes (also called Correlation Branch Prediction <ref> [8] </ref>) use a single Global BHR to record the history of all branches. The pattern in the Global BHR is used to index into the PHTs. The prediction of a conditional branch is influenced by the history of other branches.
Reference: [9] <author> T-Y Yeh and Y.N. </author> <title> Patt "A Comprehensive Instruction Fetch Mechanism for a Processor Supporting Speculative Execution," </title> <booktitle> Proc of the 25th International Symposium on Microarchitecture, </booktitle> <month> (Dec. </month> <year> 1992), </year> <pages> pp. 129-139. </pages>
Reference-contexts: Section 2 summarizes some related work. Our multiple branch prediction algorithm is based on the Two-level Adaptive Branch Predictor [6, 7, 10]. The Two-level Adaptive i Branch Predictor achieves an average of 97% accuracy for a single branch prediction. Also, an instruction supply mechanism <ref> [9] </ref> to do back-to-back branch predictions and supply up to one basic block per instruction cache fetch is briefly reviewed. Section 3 provides an overview of the multiple basic block supply mechanism. Section 3.1 describes the multiple branch prediction algorithm. <p> Per-set history schemes use one BHR to record the history of a set of adjacent static branches. The prediction of a conditional branch is influenced by the history of the branches in the same set, not just the branch itself. 2.2 Instruction Supply In <ref> [9] </ref> an instruction supply mechanism was introduced where up to one basic block per cycle can be fetched by predicting branch targets in back-to-back cycles. We summarize a few details of the mechanism in this section, but the interested reader is referred to [9] for more details. <p> the branch itself. 2.2 Instruction Supply In <ref> [9] </ref> an instruction supply mechanism was introduced where up to one basic block per cycle can be fetched by predicting branch targets in back-to-back cycles. We summarize a few details of the mechanism in this section, but the interested reader is referred to [9] for more details. We will use the term fetch address to be the address used to fetch a sequence of instructions from the instruction cache. Three things are done at the same time: the instruction cache access, the branch address cache access, and the branch path prediction. <p> The next instruction cache and branch address cache accesses begin on the next cycle. 3 Fetching Multiple Basic Blocks Each Cycle The performance of the mechanism described in <ref> [9] </ref> and summarized in Section 2.2 limited the fetch capacity to one basic block per cycle. Since only one branch path prediction and only one set of consecutive instructions could be fetched from the instruction cache per cycle, instruction fetch stopped when a branch was encountered.
Reference: [10] <author> T-Y Yeh and Y.N. </author> <title> Patt "A Comparison of Dynamic Branch Predictors that use Two Levels of Branch History," </title> <booktitle> Proceedings of the 20th International Symposium on Computer Architecture, </booktitle> <month> (May </month> <year> 1993). </year>
Reference-contexts: For floating point benchmarks, the improvement is 8% and 35%. This paper is organized in 6 sections. Section 2 summarizes some related work. Our multiple branch prediction algorithm is based on the Two-level Adaptive Branch Predictor <ref> [6, 7, 10] </ref>. The Two-level Adaptive i Branch Predictor achieves an average of 97% accuracy for a single branch prediction. Also, an instruction supply mechanism [9] to do back-to-back branch predictions and supply up to one basic block per instruction cache fetch is briefly reviewed. <p> Section 3.3 discusses the instruction cache design issues. Section 4 describes the simulation model, and the benchmarks used, and Section 5 shows our simulation results. Finally, Section 6 concludes the paper. 2 Related Work 2.1 Two-level Adaptive Branch Predictor Yeh and Patt <ref> [6, 7, 10] </ref> introduced several implementations of the Two-level Adaptive Branch Predictor, each with somewhat different cost vs. prediction accuracies. The average prediction accuracy on the SPEC89 benchmarks was shown to be 97 percent. <p> One important result was that each of the different Two-level Adaptive Branch Prediction schemes can achieve the same accuracy by varying its configuration. The following is a brief overview of a few schemes. The interested reader is referred to <ref> [6, 7, 10] </ref> for more details. The Two-level Adaptive Branch Predictor uses two structures, a Branch History Register (BHR) and a Pattern History Table (PHT), as shown in Figure 1. The Branch History Register is used to record the history of taken and not taken branches. <p> The multiple branch prediction algorithm introduced in this paper is modified from the global history schemes of Two-Level Adaptive Branch Prediction described in <ref> [10] </ref> and summarized in Section 2.1. The modified global history schemes not only make the prediction of the immediately following branch but also extrapolate the predictions of subsequent branches.
Reference: [11] <author> W. Hwu, S. Mahlke, W. Chen, P. Chang, N. Warter, R. Bringmann, R. Ouellete, R. Hank, T. Kiyohara, G. Haab, J. Holm, and D. Lavery, </author> <title> "The superblock: An effective technique for VLIW and superscalar compilation," </title> <journal> The Journal of Supercomputing, </journal> <month> January </month> <year> 1993. </year>
Reference-contexts: The optimal solution may be to combine both. The first alternative is being researched and implemented in today's advanced compilers. One approach is to enlarge the basic block into traces [3] or into superblocks <ref> [11] </ref>. Another approach is to exploit predicate execution to schedule instruction execution along multiple execution paths [4]. The disadvantage 0 of predicate execution is that execution bandwidth is wasted on instructions whose results are discarded, and instruction fetch bandwidth is wasted on instructions which will not be executed.
References-found: 11

