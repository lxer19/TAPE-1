URL: ftp://theory.lcs.mit.edu/pub/people/oded/test1.ps
Refering-URL: http://theory.lcs.mit.edu/~oded/test.html
Root-URL: 
Title: Property Testing and Its Connection to Learning and Approximation  
Author: Oded Goldreich Shafi Goldwasser Dana Ron 
Date: February 13, 1998  
Abstract: In this paper, we consider the question of determining whether a function f has property P or is *-far from any function with property P. A property testing algorithm is given a sample of the value of f on instances drawn according to some distribution. In some cases, it is also allowed to query f on instances of its choice. We study this question for different properties and establish some connections to problems in learning theory and approximation. In particular we focus our attention on testing graph properties. Given access to a graph G in the form of being able to query whether an edge exists or not between a pair of vertices, we devise algorithms to test whether the underlying graph has properties such as being bipartite, k-Colorable, or having a -Clique (clique of density with respect to the vertex set). Our graph property testing algorithms are probabilistic and make assertions that are correct with high probability, while making a number of queries that is independent of the size of the graph. Moreover, the property testing algorithms can be used to efficiently (i.e., in time linear in the number of vertices) construct partitions of the graph that correspond to the property being tested, if it holds for the input graph.
Abstract-found: 1
Intro-found: 1
Reference: [ADL + 94] <author> N. Alon, R. A. Duke, H. Lefmann, V. Rodl, and R. Yuster. </author> <title> The algorithmic aspects of the regularity lemma. </title> <journal> Journal of Algorithms, </journal> <volume> 16 </volume> <pages> 80-109, </pages> <year> 1994. </year>
Reference-contexts: We do not know whether the same is true with respect to the algorithms in [AKK95]. Results on testing graph properties can be derived also from <ref> [ADL + 94] </ref>. Relation to "dual approximation" (cf., [HS87, HS88]): To illustrate this relation, we consider the -Clique Tester mentioned above. <p> Edwards also gave a polynomial-time algorithm for k-coloring k-colorable N -vertex graphs of minimum degree at least ffN , for any constant ff &gt; k3 k2 . 5 As noted by Noga Alon, similar results, alas with much worse dependence on *, can be obtained by using the results of <ref> [ADL + 94] </ref>. 7 1.2.5 Our Techniques Our algorithms share some underlying ideas. The first is the uniform selection of a small sample of vertices and the search for a suitable partition of this sample. <p> This observation may explain how we can manage with a sample of size independent of the size of the graph. 1.3 Other related work Property testers implicit in previous works. As mentioned above, results on testing graph properties can be derived from <ref> [ADL + 94] </ref>. <p> In comparison with our k-Colorability Tester, which takes a sample of O (* 3 k 2 log k) vertices, the k-Colorability tester derived from <ref> [ADL + 94] </ref> takes a 8 much bigger sample of size equaling a tower of (k=*) 20 exponents (i.e., log fl Property Testing in the context of Program Checking: There is an immediate analogy between program self-testing [BLR93] and property-testing with queries. <p> The approach of Arora et. al. uses Linear Programming and Randomized Rounding, and applies to other problems which can be casted as a "smooth" Integer Programs. 6 The methods of de la Vega [dlV94] are purely combinatorial and apply also to similar graph partition problems. Following the approach of <ref> [ADL + 94] </ref>, but using a relaxation of the regularity Lemma (and thus obtaining much improved running times), Frieze and Kanan [FK96] devise PTAS for several graph partition problems such as Max-Cut and Bisection.
Reference: [AFK96] <author> S. Arora, A. Frieze, and H. Kaplan. </author> <title> A new rounding procedure for the assignment problem with applications to dense graph arrangement problems. </title> <booktitle> In Proceedings of the Thirty-Seventh Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1996. </year>
Reference-contexts: As usual, the choice of representation has a fundamental impact on the potential algorithm. 6 In <ref> [AFK96] </ref>, the approach of [AKK95] is extended to other problems, such as Graph Isomorphism, using a new rounding procedure for the Assignment Problem. 9 Here the impact is even more dramatic since we seek algorithms which only inspect a relatively small fraction of the object (graph represented by a function).
Reference: [AGHP92] <author> N. Alon, O. Goldreich, J. H-astad, and R. Peralta. </author> <title> Simple constructions of almost k-wise independent random variables. </title> <journal> Journal of Random structures and Algorithms, </journal> <volume> 3(3) </volume> <pages> 289-304, </pages> <year> 1992. </year>
Reference-contexts: This proposition subsumes Proposition 10.5. Proof: We adapt the proof of Proposition 10.5, by considering, for each N , all graphs which arise for particular "pseudorandom" sequences. Specifically, we consider N -long sequences taken from a 1 2 2 t -biased sample space (cf., [NN93] or <ref> [AGHP92] </ref>), where t def 100 N 2 . Efficiently constructible sample spaces of size (2 t N ) 5 having the above property can be found in [NN93, AGHP92]. <p> Specifically, we consider N -long sequences taken from a 1 2 2 t -biased sample space (cf., [NN93] or [AGHP92]), where t def 100 N 2 . Efficiently constructible sample spaces of size (2 t N ) 5 having the above property can be found in <ref> [NN93, AGHP92] </ref>.
Reference: [AKK95] <author> S. Arora, D. Karger, and M Karpinski. </author> <title> Polynomial time approximation schemes for dense instances of NP-hard problems. </title> <booktitle> In Proceedings of the Twenty-Seventh Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 284-293, </pages> <year> 1995. </year>
Reference-contexts: any constant * &gt; 0, using the abovementioned tester we can approximate the size of the max-cut to within *N 2 in constant time. 4 This yields a constant time approximation scheme (i.e., to within any constant relative error) for dense graphs, improving over previous work of Arora et. al. <ref> [AKK95] </ref> 4 We comment that due to the specific structure of our tester, the value of the maximum cut is actually approximated in time T (; *; N )poly (1=*), rather than 1 * T (; *; N ). and de la Vega [dlV94] who solved this problem in polynomial-time (i.e., <p> In several cases this is possible. For example, using some ideas of this work, the Max-CUT algorithm of [dlV94] can be transformed into a tester of complexity comparable to ours. We do not know whether the same is true with respect to the algorithms in <ref> [AKK95] </ref>. Results on testing graph properties can be derived also from [ADL + 94]. Relation to "dual approximation" (cf., [HS87, HS88]): To illustrate this relation, we consider the -Clique Tester mentioned above. <p> In case of k-Colorability certain k-Colorings of the subgraph induced by this sample will do, and are found by k-Coloring a slightly augmented graph. In case of the other algorithms we exhaustively try all possible partitions. This is reminiscent of the exhaustive sampling iof <ref> [AKK95] </ref>, except that the partitions considered by us are always directly related to the combinatorial structure of the problem. We show how each possible partition of the sample induces a partition of the entire graph so that the following holds. <p> A different variant of the problem was considered by Yamanishi [Yam95]. Approximation in Dense Graphs. As stated previously, <ref> [AKK95] </ref> and [dlV94] presented polynomial-time approximation schemes (PTAS) for dense instances of Max-Cut. <p> Like de la Vega, our methods use elementary combinatorial arguments related to the problem at hand. Still our methods suffice for dealing with the General Graph Partition Problem. We note that <ref> [AKK95] </ref> showed that the "dense subgraph" problem, a generalization of -Clique, has a PTAS for dense instances. <p> As usual, the choice of representation has a fundamental impact on the potential algorithm. 6 In [AFK96], the approach of <ref> [AKK95] </ref> is extended to other problems, such as Graph Isomorphism, using a new rounding procedure for the Assignment Problem. 9 Here the impact is even more dramatic since we seek algorithms which only inspect a relatively small fraction of the object (graph represented by a function).
Reference: [ALM + 92] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. </author> <title> Proof verification and intractability of approximation problems. </title> <booktitle> In Proceedings of the Thirty-Third Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 14-23, </pages> <year> 1992. </year>
Reference-contexts: In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [BFLS91], has shifted from testing codes defined by low-degree polynomials <ref> [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] </ref> to testing Hadamard codes [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97], and recently to testing the "long code" [BGS95, H-as96b, H-as97, Tre97]. <p> In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [BFLS91], has shifted from testing codes defined by low-degree polynomials [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] to testing Hadamard codes <ref> [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97] </ref>, and recently to testing the "long code" [BGS95, H-as96b, H-as97, Tre97]. All the above has focused on property testing in the sense of [RS96], and on testing algebraic properties such as linearity, multi-linearity and being a low-degree polynomial.
Reference: [Ang78] <author> D. Angluin. </author> <title> On the complexity of minimum inference of regular sets. </title> <journal> Information and Control, </journal> <volume> 39 </volume> <pages> 337-350, </pages> <year> 1978. </year>
Reference-contexts: Proposition 3.3 If N P 6 BP P then there exist function classes which are not poly (n=*)-time testable but are poly (n=*)-time (non-properly) learnable. Proof: The proposition follows from the fact that many of the representation dependent hardness results (cf. <ref> [Gol78, Ang78, PV88, BR89, PW93] </ref>) have roughly the following form.
Reference: [AS92] <author> S. Arora and S. Safra. </author> <title> Probabilistic checkable proofs: A new characterization of NP. </title> <booktitle> In Proceedings of the Thirty-Third Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 1-13, </pages> <year> 1992. </year>
Reference-contexts: In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [BFLS91], has shifted from testing codes defined by low-degree polynomials <ref> [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] </ref> to testing Hadamard codes [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97], and recently to testing the "long code" [BGS95, H-as96b, H-as97, Tre97].
Reference: [BCH + 95] <author> M. Bellare, D. Coppersmith, J. H-astad, M. Kiwi, and M. Sudan. </author> <title> Linearity testing in characteristic two. </title> <booktitle> In Proceedings of the Thirty-Sixth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 432-441, </pages> <year> 1995. </year>
Reference-contexts: In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [BFLS91], has shifted from testing codes defined by low-degree polynomials [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] to testing Hadamard codes <ref> [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97] </ref>, and recently to testing the "long code" [BGS95, H-as96b, H-as97, Tre97]. All the above has focused on property testing in the sense of [RS96], and on testing algebraic properties such as linearity, multi-linearity and being a low-degree polynomial. <p> Let the class of parity functions, PAR = fP AR n g, where PAR n def that f S (x) = P i2S x i mod 2. Work on linearity testing [BLR93, BFL91, FGL + 91, BGLR93, BS94], culminating in the result of Bellare et al. <ref> [BCH + 95] </ref>, implies that there exists a testing algorithm for the class P AR, under the uniform distribution, whose query complexity is O (* 1 log (1=ffi)). The running-time is a factor n bigger, merely needed to write down the queries.
Reference: [BD92] <author> S. </author> <title> Ben-David. </title> <booktitle> Can finite samples detect singularities of real-valued functions? In Proceedings of the Twenty-Fourth Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 390-399, </pages> <year> 1992. </year>
Reference-contexts: Rubinfeld [Rub94] focuses on property testing as applied to properties which take the form of functional equations of various types. Property Testing in the context of Learning Theory: Departing from work in Statistics regarding the classification of distributions (e.g., [HW58, Cov73, ZK91]), Ben-David <ref> [BD92] </ref> and Kularni and Zeitouni [KZ93] considered the problem of classifying an unknown function into one of two classes of functions, given labeled examples. Ben-David studied this classification problem in the limit (of the number of examples), and Kulkarni and Zeitouni studied it in a PAC inspired model.
Reference: [BEHW89] <author> A. Blumer, A. Ehrenfeucht, D. Haussler, and M. K. Warmuth. </author> <title> Learnability and the Vapnik-Chervonenkis dimension. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 36(4) </volume> <pages> 929-965, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: In particular, the above proposition implies that if for every n, F n has polynomial (in n) VC-dimension <ref> [VC71, BEHW89] </ref> 9 , then F has a tester whose sample complexity is polynomial in n, 1=*, and log (1=ffi). The reason is that classes with polynomial VC-dimension can be properly learned from a sample of the above size [BEHW89]. <p> The reason is that classes with polynomial VC-dimension can be properly learned from a sample of the above size <ref> [BEHW89] </ref>. However, the running time of such a proper learning algorithm, and hence of the resulting testing algorithm might be exponential in n. Corollary 3.2 Every class that is learnable with constant confidence using a sample of size poly (n=*) (and thus has a poly (n) VC dimension [BEHW89]), is testable <p> above size <ref> [BEHW89] </ref>. However, the running time of such a proper learning algorithm, and hence of the resulting testing algorithm might be exponential in n. Corollary 3.2 Every class that is learnable with constant confidence using a sample of size poly (n=*) (and thus has a poly (n) VC dimension [BEHW89]), is testable with a poly (n=*) log (1=ffi) sample (in at most exponential time). Testing may be Harder than Learning. <p> On the other hand, the VC-dimension of F n is 2 n1 (since the set f0y : y 2 f0; 1g n1 g is shattered by F n ). By <ref> [BEHW89] </ref>, learning this class requires a sample of size (2 n ). The impossibility of learning the function class in Proposition 3.4 is due to its exponential VC-dimension, (i.e., it is a pure information theoretic consideration). We now turn to function classes of exponential (rather than double exponential) size.
Reference: [BFL91] <author> L. Babai, L. Fortnow, and C. Lund. </author> <title> Non-deterministic exponential time has two-prover interactive protocols. </title> <journal> Computational Complexity, </journal> <volume> 1(1) </volume> <pages> 3-40, </pages> <year> 1991. </year>
Reference-contexts: In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [BFLS91], has shifted from testing codes defined by low-degree polynomials <ref> [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] </ref> to testing Hadamard codes [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97], and recently to testing the "long code" [BGS95, H-as96b, H-as97, Tre97]. <p> Learning and Testing with queries (under the uniform distribution). Let the class of parity functions, PAR = fP AR n g, where PAR n def that f S (x) = P i2S x i mod 2. Work on linearity testing <ref> [BLR93, BFL91, FGL + 91, BGLR93, BS94] </ref>, culminating in the result of Bellare et al. [BCH + 95], implies that there exists a testing algorithm for the class P AR, under the uniform distribution, whose query complexity is O (* 1 log (1=ffi)). <p> Specifically, let P OLY = fP OLY n g, where POLY n consists of n-variate polynomials of total degree n over the field GF (q), where q is the first prime in the interval [n 4 ; 2n 4 ]. Work on low-degree testing <ref> [BFL91, BFLS91, GLR + 91] </ref>, culminating in the result of Rubinfeld and Sudan [RS96]. implies that there exists a testing algorithm for the class P OLY , under the uniform distribution, whose query complexity is O (minfn 3 ; n * g log (1=ffi)).
Reference: [BFLS91] <author> L. Babai, L. Fortnow, L. Levin, and M. Szegedy. </author> <title> Checking computations in polyloga-rithmic time. </title> <booktitle> In Proceedings of the Twenty-Third Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 21-31, </pages> <year> 1991. </year>
Reference-contexts: In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in <ref> [BFLS91] </ref>, has shifted from testing codes defined by low-degree polynomials [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] to testing Hadamard codes [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97], and recently to testing the "long code" [BGS95, H-as96b, H-as97, Tre97]. <p> In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [BFLS91], has shifted from testing codes defined by low-degree polynomials <ref> [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] </ref> to testing Hadamard codes [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97], and recently to testing the "long code" [BGS95, H-as96b, H-as97, Tre97]. <p> Specifically, let P OLY = fP OLY n g, where POLY n consists of n-variate polynomials of total degree n over the field GF (q), where q is the first prime in the interval [n 4 ; 2n 4 ]. Work on low-degree testing <ref> [BFL91, BFLS91, GLR + 91] </ref>, culminating in the result of Rubinfeld and Sudan [RS96]. implies that there exists a testing algorithm for the class P OLY , under the uniform distribution, whose query complexity is O (minfn 3 ; n * g log (1=ffi)).
Reference: [BGLR93] <author> M. Bellare, S. Goldwasser, C. Lund, and A. Russell. </author> <title> Efficient probabilistically checkable proofs and applications to approximation. </title> <booktitle> In Proceedings of the Twenty-Fifth Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 294-304, </pages> <year> 1993. </year> <month> 84 </month>
Reference-contexts: In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [BFLS91], has shifted from testing codes defined by low-degree polynomials [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] to testing Hadamard codes <ref> [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97] </ref>, and recently to testing the "long code" [BGS95, H-as96b, H-as97, Tre97]. All the above has focused on property testing in the sense of [RS96], and on testing algebraic properties such as linearity, multi-linearity and being a low-degree polynomial. <p> Learning and Testing with queries (under the uniform distribution). Let the class of parity functions, PAR = fP AR n g, where PAR n def that f S (x) = P i2S x i mod 2. Work on linearity testing <ref> [BLR93, BFL91, FGL + 91, BGLR93, BS94] </ref>, culminating in the result of Bellare et al. [BCH + 95], implies that there exists a testing algorithm for the class P AR, under the uniform distribution, whose query complexity is O (* 1 log (1=ffi)).
Reference: [BGS95] <author> M. Bellare, O. Goldreich, and M. Sudan. </author> <title> Free bits, pcps and non-approximability - towards tight results. </title> <booktitle> In Proceedings of the Thirty-Sixth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 422-431, </pages> <year> 1995. </year> <note> Full version available from ECCC, http://www.eccc.uni-trier.de/eccc/. </note>
Reference-contexts: This paradigm, explicitly introduced in [BFLS91], has shifted from testing codes defined by low-degree polynomials [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] to testing Hadamard codes [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97], and recently to testing the "long code" <ref> [BGS95, H-as96b, H-as97, Tre97] </ref>. All the above has focused on property testing in the sense of [RS96], and on testing algebraic properties such as linearity, multi-linearity and being a low-degree polynomial. In this work we extend the scope of property testing in two ways: 1. <p> To demonstrate that these two tasks are vastly different we mention that whereas the former task is NP-Hard, for &lt; 1=4 (see <ref> [BGS95, H-as96b, H-as96a] </ref>), the latter task can be solved in exp (O (1=* 2 ))-time, for any ; * &gt; 0.
Reference: [BLR93] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Self-testing/correcting with applications to numerical problems. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 47 </volume> <pages> 549-595, </pages> <year> 1993. </year>
Reference-contexts: E-mail: shafi@theory.lcs.mit.edu. z Laboratory for Computer Science, MIT, 545 Technology Sq., Cambridge, MA 02139. E-mail: danar@theory.lcs.mit.edu. Supported by an NSF postdoctoral fellowship. 1 the program satisfies certain properties before checking that it computes a specified function. This paradigm has been followed both in the theory of program checking <ref> [BLR93, RS96] </ref>, and in practice where often programmers first test their programs by verifying that the programs satisfy properties that are known to be satisfied by the function they compute. In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. <p> O (* 3 k 2 log k) vertices, the k-Colorability tester derived from [ADL + 94] takes a 8 much bigger sample of size equaling a tower of (k=*) 20 exponents (i.e., log fl Property Testing in the context of Program Checking: There is an immediate analogy between program self-testing <ref> [BLR93] </ref> and property-testing with queries. The difference is that in self-testing, a function f (represented by a program) is tested for being close to a fully specified function g, whereas in property-testing the test is whether f is close to any function in a function class G. <p> The difference is that in self-testing, a function f (represented by a program) is tested for being close to a fully specified function g, whereas in property-testing the test is whether f is close to any function in a function class G. Interestingly, many self-testers <ref> [BLR93, RS96] </ref> work by first testing that the program satisfies some properties which the function it is supposed to compute satisfies (and only then checking that the program satisfies certain constraints specific to the function). <p> Learning and Testing with queries (under the uniform distribution). Let the class of parity functions, PAR = fP AR n g, where PAR n def that f S (x) = P i2S x i mod 2. Work on linearity testing <ref> [BLR93, BFL91, FGL + 91, BGLR93, BS94] </ref>, culminating in the result of Bellare et al. [BCH + 95], implies that there exists a testing algorithm for the class P AR, under the uniform distribution, whose query complexity is O (* 1 log (1=ffi)).
Reference: [BR89] <author> A. Blum and R. Rivest. </author> <title> Training a 3-node neural network is NP-complete. </title> <booktitle> In Advances in Neural Information Processing Systems I, </booktitle> <pages> pages 494-501, </pages> <year> 1989. </year>
Reference-contexts: In contrast to Proposition 3.1 and to Corollary 3.2, we show that there are classes which are efficiently learnable (though not by a proper learning algorithm) but are not efficiently testable. This is proven by observing that many hardness results for proper learning (cf. <ref> [PV88, BR89, PW93] </ref>) actually establish the hardness of testing (for the same classes). Furthermore, we believe that it is more natural to view these hardness results as referring to testing and derive the hardness for proper learning via Proposition 3.1. <p> Proposition 3.3 If N P 6 BP P then there exist function classes which are not poly (n=*)-time testable but are poly (n=*)-time (non-properly) learnable. Proof: The proposition follows from the fact that many of the representation dependent hardness results (cf. <ref> [Gol78, Ang78, PV88, BR89, PW93] </ref>) have roughly the following form.
Reference: [BS94] <author> M. Bellare and M. Sudan. </author> <title> Improved non-approximability results. </title> <booktitle> In Proceedings of the Twenty-Sixth Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 184-193, </pages> <year> 1994. </year>
Reference-contexts: In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [BFLS91], has shifted from testing codes defined by low-degree polynomials [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] to testing Hadamard codes <ref> [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97] </ref>, and recently to testing the "long code" [BGS95, H-as96b, H-as97, Tre97]. All the above has focused on property testing in the sense of [RS96], and on testing algebraic properties such as linearity, multi-linearity and being a low-degree polynomial. <p> Learning and Testing with queries (under the uniform distribution). Let the class of parity functions, PAR = fP AR n g, where PAR n def that f S (x) = P i2S x i mod 2. Work on linearity testing <ref> [BLR93, BFL91, FGL + 91, BGLR93, BS94] </ref>, culminating in the result of Bellare et al. [BCH + 95], implies that there exists a testing algorithm for the class P AR, under the uniform distribution, whose query complexity is O (* 1 log (1=ffi)).
Reference: [CFGN96] <author> R. Canetti, U. Feige, O. Goldreich, and M. Naor. </author> <title> Adaptively secure multi-party computation. </title> <type> Technical Report TR-682, </type> <institution> LCS/MIT, </institution> <year> 1996. </year> <note> Extended abstract in 28th STOC, pp. 639-648, </note> <year> 1996. </year>
Reference-contexts: The weak trapdoor condition is a relaxation of the standard condition which requires also that one can efficiently generate (ff,trapdoor)-pairs. The dense domain condition is indeed non-standard, but does hold for all popular candidates (e.g., RSA and Rabin functions). See discussion in <ref> [CFGN96] </ref>. Another non-standard aspect of the definition is associating a permutation with each string, whereas the standard definition associates permutations only with a subset of all strings. <p> Furthermore, the functions can be computed by poly (n)-size circuits. Proof: By <ref> [CFGN96] </ref>, any collection of trapdoor one-way permutations with dense domains can be converted into a collection trapdoor one-way permutations where the domain of each p ff is f0; 1g jffj . <p> Assuming that f is *-far from OW n , with respect to some distribution D, we wish to show that f is rejected by the test with high probability. We consider two cases. 10 One way of doing so proceeds in two steps, and is analogous to the <ref> [CFGN96] </ref> transformation mentioned subsequently. First one introduces dummy permutations for each string that is not associated with a permutation in the original construction. This may weaken the one-way property but still some "one-wayness" remains.
Reference: [Cov73] <author> T. M. </author> <title> Cover. On determining the rationality of the mean of a random variable. </title> <journal> Annals of Statistics, </journal> <volume> 1 </volume> <pages> 862-871, </pages> <year> 1973. </year>
Reference-contexts: Rubinfeld [Rub94] focuses on property testing as applied to properties which take the form of functional equations of various types. Property Testing in the context of Learning Theory: Departing from work in Statistics regarding the classification of distributions (e.g., <ref> [HW58, Cov73, ZK91] </ref>), Ben-David [BD92] and Kularni and Zeitouni [KZ93] considered the problem of classifying an unknown function into one of two classes of functions, given labeled examples.
Reference: [dlV94] <author> W. F. de la Vega. </author> <title> MAX-CUT has a randomized approximation scheme in dense graphs. </title> <note> To appear in Random Structures and Algorithms , 1994. </note>
Reference-contexts: over previous work of Arora et. al. [AKK95] 4 We comment that due to the specific structure of our tester, the value of the maximum cut is actually approximated in time T (; *; N )poly (1=*), rather than 1 * T (; *; N ). and de la Vega <ref> [dlV94] </ref> who solved this problem in polynomial-time (i.e., in O (N 1=* 2 )-time and exp ( e O (1=* 2 )) N 2 -time, respectively). In the latter works the problem is solved by actually constructing approximate max-cuts. <p> One can turn the question around and ask whether approximation algorithms for dense instances can be transformed into corresponding testers as defined above. In several cases this is possible. For example, using some ideas of this work, the Max-CUT algorithm of <ref> [dlV94] </ref> can be transformed into a tester of complexity comparable to ours. We do not know whether the same is true with respect to the algorithms in [AKK95]. Results on testing graph properties can be derived also from [ADL + 94]. <p> A different variant of the problem was considered by Yamanishi [Yam95]. Approximation in Dense Graphs. As stated previously, [AKK95] and <ref> [dlV94] </ref> presented polynomial-time approximation schemes (PTAS) for dense instances of Max-Cut. The approach of Arora et. al. uses Linear Programming and Randomized Rounding, and applies to other problems which can be casted as a "smooth" Integer Programs. 6 The methods of de la Vega [dlV94] are purely combinatorial and apply also <p> As stated previously, [AKK95] and <ref> [dlV94] </ref> presented polynomial-time approximation schemes (PTAS) for dense instances of Max-Cut. The approach of Arora et. al. uses Linear Programming and Randomized Rounding, and applies to other problems which can be casted as a "smooth" Integer Programs. 6 The methods of de la Vega [dlV94] are purely combinatorial and apply also to similar graph partition problems. Following the approach of [ADL + 94], but using a relaxation of the regularity Lemma (and thus obtaining much improved running times), Frieze and Kanan [FK96] devise PTAS for several graph partition problems such as Max-Cut and Bisection.
Reference: [Edw86] <author> K. Edwards. </author> <title> The complexity of colouring problems on dense graphs. </title> <journal> Theoretical Computer Science, </journal> <volume> 43 </volume> <pages> 337-343, </pages> <year> 1986. </year>
Reference-contexts: Furthermore, deciding k-Colorability even for N -vertex graphs of minimum degree at least k3 k2 N is NP-complete (cf., <ref> [Edw86] </ref>).
Reference: [EKK + 98] <author> F. Ergun, S. Kannan, S. R. Kumar, R. Rubinfeld, and M. Viswanathan. Spot-checkers. </author> <booktitle> In Proceedings of the Thirtieth Annual ACM Symposium on the Theory of Computing, </booktitle> <year> 1998. </year>
Reference-contexts: In recent work, Kearns and Ron [KR98] generalize our definition of property testing, and present testing algorithms that use only random examples for classes of functions that have been studied in the learning literature. We also mention the work of Ergun et al. <ref> [EKK + 98] </ref>, in which they propose the study of Spot Checker , which in some contexts coincides with property testing. 1.5 Organization The paper is organized in two parts. The first part focuses on property testing in general: A definition is given and discussed in Section 2.
Reference: [FGL + 91] <author> U. Feige, S. Goldwasser, L. Lovasz, S. Safra, and M. Szegedy. </author> <title> Approximating clique is almost NP-complete. </title> <booktitle> In Proceedings of the Thirty-Second Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 2-12, </pages> <year> 1991. </year>
Reference-contexts: In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [BFLS91], has shifted from testing codes defined by low-degree polynomials <ref> [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] </ref> to testing Hadamard codes [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97], and recently to testing the "long code" [BGS95, H-as96b, H-as97, Tre97]. <p> Learning and Testing with queries (under the uniform distribution). Let the class of parity functions, PAR = fP AR n g, where PAR n def that f S (x) = P i2S x i mod 2. Work on linearity testing <ref> [BLR93, BFL91, FGL + 91, BGLR93, BS94] </ref>, culminating in the result of Bellare et al. [BCH + 95], implies that there exists a testing algorithm for the class P AR, under the uniform distribution, whose query complexity is O (* 1 log (1=ffi)).
Reference: [FK96] <author> A. Frieze and R. Kanan. </author> <title> The regularity lemma and approximation schemes for dense problems. </title> <booktitle> In Proceedings of the Thirty-Seventh Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1996. </year>
Reference-contexts: Following the approach of [ADL + 94], but using a relaxation of the regularity Lemma (and thus obtaining much improved running times), Frieze and Kanan <ref> [FK96] </ref> devise PTAS for several graph partition problems such as Max-Cut and Bisection. We note that compared to all the above results, our respective graph partitioning algorithms have better running-times (not to mention that we obtain constant-time approximation schemes for approximating only the value of the partition).
Reference: [GLR + 91] <author> P. Gemmell, R. Lipton, R. Rubinfeld, M. Sudan, and A. Wigderson. </author> <title> Self-testing/correcting for polynomials and for approximate functions. </title> <booktitle> In Proceedings of the Twenty-Third Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 32-42, </pages> <year> 1991. </year>
Reference-contexts: Specifically, let P OLY = fP OLY n g, where POLY n consists of n-variate polynomials of total degree n over the field GF (q), where q is the first prime in the interval [n 4 ; 2n 4 ]. Work on low-degree testing <ref> [BFL91, BFLS91, GLR + 91] </ref>, culminating in the result of Rubinfeld and Sudan [RS96]. implies that there exists a testing algorithm for the class P OLY , under the uniform distribution, whose query complexity is O (minfn 3 ; n * g log (1=ffi)).
Reference: [GLS88] <author> M. Grotschel, L. Lovasz, and A. Schrijver. </author> <title> Geometric Algorithms and Combinatorial Optimization. </title> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference: [Gol78] <author> M. E. Gold. </author> <title> Complexity of automaton identification from given data. </title> <journal> Information and Control, </journal> <volume> 37 </volume> <pages> 302-320, </pages> <year> 1978. </year>
Reference-contexts: Proposition 3.3 If N P 6 BP P then there exist function classes which are not poly (n=*)-time testable but are poly (n=*)-time (non-properly) learnable. Proof: The proposition follows from the fact that many of the representation dependent hardness results (cf. <ref> [Gol78, Ang78, PV88, BR89, PW93] </ref>) have roughly the following form.
Reference: [Gol95] <author> O. Goldreich. </author> <title> Foundations of Cryptography Fragments of a Book. </title> <note> Available from ECCC , http://www.eccc.uni-trier.de/eccc/, 1995. 85 </note>
Reference-contexts: We present a function class that is easy to test but cannot be learned in polynomial-time (even under the uniform distribution), provided certain trapdoor one-way permutations exist (e.g., factoring is intractable). We start by defining this assumption, which in some sense is weaker than the standard one (cf., <ref> [Gol95, Sec. 2.4] </ref>). (We comment that the standard term "trapdoor permutation" is somewhat misleading since what is being defined is a collection of permutations.) 14 Definition 3.5 (weak trapdoor permutations with dense domains): Let fp ff : D ff 7! D ff g ff2f0;1g fl be a family of permutations.
Reference: [GR97a] <author> O. Goldreich and D. Ron. </author> <title> Property testing in bounded degree graphs. </title> <booktitle> In Proceedings of the Twenty-Ninth Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 406-415, </pages> <year> 1997. </year>
Reference-contexts: Secondly, the above adjacency predicate representation is most appropriate for dense graphs, and so the reader may think of the graph as being dense (e.g., having at least *N 2 edges). An alternative representation, appropriate for bounded-degree graphs, has been subsequently considered in <ref> [GR97a] </ref>. 1.2.3 Our Algorithms We present algorithms of poly (1=*) query-complexity and running-time 3 at most exp ( e O (1=* 3 )) for testing the following natural graph properties: k-Colorability for any fixed k 2. (Here the query-complexity is poly (k=*), and for k = 2 the running-time is e <p> Our General Graph Partition algorithm (with the appropriate setting of the parameters) improves on their result. 1.4 Subsequent work As mentioned above, our representation of graphs by their adjacency predicate is most adequate for dense graphs. Another natural representation, most adequate for bounded-degree graphs was subsequently suggested in <ref> [GR97a] </ref>: An N -vertex graph of degree bound d is represented there by the incidence function, g : Vfi [d] 7! V [ f0g, so that g (u; i) = v if v is the i th vertex incident at u, and g (u; i) = 0 62 V if u <p> In particular, distance * in the adjacency predicate representation (adopted in this paper) means a symmetric difference of 2* N 2 edges, whereas in the incident function representation (of <ref> [GR97a] </ref>) this means a symmetric difference of 2* dN edges. (In both cases, the extra factor 2 is due to the redundant representation which is adopted for sake of simplicity.) In contrast to our poly (1=*)-query Bipartite tester (for the adjacency predicate representation), it was proven in [GR97a] that testing Bipartiteness <p> function representation (of <ref> [GR97a] </ref>) this means a symmetric difference of 2* dN edges. (In both cases, the extra factor 2 is due to the redundant representation which is adopted for sake of simplicity.) In contrast to our poly (1=*)-query Bipartite tester (for the adjacency predicate representation), it was proven in [GR97a] that testing Bipartiteness in the incident function representation requires ( p N ) queries. <p> Interestingly, this bound is tight up to a polylogarithmic factor, as shown in [GR97b] which presents a Bipartite tester for the incident function representation working in time O (poly (* 1 log N ) p N). We mention that <ref> [GR97a] </ref> also presents poly (1=*)-time algorithms for testing k-Connectivity, for k 1, Planarity and other properties (all in the incident function representation).
Reference: [GR97b] <author> O. Goldreich and D. Ron. </author> <title> A sublinear bipartite tester for bounded degree graphs. </title> <type> Manuscript, </type> <year> 1997. </year>
Reference-contexts: Interestingly, this bound is tight up to a polylogarithmic factor, as shown in <ref> [GR97b] </ref> which presents a Bipartite tester for the incident function representation working in time O (poly (* 1 log N ) p N). We mention that [GR97a] also presents poly (1=*)-time algorithms for testing k-Connectivity, for k 1, Planarity and other properties (all in the incident function representation).
Reference: [Haj91] <author> P. Hajnal. </author> <title> An (n 4=3 ) lower bound on the randomized complexity of graph properties. </title> <journal> Combinatorica, </journal> <volume> 11(2) </volume> <pages> 131-144, </pages> <year> 1991. </year>
Reference-contexts: The query complexity of randomized decision procedures was conjectured by Yao to be also (N 2 ). Progress towards proving this conjecture was made in [Yao87], [Kin91] and <ref> [Haj91] </ref> culminating in an (N 4=3 ) lower bound. This stands in striking contrast to the results mentioned above, by which some nontrivial monotone graph properties can be tested by examining a constant number of locations in the matrix.
Reference: [H-as96a] <editor> J. H-astad. </editor> <booktitle> Clique is hard to approximate within n 1* . In Proceedings of the Thirty-Seventh Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 627-636, </pages> <year> 1996. </year>
Reference-contexts: To demonstrate that these two tasks are vastly different we mention that whereas the former task is NP-Hard, for &lt; 1=4 (see <ref> [BGS95, H-as96b, H-as96a] </ref>), the latter task can be solved in exp (O (1=* 2 ))-time, for any ; * &gt; 0.
Reference: [H-as96b] <author> J. H-astad. </author> <title> Testing of the long code and hardness for clique. </title> <booktitle> In Proceedings of the Twenty-Eighth Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 11-19, </pages> <year> 1996. </year>
Reference-contexts: This paradigm, explicitly introduced in [BFLS91], has shifted from testing codes defined by low-degree polynomials [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] to testing Hadamard codes [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97], and recently to testing the "long code" <ref> [BGS95, H-as96b, H-as97, Tre97] </ref>. All the above has focused on property testing in the sense of [RS96], and on testing algebraic properties such as linearity, multi-linearity and being a low-degree polynomial. In this work we extend the scope of property testing in two ways: 1. <p> To demonstrate that these two tasks are vastly different we mention that whereas the former task is NP-Hard, for &lt; 1=4 (see <ref> [BGS95, H-as96b, H-as96a] </ref>), the latter task can be solved in exp (O (1=* 2 ))-time, for any ; * &gt; 0.
Reference: [H-as97] <author> J. H-astad. </author> <title> Getting optimal in-approximability results. </title> <booktitle> In Proceedings of the Twenty-Ninth Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 1-10, </pages> <year> 1997. </year>
Reference-contexts: This paradigm, explicitly introduced in [BFLS91], has shifted from testing codes defined by low-degree polynomials [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] to testing Hadamard codes [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97], and recently to testing the "long code" <ref> [BGS95, H-as96b, H-as97, Tre97] </ref>. All the above has focused on property testing in the sense of [RS96], and on testing algebraic properties such as linearity, multi-linearity and being a low-degree polynomial. In this work we extend the scope of property testing in two ways: 1.
Reference: [HS87] <author> D. S. Hochbaum and D. B. Shmoys. </author> <title> Using dual approximation algorithms for scheduling problems: Theoretical and practical results. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 34(1) </volume> <pages> 144-162, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: We do not know whether the same is true with respect to the algorithms in [AKK95]. Results on testing graph properties can be derived also from [ADL + 94]. Relation to "dual approximation" (cf., <ref> [HS87, HS88] </ref>): To illustrate this relation, we consider the -Clique Tester mentioned above. The traditional notion of approximating Max-Clique corresponds to distinguishing the case in which the max-clique has size at least N from, say, the case in which the max-clique has size at most N=2.
Reference: [HS88] <author> D. S. Hochbaum and D. B. Shmoys. </author> <title> A polynomial approximation scheme for machine scheduling on uniform processors: Using the dual approximation approach. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17(3) </volume> <pages> 539-551, </pages> <year> 1988. </year>
Reference-contexts: We do not know whether the same is true with respect to the algorithms in [AKK95]. Results on testing graph properties can be derived also from [ADL + 94]. Relation to "dual approximation" (cf., <ref> [HS87, HS88] </ref>): To illustrate this relation, we consider the -Clique Tester mentioned above. The traditional notion of approximating Max-Clique corresponds to distinguishing the case in which the max-clique has size at least N from, say, the case in which the max-clique has size at most N=2.
Reference: [HW58] <author> W. Hoeffding and J. Wolfowitz. </author> <title> Distinguishability of sets of distributions. </title> <journal> Annals of Mathematical Statistics, </journal> <volume> 29 </volume> <pages> 700-718, </pages> <year> 1958. </year>
Reference-contexts: Rubinfeld [Rub94] focuses on property testing as applied to properties which take the form of functional equations of various types. Property Testing in the context of Learning Theory: Departing from work in Statistics regarding the classification of distributions (e.g., <ref> [HW58, Cov73, ZK91] </ref>), Ben-David [BD92] and Kularni and Zeitouni [KZ93] considered the problem of classifying an unknown function into one of two classes of functions, given labeled examples.
Reference: [Kin91] <author> V. King. </author> <title> An (n 5=4 ) lower bound on the randomized complexity of graph properties. </title> <journal> Combinatorica, </journal> <volume> 11(1) </volume> <pages> 23-32, </pages> <year> 1991. </year>
Reference-contexts: The query complexity of randomized decision procedures was conjectured by Yao to be also (N 2 ). Progress towards proving this conjecture was made in [Yao87], <ref> [Kin91] </ref> and [Haj91] culminating in an (N 4=3 ) lower bound. This stands in striking contrast to the results mentioned above, by which some nontrivial monotone graph properties can be tested by examining a constant number of locations in the matrix.
Reference: [Kiw96] <author> M. Kiwi. </author> <title> Probabilistically Checkable Proofs and the Testing of Hadamard-like Codes. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1996. </year>
Reference-contexts: In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [BFLS91], has shifted from testing codes defined by low-degree polynomials [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] to testing Hadamard codes <ref> [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97] </ref>, and recently to testing the "long code" [BGS95, H-as96b, H-as97, Tre97]. All the above has focused on property testing in the sense of [RS96], and on testing algebraic properties such as linearity, multi-linearity and being a low-degree polynomial.
Reference: [KMR + 94] <author> M. J. Kearns, Y. Mansour, D. Ron, R. Rubinfeld, R. E. Schapire, and L. Sellie. </author> <title> On the learnability of discrete distributions. </title> <booktitle> In The 25th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 273-282, </pages> <year> 1994. </year>
Reference-contexts: which generates strings according to D 0 , or in form of a machine that on input x 2 f0; 1g n outputs D 0 (x)), such that with probability at least 1 ffi, the variation distance between D and D 0 is at most *. (For further details see <ref> [KMR + 94] </ref>.) In contrast, a distribution testing algorithm, upon receiving a sample of strings in f0; 1g n drawn according to an unknown distribution D, is required to accept D, with probability at least 1 ffi, if D 2 D n , and to reject (with probability 1 ffi) if
Reference: [KMS94] <author> D. R. Karger, R. Motwani, and M. Sudan. </author> <title> Approximate graph coloring by semidefinite programming. </title> <booktitle> In Proceedings of the Twenty-Sixth Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 2-13, </pages> <year> 1994. </year>
Reference-contexts: (i.e., N -vertex graphs with o (N 2 ) edges). (The reduction produces a coloring for dense graphs with 3 times more colors than the number used by the coloring of the non-dense graphs, but a factor of 3 seems small at the current state of art for this problem <ref> [KMS94] </ref>.) We remark that some known algorithms for this task, seem to perform better when the maximum degree of vertices in the graph is smaller [KMS94]. Furthermore, deciding k-Colorability even for N -vertex graphs of minimum degree at least k3 k2 N is NP-complete (cf., [Edw86]). <p> number used by the coloring of the non-dense graphs, but a factor of 3 seems small at the current state of art for this problem <ref> [KMS94] </ref>.) We remark that some known algorithms for this task, seem to perform better when the maximum degree of vertices in the graph is smaller [KMS94]. Furthermore, deciding k-Colorability even for N -vertex graphs of minimum degree at least k3 k2 N is NP-complete (cf., [Edw86]).
Reference: [KR98] <author> M. Kearns and D. Ron. </author> <title> Testing problems with sub-learning sample complexity. </title> <type> Manuscript, </type> <year> 1998. </year>
Reference-contexts: We mention that [GR97a] also presents poly (1=*)-time algorithms for testing k-Connectivity, for k 1, Planarity and other properties (all in the incident function representation). In recent work, Kearns and Ron <ref> [KR98] </ref> generalize our definition of property testing, and present testing algorithms that use only random examples for classes of functions that have been studied in the learning literature.
Reference: [KSS92] <author> M. J. Kearns, R. E. Schapire, and L. M. Sellie. </author> <title> Toward efficient agnostic learning. </title> <booktitle> In Proceedings of the Fifth Annual ACM Workshop on Computational Learning Theory, </booktitle> <pages> pages 341-352, </pages> <year> 1992. </year> <month> 86 </month>
Reference-contexts: The above assertion is demonstrated within one of the most basic domains of approximation algorithms the one of graph algorithms. But let us start with a general high level discussion. 1 Here and throughout the introduction we refer to the standard PAC learning model. We shortly discuss agnostic learning <ref> [KSS92] </ref>, where no assumption is made on the target function, towards the end of Section 3. 2 Similarly, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. <p> Finally, one invokes Schwarz's Lemma [Sch80], by which two such degree n polynomials can agree on at most n q &lt; 1 n 3 fraction of the domain. Agnostic Learning and Testing. In a variant of PAC learning, called Agnostic PAC learning <ref> [KSS92] </ref>, there is no promise concerning the target function f . Instead, the learner is required to output a hypothesis h from a certain hypothesis class H, such that h is *-close to the function in H which is closest to f .
Reference: [KZ93] <author> S. R. Kulkarni and O. Zeitouni. </author> <title> On probably correct classification of concepts. </title> <booktitle> In Proceedings of the Sixth Annual ACM Conference on Computational Learning Theory, </booktitle> <pages> pages 111-116, </pages> <year> 1993. </year>
Reference-contexts: Rubinfeld [Rub94] focuses on property testing as applied to properties which take the form of functional equations of various types. Property Testing in the context of Learning Theory: Departing from work in Statistics regarding the classification of distributions (e.g., [HW58, Cov73, ZK91]), Ben-David [BD92] and Kularni and Zeitouni <ref> [KZ93] </ref> considered the problem of classifying an unknown function into one of two classes of functions, given labeled examples. Ben-David studied this classification problem in the limit (of the number of examples), and Kulkarni and Zeitouni studied it in a PAC inspired model.
Reference: [LY91] <author> L. Lovasz and N. Young. </author> <title> Lecture notes on evasiveness of graph properties. </title> <type> Technical Report TR-317-91, </type> <institution> Princeton University, Computer Science Department, </institution> <year> 1991. </year>
Reference-contexts: Relation to deciding (recognizing) graph properties: Our notion of testing a graph property P is a relaxation of the notion of deciding (recognizing) the graph property P which has received much attention in the last three decades <ref> [LY91] </ref>. In the classical problem there are no margins of error, and one is required to accept all graphs having property P and reject all graphs which lack it.
Reference: [NN93] <author> J. Naor and M. Naor. </author> <title> Small-bias probability spaces: Efficient constructions and applications. </title> <journal> SIAM Journal on Computing, </journal> <volume> 22(4) </volume> <pages> 838-856, </pages> <year> 1993. </year>
Reference-contexts: This proposition subsumes Proposition 10.5. Proof: We adapt the proof of Proposition 10.5, by considering, for each N , all graphs which arise for particular "pseudorandom" sequences. Specifically, we consider N -long sequences taken from a 1 2 2 t -biased sample space (cf., <ref> [NN93] </ref> or [AGHP92]), where t def 100 N 2 . Efficiently constructible sample spaces of size (2 t N ) 5 having the above property can be found in [NN93, AGHP92]. <p> Specifically, we consider N -long sequences taken from a 1 2 2 t -biased sample space (cf., [NN93] or [AGHP92]), where t def 100 N 2 . Efficiently constructible sample spaces of size (2 t N ) 5 having the above property can be found in <ref> [NN93, AGHP92] </ref>.
Reference: [Pet94] <author> E. Petrank. </author> <title> The hardness of approximations: Gap location. </title> <journal> Computational Complexity, </journal> <volume> 4 </volume> <pages> 133-157, </pages> <year> 1994. </year>
Reference-contexts: As another illustration of the applicability to "dual approximation" problems, we discuss our results regarding testing k-Colorability. It is known that it is NP-Hard to distinguish 3-Colorable graphs from graphs in which every 3-partition of the vertex set violates at least a constant fraction of the edges <ref> [Pet94] </ref>. In contrast, our k-Colorability Tester implies that solving the same promise problem is easy for dense graphs, where by dense graphs we mean N -vertex graphs with (N 2 ) edges.
Reference: [PV88] <author> L. Pitt and L. G. Valiant. </author> <title> Computational limitations on learning from examples. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 35(4) </volume> <pages> 965-984, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Namely, the absence of a promise makes testing potentially harder than learning, whereas deciding whether a function belongs to a class rather than finding the function may make testing easier. In the learning literature, a distinction is made between proper (or representation dependent) learning and non-proper learning <ref> [PV88] </ref>. In the former model, the hypothesis output by the learning algorithm is required to belong to the same function class as the target function f , i.e. h 2 F , while in the latter model, h 2 H, for some hypothesis class H such that F H. <p> In contrast to Proposition 3.1 and to Corollary 3.2, we show that there are classes which are efficiently learnable (though not by a proper learning algorithm) but are not efficiently testable. This is proven by observing that many hardness results for proper learning (cf. <ref> [PV88, BR89, PW93] </ref>) actually establish the hardness of testing (for the same classes). Furthermore, we believe that it is more natural to view these hardness results as referring to testing and derive the hardness for proper learning via Proposition 3.1. <p> Proposition 3.3 If N P 6 BP P then there exist function classes which are not poly (n=*)-time testable but are poly (n=*)-time (non-properly) learnable. Proof: The proposition follows from the fact that many of the representation dependent hardness results (cf. <ref> [Gol78, Ang78, PV88, BR89, PW93] </ref>) have roughly the following form. <p> Hence, our decision procedure rejects no-instances with probability at least 1 ffi. This establishes, in particular, that testing the class of k-Term DNF (where k is a constant) is NP-Hard (see <ref> [PV88] </ref>). On the other hand, k-Term DNF (for constant k) is efficiently learnable (using the hypothesis class of k-CNF) [Val84, PV88]. <p> This establishes, in particular, that testing the class of k-Term DNF (where k is a constant) is NP-Hard (see [PV88]). On the other hand, k-Term DNF (for constant k) is efficiently learnable (using the hypothesis class of k-CNF) <ref> [Val84, PV88] </ref>. We stress that whereas Proposition 3.1 generalizes to learning and testing under specific distributions, and to learning and testing with queries, the proof of Proposition 3.3 uses the premise that the testing (or proper learning) algorithm works for any distribution and does not make queries.
Reference: [PW93] <author> L. Pitt and M. K. Warmuth. </author> <title> The minimum consistent DFA problem cannot be approximated within any polynomial. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 95-142, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: In contrast to Proposition 3.1 and to Corollary 3.2, we show that there are classes which are efficiently learnable (though not by a proper learning algorithm) but are not efficiently testable. This is proven by observing that many hardness results for proper learning (cf. <ref> [PV88, BR89, PW93] </ref>) actually establish the hardness of testing (for the same classes). Furthermore, we believe that it is more natural to view these hardness results as referring to testing and derive the hardness for proper learning via Proposition 3.1. <p> Proposition 3.3 If N P 6 BP P then there exist function classes which are not poly (n=*)-time testable but are poly (n=*)-time (non-properly) learnable. Proof: The proposition follows from the fact that many of the representation dependent hardness results (cf. <ref> [Gol78, Ang78, PV88, BR89, PW93] </ref>) have roughly the following form.
Reference: [Ros73] <author> A. L. Rosenberg. </author> <title> On the time required to recognize properties of graphs: A problem. </title> <journal> SIGACT News, </journal> <volume> 5 </volume> <pages> 15-16, </pages> <year> 1973. </year>
Reference-contexts: In the classical problem there are no margins of error, and one is required to accept all graphs having property P and reject all graphs which lack it. In 1975, Rivest and Vuillemin resolved the Aanderaa-Rosenberg Conjecture <ref> [Ros73] </ref>, showing that any deterministic procedure for deciding any non-trivial monotone N -vertex graph property must examine (N 2 ) entries in the adjacency matrix representing the graph. The query complexity of randomized decision procedures was conjectured by Yao to be also (N 2 ).
Reference: [RS96] <author> R. Rubinfeld and M. Sudan. </author> <title> Robust characterization of polynomials with applications to program testing. </title> <journal> SIAM Journal on Computing, </journal> <volume> 25(2) </volume> <pages> 252-271, </pages> <year> 1996. </year>
Reference-contexts: 1 Introduction Property Testing is concerned with the computational task of determining whether a given object has a predetermined property or is "far" from any object having the property. A notion of Property Testing was first formulated in <ref> [RS96] </ref>. In their formulation, a property testing algorithm for property P is given oracle access to the tested function f . The algorithm must distinguish the case that f has property P from the case that f is far from any function having the property. <p> E-mail: shafi@theory.lcs.mit.edu. z Laboratory for Computer Science, MIT, 545 Technology Sq., Cambridge, MA 02139. E-mail: danar@theory.lcs.mit.edu. Supported by an NSF postdoctoral fellowship. 1 the program satisfies certain properties before checking that it computes a specified function. This paradigm has been followed both in the theory of program checking <ref> [BLR93, RS96] </ref>, and in practice where often programmers first test their programs by verifying that the programs satisfy properties that are known to be satisfied by the function they compute. In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. <p> All the above has focused on property testing in the sense of <ref> [RS96] </ref>, and on testing algebraic properties such as linearity, multi-linearity and being a low-degree polynomial. In this work we extend the scope of property testing in two ways: 1. Working within the above framework, we venture into the domain of combinatorial objects . <p> This holds even with respect to the restricted notion of property testing where one considers only the uniform distribution and allows the algorithm to make queries of its choice <ref> [RS96] </ref>. The above assertion is demonstrated within one of the most basic domains of approximation algorithms the one of graph algorithms. But let us start with a general high level discussion. 1 Here and throughout the introduction we refer to the standard PAC learning model. <p> As mentioned above, this paradigm has been followed both in the theory and practice of program checking. 3 1.2.1 Motivating Discussion Throughout the rest of the introduction, we refer to property testing in the restricted sense of <ref> [RS96] </ref>. Recall that the definition of property testing is a relaxation of the standard definition of a decision task: The tester is allowed arbitrary behavior when the object does not have the property, and yet is "close" to an object having the property. <p> The difference is that in self-testing, a function f (represented by a program) is tested for being close to a fully specified function g, whereas in property-testing the test is whether f is close to any function in a function class G. Interestingly, many self-testers <ref> [BLR93, RS96] </ref> work by first testing that the program satisfies some properties which the function it is supposed to compute satisfies (and only then checking that the program satisfies certain constraints specific to the function). <p> Interestingly, many self-testers [BLR93, RS96] work by first testing that the program satisfies some properties which the function it is supposed to compute satisfies (and only then checking that the program satisfies certain constraints specific to the function). Rubinfeld and Sudan <ref> [RS96] </ref> defined property testing, under the uniform distribution and using queries, and related it to their notion of Robust Characterization. Rubinfeld [Rub94] focuses on property testing as applied to properties which take the form of functional equations of various types. <p> Work on low-degree testing [BFL91, BFLS91, GLR + 91], culminating in the result of Rubinfeld and Sudan <ref> [RS96] </ref>. implies that there exists a testing algorithm for the class P OLY , under the uniform distribution, whose query complexity is O (minfn 3 ; n * g log (1=ffi)).
Reference: [Rub94] <author> R. Rubinfeld. </author> <title> Robust functional equations and their applications to program testing. </title> <booktitle> In Proceedings of the Thirty-Fifth Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1994. </year>
Reference-contexts: Rubinfeld and Sudan [RS96] defined property testing, under the uniform distribution and using queries, and related it to their notion of Robust Characterization. Rubinfeld <ref> [Rub94] </ref> focuses on property testing as applied to properties which take the form of functional equations of various types.
Reference: [Sch80] <author> J. T. Schwartz. </author> <title> Fast probabilistic algorithms for verification of polynomial identities. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 27 </volume> <pages> 701-717, </pages> <year> 1980. </year>
Reference-contexts: Again, the reason is that any query (or example) gives rise to a single linear constraint on the coefficients of the polynomial. Since there are exponentially (in n) many coefficients, this leaves the polynomial not uniquely defined. Finally, one invokes Schwarz's Lemma <ref> [Sch80] </ref>, by which two such degree n polynomials can agree on at most n q &lt; 1 n 3 fraction of the domain. Agnostic Learning and Testing. In a variant of PAC learning, called Agnostic PAC learning [KSS92], there is no promise concerning the target function f .
Reference: [Sze78] <author> E. Szemeredi. </author> <title> Regular partitions of graphs. </title> <booktitle> In Proceedings, Colloque Inter. CNRS, </booktitle> <pages> pages 399-401, </pages> <year> 1978. </year>
Reference-contexts: As noted above, much less effi-cient testers for k-Colorability and other graph properties can be obtained by using the Regularity Lemma of Szemeredi <ref> [Sze78] </ref>. Interestingly, the Regularity Lemma yields the following result about testing, which we do not know to obtain without it. Let H be an arbitrary fixed graph (e.g., the triangle K 3 ) and consider the class of graphs which have no H subgraphs.
Reference: [Tre97] <author> L. Trevisan. </author> <title> Recycling queries in pcps and in linearity tests. </title> <type> Manuscript, </type> <year> 1997. </year>
Reference-contexts: In the context of probabilistically checkable proofs, the property tested is being a codeword with respect to a specific code. This paradigm, explicitly introduced in [BFLS91], has shifted from testing codes defined by low-degree polynomials [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] to testing Hadamard codes <ref> [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97] </ref>, and recently to testing the "long code" [BGS95, H-as96b, H-as97, Tre97]. All the above has focused on property testing in the sense of [RS96], and on testing algebraic properties such as linearity, multi-linearity and being a low-degree polynomial. <p> This paradigm, explicitly introduced in [BFLS91], has shifted from testing codes defined by low-degree polynomials [BFL91, BFLS91, FGL + 91, AS92, ALM + 92] to testing Hadamard codes [ALM + 92, BGLR93, BS94, BCH + 95, Kiw96, Tre97], and recently to testing the "long code" <ref> [BGS95, H-as96b, H-as97, Tre97] </ref>. All the above has focused on property testing in the sense of [RS96], and on testing algebraic properties such as linearity, multi-linearity and being a low-degree polynomial. In this work we extend the scope of property testing in two ways: 1.
Reference: [Val84] <author> L. G. Valiant. </author> <title> A theory of the learnable. </title> <journal> Communications of the ACM, </journal> <volume> 27(11) </volume> <pages> 1134-1142, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: Distance between functions is measured, accordingly, with respect to D. This formulation is inspired by the PAC learning model <ref> [Val84] </ref>, and we indeed relate property testing so formulated to various variants of the PAC model. We believe that property testing offers new perspective with respect to computational learning theory. <p> and is required to pass with high probability every f which is * 1 -close to F n , and fail every f which is * 2 -far from F n . 11 3 On the Relation between Property Testing and PAC Learning A Probably Approximately Correct (PAC) learning algorithm <ref> [Val84] </ref> works in the same framework as that described in Definition 2.1 except for the following (crucial) differences: 1. It is given a promise that the unknown function f (referred to as the target function) belongs to F ; 2. <p> This establishes, in particular, that testing the class of k-Term DNF (where k is a constant) is NP-Hard (see [PV88]). On the other hand, k-Term DNF (for constant k) is efficiently learnable (using the hypothesis class of k-CNF) <ref> [Val84, PV88] </ref>. We stress that whereas Proposition 3.1 generalizes to learning and testing under specific distributions, and to learning and testing with queries, the proof of Proposition 3.3 uses the premise that the testing (or proper learning) algorithm works for any distribution and does not make queries.
Reference: [VC71] <author> V. N. Vapnik and A. Y. Chervonenkis. </author> <title> On the uniform convergence of relative frequencies of events to their probabilities. </title> <journal> Theory of Probability and its applications, </journal> <volume> 17(2) </volume> <pages> 264-280, </pages> <year> 1971. </year>
Reference-contexts: In particular, the above proposition implies that if for every n, F n has polynomial (in n) VC-dimension <ref> [VC71, BEHW89] </ref> 9 , then F has a tester whose sample complexity is polynomial in n, 1=*, and log (1=ffi). The reason is that classes with polynomial VC-dimension can be properly learned from a sample of the above size [BEHW89].
Reference: [Yam95] <author> K. Yamanishi. </author> <title> Probably almost discriminative learning. </title> <journal> Machine Learning, </journal> <volume> 18 </volume> <pages> 23-50, </pages> <year> 1995. </year>
Reference-contexts: For any fixed *, the problem of testing the class F with distance parameter * can be casted as such a classification problem (with F and the set of functions *-away from F being the two classes). A different variant of the problem was considered by Yamanishi <ref> [Yam95] </ref>. Approximation in Dense Graphs. As stated previously, [AKK95] and [dlV94] presented polynomial-time approximation schemes (PTAS) for dense instances of Max-Cut.
Reference: [Yao87] <author> A. C. C. Yao. </author> <title> Lower bounds to randomized algorithms for graph properties. </title> <booktitle> In Proceedings of the Twenty-Eighth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 393-400, </pages> <year> 1987. </year>
Reference-contexts: The query complexity of randomized decision procedures was conjectured by Yao to be also (N 2 ). Progress towards proving this conjecture was made in <ref> [Yao87] </ref>, [Kin91] and [Haj91] culminating in an (N 4=3 ) lower bound. This stands in striking contrast to the results mentioned above, by which some nontrivial monotone graph properties can be tested by examining a constant number of locations in the matrix.
Reference: [ZK91] <author> O. Zeitouni and S. R. Kulkarni. </author> <title> A general classification rule for probability measures. </title> <note> To appear in Annals of Statistics, 1991. 87 </note>
Reference-contexts: Rubinfeld [Rub94] focuses on property testing as applied to properties which take the form of functional equations of various types. Property Testing in the context of Learning Theory: Departing from work in Statistics regarding the classification of distributions (e.g., <ref> [HW58, Cov73, ZK91] </ref>), Ben-David [BD92] and Kularni and Zeitouni [KZ93] considered the problem of classifying an unknown function into one of two classes of functions, given labeled examples.
References-found: 60

