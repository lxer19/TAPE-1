URL: ftp://cse.ogi.edu/pub/tech-reports/1998/98-002.ps.gz
Refering-URL: ftp://cse.ogi.edu/pub/tech-reports/README.html
Root-URL: http://www.cse.ogi.edu
Title: Multi-Stage Programming: Axiomatization and Type Safety extended abstract  
Author: Walid Taha Zine-El-Abidine Benaissa Tim Sheard 
Date: January 14, 1998  
Abstract: Multi-staged programming provides a new paradigm for constructing efficient solutions to complex problems. Techniques such as program generation, multi-level partial evaluation, and run-time code generation respond to the need for general purpose solutions which do not pay run-time interpretive overheads. This paper provides a foundation for the formal analysis of one such system. We introduce a multi-stage language and present its axiomatic, reduction, and natural semantics. Our axiomatic semantics is an extension of the call-by-value -calculus with staging constructs. We demonstrate the soundness of the axiomatic semantics with respect to the natural semantics. We show that staged-languages can "go Wrong" in new ways, and devise a type system that screens out such programs. Finally, we present a proof of the soundness of this type system with respect to the reduction semantics, and show how to extend this result to the natural semantics.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Joel Auslander, Matthai Philipose, Craig Chambers, Susan J. Eggers, and Brian N. Bershad. </author> <title> Fast, effective dynamic compilation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 149-159, </pages> <address> Philadelphia, Pennsylvania, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Recently, there has been significant interest in various forms of multi-stage computation, including program generation [3, 26], multi-level partial evaluation [11, 12], and run-time code generation <ref> [1, 5, 4, 8, 9, 13, 15, 16, 22] </ref>. Such techniques combine both the software engineering advantages of general purpose systems and the efficiency of specialized ones. <p> Hence by type soundness of the reduction semantics, e is not typable. 7 Related Work Multi-stage programming techniques have been used in a wide variety of settings, including run-time program generation in ML [17], run-time specialization of C programs [5, 4, 21, 9], and advanced dynamic compilation for C programs <ref> [1] </ref>. Nielson and Nielson present a seminal detailed study into a two-level functional programming language [19]. This language was developed for studying code generation.
Reference: [2] <author> Henk . P. Barendregt. </author> <title> The Lambda-Calculus, its syntax and semantics. Studies in Logic and the Foundation of Mathematics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year> <note> Second edition. </note>
Reference-contexts: Because each rule in the inductive definition above is an instance of one of the rules given in the inductive definition for level-annotated terms it is easy to show that values are a subset of level-annotated terms. 2.2 Contexts We generalize the notion of contexts <ref> [2] </ref> to a notion of annotated contexts: 3 c 0 := [ ] 0 j (c 0 a 0 ) 0 j (a 0 c 0 ) 0 j (x:c 0 ) 0 j &lt;c 1 &gt; 0 j (run c 0 ) 0 &lt;c n+2 &gt; n+1 j (~c n <p> Theorem 1 (Confluence). The reduction semantics is confluent. Proof. Using a notion of parallel reduction and a Strip Lemma, following closely the development in <ref> [2, pages 277-283] </ref>. Corollary 2 (Church-Rosser). The axiomatic semantics is Church-Rosser. 3 Faulty Terms Under the reduction semantics, when a term has been sufficiently reduced, we would like such a term to be a value, but this is not always the case.
Reference: [3] <author> Don Batory and Bart J. Geraci. </author> <title> Composition validation and subjectivity in genvoca generators. </title> <journal> IEEE Transactions on Software Engineering, </journal> <year> 1997. </year>
Reference-contexts: 1 Introduction Recently, there has been significant interest in various forms of multi-stage computation, including program generation <ref> [3, 26] </ref>, multi-level partial evaluation [11, 12], and run-time code generation [1, 5, 4, 8, 9, 13, 15, 16, 22]. Such techniques combine both the software engineering advantages of general purpose systems and the efficiency of specialized ones.
Reference: [4] <author> Charles Consel and Fran~cois Noel. </author> <title> A general approach for run-time specialization and its application to C. </title> <booktitle> In Conference Record of POPL '96: The 23 rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 145-156, </pages> <address> St. Petersburg Beach, Florida, </address> <month> 21-24 January </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Recently, there has been significant interest in various forms of multi-stage computation, including program generation [3, 26], multi-level partial evaluation [11, 12], and run-time code generation <ref> [1, 5, 4, 8, 9, 13, 15, 16, 22] </ref>. Such techniques combine both the software engineering advantages of general purpose systems and the efficiency of specialized ones. <p> Note how the looping overhead has been removed from the generated code. This is the purpose of program staging and it can be highly effective as discussed elsewhere <ref> [4, 10, 13, 17, 22, 25] </ref>. In this paper we move away from how staged languages are used and address their foundations. 2 The -R Language The -R language represents the core of MetaML. <p> Hence by type soundness of the reduction semantics, e is not typable. 7 Related Work Multi-stage programming techniques have been used in a wide variety of settings, including run-time program generation in ML [17], run-time specialization of C programs <ref> [5, 4, 21, 9] </ref>, and advanced dynamic compilation for C programs [1]. Nielson and Nielson present a seminal detailed study into a two-level functional programming language [19]. This language was developed for studying code generation.
Reference: [5] <author> Charles Consel, Calton Pu, and Jonathan Walpole. </author> <title> Incremental specialization: The key to high performance, modularity, and portability in operating systems. </title> <booktitle> In Proceedings of the Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 44-46, </pages> <address> New York, NY, USA, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction Recently, there has been significant interest in various forms of multi-stage computation, including program generation [3, 26], multi-level partial evaluation [11, 12], and run-time code generation <ref> [1, 5, 4, 8, 9, 13, 15, 16, 22] </ref>. Such techniques combine both the software engineering advantages of general purpose systems and the efficiency of specialized ones. <p> Hence by type soundness of the reduction semantics, e is not typable. 7 Related Work Multi-stage programming techniques have been used in a wide variety of settings, including run-time program generation in ML [17], run-time specialization of C programs <ref> [5, 4, 21, 9] </ref>, and advanced dynamic compilation for C programs [1]. Nielson and Nielson present a seminal detailed study into a two-level functional programming language [19]. This language was developed for studying code generation.
Reference: [6] <author> Rowan Davies. </author> <title> A temporal-logic approach to binding-time analysis. </title> <booktitle> In Proceedings, 11 th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 184-195, </pages> <address> New Brunswick, New Jersey, July 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Our notion of level is very similar to that used by Gluck and Jtrgensen [10, 11]. Davies extended the Curry-Howard isomorphism to a relation between modal logic and the type system for a multi-level language <ref> [6] </ref>. Intuitively, fl provide a good framework for formalizing the presence of quote and quasi-quote in a language. The semantics of our Bracket and Escape correspond closely to those of quote and quasi-quote, respectively. Previous attempts to combine the fl and fl systems have not been successful [7, 6, 25]. <p> Intuitively, fl provide a good framework for formalizing the presence of quote and quasi-quote in a language. The semantics of our Bracket and Escape correspond closely to those of quote and quasi-quote, respectively. Previous attempts to combine the fl and fl systems have not been successful <ref> [7, 6, 25] </ref>. To our knowledge, our work is the first successful attempt to define a sound type system combining Brackets, Escape and Run in the same language.
Reference: [7] <author> Rowan Davies and Frank Pfenning. </author> <title> A modal analysis of staged computation. </title> <booktitle> In 23rd Annual ACM Symposium on Principles of Programming Languages (POPL'96), </booktitle> <address> St.Petersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Davies and Pfenning show that a generalization of this language to a multi-level language called fl gives rise to a type system very related to a modal logic, and that this type system is equivalent to the binding-time analysis of Nielson and Nielson <ref> [7] </ref>. Intuitively, fl provides a natural framework where LISP's quote and eval can be present in a language. The semantics of our Bracket and Run correspond closely to those of quote and eval, respectively. <p> Intuitively, fl provide a good framework for formalizing the presence of quote and quasi-quote in a language. The semantics of our Bracket and Escape correspond closely to those of quote and quasi-quote, respectively. Previous attempts to combine the fl and fl systems have not been successful <ref> [7, 6, 25] </ref>. To our knowledge, our work is the first successful attempt to define a sound type system combining Brackets, Escape and Run in the same language.
Reference: [8] <author> Dawson R. Engler. </author> <title> VCODE : A retargetable, extensible, very fast dynamic code generation system. </title> <booktitle> In Proceedingsof the ACM SIGPLAN Conference on Programming Language Design and Implemantation, </booktitle> <pages> pages 160-170, </pages> <address> New York, May 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction Recently, there has been significant interest in various forms of multi-stage computation, including program generation [3, 26], multi-level partial evaluation [11, 12], and run-time code generation <ref> [1, 5, 4, 8, 9, 13, 15, 16, 22] </ref>. Such techniques combine both the software engineering advantages of general purpose systems and the efficiency of specialized ones.
Reference: [9] <author> Dawson R. Engler, Wilson C. Hsieh, and M. Frans Kaashoek. </author> <title> `C: A language for high-level, efficient, and machine-independent dynaic code generation. </title> <booktitle> In Conference Record of POPL '96: The 23 rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 131-144, </pages> <address> St. Peters-burg Beach, Florida, </address> <month> January </month> <year> 1996. </year> <month> 11 </month>
Reference-contexts: 1 Introduction Recently, there has been significant interest in various forms of multi-stage computation, including program generation [3, 26], multi-level partial evaluation [11, 12], and run-time code generation <ref> [1, 5, 4, 8, 9, 13, 15, 16, 22] </ref>. Such techniques combine both the software engineering advantages of general purpose systems and the efficiency of specialized ones. <p> Hence by type soundness of the reduction semantics, e is not typable. 7 Related Work Multi-stage programming techniques have been used in a wide variety of settings, including run-time program generation in ML [17], run-time specialization of C programs <ref> [5, 4, 21, 9] </ref>, and advanced dynamic compilation for C programs [1]. Nielson and Nielson present a seminal detailed study into a two-level functional programming language [19]. This language was developed for studying code generation.
Reference: [10] <author> Robert Gluck and Jesper Jtrgensen. </author> <title> Efficient multi-level generating extensions for program special-ization. </title> <editor> In S. D. Swierstra and M. Hermenegildo, editors, </editor> <booktitle> Programming Languages: Implementations, Logics and Programs (PLILP'95), volume 982 of Lecture Notes in Computer Science, </booktitle> <pages> pages 259-278. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Note how the looping overhead has been removed from the generated code. This is the purpose of program staging and it can be highly effective as discussed elsewhere <ref> [4, 10, 13, 17, 22, 25] </ref>. In this paper we move away from how staged languages are used and address their foundations. 2 The -R Language The -R language represents the core of MetaML. <p> They also demonstrate that binding-time analysis in a multi-level setting can be done with efficiency comparable to that of two-level binding time analysis. Our notion of level is very similar to that used by Gluck and Jtrgensen <ref> [10, 11] </ref>. Davies extended the Curry-Howard isomorphism to a relation between modal logic and the type system for a multi-level language [6]. Intuitively, fl provide a good framework for formalizing the presence of quote and quasi-quote in a language.
Reference: [11] <author> Robert Gluck and Jesper Jtrgensen. </author> <title> Fast binding-time analysis for multi-level specialization. </title> <editor> In Dines Bjtrner, Manfred Broy, and Igor V. Pottosin, editors, </editor> <booktitle> Perspectives of System Informatics. Proceedings, volume 1181 of Lecture Notes in Computer Science, </booktitle> <pages> pages 261-272. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Recently, there has been significant interest in various forms of multi-stage computation, including program generation [3, 26], multi-level partial evaluation <ref> [11, 12] </ref>, and run-time code generation [1, 5, 4, 8, 9, 13, 15, 16, 22]. Such techniques combine both the software engineering advantages of general purpose systems and the efficiency of specialized ones. <p> They also demonstrate that binding-time analysis in a multi-level setting can be done with efficiency comparable to that of two-level binding time analysis. Our notion of level is very similar to that used by Gluck and Jtrgensen <ref> [10, 11] </ref>. Davies extended the Curry-Howard isomorphism to a relation between modal logic and the type system for a multi-level language [6]. Intuitively, fl provide a good framework for formalizing the presence of quote and quasi-quote in a language.
Reference: [12] <author> Robert Gluck and Jesper Jtrgensen. </author> <title> An automatic program generator for multi-level specialization. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 10(2) </volume> <pages> 113-158, </pages> <year> 1997. </year>
Reference-contexts: 1 Introduction Recently, there has been significant interest in various forms of multi-stage computation, including program generation [3, 26], multi-level partial evaluation <ref> [11, 12] </ref>, and run-time code generation [1, 5, 4, 8, 9, 13, 15, 16, 22]. Such techniques combine both the software engineering advantages of general purpose systems and the efficiency of specialized ones. <p> The semantics of our Bracket and Run correspond closely to those of quote and eval, respectively. Gluck and Jtrgensen study partial evaluation in the generalized context where inputs can arrive at an arbitrary number of times rather than just specialization-time and run-time <ref> [12] </ref>. They also demonstrate that binding-time analysis in a multi-level setting can be done with efficiency comparable to that of two-level binding time analysis. Our notion of level is very similar to that used by Gluck and Jtrgensen [10, 11].
Reference: [13] <author> Brian Grant, Markus Mock, Matthai Philipose, Craig Chambers, and Susan J. Eggers. </author> <title> Annotation-directed run-time specialization in C. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 163-178, </pages> <address> Amsterdam, The Netherlands, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: 1 Introduction Recently, there has been significant interest in various forms of multi-stage computation, including program generation [3, 26], multi-level partial evaluation [11, 12], and run-time code generation <ref> [1, 5, 4, 8, 9, 13, 15, 16, 22] </ref>. Such techniques combine both the software engineering advantages of general purpose systems and the efficiency of specialized ones. <p> Note how the looping overhead has been removed from the generated code. This is the purpose of program staging and it can be highly effective as discussed elsewhere <ref> [4, 10, 13, 17, 22, 25] </ref>. In this paper we move away from how staged languages are used and address their foundations. 2 The -R Language The -R language represents the core of MetaML.
Reference: [14] <author> John Launchbury and Simon L. Peyton-Jones. </author> <title> State in haskell. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 293-342, </pages> <month> December </month> <year> 1995. </year> <month> pldi94. </month>
Reference-contexts: We used unbound polymorphic type variable names in a scheme similar to that devised by Launchbury and Peyton Jones for ensuring the safety of state in Haskel <ref> [14] </ref>. It turns out that not allowing any free variables is too strong, and that using polymorphism was too weak. It is better to simply take account of the number of surrounding occurrences of Run in the Var rule.
Reference: [15] <author> Peter Lee. </author> <title> Realistic Compiler Generation. </title> <booktitle> Foundations of Computing Series. </booktitle> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Recently, there has been significant interest in various forms of multi-stage computation, including program generation [3, 26], multi-level partial evaluation [11, 12], and run-time code generation <ref> [1, 5, 4, 8, 9, 13, 15, 16, 22] </ref>. Such techniques combine both the software engineering advantages of general purpose systems and the efficiency of specialized ones.
Reference: [16] <author> Peter Lee and Mark Leone. </author> <title> Optimizing ML with run-time code uen&ation. </title> <booktitle> In Proceedingsof the ACM SIGPLAN Conference on Programming Language Design and Implemantation, </booktitle> <pages> pages 137-148, </pages> <address> New York, May21-24 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction Recently, there has been significant interest in various forms of multi-stage computation, including program generation [3, 26], multi-level partial evaluation [11, 12], and run-time code generation <ref> [1, 5, 4, 8, 9, 13, 15, 16, 22] </ref>. Such techniques combine both the software engineering advantages of general purpose systems and the efficiency of specialized ones.
Reference: [17] <author> Mark Leone and Peter Lee. </author> <title> A declarative approach to run-time code generation. </title> <booktitle> In Workshop on Compiler Support for System Software (WCSSS), </booktitle> <month> February </month> <year> 1996. </year>
Reference-contexts: Note how the looping overhead has been removed from the generated code. This is the purpose of program staging and it can be highly effective as discussed elsewhere <ref> [4, 10, 13, 17, 22, 25] </ref>. In this paper we move away from how staged languages are used and address their foundations. 2 The -R Language The -R language represents the core of MetaML. <p> Hence by type soundness of the reduction semantics, e is not typable. 7 Related Work Multi-stage programming techniques have been used in a wide variety of settings, including run-time program generation in ML <ref> [17] </ref>, run-time specialization of C programs [5, 4, 21, 9], and advanced dynamic compilation for C programs [1]. Nielson and Nielson present a seminal detailed study into a two-level functional programming language [19]. This language was developed for studying code generation.
Reference: [18] <author> Eugenio Moggi. </author> <title> A categorical account of two-level languages. </title> <booktitle> In MFPS 1997, </booktitle> <year> 1997. </year>
Reference-contexts: This improvement avoids the problems that Moggi points out regarding the use of such stateful functions in defining the semantics of two-level languages <ref> [18] </ref>. Now we move on to present some fundamental results about the untyped -R language, and use these results, in addition to the soundness of the type system with respect to the reduction semantics, to prove the soundness of the type system with respect to the natural semantics. <p> To our knowledge, our work is the first successful attempt to define a sound type system combining Brackets, Escape and Run in the same language. Moggi advocates a categorical approach to two-level languages, and and uses indexed categories to develop models for two languages similar to fl and fl <ref> [18] </ref>. He points out that two-level languages generally have not been presented along with an equational calculus.
Reference: [19] <author> Flemming Nielson and Hanne Rijs Nielson. </author> <title> Two-Level Functional Languages. </title> <booktitle> Number 34 in Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Nielson and Nielson present a seminal detailed study into a two-level functional programming language <ref> [19] </ref>. This language was developed for studying code generation.
Reference: [20] <author> Gordon Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1(1) </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: Proof. By induction on the proof tree for e n ,! v n . Lemma 14. If e fl ! v then e ,! v 0 . Proof. This proof requires a Standardization Theorem along the lines of Plotkin <ref> [20] </ref>, but one extended to deal with Brackets, Escape and Run. We omit the details for the sake of brevity. Please see the technical report for the full details [24]. 9 Corollary 15.
Reference: [21] <author> Calton Pu, Andrew Black, Crispin Cowan, and Jonathan Walpole. </author> <title> Microlanguages for operating system specialization. </title> <booktitle> In Proceedings of the SIGPLAN Workshop on Domain-Specific Languages, </booktitle> <address> Paris, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: Hence by type soundness of the reduction semantics, e is not typable. 7 Related Work Multi-stage programming techniques have been used in a wide variety of settings, including run-time program generation in ML [17], run-time specialization of C programs <ref> [5, 4, 21, 9] </ref>, and advanced dynamic compilation for C programs [1]. Nielson and Nielson present a seminal detailed study into a two-level functional programming language [19]. This language was developed for studying code generation.
Reference: [22] <author> Calton Pu and Jonathan Walpole. </author> <title> A study of dynamic optimization techniques: Lessons and directions in kernel design. </title> <type> Technical Report OGI-CSE-93-007, </type> <institution> Oregon Graduate Institute of Science and Technology, </institution> <year> 1993. </year>
Reference-contexts: 1 Introduction Recently, there has been significant interest in various forms of multi-stage computation, including program generation [3, 26], multi-level partial evaluation [11, 12], and run-time code generation <ref> [1, 5, 4, 8, 9, 13, 15, 16, 22] </ref>. Such techniques combine both the software engineering advantages of general purpose systems and the efficiency of specialized ones. <p> Note how the looping overhead has been removed from the generated code. This is the purpose of program staging and it can be highly effective as discussed elsewhere <ref> [4, 10, 13, 17, 22, 25] </ref>. In this paper we move away from how staged languages are used and address their foundations. 2 The -R Language The -R language represents the core of MetaML.
Reference: [23] <author> Mark Shields, Tim Sheard, and Simon Peyton Jones. </author> <title> Dynamic typing as staged type inference. </title> <booktitle> In Proceedings of the 25th ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, Ca. </address> <publisher> ACM Press, </publisher> <month> jan </month> <year> 1998. </year>
Reference-contexts: Proof: By induction on the structure of e n . 4 Type System The main obstacle to defining a sound type system for our language is the interaction between Run and Escape. While this is problematic, it adds significantly to the expressiveness of a staged language <ref> [23] </ref>, so it is worthwhile overcoming the difficulty. The problem is that Escape allows Run to appear inside a Bracketed -abstraction, and it is possible for Run to "drop" that -bound variable to a level lower than the level at which it is bound.
Reference: [24] <author> Walid Taha, Zine-el-abidine Benaissa, and Tim Sheard. </author> <title> The essence of staged programming. </title> <type> Technical report, OGI, </type> <address> Portland, OR, </address> <month> December </month> <year> 1997. </year>
Reference-contexts: Proof. This proof requires a Standardization Theorem along the lines of Plotkin [20], but one extended to deal with Brackets, Escape and Run. We omit the details for the sake of brevity. Please see the technical report for the full details <ref> [24] </ref>. 9 Corollary 15. There exists a value v such that -R ` e = v if and only if e ,! v 0 . Proof. Consequence of Lemmas 14 and 13. Theorem 16 (Soundness of Axiomatic Semantics).
Reference: [25] <author> Walid Taha and Tim Sheard. </author> <title> Multi-stage programming with explicit annotations. </title> <booktitle> In Proceedings of the ACM-SIGPLAN Symposium on Partial Evaluation and semantic based program manipulations PEPM'97, Amsterdam, </booktitle> <pages> pages 203-217. </pages> <publisher> ACM, </publisher> <year> 1997. </year>
Reference-contexts: We would like to guarantee statically that a program generator synthesizes only programs with properties such as: type-correctness, global references only to names in scope, and local names which do not inadvertently hide global references. In previous work <ref> [25] </ref>, we introduced a multi-stage programming language called MetaML. In that work we introduced four staging annotations to control the order of evaluation of terms. <p> Note how the looping overhead has been removed from the generated code. This is the purpose of program staging and it can be highly effective as discussed elsewhere <ref> [4, 10, 13, 17, 22, 25] </ref>. In this paper we move away from how staged languages are used and address their foundations. 2 The -R Language The -R language represents the core of MetaML. <p> This term is not a value and contains no redex. 2. A variable appears at a level lower than the level at which it was bound. This is the key, distinguishing form of undesirable behavior in multi-stage computation <ref> [25] </ref>. For example: &lt;(x:~(x 0 ) 1 ) 1 &gt; 0 is stuck since x is used at level 0 but bound at level 1. 3. A non-Bracket value is the argument to Run. <p> This implies that n + k + 1 + 1 + j + k 2 n + j which is impossible. The other cases are straight-forward. 6 Natural Semantics In previous work, we defined core MetaML by a natural semantics <ref> [25] </ref>. While this style of presentation is closer to the implementation of MetaML than the reduction semantics presented in this paper, it is more complex. <p> We have found that it was easier to prove type soundness first with respect to the reduction semantics, and then to extend this result to the natural semantics. In this paper, we present a more concise natural semantics for MetaML than the one we have presented in previous work <ref> [25] </ref>: (x:e 0 ) ,! (x:e 0 ) e 1 0 0 ,! v 1 1 ]) ,! v 0 (e 0 2 ) ,! v 2 0 0 1 e 1 0 ,! &lt;v 1 0 1 #) ,! v 2 0 1 ) ,! v 2 0 (e n+1 <p> Intuitively, fl provide a good framework for formalizing the presence of quote and quasi-quote in a language. The semantics of our Bracket and Escape correspond closely to those of quote and quasi-quote, respectively. Previous attempts to combine the fl and fl systems have not been successful <ref> [7, 6, 25] </ref>. To our knowledge, our work is the first successful attempt to define a sound type system combining Brackets, Escape and Run in the same language. <p> This characterization played a crucial role in leading us to the type system presented here. Finally, it is useful to note that our reduction semantics allows for fi-reductions inside Brackets, thus giving us a basis for verifying the soundness of the safe-fi optimization that we discussed in previous work <ref> [25] </ref>. MetaML currently exists as a prototype implementation that we intend to distribute freely on the web. The implementation supports the three programming constructs, higher-order datatypes (with support for Monads), Hindley-Milner polymorphism, recursion, and mutable state.
Reference: [26] <author> Richard Waldinger and Michael Lowry. AMPHION: </author> <title> Towards kinder, gentler formal methods. </title> <booktitle> In Proceedings of the 1994 Monterey Workshop on Formal Methods. </booktitle> <institution> U.S. Naval Postgraduate School, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Recently, there has been significant interest in various forms of multi-stage computation, including program generation <ref> [3, 26] </ref>, multi-level partial evaluation [11, 12], and run-time code generation [1, 5, 4, 8, 9, 13, 15, 16, 22]. Such techniques combine both the software engineering advantages of general purpose systems and the efficiency of specialized ones.
Reference: [27] <author> Andrew K. Wright and Matthias Felleisen. </author> <title> A syntactic approach to type soundness. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 38-94, </pages> <month> 15 November </month> <year> 1994. </year> <month> 12 </month>
Reference-contexts: A characterization of the additional ways in which a staged program can "go Wrong". 1 3. A type system to screen out such programs. 4. A soundness proof for the type system with respect to the reduction semantics using the syntactic approach to type-soundness of Wright and Felliesen <ref> [27] </ref>. 5. A natural semantics that chooses the order in which rules are applied. 6. The soundness of the axiomatic semantics with respect to the natural semantics. <p> If no rules apply, and the term is not a value, we say that such a term is stuck <ref> [27] </ref>. There are four contexts in which such terms can arise: 1. A non- value in a function position in an application (at level 0). This is the familiar form of undesirable behavior arising whenever the pure -calculus is extended with constants. <p> This way we ensure that if Run is ever in a -abstraction, it can only strip away Brackets that are explicitly apparent in that -abstraction. 5 Type Soundness of the Reduction Semantics The type soundness proof closely follows the subject reduction proofs of Wright and Felliesen <ref> [27] </ref>. Once the reduction semantics and type system have been defined, the syntactic type soundness proof proceeds as follows: 1. Show that reduction in the standard reduction semantics preserves typing. This is called subject reduction. 2. Show that faulty terms are not typable.
References-found: 27

