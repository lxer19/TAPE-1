URL: ftp://ftp.cs.utexas.edu/pub/code2/KleynDissBook.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/code/code-publications/
Root-URL: http://www.cs.utexas.edu
Title: A HIGH LEVEL LANGUAGE FOR SPECIFYING GRAPH-BASED LANGUAGES AND THEIR PROGRAMMING ENVIRONMENTS  
Degree: APPROVED BY DISSERTATION COMMITTEE:  
Abstract-found: 0
Intro-found: 1
Reference: [ACR + 89] <author> Bowen Alpern, Alan Carle, Barry Rosen, Peter Sweney, and Kenneth Zadeck. </author> <title> Graph attribution as a specification paradigm. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(2):121129, </volume> <month> February </month> <year> 1989. </year>
Reference: [ACS90] <author> B. Alpern, L. Carter, and T. Selker. </author> <title> Visualizing computer memory architecture. </title> <booktitle> In Proceedings of the First IEEE Workshop on Visualization, </booktitle> <pages> pages 107113, </pages> <month> October </month> <year> 1990. </year>
Reference: [AI89] <author> H. Ammar and S. Rezaul Islam. </author> <title> Time scale decomposition of a class of generalized stochastic Petri net models. </title> <journal> IEEE Trans. on Software Engneering, </journal> <volume> 15(6):809820, </volume> <month> June </month> <year> 1989. </year>
Reference: [AltReal88] <author> R. Smith. </author> <title> The Alternative Reality Kit. </title> <booktitle> Workshop on Visual Languages 1988 </booktitle>
Reference-contexts: Examples of this are the programming by demonstration visual programming systems such as Programming by Rehearsal [ShuPBH], KidSim [Kidsim94], and the Alternative Reality Kit <ref> [AltReal88] </ref>. All visual languages share the need for a programming environment - an interactive graphical user interface which is used to create and manipulate visual language programs. Early visual language systems required extensive custom graphics software to be realized.
Reference: [ARM91] <author> B. Stroustrup. </author> <title> The C++ programming language 2nd ed. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Objectoriented programming languages have been described as languages which provide extensive support for dealing with and controlling the use of pointers. The following comments by Stroustrup <ref> [ARM91] </ref> also allude to the issue under consideration: One of the most powerful intellectual tools for managing complexity is hierarchy, that is, organizing related concepts into a tree structure......Naturally, this organization has its limits.
Reference: [AYC88] <author> R. Akscyn, E. Yoder, D. MacCracken. </author> <title> The data model is the heart of interface design. </title> <booktitle> CHI 1988 </booktitle>
Reference-contexts: This approach, that the interface should not get in the way of the user, has repeatedly been advocated in the of user interface research community <ref> [AYC88, Sze93, Fol93, ShuFol] </ref>. 1.3 Results The results of this work are a set of concepts for characterizing graph-based visual languages and a set of abstractions embodied in the Glide specifi 5 cation language for specifying them and their programming environments.
Reference: [BA88] <author> J.C. Browne and Ashok Adiga. </author> <title> Performance Evaluation of Supercomputers, Chapter: Graph Structured Performance Models. </title> <publisher> Elsevier, </publisher> <year> 1988, </year> <pages> pp. 239-281. </pages>
Reference-contexts: For example, Colored Petri Nets is a model which adds structured typed tokens and more complex firing rules [CPN90], and PCM is an augmentation in which nets can be hierarchical, have time delays, and include parameters which specify replication of nodes at run time <ref> [BA88] </ref>. Others variations and many visual programing tools which provide simulation and animation are described in the proceedings for Petri Net workshops [F86]. State T ransition Systems : A graph-based way of representing finite state automata is through transition network diagrams. <p> PCM is a directed graph based language intended for performance modeling of parallel computa tions <ref> [BA88] </ref> [Adi88]. PCM is one of a very large number of variations on the basic Petri Net model that have been developed over the years. <p> The Glide syntax of the text expressions were trivially derived from their BNF <ref> [BA88] </ref>. The execution state of a node during execution is represented by the values of the enumerated type State. This includes the ACTIVE state which TransAttributes == Pi:Pexpr . PiVal:PexprVal . // Predicate result value Phi:Proc .
Reference: [BCL90] <author> Duane Bailey, Janice Cuny, and Craig Loomis. Paragraph: </author> <title> Graph editor support for parallel programming environments. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 19(2):75110, </volume> <year> 1990. </year> <title> parallel programming environment graph grammar. </title>
Reference-contexts: The Delta system is a model of parallel computation in which parallel programs can be defined with graph grammars [Delta91]. The ParaGraph system is an example of using graph grammars to concisely specify regular communications patterns used in parallel algorithms <ref> [BCL90] </ref>. Many of these models are visual languages since the rewrite rules and there effects are specified directly as graph diagrams, and not textually. 2.3 Summary This chapter has given an overview of graph-based visual languages and the use of directed graph models of computation.
Reference: [BDD92] <author> R. Bryant. </author> <title> Symbolic Boolean Manipulation with Ordered Binary-Decision Diagrams. </title> <journal> In ACM Computing Surveys, </journal> <note> Vol 24, No.3 Sept. 1992. </note> <author> [BDG + 91] A. Beguelin, J. Dongarra, G. Geist, R. Manchek, and V. Sunderam. </author> <title> Graphical development tools for network-based concurrent supercomputing. </title> <booktitle> In Supercomputing 91, </booktitle> <pages> pages 435444, </pages> <month> Nov </month> <year> 1991. </year>
Reference-contexts: A graph model in which the editing operations are nontrivial is Binary Decision Diagrams <ref> [BDD92] </ref>. These diagrams are a means for encoding boolean functions in the form of a binary DAG (each node has two edges pointing out and any number pointing in).
Reference: [BH92a] <author> M. H. Brown and J. Hershberger. </author> <title> Animation of Geometric Algorithms: A Video Review. </title> <type> Technical Report 87a, </type> <institution> DEC Systems Research Center, </institution> <address> Palo 182 Alto, </address> <month> June </month> <year> 1992. </year>
Reference: [BH92b] <author> M. H. Brown and J. Hershberger. </author> <title> Color and Sound in Algorithm Animation. </title> <type> Technical Report 76a, </type> <institution> DEC Systems Research Center, Palo Alto, </institution> <month> June </month> <year> 1992. </year>
Reference: [BL86] <author> B.Liskov, J.Guttag, </author> <title> Abstraction and specification in program development, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass.1986. </address>
Reference-contexts: A list defined in this way can be viewed either as a linked list or as a recursive containment as illustrated by the two diagrams in the figure below (taken from <ref> [BL86] </ref> p. 83). Recursive types II: trees A simple generalization of the list type is the tree type. Trees can also be conveniently represented using recursive type definitions.
Reference: [Boo94] <author> G. Booch. </author> <title> Object-oriented analysis and design with applications. 2nd ed. </title> <address> Redwood City, </address> <year> 1994. </year>
Reference-contexts: Many visual languages are based on the composition of objects into a graph but then also make use of 2D graphical features in order convey further semantics. Typical of these are the various objectoriented design notations such as Rumbaughs Object Modelling Technique [OMT91], the Booch notation <ref> [Boo94] </ref>, and the Shlaer/Mellor design language [ShM88]. These notations are all collections of graph-based visual languages which are overlaid with text and graphical features (e.g. iconic shapes). These features may have a particular meaning and their 2D spatial placement can be significant.
Reference: [Bow89] <author> Jonathan P. Bowen. </author> <title> Formal specification of window systems. </title> <type> Technical Monograph PRG-74, </type> <month> June </month> <year> 1989. </year>
Reference: [Bro85] <author> J. C. Browne. </author> <title> Formulation and programming of parallel computers: A unified approach. </title> <booktitle> In Proc. Intl. Conf. Par. Proc., </booktitle> <pages> pages 624631, </pages> <year> 1985. </year>
Reference: [Bro88] <author> Marc H. Brown. </author> <title> Algorithm Animation. ACM Doctoral Dissertation Award. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass, </address> <year> 1988. </year>
Reference: [Bro92] <author> M. H. Brown. Zeus: </author> <title> A System for Algorithm Animation and Multi-view Editing. </title> <type> Technical Report 75, </type> <institution> DEC Systems Research Center, Palo Alto, </institution> <month> February </month> <year> 1992. </year>
Reference: [BS84] <author> M. H. Brown and R. Sedgewick. </author> <title> A System for Algorithm Animation. </title> <journal> Computer Graphics, </journal> <volume> 18(3):177186, </volume> <month> July </month> <year> 1984. </year>
Reference: [BSS84] <editor> D. R. Barstow, H. E. Shrobe, and E. Sandewall, editors. </editor> <title> Interactive Programming Environments. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1984. </year>
Reference: [BS84] <author> M. H. Brown and R. Sedgewick. </author> <title> A System for Algorithm Animation. </title> <journal> Computer Graphics, </journal> <volume> 18(3):177186, </volume> <month> July </month> <year> 1984. </year> <month> (BALSA) </month>
Reference: [Bur94] <author> M. Burnett, R. Hossli, T. Pulliam, B. VanHoorst, X. Yang. </author> <title> Toward Visual Programming Languages for Steering Scientific Computations. </title> <booktitle> In IEEE Computational Science and Engineering, </booktitle> <month> Winter </month> <year> 1994. </year>
Reference-contexts: The programming environments allow the visual language to be executed in situ and the execution behavior is reflected as animations on the diagram (the visual language program) that the user created. This immediate visual feedback is a powerful aid to program comprehension <ref> [Bur94] </ref>. Visual language environments that provide animation are a specialized form of the more general concept of program visualization. Most program visualization systems have been developed for producing animations of algorithms and are independent of any particular programming lan-g u a g e .
Reference: [BY90] <author> W Burton, HK Yang. </author> <title> Manipulating multilinked data structures in a pure functional language. </title> <note> Software Practice and Experience Vol 20 (11) 1167-1185 Nov 1990. </note>
Reference-contexts: One proposed solution that avoids recreating the entire data structure after any change to a data structure is described by Burton and Yang on the use of multilinked data structures in functional languages <ref> [BY90] </ref>. This solution hides the change of state as auxiliary heap data structure which must then be passed as an extra argument between function invocations. It is possible to reduce the amount of copying by carefully sharing structure between the successive heaps associated with each function invocation.
Reference: [BW88] <author> R. Bird, P. Wadler. </author> <title> Introduction to Functional Programming. </title> <publisher> Prentice-Hall 1988. </publisher>
Reference-contexts: Functions accessing and manipulating instances of the types (values) can be defined abstractly and in a way independent of their implementation.Two functional languages are used here as illustrative examples, first ML [Paul] and then Miranda <ref> [BW88] </ref>. 98 As its name suggests (Meta Language), one of the primary purposes of ML is to describe languages, and thus it is wellsuited to applications centered on representing language structure.
Reference: [CComp88] <author> C. Fischer, R. LeBlanc, </author> <title> Crafting a compiler. </title> <address> Benjamin/Cummings, Menlo Park, CA, c1988. </address>
Reference: [CER78] <editor> Volker Claus, Hartmut Ehrig, and Grzegorz Rozenberg, editors. </editor> <booktitle> Graph-grammars and their application to computer science and biology: international workshop. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Bad Honnef, </address> <month> October </month> <year> 1978. </year> <note> 183 LNCS73. </note>
Reference: [CGP89] <author> P. T. Cox, F. R. Giles, and T. Pietrzykowski. Prograph: </author> <title> A step towards liberating programming form textual conditioning. </title> <booktitle> In IEEE Workshop on Visual Language, </booktitle> <pages> pages 150156, </pages> <address> Rome, Italy, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: There are only a few attempts to create general purpose graph-based languages which are analogous to the general purpose textual ones (C, Pascal) - LabVIEW and Prograph <ref> [CGP89] </ref> come closest. Most are little languages which have specialized semantics for a particular domain. They are also often embedded as part of a larger system (AVS is a good example).
Reference: [Che91] <author> D. Cheng. </author> <title> A survey of parallel programming tools. </title> <type> Technical Report RND-91-005, </type> <institution> NASA Ames, </institution> <month> May </month> <year> 1991. </year>
Reference: [Chi85] <author> Uli H. Chi. </author> <title> Formal specification of user interfaces: A comparison and evaluation of four axiomatic approaches. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(8):671685, </volume> <month> August </month> <year> 1985. </year>
Reference: [CHVL91] <author> C. </author> <title> Holt in Report on E-mail Panel: Is Visual Programming a New Programming Paradigm? IEEE Workshop on Visual Languages 1991. </title>
Reference: [CL88] <author> C. Chow and S. Lam. Prospec: </author> <title> An interactive programming environment for designing and verifying communication protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(3):327338, </volume> <month> March </month> <year> 1988. </year>
Reference-contexts: Another example is modelling communications protocols. Peers in communications protocols can be modeled as communicating finite state machines. The 16 Prospec system is an example of a visual programming tool developed for this kind of modeling <ref> [CL88] </ref>. Hygraphs is a model of computation based on hypergraphs. It is the model underlying the Statecharts visual language [Har87,Har88]. The model is based on state transition model and is intended to model socalled reactive systems. Reactive systems are systems which must respond to external events.
Reference: [CLU93] <author> B. Liskov. </author> <booktitle> A history of CLU Proceedings of the Second ACM SIGPLAN History of Programming Languages Conference (HOPL-II). ACM SIGPLAN Notices. V28, </booktitle> <volume> Number 3, </volume> <month> March </month> <year> 1993. </year>
Reference: [Cou90] <author> Bruno Courcelle. </author> <title> Handbook of Theoretical Computer Science, volume B - Formal Models and Semantics, chapter 5 - Graph Rewriting: An Algebraic and Logic Approach, </title> <publisher> pages 194242. Elsevier, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference: [CPN90] <author> K Jensen, </author> <title> Colored Petri Nets: A High Level Language for System Design and Analysis. </title> <booktitle> In Advances in Petri Nets 1990 LNCS no.483, </booktitle> <publisher> Springer, </publisher> <address> Berlin NY 1990, </address> <pages> pp. </pages> <month> 342-416. </month> <title> ..In our opinion, all users of CP-nets (and other kinds of Petri-nets) are forced to make simulations - because it is impossible to construct a CP-net without thinking about the effects of the individual transitions. Thus the proper question is not whether the modeller should make simulations or not, but whether he wants computer support for this activity. With this rephrasing the answer becomes trivial: Of course we want computer support.. </title>
Reference-contexts: There a great many variations of this basic theme that have been developed. For example, Colored Petri Nets is a model which adds structured typed tokens and more complex firing rules <ref> [CPN90] </ref>, and PCM is an augmentation in which nets can be hierarchical, have time delays, and include parameters which specify replication of nodes at run time [BA88]. Others variations and many visual programing tools which provide simulation and animation are described in the proceedings for Petri Net workshops [F86].
Reference: [CS90] <author> L. Chang and B. Smith. </author> <title> Classification and evaluation of parallel programming tools. </title> <institution> Tech Rept CS90-22, Dept. of Comp. Sci. Univ. of New Mexico, </institution> <year> 1990. </year>
Reference: [daV93] <author> M. Frohlich, M. Werner. daVinci. </author> <title> Ver 1.1 User Manual. </title> <type> Tech Report Univ. </type> <note> Bremen August 1993 </note>
Reference: [Dea92] <author> Nate Dean. </author> <title> Viewing and analyizing graphs with netpad. </title> <booktitle> In Proceedings of the DIMACS Workshop, </booktitle> <month> March </month> <year> 1992. </year>
Reference: [DF82] <author> Davis, Keller. </author> <title> Data Flow Program Graphs. </title> <note> In IEEE Computer Special Issue on DataFlow Langauges. 1982 184 </note>
Reference-contexts: In this model of computation values ow along the arcs and are consumed by nodes which compute new values ( e.g. simple arithmetic operations), and the new values are passed on out of the node . Again many more complex variations of this basic model have been developed <ref> [DF82] </ref>. Control Flow: Control ow graphs are used to model the ow of execution in a program. Flowcharts is an early form of graph-based language for specifying program structure based on control ow. Some graph models are intended to specify purely static relationships.
Reference: [DH89] <author> R. Davidson and D. Harel. </author> <title> Drawing graphs nicely using simulated annealing. </title> <type> Technical Report CS89-13, </type> <institution> Weizmann Institute of Science, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: All these packages face the graph layout problem. i.e., the need to provide a readable arrangement of nodes and links, preferably in the smallest amount of space. The problem of ef ficient of 2D layout algorithms for readable graph displays has received exten sive attention (see surveys by Harel <ref> [DH89] </ref> and Tammasia [RTB88], and an analysis of the problem in [ET89]. Many of these algorithms have already been incorporated into some the graph GUI tools such as EDGE and XGRAB. 181
Reference: [Dil90] <author> Antoni Diller. </author> <title> Z - A Introduction to Formal Methods. </title> <publisher> John Wiley and Sons, </publisher> <address> Chichester, </address> <year> 1990. </year>
Reference: [Dix91] <author> Alan John Dix. </author> <title> Formal Methods for Interactive Systems. </title> <year> 1991. </year>
Reference: [DP83] <author> Dipayan Gangopadhyay. </author> <title> A formal system for network databases and its applications to integrity based issues. </title> <type> Ph.D. Thesis, </type> <institution> University of Texas, Dept. of Computer Sciences 1983. </institution>
Reference: [Dye89] <author> R. Dye. </author> <title> Labview : A visual data-flow programming language and environment. </title> <type> Masters thesis, </type> <institution> Dept. of Elec. and Comp. Eng. University of Texas at Austin, </institution> <year> 1989. </year>
Reference-contexts: More specifically, the Glide specification presented in this section was derived from <ref> [Dye89] </ref>, which provides an informal english description of the syntax, semantics, and graphical appearance of an early version of LabVIEW. The commercial system has evolved, but the compact and self-contained Dye description provides an ideal source from which to derive a Glide specification and compare it.
Reference: [E. 90] <author> E. Kant, F. Daube, W. MacGregor, J. Wald. </author> <title> Synthesis of mathematical modelling programs. </title> <booktitle> In Mathematica Conference Proceedings, </booktitle> <address> Redwood City, CA, </address> <month> January </month> <year> 1990. </year>
Reference: [ea85] <author> D. Notkin et al. </author> <title> The GANDALF Project. </title> <journal> The Journal of Systems and Software, </journal> <year> 1985. </year>
Reference-contexts: These efforts ranged from the comprehensive approach of creating a complete set of language tools (editors, compilers, debuggers, profil-ers, etc.) to efforts targeted specifically at creating interactive editors tailored to a particular programming language. Some large systems were developed including Gandalf <ref> [ea85] </ref> and the Cornell Program Synthesizer (CPS) [ref TR81], and more recently Centaur [Klint93], and Pan [Grahm]. These systems are text language-based systems.
Reference: [ea91] <editor> J. Werth et al. </editor> <title> The interaction of the formal and practical in parallel programming environment development: Code. </title> <type> Tech. Rep. </type> <institution> TR-91-09, Dept. Comp. Sci., Univ. Texas at Austin, </institution> <year> 1991. </year>
Reference: [EGF91] <author> M. Blattner E. Glinert and C. Frerking. </author> <title> Visual tools and languages: Directions for the 90s. </title> <booktitle> In Workshop on Visual Languages, </booktitle> <pages> pages 8995. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference: [Ehr87] <editor> Hartmut Ehrig, editor. </editor> <booktitle> Graph-grammars and their application to computer science : 3rd international workshop. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Warrenton, Virginia, USA, </address> <month> December </month> <year> 1987. </year> <month> LNCS291. </month>
Reference: [Ehr90] <editor> Hartmut Ehrig, editor. </editor> <booktitle> Graph-Grammars and their Application to Computer Science : 4th International Workshop. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Bremen, Germany, </address> <month> March </month> <year> 1990. </year> <note> See discussion page 41. </note> <author> [ELN + 92] G. Engels, C. Lewerentz, M. Nagl, W Schafer, </author> <title> and A Schurr. Building integrated software development environments part1: Tool specification. </title> <journal> ACM Transaction on Software Engineering and Methodology, </journal> <volume> 1(2):125167, </volume> <month> April </month> <year> 1992. </year>
Reference-contexts: The problem of circular structures is hidden by dealing with pictures of graphs directly. The difficulties encountered in attempting to find a concise standard textual notation for graph rewriting is an indication of the underlying problem of cyclic structures <ref> [Ehr90] </ref>. 5.6 Dynamic Structures, Anonymity, and Connections This survey of the different approaches to describing shared and cyclic structures shows that there is an underlying issue of whether or not to associate explicit names (a pointer is a kind of name) with objects so that these names can be used to
Reference: [ENR82] <editor> Hartmut Ehrig, Manfred Nagl, and Grzegorz Rozenberg, editors. </editor> <booktitle> Graph-grammars and their application to computer science : 2nd international workshop. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Haus Ohrbeck, </address> <month> October </month> <year> 1982. </year> <note> LNCS153. 185 </note>
Reference: [Env92] <author> Interactive Development Environments. </author> <title> Software through pictures, </title> <booktitle> 1992. </booktitle> <address> 595 Market Street, San Fransisco CA94105. </address>
Reference: [ERL90] <author> H. El-Rewini and T. G. Lewis. </author> <title> Task grapher: A tool for scheduling parallel program tasks. </title> <booktitle> In Proceedings of the 5th Distributed Memory Computing Conference, </booktitle> <pages> pages 11711178, </pages> <address> Charleston So. Carlonia, </address> <month> April </month> <year> 1990. </year>
Reference: [ET89] <author> P. Eades and R. Tamassia. </author> <title> Algorithms for automatic graph drawing: an annotated bibliography. </title> <type> Tech Report CS-89-09, </type> <institution> Dept. of Comp. Sci., Brown Univ., </institution> <year> 1989. </year>
Reference-contexts: too many to enumerate here, but the following list is a small representative sample of the main classes of graph-based models of computa 2 Providing efficient algorithms that produce readable graph layouts for applications such as graph-based visual programming environments is a difficult problem and an active area of research <ref> [ET89] </ref>. 15 tion. It illustrates how widespread the use of a graph abstraction is in models of software systems. Petri Nets: A well known simple example of a graph-based model is Petri Nets [Pet81]. <p> The problem of ef ficient of 2D layout algorithms for readable graph displays has received exten sive attention (see surveys by Harel [DH89] and Tammasia [RTB88], and an analysis of the problem in <ref> [ET89] </ref>. Many of these algorithms have already been incorporated into some the graph GUI tools such as EDGE and XGRAB. 181
Reference: [ET++89] <author> A. Weinand, E. Gamma, R. Marty. </author> <title> Design and implementation of ET++ a seamless object-oriented application framework. </title> <journal> Structured Programming, </journal> <volume> Vol1 No. </volume> <month> 2 </month> <year> 1989. </year>
Reference-contexts: Graphical user interface toolkits allow an interactive graphical interface to be created by composing small interactive objects (widgets) into a complete interface for given application. The neighboring relationships between such objects are often captured with inter-object references which may be cyclic <ref> [ET++89] </ref>. The area of concern for Glide, interfaces for GBVLs, is another application area in which these kinds of structures are needed, as the description of Glide in the previous chapter has already illustrated. Classical notations for defining the structure of programming languages are essentially describing tree-based structures.
Reference: [F86] <author> F. Feldbrugge and K. Jensen. </author> <title> Petri Net Tools Survey. Petri Nets: Central Models and Properties. </title> <booktitle> In Advances in Petri Nets, pages 2061, </booktitle> <address> Berlin, 1986. </address> <publisher> Springer-Verlag. LNCS 254. </publisher>
Reference-contexts: Others variations and many visual programing tools which provide simulation and animation are described in the proceedings for Petri Net workshops <ref> [F86] </ref>. State T ransition Systems : A graph-based way of representing finite state automata is through transition network diagrams. In these diagrams, every state of a system is represented by a separate node and edges between nodes are labeled with input symbols representing transitions that can occur between states.
Reference: [FA90] <author> D. Workman F. Arefi, C. Hughes. </author> <title> Automatically generating visual syntax-directed editors. </title> <journal> Communications of the ACM, </journal> <volume> 33(3), </volume> <month> March </month> <year> 1990. </year>
Reference: [FLS93] <institution> Workshop on State in Programming Languages (SIPL), </institution> <address> June 12 Copenhagen, Denmark.. </address>
Reference-contexts: The problem of dealing with state and functional languages continues to receive attention in research on functional languages <ref> [FLS93] </ref>. 5.3 Abstract Data Types Work on the formal specification of abstract data types is similar to the work in functional languages in that both strive for concise declarative abstract descriptions of data types and functions operating on them.In the same spirit as functional descriptions, the algebraic approach to specifying abstract
Reference: [Fol93] <author> J. Foley. </author> <title> A Second Generation User Interface Design Environment: The Model and the Runtime Architecture. </title> <booktitle> Proceedings of CHI 93. </booktitle>
Reference-contexts: This approach, that the interface should not get in the way of the user, has repeatedly been advocated in the of user interface research community <ref> [AYC88, Sze93, Fol93, ShuFol] </ref>. 1.3 Results The results of this work are a set of concepts for characterizing graph-based visual languages and a set of abstractions embodied in the Glide specifi 5 cation language for specifying them and their programming environments.
Reference: [GDr93] <author> Graph Drawing 93. </author> <booktitle> ALCOM International Workshop on Graph Drawing and Toplogical Graph Algorithms. </booktitle> <month> September </month> <year> 1993. </year> <note> Paris. </note>
Reference: [GH80] <author> J. Guttag and J. Hornig. </author> <title> Formal specification as a design tool. </title> <booktitle> In Proc. 7th Symp. Principles of Programming Lang.. ACM, </booktitle> <year> 1980. </year> <note> [GH78]. </note> <author> J. Guttag and J. Horning. </author> <title> The Algebraic Specification of Abstract Data Types. </title> <journal> Acta. Inform., </journal> <volume> vol. 10. </volume> <year> 1978. </year>
Reference: [Got89] <author> H. Gottler, </author> <title> Graph grammars, a new paradigm for implementing visual languages. </title> <booktitle> In Eurographics89, </booktitle> <pages> pages 505516, </pages> <year> 1989. </year>
Reference: [Got92] <author> H. Gottler, </author> <title> Diagram editors = graphs + attributes + graph grammars. </title> <journal> Int. J Man-Machine Studies (1992) 37,481-502. </journal>
Reference: [GNV88] <author> E. Gansner, S. North, and K. Vo. </author> <title> Dag - a program that draws directed graphs. </title> <journal> Software Experience and Practice, </journal> <volume> 18(11):1047106210471062, </volume> <month> November </month> <year> 1988. </year>
Reference-contexts: After an evaluation of available graph widgets, the dot/dag graph display libraries were integrated into Tk for the demonstration system <ref> [GNV88] </ref>. The Tk library has good support for dynamically creating and modifying nested widgets through the use of frame widgets for composing widgets together and treating them as a unit. <p> XSIM has been used as a front end a Generalized Timed Petri Nets (GTPN) simulator. [Tho90] DAG - The DAG system is described by Gansner , North, and V o in <ref> [GNV88] </ref>. It describes various layout strategies and performance statistics for them. This package and it successor was used in Glider. 180 GMB - The GMB graph display system was created in the context and managing software in the Faust software programming environment for developing supercomputing applications.
Reference: [Grahm] <author> M. Vanter, S. Graham, R, Ballance. </author> <title> Coherent user interfaces for language-based editing. </title> <journal> Int. J. of Man-Machine Studies No 37 1992 pp. </journal> <pages> 431-466. </pages>
Reference-contexts: Some large systems were developed including Gandalf [ea85] and the Cornell Program Synthesizer (CPS) [ref TR81], and more recently Centaur [Klint93], and Pan <ref> [Grahm] </ref>. These systems are text language-based systems. Generation of the programming environment is based upon a specification of the syntax and semantics of the language in some meta language (the meta-syntactic formalism in the case of CPS and the 20 language description language in the case of Pan).
Reference: [GS92] <author> E. P. Glinert and P. D. Stotts. </author> <title> Special issue on visual languages and 186 concurrent computing. </title> <journal> Journal of Visual Langauges and Computing, </journal> <volume> 3(2), </volume> <month> June </month> <year> 1992. </year>
Reference: [Har87] <author> David Harel. Statecharts: </author> <title> A Visual Formalism for Complex Systems. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 8:231274, </address> <year> 1987. </year>
Reference: [Har88] <author> D. Harel. </author> <title> On visual formalisms. </title> <journal> Communications of ACM, </journal> <volume> 31(5):514529, </volume> <month> May </month> <year> 1988. </year>
Reference: [HC88] <author> A. Hough and J. Cuny. </author> <title> Initial experiences with a pattern-oriented parallel debugger. </title> <booktitle> In Proceedings of the 1988 Workshop on Parallel and Distributed Debugging, pages 195205. ACM, </booktitle> <year> 1988. </year> <note> also SIGPLAN Notices 24(1). </note>
Reference: [HC90] <author> A. Hough and J. Cuny. </author> <title> Perspective views: A technique for enhacing parallel program visualization. </title> <type> Coins Technical Report 90-02, </type> <institution> University of Massachusetts at Amherst, </institution> <month> January </month> <year> 1990. </year>
Reference: [HE91] <author> Michael Heath and Jennifer Etheridge. </author> <title> Visualizing the performance of parallel programs. </title> <journal> IEEE Software, </journal> <pages> pages 2939, </pages> <month> September </month> <year> 1991. </year>
Reference: [HH&N92] <author> J. Hummel, L. Hendren, A. Nicolau. </author> <title> A language for conveying the aliasing properties of dynamic, pointer-based data structures. </title> <booktitle> International Conference on Parallel Processing 1992. </booktitle>
Reference-contexts: If the compiler can identify the type or the absence of dependencies it may then be possible to partition a program into independent pieces which can be executed separately. Most of this work has focused on array dependencies but Hummel, Hendern and Nicolau <ref> [HH&N92] </ref> have examined the problem in the context of arbitrary (pointer-based) C data structures. In these structures, dependencies due to sharing (the term used here isaliasing) can preclude parallelization. The scheme used by HH&N is in effect the dual of Glide shape predicates.
Reference: [Him89] <author> Michael Himsolt. Graphed: </author> <title> An interactive graph editor. </title> <booktitle> In STACS 89, </booktitle> <year> 1989. </year>
Reference-contexts: Though most the work in this area has dealt with classifying and finding properties of different classes of graph grammars, practical systems have also been built. The GraphEd system <ref> [Him89] </ref> is an interactive visual environment within which collections of graph rewriting rules of different classes can be defined and applied to sample graphs. The IPSEN system is a complete software development system (CASE tool) based on the graph rewriting concept [IPSEN92].
Reference: [HO] <author> Jack Hagemeister and Paul Oman. </author> <title> Powerful CASE on the Mac. product review, </title> <note> IEEE Computer July 1992. </note>
Reference: [Hoare75] <author> C.A.R. Hoare. </author> <title> Recursive data structures. </title> <journal> Intl. Journal of Computing and Information Sciences. </journal> <volume> Vol. 4, No. </volume> <month> 2 </month> <year> 1975. </year>
Reference-contexts: The dereferencing operator and this annotation bring to the surface an aspect of the implementation which would ideally be hidden <ref> [Hoare75] </ref>. A recursive type does not restrict the size (length) of the instances. This introduces the issue of dynamic structures whose size is only known at runtime and may vary during the course of program execution. <p> This essentially involves avoiding the explicit use of pointers, as is done in Glide and is advocated in <ref> [Hoare75] </ref>.
Reference: [Hun90] <author> N. Hunt. Idf: </author> <title> A graphical data flow language for image processing and computer vision. </title> <booktitle> In IEEE Conf. on Systems, Man, and Cybernetics. IEEE, </booktitle> <month> Nov </month> <year> 1990. </year>
Reference: [Int85] <institution> Xerox Artificial Intelligence Systems, Pasadena, CA. </institution> <note> Interlisp-D Reference Manual, </note> <month> October </month> <year> 1985. </year>
Reference-contexts: A number of earlier systems exist, notably the ones developed on interactive lisp workstations such as the ISI Grapher [Rob87] and the Interlisp Grapher <ref> [Int85] </ref>. Some experiments have been performed by MacKinlay et al. at Xerox with the display of graphs in 3D.
Reference: [IPSEN92] <author> G. Engels, C. Lewerentz, M. Nagl, W. Schafer, A. Schurr. </author> <title> Building Integrated Software Development Environments Part1: Tool Specification. </title> <journal> In ACM Transactions on Software Engineering and Methodology, April, </journal> <volume> Vol. 1, No. 2, </volume> <pages> 125-167, </pages> <year> 1992. </year>
Reference-contexts: The GraphEd system [Him89] is an interactive visual environment within which collections of graph rewriting rules of different classes can be defined and applied to sample graphs. The IPSEN system is a complete software development system (CASE tool) based on the graph rewriting concept <ref> [IPSEN92] </ref>. The Delta system is a model of parallel computation in which parallel programs can be defined with graph grammars [Delta91]. The ParaGraph system is an example of using graph grammars to concisely specify regular communications patterns used in parallel algorithms [BCL90].
Reference: [ITCL94] <author> M.. McLennan, </author> <title> Object-Oriented Programming with [incr Tcl]. </title> <booktitle> Seminar at Tcl/Tk Workshop June 20-25, 1994, </booktitle> <address> in New Orleans, LA. </address>
Reference-contexts: Tcl also provides a tight and elegant interface to its associated GUI library Tk. This substrate allows the generated programs to be small and fairly simple. Tcl also has various objectoriented extensions, one of which, itcl, was used as the implementation language for PINs in the demonstration system <ref> [ITCL94] </ref>. The Tcl/Tk target environment was chosen for speed and ease of development of the demonstration system. GUI Libraries GUI libraries are still undergoing rapid change, but a number of standard libraries that are in widespread use have emerged over the last few years.
Reference: [J88] <editor> David Jablonowski et al. </editor> <booktitle> GMB - In ACM SIGGRAPH Symposium on User 187 Interface Software, </booktitle> <address> Banff, Canada, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: This package and it successor was used in Glider. 180 GMB - The GMB graph display system was created in the context and managing software in the Faust software programming environment for developing supercomputing applications. GMB was used for such things as the display of file compilation dependencies (makefiles). <ref> [J88] </ref> [JG89] [Jab90]. GUIDE II - Guide is an internal product of Scientific and Engineering Software Inc.
Reference: [Jab90] <author> David Jablonowski. </author> <title> Gmb: Graph manager / browser. </title> <type> Technical Report CSRD 968, </type> <institution> Center for Supercomputing Research and Development, Univ. of Illinois, </institution> <month> February </month> <year> 1990. </year>
Reference-contexts: GMB was used for such things as the display of file compilation dependencies (makefiles). [J88] [JG89] <ref> [Jab90] </ref>. GUIDE II - Guide is an internal product of Scientific and Engineering Software Inc. It is one of the few systems that provides a high level of functionality for both graph display and manipulation and other more standard interactors such as tables and menus, integrated in the same package.
Reference: [Jac85] <author> R. J. K. Jacob. </author> <title> A state transition diagram language for visual programming. </title> <booktitle> Computer, </booktitle> <address> 18(8):5159, </address> <month> August </month> <year> 1985. </year>
Reference-contexts: In this model the current state is represented by one node and not distributed over many nodes. More complex variations of this basic model have been developed. For example the system described in <ref> [ShuJLin, Jac85] </ref> is a transition network diagram model for specifying interaction in user interfaces. In this model there are several types of links which represent dif ferent types of transitions (e.g., user input, interface output, function invocation). Another example is modelling communications protocols.
Reference: [JG89] <author> David Jablonowski and Vincent Guarana. </author> <title> Gmb - a tool for manipulating and animating graph structures. </title> <journal> Software Practice and Experience, </journal> <volume> 19(3):283301, </volume> <month> March </month> <year> 1989. </year>
Reference-contexts: GMB was used for such things as the display of file compilation dependencies (makefiles). [J88] <ref> [JG89] </ref> [Jab90]. GUIDE II - Guide is an internal product of Scientific and Engineering Software Inc.
Reference: [JM88] <author> A. Jahanian and A. Mok. Modechart: </author> <title> A specification language for real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <year> 1988. </year>
Reference-contexts: The model is based on state transition model and is intended to model socalled reactive systems. Reactive systems are systems which must respond to external events. Many variations of this model have been developed including, for example, Modecharts for modeling real time systems <ref> [JM88] </ref>. Data Flow: The data ow model of computation is a graph-based model of computation which is intended to expose the maximum available parallelism.
Reference: [K&S93] <author> N. Klarlund, M. Schwartzbach. </author> <title> Graph Types. </title> <booktitle> POPL 1993. </booktitle>
Reference-contexts: This resembles the Miranda view of cyclic structures as infinite structures. The repeating pattern is similar to the notion of congruences of Levy. Solutions of Moller and Levy require a high degree of comfort with abstract algebraic techniques. Graph Types More recent work by Klarlund and Schwarzbach <ref> [K&S93] </ref> also examines the problem of capturing cyclic structures as a data type (which they term graph types). The authors provide a simpler yet effective way of formalizing at least a subset of graph structures as abstract data types.
Reference: [Kan90] <author> Elaine Kant. </author> <title> Automated program synthesis. </title> <booktitle> Industry Leaders in Computer Science and Electrical Engineering Distinguished Lecture Series Video, </booktitle> <month> May </month> <year> 1990. </year> <note> University Video Communications. </note>
Reference: [KidSim94] <author> D. Smith, A. Cypher, J. Spohrer; KIDSIM: </author> <title> Programming Agents without a Programming Langauge. </title> <booktitle> Commuincations of the ACM July 1994, </booktitle> <pages> pages 55-66. </pages>
Reference-contexts: They further exploit a human users familiarity with objects in the physical world by giving the illusion of direct manipulation of physical objects by means of graphical objects on the screen. Examples of this are the programming by demonstration visual programming systems such as Programming by Rehearsal [ShuPBH], KidSim <ref> [Kidsim94] </ref>, and the Alternative Reality Kit [AltReal88]. All visual languages share the need for a programming environment - an interactive graphical user interface which is used to create and manipulate visual language programs. Early visual language systems required extensive custom graphics software to be realized.
Reference: [KKS88] <author> Hyoung-Joo Kim, Henry F. Korth, and Avi Silberschatz. Picasso: </author> <title> A graphical query langauge. </title> <journal> Software Practive and Experience, </journal> <volume> 18(3):169203, </volume> <month> March </month> <year> 1988. </year>
Reference: [Klint93] <author> P. </author> <title> Klint A Meta-Environment for Generating Programming Environments. </title> <booktitle> ACM Transaction on Software Engineering Methodology Vol 2, </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: Some large systems were developed including Gandalf [ea85] and the Cornell Program Synthesizer (CPS) [ref TR81], and more recently Centaur <ref> [Klint93] </ref>, and Pan [Grahm]. These systems are text language-based systems.
Reference: [KN90] <author> D. Kimelman and T. Ngo. </author> <title> Program visualization for rp3: An overview. </title> <type> Technical Report RC 15917, </type> <institution> IBM T.J. Watson Research Center, </institution> <month> July </month> <year> 1990. </year>
Reference: [KS84] <author> P. Kruchten and E Schonberg. </author> <title> The ada/ed system: A large scale experiment in software protoyping. </title> <institution> Technique et science informatiques, 3(3):179185, </institution> <year> 1984. </year>
Reference: [KS90] <author> A. Karrer and W. Scacchi. </author> <title> Requirements for an extensible object-oriented tree/graph editor. </title> <booktitle> In Proceedings of ACM Third Annual Symposium on User Interface Software and Technology, </booktitle> <pages> pages 8491, </pages> <year> 1990. </year>
Reference-contexts: The paper by Karrer and Scacchi provides a description of the essential requirements for a general tool graph interface library and point out the dif ficulties of trying to use one of the existing packages to implement a real system ( e.g,. the need to be able to store graphs). <ref> [KS90] </ref> XSIM - A simple but ef fective package. XSIM provides support for agging syntactic errors and generating the textual representation of a graph suitable for input to other programs.
Reference: [Lam90] <author> L. Lamport. </author> <title> A temporal logic of actions. </title> <type> Tech. Report 57, </type> <institution> Digital Research Center, </institution> <year> 1990. </year>
Reference-contexts: The graph has the same meaning no matter where the nodes and links are placed - it is only their interconnection that matters. However, just as in text languages with no formatting 1 , it is difficult to read a poorly laid out graph 2 1 See Lamport <ref> [Lam90] </ref> for an illustration of the importance of formatting in text languages - the introduction discusses about how important formatting (i.e. layout) is in programs vs. in mathematical expressions. 14 The objects that are connected into a graph also often have further structure in the form of attributes or components.
Reference: [Lan87] <author> D. Lange. </author> <title> A formal approach to hypertext using post-prototype formal specification. </title> <address> INTERCHI 188 </address>
Reference: [LD85] <author> Ralph L. London and Robert A. Duisberg. </author> <title> Animating Programs Using Smalltalk. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 6171, </pages> <month> August </month> <year> 1985. </year>
Reference: [LER92] <author> T.G. Lewis and H. El-Rewini. </author> <title> Introduction to Parallel Computing, chapter 12. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year> <title> [Lev92]. M.R. Levy Data types with sharing and circularity Ph.D. </title> <type> Thesis Dept. </type> <institution> of Computer Science, University of Waterloo 1978. </institution>
Reference: [LMCF90] <author> T. LeBlanc, J. Mellor-Crummey, and R. Fowler. </author> <title> Analyzing parallel program executions using multiple views. </title> <type> Technical Report TR90-110, </type> <institution> Rice University, </institution> <month> January </month> <year> 1990. </year>
Reference: [Loy91] <author> Joseph Patrick Loyall. </author> <title> Specification of Concurrent Systems Using Graph Grammars. </title> <type> PhD thesis, </type> <institution> Dept. of Comp. Sci., Univ. of Illinois, Urbana-Champaign, </institution> <month> May </month> <year> 1991. </year>
Reference: [MDB87] <author> B. H. McCormick, T. A. DeFanti, and M. D. Brown. </author> <title> Special issue on visualization in scientific computing. </title> <journal> Computer Graphics, </journal> <volume> 21(6), </volume> <month> November </month> <year> 1987. </year>
Reference: [Mey90] <author> B. Meyer. </author> <title> Introduction to the Theory of Programming Languages. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: The productions that make up a Glide 27 grammar will be mostly referred to here as productions, though on some occasions the term type will be used to emphasize the latter point of view. The Metanot notation was developed by Meyer in <ref> [Mey90] </ref> in order to specify language syntax and semantics. In Metanot, a text language is described by modelling a language as a collection of complex structured types. This forms the basis for defining their semantics.
Reference: [MK92] <author> J. Magee and J. Kramer. </author> <title> Mp: A programming environment for multicomputers. </title> <booktitle> In Proc. of Working Conference on Programming Environments for Parallel Computing, </booktitle> <address> Edinburgh, April 1992. </address> <publisher> Springer-Verlag. IFIP WG10.3. </publisher>
Reference: [Min92] <editor> Interacting with structure-oriented editors. </editor> <booktitle> Int. J Man-Machine Studies (1992) 37,399-418 </booktitle>
Reference-contexts: This is different from using a plain text editor in which the user only manipulates arbitrary (semantics-free) character strings. In <ref> [Min92] </ref> it is argued that this kind of direct manipulation (of instances of terminals and nonterminals) is the correct approach to designing structure-based language editors and that reinforcing this approach in the view of the user (e.g., by not insisting on a top-down or bottom-up order of editing operations) can overcome
Reference: [Mol85] <author> B. </author> <title> Moller On the algebraic specification of infinite objects - ordered and continuous models of algebraic types in Acta Informatica 22 p.537-578 1985. </title>
Reference-contexts: Sets of equations are used to characterize sharing in instances of a type. These sets of equations play a similar role to that of the shape predicates of Glide in characterizing the loops. Moller <ref> [Mol85] </ref> also addresses the problem of shared and cyclic structures from an abstract mathematical perspective on algebraic specification. He proposes a solution to the inability of algebraic formalisms to describe graph structures in which a graph is characterized as a repeating pattern in an infinite tree.
Reference: [Mot93] <author> V. </author> <title> Quercia, </title> <journal> T.OReilly Volume 3M: </journal> <note> X Window System Users Guide:Motif Edition 2nd Edition January 1993 ISBN: 1-56592-015-5. </note>
Reference-contexts: The Tcl/Tk target environment was chosen for speed and ease of development of the demonstration system. GUI Libraries GUI libraries are still undergoing rapid change, but a number of standard libraries that are in widespread use have emerged over the last few years. These standard libraries, such as (Motif <ref> [Mot93] </ref>, Microsoft Windows [MSWin], 118 and Macintosh System 7.x) have a great deal in common. They provide similar forms of user interaction widgets such as command menus, pop-up menus, check boxes, type-in dialog boxes, etc.
Reference: [MR92] <author> Brad A. Myers and Mary Beth Rosson. </author> <title> Survey on user interface programming. </title> <type> Tech. </type> <institution> Rpt. CMU-CS-92-113, Carnegie-Mellon, School of Comp. Sci., </institution> <month> February </month> <year> 1992. </year> <note> To appear in Proceedings SIGCHI92. </note>
Reference: [MSWin] <author> C. Petzold, </author> <title> Programming Windows 3.1, </title> <publisher> Microsoft Press Books - ,ISBN: </publisher> <address> 1-55615-395-3, </address> <year> 1992. </year>
Reference-contexts: GUI Libraries GUI libraries are still undergoing rapid change, but a number of standard libraries that are in widespread use have emerged over the last few years. These standard libraries, such as (Motif [Mot93], Microsoft Windows <ref> [MSWin] </ref>, 118 and Macintosh System 7.x) have a great deal in common. They provide similar forms of user interaction widgets such as command menus, pop-up menus, check boxes, type-in dialog boxes, etc.
Reference: [Nat87] <institution> National Instruments Corp., 12109 Technology Blvd. Austin, Texas. LabVIEW: a demonstration, </institution> <year> 1987. </year>
Reference: [NB92] <author> P. Newton and J. C. Browne. </author> <title> The Code2.0 graphical parallel programming 189 language. </title> <booktitle> In Proc. ACM Intl. Conf on Supercomputing, </booktitle> <month> July </month> <year> 1992. </year>
Reference: [New94] <author> Peter Newton. </author> <title> A Graphical Targetable Parallel Programming Environment and its Efficient Implementation. </title> <type> PhD thesis, </type> <institution> Dept. of Comp. Sci., The University of Texas at Austin, </institution> <year> 1994. </year>
Reference-contexts: Each AST node class contains methods which may be invoked for the particular pass. Using an objectoriented design for a compiler is becoming more common with the widespread availability of objectoriented programming languages (OOPLs) such as C++ (e.g., <ref> [New94] </ref>). This modular design has several benefits. The standard benefit of programs written in an objectoriented manner, that they are more easily modified and extended, makes changing and extending the Glide language simpler. The design also allows the generator to be more easily retargetable.
Reference: [NUH89] <author> H. Kawata N. Uchihira and S. Honiden. </author> <title> A concurrent program synthesis using petri net and temporal logic in mendels-zone. </title> <type> Tech. Rep. 449, </type> <institution> ICOT, </institution> <month> Jan </month> <year> 1989. </year>
Reference: [Nut91] <author> G. Nutt. </author> <title> A simulation system architecture for graph models. </title> <booktitle> In Advances in Petri Nets, </booktitle> <address> Berlin, 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference: [OMT91] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, W. Lorensen. </author> <title> Object-oriented modeling and design, </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Many visual languages are based on the composition of objects into a graph but then also make use of 2D graphical features in order convey further semantics. Typical of these are the various objectoriented design notations such as Rumbaughs Object Modelling Technique <ref> [OMT91] </ref>, the Booch notation [Boo94], and the Shlaer/Mellor design language [ShM88]. These notations are all collections of graph-based visual languages which are overlaid with text and graphical features (e.g. iconic shapes). These features may have a particular meaning and their 2D spatial placement can be significant.
Reference: [OPP89] <author> Joseph Oliger, Ramani Pichumani, and Dulce Poceleon. </author> <title> A visual object-oriented unification system. </title> <type> Technical report, </type> <institution> Center for Large Scale Computing, Dept. Comp Sci., Stanford Univ., </institution> <year> 1989. </year>
Reference: [Oust94] <author> J. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <address> Adison-Wesley, Reading MA, </address> <year> 1994 </year>
Reference-contexts: to accommodate this composition-oriented approach, graphical attributes can contain path expressions which provide a means to reflect the graphical properties of the subobject (in this case,transition or place) in the superobject (in this caseNode). 5 In this case the widget properties of the Tk API of the Tcl/Tk GUI toolkit <ref> [Oust94] </ref>. 82 Operationally, the values of graphical attributes are combined with the result of a query (query trees) and passed as more complex data structure (the glider display tree) to the runtime rendering module. <p> BindMethod:procedure bindV3 () Root CodeTemplate: BindMethod: 117 6.3 Target Runtime Environment In the demonstration system that was built, the Glider compiler generates programs in the interpreted languageTcl and the Glider RTL consists of programs implemented in a combination of C and Tcl and they use the GUI Library Tk <ref> [Oust94] </ref>. Though the demonstration system has been implemented to target this particular substrate, the compiler is designed, as has just been described, to allow easy retargeting to other substrates (e.g., C/C++/Motif). It is possible to target both compiled and interpreted languages.
Reference: [Pan91] <author> Bhalchandra Shankar Pandit. </author> <title> A syntax directed editor for code. </title> <type> Masters thesis, </type> <institution> Dept. of Comp Sci., Univeristy of Texas at Austin, </institution> <year> 1991. </year>
Reference: [Pau88] <author> Frances Newberry Paulisch. </author> <title> An interface description language for graph editors. </title> <booktitle> In Workshop on Visual Languages. IEEE, </booktitle> <year> 1988. </year>
Reference-contexts: The following ones have either been described in the literature or are publicly available: EDGE The EDGE system was first described in <ref> [Pau88] </ref> and forms the basis of a thesis by Paulisch [EDGE90]. EDGE is objectoriented (implemented in C++) so that the classes, node and edge can be specialized, adding attributes which define the application. Both edges and links can be labelled.
Reference: [Pau] <author> L. Paulson. </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press. </publisher>
Reference: [Pet81] <author> J. Peterson. </author> <title> Petri net theory and the modeling of systems. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliff, </address> <year> 1981. </year>
Reference-contexts: It illustrates how widespread the use of a graph abstraction is in models of software systems. Petri Nets: A well known simple example of a graph-based model is Petri Nets <ref> [Pet81] </ref>. The Petri Net model is a parallel model of computation which is used to model the coordinated behavior of devices. Petri Nets are bipartite graphs; there are two kinds of nodes, transition nodes and place nodes, and there is one kind of directed link.
Reference: [PL88] <author> Uwe Pleban and Peter Lee. </author> <title> An automatically generated, realistic compiler for an imperative language. </title> <booktitle> In SIGPLAN 88 Conference on Language Design and Implementation, </booktitle> <pages> pages 222227, </pages> <address> Atlanta Georgia, </address> <month> June </month> <year> 1988. </year> <note> ACM. </note>
Reference: [Pou94] <author> A. Poulovassilis, M. Levine. </author> <title> A nested-graph model for the representation and manipulation of complex objects. </title> <journal> ACM Transactions on Informations Systems Vol 12 No. </journal> <month> 1 Jan </month> <year> 1994 </year> <month> pages35-68. </month>
Reference: [PT90] <author> Frances Newberry Paulisch and Walter F. Tichy. </author> <title> Edge: An extendible graph editor. </title> <journal> Software-Practice and Experience, </journal> <volume> S1(20), </volume> <month> June </month> <year> 1990. </year>
Reference: [RC89] <author> G. Roman and K. Cox. </author> <title> A declarative approach to visualizing concurrent computations. </title> <journal> IEEE Computer, </journal> <note> 1989. </note> <author> [RDM + 87] L. Rowe, M. Davis, E. Messinger, C. Meyer, C. Spirakis, and A. Tuan. </author> <title> A browser for directed graphs. </title> <journal> Software Practice and Experience, </journal> <volume> 190 </volume>
Reference: [Rob87] <author> Gabriel Robins. </author> <title> The ISI grapher: A portable tool for displaying graphs pictorially. </title> <booktitle> In Symboliikka 87, </booktitle> <address> Helsinki, Finnland, </address> <month> August </month> <year> 1987. </year> <title> Also Chp 12. Multicomputer Vision, </title> <publisher> 1988 Academic Press. </publisher>
Reference-contexts: A number of earlier systems exist, notably the ones developed on interactive lisp workstations such as the ISI Grapher <ref> [Rob87] </ref> and the Interlisp Grapher [Int85]. Some experiments have been performed by MacKinlay et al. at Xerox with the display of graphs in 3D.
Reference: [RTB88] <author> Enrico Nardelli Roberto Tamassia and Carlo Batini. </author> <title> Automatic Graph Drawing and Readability of Diagrams. </title> <journal> IEEE Transactions on Systems, Man and Cybernetics, </journal> <volume> 18(1):6179, </volume> <month> January-February </month> <year> 1988. </year>
Reference-contexts: The problem of ef ficient of 2D layout algorithms for readable graph displays has received exten sive attention (see surveys by Harel [DH89] and Tammasia <ref> [RTB88] </ref>, and an analysis of the problem in [ET89]. Many of these algorithms have already been incorporated into some the graph GUI tools such as EDGE and XGRAB. 181
Reference: [SBN88] <author> D. Socha, M. Bailey, and D. Notkin. Voyeur: </author> <title> Graphical views of parallel programs. </title> <booktitle> In Proceedings of the 1988 Workshop on Parallel and Distributed DebuggingIEEE Workkshop On Visual Languages, pages 206215, </booktitle> <address> New York,NY, </address> <year> 1988. </year> <note> ACM. also SIGPLAN Notices 24(1). </note>
Reference: [SBY87] <author> R. G. Smith, P. S. Barth, and R. L. Young. </author> <title> A Substrate for Object-Oriented Interface Design. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions In Object-Oriented Programming, </booktitle> <pages> pages 253315. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference: [ShM88] <author> S. Shlaer, S. Mellor. </author> <title> Object-oriented systems analysis : modeling the world in data, </title> <publisher> N.J.,Yourdon Press, </publisher> <address> Englewood Cliffs, </address> <year> 1988. </year>
Reference-contexts: Typical of these are the various objectoriented design notations such as Rumbaughs Object Modelling Technique [OMT91], the Booch notation [Boo94], and the Shlaer/Mellor design language <ref> [ShM88] </ref>. These notations are all collections of graph-based visual languages which are overlaid with text and graphical features (e.g. iconic shapes). These features may have a particular meaning and their 2D spatial placement can be significant.
Reference: [Shu] <author> Nan C. Shu, </author> <title> Visual Programming, </title> <publisher> Van Nostrand Rheinhold, </publisher> <address> NY, </address> <year> 1988. </year>
Reference: [ShuQBE] <author> Nan C. Shu, </author> <title> Chapter 11, Visual Programming, </title> <publisher> Van Nostrand Rheinhold, </publisher> <address> NY, </address> <year> 1988. </year>
Reference-contexts: An early example of this is the tabular specification interfaces of Query-by-Example database interfaces <ref> [ShuQBE] </ref>. This form of visual language makes use of vertical and horizontal alignment to convey common relationships between objects. At the time these interfaces were created they were considered visual language interfaces, but by current standards they would no longer be considered very graphical.
Reference: [ShuFol] <author> J.D. </author> <title> Foley in Visual Programming, </title> <editor> Nan C. Shu ed., </editor> <title> page 17: When a person uses an interactive graphics system to do real work, he wants the system to virtually disappear from his conciousness so that only his work and its ramification have a claim on his energy </title>
Reference-contexts: This approach, that the interface should not get in the way of the user, has repeatedly been advocated in the of user interface research community <ref> [AYC88, Sze93, Fol93, ShuFol] </ref>. 1.3 Results The results of this work are a set of concepts for characterizing graph-based visual languages and a set of abstractions embodied in the Glide specifi 5 cation language for specifying them and their programming environments.
Reference: [ShuGRASE] <author> Nan C. </author> <title> Shu Chapter 9, Visual Programming, </title> <publisher> Van Nostrand Rheinhold, </publisher> <address> NY, </address> <year> 1988. </year>
Reference-contexts: The GRASE visual programming system is really a syntax-directed editor for a textual language (Pascal) which is graphically presented through variants of Nassi-Schneiderman diagrams <ref> [ShuGRASE] </ref>. Nassi-Schneiderman diagrams are recursive diagrams which divide a 2D rectangular space into triangular or rectangular parts. Each part represents a different syntactic component of a production of the syntax of a textual language. Each part can be recursively subdivided to represent the expansion of a production into components.
Reference: [ShuJLin] <author> Nan C. </author> <title> Shu Chapter 9, Visual Programming, </title> <publisher> Van Nostrand Rheinhold, </publisher> <address> NY, </address> <year> 1988. </year>
Reference-contexts: In this model the current state is represented by one node and not distributed over many nodes. More complex variations of this basic model have been developed. For example the system described in <ref> [ShuJLin, Jac85] </ref> is a transition network diagram model for specifying interaction in user interfaces. In this model there are several types of links which represent dif ferent types of transitions (e.g., user input, interface output, function invocation). Another example is modelling communications protocols.
Reference: [ShuPBH] <author> Nan C.. Shu, </author> <title> Chapter 5, Visual Programming, </title> <publisher> Van Nostrand Rheinhold, </publisher> <address> NY, </address> <year> 1988. </year>
Reference-contexts: They further exploit a human users familiarity with objects in the physical world by giving the illusion of direct manipulation of physical objects by means of graphical objects on the screen. Examples of this are the programming by demonstration visual programming systems such as Programming by Rehearsal <ref> [ShuPBH] </ref>, KidSim [Kidsim94], and the Alternative Reality Kit [AltReal88]. All visual languages share the need for a programming environment - an interactive graphical user interface which is used to create and manipulate visual language programs. Early visual language systems required extensive custom graphics software to be realized.
Reference: [ShuPICT] <author> Nan C. Shu, </author> <title> Chapter 10, Visual Programming, </title> <publisher> Van Nostrand Rheinhold, </publisher> <address> NY, </address> <year> 1988. </year>
Reference-contexts: Animation is the use of dynamic graphics to convey the execution behavior of a program. An example of a visual language in which programs are animated to illustrate execution is PICT <ref> [ShuPICT] </ref>. All visual languages share the need for graphics primitives to support the implementation of their programming environments, so it has been natural to further exploit the primitives to support animation.
Reference: [ShuVLdef] <editor> Definition of Visual Programming in Nan C. </editor> <title> Shu, Visual Programming: : Visual Programming - the use of meaningful graphic representations in the process of programming </title>
Reference-contexts: Research into visual languages is aimed at finding ways of exploiting graphical displays to efficiently mediate communication. This involves making use of two or three spatial di 9 mensions, color, icons, animation, and any other meaningful graphic representations <ref> [ShuVLdef] </ref> for which the human visual system has a natural affinity. Research into visual programming languages, however, is more specifically aimed at finding graphical means other than the conventional linear sequence of ASCII symbols to encode and display programs and specifications.
Reference: [Sil92] <institution> Silicon Graphics Inc. </institution> <note> Iris Explorer Users Manual, </note> <month> Jan </month> <year> 1992. </year> <month> 191 </month>
Reference: [Spi88] <author> J. Spivey. </author> <title> Understanding Z - A Specification Language and its Formal Semantics. </title> <publisher> Cambridge Univ. Press, </publisher> <year> 1988. </year>
Reference: [SS92] <author> S. Sistare. </author> <title> Data visualization and programming in the prism programming environment. </title> <booktitle> In Proc. of Working Conference on Programming Environments for Parallel Computing, </booktitle> <address> Edinburgh, April 1992. </address> <publisher> Springer-Verlag. IFIP WG10.3. </publisher> <address> [SSW + 92] D. </address> <note> Szafron, </note> <author> J. Schaeffer, P.S. Wong, E. Chan, P. Lu, and C. Smith. </author> <title> The enterprise distributed programming model. </title> <booktitle> In Proc. of Working Conference on Programming Environments for Parallel Computing, </booktitle> <address> Edinburgh, April 1992. </address> <publisher> Springer-Verlag. IFIP WG10.3. </publisher>
Reference: [Sta90] <author> John T. Stasko. </author> <title> The path-transition paradigm: A practical methodology for adding animation to program interfaces. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 1:213236, </volume> <year> 1990. </year>
Reference: [Sta91] <institution> Stardent Computer Inc. </institution> <note> AVS Reference Manual, </note> <year> 1991. </year>
Reference-contexts: our paradigm is based on representing programs as graphs... ( from Is Visual Programming a New Programming Paradigm? [CHVL 91]) There are too many examples to provide a complete list, but the follow ing are three prominent examples of graph-based visual programming lan guage environments: the network editor in AVS <ref> [Sta91] </ref>, the CODE2 parallel visual programming environment [Bro85,NB92,New94], and the graphical programming component of the LabVIEW system [Nat87,Dye89]: AVS: The data visualization tool A VS contains a network editor subsystem.
Reference: [Sto88] <author> D.P. Stotts. </author> <title> The PFG Language: Visual Programming for Concurrent Computation Expressing High-Level Visual Concurrency Structures in the PFG Kernel Language. </title> <booktitle> In Int. Conf. on Par. Proc., </booktitle> <pages> pages 7279, </pages> <month> August </month> <year> 1988. </year> <institution> Vol2: Software, Univ Maryland. </institution>
Reference-contexts: The PFG system has an underlying Petri Net based model of computation. The primitives of the kernel computation engine have been made available to allow the creation higher level constructs to implement higher-level visual languages for particular applications of the system <ref> [Sto88] </ref>. Another example of this is the Olympus sys-t e m [ N u t 9 1 ] .
Reference: [Sto90] <author> P. </author> <title> Stotts Graphical Operational Semantics for Visual Programming. in Visual Languages and Visual Programming, </title> <note> S-K Chang 1990 </note>
Reference: [STP93] <institution> Interactive Development Environments Software Through Pictures. </institution> <address> 595 Market Street San Fransisco CA94105. </address> <note> System reviewed by P. </note> <author> D. </author> <title> Stotts in Tools Review: Software through Pictures from IDE Inc. </title> <booktitle> in Journal of Visual Languages and Computing (1993) 4, </booktitle> <pages> 201-209. </pages>
Reference: [Sur82] <author> Bernard Surfin. </author> <title> Formal specification of a display oriented text editor. </title> <booktitle> Science of Computer Programming, </booktitle> <address> (1):157202, </address> <year> 1982. </year>
Reference: [Sze93] <author> P. Szelky, P. Luo, R. </author> <title> Neches Beyond Interface Builders: Model Based Interface Tools. </title> <booktitle> Human Factors in Computing Systems INTERCHI 93 pages 383-390. </booktitle> <address> Amsterdam 24-29 April 1993 </address>
Reference-contexts: This approach, that the interface should not get in the way of the user, has repeatedly been advocated in the of user interface research community <ref> [AYC88, Sze93, Fol93, ShuFol] </ref>. 1.3 Results The results of this work are a set of concepts for characterizing graph-based visual languages and a set of abstractions embodied in the Glide specifi 5 cation language for specifying them and their programming environments.
Reference: [Szw87] <author> Gerd Szwillus. </author> <title> Cegs - a system for generating graphical editors. </title> <editor> In H. Bullinger and B. Schakel, editors, </editor> <title> Human-Computer Interaction - Interact 87. </title> <publisher> Elsevier, </publisher> <year> 1987. </year>
Reference: [Tho90] <author> Gregory S. Thomas. </author> <note> Xsim 2.0 users guide. ftp cs.washington.edu, </note> <month> April </month> <year> 1990. </year> <institution> Dept. of Comp Sci. Univ Washington. </institution>
Reference-contexts: XSIM provides support for agging syntactic errors and generating the textual representation of a graph suitable for input to other programs. XSIM has been used as a front end a Generalized Timed Petri Nets (GTPN) simulator. <ref> [Tho90] </ref> DAG - The DAG system is described by Gansner , North, and V o in [GNV88]. It describes various layout strategies and performance statistics for them.
Reference: [TR81] <author> T. Teitelbaum and T. Reps. </author> <title> The cornell program synthesizer.: a syntax-directed programming environment. </title> <journal> Communications of the ACM, </journal> <volume> 24(9):563573, </volume> <month> Sept. </month> <year> 1981. </year> <month> 192 </month>
Reference: [Tur92] <author> Russel Turpin. </author> <title> Programming Data Structures in Logic. </title> <type> PhD thesis, </type> <institution> Dept. of Comp. Sci., The University of Texas at Austin, </institution> <year> 1992. </year>
Reference: [VLWks] <institution> Proceedings of the IEEE Workshop on Visual Languages: </institution> <year> 1990, </year> <booktitle> October Skokie Illinois; Proceedings of the IIEE Workshop on Visual Languages 1991, October Kobe Japan; 1994 (10th) IEEE/CS International Symposium on Visual Languages, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: A simple tally of papers in the Proceedings of IEEE Visual Language Workshops <ref> [VLWks] </ref> reflects this.
Reference: [vZMC92] <author> Lynette van Zijl, Deon Mitton, and Simon Crosby. </author> <title> A tool for graphical network modelling and analysis. </title> <journal> IEEE Software, </journal> <pages> pages 4754, </pages> <month> January </month> <year> 1992. </year>
Reference: [XTANGO] <author> J. T. Stasko. </author> <title> Tango: A framework and system for algorithm animation. </title> <booktitle> Computer v 23 n 9 Sep 1990, </booktitle> <pages> pp 27-39. </pages> <note> J. </note> <author> T. Stasko. </author> <title> Simplifying algorithm animation with Tango. </title> <booktitle> Proceedings of the 1990 IEEE Workshop on Visual Languages, </booktitle> <pages> pp 1-6. </pages>
Reference-contexts: E x a m p l e s o f s u c h s y s t e m s a r e B A L S A [ B r o 8 8 ] a n d X TA N G O <ref> [XTANGO] </ref>. These systems are used to illustrate and help explain programs and algorithms using a wide variety of graphical techniques. <p> Animation procedures In addition to the tying a graphical attribute to the value in the PIN (or, more generally, the state of the the PIN), it is also possible to register attributes which are procedures. This is similar to the path transition paradigm of <ref> [XTANGO] </ref>.
Reference: [YNTL88] <author> S. S. Yau, R. A. Nicholl, J. J.-P. Tsai, and S.-S. Liu. </author> <title> An Integrated Life-Cycle Model for Software Maintenance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(14):11281144, </volume> <month> August </month> <year> 1988. </year>
References-found: 151

