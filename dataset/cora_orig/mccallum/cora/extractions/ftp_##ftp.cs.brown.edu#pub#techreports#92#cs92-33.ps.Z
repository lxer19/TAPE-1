URL: ftp://ftp.cs.brown.edu/pub/techreports/92/cs92-33.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-92-33.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> S. Abiteboul, P. Kanellakis. </author> <title> Object Identity as a Query Language Primitive. </title> <booktitle> Proc. ACM SIGMOD, </booktitle> <pages> 159-173, </pages> <year> 1989. </year> <note> Also INRIA Tech. Rep. 1022, </note> <month> April </month> <year> 1989. </year>
Reference-contexts: Sloan Fellowship. x Dept. of Computer Science, Brown University. sr@cs.brown.edu. Work supported by ONR Contract N00014 91-J-4052, ARPA Order 8225. 1 principles of these new systems have also been investigated. For example, <ref> [1] </ref> and [17] address the expressibility of languages in this new context, and use many of the tools of typed complex structure and semantic modeling research. <p> We use object assignments <ref> [1] </ref> to provide semantics for classes with inheritance. 6 The semantics of base methods is defined using partial functions satisfying certain signature constraints.
Reference: [2] <author> E. Ashcroft, Z. Manna, A. Pnueli. </author> <title> Decidable Properties of Monadic Functional Schemas. </title> <journal> JACM, </journal> <volume> 20:3:489-499, </volume> <year> 1973. </year>
Reference-contexts: In the case of monadic schemas, the set of possible computations can be described using a context-free language. An inconsistency may be reached if this language has a non-empty intersection with a particular regular language. To handle overloading, our proof uses a modification of a technique of <ref> [2] </ref>. The decision procedure runs in O (nc 3 ) time. In the case of monadic and recursion-free schemas, we show that checking a whole schema for consistency is logspace-complete in PTIME. We reduce from the circuit value problem [24].
Reference: [3] <author> M. Atkinson, F. Bancilhon, D. DeWitt, K. Dittrich, D. Maier, S. Zdonik. </author> <title> The Object-Oriented Database System Manifesto. </title> <booktitle> Proc. First International Conference on Deductive and Object-Oriented Databases, </booktitle> <address> Japan, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction Object-oriented database systems are the focus of a great deal of current experimentation and research | for motivation and terminology see <ref> [3, 4, 22, 23, 34] </ref>.
Reference: [4] <author> F. Bancilhon. </author> <title> Object-Oriented Database Systems. </title> <booktitle> Proc. 7th ACM PODS, </booktitle> <pages> 152-162, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Object-oriented database systems are the focus of a great deal of current experimentation and research | for motivation and terminology see <ref> [3, 4, 22, 23, 34] </ref>.
Reference: [5] <author> F. Bancilhon, C. Delobel, P. </author> <title> Kanellakis (editors) Building an Object-Oriented Database System: </title> <publisher> The Story of O 2 . Morgan Kaufman, </publisher> <year> 1992. </year> <month> 37 </month>
Reference-contexts: 1 Introduction Object-oriented database systems are the focus of a great deal of current experimentation and research | for motivation and terminology see [3, 4, 22, 23, 34]. Although most of the work to-date has concentrated on system development (e.g., <ref> [5, 6, 12, 26, 33] </ref>) some of the fl A preliminary version of this paper appeared in the proceedings of the 9th ACM PODS, 1990. y INRIA, 78153 Le Chesnay Cedex, France. abitebou@inria.inria.fr, waller@seti.inria.fr. <p> In an object-oriented context, it is not reasonable to recompile all methods each time the schema is updated. The problem is to obtain an incremental consistency checking algorithm that would avoid redoing the same verifications/computations. A solution that is adopted practically (e.g., <ref> [5] </ref>) is to maintain a dependency graph of the methods and recompile only methods that may have been affected by the update. Of course, understanding what may be affected is the crucial part. This is where our analysis contributes.
Reference: [6] <author> J. Banerjee, et al., </author> <title> Data Model Issues for Object-Oriented Applications. </title> <journal> ACM TOIS, </journal> <volume> 5:1:3-26, </volume> <year> 1987. </year>
Reference-contexts: 1 Introduction Object-oriented database systems are the focus of a great deal of current experimentation and research | for motivation and terminology see [3, 4, 22, 23, 34]. Although most of the work to-date has concentrated on system development (e.g., <ref> [5, 6, 12, 26, 33] </ref>) some of the fl A preliminary version of this paper appeared in the proceedings of the 9th ACM PODS, 1990. y INRIA, 78153 Le Chesnay Cedex, France. abitebou@inria.inria.fr, waller@seti.inria.fr.
Reference: [7] <author> J. Banerjee, W. Kim, H-J. Kim, H.F. Korth. </author> <title> Semantics and Implementation of Schema Evolution in Object-Oriented Databases. </title> <booktitle> Proc. ACM SIGMOD, </booktitle> <pages> 311-322, </pages> <year> 1987. </year>
Reference-contexts: A key computational problem is: consistency maintenance of method schemas. Its solution has many applications. For example, it can be used to facilitate the support of schema evolution (e.g., <ref> [7, 28] </ref>). Let us briefly outline our formalization: Syntax: We have an isa hierarchy of classes, where each class denotes a set of objects. Each object has an associated set of methods and all objects in a class have the same methods.
Reference: [8] <author> A. Borgida. </author> <title> Type Systems for Querying Class Hierarchies with Non-strict Inheritance, </title> <booktitle> Proc. ACM PODS, </booktitle> <pages> 394-400, </pages> <year> 1989. </year>
Reference-contexts: Here, we do not examine such "structural" aspects, but focus instead on some of the "behavioral" aspects of the object-oriented paradigm | for some other recent work in this direction see <ref> [8, 18] </ref>. We propose method schemas as a simple abstraction of the object-oriented programs that are being used in most of the existing database prototypes.
Reference: [9] <author> S.A. Cook. </author> <title> Linear-time Simulation of Deterministic Two-way Pushdown Automata. </title> <booktitle> Proc. IFIP Congress, </booktitle> <pages> 172-179, </pages> <year> 1971. </year>
Reference-contexts: We present a first principles algorithm to show this linear time bound using radix trees. Initially, we showed this bound using two-way deterministic 3 pushdown automata (2dpda's) <ref> [9] </ref>. We present this proof in an appendix. In the case of recursion-free schemas, the consistency problem is coNP-complete for a single coded method with two arguments. Some special cases can be shown to be in PTIME, using tree automata techniques [11, 31].
Reference: [10] <author> B. Courcelle. </author> <title> Recursive Applicative Program Schemes. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. B, Chapter 9, </volume> <editor> (J. van Leeuwen, A.R. Meyer, N. Nivat, M.S. Paterson, D. Perrin editors), </editor> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: We provide an abstract view of flow of control based on method composition and possibly recursive method calls. We are consistent with any programming paradigm based on inheritance, overloading, and late binding. In this sense, the present work is similar to research on recursive applicative program schemas <ref> [10, 14, 25] </ref>.
Reference: [11] <author> J. E. Doner. </author> <title> Tree Acceptors and some of their Applications. </title> <journal> JCSS, </journal> <volume> 4 </volume> <pages> 406-451, </pages> <year> 1971. </year>
Reference-contexts: We present this proof in an appendix. In the case of recursion-free schemas, the consistency problem is coNP-complete for a single coded method with two arguments. Some special cases can be shown to be in PTIME, using tree automata techniques <ref> [11, 31] </ref>. Covariance does not help in the recursive case. However, in the recursion-free covariant case we show that there is a PTIME test for a fixed arity coded method. This is interesting in practice, because it motivates our heuristic for the general case. <p> Remark: If the k-terms of the methods to be checked are trees (not dag's), where each input i, for 1 i k appears at most once, consistency checking is in PTIME. This bound is obtained by generalizing the automaton technique to tree automata <ref> [11, 31] </ref>. 26 5 Covariance In this section, we consider covariance and show that it simplifies the consistency problem. We first consider simple schemas. For simple schemas, covariance is the following constraint on the signatures of base methods.
Reference: [12] <author> D. Fishman et al. </author> <title> Iris: an Object-Oriented Database Management System. </title> <journal> ACM TOIS, </journal> <volume> 5:1:46-69, </volume> <year> 1987. </year>
Reference-contexts: 1 Introduction Object-oriented database systems are the focus of a great deal of current experimentation and research | for motivation and terminology see [3, 4, 22, 23, 34]. Although most of the work to-date has concentrated on system development (e.g., <ref> [5, 6, 12, 26, 33] </ref>) some of the fl A preliminary version of this paper appeared in the proceedings of the 9th ACM PODS, 1990. y INRIA, 78153 Le Chesnay Cedex, France. abitebou@inria.inria.fr, waller@seti.inria.fr.
Reference: [13] <author> A. Goldberg, D. Robson. Smalltalk80: </author> <title> The Language and its Implementation. </title> <publisher> Addison Wesley, </publisher> <year> 1983. </year>
Reference-contexts: The operational semantics that we use can be viewed as an abstraction of a Smalltalk interpreter <ref> [13] </ref>, and is relatively straightforward. On the other hand, it is hard to statically (at compile-time) analyze methods. This difficulty is substantiated by the undecidability of consistency checking, even in our simple model. We prove undecidability by reduction from problems involving program (flowchart) schemas [25].
Reference: [14] <author> S. A. Greibach. </author> <title> Theory of Program Structures: Schemes, Semantics, </title> <booktitle> Verification. </booktitle> <volume> LNCS vol. 36, </volume> <publisher> Springer Verlag 1975. </publisher>
Reference-contexts: We provide an abstract view of flow of control based on method composition and possibly recursive method calls. We are consistent with any programming paradigm based on inheritance, overloading, and late binding. In this sense, the present work is similar to research on recursive applicative program schemas <ref> [10, 14, 25] </ref>. <p> This was first shown by Richard Hull for a different method formalism, [16]. To prove our result, we show that method schemas can simulate program (flowchart) schemas. The undecidability results then come from the undecidability results for these program schemas of [25]. See also <ref> [14] </ref> for linear recursion.
Reference: [15] <author> J. E. Hopcroft, J. D. </author> <title> Ullman Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1979. </year>
Reference-contexts: Thus, we analyze in detail the consistency problem for monadic and/or recursion-free method schemas, which happen to be decidable. We also quantify the effect of covariance, which is a widely used constraint on the signature of methods. For the various concepts used from complexity theory, see <ref> [15, 19, 20, 29] </ref> and from database theory, see [21, 30]. We briefly summarize our other results. Let n be the size of method definitions in the input method schema and c the size of the class hierarchy. <p> We intersect this grammar with the linear-sized regular grammar in Lemma 3.2. The resulting context-free grammar has size O (nc 3 ). Now, testing the emptiness of a context-free grammar can be reduced to depth first search <ref> [15] </ref>. The theorem follows. 2 We now consider the most general case. In particular, we show that the consistency problem for arbitrary schemas is undecidable. This was first shown by Richard Hull for a different method formalism, [16].
Reference: [16] <author> R. Hull, </author> <title> private communication, </title> <month> June </month> <year> 1989. </year>
Reference-contexts: The reduction is a modification of McCarthy's simulation of program (flowchart) schemas by recursive applicative program schemas [27]. Our reduction uses inheritance and name overloading in an essential fashion. Richard Hull proved undecidability of "reachability" for a different model of method schemas <ref> [16] </ref>, by reducing from the Post correspondence problem. Almost the same proof can be used for showing undecidability of consistency in our model. However, we believe that our simulation of program schemas provides some additional insights into the relationship between the theory of program schemas and method schemas. <p> The theorem follows. 2 We now consider the most general case. In particular, we show that the consistency problem for arbitrary schemas is undecidable. This was first shown by Richard Hull for a different method formalism, <ref> [16] </ref>. To prove our result, we show that method schemas can simulate program (flowchart) schemas. The undecidability results then come from the undecidability results for these program schemas of [25]. See also [14] for linear recursion.
Reference: [17] <author> R. Hull, J. Su. </author> <title> On Accessing Object-Oriented Databases: Expressive Power, Complexity, and Restrictions. </title> <booktitle> Proc. ACM SIGMOD, </booktitle> <pages> 147-158, </pages> <year> 1989. </year>
Reference-contexts: Sloan Fellowship. x Dept. of Computer Science, Brown University. sr@cs.brown.edu. Work supported by ONR Contract N00014 91-J-4052, ARPA Order 8225. 1 principles of these new systems have also been investigated. For example, [1] and <ref> [17] </ref> address the expressibility of languages in this new context, and use many of the tools of typed complex structure and semantic modeling research.
Reference: [18] <author> R. Hull, K. Tanaka, M. Yoshikawa. </author> <title> Behavior Analysis of Object-Oriented Databases: Method Structure, Execution Trees and Reachability. </title> <booktitle> Proc. 3rd Intl. Conf. on Foundations of Data Organization and Algorithms, </booktitle> <address> Paris, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: Here, we do not examine such "structural" aspects, but focus instead on some of the "behavioral" aspects of the object-oriented paradigm | for some other recent work in this direction see <ref> [8, 18] </ref>. We propose method schemas as a simple abstraction of the object-oriented programs that are being used in most of the existing database prototypes. <p> impossible to rewrite any start-redex into ? in a finite number of steps. 2 A variety of questions are important in this setting, e.g.: (1) Is a schema consistent? (2) Are there possible/certain diverging computations? (3) Is method m (at c) possibly/certainly "reachable" from m 0 (at c 0 ) <ref> [18] </ref>? We concentrate here on (1) although most of the techniques 8 that we develop can be used for studying other problems such as (2) or (3). Two properties simplify consistency checking: monadic arity and absence of recursion. A schema is monadic if all its methods have arity one.
Reference: [19] <author> N. Immerman. </author> <title> Nondeterministic Space is Closed Under Complement. </title> <journal> SIAM Journal of Computing, </journal> <month> 17 </month> <year> (1988) </year> <month> 935-938. </month>
Reference-contexts: Thus, we analyze in detail the consistency problem for monadic and/or recursion-free method schemas, which happen to be decidable. We also quantify the effect of covariance, which is a widely used constraint on the signature of methods. For the various concepts used from complexity theory, see <ref> [15, 19, 20, 29] </ref> and from database theory, see [21, 30]. We briefly summarize our other results. Let n be the size of method definitions in the input method schema and c the size of the class hierarchy. <p> We do not have to write down the complete FSA all at once. Given the base method definitions, we can compute parts of the transition function of the FSA as we need it. Thus, inconsistency is in NLOGSPACE. We now use the fact that NLOGSPACE is closed under complement <ref> [19, 29] </ref>, and conclude that consistency is in NLOGSPACE. Finally, we show that consistency of simple, monadic schemas is hard using a reduction of the reachability problem for graphs of out-degree 2 which is known to be logspace-complete in NLOGSPACE [20].
Reference: [20] <author> D.S. Johnson. </author> <title> A Catalog of Complexity Classes. </title> <note> Handbook of Theoretical Computer Science, Vol. A, Chapter 2, </note> <editor> (J. van Leeuwen, A.R. Meyer, N. Nivat, M.S. Paterson, D. Perrin editors), </editor> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: Thus, we analyze in detail the consistency problem for monadic and/or recursion-free method schemas, which happen to be decidable. We also quantify the effect of covariance, which is a widely used constraint on the signature of methods. For the various concepts used from complexity theory, see <ref> [15, 19, 20, 29] </ref> and from database theory, see [21, 30]. We briefly summarize our other results. Let n be the size of method definitions in the input method schema and c the size of the class hierarchy. <p> Finally, we show that consistency of simple, monadic schemas is hard using a reduction of the reachability problem for graphs of out-degree 2 which is known to be logspace-complete in NLOGSPACE <ref> [20] </ref>. Let G = (V; E) be a graph where each vertex has out-degree exactly 2; and for each w in V , let f (w) and g (w) be the two successors of w. Let v; v 0 be in V . <p> Thus consistency is in coNP. To show the lower bound, we use a reduction of 3SAT <ref> [20] </ref> to the schema inconsistency problem. Consider a 3SAT formula over variables fX 1 ; . . . ; X k g. The corresponding schema (C; ; 0 ; 1 ) is defined as follows: 24 1.
Reference: [21] <author> P.C. Kanellakis. </author> <title> Elements of Relational Database Theory. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. B, Chapter 17, </volume> <editor> (J. van Leeuwen, A.R. Meyer, N. Nivat, M.S. Paterson, D. Perrin editors), </editor> <publisher> North-Holland, </publisher> <year> 1990. </year> <month> 38 </month>
Reference-contexts: We also quantify the effect of covariance, which is a widely used constraint on the signature of methods. For the various concepts used from complexity theory, see [15, 19, 20, 29] and from database theory, see <ref> [21, 30] </ref>. We briefly summarize our other results. Let n be the size of method definitions in the input method schema and c the size of the class hierarchy. In the case of monadic schemas, the set of possible computations can be described using a context-free language.
Reference: [22] <author> W. Kim. </author> <title> Research Directions in Object-Oriented Database Systems. </title> <booktitle> Proc. 9th ACM PODS, </booktitle> <pages> 1-15, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Object-oriented database systems are the focus of a great deal of current experimentation and research | for motivation and terminology see <ref> [3, 4, 22, 23, 34] </ref>.
Reference: [23] <author> W. Kim, F. </author> <title> Lochovsky. Object-Oriented Concepts, Applications, and Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Object-oriented database systems are the focus of a great deal of current experimentation and research | for motivation and terminology see <ref> [3, 4, 22, 23, 34] </ref>.
Reference: [24] <author> R. E. Ladner. </author> <title> The Circuit Value Problem is Logspace Complete for P. SIGACT News 7, </title> <publisher> p18-20. </publisher>
Reference-contexts: The decision procedure runs in O (nc 3 ) time. In the case of monadic and recursion-free schemas, we show that checking a whole schema for consistency is logspace-complete in PTIME. We reduce from the circuit value problem <ref> [24] </ref>. This indicates that very efficient incremental solutions for even the simplest syntactic cases may be hard to obtain. We then focus on the key recursion-free case of a single coded method in the context of base methods. <p> Let value (B) = value (B n ). The circuit value problem is: Given a boolean circuit B, decide if value (B) = true. This problem is known to be P-complete <ref> [24] </ref>. Given an instance of the CVP, we define a monadic, recursion-free method schema M that is consistent iff the boolean circuit evaluates to true. M has three classes, c t , c f , and c nf which are not related to each other in the inheritance hierarchy.
Reference: [25] <author> D. C. Luckham, D. M. R. Park, M. S. Paterson. </author> <title> On Formalized Computer Programs. </title> <journal> JCSS, </journal> <volume> 4 </volume> <pages> 220-249, </pages> <year> 1970. </year>
Reference-contexts: We provide an abstract view of flow of control based on method composition and possibly recursive method calls. We are consistent with any programming paradigm based on inheritance, overloading, and late binding. In this sense, the present work is similar to research on recursive applicative program schemas <ref> [10, 14, 25] </ref>. <p> On the other hand, it is hard to statically (at compile-time) analyze methods. This difficulty is substantiated by the undecidability of consistency checking, even in our simple model. We prove undecidability by reduction from problems involving program (flowchart) schemas <ref> [25] </ref>. It turns out that the main feature in program schemas, conditional binary transfer, can be simulated using method overloading. The reduction is a modification of McCarthy's simulation of program (flowchart) schemas by recursive applicative program schemas [27]. Our reduction uses inheritance and name overloading in an essential fashion. <p> This was first shown by Richard Hull for a different method formalism, [16]. To prove our result, we show that method schemas can simulate program (flowchart) schemas. The undecidability results then come from the undecidability results for these program schemas of <ref> [25] </ref>. See also [14] for linear recursion. Definition 3.5 For program (flowchart) schemas, we will adopt the formal language of [25], which contains the following symbols: (i) F 1 2 ; F 1 1 ; F 2 3 ; . . . (operator symbols with superscripts denoting arity), (ii) L 1 <p> To prove our result, we show that method schemas can simulate program (flowchart) schemas. The undecidability results then come from the undecidability results for these program schemas of <ref> [25] </ref>. See also [14] for linear recursion. Definition 3.5 For program (flowchart) schemas, we will adopt the formal language of [25], which contains the following symbols: (i) F 1 2 ; F 1 1 ; F 2 3 ; . . . (operator symbols with superscripts denoting arity), (ii) L 1 ; L 2 ; L 3 ; ::: (location symbols), (iii) T 1 ; T 2 ; T 3 ; <p> The assignment instruction has the obvious meaning and the transfer instruction is an if-then-else statement. The computation terminates when a ST OP instruction is encountered. Example 3.6 Consider the following program schema (this is also from <ref> [25] </ref>): 1. L 2 := F 1 (L 2 ); 3. L 2 := F 2 (L 1 ; L 2 ); 5. T 1 (L 1 )6; 3; 6. STOP. In [25], it is shown that the program above can compute the factorial function under some interpretations and under others, <p> Example 3.6 Consider the following program schema (this is also from <ref> [25] </ref>): 1. L 2 := F 1 (L 2 ); 3. L 2 := F 2 (L 1 ; L 2 ); 5. T 1 (L 1 )6; 3; 6. STOP. In [25], it is shown that the program above can compute the factorial function under some interpretations and under others, over list structures, it can compute the reverse function.2 For simplicity of presentation, we omit the detailed definitions of the semantics of program schemas and refer the reader to [25]. <p> In <ref> [25] </ref>, it is shown that the program above can compute the factorial function under some interpretations and under others, over list structures, it can compute the reverse function.2 For simplicity of presentation, we omit the detailed definitions of the semantics of program schemas and refer the reader to [25]. We will now argue that method schemas can "simulate" program schemas. Intuitively, we carry the context of the program (content of variables) as arguments of the methods in a standard way. Base functions in the method schemas correspond naturally to operator symbols in program schemas. <p> Now, (1) follows from the claim and Lemmas 3.7-3.9.2 Remark: We consider in this paper only finite interpretations of method schemas. Undecidability results hold for all (finite and infinite) interpretations by the same reduction and <ref> [25] </ref>. 4 Recursion-Free Schemas In this section, we study recursion-free schemas. We consider the monadic case first, and then turn to the general case. As we know from the previous section, consistency of monadic schemas can be tested in O (nc 3 ) time. <p> In the simulation of program schemas by method schemas, we use methods of arity at most p + 1 where p is the number of locations used by the programs. It turns out that the results of <ref> [25] </ref> that we used also hold for program schemas with two locations only. Thus our undecidability results hold for schemas with methods of arity less than or equal to three. The complexity of method schema consistency with methods of arity two is not known.
Reference: [26] <author> D. Maier, A. Otis, A. Purdy. </author> <title> Development of an Object-Oriented DBMS. </title> <journal> Bulletin of IEEE on Database Engineering, </journal> <year> 1985. </year>
Reference-contexts: 1 Introduction Object-oriented database systems are the focus of a great deal of current experimentation and research | for motivation and terminology see [3, 4, 22, 23, 34]. Although most of the work to-date has concentrated on system development (e.g., <ref> [5, 6, 12, 26, 33] </ref>) some of the fl A preliminary version of this paper appeared in the proceedings of the 9th ACM PODS, 1990. y INRIA, 78153 Le Chesnay Cedex, France. abitebou@inria.inria.fr, waller@seti.inria.fr.
Reference: [27] <author> J. McCarthy. </author> <title> Towards a Mathematical Science of Computation. </title> <booktitle> Information Processing, Proceedings of IFIP Congress 1962, </booktitle> <pages> 21-28, </pages> <editor> Ed. C. M. Popplewell, </editor> <publisher> North-Holland Publishing Company, Amsterdam. </publisher>
Reference-contexts: We prove undecidability by reduction from problems involving program (flowchart) schemas [25]. It turns out that the main feature in program schemas, conditional binary transfer, can be simulated using method overloading. The reduction is a modification of McCarthy's simulation of program (flowchart) schemas by recursive applicative program schemas <ref> [27] </ref>. Our reduction uses inheritance and name overloading in an essential fashion. Richard Hull proved undecidability of "reachability" for a different model of method schemas [16], by reducing from the Post correspondence problem. Almost the same proof can be used for showing undecidability of consistency in our model.
Reference: [28] <author> A. Skarra, S. Zdonik. </author> <title> Type Evolution in an Object-Oriented Database. </title> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> 393-416, </pages> <editor> Eds. B. Shriver and P. Wegner, </editor> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: A key computational problem is: consistency maintenance of method schemas. Its solution has many applications. For example, it can be used to facilitate the support of schema evolution (e.g., <ref> [7, 28] </ref>). Let us briefly outline our formalization: Syntax: We have an isa hierarchy of classes, where each class denotes a set of objects. Each object has an associated set of methods and all objects in a class have the same methods.
Reference: [29] <author> R. Szelepcsenyi. </author> <title> The Method of Forcing for Nondeterministic Automata. </title> <journal> Bull. </journal> <volume> EATCS 33, </volume> <pages> 96-100, </pages> <year> 1987. </year>
Reference-contexts: Thus, we analyze in detail the consistency problem for monadic and/or recursion-free method schemas, which happen to be decidable. We also quantify the effect of covariance, which is a widely used constraint on the signature of methods. For the various concepts used from complexity theory, see <ref> [15, 19, 20, 29] </ref> and from database theory, see [21, 30]. We briefly summarize our other results. Let n be the size of method definitions in the input method schema and c the size of the class hierarchy. <p> We do not have to write down the complete FSA all at once. Given the base method definitions, we can compute parts of the transition function of the FSA as we need it. Thus, inconsistency is in NLOGSPACE. We now use the fact that NLOGSPACE is closed under complement <ref> [19, 29] </ref>, and conclude that consistency is in NLOGSPACE. Finally, we show that consistency of simple, monadic schemas is hard using a reduction of the reachability problem for graphs of out-degree 2 which is known to be logspace-complete in NLOGSPACE [20].
Reference: [30] <author> J.D. Ullman. </author> <title> Principles of Database Systems. </title> <publisher> Computer Science Press, </publisher> <address> 2 nd Ed., </address> <year> 1982. </year>
Reference-contexts: We also quantify the effect of covariance, which is a widely used constraint on the signature of methods. For the various concepts used from complexity theory, see [15, 19, 20, 29] and from database theory, see <ref> [21, 30] </ref>. We briefly summarize our other results. Let n be the size of method definitions in the input method schema and c the size of the class hierarchy. In the case of monadic schemas, the set of possible computations can be described using a context-free language.
Reference: [31] <author> M. Y. Vardi. </author> <title> Automata Theory for Database Theoreticians. </title> <booktitle> Proc. ACM PODS, </booktitle> <pages> 83-91, </pages> <year> 1989. </year>
Reference-contexts: We present this proof in an appendix. In the case of recursion-free schemas, the consistency problem is coNP-complete for a single coded method with two arguments. Some special cases can be shown to be in PTIME, using tree automata techniques <ref> [11, 31] </ref>. Covariance does not help in the recursive case. However, in the recursion-free covariant case we show that there is a PTIME test for a fixed arity coded method. This is interesting in practice, because it motivates our heuristic for the general case. <p> Remark: If the k-terms of the methods to be checked are trees (not dag's), where each input i, for 1 i k appears at most once, consistency checking is in PTIME. This bound is obtained by generalizing the automaton technique to tree automata <ref> [11, 31] </ref>. 26 5 Covariance In this section, we consider covariance and show that it simplifies the consistency problem. We first consider simple schemas. For simple schemas, covariance is the following constraint on the signatures of base methods.
Reference: [32] <author> E. Waller. </author> <title> Schema Updates and Consistency. </title> <booktitle> Proc. 2nd International Conference on Deductive and Object-oriented Databases, </booktitle> <address> Munich, </address> <year> 1991. </year>
Reference-contexts: Of course, understanding what may be affected is the crucial part. This is where our analysis contributes. We briefly discuss this aspect and refer to <ref> [32] </ref> for more details. The rest of the paper is organized as follows. In Section 2, we present the model. Schemas with recursion are considered in Section 3, and recursion-free schemas in Section 4. Section 5 deals with covariance. The heuristic for incremental consistency checking is considered in Section 6. <p> So covariance would only be good for one insertion, and the consistency checking algorithm may have to recompile at least part of the schema if completeness is to be achieved in future insertions. (For detailed examples and some techniques for special cases see <ref> [32] </ref>.) Covariance does not help with deletions. To see this consider the last example. Example 6.4 Let c; c 0 ; c 00 ; int be four classes with both c 0 ; c 00 c.
Reference: [33] <author> S. Zdonik. </author> <title> Object Management Systems for Design Environments. </title> <journal> Bulletin of IEEE on Database Engineering, </journal> <year> 1985. </year>
Reference-contexts: 1 Introduction Object-oriented database systems are the focus of a great deal of current experimentation and research | for motivation and terminology see [3, 4, 22, 23, 34]. Although most of the work to-date has concentrated on system development (e.g., <ref> [5, 6, 12, 26, 33] </ref>) some of the fl A preliminary version of this paper appeared in the proceedings of the 9th ACM PODS, 1990. y INRIA, 78153 Le Chesnay Cedex, France. abitebou@inria.inria.fr, waller@seti.inria.fr.
Reference: [34] <author> S. Zdonik, D. Maier. </author> <title> Readings in Object-Oriented Database Systems. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Object-oriented database systems are the focus of a great deal of current experimentation and research | for motivation and terminology see <ref> [3, 4, 22, 23, 34] </ref>.
Reference: [35] <author> R. Zicari. </author> <title> A Framework for Schema Updates in an Object-Oriented Database System. Building an Object-Oriented System: The Story of O 2 . Chapter 7, </title> <editor> (F. Bancilhon, C. Delobel, P. Kanellakis editors), </editor> <publisher> Morgan-Kaufmann, </publisher> <year> 1992. </year> <month> 39 </month>
Reference-contexts: The schema is no longer consistent even if m is still well defined in c and its subclasses.2 Finally, we would like to point out that some of the techniques of method schemas have been extended and applied to the O 2 object-oriented database system <ref> [35] </ref>. 36 7 Conclusions and Open Problems We have provided a basic programming model for object-oriented database systems, which captures classes, methods, inheritance, name overloading and late binding.
References-found: 35

