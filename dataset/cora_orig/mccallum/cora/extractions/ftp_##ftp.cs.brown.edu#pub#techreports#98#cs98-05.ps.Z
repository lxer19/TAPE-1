URL: ftp://ftp.cs.brown.edu/pub/techreports/98/cs98-05.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-98-05.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J.M. Mellor-Crummey and T.J. LeBlanc. </author> <title> A software instruction counter. </title> <booktitle> In Proceedings of the Third ASPLOS, </booktitle> <month> April </month> <year> 1989. </year>
Reference-contexts: In the simplest case, software instruction counters emulate hardware instruction counters, and are incremented after every instruction executed. Software instruction counting has been implemented efficiently for a variety of architectures <ref> [1, 3, 4] </ref> as an alternative to hardware instruction counters. Because they are implemented in software, SIC implementations usually rely heavily on instrumenting the target executable either after or during compilation.
Reference: [2] <author> M.W. Shapiro. </author> <type> Personal communication, </type> <month> October </month> <year> 1997. </year>
Reference-contexts: The SIC provides a powerful facility for implementing debugger features efficiently, and reveals a new "taxonomy of debugger events." <ref> [2] </ref> 4.1 A Taxonomy of Debugger Events In its most basic role, an instruction counter can be utilized to specify a simple instruction counter breakpoint. Such a breakpoint is specified only by the quantum q at which its action should be 5 taken, regardless of PC value.
Reference: [3] <author> M.W. Shapiro. Rdb: </author> <title> A system for incremental replay debugging. </title> <type> Masters thesis, </type> <month> May </month> <year> 1997. </year>
Reference-contexts: In the simplest case, software instruction counters emulate hardware instruction counters, and are incremented after every instruction executed. Software instruction counting has been implemented efficiently for a variety of architectures <ref> [1, 3, 4] </ref> as an alternative to hardware instruction counters. Because they are implemented in software, SIC implementations usually rely heavily on instrumenting the target executable either after or during compilation. <p> event refers to the combination of specification and action that form such a control structure. 3 The rdb Framework This section presents the rdb framework, into which we have integrated our work, and then focuses on how an rdb replay process communicates with the debugger. 3.1 Overview of rdb rdb <ref> [3] </ref> is a framework for incremental replay debugging. In an incremental replay system, tracing and replay are broken down into intervals. Trace data is kept in such a way that process state may be restored to the beginning of any interval. <p> The first is the rdb engine itself, and the second is an auxiliary library known as the trace technique. rdb implements an API for developing such techniques. Our work in this paper is primarily concerned with the rdb engine, but we have used the dfa2-spl trace technique detailed in <ref> [3] </ref> as a testbed for our ideas. rdb involves itself in the user program in three major phases. The first is at compile-time, when ALTR, the Assembly Language TRanslator, is run in order to instrument the user executable according to a series of rules provided by a technique-specific "hooks" file.
Reference: [4] <author> J.H. Slye and E.N. Elnozahy. </author> <title> Supporting nondeterministic execution in fault-tolerant systems. </title> <booktitle> In Proceedings of the Twenty-Sixth Annual International Symposium on Fault-Tolerant Computing (FTCS-26), </booktitle> <pages> pages 250-259, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: In the simplest case, software instruction counters emulate hardware instruction counters, and are incremented after every instruction executed. Software instruction counting has been implemented efficiently for a variety of architectures <ref> [1, 3, 4] </ref> as an alternative to hardware instruction counters. Because they are implemented in software, SIC implementations usually rely heavily on instrumenting the target executable either after or during compilation. <p> This is helpful because it makes that instance easy to return to later, or to share with a colleague. More fundamentally, it captures perfectly the information needed to replay asynchronous events, such as signals or thread scheduling decisions. <ref> [4] </ref> Era events may be useful for installing watchpoints, breakpoints, or profiling mechanisms over a particular era instead of over the process lifetime, especially if such mechanisms incur a high performance penalty. 4.2 Building Debugger Events This section shows that it is possible to build control point, era, and other complex
Reference: [5] <institution> Sun Microsystems, Inc., Mountain View, </institution> <address> CA. </address> <booktitle> /proc, The Process File System, </booktitle> <year> 1995. </year>
Reference-contexts: To facilitate such debugging, rdb provides an agent LWP which can service requests made on a debugger's behalf. Figure 1 shows how the agent and debugger communicate via the Solaris procfs mechanism <ref> [5] </ref>. One important restriction on the agent is that it and the process target lwp (the lwp being debugged) run in a mutually exclusive fashion. The agent is used for a variety of reasons, but conceptually it performs a number of major tasks: 1.
Reference: [6] <institution> Tera Computer Company. Hardware Characteristics of the Tera MTA, </institution> <month> April </month> <year> 1998. </year>
Reference-contexts: Some architectures provide hardware instruction counters, clock cycle counters [8], or even configurable event counters <ref> [6] </ref>, but their use is not yet widespread. In the simplest case, software instruction counters emulate hardware instruction counters, and are incremented after every instruction executed. Software instruction counting has been implemented efficiently for a variety of architectures [1, 3, 4] as an alternative to hardware instruction counters.
Reference: [7] <author> U. Vahalia. </author> <title> UNIX Internals: The New Frontiers. </title> <publisher> Prentice-Hall, </publisher> <address> New Jersey, </address> <year> 1996. </year>
Reference-contexts: The Software-event structure, rdb se t, shown in figure 5, is loosely based on various UNIX System V interfaces, such as the vnode and device interfaces. <ref> [7] </ref> In this object-oriented approach, a structure containing event specific function pointers is associated with each Software-event, forming 8 typedef struct rdb_se - rdb_bp_t se_bp; /* breakpoint storage */ ulong_t se_sic; /* sic value */ ulong_t se_sic_pair; /* pair value (gets swapped w/se_sic) */ ushort_t se_installed; /* nonzero of se is
Reference: [8] <author> D.L. Weaver and T. </author> <title> Germond. The SPARC Architecture Manual: Version 9. </title> <publisher> Prentice-Hall, </publisher> <address> New Jersey, </address> <year> 1994. </year> <month> 18 </month>
Reference-contexts: Some architectures provide hardware instruction counters, clock cycle counters <ref> [8] </ref>, or even configurable event counters [6], but their use is not yet widespread. In the simplest case, software instruction counters emulate hardware instruction counters, and are incremented after every instruction executed.
References-found: 8

