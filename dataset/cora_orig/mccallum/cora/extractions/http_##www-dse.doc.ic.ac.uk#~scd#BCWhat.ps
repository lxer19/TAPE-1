URL: http://www-dse.doc.ic.ac.uk/~scd/BCWhat.ps
Refering-URL: http://outoften.doc.ic.ac.uk/projects/slurp/papers.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: What is Java Binary Compatibility? Version 2  restricted detnition guarantees safe linking and execution.  
Author: Sophia Drossopoulou, David Wragg, Susan Eisenbach 
Note: Java, that this  
Date: June 9, 1998  
Address: College, London  
Affiliation: Department of  Imperial  
Pubnum: Computing, Technical Report Nr: 5/98  
Abstract: Java suggests a more exible framework, in which the linker checks the integrity of the binaries to be combined. Certain source code mod-itcations, such as addition of methods to classes, are detned as binary compatible. The language description guarantees that binaries of types (i.e. classes or interfaces) which were modited in binary compatible ways may be re-compiled and linked with the binaries of types that imported and were compiled using the earlier versions of the modited types. However, this is not always the case: some of the changes considered by Java as binary compatible do not guarantee successful linking and execution. In this paper we study the concepts around binary compatibility. We suggest a formalization of the requirement of safe linking and execution without re-compilation, we investigate alternatives, we demonstrate several of its properties, and we propose a more restricted detnition of binary compatible changes. Finally, we prove for a substantial subset of 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martin Abadin. </author> <title> Protection in Programming Lamguage Translations. </title> <booktitle> In ICALP'98 Proceedings. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1998. </year> <note> to appear, 23 also avaliable at: http://gatekeeper.dec.com/pub/DEC/SRC/research--resports/abstracts/src-rr-154.html. </note>
Reference-contexts: The fact that separate compilation of the types is not equivalent to compilation of all types together can be seen as another case of lack of full abstraction property in language translation, which, as shown in <ref> [1] </ref> may lead to loss of protection. It would be intersting to investigate in how far problems with binary comnpatibility can be understood in these terms. Finally, a more distant and ambitious task remains the formalization of the dynamic linker/loader, and an approach to the associated security issues.
Reference: [2] <author> L. Cardelli. </author> <title> Program Fragments, Linking, and Modularization. </title> <booktitle> In POPL'97 Proceedings, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: Ours is the only formalization for a concrete language and proof of correctness we know of. The idea of using fragments consisting of a signature and a body to describe linkable units, and of distinguishing a type checking and a substitution phase in linking stem from <ref> [2] </ref>. The system we describe here distinguishes between source code and compiled code, mainly because in Java separate compilation of parts is not equivalent to compilation of all parts together, a fact already pointed out but not pursued in [2]. <p> a type checking and a substitution phase in linking stem from <ref> [2] </ref>. The system we describe here distinguishes between source code and compiled code, mainly because in Java separate compilation of parts is not equivalent to compilation of all parts together, a fact already pointed out but not pursued in [2]. We intend to extend Java s to encompass a larger subset of Java, and then extend safe binary compatibility to include access restrictions, static variables and methods, etc.
Reference: [3] <author> M. Dausmann, S. Drossopoulou, G. Persch, and G. Winterstein. </author> <title> A Separate Compilation System for Ada. </title> <booktitle> In Proc. GI Tagung: Werkzeuge der Programmiertechnik. Springer Verlag Lecture Notes in Computer Science, </booktitle> <year> 1981. </year>
Reference-contexts: 1 Introduction Module systems [19, 18], introduced in the seventies, support the decomposition of larger programs into smaller, more manageable units (modules, classes, clusters, packages). Traditionally, separate compilation <ref> [3] </ref> allowed these units to be compiled separately using only the signature (i.e. type) information from imported units. The object code of these separately compiled units would be put together into an executable by a linker.
Reference: [4] <author> Drew Dean. </author> <title> The Security of Static Typing with Dynamic Linking. </title> <booktitle> In Fourth ACM Conference on Computer and Communication Security, </booktitle> <year> 1997. </year> <note> Revised version Tech Report number SRI CSL 9704. </note>
Reference-contexts: However, we feel, that its exact meaning and properties are not fully understood, which is unfortunate, since <ref> [5, 4] </ref> demonstrate that loopholes in the detnition and implementation of binary compatibility provide opportunities to break Java 2 security. The Java language specitcation [10] devotes a whole chapter to binary compatibility, giving examples, and pointing out possible interplay of features.
Reference: [5] <author> Drew Dean, Edward W. Felten, and Dan S. Wallach. </author> <title> Java Security: From HotJava to Netscape and Beyond. </title> <booktitle> In Proceedings of the 1996 IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 190200, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: However, we feel, that its exact meaning and properties are not fully understood, which is unfortunate, since <ref> [5, 4] </ref> demonstrate that loopholes in the detnition and implementation of binary compatibility provide opportunities to break Java 2 security. The Java language specitcation [10] devotes a whole chapter to binary compatibility, giving examples, and pointing out possible interplay of features.
Reference: [6] <author> Sophia Drossopoulou and Susan Eisenbach. </author> <title> Java is type safe probably. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: prove that safe changes satisfy link compatibility. moditcations guarantee list of binary compatible no re-compilation, changes =) linking without errors, safe execution j j formalized as formalized as # # list of safe changes =) link compatibility 3 We use some of our previous work formalizing the semantics of Java <ref> [6, 7] </ref>. However, we could have used any other formalization giving meaning to type checking and distinguishing source code from compiled code, e.g. [17].
Reference: [7] <author> Sophia Drossopoulou and Susan Eisenbach. </author> <title> Towards an Operational Semantics and a Proof of Type Soundness for Java. </title> <editor> In Jim Alvez Foss, editor, </editor> <title> Formal Syntax and Semantics of Java. </title> <publisher> Springer Verlag Lecture Notes in Computer Science, </publisher> <year> 1998. </year> <note> to appear, available at http://www-dse.doc.ic.ac.uk/projects/slurp/. </note>
Reference-contexts: prove that safe changes satisfy link compatibility. moditcations guarantee list of binary compatible no re-compilation, changes =) linking without errors, safe execution j j formalized as formalized as # # list of safe changes =) link compatibility 3 We use some of our previous work formalizing the semantics of Java <ref> [6, 7] </ref>. However, we could have used any other formalization giving meaning to type checking and distinguishing source code from compiled code, e.g. [17]. <p> In section 3 we summarize the formalization concepts from <ref> [7] </ref> needed for the current discussion. In section 4 we detne what it means to compile new code into existing binaries, in section 5 we detne link compatibility, prove some composition properties for it, detne safe changes, and demonstrate that the latter implies the former. <p> The best solution seems to be to remove the addition of methods to interfaces (directly or by adding super-interfaces) from the list of binary compatible changes. 6 3 Formalization of the Java Semantics This section summarizes material from <ref> [7] </ref> needed to support the formalization of separate compilation and binary compatibility. In [7] we describe the semantics of a large subset of Java encompassing primitive types, classes, interfaces, inheritance, instance variables and instance methods, interfaces, shadowing, dynamic method binding, the null value, arrays, exceptions and exception handling. <p> best solution seems to be to remove the addition of methods to interfaces (directly or by adding super-interfaces) from the list of binary compatible changes. 6 3 Formalization of the Java Semantics This section summarizes material from <ref> [7] </ref> needed to support the formalization of separate compilation and binary compatibility. In [7] we describe the semantics of a large subset of Java encompassing primitive types, classes, interfaces, inheritance, instance variables and instance methods, interfaces, shadowing, dynamic method binding, the null value, arrays, exceptions and exception handling. <p> In the remainder of this section we discuss these concepts in more depth. The syntax of Java s can be found in appendix A1. We do not include object and array creation yet, because their current description in <ref> [7] </ref> is not abstract enough for use in this work. For convenience, we split the typing information and the evaluation information into an environment, usually denoted by a , and a program body, usually denoted by a p. <p> The subject reduction theorem proven in <ref> [7] </ref> states that one evaluation step preserves the types up to sub-classes/sub-interfaces.
Reference: [8] <author> Ira Forman, Michael Conner, Scott Danforth, and Larry Raper. </author> <title> Release-to-Release Binary Compatibility in SOM. </title> <booktitle> In OOPSLA'95 Proceedings, </booktitle> <year> 1995. </year>
Reference-contexts: It is the task of the linker to ensure that the binaries respect each other's exported signatures, independently of the order of compilation. In particular, certain source code moditcations, such as adding a method to a class, are detned as binary compatible, based on ideas suggested in <ref> [8] </ref>. The Java language description does not require the re-compilation of programs importing classes or interfaces which were modited in binary compatible ways, and claims that successful linking and execution of the altered program is guaranteed. <p> Suggestions for binary compatibility appeared in <ref> [8] </ref>, and were taken over in Java [10]. Ours is the only formalization for a concrete language and proof of correctness we know of.
Reference: [9] <author> Allen Goldberg. </author> <title> A Specitcation of Java Loading and Bytecode Veritcation. </title> <type> Technical report, </type> <institution> Kestrel Institute, </institution> <month> December </month> <year> 1997. </year>
Reference-contexts: It would be interesting to recast some of this work in terms of a formal description of the Java byte-code and byte-code veriter (such as <ref> [15, 9] </ref>). The fact that separate compilation of the types is not equivalent to compilation of all types together can be seen as another case of lack of full abstraction property in language translation, which, as shown in [1] may lead to loss of protection.
Reference: [10] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specitcation. </title> <publisher> Addison-Wesley, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: However, we feel, that its exact meaning and properties are not fully understood, which is unfortunate, since [5, 4] demonstrate that loopholes in the detnition and implementation of binary compatibility provide opportunities to break Java 2 security. The Java language specitcation <ref> [10] </ref> devotes a whole chapter to binary compatibility, giving examples, and pointing out possible interplay of features. However, no exact detnition is given, and the term binary compatibility is used in two senses. <p> It seems that <ref> [10] </ref> claims that these moditcations satisfy the guarantee. <p> Safe changes include all changes that can be demonstrated to preserve the guarantees; they include most changes listed in <ref> [10] </ref> e.g. adding instance variables to classes, modifying method bodies, but do not include the addition of methods to interfaces, because, as we shall see, this does not preserve the property of linking without errors. <p> (); - 2nd phase interface I void meth1 (); void meth2 (); - 3rd phase class D void meth3 () I anI = new C (); anI.meth2 (); - 2.2 A problem with binary compatibility The example in tgure 2 demonstrates that the list of binary compatible changes given in <ref> [10] </ref> is too permissive and so fails to support the guarantee. In particular, [10] considers the addition of methods to interfaces to be a binary compatible change, and as a result it does not prevent values of a particular interface type referring to objects of classes which do not fully implement <p> 3rd phase class D void meth3 () I anI = new C (); anI.meth2 (); - 2.2 A problem with binary compatibility The example in tgure 2 demonstrates that the list of binary compatible changes given in <ref> [10] </ref> is too permissive and so fails to support the guarantee. In particular, [10] considers the addition of methods to interfaces to be a binary compatible change, and as a result it does not prevent values of a particular interface type referring to objects of classes which do not fully implement that interface. This problem is known to JavaSoft [16]. <p> This problem is known to JavaSoft [16]. In the trst phase consider compiling interface I, and classes C, D. Compilation will be successful. In the second phase method meth2 () is added to interface I, and I is re-compiled. This is considered a binary compatible change <ref> [10] </ref>. In the third phase code invoking anI.meth2 () is added to the body of meth3 in class D and D is re-compiled. Since the new method body is type correct, this is a binary compatible change as well, [10]. <p> This is considered a binary compatible change <ref> [10] </ref>. In the third phase code invoking anI.meth2 () is added to the body of meth3 in class D and D is re-compiled. Since the new method body is type correct, this is a binary compatible change as well, [10]. Therefore, according to the guarantee of binary compatibility, one expects to be able to link and run successfully the binaries for I 0 , C and D 0 . <p> The latter requirement is very easy to establish, and corresponds to a successful local compilation step. This contrms that reimplementing method bodies is a binary compatible change, <ref> [10] </ref>. However, the trst requirement from lemma 6, namely type preservation, is not obviously straightforward to establish, since it requires that for all possible environments 0 , the two environments should give the same types to all Java se expressions. <p> In the next section we consider restricted moditcations to the environment which imply type preservation. 5.3 Safe changes Safe changes are those of the changes described in <ref> [10] </ref>, which apply to the language Java s , and can be demonstrated to preserve the guarantees of binary compatibility. In particular, they do not include the addition of instance methods to interfaces, which was demonstrated to be problematic in section 2. <p> , a substantial subset of Java, that safe binary compatible changes do not require re-compilation and guarantee successful linking. * We characterize the safe change as those which preserve the types of the enriched Java se expressions a more ganeral and abstract characteriza tion, than the lengthy list given in <ref> [10] </ref>. 22 * We have investigated the properties of combinations of binary compatible moditcations We expect that better formalizations will be found; indeed the formulation suggested in this paper is the result of many discussions and iterations over previous approaches [20], and we continue work in this direction. <p> Suggestions for binary compatibility appeared in [8], and were taken over in Java <ref> [10] </ref>. Ours is the only formalization for a concrete language and proof of correctness we know of. The idea of using fragments consisting of a signature and a body to describe linkable units, and of distinguishing a type checking and a substitution phase in linking stem from [2].
Reference: [11] <author> James Gosling and H. McGilton. </author> <title> The Java white paper, </title> <address> http:// java.sun.com/ java.sun.com/ whitePaper/ java-whitepaper 1.html 1995. </address>
Reference-contexts: Thus, it is possible to link successfully and execute binaries corresponding to type-incorrect source code. Separate compilation of several units is no longer equivalent to compilation of all units in one step. This is a deliberate feature and constitutes a crucial ingredient of the Java approach <ref> [11] </ref>. It allows the moditcation (usually through extension) of libraries used by third party software, without requiring the re-compilation of the third party software itself, whose source code might not even be available. <p> Finally, in section 6, we draw conclusions and outline further work. 2 Binary Compatibility in Java The motivation for the concept of binary compatibility in Java comes from the intended use, supporting large scale re-use of third-party software available on the Internet <ref> [11] </ref>. Thus, a large amount of exibility and minimal amount of required re-compilation is paramount. In particular, Java avoids the fragile base class problem, found, e.g. , in most C++ implementations: A teld access is usually compiled into an oset from the beginning of the object, txed at compile-time.
Reference: [12] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: Similarly, for a Java se method call, the statically determined argument types are taken into account. These properties of the Java se types reect, at a higher level, checks performed by the bytecode veriter, <ref> [15, 12] </ref>, and are crucial for the proofs of the lemmas in section 5. Java r describes run-time terms, and is an extension of Java se . Execution also involves state, usually referred to by a . <p> In particular, because the subject reduction theorem ensures the existence of a rewrite step, it also guarantees that all required method bodies and all required instance variables will be present. Absence of instance variables of method bodies is the kind of thing that would throw a linker exception <ref> [12] </ref>. The subject reduction theorem thus suggests that the assertion ` se p 33 means that p is a complete successfully-linked Java se program body. The assertion ` se p 33 can be established by proving that ` se p 3 and that Classes (p) = Classes ().
Reference: [13] <author> Leonid Mikhajlov and Emil Sekerinski. </author> <title> A study of the fragile base class problem. </title> <booktitle> In ECOOP'98 Proceedings. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1998. </year> <note> to appear. </note>
Reference-contexts: Similar problems arise with virtual method calls. The term fragile base class problem is also used in a wider sense, to describe the problems arising in separately developed systems using inheritance for code re-use <ref> [13] </ref>. C++ development environments attempt to compensate by automatically recompiling all tles importing the modited class. Such a strategy would be too restrictive in the Java context.
Reference: [14] <author> Tobias Nipkow and David von Oheimb. </author> <title> Java `ight is type-safe detnitely. </title> <booktitle> In POPL'98 Proceedings, </booktitle> <month> January </month> <year> 1998. </year> <month> 24 </month>
Reference-contexts: p and 0 , and: T 0 =E-Thrn, E an exception, 0 conforms to , 0 = or ` T 0 wdn T, 0 conforms to , 0 conforms to 0 or * ht; i; p h 0 i and 0 conforms to Similar subject reduction theorems are proven in <ref> [17, 14] </ref> as well. Note that the exceptions in the subject reduction theorem may be the language detned exceptions divide-by-zero, null-pointer-access, array-store exception, or any of the user-detned exceptions.
Reference: [15] <author> Raymie Stata and Martin Abadi. </author> <title> A Type System For Java Bytecode Sub--routines. </title> <booktitle> In POPL'98 Proceedings, </booktitle> <month> January </month> <year> 1998. </year>
Reference-contexts: Similarly, for a Java se method call, the statically determined argument types are taken into account. These properties of the Java se types reect, at a higher level, checks performed by the bytecode veriter, <ref> [15, 12] </ref>, and are crucial for the proofs of the lemmas in section 5. Java r describes run-time terms, and is an extension of Java se . Execution also involves state, usually referred to by a . <p> It would be interesting to recast some of this work in terms of a formal description of the Java byte-code and byte-code veriter (such as <ref> [15, 9] </ref>). The fact that separate compilation of the types is not equivalent to compilation of all types together can be seen as another case of lack of full abstraction property in language translation, which, as shown in [1] may lead to loss of protection.
Reference: [16] <author> Guy Steele. </author> <title> Private Communication, </title> <month> January </month> <year> 1998. </year>
Reference-contexts: In particular, [10] considers the addition of methods to interfaces to be a binary compatible change, and as a result it does not prevent values of a particular interface type referring to objects of classes which do not fully implement that interface. This problem is known to JavaSoft <ref> [16] </ref>. In the trst phase consider compiling interface I, and classes C, D. Compilation will be successful. In the second phase method meth2 () is added to interface I, and I is re-compiled. This is considered a binary compatible change [10]. <p> These properties are crucial in delineating the exact nature of binary compatibility. In fact, we have been discussing with Java developers whether a diamond property and the preservation over libraries are satisted by binary compatibility, and in how far they should be satisted <ref> [16] </ref>. Thus, a major contribution of this paper lies, we believe, in the formulation and dierentiation of such properties. The preservation over larger fragments automatically establishes link compatibility for all fragments that contain a smaller fragment for which this property had already been established.
Reference: [17] <author> Donald Syme. </author> <title> Proving Java Type Sound. </title> <type> Technical Report 427, </type> <institution> Cam-bridge University, </institution> <month> June </month> <year> 1997. </year> <title> to appear in Formal Syntax and Semantics of Java tm , edited by Jim Alves Foss, </title> <publisher> Springer, LNCS. </publisher>
Reference-contexts: However, we could have used any other formalization giving meaning to type checking and distinguishing source code from compiled code, e.g. <ref> [17] </ref>. <p> p and 0 , and: T 0 =E-Thrn, E an exception, 0 conforms to , 0 = or ` T 0 wdn T, 0 conforms to , 0 conforms to 0 or * ht; i; p h 0 i and 0 conforms to Similar subject reduction theorems are proven in <ref> [17, 14] </ref> as well. Note that the exceptions in the subject reduction theorem may be the language detned exceptions divide-by-zero, null-pointer-access, array-store exception, or any of the user-detned exceptions.
Reference: [18] <institution> US Department of Defense. </institution> <note> Reference Manual for the Ada Programming Language, 1983. ANSI/MIL-STD-1815 A. </note>
Reference-contexts: 1 Introduction Module systems <ref> [19, 18] </ref>, introduced in the seventies, support the decomposition of larger programs into smaller, more manageable units (modules, classes, clusters, packages). Traditionally, separate compilation [3] allowed these units to be compiled separately using only the signature (i.e. type) information from imported units.
Reference: [19] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: 1 Introduction Module systems <ref> [19, 18] </ref>, introduced in the seventies, support the decomposition of larger programs into smaller, more manageable units (modules, classes, clusters, packages). Traditionally, separate compilation [3] allowed these units to be compiled separately using only the signature (i.e. type) information from imported units.
Reference: [20] <author> David Wragg, Sophia Drossopoulou, and Susan Eisenbach. </author> <title> Java binary compatibility is almost correct. </title> <type> Technical Report 3/98, </type> <institution> Imperial College Department of Computing, </institution> <month> February </month> <year> 1998. </year> <note> available at http://www-dse.doc.ic.ac.uk/projects/slurp/. </note>
Reference-contexts: and abstract characteriza tion, than the lengthy list given in [10]. 22 * We have investigated the properties of combinations of binary compatible moditcations We expect that better formalizations will be found; indeed the formulation suggested in this paper is the result of many discussions and iterations over previous approaches <ref> [20] </ref>, and we continue work in this direction. Suggestions for binary compatibility appeared in [8], and were taken over in Java [10]. Ours is the only formalization for a concrete language and proof of correctness we know of.
References-found: 20

