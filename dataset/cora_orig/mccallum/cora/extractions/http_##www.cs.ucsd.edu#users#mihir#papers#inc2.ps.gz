URL: http://www.cs.ucsd.edu/users/mihir/papers/inc2.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/mihir/papers/incremental.html
Root-URL: http://www.cs.ucsd.edu
Title: Incremental Cryptography and Application to Virus Protection  
Author: Mihir Bellare Oded Goldreich Shafi Goldwasser 
Abstract: The goal of incremental cryptography is to design cryptographic algorithms with the property that having applied the algorithm to a document, it is possible to quickly update the result of the algorithm for a modified document, rather than having to re-compute it from scratch. In settings where cryptographic algorithms such as encryption or signatures are frequently applied to changing documents, dramatic efficiency improvements can be achieved. One such setting is the use of authentication tags for virus protection. We consider documents that can be modified by powerful (and realistic) document modification operations such as insertion and deletion of character-strings (or equivalently cut and paste of text). We provide efficient incremental signature and message authentication schemes supporting the above document modification operations. They meet a strong notion of tamper-proof security which is appropriate for the virus protection setting. We initiate a study of incremental encryption, providing definitions as well as solutions. Finally, we raise the novel issue of "privacy" of incremental authentication schemes. Abstract appearing in Proceedings of the 27th ACM Symposium on the Theory of Computing, May 1995. 
Abstract-found: 1
Intro-found: 1
Reference: [AHU] <author> A. Aho, J. Ullman, and J. Hopcroft. </author> <title> The design and analysis of computer algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference: [AKS] <author> M. Ajtai, J. Koml os and E. Szemer edi. </author> <title> An O(n log n) sorting network. </title> <note> STOC 83. </note>
Reference-contexts: Finally, we set E 1 to hold the encryption of D 0 and drop the first ` elements of E 2 . Using the AKS sorting network <ref> [AKS] </ref>, our implementation of one epoch requires O (` log `) steps (whereas if we use Batcher's network we get a total of O (`) + `(log 2 `) steps). These steps can be partitioned evenly among the ` modification actions yielding the desired complexity.
Reference: [Ba] <author> K. Batcher. </author> <title> Sorting networks and their applications. </title> <booktitle> AFIPS Spring Joint Computer Conference 32, </booktitle> <year> 1968. </year>
Reference-contexts: It is crucial that the sorting is performed by an efficient and oblivious sorting network such as Batcher's sorting network <ref> [Ba] </ref>. We stress that whenever two pairs are compared and switched/unswitched they are re-encrypted by E (and so the adversary cannot tell if they were switched or not). This guarantees that the entire sorting procedure does not leak any information to the adversary.
Reference: [BGG] <author> M. Bellare, O. Goldreich and S. Gold-wasser. </author> <title> Incremental cryptography: The case of hashing and signing. </title> <type> Crypto 94. </type>
Reference: [BGR] <author> M. Bellare, R. Gu erin and P. Rogaway. </author> <title> XOR MACs: New methods for message authentication using block ciphers. </title> <type> Manuscript, </type> <month> March </month> <year> 1994. </year>
Reference: [BKR] <author> M. Bellare, J. Kilian and P. Rog-away. </author> <title> The security of cipher block chaining. </title> <type> Crypto 94. </type>
Reference: [BR] <author> M. Bellare and P. Rogaway. </author> <title> Entity authentication and key distribution. </title> <type> Crypto 93. </type>
Reference: [CW] <author> L. Carter and M. Wegman. </author> <title> Universal Classes of Hash Functions. </title> <journal> J. Computer and System Sciences 18, </journal> <pages> 143-154, </pages> <year> 1979. </year>
Reference: [Go] <author> O. Goldreich. </author> <title> Towards a Theory of Software Protection and Simulation by Oblivious RAMs. </title> <note> STOC 87. </note>
Reference-contexts: This might be acceptable in some settings, but a non-amortized solution is worth seeking. Another approach to incremental encryption is to use the idea of "software protection" as defined in <ref> [Go] </ref>. (The setting consists of a processor, having only a limited amount of local memory, to store and access information on an insecure remote memory. The simulation should be oblivious in the sense that the actual access pattern does not leak information about the original/simulated access pattern. <p> However the ideas of the software protection schemes of <ref> [Go, Os] </ref> can be adapted to derive an incremental encryption scheme for (single symbol) insert/delete that is efficient in the strict sense (i.e., number of simulation steps per original operation) rather than in the amortized sense (as presented there). The adaptation is achieved by "pipelining." A brief description follows. <p> encryption is computed and stored.) First, we set W to hold the relevant information; i.e., W [i] (i; D [i]) for i ` and W [i] M [i `] for ` + 1 i 2`. (Here we assume that the modification 10 Here is where we use the ideas of <ref> [Go, Os] </ref>. records have the form (i; ), where i is a location and a symbol to be placed in that location.) Next, we sort the pairs in W by their left element, hereafter referred to as their sorting-keys, so that if two sorting-keys are equal then the corresponding pairs are <p> These steps can be partitioned evenly among the ` modification actions yielding the desired complexity. As stated above, each of the schemes presented in <ref> [Go, Os] </ref> can be adopted to yield an incremental encryption scheme for (single symbol) insert/delete that is efficient in the strict sense. This is done analogously to the above, provided hat the document length stays within some predetermined bounds (e.g., between `=2 and 2`).
Reference: [GGM] <author> O. Goldreich, S. Goldwasser and S. Mi-cali. </author> <title> How to construct random functions. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 33, No. 4, </volume> <pages> 210-217, </pages> <year> 1986. </year>
Reference-contexts: The underlying message authentication scheme can be taken to be any of the standard ones. For example, the CBC MAC, or just one of the PRFs discussed above. (Any PRF is a MAC <ref> [GGM] </ref>). Our scheme has the additional property that it is secure even in face of an adversary who can see the authentication tags and even tamper with them.
Reference: [GM] <author> S. Goldwasser and S. Micali. </author> <title> Probabilistic encryption. </title> <journal> J. of Computer and System Sciences 28, </journal> <pages> 270-299, </pages> <month> April </month> <year> 1984. </year>
Reference: [GMR] <author> S. Goldwasser, S. Micali and R. Rivest. </author> <title> A digital signature scheme secure against adaptive chosen-message attacks. </title> <journal> SIAM Journal of Computing, </journal> <volume> 17(2) </volume> <pages> 281-308, </pages> <month> April </month> <year> 1988. </year>
Reference: [KR] <author> R. Karp and M. Rabin. </author> <title> Efficient randomized pattern matching algorithms. </title> <journal> IBM J. of Research and Development Vol. </journal> <volume> 31, No. 2, </volume> <month> March </month> <year> 1987. </year>
Reference-contexts: Our scheme has the additional property that it is secure even in face of an adversary who can see the authentication tags and even tamper with them. In contrast, the fingerprinting method of Karp-Rabin <ref> [KR] </ref> is secure only if the adver sary cannot see the fingerprint. 4 Incremental encryption 4.1 The security of incremental encryp tion As discussed in the Introduction, the usage of incremental encryption algorithms may leak information that is kept secret when using a traditional encryption scheme.
Reference: [LR] <author> M. Luby and C. Rackoff. </author> <title> How to construct pseudorandom permutations from pseudorandom functions. </title> <journal> SIAM J. Computation, </journal> <volume> Vol. 17, No. 2, </volume> <month> April </month> <year> 1988. </year>
Reference: [Me1] <author> R. Merkle. </author> <title> A certified digital signature scheme. </title> <type> Crypto 89. </type>
Reference: [Me2] <author> R. Merkle. </author> <title> Protocols for public key cryp-tosystems. </title> <booktitle> Proceedings of the 1980 Symposium on Security and Privacy. </booktitle>
Reference: [Os] <author> R. Ostrovsky. </author> <title> Efficient Computations on Oblivious RAMs. </title> <note> STOC 90. </note>
Reference-contexts: The translation from oblivious simulation of RAM to an incremental encryption scheme is quite obvious: the role of the processor is played by the user, whereas the remote memory is associated with the encryption.) A software protection scheme with polylogarithmic overhead exists <ref> [Os] </ref>, but is also amortized, and using this results in an incremental encryption scheme whose efficiency is in the end not better than that of the trivial solution above. <p> However the ideas of the software protection schemes of <ref> [Go, Os] </ref> can be adapted to derive an incremental encryption scheme for (single symbol) insert/delete that is efficient in the strict sense (i.e., number of simulation steps per original operation) rather than in the amortized sense (as presented there). The adaptation is achieved by "pipelining." A brief description follows. <p> encryption is computed and stored.) First, we set W to hold the relevant information; i.e., W [i] (i; D [i]) for i ` and W [i] M [i `] for ` + 1 i 2`. (Here we assume that the modification 10 Here is where we use the ideas of <ref> [Go, Os] </ref>. records have the form (i; ), where i is a location and a symbol to be placed in that location.) Next, we sort the pairs in W by their left element, hereafter referred to as their sorting-keys, so that if two sorting-keys are equal then the corresponding pairs are <p> These steps can be partitioned evenly among the ` modification actions yielding the desired complexity. As stated above, each of the schemes presented in <ref> [Go, Os] </ref> can be adopted to yield an incremental encryption scheme for (single symbol) insert/delete that is efficient in the strict sense. This is done analogously to the above, provided hat the document length stays within some predetermined bounds (e.g., between `=2 and 2`).
Reference: [Ri] <author> R. Rivest. </author> <title> The MD5 message-digest algorithm. IETF Network Working Group, </title> <type> RFC 1321, </type> <month> April </month> <year> 1992. </year>
References-found: 18

