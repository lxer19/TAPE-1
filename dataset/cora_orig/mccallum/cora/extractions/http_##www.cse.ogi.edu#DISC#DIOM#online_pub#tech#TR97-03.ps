URL: http://www.cse.ogi.edu/DISC/DIOM/online_pub/tech/TR97-03.ps
Refering-URL: http://www.cse.ogi.edu/DISC/DIOM/publication.html
Root-URL: http://www.cse.ogi.edu
Note: Abstract  
Abstract: One of the key issues for query processing in distributed open environments is the query scheduling problem. Given a user query, after we know that there are n sources that are relevant to the answer of this query, the first issue we need to address is how to decompose the query into n subqueries, each targeting at one single source. The second issue is how to synchronize these n subqueries in the presence of inter-site joins. The third issue is how to package and assemble the results from n information sources according to the original query posed by the user. In this thesis, we discuss the first two issues in the context of DIOM, a distributed and inter-operable query mediation system [12]. Our main contribution is the systematic development of the two-tier distributed query scheduling framework that produces the relatively best query schedule according to the given combination of cost parameters, including the total query response time, the local query processing cost, and the communication cost. Our main focus is on queries that contain inter-site joins. The first tier is called the heuristic-driven query processing, which produces a heuristic-based optimal schedule. The second tier is referred to as the cost-driven query processing, which generates a cost-based optimal schedule. We implement a subset of our query scheduling algorithms in Java accessible from any Java-compliant GUI viewer such as Netscape 3.0. The URL for the demo is ugweb.cs.ualberta.ca/~diom/query/EQ.html. The most interesting features of our Java implementation is the functionality to allow users to trace the query scheduling process through trace program interface and the trace logs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. A. Bernstein, N. Goodman, E. Wong, C. L. Reeve, and J. B. Rothnie, Jr., </author> <title> "Query Processing in a System for Distributed Databases (SDD-1)," </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 6, No. 4, </volume> <month> December </month> <year> 1981, </year> <pages> pp. 602-626. </pages>
Reference-contexts: This thesis will address the second issue by providing a theoretical analysis of the two-tier query scheduling architecture, and by applying and extending the heuristic-based and the cost-based query optimization techniques used in relational database management systems [18] and in distributed database systems <ref> [1, 5, 16] </ref>. 1 1.1.1 Query Optimization in Relational Database Systems In a centralized relational database system, given a query, there are a variety of methods for computing the answer. Each way of expressing the query "suggests" a strategy for finding the answer. <p> reduce the expected size of the intermediate result of the query [5, 9, 20]; (b) considering only such join orderings that do not result in Cartesian product between relations [18]; (c) performing the joins whose estimated result is smaller before the joins that are expected to have larger intermediate result <ref> [1] </ref>. 3.3.2 Heuristics Based on Semantic Rewriting According to [14], the query expression passed to the query optimizer after query decomposition and routing phase includes all relevant database sources that were selected to answer the query. <p> A running example is used in this section to illustrate the notions and issues involved. 3.4.1.1 Statistical Model of Relational System <ref> [1] </ref> proposes a statistical model for relational databases, according to which the attribute values in relations are 1. distributed uniformly, 2. statistically independent of the values of other attributes, and 3. statistically independent of other values of the same attribute. <p> Since all the optimization steps have to be completed before the query execution may start, it is impossible to know the actual numbers corresponding to the intermediate results of the processing. It is however possible to estimate these numbers using the statistical information and the model described in <ref> [1, 9, 20] </ref>. The cardinality of the query result depends on the selection power of the qualifying clause of the query. The more the qualifier restricts the result, the greater this selection power is. <p> The other statistical parameters, namely domain cardinality, width of domain, and attribute cardinality, of the result of the union are defined in the same way the largest relation or class extent dominates in defining the characteristics of the union result. <ref> [20, 1] </ref> give the following rules for computing the cardinality of the join result, card (1 A (Q i ; Q j )) = card (Q i ) card (Q j ) maxfcard (Q i :A); card (Q j :A)g ; (3.4) where Q i ; Q j are the operands <p> processing and optimization, and a summary of the work done in the present thesis, it also outlines the contributions of this thesis, and comments on its possible future developments and improvements. 5.1 Overview of Related Work Most theoretical research of the present thesis is based on the results obtained in <ref> [18, 1, 5] </ref>. In this section we provide a brief summary of the main ideas proposed in each of these papers. 5.1.1 Query Optimization in System R The paper describes query optimization techniques used in System R, a centralized experimental database management system based on the relational model [18]. <p> introduced by the presence of inter-site joins; * We use the heuristic-based approach to reduce the solution space of the optimization problem prior to evaluating the cost of each of the query plans, which significantly reduces the complexity of the problem. 5.1.2 Query Processing in SDD-1 The main objective of <ref> [1] </ref> is to describe a technique called semijoin and the application of this technique to distributed query optimization in the distributed version of System R SDD-1. Semijoin is an operation that allows to reduce the quantity of inter-site data transfer needed to execute an inter-site join operation. <p> Semijoin is an operation that allows to reduce the quantity of inter-site data transfer needed to execute an inter-site join operation. The algorithm proposed in this paper consists of three main steps <ref> [1] </ref>: 1. mapping the user query into relational calculus form (referred to as envelope); 2. evaluating the envelope. Evaluation is accomplished by translating the relational calculus query into a program that contains relational operations (referred to as reducers) and the move commands that move the results of reducers. <p> The cost of semijoin is lower than the cost of join. Although the benefit of a semijoin may be lower than the benefit of join, the combination of two symmetrical semijoins results in the same benefit as join. See <ref> [1] </ref> for full definition of the semijoin operator. The authors propose a method to estimate the cost and the benefit of reducers. <p> The authors present the optimization algorithm for performing step 2 of query processing. This algorithm performs an iterative hill-climbing procedure that at each iteration selects the most profitable semijoin and appends it to the resulting query execution program until all profitable semijoins have been exhausted <ref> [1] </ref>. As the authors concede, the proposed algorithm is an example of a greedy optimization algorithm. Such algorithm breaks down the complex optimization problem into simple subproblems and then solves each of these subproblems separately. <p> There are two enhancements to this algorithm proposed in the paper, which we will not discuss here as they do not change the nature of the optimization approach taken by the authors. For details, see <ref> [1] </ref>. The Distributed Query Scheduling prototype that we propose uses many of the ideas presented in this paper. For instance, we propose to employ the same statistical model and the cost estimation techniques for generating the optimal query execution plan. <p> The information about the size of the intermediate results can then be statistically estimated and used for subsequent query operators. The paper also provides a summary of the available heuristic-based optimization techniques, such as applying semijoins "greedily", as done in <ref> [1] </ref>, or enumerating all possible join orders, as done in [18]. As the middle ground, between these two heuristics, the paper proposes to use a "parametric hill climbing" heuristic that examines join sequences of length k at a time, where k is the heuristic parameter. <p> Our work on this topic started from research of the related work in the area of distributed query processing and optimization, namely <ref> [1, 5, 18] </ref>. <p> the heuristic-based query processing component, and the cost-based query processing compo nent; * adapted the the heuristic-based optimization techniques of [5] to the heterogeneous environment of DIOM and proposed a number of modified approaches to heuristic-based query opti mization; 84 * unified the techniques for evaluating the statistical information from <ref> [1, 18] </ref> and generalized them for the prototype of cost-based component of DQS; To provide evidence of viability of the proposed techniques we have carried out a task of implementing these techniques in the form of a Distributed Query Scheduling software that demonstrates the intrinsics of the proposed techniques.
Reference: [2] <author> M. Betz. </author> <title> "Interoperable Objects: Laying The Foundation for Distributed Object Computing," </title> <journal> Dr. Dobb's Journal: Software Tools for Professional Programmer, </journal> <volume> (220), </volume> <month> October </month> <year> 1994. </year>
Reference: [3] <author> R. Cattell et. al., </author> <title> The Object Database Standard: </title> <publisher> ODMG-93 (Release 1.1) Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference: [4] <author> Wesley W. Chu, and Paul Hurley, </author> <title> "Optimal Query Processing for Distributed Database Systems," </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. c-31, No. 9, </volume> <month> September </month> <year> 1982, </year> <pages> pp. 835-850. </pages>
Reference-contexts: Such permutations are done based on equivalent transformations of unary and binary relational algebraic operations, e.g. <ref> [4] </ref> gives an example of enumeration of all possible query plans based on equivalent query transformations. Such transformations are also called algebraic transformations. <p> On the other hand, however, these formulae do not give any clue in derivation of plan generating rules for this query case. To achieve the latter task, one needs to make assumptions concerning the inter-site communication and local on-site processing, similar to the ones made in <ref> [4] </ref>, * the cost of communication of one unit of data between any pair of sites in the distributed system is constant and the same for all sites in the distributed system, or 8 i; j cc ij = cc, and 1 Note that l ([(Q i ; Q j ))
Reference: [5] <author> Umeshwar Dayal, </author> <title> "Query Processing in a Multidatabase System," Query Processing: Database Systems, </title> <editor> eds. Kim, et al., </editor> <publisher> Springer Verlag, </publisher> <address> New York, </address> <booktitle> Vol. </booktitle> <volume> 1, </volume> <pages> pp. 81-108, </pages> <year> 1985. </year>
Reference-contexts: This thesis will address the second issue by providing a theoretical analysis of the two-tier query scheduling architecture, and by applying and extending the heuristic-based and the cost-based query optimization techniques used in relational database management systems [18] and in distributed database systems <ref> [1, 5, 16] </ref>. 1 1.1.1 Query Optimization in Relational Database Systems In a centralized relational database system, given a query, there are a variety of methods for computing the answer. Each way of expressing the query "suggests" a strategy for finding the answer. <p> rules we below present a number of common heuristics that are used in DIOM to limit the search space for the query processor: Heuristic 3.1 (Common Heuristics) (a) moving relational selection and projection operators down the query tree to reduce the expected size of the intermediate result of the query <ref> [5, 9, 20] </ref>; (b) considering only such join orderings that do not result in Cartesian product between relations [18]; (c) performing the joins whose estimated result is smaller before the joins that are expected to have larger intermediate result [1]. 3.3.2 Heuristics Based on Semantic Rewriting According to [14], the query <p> processing and optimization, and a summary of the work done in the present thesis, it also outlines the contributions of this thesis, and comments on its possible future developments and improvements. 5.1 Overview of Related Work Most theoretical research of the present thesis is based on the results obtained in <ref> [18, 1, 5] </ref>. In this section we provide a brief summary of the main ideas proposed in each of these papers. 5.1.1 Query Optimization in System R The paper describes query optimization techniques used in System R, a centralized experimental database management system based on the relational model [18]. <p> we propose to use a more flexible cost model that takes into account not only the communication cost but also the local processing cost and response time parameters. 5.1.3 Query Processing in a Multidatabase System This paper was written to summarize the query processing techniques used in the Multibase system <ref> [5] </ref>. Multibase is a system that integrates a collection of distributed databases that are heterogeneous and possibly inconsistent with one another. It keeps a global schema that facilitates a uniform access to these databases. <p> Due to the fact that the data can be inconsistent across local databases, relational selections and projections on a distributed relation may not always be performed before the relation is materialized at the central site. The authors present a detailed analysis of such cases (see <ref> [5] </ref> for details on this issue). The main architectural difference between the system presented in [5] and DIOM is that DIOM uses query mediator-wrapper approach to solve the problem of heterogeneity of the information producers [14], while the multidatabase model of [5] uses the global schema that logically integrates the local <p> The authors present a detailed analysis of such cases (see <ref> [5] </ref> for details on this issue). The main architectural difference between the system presented in [5] and DIOM is that DIOM uses query mediator-wrapper approach to solve the problem of heterogeneity of the information producers [14], while the multidatabase model of [5] uses the global schema that logically integrates the local databases through the global view mechanism. <p> authors present a detailed analysis of such cases (see <ref> [5] </ref> for details on this issue). The main architectural difference between the system presented in [5] and DIOM is that DIOM uses query mediator-wrapper approach to solve the problem of heterogeneity of the information producers [14], while the multidatabase model of [5] uses the global schema that logically integrates the local databases through the global view mechanism. Due to this difference query processing in DIOM is a more complex problem than in the multidatabase model described in [5]. <p> the problem of heterogeneity of the information producers [14], while the multidatabase model of <ref> [5] </ref> uses the global schema that logically integrates the local databases through the global view mechanism. Due to this difference query processing in DIOM is a more complex problem than in the multidatabase model described in [5]. For instance, such optimizing techniques as semijoins and semiouterjoins can not be used directly. Moreover, the aggregation query functions pose an even greater problem in DIOM environment than in the multidatabase environment. Our version of Distributed Query Scheduling prototype does not address these issues, leaving them for future development. <p> Our version of Distributed Query Scheduling prototype does not address these issues, leaving them for future development. At the same time our prototype does employ such techniques as query cost estimation and moving the joins down, presented in <ref> [5] </ref>. Unlike the system described in [5], DQS prototype uses the global optimization criteria for evaluating the cost of a distributed query (see Chapter 3), which allows to profile the user's preferences. <p> Our version of Distributed Query Scheduling prototype does not address these issues, leaving them for future development. At the same time our prototype does employ such techniques as query cost estimation and moving the joins down, presented in <ref> [5] </ref>. Unlike the system described in [5], DQS prototype uses the global optimization criteria for evaluating the cost of a distributed query (see Chapter 3), which allows to profile the user's preferences. <p> Our work on this topic started from research of the related work in the area of distributed query processing and optimization, namely <ref> [1, 5, 18] </ref>. <p> query scheduling in DIOM environment and the previous work in DIOM [14, 12, 10] we have accomplished the following: * identified the necessary components of the distributed query scheduling prototype, the heuristic-based query processing component, and the cost-based query processing compo nent; * adapted the the heuristic-based optimization techniques of <ref> [5] </ref> to the heterogeneous environment of DIOM and proposed a number of modified approaches to heuristic-based query opti mization; 84 * unified the techniques for evaluating the statistical information from [1, 18] and generalized them for the prototype of cost-based component of DQS; To provide evidence of viability of the proposed
Reference: [6] <author> David Flanagan, </author> <title> Java in a Nutshell, </title> <publisher> O'Reilly & Associates, Inc., </publisher> <address> First Edition, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: In this section we first give a brief overview of the Java language <ref> [6] </ref>, and then discuss the coding issues that we encountered during the coding phase with Java. 4.3.1 Java Programming Language: a Brief Overview Originated as a programming language for consumer electronics in 1990, Java's main goals were to be small, reliable, and architecture independent. <p> There are a number of other attributes of the Java programming language, such as security, high-performance, multi-threaded functionality, dynamic extensibility, and others. <ref> [6] </ref> provides a good reference that explains each of these language attributes in detail. 4.3.2 Distributed Query Scheduling Utility Software Package in Java Since Java is an object-oriented language, a software package written in this language is a collection of class definitions, each of which is a specialization of the system
Reference: [7] <author> O. R. B. T. </author> <title> Force., "The Common Object Request Broker: Architecture and Specification," </title> <booktitle> Object Management Group, </booktitle> <year> 1993. </year>
Reference-contexts: Both of the above conditions may become a serious predicament to a database's performance and extensibility. Quite differently, in an open and interoperable system, such as the DIOM, a project for building scalable and extensible query mediation services <ref> [7, 21] </ref>, DIOM server does not create and maintain an integrated view schema of all the sources' schemas. In contrast, it allows the consumers to request services through the domain-specific mediator. The interconnection of consumers to the relevant information producers is established dynamically at the query processing stage.
Reference: [8] <author> R. Hull and R. King, </author> <title> "Reference Architecture for The Intelligent Integration of Information (version 1.0.1)," </title> <address> http://isse.gmu.edu/I3 Arch/index.html, </address> <month> May </month> <year> 1995. </year>
Reference: [9] <author> Henry F. Korth and Abraham Silberschatz, </author> <title> Database System Concepts, </title> <publisher> McGraw-Hill, </publisher> <address> Inc., </address> <note> Second Edition 1991. </note>
Reference-contexts: This is the main focus and contribution of the research and implementation project reported in this thesis. Since the problem of optimization is NP-complete <ref> [9, 20] </ref>, to achieve feasible query optimization as well as to enhance the effect of the knowledge the user possesses about the idiosyncrasies of the system, heuristic search for solution is performed initially, followed by a full cost-based search in thus reduced solution space. <p> rules we below present a number of common heuristics that are used in DIOM to limit the search space for the query processor: Heuristic 3.1 (Common Heuristics) (a) moving relational selection and projection operators down the query tree to reduce the expected size of the intermediate result of the query <ref> [5, 9, 20] </ref>; (b) considering only such join orderings that do not result in Cartesian product between relations [18]; (c) performing the joins whose estimated result is smaller before the joins that are expected to have larger intermediate result [1]. 3.3.2 Heuristics Based on Semantic Rewriting According to [14], the query <p> Since all the optimization steps have to be completed before the query execution may start, it is impossible to know the actual numbers corresponding to the intermediate results of the processing. It is however possible to estimate these numbers using the statistical information and the model described in <ref> [1, 9, 20] </ref>. The cardinality of the query result depends on the selection power of the qualifying clause of the query. The more the qualifier restricts the result, the greater this selection power is.
Reference: [10] <author> Yoo-Shin Lee, </author> <title> "Prototyping the DIOM Interoperable System (TR96-32)," </title> <institution> Department of Computing Science, University of Alberta, </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: Although the DIOM interoperable architecture and its adaptive query mediation framework has been extensively covered in <ref> [10, 12, 14] </ref>, to make this thesis self-contained, in this chapter we present a brief overview of the fundamental points of the DIOM project. <p> These subqueries are still expressed in DIOM IQL and therefore need to be translated by the wrappers and executed by the individual repositories. The issue of subquery translation and execution is beyond the scope of this thesis and is covered in detail in <ref> [10, 12, 14] </ref>. 2.2.2.5 Query Result Assembly The results of each individual subquery need to be assembled and presented to the user. The specifics of query result assembly are also beyond the scope of this thesis. <p> The overall DIOM framework implemented in <ref> [10] </ref> exemplifies such requirements by using a highly portable html-cgi-oraperl combination of programming environment. Our goal is to create a value-added software package for distributed query scheduling, which is portable across platforms, and can be run by the applications via a network connection without a need for installation or compilation. <p> passed to the corresponding event handling method, which clears all the text components and sets the states of all the checkboxes to the original state; These components are laid out on the query form panel in the same way as has been designed in the IQL interface implementation 1 of <ref> [10] </ref>. The user can navigate through these components by either mouse or keyboard events. The focus is programmatically transferred through the components whenever the user presses the Next Component key, which is assigned to the platform-specific default navigation key. <p> Our work on this topic started from research of the related work in the area of distributed query processing and optimization, namely [1, 5, 18]. Based on the analysis of the task of distributed query scheduling in DIOM environment and the previous work in DIOM <ref> [14, 12, 10] </ref> we have accomplished the following: * identified the necessary components of the distributed query scheduling prototype, the heuristic-based query processing component, and the cost-based query processing compo nent; * adapted the the heuristic-based optimization techniques of [5] to the heterogeneous environment of DIOM and proposed a number of
Reference: [11] <author> Ling Liu, </author> <title> "A recursive object algebra based on aggregation abstraction for manipulating complex objects," </title> <journal> Data & Knowledge Engineering, </journal> <volume> No. 11, </volume> <year> 1993. </year>
Reference: [12] <author> Ling Liu and Calton Pu, </author> <title> "An Adaptive Object-Oriented Approach to Integration and Access of Heterogeneous Information Sources," To appear in Distributed and Parallel Databases: </title> <journal> An International Journal Volume 5, </journal> <volume> No. 2, </volume> <year> 1997. </year>
Reference-contexts: The theoretical model and the architecture for query scheduling are developed based on the previous result of the DIOM <ref> [14, 12] </ref> project. This prototype illustrates the ability to automate the query scheduling process and the ability to allow experienced users to tune the query performance by adjusting the unit costs, the statistics information, and the number of sources accessed to answer the query. <p> concludes the thesis with a brief overview of the state of the art research, and a summary of the contributions of the DQS prototype, the issues addressed by the DQS prototype implementation, and a discussion of possible future improvement. 5 Chapter 2 DIOM Architecture The Distributed Interoperable Object Model (DIOM) <ref> [12, 14] </ref> introduced the approach that explicitly defines the interfaces of an information consumer and an information producer, matching them dynamically to achieve interoperability in heterogeneous information systems with growing number of autonomous data sources as components. <p> Although the DIOM interoperable architecture and its adaptive query mediation framework has been extensively covered in <ref> [10, 12, 14] </ref>, to make this thesis self-contained, in this chapter we present a brief overview of the fundamental points of the DIOM project. <p> The main advantages of using IQL are that the customer need not be aware of the many different naming conventions and terminology used in the underlying information sources nor does the customer need to specify the join conditions. For a detailed definition of IQL, see <ref> [12] </ref>. The above query can be expressed in IQL as follows: SELECT * FROM Customer, Flight, Ticket Order WHERE Flight-&gt;destination CONTAINS 'Europe' AND Flight-&gt;date BETWEEN '01-JAN-96' AND '31-DEC-96' AND Flight-&gt;airline = 'Canadian Airlines International' As was described in section 2.2.1, DIOM query processing consists of five main steps. <p> As pointed out in <ref> [12, 14] </ref>, to generate an efficient query execution plan, two problems need to be solved: * the query processor must find the most optimal (efficient) order in which the query operators are executed, and * each of the query operators need to be assigned to a site where it can be <p> These subqueries are still expressed in DIOM IQL and therefore need to be translated by the wrappers and executed by the individual repositories. The issue of subquery translation and execution is beyond the scope of this thesis and is covered in detail in <ref> [10, 12, 14] </ref>. 2.2.2.5 Query Result Assembly The results of each individual subquery need to be assembled and presented to the user. The specifics of query result assembly are also beyond the scope of this thesis. <p> They can be derived by the IQL parser. This topic is beyond the focus of this thesis. See <ref> [12] </ref>. 53 * Next button event causes the query manager to advance the current state by one, enable Previous and Start buttons, and if the new state becomes the last state, disable this and Finish buttons; * Finish button event triggers the execution of all remaining steps of query processing and <p> Our work on this topic started from research of the related work in the area of distributed query processing and optimization, namely [1, 5, 18]. Based on the analysis of the task of distributed query scheduling in DIOM environment and the previous work in DIOM <ref> [14, 12, 10] </ref> we have accomplished the following: * identified the necessary components of the distributed query scheduling prototype, the heuristic-based query processing component, and the cost-based query processing compo nent; * adapted the the heuristic-based optimization techniques of [5] to the heterogeneous environment of DIOM and proposed a number of <p> Besides the issues specific to the Distributed Query Scheduling software, the DIOM team currently works on a number of other issues that are beyond the scope of this thesis but still are relevant to the problem of query processing <ref> [14, 12] </ref>, e.g., the semi-automatic generation of wrappers to www-html servers, relational database systems, OODB systems, and ASCII file systems (bibtex files). 86
Reference: [13] <author> Ling Liu and Calton Pu, </author> <title> "The Distributed Interoperable Object Model and its Application to Large-Scale Interoperable Database Systems," </title> <booktitle> In ACM International Conference on Information and Knowledge Management (CIKM'95), </booktitle> <address> Baltimore, Maryland, USA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Each mediator consists of a consumer's domain model and many information producer's source models and are described in terms of the DIOM interface definition language (DIOM IDL) <ref> [13] </ref>. The consumer's domain model specifies the querying interests of the consumer and the preferred query result representation. The producer's source models describe the information sources in terms of DIOM internal object representation generated by the DIOM interface manager.
Reference: [14] <author> Ling Liu, Calton Pu, Yooshin Lee, </author> <title> "Adaptive Approach to Query Mediation across Heterogeneous Information Sources," </title> <booktitle> In International Conference on Cooperative Information Systems (CoopIS), </booktitle> <address> Brussels, Belgium, </address> <month> June 13-19, </month> <year> 1996. </year>
Reference-contexts: The theoretical model and the architecture for query scheduling are developed based on the previous result of the DIOM <ref> [14, 12] </ref> project. This prototype illustrates the ability to automate the query scheduling process and the ability to allow experienced users to tune the query performance by adjusting the unit costs, the statistics information, and the number of sources accessed to answer the query. <p> concludes the thesis with a brief overview of the state of the art research, and a summary of the contributions of the DQS prototype, the issues addressed by the DQS prototype implementation, and a discussion of possible future improvement. 5 Chapter 2 DIOM Architecture The Distributed Interoperable Object Model (DIOM) <ref> [12, 14] </ref> introduced the approach that explicitly defines the interfaces of an information consumer and an information producer, matching them dynamically to achieve interoperability in heterogeneous information systems with growing number of autonomous data sources as components. <p> Although the DIOM interoperable architecture and its adaptive query mediation framework has been extensively covered in <ref> [10, 12, 14] </ref>, to make this thesis self-contained, in this chapter we present a brief overview of the fundamental points of the DIOM project. <p> The DIOM Distributed Query Scheduling Framework 2.2.1 An Overview of the Main Steps The main task of a distributed query mediation manager is to coordinate the communication and distribution of the processing of information consumer's query requests among the root mediator and its component mediators or wrappers (recall Figure 2-1). <ref> [14] </ref> has proposed the general procedure of a distributed query scheduling process in DIOM. <p> Given a query request, there are often more than one way to reduce the search space of the query, even with applying heuristics such as proposed in <ref> [14] </ref>. For instance, one of the possible tactics in reducing the solution space is to discard the query execution plans that are obviously non-optimal, thus leaving only the promising plan candidates. This includes discarding certain nonoptimal orders of execution of query operators. [14] gives an example of such tactics that when <p> even with applying heuristics such as proposed in <ref> [14] </ref>. For instance, one of the possible tactics in reducing the solution space is to discard the query execution plans that are obviously non-optimal, thus leaving only the promising plan candidates. This includes discarding certain nonoptimal orders of execution of query operators. [14] gives an example of such tactics that when two query operators, with strict and non-strict selections, need to be ordered, the priority is given to the strict one, which has greater selectivity than the non-strict, e.g., = operator is more selective than &gt; operator, therefore query operators that have the <p> As pointed out in <ref> [12, 14] </ref>, to generate an efficient query execution plan, two problems need to be solved: * the query processor must find the most optimal (efficient) order in which the query operators are executed, and * each of the query operators need to be assigned to a site where it can be <p> These subqueries are still expressed in DIOM IQL and therefore need to be translated by the wrappers and executed by the individual repositories. The issue of subquery translation and execution is beyond the scope of this thesis and is covered in detail in <ref> [10, 12, 14] </ref>. 2.2.2.5 Query Result Assembly The results of each individual subquery need to be assembled and presented to the user. The specifics of query result assembly are also beyond the scope of this thesis. <p> the query [5, 9, 20]; (b) considering only such join orderings that do not result in Cartesian product between relations [18]; (c) performing the joins whose estimated result is smaller before the joins that are expected to have larger intermediate result [1]. 3.3.2 Heuristics Based on Semantic Rewriting According to <ref> [14] </ref>, the query expression passed to the query optimizer after query decomposition and routing phase includes all relevant database sources that were selected to answer the query. The first semantic-based rewriting rule is to eliminate the sources that do not contain join attributes required in the query. <p> The authors present a detailed analysis of such cases (see [5] for details on this issue). The main architectural difference between the system presented in [5] and DIOM is that DIOM uses query mediator-wrapper approach to solve the problem of heterogeneity of the information producers <ref> [14] </ref>, while the multidatabase model of [5] uses the global schema that logically integrates the local databases through the global view mechanism. Due to this difference query processing in DIOM is a more complex problem than in the multidatabase model described in [5]. <p> Our work on this topic started from research of the related work in the area of distributed query processing and optimization, namely [1, 5, 18]. Based on the analysis of the task of distributed query scheduling in DIOM environment and the previous work in DIOM <ref> [14, 12, 10] </ref> we have accomplished the following: * identified the necessary components of the distributed query scheduling prototype, the heuristic-based query processing component, and the cost-based query processing compo nent; * adapted the the heuristic-based optimization techniques of [5] to the heterogeneous environment of DIOM and proposed a number of <p> Besides the issues specific to the Distributed Query Scheduling software, the DIOM team currently works on a number of other issues that are beyond the scope of this thesis but still are relevant to the problem of query processing <ref> [14, 12] </ref>, e.g., the semi-automatic generation of wrappers to www-html servers, relational database systems, OODB systems, and ASCII file systems (bibtex files). 86
Reference: [15] <author> L. Liu, C. Pu, R. Barga, and T. Zhou, </author> <title> "Differential Evaluation of Continual Queries," </title> <booktitle> In IEEE Proceedings of the 16 th International Conference on Distributed Computing Systems, </booktitle> <address> Hong Kong, </address> <month> May, </month> <year> 1996. </year>
Reference-contexts: and analysis of their effect on query processing; * incorporation of a richer functionality front-end component of the software, e.g., the option to install the query to DIOM server; * incorporation of the complete query routing and the query result assembly modules into the package; * support of continual queries <ref> [15] </ref> as a possible option for distributed query scheduling; * adaptation of JDBC technology to facilitate more efficient data access between the client and the DIOM server.
Reference: [16] <author> M. Tamer Ozsu and Patrick Valduriez, </author> <title> Principles of Distributed Database Systems, </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: This thesis will address the second issue by providing a theoretical analysis of the two-tier query scheduling architecture, and by applying and extending the heuristic-based and the cost-based query optimization techniques used in relational database management systems [18] and in distributed database systems <ref> [1, 5, 16] </ref>. 1 1.1.1 Query Optimization in Relational Database Systems In a centralized relational database system, given a query, there are a variety of methods for computing the answer. Each way of expressing the query "suggests" a strategy for finding the answer. <p> This increases the solution space from which to choose the distributed execution strategy, making distributed query processing significantly more sophisticated. For a concrete introduction of distributed query processing, readers may refer to Ozsu and Valduriez's book <ref> [16] </ref>. 1.1.3 Open Interoperable Database Systems Over the last two decades, there have been many research publications in the field of distributed databases and federated databases. Traditional distributed database systems have a dedicated central site that keeps the schema of the database, including the fragmentation and location information schemas. <p> Unlike DIOM, which is a distributed system, the work presented in this paper is targeted at a centralized database management system. This fundamental difference does not allow us to employ most of the query optimization techniques described in this paper <ref> [16] </ref>.
Reference: [17] <author> Roger S. Pressman, </author> <title> Software Engineering, A Practitioner's Approach, McGraw-Hill, </title> <booktitle> Third International Edition, </booktitle> <year> 1992. </year> <month> 87 </month>
Reference-contexts: As any software system <ref> [17] </ref>, the fundamental steps of this engineering process require analysis, design, and the actual coding of the software. The task of implementing the DIOM Query Scheduling Utility can be seen as a demonstration of viability of the ideas and principles presented in Chapter 3. <p> The requirements analysis is a top-down, or general-to-particular process, in which software requirements are gradually refined and finalized in some form that is acceptable to the next phase, software design <ref> [17] </ref>. 4.1.1 Analysis of Non-Functional Requirements 4.1.1.1 Portability Since the current implementation is a component of a greater project, there are certain portability requirements that need to be fulfilled. The overall DIOM framework implemented in [10] exemplifies such requirements by using a highly portable html-cgi-oraperl combination of programming environment. <p> To ensure a good and robust implementation of the Distributed Query Scheduling software package the object-oriented techniques have been used throughout the entire course of analysis, design, and development. 4.1.2 Functional System Requirements To cover the functionality of the Distributed Query Scheduling software utility we use the data flow diagrams <ref> [17] </ref> to identify the main components of the system architecture. The diagram representing the top-level functionality of DIOM Query Scheduling Utility is shown in Figure 4-1. Each of the entities in the diagram relates to one or more entities in another group, which is shown with the lines connecting them.
Reference: [18] <author> P. G. Selinger, M. M. Astrahan, D. D. Chamberlin, R. A. Lorie, T. G. Price, </author> <title> "Access Path Selection in a Relational Database Management System," </title> <booktitle> Proceedings of ACM-SIGMOD, </booktitle> <pages> pp. 82-93, </pages> <year> 1979. </year>
Reference-contexts: This thesis will address the second issue by providing a theoretical analysis of the two-tier query scheduling architecture, and by applying and extending the heuristic-based and the cost-based query optimization techniques used in relational database management systems <ref> [18] </ref> and in distributed database systems [1, 5, 16]. 1 1.1.1 Query Optimization in Relational Database Systems In a centralized relational database system, given a query, there are a variety of methods for computing the answer. Each way of expressing the query "suggests" a strategy for finding the answer. <p> space for the query processor: Heuristic 3.1 (Common Heuristics) (a) moving relational selection and projection operators down the query tree to reduce the expected size of the intermediate result of the query [5, 9, 20]; (b) considering only such join orderings that do not result in Cartesian product between relations <ref> [18] </ref>; (c) performing the joins whose estimated result is smaller before the joins that are expected to have larger intermediate result [1]. 3.3.2 Heuristics Based on Semantic Rewriting According to [14], the query expression passed to the query optimizer after query decomposition and routing phase includes all relevant database sources that <p> One needs to estimate the selectivity factor of each of such components as well as of their combination to effectively estimate the cardinality of the query result. System R <ref> [18] </ref>, a research prototype of database management system DB2, was the first one that used selectivity factors for cost-based query optimization. In this section we have tried to generalize the formulae for estimating the selectivity factors, and subdivide them based on their category and the types of their operands. <p> The size of the input to the union operation will then be reduced by the selectivity factor of each of the selection and projection operators. Previous studies in relational DBMS optimization, e.g., <ref> [18] </ref>, have shown that moving the unary operations in the query tree towards the bottom of the tree is the necessary condition for producing an optimal query execution plan. The given expression with unary operations pushed down may still result in a number of execution plans. <p> processing and optimization, and a summary of the work done in the present thesis, it also outlines the contributions of this thesis, and comments on its possible future developments and improvements. 5.1 Overview of Related Work Most theoretical research of the present thesis is based on the results obtained in <ref> [18, 1, 5] </ref>. In this section we provide a brief summary of the main ideas proposed in each of these papers. 5.1.1 Query Optimization in System R The paper describes query optimization techniques used in System R, a centralized experimental database management system based on the relational model [18]. <p> In this section we provide a brief summary of the main ideas proposed in each of these papers. 5.1.1 Query Optimization in System R The paper describes query optimization techniques used in System R, a centralized experimental database management system based on the relational model <ref> [18] </ref>. Query processing in this system consists of four phases: parsing, optimization, code generation, and execution. The main focus of the paper is on the optimization phase. <p> To reduce the number of join order permutations the authors propose to use a heuristic by which the joins between relations that do not have a common join column, i.e., the ones requiring Cartesian product, are performed as late in the join sequence as possible <ref> [18] </ref>. <p> The contributions of the query optimizer are the following <ref> [18] </ref>: * extensive use of statistical information in estimating the cost of the query execution plan; * global query optimization, which is achieved by exhaustive search of all possible join orders; * inclusion of order by and group by clauses into the process of optimization, which results in avoiding the need <p> The paper also provides a summary of the available heuristic-based optimization techniques, such as applying semijoins "greedily", as done in [1], or enumerating all possible join orders, as done in <ref> [18] </ref>. As the middle ground, between these two heuristics, the paper proposes to use a "parametric hill climbing" heuristic that examines join sequences of length k at a time, where k is the heuristic parameter. <p> Our work on this topic started from research of the related work in the area of distributed query processing and optimization, namely <ref> [1, 5, 18] </ref>. <p> the heuristic-based query processing component, and the cost-based query processing compo nent; * adapted the the heuristic-based optimization techniques of [5] to the heterogeneous environment of DIOM and proposed a number of modified approaches to heuristic-based query opti mization; 84 * unified the techniques for evaluating the statistical information from <ref> [1, 18] </ref> and generalized them for the prototype of cost-based component of DQS; To provide evidence of viability of the proposed techniques we have carried out a task of implementing these techniques in the form of a Distributed Query Scheduling software that demonstrates the intrinsics of the proposed techniques.
Reference: [19] <author> A. Sheth and J. Larson. </author> <title> "Federated database systems for managing distributed, heterogeneous, and autonomous databases," </title> <journal> ACM Computing Surveys., </journal> <volume> Vol. 22, No.3, </volume> <pages> pp. 183-236, </pages> <year> 1990. </year>
Reference-contexts: The main difference between distributed or federated database systems and open interoperable database systems is the open world assumption. The distributed database systems and the federated database systems <ref> [19] </ref> are based on the closed-world assumption, whereas in open environments such as Internet, the information sources available on-line are changing in numbers, volume, contents and query capabilities dynamically.
Reference: [20] <author> Jeffrey D. Ullman, </author> <title> Principles of Database Systems, </title> <note> Computer Science Press, Second Edition 1982. </note>
Reference-contexts: This is the main focus and contribution of the research and implementation project reported in this thesis. Since the problem of optimization is NP-complete <ref> [9, 20] </ref>, to achieve feasible query optimization as well as to enhance the effect of the knowledge the user possesses about the idiosyncrasies of the system, heuristic search for solution is performed initially, followed by a full cost-based search in thus reduced solution space. <p> rules we below present a number of common heuristics that are used in DIOM to limit the search space for the query processor: Heuristic 3.1 (Common Heuristics) (a) moving relational selection and projection operators down the query tree to reduce the expected size of the intermediate result of the query <ref> [5, 9, 20] </ref>; (b) considering only such join orderings that do not result in Cartesian product between relations [18]; (c) performing the joins whose estimated result is smaller before the joins that are expected to have larger intermediate result [1]. 3.3.2 Heuristics Based on Semantic Rewriting According to [14], the query <p> Since all the optimization steps have to be completed before the query execution may start, it is impossible to know the actual numbers corresponding to the intermediate results of the processing. It is however possible to estimate these numbers using the statistical information and the model described in <ref> [1, 9, 20] </ref>. The cardinality of the query result depends on the selection power of the qualifying clause of the query. The more the qualifier restricts the result, the greater this selection power is. <p> The other statistical parameters, namely domain cardinality, width of domain, and attribute cardinality, of the result of the union are defined in the same way the largest relation or class extent dominates in defining the characteristics of the union result. <ref> [20, 1] </ref> give the following rules for computing the cardinality of the join result, card (1 A (Q i ; Q j )) = card (Q i ) card (Q j ) maxfcard (Q i :A); card (Q j :A)g ; (3.4) where Q i ; Q j are the operands
Reference: [21] <author> G. Wiederhold, </author> <title> Intelligent Information Integration Glossary, </title> <type> Draft 7, </type> <month> March 16, </month> <year> 1995. </year>
Reference-contexts: Both of the above conditions may become a serious predicament to a database's performance and extensibility. Quite differently, in an open and interoperable system, such as the DIOM, a project for building scalable and extensible query mediation services <ref> [7, 21] </ref>, DIOM server does not create and maintain an integrated view schema of all the sources' schemas. In contrast, it allows the consumers to request services through the domain-specific mediator. The interconnection of consumers to the relevant information producers is established dynamically at the query processing stage.
Reference: [22] <author> Yao, </author> <title> S.B., "Approximating block accesses in database organizations," </title> <journal> Communications of The ACM, </journal> <volume> Vol. 20, </volume> <month> 4 (April), </month> <pages> pp. 260-261, </pages> <year> 1977. </year> <month> 88 </month>
Reference-contexts: To estimate the attribute cardinalities we use the approach taken in <ref> [22] </ref>, which presents the problem in the following way: Given n records grouped into m blocks (1 &lt; m n), each contains n=m records, if k records (k n n=m) are randomly selected from the n records, the expected number of blocks hit by the selection (blocks with at least one
References-found: 22

