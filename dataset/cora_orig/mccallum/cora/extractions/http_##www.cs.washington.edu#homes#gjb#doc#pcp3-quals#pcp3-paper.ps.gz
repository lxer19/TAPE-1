URL: http://www.cs.washington.edu/homes/gjb/doc/pcp3-quals/pcp3-paper.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/gjb/doc/pcp3-quals/index.htm
Root-URL: 
Email: gjb@cs.washington.edu  
Title: PCp 3 A C Front End for Preprocessor Analysis and Transformation  
Author: Greg J. Badros 
Date: 16 October 1997  
Abstract: Though the C preprocessor provides necessary language features, it does so in an unstructured way. The lexical nature of cpp creates numerous problems for software engineers and their tools, all stemming from the chasm between the engineer's view of the source code and the compiler's view. The simplest way to reduce this problem is to minimize use of the preprocessor. In light of the data collected in a prior empirical analysis, this paper describes a tool to aid the software engineer in analyses targeted at replacing preprocessor constructs with language features. Existing tools for analyzing C source in the context of the preprocessor are unsuitable for such transformations. This work introduces a new approach: tightly integrating the preprocessor with a C language parser, permitting the code to be analyzed at both the preprocessor and syntactic levels simultaneously. The front-end framework, called PCp 3 , combines a preprocessor, a parser, and arbitrary Perl subroutine "hooks" invoked upon various preprocessor and parser events. PCp 3 's strengths and weaknesses are discussed in the context of several program understanding and transformation tools, including a conservative analysis to support replacing cpp's #define directives with C++ language features.
Abstract-found: 1
Intro-found: 1
Reference: [AG96] <author> Darren C. Atkinson and William G. Griswold. </author> <title> The design of whole-program analysis tools. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <pages> pages 16-27, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: To better support reasoning about an entire source code artifact, a database approach similar to CIA++ [GC92] could be used. Atkinson and Griswold mention the importance of flexibility in allowing the user to select the appropriate balance between precision and performance of a whole-program analysis <ref> [AG96] </ref>. Extending PCp 3 to permit specified variables to persist between invocations on separate translation units could be implemented easily by reusing one of the existing data persistency modules, and would provide such flexibility. Converting to language features need not be limited to using C++.
Reference: [ASU86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference: [CC93] <author> James R. Cordy and Ian H. </author> <title> Carmichael. The TXL Programming Language Syntax and Informal Semantics, </title> <type> Version 7. </type> <institution> Software Technology Laboratory, Queen's University at Kingston, Kingston, Canada, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Evans's focus is on finding errors, and the analysis of macro expansions is fairly uninvolved [Eva96, Ch. 8]. Cordy and Carmichael designed TXL as a language to support arbitrary transformations on abstract syntax trees <ref> [CC93] </ref>. Their work is not targeted specifically to C code, and ignores issues relating to the preprocessor. TXL uses a grammar to parse the language and creates the tree, then applies some transformations directly on the tree, and uses an "unparser" to write the new source code back. <p> Converting to language features need not be limited to using C++. Many are interested in 16 converting legacy C code into Java code. Such transformations would also greatly benefit from a generalized AST since the TXL paradigm of parse, process, unparse <ref> [CC93] </ref> seems more appropriate for converting between source languages with significant differences. Although no tuning has been done yet, PCp 3 exhibits performance comparable to an optimizing compiler.
Reference: [CE95] <author> Martin Carroll and Margaret Ellis. </author> <title> Designing and Coding Reusable C++. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The two appendices provide more details about the PCp 3 interfaces. 2 How the preprocessor is used in practice Many cpp constructs have analogues in newer language features. Carroll and Ellis list several preprocessor uses and explain what C++ features could be used instead <ref> [CE95] </ref>. For example, 3 #defines of simple numeric and string constants can often be replaced with enumeration declar-ations or static constant variable declarations (both newer features of ANSI C, not just of C++). <p> Carroll and Ellis make the strong claim that "C++ provides mechanisms that obviate the need for most macros" <ref> [CE95, p. 147] </ref>. They list numerous uses of the preprocessor and describe the C++ language features that could replace them. Their advice is mostly prescriptive and is directed to the new C++ programmer who might be inclined to overuse cpp constructs as a crutch instead of exploiting C++ language features.
Reference: [Com96] <author> C++ Standards Committee. </author> <title> C++ standard, committee draft 2. Electronic web pages, </title> <month> December </month> <year> 1996. </year> <month> ftp://ftp.bby.com.au/pub/wphtml-cd2.tar.gz. </month>
Reference-contexts: However, casting away C in favor of almost any modern language would necessitate discarding many millions of lines of useful legacy code. The one notable exception is C++ <ref> [Com96] </ref>. For compatibility with C, C++ remains encumbered by cpp, but it also provides language-level support for many higher level constructs, which makes numerous cpp constructs redundant. Migrating C code to C++ potentially provides a path to reduce usage of the preprocessor to the benefit of tools and programmers. <p> Rammoorthy Sridharan, a researcher in the group, developed a novel technique for handling preprocessor directives. Before preprocessing, conditional compilation directives are converted to claration <ref> [Com96] </ref>. Because of the "misfeature" of such declarations still requiring definitions outside of the class, Stroustrup still recommends using enums for static integral constant members (i.e., the "enum hack") [Str97, p. 249]. 13 BAR, and BONG are conservatively not converted because they are used specially.
Reference: [CS92] <author> James R. Cordy and Medha Shukla. </author> <title> Practical metaprogramming. </title> <booktitle> In Proceedings of the 1992 Centre for Advanced Studies Conference, </booktitle> <month> November </month> <year> 1992. </year>
Reference: [Dav97] <author> Mark Davis. </author> <title> Java cookbook: Porting C++ to Java. </title> <note> Taligent White Paper, 1997. http://www.taligent.com/Technology/WhitePapers/PortingPaper. </note>
Reference-contexts: Their technique applies only to C functions after they have been preprocessed. Davis provides a thorough review of the issues involved in translating C++ language constructs to Java. He ignores the preprocessor and its contribution to C++ source code artifacts <ref> [Dav97] </ref>. Laffra's C2J and Tilevich's derived C2J++ claim to convert C and C++ to Java code. Their approach is a combination of lexical and parser-based, and is focussed only on reducing tedious editing when porting an application to Java.
Reference: [Dev92] <author> Prem Devanbu. </author> <title> GENOA a customizable, language and front-end independent code analyzer. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering, </booktitle> <pages> pages 307-317, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: These tools cannot use a straightforward parser or construct an accurate abstract syntax tree because the source is not grammatically-correct C code. Lexical tools such as etags, LSME [MN96], and font-lock-mode for Emacs and approximate parsers such as Genoa <ref> [Dev92] </ref>, and LCLint [Eva96] use this approach. In general, this leads to greater speed (especially for the lexical approach) and improved robustness in handling syntax errors and language variants (approximate parsers generally lose the current top level construct at worst, and often do better).
Reference: [EBN97a] <author> Michael Ernst, Greg Badros, and David Notkin. </author> <title> An empirical study of C preprocessor use. To replace technical report UW-CSE-97-04-06 upon completion., </title> <month> October </month> <year> 1997. </year>
Reference-contexts: A fundamental motivation in the design of PCp 3 is to automatically assist in such transformations. 1.3 Outline Section 2 highlights significant findings from an empirical study of C preprocessor use <ref> [EBN97a] </ref> with an emphasis on determining what fraction of its use in existing software artifacts can be replaced by C++ language features. Section 3 describes the tool developed to support accurate analysis of unprocessed code without losing the high level abstractions expressed with the preprocessor. <p> elimination can effect the same result as a conditional compilation directive guarding debug-only code. (The compiler-based mechanism does not assist in conditionally-included declarations, though.) Over the last year, several colleagues and the author have investigated how the C preprocessor is used in a sample of 30 freely available software packages <ref> [EBN97a] </ref>. Our findings show that the preprocessor is used very heavily|almost 10% of the lines 4 in the packages analyzed contain preprocessor directives. About a third of these are macro definitions, a bit more than a third are conditional compilation directives, and the remainder are mostly #includes. <p> Though actually a compiled language, Perl's compilation phase is exceedingly fast and integrated with the execution; thus it has the same advantages in reducing developer time as interpreted languages, yet its performance is substantially better. Additionally, most of the tools for the empirical study of C preprocessor use <ref> [EBN97a] </ref> are written in Perl, enabling reuse. 5 Hence its name, PCppP, shortened to PCp 3 . 6 Ironically, the preprocessor came to the rescue here; macros provided an easy way to rename CTree's symbols from its automatically-generated parsers and lexical analyzer which conflicted with those used when embedding Perl. 6 <p> See [Har91, Ch. 3] for details of what is required by the C language standard. Also note that details of stringization and pasting are omitted as they are infrequently used features <ref> [EBN97a] </ref>. 9 Or, if the invocation does not directly appear in the source (i.e., the macro appears in the expansion of another macro), the location is an offset within the prior macro's expansion. 8 the order in which the hooks are called (corresponding to post-order traversal of the tree).
Reference: [EBN97b] <author> Michael Ernst, Greg Badros, and David Notkin. </author> <title> An empirical study of C preprocessor use. </title> <type> Technical Report UW-CSE-97-04-06, </type> <institution> University of Washington, </institution> <month> April </month> <year> 1997. </year>
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1990. </year>
Reference: [Eva96] <author> David Evans. </author> <title> LCLint User's Guide. </title> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, MA, v2.2 edition, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: These tools cannot use a straightforward parser or construct an accurate abstract syntax tree because the source is not grammatically-correct C code. Lexical tools such as etags, LSME [MN96], and font-lock-mode for Emacs and approximate parsers such as Genoa [Dev92], and LCLint <ref> [Eva96] </ref> use this approach. In general, this leads to greater speed (especially for the lexical approach) and improved robustness in handling syntax errors and language variants (approximate parsers generally lose the current top level construct at worst, and often do better). <p> For example, a macro argument can be marked that it needs to be side-effect free at an invocation site, and LCLint will generate a warning message if that constraint is violated. Evans's focus is on finding errors, and the analysis of macro expansions is fairly uninvolved <ref> [Eva96, Ch. 8] </ref>. Cordy and Carmichael designed TXL as a language to support arbitrary transformations on abstract syntax trees [CC93]. Their work is not targeted specifically to C code, and ignores issues relating to the preprocessor.
Reference: [Fla96] <author> David Flanagan. </author> <title> Java in a Nutshell. </title> <publisher> O'Reilly & Associates, Inc., </publisher> <address> Sebastopol, California, </address> <year> 1996. </year>
Reference: [Fli97] <author> Shaun Flisakowski. </author> <title> CTree distribution, </title> <journal> v0.5. </journal> <note> Freely available software package, July 1997. ftp://ftp.kagi.com/flisakow/ctree 05.tar.gz. </note>
Reference-contexts: Choosing a parser was difficult as there are many freely available parsers, often tightly coupled to a functional back-end, thus complicating reuse. The parser from CTree <ref> [Fli97] </ref>, a freely available C front end was chosen to embed in PCp 3 . Its lexical analyzer and parser both are mechanically generated by flex [Fou95, Lev92] and bison [Fou92, Lev92] (freely available implementations of lex and yacc, respectively).
Reference: [Fou92] <institution> Free Software Foundation. Bison distribution, v1.25. </institution> <note> Freely available software package, </note> <month> April </month> <year> 1992. </year> <month> ftp://prep.ai.mit.edu/pub/bison-1.25.tar.gz. </month>
Reference-contexts: The parser from CTree [Fli97], a freely available C front end was chosen to embed in PCp 3 . Its lexical analyzer and parser both are mechanically generated by flex [Fou95, Lev92] and bison <ref> [Fou92, Lev92] </ref> (freely available implementations of lex and yacc, respectively). As CTree parses, it builds a complete abstract syntax tree of the preprocessed code. It also implements a fully scoped symbol table, assuming another essential duty for PCp 3 .
Reference: [Fou95] <institution> Free Software Foundation. </institution> <note> Flex distribution, v2.5. Freely available software package, </note> <month> March </month> <year> 1995. </year> <note> ftp://prep.ai.mit.edu/pub/flex-2.5.tar.gz. 24 </note>
Reference-contexts: The parser from CTree [Fli97], a freely available C front end was chosen to embed in PCp 3 . Its lexical analyzer and parser both are mechanically generated by flex <ref> [Fou95, Lev92] </ref> and bison [Fou92, Lev92] (freely available implementations of lex and yacc, respectively). As CTree parses, it builds a complete abstract syntax tree of the preprocessed code. It also implements a fully scoped symbol table, assuming another essential duty for PCp 3 .
Reference: [Fou97] <institution> Free Software Foundation. GCC distribution, v2.7.2.2. </institution> <note> Freely available software pack-age, January 1997. ftp://prep.ai.mit.edu/pub/gcc-2.7.2.tar.gz. </note>
Reference-contexts: Most of the changes to the parser were to eliminate name conflicts 6 and introduce calls to the various action routines. 3.2 Preprocessor Since it is essential that the framework mimic cpp exactly, the C preprocessing library from the GNU C compiler's (gcc) well-tested (and slightly extended) cpp <ref> [Fou97] </ref> is embedded in PCp 3 . By using gcc's cpplib, PCp 3 is able to consider both the unprocessed and the preprocessed views of source code.
Reference: [GAM96] <author> William G. Griswold, Darren C. Atkinson, and Collin McCurdy. </author> <title> Fast, flexible syntactic pattern matching and processing. </title> <booktitle> In Proceedings of the IEEE 1996 Workshop on Program Comprehension, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: Griswold and Atkinson studied mistakes in call graph extraction using various tools and found that macro expansion was a major cause of both false positives and false negatives <ref> [GAM96] </ref>. Such approximate tools are inappropriate for software engineering analyses that require exact or conservative information. An obvious solution to the problems cpp presents is to just avoid it, and therefore C, entirely. <p> Griswold and Atkinson note that various software tools benefited from using a special-purpose interpreted action language <ref> [GAM96] </ref>. In general, interpreted languages can speed development time [Ous97], especially when prototyping analyses. For PCp 3 , Perl [Wal97, WCS96] was chosen because it interfaces easily with C and is used widely. <p> Griswold and Atkinson review a number of them while motivating their TAWK tool <ref> [GAM96] </ref>. TAWK uses C as its action language and matches patterns in the abstract syntax tree. They take significant pains to handle macros correctly, since they use a parser which could otherwise be too fragile.
Reference: [GC92] <author> Judith E. Grass and Yih-Farn Chen. </author> <title> The C++ information abstractor. </title> <booktitle> In Proceedings of the USENIX 1992 C++ Conference, </booktitle> <address> Portland, Oregon, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: This complicates whole-program analysis. The Emacs-based text annotations provides only rudimentary support for combining information derived from various translation units. To better support reasoning about an entire source code artifact, a database approach similar to CIA++ <ref> [GC92] </ref> could be used. Atkinson and Griswold mention the importance of flexibility in allowing the user to select the appropriate balance between precision and performance of a whole-program analysis [AG96].
Reference: [Gli97] <author> Bob Glickstein. </author> <title> Writing GNU Emacs Extensions. </title> <publisher> O'Reilly & Associates, Inc., </publisher> <address> Se-bastopol, California, </address> <year> 1997. </year>
Reference: [Har91] <author> Samuel P. Harbison. </author> <title> C: A Reference Manual. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <note> 3rd edition, </note> <year> 1991. </year>
Reference-contexts: 1 Introduction More than twenty years ago, Dennis Ritchie designed the C language [KR88] to include a textual macro preprocessor called cpp <ref> [Har91, Ch. 3] </ref>. Given the simplicity of the language and the state of the art in compiler technology in the mid-1970s, his decision to provide some language features in this extra-linguistic tool may have been justified. <p> See <ref> [Har91, Ch. 3] </ref> for details of what is required by the C language standard.
Reference: [KR88] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, 2nd edition, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction More than twenty years ago, Dennis Ritchie designed the C language <ref> [KR88] </ref> to include a textual macro preprocessor called cpp [Har91, Ch. 3]. Given the simplicity of the language and the state of the art in compiler technology in the mid-1970s, his decision to provide some language features in this extra-linguistic tool may have been justified.
Reference: [KS94] <author> Maren Krone and Gregor Snelting. </author> <title> On the inference of configuration structures from source code. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 49-57. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: Another significant disadvantage of preprocessing is that it eliminates conditional compilation artifacts that are essential to the portability and versatility of the source code (see <ref> [KS94] </ref>). Preprocessing forces tools to limit their analysis to a single configuration of the source code, instead of permitting global reasoning about the entire artifact. Some tools choose a different tradeoff and operate instead on the unprocessed source code exactly as the programmer sees it. <p> compiler [Str97, p. 816-820]. 12 Personal inquiries of that paper's authors also led to no pointers. 15 #if guards depend on and relate to each other, and provide a means of visualizing the relationships with the goal of improving the programmer's understanding of the structure and properties of the configurations <ref> [KS94] </ref>. 6 Conclusion PCp 3 is a flexible infrastructure for exposing C preprocessor manipulations while performing an accurate parse and creating an abstract syntax tree. <p> This would permit future blocks of code that are #ifdefed out to be properly influenced by prior blocks of code using the same guard. Krone and Snelting's work suggests that the number of distinct paths through the source is reasonably bounded <ref> [KS94] </ref>. A generalized symbol table could encapsulate information about which versions contain each symbol, and how the type depends on macro names used in conditional compilation guards. A similar generalization could be made for the preprocessor name table.
Reference: [Laf97] <author> Chris Laffra. C2J. </author> <note> Freely available software package, 1997. http://members.aol.com/laffra/c2j.html. </note>
Reference-contexts: Compilers necessarily sit at one extreme of the transformation spectrum|they must absolutely preserve semantics of their source language as they lower the level of abstraction to machine instructions. Other tools perform source-to-source transformations mostly as an editing aid, largely disregarding semantics <ref> [Laf97, Til97] </ref>. Software engineering source-to-source transformations can afford to be slightly less stringent than a compiler, but should strive to be more than just an editing tool.
Reference: [Lev92] <author> John R. Levine. </author> <title> Lex & Yacc. </title> <publisher> O'Reilly & Associates, Inc., </publisher> <address> Sebastopol, California, 2nd edition, </address> <year> 1992. </year>
Reference-contexts: The parser from CTree [Fli97], a freely available C front end was chosen to embed in PCp 3 . Its lexical analyzer and parser both are mechanically generated by flex <ref> [Fou95, Lev92] </ref> and bison [Fou92, Lev92] (freely available implementations of lex and yacc, respectively). As CTree parses, it builds a complete abstract syntax tree of the preprocessed code. It also implements a fully scoped symbol table, assuming another essential duty for PCp 3 . <p> The parser from CTree [Fli97], a freely available C front end was chosen to embed in PCp 3 . Its lexical analyzer and parser both are mechanically generated by flex [Fou95, Lev92] and bison <ref> [Fou92, Lev92] </ref> (freely available implementations of lex and yacc, respectively). As CTree parses, it builds a complete abstract syntax tree of the preprocessed code. It also implements a fully scoped symbol table, assuming another essential duty for PCp 3 .
Reference: [LLST94] <author> Bil Lewis, Dan LaLiberte, Richard Stallman, </author> <title> and The GNU Manual Group. GNU Emacs Lisp Reference Manual. Free Software Foundation, </title> <address> Cambridge, Massachusetts, 2nd edition, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: The standard module of hook utilities provides a mechanism to output character-indexed annotations of the source code. These annotations are Emacs Lisp source code which manipulate text properties of character ranges when evaluated by Emacs <ref> [LLST94] </ref>. This provides a useful mechanism (indeed, essential during the debugging of the framework) for visualizing the results of the analyses within the context of the code analyzed.
Reference: [MN96] <author> Gail C. Murphy and David Notkin. </author> <title> Lightweight lexical source model extraction. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 5(3) </volume> <pages> 263-291, </pages> <month> July </month> <year> 1996. </year>
Reference-contexts: Some tools choose a different tradeoff and operate instead on the unprocessed source code exactly as the programmer sees it. These tools cannot use a straightforward parser or construct an accurate abstract syntax tree because the source is not grammatically-correct C code. Lexical tools such as etags, LSME <ref> [MN96] </ref>, and font-lock-mode for Emacs and approximate parsers such as Genoa [Dev92], and LCLint [Eva96] use this approach.
Reference: [Ous97] <author> John Ousterhout. </author> <title> Scripting: Higher level programming for the 21st century. Web document, </title> <month> March </month> <year> 1997. </year> <note> http://www.sunlabs.com/people/john.ousterhout. </note>
Reference-contexts: Griswold and Atkinson note that various software tools benefited from using a special-purpose interpreted action language [GAM96]. In general, interpreted languages can speed development time <ref> [Ous97] </ref>, especially when prototyping analyses. For PCp 3 , Perl [Wal97, WCS96] was chosen because it interfaces easily with C and is used widely.
Reference: [RD95] <author> Steven P. Reiss and Tony Davis. </author> <title> Experiences writing object-oriented compiler front ends. </title> <note> Available from author, January 1995. Available from author. </note>
Reference-contexts: They do not directly address converting existing use of cpp in legacy code. Reiss and Davis casually mention a research project that helps the user restructure programs by "translat [ing] an existing C program into C++" <ref> [RD95, p. 2] </ref>, but nothing further is mentioned about the project. 12 Siff and Reps also consider a transformation of C code to C++. They use type inference to generalize C functions and create a reusable template-based C++ function.
Reference: [Sim97] <author> Charles Simonyi. </author> <type> Personal conversation, </type> <month> 9 July </month> <year> 1997. </year>
Reference-contexts: Especially unusual uses of conditional compilation directives cause problems because of constraints on where C++ declarations may go, but generally the group is optimistic about the possibilities for their approach <ref> [Sim97] </ref>. LCLint attempts to analyze macro definitions for dangerous or error-prone constructs. It allows the programmer to add annotations to the code in comments. These annotations give the LCLint checker extra information that it then checks (similar to types in many languages).
Reference: [Ste90] <author> Guy L. Jr. Steele. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> 2nd edition, </address> <year> 1990. </year>
Reference-contexts: Their transformations are similar to the syntax macros suggested for use with C by Weise and Crew [WC93]. These constructs resemble the macros provided by Lisp <ref> [Ste90] </ref>, and have the desirable feature of syntactic safety, guaranteeing that macros can not introduce syntax errors. Crew also created ASTLOG, a Prolog-inspired language for examining abstract syntax trees. Again, he largely ignores the preprocessor, instead assuming a parse tree as the initial representation.
Reference: [Str94] <author> Bjarne Stroustrup. </author> <title> The Design and Evolution of C++. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: For the last two decades, C programs have exploited cpp's capabilities for everything from manifest constants and type-less pseudo-inline functions, through modularization and symbol generation. Bjarne Stroustrup, the designer and original implementor of C++, notes that "without the C preprocessor, C itself : : : would have been stillborn" <ref> [Str94, p. 119] </ref>. Certainly cpp contributes to C's expressiveness and portability, but perhaps at too large a cost. <p> Stroustrup recognizes this tradeoff: Occasionally, even the most extreme uses of cpp are useful, but its facilities are so unstructured and intrusive that they are a constant problem to programmers, main tainers, people porting code, and tool builders <ref> [Str94, p. 424] </ref>. fl Supported by a National Science Foundation Graduate Fellowship. <p> Though a legal ANSI C program, its semantics are undefined in light of cpp. When compiled using cc -Dprintf (x)=, the program no longer outputs the familiar "Hello world" message. (Adapted from an example given by Stroustrup <ref> [Str94, p. 423] </ref>.) What you see is not what the compiler gets. #include &lt;stdio.h&gt; int main (int argc, char *argv []) - printf ("Hello world"); return 0; - Experienced and novice C programmers alike have been frustrated by similar misunderstandings of source code due to the arbitrary transformations cpp performs before <p> Crew also created ASTLOG, a Prolog-inspired language for examining abstract syntax trees. Again, he largely ignores the preprocessor, instead assuming a parse tree as the initial representation. Stroustrup explains that making the preprocessor redundant was a design goal of C++ <ref> [Str94, p. 424] </ref>. 11 Though C++ provides no feature to replace the obviously still-needed #include directive, Stroustrup discuss the form that the construct might take. Carroll and Ellis make the strong claim that "C++ provides mechanisms that obviate the need for most macros" [CE95, p. 147].
Reference: [Str97] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas-sachusetts, </address> <note> 3rd edition, </note> <year> 1997. </year>
Reference-contexts: Before preprocessing, conditional compilation directives are converted to claration [Com96]. Because of the "misfeature" of such declarations still requiring definitions outside of the class, Stroustrup still recommends using enums for static integral constant members (i.e., the "enum hack") <ref> [Str97, p. 249] </ref>. 13 BAR, and BONG are conservatively not converted because they are used specially. Text coloring is done by the analysis: blue text indicates macros that expand. <p> Krone and Snelting analyze conditional compilation directives in the context of a lattice-theoretic framework for inferring configuration structures from the source code. They study how 11 Stroustrup also discusses differences between C and C++ which could cause other problems when re-targeting legacy C code to a C++ compiler <ref> [Str97, p. 816-820] </ref>. 12 Personal inquiries of that paper's authors also led to no pointers. 15 #if guards depend on and relate to each other, and provide a means of visualizing the relationships with the goal of improving the programmer's understanding of the structure and properties of the configurations [KS94]. 6
Reference: [Til97] <author> Ilya Tilevich. C2J++. </author> <note> Freely available software package, 1997. http://pacevm.dac.pace.edu/ ny971734/c2j.html. 25 </note>
Reference-contexts: Compilers necessarily sit at one extreme of the transformation spectrum|they must absolutely preserve semantics of their source language as they lower the level of abstraction to machine instructions. Other tools perform source-to-source transformations mostly as an editing aid, largely disregarding semantics <ref> [Laf97, Til97] </ref>. Software engineering source-to-source transformations can afford to be slightly less stringent than a compiler, but should strive to be more than just an editing tool.
Reference: [Wal97] <author> Larry Wall. </author> <title> Perl language, </title> <journal> v5.004. </journal> <note> Freely available software package, </note> <month> June </month> <year> 1997. </year> <month> ftp://ftp.perl.com/pub/perl/src/CPAN/5.0/perl5.004.tar.gz. </month>
Reference-contexts: Griswold and Atkinson note that various software tools benefited from using a special-purpose interpreted action language [GAM96]. In general, interpreted languages can speed development time [Ous97], especially when prototyping analyses. For PCp 3 , Perl <ref> [Wal97, WCS96] </ref> was chosen because it interfaces easily with C and is used widely. Though actually a compiled language, Perl's compilation phase is exceedingly fast and integrated with the execution; thus it has the same advantages in reducing developer time as interpreted languages, yet its performance is substantially better.
Reference: [WC93] <author> Daniel Weise and Roger Crew. </author> <title> Programmable syntax macros. </title> <booktitle> In Proceedings of the ACM conference on Programming Language Design and Implementation, </booktitle> <address> Albur-querque, NM, </address> <year> 1993. </year>
Reference-contexts: TXL uses a grammar to parse the language and creates the tree, then applies some transformations directly on the tree, and uses an "unparser" to write the new source code back. Their transformations are similar to the syntax macros suggested for use with C by Weise and Crew <ref> [WC93] </ref>. These constructs resemble the macros provided by Lisp [Ste90], and have the desirable feature of syntactic safety, guaranteeing that macros can not introduce syntax errors. Crew also created ASTLOG, a Prolog-inspired language for examining abstract syntax trees.
Reference: [WCS96] <author> Larry Wall, Tom Christiansen, and Randal L. Schwartz. </author> <title> Programming Perl. </title> <publisher> O'Reilly & Associates, Inc., </publisher> <address> Sebastopol, California, </address> <year> 1996. </year> <month> 26 </month>
Reference-contexts: Griswold and Atkinson note that various software tools benefited from using a special-purpose interpreted action language [GAM96]. In general, interpreted languages can speed development time [Ous97], especially when prototyping analyses. For PCp 3 , Perl <ref> [Wal97, WCS96] </ref> was chosen because it interfaces easily with C and is used widely. Though actually a compiled language, Perl's compilation phase is exceedingly fast and integrated with the execution; thus it has the same advantages in reducing developer time as interpreted languages, yet its performance is substantially better.
References-found: 37

