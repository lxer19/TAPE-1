URL: ftp://ftp.cs.utexas.edu/pub/garbage/rttdshrt.ps
Refering-URL: http://www.cs.utexas.edu/users/oops/papers.html
Root-URL: 
Email: (fsvkakkad|markj|wilsong@cs.utexas.edu)  
Title: "Portable" Runtime Type Description for Conventional Compilers  
Author: Sheetal V. Kakkad, Mark S. Johnstone, and Paul R. Wilson 
Keyword: Object-Oriented Programming Systems Group  
Address: Austin, Texas 78712-1188  
Affiliation: Dept. of Computer Sciences, University of Texas at Austin  
Note: (http://www.cs.utexas.edu/users/oops)  
Abstract: For clean and efficient implementation as libraries, these systems require knowledge of the actual layouts of data objects, which is unavailable in most traditionally-compiled and linked programming languages, such as C, C++, and Ada. (Even C++'s recently-standardized runtime type identification (RTTI) feature is insufficient, because it describes language-level features of the type hierarchy, not the compiler-dependent layout decisions.) This paper presents a facility for runtime type description, or RTTD, which extracts the low-level layout information from debug output of conventional compilers, and makes it available to user programs. We believe this to be the simplest and most portable approach to runtime type description, requiring no changes to existing compilers, though it requires some slight retargeting for some platforms. (This retargeting can be simplified by using existing code from multi-format debuggers such as gdb.) We describe the basic strategies of the system, and present details of our interface for C++. We also sketch some extensions we have implemented, including special treatment of C++'s virtual function table pointers to match persistent or foreign data objects with the actual code in a particular executable. Our implementation of runtime type description is freely available via anonymous FTP. It is in daily use with multiple operating systems and compilers, in both free and commercial products, including a real-time garbage collector and a high-performance persistent object store for C++.
Abstract-found: 1
Intro-found: 1
Reference: [ABC + 83] <author> M.P. Atkinson, P.J. Bailey, K.J. Chisholm, P. W. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> Computer Journal, </journal> <volume> 26(4) </volume> <pages> 360-365, </pages> <month> December </month> <year> 1983. </year>
Reference-contexts: 1 Introduction Low-level information about the format of data objects (records and class instances) is necessary for clean and efficient implementation of a variety of language extensions and runtime libraries. These include persistent object stores <ref> [ABC + 83, AM95] </ref>, data structure serializers (picklers), advanced foreign function call interfaces, parameter marshaling facilities for messaging and remote procedure calls, data structure browsers, data format conversion utilities, precise garbage collectors [Wil], advanced profiling, debugging, and tracing tools, and a variety of other "systems support" facilities.
Reference: [AF94] <author> G. Attardi and T. Flagella. </author> <title> A customizable memory management framework. </title> <booktitle> In Proceedings of the USENIX C++ Conference, </booktitle> <address> Cambridge, Massachussetts, </address> <year> 1994. </year>
Reference-contexts: Our contributions are to expose this information to arbitrary runtime libraries, which may be linked into applications in the usual way, and to support conventional off-the-shelf compilers for popular languages. Several libraries provide runtime type descriptors for garbage collection (e.g., <ref> [AF94, Ede92b] </ref>), but require programmers to provide methods that reveal pointer locations to the collector; our system was designed to avoid burdening the programmer with such tedious and error-prone coding.
Reference: [AM95] <author> M. P. Atkinson and R. Morrison. </author> <title> Orthogonally Persistent Object Systems. </title> <journal> VLDB Journal, </journal> <volume> 4(3), </volume> <year> 1995. </year>
Reference-contexts: 1 Introduction Low-level information about the format of data objects (records and class instances) is necessary for clean and efficient implementation of a variety of language extensions and runtime libraries. These include persistent object stores <ref> [ABC + 83, AM95] </ref>, data structure serializers (picklers), advanced foreign function call interfaces, parameter marshaling facilities for messaging and remote procedure calls, data structure browsers, data format conversion utilities, precise garbage collectors [Wil], advanced profiling, debugging, and tracing tools, and a variety of other "systems support" facilities.
Reference: [BC92] <editor> Yves Bekkers and Jacques Cohen, editors. </editor> <booktitle> International Workshop on Memory Management, number 637 in Lecture Notes in Computer Science, </booktitle> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference: [Coh81] <author> Jacques Cohen. </author> <title> Garbage collection of linked data structures. </title> <journal> Computing Surveys, </journal> <volume> 13(3) </volume> <pages> 341-367, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: The general strategy of making type descriptors available to sophisticated runtime systems is present in most garbage-collected languages, going back decades <ref> [Coh81, Wil] </ref>. Our contributions are to expose this information to arbitrary runtime libraries, which may be linked into applications in the usual way, and to support conventional off-the-shelf compilers for popular languages.
Reference: [Det92] <author> David L. Detlefs. </author> <title> Garbage Collection and Runtime Typing as a C++ Library. </title> <booktitle> In USENIX C++ Conference [USE92]. </booktitle>
Reference-contexts: In programming language terms, we have implemented a simple dynamic linker for virtual function tables. 14 Marc Shapiro, personal communication, May 1996. 10 interface <ref> [Det92] </ref> is somewhat cleaner, but incurs extra overheads and/or restrictions because conceptually compile-time operations must be performed within the language, at runtime. (Our system avoids this problem by performing most compile-time operations at compile time (or link time), at the expense of full portability|we must rely on debug information and knowledge
Reference: [Ede92a] <author> Daniel R. Edelson. </author> <title> Precompiling C++ for Garbage Collection. </title> <note> In Bekkers and Cohen [BC92]. </note>
Reference-contexts: be performed within the language, at runtime. (Our system avoids this problem by performing most compile-time operations at compile time (or link time), at the expense of full portability|we must rely on debug information and knowledge of the linking process.) Preprocessors for runtime type description have also been proposed (e.g., <ref> [Ede92a] </ref>).
Reference: [Ede92b] <author> Daniel Ross Edelson. </author> <title> Smart Pointers: They're Smart, But They're Not Pointers. </title> <booktitle> In USENIX C++ Conference [USE92], </booktitle> <pages> pages 1-19. </pages> <note> Technical Report UCSC-CRL-92-27, </note> <institution> University of Cali-fornia at Santa Cruz, Baskin Center for Computer Engineering and Information Sciences, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: Our contributions are to expose this information to arbitrary runtime libraries, which may be linked into applications in the usual way, and to support conventional off-the-shelf compilers for popular languages. Several libraries provide runtime type descriptors for garbage collection (e.g., <ref> [AF94, Ede92b] </ref>), but require programmers to provide methods that reveal pointer locations to the collector; our system was designed to avoid burdening the programmer with such tedious and error-prone coding.
Reference: [KJW97] <author> Sheetal V. Kakkad, Mark Johnstone, and Paul R. Wilson. </author> <title> "Portable" Runtime Type Description for Conventional Compilers. </title> <note> In preparation, </note> <year> 1997. </year>
Reference-contexts: allocator simply stores the object's type in a hidden header word for each object, and supports mapping from pointers to (or to the interior of) an object to the location of that header word. 8 Due to space limitations, we will not describe our allocator in detail here, but see <ref> [KJW97] </ref>. <p> We will sketch some of the complications and enhancements. (For a full description, see <ref> [KJW97] </ref>.) 3.2.1 Forcing generation of debug output A smart compiler may avoid generating debug output for classes that are never actually instantiated, or perhaps for classes that are instantiated but never operated on. <p> The problem arises because of a C++ language restriction on forward references, which we believe to be unnecessary and misguided. (See <ref> [KJW97] </ref> for a full description and discussion.) 4 Related Work Two other systems similar to ours have been developed, to our knowledge, both independently; unfortunately, no published descriptions exist.
Reference: [Mei96] <author> Gregory A. Meinke. </author> <title> Object Databases: Not Just for CAD/CAM Anymore. </title> <journal> Linux Journal, </journal> <pages> pages 39-44, </pages> <month> July </month> <year> 1996. </year> <month> 11 </month>
Reference-contexts: In many cases, ports are trivial because compilers can emit a standard debug format, though in some cases, it is necessary to write or modify code to recognize a new format. We have found this library quite useful and easy to use, as have others (e.g., <ref> [Mei96] </ref>). We hope it will used in a variety of applications, and ported to most popular machines. We welcome contributions of ports to improve the usefulness of this free software.
Reference: [SKW92] <author> Vivek Singhal, Sheetal V. Kakkad, and Paul R. Wilson. </author> <title> Texas: An Efficient, Portable Persistent Store. </title> <editor> In Antonio Albano and Ron Morrison, editors, </editor> <booktitle> Fifth International Workshop on Persistent Object Systems, </booktitle> <pages> pages 11-33, </pages> <address> San Miniato, Italy, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference-contexts: Status and Availability. We have implemented our runtime type descriptor mechanism and currently use it in the Texas Persistent Store (a high performance page-faulting persistent store <ref> [SKW92] </ref> using pointer swizzling at page fault time [WK92]) and a real-time and generational garbage collector for C++ [WJ93].
Reference: [USE92] <editor> USENIX Association. </editor> <booktitle> USENIX C++ Conference, </booktitle> <address> Portland, Oregon, </address> <month> August </month> <year> 1992. </year>
Reference: [Wil] <author> Paul R. Wilson. </author> <title> Garbage Collection. </title> <journal> Computing Surveys. </journal> <note> Expanded version of [Wil92]. Draft available via anonymous internet FTP from cs.utexas.edu as pub/garbage/bigsurv.ps. In revision, to appear. </note>
Reference-contexts: These include persistent object stores [ABC + 83, AM95], data structure serializers (picklers), advanced foreign function call interfaces, parameter marshaling facilities for messaging and remote procedure calls, data structure browsers, data format conversion utilities, precise garbage collectors <ref> [Wil] </ref>, advanced profiling, debugging, and tracing tools, and a variety of other "systems support" facilities. Traditionally, such features have relied heavily on programmer cooperation, or compiler cooperation, or the use of special-purpose preprocessors or precompilers. <p> The general strategy of making type descriptors available to sophisticated runtime systems is present in most garbage-collected languages, going back decades <ref> [Coh81, Wil] </ref>. Our contributions are to expose this information to arbitrary runtime libraries, which may be linked into applications in the usual way, and to support conventional off-the-shelf compilers for popular languages.
Reference: [Wil92] <author> Paul R. Wilson. </author> <title> Uniprocessor Garbage Collection Techniques. </title> <booktitle> In Bekkers and Cohen [BC92], </booktitle> <pages> pages 1-42. </pages>
Reference: [WJ93] <author> Paul R. Wilson and Mark S. Johnstone. </author> <title> Truly Real-Time Non-Copying Garbage Collection. </title> <booktitle> In OOPSLA '93 Workshop on Memory Management and Garbage Collection, </booktitle> <month> December </month> <year> 1993. </year> <note> Available for anonymous FTP from cs.utexas.edu in /pub/garbage/GC93. </note>
Reference-contexts: Status and Availability. We have implemented our runtime type descriptor mechanism and currently use it in the Texas Persistent Store (a high performance page-faulting persistent store [SKW92] using pointer swizzling at page fault time [WK92]) and a real-time and generational garbage collector for C++ <ref> [WJ93] </ref>. Our RTTD system works under several flavors of UNIX (SunOS, Solaris, ULTRIX, Linux and others) with the GNU C++ compiler, under Solaris with the GNU or Sun C++ compiler, and under OS/2 with IBM's C/Set (VisualAge) C++ compiler.
Reference: [WJNB95] <author> Paul R. Wilson, Mark S. Johnstone, Michael Neely, and David Boles. </author> <title> Dynamic Storage Allocation: A survey and critical review. </title> <booktitle> In 1995 International Workshop on Memory Management, </booktitle> <address> Kinross, Scotland, UK, 1995. </address> <publisher> Springer Verlag LNCS. </publisher>
Reference-contexts: Most allocators <ref> [WJNB95] </ref> can easily be modified to record the relevant information at little cost. (Most already include a hidden header word that records the size of a block.) 2.3 Compilation and Linkage Model To enable both the construction of type descriptors and their association with instances, we carefully intervene in the compilation
Reference: [WK92] <author> Paul R. Wilson and Sheetal V. Kakkad. </author> <title> Pointer Swizzling at Page Fault Time: Efficiently and Compatibly Supporting Huge Addresses on Standard Hardware. </title> <booktitle> In International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 364-377, </pages> <address> Paris, France, </address> <month> September </month> <year> 1992. </year> <note> IEEE Press. 12 </note>
Reference-contexts: Status and Availability. We have implemented our runtime type descriptor mechanism and currently use it in the Texas Persistent Store (a high performance page-faulting persistent store [SKW92] using pointer swizzling at page fault time <ref> [WK92] </ref>) and a real-time and generational garbage collector for C++ [WJ93]. Our RTTD system works under several flavors of UNIX (SunOS, Solaris, ULTRIX, Linux and others) with the GNU C++ compiler, under Solaris with the GNU or Sun C++ compiler, and under OS/2 with IBM's C/Set (VisualAge) C++ compiler.
References-found: 17

