URL: http://www.eecs.umich.edu/RTCL/arpa-project/rtcast/rtcast_full.ps
Refering-URL: http://www.eecs.umich.edu/RTCL/arpa-project/rtcast/
Root-URL: http://www.eecs.umich.edu
Email: kgshing@eecs.umich.edu  
Title: RTCAST: Lightweight Multicast for Real-Time Process Groups  
Author: Tarek Abdelzaher, Anees Shaikh, Scott Johnson, Farnam Jahanian, and Kang Shin fzaher, ashaikh, scottdj, farnam, 
Date: June 16, 1997  
Address: Ann Arbor, Michigan 481092122  
Affiliation: Real-Time Computing Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: We propose a lightweight fault-tolerant multicast and membership service for real-time process groups which may exchange periodic and aperiodic messages. The service supports bounded-time message transport, atomicity, and order for multicasts within a group of communicating processes in the presence of processor crashes and communication failures. It guarantees agreement on membership among the communicating processors, and ensures that membership changes (e.g., resulting from processor joins or departures) are atomic and ordered with respect to multicast messages. We provide the flexibility of an event-triggered approach with the fast message delivery time of time-triggered protocols, such as TTP [1], where messages are delivered to the application immediately upon reception. This is achieved without compromising agreement, order and atomicity properties. In addition to the design and details of the algorithm, we describe an implementation of the protocol, and present an evaluation of protocol performance using an x-Kernel-based protocol architecture running on MK 7.2 from the Open Software Foundation (OSF) Research Institute. The work reported in this paper was supported in part by the Advanced Research Projects Agency, monitored by the US Air Force Rome Laboratory under Grant F30602-95-1-0044. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Kopetz and G. Grunsteidl, </author> <title> TTP a protocol for fault-tolerant real-time systems, </title> <journal> IEEE Computer, </journal> <volume> vol. 27, no. 1, </volume> <pages> pp. 1423, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous [25] and synchronous <ref> [1, 6, 7] </ref> environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. <p> Permanent link failures are allowed too. However, we believe that the proper way to handle permanent link failures in fault-tolerant real-time systems is to employ hardware redundancy, for example, as in TTP <ref> [1] </ref> or as suggested in [8]. Hardware redundancy virtually eliminates the possibility of network partitions. Thus, network partitions are not a concern of our algorithm. Under the above failure assumptions RTCAST guarantees bounded-time message transport, atomicity, and order for multicasts within the process group. <p> The abstraction hides a portable, analyzable, scalable and efficient mechanism for group communication. It does not, however, attempt to guarantee atomicity and order in the presence of failures, which may compromise consistency. The authors of TTP <ref> [1] </ref> provide a simple and elegant membership algorithm. It achieves predictability in real-time applications where an a priori static schedule can be determined for the computation and communication tasks. TTP uses a time-triggered scheme to provide predictable immediate message delivery, membership service, and redundancy management in fault-tolerant real-time systems.
Reference: [2] <author> K. P. Birman, </author> <title> The process group approach to reliable distributed computing, </title> <journal> Communications of the ACM, </journal> <volume> vol. 36, no. 12, </volume> <pages> pp. 3753, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Failure of the token site will delay message reception even if both the source and destination are operational. In contrast, RTCAST does not acknowledge each message, and need not involve an intermediate node on the path of each message. ISIS <ref> [2, 21] </ref> introduced the concept of virtual synchrony, and integrated a membership protocol into the multicast communication subsystem, whereby membership changes take place in response to communication failure.
Reference: [3] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki, </author> <title> The transis approach to high availability cluster communication, </title> <journal> Communications of the ACM, </journal> <volume> vol. 39, no. 4, </volume> <pages> pp. 6470, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: The ordering task, however, is simplified by assuming a ring network. In addition to ISIS, several other systems have adopted the notion of fault-tolerant process groups, using similar abstractions to support distributed applications. Some of these include Consul [5], Transis <ref> [3] </ref>, and Horus [4]. A number of systems choose to separate the group membership service from the fault-tolerant multicast ser vice. As a result, the group membership service maintains consistency regarding the membership view and may assume that separate reliable atomic multicast support is available.
Reference: [4] <author> R. van Renesse, K. Birman, and S. Maffeis, Ho-rus: </author> <title> A flexible group communication system, </title> <journal> Communications of the ACM, </journal> <volume> vol. 39, no. 4, </volume> <pages> pp. 7683, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: The ordering task, however, is simplified by assuming a ring network. In addition to ISIS, several other systems have adopted the notion of fault-tolerant process groups, using similar abstractions to support distributed applications. Some of these include Consul [5], Transis [3], and Horus <ref> [4] </ref>. A number of systems choose to separate the group membership service from the fault-tolerant multicast ser vice. As a result, the group membership service maintains consistency regarding the membership view and may assume that separate reliable atomic multicast support is available.
Reference: [5] <author> S. Mishra, L. Peterson, and R. Schlichting, </author> <title> Consul: A communication substrate for fault-tolerant distributed programs, </title> <journal> Distributed Systems Engineering Journal, </journal> <volume> vol. 1, no. 2, </volume> <pages> pp. 87103, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: The ordering task, however, is simplified by assuming a ring network. In addition to ISIS, several other systems have adopted the notion of fault-tolerant process groups, using similar abstractions to support distributed applications. Some of these include Consul <ref> [5] </ref>, Transis [3], and Horus [4]. A number of systems choose to separate the group membership service from the fault-tolerant multicast ser vice. As a result, the group membership service maintains consistency regarding the membership view and may assume that separate reliable atomic multicast support is available.
Reference: [6] <author> Y. Amir, L. Moser, P. Melliar-Smith, D. Agarwal, and P. Ciarfella, </author> <title> The Totem single-ring ordering and membership protocol, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 13, no. 4, </volume> <pages> pp. 311342, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous [25] and synchronous <ref> [1, 6, 7] </ref> environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. <p> Thus, these techniques are not suitable for the applications in which we are interested. There are, however, several protocols that integrate reliable multicast and group membership and also target real-time applications. Totem <ref> [6, 27] </ref> is an example of a protocol that provides probabilistic real-time guarantees. It is based on a token ring, and guarantees totally ordered delivery of messages.
Reference: [7] <author> F. Cristian, B. Dancy, and J. Dehn, </author> <title> Fault-tolerance in the advanced automation system, </title> <booktitle> in Proc. of Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 617, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous [25] and synchronous <ref> [1, 6, 7] </ref> environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application.
Reference: [8] <author> B. Chen, S. Kamat, and W. Zhao, </author> <title> Fault-tolerant real-time communication in fddi-based networks, </title> <booktitle> in Proc. 16th IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 141150, </pages> <address> Pisa, Italy, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Permanent link failures are allowed too. However, we believe that the proper way to handle permanent link failures in fault-tolerant real-time systems is to employ hardware redundancy, for example, as in TTP [1] or as suggested in <ref> [8] </ref>. Hardware redundancy virtually eliminates the possibility of network partitions. Thus, network partitions are not a concern of our algorithm. Under the above failure assumptions RTCAST guarantees bounded-time message transport, atomicity, and order for multicasts within the process group. <p> Similarly, XTP provides no ordering semantics, again leaving message ordering enforcement to applications. Finally, a research effort complementary to ours is reported in <ref> [8] </ref>. While we consider fault-tolerance with respect to processor failure, we do not suggest a mechanism for implementing fault-tolerant message communication. For example, we do not specify whether or not redundancy is used to tolerate link failures.
Reference: [9] <editor> S. Mullender, editor, </editor> <booktitle> Distributed Systems, chapter 5, </booktitle> <pages> pp. 103104, </pages> <publisher> Addison Wesley, </publisher> <address> 2nd edition, </address> <year> 1993. </year>
Reference-contexts: A multicast message m by N i is delivered reliably if it is guaranteed that each member in V i eventually delivers m <ref> [9] </ref>. We assume that the state of a process is volatile and as such, does not survive crash failures. Because of this assumption the scenario where a process delivers m then crashes immediately (i.e., before taking any further action) is indistinguishable from that where the process crashes before delivering m.
Reference: [10] <author> F. Cristian, </author> <title> Group, majority, and strict agreement in timed asynchronous distributed systems, </title> <booktitle> in Proc. of Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 178 187, </pages> <year> 1996. </year>
Reference-contexts: Consequently, all member nodes which deliver the membership update U share the same membership view at the time of delivery. This is the characteristic feature of virtual synchrony. In <ref> [10] </ref> agreement protocols are generally broken into three categoties; group, majority and strict agreement [10]. According to this taxonomy, our semantics fall in the category of group agreement. 2.3 View-preserved Ordered Delivery RTCAST guarantees that delivery of membership updates is totally ordered with respect to regular message mul-ticasts. <p> Consequently, all member nodes which deliver the membership update U share the same membership view at the time of delivery. This is the characteristic feature of virtual synchrony. In <ref> [10] </ref> agreement protocols are generally broken into three categoties; group, majority and strict agreement [10]. According to this taxonomy, our semantics fall in the category of group agreement. 2.3 View-preserved Ordered Delivery RTCAST guarantees that delivery of membership updates is totally ordered with respect to regular message mul-ticasts.
Reference: [11] <author> L. Lamport, </author> <title> Time, clocks, and the ordering of events in a distributed system, </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. 7, </volume> <pages> pp. 558565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Either case indicates that N i 's turn to send messages has come. 5 This is different from using vector clocks <ref> [11] </ref>; here, messages carry only their sequence number and sender id. 6 We know who the sender is because we know from whom a message is missing A B C D EFGH Token When N i 's turn comes, it first determines the processors from which it has not received a <p> ISIS [2, 21] introduced the concept of virtual synchrony, and integrated a membership protocol into the multicast communication subsystem, whereby membership changes take place in response to communication failure. ISIS implements an atomic ordered multicast on top of a vector clock-based <ref> [11] </ref> causal multicast service, using an idea similar to that of Chang and Maxemchuk. We integrate membership and multicast services, but implement ordered atomic multicast directly without constructing a partial order first. The ordering task, however, is simplified by assuming a ring network.
Reference: [12] <author> L. Sha, R. Rajkumar, and S. S. Sathaye, </author> <title> Generalized rate monotonic scheduling theory: A framework for developing real-time systems, </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> vol. 82, no. 1, </volume> <pages> pp. 6882, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: The goal of this separation is to allow use of a number of admission control policies to ensure timeliness while leaving consistency to the multicast algorithm. For example, instead of the schedulability condition stated in Theorem 1, one may use the generalized rate monotonic analysis <ref> [12] </ref>, FDDI synchronous bandwidth allocation analysis [13], or delay analysis for Controller Area Networks [14], depending on the application at hand.
Reference: [13] <author> N. Malcolm, S. Kamat, and W. Zhao, </author> <title> Real-time communication in FDDI networks, </title> <booktitle> Real-Time Systems, </booktitle> <volume> vol. 10, no. 1, </volume> <pages> pp. 75107, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: For example, instead of the schedulability condition stated in Theorem 1, one may use the generalized rate monotonic analysis [12], FDDI synchronous bandwidth allocation analysis <ref> [13] </ref>, or delay analysis for Controller Area Networks [14], depending on the application at hand.
Reference: [14] <author> K. Tindell, A. Burns, and A. J. Wellings, </author> <title> Calculating controller area network (CAN) message response times, </title> <journal> Control Engineering Practice, </journal> <volume> vol. 3, no. 8, </volume> <pages> pp. 11631169, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: For example, instead of the schedulability condition stated in Theorem 1, one may use the generalized rate monotonic analysis [12], FDDI synchronous bandwidth allocation analysis [13], or delay analysis for Controller Area Networks <ref> [14] </ref>, depending on the application at hand.
Reference: [15] <author> F. Cristian, </author> <title> Probabilistic clock synchronization, </title> <journal> Distributed Computing, </journal> <volume> vol. 3, </volume> <pages> pp. 146158, </pages> <year> 1989. </year>
Reference-contexts: The RTCAST layer implements the multicast and membership service described in Section 3. The Retransmission layer is responsible for handling re-transmissions as described in Section 3.6. ClockSync provides a synchronization service using the probabilistic algorithm developed by Cristian <ref> [15] </ref>. In soft real-time systems, non real-time systems, or systems where hard real-time communication has been prescheduled and guaranteed a priori, we may wish to omit the ACSA layer, in which case the application interfaces directly to RTCAST. <p> One possible solution to this problem is to use a protocol such as Order described above to queue and reorder 9 The clock synchronization service is distributed with the MK 7.2 CORDS framework and uses the algorithm by Cristian <ref> [15] </ref>. messages. If a sufficiently large number of messages arrive and are shepherded in an undefined order, however, Order may incorrectly conclude that messages were lost when in fact their corresponding shepherd threads just were not correctly scheduled.
Reference: [16] <author> N. C. Hutchinson and L. L. Peterson, </author> <title> The x-Kernel: An architecture for implementing network protocols, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 17, no. 1, </volume> <pages> pp. 6476, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: provides atomic ordered multicast, and implements a group membership service that guarantees atomic ordered membership changes, and agreement on group membership view. 5.2 RTCAST Communications Server RTCAST was initially implemented and tested on the Real-Time Mach 3.0 operating system from Carnegie Mellon University within the x-Kernel 3.2 protocol implementation environment <ref> [16] </ref>. The primary motivation for using x-Kernel was the ability to easily reconfigure the protocol graph according to application needs by adding or removing corresponding protocols (as described above). Current development is conducted on the MK 7.2 microkernel operating system from the Open Software Foundation (OSF) Research Institute [17].
Reference: [17] <institution> OSF RI MK 7.2 Release Notes, OSF Reasearch Institute Real-Time Group, </institution> <month> October </month> <year> 1996. </year>
Reference-contexts: The primary motivation for using x-Kernel was the ability to easily reconfigure the protocol graph according to application needs by adding or removing corresponding protocols (as described above). Current development is conducted on the MK 7.2 microkernel operating system from the Open Software Foundation (OSF) Research Institute <ref> [17] </ref>. MK 7.2 includes the CORDS (Communication Objects for Real-Time Dependable Systems) environment, which is evolved from the x-Kernel object-oriented networking framework [18]. We created two implementations of RTCAST: one running as a user-level CORDS server as shown in layers operate as described above in Section 5.1.
Reference: [18] <author> E. F. Menze and F. Travostino, </author> <title> The CORDS Book, </title> <booktitle> Open Software Foundation Research Institute, </booktitle> <address> Cam-bridge, MA, 2.0 edition, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: Current development is conducted on the MK 7.2 microkernel operating system from the Open Software Foundation (OSF) Research Institute [17]. MK 7.2 includes the CORDS (Communication Objects for Real-Time Dependable Systems) environment, which is evolved from the x-Kernel object-oriented networking framework <ref> [18] </ref>. We created two implementations of RTCAST: one running as a user-level CORDS server as shown in layers operate as described above in Section 5.1.
Reference: [19] <author> T. Abdelzaher, A. Shaikh, F. Jahanian, and K. Shin, RTCAST: </author> <title> Lightweight multicast for real-time process groups, </title> <booktitle> in Proc. IEEE Real-Time Technology and Applications Symposium (RTAS '96), </booktitle> <pages> pp. 250 259, </pages> <address> Boston, MA, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: The RTCAST layer was tested first to verify its support for system consistency, then the ACSA layer was added, and the system was tested for deadline guarantees. These tests are further described in <ref> [19] </ref>. Though the user-level server implementation was adequate for functional testing, we found that performance testing which heavily loaded the server led to unpredictable behavior in terms of message delivery order.
Reference: [20] <author> J.-M. Chang and N. Maxemchuk, </author> <title> Reliable broadcast protocols, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 2, no. 3, </volume> <pages> pp. 251273, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: The complete API specifications for both RTCAST and the service library are available at http://www.eecs.umich.edu/RTCL/armada/rtcast/api.html. 6 Related work Several fault-tolerant, atomic ordered multicast and membership protocols have been proposed for use in asynchronous distributed systems. In some of the earliest work, Chang and Maxemchuk <ref> [20] </ref> proposed a token-based algorithm for a process group where each member sends its messages to a token site which orders the messages and broadcasts acknowledgments. Destinations use the acknowledgments to order messages as specified by the token site.
Reference: [21] <author> K. Birman, A. Schiper, and P. Stephenson, </author> <title> Lightweight causal and atomic group multicast, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 9, no. 3, </volume> <pages> pp. 272314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Failure of the token site will delay message reception even if both the source and destination are operational. In contrast, RTCAST does not acknowledge each message, and need not involve an intermediate node on the path of each message. ISIS <ref> [2, 21] </ref> introduced the concept of virtual synchrony, and integrated a membership protocol into the multicast communication subsystem, whereby membership changes take place in response to communication failure.
Reference: [22] <author> F. Jahanian, S. Fakhouri, and R. Rajkumar, </author> <title> Processor group membership protocols: Specification, </title> <booktitle> design, and implementation, in Proc. 12th Symposium on Reliable Distributed Systems, </booktitle> <pages> pp. 211, </pages> <year> 1993. </year>
Reference-contexts: As a result, the group membership service maintains consistency regarding the membership view and may assume that separate reliable atomic multicast support is available. Examples of this approach are found in the Strong Group Membership protocol <ref> [22] </ref> and the MGS protocol for processor group membership [23]. Additional work on group membership protocols appeared in [2426]. Common to the above-mentioned protocols whether strictly group membership or combining multicast and group membership, is that they do not explicitly consider the needs of hard real-time applications.
Reference: [23] <author> L. Rodrigues, P. Ver issimo, and J. Rufino, </author> <title> A low-level processor group membership protocol for LANs, </title> <booktitle> in Proc. Int. Conf. on Distributed Computer Systems, </booktitle> <pages> pp. 541550, </pages> <year> 1993. </year>
Reference-contexts: As a result, the group membership service maintains consistency regarding the membership view and may assume that separate reliable atomic multicast support is available. Examples of this approach are found in the Strong Group Membership protocol [22] and the MGS protocol for processor group membership <ref> [23] </ref>. Additional work on group membership protocols appeared in [2426]. Common to the above-mentioned protocols whether strictly group membership or combining multicast and group membership, is that they do not explicitly consider the needs of hard real-time applications.
Reference: [24] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki, </author> <title> Membership algorithms for multicast communication groups, </title> <booktitle> in Proc. 6th International Workshop on Distributed Algorithms, number 647 in Lecture Notes in Computer Science, </booktitle> <pages> pp. 292312, </pages> <address> Haifa, Is-rael, </address> <month> November </month> <year> 1992. </year>
Reference: [25] <author> F. Cristian, </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems, </title> <journal> Distributed Computing, </journal> <volume> vol. 4, </volume> <pages> pp. 175187, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous <ref> [25] </ref> and synchronous [1, 6, 7] environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application.
Reference: [26] <author> A. M. Ricciardi and K. P. Birman, </author> <title> Process membership in asynchronous environments, </title> <type> Technical Report TR93-1328, </type> <institution> Dept. of Computer Science, Cor-nell University, </institution> <month> February </month> <year> 1993. </year>
Reference: [27] <author> L. Moser and P. Melliar-Smith, </author> <title> Probabalistic bounds on message delivery for the totem single-ring protocol, </title> <booktitle> in Proc. IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 238248, </pages> <year> 1994. </year>
Reference-contexts: Thus, these techniques are not suitable for the applications in which we are interested. There are, however, several protocols that integrate reliable multicast and group membership and also target real-time applications. Totem <ref> [6, 27] </ref> is an example of a protocol that provides probabilistic real-time guarantees. It is based on a token ring, and guarantees totally ordered delivery of messages.
Reference: [28] <author> R. Rajkumar, M. Gagliardi, and L. Sha, </author> <title> The real-time publisher/subscriber inter-process communication model for distributed real-time systems: </title> <booktitle> Design and implementation, in Proc. Real Time Technology and Applications Symposium, </booktitle> <pages> pp. 6675, </pages> <address> Chicago, IL, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: For example, it may be better to kill one replica of a replicated server in exchange for delivering a multicast in time for the rest of the group than delay delivery potentially causing the entire group to miss their deadline. Rajkumar et al. <ref> [28, 29] </ref> present an elegant publisher/subscriber model for distributed real-time systems. It provides a simple user interface for publishing messages on a logical channel, and for subscribing to selected channels as needed by each application.
Reference: [29] <author> M. Gagliardi, R. Rajkumar, and L. Sha, </author> <title> Designing for evolvability: Building blocks for evolvable real-time systems, </title> <booktitle> in Real-Time Technology and Applications Symposium, </booktitle> <pages> pp. 100109, </pages> <address> Brookline, Mas-sachusetts, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: For example, it may be better to kill one replica of a replicated server in exchange for delivering a multicast in time for the rest of the group than delay delivery potentially causing the entire group to miss their deadline. Rajkumar et al. <ref> [28, 29] </ref> present an elegant publisher/subscriber model for distributed real-time systems. It provides a simple user interface for publishing messages on a logical channel, and for subscribing to selected channels as needed by each application.
Reference: [30] <author> F. Cristian, </author> <title> Synchronous atmoic broadcast for redundant broadcast channels, </title> <booktitle> Real-Time Systems, </booktitle> <volume> vol. 2, no. 3, </volume> <pages> pp. </pages> <address> 195212, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: We also consider the case where a sent message is received by a subset of correct destinations, which may occur in the case of receiver buffer overflow, or message corruption on one of many links in an arbitrary topology network. A synchronous atomic broadcast protocol was proposed in <ref> [30] </ref> for redundant broadcast channels. It uses lazy forwarding to achieve broadcast atomicity and uses timestamps to achieve total order. Senders can send messages at any time.
Reference: [31] <editor> Xpress Transport Protocol 4.0 specification. </editor> <publisher> XTP Forum, Inc., </publisher> <year> 1995. </year>
Reference-contexts: This implicitly defines an agreement among these tasks on the prefix of delivered messages they need to use thus avoiding potential inconsistency. The Xpress Transport Protocol (XTP) <ref> [31] </ref> is a general purpose internetwork connection-oriented protocol which also provides some features similar to RTCAST. Chiefly designed to address shortcomings in existing transport layer protocols such as TCP, XTP provides, for example, support for selective retransmissions, multicast (reliable and unreliable), and static priority-based message communication.
Reference: [32] <author> J. W. Atwood, O. Catrina, J. Fenton, and W. T. Strayer, </author> <title> Reliable multicast in the Xpress Transport Protocol, </title> <booktitle> in Proc. of 21st Conf. on Local Computer Networks, </booktitle> <pages> pp. </pages> <address> 202211, Minneapolis, MN, </address> <year> 1996. </year>
Reference-contexts: It provides some rate-based traffic shaping at senders, but not admission control for connections. XTP also provides sender- and receiver-initiated multi-cast group formation but ensuring group integrity requires that senders periodically request status reports from receivers <ref> [32] </ref>. This is illustrative of the XTP approach in which mechanisms for gathering information are provided but deciding the current group membership view is left to the applications. Similarly, XTP provides no ordering semantics, again leaving message ordering enforcement to applications.
References-found: 32

