URL: http://www.cis.ohio-state.edu/~hartman/PUBLIC/hartman-dissertation-compressed.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~hartman/publications.html
Root-URL: 
Title: AUTOMATIC CONTROL UNDERSTANDING FOR NATURAL PROGRAMS  
Author: JOHN HARTMAN 
Degree: DISSERTATION Presented to the Faculty of the Graduate School of  in Partial Fulfillment of the Requirements for the Degree of DOCTOR OF PHILOSOPHY  
Date: May, 1991  
Address: Austin  
Affiliation: The University of Texas at  
Abstract: This work has taken place in the Qualitative Reasoning Group at the Artificial Intelligence Laboratory, The University of Texas at Austin. Research of the Qualitative Reasoning Group is supported in part by NSF grants IRI-8602665, IRI-8905494, and IRI-8904454, by NASA grants NAG 2-507 and NAG 9-200, and by the Texas Advanced Research Program under grant no. 003658175. 
Abstract-found: 1
Intro-found: 1
Reference: [ABFP85] <author> Guillermo Arango, Ira Baxter, Peter Freeman, and Christopher Pidgeon. </author> <title> Maintenance and porting of software by design recovery. </title> <booktitle> In Proceedings of the Conference on Software Maintenance. </booktitle> <publisher> IEEE, IEEE Computer Society Press, </publisher> <month> November 11-13 </month> <year> 1985. </year>
Reference: [Ade81] <author> Beth Adelson. </author> <title> Problem solving and the development of abstract categories in programming languages. </title> <journal> Memory and Cognition, </journal> <volume> 9(4) </volume> <pages> 422-433, </pages> <year> 1981. </year>
Reference: [AF85] <author> Guillermo Arango and Peter Freeman. </author> <title> Modeling knowledge for software development. </title> <booktitle> In Proceedings of the Third International Workshop on Software Specifications and Design, </booktitle> <pages> pages 63-66, </pages> <year> 1985. </year>
Reference-contexts: Knowledge and information information about domains and design can provide guidance when it is available, as discussed in Appendix B and <ref> [AS86, Pen87a, AF85, HY85, PD90, Pot89, Ara89, IW89] </ref>. 175 To maintain realism, we will consider additional information only as it becomes useful for particular applications.
Reference: [Aht90] <author> Tero Ahtee. </author> <title> Bibliography of CASE, </title> <institution> systems, and software engineering. University of Tampere, Finland, </institution> <month> January 24 </month> <year> 1990. </year>
Reference: [ai-89] <institution> PROCEEDINGS OF THE AAAI SPRING SYMPOSIUM ON AI AND SOFTWARE ENGINEERING. AAAI, </institution> <month> March </month> <year> 1989. </year>
Reference: [Ake90] <author> Robert L. Akers. </author> <title> Strong static type checking for functional Common Lisp. Dissertation proposal and type inference bibliography. </title> <institution> Dept. of Computer Sciences, The University of Texas at Austin, </institution> <month> August </month> <year> 1990. </year>
Reference: [AKPT90] <author> James Allen, Henry Kautz, Richard Pelavin, and Joshua Tenen-berg. </author> <title> REASONING ABOUT PLANS. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference: [AL80] <author> Anne Adam and Jean Pierre Laurent. LAURA, </author> <title> A system to debug student programs. </title> <journal> Artificial Intelligence, </journal> <volume> 15 </volume> <pages> 75-122, </pages> <year> 1980. </year>
Reference: [Ale64] <author> Christopher Alexander. </author> <title> NOTES ON THE SYNTHESIS OF FORM. </title> <publisher> Harvard University Press, </publisher> <year> 1964. </year>
Reference: [Ara88] <author> G. Arango. </author> <title> Domain engineering for software reuse. </title> <type> Technical Report 88-27, </type> <institution> Department of Information and Computer Science, University of California at Irvine, </institution> <year> 1988. </year> <pages> 35 36 </pages>
Reference: [Ara89] <author> G. Arango. </author> <title> Domain analysis: From art to engineering discipline. </title> <booktitle> In Proceedings of the Fifth International Workshop On Software Specification and Design, </booktitle> <pages> pages 152 - 159, </pages> <month> May </month> <year> 1989. </year> <journal> Software Engineering Notes, </journal> <volume> Vol. 14, No. </volume> <pages> 3. </pages>
Reference-contexts: Knowledge and information information about domains and design can provide guidance when it is available, as discussed in Appendix B and <ref> [AS86, Pen87a, AF85, HY85, PD90, Pot89, Ara89, IW89] </ref>. 175 To maintain realism, we will consider additional information only as it becomes useful for particular applications.
Reference: [Arn86] <author> Robert S. Arnold. </author> <title> TUTORIAL ON SOFTWARE RESTRUCTURING. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1986. </year>
Reference: [AS86] <author> Beth Adelson and Elliot Soloway. </author> <title> A model of software design. </title> <journal> International Journal of Intelligent Systems, </journal> <volume> 1(3), </volume> <month> Fall </month> <year> 1986. </year>
Reference-contexts: Knowledge and information information about domains and design can provide guidance when it is available, as discussed in Appendix B and <ref> [AS86, Pen87a, AF85, HY85, PD90, Pot89, Ara89, IW89] </ref>. 175 To maintain realism, we will consider additional information only as it becomes useful for particular applications.
Reference: [ASU86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> COMPILERS PRINCIPLES, TECHNIQUES, and TOOLS. </booktitle> <publisher> Addison-Wesley Pub. Co., </publisher> <year> 1986. </year>
Reference: [AT90] <author> James Allen and Austin Tate. </author> <title> READINGS IN PLANNING. </title> <publisher> Mor-gan Kaufmann, </publisher> <month> May </month> <year> 1990. </year>
Reference: [AU77] <author> Alfred V. Aho and Jeffrey D. Ullman. </author> <title> PRINCIPLES of COMPILER DESIGN. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <year> 1977. </year>
Reference: [Bak77] <author> Brenda S. Baker. </author> <title> An algorithm for structuring flowgraphs. </title> <journal> Journal of the ACM, </journal> <volume> 24(1), </volume> <month> January </month> <year> 1977. </year>
Reference: [Bar87] <author> Ray Bareiss. </author> <title> A survey of psychological models of concept representation. </title> <type> Technical Report AI TR-87-50, </type> <institution> University of Texas at Austin, Dept. of Computer Sciences, </institution> <year> 1987. </year>
Reference: [Bar89] <author> Ray Bareiss. </author> <title> EXEMPLAR-BASED KNOWLEDGE ACQUISITION. </title> <publisher> Academic Press, </publisher> <year> 1989. </year>
Reference: [BG85] <author> Charles Babcock and John Gallant. </author> <title> IBM reveals tool to restructure VM, MVS Cobol code. </title> <booktitle> Computerworld, </booktitle> <pages> page 10, </pages> <month> November 25 </month> <year> 1985. </year>
Reference: [BG86] <author> G. Bruns and S. Gerhart. </author> <title> Theories of design: An introduction to the literature. </title> <type> Technical Report STP-068-86, </type> <institution> Microelectronics and Computer Technology Corporation (MCC), </institution> <month> March </month> <year> 1986. </year>
Reference: [Big89a] <author> Ted Biggerstaff. </author> <title> Design recovery for maintenance and reuse. </title> <booktitle> IEEE Computer, </booktitle> <month> July </month> <year> 1989. </year>
Reference: [Big89b] <author> Ted Biggerstaff. </author> <title> A framework for program analysis and understanding tools. </title> <type> Technical Report STP-129-89, </type> <institution> Microelectronics and Computer Technology Corporation (MCC), </institution> <month> March 20 </month> <year> 1989. </year> <month> 37 </month>
Reference: [BJ66] <author> C. Bohm and G. Jacopini. </author> <title> Flow diagrams, Turing machines and languages with only two formation rules. </title> <journal> Communications of the ACM, </journal> <volume> 9 </volume> <pages> 366-371, </pages> <month> May </month> <year> 1966. </year>
Reference: [BKM90] <author> S. Burson, G. B. Kotic, and L. Z. Markosian. </author> <title> A program transformation approach to automating software re-engineering. </title> <editor> In George J. Knafl, editor, </editor> <booktitle> COMPSAC90 The Fourteenth Annual International Computer Software & Applications Conference, </booktitle> <pages> pages 314-322. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> October 31-November 2 </month> <year> 1990. </year>
Reference: [BM82] <author> Victor Basili and Harlan Mills. </author> <title> Understanding and documenting programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 8(3), </volume> <month> May </month> <year> 1982. </year>
Reference: [BP89] <author> T.J. Biggerstaff and A.J. Perlis. </author> <title> SOFTWARE REUSABILITY. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year> <title> Vol. 1: Concepts and Models, Vol. II: </title> <journal> Applications and Experience. </journal>
Reference: [Bro83] <author> Ruven Brooks. </author> <title> Towards a theory of the comprehension of computer programs. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 18 </volume> <pages> 543-554, </pages> <year> 1983. </year>
Reference: [Bro84] <author> D. C. Brotsky. </author> <title> An algorithm for parsing flow graphs. </title> <type> Master's thesis, </type> <institution> M.I.T., </institution> <month> March </month> <year> 1984. </year> <type> TR 707, </type> <institution> MIT Artificial Intelligence Laboratory. </institution>
Reference-contexts: for the plan calculus [Ric81b], as far as we know, surface plans have not been used for recognition. 1 Instead, recognition work at M.I.T. has modified surface plan diagrams for recognition by parsing.[Wil87] Wills' RECOGNIZER is based on (an extension of) Brotsky's acyclic "flow graph" (f. g. ) parser. 2 <ref> [Bro84] </ref> The parser constrains the program representation.
Reference: [Bus85] <author> Eric Bush. </author> <title> The automatic restructuring of Cobol. </title> <booktitle> In Proceedings of the Conference on Software Maintenance, </booktitle> <pages> pages 35-41. </pages> <publisher> IEEE, IEEE Computer Society Press, </publisher> <month> November 11-13 </month> <year> 1985. </year>
Reference-contexts: Of course recognition cost and rates can be tailored to restructuring, as discussed in 7.1, 9.3.2, and elsewhere. Input language generality may be affected by Cobol language features and the analyzability limitation. Analyzing PERFORM is discussed in <ref> [Bus85] </ref>, [IBM86] and [Cra90], and we haven't come to grips with this problem. Data flow analyzability may or may not be a problem, depending on the data type model and uses of data flow.
Reference: [Car85] <author> R. Emmett Carlyle. </author> <title> Can AI save COBOL? Datamation, </title> <note> Septem-ber 15 1985. </note>
Reference-contexts: Linger, Mills, and Witt give transformations which improve the results of label structuring.[LMW79] Othmer describes classes of restructuring algorithms in the context of Cobol restructuring.[Oth81] Commercial Cobol restructuring tools are discussed in <ref> [Car85, Par86, MS87] </ref>. Major products and methodologies include Peat Marwick's Structured Retrofit, CDSI's SUPERSTRUCTURE and RETOOL, IBM's Cobol Structuring Facility, and Language Technology's RECODER.[pea84, com, BG85, IBM86, Bus85] The U.S.
Reference: [Car89] <author> R. Emmett Carlyle. Fighting corporate amnesia. Datamation, </author> <month> February 1 </month> <year> 1989. </year>
Reference: [cas90] <institution> PROCEEDINGS of the 4TH INTERNATIONAL WORKSHOP ON COMPUTER AIDED SOFTWARE ENGINEERING. IEEE Computer Society Press, </institution> <year> 1990. </year> <note> See also preceding workshops. </note>
Reference: [Cen87] <author> Federal Software Management Support Center. </author> <title> Parallel test and evaluation of a COBOL restructuring tool. </title> <type> Technical report, U.S. </type> <institution> General Services Administration, </institution> <month> September </month> <year> 1987. </year> <month> 38 </month>
Reference: [Chi89] <author> Elliot J. Chikovsky. </author> <title> COMPUTER AIDED SOFTWARE ENGINEERING (CASE). </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference: [CI90] <author> Elliot J. Chikovsky and James H. </author> <title> Cross II. Reverse engineering and design recovery: A taxonomy. </title> <journal> IEEE Software, </journal> <pages> pages 13-17, </pages> <month> January </month> <year> 1990. </year>
Reference: [com] <institution> SUPERSTRUCTURE and RETOOL Product descriptions. Computer Data Systems Inc. </institution>
Reference: [Cor89] <author> Thomas A. Corbi. </author> <title> Program understanding: Challenge for the 1990's. </title> <type> Technical Report RC 14370, </type> <institution> IBM Research Division, T.J. Watson Research Center, </institution> <month> January 30 </month> <year> 1989. </year>
Reference: [Cra90] <author> M.A. Crawford. </author> <title> Lurking within Cobol PERFORMs. </title> <journal> Journal of Software Maintenance, </journal> <volume> 2(1) </volume> <pages> 33-46, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Of course recognition cost and rates can be tailored to restructuring, as discussed in 7.1, 9.3.2, and elsewhere. Input language generality may be affected by Cobol language features and the analyzability limitation. Analyzing PERFORM is discussed in [Bus85], [IBM86] and <ref> [Cra90] </ref>, and we haven't come to grips with this problem. Data flow analyzability may or may not be a problem, depending on the data type model and uses of data flow. There are proprietary reverse engineering tools that produce complete Cobol memory models and data flow, despite sharing and indexing.
Reference: [CS90] <author> Song C. Choi and Walt Sacchi. </author> <title> Extracting and restructuring the design of large systems. </title> <journal> IEEE Software, </journal> <month> January </month> <year> 1990. </year>
Reference: [Cur] <author> Bill Curtis. </author> <title> HUMAN BEHAVIOR IN SOFTWARE ENGINEERING. </title> <publisher> McGraw-Hill. In Press. </publisher>
Reference-contexts: Recognition performance reflects the interaction between program representations, knowledge representations, and the recognition procedure. Method and human performance could be compared. For example, the method 7 B.1 and Figure B.1 give the context of plan instance recognition. Program comprehension psychology surveys are in <ref> [Pen85, PG84, Pen87b, Cur] </ref>. 163 may model how human comprehension and debugging performance are affected by data flow delocalization and analyzability.[Wei82] The use of the method as a model for evaluating structured programming is discussed separately below.
Reference: [Cur86] <author> Bill Curtis. </author> <booktitle> HUMAN FACTORS IN SOFTWARE DEVELOPMENT. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <address> second edition, </address> <year> 1986. </year>
Reference: [cut] <institution> CASE Strategies newsletter and reports. Cutter Information Corp. </institution>
Reference: [CW85] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> De-cember </month> <year> 1985. </year>
Reference: [DE88] <author> M. Ducasse and A.-M. Emde. </author> <title> A review of automated debugging systems: Knowledge, strategies, and techniques. </title> <booktitle> In Proceedings of the 10th International Conference on Software Engineering, </booktitle> <pages> pages 162-171, </pages> <address> Singapore, </address> <month> April </month> <year> 1988. </year>
Reference: [DE89] <author> M. Ducasse and A.-M. Emde. </author> <title> A survey of automated bug location. </title> <type> Technical Report IR-LP-31-23, </type> <institution> ECRC, </institution> <month> December </month> <year> 1989. </year>
Reference: [Dij68] <author> E.W. Dijsktra. </author> <title> GO TO Statement considered harmful. </title> <journal> Communications of the ACM, </journal> <volume> 11(3) </volume> <pages> 147-148, </pages> <month> March </month> <year> 1968. </year>
Reference: [Dij87] <author> Edsger W. Dijsktra. </author> <title> Letter in ACM Forum. </title> <journal> Communications of the ACM, </journal> <volume> 30(8) </volume> <pages> 661-662, </pages> <month> August </month> <year> 1987. </year> <month> 39 </month>
Reference: [DS91] <editor> Marc Dymetman and Tomek Strzalkowski. </editor> <booktitle> Workshop on reversible grammar in natural language processing. In PROCEEDINGS OF THE 29TH MEETING OF THE ACL. Association for Computational Linguistics, </booktitle> <month> June </month> <year> 1991. </year> <note> Includes reversible computation. </note>
Reference-contexts: At present it's hard enough to get dedicated recognition plans (and transformations) to work, so duality for other purposes hasn't been our concern. This issue will will become clearer as more plans, constraints, and transformations are acquired and used. 1 1 Related issues will be discussed in <ref> [DS91] </ref>. Appendix D Example Input For CACM BLS Study Rubin2-2a, Musciano's solution to Rubin's bounded linear search problem:[Rub87] Let X be an N X N matrix of integers. Write a program that will print the number of the first all-zero row of X, if any.
Reference: [EM82] <author> James L. Elshoff and Michael Marcotty. </author> <title> Improving computer program readability to aid modification. </title> <journal> Communications of the ACM, </journal> <volume> 25(8), </volume> <year> 1982. </year>
Reference: [Fau81] <author> G. </author> <title> Faust. Semiautomatic translation of Cobol into Hibol. </title> <type> Master's thesis, </type> <institution> M.I.T., </institution> <month> March </month> <year> 1981. </year> <type> TR 256, </type> <institution> MIT Laboratory of Computer Science. </institution>
Reference-contexts: Condition variable used to merge/split cases|We can avoid duplicating case information in new control variables. 10. User implementation of extended control structures, iterators|Eg. translate DO loop with permitted extended control structures or standard implementa tions, annotate. 11. Abstract branches|Eg. selector loop, search loop. 12. Standard file processing, multi-file processing|See <ref> [Fau81] </ref>. 13. Branching structure|Eg. classification networks can be replaced with trees, table etc. 14. Network structure|With justification, some primes should be left unstructured, documented, and encapsulated, eg. logic networks; networks describing user-terminal interaction, implementing FSM's or ATN's.
Reference: [For79] <author> Ira R. Forman. </author> <title> ON THE DECOMPOSITION OF PROGRAMS INTO PRIMES. </title> <type> PhD thesis, </type> <institution> University of Maryland, Dept. for Computer Science, </institution> <year> 1979. </year>
Reference: [Fre81] <author> Greg N. Frederickson. </author> <title> Fast algorithms for parsing flowgraphs using a prime subgraph grammar. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, Penn State University, </institution> <year> 1981. </year> <title> Revision of CS-78-21. </title>
Reference: [Fre83] <author> Peter Freeman. </author> <title> The nature of design. </title> <editor> In Peter Freeman and An-thony I. Wasserman, editors, </editor> <booktitle> TUTORIAL ON SOFTWARE DESIGN TECHNIQUES. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> September </month> <year> 1983. </year>
Reference: [Fre87] <author> Peter Freeman. </author> <title> SOFTWARE REUSABILITY. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference: [GG87] <author> D. J. Gilmore and T. R. G. Green. </author> <title> Are programming plans psychologically real|outside pascal? In Human-Computer Interaction| INTERACT'87. </title> <publisher> IFIP, Elsevier Science Publishers B. V., </publisher> <year> 1987. </year>
Reference: [GH80] <author> John D. Gannon and Matthew Hecht. </author> <title> Parsing a program into its prime subprograms. </title> <type> Technical Report CSC TR 692, </type> <institution> University of Maryland, Dept. of Computer Science, </institution> <year> 1980. </year>
Reference: [GJ79] <author> Michael R. Garey and David S. Johnson. </author> <title> COMPUTERS and INTRACTABILITY: A GUIDE TO THE THEORY OF NP-COMPLETENESS. </title> <editor> W. H. </editor> <publisher> Freeman, </publisher> <year> 1979. </year> <note> Describes work by Luks et. al. </note>
Reference: [Gro78] <author> Design Methods Group. </author> <title> A review of the publications of the Design Methods Group. Design Methods and Theories, </title> <type> 12(3-4), </type> <institution> Sept.-Dec. </institution> <year> 1978. </year> <month> 40 </month>
Reference: [Gui88] <author> Raymonde Guindon. </author> <title> Software design tasks as ill-structured problems, Software design as an opportunistic process. </title> <type> Technical Report STP-214-88, </type> <institution> Microelectronics and Computer Technology Corporation (MCC), </institution> <month> July 7 </month> <year> 1988. </year>
Reference: [Har80] <author> John Hartman. </author> <title> Restructuring Cobol programs into abstract data type modules. </title> <type> Technical Report SDBEG-21, </type> <institution> Dept. of Computer Sciences, The University of Texas at Austin, </institution> <year> 1980. </year> <title> Implementation is described in "XTC User's Guide", </title> <publisher> SDBEG-18. </publisher>
Reference-contexts: D-D paths, basic blocks, natural loops, intervals [Pai77]; data flow [Zis75, HB85, LW90]; and combined control flow and data flow, eg. PBM's, slices, and modules <ref> [Wat79, Wei81, Har80] </ref>.
Reference: [Har83] <author> John Hartman. </author> <title> Programming idiom and concept recognition for high-level translation. References translation experiments, </title> <month> Decem-ber </month> <year> 1983. </year>
Reference-contexts: Our method is specifically applicable to all design representations which contain control and data flow. 4 10.2.1 Tools and Environments Software engineering environments recognize the relationship between maintenance and programming by integrating tools and representations for 3 We describe a translation experiment, concepts, and the application of program understanding in <ref> [Har83] </ref>. Note that translating from an unstructured to a structured language requires restructuring. 4 Designs and representations at higher levels of the semantic spectrum are often said to be more declarative and less procedural, but this needn't be the case.
Reference: [Har87] <author> John Hartman. </author> <title> Automatic program understanding and the maintenance interface. </title> <booktitle> In Second Annual User-System Interface Conference, </booktitle> <address> Austin, Texas, </address> <month> February 20-21 </month> <year> 1987. </year>
Reference: [Har90] <author> John Hartman. </author> <title> Pragmatic program understanding for automated re-engineering. </title> <editor> In George J. Knafl, editor, </editor> <booktitle> COMPSAC90 The Fourteenth Annual International Computer Software & Applications Conference. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> October 31-November 2 </month> <year> 1990. </year> <title> Position paper for Panel on Industrial Experience in Automating Software Re-Engineering. </title>
Reference-contexts: Raising the semantic level of such tools has obvious benefits for improved interpretations and manipulations. Recognizing any concepts makes a contribution. Program understanding can lead to tools with increased benefits and autonomy.[Car85, Cor89, Big89a, OC90, JT90] In <ref> [Har90] </ref> we argue that pragmatic program understanding can automate concept recognition for maintenance tools and tasks. We suggest an application-driven approach of first identifying concepts that can be usefully recognized, then tailoring the recognition method to the application's needs.
Reference: [Har91] <author> John Hartman. </author> <title> Understanding natural programs using proper decomposition. </title> <booktitle> In 13TH INTERNATIONAL CONFERENCE ON SOFTWARE ENGINEERING - ICSE-13. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> May 13-16 </month> <year> 1991. </year>
Reference-contexts: in 11.3 that practical program understanding remains an open empirical question, and working back though our approach to addressing it with a program understander. 22 Best of all, you can avoid reading this dissertation by contacting the author for personal discussions, updated material, new results, and summary publications such as <ref> [Har91] </ref>.
Reference: [HB85] <author> D. H. Hutchens and V. R. Basili. </author> <title> System structure analysis: Clustering with data bindings. </title> <journal> IEEE Transactions. on Software Engineering, </journal> <volume> 11(8) </volume> <pages> 749-757, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: Then we describe the final HMODEL program representation. 2.3.1 Proper Decomposition Various methods can be used for a priori decomposition, using only control flow, eg. D-D paths, basic blocks, natural loops, intervals [Pai77]; data flow <ref> [Zis75, HB85, LW90] </ref>; and combined control flow and data flow, eg. PBM's, slices, and modules [Wat79, Wei81, Har80].
Reference: [Hec77] <author> Matthew Hecht. </author> <title> FLOW ANALYSIS of COMPUTER PROGRAMS. </title> <publisher> Elsevier North Holland, </publisher> <year> 1977. </year>
Reference: [Her81] <author> Robert Herbold. </author> <title> Prime program decomposition of Fortran programs. </title> <type> Master's thesis, </type> <institution> University of Maryland, Dept. of Computer Science, </institution> <year> 1981. </year>
Reference: [HN87] <author> Henderson and Notkin. </author> <title> Special issues on integrated design and programming environments. </title> <booktitle> IEEE Computer, </booktitle> <month> 20(11), November </month> <year> 1987. </year> <note> Also published as IEEE Software, </note> <month> November, </month> <year> 1987. </year> <month> 41 </month>
Reference: [HN90] <author> Mehdi T. Harandi and Jim Q. Ning. </author> <title> Knowledge-Based program analysis. </title> <journal> IEEE Software, </journal> <pages> pages 75-81, </pages> <month> January </month> <year> 1990. </year>
Reference: [Hoc88] <author> J. M. </author> <title> Hoc. COGNITIVE PSYCHOLOGY OF PLANNING. </title> <publisher> Academic Press, </publisher> <month> January </month> <year> 1988. </year>
Reference: [Hol82] <author> John Douglas Holt. </author> <title> ANALYSIS of PROGRAM CONTROL STRUCTURE and DATA FLOW. </title> <type> PhD thesis, </type> <year> 1982. </year> <pages> UMI 82-06529. </pages>
Reference: [HPLH90] <author> Philip A. Hausler, Mark G. Pleszkoch, Richard C. Linger, and Alan R. Hevner. </author> <title> Using function abstraction to understand program behavior. </title> <journal> IEEE Software, </journal> <pages> pages 55-83, </pages> <month> January </month> <year> 1990. </year>
Reference: [Hufts] <author> Huff. </author> <title> Plan-based intelligent assistance: An approach to supporting the software development process. </title> <type> Technical Report 89-97, </type> <institution> Department of Computer and Information Science, University of Massachusetts. </institution>
Reference: [HY85] <author> M. T. Harandi and F. H. Young. </author> <title> Template based specification and design. </title> <booktitle> In Proceedings of the Third International Workshop on Software Specifications and Design, </booktitle> <pages> pages 94-97, </pages> <year> 1985. </year>
Reference-contexts: Knowledge and information information about domains and design can provide guidance when it is available, as discussed in Appendix B and <ref> [AS86, Pen87a, AF85, HY85, PD90, Pot89, Ara89, IW89] </ref>. 175 To maintain realism, we will consider additional information only as it becomes useful for particular applications.
Reference: [IBM86] <author> IBM. </author> <title> Cobol structuring facility - Re-Engineering concepts. </title> <type> Technical Report SC34-4079-0, </type> <month> January </month> <year> 1986. </year>
Reference-contexts: Of course recognition cost and rates can be tailored to restructuring, as discussed in 7.1, 9.3.2, and elsewhere. Input language generality may be affected by Cobol language features and the analyzability limitation. Analyzing PERFORM is discussed in [Bus85], <ref> [IBM86] </ref> and [Cra90], and we haven't come to grips with this problem. Data flow analyzability may or may not be a problem, depending on the data type model and uses of data flow.
Reference: [ics90] <editor> Panel on re-engineering. </editor> <booktitle> In Twelfth International Conference on Software Engineering|12ICSE, </booktitle> <year> 1990. </year>
Reference: [iee88] <author> PROCEEDINGS: </author> <title> 2ND WORKSHOP ON SOFTWARE TESTING, VERIFICATION AND ANALYSIS. </title> <publisher> IEEE Computer Society Press, </publisher> <month> July </month> <year> 1988. </year>
Reference: [IEE90] <editor> IEEE Computer Society Press. </editor> <booktitle> CONFERENCE ON SOFTWARE MAINTENANCE, </booktitle> <address> San Diego, California, </address> <month> November </month> <year> 1990. </year> <note> See previous conferences also. </note>
Reference: [Int89] <institution> International Joint Conferences on Artificial Intelligence. </institution> <note> PROCEEDINGS of the WORKSHOP ON AUTOMATING SOFTWARE DESIGN|IJCAI-89, </note> <year> 1989. </year>
Reference: [Isc88] <editor> Neil Iscoe, editor. </editor> <booktitle> PROCEEDINGS OF THE WORKSHOP ON DOMAIN ANALYSIS. ACM, </booktitle> <month> October </month> <year> 1988. </year> <title> In conjunction with OOPSLA, </title> <address> San Diego. </address> <month> 42 </month>
Reference: [IW89] <editor> Neil Iscoe and Gerry Williams, editors. </editor> <booktitle> PROCEEDINGS OF THE WORKSHOP ON DOMAIN MODELING FOR SOFTWARE ENGINEERING. ACM, </booktitle> <month> October </month> <year> 1989. </year> <title> In conjunction with OOPSLA, </title> <address> New Orleans. </address>
Reference-contexts: Knowledge and information information about domains and design can provide guidance when it is available, as discussed in Appendix B and <ref> [AS86, Pen87a, AF85, HY85, PD90, Pot89, Ara89, IW89] </ref>. 175 To maintain realism, we will consider additional information only as it becomes useful for particular applications.
Reference: [Jac80] <author> M. Jackson. </author> <title> The design and use of conventional computing languages. </title> <editor> In H.T. Smith and T.R.G. Green, editors, </editor> <booktitle> HUMAN INTERACTION WITH COMPUTERS, </booktitle> <pages> pages 321-347. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference: [Joh86] <author> W. Lewis Johnson. </author> <title> INTENTION-BASED DIAGNOSIS OF NOVICE PROGRAMMING ERRORS. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1986. </year>
Reference-contexts: Recall that each stimp matches a set of programs. 19 Transformations may also have recognition and generation parts that are not plans. 20 Note that a relationship name like "specialization" may have different meanings for different authors and uses. 21 Some of these are in the plan library in <ref> [Joh86] </ref>. 62 In the figure, a stimp's sub-tree contains only specialization stimps that recognize a subset of the programs recognized by the parent. Thus the tree describes properly nested sets of recognized programs. In a typical application, checking proceeds top-down.
Reference: [Jon70] <author> Christopher Jones. </author> <title> DESIGN METHODS. </title> <year> 1970. </year>
Reference: [Jon86] <author> Capers Jones. </author> <title> PROGRAMMING PRODUCTIVITY. </title> <publisher> McGraw-Hill, </publisher> <year> 1986. </year>
Reference: [JT90] <author> Stanislaw Jarzabek and Kelly Tham. </author> <title> Towards automating software maintenance. </title> <institution> CSA Research and The National University of Singapore, </institution> <year> 1990. </year>
Reference: [JTPA81] <author> Robin Jeffries, Althea A. Turner, Peter G. Polson, and Michael E. Atwood. </author> <title> The processes involved in designing software. </title> <journal> In COGNITIVE SKILLS and THEIR ACQUISITION, </journal> <pages> pages 255-283. </pages> <address> Erl-baum, </address> <year> 1981. </year>
Reference: [KA86] <author> C.M. Kessler and J.R. Anderson. </author> <title> Learning flow of control: Recursive and iterative procedures. </title> <journal> Human-Computer Interaction, </journal> <volume> 2(2) </volume> <pages> 135-166, </pages> <year> 1986. </year>
Reference: [Kru89] <author> Charles W. Krueger. </author> <title> Models of reuse in software engineering. </title> <type> Technical Report CMU-CS-89-188, </type> <institution> Carnegie Mellon University, School of Computer Science, </institution> <month> December </month> <year> 1989. </year>
Reference: [KU78] <author> Marc Kaplan and Jeffrey Ullman. </author> <title> A general scheme for the automatic inference of variable types. </title> <booktitle> In Fifth Principles of Programming Languages, </booktitle> <year> 1978. </year>
Reference: [KZ77] <author> Ken Kennedy and Linda Zuconi. </author> <title> Applications of a graph grammar for program control flow analysis. </title> <booktitle> In FOURTH PRINCIPLES OF PROGRAMMING LANGUAGES, </booktitle> <month> January </month> <year> 1977. </year> <month> 43 </month>
Reference: [Let87] <author> S. Letovsky. </author> <title> Program understanding with the lambda calculus. </title> <booktitle> In Proceedings of the Tenth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 512-514, </pages> <address> Milan, Italy, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: The resulting hmodel is a tree of sub-hmodels, each of which can be viewed as an independent hmodel. 2.1.2 Issues and HMODEL Design Program representations used in existing understanders are based on combinations of: 1) programming languages,[Rut76, Sol83, Joh86, HN90] 2) graphs,[AL80, RW90a, Wil87, RW90b, Wil90] and 3) formal languages <ref> [Let87, Let88, Mur88] </ref>. 2 Major representations are summarized in Table 2.1. They Table 2.1: Program Representations For Understanders are described and compared to HMODEL in Appendix A. Here we'll briefly describe how HMODEL satisfies the control understanding goals and contrasts with other representations.
Reference: [Let88] <author> Stanley Ian Letovsky. </author> <title> PLAN ANALYSIS OF PROGRAMS. </title> <type> PhD thesis, </type> <institution> Yale University, Dept. of Computer Science, </institution> <month> December </month> <year> 1988. </year> <note> YALEU/CSD/RR 662. </note>
Reference-contexts: The resulting hmodel is a tree of sub-hmodels, each of which can be viewed as an independent hmodel. 2.1.2 Issues and HMODEL Design Program representations used in existing understanders are based on combinations of: 1) programming languages,[Rut76, Sol83, Joh86, HN90] 2) graphs,[AL80, RW90a, Wil87, RW90b, Wil90] and 3) formal languages <ref> [Let87, Let88, Mur88] </ref>. 2 Major representations are summarized in Table 2.1. They Table 2.1: Program Representations For Understanders are described and compared to HMODEL in Appendix A. Here we'll briefly describe how HMODEL satisfies the control understanding goals and contrasts with other representations.
Reference: [Let89] <author> Stanley Letovsky. </author> <title> Plan analysis of programs. </title> <booktitle> In AAAI SPRING SYMPOSIUM ON AI and SOFTWARE ENGINEERING. AAAI, </booktitle> <month> March </month> <year> 1989. </year>
Reference: [LM85] <author> Henry F. Ledgard and Michael Marcotty. </author> <title> A genealogy of control structures. </title> <journal> Communications of the ACM, </journal> <volume> 18(11) </volume> <pages> 629-639, </pages> <month> Novem-ber </month> <year> 1985. </year>
Reference: [LMW79] <author> Richard C. Linger, Harlan D. Mills, and Bernard I. </author> <title> Witt. STRUCTURED PROGRAMMING: THEORY AND PRACTICE. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: Other advantages aside, proper decomposition is required for applications like translation and restructuring that deal with structured and unstructured control structures. Theory of Propers and Structured Programming There is a large literature characterizing control structures, control flow graphs, and structured programs.[LM85, Ram88] We'll present some important definitions, roughly following <ref> [LMW79] </ref>, and describe proper decomposition. This will also show how natural programs are unstructured, and provide background for the restructuring application discussed in Chapter 8. A proper control flow graph has a single entry, a single exit, and a path from the entry to the exit through each node. <p> This section discusses the implementation and some fine points of proper parsing and MODEL-HMODEL. 5.2.1 Proper Parsing The description of proper decomposition in 2.3.1 ignored subtleties in the semantics of propers and their interaction with particular flow graph formalisms. Much of the proper parsing literature, including <ref> [LMW79] </ref>, assumes flow graphs with only binary branches and joins. For example, Gannon and Hecht, and Frederickson give proper parsing algorithms for graphs with binary branches and joins.[GH80, Fre81] We showed in Chapter 2 that n-ary joins are preferable for program understanding because they are unique and capture join associativity. <p> McCarthy's construction gives even worse properties, including more functions and indirect recursion, than the transformation we'll discuss. There are variations in <ref> [Urs75, Moo75, LMW79, Ram88] </ref> etc. 4 The memory environment at each transfer is passed to/returned from the function calls, but since our interest here is control we'll ignore this aspect to simplify the discussion and examples. 7 Figure A.3: Flow Graph and Tail Recursive Functions Figure A.4: Source Programs Transformed to
Reference: [Lon90] <author> David H. Longstreet. </author> <title> SOFTWARE MAINTENANCE and COMPUTERS. </title> <publisher> IEEE Computer Society Press, </publisher> <month> March </month> <year> 1990. </year>
Reference: [LS86] <author> S. Letovsky and E. Soloway. </author> <title> Delocalized plans and program comprehension. </title> <journal> IEEE Software, </journal> <volume> 3(3) </volume> <pages> 41-49, </pages> <year> 1986. </year>
Reference: [Luk80] <author> F. J. Lukey. </author> <title> Understanding and debugging programs. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 12 </volume> <pages> 189-202, </pages> <year> 1980. </year>
Reference: [LW90] <author> S. S. Liu and N. Wilde. </author> <title> Identifying objects in a conventional procedural language: An example of data design recovery. </title> <booktitle> In Conference on Software Maintenance, </booktitle> <pages> pages 266-271, </pages> <address> San Diego, CA, </address> <month> Novem-ber </month> <year> 1990. </year>
Reference-contexts: Then we describe the final HMODEL program representation. 2.3.1 Proper Decomposition Various methods can be used for a priori decomposition, using only control flow, eg. D-D paths, basic blocks, natural loops, intervals [Pai77]; data flow <ref> [Zis75, HB85, LW90] </ref>; and combined control flow and data flow, eg. PBM's, slices, and modules [Wat79, Wei81, Har80].
Reference: [Man74] <author> Zohar Manna. </author> <title> MATHEMATICAL THEORY OF COMPUTING. </title> <publisher> McGraw-Hill, </publisher> <year> 1974. </year>
Reference: [Mar90] <author> L. Z. Markosian. </author> <title> Panel on industrial experience in automating software re-engineering. </title> <editor> In George J. Knafl, editor, </editor> <booktitle> COMPSAC90 - The Fourteenth Annual International Computer Software & Applications Conference, </booktitle> <pages> pages 611-616. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> October 31-November 2 </month> <year> 1990. </year> <month> 44 </month>
Reference: [Mat78] <author> David L. Matuszek. </author> <title> DISJUNCTIVE COMPLEXITY OF ASSERTIONS AS A MODEL OF PERCEIVED COMPLEXITY OF COMPUTER PROGRAMS. </title> <type> PhD thesis, </type> <institution> The University of Texas at Austin, Dept. of Computer Sciences, </institution> <month> August </month> <year> 1978. </year>
Reference: [McC60] <author> John McCarthy. </author> <title> Recursive functions of symbolic functions and their computation by machine. </title> <journal> Communications of the ACM, </journal> <volume> 3(4), </volume> <month> April </month> <year> 1960. </year>
Reference-contexts: This looks good on paper, but let's see what happens when source programs are transformed to the recursive representation. Figure A.4 contains two Cobol source programs for this problem, their recursive functions, and the call graphs. 3 The transformation is attributed to McCarthy in <ref> [McC60] </ref>. This may be an early publication of the transformation idea, but McCarthy's transformation differs from Steele's in that it creates a new function for every branch, instead of every label. McCarthy's construction gives even worse properties, including more functions and indirect recursion, than the transformation we'll discuss.
Reference: [MDG86] <author> Ali Mili, Jules Desharais, and Jean Gagne. </author> <title> Formal models of stepwise refinement of programs. </title> <journal> Computing Surveys, </journal> <volume> 18(3), </volume> <month> September </month> <year> 1986. </year>
Reference: [MG90] <author> Mary Lou Maher and John S. Gero. </author> <title> Theme issue on design theories, models, and problem solving. </title> <journal> AI Magazine, </journal> <volume> 11(4), </volume> <month> Winter </month> <year> 1990. </year>
Reference: [MH90] <author> K. Miriyala and M. T. Harandi. </author> <title> Automatic derivation of formal software specifications from informal descriptions. </title> <type> Technical Report UIUCDCS-R-90-1581, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <type> 240 DCL, 1304 W. </type> <address> Springfield Ave., Urbana, IL 61801, </address> <month> April </month> <year> 1990. </year>
Reference: [MJ81] <author> Stephen S. Muchnick and Neil D. Jones. </author> <title> PROGRAM FLOW ANALYSIS: THEORY and APPLICATIONS. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference: [Moo75] <author> J. Strother Moore. </author> <title> Introducing iteration into the pure Lisp theorem proved. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 1(3), </volume> <month> September </month> <year> 1975. </year>
Reference-contexts: McCarthy's construction gives even worse properties, including more functions and indirect recursion, than the transformation we'll discuss. There are variations in <ref> [Urs75, Moo75, LMW79, Ram88] </ref> etc. 4 The memory environment at each transfer is passed to/returned from the function calls, but since our interest here is control we'll ignore this aspect to simplify the discussion and examples. 7 Figure A.3: Flow Graph and Tail Recursive Functions Figure A.4: Source Programs Transformed to
Reference: [MRRH81] <author> K.B. McKeithen, J.S. Reitman, H.H. Rueter, </author> <title> and S.C. Hirtle. Knowledge organization and skill differences in computer programmers. </title> <journal> Cognitive Psychology, </journal> <volume> 13 </volume> <pages> 307-325, </pages> <year> 1981. </year>
Reference: [MS87] <author> J. Miller and Strang. </author> <title> Implications of automatic restructuring of Cobol. </title> <journal> SIGPLAN Notices, </journal> <volume> 22(6) </volume> <pages> 76-82, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Linger, Mills, and Witt give transformations which improve the results of label structuring.[LMW79] Othmer describes classes of restructuring algorithms in the context of Cobol restructuring.[Oth81] Commercial Cobol restructuring tools are discussed in <ref> [Car85, Par86, MS87] </ref>. Major products and methodologies include Peat Marwick's Structured Retrofit, CDSI's SUPERSTRUCTURE and RETOOL, IBM's Cobol Structuring Facility, and Language Technology's RECODER.[pea84, com, BG85, IBM86, Bus85] The U.S.
Reference: [Mur88] <author> William R. Murray. </author> <title> AUTOMATIC PROGRAM DEBUGGING FOR INTELLIGENT TUTORING SYSTEMS. </title> <publisher> Morgan Kauf-mann, </publisher> <year> 1988. </year>
Reference-contexts: The resulting hmodel is a tree of sub-hmodels, each of which can be viewed as an independent hmodel. 2.1.2 Issues and HMODEL Design Program representations used in existing understanders are based on combinations of: 1) programming languages,[Rut76, Sol83, Joh86, HN90] 2) graphs,[AL80, RW90a, Wil87, RW90b, Wil90] and 3) formal languages <ref> [Let87, Let88, Mur88] </ref>. 2 Major representations are summarized in Table 2.1. They Table 2.1: Program Representations For Understanders are described and compared to HMODEL in Appendix A. Here we'll briefly describe how HMODEL satisfies the control understanding goals and contrasts with other representations.
Reference: [Nin89a] <author> Jim Q. Ning. </author> <title> An experiment in automating code analysis. </title> <booktitle> In AAAI SPRING SYMPOSIUM ON AI and SOFTWARE ENGINEERING, </booktitle> <month> March </month> <year> 1989. </year> <month> 45 </month>
Reference: [Nin89b] <author> Jim Q. Ning. </author> <title> A KNOWLEDGE-BASED APPROACH TO AUTOMATIC PROGRAM ANALYSIS. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1989. </year>
Reference: [Nov83] <author> Gordon S. Novak. </author> <title> GLISP: A Lisp-based programming system with data abstraction. </title> <journal> The AI Magazine, </journal> <pages> pages 37-47, </pages> <month> Fall </month> <year> 1983. </year> <note> Manual is TR-83-25, </note> <institution> Dept. of Computer Sciences, The University of Texas at Austin, </institution> <month> December, </month> <year> 1983. </year>
Reference: [NTI88] <editor> NTIS. </editor> <booktitle> Software tools for software maintenance. </booktitle> <address> AD-A216 910/0/WCC, </address> <year> 1988. </year>
Reference: [NTI90] <author> NTIS. </author> <title> Software quality and metrics, </title> <month> January </month> <year> 1987-April 1990, </year> <month> April </month> <year> 1990. </year> <title> A bibliography from the INSPEC, </title> <journal> PB90-864505/WLI. </journal> <note> See also PB90-862152/WCC and PB89-871792/WLI. </note>
Reference: [OC90] <author> Wilma M. Osborne and Eliot J. Chikofsky. </author> <title> Fitting pieces to the maintenance puzzle. </title> <journal> IEEE Software, </journal> <month> January </month> <year> 1990. </year> <title> Theme issue on software maintenance and re-engineering. </title>
Reference: [Oma90] <author> Paul Oman. </author> <title> Maintenance tools. </title> <journal> IEEE Software, </journal> <pages> pages 59-65, </pages> <month> May </month> <year> 1990. </year>
Reference: [ore90] <institution> SECOND ANNUAL OREGON WORKSHOP ON SOFTWARE METRICS. 1990. Portland State University, Oregon Center for Advanced Technology Education. </institution>
Reference: [OSS87] <author> Gary M. Olson, Sylvia Sheppard, and Elliot Soloway. </author> <title> EMPIRICAL STUDIES of PROGRAMMERS: </title> <booktitle> SECOND WORKSHOP. </booktitle> <publisher> Ablex, </publisher> <year> 1987. </year>
Reference: [Oth81] <author> Bobbie Ann Fredsall Othmer. </author> <title> RESTRUCTURING COBOL PROGRAMS TO IMPROVE READABILITY. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <year> 1981. </year>
Reference-contexts: The real Cobol programs were obtained from a commercial Cobol shop, the Univer sity of Texas Computation Center, restructuring literature <ref> [Oth81] </ref>, and the UT Library. The CACM programs are Cobol translations of programs published 99 100 in Communications of the ACM, as discussed below in 6.3.
Reference: [Our89] <author> Dirk Oursten. </author> <title> Program recognition. </title> <journal> IEEE Expert, </journal> <pages> pages 36-49, </pages> <month> Winter </month> <year> 1989. </year>
Reference-contexts: We call these systems program matchers because they use advance information about requirements 3 More detailed discussions of the literature are in Chapters 2-4, Appendix A, and elsewhere. Surveys are found in many of the primary references and <ref> [Our89] </ref>. 5 Table 1.1: Summary of Major Program Understanders and implementations. They demonstrate that complete program recognition is possible with small, restricted student programs. However, their methods require advance descriptions of the programs sought. In contrast, bottom-up understanders attempt deep understanding of larger, more varied programs, without advance program information.
Reference: [Pai77] <author> Michael R. Paige. </author> <title> On partitioning program graphs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 3(6), </volume> <month> November </month> <year> 1977. </year>
Reference-contexts: Then we describe the final HMODEL program representation. 2.3.1 Proper Decomposition Various methods can be used for a priori decomposition, using only control flow, eg. D-D paths, basic blocks, natural loops, intervals <ref> [Pai77] </ref>; data flow [Zis75, HB85, LW90]; and combined control flow and data flow, eg. PBM's, slices, and modules [Wat79, Wei81, Har80].
Reference: [Par72] <author> David Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Communications of the ACM, </journal> <volume> 15(12), </volume> <month> December </month> <year> 1972. </year> <month> 46 </month>
Reference: [Par86] <author> Girish Parikh. </author> <title> Restructuring engines clean up spaghetti code. </title> <type> Computerworld, </type> <month> March 31 </month> <year> 1986. </year> <note> See also Special Section on Software Maintenance, Computerworld, </note> <month> Feb. 19, </month> <year> 1986. </year>
Reference-contexts: Linger, Mills, and Witt give transformations which improve the results of label structuring.[LMW79] Othmer describes classes of restructuring algorithms in the context of Cobol restructuring.[Oth81] Commercial Cobol restructuring tools are discussed in <ref> [Car85, Par86, MS87] </ref>. Major products and methodologies include Peat Marwick's Structured Retrofit, CDSI's SUPERSTRUCTURE and RETOOL, IBM's Cobol Structuring Facility, and Language Technology's RECODER.[pea84, com, BG85, IBM86, Bus85] The U.S.
Reference: [Par90] <author> Helmut A. Partsch. </author> <title> SPECIFICATION and TRANSFORMATION OF PROGRAMS. </title> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1990. </year>
Reference: [PD90] <author> Ruben Prieto-Diaz. </author> <title> Domain analysis: An introduction. </title> <booktitle> Software Engineering Notes, </booktitle> <pages> pages 47-54, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Knowledge and information information about domains and design can provide guidance when it is available, as discussed in Appendix B and <ref> [AS86, Pen87a, AF85, HY85, PD90, Pot89, Ara89, IW89] </ref>. 175 To maintain realism, we will consider additional information only as it becomes useful for particular applications.
Reference: [pea84] <institution> Structured Retrofit! Preserving your software asset. Peat, Mar-wick, and Mitchell & Co., </institution> <year> 1984. </year>
Reference: [Pen85] <author> Nancy Pennington. </author> <title> Cognitive components of expertise in computer programming: A review of the literature. </title> <journal> Psychological Documents, </journal> <volume> 15(1), </volume> <month> July </month> <year> 1985. </year> <note> Covers research up to June 1982. </note>
Reference-contexts: Propers and primes are thought to be natural because of their formal advantages, psychological justifications such as memory span and decomposability, and empirical evidence.[VW84, VW86] Implementation using propers is also widely taught and encouraged 6 See <ref> [PG84, Pen85, Sol82] </ref> and the references in 3.1.1. 162 by programming languages. Natural generation and recognition plans should therefore reflect this organization. This is confirmed when our method gives good performance using plans localized with respect to proper decomposition, and poor performance when plans are delocalized. <p> Recognition performance reflects the interaction between program representations, knowledge representations, and the recognition procedure. Method and human performance could be compared. For example, the method 7 B.1 and Figure B.1 give the context of plan instance recognition. Program comprehension psychology surveys are in <ref> [Pen85, PG84, Pen87b, Cur] </ref>. 163 may model how human comprehension and debugging performance are affected by data flow delocalization and analyzability.[Wei82] The use of the method as a model for evaluating structured programming is discussed separately below.
Reference: [Pen87a] <author> Nancy Pennington. </author> <title> Comprehension strategies in programming. </title> <editor> In Gary M. Olson, Sylvia Sheppard, and Elliot Soloway, editors, </editor> <title> Empirical Studies of Programmers: </title> <booktitle> Second Workshop, </booktitle> <address> Norwood, NJ, 1987. </address> <publisher> Ablex. </publisher>
Reference-contexts: Knowledge and information information about domains and design can provide guidance when it is available, as discussed in Appendix B and <ref> [AS86, Pen87a, AF85, HY85, PD90, Pot89, Ara89, IW89] </ref>. 175 To maintain realism, we will consider additional information only as it becomes useful for particular applications.
Reference: [Pen87b] <author> Nancy Pennington. </author> <title> Stimulus structures and mental representations in expert comprehension of computer programs. </title> <journal> Cognitive Psychology, </journal> <volume> 19 </volume> <pages> 295-341, </pages> <year> 1987. </year>
Reference-contexts: Recognition performance reflects the interaction between program representations, knowledge representations, and the recognition procedure. Method and human performance could be compared. For example, the method 7 B.1 and Figure B.1 give the context of plan instance recognition. Program comprehension psychology surveys are in <ref> [Pen85, PG84, Pen87b, Cur] </ref>. 163 may model how human comprehension and debugging performance are affected by data flow delocalization and analyzability.[Wei82] The use of the method as a model for evaluating structured programming is discussed separately below.
Reference: [Pfr89] <author> Steven Pfrenzinger. </author> <booktitle> CASEing the Cobol joint. Computerworld, </booktitle> <pages> pages 29+, </pages> <month> October </month> <year> 1989. </year>
Reference: [PG84] <author> Nancy Pennington and Beatrice Grabowski. </author> <title> Cognitive components of expertise in computer programming: A review and conceptual framework. </title> <institution> Graduate School of Business, University of Chicago, </institution> <year> 1984. </year>
Reference-contexts: Propers and primes are thought to be natural because of their formal advantages, psychological justifications such as memory span and decomposability, and empirical evidence.[VW84, VW86] Implementation using propers is also widely taught and encouraged 6 See <ref> [PG84, Pen85, Sol82] </ref> and the references in 3.1.1. 162 by programming languages. Natural generation and recognition plans should therefore reflect this organization. This is confirmed when our method gives good performance using plans localized with respect to proper decomposition, and poor performance when plans are delocalized. <p> Recognition performance reflects the interaction between program representations, knowledge representations, and the recognition procedure. Method and human performance could be compared. For example, the method 7 B.1 and Figure B.1 give the context of plan instance recognition. Program comprehension psychology surveys are in <ref> [Pen85, PG84, Pen87b, Cur] </ref>. 163 may model how human comprehension and debugging performance are affected by data flow delocalization and analyzability.[Wei82] The use of the method as a model for evaluating structured programming is discussed separately below.
Reference: [Pos89] <author> Jonathan V. Post. </author> <title> Garbage into gold: The need for intelligent Fortran-to-Ada conversion. </title> <booktitle> In AAAI SPRING SYMPOSIUM ON AI and SOFTWARE ENGINEERING, </booktitle> <month> March </month> <year> 1989. </year>
Reference: [Pot89] <author> C. Potts. </author> <title> Requirements analysis, domain knowledge, and design. </title> <type> Technical Report STP-313-88, </type> <institution> Microelectronics and Computer Technology Corporation (MCC), </institution> <month> February 16 </month> <year> 1989. </year>
Reference-contexts: Knowledge and information information about domains and design can provide guidance when it is available, as discussed in Appendix B and <ref> [AS86, Pen87a, AF85, HY85, PD90, Pot89, Ara89, IW89] </ref>. 175 To maintain realism, we will consider additional information only as it becomes useful for particular applications.
Reference: [PS83] <author> H. Partsch and R. Steinbruggen. </author> <title> Program transformation systems. </title> <journal> Computing Surveys, </journal> <volume> 15(3) </volume> <pages> 199-236, </pages> <year> 1983. </year> <month> 47 </month>
Reference: [PZ83] <author> Girish Parikh and Nicholas Zvegintzov. </author> <title> TUTORIAL ON SOFTWARE MAINTENANCE. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1983. </year>
Reference: [Ram84] <author> Allan Ramsay. </author> <title> Type-checking in an untyped language. </title> <journal> International Journal on Man-Machine Studies, </journal> <volume> 20 </volume> <pages> 157-167, </pages> <month> February </month> <year> 1984. </year>
Reference: [Ram88] <author> Lyle Ramshaw. </author> <title> Eliminating GOTO's while preserving program structure. </title> <journal> Journal of the ACM, </journal> <volume> 35(4), </volume> <month> October </month> <year> 1988. </year>
Reference-contexts: McCarthy's construction gives even worse properties, including more functions and indirect recursion, than the transformation we'll discuss. There are variations in <ref> [Urs75, Moo75, LMW79, Ram88] </ref> etc. 4 The memory environment at each transfer is passed to/returned from the function calls, but since our interest here is control we'll ignore this aspect to simplify the discussion and examples. 7 Figure A.3: Flow Graph and Tail Recursive Functions Figure A.4: Source Programs Transformed to
Reference: [RE90] <author> Rosemary Rock-Evans. </author> <title> REVERSE ENGINEERING: MARKETS, METHODS, and TOOLS. </title> <institution> Cutter Information Corp., </institution> <year> 1990. </year>
Reference: [Rei89] <author> Brian J. Reiser. </author> <title> Reasoning and explanation in an intelligent tutor for programming. </title> <booktitle> In 3rd INTERNATIONAL CONFERENCE ON HUMAN-COMPUTER INTERACTION, </booktitle> <year> 1989. </year>
Reference: [Ric81a] <author> Charles Rich. </author> <title> Formal representation for plans in the programmer's apprentice. </title> <booktitle> In International Joint Conference on Artificial Intelligence, </booktitle> <pages> page 1044, </pages> <year> 1981. </year>
Reference-contexts: single self-recursive functions as in Figure A.3. 5 However, for unstructured programs this requires substantial control flow analysis. 6 It 5 In the M.I.T. plan diagram representation, such a transformation has been used to justify the equivalence of cyclic flow graphs and acyclic flow graphs with single self graph recursion <ref> [Wat78, Ric81a] </ref>. 6 Irreducible programs (programs with multi-entry loops), which are rare in practice, can 8 could be argued that this analysis, and other operations, could be performed with functions as well as with flow graphs. In practice, many operations are harder with functions because control flow is less explicit.
Reference: [Ric81b] <author> Charles Rich. </author> <title> Inspection methods in programming. </title> <type> Technical Report MIT/AI/TR-604, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> June </month> <year> 1981. </year> <type> PhD Thesis. </type>
Reference-contexts: The method is indifferent to the contents of stimps. As with human program understanding, knowledge determines the interpretation in terms of abstract concepts. 9 For example, a similar representation is formalized in <ref> [Ric81b] </ref>. Testing with UNPROG increases our confidence that the method's components and their integration work as intended, assuming that implementation errors do not mask method errors. 115 complete languages and predicate calculus. Therefore, all instances and all plans can be expressed and recognized. <p> Only function equivalence is preserved. In various versions of the plan calculus control flow and loops have been represented as cyclic graphs or acyclic graphs with graph recursion. Although inspection was an original motivation for the plan calculus <ref> [Ric81b] </ref>, as far as we know, surface plans have not been used for recognition. 1 Instead, recognition work at M.I.T. has modified surface plan diagrams for recognition by parsing.[Wil87] Wills' RECOGNIZER is based on (an extension of) Brotsky's acyclic "flow graph" (f. g. ) parser. 2 [Bro84] The parser constrains the
Reference: [Ric87] <author> Charles Rich. </author> <title> Inspection methods in programming: Cliches and plans. </title> <type> Technical Report A.I. Memo No. 1005, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> December </month> <year> 1987. </year>
Reference-contexts: In almost every system, the recognition plan representation and the program representation are designed to be similar, in part to facilitate the recognition process. 3 Rich surveys some other formalisms for representing programming plans in <ref> [Ric87] </ref>. 50 Table 3.1: Recognition Plan Representations LAURA, PROUST and TALUS are student program tutor/debuggers which match student programs against known correct solutions. Their recognition plans aren't so much programming knowledge as knowledge of particular programs, solutions, or algorithms. <p> TALUS and CPU are naturally decomposed by functions. Hierarchical plan diagrams with abstract segments have been described in [Wat78] and <ref> [Ric87] </ref>, but it's not clear how this facility has been used. The most important decomposition approach in the Programmer's Apprentice is Waters' plan building methods (PBM's) and similar basic loop plans in RECOGNIZER.[Wat79, Wil87] PBM's straddle the border between analysis and knowledge-based understanding.
Reference: [Ris86] <author> R. S. Rist. </author> <title> Plans in programming: Definition, demonstration, and development. </title> <editor> In Elliot Soloway and Sitharama Iyengar, editors, </editor> <booktitle> Empirical Studies of Programmers, </booktitle> <pages> pages 28-47. </pages> <publisher> Ablex, </publisher> <month> June </month> <year> 1986. </year> <note> Papers presented at the First Workshop. </note>
Reference: [ROJ90] <author> Spencer Rugaber, Stephen B. Ornburn, and Richard J. LeBlanc Jr. </author> <title> Recognizing design decisions in programs. </title> <journal> IEEE Software, </journal> <month> January </month> <year> 1990. </year>
Reference: [Rom90] <institution> Rome Air Development Center. </institution> <note> Fifth Annual Knowledge-Based Software Assistant Conference, </note> <institution> Griffiss Air Force Base, </institution> <address> NY 13441-5700, </address> <month> January </month> <year> 1990. </year> <note> See also four previous RADC conferences. </note>
Reference: [Rub87] <author> Frank Rubin. </author> <title> "GOTO considered harmful" considered harmful. </title> <journal> Communications of the ACM, </journal> <volume> 30(3) </volume> <pages> 197-196, </pages> <month> March </month> <year> 1987. </year> <note> ACM Forum, and correspondence in 30:5, 30:6, 30:7, 30:8, 30:10, 30:11. 48 </note>
Reference: [Rug77] <author> Jon Spencer Rugaber. </author> <title> A MODEL of the UNDERSTANDABILITY of COMPUTER PROGRAMS. </title> <type> PhD thesis, </type> <institution> YALE UNIVERSITY, Dept. of Computer Science, </institution> <year> 1977. </year>
Reference: [Rut76] <author> G. R. Ruth. </author> <title> Intelligent program analysis. </title> <journal> Artificial Intelligence, </journal> <volume> 7 </volume> <pages> 65-85, </pages> <year> 1976. </year>
Reference: [RW86] <author> Charles Rich and Richard C. Waters. </author> <booktitle> READINGS IN ARTIFICIAL INTELLIGENCE and SOFTWARE ENGINEERING. </booktitle> <publisher> Mor-gan Kaufmann, </publisher> <year> 1986. </year>
Reference: [RW88] <author> Charles Rich and Richard C. Waters. </author> <title> Automatic programming: Myths and prospects. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 40-51, </pages> <month> August </month> <year> 1988. </year>
Reference: [RW89] <author> H.B. Reubenstein and Richard C. Waters. </author> <title> The requirements apprentice: An initial scenario. </title> <booktitle> In 5th International Workshop on Software Specification and Design, </booktitle> <month> May </month> <year> 1989. </year>
Reference: [RW90a] <author> Charles Rich and Richard C. Waters. </author> <title> THE PROGRAMMER'S APPRENTICE. </title> <publisher> ACM Press and Addison-Wesley Publishing Co., </publisher> <year> 1990. </year>
Reference: [RW90b] <author> Charles Rich and Linda M. Wills. </author> <title> Recognizing a program's design: A graph-parsing approach. </title> <journal> IEEE Software, </journal> <pages> pages 83-90, </pages> <month> January </month> <year> 1990. </year>
Reference: [SC88] <author> Ben Shneiderman and John M. Carroll. </author> <title> Ecological studies of professional programmers. </title> <journal> Communications of the ACM, </journal> <volume> 31(11), </volume> <month> November </month> <year> 1988. </year> <title> Introduction to special section on field studies of programmers. </title>
Reference: [SE84] <author> Elliot Soloway and Kate Ehrlich. </author> <title> Empirical studies of programming knowledge. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10(5) </volume> <pages> 595-609, </pages> <month> September </month> <year> 1984. </year>
Reference: [SEB83] <author> Elliot Soloway, Kate Ehrlich, and Jeffrey Bonar. </author> <title> Cognitive strategies and looping concepts: An empirical study. </title> <journal> Communications of the ACM, </journal> <volume> 26(11), </volume> <month> November </month> <year> 1983. </year>
Reference: [SGR89] <author> Mary Shaw, Dario Giuse, and Raj Reddy. </author> <title> What a software engineer needs to know: I. Program vocabulary. </title> <type> Technical Report CMU-CS-89-190, </type> <institution> Carnegie Mellon University, Dept. of Computer Science, </institution> <year> 1989. </year> <month> 49 </month>
Reference: [Sol82] <author> Elliot Soloway. </author> <title> Tapping into tacit programming knowledge. </title> <booktitle> In PROCEEDINGS of the CONFERENCE ON HUMAN FACTORS IN COMPUTER SYSTEMS, </booktitle> <year> 1982. </year>
Reference-contexts: Propers and primes are thought to be natural because of their formal advantages, psychological justifications such as memory span and decomposability, and empirical evidence.[VW84, VW86] Implementation using propers is also widely taught and encouraged 6 See <ref> [PG84, Pen85, Sol82] </ref> and the references in 3.1.1. 162 by programming languages. Natural generation and recognition plans should therefore reflect this organization. This is confirmed when our method gives good performance using plans localized with respect to proper decomposition, and poor performance when plans are delocalized.
Reference: [Sol83] <author> Elliot Soloway. MENO-II: </author> <title> An intelligent programming tutor. Journal of Computer-Based Instruction, </title> <booktitle> 10(1 and 2), </booktitle> <month> Summer </month> <year> 1983. </year>
Reference-contexts: The Figure A.1: Program Representations For Understanders 1 2 recognition component of Murray's TALUS uses a pure Lisp subset.[Mur88] Ning's PAT represents source statements as objects in a data base with associated properties from analysis.[Nin89b] Johnson's PROUST understander (and its predecessor, MENO-II <ref> [Sol83] </ref>) represents Pascal programs by their (modified) syntax trees. He concedes, however, that a more abstract representation is needed "to keep from being thrown off by irrelevant variability."[Joh86] Generally, real world source languages create user convenience and syntactic sugar by providing multiple forms for expressing the same thing.
Reference: [Sol85] <author> Elliot Soloway. </author> <title> From problems to programs via plans: The content and structure of knowledge for introductory LISP programming. </title> <journal> Journal of Educational Computing Research, </journal> <year> 1985. </year>
Reference: [Sol86] <author> Elliot Soloway. </author> <title> Learning to program = Learning to construct mechanisms and explanations. </title> <journal> Communications of the ACM, </journal> <volume> 29(9) </volume> <pages> 850-858, </pages> <month> September </month> <year> 1986. </year>
Reference: [SPL + 88] <author> Elliot Soloway, Jeanne Pinto, Stan Letovsky, David Littman, and Robin Lampert. </author> <title> Designing documentation to compensate for de-localized plans. </title> <journal> Communications of the ACM, </journal> <volume> 31(11) </volume> <pages> 1259-1267, </pages> <month> November </month> <year> 1988. </year>
Reference: [SS89] <author> Elliot Soloway and James C. Spohrer. </author> <title> STUDYING the NOVICE PROGRAMMER. </title> <editor> L. </editor> <publisher> Erlbaum Associates, </publisher> <year> 1989. </year>
Reference: [SSP85] <author> J. Spohrer, E. Soloway, and E. Pope. </author> <title> A goal/plan analysis of buggy Pascal programs. </title> <booktitle> Human Computer Interaction, </booktitle> <month> Fall </month> <year> 1985. </year>
Reference: [Ste76] <author> G.L. Steele. </author> <title> LAMBDA|The ultimate imperative. </title> <type> Technical Report AI Memo 353, </type> <institution> M.I.T. AI laboratory, </institution> <year> 1976. </year>
Reference-contexts: The recursive representations are just other source languages. In contrast to flow graphs, they are not intrinsically more abstract or canonical than the original source program. Steele's Scheme papers <ref> [Ste76] </ref> show how recursion and iteration can be viewed as variants, and give a transformation from iteration to recursion. 3 In TALUS and CPU, Murray and Letovsky use a simple syntactic transformation like Steele's to translate iterative programs to sets of recursive functions.[Mur88, Let88] Each "labeled block" becomes a function.
Reference: [Ste81] <author> Barbara Steele. </author> <title> An accountable source-to-source transformation system. </title> <type> Technical Report MIT AI TR-636, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> June </month> <year> 1981. </year>
Reference: [Ste90] <author> Sam Steel. </author> <title> Bibliography on planning in AI. </title> <institution> Dept. of Computer Science, University of Essex, UK, </institution> <month> August </month> <year> 1990. </year>
Reference: [sw-90] <institution> Software re-engineering symposium. Digital Consulting, Inc., </institution> <note> Jan-uary 29-31 1990. Trade conference. </note>
Reference: [Tem87] <author> Aaron L. Temin. </author> <title> ANSWERING QUESTIONS ABOUT PROGRAM BEHAVIOR BY TRACING COMMANDS THROUGH SOURCE CODE. </title> <type> PhD thesis, </type> <institution> The University of Texas at Austin, Dept. of Computer Sciences, </institution> <year> 1987. </year> <month> 50 </month>
Reference: [tra85] <editor> AI tools automate software translation. </editor> <booktitle> Journal of Electronics, </booktitle> <pages> pages 59-61, </pages> <month> September 23 </month> <year> 1985. </year>
Reference: [Tra88] <author> Will Tracz. </author> <title> SOFTWARE REUSE|EMERGING TECHNOLOGY. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1988. </year>
Reference: [TV80] <author> Robert E. Tarjan and Jacabo Valdes. </author> <title> Prime subprogram parsing of a program. </title> <booktitle> In Seventh Conference: Principles of Programming Languages, </booktitle> <year> 1980. </year>
Reference: [Urs75] <author> G. Urschler. </author> <title> Automatic structuring of programs. </title> <journal> IBM Journal of Research and Development, </journal> <month> March </month> <year> 1975. </year>
Reference-contexts: McCarthy's construction gives even worse properties, including more functions and indirect recursion, than the transformation we'll discuss. There are variations in <ref> [Urs75, Moo75, LMW79, Ram88] </ref> etc. 4 The memory environment at each transfer is passed to/returned from the function calls, but since our interest here is control we'll ignore this aspect to simplify the discussion and examples. 7 Figure A.3: Flow Graph and Tail Recursive Functions Figure A.4: Source Programs Transformed to
Reference: [Ves87] <author> Iris Vessey. </author> <title> On matching programmers' chunks with program structures: An empirical investigation. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 27 </volume> <pages> 65-89, </pages> <year> 1987. </year> <note> Considers Cobol. </note>
Reference: [VW84] <author> Iris Vessey and Ron Weber. </author> <title> Research on structured programming: An empiricist's evaluation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10(4), </volume> <month> July </month> <year> 1984. </year>
Reference: [VW86] <author> Iris Vessey and Ron Weber. </author> <title> Structured tools and conditional logic: An empirical investigation. </title> <journal> Communications of the ACM, </journal> <volume> 29(1), </volume> <year> 1986. </year> <note> Considers Cobol. </note>
Reference: [Wat78] <author> Richard C. Waters. </author> <title> Automatic analysis of the logical structure of programs. </title> <type> Technical Report MIT AI TR-492, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> December </month> <year> 1978. </year> <type> PhD Thesis. </type>
Reference-contexts: TALUS and CPU are naturally decomposed by functions. Hierarchical plan diagrams with abstract segments have been described in <ref> [Wat78] </ref> and [Ric87], but it's not clear how this facility has been used. The most important decomposition approach in the Programmer's Apprentice is Waters' plan building methods (PBM's) and similar basic loop plans in RECOGNIZER.[Wat79, Wil87] PBM's straddle the border between analysis and knowledge-based understanding. <p> single self-recursive functions as in Figure A.3. 5 However, for unstructured programs this requires substantial control flow analysis. 6 It 5 In the M.I.T. plan diagram representation, such a transformation has been used to justify the equivalence of cyclic flow graphs and acyclic flow graphs with single self graph recursion <ref> [Wat78, Ric81a] </ref>. 6 Irreducible programs (programs with multi-entry loops), which are rare in practice, can 8 could be argued that this analysis, and other operations, could be performed with functions as well as with flow graphs. In practice, many operations are harder with functions because control flow is less explicit. <p> In the figure it's not clear what the T/F cases in the loop join mean, and path conditions can't be given by simple correspondence with a test in unstructured joins such as those in Figure 5.4. 9 <ref> [Wat78] </ref> only describes such semantics for acyclic plans. 11 Wills' attributed flow graph projection extends plan diagrams for recognition by an f. g. parser. It inherits and strengthens plan diagram's strong data flow, with accompanying problems, and also raises issues of explicitness.
Reference: [Wat79] <author> Richard C. Waters. </author> <title> A method for automatically analyzing programs. </title> <booktitle> In International Joint Conference on Artificial Intelligence, </booktitle> <year> 1979. </year>
Reference-contexts: D-D paths, basic blocks, natural loops, intervals [Pai77]; data flow [Zis75, HB85, LW90]; and combined control flow and data flow, eg. PBM's, slices, and modules <ref> [Wat79, Wei81, Har80] </ref>.
Reference: [Wat85] <author> Richard C. Waters. KBEMACS: </author> <title> A step toward the programmer's apprentice. </title> <type> Technical Report A.I. T.R. No. 753, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> May </month> <year> 1985. </year>
Reference-contexts: Duality also arises in justifying plans, in analysis by synthesis, and in the plan calculus' synthesis/analysis neutrality goal, eg. Wills' use of cliches that have also been used for interactive synthesis in KBEMACS <ref> [Wat85] </ref>. More practically, recognition/generation plan duality could affect plan representation. Under duality, a single plan representation formalism could be designed for both recognition and generation plans. Given plans could be represented once and used in both roles.
Reference: [Wat88] <author> Richard C. Waters. </author> <title> Program translation via abstraction and reimplementation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(8) </volume> <pages> 1207-1228, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: If j &gt; n Display "found ", i go to quit. Add 1 to i go to outer. * - quit. Display "quit" Stop run. Appendix E Restructuring Requirements and Generic Architecture Control flow restructuring is a weak case of translation by abstraction and reimplementation as described in <ref> [Wat88] </ref>. Typically only the program statements implementing static control flow are analyzed and abstracted, creating a model consisting of basic blocks and abstract control flow. Transformations may involve replacing static control flow paths with control variables and operations on them, and/or replicating basic blocks.
Reference: [Wei80] <author> William E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables, and label variables. </title> <type> Technical Report RC 8060 (#34990), </type> <institution> IBM Thomas J. Watson Research Center, </institution> <year> 1980. </year> <note> See also 7th POPL, 1980. 51 </note>
Reference: [Wei81] <author> Mark Weiser. </author> <title> Program slicing. </title> <booktitle> In 5th Int. Conf. on Software Engineering, </booktitle> <month> March </month> <year> 1981. </year>
Reference-contexts: D-D paths, basic blocks, natural loops, intervals [Pai77]; data flow [Zis75, HB85, LW90]; and combined control flow and data flow, eg. PBM's, slices, and modules <ref> [Wat79, Wei81, Har80] </ref>.
Reference: [Wei82] <author> Mark Weiser. </author> <title> Programmers use slices when debugging. </title> <journal> Communications of the ACM, </journal> <volume> 25(7) </volume> <pages> 446-452, </pages> <month> July </month> <year> 1982. </year>
Reference: [WH90] <author> P.H. Wood and P.D. Holt. </author> <title> Intelligent tutoring systems: An annotated bibliography. </title> <journal> SIGART Bulletin, </journal> <volume> 1(1) </volume> <pages> 21-41, </pages> <month> January/April </month> <year> 1990. </year>
Reference: [Wil87] <author> Linda M Wills. </author> <title> Automated program recognition. </title> <type> Technical Report AI-TR-904, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> February </month> <year> 1987. </year> <title> M.S. </title> <type> Thesis. </type>
Reference-contexts: disadvantages for parsing, transformation, reasoning etc. 9 Figure A.5: Plan Diagram and Attributed Flow Graph for SQ-REST-SIZE Figure A.6: HMODEL for SQ-REST-SIZE Figure A.5 shows a cyclic plan diagram and attributed flow graph representation for SQ-REST-SIZE, which computes the length of the CDR of a list and squares it. 8 <ref> [Wil87] </ref> Figure A.6 shows the HMODEL representation for the same program. There's considerable common ground, but plan diagram data flow differs from HMODEL because it uses object data flow semantics instead named data flow. <p> Control flow is optional, and can be viewed as degenerate data flow that orders without carrying data. In the plan diagram on the left side of Figure A.5, control flow is shown by heavy lines and data flow by light lines. This figure is unchanged from <ref> [Wil87] </ref>, but presumably at least some of the control flow arcs could be eliminated, leaving execution to be described by a data flow activation model of computation. 9 The control flow arc between CDR and 1+, for example, is an unnecessary constraint because these operations are order independent.
Reference: [Wil90] <author> Linda M. Wills. </author> <title> Automated program recognition: A feasibility demonstration. </title> <booktitle> Artificial Intelligence, </booktitle> <pages> 45(1-2), </pages> <month> September </month> <year> 1990. </year>
Reference: [Wol] <author> J. Wolberg. </author> <title> CONVERSION OF COMPUTER SOFTWARE. </title> <publisher> Prentice Hall. </publisher>
Reference: [YR88] <author> Chiung-Chen Yu and Scott P. Robertson. </author> <title> Plan-based representations of Pascal and Fortran code. </title> <booktitle> In CHI88: Conference on Computer Human Interaction, </booktitle> <pages> pages 251-256, </pages> <year> 1988. </year>
Reference: [Zim90] <author> J. A. Zimmer. </author> <title> Restructuring for style. </title> <journal> Software, </journal> <volume> 20 </volume> <pages> 365-389, </pages> <month> April </month> <year> 1990. </year>
Reference: [Zis75] <author> Paul M. Zislis. </author> <title> Semantic decomposition of computer programs: An aid to program testing. </title> <journal> Acta Informatica, </journal> <volume> 4 </volume> <pages> 245-269, </pages> <year> 1975. </year>
Reference-contexts: Then we describe the final HMODEL program representation. 2.3.1 Proper Decomposition Various methods can be used for a priori decomposition, using only control flow, eg. D-D paths, basic blocks, natural loops, intervals [Pai77]; data flow <ref> [Zis75, HB85, LW90] </ref>; and combined control flow and data flow, eg. PBM's, slices, and modules [Wat79, Wei81, Har80].
Reference: [Zve] <author> Nicholas Zvegintzov. </author> <title> Software maintenance news. </title> <journal> Monthly. </journal> <note> Trade publication. </note>
References-found: 195

