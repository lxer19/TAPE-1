URL: http://www.research.digital.com/SRC/tla/cav93.ps.Z
Refering-URL: http://www.research.digital.com/SRC/tla/papers.html
Root-URL: http://www.research.digital.com
Title: Verification of a Multiplier: 64 Bits and Beyond  
Author: R. P. Kurshan Leslie Lamport 
Keyword: Aided Verification  
Note: SUPERSEDES 12 April VERSION To appear in Proceedings of the Fifth International Workshop on Computer  
Address: Murray Hill, NJ 07974  130 Lytton Avenue Palo Alto, CA 94301  
Affiliation: AT&T Bell Labs  Digital Equipment Corporation  
Email: k@research.att.com  lamport@src.dec.com  
Date: 14 April 1993 REVISED  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Martn Abadi and Leslie Lamport. </author> <title> Open systems. </title> <note> To appear in 1993 as a SRC Research Report. </note>
Reference-contexts: To prove (4), we use the following theorem, which is proved in <ref> [1] </ref>. Decomposition Theorem If E is a safety property and, for i = 1; : : : ; n, 1.
Reference: 2. <author> Randal E. Bryant. </author> <title> Graph-based algorithms for Boolean function manipulation. </title> <journal> IEEE Transactions On Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: However, computational complexity limits the applicability of such methods. Verifying a 64-bit multiplier is beyond the capability of existing model checkers, even with indirect methods such as homomorphic reduction [8, 9], structural induction [10], and fixed-point algorithms using binary decision diagrams <ref> [2] </ref>. Mechanical theorem proving provides an alternative to automatic model checking. However, it is hard work. Proving that a system satisfies even a fairly simple property can be painful.
Reference: 3. <author> Shiu-Kai Chin. </author> <title> Verified functions for generating signed-binary arithmetic hardware. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 11(12) </volume> <pages> 1529-1558, </pages> <month> Decem-ber </month> <year> 1992. </year>
Reference-contexts: Mechanical theorem proving provides an alternative to automatic model checking. However, it is hard work. Proving that a system satisfies even a fairly simple property can be painful. Although progress is being made, and there have been some impressive verifications using theorem provers <ref> [3] </ref>, it is unclear how soon theorem proving will be feasible for the routine verification of complicated systems. In any case, complementing a theorem prover with a model checker that, when feasible, verifies proof obligations automatically will surely save work.
Reference: 4. <author> Urban Engberg, Peter Grtnning, and Leslie Lamport. </author> <title> Mechanical verification of concurrent systems with TLA. In Computer-Aided Verification, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> Berlin, Heidelberg, New York, </address> <month> June </month> <year> 1992. </year> <title> Springer-Verlag. </title> <booktitle> Proceedings of the Fourth International Conference, </booktitle> <address> CAV'92. </address>
Reference-contexts: Real multipliers are not constructed by such a simple recursive procedure. However, we expect our approach of combining model checking of local properties with theorem proving to work for real multipliers. We combine two existing tools: the TLP theorem prover <ref> [4] </ref>, which verifies models written in the Temporal Logic of Actions (TLA) [12], and the automata-theoretic model checker COSPAN [5], which verifies models written in the language S/R [6]. We chose to combine TLA and S/R because they are simple and have similar semantic bases.
Reference: 5. <author> Z. Har'El and R. P. Kurshan. </author> <title> Software for analytical development of communication protocols. </title> <journal> AT&T Technical Journal, </journal> <volume> 69(1) </volume> <pages> 44-59, </pages> <year> 1990. </year>
Reference-contexts: However, we expect our approach of combining model checking of local properties with theorem proving to work for real multipliers. We combine two existing tools: the TLP theorem prover [4], which verifies models written in the Temporal Logic of Actions (TLA) [12], and the automata-theoretic model checker COSPAN <ref> [5] </ref>, which verifies models written in the language S/R [6]. We chose to combine TLA and S/R because they are simple and have similar semantic bases. Moreover, a tool exists for the automatic synthesis to hardware of an S/R specification.
Reference: 6. <author> J. Katzenelson and R. P. Kurshan. </author> <title> S/R: A language for specifying protocols and other coordinating processes. </title> <booktitle> In Proceedings of the 5th Annual International Phoenix Conference on Computer Communications, </booktitle> <pages> pages 286-292, </pages> <address> Scottsdale, Arizona, 1986. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: We combine two existing tools: the TLP theorem prover [4], which verifies models written in the Temporal Logic of Actions (TLA) [12], and the automata-theoretic model checker COSPAN [5], which verifies models written in the language S/R <ref> [6] </ref>. We chose to combine TLA and S/R because they are simple and have similar semantic bases. Moreover, a tool exists for the automatic synthesis to hardware of an S/R specification. In principle, we could write the models in either language and translate to the other.
Reference: 7. <author> Israel Koren. </author> <title> Computer Arithmetic Algorithms. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1993. </year>
Reference-contexts: As an example, we verify a k 2 m -bit multiplier, constructed from k-bit multipliers by recursively applying a method for implementing a 2N -bit multiplier with four N -bit multipliers. The k-bit multiplier could implement a complex algorithm such as a radix-4 modified version of Booth's algorithm <ref> [7] </ref>. We could choose k as large as 8. The 8-bit multiplier is small enough to be verified by model checking, but complicated enough to make its verification with theorem proving very difficult. <p> However, since one does not reason about it in TLA, the specification B (k) can be written directly in S/R. If B (k) implements a complex multiplier, such as the radix-4 modified version of Booth's algorithm <ref> [7] </ref>, the COSPAN verification would be straightforward when k = 8. Step (ii), the induction step, is proved with the Decomposition Theorem. We first express the specification B (2N ) as a conjunction of the specification of its components.
Reference: 8. <author> R. P. Kurshan. </author> <title> Reducibility in analysis of coordination. </title> <editor> In P. Varaiya and A.B. Kurzhanski, editors, </editor> <title> Discrete Event Systems: Models and Applications, </title> <booktitle> volume 103 of Lecture Notes in Control and Information Sciences, </booktitle> <pages> pages 19-39, </pages> <address> Berlin, 1987. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: However, computational complexity limits the applicability of such methods. Verifying a 64-bit multiplier is beyond the capability of existing model checkers, even with indirect methods such as homomorphic reduction <ref> [8, 9] </ref>, structural induction [10], and fixed-point algorithms using binary decision diagrams [2]. Mechanical theorem proving provides an alternative to automatic model checking. However, it is hard work. Proving that a system satisfies even a fairly simple property can be painful. <p> The 8-bit multiplier is small enough to be verified by model checking, but complicated enough to make its verification with theorem proving very difficult. For k 2 m equal to 64, the complete multiplier is too complex to be verified entirely by model checking. Abstracting components (homomorphic reduction <ref> [8] </ref>) cannot help, because it cannot reduce the complexity below the size of the combined inputs, which exceeds the limit of tractability for a multiplier. In this simple example, we have verified not just a 64-bit multiplier, but an 8 2 m -bit multiplier for all values of m.
Reference: 9. <author> R. P. Kurshan. </author> <title> Analysis of discrete event coordination. </title> <editor> In J. W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Stepwise Refinement of Distributed Systems, volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 414-453. </pages> <publisher> Springer-Verlag, </publisher> <month> May/June </month> <year> 1989. </year>
Reference-contexts: However, computational complexity limits the applicability of such methods. Verifying a 64-bit multiplier is beyond the capability of existing model checkers, even with indirect methods such as homomorphic reduction <ref> [8, 9] </ref>, structural induction [10], and fixed-point algorithms using binary decision diagrams [2]. Mechanical theorem proving provides an alternative to automatic model checking. However, it is hard work. Proving that a system satisfies even a fairly simple property can be painful.
Reference: 10. <author> R. P. Kurshan and K. McMillan. </author> <title> A structural induction theorem for processes. </title> <booktitle> In Proceedings of the 8th annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 239-247. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: However, computational complexity limits the applicability of such methods. Verifying a 64-bit multiplier is beyond the capability of existing model checkers, even with indirect methods such as homomorphic reduction [8, 9], structural induction <ref> [10] </ref>, and fixed-point algorithms using binary decision diagrams [2]. Mechanical theorem proving provides an alternative to automatic model checking. However, it is hard work. Proving that a system satisfies even a fairly simple property can be painful.
Reference: 11. <author> Leslie Lamport. </author> <title> What good is temporal logic? In R. </title> <editor> E. A. Mason, editor, </editor> <booktitle> Information Processing 83: Proceedings of the IFIP 9th World Congress, </booktitle> <pages> pages 657-668, </pages> <address> Paris, </address> <month> September </month> <year> 1983. </year> <title> IFIP, </title> <publisher> North-Holland. </publisher>
Reference-contexts: In general, E is not expressible with the TLA operators 0 , 2, and 999 999. For example, false is the conjunction of the formulas 2 [false ] x for all variables x, and such an infinite 3 Since TLA formulas are invariant under stuttering <ref> [11] </ref>, the definition of safety that follows would be the same had we defined to satisfy F iff the behavior obtained by repeating the last state of satisfies F . 4 conjunction cannot be expressed in TLA.
Reference: 12. <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <type> Research Report 79, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: However, we expect our approach of combining model checking of local properties with theorem proving to work for real multipliers. We combine two existing tools: the TLP theorem prover [4], which verifies models written in the Temporal Logic of Actions (TLA) <ref> [12] </ref>, and the automata-theoretic model checker COSPAN [5], which verifies models written in the language S/R [6]. We chose to combine TLA and S/R because they are simple and have similar semantic bases. Moreover, a tool exists for the automatic synthesis to hardware of an S/R specification. <p> can write B (k) in TLA and translate it to S/R, this is not necessary because all verification involving B (k) is done with COSPAN, so its TLA version is not needed. 2 Decomposition in TLA We begin with a brief description of TLA; a more complete exposition appears in <ref> [12] </ref>. We assume an infinite collection of variables and a suitably large collection of values. A state is an assignment of values to variables. <p> We also use the TLA operator 999 999, where 999 999 x : F essentially denotes the formula F with x "hidden". The precise definition of 999 999 can be found in <ref> [12] </ref>.
Reference: 13. <editor> Leslie Lamport. Hybrid systems in TLA + . In Hans Rischel and Anders P. Ravn, editors, </editor> <booktitle> Hybrid Systems, Lecture Notes in Computer Science, </booktitle> <address> Berlin, </address> <year> 1993. </year> <title> Springer-Verlag. Proceedings of a Workshop on Hybrid Systems, </title> <note> to appear. </note>
Reference-contexts: This language, which can be translated into S/R, is a subset of a more general specification language under development called TLA + <ref> [13] </ref>. We assume some conventional mathematical notation for numbers and sets.
References-found: 13

