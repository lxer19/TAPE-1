URL: http://www.cs.cornell.edu/Info/People/crary/papers/admiss-cade.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/crary/papers/
Root-URL: 
Title: Admissibility of Fixpoint Induction over Partial Types  
Author: Karl Crary 
Affiliation: Cornell University  
Abstract: Partial types allow the reasoning about partial functions in type theory. The partial functions of main interest are recursively computed functions, which are commonly assigned types using fixpoint induction. However, fixpoint induction is valid only on admissible types. Previous work has shown many types to be admissible, but has not shown any dependent products to be admissible. Disallowing recursion on dependent product types substantially reduces the expressiveness of the logic; for example, it prevents much reasoning about modules, objects and algebras. In this paper I present two new tools, predicate-admissibility and monotonicity, for showing types to be admissible. These tools show a wide class of types to be admissible; in particular, they show many dependent products to be admissible. This alleviates difficulties in applying partial types to theorem proving in practice. I also present a general least upper bound theorem for fixed points with regard to a computational approximation relation, and show an elegant application of the theorem to compactness.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Allen. </author> <title> A non-type-theoretic definition of Martin-Lof's types. </title> <booktitle> In Second IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 215-221, </pages> <address> Ithaca, New York, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: Similarly, the choice of a call-by-name computation system simplifies the formalism, but is also not critical to the results. 3 Since the definition contains negative occurrences of t 1 = t 2 2 T , it is not immediately clear that it is a valid definition. Allen <ref> [1] </ref> and Harper [13] have shown how such a definition may be converted to a conventional inductive definition. f 7! f 0 t 7! t 0 t 7! t 0 case (t; x:e 1 ; x:e 2 ) 7! case (t 0 ; x:e 1 ; x:e 2 ) (x:e)t 7!
Reference: 2. <author> P. Audebaud. </author> <title> Partial objects in the calculus of constructions. </title> <booktitle> In Sixth IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 86-95, </pages> <address> Amsterdam, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: When the user attempted to invoke fixpoint induction, the system would automatically check that the goal was admissible using a set of syntactic rules [16]. Despite their obvious uses in program analysis, partial types have seen little use in theorem proving systems <ref> [8, 4, 2] </ref>. This is due in large part to the fact that too few types have been known to be admissible. Smith, in his doctoral dissertation [24], gave a significant class of admissible types for a Nuprl-like theory, but his class required product types to be non-dependent. <p> Smith, in his doctoral dissertation [24], gave a significant class of admissible types for a Nuprl-like theory, but his class required product types to be non-dependent. The type x:A:B (where x appears free in B) was explicitly excluded. Partial type extensions to Coq <ref> [2] </ref> were just as restrictive, assuming function spaces to be the only type constructor. Excluding dependent products is quite a strong restriction; they are used in encodings of modules [18], objects [21], algebras [17], and even such simple devices as variant records.
Reference: 3. <author> B. Barras, S. Boutin, C. Cornes, J. Courant, J.-C. Filli^atre, E. Gimenez, H. Her-belin, G. Huet, C. Mu~noz, C. Murthy, C. Parent, C. Paulin-Mohring, A. Sabi, and B. Werner. </author> <title> The Coq Proof Assistant Reference Manual. </title> <institution> INRIA-Rocquencourt, CNRS and ENS Lyon, </institution> <year> 1996. </year>
Reference-contexts: Later theorem provers based on constructive type theory, such as Nuprl [5], based on Martin-Lof type theory [19], and Coq <ref> [3] </ref>, based on the Calculus of Constructions [9], faced the opposite problem; they had a natural notion of total functions, but had difficulty dealing with partial functions.
Reference: 4. <author> D. A. Basin. </author> <title> An environment for automated reasoning about partial functions. </title> <booktitle> In Ninth International Conference on Automated Deduction, volume 310 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: When the user attempted to invoke fixpoint induction, the system would automatically check that the goal was admissible using a set of syntactic rules [16]. Despite their obvious uses in program analysis, partial types have seen little use in theorem proving systems <ref> [8, 4, 2] </ref>. This is due in large part to the fact that too few types have been known to be admissible. Smith, in his doctoral dissertation [24], gave a significant class of admissible types for a Nuprl-like theory, but his class required product types to be non-dependent.
Reference: 5. <author> R. Constable, S. Allen, H. Bromley, W. Cleaveland, J. Cremer, R. Harper, D. Howe, T. Knoblock, N. Mendler, P. Panangaden, J. Sasaki, and S. Smith. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Although LCF enjoyed many groundbreaking successes, one problem it faced was that, although it supported a natural notion of partial function, it had difficulty expressing the notion of a total function. Later theorem provers based on constructive type theory, such as Nuprl <ref> [5] </ref>, based on Martin-Lof type theory [19], and Coq [3], based on the Calculus of Constructions [9], faced the opposite problem; they had a natural notion of total functions, but had difficulty dealing with partial functions. <p> Type Theory Syntax 2 The Type Theory The type theory in which I formalize the results of this paper is a variant of the Nuprl type theory <ref> [5] </ref> extended with partial types (that is, types containing possibly divergent objects). This theory is a subset of the type theory of Crary [11] and is similar to Smith's theory [24].
Reference: 6. <author> R. L. Constable and K. Crary. </author> <title> Computational complexity and induction for partial computable functions in type theory. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1997. </year>
Reference-contexts: The major difference between the theory used here and Smith's is that the latter does not provide a notion of equality; the ramifications of handling equality are discussed in Constable and Crary <ref> [6] </ref> and at greater length in Crary [11]. 2.1 Preliminaries As data types, the theory contains natural numbers (denoted by N), disjoint unions (denoted by T 1 + T 2 ), dependent products 1 (denoted by x:T 1 :T 2 ), and dependent function spaces (denoted by x:T 1 :T 2 <p> It would be preferable to deal with admissibility within the logic. A theory with intensional reasoning principles, such as the one proposed in Constable and Crary <ref> [6] </ref>, would allow reasoning about computation internally. Then these results could be proved within the theory and the only extra rule that would be required would be a single rule relating admissibility to the the fixpoint principle.
Reference: 7. <author> R. L. Constable and S. F. Smith. </author> <title> Partial objects in constructive type theory. </title> <booktitle> In Second IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 183-193, </pages> <address> Ithaca, New York, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: The lack of partial functions seriously limited the scope of those theorem provers, because it made them unable to reason about programs in real programming languages where recursion does not always necessarily terminate. This problem was addressed by Constable and Smith <ref> [7] </ref>, who introduced into their type theory the partial type T , which is like a "lifted" version of T . The type T contains all members of T as well as all divergent terms.
Reference: 8. <author> R. L. Constable and S. F. Smith. </author> <title> Computational foundations of basic recursive function theory. </title> <booktitle> In Third IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 360-371, </pages> <address> Edinburgh, Scotland, </address> <month> July </month> <year> 1988. </year>
Reference-contexts: When the user attempted to invoke fixpoint induction, the system would automatically check that the goal was admissible using a set of syntactic rules [16]. Despite their obvious uses in program analysis, partial types have seen little use in theorem proving systems <ref> [8, 4, 2] </ref>. This is due in large part to the fact that too few types have been known to be admissible. Smith, in his doctoral dissertation [24], gave a significant class of admissible types for a Nuprl-like theory, but his class required product types to be non-dependent.
Reference: 9. <author> T. Coquand and G. Huet. </author> <title> The calculus of constructions. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 95-120, </pages> <year> 1988. </year>
Reference-contexts: Later theorem provers based on constructive type theory, such as Nuprl [5], based on Martin-Lof type theory [19], and Coq [3], based on the Calculus of Constructions <ref> [9] </ref>, faced the opposite problem; they had a natural notion of total functions, but had difficulty dealing with partial functions.
Reference: 10. <author> K. Crary. </author> <title> Admissibility of fixpoint induction over partial types. </title> <type> Technical Report TR98-1674, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> Apr. </month> <year> 1998. </year>
Reference-contexts: Concluding remarks appear in Section 5. Most proofs have been omitted in this paper due to space limitations; those proofs appear in the companion technical report <ref> [10] </ref>. <p> Type Definitions Part of the definition (for types other than universes) appears in Figure 3; the full definition appears in the companion technical report <ref> [10] </ref>. <p> Formally, the function f has type T ! T , but fix (f ) 62 T . (The proof of this appears in the companion technical report <ref> [10] </ref>.) Therefore T is not admissible. 3 Computational Lemmas Before presenting my main results in Section 4, I first require some lemmas about the computational behavior of the fixpoint operator.
Reference: 11. <author> K. Crary. </author> <title> Type-Theoretic Methodology for Practical Programming Languages. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <year> 1998. </year> <month> Forthcoming. </month>
Reference-contexts: This theory is a subset of the type theory of Crary <ref> [11] </ref> and is similar to Smith's theory [24]. The major difference between the theory used here and Smith's is that the latter does not provide a notion of equality; the ramifications of handling equality are discussed in Constable and Crary [6] and at greater length in Crary [11]. 2.1 Preliminaries As <p> theory of Crary <ref> [11] </ref> and is similar to Smith's theory [24]. The major difference between the theory used here and Smith's is that the latter does not provide a notion of equality; the ramifications of handling equality are discussed in Constable and Crary [6] and at greater length in Crary [11]. 2.1 Preliminaries As data types, the theory contains natural numbers (denoted by N), disjoint unions (denoted by T 1 + T 2 ), dependent products 1 (denoted by x:T 1 :T 2 ), and dependent function spaces (denoted by x:T 1 :T 2 ).
Reference: 12. <author> M. J. Gordon, A. J. Milner, and C. P. Wadsworth. </author> <title> Edinburgh LCF: A Mechanised Logic of Computation, </title> <booktitle> volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: 1 Introduction One of the earliest logical theorem provers was the LCF system <ref> [12, 20] </ref>, based on the logic of partial computable functions [22, 23]. Although LCF enjoyed many groundbreaking successes, one problem it faced was that, although it supported a natural notion of partial function, it had difficulty expressing the notion of a total function.
Reference: 13. <author> R. Harper. </author> <title> Constructing type systems over an operational semantics. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 14 </volume> <pages> 71-84, </pages> <year> 1992. </year>
Reference-contexts: Allen [1] and Harper <ref> [13] </ref> have shown how such a definition may be converted to a conventional inductive definition. f 7! f 0 t 7! t 0 t 7! t 0 case (t; x:e 1 ; x:e 2 ) 7! case (t 0 ; x:e 1 ; x:e 2 ) (x:e)t 7! e [t=x] i
Reference: 14. <author> W. Howard. </author> <title> The formulas-as-types notion of construction. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, </editor> <booktitle> To H.B. Curry: Essays on Combinatory Logic, Lambda-Calculus and Formalism, </booktitle> <pages> pages 479-490. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: In particular, no universe is a member of itself. Propositions are interpreted as types using the propositions-as-types principle <ref> [14] </ref>, but that is not central to the purposes of this paper. Each type T comes with an intrinsic equality relation denoted by t 1 = t 2 2 T . Membership is also derived from this relation; t 2 T when t = t 2 T .
Reference: 15. <author> D. J. Howe. </author> <title> Equality in lazy computation systems. </title> <booktitle> In Fourth IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1989. </year>
Reference-contexts: The formal definition appears below and is due to Howe <ref> [15] </ref>. <p> The first two follow immediately from the definition, the third uses determinism and the last is proven using Howe's method <ref> [15] </ref>. Proposition 4 and i are reflexive and transitive. If t 7! t 0 then t 0 t and t 0 i t. <p> In that case, predicate-admissibility can be shown with the tools discussed above. Second, T may be an expression that computes a type from x. In this case, T can be simplified using untyped reasoning <ref> [15] </ref>, but another tool will be needed if T performs any case analysis. Lemma 22 Consider a type case (d; x:A; x:B) that depends upon y from S. <p> The result follows directly. ut All type constructors are monotone except universes and partial types, which are never monotone. The proof of this fact is easy <ref> [15] </ref>.
Reference: 16. <author> S. Igarashi. </author> <title> Admissibility of fixed-point induction in first-order logic of typed theories. </title> <type> Technical Report AIM-168, </type> <institution> Computer Science Department, Stanford University, </institution> <month> May </month> <year> 1972. </year>
Reference-contexts: This phenomenon was not unknown to LCF; LCF used the related device of fixpoint induction, which was valid only for admissible predicates. When the user attempted to invoke fixpoint induction, the system would automatically check that the goal was admissible using a set of syntactic rules <ref> [16] </ref>. Despite their obvious uses in program analysis, partial types have seen little use in theorem proving systems [8, 4, 2]. This is due in large part to the fact that too few types have been known to be admissible. <p> The term "predicate-admissibility" stems from its similarity to the notion of admissibility of predicates in domain theory (and LCF), where there has been considerable research (this work was influenced by Igarashi <ref> [16] </ref>, for example), but I will not discuss the connection in this paper. Monotonicity is a simpler condition that will be useful for showing types admissible that do not involve partiality.
Reference: 17. <author> P. B. Jackson. </author> <title> Enhancing the Nuprl Proof Development System and Applying it to Computational Abstract Algebra. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Partial type extensions to Coq [2] were just as restrictive, assuming function spaces to be the only type constructor. Excluding dependent products is quite a strong restriction; they are used in encodings of modules [18], objects [21], algebras <ref> [17] </ref>, and even such simple devices as variant records. <p> Smith [24] showed that any type is admissible provided that it is constructed without using dependent product spaces (i.e., types) or universes. However, prohibiting dependent products is a strong restriction. Dependent products are used in, for example, encodings of modules [18], objects [21], algebras <ref> [17] </ref>, and even such simple devices as variant records. Furthermore, the restriction also disallows reasoning about programs using the closely related principle of fixpoint induction P [?] P [e] ) P [f (e)] which may be encoded with the fixpoint principle [24], but only by using dependent products.
Reference: 18. <author> D. MacQueen. </author> <title> Using dependent types to express modular structure. </title> <booktitle> In Thirteenth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 277-286, </pages> <address> St. Petersburg Beach, Florida, </address> <month> Jan. </month> <year> 1986. </year>
Reference-contexts: The type x:A:B (where x appears free in B) was explicitly excluded. Partial type extensions to Coq [2] were just as restrictive, assuming function spaces to be the only type constructor. Excluding dependent products is quite a strong restriction; they are used in encodings of modules <ref> [18] </ref>, objects [21], algebras [17], and even such simple devices as variant records. <p> Smith [24] showed that any type is admissible provided that it is constructed without using dependent product spaces (i.e., types) or universes. However, prohibiting dependent products is a strong restriction. Dependent products are used in, for example, encodings of modules <ref> [18] </ref>, objects [21], algebras [17], and even such simple devices as variant records.
Reference: 19. <author> P. Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In Sixth International Congress of Logic, Methodology and Philosophy of Science, volume 104 of Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> pages 153-175. </pages> <publisher> North Holland, </publisher> <year> 1982. </year>
Reference-contexts: Although LCF enjoyed many groundbreaking successes, one problem it faced was that, although it supported a natural notion of partial function, it had difficulty expressing the notion of a total function. Later theorem provers based on constructive type theory, such as Nuprl [5], based on Martin-Lof type theory <ref> [19] </ref>, and Coq [3], based on the Calculus of Constructions [9], faced the opposite problem; they had a natural notion of total functions, but had difficulty dealing with partial functions.
Reference: 20. <author> L. C. Paulson. </author> <title> Logic and Computation: Interactive Proof with Cambridge LCF. </title> <publisher> Cambridge University Press, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction One of the earliest logical theorem provers was the LCF system <ref> [12, 20] </ref>, based on the logic of partial computable functions [22, 23]. Although LCF enjoyed many groundbreaking successes, one problem it faced was that, although it supported a natural notion of partial function, it had difficulty expressing the notion of a total function.
Reference: 21. <author> B. C. Pierce and D. N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: The type x:A:B (where x appears free in B) was explicitly excluded. Partial type extensions to Coq [2] were just as restrictive, assuming function spaces to be the only type constructor. Excluding dependent products is quite a strong restriction; they are used in encodings of modules [18], objects <ref> [21] </ref>, algebras [17], and even such simple devices as variant records. <p> Smith [24] showed that any type is admissible provided that it is constructed without using dependent product spaces (i.e., types) or universes. However, prohibiting dependent products is a strong restriction. Dependent products are used in, for example, encodings of modules [18], objects <ref> [21] </ref>, algebras [17], and even such simple devices as variant records. Furthermore, the restriction also disallows reasoning about programs using the closely related principle of fixpoint induction P [?] P [e] ) P [f (e)] which may be encoded with the fixpoint principle [24], but only by using dependent products.
Reference: 22. <author> D. Scott. </author> <title> Outline of a mathematical theory of computation. </title> <booktitle> In Fourth Princeton Conference on Information Sciences and Systems, </booktitle> <pages> pages 169-176, </pages> <year> 1970. </year>
Reference-contexts: 1 Introduction One of the earliest logical theorem provers was the LCF system [12, 20], based on the logic of partial computable functions <ref> [22, 23] </ref>. Although LCF enjoyed many groundbreaking successes, one problem it faced was that, although it supported a natural notion of partial function, it had difficulty expressing the notion of a total function.
Reference: 23. <author> D. Scott. </author> <title> Lattice theoretic models for various type-free calculi. </title> <booktitle> In Fourth International Congress of Logic, Methodology and Philosophy of Science. </booktitle> <publisher> North-Holland, </publisher> <year> 1972. </year>
Reference-contexts: 1 Introduction One of the earliest logical theorem provers was the LCF system [12, 20], based on the logic of partial computable functions <ref> [22, 23] </ref>. Although LCF enjoyed many groundbreaking successes, one problem it faced was that, although it supported a natural notion of partial function, it had difficulty expressing the notion of a total function.
Reference: 24. <author> S. F. Smith. </author> <title> Partial Objects in Type Theory. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <month> Jan. </month> <year> 1989. </year>
Reference-contexts: Despite their obvious uses in program analysis, partial types have seen little use in theorem proving systems [8, 4, 2]. This is due in large part to the fact that too few types have been known to be admissible. Smith, in his doctoral dissertation <ref> [24] </ref>, gave a significant class of admissible types for a Nuprl-like theory, but his class required product types to be non-dependent. The type x:A:B (where x appears free in B) was explicitly excluded. <p> This theory is a subset of the type theory of Crary [11] and is similar to Smith's theory <ref> [24] </ref>. <p> I shall informally say that a type is admissible if the fixpoint principle is valid for that type and give a formal definition in Section 4. To make maximum use of a partial type theory, one wants as large a class of admissible types as possible. Smith <ref> [24] </ref> showed that any type is admissible provided that it is constructed without using dependent product spaces (i.e., types) or universes. However, prohibiting dependent products is a strong restriction. <p> Furthermore, the restriction also disallows reasoning about programs using the closely related principle of fixpoint induction P [?] P [e] ) P [f (e)] which may be encoded with the fixpoint principle <ref> [24] </ref>, but only by using dependent products. In Section 4 I will explore two wide classes of admissible types, one derived from a predicate-admissibility condition and another derived from a monotonicity condition. <p> But first, it is worthwhile to note that there are indeed inadmissible types: Theorem 2 There exist inadmissible types. Proof. This example is due to Smith <ref> [24] </ref>. Let T be the type of functions that do not halt for all inputs, and let f be the function that halts on zero, and on any other n immediately recurses with n 1.
References-found: 24

