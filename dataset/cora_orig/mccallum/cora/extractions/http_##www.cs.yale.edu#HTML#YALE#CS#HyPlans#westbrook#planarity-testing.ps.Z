URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/westbrook/planarity-testing.ps.Z
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/westbrook/
Root-URL: http://www.cs.yale.edu
Title: Fast Incremental Planarity Testing  
Author: Jeffery Westbrook 
Date: March 30, 1992  
Abstract: The incremental planarity testing problem is to perform the following operations on a biconnected planar graph G of at most n vertices: test if an edge can be added between two vertices while preserving planarity; add edges and vertices that preserve planarity. Let m be the total number of operations. We present fast data structures for this problem that can be used in conjunction with the previous algorithm of Di Battista and Tamassia to achieve an O(ff(m; n)) worst-case amortized time per test operation. If the graph is bicon-nected, a sequence of n additions can be performed in total time O(mff(m; n)) worst-case plus O(n) expected time. Our tree data structure is flexible and can answer in O(1) time queries about parents, roots, and nearest common ancestors while performing tree modifications such as inserting nodes, cutting edges, and merging or splitting nodes. If the graph is not biconnected then insertions of edges and vertices require O(log n) amortized expected time per operation. The study of graph planarity has a long and rich history. The off-line planarity testing problem, in which one must test if a given graph is planar, has been studied since the nineteen-sixties. If can be solved in O(n) sequential time [3, 12] and O(log n) time on a CRCW PRAM [17]. Recently Di Battista and Tamassia introduced and studied the incremental planarity testing problem [1, 2]: beginning with a biconnected graph G process on-line an intermingled sequence of the following query and update operations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. D. Battista and R. Tamassia. </author> <title> Incremental planarity testing. </title> <booktitle> In Proc. 30th IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 436-441, </pages> <year> 1989. </year>
Reference-contexts: In this case, these two children are merged into one by equating the poles of the respective graphs. After phase 3, vertices u and v are incident on a common face of some triconnected graph and the edge is inserted. Figure 4 shows an example. Lemma 2.1 <ref> [1] </ref> The total number of transformation steps over any sequence is O (n). There are O (n) marks made. To implement the test and update algorithms we need two fast data structures. The first supports the following operations on fixed embeddings. <p> An initial set of representatives can be chosen in O (n) time using an st-numbering algorithm (see <ref> [1] </ref>). By inductions we can show that properties i and ii can be maintained throughout any sequence of modification operations.
Reference: [2] <author> G. D. Battista and R. Tamassia. </author> <title> On-line graph algorithms with SPQR-trees. </title> <booktitle> In Proc. 17th ICALP, </booktitle> <year> 1990. </year>
Reference-contexts: The structure utilizes the micro-set approach of Gabow and Tar-jan [8] but is based on a different tree representation. We note that several groups of researchers have developed fast data structures for maintaining 3-edge-connected and 3-vertex connected component tree decompositions <ref> [2, 14, 16] </ref>, but they did not give algorithms to find nearest common ancestors. <p> If ! = - then ! - = -; similarly for . 2 The Test and Update Algorithms We sketch the algorithms because they differ somewhat from those of <ref> [2] </ref>. The test algorithm essentially determines whether in each component on the tree path the locations of u and v can be placed on a common face. This is always true for R and S nodes but depends on the embedding of the R nodes. <p> In this case one must use auxiliary decompositions of the graph into 1 and 2-connected components. Edges can always be inserted between different components. To handle test queries between vertices in distinct blocks, a second test algorithm is applied to the 2-connected decomposition tree. This algorithm is described in <ref> [2] </ref> and can be implemented in O (1) time using our tree data structure. When two 1-connected or two connected components are combined into one, the data structures for the smaller one are rebuilt from scratch and inserted into those of the larger.
Reference: [3] <author> K. Booth and G. Lueker. </author> <title> Testing for the consecutive ones property, interval graphs, and graph planarity using PQ-tree algorithms. </title> <journal> J. Comput. System Sci., </journal> <volume> 13 </volume> <pages> 335-379, </pages> <year> 1976. </year>
Reference: [4] <author> P. F. Deitz and D. D. Sleator. </author> <title> Two algorithms for maintaining order in a list. </title> <booktitle> In Proc. 19th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 365-372, </pages> <year> 1987. </year>
Reference-contexts: We assume that the relative order of two blocks can determined in O (1) time. This can be achieved by implementing the algorithm of Sleator and Deitz for maintaining order in a list <ref> [4] </ref> on top of our block partition. Together with an appropriate micro-memory table, this allows us to compute in O (1) whether one node is an ancestor of another. We now describe the basic algorithm for computing nca (u; v) when neither is an ancestor of the other.
Reference: [5] <author> M. Dietzfelbinger, A. Karlin, K. Mehlhorn, F. M. auf der Heide, H. Rohnert, and R. E. Tarjan. </author> <title> Dynamic perfect hashing: upper and lower bounds. </title> <booktitle> In Proceedings 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 524-531, </pages> <year> 1988. </year>
Reference-contexts: The labels on split-find sets are managed with a standard fast union-find data structure [18]. When two faces are merged the sets of labels on split-find sets on that faces are unioned. The set W of representative pairs is stored in a dynamic perfect hash table <ref> [5] </ref>. Representative pair lookups can be done in worst-case constant time. Insertions and deletions into the perfect hash table can be done in O (1) amortized expected time. The split-find operations have cost O (1).
Reference: [6] <author> M. L. Fredman and M. E. Saks. </author> <title> The cell probe complexity of dynamic data structures. </title> <booktitle> In Proc. 21st ACM Symposium on Theory of Computing, </booktitle> <pages> pages 345-354, </pages> <address> Seattle, WA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: It is straightforward to reduce the union-find problem to the problem of maintaining 3-connected components, and lower bounds of (mff (m; n)) are known for the union-find problem in both pointer machine [15] and cell probe model <ref> [6] </ref>. Hence a time bound of O (mff (m; n)) is the best possible for any algorithm that maintains a decomposition of the 3-connected components of the graph. split pairs. (b) Decomposition of graph G into 3-connected components.
Reference: [7] <author> H. N. Gabow. </author> <title> Data structures for weighted matching and nearest common ancestors with linking. </title> <booktitle> In Proc. 1st ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 434 443, </pages> <year> 1990. </year>
Reference-contexts: A splitting of a block may cause a demotion of a single label. A parent merge results in a merge in the label tree when the merged nodes are both labels. We use an extension of the data structure designed by Gabow <ref> [7] </ref> to perform nearest common ancestors with leaf insertions only. The critical ideas are use of a compressed version of the original tree. and the use of a "fat preorder number". The idea of a compressed tree comes from [10]. <p> We can extract ca (x; y) information in T from ca (x; y) information in C (T ), using the fact that the nearest common ancestor of two nodes x,y on the same heavy path is simply whichever is nearer the apex. Fat preorder numbers were invented by Gabow <ref> [7] </ref>. Let U be any tree in which for each vertex v with parent u, fis (v) s (u) for some constant fi &gt; 1. Let c and e be positive integers that satisfy c fi e + 2. <p> Given the fat preorder numbers and the ancestor tables, a ca (x; y) query can be answered in O (1) time <ref> [7] </ref>. By using the fat preorder scheme on C (T ) we can compute characteristic ancestors in T . In Gabow's original scheme, a node v is recompressed and reassigned a new subinterval of its parent interval time its size increases by a factor of ff because of leaf additions.
Reference: [8] <author> H. N. Gabow and R. E. Tarjan. </author> <title> A linear-time algorithm for a special case of disjoint set union. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 30 </volume> <pages> 209-211, </pages> <year> 1985. </year>
Reference-contexts: The structure utilizes the micro-set approach of Gabow and Tar-jan <ref> [8] </ref> but is based on a different tree representation. We note that several groups of researchers have developed fast data structures for maintaining 3-edge-connected and 3-vertex connected component tree decompositions [2, 14, 16], but they did not give algorithms to find nearest common ancestors. <p> Operation pmerge (v) is done by removing ( v and ) v from the string. To perform fast parent and findmark queries, we appropriate the microset techniques used by Gabow and Tarjan <ref> [8] </ref> and Imai and Asano [13] to solve the split-insert-find list maintenance problem. The string is partitioned into blocks of consecutive paren symbols. Each block contains between b c and and 2b c symbols, where b = log log n and c will be chosen later. <p> The parens within each level-1 block are stored in a machine word (assumed to have size (log n) bits) which is treated as a micro-memory. Blocks at higher levels are treated as linked lists. By using appropriate lookup tables and relabeling techniques, we can achieve the following. (See <ref> [8, 13] </ref> for more information.) Lemma 4.1 A sequence of m parent (v), find mark (v), add leaf (u; v), demote (u; v), mark (v), and pmerge (v) operations can be performed in time O (m + n) and space O (n).
Reference: [9] <author> F. Harary. </author> <title> Graph Theory. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA., </address> <year> 1972. </year>
Reference-contexts: Dashed lines represent virtual edges; each is labeled by the split that produced it. 1 The Decomposition Tree If a planar graph is 3-connected it has a unique embedding <ref> [9] </ref> and on-line testing reduces to testing whether an edge can be inserted into a fixed embedding. If the graph is not 3-connected then the set of possible embeddings is determined by the 3-connected components of the graph.
Reference: [10] <author> D. Harel and R. E. Tarjan. </author> <title> Fast algorithms for finding nearest common ancestors. </title> <journal> SIAM J. Comput., </journal> <volume> 13(2) </volume> <pages> 338-355, </pages> <year> 1984. </year>
Reference-contexts: The critical ideas are use of a compressed version of the original tree. and the use of a "fat preorder number". The idea of a compressed tree comes from <ref> [10] </ref>. Given T , let s (x) be the number of descendents of x. A child w of v is light if 2s (w) s (v), otherwise heavy. Deleting every edge from a light child to its parent leaves a set of disjoint heavy paths of length at least 1.
Reference: [11] <author> J. Hopcroft and R. E. Tarjan. </author> <title> Dividing a graph into triconnected components. </title> <journal> SIAM J. Comput., </journal> <volume> 2 </volume> <pages> 135-158, </pages> <year> 1973. </year>
Reference-contexts: If the graph is not 3-connected then the set of possible embeddings is determined by the 3-connected components of the graph. We review the decomposition of a 2-connected multigraph G into its 3-connected components as described in <ref> [11] </ref>. Let n be the number of vertices and m the number of edges. For convenience we assume m 3. Let fa; bg be a pair of vertices. <p> To merge G 1 and G 2 means to construct the graph induced by E 1 [ E 2 minus the two virtual edges ha; bi labeled i. The 3-connected components are unique, have total size O (m), and can be constructed in time O (m) <ref> [11] </ref>. Figure 1a gives an example of a planar graph and its 3-connected components. For each 3-connected component create a node of type S, P , or R, depending on whether the split component is a polygon, a multi-bond, or a 3-connected graph, respectively.
Reference: [12] <author> J. Hopcroft and R. E. Tarjan. </author> <title> Efficient planarity testing. </title> <journal> J. ACM, </journal> <volume> 21 </volume> <pages> 549-568, </pages> <year> 1974. </year>
Reference: [13] <author> H. Imai and T. Asano. </author> <title> Dynamic orthogonal segment intersection search. </title> <journal> Journal of Algorithms, </journal> <volume> 8 </volume> <pages> 1-18, </pages> <year> 1987. </year>
Reference-contexts: The ordered list of vertices and edges around a non-exterior face is maintained using a version of the split-insert-find data structure of <ref> [13] </ref>. A similar data structure is described in a subsequent section. This can be used to find information about the name of a face and the location of representatives around the boundary in O (1) time. Edge insertions cause splits and vertex insertions cause inserts. <p> Operation pmerge (v) is done by removing ( v and ) v from the string. To perform fast parent and findmark queries, we appropriate the microset techniques used by Gabow and Tarjan [8] and Imai and Asano <ref> [13] </ref> to solve the split-insert-find list maintenance problem. The string is partitioned into blocks of consecutive paren symbols. Each block contains between b c and and 2b c symbols, where b = log log n and c will be chosen later. Call these the level-1 blocks. <p> The parens within each level-1 block are stored in a machine word (assumed to have size (log n) bits) which is treated as a micro-memory. Blocks at higher levels are treated as linked lists. By using appropriate lookup tables and relabeling techniques, we can achieve the following. (See <ref> [8, 13] </ref> for more information.) Lemma 4.1 A sequence of m parent (v), find mark (v), add leaf (u; v), demote (u; v), mark (v), and pmerge (v) operations can be performed in time O (m + n) and space O (n).
Reference: [14] <author> G. F. Italiano and Z. Galil. </author> <title> Fully dynamic algorithms for edge connectivity problems. </title> <booktitle> In 23rd ACM Symp. on Theoretical Computer Science, </booktitle> <pages> pages 317-327, </pages> <year> 1991. </year>
Reference-contexts: The structure utilizes the micro-set approach of Gabow and Tar-jan [8] but is based on a different tree representation. We note that several groups of researchers have developed fast data structures for maintaining 3-edge-connected and 3-vertex connected component tree decompositions <ref> [2, 14, 16] </ref>, but they did not give algorithms to find nearest common ancestors.
Reference: [15] <author> J. A. La Poutre. </author> <title> Lower bounds for the union-find and split-find problems on pointer machines. </title> <booktitle> In Proc. 22nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 34-44, </pages> <year> 1990. </year>
Reference-contexts: It is straightforward to reduce the union-find problem to the problem of maintaining 3-connected components, and lower bounds of (mff (m; n)) are known for the union-find problem in both pointer machine <ref> [15] </ref> and cell probe model [6]. Hence a time bound of O (mff (m; n)) is the best possible for any algorithm that maintains a decomposition of the 3-connected components of the graph. split pairs. (b) Decomposition of graph G into 3-connected components.
Reference: [16] <author> J. A. L. Poutre. </author> <title> Dynamic Graph Algorithms and Data Structures. </title> <type> PhD thesis, </type> <institution> Uni versity of Utrecht, Netherlands, </institution> <year> 1991. </year>
Reference-contexts: The structure utilizes the micro-set approach of Gabow and Tar-jan [8] but is based on a different tree representation. We note that several groups of researchers have developed fast data structures for maintaining 3-edge-connected and 3-vertex connected component tree decompositions <ref> [2, 14, 16] </ref>, but they did not give algorithms to find nearest common ancestors.
Reference: [17] <author> V. Ramachandran and J. H. Reif. </author> <title> An optimal parallel algorithm for graph planarity. </title> <booktitle> In Proc. 30th Symposium on Foundations of Computer Science, </booktitle> <pages> pages 282-287, </pages> <year> 1989. </year>
Reference: [18] <author> R. E. Tarjan. </author> <title> Efficiency of a good but not linear set union algorithm. </title> <journal> J. ACM, </journal> <volume> 22 </volume> <pages> 215-225, </pages> <year> 1975. </year>
Reference-contexts: The function ff (m; n) is the functional inverse of Ackermann's function, and is less than 4 for any practical value of n (see <ref> [18] </ref>). Di Battista and Tamassia extended their results to include update operations that allow the construction of general 1 and 0-connected graphs, with the time bounds of O (log n) per operation. <p> Edge insertions cause splits and vertex insertions cause inserts. To handle merging of faces we add a level of indirection between the labels on split-find sets and actual face labels. The labels on split-find sets are managed with a standard fast union-find data structure <ref> [18] </ref>. When two faces are merged the sets of labels on split-find sets on that faces are unioned. The set W of representative pairs is stored in a dynamic perfect hash table [5]. Representative pair lookups can be done in worst-case constant time.
References-found: 18

