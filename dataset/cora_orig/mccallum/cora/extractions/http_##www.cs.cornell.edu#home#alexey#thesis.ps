URL: http://www.cs.cornell.edu/home/alexey/thesis.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/alexey/alexey.html
Root-URL: http://www.cs.cornell.edu
Title: BUILDING RELIABLE INTEROPERABLE DISTRIBUTED OBJECTS WITH THE MAESTRO TOOLS  
Degree: A Dissertation Presented to the Faculty of the Graduate School  in Partial Fulfillment of the Requirements for the Degree of Doctor of Philosophy by Alexey Vaysburd  
Date: May 1998  
Affiliation: of Cornell University  
Abstract-found: 0
Intro-found: 1
Reference: [ADMSM94] <author> Y. Amir, D. Dolev, P. M. Melliar-Smith, and L. E. Moser. </author> <title> Robust and Efficient Replication Using Group Communication. </title> <type> Technical Report CS94-20, </type> <institution> Institute of Computer Science, the Hebrew University of Jerusalem, Jerusalem, Israel, </institution> <year> 1994. </year>
Reference: [Ami95] <author> Y. Amir. </author> <title> Replication Using Group Communication Over a Partitioned Network. </title> <type> Ph.D. dissertation, </type> <institution> Institute of Computer Science, the Hebrew University of Jerusalem, </institution> <year> 1995. </year>
Reference-contexts: However, sometimes the effects of delivering a message cannot be meaningfully reversed, especially when they include externally observable actions triggered by the message. The applications in which state rollback is undesirable or simply not acceptable can run over the globally safe delivery layer <ref> [Ami95] </ref>, which delays delivery of messages until they become acknowledged by a majority of group members and thus are guaranteed to never have to be rolled back in any partitioning/remerging scenario.
Reference: [AMMS + 93] <author> Y. Amir, L. E. Moser, P. M. Melliar-Smith, D.A. Agarwal, and P. Ciarfella. </author> <title> Fast Message Ordering and Membership Using a Logical Token-Passing Ring. </title> <booktitle> In Proc. of the 13th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 551-560, </pages> <month> May </month> <year> 1993. </year>
Reference: [BDGS95] <author> O. Babaoglu, R. Davoli, L. Giachini, and P. Sabattini. </author> <title> The Inherent Cost of Strong-Partial View-Synchronous Communication. </title> <type> Technical Report UBLCS-95-11, </type> <institution> Department of Computer Science, University of Bologna, </institution> <month> April </month> <year> 1995. </year>
Reference: [Bir96] <author> K. P. Birman. </author> <title> Building Secure and Reliable Network Applications. </title> <publisher> Manning Publishing Company and Prentice Hall, </publisher> <month> December </month> <year> 1996. </year>
Reference-contexts: Maestro, in turn, is responsible for the mechanism of state transfer (the state transfer protocol itself), which can be implemented in several ways. In Isis <ref> [Bir96] </ref>, for example, one of the old group members (usually the coordinator) sends the state to new members. This is called the push approach. <p> This scheme can be optimized with a protocol where the new server is responsible for requesting the state from more up-to-date members and notifying the coordinator when state transfer has completed (the pull approach <ref> [Bir96] </ref>). With either push or pull mechanisms used in a state transfer protocol, there is a number of options for structuring the protocol itself, including the behavior of the application during state transfer and the contents of the state. As discussed in [Bir96], the contents and structure of the state is <p> when state transfer has completed (the pull approach <ref> [Bir96] </ref>). With either push or pull mechanisms used in a state transfer protocol, there is a number of options for structuring the protocol itself, including the behavior of the application during state transfer and the contents of the state. As discussed in [Bir96], the contents and structure of the state is usually application-specific, and the size of the state can vary from rather small to very large. The availability requirements on the application can be high or moderate. <p> specified message and merge it with its local state. 22 they exchange their states using getState ()/sendState () downcalls of Maestro While an application can use the provided downcalls (askState () and sendState ()) to perform state transfer via the standard group transport, it is also feasible (and recommended in <ref> [Bir96] </ref> for a certain type of applications) to use an out-of-band channel so as not to interfere with the normal ongoing communication in the group. <p> Other request managers might employ different techniques or replication paradigms, such as the coordinator-cohort execution style <ref> [Bir96] </ref>. Maestro interoperability tools include an implementation of IIOP Bridge and a framework for building customized Object Request Brokers [OMG97]. <p> In terms of interfaces, Elec-tra has added certain proprietary extensions to object-adaptor interfaces in order to provide functionality specific to group communication, namely methods for state transfer and membership-change notifications <ref> [Bir96] </ref>, which can be overloaded by object implementations if necessary. Two other reliable CORBA ORB implementations based on Isis are RDO/C++ [Isi94] and Orbix+Isis [LM97,II94]. Similarly to Electra, they map replicated objects to Isis groups, and provide group-communication-specific extensions to CORBA interfaces. <p> Naive implementations with cascading replicated invocations of objects could result in substantial performance degradation and inconsistent state. However, Maestro could handle cascading-replicated-invocations scenarios by using an appropriate ORB "communication style", for example one based on the coordinator-cohort paradigm <ref> [Bir96] </ref>. <p> As we have seen, in order to provide fault-tolerance based on an active replication execution style, CORBA interfaces need to be augmented with non-standard extensions encapsulating at least state transfer and membership-change-notification functionality. Other programming styles, such as group communication or publish/subscribe paradigms <ref> [Bir96] </ref>, can only be expressed in CORBA by resorting to alternative interfaces implemented as CORBA services, which remain proprietary until formally standardized by OMG. Transparency is another concern. <p> This ORB sends the reply message back to the client (7). Observe that when requests are relayed with totally ordered multicasts, they are delivered to all objects in the same order, so that all object replicas perform the same sequence of operations (the active replication model <ref> [Bir96] </ref>). The architecture of the Replicated Updates ORB scales well in the number of objects residing within a process, since all objects bound to an ORB instance are 48 multiplexed over a single Ensemble (or Horus) group. This effectively provides light-weight group semantics for free. <p> The Dynamic Sequencer total ordering layer, used in the Horus protocol stack underneath Maestro, works best with precisely this one-sender communication pattern: The active sender becomes the sequencer and can multicast totally 61 ordered messages immediately, without any delays or additional communication rounds <ref> [Bir96] </ref>. In particular, the latency of local message delivery is minimal and depends mostly on internal processing costs within Horus layers. Also, the combination of the Dynamic Sequencer protocol and one-sender communication pattern scales extremely well. <p> In the following sections we will describe an implementation of replicated state machines within the quorum-based virtual synchrony <ref> [Bir96] </ref> protocol framework, which happens to be the only technology that provides both high availability and global consistency properties [Bir96] (observe that transactions offer the latter but not the former property). <p> In the following sections we will describe an implementation of replicated state machines within the quorum-based virtual synchrony <ref> [Bir96] </ref> protocol framework, which happens to be the only technology that provides both high availability and global consistency properties [Bir96] (observe that transactions offer the latter but not the former property). To put virtual-synchrony-based state machine replication in the proper context, it is useful to compare and contrast it with classic distributed-commit protocols, which play a similar role of fundamental building blocks in the field of distributed transaction systems. <p> To put virtual-synchrony-based state machine replication in the proper context, it is useful to compare and contrast it with classic distributed-commit protocols, which play a similar role of fundamental building blocks in the field of distributed transaction systems. The most widely used protocol there is the Two Phase Commit <ref> [Bir96] </ref>. The protocol proceeds in two phases. In the first phase, the coordinator of the transaction solicits votes ("OK to commit?") from participating members and waits for their replies. <p> An alternative approach, called dynamic voting, computes the quorum as a majority of members in the immediately preceding primary view, rather than a majority of the whole group <ref> [Bir96] </ref>. With a dynamic-voting-based quorum, it can be easier to form a primary view, since a majority of the previous primary view may be smaller than a majority of the entire group.
Reference: [BJ87a] <author> K. Birman and T. Joseph. </author> <title> Exploiting Virtual Synchrony in Distributed Systems. </title> <booktitle> In Proc. of the 11th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 123-138, </pages> <month> December </month> <year> 1987. </year>
Reference: [BJ87b] <author> K. Birman and T. Joseph. </author> <title> Reliable Communication in the Presence of Failures. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(1) </volume> <pages> 47-76, </pages> <month> February </month> <year> 1987. </year>
Reference-contexts: The first software-based implementation of state machine replication in an asynchronous distributed environment was provided in the Isis system <ref> [BJ87b] </ref>, which has pioneered the virtual synchrony model within which both high availability and global consistency of replicated objects could be achieved.
Reference: [Cla98] <author> Tim Clark. </author> <title> Private communication, </title> <month> April </month> <year> 1998. </year>
Reference-contexts: We have measured a lower throughput with Ensemble than with Horus, apparently because the total ordering protocol used in Ensemble has not yet been optimized to minimize the latency of local delivery of messages <ref> [Cla98] </ref>.
Reference: [CT93] <author> T. Chandra and S. Toueg. </author> <title> Unreliable Failure Detectors for Asynchronous Systems. </title> <journal> Journal of the ACM, 1993. </journal> <volume> 96 97 </volume>
Reference-contexts: Detection of Unfair Links: A group member that doesn't crash will eventually report with a suspect () downcall any member of its view for which the link between the two members is unfair. These two properties are so called completeness properties (in terminology of <ref> [CT93] </ref>), since they only specify in which cases an object must be reported as faulty, but do not set any bounds on accuracy of failure detection. <p> It is thus inherent in the partitionable membership model that multiple concurrent views of the same group can simultaneously exist in the system (Figure 4.5). Since failure detection is realistically assumed to be unreliable <ref> [CT93] </ref> and it is often not possible to distinguish crash failures from link failures or network partitions (which all manifest themselves as performance failures), a group component cannot automatically determine whether it is the only active view in the system or whether other group members are currently operational but just happen <p> Observe that stability of views directly depends on accuracy of failure detection. In an asynchronous system, typical timeout-based failure detectors are inherently inaccurate. However, the impossibility result of [FLP85] can be rendered irrelevant by strengthening the system model <ref> [CT93] </ref>. This is indeed usually done in practice, since even though group protocols themselves are asynchronous, the failure detection (a mechanism orthogonal to protocols themselves) is often based on specific timing assumptions and its accuracy is quite predictable.
Reference: [FB96] <author> R. Friedman and K. Birman. </author> <title> Using Group Communication Technology to Develop a Reliable and Scalable Distributed IN Coprocessor. </title> <booktitle> In Proc. of the TINA 96 Conference, </booktitle> <pages> pages 25-41, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: An example of a successful use of state machine replication in such a setting is described in <ref> [FB96] </ref>. In conclusion, we want to put our implementation of partition-tolerant replicated state machines in the perspective of the famous distributed-consensus-impossibility result of [FLP85]. As shown in [FLP85], a protocol that implements distributed consensus in an asynchronous system may not guarantee termination if crash failures are possible.
Reference: [FGS98] <author> P. Felber, R. Guerraoui, and A. Schiper. </author> <title> The Implementation of a CORBA Object Group Service. </title> <journal> Theory and Practice of Object Systems, </journal> <volume> Vol. </volume> <month> 4(2) </month> <year> 1998. </year>
Reference-contexts: Note that although replication is transparent to the ORB itself, object implementations still need to be modified to implement state transfer functionality. Also, like Electra, Eternal requires that both server and client sides of the application link with the Eternal/Totem library. The Object Group Service (OGS) approach <ref> [FGS98] </ref> extends CORBA with a collection of reliability services which implement object multicast, failure detection, and other object-group functionality. The advantage of OGS is that it is CORBA-compliant and can be ported to any compatible ORB without modifications.
Reference: [FLP85] <author> M. Fischer, N. Lynch, and M. Patterson. </author> <title> Impossibility of Distributed Consensus with One Faulty Process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: An example of a successful use of state machine replication in such a setting is described in [FB96]. In conclusion, we want to put our implementation of partition-tolerant replicated state machines in the perspective of the famous distributed-consensus-impossibility result of <ref> [FLP85] </ref>. As shown in [FLP85], a protocol that implements distributed consensus in an asynchronous system may not guarantee termination if crash failures are possible. <p> An example of a successful use of state machine replication in such a setting is described in [FB96]. In conclusion, we want to put our implementation of partition-tolerant replicated state machines in the perspective of the famous distributed-consensus-impossibility result of <ref> [FLP85] </ref>. As shown in [FLP85], a protocol that implements distributed consensus in an asynchronous system may not guarantee termination if crash failures are possible. <p> Observe that stability of views directly depends on accuracy of failure detection. In an asynchronous system, typical timeout-based failure detectors are inherently inaccurate. However, the impossibility result of <ref> [FLP85] </ref> can be rendered irrelevant by strengthening the system model [CT93]. This is indeed usually done in practice, since even though group protocols themselves are asynchronous, the failure detection (a mechanism orthogonal to protocols themselves) is often based on specific timing assumptions and its accuracy is quite predictable.
Reference: [FV97] <author> R. Friedman and A. Vaysburd. </author> <title> Fast Replicated State Machines Over Partitionable Networks. </title> <booktitle> In Proc. of the IEEE 16th International Symposium on Reliable Distributed Systems, </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: Our solution, presented in this chapter, uses a different method for 70 computing quorum and can tolerate group partitions <ref> [FV97] </ref>. In particular, even if the quorum is lost, it will be automatically restored when a majority of group members can again communicate and form a view, at which point the system will be able to continue to make progress.
Reference: [FvR95a] <author> R. Friedman and R. van Renesse. </author> <title> Packing Messages as a Tool for Boosting the Performance of Total Ordering Protocols. </title> <type> Technical Report TR95-1527, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> July </month> <year> 1995. </year> <note> Submitted for publication. </note>
Reference-contexts: During normal execution within a view, the primary views layer does not add any headers on messages and has little overhead for event processing. We have found, however, that the choice of a particular total ordering protocol [AMMS + 93,FvR95a,KTHB89] and the use of message packing techniques <ref> [FvR95a] </ref> play a decisive role in setting the system's performance.
Reference: [FvR95b] <author> R. Friedman and R. van Renesse. </author> <title> Strong and Weak Virtual Synchrony in Horus. </title> <type> Technical Report TR95-1491, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> March </month> <year> 1995. </year>
Reference: [GR97] <author> K. Guo and L. Rodrigues. </author> <title> Dynamic Light-Weight Groups. </title> <booktitle> In 17th IEEE International Conference on Distributed Computing Systems, </booktitle> <address> p.33-42, Baltimore, Maryland, </address> <month> May </month> <year> 1997. </year>
Reference: [Hay97] <author> Mark Hayden. </author> <title> The Ensemble System. </title> <type> Ph.D. dissertation, </type> <institution> Department of Computer Science, Cornell University, Forthcoming, </institution> <month> Dec. </month> <year> 1997. </year>
Reference-contexts: It separated CORBA-specific abstractions (the ORB and the Basic Object Adaptor) from the communication substrate, which could be any group-communication system exporting a common interface. Electra was initially based on Isis and subsequently ported to run over the Horus [vRBM96] and Ensemble <ref> [Hay97] </ref> systems. With the Isis-based implementation, Electra creates a group per replicated object. Client objects join the group as Isis clients, and server objects (object implementations) join as Isis group members. <p> The protocols described in this chapter have been implemented within the Ho-rus group communication system [vRBM96]. However, their properties and implementation are quite generic and can be easily ported to other systems, such as Ensemble <ref> [Hay97] </ref>. In summary, the trademarks of our implementation of state machine replication are tolerance of network partitions (the system will be available whenever a majority of group objects can merge together) and high performance (no message logging is required; messages can often be delivered within one phase).
Reference: [II94] <author> IONA and Isis. </author> <title> An Introduction to Orbix+Isis. </title> <booktitle> IONA Technologies and Isis Distributed Systems, </booktitle> <year> 1994. </year>
Reference: [ION98] <author> IONA. </author> <title> Orbix. </title> <booktitle> IONA Technologies, </booktitle> <address> http://www.iona.com/Products/Orbix/, 1998. </address>
Reference-contexts: Consequently, ORB components provided by different vendors (such as IIOP bridges or object adaptors) are generally not interchangeable. 36 For example, the IIOP bridge of VisiBroker [Vis97] cannot be used with Or-bix <ref> [ION98] </ref> so as to receive IIOP requests and inject them into the ORB. Because of incompatibility of proprietary ORB architectures, it is hard or impossible to replace individual components of ORBs, in particular those responsible for injection of incoming IIOP messages and dispatching of client requests.
Reference: [Isi92] <author> Isis. </author> <title> The Isis Distributed Tolkit Version 3.0, User Reference Manual. Isis Distributed Systems, </title> <publisher> Inc., </publisher> <year> 1992. </year>
Reference-contexts: Isis also provides a collection of tools, including a state transfer tool, logging and spooling tools, the coordinator-cohort 4 5 tool, and other utilities <ref> [Isi92] </ref>. <p> A client can pick a member of the server group and issue RPC calls to it or, alternatively, multi-cast to the entire group. With another group structure implemented in Isis, called diffusion groups, clients do not issue requests but passively receive messages multi-cast by group members <ref> [Isi92] </ref>. One of the most significant differences between Isis and Maestro is that Maestro primarily focuses on the flat group model, where all members or clients/servers are members of the same object group, and does not support built-in scalable clients the way Isis does.
Reference: [Isi94] <author> Isis. </author> <title> Reliable Distributed Objects for C++. User's Guide. Isis Distributed Systems, </title> <publisher> Inc., </publisher> <month> April </month> <year> 1994. </year> <month> 98 </month>
Reference-contexts: Two other reliable CORBA ORB implementations based on Isis are RDO/C++ <ref> [Isi94] </ref> and Orbix+Isis [LM97,II94]. Similarly to Electra, they map replicated objects to Isis groups, and provide group-communication-specific extensions to CORBA interfaces. Both client and server sides of an application need to link with ORB-specific libraries and depend on a number of daemon processes.
Reference: [Kei94] <author> I. Keidar. </author> <title> A Highly Available Paradigm for Consistent Object Replication. </title> <type> Master's thesis, </type> <institution> Institute of Computer Science, the Hebrew University of Jerusalem, </institution> <year> 1994. </year>
Reference-contexts: If a majority of processes in the group crash simultaneously, the protocol will block. Differently from our protocol, the implementation in <ref> [Kei94] </ref> can sustain any number of simultaneous crashes, assuming that failed processes are eventually restarted (this is equivalent to the "no-crashes" assumption). Also, the protocols in [Kei94] can make progress even if a majority view can never be formed due to perpetual partitioning of the network, which makes that approach suitable <p> If a majority of processes in the group crash simultaneously, the protocol will block. Differently from our protocol, the implementation in <ref> [Kei94] </ref> can sustain any number of simultaneous crashes, assuming that failed processes are eventually restarted (this is equivalent to the "no-crashes" assumption). Also, the protocols in [Kei94] can make progress even if a majority view can never be formed due to perpetual partitioning of the network, which makes that approach suitable for WAN environments with very low quality of communication. However, the cost of message logging and extra communication rounds make the solution of [Kei94] impractical for <p> protocols in <ref> [Kei94] </ref> can make progress even if a majority view can never be formed due to perpetual partitioning of the network, which makes that approach suitable for WAN environments with very low quality of communication. However, the cost of message logging and extra communication rounds make the solution of [Kei94] impractical for applications with demanding performance requirements. Those applications will usually be deployed in environments with higher quality of communication links, where a majority of processes can reasonably be expected to be almost always connected. <p> For performance reasons, our protocols do not require that messages be synchronously logged on a stable storage before they can be sent or received. This is in contrast to other approaches, such as <ref> [Kei94] </ref>. The tradeoff of this decision is that when a process crashes, the state of the object (s) residing on it may be lost. <p> One of the reasons of good performance is optimistic ordering of messages within a primary view, even when globally safe delivery is enabled. With our protocol, messages are delivered with fewer communication rounds than, for example, in the more conservative global total ordering protocol of <ref> [Kei94] </ref>. As a tradeoff, optimistically ordered messages may 94 need to be aborted in certain partitioning scenarios, which would never happen in the solution of [Kei94]. <p> With our protocol, messages are delivered with fewer communication rounds than, for example, in the more conservative global total ordering protocol of <ref> [Kei94] </ref>. As a tradeoff, optimistically ordered messages may 94 need to be aborted in certain partitioning scenarios, which would never happen in the solution of [Kei94]. We therefore target our protocols for high-performance applications running in environments where real and virtual (logical) partitions are possible but unlikely and where there is a meaningful way to handle aborted multicast messages.
Reference: [KTHB89] <author> F. Kaashoek, A. Tanenbaum, S. Hummel, and H. Bal. </author> <title> An Efficient Reliable Broadcast Protocol. </title> <journal> Operating Systems Review, </journal> <volume> 23(4) </volume> <pages> 5-19, </pages> <month> October </month> <year> 1989. </year>
Reference: [LM97] <author> S. Landis and S. Maffeis. </author> <title> Building Reliable Distributed Systems with CORBA. In Theory and Practice of Object Systems, </title> <publisher> John Wiley and Sons, </publisher> <year> 1997. </year>
Reference: [Maf95a] <author> Silvano Maffeis. </author> <title> Adding Group Communication and Fault-Tolerance to CORBA. </title> <booktitle> In Proc. of the 1995 USENIX Conference on Object-Oriented Technologies, </booktitle> <address> Monterey, CA, </address> <month> June </month> <year> 1995. </year>
Reference: [Maf95b] <author> Silvano Maffeis. </author> <title> Run-Time Support for Object-Oriented Distributed Programming. </title> <type> Ph.D. dissertation, </type> <institution> University of Zurich, Switzerland, </institution> <year> 1995. </year>
Reference: [Maf96] <author> S. Maffeis. </author> <title> A Fault-Tolerant CORBA Name Server. </title> <booktitle> In Proceedings of the 15th IEEE Symposium on Reliable Distributed Systems, </booktitle> <address> Niagara-on-the-Lake, Canada, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: The elapsed time per request was in the range of 3.6-4.7 msec for Orbix and 3.5-4.7 msec for Maestro with three object replicas, for message sizes in the range of 4-1024 bytes. For comparison, the cost of the bind operation in the CORBA-compliant Electra Naming Service <ref> [Maf96] </ref> with replication degree 3 is 6.6 msec when run over Horus and 14.2 msec over Isis. Performance numbers for the Maestro Replicated Updates ORB running over Ensemble are shown in Figure 3.8.
Reference: [MAMSA94] <author> L. E. Moser, Y. Amir, P. M. Melliar-Smith, and D. A. Agarwal. </author> <title> Extended Virtual Synchrony. </title> <booktitle> In Proc. of the 14 International Conference on distributed Computing Systems, </booktitle> <month> June </month> <year> 1994. </year>
Reference: [MFSW95] <author> C. Malloth, P. Felber, A. Schiper, and U. Wilhelm. </author> <title> Phoenix: A Tollkit for Building Fault-Tolerant Distributed Application in Large Scale. </title> <type> Technical report, </type> <institution> Department d'Informatique, Ecole Polytech-nique Federale de Lausanne, </institution> <month> July </month> <year> 1995. </year>
Reference: [Mic98] <author> Microsoft. </author> <title> Component Object Model. </title> <institution> Microsoft Corporation, </institution> <note> http://www.microsoft.com/activex/, 1998. </note>
Reference-contexts: Grid *grid = new Grid (ops); // Block the main thread forever. Maestro Semaphore sema; sema.dec (); g Chapter 3 Ob ject Interoperability Tools 3.1 Introduction The distributed systems community has shown considerable interest in integrating interoperable object-oriented technologies, such as CORBA [OMG97] and DCOM <ref> [Mic98] </ref>, with technologies for building secure, reliable distributed systems [Bir96,MMSN97, NMMS97b,NMMS97a,VB97,MFSW95,Hay97,Maf95a,Maf95b].
Reference: [MMSA93] <author> L. E. Moser, P. M. Melliar-Smith, and V. Agrawala. </author> <title> Asynchronous Fault-Tolerant Total Ordering Algorithm. </title> <journal> SIAM Journal of Computing, </journal> <volume> 22(4) </volume> <pages> 727-750, </pages> <month> August </month> <year> 1993. </year>
Reference: [MMSA + 95] <author> L. E. Moser, P. M. Melliar-Smith, D. A. Agarwal, R. K. Budhia, C. A. Lingley-Papadopoulos, and T. P. Archambault. </author> <title> The Totem System. </title> <booktitle> In Proc. of the 25th Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 61-66, </pages> <address> Pasadena, CA, </address> <month> June </month> <year> 1995. </year> <month> 99 </month>
Reference: [MMSA + 96] <author> L. Moser, P. M. Melliar-Smith, D. Agarwal, R. Budhia, and C. Lingley-Papadopoulos. Totem: </author> <title> A Fault-Tolerant Multicast Group Communication System. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 54-63, </pages> <month> April </month> <year> 1996. </year>
Reference: [MMSN97] <author> L. E. Moser, P. M. Melliar-Smith, and P. Narasimhan. </author> <title> The Eternal System. </title> <booktitle> In Workshop on Dependable Distributed Object Systems, </booktitle> <address> OOPSLA'97, Atlanta, Georgia, </address> <month> October </month> <year> 1997. </year>
Reference: [MSS96] <author> L. Malhis, W. Sanders, and R. Schlichting. </author> <title> Numerical Performabil-ity Evaluation of a Group Multicast Protocol. Distributed Systems Engineering, Special Issue on Performance Modelling (ed. </title> <editor> Peter G. Harrison), </editor> <volume> vol. 3, no. 1, </volume> <pages> pp. 39-52, </pages> <month> March </month> <year> 1996. </year>
Reference: [NMMS97a] <author> P. Narasimhan, L. E. Moser, and P. M. Melliar-Smith. </author> <title> Exploiting the Internet Inter-ORB Protocol Interface to Provide CORBA with Fault Tolerance. </title> <booktitle> In Third USENIX Conference on Object-Oriented Technologies and Systems, </booktitle> <address> Portland, Oregon, </address> <month> June </month> <year> 1997. </year>
Reference: [NMMS97b] <author> P. Narasimhan, L. E. Moser, and P. M. Melliar-Smith. </author> <title> The Interception Approach to Reliable Distributed CORBA Objects. In Panel on Reliable Distributed Objects, </title> <booktitle> Third USENIX Conference on Object-Oriented Technologies and Systems, </booktitle> <address> Portland, Oregon, </address> <month> June </month> <year> 1997. </year>
Reference: [OMG97] <author> OMG. </author> <title> CORBA/IIOP 2.1 Specification. Object Management Group, </title> <note> http://www.omg.org/corba/corbiiop.htm, 1997. </note>
Reference-contexts: Various protocols for client-to-group communication appropriate for different applications can be built over this mechanism. Besides Isis, the programming model of Maestro has also been influenced by the design of Basic Object Adaptors (BOA) in the CORBA architecture <ref> [OMG97] </ref>. 7 With the BOA model, the application defines a subclass of the pre-generated server skeleton class which provides a default (usually no-op) implementation of the application object's exported interface. The interface methods are invoked as callbacks when the object receives requests coming from clients. <p> Grid *grid = new Grid (ops); // Block the main thread forever. Maestro Semaphore sema; sema.dec (); g Chapter 3 Ob ject Interoperability Tools 3.1 Introduction The distributed systems community has shown considerable interest in integrating interoperable object-oriented technologies, such as CORBA <ref> [OMG97] </ref> and DCOM [Mic98], with technologies for building secure, reliable distributed systems [Bir96,MMSN97, NMMS97b,NMMS97a,VB97,MFSW95,Hay97,Maf95a,Maf95b]. <p> Maestro interoperability tools provide such integration mechanisms, which can be used to glue together object-oriented distributed applications with reliable group communication systems (such as Horus or Ensemble [vRBM96,Hay97]) while maintaining application component interoperability through the use of a standard communication protocol (IIOP <ref> [OMG97] </ref>). The Maestro tools can be used directly to implement reliable interoperable objects in distributed applications, or they can be integrated within higher-level distributed object technologies such as CORBA Object Request Brokers. The ORB implements an infrastructure gluing together a client application accessing an object with the object implementation. <p> Other request managers might employ different techniques or replication paradigms, such as the coordinator-cohort execution style [Bir96]. Maestro interoperability tools include an implementation of IIOP Bridge and a framework for building customized Object Request Brokers <ref> [OMG97] </ref>. The ORBs 32 included with Maestro are a reliable Replicated Updates ORB (with object implementations actively replicated over a group communication system underneath), and a Simple ORB with no reliability mechanisms provided. <p> In particular, large corporate system developers are sometimes weary of depending upon proprietary interfaces provided by commercial vendors' tools and prefer to rely on industry standards. This explains, to some extent, why CORBA <ref> [OMG97] </ref> specifications have been concerned mostly with application-level interfaces, with protocol-level IIOP specifications having been added relatively recently. Adding reliability to CORBA ORBs has been an active area of research. We believe the first CORBA-compliant reliable ORB was Electra [Maf95a,Maf95b].
Reference: [RGS + 96] <author> L. Rodrigues, K. Guo, A. Sargento, R. van Renesse, B. Glade, P. Verisimo, and K. Birman. </author> <title> A Transparent Light-Weight Group Service. </title> <booktitle> In 15th IEEE Symposium on Reliable Distributed Systems, </booktitle> <address> p.130-139, Niagara-on-the-Lake, Canada, </address> <month> October </month> <year> 1996. </year>
Reference: [Sch84] <author> Fred B. Schneider. </author> <title> Byzantine Generals in Action: Implementing Fail-Stop Processors. </title> <journal> ACM Transactions on Computer Systems 2:2, </journal> <volume> pp.145-154, </volume> <month> May </month> <year> 1984. </year>
Reference-contexts: The Three Phase Commit Protocol [Ske85] was designed to provide higher availability and, in particular, to tolerate crash failures during execution of the protocol. However, despite the increased performance cost due to the added "prepare-to-commit" phase, the Three Phase Commit protocol assumes an idealized fail-stop failure model <ref> [Sch84] </ref> (where participants fail by crashing and failure detection is immediate and perfectly accurate) and may block in a real setting due to network partitions or inaccurate failure detection (see Figure 4.2).
Reference: [Sch86] <author> Fred B. Schneider. </author> <title> The state machine approach: a tutorial. </title> <type> Technical Report TR 86-800, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> December </month> <year> 1986. </year> <note> Revised June 1987. </note>
Reference-contexts: Maestro group tools, however, rely on the group communication system underneath to provide necessary system membership and message delivery properties within a coherent programming model. In this chapter we will discuss one such model, called state machine replication <ref> [Sch86] </ref>, which plays the role of a fundamental building block in design of reliable/highly available distributed applications with strong consistency requirements on membership and communication. <p> In the following sections we will describe the state machine replication model in detail and present its virtual-synchrony-based implementation for the most general setting, namely a partitionable network environment with inaccurate failure detection, with excellent performance characteristics. 4.2 Background and Related Work The replicated state machine model proposed in <ref> [Sch86] </ref> defines consistent behavior of a collection of distributed objects. With this model, the objects run identical state machines and perform the same sequence of operations, thus producing the same sequence of outputs and transitioning through the same sequence of states. <p> Throughout the following discussion, we assume an asynchronous distributed system prone to process crashes, link failures, and network partitions. The system consists of a group of application processes, each running a deterministic state machine <ref> [Sch86] </ref>, and communicating by sending multicast messages to each other. Messages are sent via cast () downcalls in Maestro and delivered via invocation of corresponding callback methods at destination objects.
Reference: [Ske85] <author> D. Skeen. </author> <title> Determining the Last Process to Fail. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 3:1, pp.15-30, </volume> <month> February </month> <year> 1985. </year>
Reference-contexts: However, the two-phase commit is not fault-tolerant and may block even if a single failure, such as the coordinator's crash, occurs during the execution of the protocol 66 67 (see Figure 4.1). The Three Phase Commit Protocol <ref> [Ske85] </ref> was designed to provide higher availability and, in particular, to tolerate crash failures during execution of the protocol.
Reference: [SM87] <author> W. Sanders and J. Meyer. </author> <title> Performability Evaluation of Distributed Systems Using Stochastic Activity Networks. </title> <booktitle> In Proceedings of the 100 International Workshop on Petri Nets and Performance Models, </booktitle> <pages> pp. 111-120, </pages> <address> Madison, WI, </address> <month> August </month> <year> 1987. </year>
Reference: [VB97] <author> A. Vaysburd and K. Birman. </author> <title> Building Reliable Adaptive Distributed Objects with the Maestro Tools. </title> <booktitle> In Workshop on Dependable Distributed Object Systems, </booktitle> <address> OOPSLA'97, Atlanta, Georgia, </address> <month> October </month> <year> 1997. </year>
Reference: [Vis97] <author> Visigenic. VisiBroker. </author> <note> Visigenic Software, http://www.visigenic.com/prod/, 1997. </note>
Reference-contexts: Consequently, ORB components provided by different vendors (such as IIOP bridges or object adaptors) are generally not interchangeable. 36 For example, the IIOP bridge of VisiBroker <ref> [Vis97] </ref> cannot be used with Or-bix [ION98] so as to receive IIOP requests and inject them into the ORB.
Reference: [Vit98] <institution> Vitria. Vitria Velocity. Vitria Technology, Inc., </institution> <note> http://www.vitria.com, 1998. </note>
Reference-contexts: Because of the insufficiency of CORBA interfaces, some vendors already offer server-side products which are compliant with the CORBA standard at the protocol/message format/data representation level (IIOP/GIOP), but provide proprietary extensions or alternatives to CORBA interfaces at the server side <ref> [Vit98] </ref>. The BBN QuO project [ZBS97] is exploring another dimension of the interfaces issue, with a focus on augmenting "functional" CORBA interfaces (based on IDL) with orthogonal interfaces that describe system-level properties (specifically those concerning quality-of-service and reliability) using a System Definition Language.
Reference: [vRBM96] <author> R. van Renesse, K. Birman, and S. Maffeis. Horus: </author> <title> A flexible Group Communication System. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 76-83, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: We believe the first CORBA-compliant reliable ORB was Electra [Maf95a,Maf95b]. It separated CORBA-specific abstractions (the ORB and the Basic Object Adaptor) from the communication substrate, which could be any group-communication system exporting a common interface. Electra was initially based on Isis and subsequently ported to run over the Horus <ref> [vRBM96] </ref> and Ensemble [Hay97] systems. With the Isis-based implementation, Electra creates a group per replicated object. Client objects join the group as Isis clients, and server objects (object implementations) join as Isis group members. <p> Our protocols are best suited for use in such high-performance systems, running over partitionable yet high-quality networks. The protocols described in this chapter have been implemented within the Ho-rus group communication system <ref> [vRBM96] </ref>. However, their properties and implementation are quite generic and can be easily ported to other systems, such as Ensemble [Hay97]. <p> We will describe the details of our approach in the following sections. 4.3 System Model and Protocol Support in Horus In this section we will describe a layered implementation of state machine replication based on the Horus group communication system <ref> [vRBM96] </ref>. The architecture of Horus supports multiple protocol stacks, where the high-level group seman 71 tics provided to the application is built as a composite function of properties of individual protocol layers included in a particular stack. Each layer implements a different mini-protocol and thus differ semantically.
Reference: [Wan97] <author> Yi-Min Wang. </author> <title> Private communication, </title> <month> November </month> <year> 1997. </year>
Reference-contexts: While standardization of inflexible heavy-weight interfaces at the application level is problematic, CORBA interfaces are in fact understandardized at the "bottom" level, in particular as regards request injection/dispatching functionality <ref> [Wan97] </ref>. Consequently, ORB components provided by different vendors (such as IIOP bridges or object adaptors) are generally not interchangeable. 36 For example, the IIOP bridge of VisiBroker [Vis97] cannot be used with Or-bix [ION98] so as to receive IIOP requests and inject them into the ORB.
Reference: [ZBS97] <author> J. Zinky, D. Bakken, and R. Schantz. </author> <title> Architectural Support for Quality of Service for CORBA Objects. </title> <booktitle> Theory and Practice of Object Systems, </booktitle> <month> April </month> <year> 1997. </year>
Reference-contexts: Because of the insufficiency of CORBA interfaces, some vendors already offer server-side products which are compliant with the CORBA standard at the protocol/message format/data representation level (IIOP/GIOP), but provide proprietary extensions or alternatives to CORBA interfaces at the server side [Vit98]. The BBN QuO project <ref> [ZBS97] </ref> is exploring another dimension of the interfaces issue, with a focus on augmenting "functional" CORBA interfaces (based on IDL) with orthogonal interfaces that describe system-level properties (specifically those concerning quality-of-service and reliability) using a System Definition Language.
References-found: 49

