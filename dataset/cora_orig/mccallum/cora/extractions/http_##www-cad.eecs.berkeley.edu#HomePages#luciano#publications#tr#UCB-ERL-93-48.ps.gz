URL: http://www-cad.eecs.berkeley.edu/HomePages/luciano/publications/tr/UCB-ERL-93-48.ps.gz
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/luciano/publications.html
Root-URL: 
Title: A Formal Specification Model for Hardware/Software Codesign  
Author: Massimiliano Chiodo, Paolo Giusto, Harry Hsieh, Attila Jurecska, Luciano Lavagno, Alberto Sangiovanni-Vincentelli 
Date: June 1, 1993  
Abstract: Embedded controllers for reactive real-time applications are implemented as mixed software-hardware systems. In this paper we present a model for specification, partitioning, and implementation of such systems. The model, called Codesign Finite State Machines (CFSMs), is based on FSMs and is particularly suited to a specific class of systems with relatively low algorithmic complexity. Pre-existing formal specification languages can be used by the designer to specify the intended behavior of the system and mapped into our model. CFSMs use a non-zero unbounded reaction delay model and hence can be indifferently implemented either in hardware or in software. The implementation only restricts the range of variation of some previously undefined delays, thus preserving formal properties of the specification across implementation refinements. The communication primitive, event broadcasting, is low-level enough to be implemented efficiently and yet general enough to allow higher-level mechanisms (such as channels) to be defined by the designer. 
Abstract-found: 1
Intro-found: 1
Reference: [ACD90] <author> R. Alur, C. Courcoubetis, and D. Dill. </author> <title> Model-Checking for Real-Time Systems. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 414-425, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: We would also like to use probabilistic timing analysis techniques to verify the satisfaction of timing constraints without the need to use expensive exhaustive verification methods based on state space exploration (e.g., [Bur92], <ref> [ACD90] </ref>). 33
Reference: [Aco92] <author> R. D. Acosta. </author> <title> Use of dataflow specifications for software/hardware codesign. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: Others (e.g. <ref> [Aco92] </ref>, : : : ) define it as the choice of the best processor/bus/memory architecture that suits a given software specification.
Reference: [Bak93] <author> W. Baker. </author> <title> Application of the synchronous/reactive model to the VHDL language. </title> <type> Technical report, </type> <institution> U.C. Berkeley, </institution> <year> 1993. </year>
Reference: [BC84] <author> Gerard Berry and Laurent Cosserat. </author> <title> The ESTEREL synchronous programming language and its mathematical semantics. In S.D. </title> <editor> Brookes, A.W. Roscoe, and G. Winskel, editors, </editor> <booktitle> Seminar on Concurrency, </booktitle> <pages> pages 369-448. </pages> <institution> Carnegie-Mellon Univeristy, </institution> <year> 1984. </year>
Reference: [BCH + 91] <author> R.K. Brayton, M. Chiodo, R. Hojati, T. Kam, K. Kodandapani, R.P. Kurshan, S. Ma-lik, A.L. Sangiovanni-Vincentelli, E.M. Sentovich, T. Shiple, and H.Y. Wang. </author> <title> BLIF-MV:an interchange format for design verification and synthesis. </title> <type> Technical Report UCB/ERL M91/97, </type> <institution> U.C. Berkeley, </institution> <month> November </month> <year> 1991. </year>
Reference: [BE91] <author> E. Best and J. Esparza. </author> <title> Model checking of persistent Petri Nets. </title> <note> In Computer Science Logic 91 (LNCS), 1991. Also appeared as Hildesheimer Informatik Fachbericht 11/91. </note>
Reference-contexts: CFSMs also have the advantage that their behavior is defined using partial orders, and hence are amenable to verification techniques that reduce state space explosion by avoiding to construct all possible interleavings of concurrent actions ([NPW81], <ref> [BE91] </ref>). 2.2 Events and Traces The basic observable entities that define the behavior of the system that we want to model are events. <p> We hope to be able to extend and use methods based on partial orders, such as those proposed by [NPW81] and <ref> [BE91] </ref>, that avoid the state explosion problem due to the exploration of all possible interleavings of concurrent events.
Reference: [Ber91] <author> G. Berry. </author> <title> A hardware implementation of pure ESTEREL. </title> <booktitle> In Proceedings of the International Workshop on Formal Methods in VLSI Design, </booktitle> <month> January </month> <year> 1991. </year>
Reference: [BM87] <author> S. Burns and A. Martin. </author> <title> A synthesis method for self-timed VLSI circuits. </title> <booktitle> In Proceedings of the International Conference on Computer Design, </booktitle> <year> 1987. </year>
Reference-contexts: Methods to implement software programs in hardware; for example: * various flavors of CSP ([Hoa78]), a formalism developed for correct concurrent program specification, have been translated into synchronous ([PL91], [WOB92], : : : ) or asyn chronous ([vBKR + 91], <ref> [BM87, Mar90b, Mar90a] </ref>, : : : ) circuits. * languages for real-time software specification, such as ESTEREL or StateCharts , have been directly ([Ber91]) or indirectly ([NVG91]) used as hardware description languages. 2.
Reference: [BN92] <author> W. Baker and A. R. </author> <title> Newton. Synchronous parallelism and object-oriented computing for real-time software applications. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: It can also be augmented, e.g. as in [JLHM91] or [MKP92], to describe the constraints that must be satisfied by the implementation and that drive the synthesis process. * Its underlying computational model satisfies the requirements posed by <ref> [BN92] </ref>, because it allows only finite state and finite interconnection. It also reduces to a bare minimum the indeterminacy in execution times due to the real-time operating system. The basic idea is to use a network of interacting FSMs, that communicate through a very low-level primitive: events.
Reference: [Bur92] <author> J. R. Burch. </author> <title> Automatic Symbolic Verification of Real-Time Concurrent Systems. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> August </month> <year> 1992. </year>
Reference-contexts: We use a discrete model of time, where each computing element takes a non-zero unbounded (at least before an implementation is chosen) time to perform its task. This model is quite realistic for synchronous systems and lends itself to efficient formal verification techniques (e.g. [Kur90], <ref> [Bur92] </ref>). 4 The CFSM model (like most FSM-based models) is not meant to be used directly by designers, due to its relatively low level (almost "bitwise") view of the world. <p> We would also like to use probabilistic timing analysis techniques to verify the satisfaction of timing constraints without the need to use expensive exhaustive verification methods based on state space exploration (e.g., <ref> [Bur92] </ref>, [ACD90]). 33
Reference: [CGH + 93] <author> Massimiliano Chiodo, Paolo Giusto, Harry Hsieh, Attila Jurecska, Luciano Lavagno, and Alberto Sangiovanni-Vincentelli. </author> <title> Synthesis of mixed software-hardware implementations from CFSM specifications. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <year> 1993. </year>
Reference-contexts: Note that our unbounded non-zero discrete delay model also allows for pipelined implementations of the very same specification, of course if the designer provides some adequate means for synchronization between components with different degrees of pipelining. For a detail description about synthesis and partitioning of CFSM systems, see <ref> [CGH + 93] </ref>. The CFSM delay model plays a key role in making the software implementation possible as well. Writing a procedure that computes the next state and the output function given some input data and present state information is trivial.
Reference: [CKN86] <author> D. Del Corso, H. Kirkman, and J. D. Nicoud. </author> <title> Microcomputer buses and links. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1986. </year>
Reference: [CLM91] <author> E. M. Clarke, D. E. Long, and K. L. McMillan. </author> <title> A language for compositional specification and verification of finite state hardware controllers. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9), </volume> <month> September </month> <year> 1991. </year>
Reference: [COB92] <author> P. Chou, R. Ortega, and G. Borriello. </author> <booktitle> Synthesis of hardware/software interface in microcontroller-based systems. In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <month> November </month> <year> 1992. </year> <month> 34 </month>
Reference-contexts: Methods to implement hardware specifications in software (e.g., [WWD92], [GJM92c, GJM92b, GJM92a], [Str92], : : : ). 3. Methods to solve various particular aspects of hardware-software cooperation; for example: * design of interfaces between hardware and software components ([SB92], <ref> [COB92] </ref>, : : : ). * formal specification of hardware-software system properties ([MKP92], : : : ).
Reference: [Coc92] <author> M. Cochran. </author> <title> Using the rate monotonic analysis to analyze the schedulability of ADARTS real-time software designs. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: We will exclude from our consideration large systems that require the coordination of many boards and tens of thousands of lines of code ([SB91], <ref> [Coc92] </ref>, : : : ). Available approaches to this problem can be classified in three broad groups: 1.
Reference: [CR78] <author> P. F. Conklin and D. P. Rodgers. </author> <title> Advanced minicomputer designed by team evaluation of hardware-software tradeoffs. </title> <booktitle> Computer Design, </booktitle> <pages> pages 129-137, </pages> <month> April </month> <year> 1978. </year>
Reference-contexts: 1 Introduction Many different definitions of the term "hardware-software codesign" have been used in the literature. Some (e.g. [Tur78], [RR83], <ref> [CR78] </ref>, [HJB + 82], : : : ) consider it as the definition of the Instruction Set Architecture for a new computer, where the cost of implementing operations with hardware, microcode or subroutines, as well as the compiler technology advances required to handle highly pipelined or concurrent implementations must be taken
Reference: [Dil88] <author> D.L. Dill. </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-Independent Circuits. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year> <note> An ACM Distinguished Dissertation 1988. </note>
Reference-contexts: A timed trace is an ordered finite or infinite sequence of events from some alphabet, with monotonically nondecreasing times of occurrence, such that no two events with the same name are simultaneous (i.e. each "communication port" can carry only one value at a time). Following <ref> [Dil88] </ref>, we require sets of traces describing the behavior in time of a system to be prefix-closed , because every partial observation of a valid behavior up to a certain point in time must be considered a valid behavior as well. <p> The 27 internal signals will correspond to the external signals, except for a possible delay and the possible omission of some events (due to the "overwriting" explained in Section 2). Such internal signals of course must not be considered (i.e. they must be "hidden" from the traces <ref> [Dil88] </ref>) when we compare the behavior of the two. In the following we will assume that time units for CFSMs and FSMs coincide.
Reference: [EH92] <author> R. Ernst and J. Henkel. </author> <title> Hardware-software codesign of embedded controllers based on hardware extraction. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> September </month> <year> 1992. </year>
Reference: [GJM92a] <author> R. K. Gupta, C. N. Coelho Jr., and G. De Micheli. </author> <title> Program implementation schemes for hardware-software systems. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: Others (e.g. [Aco92], : : : ) define it as the choice of the best processor/bus/memory architecture that suits a given software specification. We will use the term in a different sense (common, e.g., to [SB91], <ref> [GJM92c, GJM92b, GJM92a] </ref>, [WWD92], : : : ), meaning the design of a special-purpose system composed of a few Application Specific Integrated Circuits cooperating with software procedures on general-purpose processors. This restricted definition is still too wide to allow a useful formalization of generally applicable automated design methodologies. <p> Methods to implement hardware specifications in software (e.g., [WWD92], <ref> [GJM92c, GJM92b, GJM92a] </ref>, [Str92], : : : ). 3. Methods to solve various particular aspects of hardware-software cooperation; for example: * design of interfaces between hardware and software components ([SB92], [COB92], : : : ). * formal specification of hardware-software system properties ([MKP92], : : : ).
Reference: [GJM92b] <author> R. K. Gupta, C. N. Coelho Jr., and G. De Micheli. </author> <title> Synthesis and simulation of digital systems containing interacting hardware and software components. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Others (e.g. [Aco92], : : : ) define it as the choice of the best processor/bus/memory architecture that suits a given software specification. We will use the term in a different sense (common, e.g., to [SB91], <ref> [GJM92c, GJM92b, GJM92a] </ref>, [WWD92], : : : ), meaning the design of a special-purpose system composed of a few Application Specific Integrated Circuits cooperating with software procedures on general-purpose processors. This restricted definition is still too wide to allow a useful formalization of generally applicable automated design methodologies. <p> Methods to implement hardware specifications in software (e.g., [WWD92], <ref> [GJM92c, GJM92b, GJM92a] </ref>, [Str92], : : : ). 3. Methods to solve various particular aspects of hardware-software cooperation; for example: * design of interfaces between hardware and software components ([SB92], [COB92], : : : ). * formal specification of hardware-software system properties ([MKP92], : : : ).
Reference: [GJM92c] <author> R. K. Gupta, C. N. Coelho Jr., and G. De Micheli. </author> <title> System-level synthesis using re-programmable components. </title> <booktitle> In Proceedings of the European Design Automation Conference (EDAC), </booktitle> <pages> pages 2-7, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Others (e.g. [Aco92], : : : ) define it as the choice of the best processor/bus/memory architecture that suits a given software specification. We will use the term in a different sense (common, e.g., to [SB91], <ref> [GJM92c, GJM92b, GJM92a] </ref>, [WWD92], : : : ), meaning the design of a special-purpose system composed of a few Application Specific Integrated Circuits cooperating with software procedures on general-purpose processors. This restricted definition is still too wide to allow a useful formalization of generally applicable automated design methodologies. <p> Methods to implement hardware specifications in software (e.g., [WWD92], <ref> [GJM92c, GJM92b, GJM92a] </ref>, [Str92], : : : ). 3. Methods to solve various particular aspects of hardware-software cooperation; for example: * design of interfaces between hardware and software components ([SB92], [COB92], : : : ). * formal specification of hardware-software system properties ([MKP92], : : : ).
Reference: [Gun92] <author> J. Gunawardena. </author> <title> Causal automata. </title> <journal> Theoretical Computer Science, </journal> <volume> 101(2) </volume> <pages> 265-288, </pages> <year> 1992. </year>
Reference-contexts: Hence they are not very suitable to concisely express other causality paradigms such as, for example, or causality (meaning that any one of a given set of preconditions is sufficient to cause an action <ref> [Gun92] </ref>). Synchronous programming languages require a zero reaction time that, as argued above, is not realistic enough for our purposes and that may be rather inefficient to implement in hardware, with very long combinational logic delays ([Ber91]).
Reference: [HJB + 82] <author> J. Hennessy, N. Jouppi, F. Baskett, T. R. Gross, and J. Gill. </author> <title> Hardware-software tradeoffs for increased performance. </title> <booktitle> In Proceedings of the Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 2-11, </pages> <month> March </month> <year> 1982. </year>
Reference-contexts: 1 Introduction Many different definitions of the term "hardware-software codesign" have been used in the literature. Some (e.g. [Tur78], [RR83], [CR78], <ref> [HJB + 82] </ref>, : : : ) consider it as the definition of the Instruction Set Architecture for a new computer, where the cost of implementing operations with hardware, microcode or subroutines, as well as the compiler technology advances required to handle highly pipelined or concurrent implementations must be taken into
Reference: [Hoa78] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> In Communications of the ACM, </booktitle> <pages> pages 666-677, </pages> <month> August </month> <year> 1978. </year>
Reference: [JLHM91] <author> M. Jaffe, N. Leveson, M. Heimdahl, and B. Melhart. </author> <title> Software requirements analysis for real-time process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(3), </volume> <month> March </month> <year> 1991. </year>
Reference-contexts: For example: * Following [MKP92], it can describe the format of information (even though at a rather basic level), precedence relations between events and functional relations between input and output values. It can also be augmented, e.g. as in <ref> [JLHM91] </ref> or [MKP92], to describe the constraints that must be satisfied by the implementation and that drive the synthesis process. * Its underlying computational model satisfies the requirements posed by [BN92], because it allows only finite state and finite interconnection.
Reference: [Kur90] <author> R. P. Kurshan. </author> <title> Analysis of discrete event coordination. </title> <booktitle> In Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: We use a discrete model of time, where each computing element takes a non-zero unbounded (at least before an implementation is chosen) time to perform its task. This model is quite realistic for synchronous systems and lends itself to efficient formal verification techniques (e.g. <ref> [Kur90] </ref>, [Bur92]). 4 The CFSM model (like most FSM-based models) is not meant to be used directly by designers, due to its relatively low level (almost "bitwise") view of the world. <p> They combine a very intuitive semantics, that is generally familiar to designers, with the availability of excellent synthesis and formal verification tools (e.g. [SSL + 92, SSM + 92], <ref> [Kur90, Kur93] </ref>). However, their "classical" definition has an implied synchronous hypothesis: all the FSMs used to model a system must change state and produce their outputs simultaneously. A mixed hardware-software system, on the other hand, may contain components that proceed at very different speeds.
Reference: [Kur93] <author> R. P. Kurshan. </author> <title> Automata-Theoretic Verification of Coordinating Processes. </title> <publisher> Princeton University Press, </publisher> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: They combine a very intuitive semantics, that is generally familiar to designers, with the availability of excellent synthesis and formal verification tools (e.g. [SSL + 92, SSM + 92], <ref> [Kur90, Kur93] </ref>). However, their "classical" definition has an implied synchronous hypothesis: all the FSMs used to model a system must change state and produce their outputs simultaneously. A mixed hardware-software system, on the other hand, may contain components that proceed at very different speeds.
Reference: [Mar90a] <author> A. Martin. </author> <title> Formal program transformations for VLSI synthesis. </title> <editor> In E. W. Dijkstra, editor, </editor> <booktitle> Formal Development of Programs and Proofs, The UT Year of Programming Series. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1990. </year> <month> 35 </month>
Reference-contexts: Methods to implement software programs in hardware; for example: * various flavors of CSP ([Hoa78]), a formalism developed for correct concurrent program specification, have been translated into synchronous ([PL91], [WOB92], : : : ) or asyn chronous ([vBKR + 91], <ref> [BM87, Mar90b, Mar90a] </ref>, : : : ) circuits. * languages for real-time software specification, such as ESTEREL or StateCharts , have been directly ([Ber91]) or indirectly ([NVG91]) used as hardware description languages. 2.
Reference: [Mar90b] <author> A. Martin. </author> <title> Programming in VLSI: From communicating processes to delay-insensitive circuits. </title> <editor> In C. A. R. Hoare, editor, </editor> <booktitle> Developments in Concurrency and Communications, The UT Year of Programming Series. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Methods to implement software programs in hardware; for example: * various flavors of CSP ([Hoa78]), a formalism developed for correct concurrent program specification, have been translated into synchronous ([PL91], [WOB92], : : : ) or asyn chronous ([vBKR + 91], <ref> [BM87, Mar90b, Mar90a] </ref>, : : : ) circuits. * languages for real-time software specification, such as ESTEREL or StateCharts , have been directly ([Ber91]) or indirectly ([NVG91]) used as hardware description languages. 2.
Reference: [MKP92] <author> M.C. McFarland, T.J. Kowalski, and M.J. Peman. </author> <title> Language and formal semantics of the specification system CPA. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: It satisfies the requirements posed by various researchers who have worked in the area. For example: * Following <ref> [MKP92] </ref>, it can describe the format of information (even though at a rather basic level), precedence relations between events and functional relations between input and output values. It can also be augmented, e.g. as in [JLHM91] or [MKP92], to describe the constraints that must be satisfied by the implementation and that <p> For example: * Following <ref> [MKP92] </ref>, it can describe the format of information (even though at a rather basic level), precedence relations between events and functional relations between input and output values. It can also be augmented, e.g. as in [JLHM91] or [MKP92], to describe the constraints that must be satisfied by the implementation and that drive the synthesis process. * Its underlying computational model satisfies the requirements posed by [BN92], because it allows only finite state and finite interconnection.
Reference: [Mur89] <author> T. Murata. </author> <title> Petri Nets: Properties, analysis and applications. </title> <booktitle> Proceedings of the IEEE, </booktitle> <pages> pages 541-580, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Introducing a specialized model eases the definition of the basic requirements that we want to impose on the codesign system. Existing formal models that embody the desired notion of non-deterministic timing, such as Petri nets ([Pet62], <ref> [Mur89] </ref>) or synchronous programming languages ([BC84]) are not very suitable for our purposes either. Petri nets per se have infinite state, and there are no easy syntactic restrictions to limit the class of specifiable behaviors to bounded nets, which require only a finite amount of state 2 .
Reference: [NPW81] <author> M. Nielsen, G. Plotkin, and G. Winskel. </author> <title> Petri nets, event structures and domains. part I. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 85-108, </pages> <year> 1981. </year>
Reference-contexts: We hope to be able to extend and use methods based on partial orders, such as those proposed by <ref> [NPW81] </ref> and [BE91], that avoid the state explosion problem due to the exploration of all possible interleavings of concurrent events.
Reference: [NVG91] <author> S. Narayan, F. Vahid, and D. D. Gajski. </author> <title> System specification and synthesis with the SpecCharts language. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <month> November </month> <year> 1991. </year>
Reference: [Pet62] <author> C. A. </author> <title> Petri. Kommunikation mit Automaten. </title> <type> PhD thesis, </type> <institution> Bonn, Institut fur Instru-mentelle Mathematik, </institution> <year> 1962. </year> <note> (technical report Schriften des IIM Nr. 3). </note>
Reference: [PL91] <author> I. Page and W. Luk. </author> <title> Compiling occam into FPGAs. </title> <editor> In W. Moore and W. Luk, editors, </editor> <booktitle> FPGAs, </booktitle> <pages> pages 271-283. </pages> <publisher> Abingdon EE&CS Books, </publisher> <year> 1991. </year>
Reference: [RR83] <author> G. S. Rao and P. L. Rosenfeld. </author> <title> Integration of machine organization and control program design review and direction. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 27(3) </volume> <pages> 247-256, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: 1 Introduction Many different definitions of the term "hardware-software codesign" have been used in the literature. Some (e.g. [Tur78], <ref> [RR83] </ref>, [CR78], [HJB + 82], : : : ) consider it as the definition of the Instruction Set Architecture for a new computer, where the cost of implementing operations with hardware, microcode or subroutines, as well as the compiler technology advances required to handle highly pipelined or concurrent implementations must be
Reference: [SB91] <author> M. B. Srivastava and R. W. Brodersen. </author> <title> Rapid-prototyping of hardware and software in a unified framework. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <month> November </month> <year> 1991. </year>
Reference-contexts: Others (e.g. [Aco92], : : : ) define it as the choice of the best processor/bus/memory architecture that suits a given software specification. We will use the term in a different sense (common, e.g., to <ref> [SB91] </ref>, [GJM92c, GJM92b, GJM92a], [WWD92], : : : ), meaning the design of a special-purpose system composed of a few Application Specific Integrated Circuits cooperating with software procedures on general-purpose processors. This restricted definition is still too wide to allow a useful formalization of generally applicable automated design methodologies.
Reference: [SB92] <author> J. Sun and R. W. Brodersen. </author> <title> Design of system interface modules. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 478-481, </pages> <month> November </month> <year> 1992. </year>
Reference: [SSL + 92] <author> E. M. Sentovich, K. J. Singh, L. Lavagno, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P. R. Stephan, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> SIS: A system for sequential circuit synthesis. </title> <type> Technical Report UCB/ERL M92/41, </type> <institution> U.C. Berkeley, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: They combine a very intuitive semantics, that is generally familiar to designers, with the availability of excellent synthesis and formal verification tools (e.g. <ref> [SSL + 92, SSM + 92] </ref>, [Kur90, Kur93]). However, their "classical" definition has an implied synchronous hypothesis: all the FSMs used to model a system must change state and produce their outputs simultaneously. A mixed hardware-software system, on the other hand, may contain components that proceed at very different speeds. <p> This format is mainly an extension of BLIF-MV ([BCH + 91]), which in turn is a multi-valued extension of the Berkeley Logic Interchange Format (BLIF, <ref> [SSL + 92] </ref>). In SHIFT a CFSM description consists of a list of input variables, a list of output variables, and the transition relation.
Reference: [SSM + 92] <author> E.M. Sentovich, K.J. Singh, C. Moon, H. Savoj, R.K. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <title> Sequential circuit design using synthesis and optimization. </title> <booktitle> In Proceedings of the International Conference on Computer Design, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: They combine a very intuitive semantics, that is generally familiar to designers, with the availability of excellent synthesis and formal verification tools (e.g. <ref> [SSL + 92, SSM + 92] </ref>, [Kur90, Kur93]). However, their "classical" definition has an implied synchronous hypothesis: all the FSMs used to model a system must change state and produce their outputs simultaneously. A mixed hardware-software system, on the other hand, may contain components that proceed at very different speeds.
Reference: [Str92] <author> C. E. Stroud. </author> <title> Problems associated with hardware implementation of software algorithms using behavioral model synthesis. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: Methods to implement hardware specifications in software (e.g., [WWD92], [GJM92c, GJM92b, GJM92a], <ref> [Str92] </ref>, : : : ). 3. Methods to solve various particular aspects of hardware-software cooperation; for example: * design of interfaces between hardware and software components ([SB92], [COB92], : : : ). * formal specification of hardware-software system properties ([MKP92], : : : ).
Reference: [Tur78] <author> R. </author> <title> Turn. </title> <booktitle> Hardware-software tradeoffs in reliable software development. In 11th Annual Asilomar Conference on Circuits, Systems and Computers, </booktitle> <pages> pages 282-288, </pages> <year> 1978. </year> <month> 36 </month>
Reference-contexts: 1 Introduction Many different definitions of the term "hardware-software codesign" have been used in the literature. Some (e.g. <ref> [Tur78] </ref>, [RR83], [CR78], [HJB + 82], : : : ) consider it as the definition of the Instruction Set Architecture for a new computer, where the cost of implementing operations with hardware, microcode or subroutines, as well as the compiler technology advances required to handle highly pipelined or concurrent implementations must
Reference: [vBKR + 91] <author> K. van Berkel, J. Kessels, M. Roncken, R. Saejis, and F. Schalij. </author> <title> The VLSI--programming language Tangram and its translation into handshake circuits. </title> <booktitle> In Proceedings of the European Design Automation Conference (EDAC), </booktitle> <pages> pages 384-389, </pages> <year> 1991. </year>
Reference: [WOB92] <author> A. S. Wenban, J. W. O'Leary, and G. M. Brown. </author> <title> Codesign of communication protocols. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: Available approaches to this problem can be classified in three broad groups: 1. Methods to implement software programs in hardware; for example: * various flavors of CSP ([Hoa78]), a formalism developed for correct concurrent program specification, have been translated into synchronous ([PL91], <ref> [WOB92] </ref>, : : : ) or asyn chronous ([vBKR + 91], [BM87, Mar90b, Mar90a], : : : ) circuits. * languages for real-time software specification, such as ESTEREL or StateCharts , have been directly ([Ber91]) or indirectly ([NVG91]) used as hardware description languages. 2.
Reference: [WTHM92] <author> W. Wolf, A. Takach, C.-Y. Huang, and R. </author> <title> Manno. The Princeton University behavioral synthesis system. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1992. </year>
Reference: [WWD92] <author> N. Woo, W. Wolf, and A. Dunlop. </author> <title> Compilation of a single specification into hardware and software. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> September </month> <year> 1992. </year> <month> 37 </month>
Reference-contexts: Others (e.g. [Aco92], : : : ) define it as the choice of the best processor/bus/memory architecture that suits a given software specification. We will use the term in a different sense (common, e.g., to [SB91], [GJM92c, GJM92b, GJM92a], <ref> [WWD92] </ref>, : : : ), meaning the design of a special-purpose system composed of a few Application Specific Integrated Circuits cooperating with software procedures on general-purpose processors. This restricted definition is still too wide to allow a useful formalization of generally applicable automated design methodologies. <p> Methods to implement hardware specifications in software (e.g., <ref> [WWD92] </ref>, [GJM92c, GJM92b, GJM92a], [Str92], : : : ). 3. Methods to solve various particular aspects of hardware-software cooperation; for example: * design of interfaces between hardware and software components ([SB92], [COB92], : : : ). * formal specification of hardware-software system properties ([MKP92], : : : ).
References-found: 46

