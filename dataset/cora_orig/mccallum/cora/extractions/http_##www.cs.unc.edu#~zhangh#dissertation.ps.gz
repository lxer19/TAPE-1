URL: http://www.cs.unc.edu/~zhangh/dissertation.ps.gz
Refering-URL: http://www.cs.unc.edu/~zhangh/research.html
Root-URL: http://www.cs.unc.edu
Title: Effective Occlusion Culling for the Interactive Display of Arbitrary Models  
Author: by Hansong Zhang Frederick P. Brooks, Jr., Reader Anselmo Lastra, Reader 
Degree: A Dissertation submitted to the faculty of The  in partial fulfillment of the requirements for the degree of Doctor of Philosophy in the  Approved by: Dinesh Manocha, Advisor  
Date: 1998  
Address: Chapel Hill  
Affiliation: University of North Carolina at Chapel Hill  Department of Computer Science.  
Abstract-found: 0
Intro-found: 1
Reference: [AJ88] <author> Kurt Akeley and Tom Jermoluk. </author> <title> High-performance polygon rendering. </title> <editor> In John Dill, editor, </editor> <booktitle> Computer Graphics (SIGGRAPH '88 Proceedings), </booktitle> <volume> volume 22, </volume> <pages> pages 239-246, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Pipelining is an important technique for the acceleration of graphics applications. Pipelining has been extensively used both at the software application level (e.g. by the Iris Performer [RH94]) and inside the graphics hardware (e.g. <ref> [AJ88] </ref>). For our two-pass occlusion culling framework (section 3.2), we are interested in software pipelining schemes for the parallelization of the application pipeline, and regard the hardware pipeline as a blackbox to which we send graphics primitives.
Reference: [App67] <author> Arthur Appel. </author> <title> The notion of quantitative invisibility and the machine rendering of solids. </title> <booktitle> Proc. ACM Natl. Mtg., </booktitle> <pages> page 387, </pages> <year> 1967. </year>
Reference-contexts: Sutherland et. al. [SSS74] presents a characterization of the algorithms. The book by Foley et. al. [FDFH90] has a chapter on visible-surface determination that includes most of the algorithms developed so far. Specifically, algorithms for hidden surface removal include visible-line determination <ref> [Rob63, App67] </ref>, the z-buffer (or depth-buffer) algorithm [Cat74], the depth-sort algorithm [NNS72], scan-line algorithms [WREE67, BK70, Bou70, Wat70], area-subdivision algorithms [War69, WA77] and ray-tracing [App68]. Visibility determination is closely related to depth sorting of primitives. Once the primitives are ordered in depth, they can be rendered back-to-front for correct visibility.
Reference: [App68] <author> A. Appel. </author> <title> Some techniques for shading machine renderings of solids. </title> <booktitle> In IFIP, </booktitle> <volume> volume 32, </volume> <pages> pages 37-45, </pages> <year> 1968. </year>
Reference-contexts: Specifically, algorithms for hidden surface removal include visible-line determination [Rob63, App67], the z-buffer (or depth-buffer) algorithm [Cat74], the depth-sort algorithm [NNS72], scan-line algorithms [WREE67, BK70, Bou70, Wat70], area-subdivision algorithms [War69, WA77] and ray-tracing <ref> [App68] </ref>. Visibility determination is closely related to depth sorting of primitives. Once the primitives are ordered in depth, they can be rendered back-to-front for correct visibility. The binary space partitioning (BSP) algorithms [FKN80] produce an organization of polygons from which their depth ordering can be quickly derived.
Reference: [ARB90] <author> John M. Airey, John H. Rohlf, and Frederick P. Brooks, Jr. </author> <title> Towards image realism with interactive update rates in complex virtual building environments. </title> <editor> In Rich Riesenfeld and Carlo Sequin, editors, </editor> <booktitle> Computer Graphics (1990 Symposium on Interactive 3D Graphics), </booktitle> <volume> volume 24, </volume> <pages> pages 41-50, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Finding the exact set of visible objects often takes much more time than that saved by not rendering non-visible objects, in which case visibility culling actually leads to slower frame rates. So most algorithms seek to find only the potentially visible set (PVS), proposed by <ref> [ARB90] </ref>, which is a superset of the exact set of visible objects; in other words, a typical PVS contains all the visible objects and some non-visible objects. The PVS is less expensive to find than the exact set and can still be significantly smaller than the original model. <p> The mask represents the intersection of the infinite frusta defined by the viewpoint and each portal in the sequence. If the a portal does not intersect the mask, it must be hidden from the viewer, and the cell on the other side need not be traversed. Airey <ref> [ARB90] </ref> proposed the notion of densely occluded environments|scenes only a small fraction of which can be seen from most viewpoints. He further studied one type of such environments suitable for a portal-based treatment, namely the architectural environment.
Reference: [BE89] <author> M. Bunker and R. </author> <title> Economy. Evolution of GE CIG Systems. General Electric Company, </title> <address> Daytona Beach, FL, </address> <year> 1989. </year>
Reference-contexts: An overview of flight simulator architectures is given in [Mue95]. Most notably, the Singer Company's Modular Digital Image Generator [Lat94] renders 20 polygons in front-to-back order using a hierarchy of mask buffers to skip over already covered spans, segments or rows in the image. General Electric's COMPU-SCENE PT2000 <ref> [BE89] </ref> uses a similar algorithm but does not require the input polygons to be rendered in front-to-back order, and the mask buffer is not hierarchical. The Loral GT200 [Lor94] first renders near objects and fills in a (possibly hierarchical) mask buffer, which is used to cull away far objects.
Reference: [BK70] <author> W. J. Bouknight and K. C. Kelly. </author> <title> An algorithm for producing half-tone computer graphics presentations with shadows and movable light sources. </title> <booktitle> In Proc. AFIPS JSCC, </booktitle> <volume> volume 36, </volume> <pages> pages 1-10, </pages> <year> 1970. </year>
Reference-contexts: The book by Foley et. al. [FDFH90] has a chapter on visible-surface determination that includes most of the algorithms developed so far. Specifically, algorithms for hidden surface removal include visible-line determination [Rob63, App67], the z-buffer (or depth-buffer) algorithm [Cat74], the depth-sort algorithm [NNS72], scan-line algorithms <ref> [WREE67, BK70, Bou70, Wat70] </ref>, area-subdivision algorithms [War69, WA77] and ray-tracing [App68]. Visibility determination is closely related to depth sorting of primitives. Once the primitives are ordered in depth, they can be rendered back-to-front for correct visibility.
Reference: [BM96] <author> D. Blythe and T. McReynolds. </author> <title> Programming with OpenGL: </title> <booktitle> Advanced rendering. SIGGRAPH'96 Course Notes, </booktitle> <pages> pages 27-28, </pages> <month> August </month> <year> 1996. </year>
Reference-contexts: Then at a certain level in the pyramid where the map drops below a threshold size, we turn to software. The break-even point between hardware and software computation, represented by the threshold map size, varies with different graphics systems. <ref> [BM96] </ref> presents a technique for generating mipmaps using a hardware accumulation buffer.
Reference: [Bou70] <author> W. Jack Bouknight. </author> <title> A procedure for generation of three-dimensional halftoned computer graphics presentations. </title> <journal> Communications of the ACM, </journal> <month> September </month> <year> 1970. </year>
Reference-contexts: The book by Foley et. al. [FDFH90] has a chapter on visible-surface determination that includes most of the algorithms developed so far. Specifically, algorithms for hidden surface removal include visible-line determination [Rob63, App67], the z-buffer (or depth-buffer) algorithm [Cat74], the depth-sort algorithm [NNS72], scan-line algorithms <ref> [WREE67, BK70, Bou70, Wat70] </ref>, area-subdivision algorithms [War69, WA77] and ray-tracing [App68]. Visibility determination is closely related to depth sorting of primitives. Once the primitives are ordered in depth, they can be rendered back-to-front for correct visibility.
Reference: [Bur88] <author> Peter J. Burt. </author> <title> Smart sensing within a pyramid vision machine. </title> <booktitle> In Proceedings of IEEE, </booktitle> <volume> volume 76, </volume> <pages> pages 1006-1015. </pages> <publisher> IEEE, </publisher> <month> August </month> <year> 1988. </year>
Reference-contexts: An examples of this is the use of mip-maps [Wil83], or hierarchical textures, to alleviate aliasing in texturing an object at different distances. Burt <ref> [Bur88] </ref> designed and implemented the Pyramid Vision Machine based on the hierarchical (pyramidal) representation of images.
Reference: [Car84] <author> Loren Carpenter. </author> <title> The A-buffer, an antialiased hidden surface method. </title> <editor> In Hank Christiansen, editor, </editor> <booktitle> Computer Graphics (SIGGRAPH '84 Proceedings), </booktitle> <volume> volume 18, </volume> <pages> pages 103-108, </pages> <month> July </month> <year> 1984. </year> <month> 93 </month>
Reference-contexts: Note that this result holds only for the box filter, by which a primitive's contribution is weighted only by its area, regardless of its sub-pixel location. 29 Computing the exact percentage of coverage is an expensive operation. In practice, anti-aliasing algorithms such as supersampling [FDFH90] and the A-buffer <ref> [Car84] </ref> seek to approximate pixel coverage instead of computing it exactly. For example, if a 4 fi 4 sub-pixel mask is used, there are only 16 possible values for A k , and at most 16 primitives can make contributions (N &lt; 16).
Reference: [Cat74] <author> Edwin E. Catmull. </author> <title> A Subdivision Algorithm for Computer Display of Curved Surfaces. </title> <type> PhD thesis, </type> <institution> Dept. of CS, U. of Utah, </institution> <month> December </month> <year> 1974. </year>
Reference-contexts: Sutherland et. al. [SSS74] presents a characterization of the algorithms. The book by Foley et. al. [FDFH90] has a chapter on visible-surface determination that includes most of the algorithms developed so far. Specifically, algorithms for hidden surface removal include visible-line determination [Rob63, App67], the z-buffer (or depth-buffer) algorithm <ref> [Cat74] </ref>, the depth-sort algorithm [NNS72], scan-line algorithms [WREE67, BK70, Bou70, Wat70], area-subdivision algorithms [War69, WA77] and ray-tracing [App68]. Visibility determination is closely related to depth sorting of primitives. Once the primitives are ordered in depth, they can be rendered back-to-front for correct visibility.
Reference: [CH92] <author> I-Cheng Chang and Chung-Lin Huang. </author> <title> Aspect graph generation for non-convex polyhedra from perspective projection view. </title> <journal> Pattern Recognition, </journal> <volume> 25(10) </volume> <pages> 1075-1096, </pages> <year> 1992. </year>
Reference-contexts: At run-time, correct visibility is retrieved from the data structures according to the current view point. Aspect graphs have been extensively investigated in computer vision for applications like object recognition for robots <ref> [GM90, GCS91, PD90, CH92] </ref>. The goal for this research is to characterize changes in aspect, i.e. topological appearance, of surfaces as the viewer moves in space. The changes are called visual events. As an 12 example, Figure 2.5 shows three views of the same tetrahedron. <p> The dual of this subdivision is called the aspect graph. [PD90] presented algorithms for generating the aspect graph under parallel or perspective projections, for convex or non-convex polyhedra. They also introduced a complex data structure named asp to store the results. <ref> [CH92] </ref> presented a different aspect graph algorithm for non-convex polyhedra under perspective projections. Form-factor computation in radiosity algorithms (for simulating global diffuse illumination) requires global visibility information among pairs of patches.
Reference: [Cla76] <author> J. H. Clark. </author> <title> Hierarchical geometric models for visible surface algorithms. </title> <journal> Communications of the ACM, </journal> 19(10) 547-554, October 1976. 
Reference-contexts: Traversing all the primitives to compute visibility for each of them is too expensive to do in real-time. Hierarchical organization of primitives helps to reduce this per-primitive operation to an efficient logarithmic search. Clark <ref> [Cla76] </ref> proposed a tree-structured bounding-volume hierarchy to accelerate the rendering of complex models. Every object has a bounding volume, which is simple in shape and spatially contains the object. For instance, the axis-aligned bounding box is one of the most commonly used bounding volumes.
Reference: [CT97] <author> S. Coorg and S. Teller. </author> <title> Real-time occlusion culling for models with large occluders. </title> <booktitle> In Proc. of ACM Symposium on Interactive 3D Graphics, </booktitle> <year> 1997. </year>
Reference-contexts: They used regular spatial subdivision to partition the model into cells. However, the resulting algorithm are very memory-intensive and does not scale well to large models. 2.2.3.4 Other Object-Space Approaches Other object-space approaches to occlusion culling have been developed for environments more general than building interiors. Coorg and Teller <ref> [CT97] </ref> and Hudson et al. [HMC + 97]. proposed object-space occlusion culling algorithms for environments with many of large polygonal occluders. These algorithms dynamically choose a subset of polygons as occluders and use them for occlusion culling. [CT97] computed an arrangement corresponding to a linearized portion of an aspect graph; at <p> Coorg and Teller <ref> [CT97] </ref> and Hudson et al. [HMC + 97]. proposed object-space occlusion culling algorithms for environments with many of large polygonal occluders. These algorithms dynamically choose a subset of polygons as occluders and use them for occlusion culling. [CT97] computed an arrangement corresponding to a linearized portion of an aspect graph; at run-time, they tracked the viewpoint with respect to the arrangement to check for occlusion. [HMC + 97] made use of shadow frusta formed by the occluder polygons and the viewpoint.
Reference: [CVM + 96] <author> Jonathan Cohen, Amitabh Varshney, Dinesh Manocha, Greg Turk, Hans Weber, Pankaj Agarwal, Frederick P. Brooks, Jr., and William Wright. </author> <title> Simplification envelopes. </title> <editor> In Holly Rushmeier, editor, </editor> <booktitle> SIGGRAPH 96 Conference Proceedings, Annual Conference Series, </booktitle> <pages> pages 119-128. </pages> <publisher> ACM SIGGRAPH, Addison Wesley, </publisher> <month> August </month> <year> 1996. </year> <title> held in New Orleans, </title> <address> Louisiana, </address> <month> 04-09 August </month> <year> 1996. </year>
Reference-contexts: Given a complex object in the original model, 60 we would like to derive from it a simplified version (with fewer polygons) that retains most of the occlusion the original object can provide. This is what we call occlusion preserving simplification. Current geometry simplification algorithms <ref> [Tur92, SZL92, RB93, CVM + 96, Hop96] </ref> operate under the constraint that the simplified object should preserve the shape of the original object to certain fidelity. <p> Intuitively, this means the simplified object should be enclosed entirely by the original object. No existing simplification algorithm can be applied directly to satisfy this constraint. We have modified the simplification-envelope algorithm <ref> [CVM + 96] </ref> to do COPS, by simplifying an inner offset-surface between the original surface and another inner offset-surface with twice as much offset.
Reference: [DDP96] <author> Fredo Durand, George Drettakis, and Claude Puech. </author> <title> The 3D visibility complex: A new approach to the problems of accurate visibility. </title> <editor> In Xavier Pueyo and Peter Schroder, editors, </editor> <booktitle> Eurographics Rendering Workshop 1996, </booktitle> <pages> pages 245-256, </pages> <address> New York City, NY, </address> <month> June </month> <year> 1996. </year> <title> Eurographics, </title> <publisher> Springer Wein. </publisher> <address> ISBN 3-211-82883-4. </address>
Reference-contexts: The visibility complex [Poc92, PV95] stores 2-D global visibility information for "flatland" radiosity (i.e. the imaginary "radiosity" computation among lines on a plane). Its 3-D extension, the 3-D visibility complex <ref> [DDP96] </ref>, is similar to the asp. More recent research along this line includes the visibility skeleton [DDP97], which aims to simplify the intricate data structures of the visibility complex.
Reference: [DDP97] <author> Fredo Durand, George Drettakis, and Claude Puech. </author> <title> The visibility skeleton: A powerful and efficient multi-purpose global visibility tool. </title> <editor> In Turner Whitted, editor, </editor> <booktitle> SIGGRAPH 97 Conference Proceedings, Annual Conference Series, </booktitle> <pages> pages 89-100. </pages> <publisher> ACM SIGGRAPH, Addison Wesley, </publisher> <month> August </month> <year> 1997. </year> <note> ISBN 0-89791-896-7. </note>
Reference-contexts: The visibility complex [Poc92, PV95] stores 2-D global visibility information for "flatland" radiosity (i.e. the imaginary "radiosity" computation among lines on a plane). Its 3-D extension, the 3-D visibility complex [DDP96], is similar to the asp. More recent research along this line includes the visibility skeleton <ref> [DDP97] </ref>, which aims to simplify the intricate data structures of the visibility complex. The application of global visibility algorithms in interactive display of complex models is limited by the fact that the worst-case complexity is these algorithms is as high as n 6 .
Reference: [Dor94] <author> S. E. Dorward. </author> <title> A survey of object-space hidden surface removal. </title> <journal> Internat. J. Comput. Geom. Appl., </journal> <volume> 4 </volume> <pages> 325-362, </pages> <year> 1994. </year>
Reference-contexts: Also, dynamic model changes are a challenge for BSP algorithms. There has been significant research in visible surface computation in computational geometry, and many algorithms have been proposed [Mul89, McK87] (see <ref> [Dor94] </ref> for a recent survey). However, the practical utility of these algorithms is unclear at the moment. 2.2.2 Global Visibility Global visibility algorithms pre-compute visibility information for arbitrary viewer positions in the 3-D space and store it in special data structures.
Reference: [EM98] <author> Carl Erikson and Dinesh Manocha. </author> <title> Simplification culling of static and dynamic scene graphs. </title> <type> Technical Report TR98-009, </type> <institution> Department of Computer Science, UNC-Chapel Hill, </institution> <year> 1998. </year>
Reference-contexts: The original model contains 632,252 triangles. Triangles that belong to the same part (e.g. a rib, the engine case, etc) are grouped into an object. Four levels of detail are generated for each original object using Erikson's simplification system <ref> [EM98] </ref>. Each simplified level has half of the polygon count of its neighboring more-detailed level. The original objects and their simplified versions are split as necessary in building the bounding volume hierarchy.
Reference: [FDFH90] <author> J. D. Foley, A. Dam, S. K. Feiner, and J. F. Hughes. </author> <title> Computer Graphics: </title> <booktitle> Principles and Practice. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Given a geometric model (most often a collection of polygons) and the viewing parameters, hidden surface algorithms find out which surfaces or parts of surfaces are visible to the viewer. Sutherland et. al. [SSS74] presents a characterization of the algorithms. The book by Foley et. al. <ref> [FDFH90] </ref> has a chapter on visible-surface determination that includes most of the algorithms developed so far. Specifically, algorithms for hidden surface removal include visible-line determination [Rob63, App67], the z-buffer (or depth-buffer) algorithm [Cat74], the depth-sort algorithm [NNS72], scan-line algorithms [WREE67, BK70, Bou70, Wat70], area-subdivision algorithms [War69, WA77] and ray-tracing [App68]. <p> Note that this result holds only for the box filter, by which a primitive's contribution is weighted only by its area, regardless of its sub-pixel location. 29 Computing the exact percentage of coverage is an expensive operation. In practice, anti-aliasing algorithms such as supersampling <ref> [FDFH90] </ref> and the A-buffer [Car84] seek to approximate pixel coverage instead of computing it exactly. For example, if a 4 fi 4 sub-pixel mask is used, there are only 16 possible values for A k , and at most 16 primitives can make contributions (N &lt; 16).
Reference: [FKN80] <author> H. Fuchs, Z. M. Kedem, and B. F. Naylor. </author> <title> On visible surface generation by a priori tree structures. </title> <booktitle> In Computer Graphics (SIGGRAPH '80 Proceedings), </booktitle> <volume> volume 14, </volume> <pages> pages 124-133, </pages> <month> July </month> <year> 1980. </year> <month> 94 </month>
Reference-contexts: Visibility determination is closely related to depth sorting of primitives. Once the primitives are ordered in depth, they can be rendered back-to-front for correct visibility. The binary space partitioning (BSP) algorithms <ref> [FKN80] </ref> produce an organization of polygons from which their depth ordering can be quickly derived. More recently, Naylor ([Nay92]) described a algorithm which projects a 3-D BSP tree in object space into a 2D BSP tree in screen space for depth ordering and occlusion culling.
Reference: [GCS91] <author> Ziv Gigus, John Canny, and Raimund Seidel. </author> <title> Efficiently computing and representing aspect graphs of polyhedral objects. </title> <journal> IEEE Transaction on Pattern Matching and Machine Intelligence, </journal> <volume> 13(6), </volume> <year> 1991. </year>
Reference-contexts: At run-time, correct visibility is retrieved from the data structures according to the current view point. Aspect graphs have been extensively investigated in computer vision for applications like object recognition for robots <ref> [GM90, GCS91, PD90, CH92] </ref>. The goal for this research is to characterize changes in aspect, i.e. topological appearance, of surfaces as the viewer moves in space. The changes are called visual events. As an 12 example, Figure 2.5 shows three views of the same tetrahedron.
Reference: [Geo95] <author> C. Georges. </author> <title> Obscuration culling on parallel graphics architectures. </title> <type> TR 95-017, </type> <institution> Department of Computer Science, UNC-Chapel Hill, </institution> <year> 1995. </year>
Reference-contexts: Hardware Z-queries (i.e. whether scan-converting certain primitives yields any visible pixels) are also rarely supported in hardware and can be expensive to perform in a pipelined architecture. <ref> [Geo95] </ref> described an implementation of the above algorithm (but without the z-buffer hierarchy) on a parallel graphics computer (Pixel-Planes 5). 19 2.2.3.6 Hierarchical Polygon Tiling The hierarchical z-buffer algorithm is prone to aliasing problems (i.e. zig-zag polygon edges) because the point sampling used in scan conversion.
Reference: [GK93] <author> Ned Greene and M. Kass. </author> <title> Hierarchical Z-buffer visibility. </title> <booktitle> In Computer Graphics Proceedings, Annual Conference Series, </booktitle> <year> 1993, </year> <pages> pages 231-240, </pages> <year> 1993. </year>
Reference-contexts: In other words, the general effectiveness of these algorithms is limited due to the lack of a representation for cumulative occlusion. 2.2.3.5 Hierarchical Z-Buffer The hierarchical Z-buffer algorithm was presented and improved by Greene in <ref> [GK93, GK94] </ref>. In our terminology, cumulative occlusion is represented by an ordinary z-buffer, which forms the finest level of the Z-pyramid.
Reference: [GK94] <author> Ned Greene and Michael Kass. </author> <title> Error-bounded antialiased rendering of complex environments. </title> <editor> In Andrew Glassner, editor, </editor> <booktitle> Proceedings of SIG-GRAPH '94 (Orlando, </booktitle> <address> Florida, </address> <month> July 24-29, </month> <year> 1994), </year> <booktitle> Computer Graphics Proceedings, Annual Conference Series, </booktitle> <pages> pages 59-66. </pages> <publisher> ACM SIGGRAPH, ACM Press, </publisher> <month> July </month> <year> 1994. </year> <note> ISBN 0-89791-667-0. </note>
Reference-contexts: In other words, the general effectiveness of these algorithms is limited due to the lack of a representation for cumulative occlusion. 2.2.3.5 Hierarchical Z-Buffer The hierarchical Z-buffer algorithm was presented and improved by Greene in <ref> [GK93, GK94] </ref>. In our terminology, cumulative occlusion is represented by an ordinary z-buffer, which forms the finest level of the Z-pyramid.
Reference: [GM90] <author> Ziv Gigus and Jitendra Malik. </author> <title> Computing the aspect graph for the line drawing of polyhedral objects. </title> <journal> IEEE Transaction on Pattern Matching and Machine Intelligence, </journal> <volume> 12(2), </volume> <year> 1990. </year>
Reference-contexts: At run-time, correct visibility is retrieved from the data structures according to the current view point. Aspect graphs have been extensively investigated in computer vision for applications like object recognition for robots <ref> [GM90, GCS91, PD90, CH92] </ref>. The goal for this research is to characterize changes in aspect, i.e. topological appearance, of surfaces as the viewer moves in space. The changes are called visual events. As an 12 example, Figure 2.5 shows three views of the same tetrahedron.
Reference: [Gre96] <author> Ned Greene. </author> <title> Hierarchical polygon tiling with coverage masks. </title> <editor> In Holly Rushmeier, editor, </editor> <booktitle> SIGGRAPH 96 Conference Proceedings, Annual Conference Series, </booktitle> <pages> pages 65-74. </pages> <publisher> ACM SIGGRAPH, Addison Wesley, </publisher> <month> August </month> <year> 1996. </year> <title> held in New Orleans, </title> <address> Louisiana, </address> <month> 04-09 August </month> <year> 1996. </year>
Reference-contexts: In an effort to reduce aliasing, Greene <ref> [Gre96] </ref> presented a hierarchical tiling algorithm using coverage masks. The algorithm combines mask-based hierarchical polygon scan conversion with hierarchical occlusion culling. It employs a hierarchy of tri-valued masks, known as the triage mask pyramid, to hierarchically represent the screen projections of primitives as they are rendered.
Reference: [HMC + 97] <author> T. Hudson, D. Manocha, J. Cohen, M. Lin, K. Hoff, and H. Zhang. </author> <title> Accelerated occlusion culling using shadow frusta. </title> <booktitle> In Proc. of ACM Symposium on Computational Geometry, </booktitle> <pages> pages 1-10, </pages> <year> 1997. </year>
Reference-contexts: However, the resulting algorithm are very memory-intensive and does not scale well to large models. 2.2.3.4 Other Object-Space Approaches Other object-space approaches to occlusion culling have been developed for environments more general than building interiors. Coorg and Teller [CT97] and Hudson et al. <ref> [HMC + 97] </ref>. proposed object-space occlusion culling algorithms for environments with many of large polygonal occluders. <p> These algorithms dynamically choose a subset of polygons as occluders and use them for occlusion culling. [CT97] computed an arrangement corresponding to a linearized portion of an aspect graph; at run-time, they tracked the viewpoint with respect to the arrangement to check for occlusion. <ref> [HMC + 97] </ref> made use of shadow frusta formed by the occluder polygons and the viewpoint. Objects completely inside one of the shadow frusta are culled away.
Reference: [Hop96] <author> Hugues Hoppe. </author> <title> Progressive meshes. </title> <editor> In Holly Rushmeier, editor, </editor> <booktitle> SIG-GRAPH 96 Conference Proceedings, Annual Conference Series, </booktitle> <pages> pages 99-108. </pages> <publisher> ACM SIGGRAPH, Addison Wesley, </publisher> <month> August </month> <year> 1996. </year> <title> held in New Or-leans, </title> <address> Louisiana, </address> <month> 04-09 August </month> <year> 1996. </year>
Reference-contexts: Given a complex object in the original model, 60 we would like to derive from it a simplified version (with fewer polygons) that retains most of the occlusion the original object can provide. This is what we call occlusion preserving simplification. Current geometry simplification algorithms <ref> [Tur92, SZL92, RB93, CVM + 96, Hop96] </ref> operate under the constraint that the simplified object should preserve the shape of the original object to certain fidelity.
Reference: [Hop97] <author> Hugues Hoppe. </author> <title> View-dependent refinement of progressive meshes. </title> <editor> In Turner Whitted, editor, </editor> <booktitle> SIGGRAPH 97 Conference Proceedings, Annual Conference Series, </booktitle> <pages> pages 189-198. </pages> <publisher> ACM SIGGRAPH, Addison Wesley, </publisher> <month> August </month> <year> 1997. </year> <note> ISBN 0-89791-896-7. </note>
Reference-contexts: More recently, view-dependent, dynamic simplification algorithms <ref> [XESV97, LE97, Hop97] </ref> have been proposed to exploit the fact that the silhouette of an object is more important to its appearance than the parts inside the silhouette.
Reference: [Jon71] <author> C. B. Jones. </author> <title> A new approach to the `hidden line' problem. </title> <journal> Computer Journal, </journal> <volume> 14(3) </volume> <pages> 232-237, </pages> <month> August </month> <year> 1971. </year>
Reference-contexts: This is much more difficult than view-frustum or back-face culling. Below we review some major occlusion culling algorithms. 2.2.3.3 Cells and Portals The terms cells and portals were first used by Jones <ref> [Jon71] </ref> in his algorithm for hidden line removal. In his algorithm, the model geometry is subdivided into convex polyhedral cells and convex polygonal portals, so that every polygon in the model belongs to the face of one or more cells.
Reference: [KMGL96] <author> Subodh Kumar, Dinesh Manocha, William Garrett, and Ming Lin. </author> <title> Hierarchical back-face computation. </title> <editor> In Xavier Pueyo and Peter Schroder, editors, </editor> <booktitle> Eurographics Rendering Workshop 1996, </booktitle> <pages> pages 235-244, </pages> <address> New York City, NY, </address> <month> June </month> <year> 1996. </year> <title> Eurographics, </title> <publisher> Springer Wein. </publisher> <address> ISBN 3-211-82883-4. </address> <month> 95 </month>
Reference: [Lat94] <author> R. Latham. </author> <title> Advanced image generator architectures. Course reference material, </title> <year> 1994. </year>
Reference-contexts: Their publications have described algorithms that often bear strong resemblance to those developed separately (and often later) in the computer graphics community. An overview of flight simulator architectures is given in [Mue95]. Most notably, the Singer Company's Modular Digital Image Generator <ref> [Lat94] </ref> renders 20 polygons in front-to-back order using a hierarchy of mask buffers to skip over already covered spans, segments or rows in the image.
Reference: [LE97] <author> David Luebke and Carl Erikson. </author> <title> View-dependent simplification of arbitrary polygonal environments. </title> <editor> In Turner Whitted, editor, </editor> <booktitle> SIGGRAPH 97 Conference Proceedings, Annual Conference Series, </booktitle> <pages> pages 199-208. </pages> <publisher> ACM SIGGRAPH, Addison Wesley, </publisher> <month> August </month> <year> 1997. </year> <note> ISBN 0-89791-896-7. </note>
Reference-contexts: More recently, view-dependent, dynamic simplification algorithms <ref> [XESV97, LE97, Hop97] </ref> have been proposed to exploit the fact that the silhouette of an object is more important to its appearance than the parts inside the silhouette.
Reference: [LG95] <author> David Luebke and Chris Georges. </author> <title> Portals and mirrors: Simple, fast evaluation of potentially visible sets. </title> <editor> In Pat Hanrahan and Jim Winget, editors, </editor> <booktitle> 1995 Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 105-106. </pages> <publisher> ACM SIG-GRAPH, </publisher> <month> April </month> <year> 1995. </year> <note> ISBN 0-89791-736-7. </note>
Reference: [Lor94] <author> Loral. </author> <title> GT200T Level II image generator product overview, </title> <year> 1994. </year>
Reference-contexts: General Electric's COMPU-SCENE PT2000 [BE89] uses a similar algorithm but does not require the input polygons to be rendered in front-to-back order, and the mask buffer is not hierarchical. The Loral GT200 <ref> [Lor94] </ref> first renders near objects and fills in a (possibly hierarchical) mask buffer, which is used to cull away far objects. This is similar to the hierarchical coverage masks used in the hierarchical polygon tiling algorithm.
Reference: [McK87] <author> M. McKenna. </author> <title> Worst-case optimal hidden-surface removal. </title> <journal> ACM Trans. Graph., </journal> <volume> 6 </volume> <pages> 19-28, </pages> <year> 1987. </year>
Reference-contexts: Also, dynamic model changes are a challenge for BSP algorithms. There has been significant research in visible surface computation in computational geometry, and many algorithms have been proposed <ref> [Mul89, McK87] </ref> (see [Dor94] for a recent survey). However, the practical utility of these algorithms is unclear at the moment. 2.2.2 Global Visibility Global visibility algorithms pre-compute visibility information for arbitrary viewer positions in the 3-D space and store it in special data structures.
Reference: [Mue95] <author> C. Mueller. </author> <title> Architectures of image generators for flight simulators. </title> <type> TR 95-015, </type> <institution> Department of Computer Science, UNC-Chapel Hill, </institution> <year> 1995. </year>
Reference-contexts: Their publications have described algorithms that often bear strong resemblance to those developed separately (and often later) in the computer graphics community. An overview of flight simulator architectures is given in <ref> [Mue95] </ref>. Most notably, the Singer Company's Modular Digital Image Generator [Lat94] renders 20 polygons in front-to-back order using a hierarchy of mask buffers to skip over already covered spans, segments or rows in the image.
Reference: [Mul89] <author> K. Mulmuley. </author> <title> An efficient algorithm for hidden surface removal. </title> <journal> Computer Graphics, </journal> <volume> 23(3) </volume> <pages> 379-388, </pages> <year> 1989. </year>
Reference-contexts: Also, dynamic model changes are a challenge for BSP algorithms. There has been significant research in visible surface computation in computational geometry, and many algorithms have been proposed <ref> [Mul89, McK87] </ref> (see [Dor94] for a recent survey). However, the practical utility of these algorithms is unclear at the moment. 2.2.2 Global Visibility Global visibility algorithms pre-compute visibility information for arbitrary viewer positions in the 3-D space and store it in special data structures.
Reference: [Nay92] <author> Bruce F. Naylor. </author> <title> Partitioning tree image representation and generation from 3D geometric models. </title> <booktitle> In Proceedings of Graphics Interface '92, </booktitle> <pages> pages 201-212, </pages> <month> May </month> <year> 1992. </year>
Reference: [NNS72] <author> Martin E. Newell, R. G. Newell, and T. L. Sancha. </author> <title> A solution to the hidden surface problem. </title> <booktitle> In Proc. ACM Nat. Mtg. </booktitle> <year> 1972. </year>
Reference-contexts: The book by Foley et. al. [FDFH90] has a chapter on visible-surface determination that includes most of the algorithms developed so far. Specifically, algorithms for hidden surface removal include visible-line determination [Rob63, App67], the z-buffer (or depth-buffer) algorithm [Cat74], the depth-sort algorithm <ref> [NNS72] </ref>, scan-line algorithms [WREE67, BK70, Bou70, Wat70], area-subdivision algorithms [War69, WA77] and ray-tracing [App68]. Visibility determination is closely related to depth sorting of primitives. Once the primitives are ordered in depth, they can be rendered back-to-front for correct visibility.
Reference: [PD84] <author> Thomas Porter and Tom Duff. </author> <title> Compositing digital images. </title> <editor> In Hank Christiansen, editor, </editor> <booktitle> Computer Graphics (SIGGRAPH '84 Proceedings), </booktitle> <volume> volume 18, </volume> <pages> pages 253-259, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: An occlusion map represents a fusion of occluders in image space. If not rendered directly as proposed above, the occlusion map can be obtained as a by-product of normal rendering. For example, it can be the ff-channel <ref> [PD84] </ref> of a rendered image if alpha values are properly set for the primitives. However, this method results in maps that are at the same resolution of the screen image (e.g. 1280 fi 1024) which is usually too high to process in real time.
Reference: [PD90] <author> H. Plantinga and C. R. Dyer. </author> <title> Visibility, occlusion and the aspect graph. </title> <journal> Internal J. Comput. Vision, </journal> <volume> 5(2) </volume> <pages> 137-160, </pages> <year> 1990. </year>
Reference-contexts: At run-time, correct visibility is retrieved from the data structures according to the current view point. Aspect graphs have been extensively investigated in computer vision for applications like object recognition for robots <ref> [GM90, GCS91, PD90, CH92] </ref>. The goal for this research is to characterize changes in aspect, i.e. topological appearance, of surfaces as the viewer moves in space. The changes are called visual events. As an 12 example, Figure 2.5 shows three views of the same tetrahedron. <p> The 3-D space is subdivided into volumes of constant aspect (i.e. the same topological appearance), separated by boundaries across which visual events occur. The dual of this subdivision is called the aspect graph. <ref> [PD90] </ref> presented algorithms for generating the aspect graph under parallel or perspective projections, for convex or non-convex polyhedra. They also introduced a complex data structure named asp to store the results. [CH92] presented a different aspect graph algorithm for non-convex polyhedra under perspective projections.
Reference: [Poc92] <author> M. Pocchiola. </author> <title> The visibility complex. </title> <booktitle> In Proc. 5th Franco-Japanese Days on Combinatorics and Optimizatio n, page ??, 1992. </booktitle>
Reference-contexts: Solutions to this problem bear much resemblance to the construction of aspect graphs. [TH93] introduced an algorithm which conservatively supports visibility queries between two patches, as well as providing a list of blocking objects between them. The visibility complex <ref> [Poc92, PV95] </ref> stores 2-D global visibility information for "flatland" radiosity (i.e. the imaginary "radiosity" computation among lines on a plane). Its 3-D extension, the 3-D visibility complex [DDP96], is similar to the asp.
Reference: [PV95] <author> M. Pocchiola and G. Vegter. </author> <title> Computing the visibility graph via pseudo-triangulations. </title> <booktitle> In Proc. 11th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 248-257, </pages> <year> 1995. </year>
Reference-contexts: Solutions to this problem bear much resemblance to the construction of aspect graphs. [TH93] introduced an algorithm which conservatively supports visibility queries between two patches, as well as providing a list of blocking objects between them. The visibility complex <ref> [Poc92, PV95] </ref> stores 2-D global visibility information for "flatland" radiosity (i.e. the imaginary "radiosity" computation among lines on a plane). Its 3-D extension, the 3-D visibility complex [DDP96], is similar to the asp.
Reference: [RB93] <author> J. Rossignac and P. Borrel. </author> <title> Multi-resolution 3D approximation for rendering complex scenes. </title> <booktitle> In Second Conference on Geometric Modelling in Computer Graphics, </booktitle> <pages> pages 453-465, </pages> <month> June </month> <year> 1993. </year> <institution> Genova, Italy. </institution> <month> 96 </month>
Reference-contexts: Given a complex object in the original model, 60 we would like to derive from it a simplified version (with fewer polygons) that retains most of the occlusion the original object can provide. This is what we call occlusion preserving simplification. Current geometry simplification algorithms <ref> [Tur92, SZL92, RB93, CVM + 96, Hop96] </ref> operate under the constraint that the simplified object should preserve the shape of the original object to certain fidelity.
Reference: [RH94] <author> John Rohlf and James Helman. IRIS performer: </author> <title> A high performance multiprocessing toolkit for real-Time 3D graphics. </title> <editor> In Andrew Glassner, editor, </editor> <booktitle> Proceedings of SIGGRAPH '94 (Orlando, </booktitle> <address> Florida, </address> <month> July 24-29, </month> <year> 1994), </year> <booktitle> Computer Graphics Proceedings, Annual Conference Series, </booktitle> <pages> pages 381-395. </pages> <publisher> ACM SIGGRAPH, ACM Press, </publisher> <month> July </month> <year> 1994. </year> <note> ISBN 0-89791-667-0. </note>
Reference-contexts: Pipelining is an important technique for the acceleration of graphics applications. Pipelining has been extensively used both at the software application level (e.g. by the Iris Performer <ref> [RH94] </ref>) and inside the graphics hardware (e.g. [AJ88]). For our two-pass occlusion culling framework (section 3.2), we are interested in software pipelining schemes for the parallelization of the application pipeline, and regard the hardware pipeline as a blackbox to which we send graphics primitives. <p> Also, we assume that there is only one hardware pipe, which is the case for most commercial graphics platforms. Rohlf and Helman <ref> [RH94] </ref> described an App-Cull-Draw pipeline that includes three parallel stages. The App stage performs application-specific processing (numerical simulations, modifications to the scene, etc.), the Cull stage involves view-frustum culling, and the Draw stage issues graphics commands to the graphics hardware to finally render the polygons.
Reference: [Rob63] <author> Lawrence G. Roberts. </author> <title> Machine perception of three-dimensional solids. </title> <type> TR 315, </type> <institution> Lincoln Lab, MIT, Lexington, </institution> <address> MA, </address> <month> May </month> <year> 1963. </year>
Reference-contexts: Sutherland et. al. [SSS74] presents a characterization of the algorithms. The book by Foley et. al. [FDFH90] has a chapter on visible-surface determination that includes most of the algorithms developed so far. Specifically, algorithms for hidden surface removal include visible-line determination <ref> [Rob63, App67] </ref>, the z-buffer (or depth-buffer) algorithm [Cat74], the depth-sort algorithm [NNS72], scan-line algorithms [WREE67, BK70, Bou70, Wat70], area-subdivision algorithms [War69, WA77] and ray-tracing [App68]. Visibility determination is closely related to depth sorting of primitives. Once the primitives are ordered in depth, they can be rendered back-to-front for correct visibility.
Reference: [(SO94] <author> J. C. Chauvin (SOGITEC). </author> <title> An advanced z-buffer technology. </title> <booktitle> In IMAGE VII, </booktitle> <pages> pages 76-85, </pages> <year> 1994. </year>
Reference: [SSS74] <author> I. E. Sutherland, R. F. Sproull, and R. A. Schumacker. </author> <title> A characterization of ten hidden-surface algorithms. </title> <journal> Journal of the ACM, </journal> <month> March </month> <year> 1974. </year> <note> summarized in "Naval Research Reviews", </note> <month> June </month> <year> 1975, </year> <pages> pp. 21-23. </pages>
Reference-contexts: Given a geometric model (most often a collection of polygons) and the viewing parameters, hidden surface algorithms find out which surfaces or parts of surfaces are visible to the viewer. Sutherland et. al. <ref> [SSS74] </ref> presents a characterization of the algorithms. The book by Foley et. al. [FDFH90] has a chapter on visible-surface determination that includes most of the algorithms developed so far.
Reference: [SZL92] <author> William J. Schroeder, Jonathan A. Zarge, and William E. Lorensen. </author> <title> Decimation of triangle meshes. </title> <editor> In Edwin E. Catmull, editor, </editor> <booktitle> Computer Graphics (SIGGRAPH '92 Proceedings), </booktitle> <volume> volume 26, </volume> <pages> pages 65-70, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Given a complex object in the original model, 60 we would like to derive from it a simplified version (with fewer polygons) that retains most of the occlusion the original object can provide. This is what we call occlusion preserving simplification. Current geometry simplification algorithms <ref> [Tur92, SZL92, RB93, CVM + 96, Hop96] </ref> operate under the constraint that the simplified object should preserve the shape of the original object to certain fidelity.
Reference: [TH93] <author> Seth Teller and Pat Hanrahan. </author> <title> Global visibility algorithms for illumination computations. </title> <booktitle> In Computer Graphics Proceedings, Annual Conference Series, </booktitle> <year> 1993, </year> <pages> pages 239-246, </pages> <year> 1993. </year>
Reference-contexts: Form-factor computation in radiosity algorithms (for simulating global diffuse illumination) requires global visibility information among pairs of patches. Solutions to this problem bear much resemblance to the construction of aspect graphs. <ref> [TH93] </ref> introduced an algorithm which conservatively supports visibility queries between two patches, as well as providing a list of blocking objects between them. The visibility complex [Poc92, PV95] stores 2-D global visibility information for "flatland" radiosity (i.e. the imaginary "radiosity" computation among lines on a plane).
Reference: [TP75] <author> S. L. Tanimoto and Theo Pavlidis. </author> <title> A hierarchical data structure for picture processing. </title> <journal> Computer Graphics and Image Processing, </journal> <volume> 4(2) </volume> <pages> 104-119, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: Such blocks are often formed hierarchically in a quad-tree structure, with tree nodes at different levels representing different block sizes. The quad-tree is commonly called an image pyramid <ref> [TP75] </ref>. Image pyramids are typically employed for analyzing and accessing images in multiple resolutions. The pyramid supports viewing of the scene at a higher, more 15 general level (i.e. through a larger aperture or at a greater distance), with the details "smoothed out" but global features preserved.
Reference: [TS91] <author> Seth J. Teller and Carlo H. Sequin. </author> <title> Visibility preprocessing for interactive walkthroughs. </title> <editor> In Thomas W. Sederberg, editor, </editor> <booktitle> Computer Graphics (SIGGRAPH '91 Proceedings), </booktitle> <volume> volume 25, </volume> <pages> pages 61-69, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: In such environments, the visibility problem is reduced to computing cell-to-cell visibility, by considering sequences of portals. Airey suggested multiple way to precompute cell-to-cell visibility, including shooting random rays from the portals and using shadow volumes. Teller et. al. <ref> [TS91] </ref> characterized cell-to-cell visibility as a linear programming problem and gave a closed-form analytical solution. In both approaches, cell-to-cell visibility is computed and stored as preprocessing; the time and storage space required by the preprocessing tend to be excessive for large models.
Reference: [Tur92] <author> Greg Turk. </author> <title> Re-tiling polygonal surfaces. </title> <editor> In Edwin E. Catmull, editor, </editor> <booktitle> Computer Graphics (SIGGRAPH '92 Proceedings), </booktitle> <volume> volume 26, </volume> <pages> pages 55-64, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Given a complex object in the original model, 60 we would like to derive from it a simplified version (with fewer polygons) that retains most of the occlusion the original object can provide. This is what we call occlusion preserving simplification. Current geometry simplification algorithms <ref> [Tur92, SZL92, RB93, CVM + 96, Hop96] </ref> operate under the constraint that the simplified object should preserve the shape of the original object to certain fidelity.
Reference: [WA77] <author> K. Weiler and K. Atherton. </author> <title> Hidden surface removal using polygon area sorting. </title> <booktitle> Computer Graphics (SIGGRAPH '77 Proceedings), </booktitle> <volume> 11(2) </volume> <pages> 214-222, </pages> <month> July </month> <year> 1977. </year>
Reference-contexts: Specifically, algorithms for hidden surface removal include visible-line determination [Rob63, App67], the z-buffer (or depth-buffer) algorithm [Cat74], the depth-sort algorithm [NNS72], scan-line algorithms [WREE67, BK70, Bou70, Wat70], area-subdivision algorithms <ref> [War69, WA77] </ref> and ray-tracing [App68]. Visibility determination is closely related to depth sorting of primitives. Once the primitives are ordered in depth, they can be rendered back-to-front for correct visibility.
Reference: [War69] <author> J. Warnock. </author> <title> A hidden-surface algorithm for computer generated halftone pictures. </title> <type> Technical Report TR 4-15, </type> <institution> NTIS AD-733 671, University of Utah, Computer Science Department, </institution> <year> 1969. </year>
Reference-contexts: Specifically, algorithms for hidden surface removal include visible-line determination [Rob63, App67], the z-buffer (or depth-buffer) algorithm [Cat74], the depth-sort algorithm [NNS72], scan-line algorithms [WREE67, BK70, Bou70, Wat70], area-subdivision algorithms <ref> [War69, WA77] </ref> and ray-tracing [App68]. Visibility determination is closely related to depth sorting of primitives. Once the primitives are ordered in depth, they can be rendered back-to-front for correct visibility.
Reference: [Wat70] <author> G. S. Watkins. </author> <title> A real time visible surface algorithm. </title> <type> Technical Report UTEC-CSc-70-101, </type> <institution> NTIS AD-762 004, Computer Science Department, University of Utah, </institution> <address> Salt Lake City, UT, </address> <month> June </month> <year> 1970. </year> <month> 97 </month>
Reference-contexts: The book by Foley et. al. [FDFH90] has a chapter on visible-surface determination that includes most of the algorithms developed so far. Specifically, algorithms for hidden surface removal include visible-line determination [Rob63, App67], the z-buffer (or depth-buffer) algorithm [Cat74], the depth-sort algorithm [NNS72], scan-line algorithms <ref> [WREE67, BK70, Bou70, Wat70] </ref>, area-subdivision algorithms [War69, WA77] and ray-tracing [App68]. Visibility determination is closely related to depth sorting of primitives. Once the primitives are ordered in depth, they can be rendered back-to-front for correct visibility.
Reference: [Wil83] <author> Lance Williams. Pyramidal parametrics. </author> <booktitle> In Computer Graphics (SIG--GRAPH '83 Proceedings), </booktitle> <volume> volume 17, </volume> <pages> pages 1-11, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: The pyramid supports viewing of the scene at a higher, more 15 general level (i.e. through a larger aperture or at a greater distance), with the details "smoothed out" but global features preserved. An examples of this is the use of mip-maps <ref> [Wil83] </ref>, or hierarchical textures, to alleviate aliasing in texturing an object at different distances. Burt [Bur88] designed and implemented the Pyramid Vision Machine based on the hierarchical (pyramidal) representation of images.
Reference: [WREE67] <author> C. Wylie, G. W. Romney, D. C. Evans, and A. C. Erdahl. </author> <title> Halftone perspective drawing by computer. </title> <booktitle> In FJCC, </booktitle> <pages> pages 49-58, </pages> <address> Washington, DC, </address> <year> 1967. </year>
Reference-contexts: The book by Foley et. al. [FDFH90] has a chapter on visible-surface determination that includes most of the algorithms developed so far. Specifically, algorithms for hidden surface removal include visible-line determination [Rob63, App67], the z-buffer (or depth-buffer) algorithm [Cat74], the depth-sort algorithm [NNS72], scan-line algorithms <ref> [WREE67, BK70, Bou70, Wat70] </ref>, area-subdivision algorithms [War69, WA77] and ray-tracing [App68]. Visibility determination is closely related to depth sorting of primitives. Once the primitives are ordered in depth, they can be rendered back-to-front for correct visibility.
Reference: [XESV97] <author> Julie C. Xia, Jihad El-Sana, and Amitabh Varshney. </author> <title> Adaptive real-time level-of-detail-based rendering for polygonal models. </title> <journal> IEEE Transactions on Visualization and Computer Graphics, </journal> <volume> 3(2), </volume> <month> April-June </month> <year> 1997. </year> <pages> ISSN 1077-2626. </pages>
Reference-contexts: More recently, view-dependent, dynamic simplification algorithms <ref> [XESV97, LE97, Hop97] </ref> have been proposed to exploit the fact that the silhouette of an object is more important to its appearance than the parts inside the silhouette.
Reference: [YR96] <author> R. Yagel and W. Ray. </author> <title> Visibility computations for efficient walkthrough of complex environments. </title> <journal> Presence, </journal> <volume> 5(1) </volume> <pages> 1-16, </pages> <year> 1996. </year> <month> 98 </month>
Reference-contexts: The above techniques are restricted to environments that can be divided into cells and portals. They are not very effective for outdoor, open-space scenes and other non-architectural models. Other algorithms for densely-occluded but somewhat less-structured models have been proposed by Yagel and Ray <ref> [YR96] </ref>. They used regular spatial subdivision to partition the model into cells. However, the resulting algorithm are very memory-intensive and does not scale well to large models. 2.2.3.4 Other Object-Space Approaches Other object-space approaches to occlusion culling have been developed for environments more general than building interiors.
References-found: 62

