URL: ftp://nezz.cs.stir.ac.uk/pub/papers/GH-13.ps.gz
Refering-URL: http://www.gh.cs.su.oz.au/Grasshopper/Papers/Papers.html
Root-URL: 
Email: al@cs.stir.ac.uk  dave@cs.adelaide.edu.au  
Title: On Page-based Optimistic Process Checkpointing  
Author: Alan Dearle David Hulse 
Address: Stirling, FK9 4LA, Scotland  Adelaide, S.A., 5005, Australia  
Affiliation: Department of Computing Science University of Stirling,  Department of Computer Science University of  
Abstract: Persistent object systems must provide some form of checkpointing to ensure that changes to persistent data are secured on nonvolatile storage. When processes share or exchange modified data, mechanisms must be provided to ensure that they may be consistently checkpointed. This may be performed eagerly by synchronously checkpointing all dependent data. Alternatively, optimistic techniques may be used where processes are individually checkpointed and globally consistent states are found asynchronously. This paper examines two eager checkpointing techniques and describes a new optimistic technique. The technique is applicable in systems such as SASOS, where the notion of process and address space are decoupled. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Challis, M. F. </author> <title> Database Consistency and Integrity in a MultiUser Environment, Databases: </title> <publisher> Improving Usability and Responsiveness , Academic Press, </publisher> <pages> pp. 245-270, </pages> <year> 1978. </year>
Reference-contexts: New checkpoints must be established with care, as they must not endanger the integrity of the previous checkpoint. In many persistent systems this is achieved using a shadow paging technique [13] combined with an atomic commit operation <ref> [1] </ref>. When shadow paging is employed, a dirty page never overwrites a clean version of a page in the stable store. Instead, dirty pages are written to another location (the shadow), with these copies of the pages being known as shadow copies.
Reference: 2. <author> Chase, J. and Levy, H. </author> <title> Sharing and Protection in a Single Address Space Operating System, </title> <journal> Transactions on Computer Systems, </journal> <volume> vol 12, 2, </volume> <pages> pp. </pages> <note> to appear, </note> <year> 1994. </year>
Reference-contexts: Consequently, there is no 1-1 correspondence between processes and address spaces as there is in Unix. This computational model is similar to that found in SASOS <ref> [2] </ref>, and Grasshopper may be considered to be a superset of the SASOS approach [12].
Reference: 3. <author> Dearle, A., Bona, R. d., Farrow, J., Henskens, F., Lindstrm, A., Rosenberg, J. and Vaughan, F. Grasshopper: </author> <title> An Orthogonally Persistent Operating System, </title> <booktitle> Computer Systsms, vol Summer, </booktitle> <year> 1994. </year>
Reference-contexts: Notice that the stable state of process P2 cannot become part of a globally consistent state until P1 performs a checkpoint. with Vector Times 6. Implementation Considerations We are currently implementing the mechanisms described in this paper in the context of the Grasshopper operating system <ref> [3] </ref>. Indeed, the motivation for this work was to improve checkpointing in Grasshopper. In Grasshopper, all processes (loci in Grasshopper parlance) execute in the context of persistent data repositories called containers, and may access any data from any container for which they hold a capability.
Reference: 4. <author> Elnozahy, E., Johnson, D. and Zwaenepoel, W. </author> <title> The Performance of Consistent Checkpointing, </title> <booktitle> 11th Symposium on Reliable Distributed Systems , Houston, Texas, IEEE, </booktitle> <pages> pp. 39-47, </pages> <year> 1992. </year>
Reference-contexts: However, the third approach requires some policy, such as eager checkpointing, to ensure that globally consistent states may always be found. The use of copy-on-write techniques to protect RAM resident pages from modification may be used to optimise any of these techniques, sometimes with great effect <ref> [4] </ref>. Wu and Fuchs [18] describe a hardware implementation of the first approach in which processes are prevented from sharing modified data. This is achieved by forcing processes to perform checkpoint operations as soon as another client requests the use of any updated data.
Reference: 5. <author> Fidge, C. </author> <title> Timestamps in Message-Passing Systems That Preserve Partial Ordering, </title> <booktitle> 11th Australian Computer Science Conference, University of Queensland, </booktitle> <pages> pp. 56-66, </pages> <year> 1988. </year>
Reference-contexts: Checkpointing of individual proce sses and objects may be per formed independently provided that consistent cuts can later be found. It has been shown by Schwarz and Mattern [16] that vector time <ref> [5] </ref> may be used to characterise consistent cuts. In systems that employ vector time, each entity maintains a time vector, in which the elements represent knowledge about other entities within the system.
Reference: 6. <author> Henskens, F. A., Rosenberg, J. and Keedy, J. L. </author> <title> A Capability-based Distributed Shared Memory, </title> <booktitle> Proceedings of the 14th Australian Computer Science Conference, </booktitle> <address> Sydney, Australia, </address> <pages> pp. </pages> <address> 29.1-29.12, </address> <year> 1991. </year>
Reference-contexts: The simplest approach to global consistency is to enforce system wide simultaneous checkpoint in which the kernel (s) block all executing processes and copy modified data to some stable medium. This approach has been implemented in the Monads system <ref> [6] </ref>. The disadvantages of this approach are: the entire system freezes whilst the stabilise occurs, and the technique does not scale well. There are three basic alternatives to this approach: 1.
Reference: 7. <author> Jalili, R. and Henskens, F. A. </author> <title> Using Directed Graphs to Describe Entity Dependency in Stable Distributed Persistent Stores, </title> <booktitle> Hawaii International Conference on System Sciences , 1994. </booktitle>
Reference-contexts: Synchronous Checkpointing In this section we describe two synchronous approaches to checkpoint formation. The systems examined are the CASPER system [17] and a system developed by Jalili and Henskens <ref> [7] </ref> used in the Monads system [15]. <p> This observation has lead to a refinement of the associations concept based on the maintenance of directed dependency graphs. 3.2 Directed Dependency Graphs Like the CASPER system, the system described by Jalili and Henskens <ref> [7] </ref> tracks page reads and writes. The information gathered is used to construct directed dependency graphs (DDGs) rather than simple associations. A process may perform one of three operations on a page: 1.
Reference: 8. <author> Johnson, D. </author> <title> Efficient Transparent Optimistic Recovery for Distributed Application Systems, </title> <institution> Computer Science, Carnegie Mellon University, </institution> <type> Technical Report CMU-CS-93-127, </type> <year> 1993. </year>
Reference-contexts: This intuitively states that no entity depends upon an event that happened after the consistent cut was established. Whilst the algorithm of Johnson and Zwaenepoel is centralised, Johnson has developed a similar algorithm that may be applied in a distributed environment <ref> [8] </ref>. 3. Synchronous Checkpointing In this section we describe two synchronous approaches to checkpoint formation. The systems examined are the CASPER system [17] and a system developed by Jalili and Henskens [7] used in the Monads system [15].
Reference: 9. <author> Johnson, D. and Zwaenepoel, W. </author> <title> Recovery in Distributed Systems Using Optimistic Message Logging and Checkpointing, </title> <journal> Journal of Algorithms, </journal> <volume> vol 11, 3, </volume> <pages> pp. 462-491, </pages> <year> 1990. </year>
Reference-contexts: Whenever a message is sent to another entity, the sender's vector is transmitted with the message. Upon receipt of a message, the receiving entity updates its own vector by constructing the piecewise maximum of its own and the sender's vector. Johnson and Zwaenepoel <ref> [9] </ref> describe a technique for finding consistent cuts which involves the construction of a dependency matrix whose rows correspond to the vector times of all entities in the system. They show that a dependency matrix M represents a consistent cut iff, "i,j Mij Mjj. <p> Each individual checkpoint has an associated vector time which permits consistent cuts to be found optimistically. The manner in which this is performed is beyond the scope of this paper, however the techniques described by Johnson and Zwaenepoel <ref> [9] </ref> would satisfy this requirement. Jalili and Henskens use virtual page invalidation to impose an ordering on events to ensure a high degree of accuracy in causal tracking. In contrast, our technique tolerates an inexact ordering of events to improve performance.
Reference: 10. <author> Lamport, L. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System, </title> <journal> CACM, </journal> <volume> vol 21, 7, </volume> <pages> pp. 558-565, </pages> <year> 1978. </year>
Reference-contexts: Causality and Causal Histories The notion of the causal history of a process is central to process checkpointing. Causality can intuitively be defined in terms of some entity being in some way dependent upon the state of another. Formally, causality may be defined in terms of the happened-before relation <ref> [10] </ref>.
Reference: 11. <author> Lindstrom, A., Dearle, A., Bona, R. d., Farrow, J., Henskens, F., Rosenberg, J. and Vaughan, F. </author> <title> A Model For User-Level Memory Management in a Distributed, Persistent Environment, </title> <booktitle> 17th Australian Computer Science Conference in, Australian Computer Science Communications, </booktitle> <volume> vol 16, </volume> <pages> pp. 343-354, </pages> <year> 1994. </year>
Reference-contexts: In both SASOS systems and systems like Grasshopper, mechanisms such as those described in this paper must be used in order to track page accesses if checkpoints are to take place on any granularity finer than all of RAM. The vanilla Grasshopper memory management system provides no such support <ref> [11] </ref>, and therefore gives a good baseline for the costs involved in this form of causality tracking. In Grasshopper, each process (locus) is represented by a kernel level data structure, the address of which is used internally by the kernel to uniquely identify the process.
Reference: 12. <author> Lindstrom, A., Rosenberg, J. and Dearle, A. </author> <title> The Grand Unified Theory of Address Spaces, </title> <booktitle> Hot Topics in Operating Systems (HotOS-V) , Seattle, </booktitle> <year> 1995. </year>
Reference-contexts: Consequently, there is no 1-1 correspondence between processes and address spaces as there is in Unix. This computational model is similar to that found in SASOS [2], and Grasshopper may be considered to be a superset of the SASOS approach <ref> [12] </ref>. In both SASOS systems and systems like Grasshopper, mechanisms such as those described in this paper must be used in order to track page accesses if checkpoints are to take place on any granularity finer than all of RAM.
Reference: 13. <author> Lorie, R. A. </author> <title> Physical Integrity in a Large Segmented Database, </title> <journal> Association for Computing Machinery Transactions on Database Systems , vol 2, </journal> <volume> 1, </volume> <pages> pp. 91 - 104, </pages> <year> 1977. </year>
Reference-contexts: New checkpoints must be established with care, as they must not endanger the integrity of the previous checkpoint. In many persistent systems this is achieved using a shadow paging technique <ref> [13] </ref> combined with an atomic commit operation [1]. When shadow paging is employed, a dirty page never overwrites a clean version of a page in the stable store. Instead, dirty pages are written to another location (the shadow), with these copies of the pages being known as shadow copies.
Reference: 14. <author> Mattern, F. </author> <title> Efficient Distributed Snapshots and Global Virtual Time Algorithms for Non-FIFO Systems, </title> <year> 1990. </year>
Reference-contexts: Formally, such a state is termed a consistent cut which is a subset of the events which comprise the system such that, if e is an element of the consistent cut and e ' fi e then e ' is also an element of the cut <ref> [14] </ref>. Graphically, consistent cuts are easily conveyed as a line drawn downwards through a time diagram partitioning the diagram into two parts with the past on the left and the future on the right.
Reference: 15. <author> Rosenberg, J. and Abramson, D. A. MONADS-PC: </author> <title> A Capability Based Workstation to Support Software Engineering, </title> <booktitle> 18th Hawaii International Conference on System Sciences , pp. </booktitle> <pages> 515-522, </pages> <year> 1985. </year>
Reference-contexts: Synchronous Checkpointing In this section we describe two synchronous approaches to checkpoint formation. The systems examined are the CASPER system [17] and a system developed by Jalili and Henskens [7] used in the Monads system <ref> [15] </ref>.
Reference: 16. <author> Schwarz, R. and Mattern, F. </author> <title> Detecting Causal Relationships in Distributed Computations: In Search of The Holy Grail, </title> <institution> Department of Computer Science, University of Kaiserslautern and University of Saarland, </institution> <type> Technical Report SFB 124-15/92, </type> <year> 1992. </year>
Reference-contexts: The intersection of the cut line and a process time line represents the time at which a checkpoint was made. Checkpointing of individual proce sses and objects may be per formed independently provided that consistent cuts can later be found. It has been shown by Schwarz and Mattern <ref> [16] </ref> that vector time [5] may be used to characterise consistent cuts. In systems that employ vector time, each entity maintains a time vector, in which the elements represent knowledge about other entities within the system.
Reference: 17. <author> Vaughan, F., Schunke, T., Koch, B., Dearle, A., Marlin, C. and Barter, C. Casper: </author> <title> A Cached Architecture Supporting Persistence, </title> <booktitle> Computing Systems , vol 5, 3, </booktitle> <address> California, </address> <year> 1992. </year>
Reference-contexts: Whilst the algorithm of Johnson and Zwaenepoel is centralised, Johnson has developed a similar algorithm that may be applied in a distributed environment [8]. 3. Synchronous Checkpointing In this section we describe two synchronous approaches to checkpoint formation. The systems examined are the CASPER system <ref> [17] </ref> and a system developed by Jalili and Henskens [7] used in the Monads system [15]. <p> Each of these systems eagerly finds consistent cuts by determining which processes and data are causally dependent upon each other's state, and forces these to checkpoint synchronously, leaving the other processes and data unaffected. 3.1 CASPER The CASPER system <ref> [17] </ref> supports persistent distributed shared memory over a set of client processes which run on individual workstations. In CASPER, only those subsets of clients that share modified data must stabilise together. Such interdependent clients are termed associates and a set of mutually dependent clients an association.
Reference: 18. <author> Wu, K.-L. and Fuchs, W. K. </author> <title> Recoverable Distributed Shared Virtual Memory, </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol 39, 4, </volume> <pages> pp. 460-469, </pages> <year> 1990. </year>
Reference-contexts: The use of copy-on-write techniques to protect RAM resident pages from modification may be used to optimise any of these techniques, sometimes with great effect [4]. Wu and Fuchs <ref> [18] </ref> describe a hardware implementation of the first approach in which processes are prevented from sharing modified data. This is achieved by forcing processes to perform checkpoint operations as soon as another client requests the use of any updated data.
References-found: 18

