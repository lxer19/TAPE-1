URL: http://www.cs.utah.edu/~cs686/Previous/a97/oo-opt.ps
Refering-URL: http://www.cs.utah.edu/~cs686/Previous/a97/
Root-URL: 
Abstract: 1 Abstract: Two promising optimization techniques for object-oriented languages are type feedback (profile-based receiver class prediction) and concrete type inference (static analysis). We directly compare the two techniques, evaluating their effectiveness on a suite of 23 SELF programs while keeping other factors constant. Our results show that both systems inline over 95% of all sends and deliver similar overall performance with one exception: SELFs automatic coercion of machine integers to arbitrary-precision integers upon overow confounds type inference and slows down arithmetic-intensive benchmarks. We discuss several other issues which, given the comparable run-time performance, may inuence the choice between type feedback and type inference. 
Abstract-found: 1
Intro-found: 1
Reference: [Age94] <author> Ole Agesen. </author> <title> Constraint-Based Type Inference and Parametric Polymorphism. </title> <booktitle> In SAS 94, First International Static Analysis Symposium, p. </booktitle> <pages> 78-100, </pages> <address> Namur, Belgium, Sept. 1994. </address> <publisher> Springer-Verlag (LNCS 864). </publisher>
Reference-contexts: Expressed in terms of templates, polyvariance means that several templates are created for a single method, with different sends invoking the method being routed to different templates. Several polyvariance strategies, varying widely in precision and efficiency, have been proposed; see <ref> [Age94] </ref> for an overview.
Reference: [AU94] <author> Ole Agesen and David Ungar. </author> <title> Sifting Out the Gold: Delivering Compact Applications from an Object-Oriented Exploratory Programming Environment. </title> <booktitle> In OOPSLA 94, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 355-370, </pages> <address> Portland, OR, </address> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: The interface between the two systems is a snapshot (image) containing a type-annotated benchmark program. We first modified the application extractor, described in <ref> [AU94] </ref>, to output benchmark programs together with their type information. The normal functionality of the extractor is to identify a set of methods and objects that are sufficient to run a given application and write them out as SELF source code. <p> Since so many different aspects inuence space usage, we are not convinced that either system is inherently more space-efficient. Of course, type inference can significantly reduce program size through its use in program extraction <ref> [AU94] </ref>. However, program extraction is performed in a separate step and can easily be used for application delivery with a type feedback based system (in fact, this is what our experimental implementation does). Source code protection.
Reference: [Age95] <author> Ole Agesen. </author> <title> The Cartesian Product Algorithm: Simple and Precise Type Inference of Parametric Polymorphism. </title> <booktitle> In ECOOP 95, Ninth European Conference on Object-Oriented Programming, </booktitle> <address> rhus, Denmark, </address> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: Several polyvariance strategies, varying widely in precision and efficiency, have been proposed; see [Age94] for an overview. The strategy used in this paper, the Cartesian product algorithm <ref> [Age95] </ref>, computes the Cartesian product of the actual argument types and analyzes each combination separately. 2.5 Summary and Comparison Both type feedback and type inference operate with types that are sets of classes, and both systems produce types that are approximations. However, the approximations differ in nature. <p> Using the template array and several auxiliary arrays, the compiler searches for applicable method templates whenever it compiles a particular source method. In general, the type inferencer may generate more than one template per method, each of them for a particular combination of receiver or argument types <ref> [Age95] </ref>. Using its internal type information about the methods receiver and arguments, the compiler discards all templates that do not match (e.g., because they specify an incompatible receiver or argument type). <p> Obviously, inserting a global analysis into an edit-compile-run loop (or the edit-continue loop of the SELF system) will not go unnoticed by the programmer. The SELF type inference system supports incremental recomputation of the types when a previously analyzed program is modified locally <ref> [Age95] </ref>. While an incremental re-analysis is often an order of magnitude faster than a full analysis, it is still slower than the typical sub-second compile pauses of type feedback.
Reference: [AH95] <author> Ole Agesen and Urs Hlzle. </author> <title> Type Feedback vs. Concrete Type Inference: A Comparison of Optimization Techniques for Object-Oriented Languages. </title> <type> Technical Report TRCS95-04, </type> <institution> University of California, Santa Barbara, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Because the programs in the Large suite are the most realistic, we will examine their behavior in detail throughout this paper while summarizing the programs in the other two sets. Full data on all benchmarks is given in <ref> [AH95] </ref>. To illustrate the various effects and trade-offs of type inference and type feedback, we measured several systems (see Table 2). The first two systems use type inference. <p> Unless mentioned otherwise, all data in this paper are dynamic, i.e., take the relative execution frequencies of sends into account. To streamline the exposition, we usually give only summary charts in the main text, but detailed data can be found in <ref> [AH95] </ref>. a Approx. lines of code, excluding code in standard classes such as integer, lists, etc. All line counts exclude blank lines. b Lines of code that type inference shows to be part of the application, e.g., including methods in standard data types such as lists, arrays, etc. <p> The graph exaggerates the differences between the systems somewhat since the absolute number of calls is often small. For example, the seemingly large relative difference in DeltaBlue represents an absolute difference of less that 90,000 calls (see <ref> [AH95] </ref>) and thus has very little effect on performance given the overall execution time. The SELF system implements all dispatches via type test sequences which sequentially compare the receiver against predicted classes. <p> On average, TI performs 8% more dispatches than TF, and Bubble even shows a disturbing 40% difference to TF (see <ref> [AH95] </ref> for detailed numbers). What is going on? The reason for the additional dispatch tests is subtle and requires a discussion of some details of the SELF-93 optimizing compiler. One of the optimizations it performs is message splitting [CU90]. Splitting avoids dispatches by copying parts of the control ow graph. <p> While Figure 10 also hints at a difference between TF and TI (with TI having a higher fraction of SELF++ dispatches), a closer look at the data reveals that while TIs variance is much higher, its mean and median arent that different from TF (see <ref> [AH95] </ref>). Based on this observation, we do not believe that the data indicates a significant difference between TF and TI in this respect.
Reference: [APS93] <author> Ole Agesen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Type Inference of SELF: Analysis of Objects with Dynamic and Multiple Inheritance. </title> <booktitle> In ECOOP 93, Seventh European Conference on Object-Oriented Programming, p. </booktitle> <pages> 247-267, </pages> <address> Kaiserslautern, Germany, </address> <month> July </month> <year> 1993. </year> <note> Springer-Verlag (LNCS 707). </note>
Reference-contexts: On the other hand, when compiling the statements j: i. i: i + j the compiler will test js class even if a simple dataow analysis would reveal that j is equal to i. 2.4 Type inference Concrete type inference or constraint-based analysis <ref> [PS91, APS93, PC94a] </ref>, unlike type feedback, does not rely on executing the program. Given the program source, this global analysis will statically compute a type for every expression in the program.
Reference: [CGZ94] <author> Brad Calder, Dirk Grunwald, and Benjamin Zorn. </author> <title> Quantifying Behavioral Differences Between C and C++ Programs. </title> <journal> Journal of Programming Languages 4(2), </journal> <month> Dec. </month> <year> 1994. </year>
Reference: [CUL89] <author> Craig Chambers, David Ungar, and Elgin Lee. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In OOPSLA 89, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 49-70, </pages> <address> New Orleans, LA, </address> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: Thus, the type inferencer benefits from the same local analysis that the standard system uses, so that the two can be fairly compared. Two limitations currently affect the type inference based compiler. The SELF virtual machine requires that all methods be customized to their receiver <ref> [CUL89] </ref>; thus, methods will be customized to a specific receiver even if the type inferencer does not require it. <p> Examples include sends where type inference determined a single receiver class (but did not inline the send), or implicit-self sends (which require no dispatch because of customization <ref> [CUL89] </ref>). 8 of message sends on almost all programs. The reason for this parity in inlining performance is simple: both systems have enough type information to inline virtually all sends. <p> SELF compilers were the first ones to use type feedback for object-oriented programs [HCU91], [HU94a]. Other systems have used some form of runtime type information for optimization. For example, Mitchells system [Mit70] specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization <ref> [CUL89] </ref>). Similarly, several APL compilers created specialized code for certain expressions (e.g. [Dyk77, GW78, Joh79]). The HP APL compiler [Dyk77] specialized compiled code according to the specific operand types (number of dimensions, size of each dimension, element type, etc.).
Reference: [CU90] <author> Craig Chambers and David Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <booktitle> In Proceedings of the SIGPLAN 90 Conference on Programming Language Design and Implementation, p. </booktitle> <pages> 150-164, </pages> <address> White Plains, NY, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: What is going on? The reason for the additional dispatch tests is subtle and requires a discussion of some details of the SELF-93 optimizing compiler. One of the optimizations it performs is message splitting <ref> [CU90] </ref>. Splitting avoids dispatches by copying parts of the control ow graph. In the code shown in the left half of Figure 7, the send of area requires a dispatch since its receiver could be either a circle or a square. <p> However, no data was given about the effectiveness of this approach. The SELF-91 compiler used iterative type analysis to eliminate dispatches <ref> [CU90] </ref>. Like the SELF-93 compiler used here, its analysis was local, i.e., restricted to a single method and the methods inlined in it. However, its local analysis was significantly more powerful than the simple analysis used in SELF-93.
Reference: [DGC95] <author> Jeffrey Dean, David Grove, and Craig Chambers. </author> <title> Optimization of object-oriented programs using static class hierarchy analysis. </title> <booktitle> In ECOOP 95, Ninth European Conference on Object-Oriented Programming, </booktitle> <address> rhus, Denmark, </address> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: Whether or not it is advantageous to exploit such an opportunity is a non-trivial question (see <ref> [DGC95] </ref>). Note: dispatch does not imply call but also includes the dispatch of inlined sends (see text). 9 almost all integer programs, TI (i.e., type inference in the presence of arbitrary-precision BigIntegers) performs more dispatches than TF. <p> If the code was invoked with incompatible types, a new version with less restrictive assumptions was generated (so-called soft code). Grove et al. [Gro95] describe a compiler for the object-oriented language Cecil that uses type feedback in combination with static compilation to eliminate dynamically-dispatched calls. Dean et al. <ref> [DGC95] </ref> eliminate dynamic dispatch with a simple class hierarchy analysis that detects situations where a method has no overriding definition in any subclass of the sending method holder. <p> We have presented a detailed comparison of these two techniques. To our knowledge, this is the first in-depth comparison of a static and a dynamic optimization technique for object-oriented programs. Our comparison is particularly interesting for two reasons: The only exception being section 3.3 of <ref> [DGC95] </ref> which contains some quantitative data of a comparison of type feedback and class hierarchy analysis. 16 First, it is direct, because we eliminated other effects by using two identical compilers except for their source of receiver class information. Second, it is realistic, since the compared systems are high-quality implementations.
Reference: [DS84] <author> L. Peter Deutsch and Alan Schiffman. </author> <title> Efficient Imple mentation of the Smalltalk-80 System. </title> <booktitle> Proceedings of the 11th Symposium on the Principles of Programming Languages, p. </booktitle> <pages> 297-302, </pages> <address> Salt Lake City, UT, </address> <month> Jan. </month> <year> 1984. </year>
Reference: [Dyk77] <author> Eric J. Van Dyke. </author> <title> A dynamic incremental compiler for an interpretative language. </title> <journal> HP Journal, </journal> <volume> p. </volume> <pages> 17-24, </pages> <month> July </month> <year> 1977. </year>
Reference-contexts: Other systems have used some form of runtime type information for optimization. For example, Mitchells system [Mit70] specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization [CUL89]). Similarly, several APL compilers created specialized code for certain expressions (e.g. <ref> [Dyk77, GW78, Joh79] </ref>). The HP APL compiler [Dyk77] specialized compiled code according to the specific operand types (number of dimensions, size of each dimension, element type, etc.). <p> For example, Mitchells system [Mit70] specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization [CUL89]). Similarly, several APL compilers created specialized code for certain expressions (e.g. [Dyk77, GW78, Joh79]). The HP APL compiler <ref> [Dyk77] </ref> specialized compiled code according to the specific operand types (number of dimensions, size of each dimension, element type, etc.). This so-called hard code could execute much more efficiently than more general versions since the cost of an APL operator varies greatly depending on the actual argument types.
Reference: [Gro95] <author> David Grove, Jeffrey Dean, Charles D. Garrett, and Craig Chambers. </author> <title> Profile-Guided Receiver Class Prediction. </title> <booktitle> In OOPSLA 95, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <address> Austin, TX, </address> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: If the code was invoked with incompatible types, a new version with less restrictive assumptions was generated (so-called soft code). Grove et al. <ref> [Gro95] </ref> describe a compiler for the object-oriented language Cecil that uses type feedback in combination with static compilation to eliminate dynamically-dispatched calls.
Reference: [GW78] <author> Leo J. Guibas and Douglas K. Wyatt. </author> <title> Compilation and Delayed Evaluation in APL. </title> <booktitle> In Fifth Annual ACM Symposium on Principles of Programming Languages, p. </booktitle> <pages> 1-8, </pages> <year> 1978. </year>
Reference-contexts: Other systems have used some form of runtime type information for optimization. For example, Mitchells system [Mit70] specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization [CUL89]). Similarly, several APL compilers created specialized code for certain expressions (e.g. <ref> [Dyk77, GW78, Joh79] </ref>). The HP APL compiler [Dyk77] specialized compiled code according to the specific operand types (number of dimensions, size of each dimension, element type, etc.).
Reference: [HCU91] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Optimizing Dynamically-Typed Object-Oriented Languages with Polymorphic Inline Caches. </title> <booktitle> In ECOOP 91, Fifth European Conference on Object-Oriented Programming, p. </booktitle> <pages> 21-38, </pages> <address> Geneva, </address> <month> July </month> <year> 1991. </year> <note> Springer-Verlag (LNCS 512). </note>
Reference-contexts: The SELF system implements all dispatches via type test sequences which sequentially compare the receiver against predicted classes. For non-inlined sends, the type test is part of an inline cache or polymorphic inline cache <ref> [HCU91] </ref>, and for inlined sends it surrounds the inlined code (see Section 2.3). Type inference can determine the exact receiver class for many sends. Since such sends no longer require a dispatch, the overall number of dispatches is reduced. <p> However, its local analysis was significantly more powerful than the simple analysis used in SELF-93. SELF compilers were the first ones to use type feedback for object-oriented programs <ref> [HCU91] </ref>, [HU94a]. Other systems have used some form of runtime type information for optimization. For example, Mitchells system [Mit70] specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization [CUL89]). Similarly, several APL compilers created specialized code for certain expressions (e.g. [Dyk77, GW78, Joh79]).
Reference: [Hl94] <author> Urs Hlzle. </author> <title> Adaptive Optimization in SELF: Reconciling High Performance with Exploratory Programming. </title> <type> Ph.D. Thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <month> Aug. </month> <year> 1994. </year> <note> (Available from http://www.cs.ucsb.edu/~urs.) </note>
Reference-contexts: SELF programs typically spend about 15% of their execution time in type tests implementing message dispatch <ref> [Hl94] </ref> which agrees well with the speedups measured here. Of course, other factors may also contribute to performance differences (e.g., instruction cache misses) but a detailed analysis of these effects is beyond the scope of this paper. <p> We include both inlined and non-inlined dispatches because both introduce similar overhead. For example, the system using type feedback compiles methods in different order (since it adaptively optimizes the program <ref> [Hl94] </ref>) and thus may generate a different set of methods. relative to unoptimized SELF This graphs shows that all systems are very successful at inlining message sends; often, less than 5% of the original calls remain. <p> Type feedback based systems, in contrast, contain code only for paths that were actually executed, i.e., for only a subset of all possible program executions. (Programs do include additional checks and trap instructions to cover unexpected cases <ref> [Hl94] </ref>, but this code contributes little to the overall code size.) To cover all other executions, a type feedback system needs to include general code for the entire application, or an interpreter or compiler at an additional space cost of as little as 20 Kbytes for a Smalltalk byte-code interpreter [Kra83] <p> To cover all other executions, a type feedback system needs to include general code for the entire application, or an interpreter or compiler at an additional space cost of as little as 20 Kbytes for a Smalltalk byte-code interpreter [Kra83] or as much as 800 Kbytes for an optimizing compiler <ref> [Hl94] </ref>. For smaller applications, the fixed cost of the interpreter or compiler will tilt the scales toward type inference, whereas larger applications will 14 tend to favor type feedback. Since so many different aspects inuence space usage, we are not convinced that either system is inherently more space-efficient.
Reference: [HU94a] <author> Urs Hlzle and David Ungar. </author> <title> Optimizing Dynamically Dispatched Calls with Run-Time Type Feedback. </title> <booktitle> In Proceedings of the SIGPLAN 94 Conference on Programming Language Design and Implementation, p. </booktitle> <pages> 326-336, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Type inference may generate better code because it can completely eliminate dispatch for some message sends. Previous studies have reported the effectiveness of type inference and type feedback (e.g., [PC94a] and <ref> [HU94a] </ref>) but direct comparisons have been impossible because important other factors were different, including programming language, compiler technology, and choice of benchmarks. <p> same compiler back end, use the same run-time system, and execute the same suite of benchmarks in both cases; and realistic, because both the type feedback system and the type inferencer represent high-quality implementations of these concepts (the underlying SELF-93 system has been shown to significantly outperform commercial Smalltalk implementations <ref> [HU94a] </ref>). In the remainder of this paper, we briey summarize the two techniques (section 2), quantitatively compare them step by step (section 3), and qualitatively discuss their relative strengths and weaknesses (section 4). We then review related work (section 5) and finally offer our conclusions (section 6). 2. <p> The implementation of type feedback in the SELF-93 optimizing compiler has been described elsewhere ([Hl94, HU94a]). With type feedback, the SELF-93 compiler can inline more message sends and achieve better performance than previous compilers <ref> [HU94a] </ref>. For example, SELF-93 executes a suite of three medium-sized (400-1,100 lines) and six large (4,000-15,000 lines) programs 1.5 times faster than the SELF-91 compiler [HU94a]. For two medium-sized programs that are also available in Smalltalk, SELF-93 is about three times faster than ParcPlace Smalltalk. <p> With type feedback, the SELF-93 compiler can inline more message sends and achieve better performance than previous compilers <ref> [HU94a] </ref>. For example, SELF-93 executes a suite of three medium-sized (400-1,100 lines) and six large (4,000-15,000 lines) programs 1.5 times faster than the SELF-91 compiler [HU94a]. For two medium-sized programs that are also available in Smalltalk, SELF-93 is about three times faster than ParcPlace Smalltalk. In contrast to a type inference system (and to previous SELF systems), SELF-93 performs very little dataow (or typeow) analysis in an effort to keep the compiler small and fast. <p> This difference also has consequences for the system as a whole, as will be discussed in section 4. 3. Quantitative evaluation 3.1 Implementation overview To assess type feedback, we used an essentially unmodified version of the current SELF system which is based on the SELF-93 compiler <ref> [HU94a] </ref>. To enable an unbiased comparison, we made sure that the compiler used exactly the same optimization 5 parameters and heuristics as the type inference based compiler described next. <p> However, its local analysis was significantly more powerful than the simple analysis used in SELF-93. SELF compilers were the first ones to use type feedback for object-oriented programs [HCU91], <ref> [HU94a] </ref>. Other systems have used some form of runtime type information for optimization. For example, Mitchells system [Mit70] specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization [CUL89]). Similarly, several APL compilers created specialized code for certain expressions (e.g. [Dyk77, GW78, Joh79]). <p> Second, it is realistic, since the compared systems are high-quality implementations. Both are based on the SELF-93 system which has been shown to provide excellent performance compared to a commercial Smalltalk implementation <ref> [HU94a] </ref>. Although the quantitative results are specific to SELF, they may nevertheless be interesting to implementors of other languages.
Reference: [HU94b] <author> Urs Hlzle and David Ungar. </author> <title> A Third-Generation SELF Implementation: Reconciling Responsiveness with Performance. </title> <booktitle> OOPSLA 94, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 229-243, </pages> <address> Portland, OR, </address> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: The goal was met largely due to the incremental nature of type feedback: type information is computed gradually and methods can be compiled one at a time (after inline expansion, of course) <ref> [HU94b] </ref>. On the other hand, the style of type inference used in this work is fundamentally a global analysis: the unit analyzed is an entire program. Obviously, inserting a global analysis into an edit-compile-run loop (or the edit-continue loop of the SELF system) will not go unnoticed by the programmer.
Reference: [JGZ88] <author> Ralph Johnson, Justin Graver, and Lawrence Zurawski. </author> <title> TS: An optimizing compiler for Smalltalk. </title> <booktitle> In OOPSLA 88, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 18-26, </pages> <address> San Diego, CA, </address> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: Unfortunately, Suzuki was unable to fully implement his system within the limited heap space of Smalltalk-76 and only managed to test a simplified version of the inference algorithm on some of the number classes. The Typed Smalltalk project <ref> [JGZ88] </ref> incorporated a type inferencer for Smalltalk which relied on explicit type declarations inserted by the programmer; these types were specified as sets of classes. (A second, more abstract kind of type was provided for type checking but was not used by the compiler).
Reference: [Joh79] <author> Ronald L. Johnston. </author> <title> The Dynamic Incremental Compiler of APL"3000. In Proceedings of the APL 79 Conference. </title> <note> Published as APL Quote Quad 9(4), </note> <author> p. </author> <month> 82-87, </month> <year> 1979. </year>
Reference-contexts: Other systems have used some form of runtime type information for optimization. For example, Mitchells system [Mit70] specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization [CUL89]). Similarly, several APL compilers created specialized code for certain expressions (e.g. <ref> [Dyk77, GW78, Joh79] </ref>). The HP APL compiler [Dyk77] specialized compiled code according to the specific operand types (number of dimensions, size of each dimension, element type, etc.).
Reference: [Kra83] <author> Glenn Krasner, ed., </author> <title> Smalltalk-80: Bits of History and Words of Advice. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: [Hl94], but this code contributes little to the overall code size.) To cover all other executions, a type feedback system needs to include general code for the entire application, or an interpreter or compiler at an additional space cost of as little as 20 Kbytes for a Smalltalk byte-code interpreter <ref> [Kra83] </ref> or as much as 800 Kbytes for an optimizing compiler [Hl94]. For smaller applications, the fixed cost of the interpreter or compiler will tilt the scales toward type inference, whereas larger applications will 14 tend to favor type feedback.
Reference: [Mit70] <author> J. G. Mitchell, </author> <title> Design and Construction of Flexible and Efficient Interactive Programming Systems. </title> <type> Ph.D. Thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1970. </year>
Reference-contexts: However, its local analysis was significantly more powerful than the simple analysis used in SELF-93. SELF compilers were the first ones to use type feedback for object-oriented programs [HCU91], [HU94a]. Other systems have used some form of runtime type information for optimization. For example, Mitchells system <ref> [Mit70] </ref> specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization [CUL89]). Similarly, several APL compilers created specialized code for certain expressions (e.g. [Dyk77, GW78, Joh79]).
Reference: [OPS92] <author> Nicholas Oxhj, Jens Palsberg and Michael I. Schwartzbach. </author> <title> Making Type Inference Practical. </title> <booktitle> In ECOOP 92, Sixth European Conference on Object-Oriented Programming, p. </booktitle> <pages> 329-349, </pages> <address> Utrecht, The Netherlands, June 1992. </address> <publisher> Springer-Verlag (LNCS 615). </publisher>
Reference-contexts: Unfortunately, the system was not completed and the only published performance data concerned very small integer programs similar to our Tiny benchmark set. More recently, Palsberg and Schwartzbach described a constraint-based analysis system for a Smalltalk-like toy language [PS91], which was improved and implemented in cooperation with Oxhj <ref> [OPS92] </ref>. Palsberg and Schwartzbach suggested the use of their types for optimization but did not implement such a system. The type inferencer used here is a further development of the ideas originally proposed by Palsberg and Schwartzbach.
Reference: [PS91] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object Oriented Type Inference. </title> <booktitle> In OOPSLA 91, Conference on Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 146-161, </pages> <address> Phoenix, AZ, </address> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: On the other hand, when compiling the statements j: i. i: i + j the compiler will test js class even if a simple dataow analysis would reveal that j is equal to i. 2.4 Type inference Concrete type inference or constraint-based analysis <ref> [PS91, APS93, PC94a] </ref>, unlike type feedback, does not rely on executing the program. Given the program source, this global analysis will statically compute a type for every expression in the program. <p> Unfortunately, the system was not completed and the only published performance data concerned very small integer programs similar to our Tiny benchmark set. More recently, Palsberg and Schwartzbach described a constraint-based analysis system for a Smalltalk-like toy language <ref> [PS91] </ref>, which was improved and implemented in cooperation with Oxhj [OPS92]. Palsberg and Schwartzbach suggested the use of their types for optimization but did not implement such a system. The type inferencer used here is a further development of the ideas originally proposed by Palsberg and Schwartzbach.
Reference: [PR94] <author> Hemant D. Pande and Barbara G. Ryder. </author> <title> Static Type Deter mination and Aliasing for C++. </title> <type> Technical Report LCSR-TR-236, </type> <institution> Rutgers University, </institution> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: Recently, Pande and Ryder have made progress in extending data-ow techniques to C++ <ref> [PR94] </ref>. The main goal of their work is to extend data-ow analysis techniques to solve static analysis problems for C++.
Reference: [PC94a] <author> John B. Plevyak and Andrew A. Chien. </author> <title> Precise Concrete Type Inference for Object-Oriented Languages. </title> <booktitle> In OOPSLA 94, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 324-340, </pages> <address> Portland, OR, </address> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: Type inference may generate better code because it can completely eliminate dispatch for some message sends. Previous studies have reported the effectiveness of type inference and type feedback (e.g., <ref> [PC94a] </ref> and [HU94a]) but direct comparisons have been impossible because important other factors were different, including programming language, compiler technology, and choice of benchmarks. <p> On the other hand, when compiling the statements j: i. i: i + j the compiler will test js class even if a simple dataow analysis would reveal that j is equal to i. 2.4 Type inference Concrete type inference or constraint-based analysis <ref> [PS91, APS93, PC94a] </ref>, unlike type feedback, does not rely on executing the program. Given the program source, this global analysis will statically compute a type for every expression in the program. <p> The type inferencer used here is a further development of the ideas originally proposed by Palsberg and Schwartzbach. Plevyak and Chien independently improved Palsberg and Schwartzbachs algorithm and applied it to Concurrent Aggregates (CA), a concurrent, single-inheritance, dynamically-typed object-oriented language <ref> [PC94a] </ref>. Their system employs an iterative analysis which in each iteration uses the types from the previous iteration to guide the analysis. The inference algorithm can clone classes during analysis to obtain high precision on code with data polymorphism. (Our algorithm is less precise in this regard.
Reference: [PC94b] <author> John B. Plevyak and Andrew A. Chien. </author> <title> Precise Concrete Type Inference and its Use in Program Optimization. </title> <type> Unpublished report, </type> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: It only clones classes based on observing initial values of their 15 instances). Plevyak and Chiens type inferencer has been used in the CA compiler to eliminate dispatches in the (non-object-oriented) Livermore Loops [PZC95] and in object-oriented CA programs <ref> [PC94b, PC94c] </ref>. In the latter two studies, the compiler was able to completely eliminate dynamic dispatch in six of the nine benchmark programs.
Reference: [PC94c] <author> John B. Plevyak and Andrew A. Chien. </author> <title> Efficient cloning to eliminate dynamic dispatch in object-oriented languages. </title> <type> Unpublished report, </type> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: It only clones classes based on observing initial values of their 15 instances). Plevyak and Chiens type inferencer has been used in the CA compiler to eliminate dispatches in the (non-object-oriented) Livermore Loops [PZC95] and in object-oriented CA programs <ref> [PC94b, PC94c] </ref>. In the latter two studies, the compiler was able to completely eliminate dynamic dispatch in six of the nine benchmark programs.
Reference: [PZC95] <author> John B. Plevyak, Xingbin Zhang, and Andrew A. Chien. </author> <title> Obtaining sequential efficiency for concurrent object-oriented languages. </title> <booktitle> In Proceedings of the 22nd Symposium on Principles of Programming Languages, p. </booktitle> <pages> 311-321, </pages> <address> San Francisco, CA, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: It only clones classes based on observing initial values of their 15 instances). Plevyak and Chiens type inferencer has been used in the CA compiler to eliminate dispatches in the (non-object-oriented) Livermore Loops <ref> [PZC95] </ref> and in object-oriented CA programs [PC94b, PC94c]. In the latter two studies, the compiler was able to completely eliminate dynamic dispatch in six of the nine benchmark programs.
Reference: [Suz81] <author> Norihisa Suzuki. </author> <title> Inferring Types in Smalltalk. </title> <booktitle> In Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Languages, p. </booktitle> <pages> 227-241, </pages> <month> Jan. </month> <year> 1981. </year>
Reference-contexts: Adapting concrete type inference to work in such an environment remains a major technical challenge. 5. Related work Type inference for dynamically-typed object-oriented languages has been an active field since the early eighties. Suzuki pioneered the field in the Smalltalk community <ref> [Suz81] </ref>. Similar to our work, he used sets of classes as the basic types and had the same goal of eliminating dynamic dispatch to improve execution efficiency.
Reference: [US87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 227-241, </pages> <address> Orlando, FL, </address> <month> Oct. </month> <year> 1987. </year>
Reference-contexts: We then review related work (section 5) and finally offer our conclusions (section 6). 2. Background 2.1 SELF SELF <ref> [US87] </ref> is a pure object-oriented language: all data are objects, and all computation is performed via dynamically-bound message sends (including all instance variable accesses, integer arithmetic, and control structures like if and while).
Reference: [VHU92] <author> Jan Vitek, R. Nigel Horspool and James S. Uhl. </author> <title> Compile time Analysis of Object-Oriented Programs. </title> <booktitle> In Proceedings of CC92, 4th International Conference on Compiler Construction, p. </booktitle> <pages> 236-250, </pages> <address> Paderborn, Germany, Oct. 1992. </address> <publisher> Springer-Verlag (LNCS 641). </publisher>
Reference-contexts: The strength of the analyses mentioned above ([PS91, PC94a, PR94, and Age95]) is that they acknowledge this problem up-front and solve a combined control-ow and data-ow problem. Vitek et al. demonstrated that this can also be achieved in a data-ow framework <ref> [VHU92] </ref>: for each program point, they computed an abstract object graph, a sufficiently detailed approximation of the full program heap to allow simulation of lookups. However, no data was given about the effectiveness of this approach. The SELF-91 compiler used iterative type analysis to eliminate dispatches [CU90].
References-found: 31

