URL: http://www.cs.wustl.edu/~schmidt/TAPOS-95.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/ACE.FAQ.html
Root-URL: 
Email: schmidt@cs.wustl.edu  
Phone: (TEL) 314-935-7538, (FAX) 314-935-7302  
Title: A Family of Design Patterns for Application-Level Gateways  
Author: Douglas C. Schmidt 
Address: St. Louis 63130  
Affiliation: Department of Computer Science Washington University,  
Web: http://www.cs.wustl.edu/~schmidt/  
Abstract: This paper appeared in the journal Theory and Practice of Object Systems, special issue on Patterns and Pattern Languages, Wiley & Sons, Vol. 2, No. 1, December 1996. Abstract Abstract Developers of communication software must confront recurring design challenges involving robustness, efficiency, and extensibility. Many of these challenges are independent of the application-specific requirements. Successful developers resolve these challenges by applying appropriate design patterns. However, these patterns have traditionally been locked in the minds of expert developers or buried within complex system source code. The primary contribution of this paper is to describe a family of design patterns that underly many object-oriented communication software systems. In addition to describing each pattern separately, the paper illustrates how knowledge of the relationships and trade-offs among patterns helps guide the construction of reusable communication software frameworks. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Design patterns represent successful solutions to problems that arise when building software <ref> [1] </ref>. Capturing and articulating key design patterns helps to enhance software quality by addressing fundamental challenges in large-scale system development. <p> A Gateway is a Mediator <ref> [1] </ref> that de-couples cooperating Peers throughout a network and allows them to interact without having direct dependencies on each other [5]. <p> These components simplify the development of portable and correct communication software by shielding developers from low-level, tedious, and error-prone socket-level programming. In addition, they form the foundation for the higher-level ACE components and patterns described below. * Service initialization components: The Connector and Acceptor are factories <ref> [1] </ref> that implement active and passive strategies for initializing network services, respectively. 2 These components are based on the Connector pattern described in Section 3.2 and Acceptor pattern described in Section 3.3. <p> As shown in Figure 3 3 Input and Output Channels inherit from a common ancestor: the ACE Svc Handler class, which is produced by Connectors and Acceptors. The Svc Handler is a local Proxy <ref> [1] </ref> for a remotely connected Peer. It provides a SOCK Stream, which enables Peers to exchange messages via connected Channels. An Output Channel uses an ACE Message Queue to chain unsent messages in the order they must be delivered when flow control mechanisms permit. <p> A thorough understanding of tactical patterns is essential to implement highly flexible software that is resilient to changes in application requirements and platform environments. Although there are various forms for describing patterns, they typically convey the following information <ref> [1] </ref>: * The intent of the pattern; 5 * The design forces that motivate and shape the pattern; * The solution to these forces; * The related classes and their roles in the solution; * The responsibilities and dynamic collaborations among classes; * The positive and negative consequences of using the <p> This enables the wholesale replacement of the SVC HANDLER and PEER CONNECTOR types, without affecting the Connector pattern's service initialization strategy. Note that a similar degree of decoupling could be achieved via inheritance and dynamic binding by using the Abstract Factory or Factory Method patterns described in <ref> [1] </ref>. Parameterized types were used to implement this pattern since they improve run-time efficiency. In general, templates trade compile- and link-time overhead and space overhead for improved run-time performance. Collaborations: The collaborations among participants in the Connector pattern are divided into three phases: 1. <p> Usage: The Connector pattern is used by the Gateway to simplify the task of connecting to a large number of Peers. Peer addresses are read from a configuration file during Gateway initialization. The Gateway uses the Builder pattern <ref> [1] </ref> to bind these addresses to dynamically allocated Channels. Since Channels inherit from Svc Handler, all connections can be initiated asynchronously using the Iterator pattern [1]. The connections are then completed in parallel using the Connector. in the Connector pattern after four connections have been established. <p> Peer addresses are read from a configuration file during Gateway initialization. The Gateway uses the Builder pattern <ref> [1] </ref> to bind these addresses to dynamically allocated Channels. Since Channels inherit from Svc Handler, all connections can be initiated asynchronously using the Iterator pattern [1]. The connections are then completed in parallel using the Connector. in the Connector pattern after four connections have been established. Three other connections that have not yet completed are owned by the Connector. <p> In general, documenting the interactions and relationships between closely related patterns is a very challenging and unresolved topic that is currented be addressed by the patterns community. 4 Related Work <ref> [1, 5, 20] </ref> identify, name, and catalog many fundamental object-oriented design patterns. This section examines how the patterns described in this paper relate to other patterns in the literature. Note that many of the tactical patterns form the basis for implementing the strategic patterns presented in this paper. <p> This section examines how the patterns described in this paper relate to other patterns in the literature. Note that many of the tactical patterns form the basis for implementing the strategic patterns presented in this paper. The Reactor pattern is related to the Observer pattern <ref> [1] </ref>. In the Observer pattern, multiple dependents are updated automatically when a subject changes. In the Reactor pattern, a handler is dispatched automatically when an event occurs. Thus, the Reactor dispatches a single handler for each event (though there can be multiple sources of events). <p> In the Reactor pattern, a handler is dispatched automatically when an event occurs. Thus, the Reactor dispatches a single handler for each event (though there can be multiple sources of events). The Reactor pattern also provides a Facade <ref> [1] </ref>. The Facade pattern presents an interface that shields applications from complex relationships within a subsystem. The Reactor pattern shields applications from complex mechanisms that perform event demultiplexing and event handler dispatching. The mechanism the Reactor uses to dispatch Event Handlers is similar to the Factory Callback pattern [21]. <p> The primary different is the purpose of the pattern the Factory Callback is a creational pattern, whereas the Reactor dispatching is a behavioral pattern. The Connector pattern is a variation of the Template Method and Factory Method patterns <ref> [1] </ref>. In the Template Method pattern, an algorithm is written such that some steps are supplied by a derived class. <p> They both are concerned with separating active connection establishment from the subsequent service. The primary difference is that the Connector pattern addresses both synchronous and asynchronous connection establishment. The Acceptor pattern can also be viewed as a variation of the Strategy and Factory Method patterns <ref> [1] </ref>. The Acceptor pattern is a connection factory that embodies the strategy for create service handlers, accepting connections into service handlers, and activating service handles to process data exchanged across communication channels. <p> The handler performs a service using data exchanged on the connection. Thus, the service is decoupled from the network programming interface and the transport protocol used to establish the connection. The Router pattern is a variant of the Mediator pattern <ref> [1] </ref>, which decouples cooperating components of a software system and allows them to interact without having direct dependencies among each other. The Router pattern is specialized to resolve the forces associated with network communication.
Reference: [2] <author> D. C. Schmidt, </author> <title> Experience Using Design Patterns to Develop Reuseable Object-Oriented Communication Software, </title> <journal> Communications of the ACM (Special Issue on Object-Oriented Experiences), </journal> <volume> vol. 38, </volume> <month> October </month> <year> 1995. </year>
Reference-contexts: Therefore, they are excellent exemplars for presenting the structure, participants, and consequences of key design patterns that appear in many communication software systems. 1 Gateway The patterns described in this paper were discovered while building a wide range of communication systems including on-line transaction processing systems, telecommunication switch management systems <ref> [2] </ref>, electronic medical imaging systems [3], and parallel communication subsystems [4]. Although the specific application requirements in these systems were quite different, the communication software design challenges were very similar. <p> frameworks in these systems by capturing the structure and collaboration of participants in a software architecture at a higher level than (1) source code and (2) object-oriented design models that focus on individual ob jects and classes. 15 Our experience applying a design pattern-based reuse strat-egy has been quite positive <ref> [2] </ref>. For instance, we've significantly reduced the software maintenance and training effort for the production communication systems by documenting the intent, structure, and behavior of ACE components in terms of the patterns they reify. <p> Focusing on patterns has also enabled us to reuse software architecture even when reuse of algorithms, implementations, interfaces, or detailed designs was not feasible due to differences in OS platforms [12]. An in-depth discussion of our experiences and lessons learned using patterns appeared in <ref> [2] </ref>. Acknowledgements I would like to thank Steve Berczuk, Chris Cleeland, Tim Harrison, Hans Rohnert, and the anonymous referees for contributing valuable suggestions that helped improve the quality of this paper.
Reference: [3] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging, </title> <booktitle> in Proceedings of the 2 nd Conference on Object-Oriented Technologies and Systems, </booktitle> <institution> (Toronto, Canada), USENIX, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: for presenting the structure, participants, and consequences of key design patterns that appear in many communication software systems. 1 Gateway The patterns described in this paper were discovered while building a wide range of communication systems including on-line transaction processing systems, telecommunication switch management systems [2], electronic medical imaging systems <ref> [3] </ref>, and parallel communication subsystems [4]. Although the specific application requirements in these systems were quite different, the communication software design challenges were very similar. Therefore, although the examples in this paper focus on Gateways, the patterns embody design expertise that can be reused broadly in the communication domain. <p> The family of design patterns and the ACE framework components described in this paper have been reused by the author and his colleagues in many production communication software systems ranging from telecommunication and electronic medical imaging projects <ref> [12, 3] </ref> to academic research projects [10].
Reference: [4] <author> D. C. Schmidt and T. Suda, </author> <title> Measuring the Performance of Parallel Message-based Process Architectures, </title> <booktitle> in Proceedings of the Conference on Computer Communications (INFO-COM), </booktitle> <address> (Boston, MA), </address> <pages> pp. 624-633, </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1995. </year>
Reference-contexts: and consequences of key design patterns that appear in many communication software systems. 1 Gateway The patterns described in this paper were discovered while building a wide range of communication systems including on-line transaction processing systems, telecommunication switch management systems [2], electronic medical imaging systems [3], and parallel communication subsystems <ref> [4] </ref>. Although the specific application requirements in these systems were quite different, the communication software design challenges were very similar. Therefore, although the examples in this paper focus on Gateways, the patterns embody design expertise that can be reused broadly in the communication domain.
Reference: [5] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: A Gateway is a Mediator [1] that de-couples cooperating Peers throughout a network and allows them to interact without having direct dependencies on each other <ref> [5] </ref>. As shown in Figure 1, messages routed through the Gateway contain payloads encapsulated in routing messages. and external collaborations among objects within a software architecture for application-level Gateways. 1 This architecture is based on extensive experience developing connection-oriented Gateways for various commercial and research communication systems. <p> In general, documenting the interactions and relationships between closely related patterns is a very challenging and unresolved topic that is currented be addressed by the patterns community. 4 Related Work <ref> [1, 5, 20] </ref> identify, name, and catalog many fundamental object-oriented design patterns. This section examines how the patterns described in this paper relate to other patterns in the literature. Note that many of the tactical patterns form the basis for implementing the strategic patterns presented in this paper. <p> In the Connector pattern, the connect method implements a standard algorithm for initiating a connection and activating a handler when the connection is established. The intent of the Connector pattern is similar to the Client/Dispatcher/Server pattern described in <ref> [5] </ref>. They both are concerned with separating active connection establishment from the subsequent service. The primary difference is that the Connector pattern addresses both synchronous and asynchronous connection establishment. The Acceptor pattern can also be viewed as a variation of the Strategy and Factory Method patterns [1].
Reference: [6] <author> G. Booch, </author> <title> Object Oriented Analysis and Design with Applications (2 nd Edition). </title> <address> Redwood City, California: Ben-jamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: Therefore, Section 3 describes the interactions and relationships among these patterns in terms of a family of design patterns for communication software. These design patterns work together to solve complex problems within the domain of communication software. 1 Relationships between components are illustrated throughout this paper using Booch notation <ref> [6] </ref>.
Reference: [7] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Some of the communication software patterns described in this paper have been documented individually <ref> [7, 8, 9] </ref>. Although individual pattern descriptions capture valuable design expertise, complex communication software systems embody scores of patterns. Understanding the relationships among these patterns is essential to document, motivate, and resolve difficult challenges that arise when building communication software. <p> When a SOCK Connector connects two socket endpoints via TCP it produces a SOCK Stream object, which is then used to exchange data between that Peer and the Gateway. * Event demultiplexing components: The Reactor is an object-oriented event demultiplexing mechanism based on the Reactor pattern <ref> [7] </ref> described in Section 3.1. It channels all external stimuli in an event-driven application to a single demultiplexing point. This permits single-threaded applications to wait on event handles, demultiplex events, and dispatch event handlers efficiently. <p> It is important to recognize that the strategic patterns in this paper are much more generally applicable than the specific use cases for the Gateway described below. The references <ref> [7, 8, 9] </ref> provide additional use cases for these patterns, along with more detailed coverage of each pattern and sample implementations. 3.1 The Reactor Pattern Intent: The Reactor pattern decouples event demultiplex-ing and event handler dispatching from the services performed in response to events.
Reference: [8] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Initializing Communication Services, </title> <booktitle> in The 1 st European Pattern Languages of Programming Conference (Washington University technical report #WUCS-97-07), </booktitle> <month> July </month> <year> 1997. </year>
Reference-contexts: Some of the communication software patterns described in this paper have been documented individually <ref> [7, 8, 9] </ref>. Although individual pattern descriptions capture valuable design expertise, complex communication software systems embody scores of patterns. Understanding the relationships among these patterns is essential to document, motivate, and resolve difficult challenges that arise when building communication software. <p> It is important to recognize that the strategic patterns in this paper are much more generally applicable than the specific use cases for the Gateway described below. The references <ref> [7, 8, 9] </ref> provide additional use cases for these patterns, along with more detailed coverage of each pattern and sample implementations. 3.1 The Reactor Pattern Intent: The Reactor pattern decouples event demultiplex-ing and event handler dispatching from the services performed in response to events.
Reference: [9] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, </title> <booktitle> in Proceedings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 1-7, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Some of the communication software patterns described in this paper have been documented individually <ref> [7, 8, 9] </ref>. Although individual pattern descriptions capture valuable design expertise, complex communication software systems embody scores of patterns. Understanding the relationships among these patterns is essential to document, motivate, and resolve difficult challenges that arise when building communication software. <p> It is important to recognize that the strategic patterns in this paper are much more generally applicable than the specific use cases for the Gateway described below. The references <ref> [7, 8, 9] </ref> provide additional use cases for these patterns, along with more detailed coverage of each pattern and sample implementations. 3.1 The Reactor Pattern Intent: The Reactor pattern decouples event demultiplex-ing and event handler dispatching from the services performed in response to events. <p> Service processing phase once activated, the Svc Handler processes incoming event messages arriving on the PEER STREAM. A Svc Handler will process incoming event messages using a concurrent event handling pattern such as the Reactor or the Active Object <ref> [9] </ref>. Usage: Figure 13 illustrates how the Acceptor pattern is used by the Gateway. The Gateway uses this pattern when it plays the passive connection role.
Reference: [10] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: The Gateway systems this paper is based upon were implemented with the ADAPTIVE Communication Environment (ACE) software <ref> [10] </ref>. ACE provides an integrated framework of reusable C++ wrappers and components that perform common communication software tasks. These tasks include event demultiplexing, event handler dispatching, connection establishment, routing, dynamic configuration of application services, and concurrency control. <p> The Routing Table maps addressing information contained in routing messages sent by Peers to the appropriate set of Output Channels. * Message queueing components: The Message Queue <ref> [10] </ref> provides a generic queueing mechanism. This mechanism runs efficient and robustly in multi-threaded or single-threaded environments. <p> These events are used by the Acceptor described in Section 3.3. The Reactor pattern has been used in many single-threaded event-driven frameworks (such as the Motif, Interviews [13], System V STREAMS [14], the ACE object-oriented communication framework <ref> [10] </ref>, and implementations of DCE and CORBA). In addition, it forms the foundation for most of the strategic patterns presented below. 3.2 The Connector Pattern Intent: The Connector pattern decouples active service initialization from the tasks performed once a service is initialized. <p> The family of design patterns and the ACE framework components described in this paper have been reused by the author and his colleagues in many production communication software systems ranging from telecommunication and electronic medical imaging projects [12, 3] to academic research projects <ref> [10] </ref>.
Reference: [11] <author> D. C. Schmidt, T. H. Harrison, and E. Al-Shaer, </author> <title> Object-Oriented Components for High-speed Network Programming, </title> <booktitle> in Proceedings of the 1 st Conference on Object-Oriented Technologies and Systems, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: The behavior of the application-independent components in the Gateway is outlined below: * Interprocess communication (IPC) components: The SOCK Stream, SOCK Connector, and SOCK Acceptor components encapsulate the socket network programming interface <ref> [11] </ref>. These components simplify the development of portable and correct communication software by shielding developers from low-level, tedious, and error-prone socket-level programming. <p> Therefore, to expedite initialization, the Gateway's Connector can initiate all connections asynchronously rather than synchronously. Asynchrony helps decrease connection latency over long delay paths (such as wide-area networks (WANs) built over satellites or long-haul terrestrial links). The underlying SOCK Connector <ref> [11] </ref> contained within a Connector provides the low-level asynchronous connection mechanism.
Reference: [12] <author> D. C. Schmidt and P. Stephenson, </author> <title> Experiences Using Design Patterns to Evolve System Software Across Diverse OS Platforms, </title> <booktitle> in Proceedings of the 9 th European Conference on Object-Oriented Programming, </booktitle> <address> (Aarhus, Denmark), </address> <publisher> ACM, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: A thorough understanding of the patterns presented below enables widespread reuse of Gateway software architecture in other systems, even when reuse of its algorithms, implementations, in terfaces, or detailed designs is not feasible <ref> [12] </ref>. 4 Gateways 2. Reduce the effort of maintaining and enhancing Gateway software The use of patterns helps to capture and motivate the collaboration between multiple classes and objects. This is important for developers who must maintain and enhance a Gateway. <p> The family of design patterns and the ACE framework components described in this paper have been reused by the author and his colleagues in many production communication software systems ranging from telecommunication and electronic medical imaging projects <ref> [12, 3] </ref> to academic research projects [10]. <p> Focusing on patterns has also enabled us to reuse software architecture even when reuse of algorithms, implementations, interfaces, or detailed designs was not feasible due to differences in OS platforms <ref> [12] </ref>. An in-depth discussion of our experiences and lessons learned using patterns appeared in [2]. Acknowledgements I would like to thank Steve Berczuk, Chris Cleeland, Tim Harrison, Hans Rohnert, and the anonymous referees for contributing valuable suggestions that helped improve the quality of this paper.
Reference: [13] <author> M. A. Linton, J. Vlissides, and P. Calder, </author> <title> Composing User Interfaces with InterViews, </title> <journal> IEEE Computer, </journal> <volume> vol. 22, </volume> <pages> pp. 8-22, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: These events are used by the Acceptor described in Section 3.3. The Reactor pattern has been used in many single-threaded event-driven frameworks (such as the Motif, Interviews <ref> [13] </ref>, System V STREAMS [14], the ACE object-oriented communication framework [10], and implementations of DCE and CORBA).
Reference: [14] <author> D. Ritchie, </author> <title> A Stream Input-Output System, </title> <journal> AT&T Bell Labs Technical Journal, </journal> <volume> vol. 63, </volume> <pages> pp. 311-324, </pages> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: These events are used by the Acceptor described in Section 3.3. The Reactor pattern has been used in many single-threaded event-driven frameworks (such as the Motif, Interviews [13], System V STREAMS <ref> [14] </ref>, the ACE object-oriented communication framework [10], and implementations of DCE and CORBA). In addition, it forms the foundation for most of the strategic patterns presented below. 3.2 The Connector Pattern Intent: The Connector pattern decouples active service initialization from the tasks performed once a service is initialized.
Reference: [15] <author> W. R. Stevens, </author> <title> UNIX Network Programming, First Edition. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Motivation and Forces: Connection-oriented applications (like a Gateway) and middleware (like CORBA or Distributed COM) are often written using lower-level network programming interfaces (like sockets <ref> [15] </ref> and TLI [16]). The Connector pattern resolves the following forces that impact the active initialization of services written using these lower-level interfaces: 1. <p> The intent and general architecture of the Acceptor pattern is found in network server management tools like inetd <ref> [15] </ref> and listen [16]. These tools utilize a master Acceptor process that listens for connections on a set of communication ports. Each port is associated with a communication-related service (such as the standard Internet services ftp, telnet, daytime, and echo).
Reference: [16] <author> S. Rago, </author> <title> UNIX System V Network Programming. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Motivation and Forces: Connection-oriented applications (like a Gateway) and middleware (like CORBA or Distributed COM) are often written using lower-level network programming interfaces (like sockets [15] and TLI <ref> [16] </ref>). The Connector pattern resolves the following forces that impact the active initialization of services written using these lower-level interfaces: 1. <p> The intent and general architecture of the Acceptor pattern is found in network server management tools like inetd [15] and listen <ref> [16] </ref>. These tools utilize a master Acceptor process that listens for connections on a set of communication ports. Each port is associated with a communication-related service (such as the standard Internet services ftp, telnet, daytime, and echo).
Reference: [17] <author> D. C. Schmidt and C. D. Cranor, Half-Sync/Half-Async: </author> <title> an Architectural Pattern for Efficient and Well-structured Concurrent I/O, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Network services are generally easier to program if blocking I/O is used rather than reactive non-blocking I/O <ref> [17] </ref>. The increased simplicity occurs since the execution state can be localized in the activation records of a thread of control, rather than being decentralized in a set of control blocks maintained 13 Pattern by application developers.
Reference: [18] <author> R. H. Halstead, Jr., </author> <title> Multilisp: A Language for Concurrent Symbolic Computation, </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> vol. 7, </volume> <pages> pp. 501-538, </pages> <month> Oct. </month> <year> 1985. </year>
Reference-contexts: The Method Object is then bound to the current Resource Representation and the method is allowed to access/update this representation and create a Result Handle. 3. Return result the final phase binds the Result Handle value, if any, to a future <ref> [18, 19] </ref> object that Active Object Gateway passes return values back to the caller when the method finishes executing. A future is a synchronization object that enforces write-once, read-many synchronization. Subsequently, any readers that rendezvous with the future will evaluate the future and obtain the result value.
Reference: [19] <author> B. Liskov and L. Shrira, </author> <title> Promises: Linguistic Support for Efficient Asynchronous Procedure Calls in Distributed Systems, </title> <booktitle> in Proceedingsof the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 260-267, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: The Method Object is then bound to the current Resource Representation and the method is allowed to access/update this representation and create a Result Handle. 3. Return result the final phase binds the Result Handle value, if any, to a future <ref> [18, 19] </ref> object that Active Object Gateway passes return values back to the caller when the method finishes executing. A future is a synchronization object that enforces write-once, read-many synchronization. Subsequently, any readers that rendezvous with the future will evaluate the future and obtain the result value.
Reference: [20] <editor> J. O. Coplien and D. C. Schmidt, eds., </editor> <booktitle> Pattern Languages of Program Design. </booktitle> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: In general, documenting the interactions and relationships between closely related patterns is a very challenging and unresolved topic that is currented be addressed by the patterns community. 4 Related Work <ref> [1, 5, 20] </ref> identify, name, and catalog many fundamental object-oriented design patterns. This section examines how the patterns described in this paper relate to other patterns in the literature. Note that many of the tactical patterns form the basis for implementing the strategic patterns presented in this paper.
Reference: [21] <author> S. Berczuk, </author> <title> A Pattern for Separating Assembly and Processing, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The Facade pattern presents an interface that shields applications from complex relationships within a subsystem. The Reactor pattern shields applications from complex mechanisms that perform event demultiplexing and event handler dispatching. The mechanism the Reactor uses to dispatch Event Handlers is similar to the Factory Callback pattern <ref> [21] </ref>. The intent of both patterns is to decoupling event reception from event processing. The primary different is the purpose of the pattern the Factory Callback is a creational pattern, whereas the Reactor dispatching is a behavioral pattern.
References-found: 21

