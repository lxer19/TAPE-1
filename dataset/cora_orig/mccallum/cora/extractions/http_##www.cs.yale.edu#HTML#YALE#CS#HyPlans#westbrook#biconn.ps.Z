URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/westbrook/biconn.ps.Z
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/westbrook/
Root-URL: http://www.cs.yale.edu
Title: Maintaining Bridge-Connected and Biconnected Components On-line  
Author: Jeffery Westbrook Robert E. Tarjan 
Date: September 28, 1993  
Abstract: We consider the twin problems of maintaining the bridge-connected components and the biconnected components of a dynamic undirected graph. The allowed changes to the graph are vertex and edge insertions. We give an algorithm for each problem. With simple data structures, each algorithm runs in O(n log n + m) time, where n is the number of vertices and m is the number of operations. We develop a modified version of the dynamic trees of Sleator and Tarjan that is suitable for efficient recursive algorithms, and use it to reduce the running time of the algorithms for both problems to O(mff(m; n)), where ff is a functional inverse of Ackermann's function. This time bound is optimal. All of the algorithms use O(n) space.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Awerbuch and Y. Shiloach. </author> <title> New connectivity and msf algorithms for shu*e-exchange network and pram. </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-36:1258-1263, </volume> <year> 1987. </year>
Reference-contexts: Hopcroft and Tarjan [9] and Tarjan [18] give sequential algorithms that run in time O (n + m) where n = jV j and m = jEj. Logarithmic-time parallel algorithms for finding components, bridge-blocks, and blocks are given in references <ref> [1] </ref> and [24] (see also the survey paper [10]). The problem of answering queries about edge and vertex membership in the components of a dynamic graph, i.e., a graph that is changing on-line, has been addressed in references [5, 6, 7, 13].
Reference: [2] <author> G. D. Battista and R. Tamassia. </author> <title> Incremental planarity testing. </title> <booktitle> In Proc. 30th IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 436-441, </pages> <year> 1989. </year>
Reference-contexts: The block and bridge-block problems are fundamental problems in the study of on-line graph algorithms, a study that has wide applications to networks, CAD/CAM, and distributed computing. They appear as subproblems of other on-line graph problems, such as incremental planarity testing <ref> [2] </ref>. The incremental planarity testing problem is to maintain a representation of a planar graph as edges are being added, and to determine the first edge addition that makes the graph nonplanar.
Reference: [3] <author> G. D. Battista and R. Tamassia. </author> <title> On-line graph algorithms with spqr-trees. </title> <booktitle> In Proc. 17th ICALP, </booktitle> <year> 1990. </year> <note> To appear. </note>
Reference-contexts: In recent work other researchers have addressed several problems that we posed in the preliminary version of this paper [25]. Tamassia and Di Battista <ref> [3] </ref> give a data structure that uses our condensible nodes and maintains the triconnected components of a graph; m operations require O (mff (m; n)) time if the graph is initially biconnected, and O (m log n) time otherwise.
Reference: [4] <author> N. Blum. </author> <title> On the single-operation worst-case time complexity of the disjoint set union problem. </title> <journal> SIAM J. Comput., </journal> <volume> 15 </volume> <pages> 1021-1024, </pages> <year> 1986. </year>
Reference-contexts: Let n be the number of elements and m the number of operations in an instance of disjoint set union. Tarjan [20] gave a lower bound of (ff (m; n)) on the amortized time per operation and Blum <ref> [4] </ref> gave a lower bound of (log n= log logn) on the worst-case time of a single operation. Both these lower bounds apply to the class of separable pointer algorithms for set union [4, 20]. <p> Both these lower bounds apply to the class of separable pointer algorithms for set union <ref> [4, 20] </ref>.
Reference: [5] <author> G. A. Cheston. </author> <title> Incremental Algorithms in Graph Theory. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, University of Toronto, </institution> <year> 1976. </year> <note> Technical Report No. 91. </note>
Reference-contexts: The problem of answering queries about edge and vertex membership in the components of a dynamic graph, i.e., a graph that is changing on-line, has been addressed in references <ref> [5, 6, 7, 13] </ref>. Even and Shiloach [6] consider the component problem for a graph undergoing edge deletions.
Reference: [6] <author> S. Even and Y. Shiloach. </author> <title> An on-line edge deletion problem. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 28 </volume> <pages> 1-4, </pages> <year> 1981. </year>
Reference-contexts: The problem of answering queries about edge and vertex membership in the components of a dynamic graph, i.e., a graph that is changing on-line, has been addressed in references <ref> [5, 6, 7, 13] </ref>. Even and Shiloach [6] consider the component problem for a graph undergoing edge deletions. <p> The problem of answering queries about edge and vertex membership in the components of a dynamic graph, i.e., a graph that is changing on-line, has been addressed in references [5, 6, 7, 13]. Even and Shiloach <ref> [6] </ref> consider the component problem for a graph undergoing edge deletions. <p> Frederickson [7] gives an algorithm that performs queries in constant time and edge insertions and deletions in time O ( p m i ), where m i is the number of edges in G at the time of the i th update. It is well-known (see, for example, <ref> [6, 13] </ref>) that if only edge insertions are allowed, the component problem can be solved by straightforward application of a fast disjoint set union algorithm.
Reference: [7] <author> G. N. Frederickson. </author> <title> Data structures for on-line updating of minimum spanning trees, with applications. </title> <journal> SIAM J. Comput., </journal> <volume> 14 </volume> <pages> 781-798, </pages> <year> 1985. </year>
Reference-contexts: The problem of answering queries about edge and vertex membership in the components of a dynamic graph, i.e., a graph that is changing on-line, has been addressed in references <ref> [5, 6, 7, 13] </ref>. Even and Shiloach [6] consider the component problem for a graph undergoing edge deletions. <p> Reif [13] gives an algorithm for the same problem that runs in time O (ng + n log n) when given an initial graph embedded in a surface of genus g. Frederickson <ref> [7] </ref> gives an algorithm that performs queries in constant time and edge insertions and deletions in time O ( p m i ), where m i is the number of edges in G at the time of the i th update.
Reference: [8] <author> M. L. Fredman and M. E. Saks. </author> <title> The cell probe complexity of dynamic data structures. </title> <booktitle> In Proc. 21st ACM Symposium on Theory of Computing, </booktitle> <pages> pages 345-354, </pages> <address> Seattle, WA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Both these lower bounds apply to the class of separable pointer algorithms for set union [4, 20]. La Poutre [11] has proven the (ff (m; n)) amortized cost bound in a general pointer machine model, and Fredman and Saks <ref> [8] </ref> have shown an (ff (m; n)) bound on the amortized cost per operation and an (log n= log logn) bound on the worst-case cost per operation in the cell probe model of Yao [26].
Reference: [9] <author> J. Hopcroft and R. E. Tarjan. </author> <title> Algorithm 447: Efficient algorithms for graph manipulation. </title> <journal> Communications of the Association for Computing Machinery, </journal> <volume> 16 </volume> <pages> 372-378, </pages> <year> 1973. </year>
Reference-contexts: The problems of finding the components, blocks, and bridge-blocks of a fixed graph are well-understood. Hopcroft and Tarjan <ref> [9] </ref> and Tarjan [18] give sequential algorithms that run in time O (n + m) where n = jV j and m = jEj. Logarithmic-time parallel algorithms for finding components, bridge-blocks, and blocks are given in references [1] and [24] (see also the survey paper [10]). <p> Proof. The bridge-blocks and initial BBF of G 0 can be found in time O (jE 0 j) using one of the algorithms in references <ref> [9, 18] </ref>. By Lemma 1, the total number of pointer steps and condensations is O (m), giving the bound. 2 3 Maintaining Blocks On-line The problem of maintaining blocks on-line is similar to that of maintaining bridge-blocks, and the algorithms are almost identical.
Reference: [10] <author> R. Karp and V. Ramachandran. </author> <title> Parallel algorithms for shared memory machines. </title> <type> Technical Report CSD 88/408, </type> <institution> Dept. of Computer Science, U.C. Berkeley, </institution> <year> 1988. </year> <note> To appear in Handbook of Theoretical Computer Science, North-Holland. </note>
Reference-contexts: Hopcroft and Tarjan [9] and Tarjan [18] give sequential algorithms that run in time O (n + m) where n = jV j and m = jEj. Logarithmic-time parallel algorithms for finding components, bridge-blocks, and blocks are given in references [1] and [24] (see also the survey paper <ref> [10] </ref>). The problem of answering queries about edge and vertex membership in the components of a dynamic graph, i.e., a graph that is changing on-line, has been addressed in references [5, 6, 7, 13]. Even and Shiloach [6] consider the component problem for a graph undergoing edge deletions.
Reference: [11] <author> J. A. La Poutre. </author> <title> Lower bounds for the union-find and split-find problem on pointer machines. </title> <booktitle> In Proceedings 22nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 34-44, </pages> <year> 1990. </year>
Reference-contexts: Both these lower bounds apply to the class of separable pointer algorithms for set union [4, 20]. La Poutre <ref> [11] </ref> has proven the (ff (m; n)) amortized cost bound in a general pointer machine model, and Fredman and Saks [8] have shown an (ff (m; n)) bound on the amortized cost per operation and an (log n= log logn) bound on the worst-case cost per operation in the cell probe
Reference: [12] <author> J. A. La Poutre, J. van Leeuwen, and M. H. Overmars. </author> <title> Maintenance of 2- and 3-edge-connected components of graphs. </title> <type> Manuscript, </type> <year> 1990. </year>
Reference-contexts: that at every step changes the number of blocks in the graph by fi (n). 4 Working independently and using techniques different from ours, La Poutre, van Leeuwen, and Overmars have recently also obtained an O (mff (m; n)) time bound for maintaining bridge-blocks and for maintaining three-edge connected components <ref> [12] </ref>. Their results, as well as other recent work that builds on the preliminary version of the present paper [25] are briefly discussed in Section 8. 2 Maintaining Bridge-Blocks On-Line The bridge-blocks and bridges of a connected graph have a natural tree structure that we call the bridge-block tree. <p> Galil and Italiano [private communication, 1990] use our condensible nodes in designing a data structure to maintain the 3-edge-connected components of an initially connected graph in O (mff (m; n)) total time. La Poutre, van Leeuwen and Overmars <ref> [12] </ref>, working independently, have designed a different data structure for maintaining bridge-blocks and 3-edge-connected components that runs in total time O (mff (m; n)). They claim that their approach can be extended to the problem of maintaining biconnected and tricon-nected components. 32
Reference: [13] <author> J. H. Reif. </author> <title> A topological approach to dynamic graph connectivity. </title> <journal> Inform. Process. Lett., </journal> <volume> 25 </volume> <pages> 65-70, </pages> <year> 1987. </year>
Reference-contexts: The problem of answering queries about edge and vertex membership in the components of a dynamic graph, i.e., a graph that is changing on-line, has been addressed in references <ref> [5, 6, 7, 13] </ref>. Even and Shiloach [6] consider the component problem for a graph undergoing edge deletions. <p> They give algorithms with constant query time, O (n log n) total update time in the case that G is a tree or forest, and O (mn) update time for general G, where m and n are the numbers of edges and vertices, respectively, in the initial graph. Reif <ref> [13] </ref> gives an algorithm for the same problem that runs in time O (ng + n log n) when given an initial graph embedded in a surface of genus g. <p> Frederickson [7] gives an algorithm that performs queries in constant time and edge insertions and deletions in time O ( p m i ), where m i is the number of edges in G at the time of the i th update. It is well-known (see, for example, <ref> [6, 13] </ref>) that if only edge insertions are allowed, the component problem can be solved by straightforward application of a fast disjoint set union algorithm.
Reference: [14] <author> D. D. Sleator and R. E. Tarjan. </author> <title> A data structure for dynamic trees. </title> <journal> J. Comput. System Sci., </journal> <volume> 26 </volume> <pages> 362-391, </pages> <year> 1983. </year>
Reference-contexts: Both these data structures answer queries in O (1) worst-case time. In Sections 4-6 we introduce the link/condense tree data structure, a modified version of the dynamic trees of Sleator and Tarjan <ref> [14, 15] </ref>, By a delicate analysis we show that this data structure reduces the amortized time per operation to O (ff (m; n)). <p> The link/condense tree. is derived from the dynamic tree data structure of Sleator and Tarjan <ref> [14, 15] </ref>. <p> As defined in [15], a dynamic tree node v contains pointers to its left and right children in the solid subtree, left (v) and right (v), and to its virtual parent, vparent (v). It also contains a bit reverse (v), used to implement eversion efficiently (see <ref> [14] </ref>). Node v may enter reversed state, in which case the meanings of left (v) and right (v) are reversed. (That is, left (v) points to the right child, and right (v) points to the left child. <p> of m biconnected component operations can be performed in worst-case time O (mff (m; n)) and O (n) space. 5 Eversion and Linking of Link/Condense Trees An eversion of a link/condense tree T at node u is done using the same procedure as in the dynamic tree data structure (see <ref> [14] </ref>). Node u is moved to the root of the virtual tree V by an extended splay. Following the e-splay, the right subtree of u contains the path from u to the root of T . A null splice at u is done.
Reference: [15] <author> D. D. Sleator and R. E. Tarjan. </author> <title> Self-adjusting binary search trees. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 32 </volume> <pages> 652-686, </pages> <year> 1985. </year> <month> 33 </month>
Reference-contexts: Both these data structures answer queries in O (1) worst-case time. In Sections 4-6 we introduce the link/condense tree data structure, a modified version of the dynamic trees of Sleator and Tarjan <ref> [14, 15] </ref>, By a delicate analysis we show that this data structure reduces the amortized time per operation to O (ff (m; n)). <p> The link/condense tree. is derived from the dynamic tree data structure of Sleator and Tarjan <ref> [14, 15] </ref>. <p> The variants differ significantly. We base our data structure on the implementation of dynamic trees described in <ref> [15] </ref>. The following summary description of dynamic trees is taken from [15, pp. 678], (See We represent each dynamic tree T by a virtual tree V containing the same nodes as T but having a different structure. <p> The variants differ significantly. We base our data structure on the implementation of dynamic trees described in [15]. The following summary description of dynamic trees is taken from <ref> [15, pp. 678] </ref>, (See We represent each dynamic tree T by a virtual tree V containing the same nodes as T but having a different structure. <p> The parent of v in T is called the true parent of v, and the parent of v in V is called the virtual parent. The solid subtrees are maintained with splay trees <ref> [15] </ref>. A splay at node x moves x to the root of its solid subtree by applying a standard binary tree rotation to every edge along the path from x to the root (Figure 6a). A rotation rearranges left and right children while preserving the symmetric order. <p> A rotation rearranges left and right children while preserving the symmetric order. Middle children are unaffected. The sequence of rotations is determined by the structure of the path <ref> [15] </ref>. The splay procedure can be extended to the full virtual tree with the addition of a second primitive called splicing, which exchanges a middle child with the left child of a solid subtree root (Figure 6b). <p> The e-splay algorithm is described fully in <ref> [15] </ref>, where it is shown that the amortized cost of an e-splay in a tree of size n is O (log n). In the dynamic tree data structure, every operation is implemented by O (1) extended splays followed by O (1) additional operations of amortized cost O (log n). <p> The link/condense data structure differs in that path-finding and condensation do not involve extended splays, while everting and linking do. We augment the dynamic tree data structure to allow path-finding and condensation without significantly interfering with extended splays. As defined in <ref> [15] </ref>, a dynamic tree node v contains pointers to its left and right children in the solid subtree, left (v) and right (v), and to its virtual parent, vparent (v). It also contains a bit reverse (v), used to implement eversion efficiently (see [14]). <p> The reversal state of 13 v is given by the exclusive-OR of the reverse values stored in v and all its ancestors in the solid subtree. Rules are given in reference <ref> [15] </ref> for updating the reversal bit and left, right and vparent pointers of the nodes affected by a rotation or splice. Note that the reversal states of a solid subtree root and its children can be determined by examining a constant number of reverse bits. <p> We can measure this length by the number of rotations performed, as stated at the end of Section 4. To analyze the cost of an operation in terms of the number of rotations, we extend the amortization argument used by Sleator and Tarjan. Let be a potential function <ref> [15, 22] </ref> defined on the virtual tree structure. For each node x in a virtual tree, we define the weight 16 have been deleted for clarity. <p> Let be a potential function [15, 22] defined on the virtual tree structure. For each node x in a virtual tree, we define the weight 16 have been deleted for clarity. Dotted lines represent deferred links. (a) First pass: splaying inside solid subtrees (see <ref> [15] </ref> for details of splaying). (b) Second pass: splicing dashed edges. (c) Third pass: splaying solid subtrees between deferred links. (d) Fourth pass: converting deferred links to dashed edges, followed by splicing. (e) Fifth pass: splaying along final solid path. 17 of node x, w (x), as the number of virtual <p> Sleator and Tarjan use this restricted potential function to show that in the basic dynamic tree data structure an e-splay at node v has cost at most 12lgw 0 v, where lgw 0 v is the logarithmic weight of v after the extended splay <ref> [15] </ref>. <p> (The reversal states of all nodes along the splay path are computed by an initial walk down the path.) The behavior of splaying is such that after the first two splays, v is a right child of pred (v) and pred (v) is a left child of succ (v) (see <ref> [15] </ref>). If v has no predecessor or successor, then the code involving the missing node can simply be ignored. For example, if v has no predecessor, then we need only splay at the successor. <p> From this, the rest of the results of Section 5 follow, and we can conclude that n 1 component links have cost O (n). Our analysis will be fairly terse, relying on results proven in reference <ref> [15] </ref>. The reader is advised to examine that paper for further details and explanation. We define = nodes x 5lgwx + X a (1 + log dsize (S)) From Lemma 1 of reference [15] we conclude the following: let x be a left or right child of y. <p> Our analysis will be fairly terse, relying on results proven in reference <ref> [15] </ref>. The reader is advised to examine that paper for further details and explanation. We define = nodes x 5lgwx + X a (1 + log dsize (S)) From Lemma 1 of reference [15] we conclude the following: let x be a left or right child of y. A single rotation of the edge between x and y has amortized cost 1 + 3 (5lgw (y) 5lgw (x)). This bounds the cost of a square-splice. <p> Therefore, at least k 2 rotations occur in the third pass. We charge 5 for each of these k2 rotations; the additional charge accounts for 4k 8 of the rotations left over from the first two passes. From the discussion of e-splay in reference <ref> [15] </ref>, we find that even with this additional charge, the amortized cost of the final splay is at most 5 + 15lgw (t).
Reference: [16] <author> R. Tamassia. </author> <title> A dynamic data structure for planar graph embedding. </title> <booktitle> In Proc. 15th Int. Conf. on Automata, Languages, and Programming, (ICALP 1988), Lecture Notes in Computer Science, </booktitle> <volume> vol. 317, </volume> <pages> pages 576-590. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988. </year>
Reference-contexts: Maintaining the blocks of a dynamic graph also arises in the implementation of efficient search strategies for logic programming [Graeme Port, private communication, 1988]. Tamassia <ref> [16, 17] </ref> gives a data structure for the on-line block problem that achieves O (log n) worst-case query time and O (log n) amortized update time. This paper is organized as follows.
Reference: [17] <author> R. Tamassia. </author> <title> Dynamic Data Structures for Two-Dimensional Searching. </title> <type> PhD thesis, </type> <institution> Coordinated Science Laboratory, University of Illinois at Urbana-Champagne, </institution> <year> 1988. </year> <note> Technical Report ACT-100. </note>
Reference-contexts: Maintaining the blocks of a dynamic graph also arises in the implementation of efficient search strategies for logic programming [Graeme Port, private communication, 1988]. Tamassia <ref> [16, 17] </ref> gives a data structure for the on-line block problem that achieves O (log n) worst-case query time and O (log n) amortized update time. This paper is organized as follows.
Reference: [18] <author> R. E. Tarjan. </author> <title> Depth first search and linear graph algorithms. </title> <journal> SIAM J. Computing, </journal> <volume> 1 </volume> <pages> 146-160, </pages> <year> 1972. </year>
Reference-contexts: The problems of finding the components, blocks, and bridge-blocks of a fixed graph are well-understood. Hopcroft and Tarjan [9] and Tarjan <ref> [18] </ref> give sequential algorithms that run in time O (n + m) where n = jV j and m = jEj. Logarithmic-time parallel algorithms for finding components, bridge-blocks, and blocks are given in references [1] and [24] (see also the survey paper [10]). <p> Proof. The bridge-blocks and initial BBF of G 0 can be found in time O (jE 0 j) using one of the algorithms in references <ref> [9, 18] </ref>. By Lemma 1, the total number of pointer steps and condensations is O (m), giving the bound. 2 3 Maintaining Blocks On-line The problem of maintaining blocks on-line is similar to that of maintaining bridge-blocks, and the algorithms are almost identical.
Reference: [19] <author> R. E. Tarjan. </author> <title> Efficiency of a good but not linear set union algorithm. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 22 </volume> <pages> 215-225, </pages> <year> 1975. </year>
Reference-contexts: The fastest algorithms for this problem run in O (ff (m; n)) amortized time per operation 1 and O (n) space, where m is the length of the sequence, n is the total number of elements, and ff is a functional inverse of Ackermann's function <ref> [19, 23] </ref>. In this paper we study the problems of answering queries about the blocks or bridge-blocks of a dynamic graph. We allow two on-line graph update operations to be performed on an initially null graph G: make vertex (A): Add a new vertex with no incident edges to G.
Reference: [20] <author> R. E. Tarjan. </author> <title> A class of algorithms which require nonlinear time to maintain disjoint sets. </title> <journal> J. Comput. Sys. Sci., </journal> <volume> 18 </volume> <pages> 110-127, </pages> <year> 1979. </year>
Reference-contexts: Let n be the number of elements and m the number of operations in an instance of disjoint set union. Tarjan <ref> [20] </ref> gave a lower bound of (ff (m; n)) on the amortized time per operation and Blum [4] gave a lower bound of (log n= log logn) on the worst-case time of a single operation. <p> Both these lower bounds apply to the class of separable pointer algorithms for set union <ref> [4, 20] </ref>.
Reference: [21] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA., </address> <year> 1983. </year>
Reference-contexts: The amortized cost of a condensible node operation is O (ff (k; n)). Thus the total running time is O (kff (k; n)). Since ff (a; b) = 1 for a b log log b <ref> [21] </ref>, this expression is O (n log n + m). The total time spent in the auxiliary on-line components subroutine is O (mff (m; n)), which is also O (n log n + m).
Reference: [22] <author> R. E. Tarjan. </author> <title> Amortized computational complexity. </title> <journal> SIAM J. Alg. Disc. Meth., </journal> <volume> 6 </volume> <pages> 306-318, </pages> <year> 1985. </year>
Reference-contexts: Similarly, in the block problem we allow the following query: 1 The amortized cost of an operation is the cost of a worst-case sequence of operations divided by the number of operations in the sequence. See <ref> [22] </ref> for a general discussion of amortization. 2 Multiply-appearing vertices are articulation points. 3 find block (u; v): Return the label of the block, if any, containing the pair of vertices fu; vg. <p> We can measure this length by the number of rotations performed, as stated at the end of Section 4. To analyze the cost of an operation in terms of the number of rotations, we extend the amortization argument used by Sleator and Tarjan. Let be a potential function <ref> [15, 22] </ref> defined on the virtual tree structure. For each node x in a virtual tree, we define the weight 16 have been deleted for clarity. <p> The initial value of is zero, and is always positive. By a standard property of amortized analysis <ref> [22] </ref>, this implies that A (n) bounds the actual number of rotations. 2 Note that the time per rotation is O (1) plus the time for O (1) changes to pointers plus the time for O (1) operations on the deferred link sets. 6 Path-finding and Condensation in Link/Condense Trees We
Reference: [23] <author> R. E. Tarjan and J. van Leeuwen. </author> <title> Worst-case analysis of set union algorithms. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 31 </volume> <pages> 245-281, </pages> <year> 1984. </year>
Reference-contexts: The fastest algorithms for this problem run in O (ff (m; n)) amortized time per operation 1 and O (n) space, where m is the length of the sequence, n is the total number of elements, and ff is a functional inverse of Ackermann's function <ref> [19, 23] </ref>. In this paper we study the problems of answering queries about the blocks or bridge-blocks of a dynamic graph. We allow two on-line graph update operations to be performed on an initially null graph G: make vertex (A): Add a new vertex with no incident edges to G. <p> An on-line component maintenance subroutine is used in the insert edge procedure to determine if two vertices are in the same component of G and to determine the size of a 6 component. This subroutine is a straightforward application of a fast disjoint set union algorithm <ref> [23] </ref>. Appropriate calls to the update functions of this subroutine must be made when making a new vertex or performing a component link. The tree data structure is built using condensible nodes. <p> The tree data structure is built using condensible nodes. A condensible node x consists of a block of storage, N (x), containing an arbitrary but fixed collection of fields, and a set of subnodes, S (x). The subnode sets are maintained with a fast disjoint set union algorithm <ref> [23] </ref>. The name of set S (x) is simply N (x). A condensible node is initialized with one subnode. To make a pointer p to node x, we store in p the name of some subnode s 2 S (x).
Reference: [24] <author> R. E. Tarjan and U. Vishkin. </author> <title> An efficient parallel biconnectivity algorithm. </title> <journal> SIAM J. Computing, </journal> <volume> 14 </volume> <pages> 862-874, </pages> <year> 1985. </year>
Reference-contexts: Hopcroft and Tarjan [9] and Tarjan [18] give sequential algorithms that run in time O (n + m) where n = jV j and m = jEj. Logarithmic-time parallel algorithms for finding components, bridge-blocks, and blocks are given in references [1] and <ref> [24] </ref> (see also the survey paper [10]). The problem of answering queries about edge and vertex membership in the components of a dynamic graph, i.e., a graph that is changing on-line, has been addressed in references [5, 6, 7, 13].
Reference: [25] <author> J. Westbrook and R. E. Tarjan. </author> <title> Maintaining bridge-connected and biconnected components on-line. </title> <type> Technical Report CS-TR-228-89, </type> <institution> Dept. of Computer Science, Princeton University, Princeton, NJ, </institution> <year> 1989. </year>
Reference-contexts: Their results, as well as other recent work that builds on the preliminary version of the present paper <ref> [25] </ref> are briefly discussed in Section 8. 2 Maintaining Bridge-Blocks On-Line The bridge-blocks and bridges of a connected graph have a natural tree structure that we call the bridge-block tree. <p> In recent work other researchers have addressed several problems that we posed in the preliminary version of this paper <ref> [25] </ref>. Tamassia and Di Battista [3] give a data structure that uses our condensible nodes and maintains the triconnected components of a graph; m operations require O (mff (m; n)) time if the graph is initially biconnected, and O (m log n) time otherwise.
Reference: [26] <author> A. C. Yao. </author> <title> Should tables be sorted? Journal of the Association for Computing Machinery, </title> <booktitle> 28 </booktitle> <pages> 615-628, </pages> <year> 1981. </year> <month> 34 </month>
Reference-contexts: (ff (m; n)) amortized cost bound in a general pointer machine model, and Fredman and Saks [8] have shown an (ff (m; n)) bound on the amortized cost per operation and an (log n= log logn) bound on the worst-case cost per operation in the cell probe model of Yao <ref> [26] </ref>. In this powerful and general model, memory is organized into cells, each of which can hold log n bits. In answering a query, a cell-probe algorithm is allowed to randomly access cells based on the information gathered from previous probes.
References-found: 26

