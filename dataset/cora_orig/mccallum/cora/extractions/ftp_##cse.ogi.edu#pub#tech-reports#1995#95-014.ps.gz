URL: ftp://cse.ogi.edu/pub/tech-reports/1995/95-014.ps.gz
Refering-URL: ftp://cse.ogi.edu/pub/tech-reports/README.html
Root-URL: http://www.cse.ogi.edu
Email: ffegaras,sheardg@cse.ogi.edu  
Title: Revisiting Catamorphisms over Datatypes with Embedded Functions  
Author: Leonidas Fegaras Tim Sheard 
Keyword: functional programming, lambda calculus, type systems, infinite lists, functional graphs, para-metricity theorem.  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  
Address: 95/014  20000 N.W. Walker Road P.O. Box 91000 Portland, OR 97291-1000  
Pubnum: OGI Technical Report  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> L. Fegaras, T. Sheard, and T. Zhou. </author> <title> Improving Programs which Recurse over Multiple Inductive Structures. </title> <booktitle> In ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> Orlando, Florida, </address> <pages> pp 21-32, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Writing functional programs based upon catamorphisms (folds), or other control mechanisms that are generated from algebraic type definitions, leads to benefits ranging from the ability to calculate programs from specifications [3] to encoding a good intermediate representation that supports optimization <ref> [8, 1, 2] </ref>. Recently Paterson [5] and Meijer & Hutton [4] extended the use of such control structures to datatypes that include embedded functions.
Reference: [2] <author> J. Launchbury and T. Sheard. </author> <title> Warm Fusion. </title> <booktitle> Seventh Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> La Jolla, California, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Writing functional programs based upon catamorphisms (folds), or other control mechanisms that are generated from algebraic type definitions, leads to benefits ranging from the ability to calculate programs from specifications [3] to encoding a good intermediate representation that supports optimization <ref> [8, 1, 2] </ref>. Recently Paterson [5] and Meijer & Hutton [4] extended the use of such control structures to datatypes that include embedded functions.
Reference: [3] <author> E. Meijer, M. Fokkinga, and R. Paterson. </author> <title> Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire. </title> <booktitle> In Proceedings of the 5th ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, Massachusetts, </address> <pages> pp 124-144, </pages> <month> August </month> <year> 1991. </year> <note> LNCS 523. </note>
Reference-contexts: 1 Introduction Writing functional programs based upon catamorphisms (folds), or other control mechanisms that are generated from algebraic type definitions, leads to benefits ranging from the ability to calculate programs from specifications <ref> [3] </ref> to encoding a good intermediate representation that supports optimization [8, 1, 2]. Recently Paterson [5] and Meijer & Hutton [4] extended the use of such control structures to datatypes that include embedded functions.
Reference: [4] <author> E. Meijer and G. Hutton. </author> <title> Bananas in Space: Extending Fold and Unfold to Exponential Types. </title> <booktitle> Seventh Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> La Jolla, California, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Recently Paterson [5] and Meijer & Hutton <ref> [4] </ref> extended the use of such control structures to datatypes that include embedded functions. <p> Representations like this have been avoided because of the difficulty of expressing certain kinds of computations. We now present an evaluator for terms in the style of Paterson [5], and Meijer & Hutton <ref> [4] </ref>. We use explicit recursion instead of catamorphisms to make clear what exactly is going on and to illustrate why this approach is limited. Our approach, which improves this method, is described in detail in the next section. <p> This duality is exactly what Paterson [5] and Meijer & Hutton <ref> [4] </ref> have explored. <p> For example, the following program computes mapC (g), the map over Clist: cata Clist (inL y: inL y [] inR y: inR ((inL z: inL (((a; r): (g a; r)) z) Meijer and Hutton <ref> [4] </ref> define a catamorphism cata T in conjunction with its dual the anamorphism ana T as follows: cata T (in T x) = (E T (cata T ; ana T ) x) ana T x = in (E T (ana T ; cata T ) ( x)) That is, both cata
Reference: [5] <author> R. Paterson. </author> <title> Control Structures from Types. </title> <note> Submitted to Journal of Functional Programming, 1994. Available from ftp://ftp-ala.doc.ic.ac.uk/pub/papers/R.Paterson/folds.dvi. </note>
Reference-contexts: 1 Introduction Writing functional programs based upon catamorphisms (folds), or other control mechanisms that are generated from algebraic type definitions, leads to benefits ranging from the ability to calculate programs from specifications [3] to encoding a good intermediate representation that supports optimization [8, 1, 2]. Recently Paterson <ref> [5] </ref> and Meijer & Hutton [4] extended the use of such control structures to datatypes that include embedded functions. <p> Representations like this have been avoided because of the difficulty of expressing certain kinds of computations. We now present an evaluator for terms in the style of Paterson <ref> [5] </ref>, and Meijer & Hutton [4]. We use explicit recursion instead of catamorphisms to make clear what exactly is going on and to illustrate why this approach is limited. Our approach, which improves this method, is described in detail in the next section. <p> This duality is exactly what Paterson <ref> [5] </ref> and Meijer & Hutton [4] have explored.
Reference: [6] <author> L. Paulson. </author> <title> ML for the working programmer. </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: In contrast to other approaches, we represent terms as structures with functionals: (all our examples are written in Standard ML (SML) <ref> [6] </ref>) datatype Term = Const of int j Succ j Appl of Term fi Term j Abs of Term ! Term For example, the lambda term (x:1 + x) 1 is represented by the Term construction Appl (Abs (fn x ) Appl (Succ,x)),Const 1) In most lambda term representations, lambda-abstractions are <p> One way to construct infinite lists in SML is to use lazy lists (also known as streams), which use an explicit "thunk" for the tail of a list to obtain tail laziness <ref> [6] </ref>: datatype ff Clist = Nil j Cons of ff fi (unit ! ff Clist) For example, the list circ=0:1:circ is expressed as follows: let fun circ () = Cons (0,fn () ) Cons (1,circ)) in circ () end Even though many circular structures can be defined this way, many operations
Reference: [7] <author> C. Reade. </author> <title> Elements of Functional Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference: [8] <author> T. Sheard and L. Fegaras. </author> <title> A Fold for All Seasons. </title> <booktitle> Sixth Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pp 233-242, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Writing functional programs based upon catamorphisms (folds), or other control mechanisms that are generated from algebraic type definitions, leads to benefits ranging from the ability to calculate programs from specifications [3] to encoding a good intermediate representation that supports optimization <ref> [8, 1, 2] </ref>. Recently Paterson [5] and Meijer & Hutton [4] extended the use of such control structures to datatypes that include embedded functions.
Reference: [9] <editor> P. Wadler. </editor> <booktitle> Theorems for Free! Fourth Conference on Functional Programming Languages and Computer Architecture, </booktitle> <institution> Imperial College, </institution> <address> London, </address> <month> September </month> <year> 1989. </year> <month> 12 </month>
References-found: 9

