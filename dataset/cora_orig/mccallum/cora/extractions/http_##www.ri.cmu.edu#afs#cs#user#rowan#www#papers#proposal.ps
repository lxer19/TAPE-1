URL: http://www.ri.cmu.edu/afs/cs/user/rowan/www/papers/proposal.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/user/rowan/www/papers/abstracts.html
Root-URL: 
Title: Thesis Proposal: Practical Refinement-type Checking  
Author: Rowan Davies 
Date: November 13, 1997  
Abstract: One of the major benefits of statically-typed programming languages is that they significantly improve programmer productivity. An obvious reason for this is that they dramatically reduce the amount of time spent debugging by catching most common errors at compile time. A perhaps more important reason is that programmers can use the types to guide understanding of the structure of a piece of code, both during the development of the code, and during code maintenance. One proposal for increasing these benefits is to extend an existing statically-typed language so that each ordinary type is refined by a number of refinement-types, which allow many common program invariants to be expressed and checked. In the resulting system a part of a program which is assigned a particular type may also be assigned multiple refinements of that type. Previous work indicates that automatically inferring refinement-types is algorithmically impractical in general. However, if a programmer annotates their program with enough of the intended refinement-types the problem of checking the annotated program has been found to be much easier in some preliminary experiments. The goal of this work is to demonstrate that refinement-type checking can be a practical and useful addition to a real programming language. To achieve this I intend to design an extension of Standard ML which is suitable for refinement-type checking, extend a real compiler with an efficient refinement-type checker, and demonstrate that this allows many common program invariants to be captured in a practical way.
Abstract-found: 1
Intro-found: 1
Reference: [AM91] <author> Alexander Aiken and Brian R. Murphy. </author> <title> Implementing regular tree expressions. </title> <booktitle> In Proceedings of the 1991 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 427-447, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Unfortunately, it is not clear how to combine this solution with the idea of a lattice of refinements for type constructors to be used during sort checking of expressions. An alternative approach would be to make use of the algorithms for comparing regular tree grammars with free variables in <ref> [AM91] </ref>.
Reference: [AW92] <author> Alexander Aiken and Edward L. Wimmers. </author> <title> Solving systems of set constraints. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 329-340, </pages> <month> June </month> <year> 1992. </year>
Reference: [AW93] <author> Alexander Aiken and Edward L. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year>
Reference: [AWL94] <author> Alexander Aiken, Edward L. Wimmers, and T. K. Lakshman. </author> <title> Soft typing with conditional types. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <year> 1994. </year> <month> 27 </month>
Reference: [BHLM94] <author> Edoardo Biagioni, Robert Harper, Peter Lee, and Brian Milnes. </author> <title> Signatures for a network protocol stack a systems application of Standard ML. </title> <booktitle> In 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 55-64, </pages> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Some possible extensions are described in Section 10. The experiments will be based mostly on existing SML code, including the TIL2 SML compiler, the FoxNet implementation <ref> [BHLM94] </ref>, the Twelf interpreter, and the implementation of the SML basis library included with the SML/NJ compiler. 10 Possible Extensions In this section we outline some possible extensions of the work outlined so far.
Reference: [Car97] <author> Luca Cardelli. </author> <title> Type systems. </title> <editor> In Allen B. Tucker Jr., editor, </editor> <booktitle> The Handbook of Computer Science and Engineering, chapter 103, </booktitle> <pages> pages 2208-2236. </pages> <publisher> CRC Press, </publisher> <year> 1997. </year>
Reference: [CDCV81] <author> Mario Coppo, Maria Dezani-Ciancaglini, and B. Venneri. </author> <title> Functional character of solvable terms. </title> <journal> Zeitschrift fur mathematische Logic und Grundlagen der Mathematik, </journal> <volume> 27 </volume> <pages> 45-58, </pages> <year> 1981. </year>
Reference: [CF91] <author> Robert Cartwright and Mike Fagan. </author> <title> Soft typing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 278-292, </pages> <month> June </month> <year> 1991. </year>
Reference: [Dav97] <author> Rowan Davies. </author> <title> A refinement-type checker for Standard ML. </title> <booktitle> In Proceedings of the Sixth International Conference on Algebraic Methodology and Software Technology, </booktitle> <month> December </month> <year> 1997. </year> <note> To appear. </note>
Reference: [DG94] <author> Razvan Diaconescu and Joseph Goguen. </author> <title> An Oxford survey of order sorted algebra. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 4 </volume> <pages> 363-392, </pages> <year> 1994. </year>
Reference: [DP97] <author> Rowan Davies and Frank Pfenning. </author> <title> Practical refinement-type checking. </title> <note> Unpublished draft available from http://www.cs.cmu.edu/~rowan, July 1997. </note>
Reference: [DZ92] <author> Philip W. Dart and Justin Zobel. </author> <title> A regular type language for logic programs. </title> <editor> In Frank Pfenning, editor, </editor> <booktitle> Types in Logic Programming, chapter 5, </booktitle> <pages> pages 157-187. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1992. </year>
Reference: [FA97] <author> Manuel Fahndrich and Alexander Aiken. </author> <title> Program analysis using mixed term and set constraints. </title> <booktitle> In International Static Analysis Symposium, </booktitle> <month> September </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: For example, positive and negative integers could be defined as refinements of the type of integers. Also, refinements of exceptions could be defined, and then the sort of every expression and every function sort could be annotated with the possible exceptions that could be raised, somewhat similar to <ref> [FA97] </ref> except that locally defined exceptions could be handled more cleanly by locally defined refinements. This idea could also be extended to annotations restricting the references that could be touched by an expression.
Reference: [FFK + 96] <author> Cormac Flanagan, Matthew Flatt, Shriram Krishnamurthi, Stephanie Weirich, and Matthias Felleisen. </author> <title> Catching bugs in the web of program invariants. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 23-32, </pages> <month> May </month> <year> 1996. </year>
Reference: [FP91] <author> Tim Freeman and Frank Pfenning. </author> <title> Refinement types for ML. </title> <booktitle> In Proceedings of the SIGPLAN '91 Symposium on Language Design and Implementation, </booktitle> <address> Toronto, Ontario, </address> <pages> pages 268-277. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1991. </year>
Reference: [Fre94] <author> Tim Freeman. </author> <title> Refinement Types for ML. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> March </month> <year> 1994. </year> <note> Available as technical report CMU-CS-94-110. </note>
Reference-contexts: However, it is not clear how to capture the sequential nature of pattern matching using sorts in a way that is accurate, intuitive, and has an efficient implementation. Freeman <ref> [Fre94] </ref> avoided this issue by only considering a simple elimination form for constructed types, and arguing that pattern matching can be expanded into nested eliminations. However, actually doing this expansion is not very practical, and it is not clear that it would lead to a predictable system.
Reference: [Hay94] <author> Susumu Hayashi. </author> <title> Singleton, union and intersection types. </title> <journal> Information and Computation, </journal> <volume> 109 </volume> <pages> 174-210, </pages> <year> 1994. </year>
Reference: [Hei94] <author> Nevin Heintze. </author> <title> Set based analysis of ML programs. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 306-317, </pages> <year> 1994. </year>
Reference: [Mis84] <author> Prakeesh Mishra. </author> <title> Towards a theory of types in prolog. </title> <booktitle> In Proceedings of the 1984 Symposium on Logic Programming, </booktitle> <pages> pages 289-298, </pages> <address> Atlantic City, New Jersey, </address> <year> 1984. </year>
Reference: [Mit84] <author> John Mitchell. </author> <title> Coercion and type inference (summary). </title> <booktitle> In Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 175-185, </pages> <month> January </month> <year> 1984. </year>
Reference: [Pfe91] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: Part of the code from this experiment is included in Appendix A. In the second experiment we added sorts to the parser of the Twelf interpreter (a recent reimplementation of the Elf logic programming language <ref> [Pfe91] </ref>). In this case we were able to check some complicated invariants involving an intermediate stack of unresolved operations which is used to resolve prefix, postfix and infix operations with precedence.
Reference: [Pfe93] <author> Frank Pfenning. </author> <title> Refinement types for logical frameworks. </title> <editor> In Herman Geuvers, editor, </editor> <booktitle> Informal Proceedings of the 1993 Workshop on Types for Proofs and Programs, </booktitle> <pages> pages 285-299, </pages> <address> Nijmegen, The Netherlands, </address> <month> May </month> <year> 1993. </year> <institution> University of Nijmegen. </institution> <month> 28 </month>
Reference: [Pie93] <author> Benjamin C. Pierce. </author> <title> Intersection types and bounded polymorphism. </title> <editor> In M. Bezem and J.F. Groote, editors, </editor> <booktitle> Proceedings of the International Conference on Typed Lambda Calculi and Applications, TLCA'93, </booktitle> <pages> pages 346-360, </pages> <address> Utrecht, The Netherlands, </address> <month> March </month> <year> 1993. </year> <note> Springer-Verlag LNCS 664. A version will also appear in the journal MSCS. </note>
Reference: [Rey69] <author> John C. Reynolds. </author> <title> Automatic computation of data set definitions. </title> <journal> Information Processing, </journal> <volume> 68 </volume> <pages> 456-461, </pages> <year> 1969. </year>
Reference: [Rey81] <author> John C. Reynolds. </author> <title> The essence of algol. </title> <editor> In J. W. de Bakker and J. C. van Vliet, editors, </editor> <booktitle> Proceedings of the International Symposium on Algorithmic Languages, </booktitle> <pages> pages 345-372, </pages> <address> Amsterdam, 1981. </address> <publisher> North-Holland. </publisher>
Reference: [Rey88] <author> John C. Reynolds. </author> <title> Preliminary design of the programming language Forsythe. </title> <type> Technical Report CMU-CS-88-159, </type> <institution> Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> June </month> <year> 1988. </year>
Reference: [Rey91] <author> John C. Reynolds. </author> <title> The coherence of languages with intersection types. </title> <editor> In T. Ito and A. R. Meyer, editors, </editor> <booktitle> International Conference on Theoretical Aspects of Computer Software, </booktitle> <pages> pages 675-700, </pages> <address> Sendai, Japan, </address> <month> September </month> <year> 1991. </year> <note> Springer-Verlag LNCS 526. </note>
Reference: [Rey96] <author> John C. Reynolds. </author> <title> Design of the programming language Forsythe. </title> <type> Technical Report CMU-CS-96-146, </type> <institution> Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> June </month> <year> 1996. </year>
Reference: [Sei90] <author> Helmut Seidl. </author> <title> Deciding equivalence of finite tree automata. </title> <journal> SIAM Journal of Computing, </journal> <volume> 19 </volume> <pages> 424-437, </pages> <month> June </month> <year> 1990. </year>
Reference: [Ska97] <author> Chris Skalka. </author> <title> Some decision problems for ML refinement types. </title> <type> Master's thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> July </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Skalka <ref> [Ska97] </ref> has studied algorithms designed to solve this problem. Unfortunately, it is not clear how to combine this solution with the idea of a lattice of refinements for type constructors to be used during sort checking of expressions.
Reference: [WF94] <author> Andrew K. Wright and Matthias Felleisen. </author> <title> A syntactic approach to type soundness. </title> <journal> Information and Computation, </journal> <volume> 115 </volume> <pages> 38-94, </pages> <year> 1994. </year> <note> Preliminary version is Rice Technical Report TR91-160. </note>
Reference-contexts: introduction of parametric polymorphism suffices <ref> [WF94] </ref>. An alternative to the above approach is to note that it is quite natural to extend the value restriction on parametric polymorphism to a value restriction the finite polymorphism expressed by intersection sorts. Then, in different branches of the intersection rule, different instantiations of polymorphic sorts could be chosen.
Reference: [XP97a] <author> Hongwei Xi and Frank Pfenning. </author> <title> Eliminating array bound checking through dependent types. </title> <note> Unpublished draft available from http://www.cs.cmu.edu/~fp, November 1997. </note>
Reference: [XP97b] <author> Hongwei Xi and Frank Pfenning. </author> <title> A schema for adding dependent types to ML. </title> <note> Unpublished draft available from http://www.cs.cmu.edu/~fp, July 1997. </note>
References-found: 33

