URL: http://www.cs.princeton.edu/~erez/gop.ps
Refering-URL: http://www.cs.princeton.edu/~erez/publications.html
Root-URL: http://www.cs.princeton.edu
Email: E-mail: oded@wisdom.weizmann.ac.il.  E-mail: erez@cs.toronto.edu  
Title: Computational Complexity and Knowledge Complexity  
Author: Oded Goldreich Rafail Ostrovsky Erez Petrank 
Note: Supported by grant no. 92-00226 from the United States Israel Binational Science Foundation, Jerusalem, Israel.  
Address: Rehovot, Israel.  Toronto, Toronto, Ontario, Canada M5S 3G4.  
Affiliation: Department of Computer Science and Applied Mathematics, Weizmann Institute of Science,  Department of Computer Science, University of  
Date: January 29, 1996  
Abstract: We study the computational complexity of languages which have interactive proofs of logarithmic knowledge-complexity. We show that all such languages can be recognized in BPP NP . Prior to this work, for languages with greater-than-zero knowledge-complexity only trivial computational complexity bounds were known. In the course of our proof, we relate statistical knowledge-complexity with perfect knowledge-complexity; specifically, we show that, for the honest verifier, these hierarchies coincide, up to a logarithmic additive term. fl An extended abstract of this paper appeared in the 26th ACM Symposium on Theory of Computing (STOC 94), held in Montreal, Quebec, Canada, May 23-25, 1994. z Bell Communications Research, 445 South Street, Morristown, New Jersey 07960-6438. E-mail: rafail@bellcore.com. Part of this work was done at University of California at Berkeley and International Computer Science Institute at Berkeley and supported by an NSF postdoctoral fellowship and ICSI. 
Abstract-found: 1
Intro-found: 1
Reference: [ABV-95] <author> W. Aiello, M. Bellare and R. Venkatesan. </author> <title> Knowledge on the Average Perfect, Statistical and Logarithmic. </title> <booktitle> Proceedings of the 27th Annual ACM Symposium on the Theory of Computing, ACM (1995). </booktitle>
Reference-contexts: Following the conference presentation of our work, Aiello, Bellare and Venkatesan showed that statistical zero-knowledge coincides with negligible on the average perfect knowledge-complexity <ref> [ABV-95] </ref>. Their result is stronger in two respects; it refer to all verifiers, not only the honest verifier, and it bounds the perfect knowledge-complexity by a negligible function rather than by a logarithmic one. <p> However, the challenging case is when some conversation is less probable in the simulation (than in the original interaction). Using the oracle to produce such conversations is too costly, in terms of query complexity, unless we consider average-case query complexity (as in <ref> [ABV-95] </ref>). Thus, we need a different approach. Our approach is to modify the original prover so that it truncates conversations at a point they become less probable in the simulation. This truncation is also probabilistic.
Reference: [AH-87] <author> W. Aiello and J. H -astad. </author> <title> Perfect Zero-Knowledge can be Recognized in Two Rounds. </title> <booktitle> Proceedings of the 28th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1987). </booktitle>
Reference-contexts: In this paper we will be only interested in the other two hierarchies. Previous works have provided information only concerning the zero level of these hierarchies (see, for example, Fortnow [F-89] and Aiello and Hastad <ref> [AH-87] </ref>). Our main result is an upper bound on the computational complexity of languages having logarithmic (statistical) knowledge-complexity; namely, we show that such languages are contained in BPP N P . We consider the (statistical) knowledge-complexity hierarchy to be a very natural one. <p> We consider the (statistical) knowledge-complexity hierarchy to be a very natural one. Its lowest level resides in the second level of the Polynomial-Time Hierarchy (cf., <ref> [F-89, AH-87, B-85] </ref>), whereas as a whole it covers all of PSPACE . Another hierarchy with a similar feature, which also deserves investigation, is the hierarchy of languages classified by the number of rounds in their ("shortest") interactive proof system. <p> He showed that any language that admits a zero-knowledge interactive-proof is in the class coAM. Subsequently, Aiello and Hastad <ref> [AH-87] </ref> showed that these languages are also in AM. Bellare and Petrank [BP-92] bounded the computational complexity of languages which have short interactive-proofs with low knowledge-complexity.
Reference: [B-85] <author> L. Babai. </author> <title> Trading Group Theory for Randomness. </title> <booktitle> Proceedings of the 17th Annual ACM Symposium on the Theory of Computing, ACM (1985). </booktitle>
Reference-contexts: We consider the (statistical) knowledge-complexity hierarchy to be a very natural one. Its lowest level resides in the second level of the Polynomial-Time Hierarchy (cf., <ref> [F-89, AH-87, B-85] </ref>), whereas as a whole it covers all of PSPACE . Another hierarchy with a similar feature, which also deserves investigation, is the hierarchy of languages classified by the number of rounds in their ("shortest") interactive proof system.
Reference: [BM-88] <author> L. Babai and S. Moran. </author> <title> Arthur-Merlin Games: A Randomized Proof System and a Hierarchy of Complexity Classes. </title> <journal> JCSS, </journal> <volume> Vol. 36, </volume> <pages> pages 254-276, </pages> <year> 1988. </year>
Reference-contexts: Another hierarchy with a similar feature, which also deserves investigation, is the hierarchy of languages classified by the number of rounds in their ("shortest") interactive proof system. Interestingly, the latter hierarchy has a multiplicative collapse (cf., <ref> [BM-88] </ref>) whereas no such result is known for the knowledge-complexity hierarchy. 1.1 Background on knowledge-complexity Loosely speaking, an interactive-proof system for a language L is a two-party protocol, by which a powerful prover can "convince" a probabilistic polynomial-time verifier of membership in L, but will fail (with high probability) when trying
Reference: [BMO-90] <author> M. Bellare, S. Micali and R. Ostrovsky. </author> <title> The (True) Complexity of Statistical Zero-Knowledge. </title> <booktitle> Proceedings of the 22nd Annual ACM Symposium on the Theory of Computing, ACM (1990). </booktitle>
Reference-contexts: our Main Theorem is only strengthened by referring to the honest-verifier classes, whereas Theorem 2 is arguably weaker than an analogous statement referring to the arbitrary-verifier classes. 3.2 The Perfect Case Overview Our proof of Theorem 1 follows the procedure suggested in [BP-92], which in turn follows the approach of <ref> [F-89, BMO-90, Ost-91] </ref> while introducing a new "uniform generation" procedure which builds on ideas of [Si-83, St-83, GS-89, JVV-86].
Reference: [BP-92] <author> M. Bellare and E. Petrank. </author> <title> Making Zero-Knowledge Provers Efficient. </title> <booktitle> Proceedings of the 24th Annual ACM Symposium on the Theory of Computing, ACM (1992) </booktitle>
Reference-contexts: He showed that any language that admits a zero-knowledge interactive-proof is in the class coAM. Subsequently, Aiello and Hastad [AH-87] showed that these languages are also in AM. Bellare and Petrank <ref> [BP-92] </ref> bounded the computational complexity of languages which have short interactive-proofs with low knowledge-complexity. <p> This result does not apply to the general class of low knowledge-complexity languages, since these languages might not have interactive-proofs which are both of small round complexity and low knowledge-complexity. 1.3 This work In this work we extend the result of <ref> [BP-92] </ref>, showing that any language having an interactive proof with logarithmic knowledge-complexity, can be recognized in BPP N P . We recall that BP P N P is contained in the third level of the polynomial-time hierarchy (P H). <p> Our proof that languages of logarithmic knowledge-complexity are in BP P N P consists of two parts. In the first part, we show that the BPP N P procedure described by Bellare and Pe-trank <ref> [BP-92] </ref> is applicable for recognizing languages having interactive proofs of logarithmic perfect knowledge-complexity. To this end, we use a more careful analysis than the one used in [BP-92]. <p> In the first part, we show that the BPP N P procedure described by Bellare and Pe-trank <ref> [BP-92] </ref> is applicable for recognizing languages having interactive proofs of logarithmic perfect knowledge-complexity. To this end, we use a more careful analysis than the one used in [BP-92]. In the second part of our proof, we transform interactive proofs of statistical knowledge-complexity k (n) into interactive proofs of perfect knowledge-complexity k (n) + O (log n). <p> Thus, our Main Theorem is only strengthened by referring to the honest-verifier classes, whereas Theorem 2 is arguably weaker than an analogous statement referring to the arbitrary-verifier classes. 3.2 The Perfect Case Overview Our proof of Theorem 1 follows the procedure suggested in <ref> [BP-92] </ref>, which in turn follows the approach of [F-89, BMO-90, Ost-91] while introducing a new "uniform generation" procedure which builds on ideas of [Si-83, St-83, GS-89, JVV-86]. <p> We show that the probability that the interaction (P fl ; V ) is accepting is negligible if x 62 L and greater than a polynomial fraction if x 2 L. Our proof differs from <ref> [BP-92] </ref> in the analysis of the case x 2 L (and thus we get a stronger result although we use the same procedure). This separation between the cases x 62 L and x 2 L can be amplified by sequential repetitions of the protocol (P fl ; V ). <p> So it remains to observe that we can sample the (P fl ; V ) interactions in probabilistic polynomial-time having access to an NP-oracle. This observation originates from <ref> [BP-92] </ref> and is justified as follows. Clearly, V 's part of the interaction can be produced in polynomial-time. Also, by the uniform generation procedure of [BP-92] we can implement P fl by a probabilistic polynomial-time oracle machine that has access to an NP-oracle. <p> This observation originates from <ref> [BP-92] </ref> and is justified as follows. Clearly, V 's part of the interaction can be produced in polynomial-time. Also, by the uniform generation procedure of [BP-92] we can implement P fl by a probabilistic polynomial-time oracle machine that has access to an NP-oracle. Thus, it remains only to analyze the accepting probability of (P fl ; V ) on input x. The case x 62 L follows trivially from the soundness condition of V . <p> Namely, Theorem 1 PKC (O (log n)) BPP N P As stated above, our proof follows the procedure suggested in <ref> [BP-92] </ref>. Suppose that (P; V ) is an interactive proof of perfect knowledge-complexity k (n) = O (log n) for the languages L, and let M 7 be the simulator guaranteed by Definition 2.2. Let us denote by P fl the simulation-based-prover (for M ); see x2.3. Then, Lemma 4.1 [BP-92]: <p> <ref> [BP-92] </ref>. Suppose that (P; V ) is an interactive proof of perfect knowledge-complexity k (n) = O (log n) for the languages L, and let M 7 be the simulator guaranteed by Definition 2.2. Let us denote by P fl the simulation-based-prover (for M ); see x2.3. Then, Lemma 4.1 [BP-92]: P fl can be implemented by a probabilistic polynomial-time oracle machine that has access to an NP-oracle. Lemma 4.2 (Analysis of the behavior of P fl ): 1. <p> If x 62 L then the probability that (P fl ; V ) outputs an accepting conversation is negligible (in jxj). Remark: In <ref> [BP-92] </ref>, a weaker lemma is proven. Specifically, they show that the probability that (P fl ; V ) outputs an accepting conversation on x 2 L is related to 2 k (jxj)t (jxj) , where t () is the number of rounds in the protocol. <p> We stress that our lemma does not refer to the number of rounds which may be polynomial in jxj, whereas the weaker form of <ref> [BP-92] </ref> is meaningful only for logarithmic number of rounds (i.e., t (n) = O (log n)). 4.1 Proof of Theorem 1 Combining Lemma 4.1 with the fact that V is probabilistic polynomial-time and using Lemma 4.2, we obtain a probabilistic polynomial-time oracle machine, A, that when given access to an NP-oracle
Reference: [B+ 88] <author> M. Ben-Or, S. Goldwasser, O. Goldreich, J. H -astad, J. Kilian, S. Micali and P. Rogaway. </author> <title> Everything Provable is Provable in Zero-Knowledge. </title> <booktitle> Advances in Cryptology | Proceedings of CRYPTO 88, Lecture Notes in Computer Science 403, </booktitle> <publisher> Springer-Verlag (1989). </publisher> <editor> S. Goldwasser, </editor> <publisher> ed. </publisher>
Reference-contexts: Actually, there are three hierarchies extending the three standard definitions of zero-knowledge; that is, perfect, statistical and computational. Assuming the existence of one-way functions, the third hierarchy collapses; that is, the zero level of the computational knowledge-complexity hierarchy contains all languages having interactive proof systems <ref> [GMW-86, IY-87, B+ 88] </ref>, and thus contains all levels of the (computational) knowledge-complexity hierarchy. In this paper we will be only interested in the other two hierarchies. Previous works have provided information only concerning the zero level of these hierarchies (see, for example, Fortnow [F-89] and Aiello and Hastad [AH-87]).
Reference: [BHZ-87] <author> R. Boppana, J. H -astad and S. Zachos. </author> <title> Does coN P Have Short Interactive Proofs". </title> <journal> Information Processing Letters, </journal> <volume> Vol 25 (1987), No. 2, </volume> <pages> pp 127-132. </pages>
Reference-contexts: A possible avenue for proving this conjecture is to show that languages having logarithmic knowledge-complexity are in coAM, rather than in BPP N P (recall that NP is unlikely to be in coAM see also <ref> [BHZ-87] </ref>). The second suggestion is to try to provide indications that there are languages in P SP ACE which do not have interactive proofs of linear (rather than logarithmic) knowledge-complexity. The reader can easily envision more moderate and more ambitious challenges in this direction.
Reference: [F-89] <author> L. Fortnow. </author> <title> The Complexity of Perfect Zero-Knowledge. Advances in Computing Research (ed. </title> <editor> S. </editor> <volume> Micali) Vol. </volume> <month> 18 </month> <year> (1989). </year>
Reference-contexts: In this paper we will be only interested in the other two hierarchies. Previous works have provided information only concerning the zero level of these hierarchies (see, for example, Fortnow <ref> [F-89] </ref> and Aiello and Hastad [AH-87]). Our main result is an upper bound on the computational complexity of languages having logarithmic (statistical) knowledge-complexity; namely, we show that such languages are contained in BPP N P . We consider the (statistical) knowledge-complexity hierarchy to be a very natural one. <p> We consider the (statistical) knowledge-complexity hierarchy to be a very natural one. Its lowest level resides in the second level of the Polynomial-Time Hierarchy (cf., <ref> [F-89, AH-87, B-85] </ref>), whereas as a whole it covers all of PSPACE . Another hierarchy with a similar feature, which also deserves investigation, is the hierarchy of languages classified by the number of rounds in their ("shortest") interactive proof system. <p> Furthermore, the question of how does this parameter relate to to the complexity of deciding the language is a very fundamental question. 1.2 Previous work The complexity of recognizing zero-knowledge languages was first bounded by Fortnow <ref> [F-89] </ref>. He showed that any language that admits a zero-knowledge interactive-proof is in the class coAM. Subsequently, Aiello and Hastad [AH-87] showed that these languages are also in AM. Bellare and Petrank [BP-92] bounded the computational complexity of languages which have short interactive-proofs with low knowledge-complexity. <p> The second part of our proof (i.e., the transformation of statistical knowledge-complexity to perfect knowledge-complexity) is presented in Section 5. Some concluding remarks appear in Section 6. In Appendix A, we discuss a flaw in Fortnow's paper <ref> [F-89] </ref>. We stress that the main result of [F-89] as well as its main techniques remain valid. 2 Preliminaries Let us state some of the definitions and conventions we use in the paper. Throughout this paper we use n to denote the length of the input x. <p> The second part of our proof (i.e., the transformation of statistical knowledge-complexity to perfect knowledge-complexity) is presented in Section 5. Some concluding remarks appear in Section 6. In Appendix A, we discuss a flaw in Fortnow's paper <ref> [F-89] </ref>. We stress that the main result of [F-89] as well as its main techniques remain valid. 2 Preliminaries Let us state some of the definitions and conventions we use in the paper. Throughout this paper we use n to denote the length of the input x. <p> KC (k ()) = languages having interactive proofs of perfect knowledge-complexity k (). * SKC (k ()) = languages having interactive proofs of statistical knowledge-complexity k (). 4 2.3 The simulation based prover An important ingredient in our proof is the notion of a simulation based prover, introduced by Fortnow <ref> [F-89] </ref>. Consider a simulator M that outputs conversations of an interaction between a prover P and a verifier V . We define a new prover P fl , called the simulation based prover, which selects its messages according to the conditional probabilities induced by the simulation. <p> our Main Theorem is only strengthened by referring to the honest-verifier classes, whereas Theorem 2 is arguably weaker than an analogous statement referring to the arbitrary-verifier classes. 3.2 The Perfect Case Overview Our proof of Theorem 1 follows the procedure suggested in [BP-92], which in turn follows the approach of <ref> [F-89, BMO-90, Ost-91] </ref> while introducing a new "uniform generation" procedure which builds on ideas of [Si-83, St-83, GS-89, JVV-86].
Reference: [GMS-87] <author> O. Goldreich, Y. Mansour and M. Sipser. </author> <title> Interactive Proof Systems: Provers that never Fail and Random Selection. </title> <booktitle> Proceedings of the 28th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1987). </booktitle> <pages> 21 </pages>
Reference-contexts: Then, given a two-sided interactive proof of some statistical knowledge-complexity one could first transform it to a one-sided error proof system of the same knowledge-complexity (cf., <ref> [GMS-87] </ref>). Applying the transformation for the one-sided case, to the resulting one-sided error proof system, yields an (one-sided error) interactive proof with the desired knowledge-complexity. 6 history.
Reference: [GMW-86] <author> O. Goldreich, S. Micali, and A. Wigderson, </author> <title> "Proofs that Yield Nothing But their Validity and a Methodology of Cryptographic Protocol Design", </title> <booktitle> Proc. 27th FOCS 86, See also Jour. of ACM. </booktitle> <volume> Vol 38, No 1, </volume> <month> July </month> <year> 1991, </year> <pages> pp. 691-729. </pages>
Reference-contexts: Actually, there are three hierarchies extending the three standard definitions of zero-knowledge; that is, perfect, statistical and computational. Assuming the existence of one-way functions, the third hierarchy collapses; that is, the zero level of the computational knowledge-complexity hierarchy contains all languages having interactive proof systems <ref> [GMW-86, IY-87, B+ 88] </ref>, and thus contains all levels of the (computational) knowledge-complexity hierarchy. In this paper we will be only interested in the other two hierarchies. Previous works have provided information only concerning the zero level of these hierarchies (see, for example, Fortnow [F-89] and Aiello and Hastad [AH-87]).
Reference: [GMW-87] <author> O. Goldreich, S. Micali, and A. Wigderson, </author> <title> "How to Play any Mental Game or a Completeness Theorems for Protocols of Honest Majority", </title> <type> STOC87. </type>
Reference: [GP-91] <author> O. Goldreich and E. Petrank. </author> <title> Quantifying Knowledge Complexity. </title> <booktitle> Proceedings of the 32nd Annual IEEE Symposium on the Foundations of Computer Science, </booktitle> <address> IEEE (1991). </address> <note> Submitted for publication, </note> <year> 1995. </year>
Reference-contexts: 1 Introduction The notion of knowledge-complexity was introduced in the seminal paper of Goldwasser Micali and Rackoff [GMR-85, GMR-89]. Knowledge-complexity is intended to measure the computational advantage gained by interaction. A formulation of knowledge-complexity, for the case that it is not zero, has appeared in <ref> [GP-91] </ref>. A very appealing suggestion, made by Goldwasser Micali and Rackoff, is to characterize languages according to the knowledge-complexity of their interactive proof systems [GMR-89]. The lowest level of the knowledge-complexity hierarchy is the class of languages having interactive proofs of knowledge-complexity zero, better known as zero-knowledge. <p> Actually, there are two alternative formulations of knowledge-complexity, called the oracle version and the fraction version. These formulations coincide at the zero level and differ by at most an additive constant otherwise <ref> [GP-91] </ref>. For further intuition and motivation see [GP-91]. It will be convenient to use both definitions in this paper. By the oracle formulation, the knowledge-complexity of a protocol (P; V ) is the number of oracle (bit) queries that are needed to simulate the protocol efficiently. <p> Actually, there are two alternative formulations of knowledge-complexity, called the oracle version and the fraction version. These formulations coincide at the zero level and differ by at most an additive constant otherwise <ref> [GP-91] </ref>. For further intuition and motivation see [GP-91]. It will be convenient to use both definitions in this paper. By the oracle formulation, the knowledge-complexity of a protocol (P; V ) is the number of oracle (bit) queries that are needed to simulate the protocol efficiently. <p> As mentioned above, these two measures are almost equal. Theorem <ref> [GP-91] </ref>: The fraction measure and the oracle measure are equal up to an additive constant. Since none of our results is sensitive to a difference of an additive constant in the measure, we ignore this difference in the subsequent definition as well as in the statement of our results. <p> Remark 3: The definitions of knowledge-complexity in x2.2 refer to simulations of the honest verifier. Analogous definitions of knowledge-complexity refer to simulations of arbitrary polynomial-time verifiers (cf., <ref> [GP-91] </ref>). Let us denote the corresponding classes by P KC fl () and SKC fl (). Clearly, PKC fl (k ()) PKC (k ()) and SKC fl (k ()) SKC (k ()), for every k : N 7! N. <p> Without loss of generality, we may assume that all messages are of length 1. Here we use the oracle formulation of knowledge-complexity (see Definition 2.1). Recall that Definition 2.1 only guarantees that the simulator produces output with probability at least 1 2 . Yet, employing Proposition 3.8 of <ref> [GP-91] </ref>, we get that there exists an oracle machine M , that after asking k (n) + 2 log log n queries, always produces an output so that the output is statistically close to the interaction of (P; V ).
Reference: [GMR-85] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The Knowledge Complexity of Interactive Proofs. </title> <booktitle> Proceedings of the 17th Annual ACM Symposium on the Theory of Computing, ACM (1985). </booktitle>
Reference-contexts: 1 Introduction The notion of knowledge-complexity was introduced in the seminal paper of Goldwasser Micali and Rackoff <ref> [GMR-85, GMR-89] </ref>. Knowledge-complexity is intended to measure the computational advantage gained by interaction. A formulation of knowledge-complexity, for the case that it is not zero, has appeared in [GP-91].
Reference: [GMR-89] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The Knowledge Complexity of Interactive Proofs. </title> <journal> SIAM J. Comput. </journal> <volume> 18 (1), </volume> <month> 186-208 (February </month> <year> 1989). </year>
Reference-contexts: 1 Introduction The notion of knowledge-complexity was introduced in the seminal paper of Goldwasser Micali and Rackoff <ref> [GMR-85, GMR-89] </ref>. Knowledge-complexity is intended to measure the computational advantage gained by interaction. A formulation of knowledge-complexity, for the case that it is not zero, has appeared in [GP-91]. <p> A formulation of knowledge-complexity, for the case that it is not zero, has appeared in [GP-91]. A very appealing suggestion, made by Goldwasser Micali and Rackoff, is to characterize languages according to the knowledge-complexity of their interactive proof systems <ref> [GMR-89] </ref>. The lowest level of the knowledge-complexity hierarchy is the class of languages having interactive proofs of knowledge-complexity zero, better known as zero-knowledge. Actually, there are three hierarchies extending the three standard definitions of zero-knowledge; that is, perfect, statistical and computational. <p> the knowledge-complexity hierarchy. 1.1 Background on knowledge-complexity Loosely speaking, an interactive-proof system for a language L is a two-party protocol, by which a powerful prover can "convince" a probabilistic polynomial-time verifier of membership in L, but will fail (with high probability) when trying to fool the verifier into "accepting" non-members <ref> [GMR-89] </ref>. An interactive-proof is called zero-knowledge if the interaction of any probabilistic polynomial-time machine with the predetermined prover, on common input x 2 L, can be "simulated" by a probabilistic polynomial-time machine (called the simulator), given only x [GMR-89]. <p> (with high probability) when trying to fool the verifier into "accepting" non-members <ref> [GMR-89] </ref>. An interactive-proof is called zero-knowledge if the interaction of any probabilistic polynomial-time machine with the predetermined prover, on common input x 2 L, can be "simulated" by a probabilistic polynomial-time machine (called the simulator), given only x [GMR-89]. We say that a probabilistic machine M simulates an interactive proof if the output distribution of M is statistically close to the distribution of the real interaction between the prover and the verifier. The formulation of zero-knowledge presented above is known as statistical (almost-perfect) zero-knowledge. <p> A function f : N ! [0; 1] is called negligible if for every polynomial p and all sufficiently large n's f (n) &lt; 1 p (n) . 2.1 Interactive proofs Let us recall the concept of interactive proofs, presented by <ref> [GMR-89] </ref>. For formal definitions and motivating discussions the reader is referred to [GMR-89]. A protocol between a (computationally unbounded) prover P and a (probabilistic polynomial-time) verifier V constitutes an interactive proof for a language L if there exists a negligible function * : N ! [0; 1] such that 1. <p> : N ! [0; 1] is called negligible if for every polynomial p and all sufficiently large n's f (n) &lt; 1 p (n) . 2.1 Interactive proofs Let us recall the concept of interactive proofs, presented by <ref> [GMR-89] </ref>. For formal definitions and motivating discussions the reader is referred to [GMR-89]. A protocol between a (computationally unbounded) prover P and a (probabilistic polynomial-time) verifier V constitutes an interactive proof for a language L if there exists a negligible function * : N ! [0; 1] such that 1.
Reference: [GS-89] <author> S. Goldwasser, and M. Sipser, </author> <title> Private Coins vs. Public Coins in Interactive Proof Systems, Advances in Computing Research (ed. </title> <editor> S. Micali), </editor> <booktitle> 1989, </booktitle> <volume> Vol. 5, </volume> <pages> pp. 73-90. </pages>
Reference-contexts: is arguably weaker than an analogous statement referring to the arbitrary-verifier classes. 3.2 The Perfect Case Overview Our proof of Theorem 1 follows the procedure suggested in [BP-92], which in turn follows the approach of [F-89, BMO-90, Ost-91] while introducing a new "uniform generation" procedure which builds on ideas of <ref> [Si-83, St-83, GS-89, JVV-86] </ref>. Suppose that (P; V ) is an interactive proof of perfect knowledge complexity k (n) = O (log n) for the languages L, and let M be the simulator guaranteed by the fraction formulation (i.e., Definition 2.2).
Reference: [H-94] <author> J. H -astad. </author> <title> Perfect Zero-Knowledge in AM" co-AM. Unpublished 2-page manuscript explaining the underlying ideas behind [AH-87]. </title> <year> 1994. </year>
Reference: [ILu-90] <author> R. Impagliazzo and M. Luby, </author> <title> One-Way Functions are Essential for Complexity Based Cryptography, </title> <booktitle> 30th FOCS, </booktitle> <pages> pp. 230-235, </pages> <year> 1990. </year>
Reference: [ILe-90] <author> R. Impagliazzo and L.A. Levin, </author> <title> No Better Ways to Generate Hard NP Instances than Picking Uniformly at Random, </title> <booktitle> 31st FOCS, </booktitle> <pages> pp. 812-821, </pages> <year> 1990. </year>
Reference: [IY-87] <author> R. Impagliazzo and M. Yung. </author> <title> Direct Minimum-Knowledge computations. </title> <booktitle> Advances in Cryptology | Proceedings of CRYPTO 87, Lecture Notes in Computer Science 293, </booktitle> <publisher> Springer-Verlag (1987). </publisher>
Reference-contexts: Actually, there are three hierarchies extending the three standard definitions of zero-knowledge; that is, perfect, statistical and computational. Assuming the existence of one-way functions, the third hierarchy collapses; that is, the zero level of the computational knowledge-complexity hierarchy contains all languages having interactive proof systems <ref> [GMW-86, IY-87, B+ 88] </ref>, and thus contains all levels of the (computational) knowledge-complexity hierarchy. In this paper we will be only interested in the other two hierarchies. Previous works have provided information only concerning the zero level of these hierarchies (see, for example, Fortnow [F-89] and Aiello and Hastad [AH-87]).
Reference: [JVV-86] <author> M. Jerrum, L. Valiant and V. Vazirani. </author> <title> Random Generation of Combinatorial Structures from a Uniform Distribution. </title> <booktitle> Theoretical Computer Science 43, </booktitle> <month> 169-188 </month> <year> (1986). </year>
Reference-contexts: is arguably weaker than an analogous statement referring to the arbitrary-verifier classes. 3.2 The Perfect Case Overview Our proof of Theorem 1 follows the procedure suggested in [BP-92], which in turn follows the approach of [F-89, BMO-90, Ost-91] while introducing a new "uniform generation" procedure which builds on ideas of <ref> [Si-83, St-83, GS-89, JVV-86] </ref>. Suppose that (P; V ) is an interactive proof of perfect knowledge complexity k (n) = O (log n) for the languages L, and let M be the simulator guaranteed by the fraction formulation (i.e., Definition 2.2).
Reference: [LFKN-90] <author> C. Lund, L. Fortnow, H. Karloff and N. Nisan. </author> <title> Algebraic Methods for Interactive Proof Systems. </title> <booktitle> Proceedings of the 31st Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1990). </booktitle>
Reference: [Ost-91] <author> R. Ostrovsky. </author> <title> One-Way Functions, Hard on Average Problems, and Statistical Zero-Knowledge Proofs. </title> <booktitle> Proceedings of Structures In Complexity Theory 6th Annual Conference IEEE (1991). </booktitle>
Reference-contexts: our Main Theorem is only strengthened by referring to the honest-verifier classes, whereas Theorem 2 is arguably weaker than an analogous statement referring to the arbitrary-verifier classes. 3.2 The Perfect Case Overview Our proof of Theorem 1 follows the procedure suggested in [BP-92], which in turn follows the approach of <ref> [F-89, BMO-90, Ost-91] </ref> while introducing a new "uniform generation" procedure which builds on ideas of [Si-83, St-83, GS-89, JVV-86].
Reference: [OW-93] <author> R. Ostrovsky and A. Wigderson. </author> <title> One-Way Functions are Essential For NonTrivial Zero-Knowledge, </title> <booktitle> Proc. 2nd Israeli Symp. on Theory of Computing and Systems, </booktitle> <year> 1993. </year>
Reference: [OVY-91] <author> R. Ostrovsky, R. Venkatesan and M. Yung. </author> <title> Fair Games Against an All-Powerful Adversary. </title> <booktitle> AMS DIMACS Series in Discrete Mathematics and Theoretical Computer Science. </booktitle> <volume> Vol 13. </volume> <publisher> (Jin-Yi Cai ed.) </publisher> <pages> pp. 155-169. 22 </pages>
Reference: [Sh-90] <author> A. Shamir. IP=PSPACE. </author> <booktitle> Proc. 22nd ACM Symp. on Theory of Computing, </booktitle> <pages> pages 11-15, </pages> <year> 1990. </year>
Reference: [Si-83] <author> M. Sipser. </author> <title> A Complexity Theoretic Approach to Randomness. </title> <booktitle> Proceedings of the 15th Annual ACM Symposium on the Theory of Computing, ACM (1983). </booktitle>
Reference-contexts: is arguably weaker than an analogous statement referring to the arbitrary-verifier classes. 3.2 The Perfect Case Overview Our proof of Theorem 1 follows the procedure suggested in [BP-92], which in turn follows the approach of [F-89, BMO-90, Ost-91] while introducing a new "uniform generation" procedure which builds on ideas of <ref> [Si-83, St-83, GS-89, JVV-86] </ref>. Suppose that (P; V ) is an interactive proof of perfect knowledge complexity k (n) = O (log n) for the languages L, and let M be the simulator guaranteed by the fraction formulation (i.e., Definition 2.2).
Reference: [St-83] <author> L. Stockmeyer. </author> <title> The Complexity of Approximate Counting. </title> <booktitle> Proceedings of the 15th Annual ACM Symposium on the Theory of Computing, ACM (1983). </booktitle>
Reference-contexts: is arguably weaker than an analogous statement referring to the arbitrary-verifier classes. 3.2 The Perfect Case Overview Our proof of Theorem 1 follows the procedure suggested in [BP-92], which in turn follows the approach of [F-89, BMO-90, Ost-91] while introducing a new "uniform generation" procedure which builds on ideas of <ref> [Si-83, St-83, GS-89, JVV-86] </ref>. Suppose that (P; V ) is an interactive proof of perfect knowledge complexity k (n) = O (log n) for the languages L, and let M be the simulator guaranteed by the fraction formulation (i.e., Definition 2.2).
References-found: 28

