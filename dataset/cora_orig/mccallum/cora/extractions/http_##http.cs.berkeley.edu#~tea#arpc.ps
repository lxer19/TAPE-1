URL: http://http.cs.berkeley.edu/~tea/arpc.ps
Refering-URL: http://www.cs.washington.edu/homes/tom/
Root-URL: 
Title: Anonymous RPC: Low-Latency Protection in a 64-Bit Address Space  
Author: Curtis Yarvin, Richard Bukowski, and Thomas Anderson 
Address: Berkeley  
Affiliation: Computer Science Division University of California at  
Abstract: In this paper, we propose a method of reducing the latency of cross-domain remote procedure call (RPC). Traditional systems use separate address spaces to provide memory protection between separate processes, but even with a highly optimized RPC system, the cost of switching between address spaces can make cross-domain RPC's prohibitively expensive. Our approach is to use anonymity instead of hardware page tables for protection. Logically independent memory segments are placed at random locations in the same address space and protection domain. With 64-bit virtual addresses, it is unlikely that a process will be able to locate any other segment by accidental or malicious memory probes; it impossible to corrupt a segment without knowing its location. The benefit is that a cross-domain RPC need not involve a hardware context switch. Measurements of our prototype implementation show that a round-trip null RPC takes only 7.7s on an Intel 486-33. 
Abstract-found: 1
Intro-found: 1
Reference: [Anderson et al. 1991] <author> Anderson, T., Levy, H., Bershad, B., and Lazowska, E. </author> <title> The Interaction of Architecture and Operating System Design. </title> <booktitle> In Proceedings of the 4th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 108-120, </pages> <month> April </month> <year> 1991. </year>
Reference: [Anderson et al. 1992] <author> Anderson, T., Owicki, S., Saxe, J., and Thacker, C. </author> <title> High Speed Switch Scheduling for Local Area Networks. </title> <booktitle> In Proceedings of the 5th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 98-110, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Its use can be restricted to special circumstances where speed is important, with traditional hardware domains used in all other places where protection is needed. One such use might be network communications. Some new networks <ref> [Anderson et al. 1992] </ref> offer latency on the order of microseconds, a useful feature which traditional software architectures have difficulty exporting to the user.
Reference: [Bershad et al. 1990] <author> Bershad, B., Anderson, T., Lazowska, E., and Levy, H. </author> <title> Lightweight Remote Procedure Call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1), </volume> <month> February </month> <year> 1990. </year>
Reference-contexts: And the protocol is safe; data may cross in registers, but a correctly-compiled program will never allow it to be addressed by a variable. 3.2.5 Service Management Like LRPC <ref> [Bershad et al. 1990] </ref>, ARPC is implemented by running the server procedure in the client thread. Any alternative would involve a slow interaction with operating system data structures. <p> Instead, Table 2 compares our performance to that of four other RPC implementations running on other hardware: Mach RPC [Bershad et al. 1992], SRC RPC [Schroeder & Burrows 1990], LRPC <ref> [Bershad et al. 1990] </ref>, and URPC [Bershad et al. 1991].
Reference: [Bershad et al. 1991] <author> Bershad, B., Anderson, T., Lazowska, E., and Levy, H. </author> <title> User-Level Interprocess Communication for Shared-Memory Multiprocessors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2), </volume> <month> May </month> <year> 1991. </year>
Reference-contexts: Instead, Table 2 compares our performance to that of four other RPC implementations running on other hardware: Mach RPC [Bershad et al. 1992], SRC RPC [Schroeder & Burrows 1990], LRPC [Bershad et al. 1990], and URPC <ref> [Bershad et al. 1991] </ref>. These are all optimized RPC implementations; commercial RPC implementations are frequently another order of magnitude slower. 7 Related Work The most closely related work to ours is Druschel and Peterson's fbufs, packet buffers mapped in a shared anonymous space [Druschel & Peterson 1992].
Reference: [Bershad et al. 1992] <author> Bershad, B., Draves, R., and Forin, A. </author> <title> Using Microbenchmarks to Evaluate System Performance. </title> <booktitle> In Proceedings of the Third Workshop on Workstation Operating Systems, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: It is difficult to find comparable performance figures for other RPC systems, since we do not know of any other optimized local RPC results on the same architecture. Instead, Table 2 compares our performance to that of four other RPC implementations running on other hardware: Mach RPC <ref> [Bershad et al. 1992] </ref>, SRC RPC [Schroeder & Burrows 1990], LRPC [Bershad et al. 1990], and URPC [Bershad et al. 1991].
Reference: [Birrell & Nelson 1984] <author> Birrell, A. and Nelson, B. </author> <title> Implementing Remote Procedure Calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: Traditional UNIX paradigms like pipes and sockets are not easy to use for fine-grained communication; they involve considerable system and application overhead. A better scheme for our purposes is remote procedure call (RPC) <ref> [Birrell & Nelson 1984] </ref>. In RPC, a server process exports an interface to one of its procedures; any client process can then bind to the procedure as if it was linked directly into the client.
Reference: [Carter et al. 1992] <author> Carter, J. B., Cox, A. L., Johnson, D. B., and Zwaenepoel, W. </author> <title> Distributed Operating Systems Based on a Protected Global Address Space. </title> <booktitle> In Proceedings of the Third Workshop on Workstation Operating Systems, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: It is worth noting, however, than in the past bus size has increased faster than physical memory size. Also, ARPC precludes other uses for the 64-bit address space which may be superior. Large databases [Stonebraker & Dozier 1991] or distributed systems <ref> [Carter et al. 1992] </ref> can use most of a 64-bit space. 6 Performance Results We implemented a test prototype of anonymity on an Intel 486-33 machine, capable of about 15 SPECint. The base operating system was Linux 0.98.4, a copylefted POSIX clone for the 386 architecture [Torvalds 1992]. <p> Using identical addresses to reference the same objects in all domains allows increased flexibility in sharing complex data structures. A context switch, however, still involves switching page tables. Other systems also follow this pattern <ref> [Carter et al. 1992] </ref>. 8 Conclusion Anonymous RPC exploits a simple property of memory systems: that it is impossible to address data whose address is unknown.
Reference: [Chase et al. 1992] <author> Chase, J., Levy, H., Baker-Harvey, M., and Lazowska, E. Opal: </author> <title> A Single Address Space System for 64-bit Architectures. </title> <booktitle> In Proceedings of the Third Workshop on Workstation Operating Systems, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: Unlike Pilot, Wahbe et al.'s approach is language-independent because the protection is enforced at runtime, not in the compiler. The benefit is that separate processes can run in the same address space and communicate efficiently, at the expense of a slight slowdown in memory operations. The Opal system <ref> [Chase et al. 1992] </ref> also uses a 64-bit shared address space, but each Opal task has its own protection domain; the goal is uniformity of naming. Using identical addresses to reference the same objects in all domains allows increased flexibility in sharing complex data structures.
Reference: [Dennis & Van Horn 1966] <author> Dennis, J. B. and Van Horn, E. C. </author> <title> Programming Semantics for Multipro-grammed Computations. </title> <journal> Communications of the ACM, </journal> <volume> 9(3) </volume> <pages> 143-155, </pages> <month> March </month> <year> 1966. </year>
Reference-contexts: The key to our approach is Druschel and Peterson's observation [Druschel & Peterson 1992] that, in a very large, sparse address space, virtual address mappings can act as capabilities <ref> [Dennis & Van Horn 1966] </ref>. If a process knows a segment's position in its address space, accessing it is trivial; without this knowledge, access is impossible. Protection can be accomplished by restricting the knowledge of segment mappings. We refer to this approach as anonymity.
Reference: [Druschel & Peterson 1992] <author> Druschel, P. and Peterson, L. L. </author> <title> High Performance Cross-Domain Data Trans--fer. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Arizona, </institution> <year> 1992. </year> <type> Technical Report 92-11. </type>
Reference-contexts: This could allow application interactions of a much finer grain than are now feasible, and large software systems could be structured as groups of cooperating processes instead of single monolithic entities. The key to our approach is Druschel and Peterson's observation <ref> [Druschel & Peterson 1992] </ref> that, in a very large, sparse address space, virtual address mappings can act as capabilities [Dennis & Van Horn 1966]. If a process knows a segment's position in its address space, accessing it is trivial; without this knowledge, access is impossible. <p> These are all optimized RPC implementations; commercial RPC implementations are frequently another order of magnitude slower. 7 Related Work The most closely related work to ours is Druschel and Peterson's fbufs, packet buffers mapped in a shared anonymous space <ref> [Druschel & Peterson 1992] </ref>. User-level protocols communicate via fbufs to exchange packets at very high speed. Fbufs are a much more robust and conservative use of anonymity; the user-level protocol layers which use fbufs to communicate each have their own protection domain.
Reference: [IBM 1990] <author> IBM Corporation. </author> <title> POWER Processor Architecture, </title> <year> 1990. </year>
Reference-contexts: An anonymous address space may be very sparse and difficult to manage. If logical domains become as small as one page, a traditional multilevel page-table scheme will be prohibitively expensive. However, inverted page tables <ref> [IBM 1990] </ref> will work; as will a software-loaded TLB [Kane 1987] backed by a simple search scheme such as binary tree or hash table. Tagging TLBs and virtual caches with process identifiers would decrease the cost of context switches and makes conventional protection more competitive with ARPC.
Reference: [Kane 1987] <author> Kane, G. </author> <title> MIPS R2000 RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: An anonymous address space may be very sparse and difficult to manage. If logical domains become as small as one page, a traditional multilevel page-table scheme will be prohibitively expensive. However, inverted page tables [IBM 1990] will work; as will a software-loaded TLB <ref> [Kane 1987] </ref> backed by a simple search scheme such as binary tree or hash table. Tagging TLBs and virtual caches with process identifiers would decrease the cost of context switches and makes conventional protection more competitive with ARPC.
Reference: [Massalin & Pu 1989] <author> Massalin, H. and Pu, C. </author> <title> Threads and Input/Output in the Synthesis Kernel. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. 191-201, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: That overhead was 29 instructions; of them, 15 were involved in loading static parameters, and could be eliminated were we to synthesize the intermediary for each bind <ref> [Massalin & Pu 1989] </ref>. This is somewhat more overhead than we had hoped for, but we consider it acceptable. It is difficult to find comparable performance figures for other RPC systems, since we do not know of any other optimized local RPC results on the same architecture.
Reference: [Mullender et al. 1990] <author> Mullender, S. J., van Rossum, G., Tanenbaum, A. S., van Renesse, R., and van Staveren, H. </author> <title> Amoeba: A Distributed Operating System for the 1990s. </title> <journal> IEEE Computer Magazine, </journal> <volume> 23(5) </volume> <pages> 44-54, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: In an ARPC-based system, it seems too easy for small software errors in implementation the accidental release of capabilities to leave obscure security holes that could be exploited by dedicated intruders. This is true in any system that uses cryptographic capabilities - e.g. Amoeba <ref> [Mullender et al. 1990] </ref> but especially so in ARPC, where every pointer is a capability. 4.3 Limited Uses of ARPC To be useful, ARPC need not be the main protection device in a system.
Reference: [Nat 1977] <author> National Bureau of Standards. </author> <title> The Data Encryption System, </title> <note> 1977. Federal Information Processing Standards Publication 46. </note>
Reference-contexts: So we must select the address randomly. If the address is truly random, than no better algorithm exists to discover it than brute-force search. Unfortunately, there is no such thing as a truly random number generator. The best we can do is a cryptosystem, such as DES <ref> [Nat 1977] </ref>; if the key is a secure password or code, and the plaintext an allocation sequence number, then the resulting encrypted text will be securely random.
Reference: [Redell et al. 1980] <author> Redell, D. D., Dalal, Y. K., Horsley, T. R., Lauer, H. C., Lynch, W. C., McJones, P. R., Murray, H. G., and Purcell, S. C. </author> <title> Pilot: An Operating System for a Personal Computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 81-92, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: Buffers do not need to be remapped in the middle of a transfer, nor must they be assigned to specific protocol pairs beforehand. Fbufs achieve data transfer rates near the theoretical limits of memory. Other systems, like Pilot <ref> [Redell et al. 1980] </ref>, use a single address space without separate hardware domains, and rely for protection on languages which restrict the use of pointers.
Reference: [Schroeder & Burrows 1990] <author> Schroeder, M. and Burrows, M. </author> <title> Performance of Firefly RPC. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 1-17, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: Instead, Table 2 compares our performance to that of four other RPC implementations running on other hardware: Mach RPC [Bershad et al. 1992], SRC RPC <ref> [Schroeder & Burrows 1990] </ref>, LRPC [Bershad et al. 1990], and URPC [Bershad et al. 1991].
Reference: [Stonebraker & Dozier 1991] <author> Stonebraker, M. and Dozier, J. </author> <title> Sequoia 2000: Large Capacity Object Servers to Support Global Change Research. </title> <type> Technical report, </type> <institution> Computer Science Division, University of California, Berkeley, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: It is worth noting, however, than in the past bus size has increased faster than physical memory size. Also, ARPC precludes other uses for the 64-bit address space which may be superior. Large databases <ref> [Stonebraker & Dozier 1991] </ref> or distributed systems [Carter et al. 1992] can use most of a 64-bit space. 6 Performance Results We implemented a test prototype of anonymity on an Intel 486-33 machine, capable of about 15 SPECint.
Reference: [Torvalds 1992] <author> Torvalds, L. </author> <title> Free Unix for the 386, </title> <note> 1992. finger torvalds@kruuna.helsinki.fi. </note>
Reference-contexts: The base operating system was Linux 0.98.4, a copylefted POSIX clone for the 386 architecture <ref> [Torvalds 1992] </ref>. The 486 is a 32-bit machine, and as such a truly functional implementation was impossible; however, we did our best to assure that practical concerns were treated as realistically as possible.
Reference: [Wahbe et al. 1993] <author> Wahbe, R., Lucco, S., Anderson, T., and Graham, S. </author> <title> Low Latency RPC Via Software-Enforced Protection Domains. </title> <type> Technical report, </type> <institution> Computer Science Division, University of Cal-ifornia, Berkeley, </institution> <month> April </month> <year> 1993. </year>

References-found: 20

