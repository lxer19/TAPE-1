URL: ftp://mancos.cs.utah.edu/papers/oskit-sosp97-10pt.ps.gz
Refering-URL: ftp://mancos.cs.utah.edu/papers/oskit-sosp16-abs.html
Root-URL: 
Title: The Flux OSKit: A Substrate for Kernel and Language Research  
Author: Bryan Ford Godmar Back Greg Benson Jay Lepreau Albert Lin Olin Shivers 
Affiliation: University of Utah University of California, Davis Massachusetts Institute of Technology  
Abstract: Implementing new operating systems is tedious, costly, and often impractical except for large projects. The Flux OSKit addresses this problem in a novel way by providing clean, well-documented OS components designed to be reused in a wide variety of other environments, rather than defining a new OS structure. The OSKit uses unconventional tech niques to maximize its usefulness, such as intentionally ex posing implementation details and platform-specific facili ties. Further, the OSKit demonstrates a technique that al lows unmodified code from existing mature operating sys tems to be incorporated quickly and updated regularly, by wrapping it with a small amount of carefully designed glue code to isolate its dependencies and export well-defined in terfaces. The OSKit uses this technique to incorporate over 230,000 lines of stable code including device drivers, file sys tems, and network protocols. Our experience demonstrates that this approach to component software structure and reuse has a surprisingly large impact in the OS implementation do main. Four real-world examples show how the OSKit is cat alyzing research and development in operating systems and programming languages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: A New Kernel Founda tion for UNIX Development. </title> <booktitle> In Proc. of the Summer 1986 USENIX Conf., </booktitle> <pages> pages 93-112, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Finally, in sections 7 and 8 we present status, future work, and conclusions. 2 Related Work Many OS research projects have taken code from other ex isting, stable systems to reduce the startup cost of OS re search: Mach <ref> [1] </ref> used device drivers from BSD and hard ware vendors, the x86 port of SPIN [10] uses device drivers from FreeBSD, and VINO [30] takes its device drivers, boot strap code, and low-level support for virtual memory from NetBSD.
Reference: [2] <author> G. R. Andrews. </author> <type> Personal communication, </type> <month> Feb. </month> <year> 1997. </year>
Reference-contexts: Later, during the Saguaro distributed operating system project, an SR implementation on the bare hardware was again consid ered, but abandoned due to the lack of good development tools <ref> [2] </ref>. 6.1.4 Java Finally, in a project to create a Java [19] environment on the raw hardware, we started with Kaffe [34], a freely available and portable Java virtual machine and just-in-time compiler.
Reference: [3] <author> G. R. Andrews and R. A. Olsson. </author> <title> The SR Programming Lan guage: Concurrency in Practice. </title> <publisher> The Benjamin/Cummings Publishing Co., </publisher> <address> Redwood City, California, </address> <year> 1993. </year>
Reference-contexts: By imple menting Standard ML [26] directly on the hardware using the OSKit, we are able to model hardware resources with the con structs of a functional programming language. Our port of SR (Synchronizing Resources) <ref> [3] </ref>, a parallel language in tended for systems-level programming but never extensively used for this purpose, allows us to investigate the effective ness of using a communication-oriented language for imple menting OS functionality. <p> But the de tails of doing so have been sufficiently forbidding as to pre vent these efforts from ever being completed. 6.1.3 SR SR is a language designed for writing concurrent programs, both parallel and distributed <ref> [3] </ref>, for both application and sys tems software. It offers a flexible concurrency model, and includes as inherent parts of the language entities such as threads, synchronization, and communication mechanisms.
Reference: [4] <author> A. W. Appel. </author> <title> A Runtime System. </title> <journal> Lisp and Symbolic Compu tation, </journal> <volume> 3(4) </volume> <pages> 343-380, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: The trickery involved is considered sufficiently clever as to be worth reporting in the literature <ref> [4] </ref>. Since in our case the hardware is exposed in a documented manner, we just did it. No Unix; no trickery. Java provided other examples of leveraging the exposed implementation and hardware.
Reference: [5] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge Uni versity Press, </publisher> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: In contrast to this experience, strong groups of advanced programming language researchers have been in tending, for years, to implement a sophisticated functional language directly on a raw hardware platform. For example, the Fox project at CMU <ref> [5, page 214] </ref> and the Programming Principles group at Bell Labs have at different times begun efforts to port SML/NJ to run on bare hardware.
Reference: [6] <author> A. W. Appel and D. B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <booktitle> In Third International Symp. on Programming Lan guage Implementation and Logic Programming, </booktitle> <pages> pages 1-13. </pages> <publisher> Springer-Verlag LNCS 528, </publisher> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: We built our system, called ML/OS, by porting the Standard ML of New Jersey (SML/NJ) implementation <ref> [6] </ref> to run on a PC using the OS Kit. SML/NJ is a complex, Unix-based system comprising about 144,000 lines of code, in over 1000 source files.
Reference: [7] <author> A. Baird-Smith. </author> <title> Jigsaw An Object-Oriented Web Server in Java. </title> <address> http://www.w3.org/pub/WWW/Jigsaw/. </address>
Reference-contexts: Less than three weeks later he had built a usable system that ran com plex applications such as the Jigsaw Web Server <ref> [7] </ref>, mak ing extensive use of threads, timers, and file and network I/O. The resulting system is similar in function to Sun's JavaOS [33] but with a dramatically different implementa tion.
Reference: [8] <author> F. J. Ballesteros and L. L. Fernandez. </author> <title> The Network Hardware is the Operating System. </title> <booktitle> In Proc. of the Sixth Workshop on Hot Topics in Operating Systems, </booktitle> <address> Cape Cod, MA, </address> <month> May </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: A few of the sites that have retrieved the OSKit have in formed us of their use. Among these are researchers at the University of Carlos III in Spain who have built their Off distributed adaptable microkernel <ref> [8] </ref> on top of the OSKit, and the bits and pieces microkernel (bpmk), developed in Finland. A company, Network Storage Solutions, is using the OSKit to provide the base hardware support for a net work appliance-style server.
Reference: [9] <author> G. D. Benson and R. A. Olsson. </author> <title> A Portable RunTime Sys tem for the SR Concurrent Programming Language. </title> <booktitle> In Pro ceedings of the Workshop on Run-Time Systems for Parallel Processing. </booktitle> <institution> IR-417, Department of Mathematics and Com puter Science, Vrije Universiteit, </institution> <address> Amsterdam, The Nether lands, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: The standard SR implementation [31] is tightly coupled to Unix I/O and Unix sockets, thus for the work described in this paper we started with a previously developed, more platform neutral version of SR <ref> [9] </ref>. That version removes many Unix dependencies and isolates system-dependent functionality such as threads, synchronization, and network communica tion. Our research goal in porting SR to the raw hardware is to investigate the effectiveness of a communication-oriented language for implementing OS functionality.
Reference: [10] <author> B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. E. Fi uczynski, D. Becker, C. Chambers, and S. Eggers. Extensibil ity, </author> <title> Safety, and Performance in the SPIN Operating System. </title> <booktitle> In Proc. of the 15th ACM Symp. on Operating Systems Princi ples, </booktitle> <pages> pages 267-284, </pages> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: and 8 we present status, future work, and conclusions. 2 Related Work Many OS research projects have taken code from other ex isting, stable systems to reduce the startup cost of OS re search: Mach [1] used device drivers from BSD and hard ware vendors, the x86 port of SPIN <ref> [10] </ref> uses device drivers from FreeBSD, and VINO [30] takes its device drivers, boot strap code, and low-level support for virtual memory from NetBSD.
Reference: [11] <author> A. B. Brown and M. Seltzer. </author> <title> Operating System Benchmarking in the Wake of Lmbench: A Case Study of the Performance of 17 NetBSD on the Intel x86 Architecture. </title> <booktitle> In Proc. of the 1997 ACM SIGMETRICS Conf. on Measurement and Modeling of Computer Systems, </booktitle> <address> Seattle, WA, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: We implemented a second benchmark to measure latency, similar to hbench's <ref> [11] </ref> lat tcp, called rtcp, which measures the time required for a 1-byte round trip.
Reference: [12] <author> R. Campbell, N. Islam, P. Madany, and D. Raila. </author> <title> Design ing and Implementing Choices: An Object-Oriented System in C++. </title> <journal> Communications of the ACM, </journal> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: Other VxWorks compo nents require this thread's presence, so cannot easily be used in other environments. Several object-oriented operating systems have been cre ated, such as Choices <ref> [12] </ref>, which provides a full operating system, and the Taligent [27] system, which provides OS services above an underlying microkernel. Like the OSKit, these systems attempt to provide an extensible OS structure built from customizable, replaceable components.
Reference: [13] <institution> Chesapeake Computer Consultants, Inc. </institution> <note> Test TCP (TTCP). http://www.ccci.com/tools/ttcp, 1997. </note>
Reference-contexts: accessing physical memory in this way; this constant can simply be changed into a variable initial ized by the BSD glue code on start-up to point to a region of mapped physical memory. 5 Example OSKit-Based Systems The examples distributed with the OSKit include Chesa peake's Test TCP (ttcp) benchmark <ref> [13] </ref> which measures TCP send/receive bandwidth. We implemented a second benchmark to measure latency, similar to hbench's [11] lat tcp, called rtcp, which measures the time required for a 1-byte round trip.
Reference: [14] <author> D. R. Engler, M. F. Kaashoek, and J. O'Toole Jr. Exokernel: </author> <title> An Operating System Architecture for Application-Level Re source Management. </title> <booktitle> In Proc. of the 15th ACM Symp. on Oper ating Systems Principles, </booktitle> <pages> pages 251-266, </pages> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: The OSKit allows the devel oper to save more time by providing common components in a convenient form, already separated out and documented. Recent research projects such as the exokernel <ref> [14] </ref>, SPIN, and VINO focus on creating extensible systems which allow applications to modify the behavior of the core OS to suit their particular needs. <p> However, these systems still de fine a particular, fixed set of core functionality and a set of policies by which the core can be used and extended. As the exokernel authors state, mechanism is policy, albeit with one less layer of indirection <ref> [14] </ref>. The OSKit, in contrast, makes no attempt to be a useful OS in itself and does not define any particular set of core functionality, but merely provides a suite of components from which real OS's can be built.
Reference: [15] <author> B. Ford. MOSS: </author> <title> A DOS extender based on the Flux OS Toolkit. </title> <note> Available as http://www.cs.utah.edu/projects/flux/ moss/, </note> <year> 1996. </year>
Reference-contexts: Whereas almost all components in our system reuse ex isting C-based components provided by the OSKit, Sun's was primarily written anew in Java and took much longer to build. 6.1.5 Other Uses of the OSKit We used an early version of the OSKit in a DOS exten der <ref> [15] </ref>, a small OS kernel that runs on MS-DOS and cre ates a more complete process environment for 32-bit appli cations; this DOS extender is now being used in commercial products.
Reference: [16] <author> B. Ford and E. S. Boleyn. </author> <title> MultiBoot Standard. </title> <note> Available as ftp://flux.cs.utah.edu/flux/multiboot, </note> <year> 1996. </year>
Reference-contexts: This figure shows only the approximate relationships between components; the sizes of the regions do not correspond to the sizes of the components. differences in design philosophy or requirements. To solve this problem, the OSKit directly supports the MultiBoot stan dard <ref> [16] </ref> which was cooperatively designed by members of several OS projects to provide a simple but general interface between boot loaders and OS kernels, allowing any compli ant boot loader to load any compliant OS.
Reference: [17] <author> B. Ford, M. Hibler, J. Lepreau, P. Tullmann, G. Back, and S. Clawson. </author> <title> Microkernels Meet Recursive Virtual Machines. </title> <booktitle> In Proc. of the Second Symp. on Operating Systems Design and Implementation, </booktitle> <pages> pages 137-151, </pages> <address> Seattle, WA, Oct. 1996. </address> <publisher> USENIX Assoc. </publisher>
Reference-contexts: The OS Kit can be used to bootstrap unconventional operating sys tems quickly, such as those for embedded systems and net work computers. The OSKit is heavily used in at least three OS kernels un der ongoing development at different institutions. Our own microkernel-based OS, Fluke <ref> [17] </ref>, puts almost all of the OS Kit to use. Over half of the Fluke kernel is OSKit code, and many of the servers and user-level utilities that run on top of this kernel also rely heavily on parts of the OSKit. <p> and the overall experience of using the OSKit in each case; the next section will describe in more detail specific aspects of the OSKit that proved to be particularly useful in these re search projects. 6.1.1 The Fluke OS In 1996 we developed an entirely new microkernel-based system called Fluke <ref> [17] </ref> to explore numerous ideas in funda mental kernel structuring, including scheduling mechanisms, execution models, IPC, and virtual memory.
Reference: [18] <author> S. Goel and D. Duchamp. </author> <title> Linux Device Driver Emulation in Mach. </title> <booktitle> In Proc. of the Annual USENIX 1996 Technical Conf., </booktitle> <pages> pages 65-73, </pages> <address> San Diego, CA, </address> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: This approach generalizes the technique explored by Goel at Columbia and Utah, in which Linux device drivers were used unchanged in the Mach 3.0 kernel <ref> [18] </ref>.
Reference: [19] <author> J. Gosling and H. McGilton. </author> <title> The Java Language Environment: </title>
Reference-contexts: Our port of SR (Synchronizing Resources) [3], a parallel language in tended for systems-level programming but never extensively used for this purpose, allows us to investigate the effective ness of using a communication-oriented language for imple menting OS functionality. Finally, using a Java <ref> [19] </ref> virtual machine running on the OSKit, we have prototyped a small network computer supporting a Java-based web server and other applications, as well as an active network router that dynamically executes Java bytecode embedded in network packets. <p> Be sides the obvious advantages of making the OSKit's inter faces more consistent with each other and with those widely used in component-oriented applications, COM also brings several technical advantages described below. 6 4.4.1 Implementation Hiding COM is founded on the notion of interfaces, which are com parable to Java <ref> [19] </ref> interfaces: they define a set of meth ods that can be invoked on an object without providing any direct access to the object's internal state. <p> Later, during the Saguaro distributed operating system project, an SR implementation on the bare hardware was again consid ered, but abandoned due to the lack of good development tools [2]. 6.1.4 Java Finally, in a project to create a Java <ref> [19] </ref> environment on the raw hardware, we started with Kaffe [34], a freely available and portable Java virtual machine and just-in-time compiler. Kaffe is written for a standard POSIX environment, requiring support for file I/O calls such as open and read, as well as BSD's socket API.
References-found: 19

