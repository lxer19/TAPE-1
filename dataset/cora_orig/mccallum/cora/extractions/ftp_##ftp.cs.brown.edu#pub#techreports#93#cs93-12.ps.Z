URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-12.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-12.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <editor> David R. Barstow, Howard E. Shrobe, and Erik Sandewall, eds., </editor> <title> Interactive Programming Environments. </title> <publisher> McGraw-Hill, </publisher> <year> 1984. </year>
Reference: [2] <author> Marshall P. Cline and Doug Lea, </author> <title> "The Behavior of C++ Classes," </title> <booktitle> in Proceedings of the Symposium on Object-Oriented Programming Emphasizing Practical Applications (SOOPPA), </booktitle> <pages> pp. 81-91, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Support for formal design constraints in the form of assertions or annotations was designed into Eif-fel [14], has been grafted onto Ada in the language Anna [13], and has been proposed for C++ in the form of A++ <ref> [3, 2] </ref>. This work, however, has grown out of the theory of abstract data types [12], and has tended to limit itself to formally specifying the semantics of individual functions and/or collections of functions (e.g., how the member functions within a class relate to one another).
Reference: [3] <author> Marshall P. Cline and Doug Lea, </author> <title> "Using Annotated C++," </title> <booktitle> in Proceedings of C++ at Work - '90, </booktitle> <pages> pp. 65-71, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Support for formal design constraints in the form of assertions or annotations was designed into Eif-fel [14], has been grafted onto Ada in the language Anna [13], and has been proposed for C++ in the form of A++ <ref> [3, 2] </ref>. This work, however, has grown out of the theory of abstract data types [12], and has tended to limit itself to formally specifying the semantics of individual functions and/or collections of functions (e.g., how the member functions within a class relate to one another).
Reference: [4] <author> Carolyn K. Duby, Scott Meyers, and Steven P. Reiss, "CCEL: </author> <title> A Metalanguage for C++," </title> <booktitle> in USENIX C++ Conference Proceedings, </booktitle> <month> August </month> <year> 1992. </year> <note> Also available as Brown University Computer Science Department Technical Report CS-92-51, </note> <month> October </month> <year> 1992. </year>
Reference-contexts: The most fundamental difference, then, between lint and CCEL is that CCEL was designed from the outset to allow for the addition of programmer-defined constraints. An earlier working paper describing CCEL has already been published <ref> [4] </ref>, but since the time of that publication we have made significant improvements to both the language and the software architecture built around it. <p> Use of such tools allows programmers to see not only CCEL constraint violation diagnostics, but also the CCEL source giving rise to the violation and the C++ source that violates the constraint. This makes it much easier to locate and eliminate constraint violations. 6 Our earlier working paper <ref> [4] </ref> described a prototype implementation of CCEL that was less elaborate than that shown in Figure 2.
Reference: [5] <author> Margaret A. Ellis and Bjarne Stroustrup, </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Hence B and D may be bound to any of these language constructs. This use of the term "class" is consistent with that employed by the C++ language reference manual <ref> [5] </ref>. Member functions in the CCEL class Class allow programmers to distinguish between classes, structs, and unions. 4 Sometimes what is a single conceptual constraint is best expressed using a set of simpler constraints bundled into a constraint class.
Reference: [6] <author> Keith E. Gorlen, Sanford M. Orlow, and Perry S. Plexico, </author> <title> Data Abstraction and Object-Oriented Programming in C++. </title> <publisher> John Wiley & Sons, </publisher> <year> 1990. </year>
Reference-contexts: This is an example of a design constraint, because the constraint is specific to a particular class, C, and a particular function in that class, M. This kind of constraint is common in general-purpose class libraries. For example, the NIH class library <ref> [6] </ref> contains many functions which must always be redefined if the library is to function correctly. * If a class declares a pointer member, it must also declare an assignment operator and a copy constructor. This is an example of design-independent implementation constraint.
Reference: [7] <author> Judith E. Grass and Yih-Farn Chen, </author> <title> "The C++ Information Abstractor," </title> <booktitle> in USENIX C++ Conference Proceedings, </booktitle> <pages> pp. 265-277, </pages> <year> 1990. </year>
Reference: [8] <author> Yueh hong Lin and Scott Meyers, "CCEL: </author> <title> The C++ Constraint Expression Language." </title> <note> In preparation, </note> <month> February </month> <year> 1993. </year>
Reference-contexts: Details are available in the CCEL language specification <ref> [8] </ref>. 3 A Software Architecture The architecture for our prototype constraint-checking environment is shown in Figure 2. CCEL constraints may be specified in one or more files and/or within a C++ program in the form of specially formatted comments. <p> This makes it much easier to locate and eliminate constraint violations. 6 Our earlier working paper [4] described a prototype implementation of CCEL that was less elaborate than that shown in Figure 2. We are currently implementing a second-generation prototype that corresponds to the current (much expanded) language specification <ref> [8] </ref> and that is based on the database XREFDB. 4 Application to Other Languages The classes supported by CCEL and the member functions of those classes are clearly specific to C++. The more fundamental design principles behind CCEL, however, apply equally well to other object-oriented languages.
Reference: [9] <author> Gregor Kiczales and John Lamping, </author> <title> "Issues in the Design and Specification of Class Libraries," </title> <booktitle> in Proceedings of the 1992 Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '92) (Andreas Paepcke, </booktitle> <publisher> ed.), </publisher> <pages> pp. 435-451, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The more fundamental design principles behind CCEL, however, apply equally well to other object-oriented languages. The kinds of constraints described in Section 1 exist for languages like Smalltalk and CLOS as much as they do for C++ <ref> [9] </ref>. The desireability of choosing a syntax, semantics, and conceptual model that is familiar to programmers is as important for an Eiffel constraint language as it is for CCEL. <p> short, the primary design considerations | both in terms of the language itself and the implementation of that language | are divorced from the specifics of C++ and can be directly applied to constraint languages for other object-oriented languages. 5 Related Work In their analysis of the CLOS Metaobject Protocol <ref> [9] </ref>, Kiczales and Lamping identified a number of issues germane to the design of extensible class libraries, and they proposed a set of informal techniques by which to specify requirements and restrictions on classes inheriting from the library.
Reference: [10] <author> Moises Lejter, Scott Meyers, and Steven P. Reiss, </author> <title> "Adding Semantic Information To C++ Development Environments," </title> <booktitle> in Proceedings of C++ at Work - '90, </booktitle> <pages> pp. 103-108, </pages> <month> September </month> <year> 1990. </year>
Reference: [11] <author> Moises Lejter, Scott Meyers, and Steven P. Reiss, </author> <title> "Support for Maintaining Object-Oriented Programs," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 18, no. 12, </volume> <month> December </month> <year> 1992. </year> <note> Also available as Brown University Computer Science Department Technical Report CS-91-52, August 1991. An earlier version of this paper appeared in the Proceedings of the 1991 Conference on Software Maintenance (CSM '91), October 1991. This paper is largely drawn from two other papers [15, 10]. </note>
Reference-contexts: The oracle is in essence a virtual database system containing information about C++ programs. There are many actual database systems containing such information (e.g., Reprise [20], CIA++[7], and XREFDB <ref> [11] </ref>), and our virtual database interface allows us to decouple the constraint-checker from any particular database. In fact, our eventual virtual database interface will be OQL ("Object Query Language") [19], a virtual interface to many database systems. The output of the constraint checker is a series of violation messages.
Reference: [12] <author> Barbara Liskov and John Guttag, </author> <title> Abstraction and Specification in Program Development. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: This work, however, has grown out of the theory of abstract data types <ref> [12] </ref>, and has tended to limit itself to formally specifying the semantics of individual functions and/or collections of functions (e.g., how the member functions within a class relate to one another). In general, violations of these kinds of 7 constraints can only be detected at runtime.
Reference: [13] <author> D. Luckham, F. von Henke, B. Krieg-Bruckner, and O. Owe, Anna, </author> <title> A Language for Annotating Ada Programs: Reference Manual, </title> <booktitle> vol. 260 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: CCEL is an important step towards formalizing such requirements and restrictions and toward making them amenable to automatic verification. Support for formal design constraints in the form of assertions or annotations was designed into Eif-fel [14], has been grafted onto Ada in the language Anna <ref> [13] </ref>, and has been proposed for C++ in the form of A++ [3, 2].
Reference: [14] <author> Bertrand Meyer, </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall International Series in Computer Science, Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: CCEL is an important step towards formalizing such requirements and restrictions and toward making them amenable to automatic verification. Support for formal design constraints in the form of assertions or annotations was designed into Eif-fel <ref> [14] </ref>, has been grafted onto Ada in the language Anna [13], and has been proposed for C++ in the form of A++ [3, 2].
Reference: [15] <author> Scott Meyers, </author> <title> "Working with Object-Oriented Programs: The View from the Trenches is Not Always Pretty," </title> <booktitle> in Proceedings of the Symposium on Object-Oriented Programming Emphasizing Practical Applications (SOOPPA), </booktitle> <pages> pp. 51-65, </pages> <month> September </month> <year> 1990. </year>
Reference: [16] <author> Scott Meyers, </author> <title> Effective C++: 50 Specific Ways to Improve Your Programs and Designs. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: This is an example of design-independent implementation constraint. Failure to adhere to this constraint almost always leads to incorrect program behavior <ref> [16] </ref>. * All class names must begin with an upper case letter. This is an example of one of the most common kinds of stylistic constraint. Most software development teams adopt some set of naming conventions that developers are required to follow. <p> If omitted, the set of CCEL variables is empty, the scope of applicability is global, and constraint violations are indicated by a message in a default format. As an example of a CCEL constraint, consider Meyers' admonition <ref> [16] </ref> that every base class in C++ should declare a virtual destructor: 3 BaseClassDtor ( This constraint is called "BaseClassDtor": Class B; For all classes B, Class D j D.is descendant (B); for all classes D such that D is a descendant of B, Assert (MemberFunction B::m; j there must exist <p> The following example consists of a pair of constraints that detects undeclared assignment operators for classes that contain a pointer member or are derived from classes containing a pointer member. This is an important constraint in real-world C++ programs <ref> [16] </ref> and is one that cannot be specified in C++ itself: PointersAndAssignment f // If a class contains a pointer member, it must declare an assignment operator: AssignmentMustBeDeclaredCond1 ( Class C; DataMember C::cmv j cmv.is pointer (); Assert (MemberFunction C::cmf; j cmf.name () == "operator="); ); // If a class inherits
Reference: [17] <author> Scott Meyers and Moises Lejter, </author> <title> "Automatic Detection of C++ Programming Errors: Initial Thoughts on a lint++," </title> <booktitle> in USENIX C++ Conference Proceedings, </booktitle> <pages> pp. 29-40, </pages> <month> April </month> <year> 1991. </year> <note> Also available as Brown University Computer Science Department Technical Report CS-91-51, </note> <month> August </month> <year> 1991. </year> <month> 8 </month>
Reference-contexts: programmers, but we quickly discovered that the kinds of errors C programmers need to detect are qualitatively different from the errors that C++ programmers fl This paper was originally presented at PPCP93 | the First Workshop on Principles and Practice of Constraint Program ming, April 1993. 1 need to detect <ref> [17] </ref>. lint concentrates on type mismatches and data-flow anomalies, but the stronger typing of C++ obviates the need for lint's type-checking, and data flow analysis is typically unrelated to the high-level perspective encouraged by the modular constructs of C++. <p> The scope of the constraint has been omitted, so it applies to all classes. The violation message has also been omitted. This constraint is in fact an important one in practice, because programs that violate it, though legal, almost always behave incorrectly <ref> [17] </ref>. The assertion inside a constraint is evaluated only if it is possible to find a binding for each of the universally quantified variables declared in the constraint.
Reference: [18] <author> Steven P. Reiss, </author> <title> "Connecting Tools using Message Passing in the FIELD Program Development Environment," </title> <journal> IEEE Software, </journal> <pages> pp. 57-67, </pages> <month> July </month> <year> 1990. </year> <note> Also available as Brown University Computer Science Department Technical Report CS-88-18, "Integration Mechanisms in the FIELD Environment," </note> <month> October </month> <year> 1988. </year>
Reference-contexts: The output of the constraint checker is a series of violation messages. These may be viewed as is, or they may be parsed by higher-level tools, such as Emacs [21] or the annotation editor inside FIELD <ref> [18] </ref>. Use of such tools allows programmers to see not only CCEL constraint violation diagnostics, but also the CCEL source giving rise to the violation and the C++ source that violates the constraint.
Reference: [19] <author> Steven P. Reiss and Manojit Sarkar, </author> <title> "Generating Program Abstractions." </title> <note> Working paper, </note> <month> September </month> <year> 1992. </year>
Reference-contexts: There are many actual database systems containing such information (e.g., Reprise [20], CIA++[7], and XREFDB [11]), and our virtual database interface allows us to decouple the constraint-checker from any particular database. In fact, our eventual virtual database interface will be OQL ("Object Query Language") <ref> [19] </ref>, a virtual interface to many database systems. The output of the constraint checker is a series of violation messages. These may be viewed as is, or they may be parsed by higher-level tools, such as Emacs [21] or the annotation editor inside FIELD [18].
Reference: [20] <author> David S. Rosenblum and Alexander L. Wolf, </author> <title> "Representing Semantically Analyzed C++ Code with Reprise," </title> <booktitle> in USENIX C++ Conference Proceedings, </booktitle> <pages> pp. 119-134, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: The oracle is in essence a virtual database system containing information about C++ programs. There are many actual database systems containing such information (e.g., Reprise <ref> [20] </ref>, CIA++[7], and XREFDB [11]), and our virtual database interface allows us to decouple the constraint-checker from any particular database. In fact, our eventual virtual database interface will be OQL ("Object Query Language") [19], a virtual interface to many database systems.
Reference: [21] <author> Richard M. Stallman, </author> <title> "EMACS: The Extensible, Customizable, Self-Documenting Display Editor," </title> <booktitle> in Proceedings of the ACM SIGPLAN/SIGOA Symposium on text Manipulation, </booktitle> <pages> pp. 147-156, </pages> <month> June </month> <year> 1981. </year> <note> Reprinted in [1, pp. 300-325]. </note>
Reference-contexts: The output of the constraint checker is a series of violation messages. These may be viewed as is, or they may be parsed by higher-level tools, such as Emacs <ref> [21] </ref> or the annotation editor inside FIELD [18]. Use of such tools allows programmers to see not only CCEL constraint violation diagnostics, but also the CCEL source giving rise to the violation and the C++ source that violates the constraint.
References-found: 21

