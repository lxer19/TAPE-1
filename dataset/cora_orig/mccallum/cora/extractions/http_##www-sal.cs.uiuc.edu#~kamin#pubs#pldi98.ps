URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/pldi98.ps
Refering-URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/index.html
Root-URL: http://www.cs.uiuc.edu
Email: fkaming@cs.uiuc.edu  
Title: Language implementation as a functional tool-building exercise  
Author: Sam Kamin 
Keyword: Domain-specific languages, functional languages, program generators  
Affiliation: University of Illinois at Urbana-Champaign  
Abstract: We describe an experiment in the use of domain-specific embedded languages for program generation. Specifically, we describe how the processor for the language JR has been built by embedding program generators in Standard ML. The processor is built from four program generators: a lexer generator, a parser generator, an abstract syntax generator, and an abstract syntax tree translation generator. We discuss the specifications given in these embedded languages as well as their implementation. In particular, we show that using the embedded language approach leads to powerful languages at relatively low cost. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Ahmed, D. Gelernter, </author> <title> Program builders as alternatives to high-level languages, </title> <institution> Yale Univ. C.S. Dept. </institution> <type> TR 887, </type> <month> November </month> <year> 1991. </year>
Reference-contexts: FPIC [12] is an ML-based language for specifying simple pictures. Embedding languages in this wasy is also advocated in [4, 5, 9]. Program generation is a very common activity, but program generating languages do not always seem to be considered as full-fledged languages. Examples include Gelernter's program builders <ref> [1] </ref>, and Waters's KBEmacs [17]. Each provides a fixed set of program-building operations, but there is no direct manipulation of programs, nor is it easy for users to define their own operations. Work at OGI [3] and at ISI [2] is specifically aimed at the development of program generators.
Reference: [2] <author> B. Balzer, N. Goldman, D. Wile, </author> <title> Rationale and Support for Domain Specific Languages, </title> <journal> USC/Information Sciences Institute, </journal> <note> available at http://www.isi.edu/software-sciences/dssa/dssls/dssls.html. </note>
Reference-contexts: Examples include Gelernter's program builders [1], and Waters's KBEmacs [17]. Each provides a fixed set of program-building operations, but there is no direct manipulation of programs, nor is it easy for users to define their own operations. Work at OGI [3] and at ISI <ref> [2] </ref> is specifically aimed at the development of program generators. In both cases, the specification is translated to a very-high-level language, from which an imperative language program is extracted. Our approach is more direct: the program generating language provides operations that manipulate programs, not specifications.
Reference: [3] <author> J. Bell, F. Bellegarde, J. Hook, R.B. Kieburtz, A. Kotov, J. Lewis, L. McKinney, D.P. Oliva, T. Shear, L. Tong, L. Walton, and T. Zhou, </author> <title> Software design for reliabiity and reuse: A proof-of-concept demonstration, </title> <address> TRI-Ada '94. </address>
Reference-contexts: Examples include Gelernter's program builders [1], and Waters's KBEmacs [17]. Each provides a fixed set of program-building operations, but there is no direct manipulation of programs, nor is it easy for users to define their own operations. Work at OGI <ref> [3] </ref> and at ISI [2] is specifically aimed at the development of program generators. In both cases, the specification is translated to a very-high-level language, from which an imperative language program is extracted. Our approach is more direct: the program generating language provides operations that manipulate programs, not specifications.
Reference: [4] <author> W. E. Carlson, P. Hudak, M. P. Jones, </author> <title> An experiment using Haskell to prototype "Geometric Region Servers" for navy command and control, </title> <institution> Research Report YALEU/DCS/RR-1031, Yale Univ. C. S. Dept., </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: Haskore [10] is a Haskell-based language for the specification of musical scores. Fran [7, 6] is language for describing animation models, also based on Haskell. FPIC [12] is an ML-based language for specifying simple pictures. Embedding languages in this wasy is also advocated in <ref> [4, 5, 9] </ref>. Program generation is a very common activity, but program generating languages do not always seem to be considered as full-fledged languages. Examples include Gelernter's program builders [1], and Waters's KBEmacs [17].
Reference: [5] <author> Emmanuel Chailloux, Ascander Suarez, </author> <title> mlPicT E X, a picture environment for L A T E X, </title> <booktitle> in ACM SIGPLAN Workshop on Standard ML and its Applications, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Haskore [10] is a Haskell-based language for the specification of musical scores. Fran [7, 6] is language for describing animation models, also based on Haskell. FPIC [12] is an ML-based language for specifying simple pictures. Embedding languages in this wasy is also advocated in <ref> [4, 5, 9] </ref>. Program generation is a very common activity, but program generating languages do not always seem to be considered as full-fledged languages. Examples include Gelernter's program builders [1], and Waters's KBEmacs [17].
Reference: [6] <author> C. Elliott, </author> <title> Modeling interactive 3D and multimedia animation with an embedded language, </title> <booktitle> Proc. USENIX Conf. on Domain-Specific Languages, </booktitle> <address> Santa Barbara, </address> <month> Oct. </month> <year> 1997, </year> <pages> 285-296. </pages>
Reference-contexts: 1 Introduction A number of recent studies have explored the design of new special-purpose languages by extension to existing languages. Such extensions have been called embedded domain-specific languages <ref> [9, 6] </ref>. The embedding seems to work best with functional languages, because the existence of higher-order functions allows fragments to be put together neatly. Indeed, we view this as a way of gaining acceptance for functional languages. <p> The method has been particularly championed by Hudak [10, 9], who also coined the term domain-specific embedded language. Haskore [10] is a Haskell-based language for the specification of musical scores. Fran <ref> [7, 6] </ref> is language for describing animation models, also based on Haskell. FPIC [12] is an ML-based language for specifying simple pictures. Embedding languages in this wasy is also advocated in [4, 5, 9].
Reference: [7] <author> C. Elliott, P. Hudak, </author> <title> Functional reactive animation, </title> <booktitle> Proc. Intl. Conf. on Functional Programming, </booktitle> <year> 1997. </year>
Reference-contexts: The method has been particularly championed by Hudak [10, 9], who also coined the term domain-specific embedded language. Haskore [10] is a Haskell-based language for the specification of musical scores. Fran <ref> [7, 6] </ref> is language for describing animation models, also based on Haskell. FPIC [12] is an ML-based language for specifying simple pictures. Embedding languages in this wasy is also advocated in [4, 5, 9].
Reference: [8] <author> M. Frigo, S.G. Johnson, </author> <title> The Fastest Fourier Transform in the West, </title> <type> MIT Technical Report, </type> <institution> MIT-LCS-TR-728, </institution> <month> Sept. 11, </month> <year> 1997. </year>
Reference: [9] <author> P. Hudak, </author> <title> Building domain-specific embedded languages, </title> <booktitle> position paper for Workshop on Software Engineering and Programming Languages, </booktitle> <address> Cambridge, MA, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: 1 Introduction A number of recent studies have explored the design of new special-purpose languages by extension to existing languages. Such extensions have been called embedded domain-specific languages <ref> [9, 6] </ref>. The embedding seems to work best with functional languages, because the existence of higher-order functions allows fragments to be put together neatly. Indeed, we view this as a way of gaining acceptance for functional languages. <p> The title of this paper is a deliberate take-off from [14]. 1.1 Related work A number of experiments of developing languages by embedding them in existing functional languages hae been reported. The method has been particularly championed by Hudak <ref> [10, 9] </ref>, who also coined the term domain-specific embedded language. Haskore [10] is a Haskell-based language for the specification of musical scores. Fran [7, 6] is language for describing animation models, also based on Haskell. FPIC [12] is an ML-based language for specifying simple pictures. <p> Haskore [10] is a Haskell-based language for the specification of musical scores. Fran [7, 6] is language for describing animation models, also based on Haskell. FPIC [12] is an ML-based language for specifying simple pictures. Embedding languages in this wasy is also advocated in <ref> [4, 5, 9] </ref>. Program generation is a very common activity, but program generating languages do not always seem to be considered as full-fledged languages. Examples include Gelernter's program builders [1], and Waters's KBEmacs [17].
Reference: [10] <author> Paul Hudak, Tom Makucevich, Syam Gadde, Bo Whong, </author> <title> Haskore music notation: An algebra of music, </title> <journal> J. Func. Prog., </journal> <note> to appear. </note>
Reference-contexts: The title of this paper is a deliberate take-off from [14]. 1.1 Related work A number of experiments of developing languages by embedding them in existing functional languages hae been reported. The method has been particularly championed by Hudak <ref> [10, 9] </ref>, who also coined the term domain-specific embedded language. Haskore [10] is a Haskell-based language for the specification of musical scores. Fran [7, 6] is language for describing animation models, also based on Haskell. FPIC [12] is an ML-based language for specifying simple pictures. <p> The method has been particularly championed by Hudak [10, 9], who also coined the term domain-specific embedded language. Haskore <ref> [10] </ref> is a Haskell-based language for the specification of musical scores. Fran [7, 6] is language for describing animation models, also based on Haskell. FPIC [12] is an ML-based language for specifying simple pictures. Embedding languages in this wasy is also advocated in [4, 5, 9].
Reference: [11] <editor> Paul Hudak, Simon L. Peyton Jones, and Philip Wadler (eds.), </editor> <title> Report on the Programming Language Haskell, A Non-strict Purely Functional Language (Version 1.2), </title> <journal> SIGPLAN Notices 27(5), </journal> <month> May </month> <year> 1992, </year> <note> Section R. </note>
Reference-contexts: Furthermore, this may be the program generator in which the syntactic awkwardness is most painful. One would like to write the above rules in terms of the initial concrete syntax, just as they are given in, say, the Haskell manual <ref> [11] </ref>. In this form, the second rules above might be: e ==&gt; val _ = print e and the first rule above would not be needed at all, since translation of sub-expressions is implicit.
Reference: [12] <author> S. Kamin, D. Hyatt, </author> <title> A special-purpose language for picture-drawing, </title> <booktitle> Proc. USENIX Conf. on Domain-Specific Languages, </booktitle> <address> Santa Barbara, </address> <month> Oct. </month> <year> 1997, </year> <pages> 297-310. 10 </pages>
Reference-contexts: The method has been particularly championed by Hudak [10, 9], who also coined the term domain-specific embedded language. Haskore [10] is a Haskell-based language for the specification of musical scores. Fran [7, 6] is language for describing animation models, also based on Haskell. FPIC <ref> [12] </ref> is an ML-based language for specifying simple pictures. Embedding languages in this wasy is also advocated in [4, 5, 9]. Program generation is a very common activity, but program generating languages do not always seem to be considered as full-fledged languages.
Reference: [13] <author> T. Sheard, N. Nelson, </author> <title> Type safe abstractions using program generators, </title> <type> Tech. Report 95-013, </type> <institution> Oregon Graduate Institute, Computer Science Dept., </institution> <year> 1995. </year>
Reference-contexts: However, these languages are written in PERL, and are not themselves functional languages. Sheard and Nelson have specifically addressed the use of ML as a meta-language for itself <ref> [13] </ref>. Their concern is to guarantee the type correctness of generated ML programs. 2 The experiment Our interpreter is at present built on four domain-specific languages, which are used to specify programs in C++: * Lexer generator.
Reference: [14] <author> Diomidis Spinellis, </author> <title> Implementing Haskell: Language implementation as a tool building exercise, </title> <booktitle> Software: Concepts and Tools 14, </booktitle> <year> 1993, </year> <pages> 37-48. </pages>
Reference-contexts: The interpreter is, fl Partially supported by NSF grant CCR 96-19644 1 at present, based on four domain-specific languages. These are embedded in Standard ML [15]. In the next section we describe the structure of the interpreter and give a brief overview of each of the four languages. Spinellis <ref> [14] </ref> characterizes language implementation as a tool-building process. This paper advocates that the tools be built in a functional language. The title of this paper is a deliberate take-off from [14]. 1.1 Related work A number of experiments of developing languages by embedding them in existing functional languages hae been reported. <p> Spinellis <ref> [14] </ref> characterizes language implementation as a tool-building process. This paper advocates that the tools be built in a functional language. The title of this paper is a deliberate take-off from [14]. 1.1 Related work A number of experiments of developing languages by embedding them in existing functional languages hae been reported. The method has been particularly championed by Hudak [10, 9], who also coined the term domain-specific embedded language. <p> Our approach is more direct: the program generating language provides operations that manipulate programs, not specifications. Furthermore, that language has powerful features inherited from its base language, and the translation is not dependent upon the success of a compiler in compiling a very-high-level language down to imperative code. Spinellis <ref> [14] </ref> describes an implementation of Haskell which is similar to our implementation of JR in that he builds a variety of mini-languages to specify the various phases of the compiler. However, these languages are written in PERL, and are not themselves functional languages.
Reference: [15] <institution> Standard ML of New Jersey User's Guide, </institution> <month> Feb. 15, </month> <year> 1993, </year> <note> available at http://www.cs.princeton.edu/~appel/smlnj/. </note>
Reference-contexts: We have used them to develop an interpreter for an ML-like language that we call JR. The interpreter is, fl Partially supported by NSF grant CCR 96-19644 1 at present, based on four domain-specific languages. These are embedded in Standard ML <ref> [15] </ref>. In the next section we describe the structure of the interpreter and give a brief overview of each of the four languages. Spinellis [14] characterizes language implementation as a tool-building process. This paper advocates that the tools be built in a functional language.
Reference: [16] <author> D. Wang, A. Appel, J. Korn, C. Serra, </author> <title> The Zephyr abstract syntax description language, </title> <booktitle> Proc. USENIX Conf. on Domain-Specific Languages, </booktitle> <address> Santa Barbara, </address> <month> Oct. </month> <year> 1997, </year> <pages> 213-227. </pages>
Reference-contexts: The functions generated also include constructors, a print operation (for debugging), and an overwrite operation to replace one node's contents by another's. Thus, this is kind of a low-rent version of the abstract syntax generator described in <ref> [16] </ref>. Although in principle it does very little, in practice it is extremely useful.
Reference: [17] <author> R. C. Waters, </author> <title> The Programmer's Apprentice: A session with KBEmacs, </title> <journal> IEEE Trans. Software Eng. </journal> <volume> SE-11(11), </volume> <pages> 1296-1320, </pages> <month> Nov. </month> <year> 1985. </year> <month> 11 </month>
Reference-contexts: Embedding languages in this wasy is also advocated in [4, 5, 9]. Program generation is a very common activity, but program generating languages do not always seem to be considered as full-fledged languages. Examples include Gelernter's program builders [1], and Waters's KBEmacs <ref> [17] </ref>. Each provides a fixed set of program-building operations, but there is no direct manipulation of programs, nor is it easy for users to define their own operations. Work at OGI [3] and at ISI [2] is specifically aimed at the development of program generators.
References-found: 17

