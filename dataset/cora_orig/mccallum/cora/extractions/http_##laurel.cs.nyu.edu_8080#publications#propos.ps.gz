URL: http://laurel.cs.nyu.edu:8080/publications/propos.ps.gz
Refering-URL: http://laurel.cs.nyu.edu:8080/disser/
Root-URL: http://www.cs.nyu.edu
Email: yung@cs.nyu.edu  
Title: Update-in-place Analysis for Sets  
Author: Chung Yung 
Date: December 15, 1997  
Address: New York University  
Affiliation: Computer Science Department Courant Institute of Mathematical Sciences  
Note: Dissertation Proposal  
Abstract: This paper describes a doctoral dissertation proposal on the update-in-place analysis for sets. Pure functional languages do not allow mutations, destructive updates, or selective updates so that straightforward implementations of functional language compilers may induce large amounts of copying to preserve program semantics. The unnecessary copying of data can increase both the execution time and the memory requirements of an application. Introducing sets to functional languages as a primitive data constructor posts a new problem of update-in-place analysis in functional languages. Moreover, most of the compiler optimization techniques depend on the side-effects and the update-in-place analysis serves as the premise of applying such optimization techniques. Among other compiler optimization techniques, finite differencing captures common yet distinctive program constructions of costly repeated calculations and transforms them into more efficient incremental program constructions. This dissertation is an attempt to explore the update-in-place analysis for sets in functional languages in order to apply finite differencing to compiling pure functional languages. In this dissertation proposal, we will describe the idea of update-in-place analysis for sets and the idea of applying finite differencing to functional languages. We will also include the dissertation project plan.
Abstract-found: 1
Intro-found: 1
Reference: [AR95] <author> S. Anglade, and G. Richard. "S3L: </author> <title> a Fair Functional Language Implementing Infinite Sets," </title> <note> appeared in TENCON '91, revised on November 1995. </note>
Reference-contexts: e 1 :: e 2 e 1 with e 2 hd e rep e tl e e 1 less e 2 isnil e isemp e Table 1: list operations and set operations 3.2 S3L S3L is a functional language developed at Orleans University, France, that allows easy manipulation of sets <ref> [AR95] </ref>. In S3L, sets are native objects. They can be finite or infinite, and for an efficient implementation multiple occurrences of the same object are allowed. The main features of S3L are: * Sets are considered as first class citizens.
Reference: [App92] <author> A. W. Appel. </author> <title> Compiling with Continuations, </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference: [Ber82] <author> F. Le Berre. </author> <title> Un Langage pour manipuler les ensembles: MANENS, </title> <type> Ph.D. thesis, </type> <institution> Paris VII, </institution> <year> 1982. </year>
Reference-contexts: The optimization of programs with set operations is discussed in Freudenberger et al. [FSS83]. Manens <ref> [Ber82] </ref> and S3L [Lac92] are lambda-calculi with sets. Goubault [Gou94]described HimML, an extension of Standard ML [MTH90] with fast polymorphic set-theoretic data structures. The destructive update optimization has been considered in the literature before. One of the early works is Mycroft [Myc81].
Reference: [Blo94] <author> A. Bloss. </author> <title> "Path Analysis and the Optimization of Non-strict Functional Languages," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 16, No. 3, </volume> <pages> pp. 328-369, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: In this dissertation, we are specially interested in their relation with sets and other aggregates. 2. Update-in-place analysis for sets in functional languages: Traditional update-in-place analysis techniques on functional languages have concentrated on the application to array constructs. Some of the well-known approaches are Bloss' path analysis <ref> [Blo89a, Blo89b, Blo94] </ref>, Draghicescu and Purushothaman's variable reduction analysis [DP93], and Odersky's effect analysis [Ode91]. They all applied, in different ways, abstract interpretation frameworks for update-in-place analysis. <p> It was shown that the information inferred by path analysis can be used to implement destructive aggregate updating, in which updates on functional aggregates that are provably not live are done destructively <ref> [Blo94] </ref>. Draghicescu and Purushothaman defined the destructive update problem as follows [DP93].
Reference: [Blo89a] <author> A. Bloss. </author> <title> Path Analysis and the Optimization of Non-strict Functional Languages, </title> <type> Ph.D. thesis, </type> <institution> YALEU/DCS/RR-704, Yale University, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: An applicative-order language is treated in Hudak [Hud87] using an abstraction of reference counting. A related analysis is presented by Schmidt [Sch85, Sch88], also in an applicative-order setting. The problem is also discussed in Bloss <ref> [Blo89a, Blo89b] </ref> as an application of path analysis. A variation of path analysis is also used in Gopinath and Hennessy [GH89] for a language with call-by-value semantics. Draghicescu and Purushothaman [DP93] offered a solution to object sharing and evaluation order problems for lazy functional languages. <p> In this dissertation, we are specially interested in their relation with sets and other aggregates. 2. Update-in-place analysis for sets in functional languages: Traditional update-in-place analysis techniques on functional languages have concentrated on the application to array constructs. Some of the well-known approaches are Bloss' path analysis <ref> [Blo89a, Blo89b, Blo94] </ref>, Draghicescu and Purushothaman's variable reduction analysis [DP93], and Odersky's effect analysis [Ode91]. They all applied, in different ways, abstract interpretation frameworks for update-in-place analysis. <p> idea of combining used once analysis with Chuang and Goldberg's backward analysis techniques as a new approach for update-in-place analysis. 4.1 Abstract Interpretation Framework Bloss presented an exact non-standard semantics, called path semantics, that models order of evaluation in a nonstrict sequential functional language, and its computable abstraction, path analysis <ref> [Blo89a, Blo89b] </ref>. It was shown that the information inferred by path analysis can be used to implement destructive aggregate updating, in which updates on functional aggregates that are provably not live are done destructively [Blo94]. Draghicescu and Purushothaman defined the destructive update problem as follows [DP93].
Reference: [Blo89b] <author> A. Bloss. </author> <title> "Update Analysis and the Efficient Implementation of Functional Aggregates," </title> <booktitle> 4 th International Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pp. 26-38, </pages> <year> 1989. </year>
Reference-contexts: An applicative-order language is treated in Hudak [Hud87] using an abstraction of reference counting. A related analysis is presented by Schmidt [Sch85, Sch88], also in an applicative-order setting. The problem is also discussed in Bloss <ref> [Blo89a, Blo89b] </ref> as an application of path analysis. A variation of path analysis is also used in Gopinath and Hennessy [GH89] for a language with call-by-value semantics. Draghicescu and Purushothaman [DP93] offered a solution to object sharing and evaluation order problems for lazy functional languages. <p> In this dissertation, we are specially interested in their relation with sets and other aggregates. 2. Update-in-place analysis for sets in functional languages: Traditional update-in-place analysis techniques on functional languages have concentrated on the application to array constructs. Some of the well-known approaches are Bloss' path analysis <ref> [Blo89a, Blo89b, Blo94] </ref>, Draghicescu and Purushothaman's variable reduction analysis [DP93], and Odersky's effect analysis [Ode91]. They all applied, in different ways, abstract interpretation frameworks for update-in-place analysis. <p> idea of combining used once analysis with Chuang and Goldberg's backward analysis techniques as a new approach for update-in-place analysis. 4.1 Abstract Interpretation Framework Bloss presented an exact non-standard semantics, called path semantics, that models order of evaluation in a nonstrict sequential functional language, and its computable abstraction, path analysis <ref> [Blo89a, Blo89b] </ref>. It was shown that the information inferred by path analysis can be used to implement destructive aggregate updating, in which updates on functional aggregates that are provably not live are done destructively [Blo94]. Draghicescu and Purushothaman defined the destructive update problem as follows [DP93].
Reference: [CP93] <author> J. Cai, and R. Paige. </author> <title> "Towards Increased Productivity of Algorithm Implementation," </title> <booktitle> Proceedings on ACM SIGSOFT 1993, </booktitle> <pages> pp. 71-78, </pages> <booktitle> also in ACM Software Engineering Notes, </booktitle> <volume> Vol. 18, No. 5, </volume> <month> December </month> <year> 1993. </year>
Reference-contexts: This method generalizes John Cocke's method of strength reduction, and provides a convenient framework to implement a host of program transformations, including Earley's "iteration inversion" [PK82]. It has been applied to program transformation systems between imperative languages <ref> [CP93, Pai94] </ref>. <p> The finite dif-ferencing technique is, from a theoretical point of view, language independent and may be applied to imperative languages, functional languages, logic languages, and so on. The finite differencing technique has been successfully applied to imperative programming language transformation <ref> [CP93, Pai94] </ref>, semantic transformation on Lisp programs [Liu96], and semi-automatic program development systems [Smi90]. However, the evidence is still missing that such techniques can be applied to functional language compilation. We are interested in applying the finite differencing techniques to the functional programs with sets. <p> Finite differencing has been applied to program transformation between imperative programming languages <ref> [CP93, Pai94] </ref>, semantic transformation on Lisp programs [Liu96], and semi-automatic program development systems [Smi90]. This dissertation will explore the application of finite differencing to compiling functional languages.
Reference: [CG92] <author> T-R. Chuang, and B. Goldberg, </author> <title> "Backward Analysis for Higher-Order Functions Using Inverse Images," </title> <type> Technical Report, </type> <institution> TR1992-620, Computer Science Department, </institution> <address> New York University, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: However, how to make this idea practical in update-in-place is still not clear. Chuang and Goldberg's backward analysis is a method for performing backward analysis on higher-order functional programming languages based on computing inverse image of functions over abstract domains <ref> [CG92] </ref>. Combining Turner, Wadler and Mossin's used-once analysis and Chuang and Goldberg's back ward analysis presents a possibility for new update-in-place analysis techniques. 3. Applying the finite differencing techniques: 5 Finite differencing is a high-level compiler optimization technique. <p> However, it is not clear how this could be done. Chuang and Goldberg proposed a method for performing backward analysis on higher-order functional programming languages based on computing inverse images of functions over abstract domains <ref> [CG92] </ref>. This method may be viewed as abstract interpretation done backward. Given an abstract semantics which supports forward analysis, their method can transform it into an abstract semantics which performs backward analysis.
Reference: [DP93] <author> M. Draghicescu, and S. Purushothaman. </author> <title> "A Uniform Treatment of Order of Evaluation and Aggregate Update," </title> <booktitle> Theoretical Computer Science, B , 2(118), September 1993; also in Proceeding of the 1990 ACM Conference on Lisp and Functional Programming. </booktitle>
Reference-contexts: The problem is also discussed in Bloss [Blo89a, Blo89b] as an application of path analysis. A variation of path analysis is also used in Gopinath and Hennessy [GH89] for a language with call-by-value semantics. Draghicescu and Purushothaman <ref> [DP93] </ref> offered a solution to object sharing and evaluation order problems for lazy functional languages. Fitzgerald and Oldehoeft explored update-in-place analysis for true multidimensional arrays with a graph-based language as an intermediate form [FO95]. Odersky presented effect analysis for a safe embedding of mutable data structure in functional languages [Ode91]. <p> Update-in-place analysis for sets in functional languages: Traditional update-in-place analysis techniques on functional languages have concentrated on the application to array constructs. Some of the well-known approaches are Bloss' path analysis [Blo89a, Blo89b, Blo94], Draghicescu and Purushothaman's variable reduction analysis <ref> [DP93] </ref>, and Odersky's effect analysis [Ode91]. They all applied, in different ways, abstract interpretation frameworks for update-in-place analysis. On the other hand, Turner, Wadler, and Mossin [TWM95] proposed a new idea for update-in-place analysis with their used-once analysis, which integrates the analysis into the type system. <p> It was shown that the information inferred by path analysis can be used to implement destructive aggregate updating, in which updates on functional aggregates that are provably not live are done destructively [Blo94]. Draghicescu and Purushothaman defined the destructive update problem as follows <ref> [DP93] </ref>. Given the expression update (e 1 ; e 2 ; e 3 ), determine at compile time, if possible, that the object denoted by e 1 will not be referenced after the update is performed; in such a case a compiler can generate code to update in place.
Reference: [FO95] <author> S. M. Fitzgerald, and R. R. Oldehoeft. </author> <title> "Update-in-place Analysis for True Multidimensional Arrays," High Performance Functional Computing, </title> <editor> A. P. Wim Bohm, and J. T. Feo, </editor> <booktitle> editors, </booktitle> <pages> pp. 105-118, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: An implementation that strictly adheres to the applicative model is required to copy when data values are modified. However, the cost associated with copying large data aggregates such as arrays and sets can become prohibitive <ref> [FO95] </ref>. This leads to our investigation in optimization techniques for optimizing pure functional programs with aggregates. <p> Draghicescu and Purushothaman [DP93] offered a solution to object sharing and evaluation order problems for lazy functional languages. Fitzgerald and Oldehoeft explored update-in-place analysis for true multidimensional arrays with a graph-based language as an intermediate form <ref> [FO95] </ref>. Odersky presented effect analysis for a safe embedding of mutable data structure in functional languages [Ode91].
Reference: [FSS83] <author> S. M. Freudenberger, J. T. Schwartz, and M. Sharir. </author> <title> "Experience with the SETL Optimizer," </title> <journal> ACM Transaction on Programming Languages and Systems, pp. </journal> <volume> 26-45, Vol. 5, No. 1, </volume> <month> January </month> <year> 1983. </year>
Reference-contexts: We will describe more of this in the following sections. 1.2 Related Works The SETL programming language, developed at New York University [SDDS86, Sny90], is the first programming language with a general purpose set data structure. The optimization of programs with set operations is discussed in Freudenberger et al. <ref> [FSS83] </ref>. Manens [Ber82] and S3L [Lac92] are lambda-calculi with sets. Goubault [Gou94]described HimML, an extension of Standard ML [MTH90] with fast polymorphic set-theoretic data structures. The destructive update optimization has been considered in the literature before. One of the early works is Mycroft [Myc81]. <p> Since all functional programming languages can be viewed as syntactic variations of the -calculus, we actually validate that all functional languages can be enriched with set notations. Since a set is an unordered list whose elements appear only once <ref> [FSS83, SDDS86] </ref>, it allows us to extend the typed -calculus with sets in a straightforward way. Analogous to the list operations, we have a few set operations. Table 1 shows our extension to set operations. Please note that the rep operation is different from the arb operation in SETL.
Reference: [GH89] <author> K. Gopinath, and J. L. Hennessy. </author> <title> "Copy Elimination in Functional Languages," </title> <booktitle> 16 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 303-314, </pages> <year> 1989. </year>
Reference-contexts: A related analysis is presented by Schmidt [Sch85, Sch88], also in an applicative-order setting. The problem is also discussed in Bloss [Blo89a, Blo89b] as an application of path analysis. A variation of path analysis is also used in Gopinath and Hennessy <ref> [GH89] </ref> for a language with call-by-value semantics. Draghicescu and Purushothaman [DP93] offered a solution to object sharing and evaluation order problems for lazy functional languages. Fitzgerald and Oldehoeft explored update-in-place analysis for true multidimensional arrays with a graph-based language as an intermediate form [FO95].
Reference: [Gou94] <author> J. Goubault. "HimML: </author> <title> Standard ML with fast sets and maps," </title> <booktitle> ACM SIGPLAN Workshop on Standard ML and its Applications, </booktitle> <month> June </month> <year> 1994. </year>
Reference: [Hal77] <author> M. H. Halstead. </author> <title> Elements of Software Science, </title> <publisher> Elsevier North-Holland Publishing, </publisher> <address> New York, </address> <year> 1977. </year>
Reference: [Hud87] <author> P. Hudak. </author> <title> "A Semantic Model of Reference Counting and Its Abstraction," Abstract Interpretation of Declarative Languages, </title> <editor> S. Abramsky and C. Hankin, editors, </editor> <publisher> Ellis Horwood Press, </publisher> <year> 1987. </year>
Reference-contexts: The destructive update optimization has been considered in the literature before. One of the early works is Mycroft [Myc81]. In Hudak and Bloss [HB85], the problem is discussed in an operational model based on graph reduction. An applicative-order language is treated in Hudak <ref> [Hud87] </ref> using an abstraction of reference counting. A related analysis is presented by Schmidt [Sch85, Sch88], also in an applicative-order setting. The problem is also discussed in Bloss [Blo89a, Blo89b] as an application of path analysis.
Reference: [HB85] <author> P. Hudak, and A. Bloss. </author> <title> "The Aggregate Update Problem in Functional Programming Systems," </title> <booktitle> 12 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 300-314, </pages> <year> 1985. </year>
Reference-contexts: Manens [Ber82] and S3L [Lac92] are lambda-calculi with sets. Goubault [Gou94]described HimML, an extension of Standard ML [MTH90] with fast polymorphic set-theoretic data structures. The destructive update optimization has been considered in the literature before. One of the early works is Mycroft [Myc81]. In Hudak and Bloss <ref> [HB85] </ref>, the problem is discussed in an operational model based on graph reduction. An applicative-order language is treated in Hudak [Hud87] using an abstraction of reference counting. A related analysis is presented by Schmidt [Sch85, Sch88], also in an applicative-order setting.
Reference: [Joh85] <author> T. Johnsson. </author> <title> "Lambda Lifting: Transforming Programs to Recursive Equations," </title> <booktitle> Functional Languages and Computer Architecture, </booktitle> <volume> LNCS Vol. 201, </volume> <pages> pp. 190-203, </pages> <publisher> Springer-Verlag Press 1985. </publisher>
Reference: [Lac92] <author> J.-J. Larcrampe. "S3L a tire d'ailes," </author> <type> Technical Report 92-11, </type> <institution> Laboratoire d'Informatique Fondamentale de l'Universite d'Orleans, </institution> <address> BP 6759-45067, Orleans Cedex 2, France, </address> <year> 1992. </year>
Reference-contexts: The optimization of programs with set operations is discussed in Freudenberger et al. [FSS83]. Manens [Ber82] and S3L <ref> [Lac92] </ref> are lambda-calculi with sets. Goubault [Gou94]described HimML, an extension of Standard ML [MTH90] with fast polymorphic set-theoretic data structures. The destructive update optimization has been considered in the literature before. One of the early works is Mycroft [Myc81].
Reference: [Liu96] <author> Y. A. Liu, </author> <title> Incremental Computation: A Semantics-Based Systematic Transformational Approach, </title> <type> Ph.D. Dissertation, </type> <institution> Computer Science Department, Cornell University, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: It has been applied to program transformation systems between imperative languages [CP93, Pai94]. Some recent work caught the spirit of finite differencing and applied it to incremental computation systems <ref> [Liu96] </ref>, and semi-automatic program development systems [Smi90]. 2 Dissertation Overview This dissertation attempts to explore the update-in-place analysis in set functional languages in order to apply finite differencing techniques to the optimization phase in compiling functional languages. <p> The finite dif-ferencing technique is, from a theoretical point of view, language independent and may be applied to imperative languages, functional languages, logic languages, and so on. The finite differencing technique has been successfully applied to imperative programming language transformation [CP93, Pai94], semantic transformation on Lisp programs <ref> [Liu96] </ref>, and semi-automatic program development systems [Smi90]. However, the evidence is still missing that such techniques can be applied to functional language compilation. We are interested in applying the finite differencing techniques to the functional programs with sets. <p> Finite differencing has been applied to program transformation between imperative programming languages [CP93, Pai94], semantic transformation on Lisp programs <ref> [Liu96] </ref>, and semi-automatic program development systems [Smi90]. This dissertation will explore the application of finite differencing to compiling functional languages.
Reference: [MTH90] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML, </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The optimization of programs with set operations is discussed in Freudenberger et al. [FSS83]. Manens [Ber82] and S3L [Lac92] are lambda-calculi with sets. Goubault [Gou94]described HimML, an extension of Standard ML <ref> [MTH90] </ref> with fast polymorphic set-theoretic data structures. The destructive update optimization has been considered in the literature before. One of the early works is Mycroft [Myc81]. In Hudak and Bloss [HB85], the problem is discussed in an operational model based on graph reduction.
Reference: [Myc81] <author> A. Mycroft. </author> <title> Abstract Interpretation and Optimising Transformations for Applicative Programs, </title> <type> Ph.D. thesis, </type> <institution> University of Edinburgh, </institution> <year> 1981. </year>
Reference-contexts: Manens [Ber82] and S3L [Lac92] are lambda-calculi with sets. Goubault [Gou94]described HimML, an extension of Standard ML [MTH90] with fast polymorphic set-theoretic data structures. The destructive update optimization has been considered in the literature before. One of the early works is Mycroft <ref> [Myc81] </ref>. In Hudak and Bloss [HB85], the problem is discussed in an operational model based on graph reduction. An applicative-order language is treated in Hudak [Hud87] using an abstraction of reference counting. A related analysis is presented by Schmidt [Sch85, Sch88], also in an applicative-order setting.
Reference: [NN92] <author> F. Neilson, and H. R. Neilson. </author> <title> Two-level Functional Languages, </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference: [Nik90] <author> R. S. Nikhil. </author> <title> "The Semantics of Update in a Functional Database Programming Language," </title> <booktitle> Advances in Database Programming Languages, </booktitle> <editor> eds. F. Bancilhon and P. Buneman, </editor> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference: [Ode91] <author> M. Odersky. </author> <title> "How to Make Destructive Update Less Destructive," </title> <booktitle> Proceedings on 18 th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: Fitzgerald and Oldehoeft explored update-in-place analysis for true multidimensional arrays with a graph-based language as an intermediate form [FO95]. Odersky presented effect analysis for a safe embedding of mutable data structure in functional languages <ref> [Ode91] </ref>. Finite differencing was developed by Paige [Pai81] as a high-level global program optimization method that captures a commonly occurring yet distinctive mechanism of program construction in which repeated costly calculations are replaced by inexpensive incremental counterparts. <p> Update-in-place analysis for sets in functional languages: Traditional update-in-place analysis techniques on functional languages have concentrated on the application to array constructs. Some of the well-known approaches are Bloss' path analysis [Blo89a, Blo89b, Blo94], Draghicescu and Purushothaman's variable reduction analysis [DP93], and Odersky's effect analysis <ref> [Ode91] </ref>. They all applied, in different ways, abstract interpretation frameworks for update-in-place analysis. On the other hand, Turner, Wadler, and Mossin [TWM95] proposed a new idea for update-in-place analysis with their used-once analysis, which integrates the analysis into the type system. <p> They gave a destructive update algorithm by applying their reduction to variables analysis, which is a method detecting the variables which denote locations where the result of an expression might be stored. Odersky proposed effect analysis to show the safety of embedding mutable data structures in functional languages <ref> [Ode91] </ref>. He developed a static criterion based abstract interpretation which checks that any side-effect which a function may exert via a destructive update remains invisible. It is interesting to note that all the three approaches apply the abstract interpretation frameworks.
Reference: [Pai81] <author> R. Paige. </author> <title> Formal Differentiation: A Program Synthesis Technique, </title> <publisher> UMI Research Press, </publisher> <year> 1981. </year>
Reference-contexts: Fitzgerald and Oldehoeft explored update-in-place analysis for true multidimensional arrays with a graph-based language as an intermediate form [FO95]. Odersky presented effect analysis for a safe embedding of mutable data structure in functional languages [Ode91]. Finite differencing was developed by Paige <ref> [Pai81] </ref> as a high-level global program optimization method that captures a commonly occurring yet distinctive mechanism of program construction in which repeated costly calculations are replaced by inexpensive incremental counterparts. <p> However, it is not clear if Chuang and Goldberg's backward analysis method may successfully apply to Turner, Wadler and Mossin's used once analysis. 5 Applying Finite Differencing Finite differencing was developed by Paige <ref> [Pai81] </ref> as a global program optimization method that captures a commonly occurring yet distinctive mechanism of program construction in which repeated costly calculations are replaced by inexpensive incremental counterparts. [PK82].
Reference: [PK82] <author> R. Paige, and S. Koenig. </author> <title> "Finite Differencing of Computable Expressions," </title> <journal> ACM Transactions on Programming Languages and Systems, pp. </journal> <volume> 402-454, Vol. 4, No. 3, </volume> <month> July </month> <year> 1982. </year> <month> 14 </month>
Reference-contexts: This method generalizes John Cocke's method of strength reduction, and provides a convenient framework to implement a host of program transformations, including Earley's "iteration inversion" <ref> [PK82] </ref>. It has been applied to program transformation systems between imperative languages [CP93, Pai94]. <p> may successfully apply to Turner, Wadler and Mossin's used once analysis. 5 Applying Finite Differencing Finite differencing was developed by Paige [Pai81] as a global program optimization method that captures a commonly occurring yet distinctive mechanism of program construction in which repeated costly calculations are replaced by inexpensive incremental counterparts. <ref> [PK82] </ref>. Finite differencing has been applied to program transformation between imperative programming languages [CP93, Pai94], semantic transformation on Lisp programs [Liu96], and semi-automatic program development systems [Smi90]. This dissertation will explore the application of finite differencing to compiling functional languages.
Reference: [Pai89] <author> R. Paige. </author> <title> "Real-Time Simulation of A Set Machine on a RAM," </title> <booktitle> Proceedings on ICCI 89, </booktitle> <month> May </month> <year> 1989, </year> <note> also in Computing and Information, Vol. </note> <editor> II, eds. R. Janicki and W. </editor> <booktitle> Koczkodaj, </booktitle> <pages> pp. 69-73, </pages> <publisher> Canadian Scholars Press, </publisher> <year> 1989. </year>
Reference: [Pai94] <author> R. Paige. </author> <title> "Viewing a Program Transformation System at Work," </title> <booktitle> Joint 6th International Conference on Programming Language Implementation and Logic programming (PLILP) and 4th International Conference on Algebraic and Logic Programming (ALP), </booktitle> <volume> LNCS 844, </volume> <editor> eds. M. Hermenegildo and J. Penjam, </editor> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1994, </year> <pages> pp. 5-24. </pages>
Reference-contexts: This method generalizes John Cocke's method of strength reduction, and provides a convenient framework to implement a host of program transformations, including Earley's "iteration inversion" [PK82]. It has been applied to program transformation systems between imperative languages <ref> [CP93, Pai94] </ref>. <p> The finite dif-ferencing technique is, from a theoretical point of view, language independent and may be applied to imperative languages, functional languages, logic languages, and so on. The finite differencing technique has been successfully applied to imperative programming language transformation <ref> [CP93, Pai94] </ref>, semantic transformation on Lisp programs [Liu96], and semi-automatic program development systems [Smi90]. However, the evidence is still missing that such techniques can be applied to functional language compilation. We are interested in applying the finite differencing techniques to the functional programs with sets. <p> Finite differencing has been applied to program transformation between imperative programming languages <ref> [CP93, Pai94] </ref>, semantic transformation on Lisp programs [Liu96], and semi-automatic program development systems [Smi90]. This dissertation will explore the application of finite differencing to compiling functional languages.
Reference: [Pip97] <author> N. Pippenger. </author> <title> "Pure versus Impure Lisp," </title> <journal> Transactions on Programming Languages ans Systems, </journal> <volume> Vol. 19, No. 2, </volume> <pages> pp. 223-238, </pages> <month> March </month> <year> 1997. </year>
Reference-contexts: One feature of functional languages that goes beyond the applicative realm is the inclusion of primitives for what is variously referred to as "mutations," "destructive updates," or "selective updates." We shall refer to a functional language with or without mutation primitives as impure or pure, respectively <ref> [Pip97] </ref>. 1 1. S := --; 2. while exist a in S1 loop 3. S1 less:= a; 4. T = - x in S1 | p (x) -; 5. if f (a) in T then 6.
Reference: [Sch85] <author> D. A. Schmidt. </author> <title> "Detecting Global Variables in Denotational Specifications," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 7, No. 2, </volume> <pages> pp. 299-310, </pages> <year> 1985. </year>
Reference-contexts: One of the early works is Mycroft [Myc81]. In Hudak and Bloss [HB85], the problem is discussed in an operational model based on graph reduction. An applicative-order language is treated in Hudak [Hud87] using an abstraction of reference counting. A related analysis is presented by Schmidt <ref> [Sch85, Sch88] </ref>, also in an applicative-order setting. The problem is also discussed in Bloss [Blo89a, Blo89b] as an application of path analysis. A variation of path analysis is also used in Gopinath and Hennessy [GH89] for a language with call-by-value semantics.
Reference: [Sch88] <author> D. A. Schmidt. </author> <title> "Detecting Stack-Based Environments in Denotational Definitions," </title> <booktitle> Science of Computer Programming, </booktitle> <volume> Vol. 11, </volume> <pages> pp 107-131, </pages> <year> 1988. </year>
Reference-contexts: One of the early works is Mycroft [Myc81]. In Hudak and Bloss [HB85], the problem is discussed in an operational model based on graph reduction. An applicative-order language is treated in Hudak [Hud87] using an abstraction of reference counting. A related analysis is presented by Schmidt <ref> [Sch85, Sch88] </ref>, also in an applicative-order setting. The problem is also discussed in Bloss [Blo89a, Blo89b] as an application of path analysis. A variation of path analysis is also used in Gopinath and Hennessy [GH89] for a language with call-by-value semantics.
Reference: [SDDS86] <author> J. T. Schwartz, R. B. K. Dewar, E. Dubinsky, E. Schonberg. </author> <title> Programming With Sets: An Introduction to SETL, </title> <publisher> Springer-Verlag Press, </publisher> <year> 1986. </year>
Reference-contexts: Therefore, the computation of the program in Figure 4 can be done in O (n) time, as we expected. We will describe more of this in the following sections. 1.2 Related Works The SETL programming language, developed at New York University <ref> [SDDS86, Sny90] </ref>, is the first programming language with a general purpose set data structure. The optimization of programs with set operations is discussed in Freudenberger et al. [FSS83]. Manens [Ber82] and S3L [Lac92] are lambda-calculi with sets. <p> Since all functional programming languages can be viewed as syntactic variations of the -calculus, we actually validate that all functional languages can be enriched with set notations. Since a set is an unordered list whose elements appear only once <ref> [FSS83, SDDS86] </ref>, it allows us to extend the typed -calculus with sets in a straightforward way. Analogous to the list operations, we have a few set operations. Table 1 shows our extension to set operations. Please note that the rep operation is different from the arb operation in SETL.
Reference: [Set89] <author> R. Sethi. </author> <title> Programming languages: Concepts and Constructs, </title> <publisher> Addison-Wesley Press, </publisher> <year> 1989. </year>
Reference-contexts: Compiling functional languages with sets: Pure functional programming is characterized, in an informal sense, by a principle: "The value of an expression depends only on the values of its subexpressions, if any" <ref> [Set89] </ref>. A few techniques have been successfully applied to functional program analysis and provide information for optimization in compiling functional languages, such as abstract interpretation frameworks. In this dissertation, we are specially interested in their relation with sets and other aggregates. 2.
Reference: [SK95] <author> K. Slonneger, and B. L. Kurtz. </author> <title> Formal Syntax and Semantics of Programming Languages, </title> <publisher> Addison-Wesley Press, </publisher> <year> 1995. </year>
Reference: [Smi90] <author> D. R. Smith. "KIDS: </author> <title> A Semi-Automatic Program Development System," </title> <journal> IEEE Transactions on Software Engineering, Special Issue on Formal Methods, </journal> <month> Sep. </month> <year> 1990. </year>
Reference-contexts: It has been applied to program transformation systems between imperative languages [CP93, Pai94]. Some recent work caught the spirit of finite differencing and applied it to incremental computation systems [Liu96], and semi-automatic program development systems <ref> [Smi90] </ref>. 2 Dissertation Overview This dissertation attempts to explore the update-in-place analysis in set functional languages in order to apply finite differencing techniques to the optimization phase in compiling functional languages. <p> The finite differencing technique has been successfully applied to imperative programming language transformation [CP93, Pai94], semantic transformation on Lisp programs [Liu96], and semi-automatic program development systems <ref> [Smi90] </ref>. However, the evidence is still missing that such techniques can be applied to functional language compilation. We are interested in applying the finite differencing techniques to the functional programs with sets. <p> Finite differencing has been applied to program transformation between imperative programming languages [CP93, Pai94], semantic transformation on Lisp programs [Liu96], and semi-automatic program development systems <ref> [Smi90] </ref>. This dissertation will explore the application of finite differencing to compiling functional languages.
Reference: [Sny90] <author> W. K. Snyder. </author> <title> "The SETL2 Programming Language," </title> <type> Technical Report 490, </type> <institution> Computer Science Department, Courant Institute of Mathematical Sciences, </institution> <address> New York University, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: Therefore, the computation of the program in Figure 4 can be done in O (n) time, as we expected. We will describe more of this in the following sections. 1.2 Related Works The SETL programming language, developed at New York University <ref> [SDDS86, Sny90] </ref>, is the first programming language with a general purpose set data structure. The optimization of programs with set operations is discussed in Freudenberger et al. [FSS83]. Manens [Ber82] and S3L [Lac92] are lambda-calculi with sets.
Reference: [TWM95] <author> D. N. Turner, P. Wadler, and C. Mossin. </author> <title> "Once Upon A Type," </title> <booktitle> Proceedings on 7 th International Conference on Functional Programming and Computer Architecture, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Some of the well-known approaches are Bloss' path analysis [Blo89a, Blo89b, Blo94], Draghicescu and Purushothaman's variable reduction analysis [DP93], and Odersky's effect analysis [Ode91]. They all applied, in different ways, abstract interpretation frameworks for update-in-place analysis. On the other hand, Turner, Wadler, and Mossin <ref> [TWM95] </ref> proposed a new idea for update-in-place analysis with their used-once analysis, which integrates the analysis into the type system. However, how to make this idea practical in update-in-place is still not clear. <p> However, it is still not completely clear, and thus is one of the goals of this dissertation, how we may derive the semantics for such analysis. 4.2 Enriched Type System Turner, Wadler and Mossin presented a method for determining when a value is used at most once <ref> [TWM95] </ref>. Their method is based on a modification of the Hindley-Milner type 8 system. Each type is labeled to indicate whether the corresponding value is used at most once, or may possibly be used many times.
Reference: [Yun97] <author> C. Yung. </author> <title> "Extending Typed Lambda Calculus to Sets," </title> <booktitle> The Proceedings of MAS-PLAS'97, in cooperation with ACM SIGPLAN, </booktitle> <address> Stroudsburg PA, </address> <month> April </month> <year> 1997. </year> <month> 15 </month>
Reference-contexts: At first, we were interested in designing such a language. The partial results are presented in the following section and in <ref> [Yun97] </ref>. Later on, we found a few compilers or interpretors for functional languages with sets. We will describe one of them, namely S3L. 3.1 Set Functional Language Design We are interested in designing a new functional language with set notations. <p> We expect that the dissertation will contribute in the following aspects: * We enrich the typed -calculus with set notations. Thus, we validate enriching all functional languages with set notations since all functional languages can be viewed as variations of -calculus <ref> [Yun97] </ref>. * We propose a new approach of update-in-place analysis for aggregates, especially that for sets. * We develop a framework for applying finite differencing techniques to functional pro grams with sets. Acknowledgement The author appreciates the advice and help from the dissertation committee.
References-found: 38

