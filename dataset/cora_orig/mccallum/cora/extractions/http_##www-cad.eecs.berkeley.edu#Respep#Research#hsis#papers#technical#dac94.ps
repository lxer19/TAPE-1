URL: http://www-cad.eecs.berkeley.edu/Respep/Research/hsis/papers/technical/dac94.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/rajeev/publications/publications.html
Root-URL: 
Title: HSIS: A BDD-Based Environment for Formal Verification  
Author: A. Aziz, F. Balarin, R. K. Brayton, S.-T. Cheng, R. Hojati, S. C. Krishnan, R. K. Ranjan, A. L. Sangiovanni-Vincentelli, T. R. Shiple, V. Singhal, S. Tasiran, H.-Y. Wang 
Address: Berkeley, CA 94720, USA  
Affiliation: Department of Electrical Engineering and Computer Sciences University of California,  
Abstract: Functional and timing verification are currently the bottlenecks in many design efforts. Simulation and emulation are extensively used for verification. Formal verification is now gaining acceptance in advanced design groups. This has been facilitated by the use of binary decision diagrams (BDDs). This paper describes the essential features of HSIS, a BDD-based environment for formal verification: 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Balarin and G. York. </author> <title> Verilog HDL Modeling Styles for Formal Verification. </title> <booktitle> In IFIP Conference on Hardware Description Languages and their Applications, </booktitle> <pages> pages 439-452. </pages> <publisher> OCRI Publications, </publisher> <month> April </month> <year> 1993. </year>
Reference-contexts: In order to allow abstraction in the system or to model an environment, we need to express non-determinism. In most HDLs, including Verilog, non-determinism is not supported. Balarin and York proposed using the non-blocking assignment in Verilog to describe non-determinism of register variables <ref> [1] </ref>. We have further extended Verilog minimally by creating a new construct for describing non-determinism of wire variables. It is also desirable to have the following additional features in Verilog for ease of expression. * Enumerated types.
Reference: [2] <author> R. S. Boyer and J. S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: We seek to improve the efficiency of verification so that larger designs can be verified, and to develop simpler methods for specifying properties. Of the various formal verification methods, the first to be used in design verification was theorem proving <ref> [9, 2] </ref>. These techniques are somewhat similar to the formal verification techniques used to verify the correctness of software written in programming languages. These verification techniques usually require extensive interactive use of human experts. There have been two recent approaches for verifying properties of systems described as state transition systems.
Reference: [3] <author> R. K. Brayton, M. Chiodo, R. Hojati, T. Kam, K. Kodandapani, R. P. Kurshan, S. Malik, A. L. Sangiovanni-Vincentelli, E. M. Sentovich, T. Shiple, K. J. Singh, and H.-Y. Wang. BLIF-MV: </author> <title> An Interchange Format for Design Verification and Synthesis. </title> <type> Technical Report UCB/ERL M91/97, </type> <institution> Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: This is achieved by using an intermediate format based on multi-level logic, called BLIF-MV <ref> [3] </ref> and described in Section 4, which is capable of compactly representing finite-state behavior (all digital hardware systems fall in this category). In order to have the same specifications for synthesis, simulation, and verification, we use the synthesis subsets of HDLs. <p> Other times, more detail must be given to the environment to properly account for the actual operating conditions of the component. 4 BLIF-MV We have designed an intermediate format called BLIF-MV <ref> [3] </ref> to allow for easy translation from HDLs for the purposes of both verification and hierarchical synthesis. It is a natural extension of BLIF, the Berkeley Logic Interchange Format [18]. We extended BLIF to provide non-determinism and multiple valued variables.
Reference: [4] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, and D. L. Dill. </author> <title> Symbolic Model Checking: 10 20 States and Beyond. </title> <journal> Information and Computation, </journal> <volume> 98(2) </volume> <pages> 142-170, </pages> <year> 1992. </year>
Reference-contexts: Implicit methods manipulate October 19, 1993 - 12 : 18 DRAFT 9 sets of states at a time. There are very many examples of large state spaces that can be explored with implicit techniques, but not explicit <ref> [4] </ref>. As is discussed in [12] a straight forward translation of the explicit algorithms in not necessarily the best for BDDs. The language containment check is translated to a language emptiness check, and this fails if there is an accepting run in the automaton.
Reference: [5] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year> <note> October 19, 1993 - 12 : 18 DRAFT 13 </note>
Reference-contexts: An alternative approach of doing property verification is to specify the properties using temporal logic and perform model checking on the system specification to verify these properties <ref> [5] </ref>. Systems that manipulate these state-based systems explicitly are limited by the size of state spaces. In the context of implementation verification, Coudert and Madre [6] illustrated the use of BDDs to implicitly manipulate state transition systems with much larger state spaces. <p> This is true if and only if no behavior is produced by the system where out1 and out2 are simultaneously asserted. An alternative way to state properties is to use CTL formulas <ref> [5] </ref>.
Reference: [6] <author> O. Coudert and J. C. Madre. </author> <title> A Unified Framework for the Formal Verification of Sequential Circuits. </title> <booktitle> In Proc. of the Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 126-129, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Systems that manipulate these state-based systems explicitly are limited by the size of state spaces. In the context of implementation verification, Coudert and Madre <ref> [6] </ref> illustrated the use of BDDs to implicitly manipulate state transition systems with much larger state spaces. Since then, the use of BDDs has been extended to manipulate transition systems in the area of design verification (as in the tool SMV [16]).
Reference: [7] <author> D. L. Dill, A. J. Drexler, A. J. Hu, and C. H. Yang. </author> <title> Protocol Verification as a Hardware Design Aid. </title> <booktitle> In Proc. of the Intl. Conf. on Computer Design, </booktitle> <pages> pages 522-525, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Determining the schedule and performing the multiplication and quantification takes only several seconds. We can show that descriptions in other models of concurrency such as the Selection/Resolution model [13] and the interleaving shared memory model <ref> [7] </ref> can be mapped efficiently (in basically linear or close to linear time) into descriptions in synchronous c/s. Although interleaved (or asynchronous) behavior can be modeled using synchronous c/s, it may be computationally advantageous to directly model it. Therefore, we have extended the c/s model to directly support interleaved semantics.
Reference: [8] <author> E. A. Emerson and C. L. Lei. </author> <title> Modalities for Model Checking: Branching Time Strikes Back. </title> <booktitle> In Proc. of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-96, </pages> <year> 1985. </year>
Reference-contexts: In [12], several graph operators were introduced that can be used to obtain various approximations. These operators are based on techniques introduced by Emerson and Lei in <ref> [8] </ref>, and are used in HSIS to provide for efficient BDD-based verification algorithms. 5.4 Early Failure Detection If verification is to be used as a debugging tool, much in the same way as a debugger is used for a programming language like C, then it is expected that it would be
Reference: [9] <author> M. Gordon. </author> <title> HOL: A Proof Generating System for Higher-order Logic. </title> <editor> In G. Birwistle and P. A. Subrahmanyam, editors, </editor> <booktitle> VLSI Specification, Verification and Synthesis, </booktitle> <pages> pages 73-127. </pages> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: We seek to improve the efficiency of verification so that larger designs can be verified, and to develop simpler methods for specifying properties. Of the various formal verification methods, the first to be used in design verification was theorem proving <ref> [9, 2] </ref>. These techniques are somewhat similar to the formal verification techniques used to verify the correctness of software written in programming languages. These verification techniques usually require extensive interactive use of human experts. There have been two recent approaches for verifying properties of systems described as state transition systems.
Reference: [10] <author> Z. Har'El and R. P. Kurshan. </author> <title> Software for Analytical Development of Communication Protocols. </title> <journal> AT&T Technical Journal, </journal> <pages> pages 45-59, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: One approach is to specify the both the system and the properties as !-automata. The verification task is equivalent to verifying that the language of the system is contained in the language of the properties (the language containment approach) (as in the verification tool COSPAN <ref> [10] </ref>). An alternative approach of doing property verification is to specify the properties using temporal logic and perform model checking on the system specification to verify these properties [5]. Systems that manipulate these state-based systems explicitly are limited by the size of state spaces.
Reference: [11] <author> R. Hojati, T. R. Shiple, R. K. Brayton, and R. P. Kurshan. </author> <title> A Unified Environment for Language Containment and Fair CTL Model Checking. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 475-481, </pages> <address> Dallas, Texas, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: For language containment, the edge-Streett/edge-Rabin environment is supported. One can prove that the next natural extension to this environment makes the language containment problem NP-complete. As for CTL, a logic known as fair CTL is supported. Combining the two environments is achieved using tech niques described in <ref> [11] </ref>. 2. Automatic algorithm for early quantification. In building transition relations for individual processes, or for the product machine, it is necessary to multiply a set of BDDs and existentially quantify out some variables. This can be done more efficiently taking advantage of early quantification. <p> There are properties expressible by one but not the other <ref> [11] </ref>. 2. Some properties may be more easily expressed in one than the other. For example, properties involving sequencing of events are expressed more easily using automata. On the other hand, CTL is easier to use for simple properties. <p> A fair state is one that is involved in some cycle satisfying all fairness constraints, and thus a reachable fair state means a failing language containment check. In <ref> [11] </ref> it is explained how such an emptiness check as well as CTL model checking can be achieved through first computing an approximation to the set of fair states. In [12], several graph operators were introduced that can be used to obtain various approximations.
Reference: [12] <author> R. Hojati, H. Touati, R. P. Kurshan, and R. K. Brayton. </author> <title> Efficient !-Regular Language Containment. </title> <booktitle> In Proc. of the Fourth Workshop on Computer-Aided Verification, </booktitle> <pages> pages 371-382, </pages> <address> Montreal, Quebec, Canada, </address> <year> 1992. </year>
Reference-contexts: Implicit methods manipulate October 19, 1993 - 12 : 18 DRAFT 9 sets of states at a time. There are very many examples of large state spaces that can be explored with implicit techniques, but not explicit [4]. As is discussed in <ref> [12] </ref> a straight forward translation of the explicit algorithms in not necessarily the best for BDDs. The language containment check is translated to a language emptiness check, and this fails if there is an accepting run in the automaton. <p> In [11] it is explained how such an emptiness check as well as CTL model checking can be achieved through first computing an approximation to the set of fair states. In <ref> [12] </ref>, several graph operators were introduced that can be used to obtain various approximations.
Reference: [13] <author> R. P. Kurshan. </author> <title> Reducibility in Analysis of Coordination. In Discrete Event Systems: Models and Applications, </title> <booktitle> volume 103 of LNCIS, </booktitle> <pages> pages 19-39. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: In one example, around 1600 relations had to be multiplied and 1500 variables had to be quantified out. Determining the schedule and performing the multiplication and quantification takes only several seconds. We can show that descriptions in other models of concurrency such as the Selection/Resolution model <ref> [13] </ref> and the interleaving shared memory model [7] can be mapped efficiently (in basically linear or close to linear time) into descriptions in synchronous c/s. Although interleaved (or asynchronous) behavior can be modeled using synchronous c/s, it may be computationally advantageous to directly model it. <p> In this case, fairness constraints will be an indispensable feature. 5.2 Property checking Properties can be stated and proved in HSIS using either automata (the language containment paradigm), or CTL formulas (the model checking paradigm). Automata can be used to express properties of designs <ref> [13] </ref>. HSIS offers support for a class of automata, known as edge-Rabin automata. Such automata can be used to describe two types of properties: safety properties and liveness properties. A safety property checks for behavior that should never happen (e.g. two units writing to the bus at the same time).
Reference: [14] <author> R. P. Kurshan. </author> <title> Automata-Theoretic Verification of Coordinating Processes. </title> <publisher> Princeton University Press, </publisher> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: The design is specified in an HDL. Verification starts at the the earliest abstract level of design. Then at each step of the design process, the design is refined by removing some non-determinism in the specification (this process is described in detail in <ref> [14] </ref>). As long as new behavior is not added to the design during refinement, then most properties (all properties except for existential properties, which assert the existence of some behavior) proved at higher levels of abstraction will automatically hold at the lower levels.
Reference: [15] <author> K. L. McMillan and J. Schwalbe. </author> <title> Formal Verification of the Encore Gigamax Cache Consistency Protocols. </title> <booktitle> In International Symposium on Shared Memory Multiprocessors, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: The experiments were run on a DECsystem 5900/260 with 440MB physical memory. The first two examples, dining philosophers and ping pong, are toy examples. 2mdlc is a message data-link controller obtained from industry. Gigamax is a multiprocessor cache consistency protocol <ref> [15] </ref>. Scheduler is a distributed scheduling protocol for multiple tasks from [17]. All examples were written in the augmented subset of Verilog discussed in Section 3. They were then translated into BLIF-MV using the vl2mv tool supplied with HSIS.
Reference: [16] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Since then, the use of BDDs has been extended to manipulate transition systems in the area of design verification (as in the tool SMV <ref> [16] </ref>). In this paper, we describe HSIS (for Hierarchical Sequential Interactive System), a BDD-based environment for design verification. HSIS is designed to be a unified environment for formal verification and logic synthesis; currently we only support the verification framework.
Reference: [17] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: The first two examples, dining philosophers and ping pong, are toy examples. 2mdlc is a message data-link controller obtained from industry. Gigamax is a multiprocessor cache consistency protocol [15]. Scheduler is a distributed scheduling protocol for multiple tasks from <ref> [17] </ref>. All examples were written in the augmented subset of Verilog discussed in Section 3. They were then translated into BLIF-MV using the vl2mv tool supplied with HSIS. The time to translate from Verilog to BLIF-MV was in all examples negligible|all under 0.5 seconds.
Reference: [18] <author> E. M. Sentovich, K. J. Singh, L. Lavagno, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P. R. Stephan, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> SIS: A System for Sequential Circuit Synthesis. </title> <type> Technical Report UCB/ERL M92/41, </type> <institution> Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: It is a natural extension of BLIF, the Berkeley Logic Interchange Format <ref> [18] </ref>. We extended BLIF to provide non-determinism and multiple valued variables. Multiple-valued variables are very useful in describing state transition graphs symbolically. The need for non-determinism is felt in describing the environment and for abstraction in the verification process.
References-found: 18

