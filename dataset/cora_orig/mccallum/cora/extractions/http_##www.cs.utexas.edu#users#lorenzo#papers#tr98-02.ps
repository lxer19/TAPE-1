URL: http://www.cs.utexas.edu/users/lorenzo/papers/tr98-02.ps
Refering-URL: http://www.cs.utexas.edu/users/lorenzo/publications.html
Root-URL: http://www.cs.utexas.edu
Email: E-mail: fsriram,lorenzo,ving@cs.utexas.edu,  
Phone: Telephone: (512) 471-9792, Fax: (512) 471-8885  
Title: The Cost of Recovery in Message Logging Protocols  
Author: Sriram Rao, Lorenzo Alvisi, and Harrick M. Vin 
Web: URL: http://www.cs.utexas.edu/users/fsriram,lorenzo,ving  
Address: Taylor Hall 2.124, Austin, Texas 78712-1188, USA  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract: Research on message-logging protocols for crash recovery has focused on minimizing overhead during failure-free executions. However, there has been no quantitative study of the cost incurred by these protocols during recovery. In this paper we make two contributions. First, we present a quantitative analysis of the recovery cost for pessimistic, optimistic, and causal logging protocols. Second, we introduce the new class of resource-aware protocols, which take advantage of the novel notion of hierarchical stable storage. In this implementation of stable storage, the cost of accessing data needed during recovery depends on the severity of crash, expressed in terms of the resources that are available to the recovering process. Resource-aware protocols (1) implement hierarchical stable storage by adapting the logging techniques of conventional message-logging protocols to replicate data needed during recovery at different levels of the hierarchy; and (2) employ recovery procedures that progressively access levels of the hierarchy with higher costs until all the data needed during recovery is available. We find that causal resource-aware protocols combine low-overhead during failure-free executions with the performance during recovery of a conventional pessimistic protocol. Furthermore, for the common case of transient software crashes, optimistic resource-aware protocols eliminate roll-backs completely, thereby matching the performance of conventional pessimistic protocols.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Alvisi, B. Hoppe, and K. Marzullo. </author> <title> Nonblocking and Orphan-Free Message Logging Protocols. </title> <booktitle> In Proceedings of the 23rd Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 145154, </pages> <month> June </month> <year> 1993. </year> <month> 18 </month>
Reference-contexts: Optimistic protocols can perform very efficiently in failure-free executions. However, if any of the determinants are lost when a process crashes, then orphans may be created. To reach a consistent global state, these processes must be identified and rolled back. * Causal protocols <ref> [1, 12] </ref> combine some of the positive aspects of pessimistic and optimistic protocols: They never create orphans, yet they do not write determinants to stable storage synchronously. In causal protocols, determinants are logged in volatile memory. <p> Although these results are significant in that they are application independent, they do not provide any insights on the relative performance of optimistic protocols with respect to other message-logging protocols. The cost of recovery in causal logging protocols has been empirically evaluated <ref> [1, 8] </ref>. However, it has not been compared with the recovery cost of any other protocols. 17 Other research efforts have considered using local memory and disks for speeding up recovery [4, 26].
Reference: [2] <author> L. Alvisi and K. Marzullo. </author> <title> Message Logging: Pessimistic, Optimistic, and Causal. </title> <booktitle> In Proceedings of the 15th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 229236. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: In our implementation, this is accomplished by piggybacking determinants on existing application messages until they are logged by at least t+1 processes <ref> [2, 12] </ref>. Recovery of a failed process proceeds in two phases. In the first phase, the process obtains from the volatile logs of the operational processes the determinants and the content of messages delivered before crashing.
Reference: [3] <author> L. Alvisi and K. Marzullo. </author> <title> Tradeoffs in Implementing Optimal Message Logging Protocols. </title> <booktitle> In Proceedings of the Fifteenth Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 5867. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1996. </year>
Reference-contexts: Then, it rolls back to a checkpoint consistent with the recovered state of the failed process and uses its logs to roll-forward to the latest possible consistent state. Causal message-logging protocol: We have implemented the det family-based message-logging protocol <ref> [3] </ref>. This protocol is based on the following observation: in a system where processes fail independently and no more than t processes fail concurrently, one can ensure the availability of determinants during recovery by replicating them in the volatile memory of t + 1 processes. <p> This is because increasing f increases the number of determinants that are logged by processes during failure-free execution <ref> [3] </ref> and therefore increases the number of determinants processed during recovery. We are in the process of conducting similar experiments for the other failure scenarios.
Reference: [4] <author> M. Baker and M. Sullivan. </author> <title> The Recovery Box: Using Fast Recovery to Provide High Availability in the UNIX Environment. </title> <booktitle> In Proceedings of the Summer 1992 USENIX Conference, </booktitle> <pages> pages 3143, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The cost of recovery in causal logging protocols has been empirically evaluated [1, 8]. However, it has not been compared with the recovery cost of any other protocols. 17 Other research efforts have considered using local memory and disks for speeding up recovery <ref> [4, 26] </ref>. In [4], the operating system uses a region of volatile memory, called the recovery box, to store backup copies of critical data needed during recovery. Since random stores may corrupt volatile memory, the contents of the recovery box are treated as hints during recovery. <p> The cost of recovery in causal logging protocols has been empirically evaluated [1, 8]. However, it has not been compared with the recovery cost of any other protocols. 17 Other research efforts have considered using local memory and disks for speeding up recovery [4, 26]. In <ref> [4] </ref>, the operating system uses a region of volatile memory, called the recovery box, to store backup copies of critical data needed during recovery. Since random stores may corrupt volatile memory, the contents of the recovery box are treated as hints during recovery.
Reference: [5] <author> A. Borg, J. Baumbach, and S. Glazer. </author> <title> A message system supporting fault tolerance. </title> <booktitle> In Proceedings of the Symposium on Operating Systems Principles, pages 9099. ACM SIGOPS, </booktitle> <month> October </month> <year> 1983. </year>
Reference-contexts: An orphan process is an operational process whose state is inconsistent with the recovered state of a crashed process. All message-logging protocols guarantee that upon recovery no process is an orphan, but differ in the way they enforce this consistency condition: * Pessimistic protocols <ref> [5, 15, 21] </ref> require that a process, before sending a message, synchronously log on stable storage the determinants and the content of all messages delivered so far. Thus, pessimistic protocols never create orphan processes.
Reference: [6] <author> P. M. Chen, W. T. Ng, S. Chandra, C. Aycock, G. Rajamani, and D. Lowell. </author> <title> The Rio File Cache: Surviving Operating System Crashes. </title> <booktitle> In Proceedings of the Seventh International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <address> Cambridge, MA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: However, local disks cannot, in general, be used to implement stable storage because they may become unavailable when processors fail. Our resource-aware message-logging protocols do not suffer from this limitation. The Rio file cache <ref> [6] </ref> presents volatile memory of the file system as a form of stable storage to applications, which can be used to store the information needed during recovery.
Reference: [7] <author> O. P. Damani and V. K. Garg. </author> <title> How to Recover Efficiently and Asynchronously when Optimism Fails. </title> <booktitle> In Proceedings of the 16th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 108115, </pages> <year> 1996. </year>
Reference-contexts: Thus, pessimistic protocols never create orphan processes. However, synchronously logging determinants on stable storage imposes a significant overhead during failure-free executions. * Optimistic protocols <ref> [7, 16, 17, 22, 23, 25] </ref> allow processes to communicate even if the determinants they depend upon are not yet logged on stable storage. These protocols only require that determinants reach stable storage eventually. Optimistic protocols can perform very efficiently in failure-free executions. <p> However, with causal protocols a process can start its recovery only after collecting the necessary determinants from the volatile logs of the operational processes. It has been qualitatively argued <ref> [7] </ref> that optimistic protocols that start recovery without waiting for data from other processes may have a shorter recovery time than causal protocols. Finally, little is known about the effect of changes in f , the number of concurrent failures, on the recovery costs of pessimistic, optimistic, and causal protocols. <p> During recovery, the state of a failed process is initialized using the latest checkpoint, and then the logs maintained on stable storage are used to replay messages and restore the process to its pre-crash state. 4 Optimistic protocol: We have implemented the optimistic message-logging protocol de-scribed in <ref> [7] </ref>. In this protocol, causal dependencies are tracked using vector clocks [19]. On a message send, the sender piggybacks its vector clock on the message; on a message deliver, the receiver updates its vector clock by computing a component-wise maximum with the piggybacked vector clock. <p> The cost of recovery incurred by optimistic message-logging protocols has been evaluated analytically <ref> [7, 10, 14, 16, 25] </ref>, with the focus on analyzing the number of roll-backs incurred due to a failure, the latest state of the failed process that can be recovered, and the number of messages needed to detect orphans.
Reference: [8] <author> E. N. Elnozahy. Manetho: </author> <title> Fault Tolerance in Distributed Systems Using Rollback-Recovery and Process Replication. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> October </month> <year> 1993. </year> <note> Available as report COMP TR93-212. </note>
Reference-contexts: Although these results are significant in that they are application independent, they do not provide any insights on the relative performance of optimistic protocols with respect to other message-logging protocols. The cost of recovery in causal logging protocols has been empirically evaluated <ref> [1, 8] </ref>. However, it has not been compared with the recovery cost of any other protocols. 17 Other research efforts have considered using local memory and disks for speeding up recovery [4, 26].
Reference: [9] <author> E. N. Elnozahy. </author> <title> On the relevance of communication costs of rollback-recovery protocols. </title> <booktitle> In Proceedings of the Fourteenth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 7479, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: In the second phase, the collected data is replayed, restoring the process to its pre-crash state. To handle multiple concurrent failures, we implemented a protocol that recovers crashed processes without blocking operational processes <ref> [9] </ref>. In this protocol, the recovering processes elect a leader, which is responsible for collecting determinants and messages on behalf of all recovering processes. The leader then forwards the pertinent data to each recovering process.
Reference: [10] <author> E. N. Elnozahy, D. B. Johnson, and Y. M. Wang. </author> <title> A Survey of Rollback-Recovery Protocols in Message-Passing Systems. </title> <type> Technical Report CMU-CS-96-181, </type> <institution> Carnegie Mellon University, </institution> <year> 1996. </year>
Reference-contexts: This property is sufficient to restore a crashed process in a state consistent with the state of all operational processes. Although several studies have measured the overhead imposed by each of these approaches during failure-free executions <ref> [10, 13] </ref>, their merits during recovery have been so far argued mostly qualitatively. For instance, there is consensus that pessimistic protocols are well-suited for supporting fast recovery, since they guarantee that all determinants can be readily retrieved from stable storage. The opinions about optimistic protocols are less unanimous. <p> The cost of recovery incurred by optimistic message-logging protocols has been evaluated analytically <ref> [7, 10, 14, 16, 25] </ref>, with the focus on analyzing the number of roll-backs incurred due to a failure, the latest state of the failed process that can be recovered, and the number of messages needed to detect orphans.
Reference: [11] <author> E. N. Elnozahy, D. B. Johnson, and W. Zwaenepoel. </author> <title> The Performance of Consistent Checkpoint-ing. </title> <booktitle> In Proceedings of the Eleventh Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 3947, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In our current implementation, checkpoints are synchronous (i.e., applications block during check-pointing). The checkpointing mechanisms used are similar to those described in [20]. We are currently enhancing our implementation to utilize optimization such as incremental checkpointing and copy-on-write <ref> [11] </ref>. <p> For the causal message-logging protocol, the log is used to reproduce during recovery the content of the messages delivered by a process during the failure-free execution. 2.1 Applications For our experiments, we have chosen the following three long-running, compute-intensive applica tions <ref> [11] </ref>. 5 * grid performs successive over-relaxation (SOR) for a Laplace partial differential equation on a grid of 200 fi 200 points. In each iteration, the value of each point is computed as a function of its value in the previous iteration and of the values of its neighbors.
Reference: [12] <author> E. N. Elnozahy and W. Zwaenepoel. Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback and fast output commit. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41(5):526531, </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: Optimistic protocols can perform very efficiently in failure-free executions. However, if any of the determinants are lost when a process crashes, then orphans may be created. To reach a consistent global state, these processes must be identified and rolled back. * Causal protocols <ref> [1, 12] </ref> combine some of the positive aspects of pessimistic and optimistic protocols: They never create orphans, yet they do not write determinants to stable storage synchronously. In causal protocols, determinants are logged in volatile memory. <p> In our implementation, this is accomplished by piggybacking determinants on existing application messages until they are logged by at least t+1 processes <ref> [2, 12] </ref>. Recovery of a failed process proceeds in two phases. In the first phase, the process obtains from the volatile logs of the operational processes the determinants and the content of messages delivered before crashing.
Reference: [13] <author> E. N. Elnozahy and W. Zwaenepoel. </author> <title> On the use and implementation of message logging. </title> <booktitle> In Digest of Papers: 24 Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 298 307. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: This property is sufficient to restore a crashed process in a state consistent with the state of all operational processes. Although several studies have measured the overhead imposed by each of these approaches during failure-free executions <ref> [10, 13] </ref>, their merits during recovery have been so far argued mostly qualitatively. For instance, there is consensus that pessimistic protocols are well-suited for supporting fast recovery, since they guarantee that all determinants can be readily retrieved from stable storage. The opinions about optimistic protocols are less unanimous.
Reference: [14] <author> D. B. Johnson. </author> <title> Efficient transparent optimistic rollback recovery for distributed application programs. </title> <booktitle> In Proceedings of the 12th Symposium on Reliable Distributed Systems, </booktitle> <month> October </month> <year> 1993. </year> <month> 19 </month>
Reference-contexts: The cost of recovery incurred by optimistic message-logging protocols has been evaluated analytically <ref> [7, 10, 14, 16, 25] </ref>, with the focus on analyzing the number of roll-backs incurred due to a failure, the latest state of the failed process that can be recovered, and the number of messages needed to detect orphans.
Reference: [15] <author> D. B. Johnson and W. Zwaenepoel. </author> <title> Sender-Based Message Logging. </title> <booktitle> In Digest of Papers: 17 Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 1419. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: An orphan process is an operational process whose state is inconsistent with the recovered state of a crashed process. All message-logging protocols guarantee that upon recovery no process is an orphan, but differ in the way they enforce this consistency condition: * Pessimistic protocols <ref> [5, 15, 21] </ref> require that a process, before sending a message, synchronously log on stable storage the determinants and the content of all messages delivered so far. Thus, pessimistic protocols never create orphan processes.
Reference: [16] <author> D. B. Johnson and W. Zwaenepoel. </author> <title> Recovery in Distributed Systems Using Optimistic Message Logging and Checkpointing. </title> <journal> Journal of Algorithms, </journal> <volume> 11:462491, </volume> <year> 1990. </year>
Reference-contexts: Thus, pessimistic protocols never create orphan processes. However, synchronously logging determinants on stable storage imposes a significant overhead during failure-free executions. * Optimistic protocols <ref> [7, 16, 17, 22, 23, 25] </ref> allow processes to communicate even if the determinants they depend upon are not yet logged on stable storage. These protocols only require that determinants reach stable storage eventually. Optimistic protocols can perform very efficiently in failure-free executions. <p> The cost of recovery incurred by optimistic message-logging protocols has been evaluated analytically <ref> [7, 10, 14, 16, 25] </ref>, with the focus on analyzing the number of roll-backs incurred due to a failure, the latest state of the failed process that can be recovered, and the number of messages needed to detect orphans.
Reference: [17] <author> T. Y. Juang and S. Venkatesan. </author> <title> Crash recovery with little overhead. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 454461. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: Thus, pessimistic protocols never create orphan processes. However, synchronously logging determinants on stable storage imposes a significant overhead during failure-free executions. * Optimistic protocols <ref> [7, 16, 17, 22, 23, 25] </ref> allow processes to communicate even if the determinants they depend upon are not yet logged on stable storage. These protocols only require that determinants reach stable storage eventually. Optimistic protocols can perform very efficiently in failure-free executions.
Reference: [18] <author> L. Lamport. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 21(7):558565, </volume> <month> July </month> <year> 1978. </year>
Reference-contexts: In causal protocols, determinants are logged in volatile memory. To prevent orphans, processes piggyback their volatile log of determinants on every message they send 1 . This guarantees that if the state of an operational process p causally depends <ref> [18] </ref> on the delivery of a message m, then p has a copy of m's determinant in its volatile memory. This property is sufficient to restore a crashed process in a state consistent with the state of all operational processes.
Reference: [19] <author> F. Mattern. </author> <title> Virtual Time and Global States of Distributed Systems. </title> <editor> In M. Cosnard et. al., editor, </editor> <booktitle> Parallel and Distributed Algorithms, </booktitle> <pages> pages 215226. </pages> <publisher> Elsevir Science Publishers B. V., </publisher> <year> 1989. </year>
Reference-contexts: In this protocol, causal dependencies are tracked using vector clocks <ref> [19] </ref>. On a message send, the sender piggybacks its vector clock on the message; on a message deliver, the receiver updates its vector clock by computing a component-wise maximum with the piggybacked vector clock.
Reference: [20] <author> J. S. Plank, M. Beck, G. Kingsley, and K. Li. </author> <title> Libckpt:Transparent checkpointing under Unix. </title> <booktitle> In Proceedings of the USENIX Technical Conference, </booktitle> <pages> pages 213224, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: In case of a failure, the failed process is re-started and its state is restored to that recorded in the latest checkpoint. In our current implementation, checkpoints are synchronous (i.e., applications block during check-pointing). The checkpointing mechanisms used are similar to those described in <ref> [20] </ref>. We are currently enhancing our implementation to utilize optimization such as incremental checkpointing and copy-on-write [11].
Reference: [21] <author> M. L. Powell and D. L. Presotto. </author> <title> Publishing: A reliable broadcast communication mechanism. </title> <booktitle> In Proceedings of the Ninth Symposium on Operating System Principles, pages 100109. ACM SIGOPS, </booktitle> <month> October </month> <year> 1983. </year>
Reference-contexts: An orphan process is an operational process whose state is inconsistent with the recovered state of a crashed process. All message-logging protocols guarantee that upon recovery no process is an orphan, but differ in the way they enforce this consistency condition: * Pessimistic protocols <ref> [5, 15, 21] </ref> require that a process, before sending a message, synchronously log on stable storage the determinants and the content of all messages delivered so far. Thus, pessimistic protocols never create orphan processes.
Reference: [22] <author> A. P. Sistla and J. L. Welch. </author> <title> Efficient Distributed Recovery Using Message Logging. </title> <booktitle> In Proceedings of the Eighth Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 223238. </pages> <publisher> ACM SIGACT/SIGOPS, </publisher> <month> August </month> <year> 1989. </year>
Reference-contexts: Thus, pessimistic protocols never create orphan processes. However, synchronously logging determinants on stable storage imposes a significant overhead during failure-free executions. * Optimistic protocols <ref> [7, 16, 17, 22, 23, 25] </ref> allow processes to communicate even if the determinants they depend upon are not yet logged on stable storage. These protocols only require that determinants reach stable storage eventually. Optimistic protocols can perform very efficiently in failure-free executions. <p> Although the literature contains careful analyses of the cost of recovery for different optimistic protocols in terms of the number of messages and the rounds of communication needed to identify and roll back orphan processes <ref> [22, 23, 25] </ref>, in general no experimental evaluations of their performance during recovery are offered. The performance of causal protocols during recovery has also been debated.
Reference: [23] <author> R. B. Strom and S. Yemeni. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3):204226, </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: Thus, pessimistic protocols never create orphan processes. However, synchronously logging determinants on stable storage imposes a significant overhead during failure-free executions. * Optimistic protocols <ref> [7, 16, 17, 22, 23, 25] </ref> allow processes to communicate even if the determinants they depend upon are not yet logged on stable storage. These protocols only require that determinants reach stable storage eventually. Optimistic protocols can perform very efficiently in failure-free executions. <p> Although the literature contains careful analyses of the cost of recovery for different optimistic protocols in terms of the number of messages and the rounds of communication needed to identify and roll back orphan processes <ref> [22, 23, 25] </ref>, in general no experimental evaluations of their performance during recovery are offered. The performance of causal protocols during recovery has also been debated.
Reference: [24] <author> R. E. Strom, D. F. Bacon, and S. A. Yemini. </author> <title> Volatile Logging in n-Fault-Tolerant Distributed Systems. </title> <booktitle> In Proceedings of the Eighteenth Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 4449, </pages> <year> 1988. </year>
Reference: [25] <author> S. Venkatesan and T.Y. Juang. </author> <title> Efficient Algorithms for Optimistic Crash Recovery. </title> <booktitle> Distributed Computing, </booktitle> <address> 8(2):105114, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Thus, pessimistic protocols never create orphan processes. However, synchronously logging determinants on stable storage imposes a significant overhead during failure-free executions. * Optimistic protocols <ref> [7, 16, 17, 22, 23, 25] </ref> allow processes to communicate even if the determinants they depend upon are not yet logged on stable storage. These protocols only require that determinants reach stable storage eventually. Optimistic protocols can perform very efficiently in failure-free executions. <p> Although the literature contains careful analyses of the cost of recovery for different optimistic protocols in terms of the number of messages and the rounds of communication needed to identify and roll back orphan processes <ref> [22, 23, 25] </ref>, in general no experimental evaluations of their performance during recovery are offered. The performance of causal protocols during recovery has also been debated. <p> The cost of recovery incurred by optimistic message-logging protocols has been evaluated analytically <ref> [7, 10, 14, 16, 25] </ref>, with the focus on analyzing the number of roll-backs incurred due to a failure, the latest state of the failed process that can be recovered, and the number of messages needed to detect orphans.
Reference: [26] <author> Y. M. Wang, Y. Huang, K. P. Vo, P. Y. Chung, and C. Kintala. </author> <title> Checkpointing and Its Applications. </title> <booktitle> In Proceedings of the IEEE Fault-Tolerant Computing Symposium (FTCS-25), </booktitle> <pages> pages 2231, </pages> <address> Pasadena, CA, </address> <month> June </month> <year> 1995. </year> <month> 20 </month>
Reference-contexts: The cost of recovery in causal logging protocols has been empirically evaluated [1, 8]. However, it has not been compared with the recovery cost of any other protocols. 17 Other research efforts have considered using local memory and disks for speeding up recovery <ref> [4, 26] </ref>. In [4], the operating system uses a region of volatile memory, called the recovery box, to store backup copies of critical data needed during recovery. Since random stores may corrupt volatile memory, the contents of the recovery box are treated as hints during recovery. <p> Our approach differs from the recovery box in that the information cached locally is always correct, although the cached data, depending on the failure model may only be a prefix of the information needed by a process to complete its recovery. Local disks have been used elsewhere <ref> [26] </ref> to implement stable storage for checkpoints to minimize the network overhead incurred when retrieving large checkpoint files. However, local disks cannot, in general, be used to implement stable storage because they may become unavailable when processors fail. Our resource-aware message-logging protocols do not suffer from this limitation.
References-found: 26

