URL: http://mnemosyne.itc.it:1024/ricci/papers/ewcbr98.ps
Refering-URL: http://mnemosyne.itc.it:1024/ricci/conference-papers-list.html
Root-URL: 
Email: email: fricci,senterg@itc.it  
Title: Structured Cases, Trees and Efficient Retrieval Fourth European Workshop on Case-Based Reasoning, Dublin, Ireland, September
Author: Francesco Ricci and Luca Senter 
Address: via Sommarive 38050 Povo (TN) Italy  
Affiliation: Istituto per la Ricerca Scientifica e Tecnologica  
Abstract: A set of efficient algorithms for case retrieval from a case base of trees labeled on both nodes and edges is proposed. They extend the best known algorithm for solving the subtree-isomorphism problem. A branch and bound technique and a general definition of similarity between trees is considered. Both the case structure, i.e. the graph structure, and his semantic part, the labels, is taken into account when evaluating similarity. The comparison with a conventional state-space search algorithm on randomly generated case bases, shows that significant speed up can be obtained.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> P. Avesani, A. Perini, and F. Ricci. Cbet: </author> <title> a case base exploration tool. </title> <editor> In Springer-Verlag, editor, </editor> <booktitle> Fifth Congress of the Italian Association for Artificial Intelligence (AI*IA 97), </booktitle> <address> Roma (Italy), </address> <year> 1997, </year> <month> September 16-19 </month> <year> 1997. </year>
Reference-contexts: To extend the definition of morphism to labeled trees we need a measure of similarity between labels s : L fi L ! <ref> [0; 1] </ref>. If x; y; w; z are nodes we shall more compactly write s (x; y) instead of s ( n (x); n (y)), and s ((x; y); (w:z)) instead of s ( e (x; y); e (w; z)). <p> The comparison with a conventional state-space search algorithm on randomly generated case bases, shows that significant speed up can be obtained. This algorithms have been integrated in a C++ library for case-based reasoning and data mining called CBET <ref> [1] </ref>.
Reference: 2. <author> K. Borner, E. Pippig, E.-C. Tammer, and K.-H. Coulon. </author> <title> Structural similarity and adaptation. </title> <booktitle> In European Workshop on CBR, </booktitle> <address> Lausanne, </address> <year> 1996. </year>
Reference-contexts: In more complex domains, e.g. planning [9], vision [14], software engineering [8] and design [6], the vector representation is not enough expressive for describing real cases. In these domains, structured representations are more appropriate <ref> [3, 9, 12, 2] </ref>. Cases are therefore modeled by semantic networks, a particular type of labeled graphs in which every node is associated to a concept and the edges represent relations between concepts. <p> In this framework retrieval algorithms essentially search the case base for a graph that contains a subgraph isomorph, or partially isomorph (maximal common subgraph), to the query case <ref> [4, 2, 6] </ref>. Unfortunately the graph isomorphism problem for generic graphs is NP-Hard (exponential in the number of graph's nodes). Many attempts were made to cope with that, but there are some positive results only with case bases of small size. <p> Many attempts were made to cope with that, but there are some positive results only with case bases of small size. It still seems very hard to scale up on case bases with hundreds of cases. Borner et al. <ref> [2] </ref> reduce the maximal common subgraph problem to the problem of searching for the maximal clique in a combination graph. <p> That structure (exponential in space) can be exploited when a query is made. They show encouraging results when the library of graphs is large and when the stored cases are very similar to each other. Another approach in this direction has been proposed by Borner et al. <ref> [2] </ref>. They exploit similarities among cases by clustering cases according to a structural similarity metric, so that matching is performed in a two stages process. First a good cluster is found and then a good set of graphs is retrieved.
Reference: 3. <author> L. K. Braiting. </author> <title> Building explanations from rules and structured cases. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 34 </volume> <pages> 797-837, </pages> <year> 1991. </year>
Reference-contexts: In more complex domains, e.g. planning [9], vision [14], software engineering [8] and design [6], the vector representation is not enough expressive for describing real cases. In these domains, structured representations are more appropriate <ref> [3, 9, 12, 2] </ref>. Cases are therefore modeled by semantic networks, a particular type of labeled graphs in which every node is associated to a concept and the edges represent relations between concepts.
Reference: 4. <author> H. Bunke and B. Messmer. </author> <title> Similarity measures for structured representations. </title> <editor> In S. Wess, K.-D. Althoff, and M. M. Richter, editors, </editor> <booktitle> Topics in Case-Based Reasoning, </booktitle> <address> Kaiserslautern, Germany, 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In this framework retrieval algorithms essentially search the case base for a graph that contains a subgraph isomorph, or partially isomorph (maximal common subgraph), to the query case <ref> [4, 2, 6] </ref>. Unfortunately the graph isomorphism problem for generic graphs is NP-Hard (exponential in the number of graph's nodes). Many attempts were made to cope with that, but there are some positive results only with case bases of small size. <p> But this does not modify the complexity of the problem. A group of approaches extract from a case library similarities between cases and use these similarities to build a hierarchy of graphs. Bunke and Messmer <ref> [4] </ref> call this hierarchy "network of model graphs" (NMG). In a NMG the common subgraphs of a graph library are organized in a lattice, where the relation is the usual subgraph relation. That structure (exponential in space) can be exploited when a query is made. <p> First a good cluster is found and then a good set of graphs is retrieved. They also use a hierarchical structure similar to that presented in <ref> [4] </ref> but restricted to trees. In this paper we follow a different approach, i.e., trading expressive power with efficiency.
Reference: 5. <author> M. Chung. </author> <title> o(n 2:5 ) time algorithms for the subgraph homeomorphism problem in trees. </title> <journal> Journal of Algorithms, </journal> <volume> 8 </volume> <pages> 106-122, </pages> <year> 1987. </year>
Reference-contexts: The proposed algorithms take the move from the best known algorithm for solving the subtree isomorphism problem on unlabeled trees, proposed by D.W. Matula [10] and M. Chung <ref> [5] </ref>. We have added a user definable similarity metric and exploited a branch and bound technique. <p> The following proposition holds <ref> [5] </ref>: Proposition 1 g 2 S r (p) iff there exists a matching in B p;g that cover C (p).
Reference: 6. <author> F. Gebhardt, A. Vo, W. Grather, and B. Schmidt-Belz. </author> <title> Reasoning with complex cases. </title> <publisher> Kluwer, </publisher> <year> 1997. </year>
Reference-contexts: In rather simple application domains a case can be represented by a vector of attributes. This representation originates from pattern recognition and is widely used in CBR systems mainly because retrieval becomes simple and fast. In more complex domains, e.g. planning [9], vision [14], software engineering [8] and design <ref> [6] </ref>, the vector representation is not enough expressive for describing real cases. In these domains, structured representations are more appropriate [3, 9, 12, 2]. <p> In this framework retrieval algorithms essentially search the case base for a graph that contains a subgraph isomorph, or partially isomorph (maximal common subgraph), to the query case <ref> [4, 2, 6] </ref>. Unfortunately the graph isomorphism problem for generic graphs is NP-Hard (exponential in the number of graph's nodes). Many attempts were made to cope with that, but there are some positive results only with case bases of small size.
Reference: 7. <author> E. K. Jones and A. Roydhouse. </author> <title> Intelligent retrieval of historical meteorological data. </title> <journal> AI Applications, </journal> <volume> 8(3) </volume> <pages> 43-54, </pages> <year> 1994. </year>
Reference-contexts: For that reason, we propose to focus on tree structured cases. We believe that notwithstanding this limitation a large class of real situations can still be managed. For instance, Jones et al. <ref> [7] </ref> represent cases with trees in a CBR system for intelligent retrieval of historical meteorological data, and Surma describes aggregation taxonomies with trees [16]. Moreover labeled trees are at the base of object oriented representation languages and document representation in information retrieval.
Reference: 8. <author> P. Katalagarianos and Y. Vassiliou. </author> <title> On the reuse of software: a case-based approach employing a repository. </title> <journal> Automated Software Engineering, </journal> <volume> 2 </volume> <pages> 55-86, </pages> <year> 1995. </year>
Reference-contexts: In rather simple application domains a case can be represented by a vector of attributes. This representation originates from pattern recognition and is widely used in CBR systems mainly because retrieval becomes simple and fast. In more complex domains, e.g. planning [9], vision [14], software engineering <ref> [8] </ref> and design [6], the vector representation is not enough expressive for describing real cases. In these domains, structured representations are more appropriate [3, 9, 12, 2].
Reference: 9. <author> B. Kettler, J. Hendler, W. A. Anderson, and M. P. Evett. </author> <title> Massively parallel support for case-bases planning. </title> <journal> IEEE Expert, </journal> <pages> pages 8-14, </pages> <year> 1994. </year>
Reference-contexts: In rather simple application domains a case can be represented by a vector of attributes. This representation originates from pattern recognition and is widely used in CBR systems mainly because retrieval becomes simple and fast. In more complex domains, e.g. planning <ref> [9] </ref>, vision [14], software engineering [8] and design [6], the vector representation is not enough expressive for describing real cases. In these domains, structured representations are more appropriate [3, 9, 12, 2]. <p> In more complex domains, e.g. planning [9], vision [14], software engineering [8] and design [6], the vector representation is not enough expressive for describing real cases. In these domains, structured representations are more appropriate <ref> [3, 9, 12, 2] </ref>. Cases are therefore modeled by semantic networks, a particular type of labeled graphs in which every node is associated to a concept and the edges represent relations between concepts.
Reference: 10. <author> D. W. Matula. </author> <title> Subtree isomorphism in O(n 5=2 ). Ann. </title> <journal> Discrete Math., </journal> <volume> 2 </volume> <pages> 91-106, </pages> <year> 1978. </year>
Reference-contexts: The proposed algorithms take the move from the best known algorithm for solving the subtree isomorphism problem on unlabeled trees, proposed by D.W. Matula <ref> [10] </ref> and M. Chung [5]. We have added a user definable similarity metric and exploited a branch and bound technique.
Reference: 11. <author> J. J. McGregor. </author> <title> Relational consistency algorithms and their application in finding subgraph and graph isomorphisms. </title> <journal> Information Science, </journal> <volume> 19 </volume> <pages> 229-250, </pages> <year> 1979. </year>
Reference-contexts: Infact both the sub-graph isomorphism problem and the maximal common subgraphs problem can be addressed in two way: by searching for maximal clique [13] or by constraints satisfaction <ref> [18, 11, 13] </ref>. But this does not modify the complexity of the problem. A group of approaches extract from a case library similarities between cases and use these similarities to build a hierarchy of graphs. Bunke and Messmer [4] call this hierarchy "network of model graphs" (NMG).
Reference: 12. <author> E. </author> <title> Plaza. Cases as terms: a feature term approach to the structured representation of cases. </title> <booktitle> In International Conference on Case-Based Reasoning (ICCBR-95), </booktitle> <address> Sesimbra, Portugal, </address> <month> Oct. </month> <pages> 23-26. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: In more complex domains, e.g. planning [9], vision [14], software engineering [8] and design [6], the vector representation is not enough expressive for describing real cases. In these domains, structured representations are more appropriate <ref> [3, 9, 12, 2] </ref>. Cases are therefore modeled by semantic networks, a particular type of labeled graphs in which every node is associated to a concept and the edges represent relations between concepts.
Reference: 13. <institution> J.-C. Regin. Developpment d'outils algorithmiques pour l'Intelligence Artificielle. applicatin a la chimique organique. These de doctorat, Universite Montpellier II, </institution> <year> 1995. </year>
Reference-contexts: Borner et al. [2] reduce the maximal common subgraph problem to the problem of searching for the maximal clique in a combination graph. Infact both the sub-graph isomorphism problem and the maximal common subgraphs problem can be addressed in two way: by searching for maximal clique <ref> [13] </ref> or by constraints satisfaction [18, 11, 13]. But this does not modify the complexity of the problem. A group of approaches extract from a case library similarities between cases and use these similarities to build a hierarchy of graphs. <p> Infact both the sub-graph isomorphism problem and the maximal common subgraphs problem can be addressed in two way: by searching for maximal clique [13] or by constraints satisfaction <ref> [18, 11, 13] </ref>. But this does not modify the complexity of the problem. A group of approaches extract from a case library similarities between cases and use these similarities to build a hierarchy of graphs. Bunke and Messmer [4] call this hierarchy "network of model graphs" (NMG). <p> We are interested in, given a query graph H and a family of graphs fG i g, identifying the subgraphs of some element G i that are isomorphic to the given query graph. We now precisely define the terms we are using <ref> [13, 19] </ref>. <p> Proposition 1 yields immediately a recursive algorithm for testing if H r is isomorphic to a subtree of G r 0 . The algorithm in Figure 2 shows an iterative version that is equivalent to that presented in <ref> [13] </ref>. In SubT reeIso there is a first initialization block (lines 2 ffi 7) of the sets S r ; the second block (lines 8 ffi 12) computes the S r (p) 8p 2 V H starting from the leaves and ending to the root of the tree.
Reference: 14. <author> R. J. Schalkoff. </author> <title> Pattern recognition: statistical, structural and neural approaches. </title> <publisher> John Wiley, </publisher> <year> 1992. </year>
Reference-contexts: In rather simple application domains a case can be represented by a vector of attributes. This representation originates from pattern recognition and is widely used in CBR systems mainly because retrieval becomes simple and fast. In more complex domains, e.g. planning [9], vision <ref> [14] </ref>, software engineering [8] and design [6], the vector representation is not enough expressive for describing real cases. In these domains, structured representations are more appropriate [3, 9, 12, 2].
Reference: 15. <author> L. Senter. Accoppiamento inesatto di alberi e ragionamento basato su casi. </author> <type> Master's thesis, </type> <institution> Univerista di Padova, Facolta di Ingegneria, </institution> <year> 1998. </year>
Reference-contexts: The algorithm in Figure 2 does not explicitly list all the injective morphisms of H r in G r 0 . To attain that goal an additional procedure must be used <ref> [15] </ref>. It is simple to show that when all the S r (p) have been computed a backtrack-free search can output all the isomorphisms. <p> The best incomplete similarity isomorphism is the element, in S r i (r), which have minimal distance (as shown in Equation 2). In <ref> [15] </ref> is proved that S r i (v) can be computed from the sets S r i (x), 8x 2 C (v). This property allows a fast search of the best incomplete similarity isomorphism. morphism.
Reference: 16. <author> J. Surma. </author> <title> A similarity measure for aggregation taxonomies. In ECML Workshop Notes on Case-Based Learning: Beyond Classification of Feature Vectors, </title> <address> Prague, </address> <year> 1997. </year>
Reference-contexts: We believe that notwithstanding this limitation a large class of real situations can still be managed. For instance, Jones et al. [7] represent cases with trees in a CBR system for intelligent retrieval of historical meteorological data, and Surma describes aggregation taxonomies with trees <ref> [16] </ref>. Moreover labeled trees are at the base of object oriented representation languages and document representation in information retrieval. We have designed and implemented a set of efficient algorithms for case retrieval from a case base of trees labeled on both nodes and edges.
Reference: 17. <author> E. Tanaka and K. Tanaka. </author> <title> The tree-to-tree editing problem. </title> <journal> International Journal of pattern recognition and artificial intelligence, </journal> <volume> 2(2) </volume> <pages> 224-240, </pages> <year> 1988. </year>
Reference-contexts: The complexity of the retrieval resides on the fact that trees here considered are general trees, i.e. they are not ordered 1 as other approaches assume <ref> [17] </ref>. This feature is important in many applications, e.g. planning, and enables one to apply the proposed algorithms to trees that partially represent a graph, for instance a spanning tree.
Reference: 18. <author> J. R. </author> <title> Ullmann. An algorithm for subgraph isomorphism. </title> <journal> Journal of the ACM, </journal> <volume> 1(23) </volume> <pages> 31-42, </pages> <year> 1976. </year>
Reference-contexts: Infact both the sub-graph isomorphism problem and the maximal common subgraphs problem can be addressed in two way: by searching for maximal clique [13] or by constraints satisfaction <ref> [18, 11, 13] </ref>. But this does not modify the complexity of the problem. A group of approaches extract from a case library similarities between cases and use these similarities to build a hierarchy of graphs. Bunke and Messmer [4] call this hierarchy "network of model graphs" (NMG).
Reference: 19. <author> J. van Leeuwen. </author> <title> Graphs algorithms. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 525-631. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: In this paper we follow a different approach, i.e., trading expressive power with efficiency. The subgraph isomorphism problem becomes polynomial when both the query case and the cases in the case base are trees <ref> [19] </ref>, and this result generalizes also to a class of planar graphs. For that reason, we propose to focus on tree structured cases. We believe that notwithstanding this limitation a large class of real situations can still be managed. <p> We are interested in, given a query graph H and a family of graphs fG i g, identifying the subgraphs of some element G i that are isomorphic to the given query graph. We now precisely define the terms we are using <ref> [13, 19] </ref>. <p> A matching of G =&lt; V; E &gt; is a subset M E such that if (x; y); (z; w) 2 M then x 6= z, x 6= w, y 6= z and y 6= w <ref> [19] </ref>. A matching M E cover a set V 0 V if for all x 2 V 0 there exists y 2 V s.t. (x; y) 2 M or (y; x) 2 M . <p> Note that SubT reeIso stops and exits with false when one tree H r (p) is not isomorph to any subtree of G r 0 . The function ComputeM atching applies a maximal bipartite matching algorithm <ref> [19] </ref> to find (lines 5 ffi 6 of function ComputeS) if a node g 2 V G is in S r (p), according to proposition 1. <p> the procedure ComputeS given two nodes h 2 V H and g 2 V G , if the similarity between the labels of the two nodes and of their incident edges is greater than 0 then the matching distance d hg is computed solving a maximum weight bipartite matching problem <ref> [19] </ref>. The matching distance d hg , computed in ComputeDist, has two parts: the first is determined by the labels of h and g and the labels of the incident edges, the second depends on the matching of the children nodes of h with the children nodes of g.
References-found: 19

