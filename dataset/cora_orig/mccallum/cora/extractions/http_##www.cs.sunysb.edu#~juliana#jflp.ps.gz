URL: http://www.cs.sunysb.edu/~juliana/jflp.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~juliana/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fjuliana,tswift,warreng@cs.sunysb.edu  
Title: Beyond Depth-First: Improving Tabled Logic Programs through Alternative Scheduling Strategies  
Author: Juliana Freire Terrance Swift David S. Warren 
Address: NY 11794-4400  
Affiliation: Department of Computer Science State University of New York at Stony Brook Stony Brook,  
Abstract: Tabled evaluation ensures termination for programs with finite models by keeping track of which subgoals have been called. Given several variant subgoals in an evaluation, only the first one encountered will use program clause resolution; the rest will resolve with the answers generated by the first subgoal. This use of answer resolution prevents infinite looping which sometimes happens in SLD. Because answers are produced in one path of the computation may be consumed, asynchronously, in others, tabling systems face an important scheduling choice not present in traditional top-down evaluation: when to schedule answer resolution. This paper investigates alternate scheduling strategies for tabling in a WAM implementation, the SLG-WAM. The original SLG-WAM had a simple mechanism of scheduling answer resolution which was expensive in terms of trailing and choice point creation. We propose here fl A preliminary version of this paper appeared in Proceedings of the Eigth International Symposium of Programming Languages, Implementations, Logics and Programs, Springer Verlag, 1996, pp. 243-258. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. At-Kaci. </author> <title> WAM: A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: frame is created and a new DFN is assigned to it. 2 Throughout this paper we will distinguish between the SCCs of an SLG system and their (safe) approximation by the completion stack, or ASCCs. 3 Scheduling Strategies 3.1 Single Stack Scheduling The scheduling of program clause resolution in Prolog <ref> [1, 24] </ref> is conceptually simple. The engine performs forward execution for as long as it possibly can.
Reference: [2] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the Power of Magic. </title> <journal> Journal of Logic Programming, </journal> <volume> 10(3) </volume> <pages> 255-299, </pages> <year> 1991. </year>
Reference-contexts: The efficient evaluation of queries to disk-resident data provides a clear instance of how a scheduling strategy can benefit an application. Efficiently accessing disk requires a strategy analogous to the semi-naive evaluation of a magic-transformed <ref> [2] </ref> program. A separate paper [11] showed how this could be done using a breadth-first set-at-a-time tabling strategy for the SLG-WAM [19] of XSB 1 . Unlike XSB's original tuple-at-a-time engine, the engine based on the breadth-first strategy showed good performance for disk accesses. <p> This latter step gives good performance for in-memory queries, but makes the Batched Scheduling algorithm differ from traditional deductive database-style evaluations such as the semi-naive evaluation of a Magic-transformed program <ref> [2] </ref>. After all answers are returned, the engine backtracks to the generator choice point of S.
Reference: [3] <author> M. Bruynooghe. </author> <title> A practical framework for the abstract interpretation of logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 10 </volume> <pages> 91-124, </pages> <year> 1991. </year> <title> 7 Versions 1.7 and higher of XSB can evaluate the well-founded semantics using either Batched Scheduling or Local Scheduling. </title> <type> 37 </type>
Reference-contexts: This behavior might significantly improve the performance of program analyzers such as those based on Bruynooghe's abstract interpretation framework <ref> [3] </ref>. In this framework, after all the clauses for a predicate have been analyzed, the abstract substitution for the predicate is computed by taking the most general substitution among the clauses.
Reference: [4] <author> W. Chen, M. Kifer, and D.S. Warren. HiLog: </author> <title> A foundation for higher--order logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 15(3) </volume> <pages> 187-230, </pages> <year> 1993. </year>
Reference-contexts: Given that a local evaluation evaluates each SCC completely before returning any answers out of it, we are guaranteed that only the most general answers will be returned out of that SCC. This process is presented in detail in Example 3.4. Example 3.4 Consider the following HiLog <ref> [4] </ref> variation of the same generation program which finds the smallest distance between two people in the same generation: sgi (X,Y)(I) :- ancestor (X,Z), subsumes (min)(sgi (Z,Z1),I1), 20 ancestor (Y,Z1), I is I1+1. :- subsumes (min)(sgi (joan,carl),I). where subsumes (min)/2 is a HiLog tabled predicate that performs answer subsumption by deleting
Reference: [5] <author> W. Chen and D.S. Warren. </author> <title> Tabled Evaluation with Delaying for General Logic Programs. </title> <journal> JACM, </journal> <volume> 43(1) </volume> <pages> 20-74, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: In this section we review tabling using the notation of SLG resolution <ref> [5] </ref> reformulated and simplified for definite programs. As preliminary terminology, subgoals and goals are atoms. Predicates can be annotated as either tabled, or non-tabled in which case SLD resolution is used. Evaluations are modeled by a sequence of systems or forests of SLG trees. <p> For each node with selected literal SL in the tree with root Subg: (a) SL is completed; or 6 (b) SL 2 S and there are no applicable subgoal call, program clause resolution, or answer clause resolution opera tions for SL. 2 Correctness of SLG was shown in <ref> [5] </ref>, along with the correctness of a restriction of SLG for definite programs. To restate this result, we briefly review some terminology. Let F be a system for an SLG evaluation of a program P and query Q. <p> It was shown in [18] that the SLG-WAM's completion stack maintains exact dependencies for local evaluations. Maintaining exact dependencies allows the engine to verify whether loops through negation exist, and to delay literals (to break these loops <ref> [5] </ref>) only when it is necessary. Even though negation handling and scheduling strategies are orthogonal issues, some strategies may be more efficient to evaluate normal programs. The following example shows how a local evaluation can benefit the evaluation of programs with negation.
Reference: [6] <author> M. Codish, B. Demoen, and K. Sagonas. </author> <title> XSB as the natural habitat for general purpose program analysis. </title> <type> Technical report, </type> <institution> KU Leuven, </institution> <year> 1996. </year>
Reference-contexts: This property has led to the use of tabled logic programming for new areas of logic programming. These include not only deductive database style applications, but other fixpoint-style problems, such as program analysis <ref> [8, 6] </ref>, compiler optimization [7] and model-checking [16]. Ensuring that these new applications run efficiently may require the use of different scheduling strategies.
Reference: [7] <author> S. Dawson, C. R. Ramakrishnan, S. Skiena, and T. Swift. </author> <title> Principles and practice of unification factoring. </title> <journal> ACM Transactions on Programming Languages and Systems (TOPLAS), </journal> <volume> 18(5) </volume> <pages> 528-563, </pages> <year> 1996. </year>
Reference-contexts: This property has led to the use of tabled logic programming for new areas of logic programming. These include not only deductive database style applications, but other fixpoint-style problems, such as program analysis [8, 6], compiler optimization <ref> [7] </ref> and model-checking [16]. Ensuring that these new applications run efficiently may require the use of different scheduling strategies.
Reference: [8] <author> S. Dawson, C.R. Ramakrishnan, and D.S. Warren. </author> <title> Practical Program Analysis Using General Purpose Logic Programming Systems | A Case Study. </title> <booktitle> In Proceedings of the ACM Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 117-125. </pages> <publisher> ACM, </publisher> <year> 1996. </year>
Reference-contexts: This property has led to the use of tabled logic programming for new areas of logic programming. These include not only deductive database style applications, but other fixpoint-style problems, such as program analysis <ref> [8, 6] </ref>, compiler optimization [7] and model-checking [16]. Ensuring that these new applications run efficiently may require the use of different scheduling strategies. <p> The ability to return only the most general answers out of a table can be useful for program analyses (see e.g., <ref> [8, 12] </ref>), for deductive database queries that use aggregates [22], and for answers involving constraints [21].
Reference: [9] <author> C. Fan and S. Dietrich. </author> <title> Extension Table Built-ins for Prolog. </title> <journal> Software-Practice and Experience, </journal> <volume> 22(7) </volume> <pages> 573-597, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: that a mixture of strategies may become useful: Batched Scheduling for existential queries, Local Scheduling for queries that involve answer subsumption, while either may evaluate the remaining class of queries. 6 Discussion and Future Directions Batched Scheduling bears some resemblance to two independently developed approaches: the ET fl algorithm from <ref> [9] </ref> and the AMAI from [12]. However, in [9], Fan and Dietrich do not consider strongly connected components in the fixpoint check, and their strategy is fair for answers 6 . The extra check for fairness may result in inefficiencies for in-memory queries such as transitive closure over a chain. <p> Batched Scheduling for existential queries, Local Scheduling for queries that involve answer subsumption, while either may evaluate the remaining class of queries. 6 Discussion and Future Directions Batched Scheduling bears some resemblance to two independently developed approaches: the ET fl algorithm from <ref> [9] </ref> and the AMAI from [12]. However, in [9], Fan and Dietrich do not consider strongly connected components in the fixpoint check, and their strategy is fair for answers 6 . The extra check for fairness may result in inefficiencies for in-memory queries such as transitive closure over a chain.
Reference: [10] <author> J. Freire, R. Hu, T. Swift, and D.S. Warren. </author> <title> Exploiting Parallelism in Tabled Evaluations. </title> <booktitle> In 7th International Symposium, </booktitle> <volume> PLILP 95 - LNCS Vol. 982, </volume> <pages> pages 115-132. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Finally, the integration of the action of returning answers into the mechanism of the choice point stack makes Single Stack Scheduling not easily adaptable to a parallel engine <ref> [10] </ref>. 3.2 Batched Scheduling Batched Scheduling can be seen as an attempt to address the problems with Single Stack Scheduling mentioned above. Indeed, versions 1.5 and higher of XSB use this new strategy as a default.
Reference: [11] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Taking I/O seriously: Resolution reconsidered for disk. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: The efficient evaluation of queries to disk-resident data provides a clear instance of how a scheduling strategy can benefit an application. Efficiently accessing disk requires a strategy analogous to the semi-naive evaluation of a magic-transformed [2] program. A separate paper <ref> [11] </ref> showed how this could be done using a breadth-first set-at-a-time tabling strategy for the SLG-WAM [19] of XSB 1 . Unlike XSB's original tuple-at-a-time engine, the engine based on the breadth-first strategy showed good performance for disk accesses. <p> At CheckComplete, not only does Batched 4 It is worth pointing out that only the underlying data structures are searched in a breadth-first manner. The predominantly depth-first nature of program clause resolution in the WAM is maintained through all strategies discussed in this paper. However, <ref> [11] </ref> discusses the SLG-WAM implementation of a general breadth-first search that is also suitable for queries to disk-resident data. 32 (a) Linear chains of varying length (b) Complete binary trees of varying height Scheduling need to schedule all unresolved answers, but for each leader subgoal it has to check whether all
Reference: [12] <author> G. Janssens, M. Bruynooghe, and V. Dumortier. </author> <title> A Blueprint for an Abstract Machine for Abstract Interpretation of (Constraint) Logic Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <pages> pages 336-350, </pages> <year> 1995. </year>
Reference-contexts: The ability to return only the most general answers out of a table can be useful for program analyses (see e.g., <ref> [8, 12] </ref>), for deductive database queries that use aggregates [22], and for answers involving constraints [21]. <p> may become useful: Batched Scheduling for existential queries, Local Scheduling for queries that involve answer subsumption, while either may evaluate the remaining class of queries. 6 Discussion and Future Directions Batched Scheduling bears some resemblance to two independently developed approaches: the ET fl algorithm from [9] and the AMAI from <ref> [12] </ref>. However, in [9], Fan and Dietrich do not consider strongly connected components in the fixpoint check, and their strategy is fair for answers 6 . The extra check for fairness may result in inefficiencies for in-memory queries such as transitive closure over a chain. In [12], Janssens et al. describe <p> and the AMAI from <ref> [12] </ref>. However, in [9], Fan and Dietrich do not consider strongly connected components in the fixpoint check, and their strategy is fair for answers 6 . The extra check for fairness may result in inefficiencies for in-memory queries such as transitive closure over a chain. In [12], Janssens et al. describe an abstract machine spe for XSB v. 1.5, they range between 0.09 and 4007.8 seconds. 6 That is, answers are not returned in the same fixpoint iteration they are created. 35 (a) (b) subsumes (min)(sgi (n-1,n),I) on graphs of the form depicted in (a) for varying
Reference: [13] <author> D. E. Knuth. </author> <title> The Stanford GraphBase: A Platform for Combinatorial Computing. </title> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: examine the differences between Single Stack Scheduling and Batched Scheduling for left-recursive transitive closure on a linear chain con 2 The nodes of these graphs are a subset of the 5757 more common 5-letter English words; there is an arc between two words if they differ in a single character <ref> [13] </ref>. 29 Table 3: SLG-WAM execution profile for left-recursive transitive closure on a linear chain with 1024 nodes Instructions/Operations XSB v. 1.4 XSB v. 1.5 Local RetryConsuming 0 1023 1023 RetryGenConsuming n/a n/a 1023 AnswerReturn 1022 n/a n/a CheckComplete 1 1 1 SwitchEnvironments 1026 1027 2050 freeze 1022 0 0 trail
Reference: [14] <author> G. Kostler, W. Kiessling, H. Thone, and U. Guntzer. </author> <title> Fixpoint iteration with subsumption in deductive databases. </title> <journal> Journal of Intelligent Information Systems (JIIS), </journal> <volume> 4(2) </volume> <pages> 123-148, </pages> <month> March </month> <year> 1995. </year> <month> 38 </month>
Reference-contexts: Resolving a call to a negative literal requires completely evaluating the subgoal contained in the literal, along with all other dependent subgoals. In a similar manner, waiting until part of an evaluation has been completely evaluated can also benefit programs that use answer subsumption (e.g., <ref> [14] </ref>), in which only the most general answers need to be maintained and returned to consuming subgoals.
Reference: [15] <author> E. Lusk, R. Butler, T. Disz, R. Olson, R. Overbeek, D.H.D. War--ren, A. Calderwood, P. Szeredi, S. Haridi, P. Brand, M. Carlsson, A. Ciepielewski, and B. Hausman. </author> <title> The Aurora or-parallel Prolog system. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 819-830. </pages> <publisher> ICOT, </publisher> <year> 1988. </year>
Reference-contexts: The SLG-WAM achieves this by freezing the various WAM stacks at the point a new consuming node is created. In fact, the SLG-WAM keeps a linearized version of the search space in its stacks (similar to the cactus stacks of OR-parallel implementations such as Aurora <ref> [15] </ref>). Switching from one environment to another is performed by backtracking to a common ancestor, and then using a forward trail to reconstitute the environments of consuming nodes. The second change arises from the need to approximate the subgoal dependency graph, and thus to provide incremental completion.
Reference: [16] <author> Y. Ramakrishna, C.R. Ramakrishnan, I.V. Ramakrishnan, S. Smolka, T. Swift, and D. Warren. </author> <title> Efficient model checking using tabled resolution. </title> <booktitle> In Proceedings of Computer Aided Verification (CAV), </booktitle> <year> 1997. </year>
Reference-contexts: This property has led to the use of tabled logic programming for new areas of logic programming. These include not only deductive database style applications, but other fixpoint-style problems, such as program analysis [8, 6], compiler optimization [7] and model-checking <ref> [16] </ref>. Ensuring that these new applications run efficiently may require the use of different scheduling strategies.
Reference: [17] <author> I.V. Ramakrishnan, P. Rao, K. Sagonas, T. Swift, and D.S. Warren. </author> <title> Efficient table access mechanisms for logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <pages> pages 697-711, </pages> <year> 1995. </year>
Reference-contexts: If so the instruction fails, otherwise the answer is added to the table. The SLG-WAM represents tables using a trie-like structure <ref> [17] </ref>. Tries provide efficient check and insert of subgoals and answers, good indexing and space savings. More specifically, the SLG-WAM uses a subgoal trie to represent subgoals present in an evaluation.
Reference: [18] <author> T. Swift. </author> <title> Efficient Evaluation of Normal Logic Programs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, State University of New York at Stony Brook, </institution> <year> 1994. </year>
Reference-contexts: The choice point stack thus serves as a scheduling stack for both returning answers and resolving program clauses. Accordingly, we call this scheduling strategy Single Stack Scheduling. The operational semantics of this scheduling strategy was described in detail in <ref> [18] </ref>, and forms the basis of the SLG-WAM as described in [19]. <p> Note that the answer generated for subgoal p (2,Y) in node 10 is only returned to its calling environment (in node 5) after the tree for p (2,Y) is completely evaluated. It was shown in <ref> [18] </ref> that the SLG-WAM's completion stack maintains exact dependencies for local evaluations. Maintaining exact dependencies allows the engine to verify whether loops through negation exist, and to delay literals (to break these loops [5]) only when it is necessary.
Reference: [19] <author> T. Swift and D. S. Warren. </author> <title> An Abstract Machine for SLG Resolution: Definite Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <pages> pages 633-654, </pages> <year> 1994. </year>
Reference-contexts: Efficiently accessing disk requires a strategy analogous to the semi-naive evaluation of a magic-transformed [2] program. A separate paper [11] showed how this could be done using a breadth-first set-at-a-time tabling strategy for the SLG-WAM <ref> [19] </ref> of XSB 1 . Unlike XSB's original tuple-at-a-time engine, the engine based on the breadth-first strategy showed good performance for disk accesses. <p> a variant of Subg; or * S is an independent SCC and there are no applicable subgoal call, program clause resolution, or answer clause resolution operations for Subg. 2 2.3 The SLG-WAM: A Virtual Machine for Tabling The data structures and instruction set used by the SLG-WAM are described in <ref> [19] </ref>; here we briefly summarize aspects of the SLG-WAM needed to describe scheduling strategies. As mentioned in Section 2.1, there are several types of nodes: generator, consuming, interior and answer. <p> Accordingly, we call this scheduling strategy Single Stack Scheduling. The operational semantics of this scheduling strategy was described in detail in [18], and forms the basis of the SLG-WAM as described in <ref> [19] </ref>.
Reference: [20] <author> T. Swift and D. S. Warren. </author> <title> Analysis of sequential SLG evaluation. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <pages> pages 219-238, </pages> <year> 1994. </year>
Reference-contexts: Unlike XSB's original tuple-at-a-time engine, the engine based on the breadth-first strategy showed good performance for disk accesses. Of course tabled evaluations must also be efficient for in-memory queries. <ref> [20] </ref> showed that, under several different criteria of measurement, tabled evaluation incurred a minimal execution time overhead compared to Prolog. <p> We also describe the instruction set that is used to implement this strategy. * We provide detailed results of experiments comparing these two strategies with XSB's original Single Stack Scheduling (described in <ref> [20] </ref>). They show that: - Batched Scheduling can provide an order of magnitude space reduction over the original strategy, as well as reliably provide a significant reduction in time.
Reference: [21] <author> D. Toman. </author> <title> Top-down beats bottom-up for constraint extensions of dat-alog. </title> <booktitle> In Proceedings of the International Logic Programming Symposium (ILPS), </booktitle> <pages> pages 98-115, </pages> <year> 1995. </year>
Reference-contexts: The ability to return only the most general answers out of a table can be useful for program analyses (see e.g., [8, 12]), for deductive database queries that use aggregates [22], and for answers involving constraints <ref> [21] </ref>. This paper motivates and describes the design and implementation of two new scheduling strategies for tabled logic programs: * We describe Batched Scheduling along with an instruction set which has been used to implement this strategy.
Reference: [22] <author> A. van Gelder. </author> <title> Foundations of Aggregation in Deductive Databases. </title> <booktitle> In Proceedings of the International Conference on Deductive and Object-Oriented Databases (DOOD), </booktitle> <pages> pages 13-34, </pages> <year> 1993. </year>
Reference-contexts: The ability to return only the most general answers out of a table can be useful for program analyses (see e.g., [8, 12]), for deductive database queries that use aggregates <ref> [22] </ref>, and for answers involving constraints [21]. This paper motivates and describes the design and implementation of two new scheduling strategies for tabled logic programs: * We describe Batched Scheduling along with an instruction set which has been used to implement this strategy.
Reference: [23] <author> A. van Gelder, K.A. Ross, and J.S. Schlipf. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <journal> JACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: Local Scheduling can perform asymptotically better than Batched Scheduling when combined with answer subsumption. This can be of use in many different areas such as aggregate selection and program analysis. In addition, Local Scheduling may have an important role to play in evaluating programs under the well-founded semantics <ref> [23] </ref>. Currently in the default scheduling strategy of XSB, the engine may have to construct part of the SDG to 36 check for loops through negation. Since Local Scheduling maintains exact SCCs, it does not require this step as was demonstrated by Example 3.3.
Reference: [24] <author> D.H.D. Warren. </author> <title> An Abstract Prolog Instruction Set. </title> <type> Technical Report 309, </type> <institution> SRI, </institution> <year> 1983. </year> <month> 39 </month>
Reference-contexts: frame is created and a new DFN is assigned to it. 2 Throughout this paper we will distinguish between the SCCs of an SLG system and their (safe) approximation by the completion stack, or ASCCs. 3 Scheduling Strategies 3.1 Single Stack Scheduling The scheduling of program clause resolution in Prolog <ref> [1, 24] </ref> is conceptually simple. The engine performs forward execution for as long as it possibly can.
Reference: [25] <author> U. Zukowski and B. Freitag. </author> <title> Adding flexibility to query evaluation for modularly stratified databases. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming (JICSLP), </booktitle> <pages> pages 304-318, </pages> <year> 1996. </year> <month> 40 </month>
Reference-contexts: Even though they take SCCs into account, these are detected statically. In the SLG-WAM, dynamic detection of SCCs has been proven useful in the evaluation of logic programs with negation (stratified or not). Local Scheduling resembles the strategy proposed by Zukowski and Freitag in <ref> [25] </ref> where program fragments are evaluated by different fixpoints. The scheduling strategies proposed in this paper can improve the performance | memory usage and execution time of tabled evaluations. Due to its performance, Batched Scheduling is now the default scheduling strategy for XSB.
References-found: 25

