URL: http://charm.cs.uiuc.edu/manuals/cml-paper.ps.gz
Refering-URL: http://charm.cs.uiuc.edu/manuals/
Root-URL: http://www.cs.uiuc.edu
Email: jhr@cs.cornell.edu  
Title: CML: A Higher-order Concurrent Language  
Author: John H. Reppy 
Affiliation: Cornell University  
Date: June 1991  February 15, 1993  
Note: A revised version of a paper presented at the SIGPLAN'91 Conference on Programming Language Design and Implementation,  
Abstract-found: 0
Intro-found: 1
Reference: [AB86] <author> Abramsky, S. and R. Bornat. Pascal-m: </author> <title> A language for loosely coupled distributed systems. </title> <editor> In Y. Paker and J.-P. Verjus (eds.), </editor> <booktitle> Distributed Computing Systems, </booktitle> <pages> pp. 163-189. </pages> <publisher> Academic Press, </publisher> <address> New York, N.Y., </address> <year> 1986. </year>
Reference: [AEL88] <author> Appel, A. W., J. R. Ellis, and K. Li. </author> <title> Real-time concurrent collection on stock multiprocessors. </title> <booktitle> In Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1988, </year> <pages> pp. 11-20. </pages>
Reference-contexts: This hot-spot behavior is the worst-case scenario for SML/NJ's collector, destroying the O (jLIVEj) normally expected from copying collection. The collector also suffers from the problem of poor real-time responsiveness. We have designed a new, multi-generational, collector for SML/NJ [Rep] , which uses the page-protection techniques of [Sha87] and <ref> [AEL88] </ref> to implement the write barrier. This new collector improves the performance of CML in two ways: the hot-spot update behavior only incurs a constant cost for garbage collection and eliminating the store-list reduces the frequency of garbage collection and the cost of update operations.
Reference: [Agh86] <author> Agha, G. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: In the following section, we give a more substantial example. 2.2 An example An example that illustrates a number of key points is an implementation of a buffered channel abstraction. Buffered channels provide a mechanism for asynchronous communication, which is similar to the actor mailbox <ref> [Agh86] </ref> . The source code for this abstraction is given in figure 3.
Reference: [AJ89] <author> Appel, A. W. and T. Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Conference Record of the 16th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1989, </year> <pages> pp. 293-302. </pages>
Reference-contexts: To a great extent, SML/NJ has met this goal as an 15 implementation of a high-level language <ref> [AJ89] </ref>. Our benchmark results show that CML maintains this standard. 5.1 The benchmarks We have conducted a series of benchmarks on three different machines (see table 2).
Reference: [AM87] <author> Appel, A. W. and D. B. MacQueen. </author> <title> A Standard ML compiler. </title> <booktitle> In Functional Programming Languages and Computer Architecture, vol. 274 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1987, </year> <pages> pp. 301-324. </pages>
Reference: [App89] <author> Appel, A. W. </author> <title> Simple generational garbage collection and fast allocation. </title> <journal> Software Practice and Experience, </journal> <volume> 19(2), </volume> <month> February </month> <year> 1989, </year> <pages> pp. 275-279. </pages>
Reference-contexts: Event RPC This implements the request/reply exchange as an event value. 5.2 Garbage collection overhead The high garbage collection overhead in these benchmarks is mostly a result of the way the current SML/NJ collector, which is a simple generational collector, keeps track of intergenerational references <ref> [App89] </ref> . Each time a mutable object is updated, a record of that update is added to the store-list. This store list is examined for potential roots at the beginning of each garbage collection.
Reference: [AS83] <author> Andrews., G. R. and F. B. Schneider. </author> <title> Concepts and notations for concurrent programming. </title> <journal> ACM Computing Surveys, </journal> <volume> 15(1), </volume> <month> March </month> <year> 1983, </year> <pages> pp. 3-43. 20 </pages>
Reference-contexts: This shows that we can have the advantages of the higher level language without sacrificing performance; a rare situation indeed. 6 Related work There are many approaches to concurrent language design (see <ref> [AS83] </ref> for an overview); our approach is an offshoot of the CSP-school of concurrent language design. CML began as a reimplementation of the concurrency primitives of PML [Rep88] in SML/NJ, but has evolved into a significantly more powerful language. PML in turn was heavily influenced by amber [Car86] .
Reference: [BCJ + 90] <author> Birman, K., R. Cooper, T. A. Joseph, K. Marzullo, M. Makpangou, K. Kane, F. Schmuck, and M. Wood. </author> <title> The ISIS system manual, </title> <type> version 2.0. </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, N.Y., </address> <month> March </month> <year> 1990. </year>
Reference: [Bor86] <author> Bornat, R. </author> <title> A protocol for generalized occam. </title> <journal> Software Practice and Experience, </journal> <volume> 16(9), </volume> <month> September </month> <year> 1986, </year> <pages> pp. 783-799. </pages>
Reference: [BS90] <author> Buhr, P. A. and R. A. Stroobosscher. </author> <title> The System: Providing light-weight concurrency on shared-memory multiprocessor computers running UNIX. </title> <journal> Software Practice and Experience, </journal> <volume> 20(9), </volume> <month> September </month> <year> 1990, </year> <pages> pp. 929-963. </pages>
Reference-contexts: specialized compiler support, such as a dedicated register for the thread ready queue, performance would improve substantially. 5.4 Comparison with the System Lastly, to put our measurements into perspective, we implemented a similar (allowing for linguistic differences) set of benchmarks in the System, which is a C light-weight process library <ref> [BS90] </ref> . We ran these benchmarks on the same machines; the results are reported in table 6.
Reference: [Bur88] <author> Burns, A. </author> <title> Programming in occam 2. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1988. </year>
Reference-contexts: This is an example of the necessity of generalized selective communication. If we have only a multiplexed input construct (e.g., occam's ALT), then we must to use a request/reply protocol to implement the server side of the bufferReceive operation (see pp. 37-41 of <ref> [Bur88] </ref>, for example). But if a request/reply protocol is used, then the bufferReceive operation cannot be used in a selective communication by the client. * The buffer thread is a good example of a common CML programming idiom: using threads to encapsulate state.
Reference: [Car86] <author> Cardelli, L. </author> <title> Amber. </title> <booktitle> In Combinators and Functional Programming Languages, vol. 242 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1986, </year> <pages> pp. 21-47. </pages>
Reference-contexts: CML began as a reimplementation of the concurrency primitives of PML [Rep88] in SML/NJ, but has evolved into a significantly more powerful language. PML in turn was heavily influenced by amber <ref> [Car86] </ref> . There have been other attempts at adding concurrency to various versions of ML. Most of these have been 18 based on message passing ([Hol83], [Mat89], and [Ram90] for example), but there is at least one shared memory approach [CM90] .
Reference: [CM90] <author> Cooper, E. C. and J. G. Morrisett. </author> <title> Adding threads to Standard ML. </title> <type> Technical Report CMU-CS-90-186, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: PML in turn was heavily influenced by amber [Car86] . There have been other attempts at adding concurrency to various versions of ML. Most of these have been 18 based on message passing ([Hol83], [Mat89], and [Ram90] for example), but there is at least one shared memory approach <ref> [CM90] </ref> . As we have shown in this paper, message passing fits very nicely into SML. It allows an applicative style of programming to be used most of the time; the state modifying operations are hidden in the thread and channel abstractions.
Reference: [CP85] <author> Cardelli, L. and R. Pike. Squeak: </author> <title> A language for communicating with mice. </title> <booktitle> In SIGGRAPH '85, </booktitle> <month> July </month> <year> 1985, </year> <pages> pp. 199-204. </pages>
Reference: [DH89] <author> Dybvig, R. K. and R. Hieb. </author> <title> Engines from continuations. </title> <journal> Computing Languages, </journal> <volume> 14(2), </volume> <year> 1989, </year> <pages> pp. 109-123. </pages>
Reference-contexts: A number of papers have been published on the use of first-class continuations to implement concurrency in scheme (e.g., [Wan80], [HFW84] and <ref> [DH89] </ref>), but we break new ground in a couple of ways: we describe the implementation of first-class synchronous operations using first-class continuations; we describe a complete language for concurrent programming and its use; and we provide performance figures.
Reference: [DHM91] <author> Duba, B., R. Harper, and D. MacQueen. </author> <title> Type-checking first-class continuations. </title> <booktitle> In Conference Record of the 18th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1991, </year> <pages> pp. 163-173. </pages>
Reference-contexts: A user's session manager will farm out pieces of the proof to idle and available servers; it uses an object similar to a promise as a place-holder for the outstanding work. 4 Implementation CML is written entirely in SML, using a couple of non-standard extensions provided by SML/NJ: first-class continuations <ref> [DHM91] </ref> and asynchronous signals [Rep90a] . We added one minor primitive operation to the compiler (a ten line change in a 30,000 line compiler), which was necessary to guarantee that sync preserve tail-recursion.
Reference: [Haa90] <author> Haahr, D. </author> <title> Montage: Breaking windows into small pieces. </title> <booktitle> In USENIX Summer Conference, </booktitle> <month> June </month> <year> 1990, </year> <pages> pp. 289-297. </pages>
Reference-contexts: Typically, each window has a separate thread for each input stream as well as a thread, or two, for managing state and coordinating the other threads. By breaking the code up this way, each individual thread is quite simple. This model is similar to those of [Pik89] and <ref> [Haa90] </ref>). This structure allows us to use delegation techniques to define new behavior from existing implementations. Delegation is an object-oriented technique (so we know it must be good), that originated in concurrent actor systems [Lie86] . <p> This means that callcc and throw are constant-time operations. While this is possible using a stack [HDB90] ; heap-based implementations are better suited for implementing light-weight threads (Haahr's experience bears this out <ref> [Haa90] </ref> ). Event values have a natural implementation in terms of first-class continuations. Without the choose operator, an event value could be represented as type 'a event = 'a cont -&gt; 'a with sync being directly implemented by callcc. <p> The one published application of continuation-based concurrency in scheme (which we know of) claims that most scheme implementations do not implement continuations efficiently enough to support this use of concurrency <ref> [Haa90] </ref> (the techniques of [HDB90] may address this problem). Our performance numbers and experience in-the-field suggest that the opposite is true for CML. Using concurrency to implement interactive systems has been proposed and implemented by several people. <p> Our performance numbers and experience in-the-field suggest that the opposite is true for CML. Using concurrency to implement interactive systems has been proposed and implemented by several people. In [RG86] we made the argument that concurrency is vital for the construction of interactive programming environments. [Pik89] and <ref> [Haa90] </ref> describe experimental window systems built out of threads and channels, but neither of these were fast enough for real use. 19 7 Conclusions We have described a higher-order concurrent language, CML, and its use in real-world applications.
Reference: [Har86] <author> Harper, R. </author> <title> Introduction to Standard ML. </title> <type> Technical Report ECS-LFCS-86-14, </type> <institution> Laboratory for Foundations of Computer Science, Computer Science Department, Edinburgh University, </institution> <month> August </month> <year> 1986. </year>
Reference: [HDB90] <author> Hieb, R., R. K. Dybvig, and C. Bruggeman. </author> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In Proceedings of the SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1990, </year> <pages> pp. 66-77. </pages>
Reference-contexts: Unlike other continuation-passing style compilers, such as [Ste78] and [KKR + 86], the code generated by the SML/NJ compiler does not use a run-time stack. This means that callcc and throw are constant-time operations. While this is possible using a stack <ref> [HDB90] </ref> ; heap-based implementations are better suited for implementing light-weight threads (Haahr's experience bears this out [Haa90] ). Event values have a natural implementation in terms of first-class continuations. <p> The one published application of continuation-based concurrency in scheme (which we know of) claims that most scheme implementations do not implement continuations efficiently enough to support this use of concurrency [Haa90] (the techniques of <ref> [HDB90] </ref> may address this problem). Our performance numbers and experience in-the-field suggest that the opposite is true for CML. Using concurrency to implement interactive systems has been proposed and implemented by several people.
Reference: [HFW84] <author> Haynes, C. T., D. P. Friedman, and M. Wand. </author> <title> Continuations and coroutines. </title> <booktitle> In Conference record of the 1984 ACM Conference on Lisp and Functional Programming, </booktitle> <month> July </month> <year> 1984, </year> <pages> pp. 293-298. </pages>
Reference-contexts: A number of papers have been published on the use of first-class continuations to implement concurrency in scheme (e.g., [Wan80], <ref> [HFW84] </ref> and [DH89]), but we break new ground in a couple of ways: we describe the implementation of first-class synchronous operations using first-class continuations; we describe a complete language for concurrent programming and its use; and we provide performance figures.
Reference: [Hol83] <author> Holmstrom, S. </author> <title> PFL: A functional language for parallel programming. </title> <booktitle> In Declarative programming workshop, </booktitle> <month> April </month> <year> 1983, </year> <pages> pp. 114-139. </pages>
Reference: [KKR + 86] <author> Kranz, D., R. Kelsey, J. Rees, P. Hudak, J. Philbin, and N. Adams. </author> <title> Orbit: An optimizing compiler for Scheme. </title> <booktitle> In Proceedings of the SIGPLAN'86 Symposium on Compiler Construction, </booktitle> <month> July </month> <year> 1986, </year> <pages> pp. 219-233. </pages>
Reference-contexts: Threads are implemented a la [Wan80], using first-class continuations, and the SML/NJ asynchronous signal facility is used to implement pre-emptive scheduling. Unlike other continuation-passing style compilers, such as [Ste78] and <ref> [KKR + 86] </ref>, the code generated by the SML/NJ compiler does not use a run-time stack. This means that callcc and throw are constant-time operations. While this is possible using a stack [HDB90] ; heap-based implementations are better suited for implementing light-weight threads (Haahr's experience bears this out [Haa90] ).
Reference: [LCJS87] <author> Liskov, B., D. Curtis, P. Johnson, and R. Scheifler. </author> <title> Implementation of Argus. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Operating System Principles, </booktitle> <month> November </month> <year> 1987, </year> <pages> pp. 111-122. </pages>
Reference: [Lie86] <author> Lieberman, H. </author> <title> Using prototypical objects to implement shared behavior in object oriented systems. </title> <booktitle> In OOPSLA'86 Proceedings, </booktitle> <month> September </month> <year> 1986, </year> <pages> pp. 214-223. </pages>
Reference-contexts: This model is similar to those of [Pik89] and [Haa90]). This structure allows us to use delegation techniques to define new behavior from existing implementations. Delegation is an object-oriented technique (so we know it must be good), that originated in concurrent actor systems <ref> [Lie86] </ref> . As an example, consider the case of adding a menu to an existing text window. We can do this in a general way by defining a wrapper that takes a window's environment and returns a new, wrapped, environment.
Reference: [LS88] <author> Liskov, B. and L. Shrira. </author> <title> Promises: Linguistic support for efficient asynchronous procedure calls in distributed systems. </title> <booktitle> In Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1988, </year> <pages> pp. 260-267. </pages>
Reference-contexts: The low-level I/O support of CML is sufficient to build a structured synchronous interface to network communication (as was done in our X-windows application). Higher-level linguistic support for distributed programming, such as the promise mechanism of <ref> [LS88] </ref>, can be built using events to define the new abstractions. Some of these ideas have been prototyped by Chet Murthy as part of a re-implementation of the Nuprl interactive proof system.
Reference: [Mac84] <author> MacQueen, D. B. </author> <title> Modules for Standard ML. </title> <booktitle> In Conference record of the 1984 ACM Conference on Lisp and Functional Programming, </booktitle> <month> July </month> <year> 1984, </year> <pages> pp. 198-207. 21 </pages>
Reference-contexts: One example is a virtual terminal window (vtty). This provides a synchronous stream interface to its clients, which is compatible with the signature of CML's concurrent I/O library. If the client-code is implemented as a functor <ref> [Mac84] </ref> (parameterized module), then it can be used with either the concurrent I/O library or the vtty abstraction. The vtty abstraction is a good example of where user-defined abstract synchronous operations are necessary for program modularity.
Reference: [Mat89] <author> Matthews, D. C. J. </author> <title> Processes for Poly and ML. In Papers on Poly/ML, </title> <type> Technical Report 161. </type> <institution> University of Cambridge, </institution> <month> February </month> <year> 1989. </year>
Reference-contexts: PML in turn was heavily influenced by amber [Car86] . There have been other attempts at adding concurrency to various versions of ML. Most of these have been 18 based on message passing ([Hol83], <ref> [Mat89] </ref>, and [Ram90] for example), but there is at least one shared memory approach [CM90] . As we have shown in this paper, message passing fits very nicely into SML.
Reference: [MTH90] <author> Milner, R., M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass, </address> <year> 1990. </year>
Reference: [Nye90] <author> Nye, A. </author> <title> Xlib Programming Manual, </title> <journal> vol. </journal> <volume> 1. </volume> <publisher> O'Reilly & Associates, Inc., </publisher> <year> 1990. </year>
Reference-contexts: Since formatting may take a significant amount of time, providing a responsive interface requires interleaving formatting and editing. If the editor and formatter are separate threads, then interleaving comes for free. Output driven applications. Most windowing toolkits, for example Xlib <ref> [Nye90] </ref> , provide an input oriented model, in which the application code is occasionally called in response to some external event. But many applications are output oriented. Consider, for example, a compu-tationally intensive simulation with a graphical display of the current state of the simulation. <p> The root cause of these forms of concurrency is computer-human interaction: humans are asynchronous and slow. CML has been used to build a multi-threaded interface to the X protocol [SG86] , called eXene. This system provides a similar level of function as Xlib <ref> [Nye90] </ref> , but with a substantially different, and we think better, model of user interaction. Windows in eXene have an environment, consisting of three streams of input from the window's parent (mouse, keyboard and control), and one output 12 stream for requesting services from the window's parent.
Reference: [Pau91] <author> Paulson, L. C. </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference: [Pik89] <author> Pike, R. </author> <title> A concurrent window system. </title> <journal> Computing Systems, </journal> <volume> 2(2), </volume> <year> 1989, </year> <pages> pp. 133-153. </pages>
Reference-contexts: Typically, each window has a separate thread for each input stream as well as a thread, or two, for managing state and coordinating the other threads. By breaking the code up this way, each individual thread is quite simple. This model is similar to those of <ref> [Pik89] </ref> and [Haa90]). This structure allows us to use delegation techniques to define new behavior from existing implementations. Delegation is an object-oriented technique (so we know it must be good), that originated in concurrent actor systems [Lie86] . <p> Our performance numbers and experience in-the-field suggest that the opposite is true for CML. Using concurrency to implement interactive systems has been proposed and implemented by several people. In [RG86] we made the argument that concurrency is vital for the construction of interactive programming environments. <ref> [Pik89] </ref> and [Haa90] describe experimental window systems built out of threads and channels, but neither of these were fast enough for real use. 19 7 Conclusions We have described a higher-order concurrent language, CML, and its use in real-world applications.
Reference: [Ram90] <author> Ramsey, N. </author> <title> Concurrent programming in ML. </title> <type> Technical Report CS-TR-262-90, </type> <institution> Department of Computer Science, Princeton University, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: PML in turn was heavily influenced by amber [Car86] . There have been other attempts at adding concurrency to various versions of ML. Most of these have been 18 based on message passing ([Hol83], [Mat89], and <ref> [Ram90] </ref> for example), but there is at least one shared memory approach [CM90] . As we have shown in this paper, message passing fits very nicely into SML.
Reference: [Rep] <author> Reppy, J. H. </author> <title> Two garbage collectors for SML/NJ. </title> <note> Cornell University technical report (in preparation). </note>
Reference-contexts: This hot-spot behavior is the worst-case scenario for SML/NJ's collector, destroying the O (jLIVEj) normally expected from copying collection. The collector also suffers from the problem of poor real-time responsiveness. We have designed a new, multi-generational, collector for SML/NJ <ref> [Rep] </ref> , which uses the page-protection techniques of [Sha87] and [AEL88] to implement the write barrier.
Reference: [Rep88] <author> Reppy, J. H. </author> <title> Synchronous operations as first-class values. </title> <booktitle> In Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1988, </year> <pages> pp. 250-259. </pages>
Reference-contexts: Applying poll to an event value will return NONE in the case that sync would block. 2.4 Extending the mechanism The concurrency mechanism described thus far is essentially that presented in <ref> [Rep88] </ref> and [Rep89]. CML extends this model in several important ways, in this section we motivate and describe these extensions. Consider a protocol consisting of a sequence of client-server communications: c 1 ; c 2 ; ; c n . <p> When this protocol is packaged up in an event value, one of the c i is designated as the commit point; the communication on which this event is chosen in a selective communication. In the mechanism of <ref> [Rep88] </ref>, the only possible commit point is c 1 . The wrap construct allows on to tack on c 2 ; ; c n after c 1 is chosen, but there is no way to make any of the other c i the commit point. <p> Another extension to <ref> [Rep88] </ref> is the function: val wrapHandler : ('a event * (exn -&gt; 'a)) -&gt; 'a event wraps an exception handler around an event 2 . For example, syncOnInput will raise an exception if the file specified by the descriptor fd has been closed. <p> CML began as a reimplementation of the concurrency primitives of PML <ref> [Rep88] </ref> in SML/NJ, but has evolved into a significantly more powerful language. PML in turn was heavily influenced by amber [Car86] . There have been other attempts at adding concurrency to various versions of ML. <p> CML extends the message passing paradigm by making synchronous operations first-class, which provides a mechanism for building user-defined synchronization abstractions. While this idea was first proposed in <ref> [Rep88] </ref>, we have made several significant improvements: * CML improves the event type in several ways. The poll operation provides a cleaner semantics than the PML polling mechanism, and the wrapHandler operation provides needed support for writing wrappers.
Reference: [Rep89] <author> Reppy, J. H. </author> <title> First-class synchronous operations in Standard ML. </title> <type> Technical Report TR 89-1068, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: Applying poll to an event value will return NONE in the case that sync would block. 2.4 Extending the mechanism The concurrency mechanism described thus far is essentially that presented in [Rep88] and <ref> [Rep89] </ref>. CML extends this model in several important ways, in this section we motivate and describe these extensions. Consider a protocol consisting of a sequence of client-server communications: c 1 ; c 2 ; ; c n . <p> Thus, the implementation of an event value is a list of base events, with each base event represented by a polling function, a function to call for immediate synchronization and a function for blocking. The implementation of a precursor to CML is described in detail in <ref> [Rep89] </ref>. The support of poll requires grouping base events that are being polled as a group. Note that poll has the property that the event poll (poll $ev_1$) is equivalent to wrap (poll $ev_1$, SOME) We use this property to collapse nested applications of poll.
Reference: [Rep90a] <author> Reppy, J. H. </author> <title> Asynchronous signals in Standard ML. </title> <type> Technical Report TR 90-1144, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: will farm out pieces of the proof to idle and available servers; it uses an object similar to a promise as a place-holder for the outstanding work. 4 Implementation CML is written entirely in SML, using a couple of non-standard extensions provided by SML/NJ: first-class continuations [DHM91] and asynchronous signals <ref> [Rep90a] </ref> . We added one minor primitive operation to the compiler (a ten line change in a 30,000 line compiler), which was necessary to guarantee that sync preserve tail-recursion. Threads are implemented a la [Wan80], using first-class continuations, and the SML/NJ asynchronous signal facility is used to implement pre-emptive scheduling.
Reference: [Rep90b] <author> Reppy, J. H. </author> <title> Concurrent programming with events The Concurrent ML manual. </title> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, N.Y., </address> <month> November </month> <year> 1990. </year> <note> (Last revised October 1991). </note>
Reference-contexts: The underlying window toolkit (eXene) provides an abstract interface to the input stream, but, since it is event-valued, it can be used in the selective communication. Another example of the use of new communication abstractions is a buffered multicast channel (a simple version is described in <ref> [Rep90b] </ref>). This abstraction has proven quite useful in supporting multiple views of an object. When the viewed object is updated, the thread managing its state sends a notification on the multicast channel.
Reference: [Rep92] <author> Reppy, J. H. </author> <title> Higher-order concurrency. </title> <type> Ph.D. dissertation, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, NY, </address> <month> January </month> <year> 1992. </year> <note> Available as Technical Report TR 92-1285. </note>
Reference: [RG86] <author> Reppy, J. H. and E. R. Gansner. </author> <title> A foundation for programming environments. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <month> December </month> <year> 1986, </year> <pages> pp. 218-227. </pages>
Reference-contexts: In this section we describe two applications of CML, and how they use the features of CML. 3.1 Interactive systems Providing a better foundation for programming interactive systems, such as programming environments, was the original motivation for this line of research <ref> [RG86] </ref> . Because of their naturally concurrent structure, interactive systems are one of the most important application areas for CML. Concurrency arises in several ways in interactive systems: User interaction. Handling user input is the most complex aspect of an interactive program. <p> Our performance numbers and experience in-the-field suggest that the opposite is true for CML. Using concurrency to implement interactive systems has been proposed and implemented by several people. In <ref> [RG86] </ref> we made the argument that concurrency is vital for the construction of interactive programming environments. [Pik89] and [Haa90] describe experimental window systems built out of threads and channels, but neither of these were fast enough for real use. 19 7 Conclusions We have described a higher-order concurrent language, CML, and
Reference: [SG86] <author> Scheifler, R. W. and J. Gettys. </author> <title> The X window system. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 5(2), </volume> <month> April </month> <year> 1986, </year> <pages> pp. 79-109. </pages>
Reference-contexts: By separating the display code and simulation code into separate threads, the handling of asynchronous redrawing is easy. The root cause of these forms of concurrency is computer-human interaction: humans are asynchronous and slow. CML has been used to build a multi-threaded interface to the X protocol <ref> [SG86] </ref> , called eXene. This system provides a similar level of function as Xlib [Nye90] , but with a substantially different, and we think better, model of user interaction.
Reference: [Sha87] <author> Shaw, R. A. </author> <title> Improving garbage collection performance in virtual memory. </title> <type> Technical Report CSL-TR-87-323, </type> <institution> Computer Systems Laboratory, Stanford University, </institution> <year> 1987. </year>
Reference-contexts: This hot-spot behavior is the worst-case scenario for SML/NJ's collector, destroying the O (jLIVEj) normally expected from copying collection. The collector also suffers from the problem of poor real-time responsiveness. We have designed a new, multi-generational, collector for SML/NJ [Rep] , which uses the page-protection techniques of <ref> [Sha87] </ref> and [AEL88] to implement the write barrier. This new collector improves the performance of CML in two ways: the hot-spot update behavior only incurs a constant cost for garbage collection and eliminating the store-list reduces the frequency of garbage collection and the cost of update operations.
Reference: [Ste78] <author> Steele Jr., G. L. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Master's dissertation, </type> <institution> MIT, </institution> <month> May </month> <year> 1978. </year>
Reference-contexts: Threads are implemented a la [Wan80], using first-class continuations, and the SML/NJ asynchronous signal facility is used to implement pre-emptive scheduling. Unlike other continuation-passing style compilers, such as <ref> [Ste78] </ref> and [KKR + 86], the code generated by the SML/NJ compiler does not use a run-time stack. This means that callcc and throw are constant-time operations.
Reference: [Wan80] <author> Wand, M. </author> <title> Continuation-based multiprocessing. </title> <booktitle> In Conference Record of the 1980 Lisp Conference, </booktitle> <month> August </month> <year> 1980, </year> <pages> pp. 19-28. </pages>
Reference-contexts: We added one minor primitive operation to the compiler (a ten line change in a 30,000 line compiler), which was necessary to guarantee that sync preserve tail-recursion. Threads are implemented a la <ref> [Wan80] </ref>, using first-class continuations, and the SML/NJ asynchronous signal facility is used to implement pre-emptive scheduling. Unlike other continuation-passing style compilers, such as [Ste78] and [KKR + 86], the code generated by the SML/NJ compiler does not use a run-time stack. This means that callcc and throw are constant-time operations. <p> Our implementation techniques are not particularly novel. The use of timers to implement preemption is an old technique used by most threads packages, and the use of first-class continuations to implement concurrency goes back, at least, to <ref> [Wan80] </ref>. A number of papers have been published on the use of first-class continuations to implement concurrency in scheme (e.g., [Wan80], [HFW84] and [DH89]), but we break new ground in a couple of ways: we describe the implementation of first-class synchronous operations using first-class continuations; we describe a complete language for <p> The use of timers to implement preemption is an old technique used by most threads packages, and the use of first-class continuations to implement concurrency goes back, at least, to <ref> [Wan80] </ref>. A number of papers have been published on the use of first-class continuations to implement concurrency in scheme (e.g., [Wan80], [HFW84] and [DH89]), but we break new ground in a couple of ways: we describe the implementation of first-class synchronous operations using first-class continuations; we describe a complete language for concurrent programming and its use; and we provide performance figures.
References-found: 43

