URL: ftp://ftp.di.unipi.it/pub/Papers/comini/EffDetIncErr/EffDetIncErr95.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: giuvit@udsab.dia.unisa.it  
Title: Efficient Detection of Incompleteness Errors in the  
Author: Giuliana Vitiello 
Address: Baronissi (Salerno), Italy  
Affiliation: Dipartimento di Informatica ed Applicazioni, Universita di Salerno,  
Abstract: Debugging of Logic Programs Abstract Abstract debugging of logic programs is an extension of declarative debugging, where we deal with specifications of operational properties, which can be characterized as abstractions of SLD-trees (observables). We introduce a simple and efficient method to detect incompleteness errors, which is based on the application of the immediate consequences operator to the specification. The method is proved to be correct and complete whenever the immediate consequences operator has a unique fixpoint. We then prove that this property is always satisfied if the program belongs to a large class of programs (acceptable programs). We finally show that the same property can be proved for any program P , if the observable belongs to a suitable class of observables.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </booktitle> <pages> pages 495-574. </pages> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: We show that several interesting observables belong to this class. 2 Observables We consider pure logic programs with the PROLOG (leftmost) selection rule. We assume the reader to be familiar with the notions of SLD-resolution and SLD-tree (see <ref> [20, 1] </ref>). We represent, for notational convenience, SLD-trees as sets of nodes. Let T be an SLD-tree rooted at the goal G. <p> P is acceptable w.r.t. j j and I, if for every clause a : b 1 ; : : : b n in Ground (P ) the following implication holds for i 2 <ref> [1; n] </ref>: I j= ^ i1 One relevant technical property of acceptable programs is that the ground immediate consequences operator has a unique fixpoint [2].
Reference: [2] <author> K. R. Apt and D. Pedreschi. </author> <title> Reasoning about termination of pure PROLOG programs. </title> <journal> Information and Computation, </journal> <volume> 106(1) </volume> <pages> 109-157, </pages> <year> 1993. </year>
Reference-contexts: The main result is that this method is correct and complete, if T P;ff has a unique fixpoint. In Section 4 we show that this is the case for a large class of programs (acceptable programs). Acceptable programs were defined in <ref> [2] </ref> to study termination and all the pure PROLOG programs in [22] are reported to be acceptable. The same property is then shown (Section 5) to hold for all programs and for any observable ff belonging to a suitable class of s-observables. <p> In such a case, as already mentioned, I ff can be specified in an extensional way and there is no need for the oracle. 8 4 Abstract debugging of acceptable programs We consider here the abstract debugging of programs belonging to the class of acceptable programs <ref> [2] </ref>, whose definition is given below. It is worth noting that acceptable programs are the left-terminating programs, i.e., those programs for which the SLD-derivations of ground goals (via the leftmost selection rule) are finite. <p> As already mentioned, most interesting programs are acceptable (all the pure PROLOG programs in [22] are acceptable). The same property holds for most of the "wrong" versions of acceptable programs, since most "natural" errors do not affect the left-termination property. Definition 4.1 <ref> [2] </ref> A level mapping for a program P is a function j j : B P ! N from ground atoms to natural numbers. Let j j be a level mapping for P and I be a (not necessarily Herbrand) model of P . <p> I, if for every clause a : b 1 ; : : : b n in Ground (P ) the following implication holds for i 2 [1; n]: I j= ^ i1 One relevant technical property of acceptable programs is that the ground immediate consequences operator has a unique fixpoint <ref> [2] </ref>. We have proved the following theorem, which tells us that the same property holds for all the operators T P;ff , such that ff is an s-observable (SLD-trees, call patterns, answers with depth, l-answers with depth, correct and computed answers, success set, etc.).
Reference: [3] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. Martelli. </author> <title> The s-semantics approach: </title> <journal> Theory and applications. Journal of Logic Programming, </journal> <volume> 19-20:149-197, </volume> <year> 1994. </year>
Reference-contexts: 1 Introduction Abstract debugging [8] is a combination of three known techniques, i.e., algorithmic (declarative) debugging [21, 15, 19, 12], the s-semantics approach to the definition of program denotations modeling various observable behaviors <ref> [13, 14, 16, 4, 3] </ref>, and abstract interpretation [9, 10, 11]. The debugging problem can formally be defined as follows. <p> j hG; #; fl; cli 2 , n is the length of cl, n l g: * (call patterns) () = f hG; ai j hG; #; (a; ~ b); cli 2 g: s-observables are observables for which we can define a denotation which generalizes the properties of the s-semantics <ref> [3] </ref>. The program denotation is defined by collecting the behaviors for most general atomic goals, i.e., goals of the form p ( ~ X) consisting of the application of a predicate symbol to a tuple of distinct variables. This property holds for our basic observable, i.e., SLD-trees.
Reference: [4] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> A Compositional Semantics for Logic Programs. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 122(1-2):3-47, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction Abstract debugging [8] is a combination of three known techniques, i.e., algorithmic (declarative) debugging [21, 15, 19, 12], the s-semantics approach to the definition of program denotations modeling various observable behaviors <ref> [13, 14, 16, 4, 3] </ref>, and abstract interpretation [9, 10, 11]. The debugging problem can formally be defined as follows.
Reference: [5] <author> F. Bourdoncle. </author> <title> Abstract debugging of higher-order imperative languages. </title> <booktitle> In Programming Languages Design and Implementation '93, </booktitle> <pages> pages 46-55, </pages> <year> 1993. </year>
Reference-contexts: This approach is feasible even in abstract debugging. However, since our method can handle abstractions, we can easily come out with finite observable behaviors and specify them in an extensional way. The idea of combining abstract interpretation and debugging was first proposed in <ref> [5] </ref>, where abstract interpretation techniques are used to statically determine the origin of bugs in higher-order imperative languages. The result is a set of correctness conditions expressed in terms of assertions.
Reference: [6] <author> K. L. Clark. </author> <title> Predicate logic as a computational formalism. Res. </title> <type> Report DOC 79/59, </type> <institution> Imperial College, Dept. of Computing, </institution> <address> London, </address> <year> 1979. </year>
Reference-contexts: In particular, * T P; is the ground operator defined in [23] (and O (P ) is the least Herbrand model). * T P; is the non-ground operator first defined in <ref> [6] </ref> (and O (P ) is the least term model). * T P;~ is the s-semantics operator defined in [13]. * T P; is the call patterns operator defined in [16].
Reference: [7] <author> M. Comini and G. Levi. </author> <title> An algebraic theory of observables. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proceedings of the 1994 Int'l Symposium, Logic Programming, </booktitle> <pages> pages 172-186, </pages> <address> Cambridge, Mass., 1994. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: The result is a set of correctness conditions expressed in terms of assertions. Our theory of abstract debugging is built on an algebraic semantic framework for positive logic programs <ref> [7] </ref>, based on the formalization of observ-ables as abstractions. A complete description of the framework is outside the scope of this paper. In Section 2 we summarize the main properties of the framework. <p> The SLD-trees denotation O (P ) of a program P is the set of all the nodes of SLD-trees of most general atomic goals. SLD-trees have the following properties, first proved in [16, 17] and later formalized in algebraic terms <ref> [7] </ref>: * AND -compositionality, i.e., the SLD-tree of any (conjunctive) goal can be determined from O (P ). * Correctness and full abstraction of the denotation O (P ), i.e., [[P 1 ]] = [[P 2 ]] () O (P 1 ) = O (P 2 ): * Equivalent bottom-up construction <p> O ff (P ) and T P;ff are meaningful only for observables which satisfy suitable conditions formally stated in <ref> [7] </ref>. Informally, an s-observable is an abstraction ff of SLD-trees, for which we have a lifting (to more general goals) property and which is AND-compositional. <p> The converse does not hold. Proof. 1. If T P;ff (I ff ) I ff , then I ff is a pre-fixpoint of T P;ff . Since O ff (P ) = lfp T P;ff <ref> [7] </ref>, by Tarski's theorem O ff (P ) I ff . If T P;ff (I ff ) 6 I ff , then for some element , 2 T P;ff (I ff ) and 62 I ff . <p> The converse does not hold. Proof. 1. If I ff T P;ff (I ff ), then I ff is a post-fixpoint of T P;ff . By Tarski's theorem, I ff gfp T P;ff . Since O ff (P ) = lfp T P;ff <ref> [7] </ref> and gfp T P;ff = lfp T P;ff , the thesis holds. 2. Consider the program P = f p : r:; r: g and the specification I ~ = f hp; "i g. <p> Another interesting extension, related to the overall PROLOG computation rule (including the depth-first search based on the clause ordering), can be based on a PROLOG version of the semantic framework in <ref> [7] </ref>, which was recently defined in [18].
Reference: [8] <author> M. Comini, G. Levi, and G. Vitiello. </author> <title> Abstract debugging of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. Logic Program Synthesis and Transformation and Metaprogramming in Logic 1994, volume 883 of Lecture Notes in Computer Science, </booktitle> <pages> pages 440-450, </pages> <address> Berlin, 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: 1 Introduction Abstract debugging <ref> [8] </ref> is a combination of three known techniques, i.e., algorithmic (declarative) debugging [21, 15, 19, 12], the s-semantics approach to the definition of program denotations modeling various observable behaviors [13, 14, 16, 4, 3], and abstract interpretation [9, 10, 11]. The debugging problem can formally be defined as follows. <p> We will consider here an important class of observables 2 (s-observables ) with strong semantic properties for which we can consider the behaviors for most general atomic goals only. The debugging problem and the diagnosis algorithms for s-observables introduced in <ref> [8] </ref> are considered in Section 3. We show that the existing declarative debugging methods can be reconstructed as instances of abstract debugging w.r.t. s-observables. As in the case of declarative debugging, incorrect clauses can be detected by applying an immediate consequences operator to the specification. <p> (X; Y ); f X=terach; Y =isaac g; 6i; hancestor (X; Y ); f X=abraham; Y =isaac g; 2i g: The diagnosis now detects the incorrect clause c 2 in addition to the uncovered element hancestor (X; Y ); f X=terach; Y =isaac g; 4i. 6 Conclusions As shown in <ref> [8] </ref>, it is possible to debug a program w.r.t. observables which are useful for program analysis (i-observables).
Reference: [9] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Proc. Fourth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction Abstract debugging [8] is a combination of three known techniques, i.e., algorithmic (declarative) debugging [21, 15, 19, 12], the s-semantics approach to the definition of program denotations modeling various observable behaviors [13, 14, 16, 4, 3], and abstract interpretation <ref> [9, 10, 11] </ref>. The debugging problem can formally be defined as follows. Let P be a program, [[P ]] ff be the behavior of P w.r.t. the observable property ff, and I ff be the specification of the intended behavior of P w.r.t. ff.
Reference: [10] <author> P. Cousot and R. Cousot. </author> <title> Systematic Design of Program Analysis Frameworks. </title> <booktitle> In Proc. Sixth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 269-282, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction Abstract debugging [8] is a combination of three known techniques, i.e., algorithmic (declarative) debugging [21, 15, 19, 12], the s-semantics approach to the definition of program denotations modeling various observable behaviors [13, 14, 16, 4, 3], and abstract interpretation <ref> [9, 10, 11] </ref>. The debugging problem can formally be defined as follows. Let P be a program, [[P ]] ff be the behavior of P w.r.t. the observable property ff, and I ff be the specification of the intended behavior of P w.r.t. ff.
Reference: [11] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation and Applications to Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2 </volume> & 3):103-179, 1992. 
Reference-contexts: 1 Introduction Abstract debugging [8] is a combination of three known techniques, i.e., algorithmic (declarative) debugging [21, 15, 19, 12], the s-semantics approach to the definition of program denotations modeling various observable behaviors [13, 14, 16, 4, 3], and abstract interpretation <ref> [9, 10, 11] </ref>. The debugging problem can formally be defined as follows. Let P be a program, [[P ]] ff be the behavior of P w.r.t. the observable property ff, and I ff be the specification of the intended behavior of P w.r.t. ff.
Reference: [12] <author> M. Ducasse and J. </author> <title> Noye. Logic programming environments: Dynamic program analysis and debugging. </title> <journal> Journal of Logic Programming, </journal> <volume> 19-20:351-384, </volume> <year> 1994. </year>
Reference-contexts: 1 Introduction Abstract debugging [8] is a combination of three known techniques, i.e., algorithmic (declarative) debugging <ref> [21, 15, 19, 12] </ref>, the s-semantics approach to the definition of program denotations modeling various observable behaviors [13, 14, 16, 4, 3], and abstract interpretation [9, 10, 11]. The debugging problem can formally be defined as follows.
Reference: [13] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Abstract debugging [8] is a combination of three known techniques, i.e., algorithmic (declarative) debugging [21, 15, 19, 12], the s-semantics approach to the definition of program denotations modeling various observable behaviors <ref> [13, 14, 16, 4, 3] </ref>, and abstract interpretation [9, 10, 11]. The debugging problem can formally be defined as follows. <p> In particular, * T P; is the ground operator defined in [23] (and O (P ) is the least Herbrand model). * T P; is the non-ground operator first defined in [6] (and O (P ) is the least term model). * T P;~ is the s-semantics operator defined in <ref> [13] </ref>. * T P; is the call patterns operator defined in [16].
Reference: [14] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A Model-Theoretic Reconstruction of the Operational Semantics of Logic Programs. </title> <journal> Information and Computation, </journal> <volume> 102(1) </volume> <pages> 86-113, </pages> <year> 1993. </year> <month> 14 </month>
Reference-contexts: 1 Introduction Abstract debugging [8] is a combination of three known techniques, i.e., algorithmic (declarative) debugging [21, 15, 19, 12], the s-semantics approach to the definition of program denotations modeling various observable behaviors <ref> [13, 14, 16, 4, 3] </ref>, and abstract interpretation [9, 10, 11]. The debugging problem can formally be defined as follows.
Reference: [15] <author> G. Ferrand. </author> <title> Error Diagnosis in Logic Programming, an Adaptation of E. Y. Shapiro's Method. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 177-198, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Abstract debugging [8] is a combination of three known techniques, i.e., algorithmic (declarative) debugging <ref> [21, 15, 19, 12] </ref>, the s-semantics approach to the definition of program denotations modeling various observable behaviors [13, 14, 16, 4, 3], and abstract interpretation [9, 10, 11]. The debugging problem can formally be defined as follows. <p> The specification is therefore the intended declarative semantics of the program, which is the least Herbrand model in [21, 19], and the set of atomic logical consequences in <ref> [15] </ref>. Abstract debugging is a generalization of declarative debugging, where we consider operational properties. An observable is any property which can be extracted from a goal computation, i.e., observables are abstractions of SLD-trees. <p> If ff is an s-observable, we know that the actual and the intended behaviors of P for all the goals are uniquely determined by the behaviors for most general goals. The following Definitions 3.1, 3.2 and 3.3 extend to abstract debugging the definitions given in <ref> [21, 15, 19] </ref> for declarative debugging. In the following I ff is the specification of the intended behavior of program P for most general atomic goals w.r.t. the s-observable ff. Definition 3.1 1. P is partially correct w.r.t. I ff , if O ff (P ) I ff . 2. <p> Definition 3.3 1. An incorrectness symptom is an element such that 2 O ff (P ) and 62 I ff . 2. An incompleteness symptom is an element such that 2 I ff and 62 O ff (P ). Note that our incompleteness symptoms were not considered in <ref> [21, 15, 19] </ref>. Note also that a totally correct program has no incorrectness and no incompleteness symptoms. <p> In particular, * the observable (success set) gives us the declarative debugging based on the least Herbrand model [21, 19]; 6 * the observable (correct answer substitutions) gives us the declarative debugging based on the atomic logical consequences <ref> [15] </ref>. It is straightforward to realize that an element may sometimes be an (incorrectness or incompleteness) symptom, just because of another symptom. The diagnosis determines the "basic" symptoms, and, in the case of incorrectness, the relevant clause in the program.
Reference: [16] <author> M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Observational Equivalences for Logic Programs. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proc. Joint Int'l Conf. and Symposium on Logic Programming, </booktitle> <pages> pages 131-145, </pages> <address> Cambridge, Mass., </address> <year> 1992. </year> <note> The MIT Press. Extended version to appear in Information and Computation. </note>
Reference-contexts: 1 Introduction Abstract debugging [8] is a combination of three known techniques, i.e., algorithmic (declarative) debugging [21, 15, 19, 12], the s-semantics approach to the definition of program denotations modeling various observable behaviors <ref> [13, 14, 16, 4, 3] </ref>, and abstract interpretation [9, 10, 11]. The debugging problem can formally be defined as follows. <p> We will discuss the properties in the case of SLD-trees first and then move to the abstractions. The SLD-trees denotation O (P ) of a program P is the set of all the nodes of SLD-trees of most general atomic goals. SLD-trees have the following properties, first proved in <ref> [16, 17] </ref> and later formalized in algebraic terms [7]: * AND -compositionality, i.e., the SLD-tree of any (conjunctive) goal can be determined from O (P ). * Correctness and full abstraction of the denotation O (P ), i.e., [[P 1 ]] = [[P 2 ]] () O (P 1 ) = <p> [23] (and O (P ) is the least Herbrand model). * T P; is the non-ground operator first defined in [6] (and O (P ) is the least term model). * T P;~ is the s-semantics operator defined in [13]. * T P; is the call patterns operator defined in <ref> [16] </ref>.
Reference: [17] <author> M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> A resultants semantics for PROLOG. </title> <type> Technical report, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1994. </year>
Reference-contexts: We will discuss the properties in the case of SLD-trees first and then move to the abstractions. The SLD-trees denotation O (P ) of a program P is the set of all the nodes of SLD-trees of most general atomic goals. SLD-trees have the following properties, first proved in <ref> [16, 17] </ref> and later formalized in algebraic terms [7]: * AND -compositionality, i.e., the SLD-tree of any (conjunctive) goal can be determined from O (P ). * Correctness and full abstraction of the denotation O (P ), i.e., [[P 1 ]] = [[P 2 ]] () O (P 1 ) =
Reference: [18] <author> G. Levi and D. Micciancio. </author> <title> Modelling PROLOG control in constraint logic languages. </title> <note> Submitted for publication. </note>
Reference-contexts: Another interesting extension, related to the overall PROLOG computation rule (including the depth-first search based on the clause ordering), can be based on a PROLOG version of the semantic framework in [7], which was recently defined in <ref> [18] </ref>.
Reference: [19] <author> J. W. Lloyd. </author> <title> Declarative error diagnosis. </title> <journal> New Generation Computing, </journal> <volume> 5(2) </volume> <pages> 133-154, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Abstract debugging [8] is a combination of three known techniques, i.e., algorithmic (declarative) debugging <ref> [21, 15, 19, 12] </ref>, the s-semantics approach to the definition of program denotations modeling various observable behaviors [13, 14, 16, 4, 3], and abstract interpretation [9, 10, 11]. The debugging problem can formally be defined as follows. <p> The specification is therefore the intended declarative semantics of the program, which is the least Herbrand model in <ref> [21, 19] </ref>, and the set of atomic logical consequences in [15]. Abstract debugging is a generalization of declarative debugging, where we consider operational properties. An observable is any property which can be extracted from a goal computation, i.e., observables are abstractions of SLD-trees. <p> If ff is an s-observable, we know that the actual and the intended behaviors of P for all the goals are uniquely determined by the behaviors for most general goals. The following Definitions 3.1, 3.2 and 3.3 extend to abstract debugging the definitions given in <ref> [21, 15, 19] </ref> for declarative debugging. In the following I ff is the specification of the intended behavior of program P for most general atomic goals w.r.t. the s-observable ff. Definition 3.1 1. P is partially correct w.r.t. I ff , if O ff (P ) I ff . 2. <p> Definition 3.3 1. An incorrectness symptom is an element such that 2 O ff (P ) and 62 I ff . 2. An incompleteness symptom is an element such that 2 I ff and 62 O ff (P ). Note that our incompleteness symptoms were not considered in <ref> [21, 15, 19] </ref>. Note also that a totally correct program has no incorrectness and no incompleteness symptoms. <p> In particular, * the observable (success set) gives us the declarative debugging based on the least Herbrand model <ref> [21, 19] </ref>; 6 * the observable (correct answer substitutions) gives us the declarative debugging based on the atomic logical consequences [15]. It is straightforward to realize that an element may sometimes be an (incorrectness or incompleteness) symptom, just because of another symptom.
Reference: [20] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: We show that several interesting observables belong to this class. 2 Observables We consider pure logic programs with the PROLOG (leftmost) selection rule. We assume the reader to be familiar with the notions of SLD-resolution and SLD-tree (see <ref> [20, 1] </ref>). We represent, for notational convenience, SLD-trees as sets of nodes. Let T be an SLD-tree rooted at the goal G.
Reference: [21] <author> E. Y. Shapiro. </author> <title> Algorithmic program debugging. </title> <booktitle> In Proc. Ninth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 412-531. </pages> <publisher> ACM Press, </publisher> <year> 1982. </year>
Reference-contexts: 1 Introduction Abstract debugging [8] is a combination of three known techniques, i.e., algorithmic (declarative) debugging <ref> [21, 15, 19, 12] </ref>, the s-semantics approach to the definition of program denotations modeling various observable behaviors [13, 14, 16, 4, 3], and abstract interpretation [9, 10, 11]. The debugging problem can formally be defined as follows. <p> The specification is therefore the intended declarative semantics of the program, which is the least Herbrand model in <ref> [21, 19] </ref>, and the set of atomic logical consequences in [15]. Abstract debugging is a generalization of declarative debugging, where we consider operational properties. An observable is any property which can be extracted from a goal computation, i.e., observables are abstractions of SLD-trees. <p> If ff is an s-observable, we know that the actual and the intended behaviors of P for all the goals are uniquely determined by the behaviors for most general goals. The following Definitions 3.1, 3.2 and 3.3 extend to abstract debugging the definitions given in <ref> [21, 15, 19] </ref> for declarative debugging. In the following I ff is the specification of the intended behavior of program P for most general atomic goals w.r.t. the s-observable ff. Definition 3.1 1. P is partially correct w.r.t. I ff , if O ff (P ) I ff . 2. <p> Definition 3.3 1. An incorrectness symptom is an element such that 2 O ff (P ) and 62 I ff . 2. An incompleteness symptom is an element such that 2 I ff and 62 O ff (P ). Note that our incompleteness symptoms were not considered in <ref> [21, 15, 19] </ref>. Note also that a totally correct program has no incorrectness and no incompleteness symptoms. <p> In particular, * the observable (success set) gives us the declarative debugging based on the least Herbrand model <ref> [21, 19] </ref>; 6 * the observable (correct answer substitutions) gives us the declarative debugging based on the atomic logical consequences [15]. It is straightforward to realize that an element may sometimes be an (incorrectness or incompleteness) symptom, just because of another symptom.
Reference: [22] <author> L. Sterling and E. Y. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: In Section 4 we show that this is the case for a large class of programs (acceptable programs). Acceptable programs were defined in [2] to study termination and all the pure PROLOG programs in <ref> [22] </ref> are reported to be acceptable. The same property is then shown (Section 5) to hold for all programs and for any observable ff belonging to a suitable class of s-observables. <p> It is worth noting that acceptable programs are the left-terminating programs, i.e., those programs for which the SLD-derivations of ground goals (via the leftmost selection rule) are finite. As already mentioned, most interesting programs are acceptable (all the pure PROLOG programs in <ref> [22] </ref> are acceptable). The same property holds for most of the "wrong" versions of acceptable programs, since most "natural" errors do not affect the left-termination property.
Reference: [23] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year> <month> 15 </month>
Reference-contexts: Some of the specialized bottom-up operators T P;ff = ff ffi T P ffi fl are existing "immediate consequences operators". In particular, * T P; is the ground operator defined in <ref> [23] </ref> (and O (P ) is the least Herbrand model). * T P; is the non-ground operator first defined in [6] (and O (P ) is the least term model). * T P;~ is the s-semantics operator defined in [13]. * T P; is the call patterns operator defined in [16].
References-found: 23

