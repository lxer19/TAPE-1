URL: http://www.cs.utexas.edu/users/moore/publications/km97a.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/moore/publications/index.html
Root-URL: 
Title: A Precise Description of the ACL2 Logic  
Author: Matt Kaufmann and J Strother Moore 
Date: April 22, 1998  
Address: Taylor Hall 2.124  Austin, TX 78712-1188 USA  
Affiliation: Department of Computer Sciences  University of Texas at Austin  
Abstract: The ACL2 logic is a first-order, essentially quantifier-free logic of total recursive functions providing mathematical induction and several extension principles, including symbol package definition and recursive function definition. In this document we describe the logic more precisely. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. S. Boyer and J S. Moore, </author> <title> A Computational Logic Handbook, </title> <publisher> Academic Press: </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Although we do not assume familiarity with Common Lisp, readers familiar with it will notice that we have adopted much of its syntax and many of its built-in constants and functions. 1.2 Connection with the Nqthm Logic The logic described here is closely connected to the Nqthm ("Boyer-Moore") logic <ref> [1] </ref>. The Nqthm logic models a "home-grown" Pure Lisp, while ACL2 models Common Lisp. Some of the differences between the two are summarized below. * Nqthm's arithmetic was essentially just that for the natural numbers, ax-iomatized in a Peano-like fashion. <p> Using the nonnegative integers and lists we can represent the ordinals up to * 0 . (For readers familiar with ordinals: * 0 is the first infinite ordinal that is closed under ordinal exponentiation.) The ACL2 notion of ordinal is the same as that found in <ref> [1] </ref> and both are very similar to the development given in [2]. The following notes are only intended to provide some intuition about ordinals. We ultimately axiomatize two functions below, E0-ORDINALP and E0-ORD-&lt;, which formalize the concepts.
Reference: [2] <author> G. </author> <title> Gentzen, "New Version of the Consistency Proof for Elementary Number Theory" in M. </title> <editor> E. Szabo, ed., </editor> <booktitle> The Collected Papers of Gerhard Gentzen, </booktitle> <publisher> North-Holland Publishing Company: </publisher> <address> Amsterdam, </address> <year> 1969, </year> <pages> pp. 132-213. </pages>
Reference-contexts: can represent the ordinals up to * 0 . (For readers familiar with ordinals: * 0 is the first infinite ordinal that is closed under ordinal exponentiation.) The ACL2 notion of ordinal is the same as that found in [1] and both are very similar to the development given in <ref> [2] </ref>. The following notes are only intended to provide some intuition about ordinals. We ultimately axiomatize two functions below, E0-ORDINALP and E0-ORD-&lt;, which formalize the concepts.
Reference: [3] <author> M. Kaufmann and J S. Moore, </author> <title> "Design Goals of ACL2," </title> <type> Technical Report 101, </type> <institution> Computational Logic, Inc., </institution> <address> 1717 West Sixth Street, Suite 290, Austin, TX 78703, </address> <year> 1994. </year>
Reference-contexts: ACL2 | the logic and its implementation in a theorem-proving system | is best thought of as a successor to Nqthm intended to make the logic more efficiently executable and able to support the construction and analysis of larger system models. The paper <ref> [3] </ref> discusses the original design of ACL2. Bob Boyer was an active participant in the formative years of the design of ACL2.
Reference: [4] <author> M. Kaufmann and J S. Moore. ACL2: </author> <title> An Industrial Strength Version of Nqthm. </title> <booktitle> In Proceedings of the Eleventh Annual Conference on Computer Assurance (COMPASS-96), </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> June, </month> <year> 1996, </year> <pages> pp. 23-34. </pages>
Reference-contexts: Common Lisp functions are partial: they are not defined on all possible inputs. But ACL2 functions are total: they are defined on all possible inputs. In what sense, then, is ACL2 Common Lisp? In <ref> [4] </ref> we define the notions of gold functions and theorems. To establish that a function or theorem is gold, certain additional conjectures must be proved. These "guard conjectures" are derived syntactically from the candidate function definitions and theorems.
Reference: [5] <author> J. R. Shoenfield, </author> <title> Mathematical Logic, </title> <publisher> Addison-Wesley: </publisher> <address> Reading, MA, </address> <year> 1967. </year>
Reference-contexts: Our logic is built on top of traditional propositional calculus with equality. Any classical formalization of propositional calculus and equality will suit our purposes. So that this document is self-contained we have included one such formalization, namely that of Shoenfield <ref> [5] </ref>. Shoenfield formalizes propositional calculus with one axiom schema and four rules of inference. He introduces equality with three axiom schemas. We then add the rule of instantiation in place of the parts of [5] that refer to quantification, since our logic is quantifier-free. Terminology. <p> So that this document is self-contained we have included one such formalization, namely that of Shoenfield <ref> [5] </ref>. Shoenfield formalizes propositional calculus with one axiom schema and four rules of inference. He introduces equality with three axiom schemas. We then add the rule of instantiation in place of the parts of [5] that refer to quantification, since our logic is quantifier-free. Terminology. The pseudo-symbols are =, 6=, :, _, ^, ! and $. Note.
Reference: [6] <author> G. L. Steele, Jr. </author> <title> Common LISP: The Language, </title> <publisher> Digital Press, </publisher> <address> 30 North Avenue, Burlington, MA 01803, </address> <year> 1984. </year>
Reference-contexts: To achieve this we decided to make ACL2 an extension of a useful subset of the widely used and efficiently implemented 2 applicative programming language Common Lisp <ref> [6] </ref> and [7]. Executability comes at a cost: ACL2 does not support unbounded quantification, the real numbers, or infinite sets. ACL2 is essentially just an applicative programming language | and a fairly simple one at that. Common Lisp functions are partial: they are not defined on all possible inputs.
Reference: [7] <author> G. L. Steele, Jr. </author> <title> Common Lisp The Language, Second Edition. </title> <publisher> Digital Press, </publisher> <address> 30 North Avenue, Burlington, MA 01803, </address> <year> 1990. </year>
Reference-contexts: To achieve this we decided to make ACL2 an extension of a useful subset of the widely used and efficiently implemented 2 applicative programming language Common Lisp [6] and <ref> [7] </ref>. Executability comes at a cost: ACL2 does not support unbounded quantification, the real numbers, or infinite sets. ACL2 is essentially just an applicative programming language | and a fairly simple one at that. Common Lisp functions are partial: they are not defined on all possible inputs. <p> More precisely, =)is the transitive closure of the relation given below. Although =)is a function, it is not one-to-one; for example, we'll see that both 2 and '2 abbreviate the same term, namely (BINARY-+ '1 '1). Note. ACL2 provides a "macro" facility (derived from the one in Common Lisp <ref> [7] </ref>) whereby the user can add abbreviations. In our implementation of ACL2 we add most of the abbreviations below as macros that expand as shown here. Abbreviation. <p> These abbreviation conventions are compatible with those of Common Lisp <ref> [7] </ref>. Some newcomers to Lisp mistake ''2 as just another way to write 2, arguing "you can drop the quote marks before numbers." This reasoning is incorrect. <p> The Common Lisp definition <ref> [7] </ref> does not specify that these functions are Boolean. Instead, it says that they are "predicates." Then we learn (cf. [7], page 95), "One may think of a predicate as producing a Boolean value, where nil stands for false and anything else stands for true." And finally, "If no better non-nil <p> The Common Lisp definition <ref> [7] </ref> does not specify that these functions are Boolean. Instead, it says that they are "predicates." Then we learn (cf. [7], page 95), "One may think of a predicate as producing a Boolean value, where nil stands for false and anything else stands for true." And finally, "If no better non-nil value is available for the purpose of indicating success, by convention the symbol t is used as the `standard' true
Reference: [8] <author> M. Kaufmann and J Strother Moore, </author> <title> "Structured Theory Development for a Mechanized Logic," </title> <note> (in preparation, eventually to be found at URL http://www.cs.utexas.edu/users/moore/acl2/reports/- km98.ps). </note>
Reference-contexts: Note. A derived extension principle, called "encapsulation," permits the introduction of undefined but constrained function symbols. We describe encapsulation and its uses in <ref> [8] </ref>. ACL2 provides for "Skolem axioms" but these have not yet been documented. The implemented definitional principle allows for mutually recursive definitions but the one described here does not.
References-found: 8

