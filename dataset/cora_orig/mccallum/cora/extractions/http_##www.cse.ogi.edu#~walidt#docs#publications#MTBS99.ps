URL: http://www.cse.ogi.edu/~walidt/docs/publications/MTBS99.ps
Refering-URL: http://www.cse.ogi.edu/~walidt/docs/publications/
Root-URL: http://www.cse.ogi.edu
Email: moggi@disi.unige.it  fwalidt,benaissa,sheardg@cse.ogi.edu  
Phone: 2  
Title: A Simpler Idealized MetaML  
Author: Eugenio Moggi Walid Taha Zine El-Abidine Benaissa and Tim Sheard 
Note: [3], can handle call-by-name as easily as call-by-value.  
Address: Genova, Italy  Portland, OR, USA  
Affiliation: 1 DISI, Univ di Genova  Oregon Graduate Institute  
Abstract: MetaML is a statically-typed multi-stage programming language featuring three statically-typed operators comparable to the back-quote, comma, and eval of Scheme. Thus it provides special support for writing code generators, and serves as a semantically-sound basis for systems involving multiple interdependent computational stages. In previous work, we reported on an implementation of MetaML, and on the small-step semantics and a type-system for MetaML. In this paper, we present An Idealized MetaML (AIM) that is the result of our study of a categorical model for MetaML. In comparison to MetaML AIM has the following advantages: a simpler type system able to type the same terms typable in MetaML, a direct relation to the type system fl of Davies 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> U. Berger and H. Schwichtenberg. </author> <title> An inverse of the evaluation functional for typed -calculus. </title> <editor> In Rao Vemuri, editor, </editor> <booktitle> Proceedings of the Sixth Annual IEEE Symposium on Logic in Computer Science. </booktitle> <publisher> IEEE Computer Society Press, Loss Alamitos, </publisher> <year> 1991. </year>
Reference-contexts: Terms have no explicit level-annotations. In this way the definition of demotion and substitution become straightforward total operations on terms, while in [10] they are partial. This development is crucial for a call-by-name semantics. Call-by-name semantics plays an important role in the formal theory of Normalization by Evaluation <ref> [1] </ref> and Type Directed Partial Evaluation [2]. 3. The level Promotion and Demotion lemmas, and the Substitution lemma, are proven in full generality, and not just for the cases restricted to values. 4.
Reference: 2. <author> Olivier Danvy. </author> <title> Type-directed partial evaluation. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 242-257, </pages> <address> Florida, January 1996. New York: </address> <publisher> ACM. </publisher>
Reference-contexts: In this way the definition of demotion and substitution become straightforward total operations on terms, while in [10] they are partial. This development is crucial for a call-by-name semantics. Call-by-name semantics plays an important role in the formal theory of Normalization by Evaluation [1] and Type Directed Partial Evaluation <ref> [2] </ref>. 3. The level Promotion and Demotion lemmas, and the Substitution lemma, are proven in full generality, and not just for the cases restricted to values. 4. The big-step operational semantics is comparable to that given in [3], and does not make explicit use of a stateful renaming function.
Reference: 3. <author> Rowan Davies. </author> <title> A temporal-logic approach to binding-time analysis. </title> <booktitle> In Proceedings, 11 th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 184-195, </pages> <address> New Brunswick, New Jersey, July 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: This is the gap MetaML is designed to fill. 1.1 Open Code and Closed Code A number of typed languages for manipulating code fragments have been proposed in the literature. Some have types for open code <ref> [8, 6, 3] </ref>, and others have types for closed code [4]. On one hand, languages with open types play an important role in the study of partial evaluation. <p> In the presentation of AIM we have introduced important simplifications over [10], which overcome most of the problems mentioned above: 1. The type system uses only one level-annotation, like the type system in <ref> [3] </ref>. 2. Terms have no explicit level-annotations. In this way the definition of demotion and substitution become straightforward total operations on terms, while in [10] they are partial. This development is crucial for a call-by-name semantics. <p> The level Promotion and Demotion lemmas, and the Substitution lemma, are proven in full generality, and not just for the cases restricted to values. 4. The big-step operational semantics is comparable to that given in <ref> [3] </ref>, and does not make explicit use of a stateful renaming function. In the rest of the paper, we present the type system and establish several syntactic properties. we give a big-step operational semantics of AIM, including a call-by-name variant, and prove type-safety. We relate AIM to fl and MetaML. <p> be replaced by a term e 1 , provided e 1 meets the requirements on x. 3 Big-Step Operational Semantics The big-step semantics for MetaML presented in [11] reflects the existing implementation, it is complex, and hence not very suitable for formal reasoning. abstraction of that for fl given in <ref> [3] </ref>. For constants c we would have to give evaluation rules, and take them into account in the definition of values at level 0. For simplicity we ignore this issue. We avoids the explicit use of a gensym or newname for renaming bound variables, this is implicitly done by substitution. <p> The only case which is different from call-by-value is e 1 e 2 0 ,! v. However, this is unproblematic, since the Substitution Lemma for AIM's type system has no value restriction. ut 4 Relations with other languages This section shows that AIM extends fl of <ref> [3] </ref>, informally speaking we have AIM= fl + run + cross-stage persistence, and that its type system is equivalent to that given in [10] for MetaML. 4.1 Embedding of fl The embedding of fl into AIM is straight-forward. <p> Our notion of level is very similar to that used by Gluck and Jtrgensen. Davies extended the Curry-Howard isomorphism to a relation between modal logic and the type system for a multi-level language <ref> [3] </ref>. Intuitively, fl provide a good framework for formalizing the presence of back-quote and comma in a language. The semantics of our Bracket and Escape correspond closely to those of back-quote and comma, respectively.
Reference: 4. <author> Rowan Davies and Frank Pfenning. </author> <title> A modal analysis of staged computation. </title> <booktitle> In 23rd Annual ACM Symposium on Principles of Programming Languages (POPL'96), </booktitle> <address> St.Petersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: This is the gap MetaML is designed to fill. 1.1 Open Code and Closed Code A number of typed languages for manipulating code fragments have been proposed in the literature. Some have types for open code [8, 6, 3], and others have types for closed code <ref> [4] </ref>. On one hand, languages with open types play an important role in the study of partial evaluation. Typically, they provide two constructs, one for building a piece of code with free variables, and one for combining such pieces of code. <p> This language was developed for studying code generation. Davies and Pfenning show that a generalization of this language to a multi-level language called fl gives rise to a type system related to a modal logic, and extends the two-level language of Nielson and Nielson <ref> [4] </ref>. Intuitively, fl provides a natural framework where LISP's quote and eval can be present in a language. The semantics of our Bracket and Run correspond closely to those of quote and eval, respectively. Gomard and Jones [6] use a statically-typed two-level language for partial evaluation of the untyped -calculus.
Reference: 5. <author> Robert Gluck and Jesper Jtrgensen. </author> <title> An automatic program generator for multilevel specialization. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 10(2) </volume> <pages> 113-158, </pages> <year> 1997. </year>
Reference-contexts: Note how the looping overhead has been removed from the generated code. This is the purpose of program staging and it can be highly effective as discussed elsewhere <ref> [5, 11] </ref>. The last declaration evaluates this deferred piece of code. 1.3 Contribution and Organization of this Paper [11] reported on the implementation and application of MetaML, while [10] presented an axiomatic semantics and a type system for MetaML, and proved type safety. <p> This language is the basis for many BTAs. Gluck and Jtrgensen study partial evaluation in the generalized context where inputs can arrive at an arbitrary number of times rather than just two (namely, specialization-time and run-time) <ref> [5] </ref>, and demonstrate that binding-time analysis in a multi-level setting can be done with efficiency comparable to that of two-level binding time analysis. Our notion of level is very similar to that used by Gluck and Jtrgensen.
Reference: 6. <author> Carsten K. Gomard and Neil D. Jones. </author> <title> A partial evaluator for the untyped lambda calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(1) </volume> <pages> 21-69, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: This is the gap MetaML is designed to fill. 1.1 Open Code and Closed Code A number of typed languages for manipulating code fragments have been proposed in the literature. Some have types for open code <ref> [8, 6, 3] </ref>, and others have types for closed code [4]. On one hand, languages with open types play an important role in the study of partial evaluation. <p> Intuitively, fl provides a natural framework where LISP's quote and eval can be present in a language. The semantics of our Bracket and Run correspond closely to those of quote and eval, respectively. Gomard and Jones <ref> [6] </ref> use a statically-typed two-level language for partial evaluation of the untyped -calculus. This language is the basis for many BTAs.
Reference: 7. <author> Eugenio Moggi. </author> <title> A categorical account of two-level languages. </title> <booktitle> In MFPS 1997, </booktitle> <year> 1997. </year>
Reference-contexts: Intuitively, fl provide a good framework for formalizing the presence of back-quote and comma in a language. The semantics of our Bracket and Escape correspond closely to those of back-quote and comma, respectively. Moggi <ref> [7] </ref> advocates a categorical approach to two-level languages based on indexed categories, and stresses formal analogies with a categorical account of phase distinction and module languages.
Reference: 8. <author> Flemming Nielson and Hanne Rijs Nielson. </author> <title> Two-Level Functional Languages. </title> <booktitle> Number 34 in Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: This is the gap MetaML is designed to fill. 1.1 Open Code and Closed Code A number of typed languages for manipulating code fragments have been proposed in the literature. Some have types for open code <ref> [8, 6, 3] </ref>, and others have types for closed code [4]. On one hand, languages with open types play an important role in the study of partial evaluation. <p> Nielson and Nielson present a seminal detailed study into a two-level functional programming language <ref> [8] </ref>. This language was developed for studying code generation. Davies and Pfenning show that a generalization of this language to a multi-level language called fl gives rise to a type system related to a modal logic, and extends the two-level language of Nielson and Nielson [4].
Reference: 9. <author> Calton Pu, Andrew Black, Crispin Cowan, and Jonathan Walpole. </author> <title> Microlanguages for operating system specialization. </title> <booktitle> In Proceedings of the SIGPLAN Workshop on Domain-Specific Languages, </booktitle> <address> Paris, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: we get that ` e: (hti; r + 1) n is derivable in MetaML, and so also ` run e: (t; r) n is derivable. ut 5 Related and Future Work Multi-stage programming techniques have been used in a wide variety of settings [11], including run-time specialization of C programs <ref> [9] </ref>. Nielson and Nielson present a seminal detailed study into a two-level functional programming language [8]. This language was developed for studying code generation.
Reference: 10. <author> Walid Taha, Zine-El-Abidine Benaissa, and Tim Sheard. </author> <title> Multi-stage programming: Axiomatization and type-safety. </title> <booktitle> In 25th International Colloquium on Automata, Languages, and Programming, </booktitle> <address> Aalborg, Denmark, </address> <month> 13-17July </month> <year> 1998. </year>
Reference-contexts: This is the purpose of program staging and it can be highly effective as discussed elsewhere [5, 11]. The last declaration evaluates this deferred piece of code. 1.3 Contribution and Organization of this Paper [11] reported on the implementation and application of MetaML, while <ref> [10] </ref> presented an axiomatic semantics and a type system for MetaML, and proved type safety. However, there were still a number of drawbacks: 1. One could define only a call-by-value semantics, because substitution was a partially defined operation, which was well-defined only when variables are substituted with values. 2. <p> This paper describes the type system and operational semantics of An Idealized MetaML (AIM), whose design is inspired by a categorical model for MetaML (such a model will be the subject of another paper). In the presentation of AIM we have introduced important simplifications over <ref> [10] </ref>, which overcome most of the problems mentioned above: 1. The type system uses only one level-annotation, like the type system in [3]. 2. Terms have no explicit level-annotations. In this way the definition of demotion and substitution become straightforward total operations on terms, while in [10] they are partial. <p> introduced important simplifications over <ref> [10] </ref>, which overcome most of the problems mentioned above: 1. The type system uses only one level-annotation, like the type system in [3]. 2. Terms have no explicit level-annotations. In this way the definition of demotion and substitution become straightforward total operations on terms, while in [10] they are partial. This development is crucial for a call-by-name semantics. Call-by-name semantics plays an important role in the formal theory of Normalization by Evaluation [1] and Type Directed Partial Evaluation [2]. 3. <p> The Abstraction and Application rules are standard. The Bracket and Escape rules establish an isomorphism between t n+1 and hti n . The Run rule need some explanation. For typing Run <ref> [10] </ref> introduces an extra index-annotation on types for counting the number of Runs surrounding an expression (see Figure 3). <p> Promotion, Demotion and Substitution lemmas extend and improve on similar results established in <ref> [10] </ref> for MetaML's type system. Lemma 1 (Promotion). If 1 ; 2 ` e: t n then 1 ; +1 2 ` e: t n+1 . The lemma says that if we increment the level of a well-formed term e and that of some variables free variables, e remains well-formed. <p> The lemma says that if we increment the level of a well-formed term e and that of some variables free variables, e remains well-formed. Demotion on e at n, written e # n , lowers the level of e and is well-defined on all terms, unlike Demotion in <ref> [10] </ref>. <p> unproblematic, since the Substitution Lemma for AIM's type system has no value restriction. ut 4 Relations with other languages This section shows that AIM extends fl of [3], informally speaking we have AIM= fl + run + cross-stage persistence, and that its type system is equivalent to that given in <ref> [10] </ref> for MetaML. 4.1 Embedding of fl The embedding of fl into AIM is straight-forward. <p> Figure 3 recalls the MetaML type system given in <ref> [10] </ref>. ` c: (t c ; r) n ` x: (t; r) n if x = (t; p) m and m + r n + p ` x:e: (t 1 ! t 2 ; r) n ` e 1 e 2 : (t 2 ; r) n ` hei: (hti; r)
Reference: 11. <author> Walid Taha and Tim Sheard. </author> <title> Multi-stage programming with explicit annotations. </title> <booktitle> In Proceedings of the ACM-SIGPLAN Symposium on Partial Evaluation and semantic based program manipulations PEPM'97, Amsterdam, </booktitle> <pages> pages 203-217. </pages> <publisher> ACM, </publisher> <year> 1997. </year>
Reference-contexts: Note how the looping overhead has been removed from the generated code. This is the purpose of program staging and it can be highly effective as discussed elsewhere <ref> [5, 11] </ref>. The last declaration evaluates this deferred piece of code. 1.3 Contribution and Organization of this Paper [11] reported on the implementation and application of MetaML, while [10] presented an axiomatic semantics and a type system for MetaML, and proved type safety. <p> Note how the looping overhead has been removed from the generated code. This is the purpose of program staging and it can be highly effective as discussed elsewhere [5, 11]. The last declaration evaluates this deferred piece of code. 1.3 Contribution and Organization of this Paper <ref> [11] </ref> reported on the implementation and application of MetaML, while [10] presented an axiomatic semantics and a type system for MetaML, and proved type safety. However, there were still a number of drawbacks: 1. <p> ; 2 ` e 2 [x: = e 1 ]: t n This is the expected substitution property, i.e. a variable x can be replaced by a term e 1 , provided e 1 meets the requirements on x. 3 Big-Step Operational Semantics The big-step semantics for MetaML presented in <ref> [11] </ref> reflects the existing implementation, it is complex, and hence not very suitable for formal reasoning. abstraction of that for fl given in [3]. For constants c we would have to give evaluation rules, and take them into account in the definition of values at level 0. <p> By the IH we get that ` e: (hti; r + 1) n is derivable in MetaML, and so also ` run e: (t; r) n is derivable. ut 5 Related and Future Work Multi-stage programming techniques have been used in a wide variety of settings <ref> [11] </ref>, including run-time specialization of C programs [9]. Nielson and Nielson present a seminal detailed study into a two-level functional programming language [8]. This language was developed for studying code generation.
Reference: 12. <author> Philip Wickline, Peter Lee, and Frank Pfenning. </author> <title> Run-time code generation and Modal-ML. </title> <booktitle> In Proceedings of the ACM SIGPLAN'98 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 224-235, </pages> <address> Montreal, Canada, </address> <month> 17-19 June </month> <year> 1998. </year>
Reference-contexts: The type system used two index-annotations on types, while other type systems for multi-stage languages use one. Moreover, it has been criticized for not being based on a standard logical system <ref> [12] </ref>. 3. There is a problem with typing the declaration of a code fragment, and then executing it in another declaration.
References-found: 12

