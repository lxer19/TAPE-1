URL: http://ptolemy.eecs.berkeley.edu/papers/PganRpmcDppo/rapidProtoWkshp.ps.Z
Refering-URL: http://ptolemy.eecs.berkeley.edu/~murthy/pub.html
Root-URL: 
Title: Abstract graphs for which valid schedules exist are called consistent SDF graphs. In [10], ef
Author: A B Shuvra S. Bhattacharyya, Hitachi America Ltd. Praveen K. Murthy, Edward A. Lee, 
Date: June, 1995.  
Address: Berkeley  Chapel Hill, North Carolina,  
Affiliation: e e( )src e( )snk e( )d e e( )src e  University of California at Berkeley  University of California at  Rapid Systems Prototyping,  
Note: 1: Introduction SDF  Proc. 1995 IEEE International Workshop on  
Abstract: Since software prototypes of DSP applications ar e most efficient when their code and data space r equire-ments can be accommodated entir ely within the on-chip memory of the target processor, it is crucial to employ efficient memory-minimizing compilation techniques in a DSP software prototyping system. In this paper, we introduce two techniques for the combined minimization of code and data when compiling graphical pr ograms that are based on the synchronous dataow (SDF) model. The first method is a customization to acyclic graphs of a bottom-up technique, called Pairwise Gr ouping of Adjacent Nodes (PGAN), that was pr oposed earlier for general SDF graphs. We show that our customization significantly reduces the complexity of the general PGAN algorithm and performs optimally for a certain class of applications. The second approach is a top-down technique, called Recursive Partitioning by Minimum Cuts (RPMC), that is based on a generalized minimum cut operation. From an extensive experimental study, we conclude that RPMC and our customization of PGAN ar e complementary, and both should be incorporated into SDF-based prototyping environments in which the minimization of memory requirements is important. For the past several years, programmable digital signal processors have been popular in rapid prototyping environments for DSP. The limited on-chip memory of these processors, together with significant speed penalties for off-chip memory access, often render it critical for a high level software synthesis tool to produce a lean tar get program, in the dimensions of both code and data. In this paper, we present efficient techniques to compile graphical DSP programs based on the synchronous dataf low (SDF) model into software implementations that require a minimum amount of memory for code and data. Numerous DSP design environments, including a number of com mercial tools, support SDF or closely related models [9, 12, 13, 14]. Here, we focus on programs that are represented as acyclic SDF graphs. In SDF, a program is represented by a directed graph in which each vertex ( actor) represents a computation, an edge specifies a FIFO buf fer, and each actor produces (consumes) a fixed number of data values ( tokens) onto (from) each output (input) edge per invocation. Fig. 1(a) shows a simple SDF graph. Each edge is annotated with the number of tokens produced (consumed) by its source (sink) actor, and the D on the edge from actor to actor specifies a unit delay. Each unit of delay is implemented as an initial token on the edge. Given an SDF edge , we denote the source actor , sink actor, and delay of by , , and . Also, and denote the number of tokens produced onto by and consumed from by and A schedule is a sequence of actor firings. We compile an SDF graph by first constructing a valid schedule a finite schedule that fires each actor at least once, does not deadlock, and produces no net change in the number of tokens queued on each edge. Corresponding to each actor in the schedule, we instantiate a code block that is obtained from a library of predefined actors. The resulting sequence of code blocks is encapsulated within an inf inite loop to generate a software implementation of the SDF graph. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ade, R. Lauwereins, J. A. Peperstraete, </author> <title> Buf fer Memory Requirements in DSP Applications, presented at IEEE Wkshp. on Rapid System Prototyping, </title> <address> Grenoble, </address> <month> June, </month> <year> 1994. </year>
Reference-contexts: of adopting both APGAN and RPMC as a combined solution arises from complementing the strong performance of RPMC on general graphs with the formal properties of APGAN, as specified by Theorem 4, and the ability of APGAN to exploit regularity that arises frequently in practical applications. 8: Related Work In <ref> [1] </ref>, Ade, Lauwereins, and Peperstraete develop upper bounds on the minimum buf fer memory requirement for certain classes of SDF graphs.
Reference: [2] <author> S. S. Bhattacharyya, P. K. Murthy, E. A. Lee, </author> <title> Two Complementary Heuristics for Translating Graphical DSP Programs into Minimum Memory Software Implementations, </title> <note> Memorandum No. </note> <institution> UCB/ERL M95/3, Electronics Research Laboratory, University of California at Berkeley, </institution> <month> January, </month> <year> 1995. </year>
Reference-contexts: We say that is clusterable if is consistent, and if is acyclic, then introduces a cycle if contains one or more cycles. Fig. 2 gives an example of clustering. Here, edge corresponds to and vice versa. In <ref> [2] </ref>, a dynamic programming algorithm called GDPPO is developed for post-optimizing single appearance schedules to reduce the buf fer memory requirement. <p> ( ) W clust G Z W,( ) Z ( )subgraph Z clust G Z ( ) G Z clust G Z ( ) D W,( ) D C,( ) against each other and against randomly generated schedules that are post-processed by GDPPO. 3: The Buffer Memory Lower Bound In <ref> [2] </ref> we derive the following lower bound on , given a consistent SDF graph , an edge in , and a valid single appearance schedule . Definition 1: The buffer memory lower bound (BMLB) of an SDF edge , denoted , is given by , where . <p> This check is performed ef ficiently by applying a reachability matrix, which indicates for any two APG vertices , whether or not there is a path from to . Unfortunately, the cost to compute and store the APG reachability matrix can be prohibitively high for some applications <ref> [2] </ref>. <p> In an acyclic SDF graph , it is easily verified that a subset of actors is not clusterable only if introduces a cycle. This condition is easily checked given a reachability matrix for <ref> [2] </ref>. Since the existence of a cycle in is not a sufficient condition for not to be clusterable, the clusterability test that we apply in APGAN is not exact; it must be viewed as a conservative test. For some graphs, this imprecision can prevent APGAN from attaining optimal results [2]. <p> for <ref> [2] </ref>. Since the existence of a cycle in is not a sufficient condition for not to be clusterable, the clusterability test that we apply in APGAN is not exact; it must be viewed as a conservative test. For some graphs, this imprecision can prevent APGAN from attaining optimal results [2]. In exchange for some degree of suboptimality in these cases, our clusterability test attains a large computational savings over the exact test based on the reachability matrix of the APG. Fig. 3 illustrates the operation of APGAN. <p> If each edge in satisfies , then we construct the schedule , and otherwise we construct . It is straightforward to show that the resulting schedule for the subgraph corresponding to is always optimal <ref> [2] </ref>. In Fig. 3, this yields the top-level schedule (we suppress loops that have an iteration count of one) for the subgraph corresponding to . Next, we recursively descend one level in cluster hierarchy to the subgraph corresponding to , and we obtain the schedule . <p> In Fig. 3 (a) , and , , , and thus, satisfies the proper clustering condi tion. Theorem 1: <ref> [2] </ref> Suppose is a consistent, connected, W 2 3A ( ) B 2C ( ) S p 2 3A ( ) B 2C ( )( ) 5D ( ) E S p ( )buffer_memory e ( )BMLB e E 43 e ( ) h e ( )&lt;d e E P P <p> Then for each edge in , , where is the edge in that corresponds to . The following theorem guarantees that whenever an APGAN instance performs a clustering operation on a graph that has a BMLB schedule, the adjacent pair selected satisfies the proper clustering condition. Theorem 2: <ref> [2] </ref> Suppose is a connected, delayless SDF graph; has a BMLB schedule; and is an APGAN candidate in . Then satisfies the proper clustering condition in . Theorem 1 guarantees that clustering an adjacent pair that satisfies the proper clustering condition does not change the BMLB on an edge. <p> is not sufficient to simply ensure that each clusterization step selects an adjacent pair that satisfies the proper clustering condition, since although clustering an adjacent pair that satisfies the proper clustering condition preserves the BMLB values on each edge, it does not necessarily preserve the existence of a BMLB schedule <ref> [2] </ref>. Fortunately, however, the assumption that the adjacent pair being clustered has maximum repetition count is sufficient to preserve the existence of a BMLB schedule. Theorem 3: [2] Suppose is a connected, delayless SDF graph; has a BMLB schedule; and is an APGAN candidate in . <p> satisfies the proper clustering condition preserves the BMLB values on each edge, it does not necessarily preserve the existence of a BMLB schedule <ref> [2] </ref>. Fortunately, however, the assumption that the adjacent pair being clustered has maximum repetition count is sufficient to preserve the existence of a BMLB schedule. Theorem 3: [2] Suppose is a connected, delayless SDF graph; has a BMLB schedule; and is an APGAN candidate in . Then has a BMLB schedule. <p> The following consequence of Lemma 2 gives our general specification of the optimality of APGAN. Theorem 4: <ref> [2] </ref> If is a connected, acyclic SDF graph that has a BMLB schedule; for all ; and is an APGAN instance, then the schedule obtained by applying to is a BMLB schedule for . 6: Recursive Partitioning by Minimum Cuts APGAN constructs a single appearance schedule in a bottom-up fashion by <p> We also impose the constraint that the partition is fairly evenly sized. This is to increase the possibility of having gcds that are greater than unity for the repetitions of the actors in the subsets produced by the partition, thus reducing the buffer memory requirement <ref> [2] </ref>. Suppose that is a connected, consistent SDF graph. A cut of is a partition of the actor set into two disjoint sets and . <p> be expected to consistently have irregular rate changes and topologies, the average performance on random graphs of RPMC is better than APGAN by a wide margin although we have found that there is a significant proportion of random graphs for which APGAN outperforms RPMC by a margin of over 10% <ref> [2] </ref>, which suggests that APGAN is a useful complement to RPMC even when mostly irregular graphs are encountered.
Reference: [3] <author> S. S. Bhattacharyya, E. A. Lee, </author> <title> Scheduling Synchronous Dataflow Graphs for Efficient Looping, </title> <journal> Journal of VLSI Signal Processing, </journal> <month> December, </month> <year> 1993. </year>
Reference-contexts: It is easily verified that no such single appearance schedule exists for this graph. In contrast, for Fig. 1 (b), it is easily verified that is a BMLB schedule (here ). 4: PGAN for Acyclic Graphs In the original Pairwise Grouping of Adjacent Nodes (PGAN) technique, developed in <ref> [3] </ref>, a cluster hierarchy is constructed by clustering exactly two adjacent vertices at each step. At each clusterization step, a pair of adjacent actors is chosen that maximizes over all clusterable adjacent pairs.
Reference: [4] <author> T. H. Cormen, C. E. Leiserson, R. L. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> McGraw-Hill, </publisher> <year> 1990. </year>
Reference-contexts: Methods based on network f lows <ref> [4] </ref> do not work because the minimum cut given by the max-flow-min-cut theorem may not be legal and may not be bounded [11]. Hence, we give a heuristic solution for finding legal minimum cuts into bounded sets.
Reference: [5] <author> M. R. Garey, D. S. Johnson, </author> <title> Computers and Intractability-A guide to the theory of NP-completeness, </title> <publisher> Freeman, </publisher> <year> 1979. </year>
Reference-contexts: The problem then is to f ind the minimum weight legal cut into bounded sets for the graph. Since the related problem of finding a minimum cut (not necessarily legal) into bounded sets is NP-complete <ref> [5] </ref>, and the problem of finding an acyclic partition of a graph is NP-complete [5], we believe this problem to be NP-complete as well even though we have not discovered a proof. <p> The problem then is to f ind the minimum weight legal cut into bounded sets for the graph. Since the related problem of finding a minimum cut (not necessarily legal) into bounded sets is NP-complete <ref> [5] </ref>, and the problem of finding an acyclic partition of a graph is NP-complete [5], we believe this problem to be NP-complete as well even though we have not discovered a proof.
Reference: [6] <author> S.R. Govindarajan, G. R. Gao, P. Desai, </author> <title> Minimizing Memory Requirements in Rate-Optimal Schedules, </title> <booktitle> Proc. of the Intl. Conf. on Application Specific Array Processors, </booktitle> <month> August, </month> <year> 1994. </year>
Reference-contexts: A linear programming framework for minimizing the memory requirement of an SDF graph in a parallel pro cessing context is explored by Govindarajan and Gao <ref> [6] </ref>. Here the goal is to minimize the buf fer cost without sacrificing throughput. 9: Conclusions We have presented two scheduling techniques, APGAN and RPMC, for minimizing the memory required for code and data when mapping an acyclic SDF graph into an implementation on a programmable processor.
Reference: [7] <author> B. W. Kernighan, S. Lin, </author> <title> An Ef ficient Heuristic Procedure for Partitioning Graphs, </title> <journal> Bell System Technical Journal, </journal> <month> Febru-ary </month> <year> 1970. </year>
Reference-contexts: Kernighan and Lin <ref> [7] </ref> devised a heuristic procedure for computing cuts into bounded sets but they considered S P G ( )( )buffer_memory e ( )BMLB e E G V E,( )= e E P G G V e e ( )src V L e ( )snk V R V R K V L <p> Consider a cut produced by setting for some actor , and let be the set of independent, boundary actors of in . A boundary actor in is an actor that is not the predecessor of any other actor in . Following Kernighan and Lin <ref> [7] </ref>, for each of these actors, we can compute the cost dif ference that results if the actor is moved into .
Reference: [8] <author> R. Lauwereins, P. Wauters, M. Ade, J. A. Peperstraete, </author> <title> Geometric Parallelism and Cyclo-Static Dataflow in GRAPE-II, IEEE Wkshp. on Rapid System Prototyping, </title> <month> June, </month> <year> 1994. </year>
Reference-contexts: Since single appearance schedules generally have much lar ger buffer memory requirements than schedules that are optimized for minimum buffer memory only, these bounds cannot consistently give close estimates of the minimum buf fer memory requirement for single appearance schedules. In <ref> [8] </ref>, Lauwereins, Wauters, Ade, and Peperstraete present a generalization of SDF called cyclo-static data-flow.
Reference: [9] <author> R. Lauwereins, M. Engels, J. A. Peperstraete, E. Steegmans, J. Van Ginderdeuren, </author> <title> GRAPE: A CASE Tool for Digital Signal Parallel Processing, </title> <journal> IEEE ASSP Magazine, </journal> <month> April, </month> <year> 1990. </year>
Reference-contexts: Numerous DSP design environments, including a number of com mercial tools, support SDF or closely related models <ref> [9, 12, 13, 14] </ref>. Here, we focus on programs that are represented as acyclic SDF graphs.
Reference: [10] <author> E. A. Lee, D. G. Messerschmitt, </author> <title> Static Scheduling of Synchronous Dataflow Programs for Digital Signal Processing, </title> <journal> IEEE Trans. on Computers, </journal> <month> February, </month> <year> 1987. </year>
Reference-contexts: The resulting sequence of code blocks is encapsulated within an inf inite loop to generate a software implementation of the SDF graph. SDF graphs for which valid schedules exist are called consistent SDF graphs. In <ref> [10] </ref>, ef ficient algorithms are presented to determine whether or not a given SDF graph A B C A B C A B e e ( )src e ( )snk e ( )d e e ( )src e Converting Graphical DSP Programs into Memory Constrained Software Prototypes Shuvra S. <p> At each clusterization step, a pair of adjacent actors is chosen that maximizes over all clusterable adjacent pairs. To check whether or not an adjacent pair is cluster-able, PGAN maintains the cluster hierarchy on the acyclic precedence graph (APG) <ref> [10] </ref>.
Reference: [11] <author> P. K. Murthy, S. S. Bhattacharyya, E. A. Lee, </author> <title> Combined Code and Data Minimization for Synchr onous Dataflow Programs, </title> <note> Memorandum No. </note> <institution> UCB/ERL M94/93, Electronics Research Laboratory, University of California at Berkeley , November, </institution> <year> 1994. </year>
Reference-contexts: Methods based on network f lows [4] do not work because the minimum cut given by the max-flow-min-cut theorem may not be legal and may not be bounded <ref> [11] </ref>. Hence, we give a heuristic solution for finding legal minimum cuts into bounded sets. <p> It can be shown that the running time of RPMC for sparse SDF graphs, including post-optimization by GDPPO, is <ref> [11] </ref>. 7: Experimental Results Table 1 shows experimental results on the performance of APGAN and RPMC that we have developed for several practical examples of multirate acyclic SDF graphs. The column titled average random gives the average cost obtained by considering 100 random topological sorts and applying GDPPO to each.
Reference: [12] <author> D. R. OHallaron, </author> <title> The Assign Parallel Program Generator, </title> <institution> Memorandum CMU-CS-91-141, School of Computer Science, Carnegie Mellon University, </institution> <month> May, </month> <year> 1991. </year>
Reference-contexts: Numerous DSP design environments, including a number of com mercial tools, support SDF or closely related models <ref> [9, 12, 13, 14] </ref>. Here, we focus on programs that are represented as acyclic SDF graphs.
Reference: [13] <author> J. Pino, S. Ha, E. A. Lee, J. T. Buck, </author> <title> Software Synthesis for DSP Using Ptolemy, invited paper in Journal of VLSI Signal Processing, </title> <month> January, </month> <year> 1995. </year>
Reference-contexts: Numerous DSP design environments, including a number of com mercial tools, support SDF or closely related models <ref> [9, 12, 13, 14] </ref>. Here, we focus on programs that are represented as acyclic SDF graphs.

References-found: 13

