URL: http://www.cs.unc.edu/~anderson/papers/wdag94.ps.Z
Refering-URL: http://www.cs.unc.edu/~anderson/papers.html
Root-URL: http://www.cs.unc.edu
Title: Fast, Long-Lived Renaming (Extended Abstract)  
Author: Mark Moir and James H. Anderson 
Keyword: fast renaming, long-lived renaming, shared-memory multiprocessors, synchronization prim itives, wait-free synchronization  
Date: April 1994  
Address: Chapel Hill, North Carolina 27599-3175, USA  
Affiliation: Department of Computer Science The University of North Carolina at Chapel Hill  
Abstract: We consider wait-free solutions to the renaming problem for shared-memory multiprocessing systems [3, 5]. In the renaming problem, processes are required to choose new names in order to reduce the size of their name space. Previous solutions to the renaming problem have time complexity that is dependent on the size of the original name space, and allow processes to acquire names only once. In this paper, we present several new renaming algorithms. Most of our algorithms have time complexity that is independent of the size of the original name space, and some of our algorithms solve a new, more general version of the renaming problem called long-lived renaming. In long-lived renaming algorithms, processes may repeatedly acquire and release names. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Anderson and M. Moir, </author> <title> "Using k-Exclusion to Implement Resilient, Scalable Shared Objects", </title> <booktitle> to appear in Proceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing </booktitle> . 
Reference-contexts: This is the essence of a methodology we are developing for the implementation of resilient, scalable shared objects. For details of this methodology, and the use of long-lived renaming, see <ref> [1] </ref>. In that paper, we presented a simple long-lived renaming algorithm. To our knowledge, this is the only previous work on long-lived renaming. In this paper, we present several new long-lived renaming algorithms, one of which is a generalization of the algorithm we presented in [1]. <p> use of long-lived renaming, see <ref> [1] </ref>. In that paper, we presented a simple long-lived renaming algorithm. To our knowledge, this is the only previous work on long-lived renaming. In this paper, we present several new long-lived renaming algorithms, one of which is a generalization of the algorithm we presented in [1]. In the first part of the paper, we present three renaming algorithms that use only atomic read and write instructions. It has been shown that if M &lt; 2k 1, then M -renaming cannot be implemented in a wait-free manner using only atomic reads and writes [6]. <p> In many applications of renaming, it is important to achieve a name space that is as small as possible. For example, in our methodology for implementing scalable, resilient shared objects <ref> [1] </ref>, a process accesses a wait-free shared object implementation using a name acquired from a renaming algorithm as a process identifier. The time complexity of such wait-free shared object implementations often increases dramatically with the size of the name space containing the processes that access the implementation.
Reference: [2] <author> H. Attiya, A. Bar-Noy, D. Dolev, D. Koller, D. Peleg, and R. Reischuk, </author> <title> "Achievable Cases in an Asynchronous Environment", </title> <booktitle> Proceedings of the 28th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1987, </year> <pages> pp. 337-346. </pages>
Reference-contexts: 1 Introduction In the M renaming problem <ref> [2] </ref>, each of k processes is required to choose a distinct value, called a name, that ranges over f0; :::; M 1g. Each process is assumed to have a unique process identifier ranging over f0::N 1g. It is further required that k M &lt; N . <p> By first using an efficient renaming algorithm to reduce the size of the name space, the time complexity of that computation can be made independent of the size of the original name space. The renaming problem has been studied previously for both message-passing <ref> [2] </ref> and shared-memory multiprocessing systems [3, 5]. In this paper, we consider wait-free implementations of renaming in asynchronous, shared-memory systems. A renaming algorithm is wait-free iff each process is guaranteed to acquire a name after a finite number of that process's steps, regardless of the execution speeds of other processes.
Reference: [3] <author> A. Bar-Noy and D. Dolev, </author> <title> "Shared Memory versus Message-Passing in an Asynchronous Distributed Environment", </title> <booktitle> Proceedings of the 8th Annual ACM Symposium on Principles of Distributed Computing, ACM, </booktitle> <address> New York, </address> <month> August </month> <year> 1989, </year> <pages> pp. 307-318. </pages>
Reference-contexts: By first using an efficient renaming algorithm to reduce the size of the name space, the time complexity of that computation can be made independent of the size of the original name space. The renaming problem has been studied previously for both message-passing [2] and shared-memory multiprocessing systems <ref> [3, 5] </ref>. In this paper, we consider wait-free implementations of renaming in asynchronous, shared-memory systems. A renaming algorithm is wait-free iff each process is guaranteed to acquire a name after a finite number of that process's steps, regardless of the execution speeds of other processes. <p> In this paper, we also consider long-lived renaming, a new, more general version of renaming in which processes may repeatedly acquire and release names. fl Work supported, in part, by NSF Contract CCR 9216421. Email: fanderson,moirg@cs.unc.edu. Phone: (919)962-1757. Fax: (919)962-1799 Reference M Time Complexity Long-Lived? <ref> [3] </ref> k (k + 1)=2 O (N k) No [5] 2k 1 O (N k 2 ) No Thm. 2 2k 1 O (k 4 ) No Table 1: A comparison of M-renaming algorithms that employ only atomic reads and writes. <p> It has been shown that if M &lt; 2k 1, then M -renaming cannot be implemented in a wait-free manner using only atomic reads and writes [6]. Previous papers have given wait-free algorithms for one-time renaming that employ only reads and writes <ref> [3, 5] </ref>, including some that have an optimal name space of M = 2k 1. However, in all of these algorithms, the time complexity of choosing a name is dependent on N .
Reference: [4] <institution> BBN Advanced Computers, Inside the TC2000 Computer, </institution> <month> February, </month> <year> 1990. </year>
Reference-contexts: For m = 1, the set first zero and clear bit operations can be trivially implemented using test and set and write operations. For m &gt; 1, these operations can be implemented, for example, using the atomff0andset and fetch and and operations on the BBN TC2000 multiprocessor <ref> [4] </ref>. <p> The first algorithm has time complexity O (k=b). This is achieved using set first zero and clear bit. As discussed in Section 2, these operations can be implemented, for example, using operations available on the BBN TC2000 <ref> [4] </ref>. The second algorithm in this section has time complexity O (log k), which is a significant improvement over the first algorithm. To achieve this improvement, this algorithm uses a primitive operation called bounded decrement. We do not know of any systems that provide bounded decrement as a primitive operation.
Reference: [5] <author> E. Borowsky and E. Gafni, </author> <title> "Immediate Atomic Snapshots and Fast Renaming", </title> <booktitle> Proceedings of the 12th Annual ACM Symposium on Principles of Distributed Computing , ACM, </booktitle> <address> New York, </address> <month> August </month> <year> 1993, </year> <pages> pp. 41-50. </pages>
Reference-contexts: By first using an efficient renaming algorithm to reduce the size of the name space, the time complexity of that computation can be made independent of the size of the original name space. The renaming problem has been studied previously for both message-passing [2] and shared-memory multiprocessing systems <ref> [3, 5] </ref>. In this paper, we consider wait-free implementations of renaming in asynchronous, shared-memory systems. A renaming algorithm is wait-free iff each process is guaranteed to acquire a name after a finite number of that process's steps, regardless of the execution speeds of other processes. <p> Email: fanderson,moirg@cs.unc.edu. Phone: (919)962-1757. Fax: (919)962-1799 Reference M Time Complexity Long-Lived? [3] k (k + 1)=2 O (N k) No <ref> [5] </ref> 2k 1 O (N k 2 ) No Thm. 2 2k 1 O (k 4 ) No Table 1: A comparison of M-renaming algorithms that employ only atomic reads and writes. A solution to the long-lived renaming problem is useful in settings in which processes repeatedly access identical resources. <p> It has been shown that if M &lt; 2k 1, then M -renaming cannot be implemented in a wait-free manner using only atomic reads and writes [6]. Previous papers have given wait-free algorithms for one-time renaming that employ only reads and writes <ref> [3, 5] </ref>, including some that have an optimal name space of M = 2k 1. However, in all of these algorithms, the time complexity of choosing a name is dependent on N . <p> We start by presenting a one-time (k (k + 1)=2)-renaming algorithm that has O (k) time complexity. We then describe how this algorithm can be combined with previous results <ref> [5] </ref> to obtain a (2k 1)-renaming algorithm with O (k 4 ) time complexity. It has been shown that renaming is impossible for fewer than 2k 1 names when using only reads and writes, so with respect to the size of the resulting name space, this algorithm is optimal. <p> Using the algorithm presented in <ref> [5] </ref>, k processes can reduce the size of their name space from N to 2k 1 with time complexity O (N k 2 ).
Reference: [6] <author> M. Herlihy and N. Shavit, </author> <title> "The Asynchronous Computability Theorem for t-Resilient Tasks", </title> <booktitle> Proceedings of the 25th ACM Symposium on Theory of Computing, </booktitle> <year> 1993, </year> <pages> pp. 111-120. </pages>
Reference-contexts: In the first part of the paper, we present three renaming algorithms that use only atomic read and write instructions. It has been shown that if M &lt; 2k 1, then M -renaming cannot be implemented in a wait-free manner using only atomic reads and writes <ref> [6] </ref>. Previous papers have given wait-free algorithms for one-time renaming that employ only reads and writes [3, 5], including some that have an optimal name space of M = 2k 1. However, in all of these algorithms, the time complexity of choosing a name is dependent on N . <p> Combining the two algorithms, k processes can reduce the size of their name space from N to 2k 1 with time complexity O (k) + O ((k (k + 1)=2)k 2 ) = O (k 4 ). Thus, we have the following result. By the results of <ref> [6] </ref>, this algorithm is optimal with respect to the size of the name space. <p> By using read-modify-write operations, these algorithms achieve significantly better performance than the algorithms presented in the previous section. Furthermore, these algorithms all yield a name space of size k, which is clearly optimal (the lower bound results of <ref> [6] </ref> do not apply to algorithms that employ read-modify-write operations). The first algorithm has time complexity O (k=b). This is achieved using set first zero and clear bit. As discussed in Section 2, these operations can be implemented, for example, using operations available on the BBN TC2000 [4].
Reference: [7] <author> L. Lamport, </author> <title> "A Fast Mutual Exclusion Algorithm", </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 5, No. 1, </volume> <month> February, </month> <year> 1987, </year> <pages> pp. 1-11. 15 </pages>
Reference-contexts: In contrast to prior algorithms, our one-time algorithms have time complexity that depends only on k, the number of participating processes. These algorithms employ a novel technique that uses "building blocks" based on the "fast path" mechanism employed by Lamport's fast mutual exclusion algorithm <ref> [7] </ref>. We also present a read/write algorithm for long-lived renaming that yields a name space of size k (k+1)=2. This algorithm uses a modified version of the one-time building block that allows processes to "reset" the building block, so that it may be used repeatedly. <p> The code fragment shown in Figure 2 shows how the building block described above can be implemented using atomic read and write operations. The technique employed is essentially that of the "fast path" used in Lamport's fast mutual exclusion algorithm <ref> [7] </ref>. A process that stops corresponds to a process successfully "taking the fast path" in Lamport's algorithm. <p> All of our algorithms have the desirable property that time complexity is proportional to the level of contention. This is an important practical advantage because contention should be low in most well-designed applications <ref> [7] </ref>. There are numerous questions left open by our research. For example, it follows from our work that one-time (2k 1)-renaming can be solved using reads and writes with time complexity O (k 4 ).
References-found: 7

