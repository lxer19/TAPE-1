URL: http://www.neci.nj.nec.com/homepages/avg/pub/neci-tr-96-062.ps.gz
Refering-URL: http://www.neci.nj.nec.com/homepages/avg/webpub/node5.html
Root-URL: 
Email: avg@research.nj.nec.com  ret@cs.princeton.edu  
Title: Expected Performance of Dijkstra's Shortest Path Algorithm  
Author: Andrew V. Goldberg Robert E. Tarjan and 
Note: Research at Princeton University partially supported by the National Science Foundation, Grant No. CCR 8920505. Research during a visit to M.I.T. partially supported by ARPA Contract N00013-95-1-1246.  
Date: June 1996  
Address: 4 Independence Way Princeton, NJ 08540  Princeton, NJ 08858  
Affiliation: NEC Research Institute  Computer Science Department Princeton University  NEC Research Institute  
Abstract: We show that the expected number of decrease-key operations in Dijkstra's shortest path algorithm is O(n log(1 + m=n)) for an n-vertex, m-arc graph. The bound holds for any graph structure; the only assumption we make is that for every vertex, the lengths of its incoming arcs are drawn independently from the same distribution. The same bound holds with high probability. This result explains the small number of decrease-key operations observed in practice and helps to explain why Dijkstra codes based on binary heaps perform better than ones based on Fibonacci heaps. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. K. Ahuja, K. Mehlhorn, J. B. Orlin, and R. E. Tarjan. </author> <title> Faster Algorithms for the Shortest Path Problem. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 37(2) </volume> <pages> 213-223, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: The problem is well-studied. Dijkstra's algorithm [7] is the best known algorithm for the problem in theory and the most robust in practice. The best currently known bounds for the problem, based on a combination of Dijkstra's algorithm and priority queue data structures, appear in <ref> [1, 3, 4, 8, 9, 18] </ref>. The running time of an implementation of Dijkstra's algorithm is dominated by arc scans (with each arc scanned at most once) and the priority queue operations insert, extract-min, and decrease-key.
Reference: [2] <author> P.A. Bloniarz. </author> <title> A Shortest Path Algorithm with Expected Time O(n 2 log n log fl n). </title> <journal> SIAM J. Comput., </journal> <volume> 12 </volume> <pages> 588-600, </pages> <year> 1983. </year>
Reference-contexts: In this paper we show that, for a wide class of input distributions, the expected number of decrease-key operations is O (n log (1 + m=n)). This result holds in Bloniarz's endpoint-independent probabilty model <ref> [2] </ref>: for every vertex, the lengths of the incoming arcs are drawn independently from the same probability distribution. We make no other assumptions about the arc length distribution or the input graph structure. We also show that the same bound holds with high probability. <p> We are not aware of any previous results on probabilistic analysis of Dijkstra's algorithm. For probabilistic analysis of other shortest path algorithms, including those for the all-pairs problem, see <ref> [2, 10, 11, 12, 13, 15, 16] </ref>. Our result is motivated by the empirical observation that the number of decrease-key operations is small. This observation can be used to explain why Fibonacci heaps usually perform worse than binary heaps (see e.g. [5]).
Reference: [3] <author> P. Van Emde Boas, R. Kaas, and E. Zijlstra. </author> <title> Design and Implementation of an Efficient Priority Queue. </title> <journal> Math. Systems Theory, </journal> <volume> 10 </volume> <pages> 99-127, </pages> <year> 1977. </year>
Reference-contexts: The problem is well-studied. Dijkstra's algorithm [7] is the best known algorithm for the problem in theory and the most robust in practice. The best currently known bounds for the problem, based on a combination of Dijkstra's algorithm and priority queue data structures, appear in <ref> [1, 3, 4, 8, 9, 18] </ref>. The running time of an implementation of Dijkstra's algorithm is dominated by arc scans (with each arc scanned at most once) and the priority queue operations insert, extract-min, and decrease-key.
Reference: [4] <author> B. V. Cherkassky and A. V. Goldberg. </author> <title> Heap-on-Top Priority Queues. </title> <type> Technical Report 96-042, </type> <institution> NEC Research Institute, Princeton, NJ, </institution> <year> 1996. </year>
Reference-contexts: The problem is well-studied. Dijkstra's algorithm [7] is the best known algorithm for the problem in theory and the most robust in practice. The best currently known bounds for the problem, based on a combination of Dijkstra's algorithm and priority queue data structures, appear in <ref> [1, 3, 4, 8, 9, 18] </ref>. The running time of an implementation of Dijkstra's algorithm is dominated by arc scans (with each arc scanned at most once) and the priority queue operations insert, extract-min, and decrease-key.
Reference: [5] <author> B. V. Cherkassky, A. V. Goldberg, and T. Radzik. </author> <title> Shortest Paths Algorithms: Theory and Experimental Evaluation. </title> <booktitle> In Proc. 5th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 516-525, </pages> <year> 1994. </year> <note> To appear in Math. Prog. </note>
Reference-contexts: Our result is motivated by the empirical observation that the number of decrease-key operations is small. This observation can be used to explain why Fibonacci heaps usually perform worse than binary heaps (see e.g. <ref> [5] </ref>). More generally, the observation can be used to predict how an implementation of priority queues will perform when applied to Dijkstra's algorithm. This paper is organized as follows. In Section 2 we state the necessary definitions and previous results. Section 3 is devoted to our main result. <p> For dense graphs, the arc scans dominate the priority queue operations, and the two implementations perform similarly. The same holds for k-ary heaps with small values of k. This is consistent with the data in <ref> [5] </ref>. More precisely, for any heap size, the cost of extract-min is significantly higher in the Fibonacci heap implementation than in the binary heap implementation. The costs of insert and decrease-key are somewhat less for the Fibonacci heap implementation, with the difference increasing with the heap size.
Reference: [6] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: In this paper we consider only nonnegative length functions. The goal is to find shortest path distances from s to all vertices of the graph and a shortest path tree. For more details about the problem and Dijkstra's algorithm, see e.g. <ref> [6, 17] </ref>. We denote the number of vertices in G by n and the number of arcs by m. Without loss of generality, we assume that all vertices of G are reachable from s and 1 n 1 m. These assumptions imply that log (1 + m=n) &gt; 0. <p> For 1 i k, define X i = min 1ji x j . Let M (k) be the number of distinct values of X i . The following simple result is part of the folklore; see for example problem 6-2 on page 133 of <ref> [6] </ref>. Theorem 2.1 E (M (k)) = O (log k). M (k) = O (log k) w.h.p. Proof. For completeness, we include a proof that E (M (k)) = O (log k).
Reference: [7] <author> E. W. Dijkstra. </author> <title> A Note on Two Problems in Connexion with Graphs. </title> <journal> Numer. Math., </journal> <volume> 1 </volume> <pages> 269-271, </pages> <year> 1959. </year>
Reference-contexts: 1 Introduction The shortest path problem with nonnegative arc lengths is one of the most natural network optimization problems and occurs widely in practice. The problem is well-studied. Dijkstra's algorithm <ref> [7] </ref> is the best known algorithm for the problem in theory and the most robust in practice. The best currently known bounds for the problem, based on a combination of Dijkstra's algorithm and priority queue data structures, appear in [1, 3, 4, 8, 9, 18].
Reference: [8] <author> M. L. Fredman and R. E. Tarjan. </author> <title> Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 34 </volume> <pages> 596-615, </pages> <year> 1987. </year>
Reference-contexts: The problem is well-studied. Dijkstra's algorithm [7] is the best known algorithm for the problem in theory and the most robust in practice. The best currently known bounds for the problem, based on a combination of Dijkstra's algorithm and priority queue data structures, appear in <ref> [1, 3, 4, 8, 9, 18] </ref>. The running time of an implementation of Dijkstra's algorithm is dominated by arc scans (with each arc scanned at most once) and the priority queue operations insert, extract-min, and decrease-key. <p> For a graph with n vertices and m arcs, the number of insert and extract-min operations is n for each operation. The number of decrease-key operations is m in the worst case. Many data structures, such as Fibonacci heaps <ref> [8] </ref>, reduce the cost of the decrease-key operation at the expense of added complexity and an increased constant factor for the extract-min operation. In this paper we show that, for a wide class of input distributions, the expected number of decrease-key operations is O (n log (1 + m=n)).
Reference: [9] <author> M. L. Fredman and D. E. Willard. </author> <title> Trans-dichotomous Algorithms for Minimum Spanning Trees and Shortest Paths. </title> <booktitle> In Proc. 31st IEEE Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 719-725, </pages> <year> 1990. </year>
Reference-contexts: The problem is well-studied. Dijkstra's algorithm [7] is the best known algorithm for the problem in theory and the most robust in practice. The best currently known bounds for the problem, based on a combination of Dijkstra's algorithm and priority queue data structures, appear in <ref> [1, 3, 4, 8, 9, 18] </ref>. The running time of an implementation of Dijkstra's algorithm is dominated by arc scans (with each arc scanned at most once) and the priority queue operations insert, extract-min, and decrease-key.
Reference: [10] <author> A.M. Frieze and G.R. Grimmet. </author> <title> The Shortest-Path Problem for Graphs with Random Arc-Lengths. </title> <journal> Discrete Applied Mathematics, </journal> <volume> 10 </volume> <pages> 57-77, </pages> <year> 1985. </year>
Reference-contexts: We are not aware of any previous results on probabilistic analysis of Dijkstra's algorithm. For probabilistic analysis of other shortest path algorithms, including those for the all-pairs problem, see <ref> [2, 10, 11, 12, 13, 15, 16] </ref>. Our result is motivated by the empirical observation that the number of decrease-key operations is small. This observation can be used to explain why Fibonacci heaps usually perform worse than binary heaps (see e.g. [5]).
Reference: [11] <author> Q.P. Gu and T. Takaoka. </author> <title> On the Average Path Length of O(log N ) in the Shortest Path Problem. </title> <journal> Trans. IEICE, </journal> <volume> E70:1155-1158, </volume> <year> 1987. </year>
Reference-contexts: We are not aware of any previous results on probabilistic analysis of Dijkstra's algorithm. For probabilistic analysis of other shortest path algorithms, including those for the all-pairs problem, see <ref> [2, 10, 11, 12, 13, 15, 16] </ref>. Our result is motivated by the empirical observation that the number of decrease-key operations is small. This observation can be used to explain why Fibonacci heaps usually perform worse than binary heaps (see e.g. [5]).
Reference: [12] <author> S.G. Kolliopoulos and C. Stein. </author> <title> Finding Real-Valued Single-Source Shortest Paths in o(n 3 ) Expected Time. </title> <booktitle> In Proc. 5th Int. Programming and Combinatorial Optimization Conf., </booktitle> <year> 1996. </year>
Reference-contexts: We are not aware of any previous results on probabilistic analysis of Dijkstra's algorithm. For probabilistic analysis of other shortest path algorithms, including those for the all-pairs problem, see <ref> [2, 10, 11, 12, 13, 15, 16] </ref>. Our result is motivated by the empirical observation that the number of decrease-key operations is small. This observation can be used to explain why Fibonacci heaps usually perform worse than binary heaps (see e.g. [5]).
Reference: [13] <author> A. Moffat and T. Takaoka. </author> <title> An All-Pairs Shortest Path Algorithm with Expected Time O(n 2 log n). </title> <journal> SIAM J. Comput., </journal> <volume> 16 </volume> <pages> 1023-1031, </pages> <year> 1987. </year>
Reference-contexts: We are not aware of any previous results on probabilistic analysis of Dijkstra's algorithm. For probabilistic analysis of other shortest path algorithms, including those for the all-pairs problem, see <ref> [2, 10, 11, 12, 13, 15, 16] </ref>. Our result is motivated by the empirical observation that the number of decrease-key operations is small. This observation can be used to explain why Fibonacci heaps usually perform worse than binary heaps (see e.g. [5]).
Reference: [14] <author> H. Nagamochi and T. Ibaraki. </author> <title> Computing Edge-Connectivity in Multigraphs and Capacit-ated Graphs. </title> <journal> SIAM J. Disc. Meth., </journal> <volume> 5 </volume> <pages> 54-66, </pages> <year> 1992. </year> <month> 5 </month>
Reference-contexts: The above discussion suggests that Fibonacci heaps might outperform binary heaps in an application in which the number of decrease-key operations is much higher than the number of extract-min operations. The minimum cut algorithm of Nagamochi and Ibaraki <ref> [14] </ref> provides such a candidate application. This algorithm works on an undirected graph and uses a max priority queue instead of a min priority queue (i.e., extract-max and increase-key operations replace extract-min and decrease-key operations, with no difference in performance).
Reference: [15] <author> P.M. Spira. </author> <title> A new algorithm for finding all shortest paths in a graph of positive arcs in average time o(n 2 log 2 n). </title> <journal> SIAM J. Comput., </journal> <volume> 2 </volume> <pages> 28-32, </pages> <year> 1973. </year>
Reference-contexts: We are not aware of any previous results on probabilistic analysis of Dijkstra's algorithm. For probabilistic analysis of other shortest path algorithms, including those for the all-pairs problem, see <ref> [2, 10, 11, 12, 13, 15, 16] </ref>. Our result is motivated by the empirical observation that the number of decrease-key operations is small. This observation can be used to explain why Fibonacci heaps usually perform worse than binary heaps (see e.g. [5]).
Reference: [16] <author> P. Spirakis and A. Tsakadidis. </author> <title> A Very Fast, Practical Algorithm for Finding a Negative Cycle in a Digraph. </title> <booktitle> In Proc. 13th ICALP, Lecture Notes in Computer Science 226, </booktitle> <pages> pages 59-67. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: We are not aware of any previous results on probabilistic analysis of Dijkstra's algorithm. For probabilistic analysis of other shortest path algorithms, including those for the all-pairs problem, see <ref> [2, 10, 11, 12, 13, 15, 16] </ref>. Our result is motivated by the empirical observation that the number of decrease-key operations is small. This observation can be used to explain why Fibonacci heaps usually perform worse than binary heaps (see e.g. [5]).
Reference: [17] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA, </address> <year> 1983. </year>
Reference-contexts: In this paper we consider only nonnegative length functions. The goal is to find shortest path distances from s to all vertices of the graph and a shortest path tree. For more details about the problem and Dijkstra's algorithm, see e.g. <ref> [6, 17] </ref>. We denote the number of vertices in G by n and the number of arcs by m. Without loss of generality, we assume that all vertices of G are reachable from s and 1 n 1 m. These assumptions imply that log (1 + m=n) &gt; 0.
Reference: [18] <author> M. </author> <title> Thorup. On RAM Priority Queues. </title> <booktitle> In Proc. 7th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 59-67, </pages> <year> 1996. </year> <month> 6 </month>
Reference-contexts: The problem is well-studied. Dijkstra's algorithm [7] is the best known algorithm for the problem in theory and the most robust in practice. The best currently known bounds for the problem, based on a combination of Dijkstra's algorithm and priority queue data structures, appear in <ref> [1, 3, 4, 8, 9, 18] </ref>. The running time of an implementation of Dijkstra's algorithm is dominated by arc scans (with each arc scanned at most once) and the priority queue operations insert, extract-min, and decrease-key.
References-found: 18

