URL: http://www.cs.caltech.edu/~heirich/euro97.ps.Z
Refering-URL: http://www.cs.caltech.edu/~heirich/heirich.html
Root-URL: http://www.cs.caltech.edu
Title: Parallel Rendering with an Actor Model  
Author: Alan Heirich James Arvo 
Address: Pasadena, CA 91125  
Affiliation: Department of Computer Science California Institute of Technology, 256-80  
Abstract: This paper describes an application of autonomous concurrent objects (Actors) to parallel rendering. The resulting rendering system is shown to be both scalable and portable. A parallel rendering application based on Monte Carlo path tracing is constructed using programming abstractions defined by the Actor model. This application is demonstrated to scale to hundreds of computers with efficiencies approaching 99%. The abstractions and the application are demonstrated to be portable across a range of parallel and distributed computer systems with various communications characteristics and topologies. A similar set of abstractions have been implemented in VLSI, suggesting that the entire rendering application could be realized by a special purpose systolic architecture.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Agha, G. </author> <title> Actors: a Model of Concurrent Computation in Distributed Systems. </title> <publisher> (1986) MIT Press. </publisher>
Reference-contexts: Shoreline, Mountain View, CA 94043 The Actor model has been widely explored as a model for object oriented programming in distributed systems <ref> [1, 2] </ref>. Actors are autonomous, concurrently executing objects that communicate by asynchronous message passing. Actors are intended to facilitate program construction by composition, and reasoning about the correctness of those composed programs.
Reference: 2. <author> Agha, G., Frolund, S., Kim, W. Y., Panwar, R., Patterson, A. & Sturman, D. </author> <title> "Abstractions and Modularity Mechanisms for Concurrent Computing". </title> <editor> In Agha et al, </editor> <booktitle> Research Directions in Concurrent Object Oriented Programming (1993) MIT Press, </booktitle> <pages> pp. 3-21. </pages>
Reference-contexts: Shoreline, Mountain View, CA 94043 The Actor model has been widely explored as a model for object oriented programming in distributed systems <ref> [1, 2] </ref>. Actors are autonomous, concurrently executing objects that communicate by asynchronous message passing. Actors are intended to facilitate program construction by composition, and reasoning about the correctness of those composed programs.
Reference: 3. <institution> Advanced Rendering Technology, Ltd. </institution> <note> "AR250 Ray Tracing Chip". http://www.art.co.uk/products/ar250.html (1997). </note>
Reference-contexts: Similar programming abstractions have been implemented in special purpose computer architectures and have shown scalability to thousands of processors [6, 7, 13]. A small number of projects have addressed the problem of designing special purpose VLSI to support ray tracing algorithms, some of which are reaching commercialization <ref> [3] </ref>. A VLSI implementation could potentially achieve real time rendering rates by virtue of massive parallelism. This parallelism will only be realized efficiently if the implementation is scalable, and this will require dynamic load balancing of ray casting operations among a set of distributed queues [10].
Reference: 4. <author> Anderson, T. E., Culler, D. E. & Patterson, D. A. </author> <title> A case for NOW (Networks of Workstations). </title> <booktitle> IEEE Micro 15 (1995) 54-64. </booktitle>
Reference-contexts: Because communication is asynchronous the correctness of concurrent Actor programs is unaffected by race conditions and other sources of sequential nondeterminacy. As a result these programs run correctly on platforms with widely varying communication characteristics, including workstation clusters, shared memory multiprocessors, and dedicated VLSI architectures <ref> [4, 7, 14, 15] </ref>. This paper describes an Actor implementation of a parallel rendering application based on Monte Carlo ray tracing [8]. Our goals in using an Actor model were to obtain portability and scalability.
Reference: 5. <author> Chandy, K. M. & Kesselman, C. </author> <title> "CC++: a Declarative Concurrent Object Oriented Programming Notation." </title> <editor> In Agha et al, </editor> <booktitle> Research Directions in Concurrent Object Oriented Programming (1993) MIT Press, </booktitle> <pages> pp. 281-313. </pages>
Reference-contexts: With a view toward VLSI implementation our focus has been on simplicity as well as scalability. The abstractions are defined as macros which may be invoked by programs written in ANSI C, C++, or derivatives such as CC++ (Concurrent C++) <ref> [5] </ref>. An actor has local state and implements a set of methods that are invoked when messages are sent to it. Each actor has an associated message queue into which all messages are received and in which they reside until processed.
Reference: 6. <author> Dally, W. J. et al. </author> <title> "Architecture of a Message Driven Processor." </title> <booktitle> Proc. 14th ACM/IEEE Symposium on Computer Architecture (1987), </booktitle> <pages> pp. 189-196. </pages>
Reference-contexts: In the longer term it is both interesting and fruitful to speculate about portability between software and VLSI. Similar programming abstractions have been implemented in special purpose computer architectures and have shown scalability to thousands of processors <ref> [6, 7, 13] </ref>. A small number of projects have addressed the problem of designing special purpose VLSI to support ray tracing algorithms, some of which are reaching commercialization [3]. A VLSI implementation could potentially achieve real time rendering rates by virtue of massive parallelism.
Reference: 7. <author> Dally, W. J. et al. </author> <title> "The J-Machine: a Fine Grain Concurrent Computer." </title> <booktitle> Proc. IFIP Congress (1989), </booktitle> <pages> pp. 1147-1153. </pages>
Reference-contexts: Because communication is asynchronous the correctness of concurrent Actor programs is unaffected by race conditions and other sources of sequential nondeterminacy. As a result these programs run correctly on platforms with widely varying communication characteristics, including workstation clusters, shared memory multiprocessors, and dedicated VLSI architectures <ref> [4, 7, 14, 15] </ref>. This paper describes an Actor implementation of a parallel rendering application based on Monte Carlo ray tracing [8]. Our goals in using an Actor model were to obtain portability and scalability. <p> In the longer term it is both interesting and fruitful to speculate about portability between software and VLSI. Similar programming abstractions have been implemented in special purpose computer architectures and have shown scalability to thousands of processors <ref> [6, 7, 13] </ref>. A small number of projects have addressed the problem of designing special purpose VLSI to support ray tracing algorithms, some of which are reaching commercialization [3]. A VLSI implementation could potentially achieve real time rendering rates by virtue of massive parallelism.
Reference: 8. <author> Heirich, A. & Arvo, J. </author> <title> Scalable Monte Carlo Image Synthesis. </title> <note> To appear in Parallel Computing (1997). </note>
Reference-contexts: As a result these programs run correctly on platforms with widely varying communication characteristics, including workstation clusters, shared memory multiprocessors, and dedicated VLSI architectures [4, 7, 14, 15]. This paper describes an Actor implementation of a parallel rendering application based on Monte Carlo ray tracing <ref> [8] </ref>. Our goals in using an Actor model were to obtain portability and scalability. These goals have been achieved, as the application has shown portability across a variety of shared memory and distributed parallel computer systems, and scalability to hundreds of computers.
Reference: 9. <author> Heirich, A. </author> <title> "A scalable diffusion algorithm for dynamic mapping and load balancing on networks of arbitrary topology." </title> <note> To appear in Intl. J. </note> <institution> Found. Comp. Sci. </institution> <year> (1997). </year>
Reference-contexts: The rendering application requires synchronization between frames and dynamic load balancing. In order to experiment with specific schemes for automatic mapping and load balancing we have imported the concept of dedicated channels from the paradigm of Communicating Sequential Processes <ref> [9, 10, 11] </ref>. This is a separate area of research that does not directly concern this paper nor restrict its conclusions. These conclusions can be safely generalized to Actor models that do not incorporate dedicated channels. <p> This is not strictly necessary.) Dynamic Load Balancing One of our original motives in developing the parallel rendering application was to experiment with solutions to the problems of mapping and load balancing in distributed systems <ref> [9, 10] </ref>. Load balancing among a homogeneous set of actors is particularly easy because it only requires transferring messages between queues. Message prioritization proved to be essential to achieving efficient dynamic load balancing. Dynamic load balancing is initiated by a rendering actor when it is starved for work.
Reference: 10. <author> Heirich, A. & Arvo, J. </author> <title> "A Competitive Analysis of Load Balancing Strategies for Parallel Ray Tracing." </title> <note> (unpublished) (1997). </note>
Reference-contexts: The rendering application requires synchronization between frames and dynamic load balancing. In order to experiment with specific schemes for automatic mapping and load balancing we have imported the concept of dedicated channels from the paradigm of Communicating Sequential Processes <ref> [9, 10, 11] </ref>. This is a separate area of research that does not directly concern this paper nor restrict its conclusions. These conclusions can be safely generalized to Actor models that do not incorporate dedicated channels. <p> This is not strictly necessary.) Dynamic Load Balancing One of our original motives in developing the parallel rendering application was to experiment with solutions to the problems of mapping and load balancing in distributed systems <ref> [9, 10] </ref>. Load balancing among a homogeneous set of actors is particularly easy because it only requires transferring messages between queues. Message prioritization proved to be essential to achieving efficient dynamic load balancing. Dynamic load balancing is initiated by a rendering actor when it is starved for work. <p> A VLSI implementation could potentially achieve real time rendering rates by virtue of massive parallelism. This parallelism will only be realized efficiently if the implementation is scalable, and this will require dynamic load balancing of ray casting operations among a set of distributed queues <ref> [10] </ref>. The topology of the necessary interconnection network is entirely local, and thus the system could be realized in a natural way by a scalable systolic architecture. <p> We have required only the core concepts from the Actor model, plus a message prioritization scheme and dynamic load balancing. Without load balancing the computation would still be correct but would not scale well <ref> [10] </ref>. In addition it has been useful to relax strict encapsulation of data on shared memory multiprocessors in order to avoid wasting memory.
Reference: 11. <author> Hoare, C. A. R. </author> <title> "Communicating Sequential Processes." </title> <booktitle> Comm. ACM 21 (1978), </booktitle> <pages> pp. 666-677. </pages>
Reference-contexts: The rendering application requires synchronization between frames and dynamic load balancing. In order to experiment with specific schemes for automatic mapping and load balancing we have imported the concept of dedicated channels from the paradigm of Communicating Sequential Processes <ref> [9, 10, 11] </ref>. This is a separate area of research that does not directly concern this paper nor restrict its conclusions. These conclusions can be safely generalized to Actor models that do not incorporate dedicated channels.
Reference: 12. <author> Kajiya, J. </author> <title> "The rendering equation." </title> <booktitle> Proc. ACM SIGGRAPH (1986) pp. </booktitle> <pages> 143-150. </pages>
Reference-contexts: The problem of global illumination is characterized by an integral equation known as the rendering equation <ref> [12] </ref>. This equation can be approximately solved by Monte Carlo methods. These methods estimate the intensity and wavelengths of light entering the lens of a simulated camera in a virtual environment. These quantities are estimated at discrete points in the image plane that correspond to pixels.
Reference: 13. <author> Keckler, S. W. & Dally, W. J. </author> <title> "Processor Coupling: Integrating Compile Time and Run Time Scheduling for Parallelism." </title> <booktitle> Proc. ACM 19th International Symposium on Computer Architecture (1992), </booktitle> <pages> pp. 202-213. </pages>
Reference-contexts: In the longer term it is both interesting and fruitful to speculate about portability between software and VLSI. Similar programming abstractions have been implemented in special purpose computer architectures and have shown scalability to thousands of processors <ref> [6, 7, 13] </ref>. A small number of projects have addressed the problem of designing special purpose VLSI to support ray tracing algorithms, some of which are reaching commercialization [3]. A VLSI implementation could potentially achieve real time rendering rates by virtue of massive parallelism.
Reference: 14. <author> Laudon, J. & Lenoski, D. </author> <title> "System overview of the SGI Origin 200/2000 product line". </title> <booktitle> Proc. IEEE CompCon (1997), </booktitle> <pages> pp. 150-156. </pages>
Reference-contexts: Because communication is asynchronous the correctness of concurrent Actor programs is unaffected by race conditions and other sources of sequential nondeterminacy. As a result these programs run correctly on platforms with widely varying communication characteristics, including workstation clusters, shared memory multiprocessors, and dedicated VLSI architectures <ref> [4, 7, 14, 15] </ref>. This paper describes an Actor implementation of a parallel rendering application based on Monte Carlo ray tracing [8]. Our goals in using an Actor model were to obtain portability and scalability.
Reference: 15. <author> Taubes, G. </author> <title> Do-it-yourself supercomputers. </title> <note> Science 274 (1996), p. 1840. </note>
Reference-contexts: Because communication is asynchronous the correctness of concurrent Actor programs is unaffected by race conditions and other sources of sequential nondeterminacy. As a result these programs run correctly on platforms with widely varying communication characteristics, including workstation clusters, shared memory multiprocessors, and dedicated VLSI architectures <ref> [4, 7, 14, 15] </ref>. This paper describes an Actor implementation of a parallel rendering application based on Monte Carlo ray tracing [8]. Our goals in using an Actor model were to obtain portability and scalability.
References-found: 15

