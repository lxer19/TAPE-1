URL: http://www.cs.cornell.edu/Info/People/mhr/papers/cycle-equiv.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/mhr/project.html
Root-URL: 
Title: Fully Dynamic Cycle-Equivalence in Graphs  
Author: Monika Rauch Henzinger 
Address: Ithaca, NY 14853  
Affiliation: Department of Computer Science Cornell University  
Note: to appear in Proceedings of FOCS 94  
Abstract: Two edges e 1 and e 2 of an undirected graph are cycle-equivalent iff all cycles that contain e 1 also contain e 2 , i.e., iff e 1 and e 2 are a cut-edge pair. The cycle-equivalence classes of the control-flow graph are used in optimizing compilers to speed up existing control-flow and data-flow algorithms. While the cycle-equivalence classes can be computed in linear time, we present the first fully dynamic algorithm for maintaining the cycle-equivalence relation. In an n-node graph our data structure executes an edge insertion or deletion in O( n log n) time and answers the query whether two given edges are cycle-equivalent in O(log 2 n) time. We also present an algorithm for plane graphs with O(log n) update and query time and for planar graphs with O(log n) insertion time and O(log 2 n) query and deletion time. Additionally, we show a lower bound of (log n= log log n) for the amortized time per operation for the dynamic cycle-equivalence problem in the cell probe model. p
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Alberts and M. Rauch Henzinger, </author> <title> Average Case Analysis of Dynamic Graph Algorithms. </title> <type> Technical Report 1994, </type> <institution> International Computer Science Institute, Berkeley, </institution> <address> CA. </address>
Reference-contexts: in potentially all O ( p clusters have to be updated, this technique allows us to update all data structures in time O ( p n log n): Later, the technique of fast non-tree updates has also been used to analyze and design dynamic algorithms in a random input model <ref> [1] </ref>. <p> We reduce the problem to the following parity prefix sum problem (PPS problem) for which a lower bound of (log n=(log log n + log b)) on the amortized time per operation is shown in [8]: Given an array A <ref> [1] </ref>; : : : ; A [n] of integers execute Add (l) and Sum (l) operations, where an Add (l) increases A [l] by 1 and a Sum (l) returns S l := ( 1il A [i]) mod 2.
Reference: [2] <author> D. Eppstein, G. F. Italiano, R. Tamassia, R. E. Tarjan, J. Westbrook, M. Yung, </author> <title> "Maintenance of a Minimum Spanning Forest in a Dynamic Planar Graph" J.Algorithms, </title> <booktitle> 13 (1992), </booktitle> <pages> 33-54. </pages>
Reference-contexts: Then we restore the graph. The best known dynamic connectivity algorithm in plane (=planar embedded) graphs takes O (log n) time per operation <ref> [2] </ref> solving the dynamic cycle-equivalence problem in plane graphs in time O (log n) time per operation.
Reference: [3] <author> D. Eppstein, Z. Galil, and G. F. </author> <type> Italiano "Improved Sparsification" Tech. Report 93-20, </type> <institution> Department of Information and Computer Science, University of California, </institution> <address> Irvine, CA 92717. </address>
Reference-contexts: Note that up to log n factors this is as efficient as the fastest known algorithm for the simpler problem of dynamically maintaining the connectivity relation, which requires O (1) query time and O ( p n) update time <ref> [3] </ref>. Dynamic cycle-equivalence is also interesting because of the relation to dynamic 3-edge connectivity: two edges e 1 and e 2 are cycle-equivalent iff (e 1 ; e 2 ) is a cut-edge pair (i.e., the removal of e 1 and e 2 disconnects the graph). <p> as efficient as the best known dynamic algorithms for the witness versions of the simpler problems of 2-edge connectivity: checking if an edge is a bridge witnessing that two given vertices u and v are not 2-edge connected requires O (log n) query time and O ( p update time <ref> [3] </ref>. We also present an algorithm for plane graphs with O (log n) time per operation and an algorithm for planar graphs with O (log 2 n) time per operation. <p> O (log n) query time; for 2-vertex connectivity, O ( p m) update time and O (1) query time [15]; for 3-edge connectivity, (n 2=3 ) update and query time [9]; for 3-vertex connectivity, (n) update time <ref> [3] </ref>; for 4-edge connectivity and 4-vertex connectivity, (nff (n)) update time [3]; for k-edge connectivity with constant k &gt; 4, (n log n) update time [4]. <p> O (log n) query time; for 2-vertex connectivity, O ( p m) update time and O (1) query time [15]; for 3-edge connectivity, (n 2=3 ) update and query time [9]; for 3-vertex connectivity, (n) update time <ref> [3] </ref>; for 4-edge connectivity and 4-vertex connectivity, (nff (n)) update time [3]; for k-edge connectivity with constant k &gt; 4, (n log n) update time [4]. Cycle-equivalence is not convex: two edges e 1 and e 2 can be cycle-equivalent without any other edge being cycle-equivalent to e 1 or e 2 . <p> To determine at update time all uncovered clusters we maintain a dynamic biconnectivity data structure <ref> [3, 15] </ref>. It is updated in O (m=k) time per insertion or deletion. Condition 3 and 4 The non-tree edges incident to C are in ET'-order if they are ordered in the ET-order of their endpoint in C (ambiguities are resolved in an arbitrary but fixed way).
Reference: [4] <author> D. Eppstein, Z. Galil, G. F. Italiano, A. Nis-senzweig, </author> <title> "Sparsification A technique for speeding up dynamic graph algorithms" Proc. </title> <booktitle> 33nd Annual Symp. on Foundations of Computer Science, </booktitle> <year> 1992, </year> <pages> 60-69. </pages>
Reference-contexts: update time and O (1) query time [15]; for 3-edge connectivity, (n 2=3 ) update and query time [9]; for 3-vertex connectivity, (n) update time [3]; for 4-edge connectivity and 4-vertex connectivity, (nff (n)) update time [3]; for k-edge connectivity with constant k &gt; 4, (n log n) update time <ref> [4] </ref>. Cycle-equivalence is not convex: two edges e 1 and e 2 can be cycle-equivalent without any other edge being cycle-equivalent to e 1 or e 2 .
Reference: [5] <author> D. Eppstein, Z. Galil, G. F. Italiano, and T. Spencer. </author> <title> "Separator based sparsification for dynamic planar graph algorithms". </title> <booktitle> Proc. 25th Annual Symp. on Theory of Computing, </booktitle> <year> 1993, </year> <pages> 208-217. </pages>
Reference-contexts: The best known dynamic con-nectivity algorithm in planar graphs takes O (log n) time per insertion or query and O (log 2 n) time per deletion <ref> [5] </ref> implying a solution for the dynamic cycle-equivalence problem in planar graphs in time O (log n) per insertion and O (log 2 n) per deletion.
Reference: [6] <author> G. N. Frederickson, </author> <title> "Data Structures for On-line Updating of Minimum Spanning Trees" SIAM J. </title> <journal> Comput. </journal> <volume> 14 (1985), </volume> <pages> 781-798. </pages>
Reference-contexts: For testing (2c), we maintain for every cluster ambivalent information and develop a variant of topology trees <ref> [6] </ref>, called lazy topology trees: each node in the topology tree is labeled, but after each update the labels of only a dynamically changing subset of the nodes are updated, even though the label value at all nodes can change. <p> Thus, it suffices to test the cycle-equivalence between two tree edges (Section 2.2) and the cycle-equivalence between a tree edge and a non-tree edge (Section 2.3). First (Section 2.1) we give some basic definition and data structures. 2.1 Basics We present first the topology trees data structure <ref> [6] </ref>. Given a graph G with spanning tree T we expand every vertex of G with degree d &gt; 3 into d vertices that are connected by a chain of d 1 edges. <p> There are only O (1) such clusters <ref> [6] </ref>. Computing the ambiv-values of a cluster takes time O (k). Thus, all ambiv-values are updated in time O (k). <p> Assume (3) that the label and the recipe can be built from the labels of the children of X in time O (t i (n; k)) if X is a level-i cluster. Then the update algorithm for T T in <ref> [6] </ref> maintains the labels of all clusters dynamically in time O ( P i (n; k)).
Reference: [7] <author> G. N. Frederickson, </author> <title> "Ambivalent data structures for dynamic 2-edge-connectivity and k smallest spanning trees" Proc. </title> <booktitle> 32nd Annual IEEE Sympos. </booktitle> <institution> on Foundation of Comput. Sci., </institution> <year> 1991, </year> <pages> 632-641. </pages>
Reference-contexts: non-tree edge; (2b) test the cycle-equivalence between a tree edge in the cluster and a tree edge outside of the cluster; and (2c) test the cycle equivalence between two tree edges in the cluster. (Two non-tree edge cannot be cycle-equivalent.) For testing (2a) we combine the ambivalent data structure of <ref> [7] </ref> with the recipe technique of [10]. <p> Since the degree of proj (e 0 ) is 3, the projection of an edge in other (e 0 ) is not proj (e 0 ). Data structure For each pair of clusters C and C 0 and each tree edge e incident to C we maintain ambivalent information <ref> [7] </ref> in the form of 3 non-tree edges ambiv i (C; C 0 ; e) for i = 1; 2; 3 (if they exist): Assuming that e lies on (C; C 0 ) let ambiv 1 (C; C 0 ; e) (ambiv 2 (C; C 0 ; e)) be the edge <p> Theorem 2.24 The presented data structure tests condition 3-5 in time O (log 2 n) and can be updated in time O ((k + m=k) log n): 2.3 The cycle-equivalence of a tree edge and a non-tree edge The ambivalent data structure of <ref> [7] </ref> tests if a tree edge is covered by at least one non-tree edge. <p> Assuming that e 2 (X; X 0 ) and that max 1 (X; X 0 ; e) does not exist, let max 2 (X; X 0 ; e) be the edge between X and X 0 that covers the most edges on T P (X). In <ref> [7] </ref> it sufficed to maintain max 1 . We maintain both max- labels and additional labels as in [7] that are necessary to guarantee that both max-labels fulfill Conditions (1) and (2) with t (n) = O (1). The same holds for the additional labebs. <p> In <ref> [7] </ref> it sufficed to maintain max 1 . We maintain both max- labels and additional labels as in [7] that are necessary to guarantee that both max-labels fulfill Conditions (1) and (2) with t (n) = O (1). The same holds for the additional labebs. Thus, all max-labels can be maintained in time O (k + m=k).
Reference: [8] <author> M. L. Fredman, and M. E. Saks, </author> <title> "The Cell Probe Complexity of Dynamic Data Structures", </title> <booktitle> Proc. 19th Annual Symp. on Theory of Computing, </booktitle> <year> 1989, </year> <pages> 345-354. </pages>
Reference-contexts: We reduce the problem to the following parity prefix sum problem (PPS problem) for which a lower bound of (log n=(log log n + log b)) on the amortized time per operation is shown in <ref> [8] </ref>: Given an array A [1]; : : : ; A [n] of integers execute Add (l) and Sum (l) operations, where an Add (l) increases A [l] by 1 and a Sum (l) returns S l := ( 1il A [i]) mod 2.
Reference: [9] <author> Z. Galil, G. F. </author> <title> Italiano, "Fully dynamic algorithms for 3-edge connectivity" , Manuscript. </title>
Reference-contexts: While the best known dynamic algorithm for testing 3-edge connectivity requires O (n 2=3 ) query and update time <ref> [9] </ref>, we can solve the witness version of 3-edge connectivity in O (log 2 n) query time and O ( n log n) update time: given two vertices u and v and two edges e 1 and e 2 , is (e 1 ; e 2 ) a cut-edge pair witnessing <p> O (log n) query time; for 2-vertex connectivity, O ( p m) update time and O (1) query time [15]; for 3-edge connectivity, (n 2=3 ) update and query time <ref> [9] </ref>; for 3-vertex connectivity, (n) update time [3]; for 4-edge connectivity and 4-vertex connectivity, (nff (n)) update time [3]; for k-edge connectivity with constant k &gt; 4, (n log n) update time [4].
Reference: [10] <author> J. Hershberger, M. Rauch, S. Suri, </author> <title> "Data structures for two-edge connectivity in Planar Graphs" Theoret. </title> <institution> Comput. Sci. </institution> <month> 130 </month> <year> (1994), </year> <pages> 139-161. </pages>
Reference-contexts: between a tree edge in the cluster and a tree edge outside of the cluster; and (2c) test the cycle equivalence between two tree edges in the cluster. (Two non-tree edge cannot be cycle-equivalent.) For testing (2a) we combine the ambivalent data structure of [7] with the recipe technique of <ref> [10] </ref>.
Reference: [11] <author> R. Gupta and M. L. Soffa, </author> <title> "Region scheduling" Proc. </title> <booktitle> 2nd International Conference on Supercomputing, </booktitle> <year> (1987), </year> <pages> 141-148. </pages>
Reference-contexts: A third application of the control-dependence equivalence relation is in global scheduling of instructions for pipelined machines <ref> [11] </ref>. In [13], a static algorithm is used that computes the cycle-equivalence relation in linear time. Then the question is posed if the cycle-equivalence relation can be maintained efficiently during modifications of the control-flow graph.
Reference: [12] <author> R. Johnson and K. Pingali, </author> <title> "Dependence-based program analysis" Proc. </title> <booktitle> Sigplan'93 PLDI, </booktitle> <pages> 78-89. </pages> <note> Published as ACM SIGPLAN Notices 28(6). </note>
Reference-contexts: Computing cycle-equivalence is central to many compilation problems, because the control-dependence equivalence relation of a program is the cycle-equivalence relation of the undirected version of the control-flow graph <ref> [12] </ref>. In particular, code-optimization algorithms, such as static single-assignment form construction, and data-flow analysis, such as determining the subexpression availability, can be sped up if the cycle-equivalence classes of the control-flow graph are known [13].
Reference: [13] <author> R. Johnson, D. Pearson, and K. Pingali, </author> <title> "Finding Regions Fast: Single Entry Single Exit and Control Regions in Linear Time." </title> <note> To appear in Proc. Sigplan'94 PLDI. </note>
Reference-contexts: In particular, code-optimization algorithms, such as static single-assignment form construction, and data-flow analysis, such as determining the subexpression availability, can be sped up if the cycle-equivalence classes of the control-flow graph are known <ref> [13] </ref>. A third application of the control-dependence equivalence relation is in global scheduling of instructions for pipelined machines [11]. In [13], a static algorithm is used that computes the cycle-equivalence relation in linear time. <p> algorithms, such as static single-assignment form construction, and data-flow analysis, such as determining the subexpression availability, can be sped up if the cycle-equivalence classes of the control-flow graph are known <ref> [13] </ref>. A third application of the control-dependence equivalence relation is in global scheduling of instructions for pipelined machines [11]. In [13], a static algorithm is used that computes the cycle-equivalence relation in linear time. Then the question is posed if the cycle-equivalence relation can be maintained efficiently during modifications of the control-flow graph. <p> We extend this data structure to test if a tree edge e 1 is covered by exactly one non-tree edge and, if so, which non-tree edge is covering e 1 : This is equivalent to testing the cycle-equivalence of e and a non-tree edge: Lemma 2.25 <ref> [13] </ref> A tree edge e 1 and a non-tree edge e 2 are cycle-equivalent iff e 2 is the only non-tree edge covering e 1 .
Reference: [14] <author> H. Nagamochi and T. Ibaraki. </author> <title> Linear time algo-rithms for finding a sparse k-connected spanning subgraph of a k-connected graph. </title> <journal> Algorithmica 7, </journal> <pages> pages 583 - 596, </pages> <year> 1992. </year>
Reference-contexts: of G, let T 0 (T 00 ) be a spanning forest of G n T (G n fT [ T 0 g), and let G 00 = T [T 0 [T 00 . (When refering to a tree edge, we mean an edge of T .) As shown in <ref> [14] </ref> two edges are a cut-edge pair in G iff they are a cut-edge pair in G 00 . Lemma 2.1 immediately implies the following lemma.
Reference: [15] <author> M. H. Rauch. </author> <title> "Improved Data Structures for Fully Dynamic Biconnectivity" to appear in Proc. </title> <booktitle> 26 Annual Symp. on Theory of Computing, </booktitle> <year> 1994. </year>
Reference-contexts: Convexity simplifies the design of dynamic algorithms: the best known dynamic algorithms for connectivity 2-edge connectivity require O ( p n) update time and O (1) resp. O (log n) query time; for 2-vertex connectivity, O ( p m) update time and O (1) query time <ref> [15] </ref>; for 3-edge connectivity, (n 2=3 ) update and query time [9]; for 3-vertex connectivity, (n) update time [3]; for 4-edge connectivity and 4-vertex connectivity, (nff (n)) update time [3]; for k-edge connectivity with constant k &gt; 4, (n log n) update time [4]. <p> To determine at update time all uncovered clusters we maintain a dynamic biconnectivity data structure <ref> [3, 15] </ref>. It is updated in O (m=k) time per insertion or deletion. Condition 3 and 4 The non-tree edges incident to C are in ET'-order if they are ordered in the ET-order of their endpoint in C (ambiguities are resolved in an arbitrary but fixed way). <p> n=k (log log n+ log b)) on the amortized time per operation for the fully dynamic cycle-equivalence problem in plane and planar graphs where b indicates the wordsize in Yao's cell probe model [17]. (Note that this implies a bound for general graphs.) The lower bound construction is similar to <ref> [15] </ref>.
Reference: [16] <author> D. D. Sleator, R. E. Tarjan, </author> <title> "A Data Structure for Dynamic Trees" J. </title> <journal> Comput. System Sci. </journal> <volume> 24 (1983), </volume> <pages> 362-381. </pages>
Reference-contexts: each cluster C consists of 2 parts: (1) We keep a balanced search tree of all edges incident to C in ET-order. (2) We keep the following data structure for fast non-tree updates FAST (C): We maintain the minimum spanning tree of G (C) in a dynamic tree data structure <ref> [16] </ref> and keep for each tree edge the coverage number, the number of non-tree edges covering it. Every insertion or deletion of an edge (a; b) increases or decreases the coverage number of all edges on (a; b) by one. Thus, it takes time O (log n).
Reference: [17] <author> A. Yao, </author> <title> "Should tables be sorted", </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 28(3), </volume> <year> 1981, </year> <pages> 615-628. </pages>
Reference-contexts: Additionally, we show a lower bound of (log n= log log n) on the amortized time per operation for the dynamic cycle-equivalence problem in Yao's cell probe model <ref> [17] </ref>. This is the most general model for lower bounds and encompasses all RAM algorithms. All three bounds match the best known bounds for the dynamic connectivity problem. <p> We also show a lower bound of (log n=k (log log n+ log b)) on the amortized time per operation for the fully dynamic cycle-equivalence problem in plane and planar graphs where b indicates the wordsize in Yao's cell probe model <ref> [17] </ref>. (Note that this implies a bound for general graphs.) The lower bound construction is similar to [15].
References-found: 17

