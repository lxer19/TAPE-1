URL: ftp://db.stanford.edu/pub/papers/cube-maint-sigmod.ps
Refering-URL: http://www.cs.toronto.edu/~mendel/dwbib.html
Root-URL: 
Email: mumick@research.att.com  quass@cs.stanford.edu  bmumick@lucent.com  
Title: Maintenance of Data Cubes and Summary Tables in a Warehouse issues relating to choosing and
Author: Inderpal Singh Mumick Dallan Quass Barinderpal Singh Mumick 
Note: While several papers have addressed the  this is the first paper to address maintaining summary tables efficiently.  
Affiliation: AT&T Laboratories  Stanford University  Lucent Technologies  
Abstract: As changes, most notably new transactional data, are collected at the data sources, all summary tables at the warehouse that depend upon this data need to be updated. Usually, source changes are loaded into the warehouse at regular intervals, usually once a day, in a batch window, and the warehouse is made unavailable for querying while it is updated. Since the number of summary tables that need to be maintained is often large, a critical issue for data warehousing is how to maintain the summary tables efficiently. In this paper we propose a method of maintaining aggregate views (the summary-delta table method), and use it to solve two problems in maintaining summary tables in a warehouse: (1) how to efficiently maintain a summary table while minimizing the batch window needed for maintenance, and (2) how to maintain a large set of summary tables defined over the same base tables. 
Abstract-found: 1
Intro-found: 1
Reference: [AAD + 96] <author> S. Agarwal, R. Agrawal, P. Deshpande, A. Gupta, J. Naughton, R. Ramakrishnan, and S. Sarawagi. </author> <title> On the computation of multidimensional aggregates. </title> <editor> In Vijayaraman et al. </editor> <booktitle> [TMB96], </booktitle> <pages> pages 506-521. </pages>
Reference-contexts: The problem now is how to compute the summary-delta lattice efficiently, since there are possibly several choices for ancestor summary-delta tables from which to compute a summary-delta. It turns out that that this problem maps directly to the problem of computing multiple summary tables from scratch, as addressed in <ref> [AAD + 96, SAG96] </ref>. We can use their solutions to derive an efficient propagate strategy on how to sort/hash inputs, what order to evaluate summary-delta tables, and which of the incoming lattice edges (if there is more than one) to use to evaluate a summary-delta table. <p> in <ref> [AAD + 96, SAG96] </ref>. We can use their solutions to derive an efficient propagate strategy on how to sort/hash inputs, what order to evaluate summary-delta tables, and which of the incoming lattice edges (if there is more than one) to use to evaluate a summary-delta table. The algorithms of [AAD + 96, SAG96] would be directly applicable but for the fact that they do not consider join annotations in the lattice. <p> Algorithms to efficiently materialize all or a subset of the cube lattice have been proposed by <ref> [AAD + 96, SAG96] </ref>. Next, we need a technique to maintain these cube views efficiently, and our paper provides the summary-delta table method to do so. In fact, we even map a part of the maintenance problem into the problem addressed by [AAD + 96, SAG96]. <p> of the cube lattice have been proposed by <ref> [AAD + 96, SAG96] </ref>. Next, we need a technique to maintain these cube views efficiently, and our paper provides the summary-delta table method to do so. In fact, we even map a part of the maintenance problem into the problem addressed by [AAD + 96, SAG96]. Our algorithms are geared towards cube views, as well as towards generalizations of cube views that are likely to occur in typical decision-support systems.
Reference: [AL80] <author> M. Adiba and B. Lindsay. </author> <title> Database snapshots. </title> <booktitle> In Proceedings of the sixth International Conference on Very Large Databases, </booktitle> <pages> pages 86-91, </pages> <address> Montreal, Canada, </address> <month> October </month> <year> 1980. </year>
Reference: [BC79] <author> P. Buneman and E. Clemons. </author> <title> Efficiently monitoring relational databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(3) </volume> <pages> 368-382, </pages> <month> September </month> <year> 1979. </year>
Reference: [BLT86] <author> J. Blakeley, P. Larson, and F. Tompa. </author> <title> Efficiently Updating Materialized Views. </title> <booktitle> In Proceedings of ACM SIGMOD 1986 International Conference on Management of Data, </booktitle> <pages> pages 61-71, </pages> <month> May </month> <year> 1986. </year>
Reference: [CGL + 96] <author> L. Colby, T. Griffin, L. Libkin, I. Mumick, and H. Trickey. </author> <title> Algorithms for deferred view maintenance. </title> <note> In Jagadish and Mumick [JM96]. </note>
Reference-contexts: The summary-delta tables method represents a new paradigm for incremental view maintenance. * A general strategy to minimize the batch time needed for maintenance is to split the maintenance work into propagate and refresh functions <ref> [CGL + 96] </ref>. Propagate can occur outside the batch window, while refresh occurs inside the batch window. <p> It is worth noting that the previous papers do not consider the problem of maintaining multiple aggregate views, and are not as efficient as the summary-delta table method. A formal split of the maintenance process into propagate and refresh functions was proposed in <ref> [CGL + 96] </ref>. We build on the propagate/refresh idea here, extending it to aggregate views and to more complex refresh functions.
Reference: [CS94] <author> S. Chaudhuri and K. Shim. </author> <title> Including groupby in query optimization. </title> <booktitle> In Proceedings of the 20 th International Conference on Very Large Databases, </booktitle> <pages> pages 354-366, </pages> <address> Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: The decision of whether or not to pre-aggregate could be made in a cost-based manner by a query optimizer. The notion of pre-aggregation follows essentially from the idea of pushing down aggregation presented in <ref> [CS94, GHQ95, YL95] </ref>. 4.1.4 Changes to dimension tables Up to now we have considered changes only to the fact table. Changes to the dimension tables can also be incorporated into our method. Due to space constraints we will only give the intuition underlying the technique.
Reference: [CS95] <editor> M. Carey and D. Schneider, editors. </editor> <booktitle> Proceedings of ACM SIGMOD 1995 International Conference on Management of Data, </booktitle> <address> San Jose, CA, </address> <month> May 23-25 </month> <year> 1995. </year>
Reference: [CW91] <author> S. Ceri and J. Widom. </author> <title> Deriving production rules for incremental view maintenance. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Databases, </booktitle> <pages> pages 108-119, </pages> <address> Spain, </address> <month> September </month> <year> 1991. </year>
Reference: [DGN95] <editor> U. Dayal, P. Gray, and S. Nishio, editors. </editor> <booktitle> Proceedings of the 21 st International Conference on Very Large Databases, </booktitle> <address> Zurich, Switzerland, </address> <month> September 11-15 </month> <year> 1995. </year>
Reference: [GBLP96] <author> J. Gray, A. Bosworth, A. Layman, and H. Pirahesh. </author> <title> Data cube: A relational aggregation operator generalizing group-by, </title> <booktitle> cross-tab, and sub-total. In Proceedings of the Twelfth IEEE International Conference on Data Engineering, </booktitle> <pages> pages 152-159, </pages> <address> New Orleans, LA, </address> <month> February 26 March 1 </month> <year> 1996. </year>
Reference-contexts: The summary tables group the base data along various dimensions, corresponding to different sets of group-by attributes, and compute various aggregate functions, often called measures. As an example, the cube operator <ref> [GBLP96] </ref> can be used to define several such summary tables with one statement. As changes are made to the data sources, the warehouse views must be updated to reflect the changed state of the data sources. <p> For example, the name SiC sales implies that storeID and category are the group-by attributes in the view definition. The views of Figure 1 could represent four of the possible points on a "data cube" as described in <ref> [GBLP96] </ref>, except for the use of date as both a dimension and a measure. Another difference between this paper and previous work on data cubes is that in previous work the data being aggregated comes solely from the fact table, with dimension hierarchy information obtained implicitly. <p> 4.2 we show how the refresh function handles MIN and MAX aggregate functions. 3 Background and Notation In this section we review the concepts of self-maintainable aggregate functions (Section 3.1), data cube (Section 3.2), and the computation lattice corresponding to a data cube (Section 3.3). 3.1 Self-maintainable aggregate functions In <ref> [GBLP96] </ref>, aggregate functions are divided three classes: distributive, algebraic, and holistic. Distributive aggregate functions can be computed by partitioning their input into disjoint sets, aggregating each set individually, then further aggregating the (partial) results from each set into the final result. <p> = 0, then MIN (E)= null), but COUNT (E) also cannot make MIN and MAX self-maintainable (if Count (*) &gt; 0 and COUNT (E) &gt; 0, and a tuple having minimum (maximum) value is deleted, then we need to look up the base table). 3.2 Data cube The date cube <ref> [GBLP96] </ref> is a convenient way of thinking about multiple aggregate views, all derived from a fact table using different sets of group-by attributes. Data cubes are popular in OLAP because they provide an intuitive way for data analysts to navigate various levels of summary information in the database. <p> We build on the propagate/refresh idea here, extending it to aggregate views and to more complex refresh functions. Our notion of self-maintainable aggregation functions is an extension of self-maintainability for select-project-join views defined in [GJM96, QGMW96]. <ref> [GBLP96] </ref> proposed the cube operator linking together related aggregate tables into one SQL query, and started a mini-industry in warehousing research.
Reference: [GHQ95] <author> A. Gupta, V. Harinarayan, and D. Quass. </author> <title> Generalized projections: A powerful approach to aggregation. </title> <editor> In Dayal et al. </editor> <publisher> [DGN95]. </publisher>
Reference-contexts: The decision of whether or not to pre-aggregate could be made in a cost-based manner by a query optimizer. The notion of pre-aggregation follows essentially from the idea of pushing down aggregation presented in <ref> [CS94, GHQ95, YL95] </ref>. 4.1.4 Changes to dimension tables Up to now we have considered changes only to the fact table. Changes to the dimension tables can also be incorporated into our method. Due to space constraints we will only give the intuition underlying the technique.
Reference: [GJM96] <author> A. Gupta, H. Jagadish, and I. Mumick. </author> <title> Data integration using self-maintainable views. </title> <booktitle> In Proceedings of the Fifth International Conference on Extending Database Technology, </booktitle> <address> Avignon, France, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: We build on the propagate/refresh idea here, extending it to aggregate views and to more complex refresh functions. Our notion of self-maintainable aggregation functions is an extension of self-maintainability for select-project-join views defined in <ref> [GJM96, QGMW96] </ref>. [GBLP96] proposed the cube operator linking together related aggregate tables into one SQL query, and started a mini-industry in warehousing research.
Reference: [GL95] <author> T. Griffin and L. Libkin. </author> <title> Incremental maintenance of views with duplicates. </title> <note> In Carey and Schneider [CS95]. </note>
Reference-contexts: Changes to the dimension tables can also be incorporated into our method. Due to space constraints we will only give the intuition underlying the technique. Applying the incremental view-maintenance techniques of <ref> [GMS93, GL95] </ref>, we can start with the changes to a dimension table, and derive dimension-table-specific prepare-insertions and prepare-deletions views that represent the changes to the aggregate functions due to changes to the dimension table. <p> The actual refresh of the materialized view is more complex than a union/difference in the delta paradigm, and can cause updates, insertions, and/or deletions to the materialized view. Amongst the above work on view maintenance algorithms, <ref> [GMS93, GL95, JMS95, Qua96] </ref> are the only papers that discuss maintenance algorithms for aggregate views. [GMS93, GL95, Qua96] develop algorithms to compute sets of inserted and deleted tuples into an aggregate view, while [JMS95] discusses the computational complexity of immediately maintaining a single aggregate view in response to a single insertion <p> Amongst the above work on view maintenance algorithms, [GMS93, GL95, JMS95, Qua96] are the only papers that discuss maintenance algorithms for aggregate views. <ref> [GMS93, GL95, Qua96] </ref> develop algorithms to compute sets of inserted and deleted tuples into an aggregate view, while [JMS95] discusses the computational complexity of immediately maintaining a single aggregate view in response to a single insertion into a chronicle (sequence of tuples).
Reference: [GMS93] <author> A. Gupta, I. Mumick, and V. Subrahmanian. </author> <title> Maintaining views incrementally. </title> <booktitle> In Proceedings of ACM SIGMOD 1993 International Conference on Management of Data, </booktitle> <address> Washington, DC, </address> <month> May 26-28 </month> <year> 1993. </year>
Reference-contexts: Changes to the dimension tables can also be incorporated into our method. Due to space constraints we will only give the intuition underlying the technique. Applying the incremental view-maintenance techniques of <ref> [GMS93, GL95] </ref>, we can start with the changes to a dimension table, and derive dimension-table-specific prepare-insertions and prepare-deletions views that represent the changes to the aggregate functions due to changes to the dimension table. <p> The actual refresh of the materialized view is more complex than a union/difference in the delta paradigm, and can cause updates, insertions, and/or deletions to the materialized view. Amongst the above work on view maintenance algorithms, <ref> [GMS93, GL95, JMS95, Qua96] </ref> are the only papers that discuss maintenance algorithms for aggregate views. [GMS93, GL95, Qua96] develop algorithms to compute sets of inserted and deleted tuples into an aggregate view, while [JMS95] discusses the computational complexity of immediately maintaining a single aggregate view in response to a single insertion <p> Amongst the above work on view maintenance algorithms, [GMS93, GL95, JMS95, Qua96] are the only papers that discuss maintenance algorithms for aggregate views. <ref> [GMS93, GL95, Qua96] </ref> develop algorithms to compute sets of inserted and deleted tuples into an aggregate view, while [JMS95] discusses the computational complexity of immediately maintaining a single aggregate view in response to a single insertion into a chronicle (sequence of tuples).
Reference: [Han87] <author> E. Hanson. </author> <title> A performance analysis of view materialization strategies. </title> <booktitle> In Proceedings of ACM SIGMOD 1987 International Conference on Management of Data, </booktitle> <pages> pages 440-453, </pages> <address> San Francisco, CA, </address> <month> May </month> <year> 1987. </year>
Reference: [HRU96] <author> V. Harinarayan, A. Rajaraman, and J. Ullman. </author> <title> Implementing data cubes efficiently. </title> <booktitle> In Jagadish and Mumick [JM96], </booktitle> <pages> pages 205-216. </pages>
Reference-contexts: queries quickly, a warehouse will often store a number of summary tables, which are materialized views that aggregate the data in the fact table, possibly after joining it with one or more dimension tables. chosen to be materialized, either by the database administrator, or by using an algorithm such as <ref> [HRU96] </ref>. Note that the names of the views have been chosen to reflect the group-by attributes. The character S represents storeID, I represents itemID, and D represents date. <p> EXAMPLE 3.1 An example data cube for the pos table of Section 2 is shown in Figure 4 as a lattice structure. Construction of the lattice corresponding to a data cube was first introduced in <ref> [HRU96] </ref>. The dimension attributes of the data cube are storeID, itemID, and date, and the measures are COUNT (*) and SUM (qty). Since the measures computed are assumed to be the same, each point in the figure is annotated simply by the group-by attributes. <p> It turns out that a direct product of the lattice for the fact table along with the lattices for the dimension hierarchies yields the desired result <ref> [HRU96] </ref>. <p> The notion of cube lattices and dimension lattices was proposed in <ref> [HRU96] </ref>, along with an algorithm to determine a subset of cube views to be materialized so as to maximize the querying benefit under a given space constraint. Algorithms to efficiently materialize all or a subset of the cube lattice have been proposed by [AAD + 96, SAG96].
Reference: [HZ96] <author> R. Hull and G. Zhou. </author> <title> A framework for supporting data integration using the materialized and virtual approaches. </title> <note> In Jagadish and Mumick [JM96]. </note>
Reference: [JM96] <editor> H. Jagadish and I. Mumick, editors. </editor> <booktitle> Proceedings of ACM SIGMOD 1996 International Conference on Management of Data, </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1996. </year>
Reference: [JMS95] <author> H. Jagadish, I. Mumick, and A. Silberschatz. </author> <title> View maintenance issues in the chronicle data model. </title> <booktitle> In Proceedings of the Fourteenth Symposium on Principles of Database Systems (PODS), </booktitle> <address> San Jose, CA, </address> <year> 1995. </year>
Reference-contexts: The actual refresh of the materialized view is more complex than a union/difference in the delta paradigm, and can cause updates, insertions, and/or deletions to the materialized view. Amongst the above work on view maintenance algorithms, <ref> [GMS93, GL95, JMS95, Qua96] </ref> are the only papers that discuss maintenance algorithms for aggregate views. [GMS93, GL95, Qua96] develop algorithms to compute sets of inserted and deleted tuples into an aggregate view, while [JMS95] discusses the computational complexity of immediately maintaining a single aggregate view in response to a single insertion <p> Amongst the above work on view maintenance algorithms, [GMS93, GL95, JMS95, Qua96] are the only papers that discuss maintenance algorithms for aggregate views. [GMS93, GL95, Qua96] develop algorithms to compute sets of inserted and deleted tuples into an aggregate view, while <ref> [JMS95] </ref> discusses the computational complexity of immediately maintaining a single aggregate view in response to a single insertion into a chronicle (sequence of tuples).
Reference: [LMSS95] <author> J. Lu, G. Moerkotte, J. Schu, and V. Subrahmanian. </author> <title> Efficient maintenance of materialized mediated views. </title> <note> In Carey and Schneider [CS95]. </note>
Reference: [MS93] <author> J. Melton and A. Simon. </author> <title> Understanding the New SQL: A Complete Guide. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: The aggregate-source attributes are derived according to Table 1. The column labeled prepare-insertions describes how they are derived for the prepare-insertions view; the column labeled prepare-deletions describes how they are derived for the prepare-deletions view. The COUNT (expr) row uses the SQL-92 case statement <ref> [MS93] </ref>. prepare-insertions prepare-deletions COUNT (*) 1 1 COUNT (expr) case when expr is case when expr is null then 0 else 1 null then 0 else 1 SUM (expr) expr expr MIN (expr) expr expr MAX (expr) expr expr Table 1: Deriving aggregate-source attributes EXAMPLE 4.1 Consider the SiC sales view
Reference: [QGMW96] <author> D. Quass, A. Gupta, I. Mumick, and J. Widom. </author> <title> Making views self-maintainable for data warehousing. </title> <booktitle> In Proceedings of the Fourth International Conference on Parallel and Distributed Information Systems (PDIS), </booktitle> <address> Miami Beach, FL, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: We build on the propagate/refresh idea here, extending it to aggregate views and to more complex refresh functions. Our notion of self-maintainable aggregation functions is an extension of self-maintainability for select-project-join views defined in <ref> [GJM96, QGMW96] </ref>. [GBLP96] proposed the cube operator linking together related aggregate tables into one SQL query, and started a mini-industry in warehousing research.
Reference: [Qua96] <author> D. Quass. </author> <title> Maintenance expressions for views with aggregation. </title> <booktitle> Presented at the Workshop on Materialized Views, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: The actual refresh of the materialized view is more complex than a union/difference in the delta paradigm, and can cause updates, insertions, and/or deletions to the materialized view. Amongst the above work on view maintenance algorithms, <ref> [GMS93, GL95, JMS95, Qua96] </ref> are the only papers that discuss maintenance algorithms for aggregate views. [GMS93, GL95, Qua96] develop algorithms to compute sets of inserted and deleted tuples into an aggregate view, while [JMS95] discusses the computational complexity of immediately maintaining a single aggregate view in response to a single insertion <p> Amongst the above work on view maintenance algorithms, [GMS93, GL95, JMS95, Qua96] are the only papers that discuss maintenance algorithms for aggregate views. <ref> [GMS93, GL95, Qua96] </ref> develop algorithms to compute sets of inserted and deleted tuples into an aggregate view, while [JMS95] discusses the computational complexity of immediately maintaining a single aggregate view in response to a single insertion into a chronicle (sequence of tuples).
Reference: [Qua97] <author> D. Quass. </author> <title> Materialized Views in Data Warehouses. </title> <type> PhD thesis, </type> <institution> Stanford University, Department of Computer Science, </institution> <year> 1997. </year>
Reference-contexts: The theorem gives us the desired D-lattice. (A proof of the theorem appears in <ref> [Qua97] </ref>.) Theorem 5.1 The D-lattice is identical to the V-lattice, including the queries along each edge, modulo a change in the names of tables at each node.
Reference: [QW91] <author> X. Qian and G. Wiederhold. </author> <title> Incremental recomputation of active relational expressions. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 3(3) </volume> <pages> 337-341, </pages> <year> 1991. </year>
Reference: [RK86] <author> N. Roussopoulos and H. Kang. </author> <booktitle> Principles and techniques in the design of ADMS+. IEEE Computer, </booktitle> <pages> pages 19-25, </pages> <month> December </month> <year> 1986. </year>
Reference: [SAG96] <author> S. Sarawagi, R. Agrawal, and A. Gupta. </author> <title> On computing the data cube. </title> <type> Research report rj 10026, </type> <institution> IBM Al-maden Research Center, </institution> <address> San Jose, California, </address> <year> 1996. </year>
Reference-contexts: The problem now is how to compute the summary-delta lattice efficiently, since there are possibly several choices for ancestor summary-delta tables from which to compute a summary-delta. It turns out that that this problem maps directly to the problem of computing multiple summary tables from scratch, as addressed in <ref> [AAD + 96, SAG96] </ref>. We can use their solutions to derive an efficient propagate strategy on how to sort/hash inputs, what order to evaluate summary-delta tables, and which of the incoming lattice edges (if there is more than one) to use to evaluate a summary-delta table. <p> in <ref> [AAD + 96, SAG96] </ref>. We can use their solutions to derive an efficient propagate strategy on how to sort/hash inputs, what order to evaluate summary-delta tables, and which of the incoming lattice edges (if there is more than one) to use to evaluate a summary-delta table. The algorithms of [AAD + 96, SAG96] would be directly applicable but for the fact that they do not consider join annotations in the lattice. <p> Algorithms to efficiently materialize all or a subset of the cube lattice have been proposed by <ref> [AAD + 96, SAG96] </ref>. Next, we need a technique to maintain these cube views efficiently, and our paper provides the summary-delta table method to do so. In fact, we even map a part of the maintenance problem into the problem addressed by [AAD + 96, SAG96]. <p> of the cube lattice have been proposed by <ref> [AAD + 96, SAG96] </ref>. Next, we need a technique to maintain these cube views efficiently, and our paper provides the summary-delta table method to do so. In fact, we even map a part of the maintenance problem into the problem addressed by [AAD + 96, SAG96]. Our algorithms are geared towards cube views, as well as towards generalizations of cube views that are likely to occur in typical decision-support systems.
Reference: [SI84] <author> O. Shmueli and A. Itai. </author> <title> Maintenance of Views. </title> <booktitle> In Proceedings of ACM SIGMOD 1984 International Conference on Management of Data, </booktitle> <pages> pages 240-255, </pages> <year> 1984. </year>
Reference: [SP89] <author> A. Segev and J. Park. </author> <title> Updating distributed materialized views. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(2) </volume> <pages> 173-184, </pages> <month> June </month> <year> 1989. </year>
Reference: [TMB96] <editor> T. Vijayaraman, C. Mohan, and A. Buchman, editors. </editor> <booktitle> Proceedings of the 22 nd International Conference on Very Large Databases, </booktitle> <address> Mumbai, India, </address> <month> September 3-6 </month> <year> 1996. </year>
Reference: [YL95] <author> W. Yan and P. Larson. </author> <title> Eager aggregation and lazy aggregation. </title> <editor> In Dayal et al. </editor> <booktitle> [DGN95], </booktitle> <pages> pages 345-357. </pages>
Reference-contexts: The decision of whether or not to pre-aggregate could be made in a cost-based manner by a query optimizer. The notion of pre-aggregation follows essentially from the idea of pushing down aggregation presented in <ref> [CS94, GHQ95, YL95] </ref>. 4.1.4 Changes to dimension tables Up to now we have considered changes only to the fact table. Changes to the dimension tables can also be incorporated into our method. Due to space constraints we will only give the intuition underlying the technique.
Reference: [ZGHW95] <author> Y. Zhuge, H. Garcia-Molina, J. Hammer, and J. Widom. </author> <title> View maintenance in a warehousing environment. </title> <booktitle> In Carey and Schneider [CS95], </booktitle> <pages> pages 316-327. </pages>
References-found: 32

