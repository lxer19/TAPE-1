URL: http://www.math.tau.ac.il/~megiddo/psfiles/kmnys.ps.gz
Refering-URL: http://www.math.tau.ac.il/~megiddo/pub.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: A Unified Approach to Interior Point Algorithms for Linear Complementarity Problems: A Summary  
Author: Masakazu Kojima Nimrod Megiddo Toshihito Noma Akiko Yoshise 
Keyword: interior-point methods, complementarity, linear programming, quadratic programming, path-following, potential reduction  
Date: Revised October 1990  
Abstract: This note summarizes a report with the same title, where a study was carried out regarding a unified approach, proposed by Kojima, Mizuno and Yoshise, for interior point algorithms for the linear complementarily problem with a positive semi-definite matrix. This approach is extended to nonsymmetric matrices with nonnegative principal minors. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. R. Barnes. </author> <title> A variation on Karmarkar's algorithm for solving linear programming problems. </title> <journal> Math. Programming, </journal> <volume> 36 </volume> <pages> 174-182, </pages> <year> 1986. </year>
Reference-contexts: The system (3.8) involves the parameter fi 2 <ref> [0; 1] </ref>. Let the point (x 0 ; y 0 ) on S cen denote the solution of the system of equations (3.8). <p> can be represented as a convex combination of the centering direction (dx c ; dy c ) and the affine scaling direction (dx a ; dy a ). (dx; dy) = fi (dx c ; dy c ) + (1 fi)(dx a ; dy a ): (3:9) For fi 2 <ref> [0; 1] </ref>, it can be shown that (dx; dy) is a descent direction of f . Henceforth we assume an initial point (x 1 ; y 1 ) 2 S ++ is available, and the initial value of the potential function is not greater than a certain constant. <p> The UIP Method. Step 1: Let k = 1 and * &gt; 0. Step 2: Let (x; y) = (x k ; y k ). Stop if the inequality x T y * is satisfied. Step 3: Let fi = fi k 2 <ref> [0; 1] </ref>. Solve the system (3.7) for a search direction (dx; dy). Step 4: Choose = k 0 so that (x; y) + (dx; dy) 2 S ++ [ S cp . Let the new point be ( x; y) = (x; y) + (dx; dy). <p> In theory we choose * = 2 2L so that a solution of the LCP can be computed from the terminal point of the UIP method (see [ 10 ] ). The UIP method involves two parameters: fi 2 <ref> [0; 1] </ref> and 0. The parameter fi and the current point (x k ; y k ) determine the direction (dx; dy) toward the new iterate (x k+1 ; y k+1 ), while 0 controls the step length. <p> The algorithm may also be regarded as an affine scaling interior point algorithm for the LCP because the search direction at each iteration involves no centering force as in the affine scaling interior point algorithms for linear programs ( <ref> [ 1; 5; 24 ] </ref> , etc.). We acknowledge a conversation with I. Lustig on this subject. The global convergence of the algorithm presented here does not rely on nondegeneracy assumptions, while the global convergence of the affine scaling algorithms for linear programs has been established under such assumptions.
Reference: [2] <author> E. R. Barnes, S. Chopra and D. L. Jensen. </author> <title> A polynomial time version of the affine algorithm. </title> <type> Tech. Rep., </type> <institution> IBM T. J. Watson Res. Ctr., </institution> <address> Yorktown Heights, N.Y., </address> <year> 1988. </year>
Reference-contexts: that 0 fi fi cen if f cen (x; y) &lt; ff cen ; fi bd fi 1 if ff 1 &lt; f cen (x; y): &gt; = (5:11) The idea of taking a larger fi 1 when the current point is far from the central trajectory was proposed in <ref> [ 2 ] </ref> (See also [ 26; 27; 14 ] .). The vector (dx; dy) depends on the value of fi. The function f = -f cp +f cen facilitates the choice of = k for the step length.
Reference: [3] <author> S. J. Chung. </author> <title> A note on the complexity of the LCP: the LCP is strongly NP-complete. </title> <type> Tech. Rep. 792, </type> <institution> Dept. of Industrial and Operations Engineering, Univ. of Michigan, </institution> <address> Ann Arbor, MI, </address> <year> 1979. </year>
Reference-contexts: San Jose, CA 95120, and School of Mathematical Sciences, Tel Aviv University, Tel Aviv, Israel. z Department of Systems Science, Tokyo Institute of Technology, Oh-Okayama, Meguro-ku, Tokyo 152, Japan. x Graduate School of Systems Management, The University of Tsukuba, Otsuka, Bunkyo-ku, Tokyo 112, Japan. 1 The general LCP is NP-complete <ref> [ 3 ] </ref> . In [ 10 ] we assume M to be in the rich class P 0 of matrices with nonnegative principal minors. This class includes not only skew-symmetric matrices, p.s.d. matrices and P -matrices, but also NP-complete LCP's.
Reference: [4] <author> R. W. Cottle, J.-S. Pang and V. Venkateswaran. </author> <title> Sufficient matrices and the linear complementarity problem. </title> <journal> Linear Algebra and Its Applications, </journal> 114/115:231-249, 1989. 
Reference-contexts: S CS : "column sufficient" matrices <ref> [ 4 ] </ref> , characterized by the condition that ~ i [M ~] i 0 (i 2 N ) always implies ~ i [M ~] i (i 2 N ).
Reference: [5] <author> I. I. Dikin. </author> <title> Iterative solution of problems of linear and quadratic programming. </title> <journal> Soviet Math. Dokl., </journal> <volume> 8 </volume> <pages> 674-675, </pages> <year> 1967. </year> <month> 10 </month>
Reference-contexts: Specifically, we do not cover algorithms which work only on either primal or dual space <ref> [ 5; 8; 18 ] </ref> , the O ( nL) iteration potential reduction algorithms of [ 25; 7 ] , the first potential reduction algorithm given in [ 11 ] for P 0 case. We summarize the main results of [ 10 ] . <p> The algorithm may also be regarded as an affine scaling interior point algorithm for the LCP because the search direction at each iteration involves no centering force as in the affine scaling interior point algorithms for linear programs ( <ref> [ 1; 5; 24 ] </ref> , etc.). We acknowledge a conversation with I. Lustig on this subject. The global convergence of the algorithm presented here does not rely on nondegeneracy assumptions, while the global convergence of the affine scaling algorithms for linear programs has been established under such assumptions.
Reference: [6] <author> J. Ding and T.-Y. Li. </author> <title> A polynomial-time predictor-corrector algorithm for linear comple-mentarity problems. </title> <type> Tech. Rep., </type> <institution> Dept. of Math., Michigan State Univ., </institution> <address> East Lansing, MI, </address> <year> 1989. </year>
Reference-contexts: Several ways to define a neighborhood of S cen are presented in [ 10 ] . Many path-following algorithms are special cases of the UIP method <ref> [ 6; 12; 13; 16; 17; 23 ] </ref> .
Reference: [7] <author> R. M. Freund. </author> <title> Polynomial-time algorithms for linear programming based only on primal scaling and projected gradients of a potential function. </title> <address> OR 182-88, </address> <institution> Sloan School of Manag., M.I.T., </institution> <address> Cambridge, MA, </address> <year> 1988. </year>
Reference-contexts: Specifically, we do not cover algorithms which work only on either primal or dual space [ 5; 8; 18 ] , the O ( nL) iteration potential reduction algorithms of <ref> [ 25; 7 ] </ref> , the first potential reduction algorithm given in [ 11 ] for P 0 case. We summarize the main results of [ 10 ] . In Section 2, we state some classes of LCP's to which we apply the UIP method.
Reference: [8] <author> N. Karmarkar. </author> <title> A new polynomial-time algorithm for linear programming. </title> <journal> Combinatorica, </journal> <volume> 4 </volume> <pages> 373-395, </pages> <year> 1984. </year>
Reference-contexts: 1. Introduction. Many algorithms (see [ 10 ] for references) have been developed for mathematical programming since Karmarkar's paper <ref> [ 8 ] </ref> . See [ 22 ] for a survey. <p> Specifically, we do not cover algorithms which work only on either primal or dual space <ref> [ 5; 8; 18 ] </ref> , the O ( nL) iteration potential reduction algorithms of [ 25; 7 ] , the first potential reduction algorithm given in [ 11 ] for P 0 case. We summarize the main results of [ 10 ] .
Reference: [9] <author> M. Kojima, N. Megiddo and T. Noma. </author> <title> Homotopy continuation methods for nonlinear complementarity problems. </title> <journal> Math. of Oper. Res., </journal> <note> to appear. </note>
Reference: [10] <author> M. Kojima, N. Megiddo, T. Noma and A. Yoshise. </author> <title> A Unified approach to interior point algorithms for linear complementarity problems. </title> <note> Lecture Notes in Computer Science, Springer-Verlag, to appear. Also issued as Res. Rep. RJ 7493, </note> <institution> IBM Almaden Res. Ctr., </institution> <address> San Jose, CA, </address> <year> 1990. </year>
Reference-contexts: 1. Introduction. Many algorithms (see <ref> [ 10 ] </ref> for references) have been developed for mathematical programming since Karmarkar's paper [ 8 ] . See [ 22 ] for a survey. <p> They suggested a unified interior point (UIP) method for both the path-following and potential reduction algorithms that solve LCP's with positive semi-definite (p.s.d.) matrices. The purpose of this note is to summarize a study which the authors have carried out in <ref> [ 10 ] </ref> about the UIP method. fl Departments of Information Sciences and Systems Science, Tokyo Institute of Technology, Oh-Okayama, Meguro-ku, Tokyo 152, Japan. y IBM Almaden Research Center, San Jose, CA 95120, and School of Mathematical Sciences, Tel Aviv University, Tel Aviv, Israel. z Department of Systems Science, Tokyo Institute <p> In <ref> [ 10 ] </ref> we assume M to be in the rich class P 0 of matrices with nonnegative principal minors. This class includes not only skew-symmetric matrices, p.s.d. matrices and P -matrices, but also NP-complete LCP's. <p> In fact, the UIP method is closely related to or includes as special cases many interior point algorithms (for example, [ 12; 16; 17 ] , etc.) which work on the primal and dual spaces simultaneously. The global and the polynomial-time convergence results which are established in <ref> [ 10 ] </ref> can be applied to a wider class of primal-dual interior point algorithms. The UIP method can also be applied to linear programming problems in standard form (see [ 14 ] ). Consider first a smooth version of the method. <p> If in addition we choose an initial point sufficiently close to the trajectory and a suitably small step size, the potential reduction algorithm works as the path-following algorithm [ 13 ] . For more details see Section 4.3 of <ref> [ 10 ] </ref> . Our work is closely related to the works [ 19; 20; 21 ] by Tanabe (see [ 10 ] for a detailed discussion), but the analyses are different and, in particular, we emphasize the global and the polynomial-time convergence of the UIP method applied to larger classes <p> For more details see Section 4.3 of <ref> [ 10 ] </ref> . Our work is closely related to the works [ 19; 20; 21 ] by Tanabe (see [ 10 ] for a detailed discussion), but the analyses are different and, in particular, we emphasize the global and the polynomial-time convergence of the UIP method applied to larger classes of LCP's. 2 We do not give a unified view over all the interior point algorithms. <p> We summarize the main results of <ref> [ 10 ] </ref> . In Section 2, we state some classes of LCP's to which we apply the UIP method. Section 3 explains the UIP method. Section 4 gives some assumptions which are necessary for the discussion of the theoretical computational complexity of the UIP method. <p> The UIP Method. One of the main ingredients of the UIP method is the function f (x; y) = (n + -) log x T y i=1 Here - &gt; 0 is a parameter. This type of potential function has been utilized for linear programs in many papers (see <ref> [ 10 ] </ref> ). <p> In theory we choose * = 2 2L so that a solution of the LCP can be computed from the terminal point of the UIP method (see <ref> [ 10 ] </ref> ). The UIP method involves two parameters: fi 2 [0; 1] and 0. The parameter fi and the current point (x k ; y k ) determine the direction (dx; dy) toward the new iterate (x k+1 ; y k+1 ), while 0 controls the step length. <p> The UIP method involves two parameters: fi 2 [0; 1] and 0. The parameter fi and the current point (x k ; y k ) determine the direction (dx; dy) toward the new iterate (x k+1 ; y k+1 ), while 0 controls the step length. In <ref> [ 10 ] </ref> we explore flexible choices of these two parameters which ensure the global convergence, in certain cases in polynomial time. A summary is presented in Section 5. 4. Assumptions for Evaluating the Computational Complexity. We assume all the entries of M and q to be rational. <p> Condition 4.1 implies Condition 2.1. Hence the potential reduction algorithm of Sec tion 5 solves the problem under Condition 4.1. In <ref> [ 10 ] </ref> we present a method of transform ing a given LCP satisfying only (i) and (ii) of Condition 4.1 into an equivalent artificial problem satisfying (i), (ii) and (iii) simultaneously. 5. Globally Convergent Potential Reduction Algorithms. <p> A path-following algorithm traces the central trajectory numerically by generating a sequence f (x k ; y k )g in "a horn neighborhood" of S cen such that lim k!1 y k = 0. Several ways to define a neighborhood of S cen are presented in <ref> [ 10 ] </ref> . Many path-following algorithms are special cases of the UIP method [ 6; 12; 13; 16; 17; 23 ] . <p> Let 0 t &lt; 1, and fi (t ) = supf 0 : dx t x; dy t yg: Obviously, for every 2 [0; fi (t )], (x; y) + (dx; dy) 2 S ++ . It is possible (see Section 4.4 of <ref> [ 10 ] </ref> ) to find quadratic functions G t cen () and G t () such that f cen ((x; y) + (dx; dy)) f cen (x; y) G t cen () for every 2 [0; fi (t )]; 8 G t dG t d f ((x; y) + (dx; <p> First, suppose that Condition 2.1 is satisfied. Then the sequence f (x k ; y k )g is bounded and lim x k T y k = 0 (See <ref> [ 10 ] </ref> .). Three important cases are covered by this result: (a) 0 &lt; ff cen ff 1 &lt; ff bd &lt; 1. (c) 0 &lt; ff cen ff 1 = ff bd = 1. <p> Then the potential reduction algorithm solves the LCP in O ( n (1 + )L) iterations. We may take either a finite ff bd &gt; ff 1 as in the case (a) or ff bd = +1 as in the case (b). See <ref> [ 10 ] </ref> . The last result we state here is a special case of the case (c) of the first convergence result above. Suppose the LCP satisfies Condition 4.1. Let - = p n. <p> Let - = p n. Choose ff cen = 9 ff 1 = ff bd = 1 and fi cen = 0. This choice implies fi k = 0 throughout. The algorithm then solves the LCP in O (expf p n (1 + )Lg) iterations (See <ref> [ 10 ] </ref> .). <p> Lustig on this subject. The global convergence of the algorithm presented here does not rely on nondegeneracy assumptions, while the global convergence of the affine scaling algorithms for linear programs has been established under such assumptions. More general global convergence theorems are established in Section 6.2 of <ref> [ 10 ] </ref> from which we can directly derive the results above. Acknowledgements. Most of this research was done while three of the authors, Kojima, Noma and Yoshise were visiting at the IBM Almaden Research Center in the summer of 1989.
Reference: [11] <author> M. Kojima, N. Megiddo and Y. Ye. </author> <title> An interior point potential reduction algorithm for the linear complementarity problem. </title> <journal> Math. Programming, </journal> <note> to appear. </note>
Reference-contexts: Specifically, we do not cover algorithms which work only on either primal or dual space [ 5; 8; 18 ] , the O ( nL) iteration potential reduction algorithms of [ 25; 7 ] , the first potential reduction algorithm given in <ref> [ 11 ] </ref> for P 0 case. We summarize the main results of [ 10 ] . In Section 2, we state some classes of LCP's to which we apply the UIP method. Section 3 explains the UIP method.
Reference: [12] <author> M. Kojima, S. Mizuno and A. Yoshise. </author> <title> A primal-dual interior point algorithm for linear programming. </title> <editor> In N. Megiddo, ed., </editor> <booktitle> Progress in Math. Programming, Interior-Point and Related Methods, </booktitle> <pages> pp. 29-47, </pages> <address> New York, 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In fact, the UIP method is closely related to or includes as special cases many interior point algorithms (for example, <ref> [ 12; 16; 17 ] </ref> , etc.) which work on the primal and dual spaces simultaneously. The global and the polynomial-time convergence results which are established in [ 10 ] can be applied to a wider class of primal-dual interior point algorithms. <p> Several ways to define a neighborhood of S cen are presented in [ 10 ] . Many path-following algorithms are special cases of the UIP method <ref> [ 6; 12; 13; 16; 17; 23 ] </ref> .
Reference: [13] <author> M. Kojima, S. Mizuno and A. Yoshise. </author> <title> A polynomial-time algorithm for a class of linear complementary problems. </title> <journal> Math. Programming, </journal> <volume> 44 </volume> <pages> 1-26, </pages> <year> 1989. </year>
Reference-contexts: If in addition we choose an initial point sufficiently close to the trajectory and a suitably small step size, the potential reduction algorithm works as the path-following algorithm <ref> [ 13 ] </ref> . For more details see Section 4.3 of [ 10 ] . <p> The other main ingredient of the UIP method is the central trajectory for the LCP <ref> [ 15; 13 ] </ref> , given by S cen = f (x; y) 2 S ++ : Xy = te for some t &gt; 0g; (3:5) where e = (1; . . . ; 1) T 2 R n and X = diag x. <p> It is shown in <ref> [ 13 ] </ref> that if an approximate solution ( ^ x; ^ y) 2 S + satisfies ^ x T ^ y 2 2L , then there exists a solution (x fl ; y fl ) such that x fl i = 0 if ^x i 2 L and j = <p> Several ways to define a neighborhood of S cen are presented in [ 10 ] . Many path-following algorithms are special cases of the UIP method <ref> [ 6; 12; 13; 16; 17; 23 ] </ref> . <p> Specifically, if we define the neighborhood by kXy (x T y)=n)ek ff (x T y)=n with ff 2 (0; 0:2], fi k = 1 ffi= n, (ffi = ff=(1 ff)) and k = 1, we get the O (n 3:5 L) path-following algorithm for the p.s.d. case of <ref> [ 13 ] </ref> . A narrow neighborhood of S cen yields polynomial-time algorithms but is not good for practical purposes. Let ff &gt; 0 and consider a neighborhood N cen (ff) defined by f cen (x; y) ff as in [ 19; 20; 21 ] .
Reference: [14] <author> M. Kojima, S. Mizuno and A. Yoshise. </author> <title> An O( p nL) iteration potential reduction algorithm for linear complementarity problems. </title> <journal> Math. Programming, </journal> <note> to appear. </note>
Reference-contexts: Given M 2 R nfin and q 2 R n , find (x; y) 2 R 2n such that y = M x + q; (x; y) 0 and x i y i = 0 (i 2 N = f1; . . . ; ng): (1:1) Kojima, Mizuno and Yoshise <ref> [ 14 ] </ref> proposed an O ( p nL) iteration potential reduction algorithm. They suggested a unified interior point (UIP) method for both the path-following and potential reduction algorithms that solve LCP's with positive semi-definite (p.s.d.) matrices. <p> The global and the polynomial-time convergence results which are established in [ 10 ] can be applied to a wider class of primal-dual interior point algorithms. The UIP method can also be applied to linear programming problems in standard form (see <ref> [ 14 ] </ref> ). Consider first a smooth version of the method. We define a vector field, induced by the Newton directions towards the central trajectory, on the set S ++ of all the interior feasible solutions of the LCP. <p> Furthermore, the Newton directions are descent directions of the potential function whose value tends to 1 as a point (x; y) approaches a solution of the LCP along any trajectory. The potential reduction algorithm <ref> [ 14 ] </ref> can be obtained from the smooth version by specifying the step size at each (x; y) 2 S ++ for numerical integration of the vector field, using the first order method for differential equations. <p> if f cen (x; y) &lt; ff cen ; fi bd fi 1 if ff 1 &lt; f cen (x; y): &gt; = (5:11) The idea of taking a larger fi 1 when the current point is far from the central trajectory was proposed in [ 2 ] (See also <ref> [ 26; 27; 14 ] </ref> .). The vector (dx; dy) depends on the value of fi. The function f = -f cp +f cen facilitates the choice of = k for the step length. <p> Three important cases are covered by this result: (a) 0 &lt; ff cen ff 1 &lt; ff bd &lt; 1. (c) 0 &lt; ff cen ff 1 = ff bd = 1. The second result is an extension of the polynomial-time convergence result of <ref> [ 14 ] </ref> for the p.s.d. case. Suppose the LCP satisfies Condition 4.1. Let - = p and fi cen = fi bd = n=(n + -). Then the potential reduction algorithm solves the LCP in O ( n (1 + )L) iterations.
Reference: [15] <author> N. Megiddo. </author> <title> Pathways to the optimal set in linear programming. </title> <editor> In N. Megiddo, ed., </editor> <booktitle> Progress in Math. Programming, Interior-Point and Related Methods, </booktitle> <pages> pp. 131-158, </pages> <address> New York, 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The other main ingredient of the UIP method is the central trajectory for the LCP <ref> [ 15; 13 ] </ref> , given by S cen = f (x; y) 2 S ++ : Xy = te for some t &gt; 0g; (3:5) where e = (1; . . . ; 1) T 2 R n and X = diag x.
Reference: [16] <author> R. D. C. Monteiro and I. Adler. </author> <title> Interior path following primal-dual algorithms. Part I: Linear programming. </title> <journal> Math. Programming, </journal> <volume> 44 </volume> <pages> 27-41, </pages> <year> 1989. </year>
Reference-contexts: In fact, the UIP method is closely related to or includes as special cases many interior point algorithms (for example, <ref> [ 12; 16; 17 ] </ref> , etc.) which work on the primal and dual spaces simultaneously. The global and the polynomial-time convergence results which are established in [ 10 ] can be applied to a wider class of primal-dual interior point algorithms. <p> Several ways to define a neighborhood of S cen are presented in [ 10 ] . Many path-following algorithms are special cases of the UIP method <ref> [ 6; 12; 13; 16; 17; 23 ] </ref> .
Reference: [17] <author> R. D. C. Monteiro and I. Adler. </author> <title> Interior path following primal-dual algorithms. Part II: Convex quadratic programming. </title> <journal> Math. Programming, </journal> <volume> 44 </volume> <pages> 43-66, </pages> <year> 1989. </year>
Reference-contexts: In fact, the UIP method is closely related to or includes as special cases many interior point algorithms (for example, <ref> [ 12; 16; 17 ] </ref> , etc.) which work on the primal and dual spaces simultaneously. The global and the polynomial-time convergence results which are established in [ 10 ] can be applied to a wider class of primal-dual interior point algorithms. <p> Several ways to define a neighborhood of S cen are presented in [ 10 ] . Many path-following algorithms are special cases of the UIP method <ref> [ 6; 12; 13; 16; 17; 23 ] </ref> .
Reference: [18] <author> J. Renegar. </author> <title> A polynomial-time algorithm based on Newton's method for linear programming. </title> <journal> Math. Programming, </journal> <volume> 40 </volume> <pages> 59-94, </pages> <year> 1988. </year>
Reference-contexts: Specifically, we do not cover algorithms which work only on either primal or dual space <ref> [ 5; 8; 18 ] </ref> , the O ( nL) iteration potential reduction algorithms of [ 25; 7 ] , the first potential reduction algorithm given in [ 11 ] for P 0 case. We summarize the main results of [ 10 ] .
Reference: [19] <author> K. Tanabe. </author> <title> Center flattening transformation and a centered Newton method for linear programming. </title> <type> Tech. Rep., </type> <institution> The Inst. of Stat. Math., Minato-ku, </institution> <address> Tokyo, Japan, </address> <year> 1987. </year>
Reference-contexts: For more details see Section 4.3 of [ 10 ] . Our work is closely related to the works <ref> [ 19; 20; 21 ] </ref> by Tanabe (see [ 10 ] for a detailed discussion), but the analyses are different and, in particular, we emphasize the global and the polynomial-time convergence of the UIP method applied to larger classes of LCP's. 2 We do not give a unified view over all <p> A narrow neighborhood of S cen yields polynomial-time algorithms but is not good for practical purposes. Let ff &gt; 0 and consider a neighborhood N cen (ff) defined by f cen (x; y) ff as in <ref> [ 19; 20; 21 ] </ref> . When ff = 1, we define N cen (1) = S ++ . Recall that S cen corresponds to f cen (x; y) = 0. Hence S cen coincides with N cen (0).
Reference: [20] <author> K. Tanabe. </author> <title> Complementarity-enforcing centered Newton method for mathematical programming. </title> <editor> In K. Tone, ed., </editor> <booktitle> New Methods for Linear Programming, </booktitle> <pages> pp. 118-144, </pages> <institution> The Inst. of Stat. Math., Minato-ku, </institution> <address> Tokyo, Japan, </address> <year> 1987. </year> <month> 11 </month>
Reference-contexts: For more details see Section 4.3 of [ 10 ] . Our work is closely related to the works <ref> [ 19; 20; 21 ] </ref> by Tanabe (see [ 10 ] for a detailed discussion), but the analyses are different and, in particular, we emphasize the global and the polynomial-time convergence of the UIP method applied to larger classes of LCP's. 2 We do not give a unified view over all <p> A narrow neighborhood of S cen yields polynomial-time algorithms but is not good for practical purposes. Let ff &gt; 0 and consider a neighborhood N cen (ff) defined by f cen (x; y) ff as in <ref> [ 19; 20; 21 ] </ref> . When ff = 1, we define N cen (1) = S ++ . Recall that S cen corresponds to f cen (x; y) = 0. Hence S cen coincides with N cen (0).
Reference: [21] <author> K. Tanabe. </author> <title> Centered Newton method for mathematical programming. </title> <editor> In M. Iri and K. Yajima, eds., </editor> <booktitle> System Modelling and Optimization, </booktitle> <pages> pp. 197-206. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: For more details see Section 4.3 of [ 10 ] . Our work is closely related to the works <ref> [ 19; 20; 21 ] </ref> by Tanabe (see [ 10 ] for a detailed discussion), but the analyses are different and, in particular, we emphasize the global and the polynomial-time convergence of the UIP method applied to larger classes of LCP's. 2 We do not give a unified view over all <p> A narrow neighborhood of S cen yields polynomial-time algorithms but is not good for practical purposes. Let ff &gt; 0 and consider a neighborhood N cen (ff) defined by f cen (x; y) ff as in <ref> [ 19; 20; 21 ] </ref> . When ff = 1, we define N cen (1) = S ++ . Recall that S cen corresponds to f cen (x; y) = 0. Hence S cen coincides with N cen (0).
Reference: [22] <author> M. J. Todd. </author> <title> Recent developments and new directions in linear programming. </title> <type> Tech. Rep. No. 827, </type> <institution> School of O.R. and I.E., Cornell Univ., </institution> <address> Ithaca, NY, </address> <year> 1988. </year>
Reference-contexts: 1. Introduction. Many algorithms (see [ 10 ] for references) have been developed for mathematical programming since Karmarkar's paper [ 8 ] . See <ref> [ 22 ] </ref> for a survey.
Reference: [23] <author> M. J. Todd and Y. Ye. </author> <title> A centered projective algorithm for linear programming. </title> <type> Tech. Rep. No. 763, </type> <institution> School of O.R. and I.E., Cornell Univ., </institution> <address> Ithaca, NY, </address> <year> 1987. </year>
Reference-contexts: Several ways to define a neighborhood of S cen are presented in [ 10 ] . Many path-following algorithms are special cases of the UIP method <ref> [ 6; 12; 13; 16; 17; 23 ] </ref> .
Reference: [24] <author> R. J. Vanderbei, M. S. Meketon and B. A. Freedman. </author> <title> A modification of Karmarkar's linear programming algorithm. </title> <journal> Algorithmica, </journal> <volume> 1 </volume> <pages> 395-407, </pages> <year> 1986. </year>
Reference-contexts: The algorithm may also be regarded as an affine scaling interior point algorithm for the LCP because the search direction at each iteration involves no centering force as in the affine scaling interior point algorithms for linear programs ( <ref> [ 1; 5; 24 ] </ref> , etc.). We acknowledge a conversation with I. Lustig on this subject. The global convergence of the algorithm presented here does not rely on nondegeneracy assumptions, while the global convergence of the affine scaling algorithms for linear programs has been established under such assumptions.
Reference: [25] <author> Y. Ye. </author> <title> A class of potential functions for linear programming. </title> <type> Tech. Rep., </type> <institution> Dept. of Engineering-Economic Sys., Stanford Univ., </institution> <address> CA, </address> <year> 1988. </year>
Reference-contexts: Specifically, we do not cover algorithms which work only on either primal or dual space [ 5; 8; 18 ] , the O ( nL) iteration potential reduction algorithms of <ref> [ 25; 7 ] </ref> , the first potential reduction algorithm given in [ 11 ] for P 0 case. We summarize the main results of [ 10 ] . In Section 2, we state some classes of LCP's to which we apply the UIP method.
Reference: [26] <author> Y. Ye. </author> <title> Line search in potential reduction algorithms for linear programming. </title> <type> Tech. Rep., </type> <institution> Dept. of Manag. Sci., Univ. of Iowa, </institution> <address> Iowa City, IA, </address> <year> 1989. </year>
Reference-contexts: if f cen (x; y) &lt; ff cen ; fi bd fi 1 if ff 1 &lt; f cen (x; y): &gt; = (5:11) The idea of taking a larger fi 1 when the current point is far from the central trajectory was proposed in [ 2 ] (See also <ref> [ 26; 27; 14 ] </ref> .). The vector (dx; dy) depends on the value of fi. The function f = -f cp +f cen facilitates the choice of = k for the step length.
Reference: [27] <author> Y. Ye. </author> <title> An O(n 3 L) potential reduction algorithm for linear programming. </title> <type> Tech. Rep., </type> <institution> Dept. of Manag. Sci., Univ. Iowa, </institution> <address> Iowa City, IA, </address> <year> 1989. </year> <month> 12 </month>
Reference-contexts: if f cen (x; y) &lt; ff cen ; fi bd fi 1 if ff 1 &lt; f cen (x; y): &gt; = (5:11) The idea of taking a larger fi 1 when the current point is far from the central trajectory was proposed in [ 2 ] (See also <ref> [ 26; 27; 14 ] </ref> .). The vector (dx; dy) depends on the value of fi. The function f = -f cp +f cen facilitates the choice of = k for the step length.
References-found: 27

