URL: http://www.sds.lcs.mit.edu/spd/larch/pub/larchBook.ps
Refering-URL: http://www.sds.lcs.mit.edu/spd/larch/
Root-URL: 
Title: Larch: Languages and Tools for Formal Specification  with  
Author: J.V. Guttag and J.J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing 
Date: January 19, 1993  
Abstract-found: 0
Intro-found: 0
Reference: * <institution> Entries marked with an asterisk have been superseded by material in this book; they are included for historical reference only. </institution>
Reference: [1] <author> J.W. Baugh, Jr. </author> <title> Formal specification of engineering analysis programs, Expert Systems for Scientific Computing, E.N. </title> <editor> Houstis, J.R. Rice, and R. Vichnevetsky (eds.), </editor> <publisher> North-Holland, </publisher> <year> 1992. </year>
Reference-contexts: For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: <ref> [3, 1] </ref>. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91].
Reference: [2] <author> John W. Baugh, Jr. </author> <title> Is engineering software amenable to formal specification?, </title> <booktitle> in [66]. </booktitle>
Reference: [3] <author> J.W. Baugh, Jr., and D.R. Rehak. </author> <title> Computational Abstractions for Finite Element Programming, </title> <type> TR 89-182, </type> <institution> Dept. of Civil Engineering, Carnegie Mellon University, </institution> <year> 1989. </year>
Reference-contexts: For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: <ref> [3, 1] </ref>. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91].
Reference: [4] <author> Michel Bidoit. Pluss, </author> <title> un langage pour le developpement de specifications algebriques modulaires. </title> <institution> Th ese d'Etat, Universit e de Paris-Sud, Orsay, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Consider, for example, the specification of tables that store values in indexed places, Figure 4.1. This is similar to a conventional algebraic specification, as it would be written in many languages <ref> [4, 20, 24, 96] </ref>. The trait can be referred to by its name, Table1.
Reference: [5] <author> Michel Bidoit and Rolf Hennicker, </author> <title> How to prove observational theorems with LP, </title> <booktitle> in [66]. </booktitle>
Reference-contexts: LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; <ref> [5, 11, 18, 19, 76, 84] </ref>. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E.
Reference: [6] <author> A.D. Birrell, J.V. Guttag, J.J. Horning, and R. Levin. </author> <title> Synchronization primitives for a multiprocessor: a formal specification. </title> <booktitle> Operating Systems Review 21(5), </booktitle> <month> Nov. </month> <year> 1987. </year> <note> Revised version in [69]. </note>
Reference-contexts: Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: <ref> [6, 69] </ref>. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: [18, 32, 78, 75, 79]. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [7] <author> Robert H. Bourdeau and Betty H.C. Cheng. </author> <title> An Object-oriented Toolkit for Constructing Specification Editors, </title> <booktitle> Proc. COMP-SAC'92: Computer Software and Applications Conf., </booktitle> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL <ref> [7, 59] </ref>; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87].
Reference: [8] <author> Robert S. Boyer and J S. Moore. </author> <title> A Computational Logic, </title> <publisher> Academic Press, </publisher> <year> 1979. </year> <note> References 231 </note>
Reference-contexts: Because many proof attempts fail, LP is designed to fail relatively quickly and to provide useful information when it does. It is not designed to find difficult proofs automatically. Unlike the Boyer-Moore prover <ref> [8] </ref>, it does not perform heuristic searches for a proof. Unlike LCF [71], it does not allow users to define complicated search tactics. Strategic decisions, such as when to try induction, must be supplied as explicit LP commands. 7.
Reference: [9] <author> Robert S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook, </title> <publisher> Academic Press, </publisher> <year> 1988. </year>
Reference: [10] <author> Frederick P. Brooks, Jr. </author> <title> The Mythical Man-Month: </title> <booktitle> Essays on Software Engineering, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1975. </year>
Reference-contexts: Unfortunately, software is usually designed badly or barely designed at all. A symptom of negligence during design is the number of software projects that are seriously behind schedule, despite having had design phases that were completed right on schedule <ref> [10] </ref>. In practice, design is the phase of a software project that is declared complete when circumstances require it. Part of the problem is that there are few objective criteria for evaluating the quality and completeness of designs.
Reference: [11] <author> Manfred Broy. </author> <title> Experiences with Software Specification and Verification Using LP, the Larch Proof Assistant, </title> <type> TR 93, </type> <institution> DEC/SRC, </institution> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; <ref> [5, 11, 18, 19, 76, 84] </ref>. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E.
Reference: [12] <author> R.M. Burstall and J.A. Goguen. </author> <title> Semantics of CLEAR, a specification language, Proc. Advanced Course on Abstract Software Specifications, </title> <editor> D. Bjorner (ed.), </editor> <publisher> Springer-Verlag, LNCS 86, </publisher> <year> 1980. </year>
Reference: [13] <author> C.T. Burton, S.J. Cook, S. Gikas, J.R. Rowson, and S.T. Som-merville. </author> <title> Specifying the Apple Macintosh toolbox event manager, </title> <booktitle> Formal Aspects of Computing 1(2), </booktitle> <year> 1989. </year>
Reference-contexts: Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: <ref> [13] </ref>. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69].
Reference: [14] <author> Karl-Heinz Buth. </author> <title> Using SOS definitions in term rewriting proofs, </title> <booktitle> in [66]. </booktitle>
Reference: [15] <author> S.R. Cardenas and H. Oktaba. </author> <title> Formal Specification in Larch Case Study: Text Manager. Interface Specification, Implementation, in Ada and Validation of Implementation, </title> <type> TR 511, </type> <institution> Instituto de Investigaciones en Matematicas Aplicadas y en Sistemas, Universidad Nacional Autonoma de Mexico, </institution> <year> 1988. </year>
Reference-contexts: Its simplicity or complexity depends largely on the simplicity or complexity of its programming language. Larch interface languages have been designed for a variety of programming languages. The two that are discussed in this book are for C and for Modula-3. Other interface languages have been designed for Ada <ref> [15, 37] </ref>, CLU [86], C++ [60, 90, 92], ML [93], and Smalltalk [17]. There are also generic Larch interface languages that can be specialized for particular programming languages or used to specify interfaces between programs in different languages [16, 53, 61, 88]. <p> For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: <ref> [15, 37] </ref>. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: [18, 32, 78, 75, 79]. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [16] <author> Jolly Chen. </author> <title> The Larch/Generic Interface Language, </title> <type> S.B. Thesis, </type> <institution> Dept. of Electrical Engineering and Computer Science, MIT, </institution> <year> 1989. </year>
Reference-contexts: Other interface languages have been designed for Ada [15, 37], CLU [86], C++ [60, 90, 92], ML [93], and Smalltalk [17]. There are also generic Larch interface languages that can be specialized for particular programming languages or used to specify interfaces between programs in different languages <ref> [16, 53, 61, 88] </ref>. Larch interface languages encourage a style of programming that emphasizes the use of abstractions, and each provides a mechanism for specifying abstract types. <p> Suggested additions for the online version should be sent to ymtan@lcs.mit.edu. Full citations for all references are given in the next section. Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in [66]. LARCH LANGUAGES Larch Interface Languages: generic <ref> [16, 53, 61, 88] </ref>; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84].
Reference: [17] <author> Yoonsik Cheon. Larch/Smalltalk: </author> <title> A Specification Language for Smalltalk, M.Sc. </title> <type> Thesis, </type> <institution> Iowa State University, </institution> <year> 1991. </year>
Reference-contexts: Larch interface languages have been designed for a variety of programming languages. The two that are discussed in this book are for C and for Modula-3. Other interface languages have been designed for Ada [15, 37], CLU [86], C++ [60, 90, 92], ML [93], and Smalltalk <ref> [17] </ref>. There are also generic Larch interface languages that can be specialized for particular programming languages or used to specify interfaces between programs in different languages [16, 53, 61, 88]. <p> Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in [66]. LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk <ref> [17] </ref>. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13].
Reference: [18] <author> Boutheina Chetali and Pierre Lescanne. </author> <title> An exercise in LP: the proof of a nonrestoring division circuit, </title> <booktitle> in [66]. </booktitle>
Reference-contexts: LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; <ref> [5, 11, 18, 19, 76, 84] </ref>. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. <p> Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: <ref> [18, 32, 78, 75, 79] </ref>. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [19] <author> Christine Choppy and Michel Bidoit. </author> <title> Integrating ASSPEGIQUE and LP, </title> <booktitle> in [66]. </booktitle>
Reference-contexts: LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; <ref> [5, 11, 18, 19, 76, 84] </ref>. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E.
Reference: [20] <author> O.-J. Dahl, D.F. Langmyhr, and O. Owe. </author> <title> Preliminary Report on the Specification and Programming Language ABEL, </title> <type> Research Report 106, </type> <institution> Institute of Informatics, University of Oslo, Norway, </institution> <year> 1986. </year> <note> 232 References </note>
Reference-contexts: Consider, for example, the specification of tables that store values in indexed places, Figure 4.1. This is similar to a conventional algebraic specification, as it would be written in many languages <ref> [4, 20, 24, 96] </ref>. The trait can be referred to by its name, Table1.
Reference: [21] <author> Ole-Johan Dahl. </author> <title> Verifiable Programming, </title> <publisher> Prentice Hall International Series in Computer Science, </publisher> <year> 1992. </year>
Reference-contexts: Instead, such proofs are usually done by pushing predicates through the program text, in ways that can be justified by appeal to the definition of satisfaction. A description of how to do this appears in the books <ref> [21, 36] </ref>. The notion of satisfaction is a bit more complicated for implementations of abstract types, because the implementor of an abstract type is working simultaneously at two levels of abstraction.
Reference: [22] <author> David L. Detlefs. </author> <title> Concurrent, Atomic Garbage Collection, </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Computer Science, Carnegie Mellon University, TR CS-90-177, </institution> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: <ref> [22] </ref>. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: [18, 32, 78, 75, 79].
Reference: [23] <author> H.-D. Ehrich. </author> <title> Extensions and implementations of abstract data type specifications, </title> <booktitle> Proc. Mathematical Foundations of Computer Science, </booktitle> <address> Zakopane, Sept. 1978. </address> <publisher> Springer-Verlag, LNCS 64. </publisher>
Reference: [24] <author> H. Ehrig and B. Mahr. </author> <title> Fundamentals of Algebraic Specification 1: Equations and Initial Semantics, </title> <journal> EATCS Monographs on Theoretical Computer Science, </journal> <volume> vol. 6, </volume> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Consider, for example, the specification of tables that store values in indexed places, Figure 4.1. This is similar to a conventional algebraic specification, as it would be written in many languages <ref> [4, 20, 24, 96] </ref>. The trait can be referred to by its name, Table1.
Reference: [25] <author> Urban Engberg, Peter Grnning, and Leslie Lamport. </author> <title> Mechanical verification of concurrent systems with TLA, </title> <booktitle> Proc. Workshop on Computer Aided Verification, </booktitle> <year> 1992. </year> <note> Revised version in [66]. </note>
Reference-contexts: Its design and development have been motivated primarily by our work on LSL, but it also has other uses, for example, reasoning about circuit designs [75, 79], algorithms involving concurrency <ref> [25] </ref>, data types [92], and algebraic systems [65]. LP is intended primarily as an interactive proof assistant or proof debugger, rather than as a fully automatic theorem prover. Its design is based on the assumption that initial attempts to state and prove conjectures usually fail. <p> Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: [18, 32, 78, 75, 79]. Mathematical Theorems: [65]. Temporal Logic of Actions: <ref> [25] </ref>.
Reference: [26] <author> G. Feldman and J. Wild. </author> <title> The DECspec project: tools for Larch/C, </title> <booktitle> Proc. Fifth Int. Workshop on Computer-Aided Software Engineering, </booktitle> <address> Montreal, </address> <month> Jul. </month> <year> 1992. </year> <note> Revised version in [66]. </note>
Reference-contexts: Full citations for all references are given in the next section. Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in [66]. LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C <ref> [26, 80] </ref>; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. <p> Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL <ref> [26] </ref>; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99].
Reference: [27] <author> Stephen J. Garland and John V. Guttag. </author> <title> Inductive methods for reasoning about abstract data types, </title> <booktitle> Proc. 15th ACM Symp. Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1988. </year>
Reference: [28] <author> Stephen J. Garland and John V. Guttag. </author> <title> An overview of LP, the Larch Prover, </title> <booktitle> Proc. Third Intl. Conf. Rewriting Techniques and Applications, </booktitle> <address> Chapel Hill, </address> <year> 1989. </year> <note> Springer-Verlag, LNCS 355. </note> <author> [29] * Stephen J. Garland and John V. Guttag. </author> <title> Using LP to debug specifications, </title> <booktitle> Proc. IFIP Work. Conf. Programming Concepts and Methods, Tiberias, Apr. 1990. </booktitle> <publisher> North-Holland. </publisher>
Reference-contexts: However, we rarely complete our rewriting systems, because a complete set of rewrite rules with a given equational theory may not exist, may be too expensive to obtain, or may lead to normal forms that are hard to read <ref> [28] </ref>. 4. Explicit instantiation of variables in equations, rewrite rules, and deduction rules also produces consequences.
Reference: [30] <author> Stephen J. Garland and John V. Guttag. </author> <title> A Guide to LP, The Larch Prover, </title> <type> TR 82, </type> <institution> DEC/SRC, </institution> <month> Dec. </month> <year> 1991. </year> <note> [31] * Stephen J. Garland, </note> <author> John V. Guttag, and James J. Horning. </author> <title> Debugging Larch Shared Language specifications, </title> <journal> IEEE Trans. Software Engineering 16(9), </journal> <month> Sept. </month> <year> 1990. </year> <note> References 233 </note>
Reference-contexts: Hence we can't hope to build a tool that will automatically certify an arbitrary specification. However, tools can assist specifiers in checking claims during debugging. This chapter describes how two such tools fit into our work on LSL. Our principal debugging tool is LP <ref> [30] </ref>, the Larch proof assistant. 1 LP's design and development have been motivated primarily by our work on LSL, but it also has other uses (cf. Appendix E). <p> LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: <ref> [30] </ref>; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1].
Reference: [32] <author> S.J. Garland, J.V. Guttag, and J. Staunstrup. </author> <title> Verification of VLSI circuits using LP, </title> <booktitle> Proc. IFIP Work. Conf. Fusion of Hardware Design and Verification, </booktitle> <publisher> North Holland, </publisher> <year> 1988. </year>
Reference-contexts: Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: <ref> [18, 32, 78, 75, 79] </ref>. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [33] <author> Narain Gehani and Andrew McGettrick (eds.). </author> <title> Software Specification Techniques, </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference: [34] <author> J.A. Goguen, J.W. Thatcher, and E.G. Wagner. </author> <title> An initial algebra approach to the specification, correctness and implementation of abstract data types, Current Trends in Programming Methodology IV: Data Structuring, </title> <editor> R. Yeh (ed.), </editor> <publisher> Prentice-Hall, </publisher> <year> 1978. </year>
Reference-contexts: This loose semantic interpretation guarantees that formulas in the theory follow only from the presence of assertions in the traitnever from their absence. This is in contrast to algebraic specification languages based on initial algebras <ref> [34] </ref> or final algebras [85]. Using the loose interpretation ensures that all theorems proved about an incomplete specification remain valid when it is extended. Each trait should be consistent: it must not define a theory containing the equation true == false.
Reference: [35] <author> C. Gong and J.M. Wing. </author> <title> Raw Code, Specification, and Proofs of the Avalon Queue Example, </title> <institution> Carnegie Mellon University, TR CMU-CS-89-172, </institution> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: <ref> [92, 35, 91] </ref>. Circuit examples: [18, 32, 78, 75, 79]. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [36] <editor> David Gries. </editor> <booktitle> The Science of Programming, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Instead, such proofs are usually done by pushing predicates through the program text, in ways that can be justified by appeal to the definition of satisfaction. A description of how to do this appears in the books <ref> [21, 36] </ref>. The notion of satisfaction is a bit more complicated for implementations of abstract types, because the implementor of an abstract type is working simultaneously at two levels of abstraction.
Reference: [37] <author> David Guaspari, Carla Marceau, and Wolfgang Polak. </author> <title> Formal verification of Ada, </title> <journal> IEEE Trans. Software Engineering 16(9), </journal> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: Its simplicity or complexity depends largely on the simplicity or complexity of its programming language. Larch interface languages have been designed for a variety of programming languages. The two that are discussed in this book are for C and for Modula-3. Other interface languages have been designed for Ada <ref> [15, 37] </ref>, CLU [86], C++ [60, 90, 92], ML [93], and Smalltalk [17]. There are also generic Larch interface languages that can be specialized for particular programming languages or used to specify interfaces between programs in different languages [16, 53, 61, 88]. <p> Full citations for all references are given in the next section. Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in [66]. LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada <ref> [37] </ref>; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. <p> For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: <ref> [15, 37] </ref>. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: [18, 32, 78, 75, 79]. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [38] <author> David Guaspari, Carla Marceau, and Wolfgang Polak. </author> <title> Formal verification of Ada programs, </title> <booktitle> in [66]. </booktitle>
Reference-contexts: Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: <ref> [38] </ref> Avalon queue example: [92, 35, 91]. Circuit examples: [18, 32, 78, 75, 79]. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [39] <author> John V. Guttag. </author> <title> Dyadic specification and its Impact on reliability, in Three Approaches to Reliable Software: Language Design Dyadic Specification, Complementary Semantics, </title> <type> J.E. Donahue, </type> <institution> J.D. Gannon, J.V. Guttag, and J.J. Horning, University of Toronto, TR CSRG-45, </institution> <month> Dec. </month> <year> 1974. </year>
Reference: [40] <author> John V. Guttag. </author> <title> The Specification and Application to Programming of Abstract Data Types, </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Computer Science, University of Toronto, </institution> <year> 1975. </year>
Reference-contexts: The axioms that convert isEmpty, count, and 2 are inherited from Container. Unlike the preceding traits in this section, PQueue specifies a complete abstract type constructor. In such a trait there is a distinguished sort, sometimes called the type of interest <ref> [40] </ref> or data sort. An abstract type's operators can be categorized as generators, observers, and extensions (sometimes in more than one way). A set of generators produces all the values of the distinguished sort. The extensions are the remaining operators whose range is the distinguished sort.
Reference: [41] <author> John Guttag. </author> <title> Notes on type abstraction, </title> <booktitle> Proc. Conf. Specifications of Reliable Software, </booktitle> <year> 1979. </year> <note> Reprinted in [33]. </note>
Reference: [42] <author> J.V. Guttag and J.J. Horning. </author> <title> The Algebraic Specification of Abstract Data Types, </title> <journal> Acta Informatica 10(1), </journal> <year> 1978. </year>

Reference: [52] <author> Samuel P. Harbison. </author> <title> Modula-3, </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: This chapter is intended for Modula-3 programmerspracticing or potential. We assume some familiarity with Modula-3. If you are not acquainted with Modula-3, you may wish to consult a Modula-3 text <ref> [52, 69] </ref>. 6.1 The relation between LM3 and Modula-3 Modula-3 has well-defined notions of interface and implementation: * An interface file (.i3 file or .ig file) declares the components of the module's interface and documents the intended uses of exported 6.
Reference: [53] <author> David Hinman. </author> <title> On the Design of Larch Interface Languages, </title> <type> S.M. Thesis, </type> <institution> Dept. of Electrical Engineering and Computer Science, MIT, </institution> <month> Jan. </month> <year> 1987. </year> <title> [54] * J.J. Horning. Combining Algebraic and Predicative Specifications in Larch, </title> <booktitle> Proc. Intl. Joint Conf. on Theory and Practice of Software Development, TAPSOFT, </booktitle> <address> Berlin, </address> <month> Mar. </month> <year> 1985. </year> <note> Springer-Verlag, LNCS 186. </note>
Reference-contexts: Other interface languages have been designed for Ada [15, 37], CLU [86], C++ [60, 90, 92], ML [93], and Smalltalk [17]. There are also generic Larch interface languages that can be specialized for particular programming languages or used to specify interfaces between programs in different languages <ref> [16, 53, 61, 88] </ref>. Larch interface languages encourage a style of programming that emphasizes the use of abstractions, and each provides a mechanism for specifying abstract types. <p> Suggested additions for the online version should be sent to ymtan@lcs.mit.edu. Full citations for all references are given in the next section. Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in [66]. LARCH LANGUAGES Larch Interface Languages: generic <ref> [16, 53, 61, 88] </ref>; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84].
Reference: [55] <author> Kevin D. Jones. LM3: </author> <title> A Larch Interface Language for Modula-3: A Definition and Introduction: Version 1.0, </title> <type> TR 72, </type> <institution> DEC/SRC, </institution> <month> Jun. </month> <year> 1991. </year> <note> References 235 </note>
Reference-contexts: Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in [66]. LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 <ref> [55, 56, 57] </ref>; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. <p> For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: <ref> [55] </ref>. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: [18, 32, 78, 75, 79]. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [56] <author> Kevin D. Jones. </author> <title> A semantics for a Larch/Modula-3 interface language, </title> <booktitle> in [66]. </booktitle>
Reference-contexts: Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in [66]. LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 <ref> [55, 56, 57] </ref>; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13].
Reference: [57] <author> Kevin D. Jones. </author> <note> LM3 Reference Manual, (in preparation). </note>
Reference-contexts: Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in [66]. LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 <ref> [55, 56, 57] </ref>; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. <p> Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 <ref> [57] </ref>. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99].
Reference: [58] <author> Donald E. Knuth and Peter B. Bendix. </author> <title> Simple word problems in universal algebras, Computational Problems in Abstract Algebra, </title> <editor> John Leech (ed.), </editor> <publisher> Pergamon Press, Oxford, </publisher> <year> 1970. </year>
Reference-contexts: Proof mechanisms in LP 2. Automatic application of deduction rules produces new consequences after equations and rewrite rules in a system are normalized. Deduction rules can also be applied by explicit command, for example, to immune equations. 3. The computation of critical-pair equations and the Knuth-Bendix completion procedure <ref> [58, 72] </ref> produce equational consequences (such as i (e) == e) from incomplete rewriting systems (such as the three rewrite rules for groups, page 130). We often compute critical-pair equations from selected sets of rewrite rules.
Reference: [59] <author> Michael R. Laux, Robert H. Bourdeau, and Betty H.C. Cheng. </author> <title> An Integrated Environment Supporting the Reuse of Formal Specifications, </title> <institution> Michigan State University, Dept. of Computer Science, TR MSU-CPS-ACS-70, </institution> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL <ref> [7, 59] </ref>; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87].
Reference: [60] <author> Gary T. Leavens and Yoonsik Cheon. </author> <title> Preliminary design of Larch/C++, </title> <booktitle> in [66]. </booktitle>
Reference-contexts: Larch interface languages have been designed for a variety of programming languages. The two that are discussed in this book are for C and for Modula-3. Other interface languages have been designed for Ada [15, 37], CLU [86], C++ <ref> [60, 90, 92] </ref>, ML [93], and Smalltalk [17]. There are also generic Larch interface languages that can be specialized for particular programming languages or used to specify interfaces between programs in different languages [16, 53, 61, 88]. <p> Full citations for all references are given in the next section. Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in [66]. LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ <ref> [60] </ref>; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 [57].
Reference: [61] <author> Richard Allen Lerner. </author> <title> Specifying Objects of Concurrent Systems, </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Computer Science, Carnegie Mellon University, TR CS-91-131, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: Other interface languages have been designed for Ada [15, 37], CLU [86], C++ [60, 90, 92], ML [93], and Smalltalk [17]. There are also generic Larch interface languages that can be specialized for particular programming languages or used to specify interfaces between programs in different languages <ref> [16, 53, 61, 88] </ref>. Larch interface languages encourage a style of programming that emphasizes the use of abstractions, and each provides a mechanism for specifying abstract types. <p> Suggested additions for the online version should be sent to ymtan@lcs.mit.edu. Full citations for all references are given in the next section. Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in [66]. LARCH LANGUAGES Larch Interface Languages: generic <ref> [16, 53, 61, 88] </ref>; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. <p> LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and <ref> [61] </ref>. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73].
Reference: [62] <author> Pierre Lescanne. </author> <title> Computer experiments with the REVE term rewriting system generator, </title> <booktitle> Proc. Tenth ACM Symp. Principles of Programming Languages, </booktitle> <year> 1983. </year>
Reference: [63] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development, </title> <publisher> MIT EECS Series, MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Writing specifications can serve to clarify and deepen designers' understanding of whatever they are specifying, by focusing attention on possible inconsistencies, lacunae, and ambiguities. Once written, specifications are helpful to implementors, testers, and 1 For a more comprehensive discussion of the role of data abstraction in programming, see <ref> [63] </ref>. 1. Specifications in Program Development 5 maintainers. Specifications provide logical firewalls by documenting mutual obligations. Implementors are to write software that meets its specification. Clients, i.e., writers of programs that use the software interface, are to rely only on properties of the software that are guaranteed by its specification.
Reference: [64] <author> D.A. McAllester. Ontic: </author> <title> A Knowledge Representation System for Mathematics, </title> <publisher> MIT Press. </publisher>
Reference-contexts: However, it has proved useful in finding inconsistencies among equations. We can use all of LP's forward inference mechanisms to search for inconsistencies in a specification. The completion procedure searches for inconsistencies automatically, and we can instantiate axioms by focus objects (in the sense of McAllester <ref> [64] </ref>) to provide the completion procedure with a basis for its search. Even though unsuccessful searches do not certify that a specification is consistent, they increase our confidence in a specification, just as testing increases our confidence in a program. 146 7.7.
Reference: [65] <author> U. Martin and T. Nipkow. </author> <title> Automating Squiggol, </title> <booktitle> Proc. IFIP Work. Conf. Programming Concepts and Methods, Tiberias, Apr. 1990. </booktitle> <publisher> North-Holland. </publisher>
Reference-contexts: Its design and development have been motivated primarily by our work on LSL, but it also has other uses, for example, reasoning about circuit designs [75, 79], algorithms involving concurrency [25], data types [92], and algebraic systems <ref> [65] </ref>. LP is intended primarily as an interactive proof assistant or proof debugger, rather than as a fully automatic theorem prover. Its design is based on the assumption that initial attempts to state and prove conjectures usually fail. <p> Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: [18, 32, 78, 75, 79]. Mathematical Theorems: <ref> [65] </ref>. Temporal Logic of Actions: [25].
Reference: [66] <author> U. Martin and J.M. Wing. </author> <booktitle> Proc. First Intl. Workshop on Larch, Dedham, Jul. 1992, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: But Larch has reached a divide, what Churchill might have called the end of the beginning. Until now, most of the work on Larch has been done by the authors of this book and their close associates. We hope that the First International Workshop on Larch <ref> [66] </ref> and the publication of this book mark the beginning of the period when most Larch research, development, and application will be done by people we do not yet know. THE ESSENCE OF LARCH Over the years, we have spent many pages describing Larch languages, tools, and applications. <p> Suggested additions for the online version should be sent to ymtan@lcs.mit.edu. Full citations for all references are given in the next section. Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in <ref> [66] </ref>. LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95].
Reference: [67] <author> Niels Mellergaard and Jrgen A. Staunstrup. </author> <title> Generating proof obligations for circuits, </title> <booktitle> in [66]. </booktitle>
Reference: [68] <author> James H. Morris, Jr. </author> <title> Types are Not Sets, </title> <booktitle> First ACM Symp. Principles of Programming Languages, </booktitle> <address> Boston, </address> <month> Oct. </month> <year> 1973. </year> <note> 236 References </note>
Reference-contexts: This leads to a style of programming in which data abstraction plays a prominent role. A data type (data abstraction) is best thought of as a collection of related operations that manipulate a collection of related values <ref> [68] </ref>. For example, one should think of the type integer as providing operations, such as 0 and +, rather than as an array of 32 (or perhaps 64) bits, whose high-order bit is interpreted as its sign.
Reference: [69] <author> Greg Nelson (ed.). </author> <title> Systems Programming with Modula-3, </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: This chapter is intended for Modula-3 programmerspracticing or potential. We assume some familiarity with Modula-3. If you are not acquainted with Modula-3, you may wish to consult a Modula-3 text <ref> [52, 69] </ref>. 6.1 The relation between LM3 and Modula-3 Modula-3 has well-defined notions of interface and implementation: * An interface file (.i3 file or .ig file) declares the components of the module's interface and documents the intended uses of exported 6. <p> The sort on which a type is based does not appear explicitly in LM3 specifications. Instead, an LM3 type name or other type expression stands for its associated sort. LM3 follows Modula-3's type checking rules <ref> [69] </ref>. Standard LSL traits define operators of the sorts upon which Modula-3 built-in types (e.g., INTEGER and TEXT) are based. Users familiar with Modula-3 will already have some intuition about these operators. Specifier-supplied traits are used to introduce application-specific operators. <p> It does not discuss synchronization operations or the general case where routines may have action sequences of arbitrary length. A more complete example is contained in Chapter 5 of Systems Programmingwith Modula-3 <ref> [69] </ref>, which uses an earlier version of LM3 to specify Modula-3's synchronization primitives. 6. LM3: A Larch Interface Language for Modula-3 117 So the overall effect of the method is to make e the manager of the group, while ensuring that each action preserves the invariant on T. <p> Since the modifies clause doesn't allow Sort to modify s.set, the specification can dispense with the usual clause saying that the final value must be a permutation of the initial value. For more extensive use of partial revelation, see Chapter 6 of <ref> [69] </ref>. Chapter 7 Using LP to Debug LSL Specifications In earlier chapters, we have attempted to show how Larch can be used to write precise specifications. However, it is not sufficient for specifications to be precise; they should also accurately reflect the specifier's intentions. <p> Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: <ref> [6, 69] </ref>. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: [18, 32, 78, 75, 79]. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [70] <author> D.L. Parnas. </author> <title> Information distribution aspects of design methodology, </title> <booktitle> Proc. IFIP Congress 71, </booktitle> <address> Ljubljana, </address> <month> Aug. </month> <year> 1971. </year>
Reference-contexts: All of these virtues can be attributed to the information hiding provided by specifications. Specification makes it possible to completely hide the implementation of an abstraction from its clients, and to completely hide the uses made by clients from the implementor <ref> [70] </ref>. 1.4 Styles of specification A good specification should be tight enough to rule out implementations that are not acceptable. It should also be loose enough to allow the most desirable (i.e., efficient and elegant) implementations.
Reference: [71] <author> Laurence C. Paulson. </author> <title> Logic and Computation: Interactive Proof with Cambridge LCF, </title> <publisher> Cambridge University Press, </publisher> <year> 1987. </year>
Reference-contexts: Because many proof attempts fail, LP is designed to fail relatively quickly and to provide useful information when it does. It is not designed to find difficult proofs automatically. Unlike the Boyer-Moore prover [8], it does not perform heuristic searches for a proof. Unlike LCF <ref> [71] </ref>, it does not allow users to define complicated search tactics. Strategic decisions, such as when to try induction, must be supplied as explicit LP commands. 7.
Reference: [72] <author> Gerald E. Peterson and Mark E. Stickel. </author> <title> Complete sets of reductions for some equational theories, </title> <journal> J. ACM 28:2, </journal> <month> Apr. </month> <year> 1981. </year>
Reference-contexts: Proof mechanisms in LP 2. Automatic application of deduction rules produces new consequences after equations and rewrite rules in a system are normalized. Deduction rules can also be applied by explicit command, for example, to immune equations. 3. The computation of critical-pair equations and the Knuth-Bendix completion procedure <ref> [58, 72] </ref> produce equational consequences (such as i (e) == e) from incomplete rewriting systems (such as the three rewrite rules for groups, page 130). We often compute critical-pair equations from selected sets of rewrite rules.
Reference: [73] <author> Eugene J. Rollins and Jeannette M. Wing. </author> <title> Specifications as search keys for software libraries, </title> <booktitle> Proc. Intl. Conf. Logic Programming, </booktitle> <address> Paris, </address> <month> Jun. </month> <year> 1991. </year>
Reference-contexts: Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: <ref> [73] </ref>. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: [18, 32, 78, 75, 79]. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [74] <author> Donald Sannella and Andrzej Tarlecki. </author> <title> On observational equivalence and algebraic specification, </title> <booktitle> Proc. Intl. Joint Conf. Theory and Practice of Software Development, TAPSOFT, </booktitle> <address> Berlin, </address> <month> Mar. </month> <year> 1985. </year> <note> Springer-Verlag, LNCS 185. </note>
Reference: [75] <author> James B. Saxe, Stephen J. Garland, John V. Guttag, and James J. Horning. </author> <title> Using Transformations and Verification in Circuit Design, </title> <booktitle> in [66]. </booktitle>
Reference-contexts: It is designed to work efficiently on large problems and to be used by specifiers with relatively little experience with theorem proving. Its design and development have been motivated primarily by our work on LSL, but it also has other uses, for example, reasoning about circuit designs <ref> [75, 79] </ref>, algorithms involving concurrency [25], data types [92], and algebraic systems [65]. LP is intended primarily as an interactive proof assistant or proof debugger, rather than as a fully automatic theorem prover. Its design is based on the assumption that initial attempts to state and prove conjectures usually fail. <p> Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: <ref> [18, 32, 78, 75, 79] </ref>. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [76] <author> E. A. Scott and K. J. Norrie. </author> <title> Using LP to study the language PL, </title> <booktitle> in [66]. </booktitle>
Reference-contexts: LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; <ref> [5, 11, 18, 19, 76, 84] </ref>. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E.
Reference: [77] <author> Joseph R. Shoenfield. </author> <title> Mathematical Logic, </title> <publisher> Addison-Wesley, </publisher> <year> 1967. </year>
Reference-contexts: Techniques for detecting when this check fails are more useful than techniques for certifying that it succeeds. A standard approach in logic to proving consistency involves interpreting the theory being checked in another theory whose consistency is assumed (e.g., Peano arithmetic) or has been established previously <ref> [77] </ref>. In this approach, user assistance is required to define the interpretation. The proof that the interpretation satisfies the axioms of the trait being checked then becomes a problem of showing theory containment, for which LP is well suited. This approach is cumbersome and unattractive in practice. <p> This approach is cumbersome and unattractive in practice. More promising approaches are based on metatheorems in first-order logic that can be used for restricted classes of specifications. For example, any extension by definitions (see <ref> [77] </ref>) of a consistent theory is consistent. For equational traits (i.e., traits with purely equational axiomatizations, of which there are relatively few), questions about consistency can be translated into questions about critical pairs.
Reference: [78] <author> J. Staunstrup, S.J. Garland, and J.V. Guttag. </author> <title> Compositional verification of VLSI circuits, </title> <booktitle> Proc. Intl. Workshop on Automatic Verification Methods for Finite State Systems, </booktitle> <address> Grenoble, </address> <month> Jun. </month> <year> 1989, </year> <note> Springer-Verlag, LNCS 407. </note>
Reference-contexts: Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: <ref> [18, 32, 78, 75, 79] </ref>. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [79] <author> Jrgen Staunstrup, Stephen J. Garland, and John V. Guttag. </author> <title> Mechanized verification of circuit descriptions using the Larch Prover, </title> <booktitle> Proc. IFIP Work. Conf. Theorem Provers in Circuit Design: Theory, Practice, and Experience, </booktitle> <address> Nijmegen, </address> <month> Jun. </month> <title> 1992. </title> <publisher> North-Holland. </publisher>
Reference-contexts: It is designed to work efficiently on large problems and to be used by specifiers with relatively little experience with theorem proving. Its design and development have been motivated primarily by our work on LSL, but it also has other uses, for example, reasoning about circuit designs <ref> [75, 79] </ref>, algorithms involving concurrency [25], data types [92], and algebraic systems [65]. LP is intended primarily as an interactive proof assistant or proof debugger, rather than as a fully automatic theorem prover. Its design is based on the assumption that initial attempts to state and prove conjectures usually fail. <p> Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: <ref> [18, 32, 78, 75, 79] </ref>. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [80] <author> Yang Meng Tan. </author> <title> Semantic analysis of Larch interface specifications, in [66]. </title> <type> References 237 </type>
Reference-contexts: Full citations for all references are given in the next section. Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in [66]. LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C <ref> [26, 80] </ref>; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84].
Reference: [81] <author> David S. Taylor. </author> <title> A Beginner's Strategy Guide to the Larch Prover, </title> <type> S.B. Thesis, </type> <institution> Dept. of Electrical Engineering and Computer Science, MIT, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide <ref> [81] </ref>; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E.
Reference: [82] <author> Mark T. Vandevoorde. </author> <title> Optimizing programs with partial specifications, </title> <booktitle> in [66]. </booktitle>
Reference: [83] <author> Mary A. Vogt. </author> <title> Extension of the Larch Prover by a Method of Inference Using Linear Arithmetic, </title> <type> S.B. Thesis, </type> <institution> Dept. of Electrical Engineering and Computer Science, MIT, </institution> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension <ref> [83] </ref>; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E.
Reference: [84] <author> Frederic Voisin. </author> <title> A new front-end for the Larch Prover, </title> <booktitle> in [66]. </booktitle>
Reference-contexts: LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; <ref> [5, 11, 18, 19, 76, 84] </ref>. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E.
Reference: [85] <author> M. Wand. </author> <title> Final algebra semantics and data type extensions, </title> <journal> Journal of Computer and System Sciences, </journal> <month> Aug. </month> <year> 1979. </year>
Reference-contexts: This loose semantic interpretation guarantees that formulas in the theory follow only from the presence of assertions in the traitnever from their absence. This is in contrast to algebraic specification languages based on initial algebras [34] or final algebras <ref> [85] </ref>. Using the loose interpretation ensures that all theorems proved about an incomplete specification remain valid when it is extended. Each trait should be consistent: it must not define a theory containing the equation true == false. Consistency is often difficult to prove and is undecidable in general.
Reference: [86] <author> Jeannette Marie Wing. </author> <title> A Two-Tiered Approach to Specifying Programs, </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Electrical Engineering and Computer Science, MIT, TR MIT/LCS/TR-299, </institution> <month> May </month> <year> 1983. </year>
Reference-contexts: Larch interface languages have been designed for a variety of programming languages. The two that are discussed in this book are for C and for Modula-3. Other interface languages have been designed for Ada [15, 37], CLU <ref> [86] </ref>, C++ [60, 90, 92], ML [93], and Smalltalk [17]. There are also generic Larch interface languages that can be specialized for particular programming languages or used to specify interfaces between programs in different languages [16, 53, 61, 88]. <p> Full citations for all references are given in the next section. Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in [66]. LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU <ref> [86] </ref>; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 [57].
Reference: [87] <author> Jeannette M. Wing. </author> <title> A Larch specification of the library problem, </title> <booktitle> Proc. Fourth Int. Workshop on Software Specification and Design, </booktitle> <address> Monterey, </address> <month> Apr. </month> <year> 1987. </year>
Reference-contexts: For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: <ref> [87] </ref>. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: [18, 32, 78, 75, 79]. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [88] <author> Jeannette M. Wing. </author> <title> Writing Larch Interface Language Specifications, </title> <journal> ACM Trans. Programming Languages and Systems 9(1), </journal> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: Other interface languages have been designed for Ada [15, 37], CLU [86], C++ [60, 90, 92], ML [93], and Smalltalk [17]. There are also generic Larch interface languages that can be specialized for particular programming languages or used to specify interfaces between programs in different languages <ref> [16, 53, 61, 88] </ref>. Larch interface languages encourage a style of programming that emphasizes the use of abstractions, and each provides a mechanism for specifying abstract types. <p> Suggested additions for the online version should be sent to ymtan@lcs.mit.edu. Full citations for all references are given in the next section. Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in [66]. LARCH LANGUAGES Larch Interface Languages: generic <ref> [16, 53, 61, 88] </ref>; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84].
Reference: [89] <author> J.M. Wing. </author> <title> Specifying recoverable objects, </title> <booktitle> Proc. Sixth Annual Northwest Software Quality Conf., </booktitle> <address> Portland, </address> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], <ref> [89] </ref>, and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73].
Reference: [90] <author> J.M. Wing. </author> <title> Using Larch to Specify Avalon/C++ Objects, </title> <booktitle> Proc. Intl. Joint Conf. Theory and Practice of Software Development, TAPSOFT, </booktitle> <address> Barcelona, </address> <month> Mar. </month> <year> 1989. </year> <note> Springer-Verlag, LNCS 352. Revised version in [90] </note>
Reference-contexts: Larch interface languages have been designed for a variety of programming languages. The two that are discussed in this book are for C and for Modula-3. Other interface languages have been designed for Ada [15, 37], CLU [86], C++ <ref> [60, 90, 92] </ref>, ML [93], and Smalltalk [17]. There are also generic Larch interface languages that can be specialized for particular programming languages or used to specify interfaces between programs in different languages [16, 53, 61, 88].
Reference: [91] <author> Jeannette M. Wing and Chun Gong. </author> <title> Machine-Assisted Proofs of Properties of Avalon Programs, </title> <institution> Carnegie Mellon University, TR CMU-CS-89-171, </institution> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: <ref> [92, 35, 91] </ref>. Circuit examples: [18, 32, 78, 75, 79]. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [92] <author> Jeannette M. Wing and Chun Gong. </author> <title> Experience with the Larch Prover, </title> <booktitle> Proc. ACM Intl. Workshop on Formal Methods in Software Development, </booktitle> <month> May </month> <year> 1990. </year> <note> 238 References </note>
Reference-contexts: Larch interface languages have been designed for a variety of programming languages. The two that are discussed in this book are for C and for Modula-3. Other interface languages have been designed for Ada [15, 37], CLU [86], C++ <ref> [60, 90, 92] </ref>, ML [93], and Smalltalk [17]. There are also generic Larch interface languages that can be specialized for particular programming languages or used to specify interfaces between programs in different languages [16, 53, 61, 88]. <p> Its design and development have been motivated primarily by our work on LSL, but it also has other uses, for example, reasoning about circuit designs [75, 79], algorithms involving concurrency [25], data types <ref> [92] </ref>, and algebraic systems [65]. LP is intended primarily as an interactive proof assistant or proof debugger, rather than as a fully automatic theorem prover. Its design is based on the assumption that initial attempts to state and prove conjectures usually fail. <p> LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): <ref> [92] </ref>, [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. <p> Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: [94, 99]. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: <ref> [92, 35, 91] </ref>. Circuit examples: [18, 32, 78, 75, 79]. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [93] <author> J.M. Wing, Eugene Rollins, and Amy Moormann Zaremski. </author> <title> Thoughts on a Larch/ML and a new application for LP, </title> <booktitle> in [66]. </booktitle>
Reference-contexts: Larch interface languages have been designed for a variety of programming languages. The two that are discussed in this book are for C and for Modula-3. Other interface languages have been designed for Ada [15, 37], CLU [86], C++ [60, 90, 92], ML <ref> [93] </ref>, and Smalltalk [17]. There are also generic Larch interface languages that can be specialized for particular programming languages or used to specify interfaces between programs in different languages [16, 53, 61, 88]. <p> Full citations for all references are given in the next section. Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in [66]. LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML <ref> [93] </ref>; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: [95]. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13].
Reference: [94] <author> Jeannette M. Wing and Amy Moormann Zaremski. </author> <title> A formal specification of a visual language editor, </title> <booktitle> Proc. Sixth Intl. Workshop on Software Specification and Design, </booktitle> <address> Como, </address> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: <ref> [94, 99] </ref>. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: [18, 32, 78, 75, 79]. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [95] <author> Jeannette M. Wing and A. Moormann Zaremski. </author> <title> Unintrusive ways to integrate formal specifications in practice, </title> <booktitle> Proc. VDM91: Formal Software Development Methods, </booktitle> <editor> S. Prehn and W.J. Toetenel (eds.), </editor> <address> Delft, Oct. 1991. </address> <publisher> Springer-Verlag, LNCS 551. </publisher>
Reference-contexts: Papers about Larch CURRENT WORK Reports about the current status of several Larch-related projects are contained in [66]. LARCH LANGUAGES Larch Interface Languages: generic [16, 53, 61, 88]; Ada [37]; C [26, 80]; C++ [60]; CLU [86]; ML [93]; Modula-3 [55, 56, 57]; Smalltalk [17]. Larch and other methods: <ref> [95] </ref>. LARCH TOOLS LP, the Larch proof assistant: [30]; a beginner's strategy guide [81]; an extension [83]; [5, 11, 18, 19, 76, 84]. For LSL [7, 59]; for LCL [26]; for LM3 [57]. Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61].
Reference: [96] <author> M. Wirsing. </author> <title> Algebraic Specification, </title> <type> Technical Report MIP-8914, </type> <institution> University of Passau, Germany, </institution> <year> 1989. </year>
Reference-contexts: Consider, for example, the specification of tables that store values in indexed places, Figure 4.1. This is similar to a conventional algebraic specification, as it would be written in many languages <ref> [4, 20, 24, 96] </ref>. The trait can be referred to by its name, Table1.
Reference: [97] <author> Katherine Anne Yelick. </author> <title> Using Abstractions in Explicitly Parallel Programs, </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Electrical Engineering and Computer Science, MIT, TR MIT/LCS/TR-507, </institution> <month> Jul. </month> <year> 1990. </year>
Reference: [98] <author> Katherine A. Yelick and Stephen J. </author> <title> Garland. A parallel completion procedure for term rewriting systems, </title> <booktitle> Proc. 11th Intl. Conf. Automated Deduction, </booktitle> <address> Saratoga Springs, </address> <month> Jun. </month> <year> 1992. </year> <note> Springer-Verlag, LNCS 607. </note>
Reference: [99] <author> Amy Moormann Zaremski. </author> <title> A Larch Specification of the Miro Editor, </title> <institution> Carnegie Mellon University, TR CMU-CS-91-111, </institution> <month> Feb. </month> <year> 1991. </year> <title> Index ' (post-state value), 58, 61 (pre-state value), </title> <booktitle> 58, 61, 76 &gt;(in C), 60 ! (in signature), </booktitle> <volume> 8, 18, 36 =, 36, 47 6=, </volume> <pages> 47 </pages>
Reference-contexts: Example specifications Apple MAC Toolbox: [13]. Avalon built-in classes, examples (queue, directory, counter): [92], [89], and [61]. Display: [43]. Finite element analysis library: [3, 1]. Garbage collection: [22]. Appendix E. Classified Bibliography 229 IOStreams: [55]. Larch/Ada: [15, 37]. Library: [87]. Miro languages and editor: <ref> [94, 99] </ref>. Thread synchronization primitives: [6, 69]. Using specifications to search software libraries: [73]. Proofs using LP Ada programs: [38] Avalon queue example: [92, 35, 91]. Circuit examples: [18, 32, 78, 75, 79]. Mathematical Theorems: [65]. Temporal Logic of Actions: [25].
Reference: [] <editor> (LP box), </editor> <volume> 33, </volume> <pages> 139 </pages>

References-found: 89

