URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1998/tr-98-019.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1998.html
Root-URL: http://www.icsi.berkeley.edu
Title: Decoding Algebraic-Geometric Codes Beyond the Error-Correction Bound  
Phone: (510) 643-9153 FAX (510) 643-7684  
Author: M. Amin Shokrollahi and Hal Wasserman 
Date: June 1998  
Address: I 1947 Center St. Suite 600 Berkeley, California 94704-1198  
Affiliation: INTERNATIONAL COMPUTER SCIENCE INSTITUTE  
Pubnum: TR-98-019  
Abstract: We generalize Sudan's results for Reed-Solomon codes [41] to the class of algebraic-geometric codes, designing polynomial-time algorithms which decode beyond the error-correction bound (d 1)=2, where d is the minimum distance of the code. We introduce [n; k; e; b] q -codes, which are linear [n; k] q -codes such that any Hamming sphere of radius e contains at most b codewords. Using the sequence of Garcia-Stichtenoth function fields [10], we construct sequences of constant-rate [n; k; e; b] q -codes for which e=n ! * &gt; 1=2 as n grows large, while b and q remain fixed. Equivalently, we specify arbitrarily large constant-rate codes over a fixed field F q such that a codeword is efficiently, non-uniquely reconstructible after more than half of its letters have been arbitrarily corrupted. Additionally, we discover a very simple algorithm for conventional decoding of AG-codes. Furthermore, we construct codes such that a codeword is uniquely and efficiently reconstructible after more than half of its letters have been corrupted by noise which is random in a specified sense. We summarize our results in terms of bounds on asymptotic parameters, giving a new characterization of decoding beyond the traditional error-correction bound. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Ar, R. Lipton, R. Rubinfeld, and M. Sudan. </author> <title> Reconstructing algebraic functions from mixed data. </title> <booktitle> In Proc. 33rd FOCS, </booktitle> <pages> pages 503-512, </pages> <year> 1992. </year>
Reference-contexts: Definition 1. An [n; k; e; b] q -code is an [n; k] q -code such that the Hamming sphere of radius e around any y 2 F n q contains at most b codewords. For example, note that an [n; k; 2e + 1] q -code is an <ref> [n; k; e; 1] </ref> q -code. The decoding task associated with an [n; k; e; b] q -code requires methods quite different from those customarily employed for error-correction. For Reed-Solomon codes, several researchers investigated decoding algorithms that could correct more than (d1)=2 errors. <p> Sidel'nikov [35] gave another algorithm based on computing zeros of multivariate polynomials. A different line of thought was pursued by Sudan [40, 41], who, extending results of Ar et al. <ref> [1] </ref>, investigated alternative decoding algorithms for Reed-Solomon codes. <p> This application is carried out in Section 5. The bottleneck of our algorithm is the factorization routine. In Section 6 we derive for small b variants of our general algorithm in which the factorization step has been eliminated. One variant, which corresponds to the case of decoding <ref> [n; k; e; 1] </ref> q -codes (i.e., conventional decoding), is particularly interesting. It is slightly less powerful than existing AG-decoding algorithms, as it can correct only up to (d fl 1)=2 g errors. However, its implementation only requires solving an n fi (n + 1) system of linear equations. <p> Moreover, we will show in Section 7 that, if a large fraction of the letters of a codeword are corrupted by noise which is random in a specified sense, it may be possible to uniquely decode. This inspires us to speak of an <ref> [n; k; e; 1] </ref> p q -code, which is defined to be an [n; k] q -code such that, with probability of failure p, a codeword may be uniquely reconstructed after up to e of its letters have been replaced with uniform-random letters. <p> <ref> [n; k; e; 1] </ref> p q -code, which is defined to be an [n; k] q -code such that, with probability of failure p, a codeword may be uniquely reconstructed after up to e of its letters have been replaced with uniform-random letters. We will demonstrate that there exist constant-rate [n; k; e; 1] p q -AG-codes for which e is surprisingly close to n while p is very small. We also specify a corresponding decoding algorithm, which does not require polynomial factorization and hence is particularly efficient. <p> In Section 9 we investigate asymptotic properties of [n; k; e; b] q -codes. We define analogues of the function ff q [23, Def. 5.1.2] for our new classes of [n; k; e; b] q -codes and <ref> [n; k; e; 1] </ref> p q -codes, and derive lower bounds for these functions by creating asymptotically good sequences of AG-codes. One of the crucial time-parameters of our decoding algorithms is the size of the basis functions used for encoding. <p> Proof. The proof is as for Theorem 2, except that we use s := b and the new value of fi. 2 The cases b = 1 and b = 2 of the above theorem will be of particular interest. Recall that <ref> [n; k; e; 1] </ref> q - codes are those for which a codeword may be conventionally (i.e., uniquely) reconstructed after the corruption of up to e letters. Therefore, we will refer to the case b = 1 as the unique reconstruction case. <p> Setting b = 1 in the previous theorem yields the following. Corollary 14. Let C be an [n; k; d] q -AG-code built over an algebraic function field of genus g, and let ff := k + g 1. Then C is an <ref> [n; k; b (n ff 1)=2 gc; 1] </ref> q -code. We saw in Section 2 that AG-codes have designed distance d fl = n ff, and thus have designed error-correction bound e fl := b (d fl 1)=2c = b (n ff 1)=2c. <p> In the next two sections, we respond to this argument. Here we consider the possibility that, if noise is assumed to be random in a specified sense, then a codeword x may be uniquely reconstructed from its highly noisy corruption y. We fix the following definition: Definition 16. An <ref> [n; k; e; 1] </ref> p q -code is an [n; k] q -code such that, after up to e letters of a codeword x have been replaced with uniform-random letters, x may be uniquely reconstructed, with probability of failure at most p. 9 Our model of random noise is thus that <p> Let C be an [n; k; d] q -AG-code built over an algebraic function field of genus g. Let ff := k + g 1 and fi := d ffn + g 1e. Then for any ffi &gt; 0, C is an <ref> [n; k; e; 1] </ref> p q -code, where e := bn ffin 2fi fin=(ffq) ff 2g 1c; (2) p := 2 exp (ffi 2 n=2) + 2 exp (ffi 2 n): (3) Moreover, the associated decoding task can be accomplished efficiently using Algorithm 19 below. Proof. <p> Theorem 18 then tells us that, using this field and picking n := 10 6 , k := 10 4 , ffi := 0:01, we can create an <ref> [n; k; 642790; 1] </ref> p 101 2 -code, where p is less than 10 21 . <p> We also set ! q := b=1 b q . We similarly define R q to be the set of all (*; R) such that for any n 0 2 N there exist <ref> [n; k; e; 1] </ref> p q -codes for which n n 0 , (e=n; k=n) is arbitrarily close to (*; R), and p is upper-bounded by an exponentially small function of n. <p> Observe that 1 q is precisely the set of all (*; R) such that (2*; R) 2 q . Furthermore, we have obvious inclusions 1 q R q b 0 The function ff q : <ref> [0; 1] </ref> ! [0; 1], defined in [23, Def. 5.1.2], describes the boundary of q . To be precise, q is the set of all (ffi; R) such that R ff q (ffi). <p> Observe that 1 q is precisely the set of all (*; R) such that (2*; R) 2 q . Furthermore, we have obvious inclusions 1 q R q b 0 The function ff q : <ref> [0; 1] </ref> ! [0; 1], defined in [23, Def. 5.1.2], describes the boundary of q . To be precise, q is the set of all (ffi; R) such that R ff q (ffi). <p> Hence we also ask: (5) Is there a variant of our conventional decoding algorithm which can correct up to (d fl 1)=2 errors? Restricting ourselves to a model of random noise, we have also introduced <ref> [n; k; e; 1] </ref> p q -codes, and have demonstrated that there exist [n; k; e; 1] p q -AG-codes for which e is close to n while k=n is bounded away from zero and p is very small. <p> Hence we also ask: (5) Is there a variant of our conventional decoding algorithm which can correct up to (d fl 1)=2 errors? Restricting ourselves to a model of random noise, we have also introduced <ref> [n; k; e; 1] </ref> p q -codes, and have demonstrated that there exist [n; k; e; 1] p q -AG-codes for which e is close to n while k=n is bounded away from zero and p is very small. <p> In Section 9 we constructed asymptotically good sequences of [n; k; e; b] q -codes and <ref> [n; k; e; 1] </ref> p q - codes over a fixed field F q . We introduced the functions fi b q , fi ! q , which are natural variants of the well-known function ff q . Manin [24] has proved the continuity of ff q .
Reference: [2] <author> E.R. Berlekamp. </author> <title> Bounded distance + 1 soft decision Reed-Solomon decoding. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 42 </volume> <pages> 704-720, </pages> <year> 1996. </year>
Reference-contexts: The decoding task associated with an [n; k; e; b] q -code requires methods quite different from those customarily employed for error-correction. For Reed-Solomon codes, several researchers investigated decoding algorithms that could correct more than (d1)=2 errors. Welch and Berlekamp <ref> [46, 2] </ref> designed an algorithm that could correct (d 1)=2 + 1 errors in time O (n 2 ). Dumer [6] developed an algorithm that could correct d=2 + O (log n) errors in time O (n 2 ). <p> Sidel'nikov [35] gave another algorithm based on computing zeros of multivariate polynomials. A different line of thought was pursued by Sudan [40, 41], who, extending results of Ar et al. [1], investigated alternative decoding algorithms for Reed-Solomon codes. By generalizing a decoding algorithm of Welch and Berlekamp <ref> [46, 2] </ref>, he derived the surprising result that an [n; k] q Reed-Solomon code is an [n; k; e; b] q -code such that e is approximately n p 2kn and b is approximately p 2n=k. <p> However, its implementation only requires solving an n fi (n + 1) system of linear equations. Because of its simplicity, we feel that this algorithm is of independent interest. Another variant corresponds to the case of decoding <ref> [n; k; e; 2] </ref> q -codes. We find that the small increase from b = 1 to b = 2 leads to a substantial result, allowing us to reconstruct after a number of errors which may approach 2n=3. <p> The binary reconstruction case is based on the following special case of Theorem 13 for b = 2. Corollary 15. Let C be an [n; k; d] q -AG-code built over an algebraic function field K of genus g. Then C is an <ref> [n; k; b2n=3 k 2g + 2=3c; 2] </ref> q -code. Observe that, if the rate and genus are sufficiently small, then the error-bound here may rise substantially above the conventional correction bound e := b (d 1)=2c.
Reference: [3] <author> P. Burgisser, M. Clausen, and M.A. Shokrollahi. </author> <title> Algebraic Complexity Theory, volume 315 of Grundlehren der Mathematischen Wissenschaften. </title> <publisher> Springer Verlag, </publisher> <address> Heidelberg, </address> <year> 1996. </year>
Reference-contexts: Its main step is an interpolation over an algebraic function field. Using standard matrix methods, this step can be performed in O (n 3 ) F q -operations. But observe that univariate interpolation takes only O (n 1+* ) F q -operations <ref> [3, Chap. 3] </ref>. This observation inspires us to ask: (4) Can the interpolation step of our algorithm be performed in O (n 2 ) or O (n 1+* ) F q -operations? An affirmative answer to this question would yield a very fast algorithm for conventional AG-decoding.
Reference: [4] <author> H. Cohen. </author> <title> A Course in Computational Algebraic Number Theory, volume 138 of Graduate Texts in Mathematics. </title> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Our algorithm for this task is an adaptation of a well-known procedure for factoring polynomials over number fields, as described in, e.g., <ref> [4, 19, 21] </ref>. Applying Theorem 2 to the asymptotically good sequence of Garcia-Stichtenoth function fields [10] allows us to construct sequences of [n; k; e; b] q 2-codes having excellent parameters. This application is carried out in Section 5. The bottleneck of our algorithm is the factorization routine. <p> This example should serve as a prototype for how to proceed in the case of a general separable extension. We now continue with our solution, which adapts a well-known procedure for factoring univari-ate polynomials over number fields <ref> [4, 19, 21] </ref>. To each 2 K there corresponds a unique g 2 L [Y ] of degree less than deg (f ) such that = g (!). <p> Alternatively, N () = a deg (f) Res (f; g ), where a is the leading coefficient of g and Res (f; g ) is the resultant of f and g <ref> [4, p. 332] </ref>. Note that N () is an element of L. Similarly, for G := P i T i 2 K [T ], N (G) 2 L [T ] is defined to be Q (G), where runs over the same set as above. <p> The following lemma shows that factorization in K [T ] can be reduced to factorization in L [T ]. Its proof can be found in <ref> [4, Lem. 3.6.3] </ref>. Lemma 6. Suppose that G 2 K [T ] and its norm N 2 L [T ] are squarefree. Let N = N 1 N s be the factorization of N into irreducible elements of L [T ]. <p> Proof. For each appearing in the definition of N (G) (there are [K: L] such 's), let (fi ;i ) be the roots of (G). By <ref> [4, Lem. 3.6.2] </ref>, N (G (T !)) is not squarefree iff there exist ; t; i; j such that = (fi ;i fi t;j )=(t (!) (!)). Hence the number of such is polynomial in [K: L] and deg (G). 2 Theorem 8.
Reference: [5] <author> C. Dahl. </author> <title> Fast decoding of codes from algebraic curves. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 40 </volume> <pages> 223-229, </pages> <year> 1994. </year>
Reference: [6] <author> I.I. Dumer. </author> <title> Two algorithms for the decoding of linear codes. Problems Inform. </title> <journal> Transmission, </journal> <volume> 25 </volume> <pages> 17-23, </pages> <year> 1989. </year>
Reference-contexts: For Reed-Solomon codes, several researchers investigated decoding algorithms that could correct more than (d1)=2 errors. Welch and Berlekamp [46, 2] designed an algorithm that could correct (d 1)=2 + 1 errors in time O (n 2 ). Dumer <ref> [6] </ref> developed an algorithm that could correct d=2 + O (log n) errors in time O (n 2 ). Sidel'nikov [35] gave another algorithm based on computing zeros of multivariate polynomials.
Reference: [7] <author> I. Duursma. </author> <title> Algebraic decoding using special divisors. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 39 </volume> <pages> 694-698, </pages> <year> 1993. </year>
Reference: [8] <author> D. Ehrhard. </author> <title> Achieving the designed error capacity in decoding algebraic-geometric codes. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 39 </volume> <pages> 743-751, </pages> <year> 1993. </year>
Reference: [9] <author> G.L. Feng and T.R.N. Rao. </author> <title> Decoding algebraic-geometric codes up to the designed minimum distance. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 39 </volume> <pages> 37-45, </pages> <year> 1993. </year>
Reference: [10] <author> A. Garcia and H. Stichtenoth. </author> <title> A tower of Artin-Schreier extensions of function fields attaining the Drinfeld-Vladut bound. </title> <journal> Invent. Math., </journal> <volume> 121 </volume> <pages> 211-222, </pages> <year> 1995. </year>
Reference-contexts: Our algorithm for this task is an adaptation of a well-known procedure for factoring polynomials over number fields, as described in, e.g., [4, 19, 21]. Applying Theorem 2 to the asymptotically good sequence of Garcia-Stichtenoth function fields <ref> [10] </ref> allows us to construct sequences of [n; k; e; b] q 2-codes having excellent parameters. This application is carried out in Section 5. The bottleneck of our algorithm is the factorization routine. <p> Its running time can likely be improved using methods to find roots of polynomials over function fields directly, rather than carrying out full polynomial factorization. Furthermore, in Sections 6-7 we will develop more efficient algorithms for certain cases. 5 Application to Asymptotically Good AG-Codes Garcia and Stichtenoth <ref> [10] </ref> give an explicit sequence of function fields F m =F q 2 having more than q m1 (q 2 1) prime divisors of degree one and genus g m &lt; q m1 (q+1). <p> Section 10 provides a hint in this direction: we will prove that, for the case of F 3 , S is indeed polynomial in n. Example 12. Using F m =F 101 2 and setting k := b0:01nc, we can create an <ref> [n; k; b0:79nc; 10] </ref> 101 2 AG-code. <p> It has q 3 + 1 prime divisors of degree one and its genus is q (q 1)=2 <ref> [10] </ref>. We set n := q 3 . Then size (f ) and [K: L] are both o (n). Let Q be the common zero of X and Y . Then 1=X 2 L (qQ) and 1=Y 2 L ((q + 1)Q). <p> Section 5 that F 3 =F q 2 is the extension of the Hermitian function field F 2 generated by the polynomial Z q + Z (Y =X) q+1 . (We have changed our notation slightly.) F 3 has more than q 4 q 2 prime divisors of degree one <ref> [10, Prop. 3.1] </ref> and its genus is q 3 2q + 1 [10, Thm. 2.10]. Let n := q 4 q 2 . To show that our decoding algorithm takes time poly (n), we need only prove that basis size S is polynomial in n. <p> the Hermitian function field F 2 generated by the polynomial Z q + Z (Y =X) q+1 . (We have changed our notation slightly.) F 3 has more than q 4 q 2 prime divisors of degree one [10, Prop. 3.1] and its genus is q 3 2q + 1 <ref> [10, Thm. 2.10] </ref>. Let n := q 4 q 2 . To show that our decoding algorithm takes time poly (n), we need only prove that basis size S is polynomial in n. <p> Again, we will do this by exhibiting an explicit prime divisor Q and explicit basis functions ' i . For Q we choose the unique common zero of the functions X; Y; Z <ref> [10, Lem. 2.3] </ref>. We will now employ the notation of [10]. The divisor D (3) can be written as D (3) = E 1 + E 2 , for effective divisors E 1 ; E 2 such that E 1 " F 1 is the divisor of poles of X. <p> Again, we will do this by exhibiting an explicit prime divisor Q and explicit basis functions ' i . For Q we choose the unique common zero of the functions X; Y; Z [10, Lem. 2.3]. We will now employ the notation of <ref> [10] </ref>. The divisor D (3) can be written as D (3) = E 1 + E 2 , for effective divisors E 1 ; E 2 such that E 1 " F 1 is the divisor of poles of X. The discussion in Section 2 of [10] implies that we have <p> employ the notation of <ref> [10] </ref>. The divisor D (3) can be written as D (3) = E 1 + E 2 , for effective divisors E 1 ; E 2 such that E 1 " F 1 is the divisor of poles of X. The discussion in Section 2 of [10] implies that we have the following divisor decompositions for X; Y; Z in F 3 : (X) = Q + D 0 + qE 1 q 2 E 2 (3) (Z) = (q 2 + q)Q (q + 1)(E 1 + E 2 ): For integers a; b; c, this
Reference: [11] <author> J. von zur Gathen and E. Kaltofen. </author> <title> Factorization of multivariate polynomials over finite fields. </title> <journal> Math. Comp., </journal> <volume> 45 </volume> <pages> 251-261, </pages> <year> 1985. </year>
Reference-contexts: We then factor ~ N (X; T ) 2 F q [X; T ] using a bivariate factorization algorithm. This takes deterministic time polynomial in q and the degree of ~ N <ref> [11, 22] </ref>. By the Gau Lemma [20, Chap. IV, Thm. 2.1], the irreducible factors of N in L [T ] exactly correspond to the irreducible factors of ~ N in F q [X; T ]. <p> To obtain an overall polylogarithmic contribution of q one could employ a probabilistic rather than a deterministic factorization algorithm: refer to <ref> [11] </ref>. (2) If the curve defined by the algebraic function field K is a plane curve with only ordinary singularities, then it follows from the work in [16] that the parameter S in the above theorem is polynomial in n, [K: L], and size (f ).
Reference: [12] <author> O. Goldreich, R. Rubinfeld, and M. Sudan. </author> <title> Learning polynomials with queries: the highly noisy case. </title> <booktitle> In Proc. 36th FOCS, </booktitle> <pages> pages 294-303, </pages> <year> 1995. </year>
Reference-contexts: The existence of a unique solution in the presence of large quantities of random noise has been considered previously, e.g., in <ref> [12, Sec. 6] </ref>. Here we shall accompany our existence result with an efficient decoding algorithm. Indeed, this algorithm will have the advantage of being more efficient than our main algorithm of Section 4. The new algorithm (which extends a method of [45]) is suggested by the proof of Theorem 2.
Reference: [13] <author> V.D. Goppa. </author> <title> Codes on algebraic curves. </title> <journal> Sov. Math. Dokl., </journal> <volume> 24 </volume> <pages> 170-172, </pages> <year> 1981. </year>
Reference-contexts: If the minimum Hamming distance between any two distinct codewords is d, then C is called an [n; k; d] q -code. n, k, and d are called the block length, dimension, and minimum distance of C, respectively. Following a construction of Goppa <ref> [13] </ref>, one can use algebraic curves over finite fields to design linear error-correcting codes called algebraic-geometric codes or AG-codes. These codes can be viewed as a generalization of Reed-Solomon codes, for an AG-codeword is formed by evaluating at specified rational points a function in the function field of a curve. <p> An application of the Riemann-Roch Theorem proves that C is an [n; ff g + 1; d] q -code, where d n ff. The quantity d fl := n ff is called the designed distance of C. For further information on AG-codes, we refer the reader to <ref> [13, 14, 32, 39, 42] </ref>. The encoding algorithm for an AG-code requires us to know a specific basis of L (ffQ). Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities [15, 16].
Reference: [14] <author> V.D. Goppa. </author> <title> Geometry and Codes. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1988. </year>
Reference-contexts: An application of the Riemann-Roch Theorem proves that C is an [n; ff g + 1; d] q -code, where d n ff. The quantity d fl := n ff is called the designed distance of C. For further information on AG-codes, we refer the reader to <ref> [13, 14, 32, 39, 42] </ref>. The encoding algorithm for an AG-code requires us to know a specific basis of L (ffQ). Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities [15, 16].
Reference: [15] <author> M. Huang and D. Ierardi. </author> <title> Efficient algorithms for the Riemann-Roch problem and for addition in the Jacobian of a curve. </title> <booktitle> In Proc. 32nd FOCS, </booktitle> <pages> pages 678-687, </pages> <year> 1991. </year>
Reference-contexts: The encoding algorithm for an AG-code requires us to know a specific basis of L (ffQ). Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities <ref> [15, 16] </ref>. The following lemma [29, Prop. 3] shows that it suffices to know a special basis of L ((2g + 1)Q). Lemma 3.
Reference: [16] <author> M. Huang and D. Ierardi. </author> <title> Efficient algorithms for the Riemann-Roch problem and for addition in the Jacobian of a curve. </title> <journal> J. Symb. Comp., </journal> <volume> 18 </volume> <pages> 519-539, </pages> <year> 1994. </year>
Reference-contexts: The encoding algorithm for an AG-code requires us to know a specific basis of L (ffQ). Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities <ref> [15, 16] </ref>. The following lemma [29, Prop. 3] shows that it suffices to know a special basis of L ((2g + 1)Q). Lemma 3. <p> To obtain an overall polylogarithmic contribution of q one could employ a probabilistic rather than a deterministic factorization algorithm: refer to [11]. (2) If the curve defined by the algebraic function field K is a plane curve with only ordinary singularities, then it follows from the work in <ref> [16] </ref> that the parameter S in the above theorem is polynomial in n, [K: L], and size (f ).
Reference: [17] <author> J. Justesen, K.J. Larsen, A. Havemose, H.E. Jensen, and T. Htholdt. </author> <title> Construction and decoding of a class of algebraic geometry codes. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 35 </volume> <pages> 811-821, </pages> <year> 1989. </year>
Reference: [18] <author> J. Justesen, K.J. Larsen, H.E. Jensen, and T. Htholdt. </author> <title> Fast decoding of codes from algebraic plane curves. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 38 </volume> <pages> 111-119, </pages> <year> 1992. </year>
Reference: [19] <author> S. Landau. </author> <title> Factoring polynomials over algebraic number fields. </title> <journal> SIAM J. Comput., </journal> <volume> 14 </volume> <pages> 184-195, </pages> <year> 1985. </year>
Reference-contexts: Our algorithm for this task is an adaptation of a well-known procedure for factoring polynomials over number fields, as described in, e.g., <ref> [4, 19, 21] </ref>. Applying Theorem 2 to the asymptotically good sequence of Garcia-Stichtenoth function fields [10] allows us to construct sequences of [n; k; e; b] q 2-codes having excellent parameters. This application is carried out in Section 5. The bottleneck of our algorithm is the factorization routine. <p> This example should serve as a prototype for how to proceed in the case of a general separable extension. We now continue with our solution, which adapts a well-known procedure for factoring univari-ate polynomials over number fields <ref> [4, 19, 21] </ref>. To each 2 K there corresponds a unique g 2 L [Y ] of degree less than deg (f ) such that = g (!).
Reference: [20] <author> S. Lang. </author> <title> Algebra. </title> <publisher> Addison-Wesley, </publisher> <address> third edition, </address> <year> 1993. </year>
Reference-contexts: We then factor ~ N (X; T ) 2 F q [X; T ] using a bivariate factorization algorithm. This takes deterministic time polynomial in q and the degree of ~ N [11, 22]. By the Gau Lemma <ref> [20, Chap. IV, Thm. 2.1] </ref>, the irreducible factors of N in L [T ] exactly correspond to the irreducible factors of ~ N in F q [X; T ].
Reference: [21] <author> A.K. Lenstra. </author> <title> Factoring polynomials over algebraic number fields. </title> <type> Technical Report IW213/82, </type> <institution> Dept. Comp. Science, Stichting Mathematisch Centrum, </institution> <address> Amsterdam, </address> <year> 1982. </year>
Reference-contexts: Our algorithm for this task is an adaptation of a well-known procedure for factoring polynomials over number fields, as described in, e.g., <ref> [4, 19, 21] </ref>. Applying Theorem 2 to the asymptotically good sequence of Garcia-Stichtenoth function fields [10] allows us to construct sequences of [n; k; e; b] q 2-codes having excellent parameters. This application is carried out in Section 5. The bottleneck of our algorithm is the factorization routine. <p> This example should serve as a prototype for how to proceed in the case of a general separable extension. We now continue with our solution, which adapts a well-known procedure for factoring univari-ate polynomials over number fields <ref> [4, 19, 21] </ref>. To each 2 K there corresponds a unique g 2 L [Y ] of degree less than deg (f ) such that = g (!).
Reference: [22] <author> A.K. Lenstra. </author> <title> Factoring multivariate polynomials over finite fields. </title> <booktitle> In Proc. 15th STOC, </booktitle> <pages> pages 189-192, </pages> <year> 1983. </year> <month> 17 </month>
Reference-contexts: We then factor ~ N (X; T ) 2 F q [X; T ] using a bivariate factorization algorithm. This takes deterministic time polynomial in q and the degree of ~ N <ref> [11, 22] </ref>. By the Gau Lemma [20, Chap. IV, Thm. 2.1], the irreducible factors of N in L [T ] exactly correspond to the irreducible factors of ~ N in F q [X; T ].
Reference: [23] <author> J.H. van Lint. </author> <title> Introduction to Coding Theory, volume 86 of Graduate Texts in Mathematics. </title> <publisher> Springer Verlag, </publisher> <year> 1982. </year>
Reference-contexts: In Section 9 we investigate asymptotic properties of [n; k; e; b] q -codes. We define analogues of the function ff q <ref> [23, Def. 5.1.2] </ref> for our new classes of [n; k; e; b] q -codes and [n; k; e; 1] p q -codes, and derive lower bounds for these functions by creating asymptotically good sequences of AG-codes. <p> Observe that 1 q is precisely the set of all (*; R) such that (2*; R) 2 q . Furthermore, we have obvious inclusions 1 q R q b 0 The function ff q : [0; 1] ! [0; 1], defined in <ref> [23, Def. 5.1.2] </ref>, describes the boundary of q . To be precise, q is the set of all (ffi; R) such that R ff q (ffi).
Reference: [24] <author> Yu.I. Manin. </author> <title> What is the maximum number of points on a curve over F 2 ? J. </title> <journal> Fac. Sci. Tokio, </journal> <volume> 28 </volume> <pages> 715-720, </pages> <year> 1981. </year>
Reference-contexts: We introduced the functions fi b q , fi ! q , which are natural variants of the well-known function ff q . Manin <ref> [24] </ref> has proved the continuity of ff q . This motivates us to ask: q , fi ! q continuous? We have proved lower bounds analogous to the Tsfasman-Vladut-Zink bound [43] for fi b q , fi ! fi R q .
Reference: [25] <author> R. Motwani and P. Raghavan. </author> <title> Randomized Algorithms. </title> <publisher> Cambridge University Press, </publisher> <year> 1995. </year>
Reference-contexts: Proof. (1) From <ref> [25, Prob. 4.7 (c), p. 98] </ref>. (2) The specified tail-probability is evidently upper-bounded by the probability, if we threw the items into two bins so that each item had independent probability 0.5 of landing in the first bin, that the first bin would receive more than e=2 + ffin bad items. <p> Using (1) and <ref> [25, Prob. 4.6] </ref>, this probability is at most exp (2ffi 2 n). 2 Theorem 18. Let C be an [n; k; d] q -AG-code built over an algebraic function field of genus g. Let ff := k + g 1 and fi := d ffn + g 1e.
Reference: [26] <author> M.E. O'Sullivan. </author> <title> Decoding of codes defined by a single point on a curve. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 41 </volume> <pages> 1709-1719, </pages> <year> 1995. </year>
Reference: [27] <author> R. Pellikaan. </author> <title> On a decoding algorithm for codes on maximal curves. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 35 </volume> <pages> 1228-1232, </pages> <year> 1989. </year>
Reference: [28] <author> A. Peralta. </author> <title> A simple and fast probabilistic algorithm for computing square roots modulo a prime number. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 32 </volume> <pages> 846-847, </pages> <year> 1986. </year>
Reference-contexts: This task of solving a quadratic equation over a finite field F q d can be easily accomplished. E.g., using the method of <ref> [28] </ref> if q is odd, or that of [34] if q is even. Call the solutions x 1 ; x 2 .
Reference: [29] <author> S.C. Porter, B.Z. Shen, and R. Pellikaan. </author> <title> Decoding geometric Goppa codes using an extra place. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 38 </volume> <pages> 1663-1676, </pages> <year> 1992. </year>
Reference-contexts: The encoding algorithm for an AG-code requires us to know a specific basis of L (ffQ). Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities [15, 16]. The following lemma <ref> [29, Prop. 3] </ref> shows that it suffices to know a special basis of L ((2g + 1)Q). Lemma 3.
Reference: [30] <author> S. Sakata, J. Justesen, Y. Madelung, H.E. Jensen, and T. Htholdt. </author> <title> Fast decoding of algebraic-geometric codes up to the designed minimum distance. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 41 </volume> <pages> 1672-1677, </pages> <year> 1995. </year>
Reference: [31] <author> M.A. Shokrollahi. </author> <title> Codes on Hermitian curves. </title> <editor> In Th. Beth and M. Clausen, editors, </editor> <booktitle> Proc. AAECC-4, number 307 in Lecture Notes in Computer Science, </booktitle> <pages> pages 168-176. </pages> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: In all of these cases the crucial assertion is that S is polynomial in n. To prove this, we will explicitly construct the functions ' i . The basis computation for elliptic function fields is trivial. The basis computation for Hermitian function fields is well known: e.g., refer to <ref> [31, 38] </ref>. However, our basis computation for the case of F 3 seems to be novel.
Reference: [32] <author> M.A. Shokrollahi. </author> <title> Beitrage zur Codierungs- und Komplexitatstheorie mittels algebraischer Funktionenkorper. </title> <journal> Bayreuth. math. Schriften, </journal> <volume> 39 </volume> <pages> 1-236, </pages> <year> 1992. </year>
Reference-contexts: An application of the Riemann-Roch Theorem proves that C is an [n; ff g + 1; d] q -code, where d n ff. The quantity d fl := n ff is called the designed distance of C. For further information on AG-codes, we refer the reader to <ref> [13, 14, 32, 39, 42] </ref>. The encoding algorithm for an AG-code requires us to know a specific basis of L (ffQ). Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities [15, 16].
Reference: [33] <author> M.A. Shokrollahi. </author> <title> Efficient randomized generation of algorithms for multiplication in certain finite fields. </title> <journal> Comp. Compl., </journal> <volume> 2 </volume> <pages> 67-96, </pages> <year> 1992. </year>
Reference-contexts: This step depends on the presentation of the algebraic function field (or the curve) and can be performed off-line using probabilistic methods. (For a demonstration of how, for instance, to do this in the case of elliptic curves, the reader may consult <ref> [33] </ref>.) Now suppose that ' 1 ; : : : ; ' ` is a basis of the space L (ffQ).
Reference: [34] <author> M.A. Shokrollahi and K. Werther. </author> <title> Generation of optimal bilinear multiplication algorithms: theory and implementation. </title> <type> Technical report, </type> <institution> Department of Computer Sciene, Universitat Bonn, </institution> <year> 1992. </year>
Reference-contexts: This task of solving a quadratic equation over a finite field F q d can be easily accomplished. E.g., using the method of [28] if q is odd, or that of <ref> [34] </ref> if q is even. Call the solutions x 1 ; x 2 .
Reference: [35] <author> V.M. Sidel'nikov. </author> <title> Decoding the Reed-Solomon code when the number of errors is greater than (d 1)=2, and zeros of polynomials in several variables. Problems Inform. </title> <journal> Transmission, </journal> <volume> 30 </volume> <pages> 44-59, </pages> <year> 1994. </year>
Reference-contexts: Welch and Berlekamp [46, 2] designed an algorithm that could correct (d 1)=2 + 1 errors in time O (n 2 ). Dumer [6] developed an algorithm that could correct d=2 + O (log n) errors in time O (n 2 ). Sidel'nikov <ref> [35] </ref> gave another algorithm based on computing zeros of multivariate polynomials. A different line of thought was pursued by Sudan [40, 41], who, extending results of Ar et al. [1], investigated alternative decoding algorithms for Reed-Solomon codes.
Reference: [36] <author> J.H. Silverman. </author> <title> The Arithmetic of Elliptic Curves, volume 106 of Graduate Texts in Mathematics. </title> <publisher> Springer Verlag, </publisher> <year> 1986. </year>
Reference-contexts: It is well known that K has genus 1. (For these and related facts about elliptic curves, the reader may consult standard texts such as <ref> [36] </ref>.) Evidently, the size of f as well as [K: L] are constants. Thus we need only construct basis functions ' 1 ; : : :; ' n and show that S, the sum of their sizes, is polynomial in n.
Reference: [37] <author> A.N. Skorbogatov and S.G. Vladut. </author> <title> On decoding of algebraic-geometric codes. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 36 </volume> <pages> 1051-1060, </pages> <year> 1990. </year>
Reference: [38] <author> H. Stichtenoth. </author> <title> A note on Hermitian codes over GF (q 2 ). IEEE Trans. </title> <journal> Inform. Theory, </journal> <volume> 34 </volume> <pages> 1345-1348, </pages> <year> 1988. </year>
Reference-contexts: In all of these cases the crucial assertion is that S is polynomial in n. To prove this, we will explicitly construct the functions ' i . The basis computation for elliptic function fields is trivial. The basis computation for Hermitian function fields is well known: e.g., refer to <ref> [31, 38] </ref>. However, our basis computation for the case of F 3 seems to be novel.
Reference: [39] <author> H. Stichtenoth. </author> <title> Algebraic Function Fields and Codes. </title> <publisher> Universitext. Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Section 10 also includes a novel basis computation for the Garcia-Stichtenoth function field F 3 . Finally, Section 11 gives conclusions and poses open problems. 2 AG-Codes Throughout this paper we will use the terminology of algebraic function fields, for which we refer the reader to <ref> [39] </ref>. Let K=F q be an algebraic function field of one variable with field of constants F q , genus g, and distinct prime divisors of degree one Q; P 1 ; : : : ; P n . Let ff be a non-negative integer less than n. <p> An application of the Riemann-Roch Theorem proves that C is an [n; ff g + 1; d] q -code, where d n ff. The quantity d fl := n ff is called the designed distance of C. For further information on AG-codes, we refer the reader to <ref> [13, 14, 32, 39, 42] </ref>. The encoding algorithm for an AG-code requires us to know a specific basis of L (ffQ). Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities [15, 16]. <p> The basis computation for Hermitian function fields is well known: e.g., refer to [31, 38]. However, our basis computation for the case of F 3 seems to be novel. Throughout this section we assume familiarity with the theory of algebraic function fields as presented in <ref> [39] </ref>. 10.1 Elliptic Codes For simplicity we will assume in this subsection that the characteristic of F q is different from 2 or 3.
Reference: [40] <author> M. Sudan. </author> <title> Maximum likelihood decoding of Reed-Solomon codes. </title> <booktitle> In Proc. 37th FOCS, </booktitle> <pages> pages 164-172, </pages> <year> 1996. </year>
Reference-contexts: Dumer [6] developed an algorithm that could correct d=2 + O (log n) errors in time O (n 2 ). Sidel'nikov [35] gave another algorithm based on computing zeros of multivariate polynomials. A different line of thought was pursued by Sudan <ref> [40, 41] </ref>, who, extending results of Ar et al. [1], investigated alternative decoding algorithms for Reed-Solomon codes.
Reference: [41] <author> M. Sudan. </author> <title> Decoding of Reed-Solomon codes beyond the error-correction bound. </title> <journal> J. Compl., </journal> <volume> 13 </volume> <pages> 180-193, </pages> <year> 1997. </year>
Reference-contexts: Dumer [6] developed an algorithm that could correct d=2 + O (log n) errors in time O (n 2 ). Sidel'nikov [35] gave another algorithm based on computing zeros of multivariate polynomials. A different line of thought was pursued by Sudan <ref> [40, 41] </ref>, who, extending results of Ar et al. [1], investigated alternative decoding algorithms for Reed-Solomon codes. <p> Suppose that y = (y 1 ; : : : ; y n ) 2 F n q is such that x and y agree in at least fi + 1 coordinate places. We will prove that the following algorithm (a generalization of Sudan's <ref> [41] </ref>) computes a list of at most d p 2n=ff e codewords one of which must be x: 1. (Interpolation Step) Let s := b (fi g + 1)=ffc. <p> 3 , which by the Riemann-Roch Theorem is the number of gaps at Q. 2 It is now straightforward to check that L (nQ) has a basis as specified in Theorem 22 (2) whose size is polynomial in n. 11 Conclusions and Open Problems We have generalized Sudan's Reed-Solomon results <ref> [41] </ref> to algebraic-geometric codes. We have introduced the class of [n; k; e; b] q -codes, and have demonstrated that there exist [n; k; e; b] q -AG-codes for which e is surprisingly close to n while k=n is bounded away from zero and b is small.
Reference: [42] <author> M.A. Tsfasman and S.G. Vladut. </author> <title> Algebraic-Geometric Codes. Mathematics and Its Applications. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Dordrecht, </address> <year> 1991. </year>
Reference-contexts: An application of the Riemann-Roch Theorem proves that C is an [n; ff g + 1; d] q -code, where d n ff. The quantity d fl := n ff is called the designed distance of C. For further information on AG-codes, we refer the reader to <ref> [13, 14, 32, 39, 42] </ref>. The encoding algorithm for an AG-code requires us to know a specific basis of L (ffQ). Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities [15, 16].
Reference: [43] <author> M.A. Tsfasman, S.G. Vladut, and Th. Zink. </author> <title> Modular curves, Shimura curves, and Goppa codes better than the Varshamov-Gilbert bound. </title> <journal> Math. Nachrichten, </journal> <volume> 109 </volume> <pages> 21-28, </pages> <year> 1982. </year>
Reference-contexts: Manin [24] has proved the continuity of ff q . This motivates us to ask: q , fi ! q continuous? We have proved lower bounds analogous to the Tsfasman-Vladut-Zink bound <ref> [43] </ref> for fi b q , fi ! fi R q . However, these lower bounds do not appear to be tight. In particular, it would be of pragmatic interest to find lower bounds which are non-trivial when the field size q is small or the rate R is high.
Reference: [44] <author> S.G. Vladut. </author> <title> On the decoding of algebraic-geometric codes over F q for q 16. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 36 </volume> <pages> 1461-1463, </pages> <year> 1990. </year>
Reference: [45] <author> H. Wasserman. </author> <title> Reconstructing randomly sampled multivariate polynomials from highly noisy data. </title> <booktitle> In Proc. 9th SODA, </booktitle> <year> 1998. </year>
Reference-contexts: Here we shall accompany our existence result with an efficient decoding algorithm. Indeed, this algorithm will have the advantage of being more efficient than our main algorithm of Section 4. The new algorithm (which extends a method of <ref> [45] </ref>) is suggested by the proof of Theorem 2. In that proof, one constructs a polynomial G such that G (P i ; y i ) = 0 for i = 1; : : :; n.
Reference: [46] <author> L.R. Welch and E.R. Berlekamp. </author> <title> Error correction for algebraic block codes. </title> <type> U.S. Patent 4,633,470, issued Dec. 30, </type> <institution> 1986. M. Amin Shokrollahi International Computer Science Institute 1947 Center Street, Suite 600 Berkeley, CA 94704-1198 amin@icsi.berkeley.edu http://www.icsi.berkeley.edu/~amin Hal Wasserman Computer Science Division University of California Berkeley, </institution> <address> CA 94720 halw@cs.berkeley.edu http://http.cs.berkeley.edu/~halw 19 </address>
Reference-contexts: The decoding task associated with an [n; k; e; b] q -code requires methods quite different from those customarily employed for error-correction. For Reed-Solomon codes, several researchers investigated decoding algorithms that could correct more than (d1)=2 errors. Welch and Berlekamp <ref> [46, 2] </ref> designed an algorithm that could correct (d 1)=2 + 1 errors in time O (n 2 ). Dumer [6] developed an algorithm that could correct d=2 + O (log n) errors in time O (n 2 ). <p> Sidel'nikov [35] gave another algorithm based on computing zeros of multivariate polynomials. A different line of thought was pursued by Sudan [40, 41], who, extending results of Ar et al. [1], investigated alternative decoding algorithms for Reed-Solomon codes. By generalizing a decoding algorithm of Welch and Berlekamp <ref> [46, 2] </ref>, he derived the surprising result that an [n; k] q Reed-Solomon code is an [n; k; e; b] q -code such that e is approximately n p 2kn and b is approximately p 2n=k.
References-found: 46

