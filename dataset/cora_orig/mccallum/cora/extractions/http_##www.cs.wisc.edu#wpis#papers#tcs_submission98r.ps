URL: http://www.cs.wisc.edu/wpis/papers/tcs_submission98r.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Title: Interconvertibility of a Class of Set Constraints and Context-Free-Language Reachability 1  
Author: David Melski Thomas Reps 
Date: May 14, 1998  
Affiliation: Computer Sciences Department University of Wisconsin  Computer Sciences Department University of Wisconsin  
Abstract: We show the interconvertibility of context-free-language reachability problems and a class of set-constraint problems: given a context-free-language reachability problem, we show how to construct a set-constraint problem whose answer gives a solution to the reachability problem; given a set-constraint problem, we show how to construct a context-free-language reachability problem whose answer gives a solution to the set-constraint problem. The interconvertibility of these two formalisms offers an conceptual advantage akin to the advantage gained from the interconvertibility of finite-state automata and regular expressions in formal language theory, namely, a problem can be formulated in whichever formalism is most natural. It also offers some insight into the "O(n 3 ) bottleneck" for different types of program-analysis problems, and allows results previously obtained for context-free-language reachability problems to be applied to set-constraint problems and vice versa.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Afrati and C. H. Papadimitriou. </author> <title> The parallel complexity of simple chain queries. </title> <booktitle> In Proceedings of the 6yd ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 210-214, </pages> <year> 1987. </year>
Reference-contexts: This paper shows this to be the case for the class of definite set-constraint problems. 1 * CFL-reachability is known to be log-space complete for polynomial time (or "PTIME-complete") <ref> [1, 38, 48] </ref>. Because the CFL-reachability to set-constraint construction can be performed in log-space, this paper demonstrates that a class of set-constraint problems are also PTIME-complete. <p> This means that there is a log-space Turing machine program P that is equivalent to P 2 ffi P 0 1 and performs the construction of this section for an arbitrary context-free grammar. Since CFL-reachability problems are PTIME-complete (i.e., complete for PTIME under log-space reductions) <ref> [1, 38, 48] </ref>, this means that the given class of set-constraint problems are also PTIME-complete [27]. 3.5 Analysis of the Running Time In general, an all-pairs CFL-reachability problem can be solved in time O (n 3 ), where n is the number of nodes in the graph. <p> However, the problem of satisfiability for some classes of set constraints is NEXPTIME-complete [49, 7]. Since CFL-reachability is PTIME-complete <ref> [1, 38, 48] </ref>, it is impossible to use CFL-reachability to cover these classes of set constraints (and it is unclear whether one can develop a more powerful graph-reachability techniques that would handle them).
Reference: [2] <author> A. Aiken and B. Murphy. </author> <title> Implementing regular tree expressions. </title> <booktitle> In Proceedings of the 1991 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 427-447, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Typically, a set variable is created for each program variable at each program point. Set constraints are then generated that approximate the program's behavior. Program analysis then becomes a problem of finding the least solution of the set-constraint problem. Set constraints have been used for program analysis, including <ref> [2, 17, 19, 28, 43] </ref>, and type inference, including [3, 4]. Numerous classes of set constraints have been identified and studied.
Reference: [3] <author> A. Aiken and B. Murphy. </author> <title> Static type inference in a dynamically typed language. </title> <booktitle> In Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 279-290, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Set constraints are then generated that approximate the program's behavior. Program analysis then becomes a problem of finding the least solution of the set-constraint problem. Set constraints have been used for program analysis, including [2, 17, 19, 28, 43], and type inference, including <ref> [3, 4] </ref>. Numerous classes of set constraints have been identified and studied.
Reference: [4] <author> A. Aiken and E. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Set constraints are then generated that approximate the program's behavior. Program analysis then becomes a problem of finding the least solution of the set-constraint problem. Set constraints have been used for program analysis, including [2, 17, 19, 28, 43], and type inference, including <ref> [3, 4] </ref>. Numerous classes of set constraints have been identified and studied.
Reference: [5] <author> Uwe Assmann. </author> <title> On Edge Addition Rewrite Systems and Their Relevance to Program Analysis. </title> <editor> In J. Cuny, editor, </editor> <booktitle> 5th Workshop on Graph Grammars and Their Application To Computer Science, volume 1073 of Lecture Notes in Computer Science, </booktitle> <address> Williamsburg, Virginia, </address> <month> November </month> <year> 1994 1995. </year> <note> Springer. 45 </note>
Reference-contexts: In fact, the CFL-reachability Algorithm presented in Section 2.1.1 in effect emulates semi-naive bottom-up evaluation of the equivalent DATALOG program. This suggests that the class of DATALOG programs that run in cubic time may be useful for program analysis (see also <ref> [36, 5] </ref>). The construction described in Section 4 also implies that the class of set-constraints studied in this paper may also be solved by converting them to equivalent DATALOG programs. In fact, many parts of the set-constraint-to-CFL-reachability-problem constructions are more easily expressed in DATALOG.
Reference: [6] <author> W.A. Babich and M. Jazayeri. </author> <title> The method of attributes for data flow analysis: Part ii. demand analysis. </title> <journal> Acta Inf., </journal> <volume> 10(3) </volume> <pages> 265-272, </pages> <month> October </month> <year> 1978. </year>
Reference-contexts: By contrast, a demand program-analysis algorithm computes a partial solution to a problem, when only part of the full answer is needed | e.g., whether a particular fact (or set of facts) holds at a single specific point <ref> [6, 52, 36, 12, 37, 24, 44] </ref>. Demand analysis can sometimes be preferable to exhaustive analysis for the following reasons: Narrowing the focus to specific points of interest .
Reference: [7] <author> L. Bachmir, H. Ganzinger, and U. Waldmann. </author> <title> Set constraints are the monadic class. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 75-83, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: However, the problem of satisfiability for some classes of set constraints is NEXPTIME-complete <ref> [49, 7] </ref>. Since CFL-reachability is PTIME-complete [1, 38, 48], it is impossible to use CFL-reachability to cover these classes of set constraints (and it is unclear whether one can develop a more powerful graph-reachability techniques that would handle them).
Reference: [8] <author> D. Callahan. </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 47-56, </pages> <year> 1988. </year>
Reference-contexts: This approach was later applied to intraprocedural bi-directional bit-vector problems [31]. Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis [9] and alias analysis [10]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis <ref> [8] </ref> and Horwitz, Reps, and Binkley's work on interprocedural slicing [22, 23].
Reference: [9] <author> K.D. Cooper and K. Kennedy. </author> <title> Interprocedural side-effect analysis in linear time. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 57-66, </pages> <year> 1988. </year>
Reference-contexts: Kou [32] and Hecht [15] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to intraprocedural bi-directional bit-vector problems [31]. Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis <ref> [9] </ref> and alias analysis [10]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [8] and Horwitz, Reps, and Binkley's work on interprocedural slicing [22, 23].
Reference: [10] <author> K.D. Cooper and K. Kennedy. </author> <title> Fast interprocedural alias analysis. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-59, </pages> <year> 1989. </year>
Reference-contexts: Kou [32] and Hecht [15] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to intraprocedural bi-directional bit-vector problems [31]. Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis [9] and alias analysis <ref> [10] </ref>. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [8] and Horwitz, Reps, and Binkley's work on interprocedural slicing [22, 23].
Reference: [11] <author> D. Dolev, S. Even, and R.M. Karp. </author> <title> On the security of ping-pong protocols. </title> <journal> Information and Control, </journal> <volume> 55 </volume> <pages> 57-68, </pages> <year> 1982. </year>
Reference-contexts: complexity of set-based analysis with data constructors [33, 20]. 7.3 Applications of CFL-reachability Dolev, Even, and Karp used CFL-reachability to devise a formal model for studying the vulnerability to intrusion by a third party of a class of two-party ("ping-pong") protocols in distributed systems to intrusion by a third party <ref> [11] </ref>. Although messages in the system are protected by public-key encryption, in the setting studied by Dolev, Even, and Karp, the intruder . . . may be a legitimate user in the network. <p> Jon Kleinberg pointed out to us the use of CFL-reachability in reference <ref> [11] </ref>. A Correctness of the CFL-reachability to Set-constraint Construc tion Lemma A.1 Let C be a collection of set constraints containing the constraint V ae 1 , where ae 1 is an atomic expression that does not appear in any other constraint.
Reference: [12] <author> E. Duesterwald, R. Gupta, </author> <title> and M.L. Soffa. Demand-driven computation of interprocedural data flow. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 37-48, </pages> <year> 1995. </year>
Reference-contexts: By contrast, a demand program-analysis algorithm computes a partial solution to a problem, when only part of the full answer is needed | e.g., whether a particular fact (or set of facts) holds at a single specific point <ref> [6, 52, 36, 12, 37, 24, 44] </ref>. Demand analysis can sometimes be preferable to exhaustive analysis for the following reasons: Narrowing the focus to specific points of interest .
Reference: [13] <author> M. J. Fischer and A. R. Meyer. </author> <title> Boolean matrix multiplication and transitive closure. </title> <booktitle> In Conference Record of the IEEE 12th Symposium on Switching and Automata Theory, </booktitle> <year> 1971. </year>
Reference-contexts: This is sometimes (erroneously) attributed to the need to perform transitive closure when a problem is solved. However, because transitive closure can be performed in sub-cubic time <ref> [13] </ref>, this is not the correct explanation. We have long believed that, in many cases, real source of the O (n 3 ) bottleneck is that a CFL-reachability problem needs to be solved.
Reference: [14] <author> F. Gecseg and M. Steinby. </author> <title> Tree Automata. </title> <publisher> Akademiai Kiado, </publisher> <year> 1984. </year>
Reference-contexts: terms is a trivial solution to any collection of constraints. (This is not generally true of all classes of constraints; it holds here because all of our constraints are positive (i.e., without negation symbols).) The solution to a collection of set constraints can be written as a regular term grammar <ref> [14] </ref>, which is a formalism that allows certain infinite sets of terms to be represented in a finite manner. There are standard algorithms for dealing with regular term grammars (e.g., for determining membership) [14]. <p> symbols).) The solution to a collection of set constraints can be written as a regular term grammar <ref> [14] </ref>, which is a formalism that allows certain infinite sets of terms to be represented in a finite manner. There are standard algorithms for dealing with regular term grammars (e.g., for determining membership) [14]. A regular term grammar consists of a finite, non-empty set of non-terminals, a set of function symbols, and a finite set of productions. Each function symbol has a fixed arity. Productions are of the form N ) term where N is a non-terminal.
Reference: [15] <author> M.S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: Yannakakis surveys the literature up to 1990 on applications of graph-theoretic methods in database theory [51]. He discusses many types of graph-reachability problems, including CFL-reachability. A variety of work exists that has applied graph reachability (of various forms) to analysis of imperative programs. Kou [32] and Hecht <ref> [15] </ref> gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to intraprocedural bi-directional bit-vector problems [31]. Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis [9] and alias analysis [10].
Reference: [16] <author> N. Heintze. </author> <title> Set-based program analysis. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: an all-pairs CFL-reachability problem can be solved in time O (n 3 ) (where the constant of proportionality is cubic in jj). 2.2 Set Constraints In this section, we define a class of set constraints. (The material in this section is a summary of work done by Heintze and Jaffar <ref> [16, 17, 18] </ref>.) 2.2.1 Set Expressions and Set Constraints In the class of set constraints we deal with, a set expression is either a set variable (denoted by V , W , X, etc.) or has one of the following forms: * c (V 1 ; : : : ; V <p> Heintze formalizes this idea in <ref> [16] </ref>. Note that a collection of set constraints must always have a solution. <p> Such constraints are said to be in explicit form <ref> [16] </ref>: A constraint is in explicit form if it is of the form V c (V 1 ; : : : ; V r ). <p> When no more constraints can be added, the constraints in explicit form are converted to a regular term grammar; this describes the least solution <ref> [16] </ref>. 2 The SC-Reduction Algorithm does not generate new atomic expressions; this means that when the algorithm finishes, for a fixed variable Y , the number of constraints of the form Y c (V 1 ; V 2 ; : : : ; V r ) in C is bound by
Reference: [17] <author> N. Heintze. </author> <title> Set based analyis of ML programs. </title> <type> Technical Report CMU-CS-93-193, </type> <institution> Carnegie Mellon University, </institution> <year> 1993. </year>
Reference-contexts: Typically, a set variable is created for each program variable at each program point. Set constraints are then generated that approximate the program's behavior. Program analysis then becomes a problem of finding the least solution of the set-constraint problem. Set constraints have been used for program analysis, including <ref> [2, 17, 19, 28, 43] </ref>, and type inference, including [3, 4]. Numerous classes of set constraints have been identified and studied. <p> However, our interconvertibility results show that CFL-reachability can be used to analyze strict languages, and set constraints with strict semantics can be used to analyze lazy languages. A different class of set constraints has been used by Heintze to formulate analysis problems for a higher-order language (ML) <ref> [17] </ref>. In Section 5, we show how set-constraint problems of this class can be converted to CFL-reachability problems while preserving cubic-time solvability (i.e., cubic in the size of the original problem). <p> an all-pairs CFL-reachability problem can be solved in time O (n 3 ) (where the constant of proportionality is cubic in jj). 2.2 Set Constraints In this section, we define a class of set constraints. (The material in this section is a summary of work done by Heintze and Jaffar <ref> [16, 17, 18] </ref>.) 2.2.1 Set Expressions and Set Constraints In the class of set constraints we deal with, a set expression is either a set variable (denoted by V , W , X, etc.) or has one of the following forms: * c (V 1 ; : : : ; V <p> is constant, and v and n are in the worst case proportional to t, the total running time of the algorithm is bounded by O (t 3 ). 5 Solving ML Set-Constraint Problems Using CFL-reachability Heintze has used a modified class of set constraints for set-based analysis of ML programs <ref> [17] </ref>. <p> Expressions of this form do not directly correspond to any language construct. They are used to make set based analysis more accurate by preventing constraints that correspond to certain infeasible execution configurations from contributing to the solution <ref> [17, 43] </ref>. ML set constraints are of the form V se, where se is an ML set expression. A solution to a collection of ML set constraints is a mapping from set variables to a set of values such that the constraints are satisfied. <p> if X X 0 and X 0 se both appear it C, where X 0 se is in explicit form, then add X se to C When no more constraints can be added, the constraints in explicit form are converted to a regular term grammar; this describes the least solution <ref> [17] </ref>. 2 5.2 Solving ML Set-Constraint Problems Using CFL-reachability The idea for encoding an ML set-constraint problem is the same as in Section 4.1: we view the ML SC-Reduction Algorithm as computing what atomic expressions reach each set variable and construct a CFL-reachability problem that computes the same information.
Reference: [18] <author> N. Heintze and J. Jaffar. </author> <title> A decision procedure for a class of set constraints. </title> <type> Technical Report CMU-CS-91-110, </type> <institution> Carnegie Mellon University, </institution> <year> 1991. </year>
Reference-contexts: Numerous classes of set constraints have been identified and studied. Except for Section 5, the class of set constraints considered in this paper is a subclass of what have been called definite set constraints <ref> [18] </ref>; throughout the paper, the term "set constraints" refers to the class of set constraints defined in Section 2.2. <p> an all-pairs CFL-reachability problem can be solved in time O (n 3 ) (where the constant of proportionality is cubic in jj). 2.2 Set Constraints In this section, we define a class of set constraints. (The material in this section is a summary of work done by Heintze and Jaffar <ref> [16, 17, 18] </ref>.) 2.2.1 Set Expressions and Set Constraints In the class of set constraints we deal with, a set expression is either a set variable (denoted by V , W , X, etc.) or has one of the following forms: * c (V 1 ; : : : ; V
Reference: [19] <author> N. Heintze and Joxan Jaffar. </author> <title> Set constraints and set-based analysis. </title> <booktitle> In 2nd Workshop on Priciples and Practice of Constraint Programming, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Typically, a set variable is created for each program variable at each program point. Set constraints are then generated that approximate the program's behavior. Program analysis then becomes a problem of finding the least solution of the set-constraint problem. Set constraints have been used for program analysis, including <ref> [2, 17, 19, 28, 43] </ref>, and type inference, including [3, 4]. Numerous classes of set constraints have been identified and studied.
Reference: [20] <author> N. Heintze and D. McAllester. </author> <title> Linear-time subtransitive control flow analysis. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <year> 1997. </year>
Reference-contexts: 2NPDA-recognition to problems of flow analysis and typability in the Amadio-Cardelli type system. (This is consistent with something we had observed in unpublished work, where we gave a linear-time reduction from the 2NPDA-recognition problem to CFL-reachability.) Heintze and McAllester have also examined the complexity of set-based analysis with data constructors <ref> [33, 20] </ref>. 7.3 Applications of CFL-reachability Dolev, Even, and Karp used CFL-reachability to devise a formal model for studying the vulnerability to intrusion by a third party of a class of two-party ("ping-pong") protocols in distributed systems to intrusion by a third party [11].
Reference: [21] <author> N. Heintze and D. McAllester. </author> <title> On the cubic bottleneck in subtyping and flow analysis. </title> <booktitle> In LICS '97: Proceedings of the IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1997. </year>
Reference-contexts: Heintze and McAllester have also obtained results that have a bearing on this issue by considering the problem of determining membership for languages defined by 34 2-way nondeterministic pushdown automata (2NPDA-recognition) <ref> [21] </ref>. The asymptotically best algorithm known for solving the 2NPDA-recognition problem runs in O (n 3 ) time, and they observe that if there is a linear-time reduction from 2NPDA-recognition to a given problem, then that problem is unlikely to be solvable in better than O (n 3 ) time. <p> In <ref> [21] </ref> reductions are given from 2NPDA-recognition to problems of flow analysis and typability in the Amadio-Cardelli type system. (This is consistent with something we had observed in unpublished work, where we gave a linear-time reduction from the 2NPDA-recognition problem to CFL-reachability.) Heintze and McAllester have also examined the complexity of set-based
Reference: [22] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 35-46, </pages> <year> 1988. </year>
Reference-contexts: Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis [9] and alias analysis [10]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [8] and Horwitz, Reps, and Binkley's work on interprocedural slicing <ref> [22, 23] </ref>.
Reference: [23] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: 1 Introduction This paper concerns algorithms for converting between two techniques for formalizing program-analysis problems: context-free-language reachability and a class of set constraints. Context-free-language reachability (CFL-reachability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interprocedural slicing <ref> [23, 25] </ref>, interprocedural dataflow analysis [24], and shape analysis [37]. Set constraints have been applied to program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. <p> and reason in terms of whichever paradigm is most appropriate. (This is analogous to the situation one has in formal language theory with finite-state automata and regular expressions, or with pushdown automata and context-free grammars.) For example, CFL-reachability leads to natural formulations of interprocedural dataflow analysis [25] and interprocedural slicing <ref> [40, 23] </ref>. Set-constraints lead to natural formulations of shape analysis [29, 43]. <p> Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis [9] and alias analysis [10]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [8] and Horwitz, Reps, and Binkley's work on interprocedural slicing <ref> [22, 23] </ref>. <p> program analysis | show that CFL-reachability using path languages other than Dyck languages is also of utility for program analysis. 35 7.4 Slicing Higher-Order Functional Languages Program slicing is an operation that identifies semantically meaningful decompositions of programs, where the decompositions consist of elements that are not necessarily textually contiguous <ref> [50, 34, 23] </ref>. CFL-reachability has been applied to the problem of slicing programs written in imperative Algol-like languages [23]. Regular-tree grammars have been applied to the problem of slicing programs written in a first-order functional language (that manipulates heap-allocated data structures) [42]. <p> CFL-reachability has been applied to the problem of slicing programs written in imperative Algol-like languages <ref> [23] </ref>. Regular-tree grammars have been applied to the problem of slicing programs written in a first-order functional language (that manipulates heap-allocated data structures) [42].
Reference: [24] <author> S. Horwitz, T. Reps, and M. Sagiv. </author> <title> Demand interprocedural dataflow analysis. </title> <booktitle> In Proceedings of the Fourth ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 104-115, </pages> <month> October </month> <year> 1995. </year> <note> (Available on the WWW from URL http://www.cs.wisc.edu/wpis/papers/fse95.ps). </note>
Reference-contexts: Context-free-language reachability (CFL-reachability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interprocedural slicing [23, 25], interprocedural dataflow analysis <ref> [24] </ref>, and shape analysis [37]. Set constraints have been applied to program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. Typically, a set variable is created for each program variable at each program point. <p> These ideas were elaborated on in a sequence of papers <ref> [25, 24, 40] </ref>, and also applied to shape analysis of functional programs [37]. (See also [39] for a survey of this work.) All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability. <p> By contrast, a demand program-analysis algorithm computes a partial solution to a problem, when only part of the full answer is needed | e.g., whether a particular fact (or set of facts) holds at a single specific point <ref> [6, 52, 36, 12, 37, 24, 44] </ref>. Demand analysis can sometimes be preferable to exhaustive analysis for the following reasons: Narrowing the focus to specific points of interest . <p> It is desirable, therefore, for a demand-driven program-analysis algorithm to minimize the amount of such auxiliary information computed. 37 For program-analysis problems that have been transformed into CFL-reachability problems, demand algorithms are obtained for free, typically by solving a single-target or multi-target CFL-reachability problem <ref> [24] </ref>. Because an algorithm for solving single-target (or multi-target) CFL-reachability problems focuses on the nodes that reach the specific target (s), it minimizes the amount of extraneous information computed.
Reference: [25] <author> S. Horwitz, T. Reps, M. Sagiv, and G. Rosay. </author> <title> Speeding up slicing. </title> <booktitle> In Proceedings of the Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 11-20, </pages> <month> December </month> <year> 1994. </year> <note> (Available on the WWW from URL http://www.cs.wisc.edu/wpis/papers/fse94.ps). </note>
Reference-contexts: 1 Introduction This paper concerns algorithms for converting between two techniques for formalizing program-analysis problems: context-free-language reachability and a class of set constraints. Context-free-language reachability (CFL-reachability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interprocedural slicing <ref> [23, 25] </ref>, interprocedural dataflow analysis [24], and shape analysis [37]. Set constraints have been applied to program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. <p> problem, one can think and reason in terms of whichever paradigm is most appropriate. (This is analogous to the situation one has in formal language theory with finite-state automata and regular expressions, or with pushdown automata and context-free grammars.) For example, CFL-reachability leads to natural formulations of interprocedural dataflow analysis <ref> [25] </ref> and interprocedural slicing [40, 23]. Set-constraints lead to natural formulations of shape analysis [29, 43]. <p> These ideas were elaborated on in a sequence of papers <ref> [25, 24, 40] </ref>, and also applied to shape analysis of functional programs [37]. (See also [39] for a survey of this work.) All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability.
Reference: [26] <author> T. Jensen. </author> <title> Inference of polymorphic and conditional strictness properties. </title> <booktitle> In Proceedings of the 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1998. </year>
Reference-contexts: For alternative treatments of lazy languages using set constraints see <ref> [26, 30] </ref>. Example 4.2 suggests that CFL-reachability might not be powerful enough to express analysis problems for strict languages.
Reference: [27] <author> N. D. Jones and W. T. Laaser. </author> <title> Complete problems for deterministic polynomial time. </title> <booktitle> Theoretical Computer Science 3, </booktitle> <pages> pages 105-117, </pages> <year> 1977. </year>
Reference-contexts: Note that O (log p n) O (log x 2 ) = O (2 log x). For any two log-space Turing machine programs Q and R, there is a log-space Turing machine program that is equivalent to the composition Q ffi R <ref> [27] </ref>. This means that there is a log-space Turing machine program P that is equivalent to P 2 ffi P 0 1 and performs the construction of this section for an arbitrary context-free grammar. <p> Since CFL-reachability problems are PTIME-complete (i.e., complete for PTIME under log-space reductions) [1, 38, 48], this means that the given class of set-constraint problems are also PTIME-complete <ref> [27] </ref>. 3.5 Analysis of the Running Time In general, an all-pairs CFL-reachability problem can be solved in time O (n 3 ), where n is the number of nodes in the graph.
Reference: [28] <author> N. D. Jones and S. S. Muchnick. </author> <title> Flow analysis and optimization of LISP-like structures. Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <year> 1981. </year>
Reference-contexts: Typically, a set variable is created for each program variable at each program point. Set constraints are then generated that approximate the program's behavior. Program analysis then becomes a problem of finding the least solution of the set-constraint problem. Set constraints have been used for program analysis, including <ref> [2, 17, 19, 28, 43] </ref>, and type inference, including [3, 4]. Numerous classes of set constraints have been identified and studied.
Reference: [29] <editor> N.D. Jones and S.S. Muchnick. </editor> <title> Flow analysis and optimization of Lisp-like structures. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 4, </volume> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Set-constraints lead to natural formulations of shape analysis <ref> [29, 43] </ref>. Each of these problems could be formulated using the (respective) opposite formalisms|our interconvertibility result formulates this idea precisely|but it would be awkward. * These constructions also offer some insight into the "O (n 3 ) bottleneck" for program-analysis problems.
Reference: [30] <author> Neil D. Jones. </author> <title> Flow analysis of lazy higher-order functional programs. </title> <editor> In S. Abramsky and C. Hankin, editors, </editor> <booktitle> Abstract Interpretation of Declarative Languages, </booktitle> <pages> pages 103-122. </pages> <publisher> Ellis Horwood, </publisher> <address> Chichester, England, </address> <year> 1987. </year> <month> 46 </month>
Reference-contexts: For alternative treatments of lazy languages using set constraints see <ref> [26, 30] </ref>. Example 4.2 suggests that CFL-reachability might not be powerful enough to express analysis problems for strict languages.
Reference: [31] <author> U.P. Khedker and D.M. Dhamdhere. </author> <title> A generalized theory of bit vector data flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1472-1511, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: A variety of work exists that has applied graph reachability (of various forms) to analysis of imperative programs. Kou [32] and Hecht [15] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to intraprocedural bi-directional bit-vector problems <ref> [31] </ref>. Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis [9] and alias analysis [10]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [8] and Horwitz, Reps, and Binkley's work on interprocedural slicing [22, 23].
Reference: [32] <author> L.T. Kou. </author> <title> On live-dead analysis for global data flow problems. </title> <journal> J. ACM, </journal> <volume> 24(3) </volume> <pages> 473-483, </pages> <month> July </month> <year> 1977. </year>
Reference-contexts: Yannakakis surveys the literature up to 1990 on applications of graph-theoretic methods in database theory [51]. He discusses many types of graph-reachability problems, including CFL-reachability. A variety of work exists that has applied graph reachability (of various forms) to analysis of imperative programs. Kou <ref> [32] </ref> and Hecht [15] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to intraprocedural bi-directional bit-vector problems [31]. Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis [9] and alias analysis [10].
Reference: [33] <author> D. McAllester and N. Heintze. </author> <title> On the complexity of set-based analysis. </title> <booktitle> In ICFP '97: Proceedings of the Second ACM SIGPLAN International Conference on Functional Programming, </booktitle> <year> 1997. </year>
Reference-contexts: 2NPDA-recognition to problems of flow analysis and typability in the Amadio-Cardelli type system. (This is consistent with something we had observed in unpublished work, where we gave a linear-time reduction from the 2NPDA-recognition problem to CFL-reachability.) Heintze and McAllester have also examined the complexity of set-based analysis with data constructors <ref> [33, 20] </ref>. 7.3 Applications of CFL-reachability Dolev, Even, and Karp used CFL-reachability to devise a formal model for studying the vulnerability to intrusion by a third party of a class of two-party ("ping-pong") protocols in distributed systems to intrusion by a third party [11].
Reference: [34] <author> K.J. Ottenstein and L.M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <year> 1984. </year>
Reference-contexts: program analysis | show that CFL-reachability using path languages other than Dyck languages is also of utility for program analysis. 35 7.4 Slicing Higher-Order Functional Languages Program slicing is an operation that identifies semantically meaningful decompositions of programs, where the decompositions consist of elements that are not necessarily textually contiguous <ref> [50, 34, 23] </ref>. CFL-reachability has been applied to the problem of slicing programs written in imperative Algol-like languages [23]. Regular-tree grammars have been applied to the problem of slicing programs written in a first-order functional language (that manipulates heap-allocated data structures) [42].
Reference: [35] <author> J. Palsberg. </author> <title> Closure analysis in constraint form. </title> <journal> toplas, </journal> <volume> 17(1) </volume> <pages> 47-62, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: set constraints as ML set constraints to distinguish them from the set constraints discussed in the earlier part of the paper. (This class of set constraints can be used to express closure analysis| the problem of determining the set of abstractions that can reach an application|and hence related work includes <ref> [35, 47, 45] </ref>.) In this section, we define ML set constraints and then show how to encode an ML set-constraint problem as a CFL-reachability problem. 5.1 ML Set Constraints Similar to set expressions defined in Section 2.2.1, an ML set expression (se) may be a set variable or a constructor of
Reference: [36] <author> T. Reps. </author> <title> Demand interprocedural program analysis using logic databases. </title> <editor> In R. Ramakrishnan, editor, </editor> <booktitle> Applications of Logic Databases. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference-contexts: For example, a demand algorithm might be used to compute the results of a program analysis only for points in the innermost loops of a given program. Because CFL-reachability problems can be solved in a demand-driven fashion (e.g., see <ref> [37, 36] </ref>), this paper shows that (in principle) set-constraint problems can also be solved in a demand-driven fashion. To our knowledge, this has not been investigated before in the literature on set constraints. * CFL-reachability lends itself to analysis of languages with a lazy semantics [37]. <p> In fact, the CFL-reachability Algorithm presented in Section 2.1.1 in effect emulates semi-naive bottom-up evaluation of the equivalent DATALOG program. This suggests that the class of DATALOG programs that run in cubic time may be useful for program analysis (see also <ref> [36, 5] </ref>). The construction described in Section 4 also implies that the class of set-constraints studied in this paper may also be solved by converting them to equivalent DATALOG programs. In fact, many parts of the set-constraint-to-CFL-reachability-problem constructions are more easily expressed in DATALOG. <p> By contrast, a demand program-analysis algorithm computes a partial solution to a problem, when only part of the full answer is needed | e.g., whether a particular fact (or set of facts) holds at a single specific point <ref> [6, 52, 36, 12, 37, 24, 44] </ref>. Demand analysis can sometimes be preferable to exhaustive analysis for the following reasons: Narrowing the focus to specific points of interest .
Reference: [37] <author> T. Reps. </author> <title> Shape analysis as a generalized path problem. </title> <booktitle> In PEPM '95: Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> New York, NY, 1995. </address> <publisher> ACM. </publisher>
Reference-contexts: Context-free-language reachability (CFL-reachability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interprocedural slicing [23, 25], interprocedural dataflow analysis [24], and shape analysis <ref> [37] </ref>. Set constraints have been applied to program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. Typically, a set variable is created for each program variable at each program point. <p> For example, a demand algorithm might be used to compute the results of a program analysis only for points in the innermost loops of a given program. Because CFL-reachability problems can be solved in a demand-driven fashion (e.g., see <ref> [37, 36] </ref>), this paper shows that (in principle) set-constraint problems can also be solved in a demand-driven fashion. To our knowledge, this has not been investigated before in the literature on set constraints. * CFL-reachability lends itself to analysis of languages with a lazy semantics [37]. <p> To our knowledge, this has not been investigated before in the literature on set constraints. * CFL-reachability lends itself to analysis of languages with a lazy semantics <ref> [37] </ref>. Set constraints with strict semantics are more readily used to analyze languages with a strict semantics. However, our interconvertibility results show that CFL-reachability can be used to analyze strict languages, and set constraints with strict semantics can be used to analyze lazy languages. <p> The basic technique is a modification of work done by Reps in using CFL-reachability to do shape analysis <ref> [37] </ref>. In essence, our encoding involves simulating the steps of the SC-Reduction Algorithm with the productions of a reachability problem. <p> These ideas were elaborated on in a sequence of papers [25, 24, 40], and also applied to shape analysis of functional programs <ref> [37] </ref>. (See also [39] for a survey of this work.) All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability. <p> The second author became aware of the connection to the more general concept of CFL-reachability sometime in the fall of 1994. (Of the papers mentioned above, only <ref> [37] </ref> and [39] mention CFL-reachability explicitly and reference Yannakakis's paper [51].) The constructions of the present paper for converting set-constraint problems to CFL-reachability problems | together with the fact that set constraints have been used for program analysis | show that CFL-reachability using path languages other than Dyck languages is also <p> By contrast, a demand program-analysis algorithm computes a partial solution to a problem, when only part of the full answer is needed | e.g., whether a particular fact (or set of facts) holds at a single specific point <ref> [6, 52, 36, 12, 37, 24, 44] </ref>. Demand analysis can sometimes be preferable to exhaustive analysis for the following reasons: Narrowing the focus to specific points of interest .
Reference: [38] <author> T. Reps. </author> <title> On the sequential nature of interprocedural program-analysis problems. </title> <journal> Acta Inf., </journal> <volume> 33 </volume> <pages> 739-757, </pages> <year> 1996. </year>
Reference-contexts: This paper shows this to be the case for the class of definite set-constraint problems. 1 * CFL-reachability is known to be log-space complete for polynomial time (or "PTIME-complete") <ref> [1, 38, 48] </ref>. Because the CFL-reachability to set-constraint construction can be performed in log-space, this paper demonstrates that a class of set-constraint problems are also PTIME-complete. <p> This means that there is a log-space Turing machine program P that is equivalent to P 2 ffi P 0 1 and performs the construction of this section for an arbitrary context-free grammar. Since CFL-reachability problems are PTIME-complete (i.e., complete for PTIME under log-space reductions) <ref> [1, 38, 48] </ref>, this means that the given class of set-constraint problems are also PTIME-complete [27]. 3.5 Analysis of the Running Time In general, an all-pairs CFL-reachability problem can be solved in time O (n 3 ), where n is the number of nodes in the graph. <p> However, the problem of satisfiability for some classes of set constraints is NEXPTIME-complete [49, 7]. Since CFL-reachability is PTIME-complete <ref> [1, 38, 48] </ref>, it is impossible to use CFL-reachability to cover these classes of set constraints (and it is unclear whether one can develop a more powerful graph-reachability techniques that would handle them).
Reference: [39] <author> T Reps. </author> <title> Program analysis via graph reachability. </title> <editor> In J. Maluszynski, editor, </editor> <booktitle> Proceedings of ILPS '97: International Logic Programming Symposium, </booktitle> <pages> pages 5-19. </pages> <publisher> The M.I.T. Press, </publisher> <address> Cambridge, MA, </address> <year> 1997. </year>
Reference-contexts: These ideas were elaborated on in a sequence of papers [25, 24, 40], and also applied to shape analysis of functional programs [37]. (See also <ref> [39] </ref> for a survey of this work.) All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability. <p> The second author became aware of the connection to the more general concept of CFL-reachability sometime in the fall of 1994. (Of the papers mentioned above, only [37] and <ref> [39] </ref> mention CFL-reachability explicitly and reference Yannakakis's paper [51].) The constructions of the present paper for converting set-constraint problems to CFL-reachability problems | together with the fact that set constraints have been used for program analysis | show that CFL-reachability using path languages other than Dyck languages is also of utility
Reference: [40] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reachability. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <year> 1995. </year> <note> (Available on the WWW from URL http://www.cs.wisc.edu/wpis/papers/popl95.ps). </note>
Reference-contexts: and reason in terms of whichever paradigm is most appropriate. (This is analogous to the situation one has in formal language theory with finite-state automata and regular expressions, or with pushdown automata and context-free grammars.) For example, CFL-reachability leads to natural formulations of interprocedural dataflow analysis [25] and interprocedural slicing <ref> [40, 23] </ref>. Set-constraints lead to natural formulations of shape analysis [29, 43]. <p> These ideas were elaborated on in a sequence of papers <ref> [25, 24, 40] </ref>, and also applied to shape analysis of functional programs [37]. (See also [39] for a survey of this work.) All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability.
Reference: [41] <author> T. Reps, M. Sagiv, and S. Horwitz. </author> <title> Interprocedural dataflow analysis via graph reachability. </title> <type> Technical Report TR 94-14, </type> <institution> Datalogisk Institut, University of Copenhagen, </institution> <year> 1994. </year> <note> (Available on the WWW from URL http://www.cs.wisc.edu/wpis/papers/diku-tr94-14.ps). </note>
Reference-contexts: of certain kinds of nonexecutable paths should be filtered out [46]; however, the dataflow-analysis algorithms given by Sharir and Pnueli are based on machinery other than pure graph reachability.) Dyck-language reachability was shown by Reps, Sagiv, and Horwitz to be of utility for a wide variety of interprocedural program-analysis problems <ref> [41] </ref>. These ideas were elaborated on in a sequence of papers [25, 24, 40], and also applied to shape analysis of functional programs [37]. (See also [39] for a survey of this work.) All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability.
Reference: [42] <author> T. Reps and T. Turnidge. </author> <title> Program specialization via program slicing. </title> <editor> In O. Danvy, R. Glueck, and P. Thiemann, editors, </editor> <booktitle> Proc. of the Dagstuhl Seminar on Partial Evaluation, volume 1110 of Lecture Notes in Computer Science, </booktitle> <pages> pages 409-429, </pages> <address> Schloss Dagstuhl, Wadern, Germany, </address> <month> February </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: CFL-reachability has been applied to the problem of slicing programs written in imperative Algol-like languages [23]. Regular-tree grammars have been applied to the problem of slicing programs written in a first-order functional language (that manipulates heap-allocated data structures) <ref> [42] </ref>. We now sketch how the technique developed in the construction given in Section 5 allows CFL-reachability to be applied to the problem of slicing programs written in a higher-order functional language (again that manipulates heap-allocated data structures). <p> The latter problem has not been previously addressed in the literature on program slicing. Following Reps and Turnidge, we consider the problem of slicing a functional program P (x) in terms of symbolically composing P (x) with an appropriate projection function (y) <ref> [42] </ref>. Projection function (y) characterizes what information should be retained and what information should be discarded from the value that P (x) computes.
Reference: [43] <author> J.C. Reynolds. </author> <title> Automatic computation of data set definitions. </title> <booktitle> In Information Processing 68: Proceedings of the IFIP Congress, </booktitle> <pages> pages 456-461, </pages> <address> New York, NY, 1968. </address> <publisher> North-Holland. </publisher>
Reference-contexts: Typically, a set variable is created for each program variable at each program point. Set constraints are then generated that approximate the program's behavior. Program analysis then becomes a problem of finding the least solution of the set-constraint problem. Set constraints have been used for program analysis, including <ref> [2, 17, 19, 28, 43] </ref>, and type inference, including [3, 4]. Numerous classes of set constraints have been identified and studied. <p> Set-constraints lead to natural formulations of shape analysis <ref> [29, 43] </ref>. Each of these problems could be formulated using the (respective) opposite formalisms|our interconvertibility result formulates this idea precisely|but it would be awkward. * These constructions also offer some insight into the "O (n 3 ) bottleneck" for program-analysis problems. <p> Expressions of this form do not directly correspond to any language construct. They are used to make set based analysis more accurate by preventing constraints that correspond to certain infeasible execution configurations from contributing to the solution <ref> [17, 43] </ref>. ML set constraints are of the form V se, where se is an ML set expression. A solution to a collection of ML set constraints is a mapping from set variables to a set of values such that the constraints are satisfied.
Reference: [44] <author> M. Sagiv, T. Reps, and S. Horwitz. </author> <title> Precise interprocedural dataflow analysis with applications to constant propagation. </title> <journal> Theoretical Computer Science, </journal> <volume> 167 </volume> <pages> 131-170, </pages> <year> 1996. </year>
Reference-contexts: By contrast, a demand program-analysis algorithm computes a partial solution to a problem, when only part of the full answer is needed | e.g., whether a particular fact (or set of facts) holds at a single specific point <ref> [6, 52, 36, 12, 37, 24, 44] </ref>. Demand analysis can sometimes be preferable to exhaustive analysis for the following reasons: Narrowing the focus to specific points of interest .
Reference: [45] <author> P. Sestoft. </author> <title> Analysis and Efficient Implementation of Functional Programs. </title> <type> PhD thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <year> 1991. </year>
Reference-contexts: set constraints as ML set constraints to distinguish them from the set constraints discussed in the earlier part of the paper. (This class of set constraints can be used to express closure analysis| the problem of determining the set of abstractions that can reach an application|and hence related work includes <ref> [35, 47, 45] </ref>.) In this section, we define ML set constraints and then show how to encode an ML set-constraint problem as a CFL-reachability problem. 5.1 ML Set Constraints Similar to set expressions defined in Section 2.2.1, an ML set expression (se) may be a set variable or a constructor of
Reference: [46] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 7, </volume> <pages> pages 189-234. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: various kinds of matched-parenthesis (Dyck) languages, and neither paper relates the work to the more general concept of CFL-reachability. (Dyck languages had been used in earlier work on interprocedural dataflow analysis by Sharir and Pnueli to specify that the contributions of certain kinds of nonexecutable paths should be filtered out <ref> [46] </ref>; however, the dataflow-analysis algorithms given by Sharir and Pnueli are based on machinery other than pure graph reachability.) Dyck-language reachability was shown by Reps, Sagiv, and Horwitz to be of utility for a wide variety of interprocedural program-analysis problems [41].
Reference: [47] <author> O. Shivers. </author> <title> Control flow analysis in scheme. </title> <booktitle> In ACM SIGPLAN'88, Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: set constraints as ML set constraints to distinguish them from the set constraints discussed in the earlier part of the paper. (This class of set constraints can be used to express closure analysis| the problem of determining the set of abstractions that can reach an application|and hence related work includes <ref> [35, 47, 45] </ref>.) In this section, we define ML set constraints and then show how to encode an ML set-constraint problem as a CFL-reachability problem. 5.1 ML Set Constraints Similar to set expressions defined in Section 2.2.1, an ML set expression (se) may be a set variable or a constructor of
Reference: [48] <author> J. D. Ullman and A. Van Gelder. </author> <title> Parallel complexity of logical query programs. </title> <booktitle> In Proceedings of the 27th IEEE Symposium on Foundation of Computer Science, </booktitle> <pages> pages 438-454, </pages> <year> 1986. </year>
Reference-contexts: This paper shows this to be the case for the class of definite set-constraint problems. 1 * CFL-reachability is known to be log-space complete for polynomial time (or "PTIME-complete") <ref> [1, 38, 48] </ref>. Because the CFL-reachability to set-constraint construction can be performed in log-space, this paper demonstrates that a class of set-constraint problems are also PTIME-complete. <p> This means that there is a log-space Turing machine program P that is equivalent to P 2 ffi P 0 1 and performs the construction of this section for an arbitrary context-free grammar. Since CFL-reachability problems are PTIME-complete (i.e., complete for PTIME under log-space reductions) <ref> [1, 38, 48] </ref>, this means that the given class of set-constraint problems are also PTIME-complete [27]. 3.5 Analysis of the Running Time In general, an all-pairs CFL-reachability problem can be solved in time O (n 3 ), where n is the number of nodes in the graph. <p> However, the problem of satisfiability for some classes of set constraints is NEXPTIME-complete [49, 7]. Since CFL-reachability is PTIME-complete <ref> [1, 38, 48] </ref>, it is impossible to use CFL-reachability to cover these classes of set constraints (and it is unclear whether one can develop a more powerful graph-reachability techniques that would handle them).
Reference: [49] <author> Charatonik W and L. Pacholski. </author> <title> Set constraints with projections are in nexptime. </title> <booktitle> In Proceedings of 35th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 642-653, </pages> <year> 1994. </year>
Reference-contexts: However, the problem of satisfiability for some classes of set constraints is NEXPTIME-complete <ref> [49, 7] </ref>. Since CFL-reachability is PTIME-complete [1, 38, 48], it is impossible to use CFL-reachability to cover these classes of set constraints (and it is unclear whether one can develop a more powerful graph-reachability techniques that would handle them).
Reference: [50] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: program analysis | show that CFL-reachability using path languages other than Dyck languages is also of utility for program analysis. 35 7.4 Slicing Higher-Order Functional Languages Program slicing is an operation that identifies semantically meaningful decompositions of programs, where the decompositions consist of elements that are not necessarily textually contiguous <ref> [50, 34, 23] </ref>. CFL-reachability has been applied to the problem of slicing programs written in imperative Algol-like languages [23]. Regular-tree grammars have been applied to the problem of slicing programs written in a first-order functional language (that manipulates heap-allocated data structures) [42].
Reference: [51] <author> M. Yannakakis. </author> <title> Graph-theoretic methods in database theory. </title> <booktitle> In Proceedings of the Symposium on Principles of Database Systems, </booktitle> <pages> pages 230-242, </pages> <year> 1990. </year>
Reference-contexts: Yannakakis surveys the literature up to 1990 on applications of graph-theoretic methods in database theory <ref> [51] </ref>. He discusses many types of graph-reachability problems, including CFL-reachability. A variety of work exists that has applied graph reachability (of various forms) to analysis of imperative programs. Kou [32] and Hecht [15] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. <p> The second author became aware of the connection to the more general concept of CFL-reachability sometime in the fall of 1994. (Of the papers mentioned above, only [37] and [39] mention CFL-reachability explicitly and reference Yannakakis's paper <ref> [51] </ref>.) The constructions of the present paper for converting set-constraint problems to CFL-reachability problems | together with the fact that set constraints have been used for program analysis | show that CFL-reachability using path languages other than Dyck languages is also of utility for program analysis. 35 7.4 Slicing Higher-Order Functional <p> return Id return Id ::= input Rev Id input | allow higher-order languages to be handled in the fashion illustrated in Figure 13. 7.5 Connection to DATALOG It is also interesting to note another fact about CFL-reachability problems: every CFL-reachability problem can be stated as a chain program in DATALOG <ref> [51] </ref>; edges are represented as facts, and productions are encoded as Horn clauses. In fact, the CFL-reachability Algorithm presented in Section 2.1.1 in effect emulates semi-naive bottom-up evaluation of the equivalent DATALOG program.
Reference: [52] <author> F.K. Zadeck. </author> <title> Incremental data flow analysis in a structured program editor. </title> <booktitle> In ACM Symposium on Compiler Construction, </booktitle> <pages> pages 132-143, </pages> <year> 1984. </year> <pages> 47 48 49 </pages>
Reference-contexts: By contrast, a demand program-analysis algorithm computes a partial solution to a problem, when only part of the full answer is needed | e.g., whether a particular fact (or set of facts) holds at a single specific point <ref> [6, 52, 36, 12, 37, 24, 44] </ref>. Demand analysis can sometimes be preferable to exhaustive analysis for the following reasons: Narrowing the focus to specific points of interest .
References-found: 52

