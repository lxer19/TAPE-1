URL: http://www.icsi.berkeley.edu/ftp/global/pub/techreports/1994/tr-94-010.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/ftp/global/pub/techreports/1994/
Root-URL: http://www.icsi.berkeley.edu
Title: A Customisable Memory Management Framework  
Author: Giuseppe Attardi Tito Flagella 
Date: February 1994  
Pubnum: TR-94-010  
Abstract: Memory management is a critical issue for many large object-oriented applications, but in C++ only explicit memory reclamation through the delete operator is generally available. We analyse different possibilities for memory management in C++ and present a dynamic memory management framework which can be customised to the need of specific applications. The framework allows full integration and coexistence of different memory management techniques. The Customisable Memory Management (CMM) is based on a primary collector which exploits an evolution of Bartlett's mostly copying garbage collector. Specialised collectors can be built for separate memory heaps. A Heap class encapsulates the allocation strategy for each heap. We show how to emulate different garbage collection styles or user-specific memory management techniques. The CMM is implemented in C++ without any special support in the language or the compiler. The techniques used in the CMM are general enough to be applicable also to other languages. y Dipartimento di Informatica, Universita di Pisa, Corso Italia 40, I-56125 Pisa, Italy. Net: tito@di.unipi.it. This paper appeared in the USENIX C++ Conference Proceedings 1994. The research described here has been funded in part by the ESPRIT Basic Research Action, project PoSSo. Part of this work has been done while the first author was visiting the International Computer Science Institute, Berkeley, California. fl Dipartimento di Informatica, Universita di Pisa, Corso Italia 40, I-56125 Pisa, Italy. Net: attardi@di.unipi.it.
Abstract-found: 1
Intro-found: 1
Reference: [Bartlett 88] <author> Joel F. </author> <title> Bartlett "Compacting garbage collection with ambiguous roots" Tech. </title> <type> Rep. 88/2, </type> <institution> DEC Western Research Laboratory, Palo Alto, California, </institution> <month> February </month> <year> 1988. </year>
Reference: [Bartlett 89] <author> Joel F. </author> <title> Bartlett "Mostly-copying collection picks up generations and C++", </title> <type> Tech. Rep. </type> <institution> TN-12, DEC Western Research Laboratory, Palo Alto, California, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: The CMM is a memory management facility supporting complex memory intensive applications in C++. It consists of: 1. a general purpose garbage collector for C++; this collector is called primary garbage collector and is a variant of Bartlett's mostly copying collector <ref> [Bartlett 89] </ref>; 2. a user interface: this is the interface used by programmers to access the CMM; 3. a programmer interface: a set of facilities used by CMM programmers to define specific memory management policies as appropriate for their applications. <p> The first two mechanisms are already available in the CMM, while a generational collector has been implemented by Bartlett <ref> [Bartlett 89] </ref>. The mechanism to implement these alternative policies is the Heap abstraction which we develop in this paper. Specific algorithms are used and particular data structures are maintained by each Heap to ensure its proper behaviour. <p> These rules ensure that superclasses or class objects contained in the class are correctly handled. The following example illustrates the rules, which are a generalisation of those in <ref> [Bartlett 89] </ref>.
Reference: [Boehm 88] <author> H.-J. Boehm and M. </author> <title> Wiser "Garbage collection in an uncooperative environment", </title> <journal> Software Practice and Experience, </journal> <volume> 18(9), </volume> <year> 1988, </year> <pages> 807-820. </pages>
Reference-contexts: BBStack.collect () ... BBStack.deregister (b); BBStack.deregister (p); - 10 Related Work The Boehm-Wiser collector <ref> [Boehm 88] </ref> is a well known collector for C++ which is convenient to use since it is totally conservative. However is not customisable and is subject to unduly retention of space and memory fragmentation since it cannot compact memory.
Reference: [Breuel 92] <author> Thomas M. </author> <type> Breuel "Personal communication", </type> <month> October </month> <year> 1992. </year>
Reference-contexts: Recent research has proved that many of the limitations of traditional garbage collection techniques can be alleviated. Some experiments have even shown that explicit memory deallocation (using primitives like free or delete) is not necessarily faster than automatic reclamation of free memory <ref> [Breuel 92] </ref>. Techniques like generational garbage collection have been developed to min-imise latency during garbage collection. While these experiences have proved that garbage collection is a valuable technique, the variety of proposals is in itself an indication that the ideal garbage collector is impossible to achieve.
Reference: [Buchberger 85] <author> B. </author> <title> Buchberger, "Grobner bases: an algorithmic method in polynomial ideal theory", Recent trends in multidimensional systems theory, </title> <editor> N. K. Bose, ed., D. </editor> <publisher> Reidel Publ. </publisher> <address> Comp. </address> <year> 1985, </year> <pages> 184-232. </pages>
Reference-contexts: Others prefer a mark-and-sweep approach because of the fixed size of their data. The core algorithms of PoSSo required a special kind of memory management due to the particular FIFO dynamics of memory usage exhibited in certain portions of the Buchberger algorithm for computing a Grobner basis <ref> [Buchberger 85] </ref>. These requirements led us to design a framework whereby users can select among different garbage collection strategies, ranging from manual management to fully automatic garbage collection, and can also implement their own specialised memory management as appropriate for their task. <p> Dependencies between temporaries and persistent data make the use of explicit memory allocation/deallocation nearly impossible, so use of a garbage collector was essential. The main step of the Buchberger algorithm <ref> [Buchberger 85] </ref> consists in the simplification of a polynomial which involves many operations creating a lot of intermediate polynomials of which only the last one is relevant and is inserted into the basis. Once this polynomial has been computed, all the temporary structures allocated can be removed.
Reference: [Detlefs 92] <author> D. L. Detlefs, </author> <title> "Concurrent garbage collection for C++", </title> <type> CMU-CS-90-119, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1990. </year>
Reference-contexts: The updates to pointers are performed only at the end of the algorithm, using the bitmap and the forwarding pointer stored in the objects. This technique is similar to the one suggested by Detlefs <ref> [Detlefs 92] </ref> to handle C/C++ unions of pointers and non-pointers. 5.1 User Collected Heaps With the algorithm described so far, two heaps are available: an uncollected heap for non garbage collected objects and a collected heap.
Reference: [Edelson 92] <author> D.R. </author> <title> Edelson "Precompiling C++ for garbage collection", in Memory Management, </title> <editor> Y. Bekkers and J. Cohen (Eds.), </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> n. 637, </address> <publisher> Springer-Verlag, </publisher> <year> 1992, </year> <pages> 299-314. </pages>
Reference-contexts: C::traverse must contain x.traverse (zone) (c) for a class derived from another collected class, say class C:GcClass f...g, the method C::traverse must contain GcClass::traverse (zone). (d) for a class deriving from a virtual base class, say class C: virtual GcClass f...g, the method C::traverse must contain zone-&gt;scavenge (VirtualBase (GcClass)); Preprocessing <ref> [Edelson 92] </ref> or compiler support [Samples 92] could be adopted to avoid hand coding of these functions and risks of subtle errors in programs. We plan to address this issue in the future. 7.1 Object Creation When creating a collected object one can specify in which Heap to allocate it. <p> Our feeling is that this work demonstrates how the flexibility of object oriented languages can be used to implement a very complex environment, like CMM, without requiring modifications to the language. Edelson <ref> [Edelson 92] </ref> has been experimenting with the coexistance of different garbage collection techniques. The flexibility of the solutions he adopts in his approach allows the coexistance of different garbage collectors, but he does not provide any interface to the user to customise and/or define his own memory management facilities.
Reference: [Edelson 92b] <author> D.R. </author> <title> Edelson "A mark-and-sweep collector for C++", </title> <booktitle> Proc. of ACM Conference on Principle of Programming Languages, </booktitle> <year> 1992. </year>
Reference: [Ellis 93] <author> J.R. Ellis and D.L. </author> <title> Detlefs "Safe, efficient garbage collection for C++", </title> <note> Xerox PARC report CSL-93-4, 1993. 19 </note>
Reference-contexts: This is different from other solutions, where the allocation policy is associated to the type of an object. For instance, in the proposal by Ellis and Detlefs <ref> [Ellis 93] </ref>, it is possible to specify whether an instance or a class is allocated in the collected heap, rather than in the non collected heap. For the purpose of our applications, it is necessary to allocate the same type of object sometimes with one policy and sometimes with another. <p> The traditional uncollected heap is still available through the primitives malloc or new on uncollected classes. The uncollected heap cannot be eliminated since there are programs and libraries which may use uncollected object in an unsafe way for the collector <ref> [Ellis 93] </ref>, and there are objects that can't be relocated. It must be possible however that objects in the uncollected heap point to objects in the collected heap and viceversa. Pointers across heaps must be dealt carefully. <p> The flexibility of the solutions he adopts in his approach allows the coexistance of different garbage collectors, but he does not provide any interface to the user to customise and/or define his own memory management facilities. Ellis and Detlefs <ref> [Ellis 93] </ref> propose some extensions to the C++ language to allow for collectable object. The major change is the addition of the type specifier gc to specify which heap to use in allocating the object or a class.
Reference: [Samples 92] <author> A.D. </author> <title> Samples "GC-cooperative C++", </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> n. 637, </address> <publisher> Springer-Verlag, </publisher> <year> 1992, </year> <pages> 315-329. </pages>
Reference-contexts: (c) for a class derived from another collected class, say class C:GcClass f...g, the method C::traverse must contain GcClass::traverse (zone). (d) for a class deriving from a virtual base class, say class C: virtual GcClass f...g, the method C::traverse must contain zone-&gt;scavenge (VirtualBase (GcClass)); Preprocessing [Edelson 92] or compiler support <ref> [Samples 92] </ref> could be adopted to avoid hand coding of these functions and risks of subtle errors in programs. We plan to address this issue in the future. 7.1 Object Creation When creating a collected object one can specify in which Heap to allocate it. <p> Our copying collector has some advantage in performance not having to reconstruct a free list after collection and being more accurate in tracing live objects. Work on adding garbage collection to C++ has been done by Dain Samples and Daniel Edelson. Samples <ref> [Samples 92] </ref> proposes modifying C++, to include a garbage collection environment as part of the language. This may be a good long term approach for garbage collection in C++ but is not suitable for a project like PoSSo which needs portable garbage collection facilities as soon as possible.
Reference: [Wentworth 90] <author> E. P. </author> <title> Wentworth "Pitfalls of conservative garbage collection", </title> <journal> Software Practice and Experience, </journal> <volume> 20(7), </volume> <year> 1990, </year> <pages> 719-727. </pages>
Reference-contexts: The main limitations of a purely conservative collector are memory fragmentation in applications handling objects of many different sizes, arising from the inability to move objects, and the risk that a significant amount of memory might not be reclaimed in applications with densely populated address spaces of strongly connected objects <ref> [Wentworth 90] </ref>. The alternative approach which is type-accurate in identifying objects faces some non trivial problems with hidden pointers.
Reference: [Wilson 92] <author> P.R. </author> <title> Wilson "Uniprocessor garbage collection techniques", in Memory Management, </title> <editor> Y. Bekkers and J. Cohen (Eds.), </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> n. 637, </address> <publisher> Springer-Verlag, </publisher> <year> 1992, </year> <pages> 1-42. 20 </pages>
Reference-contexts: Unfortunately this is an undecidable property; therefore garbage collectors must adopt a simpler criterion based on the notion of potentially accessible or live object. A garbage collection mechanism basically consists of two parts <ref> [Wilson 92] </ref>: 1. distinguishing the live objects from the garbage in some way, or garbage detection; 2. reclaiming the garbage objects' storage, so that the running program can reuse it. The formal criterion to identify live objects is expressed in terms of a root set and reachability from these roots.
References-found: 12

