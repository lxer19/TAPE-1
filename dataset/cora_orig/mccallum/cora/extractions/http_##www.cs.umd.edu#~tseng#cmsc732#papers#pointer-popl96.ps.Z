URL: http://www.cs.umd.edu/~tseng/cmsc732/papers/pointer-popl96.ps.Z
Refering-URL: http://www.cs.umd.edu/~tseng/cmsc732/papers.html
Root-URL: 
Email: fghiya,hendreng@cs.mcgill.ca  
Title: Is it a Tree, a DAG, or a Cyclic Graph? A Shape Analysis for Heap-Directed
Author: Rakesh Ghiya and Laurie J. Hendren 
Address: Montreal, Quebec, CANADA H3A 2A7  
Affiliation: School of Computer Science, McGill University  
Note: To appear in Proceedings of the Twenty Third ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, St. Petersburg Beach, Florida, January 21-24, 1996. c fl1996 ACM (see notice below).  
Abstract: This paper reports on the design and implementation of a practical shape analysis for C. The purpose of the analysis is to aid in the disambiguation of heap-allocated data structures by estimating the shape (Tree, DAG, or Cyclic Graph) of the data structure accessible from each heap-directed pointer. This shape information can be used to improve dependence testing and in parallelization, and to guide the choice of more complex heap analyses. The method has been implemented as a context-sensitive interprocedural analysis in the McCAT compiler. Experimental results and observations are given for 16 benchmark programs. These results show that the analysis gives accurate and useful results for an important group of applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side-effects. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: A recent trend has been to actually implement pointer analyses in real C and FORTRAN90 compilers, and to examine if practical and useful solutions can be obtained. The most recently proposed (and implemented) approaches <ref> [1, 6, 26, 29, 32, 33] </ref>, mostly focus on the stack problem and only give conservative estimates for the heap problem. These approaches exploit the fact that pointer targets on the stack always possess a compile-time name. <p> Hence various schemes are used to name them: naming them according to the place (statement) in the program where they are allocated [3, 26, 29] or further qualifying these names with procedure strings to distinguish between objects allocated at the same statement but along different calling chains <ref> [1, 33] </ref>. These naming schemes can give the same name to completely unrelated heap objects, and hence tend to provide conservative results, and they cannot compute shape information.
Reference: [2] <author> A. Rogers, M. C. Carlisle, J. H. Reppy, and L. J. Hendren. </author> <title> Supporting dynamic data structures on distributed-memory machines. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(2) </volume> <pages> 231-263, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: In our benchmark set, hash uses an array of pointers to linked lists, and power implements a power network tree <ref> [2, 25] </ref> with its root having an array of pointers to disjoint subtrees. We get the shape attribute of these arrays as Tree.
Reference: [3] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the SIG-PLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Unfortunately heap objects do not have any fixed name during their lifetime, as they are dynamically allocated and are inherently anonymous. Hence various schemes are used to name them: naming them according to the place (statement) in the program where they are allocated <ref> [3, 26, 29] </ref> or further qualifying these names with procedure strings to distinguish between objects allocated at the same statement but along different calling chains [1, 33]. <p> Shape information can be gainfully exploited to parallelize such programs [12, 17, 22, 24], or to apply optimizing transformations like loop unrolling [15] and software pipelining [16] on them. Much of the previous work on heap analysis also primarily focused on some variation of the problem of shape estimation <ref> [3, 5, 17, 19, 21, 23, 28, 30] </ref>. In general, all of these approaches use a more complex abstraction than the one given in this paper, and as a result they may find a more precise answer. <p> For programs that make major structural changes to the data structure, our shape abstraction is not powerful enough to give accurate results, although the results will be safe. Other analyses can handle some of these cases <ref> [3, 5, 17, 30] </ref>, but they are substantially more complicated and more difficult to implement in real compilers. Our approach is to use the cheapest and simplest analysis possible for each program under consideration.
Reference: [4] <author> A. Deutsch. </author> <title> A storeless model of aliasing and its abstractions using finite representations of right-regular equivalence relations. </title> <booktitle> In Proceedings of the 1992 International Conference on Computer Languages, </booktitle> <pages> pages 2-13, </pages> <address> April 1992. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: We present some empirical data in Section 4, to evaluate the cost and effectiveness of shape analysis. Conclusions and some future directions are given in Section 5. 2 Analysis Rules The shape analysis is actually composed of three store-less <ref> [4] </ref> abstractions that work together and are computed together for each program point. For each heap-directed pointer, we approximate the attribute shape, and for each pair of heap-directed pointers we approximate the direction and interference relationships between them. These three abstractions are defined formally as follows.
Reference: [5] <author> A. Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 230-241, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Shape information can be gainfully exploited to parallelize such programs [12, 17, 22, 24], or to apply optimizing transformations like loop unrolling [15] and software pipelining [16] on them. Much of the previous work on heap analysis also primarily focused on some variation of the problem of shape estimation <ref> [3, 5, 17, 19, 21, 23, 28, 30] </ref>. In general, all of these approaches use a more complex abstraction than the one given in this paper, and as a result they may find a more precise answer. <p> For programs that make major structural changes to the data structure, our shape abstraction is not powerful enough to give accurate results, although the results will be safe. Other analyses can handle some of these cases <ref> [3, 5, 17, 30] </ref>, but they are substantially more complicated and more difficult to implement in real compilers. Our approach is to use the cheapest and simplest analysis possible for each program under consideration.
Reference: [6] <author> M. Emami, R. Ghiya, and L. J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: A recent trend has been to actually implement pointer analyses in real C and FORTRAN90 compilers, and to examine if practical and useful solutions can be obtained. The most recently proposed (and implemented) approaches <ref> [1, 6, 26, 29, 32, 33] </ref>, mostly focus on the stack problem and only give conservative estimates for the heap problem. These approaches exploit the fact that pointer targets on the stack always possess a compile-time name. <p> These approaches exploit the fact that pointer targets on the stack always possess a compile-time name. Using this property stack pointer relationships are accurately captured as points-to pairs <ref> [6] </ref> of the form (p,x) (denoting pointer variable p points to the data object x), or alternatively as alias pairs [26] of the form (*p,x) (denoting *p and x are aliased). <p> In our McCAT compiler we first perform a stack analysis called points-to analysis <ref> [6, 8] </ref> that resolves pointer relationships on the stack. It uses one abstract lo 1 cation called heap for all heap locations and reports all heap-directed pointers to be pointing to it. <p> It is a flow-sensitive analysis and collects program-point-specific information. The analysis is performed on the SIMPLE intermediate representation which is a simplified, compositional subset of C [7, 13, 31]. Shape analysis is performed after points-to analysis <ref> [6, 8] </ref> and focuses only on the subset of pointers reported to be pointing to heap by points-to analysis. This reduces the storage requirements for the abstractions, and makes the implementation easier as well as more efficient. The 8 overall analysis framework is similar to that used for points-to analysis. <p> Also note that we consider the loop condition as a simple assignment, when feasible. For example, when it involves a pointer equality test like (p == NULL) or (p == q). To accurately handle procedure calls, we use the interprocedural analysis framework built by points-to analysis <ref> [6, 8, 14] </ref>. It provides us the complete invocation graph of the program which is constructed by a simple depth-first traversal of the invocation structure of the program. Since the invocation structure is not known statically for recursive and indirect calls, they are handled in a special manner.
Reference: [7] <author> A. M. Erosa and L. J. Hendren. </author> <title> Taming control flow: A structured approach to eliminating goto statements. </title> <booktitle> In Proceedings of the 1994 International Conference on Computer Languages, </booktitle> <pages> pages 229-240, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: It is a flow-sensitive analysis and collects program-point-specific information. The analysis is performed on the SIMPLE intermediate representation which is a simplified, compositional subset of C <ref> [7, 13, 31] </ref>. Shape analysis is performed after points-to analysis [6, 8] and focuses only on the subset of pointers reported to be pointing to heap by points-to analysis. This reduces the storage requirements for the abstractions, and makes the implementation easier as well as more efficient.
Reference: [8] <author> M. Emami. </author> <title> A practical interprocedural alias analysis for an optimizing/parallelizing C compiler. </title> <type> Master's thesis, </type> <institution> McGill University, </institution> <month> July </month> <year> 1993. </year> <month> 14 </month>
Reference-contexts: In our McCAT compiler we first perform a stack analysis called points-to analysis <ref> [6, 8] </ref> that resolves pointer relationships on the stack. It uses one abstract lo 1 cation called heap for all heap locations and reports all heap-directed pointers to be pointing to it. <p> It is a flow-sensitive analysis and collects program-point-specific information. The analysis is performed on the SIMPLE intermediate representation which is a simplified, compositional subset of C [7, 13, 31]. Shape analysis is performed after points-to analysis <ref> [6, 8] </ref> and focuses only on the subset of pointers reported to be pointing to heap by points-to analysis. This reduces the storage requirements for the abstractions, and makes the implementation easier as well as more efficient. The 8 overall analysis framework is similar to that used for points-to analysis. <p> Also note that we consider the loop condition as a simple assignment, when feasible. For example, when it involves a pointer equality test like (p == NULL) or (p == q). To accurately handle procedure calls, we use the interprocedural analysis framework built by points-to analysis <ref> [6, 8, 14] </ref>. It provides us the complete invocation graph of the program which is constructed by a simple depth-first traversal of the invocation structure of the program. Since the invocation structure is not known statically for recursive and indirect calls, they are handled in a special manner.
Reference: [9] <author> E. Gagnon. </author> <title> A fast-forward and lazy points-to analysis. </title> <institution> ACAPS Project Report 1995.622B.03, McGill University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: We are also currently exploring other techniques to optimize our interprocedural algorithm, which include: (i) excluding the functions from the invocation graph, which neither update nor access heap-directed pointer variables, (ii) building the invocation graph in a lazy manner, as the demand for different invocation contexts arises during the analysis <ref> [9] </ref>, and (iii) performing more extensive memoization by trying to memoize all calls to a procedure (except the first one) irrespective of the call-chain they appear on. 4 Experimental Results 4.1 Benchmarks We have collected a number of small and medium sized benchmarks from a variety of sources.
Reference: [10] <author> R. Ghiya and L. J. Hendren. </author> <title> Connection analysis: A practical interprocedural heap analysis for C. </title> <booktitle> In Proceedings of the Eight Workshop on Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 1995. </year>
Reference-contexts: For programs with few uses of the heap, the level-0 or points-to analysis is enough. For programs that use a number of dynamically-allocated arrays and/or non-recursive structures, the level-1 or connection analysis is used which identifies if two heap-directed pointers point to the same structure <ref> [10, 11] </ref>. Scientific applications written in C typically exhibit this feature, as they use a number of disjoint dynamically-allocated arrays. This paper focuses on the level-2 heap analysis: shape analysis. <p> The benchmark reverse that recursively swaps a binary tree represents this case. Shape analysis abstracts all pointers from an array of pointers, say a <ref> [10] </ref>, as one pointer a. So the relationships and attribute of this pointer, represent the merge of the relationships and attributes of all the pointers it denotes (all pointers a [i]).
Reference: [11] <author> R. Ghiya. </author> <title> Practical techniques for interprocedural heap analysis. </title> <type> Master's thesis, </type> <institution> School of Computer Science, McGill University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: For programs with few uses of the heap, the level-0 or points-to analysis is enough. For programs that use a number of dynamically-allocated arrays and/or non-recursive structures, the level-1 or connection analysis is used which identifies if two heap-directed pointers point to the same structure <ref> [10, 11] </ref>. Scientific applications written in C typically exhibit this feature, as they use a number of disjoint dynamically-allocated arrays. This paper focuses on the level-2 heap analysis: shape analysis. <p> Complete rules for our interprocedural analysis scheme are described in <ref> [11] </ref>. Here we briefly discuss only the most pertinent issues. The general idea is that, first, the three matrices (for direction, interference and attribute abstractions) at the call-site are mapped to prepare the input matrices for the called procedure. <p> For each procedure call a mapping is stored between names in the calling context and names in the called context (globals, parameters and symbolic names), and is used while unmapping. Complete description of the rules for map and unmap processes can be found in <ref> [11] </ref>. Finally, in order to get the full context-sensitivity at a reduced price, we have implemented a simple memoization scheme. Every time we finish analyzing a procedure call, we store the currently computed pairs of input and output matrices, in the invocation graph node corresponding to it.
Reference: [12] <author> W. L. Harrison III. </author> <title> The interprocedural analysis and automatic parallelization of Scheme programs. </title> <journal> Lisp and Symbolic Computation, </journal> 2(3/4):179-396, 1989. 
Reference-contexts: Shape analysis is designed for programs that primarily use recursive data structures, or a combination of arrays and recursive data structures. Shape information can be gainfully exploited to parallelize such programs <ref> [12, 17, 22, 24] </ref>, or to apply optimizing transformations like loop unrolling [15] and software pipelining [16] on them. Much of the previous work on heap analysis also primarily focused on some variation of the problem of shape estimation [3, 5, 17, 19, 21, 23, 28, 30].
Reference: [13] <author> L. Hendren, C. Donawa, M. Emami, G. Gao, Jus-tiani, and B. Sridharan. </author> <title> Designing the McCAT compiler based on a family of structured intermediate representations. </title> <booktitle> In Proceedings of the 5th International Workshop on Languages and Compilers for Parallel Computing, number 757 in Lecture Notes in Computer Science, </booktitle> <pages> pages 406-420, </pages> <month> August </month> <year> 1992. </year> <note> Springer-Verlag. Published in 1993. </note>
Reference-contexts: It is a flow-sensitive analysis and collects program-point-specific information. The analysis is performed on the SIMPLE intermediate representation which is a simplified, compositional subset of C <ref> [7, 13, 31] </ref>. Shape analysis is performed after points-to analysis [6, 8] and focuses only on the subset of pointers reported to be pointing to heap by points-to analysis. This reduces the storage requirements for the abstractions, and makes the implementation easier as well as more efficient.
Reference: [14] <author> L. J. Hendren, M. Emami, R. Ghiya, and C. Ver-brugge. </author> <title> A practical context-sensitive interprocedural analysis framework for C compilers. </title> <type> ACAPS Technical Memo 72, </type> <institution> School of Computer Science, McGill University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Also note that we consider the loop condition as a simple assignment, when feasible. For example, when it involves a pointer equality test like (p == NULL) or (p == q). To accurately handle procedure calls, we use the interprocedural analysis framework built by points-to analysis <ref> [6, 8, 14] </ref>. It provides us the complete invocation graph of the program which is constructed by a simple depth-first traversal of the invocation structure of the program. Since the invocation structure is not known statically for recursive and indirect calls, they are handled in a special manner.
Reference: [15] <author> L. J. Hendren and G. R. Gao. </author> <title> Designing programming languages for analyzability: A fresh look at pointer data structures. </title> <booktitle> In Proceedings of the 1992 International Conference on Computer Languages, </booktitle> <pages> pages 242-251, </pages> <address> April 1992. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Shape analysis is designed for programs that primarily use recursive data structures, or a combination of arrays and recursive data structures. Shape information can be gainfully exploited to parallelize such programs [12, 17, 22, 24], or to apply optimizing transformations like loop unrolling <ref> [15] </ref> and software pipelining [16] on them. Much of the previous work on heap analysis also primarily focused on some variation of the problem of shape estimation [3, 5, 17, 19, 21, 23, 28, 30].
Reference: [16] <author> L. J. Hendren, J. E. Hummel, and A. Nicolau. </author> <title> Abstractions for recursive pointer data structures: Improving the analysis and transformation of imperative programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 249-260, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Shape analysis is designed for programs that primarily use recursive data structures, or a combination of arrays and recursive data structures. Shape information can be gainfully exploited to parallelize such programs [12, 17, 22, 24], or to apply optimizing transformations like loop unrolling [15] and software pipelining <ref> [16] </ref> on them. Much of the previous work on heap analysis also primarily focused on some variation of the problem of shape estimation [3, 5, 17, 19, 21, 23, 28, 30].
Reference: [17] <author> L. J. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Shape analysis is designed for programs that primarily use recursive data structures, or a combination of arrays and recursive data structures. Shape information can be gainfully exploited to parallelize such programs <ref> [12, 17, 22, 24] </ref>, or to apply optimizing transformations like loop unrolling [15] and software pipelining [16] on them. Much of the previous work on heap analysis also primarily focused on some variation of the problem of shape estimation [3, 5, 17, 19, 21, 23, 28, 30]. <p> Shape information can be gainfully exploited to parallelize such programs [12, 17, 22, 24], or to apply optimizing transformations like loop unrolling [15] and software pipelining [16] on them. Much of the previous work on heap analysis also primarily focused on some variation of the problem of shape estimation <ref> [3, 5, 17, 19, 21, 23, 28, 30] </ref>. In general, all of these approaches use a more complex abstraction than the one given in this paper, and as a result they may find a more precise answer. <p> For programs that make major structural changes to the data structure, our shape abstraction is not powerful enough to give accurate results, although the results will be safe. Other analyses can handle some of these cases <ref> [3, 5, 17, 30] </ref>, but they are substantially more complicated and more difficult to implement in real compilers. Our approach is to use the cheapest and simplest analysis possible for each program under consideration. <p> We plan to extend our shape analysis to create the level-3 analysis in our hierarchy by enriching the direction abstraction to keep information about the first link on the path (a partial implementation of path matrices <ref> [17] </ref>) and by using a more complex attribute matrix that abstracts the shape of the data structure with respect to certain links.
Reference: [18] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of the SIG-PLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 28-40, </pages> <month> June </month> <year> 1989. </year>
Reference: [19] <author> N. D. Jones and S. S. Muchnick. </author> <title> Program Flow Analysis, Theory and Applications, chapter 4, </title> <journal> Flow Analysis and Optimization of LISP-like Structures, </journal> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Shape information can be gainfully exploited to parallelize such programs [12, 17, 22, 24], or to apply optimizing transformations like loop unrolling [15] and software pipelining [16] on them. Much of the previous work on heap analysis also primarily focused on some variation of the problem of shape estimation <ref> [3, 5, 17, 19, 21, 23, 28, 30] </ref>. In general, all of these approaches use a more complex abstraction than the one given in this paper, and as a result they may find a more precise answer.
Reference: [20] <author> N. D. Jones and S. S. Muchnick. </author> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <month> January </month> <year> 1982. </year> <journal> ACM SIGACT and SIGPLAN. </journal>
Reference: [21] <author> N. Klarlund and M. Schwartzbach. </author> <title> Graph types. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 196-205, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Shape information can be gainfully exploited to parallelize such programs [12, 17, 22, 24], or to apply optimizing transformations like loop unrolling [15] and software pipelining [16] on them. Much of the previous work on heap analysis also primarily focused on some variation of the problem of shape estimation <ref> [3, 5, 17, 19, 21, 23, 28, 30] </ref>. In general, all of these approaches use a more complex abstraction than the one given in this paper, and as a result they may find a more precise answer.
Reference: [22] <author> J. R. Larus. </author> <title> Compiling Lisp programs for parallel execution. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 4 </volume> <pages> 29-99, </pages> <year> 1991. </year>
Reference-contexts: Shape analysis is designed for programs that primarily use recursive data structures, or a combination of arrays and recursive data structures. Shape information can be gainfully exploited to parallelize such programs <ref> [12, 17, 22, 24] </ref>, or to apply optimizing transformations like loop unrolling [15] and software pipelining [16] on them. Much of the previous work on heap analysis also primarily focused on some variation of the problem of shape estimation [3, 5, 17, 19, 21, 23, 28, 30].
Reference: [23] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of the SIG-PLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Shape information can be gainfully exploited to parallelize such programs [12, 17, 22, 24], or to apply optimizing transformations like loop unrolling [15] and software pipelining [16] on them. Much of the previous work on heap analysis also primarily focused on some variation of the problem of shape estimation <ref> [3, 5, 17, 19, 21, 23, 28, 30] </ref>. In general, all of these approaches use a more complex abstraction than the one given in this paper, and as a result they may find a more precise answer.
Reference: [24] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Restructuring Lisp programs for concurrent execution. </title> <booktitle> In Proceedings of the ACM/SIGPLAN PPEALS 1988 | Parallel Programming: Experience with Applications, Languages and Systems, </booktitle> <pages> pages 100-110, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Shape analysis is designed for programs that primarily use recursive data structures, or a combination of arrays and recursive data structures. Shape information can be gainfully exploited to parallelize such programs <ref> [12, 17, 22, 24] </ref>, or to apply optimizing transformations like loop unrolling [15] and software pipelining [16] on them. Much of the previous work on heap analysis also primarily focused on some variation of the problem of shape estimation [3, 5, 17, 19, 21, 23, 28, 30].
Reference: [25] <author> S. Lummetta, L. Murphy, X. Li, D. Culler, and I. Khalil. </author> <title> Decentralized optimal power pricing. </title> <booktitle> In Proceedings of Supercomputing 93, </booktitle> <pages> pages 243-249, </pages> <month> Novem-ber </month> <year> 1993. </year>
Reference-contexts: In our benchmark set, hash uses an array of pointers to linked lists, and power implements a power network tree <ref> [2, 25] </ref> with its root having an array of pointers to disjoint subtrees. We get the shape attribute of these arrays as Tree.
Reference: [26] <author> W. A. Landi and B. G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: A recent trend has been to actually implement pointer analyses in real C and FORTRAN90 compilers, and to examine if practical and useful solutions can be obtained. The most recently proposed (and implemented) approaches <ref> [1, 6, 26, 29, 32, 33] </ref>, mostly focus on the stack problem and only give conservative estimates for the heap problem. These approaches exploit the fact that pointer targets on the stack always possess a compile-time name. <p> These approaches exploit the fact that pointer targets on the stack always possess a compile-time name. Using this property stack pointer relationships are accurately captured as points-to pairs [6] of the form (p,x) (denoting pointer variable p points to the data object x), or alternatively as alias pairs <ref> [26] </ref> of the form (*p,x) (denoting *p and x are aliased). Unfortunately heap objects do not have any fixed name during their lifetime, as they are dynamically allocated and are inherently anonymous. <p> Unfortunately heap objects do not have any fixed name during their lifetime, as they are dynamically allocated and are inherently anonymous. Hence various schemes are used to name them: naming them according to the place (statement) in the program where they are allocated <ref> [3, 26, 29] </ref> or further qualifying these names with procedure strings to distinguish between objects allocated at the same statement but along different calling chains [1, 33].
Reference: [27] <author> J. Plevyak, A. Chien, and V. Karamcheti. </author> <title> Analysis of dynamic structures for efficient parallel execution. </title> <booktitle> In Proceedings of the 6th International Workshop on Languages and Compilers for Parallel Computing, number 768 in Lecture Notes in Computer Science, </booktitle> <pages> pages 37-56, </pages> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. Published in 1994. </note>
Reference: [28] <author> T. Reps. </author> <title> Shape analysis as a generalized path problem. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM), </booktitle> <pages> pages 1-11, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Shape information can be gainfully exploited to parallelize such programs [12, 17, 22, 24], or to apply optimizing transformations like loop unrolling [15] and software pipelining [16] on them. Much of the previous work on heap analysis also primarily focused on some variation of the problem of shape estimation <ref> [3, 5, 17, 19, 21, 23, 28, 30] </ref>. In general, all of these approaches use a more complex abstraction than the one given in this paper, and as a result they may find a more precise answer.
Reference: [29] <author> E. Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 13-22, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: A recent trend has been to actually implement pointer analyses in real C and FORTRAN90 compilers, and to examine if practical and useful solutions can be obtained. The most recently proposed (and implemented) approaches <ref> [1, 6, 26, 29, 32, 33] </ref>, mostly focus on the stack problem and only give conservative estimates for the heap problem. These approaches exploit the fact that pointer targets on the stack always possess a compile-time name. <p> Unfortunately heap objects do not have any fixed name during their lifetime, as they are dynamically allocated and are inherently anonymous. Hence various schemes are used to name them: naming them according to the place (statement) in the program where they are allocated <ref> [3, 26, 29] </ref> or further qualifying these names with procedure strings to distinguish between objects allocated at the same statement but along different calling chains [1, 33].
Reference: [30] <author> M. Sagiv, T. Reps, and R. Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <booktitle> In Conference Record of the Twenty Third Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: Shape information can be gainfully exploited to parallelize such programs [12, 17, 22, 24], or to apply optimizing transformations like loop unrolling [15] and software pipelining [16] on them. Much of the previous work on heap analysis also primarily focused on some variation of the problem of shape estimation <ref> [3, 5, 17, 19, 21, 23, 28, 30] </ref>. In general, all of these approaches use a more complex abstraction than the one given in this paper, and as a result they may find a more precise answer. <p> For programs that make major structural changes to the data structure, our shape abstraction is not powerful enough to give accurate results, although the results will be safe. Other analyses can handle some of these cases <ref> [3, 5, 17, 30] </ref>, but they are substantially more complicated and more difficult to implement in real compilers. Our approach is to use the cheapest and simplest analysis possible for each program under consideration.
Reference: [31] <author> B. Sridharan. </author> <title> An analysis framework for the McCAT compiler. </title> <type> Master's thesis, </type> <institution> McGill University, </institution> <month> Septem-ber </month> <year> 1992. </year>
Reference-contexts: We now present the rules to calculate direction and interference matrix abstractions, and to estimate shape information using them. 2.2 Analysis of Basic Statements The McCAT compiler translates input C programs into a structured and compositional intermediate form called SIMPLE <ref> [31] </ref> . Using this form, there are eight basic statements that can access or modify heap data structures as listed in Figure 5 (a). Variables p and q and the field f are of pointer type, variable k is of integer type, and op denotes the + and operations. <p> It is a flow-sensitive analysis and collects program-point-specific information. The analysis is performed on the SIMPLE intermediate representation which is a simplified, compositional subset of C <ref> [7, 13, 31] </ref>. Shape analysis is performed after points-to analysis [6, 8] and focuses only on the subset of pointers reported to be pointing to heap by points-to analysis. This reduces the storage requirements for the abstractions, and makes the implementation easier as well as more efficient.
Reference: [32] <author> B. Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Conference Record of the Twenty Third Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: A recent trend has been to actually implement pointer analyses in real C and FORTRAN90 compilers, and to examine if practical and useful solutions can be obtained. The most recently proposed (and implemented) approaches <ref> [1, 6, 26, 29, 32, 33] </ref>, mostly focus on the stack problem and only give conservative estimates for the heap problem. These approaches exploit the fact that pointer targets on the stack always possess a compile-time name.
Reference: [33] <author> R. P. Wilson and M. S. Lam. </author> <title> Efficient context-sensitive pointer analysis for C programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: A recent trend has been to actually implement pointer analyses in real C and FORTRAN90 compilers, and to examine if practical and useful solutions can be obtained. The most recently proposed (and implemented) approaches <ref> [1, 6, 26, 29, 32, 33] </ref>, mostly focus on the stack problem and only give conservative estimates for the heap problem. These approaches exploit the fact that pointer targets on the stack always possess a compile-time name. <p> Hence various schemes are used to name them: naming them according to the place (statement) in the program where they are allocated [3, 26, 29] or further qualifying these names with procedure strings to distinguish between objects allocated at the same statement but along different calling chains <ref> [1, 33] </ref>. These naming schemes can give the same name to completely unrelated heap objects, and hence tend to provide conservative results, and they cannot compute shape information.
References-found: 33

