URL: http://www.cs.columbia.edu/~cdo/ml98views.ps.gz
Refering-URL: http://www.cs.columbia.edu/~cdo/papers.html
Root-URL: http://www.cs.columbia.edu
Email: cdo@cs.columbia.edu  
Title: Views for Standard ML  
Author: Chris Okasaki 
Affiliation: Columbia University  
Abstract: In Standard ML, as in many other languages, programmers are often confronted with an unpleasant choice between pattern matching and abstraction. Because pattern matching can only be performed on concrete datatypes, programmers must often sacrifice either the convenience of pattern matching or the engineering benefits of abstraction. Views relieve this tension by allowing pattern matching on abstract datatypes. We propose a modest extension of Standard ML with views and define its semantics via a source-to-source translation back into Standard ML without views. We claim no particular technical innovation; rather, we have attempted to engineer a solution that blends as seamlessly as possible with the rest of the language, including the module system and the stateful features of the language.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aitken, W. E., and Reppy, J. H. </author> <title> Abstract value constructors. </title> <booktitle> In ACM SIGPLAN Workshop on ML and its Applications (June 1992), </booktitle> <pages> pp. 1-11. </pages>
Reference-contexts: The proposal most similar to ours is that of Burton et al. [3]. However, since their proposal was for Haskell, they do not consider issues such as interactions with state or with Standard ML's module system. Aitken and Reppy <ref> [1] </ref> considered a different solution to the problem of pattern matching on abstract datatypes. Their proposal for abstract value constructors allows patterns to be named. Then an occurrence of an abstract constructor expands into the named pattern.
Reference: [2] <author> Burton, F. W., and Cameron, R. D. </author> <title> Pattern matching with abstract data types. </title> <journal> Journal of Functional Programming 3, </journal> <month> 2 (Apr. </month> <year> 1993), </year> <pages> 171-190. </pages>
Reference-contexts: Unfortunately, this dual role played by view constructors proved problematic for equational reasoning. Burton and Cameron <ref> [2] </ref> solve the problems with equational reasoning by forbidding the use of view constructors in expressions. This also eliminates the need for the inverse view transformation. However, for the sake of efficient compilation, they forbid mixing constructors from different views within a single match.
Reference: [3] <author> Burton, F. W., Meijer, E., Sansom, P., Thompson, S., and Wadler, P. </author> <title> A (sic) extension to haskell 1.3 for views. Distributed on the Haskell mailing list, </title> <address> Oct. </address> <year> 1996. </year>
Reference-contexts: A major drawback of this single-constructor approach is that related constructors cannot share work during the view transformation. The proposal most similar to ours is that of Burton et al. <ref> [3] </ref>. However, since their proposal was for Haskell, they do not consider issues such as interactions with state or with Standard ML's module system. Aitken and Reppy [1] considered a different solution to the problem of pattern matching on abstract datatypes.
Reference: [4] <author> Erwig, M. </author> <title> Active patterns. </title> <booktitle> In International Workshop on the Implementation of Functional Languages (Sept. </booktitle> <year> 1996), </year> <pages> pp. 21-40. </pages>
Reference-contexts: This also eliminates the need for the inverse view transformation. However, for the sake of efficient compilation, they forbid mixing constructors from different views within a single match. Palao et al. [7] and Erwig <ref> [4] </ref> allow the mixing of arbitrary view constructors, but effectively limit each view type to a single constructor. <p> Then an occurrence of an abstract constructor expands into the named pattern. This proposal 2 When the concrete representation and view transformation are known to the compiler, pattern matching involving views can often be optimized into pattern matching against the concrete type <ref> [7, 4] </ref>. However, in the common case that the view is received as a functor argument, these optimizations will usually not apply. 22 supports very efficient compilation, but has much more limited applicability.
Reference: [5] <editor> Hudak, P., et al. </editor> <title> Report on the functional programming language Haskell, Version 1.2. </title> <journal> SIGPLAN Notices 27, </journal> <month> 5 (May </month> <year> 1992). </year>
Reference-contexts: Note that these rewrite rules are intended to define the semantics of pattern matching with views, not to suggest an implementation. They are horribly inefficient, in at least two respects. 1 These rules are similar in spirit to the formal semantics of pattern matching presented in the Haskell report <ref> [5] </ref>. 20 (case-begin) case e of match =) let v = e in case v of match | ) raise Match fv fresh, e not some generated identifier v 0 g (case-seq) case v of match | match 0 | ) e =) case v of match | ) (case v
Reference: [6] <author> Milner, R., Tofte, M., Harper, R., and MacQueen, D. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: 1 Introduction The convenience of pattern matching is one of the most seductive aspects of languages like Standard ML <ref> [6] </ref>. Not until the newcomer tries to write large programs does she encounter the Achilles' heel of this language feature: it can only be performed on concrete datatypes. Our intrepid programmer is faced with a dilemma worthy of Hobson. <p> The new syntax required to support views is minimal. We add two new keywords (viewtype and withfun) and three new productions to the syntax described in The Definition of Standard ML (Revised) <ref> [6] </ref>. spec ::= viewtype ty = condesc dec ::= viewtype viewbind hwithfun fvalbind i viewbind ::= ty = conbind where match hand viewbind i 18 We define the static and dynamic semantics of the new language constructs implicitly via a set of rewrite rules back into Standard ML without views.
Reference: [7] <author> Palao Gostanza, P., Pe ~ na, R., and N u ~ nez, M. </author> <title> A new look at pattern matching in abstract data types. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming (May 1996), </booktitle> <pages> pp. 110-121. </pages>
Reference-contexts: This also eliminates the need for the inverse view transformation. However, for the sake of efficient compilation, they forbid mixing constructors from different views within a single match. Palao et al. <ref> [7] </ref> and Erwig [4] allow the mixing of arbitrary view constructors, but effectively limit each view type to a single constructor. <p> Then an occurrence of an abstract constructor expands into the named pattern. This proposal 2 When the concrete representation and view transformation are known to the compiler, pattern matching involving views can often be optimized into pattern matching against the concrete type <ref> [7, 4] </ref>. However, in the common case that the view is received as a functor argument, these optimizations will usually not apply. 22 supports very efficient compilation, but has much more limited applicability.
Reference: [8] <author> Peyton Jones, S. </author> <title> A new view of guards. Distributed on the Haskell mailing list, </title> <month> Apr. </month> <year> 1997. </year>
Reference-contexts: For example, because the named patterns have a fixed shape, and do not allow any computation to occur, it is impossible to write an abstract value constructor that matches the last element of an arbitrary list. Peyton Jones's pattern guards <ref> [8] </ref> offer another alternative to views. Pattern guards allow bindings within the guard of a pattern to be visible within the right-hand side of the clause. If a pattern within the guard fails to match, then the guard fails.
Reference: [9] <author> Wadler, P. </author> <title> Views: A way for pattern matching to cohabit with data abstraction. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1987), </year> <pages> pp. 307-313. 23 </pages>
Reference-contexts: If this is a major concern, then it would be easy to adopt a naming convention that distinguishes view constructors from datatype constructors as a reminder that view constructors in patterns indicate function calls. 6 Related Work Wadler introduced views in <ref> [9] </ref>. He allowed view constructors to appear in both patterns and expressions, and therefore required two view transformations|one mapping from the concrete type to the abstract type (to be used in patterns) and one mapping from the abstract type to the concrete type (to be used in expressions).
References-found: 9

