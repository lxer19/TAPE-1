URL: ftp://ftp.eecs.umich.edu/groups/gasm/pam1.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Title: Specification and correctness proof of a WAM extension with abstract type constraints  
Author: Christoph Beierle and Egon Borger 
Keyword: Constraint logic programming, abstract machine, WAM, types, type constraint, correctness proof, evolving algebras  
Address: D-58084 Hagen, Germany;  Pisa, Corso Italia 40, I-56100 Pisa, Italia  
Affiliation: 1 Fachbereich Informatik, FernUniversitat Hagen,  Dipartimento di Informatica, Universita di  
Note: slightly modified version appeared in: Formal Aspects of Computing, Vol. 8(4), pp.  
Phone: 2  
Date: 428-462, 1996  
Abstract: We provide a mathematical specification of an extension of Warren's Abstract Machine for executing Prolog to type-constraint logic programming and prove its correctness. Our aim is to provide a full specification and correctness proof of a concrete system, the PROTOS Abstract Machine (PAM), an extension of the WAM by polymorphic order-sorted unification as required by the logic programming language PROTOS-L. In this paper, while leaving the details of the PAM's type constraint representation and solving facilities to a sequel to this work, we keep the notion of types and dynamic type constraints abstract to allow applications to different constraint formalisms like Prolog III or CLP(R). This generality permits us to introduce modular extensions of Borger's and Rosenzweig's formal derivation of the WAM. Since the type constraint handling is orthogonal to the compilation of predicates and clauses, we start from type-constraint Prolog algebras with compiled AND/OR structure that are derived from Borger's and Rosenzweig's corresponding compiled standard Prolog algebras. The specification of the type-constraint WAM extension is then given by a sequence of evolving algebras, each representing a refinement level, and for each refinement step a correctness proof is given. Thus, we obtain the theorem that for every such abstract type-constraint logic programming system L, every compiler to the WAM extension with an abstract notion of types which satisfies the specified conditions, is correct. Address for correspondence: Christoph Beierle, Fachbereich Informatik, LG Praktische In-formatik VIII, FernUniversitat Hagen, Bahnhofstr. 48, D-58084 Hagen, Germany; e-mail: christoph.beierle@fernuni-hagen.de fl The first author was partially funded by the German Ministry for Research and Technology (BMFT) in the framework of the WISPRO Project (Grant 01 IW 206). He would also like to thank the Scientific Center of IBM Germany where the work reported here was started. 
Abstract-found: 1
Intro-found: 1
Reference: [AK91] <author> H. At-Kaci. </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: not only been used for the description of the (operational) semantics of various programming languages (Modula-2, Occam, Prolog, Prolog III, Smalltalk, Parlog, C; see [Gur91]), but also for the description and analysis of implementation methods: Borger and Rosenzweig ([BR91, BR92b, BR92a]) provide a mathematical elaboration of Warren's Abstract Machine ([War83], <ref> [AK91] </ref>) for executing Prolog. The description consists of several refinement levels together with correctness proofs, and a correctness proof w.r.t. Borger's phenomenological Prolog description [Bor90a, Bor90b]. <p> Beierle and E. Borger term (ref (l)+i) 2 TERM type prefix (ref (l)+i) 2 TYPEPREFIX with i 2 f1,: : : ,arity (val (ref (l)))g. 3.2. Unification Lowlevel unification in the PAM can be carried out as in the WAM (see <ref> [AK91] </ref>) if we refine the bind operation into one that takes into account also the type constraints of the variables ([BMS91], [BM94]). The bind operation may thus also fail and initiate backtracking if the type constraints are not satisfied. <p> B.5): local (l) unbound (l) & l 2 HEAP & NOT (boh l &lt; h) For a discussion of local variables see <ref> [AK91] </ref> or [BR92b]. In the PROTOS-L case the type restriction of the local variable must be taken into account which Correctness Proof of a WAM Extension for Types 19 is done by the binding update in our mk heap variable abbreviation. <p> Additional WAM optimizations in the PAM 5.1. Environment Trimming and Last Call Optimization Environment trimming and last call optimization (LCO) are among the most prominent optimizations in the WAM; for a discussion we refer to <ref> [AK91] </ref> and [BR92b]. The necessary ARGUMENT REGISTERS PROPERTY as formulated in [BR92b] can be ensured by the compiler by generating a put unsafe value (y n ,x j ) instruction instead of put value (y n ,x j ) for each un safe occurrence of Y n . <p> BM94] for variables with monomorphic, polymorphic, or with no type restriction are introduced as an optimization in [BB96].) Both temporary and permanent variables can be initialized "on the fly"; for a discussion of the classification of variables into temporary and permanent ones which was introduced by [War83] we refer to <ref> [AK91] </ref> and [BR92b]. <p> This extra variable would then be set immediately after allocation, and its value would be assigned to the backtracking pointer b when a cut is encountered (see also <ref> [AK91] </ref>). 5.4. Main Theorem Putting everything together developed so far, we obtain Correctness Theorem 2 (Main Theorem): Compilation from PROTOS-L algebras to the PAM algebras developed so far is correct.
Reference: [BB91] <author> C. Beierle and E. Borger. </author> <title> A WAM extension for type-constraint logic programming: Specification and correctness proof. </title> <type> IWBS Report 200, </type> <institution> IBM Germany, Scientific Center, Inst. for Knowledge Based Systems, Stuttgart, </institution> <year> 1991. </year>
Reference-contexts: PROTOS-L which we then obtain as the final correctness theorem [BB96]. This paper was written in 1992/93 and revises and extends our work presented in <ref> [BB91] </ref> and [BB92]. It is organized as follows: Section 2 introduces an abstract notion of (type) constraints and defines PROTOS-L algebras with compiled AND/OR structure, the starting point of our development.
Reference: [BB92] <author> C. Beierle and E. Borger. </author> <title> Correctness proof for the WAM with types. </title> <editor> In E. Borger, H. Kleine Buning, G. Jager, and M. M. Richter, editors, </editor> <booktitle> Computer Science Logic - CSL'91. </booktitle> <publisher> LNCS 626. Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: PROTOS-L which we then obtain as the final correctness theorem [BB96]. This paper was written in 1992/93 and revises and extends our work presented in [BB91] and <ref> [BB92] </ref>. It is organized as follows: Section 2 introduces an abstract notion of (type) constraints and defines PROTOS-L algebras with compiled AND/OR structure, the starting point of our development.
Reference: [BB96] <author> C. Beierle and E. Borger. </author> <title> Refinement of a typed WAM extension by polymorphic order-sorted types. </title> <journal> Formal Aspects of Computing, </journal> <note> 8(5), 1996 (to appear). </note>
Reference-contexts: This allows us to develop a detailed and mathematically precise account of the PAM's compiled type constraint representation and solving facilities, and to prove its correctness w.r.t. PROTOS-L which we then obtain as the final correctness theorem <ref> [BB96] </ref>. This paper was written in 1992/93 and revises and extends our work presented in [BB91] and [BB92]. It is organized as follows: Section 2 introduces an abstract notion of (type) constraints and defines PROTOS-L algebras with compiled AND/OR structure, the starting point of our development. <p> As an integrity constraint we assume solution (ft : TOPg) = (;,;) i.e., TOP is used to represent a trivially solvable type constraint. These are the only assumptions we make about the universe TYPETERM in this paper. (A special representation for it is introduced in <ref> [BB96] </ref>.) Thus, the complete development carried out here applies to any concept of (type) constraints that exhibits the minimal requirements stated so far. <p> In a PROTOS-L algebra a program is a pair consisting of a definition context and a sequence of clauses PROGRAM DEFCONTEXT fi CLAUSE fl The definition context contains declarations of types, type constructors, etc. and will be refined in <ref> [BB96] </ref>. For prog = (defc,db) 2 PROGRAM we will write x 2 prog for both x 2 defc and x 2 db when it is clear from the context whether x is e.g. a type declaration or a list of clauses. <p> The tag FUNC from [BR92b] is not included since it is not needed. Correctness Proof of a WAM Extension for Types 13 The codomain of ref contains the universe TYPETERM since we will keep the type term representation abstract here; it will be refined later (see Section 2 in <ref> [BB96] </ref>). <p> variable the trailing of both locations l 1 and l 2 may be triggered by bind (l 1 ,l 2 ); moreover, if e.g. l 2 denotes a polymorphic term containing variables these variables also have to be trailed if they get another type restriction in the binding process (see <ref> [BB96] </ref>). 4.3. Pure PROTOS-L theorem In order to establish a correctness proof of compilation to PAM algebras developed so far from PROTOS-L algebras with compiled AND/OR structure of Section 2, we can generalize the "Pure Prolog Theorem" of [BR92b] to our case. We will thus construct a function F (c.f. <p> However, as explained in [BMS91], the first occurrence of a variable in a PROTOS-L clause is sufficient to consider the statically available type restriction. (The specialized instructions of [BMS91, BM94] for variables with monomorphic, polymorphic, or with no type restriction are introduced as an optimization in <ref> [BB96] </ref>.) Both temporary and permanent variables can be initialized "on the fly"; for a discussion of the classification of variables into temporary and permanent ones which was introduced by [War83] we refer to [AK91] and [BR92b]. <p> However, in PROTOS-L additionally a switch on the type restriction of a variable is possible (see <ref> [BB96] </ref>). For the establishment of the Pure PROTOS-L Theorem we had deliberately left out the built-in predicate cut.
Reference: [BBM91] <author> C. Beierle, S. Bottcher, and G. Meyer. </author> <title> Draft report of the logic programming language PROTOS-L. </title> <type> IWBS Report 175, </type> <institution> IBM Germany, Stuttgart, </institution> <year> 1991. </year> <note> Revised version: Working Paper 4, </note> <institution> IBM Germany, Scientific Center, Institute for Logics and Linguistics, </institution> <address> Heidelberg, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: For instance, if there are types and subtypes, restricting a variable to a subtype represents a constraint in the spirit of constraint logic programming. PROTOS-L ([Bei92], <ref> [BBM91] </ref>, [Bei95]) is a logic programming language that has a polymorphic, order-sorted type concept (similar to the slightly more general type concept of TEL [Smo88]) and a complete abstract machine implementation, called PAM ([BMS91], [BM94]) that is an extension of the WAM by the required polymorphic order-sorted unification.
Reference: [Bei92] <author> C. Beierle. </author> <title> Logic programming with typed unification and its realization on an abstract machine. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 36(3) </volume> <pages> 375-390, </pages> <month> May </month> <year> 1992. </year>
Reference: [Bei94] <author> C. Beierle. </author> <title> Formal design of an abstract machine for constraint logic programming. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> Technology and Foundations Proceedings of the IFIP Congress 94, </booktitle> <volume> volume 1, </volume> <pages> pages 377-382. </pages> <publisher> Elsevier / North Holland, </publisher> <address> Amsterdam, </address> <year> 1994. </year> <title> Correctness Proof of a WAM Extension for Types 27 </title>
Reference-contexts: For instance, in [BS95] a specification of the CLAM, an abstract machine for CLP (R), is given along these lines, together with a correctness proof for CLP (R) compilation. <ref> [Bei94] </ref> extends the work reported here by studying a general implementation scheme for CLP (X) and designing a generic extension WAM (X) of the WAM.
Reference: [Bei95] <author> C. Beierle. </author> <title> Concepts, implementation, and applications of a typed logic programming language. </title> <editor> In C. Beierle and L. Plumer, editors, </editor> <booktitle> Logic Programming: Formal Methods and Practical Applications, Studies in Computer Science and Artificial Intelligence, chapter 5, </booktitle> <pages> pages 139-167. </pages> <address> Elsevier Science B.V./North-Holland, Am-sterdam, </address> <year> 1995. </year>
Reference-contexts: For instance, if there are types and subtypes, restricting a variable to a subtype represents a constraint in the spirit of constraint logic programming. PROTOS-L ([Bei92], [BBM91], <ref> [Bei95] </ref>) is a logic programming language that has a polymorphic, order-sorted type concept (similar to the slightly more general type concept of TEL [Smo88]) and a complete abstract machine implementation, called PAM ([BMS91], [BM94]) that is an extension of the WAM by the required polymorphic order-sorted unification.
Reference: [BM94] <author> C. Beierle and G. Meyer. </author> <title> Run-time type computations in the Warren Abstract Machine. </title> <journal> Journal of Logic Programming, </journal> <volume> 18(2) </volume> <pages> 123-148, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: PROTOS-L ([Bei92], [BBM91], [Bei95]) is a logic programming language that has a polymorphic, order-sorted type concept (similar to the slightly more general type concept of TEL [Smo88]) and a complete abstract machine implementation, called PAM ([BMS91], <ref> [BM94] </ref>) that is an extension of the WAM by the required polymorphic order-sorted unification. Our aim is to provide a full specification and correctness proof of the concrete PAM system. Here we keep the notion of types and dynamic type constraints sufficiently abstract to allow applications to different constraint formalisms. <p> Unification Lowlevel unification in the PAM can be carried out as in the WAM (see [AK91]) if we refine the bind operation into one that takes into account also the type constraints of the variables ([BMS91], <ref> [BM94] </ref>). The bind operation may thus also fail and initiate backtracking if the type constraints are not satisfied. <p> However, as explained in [BMS91], the first occurrence of a variable in a PROTOS-L clause is sufficient to consider the statically available type restriction. (The specialized instructions of <ref> [BMS91, BM94] </ref> for variables with monomorphic, polymorphic, or with no type restriction are introduced as an optimization in [BB96].) Both temporary and permanent variables can be initialized "on the fly"; for a discussion of the classification of variables into temporary and permanent ones which was introduced by [War83] we refer to
Reference: [BMS91] <author> C. Beierle, G. Meyer, and H. Semle. </author> <title> Extending the Warren Abstract Machine to polymorphic order-sorted resolution. </title> <editor> In V. Saraswat and K. Ueda, editors, </editor> <booktitle> Logic Programming: Proceedings of the 1991 International Symposium, </booktitle> <pages> pages 272-286, </pages> <address> Cambridge, MA, 1991. </address> <publisher> MIT Press. </publisher>
Reference-contexts: A sequence of r corresponding put constraint (y j ,tt j ) instructions initialized the type restriction on the variables y j to tt j found in the clause's type prefix. However, as explained in <ref> [BMS91] </ref>, the first occurrence of a variable in a PROTOS-L clause is sufficient to consider the statically available type restriction. (The specialized instructions of [BMS91, BM94] for variables with monomorphic, polymorphic, or with no type restriction are introduced as an optimization in [BB96].) Both temporary and permanent variables can be initialized <p> However, as explained in [BMS91], the first occurrence of a variable in a PROTOS-L clause is sufficient to consider the statically available type restriction. (The specialized instructions of <ref> [BMS91, BM94] </ref> for variables with monomorphic, polymorphic, or with no type restriction are introduced as an optimization in [BB96].) Both temporary and permanent variables can be initialized "on the fly"; for a discussion of the classification of variables into temporary and permanent ones which was introduced by [War83] we refer to
Reference: [Bor90a] <author> E. Borger. </author> <title> A logical operational semantics of full Prolog. Part I. Selection core and control. </title> <editor> In E. Borger, H. Kleine Buning, and M. M. Richter, editors, </editor> <booktitle> CSL'89 3rd Workshop on Computer Science Logic. </booktitle> <volume> LNCS 440, </volume> <pages> pages 36-64. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: The description consists of several refinement levels together with correctness proofs, and a correctness proof w.r.t. Borger's phenomenological Prolog description <ref> [Bor90a, Bor90b] </ref>. In this work we demonstrate how the evolving algebra approach naturally allows for modifications and extensions in the description of both the semantics of programming languages as well as in the description of implementation methods.
Reference: [Bor90b] <author> E. Borger. </author> <title> A logical operational semantics of full Prolog. Part II. Built-in predicates for database manipulations. </title> <editor> In B. Rovan, editor, </editor> <booktitle> MFCS'90 Mathematical Foundations of Computer Science. </booktitle> <volume> LNCS 452, </volume> <pages> pages 1-14, </pages> <address> Berlin, 1990. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The description consists of several refinement levels together with correctness proofs, and a correctness proof w.r.t. Borger's phenomenological Prolog description <ref> [Bor90a, Bor90b] </ref>. In this work we demonstrate how the evolving algebra approach naturally allows for modifications and extensions in the description of both the semantics of programming languages as well as in the description of implementation methods. <p> PROTOS-L Algebras with compiled AND / OR structure 2.1. An abstract notion of type constraints The basic universes and functions in PROTOS-L algebras dealing with terms and substitutions can be taken directly from the standard Prolog algebras ([Bor90a], <ref> [Bor90b] </ref>). In particular, we have the universes TERM and SUBST of terms and substitutions with a function subres: TERM fi SUBST ! TERM yielding subres (t,s), the result of applying s to t.
Reference: [BR91] <author> E. Borger and D. Rosenzweig. </author> <title> From Prolog algebras towards WAM a mathematical study of implementation. </title> <editor> In E. Borger, H. Kleine Buning, M. M. Richter, and W. Schonfeld, editors, </editor> <booktitle> Computer Science Logic. </booktitle> <volume> LNCS 533, </volume> <pages> pages 31-66. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: Leaving the notion of terms and substitutions as abstract as in 2.1, we can use the compiled AND/OR structure development for Prolog in <ref> [BR91] </ref>, [BR92b] also for PROTOS-L: Essentially we just have to replace substitutions by the more general constraint systems, and have to take care of a clause constraint when resolving a goal.
Reference: [BR92a] <author> E. Borger and D. Rosenzweig. </author> <title> The WAM definition and compiler correctness. </title> <institution> TR-14/92, Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1992. </year> <note> (Revised version in: </note> <editor> C. Beierle, L. Plumer (Eds.), </editor> <title> Logic Programming: Formal Methods and Practical Applications, </title> <publisher> North-Holland, </publisher> <year> 1995). </year>
Reference-contexts: For the establishment of the Pure PROTOS-L Theorem we had deliberately left out the built-in predicate cut. Since there is no interdependence between cut and the type constraints of PROTOS-L, the cut treatment of Prolog carries over to our case as well <ref> [BR92a] </ref>: We could either extend every environment by a cutpointer, to be set and restored just as in Section 2, or we could allocate an extra (permanent) variable in those environments containig a so-called deep cut .
Reference: [BR92b] <author> E. Borger and D. Rosenzweig. </author> <title> WAM algebras a mathematical study of implementation, Part II. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Logic Programming. LNAI 592, </booktitle> <pages> pages 35-54, </pages> <address> Berlin, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Leaving the notion of terms and substitutions as abstract as in 2.1, we can use the compiled AND/OR structure development for Prolog in [BR91], <ref> [BR92b] </ref> also for PROTOS-L: Essentially we just have to replace substitutions by the more general constraint systems, and have to take care of a clause constraint when resolving a goal. <p> All abbreviations as well as the complete set of transition rules are given in Appendix A. 12 C. Beierle and E. Borger 3. Term representation The representation of terms and substitutions in the WAM can be introduced in several steps. Following the development in <ref> [BR92b] </ref> we first introduce the treatment of the low-level run-time unification (but leaving the details of type constraint solving as an abstract update to be refined later), followed by the term constructing and analyzing put and get instructions. <p> The tag FUNC from <ref> [BR92b] </ref> is not included since it is not needed. Correctness Proof of a WAM Extension for Types 13 The codomain of ref contains the universe TYPETERM since we will keep the type term representation abstract here; it will be refined later (see Section 2 in [BB96]). As in [BR92b] we use <p> FUNC from <ref> [BR92b] </ref> is not included since it is not needed. Correctness Proof of a WAM Extension for Types 13 The codomain of ref contains the universe TYPETERM since we will keep the type term representation abstract here; it will be refined later (see Section 2 in [BB96]). As in [BR92b] we use some abbreviations for dealing with locations l 2 DATAAREA: tag (l) tag (val (l)) l 1 l 2 val (l 1 ) := val (l 2 ) ref (l) := r unbound (l) tag (l) = VAR mk unbound (l) mk unbound (l,TOP) mk unbound (l,tt) tag (l) <p> The bind operation may thus also fail and initiate backtracking if the type constraints are not satisfied. Thus, we can use the treatment of unification as described in <ref> [BR92b] </ref>, while leaving the bind operation abstract for the moment, not only in order to postpone the discussion of occur check and trailing but also to stress the fact that the bind operation will take care of the type constraints for the variables. <p> The 0-ary function what to do 2 fUnify, Rung will be used in the guard of all following rules in the form of conditions like UNIF OK & what to do = Unify RUN OK & what to do = Run Unification is carried out by unification rules as in <ref> [BR92b] </ref> (see appendix B.1) where for the abstract bind update we impose the following modified BINDING CONDITION 1: For any l 1 , l 2 , l 2 DATAARRA, with term resp. term' values of term (l) and with prefix resp. prefix' values of type prefix (l) before resp. after execution <p> Note that put constraint (y n ,tt) is a new instruction used for inserting a type restriction into a heap location. Instead of having a pair (fn,a) 2 ATOM fi NAT we use f = entry (fn,a) in the code. The code developed in Section 1.2 of <ref> [BR92b] </ref> for constructing terms in body goals uses put instructions which assume that, for all variables Y i of the term t to be built on the heap, there is already a term denoting y i 2 DATAAREA available. <p> The get value, unify value, and unify variable instructions are as in the WAM case (see Appendix B.4 and B.5). Note that we need unify variable both in Read and Write mode which is controlled by the 0-ary function mode 2 fRead, Writeg. In <ref> [BR92b] </ref> unify variable in Write mode is introduced only as an optimization for variable initialization "on the fly", but when the machine enters Write mode in get structure, unify variable will be executed for the auxiliary substructure descriptors X i generated by the term normal form function nf a (Appendix B.2). <p> B.5): local (l) unbound (l) & l 2 HEAP & NOT (boh l &lt; h) For a discussion of local variables see [AK91] or <ref> [BR92b] </ref>. In the PROTOS-L case the type restriction of the local variable must be taken into account which Correctness Proof of a WAM Extension for Types 19 is done by the binding update in our mk heap variable abbreviation. <p> Thus, the HEAP VARIABLES CONSTRAINT as well as the HEAP VARIABLES LEMMA: If the put code and get code functions generate unify local value instead of unify value for all occurrences of local variables, then the execution of put seq and get seq preserve the HEAP VARIABLES CONSTRAINT <ref> [BR92b] </ref>. carries over to the PROTOS-L case, provided we ensure BINDING CONDITION 2: The bind update preserves the HEAP VARIABLES CONSTRAINT. 3.5. <p> Putting of Constraints In this section we will still keep the type constraint representation abstract, while specifying the conditions about the constraint handling code (for realization of add constraint of Section 2) in order to prove a theorem corresponding to the Pure Prolog Theorem of <ref> [BR92b] </ref> (see 4). <p> Beierle and E. Borger (STACK; bos; +, -; val) with bos 2 STACK representing the bottom element corresponding to nil in Section 2. The concrete memory layout can be done as in the WAM <ref> [BR92b] </ref> (see Appendix B.6) since the only type-related action is in the allocation of n free variable cells in the rule for Allocate: This situation is covered by our modified mk unbound abbreviation that assigns the trivial TOP type restriction to each such initialized variable: if OK allocate & code (p) <p> Whereas BINDING CONDITION 3 and the STACK VARIABLES PROPERTY are exactly as in the WAM case <ref> [BR92b] </ref>, for trailing variable bindings also the type restrictions must be taken into account in the PAM. <p> Pure PROTOS-L theorem In order to establish a correctness proof of compilation to PAM algebras developed so far from PROTOS-L algebras with compiled AND/OR structure of Section 2, we can generalize the "Pure Prolog Theorem" of <ref> [BR92b] </ref> to our case. We will thus construct a function F (c.f. Section 1) from the PROTOS-L algebras to the PAM algebras. <p> Furthermore, we establish the functions css: TRAIL ! CSS 1 subst: TRAIL ! SUBST 1 choicepoint: STACK ! STATE 1 env: STACK ! ENV 1 term: DATAAREA fi TRAIL ! TERM 1 typeprefix: DATAAREA fi TRAIL ! TYPEPREFIX 1 where we have added - w.r.t. the WAM case in <ref> [BR92b] </ref> the functions css and typeprefix in order to construct the correspondence between the constraint representations. Viewing an element of STATE 1 (resp. <p> Additional WAM optimizations in the PAM 5.1. Environment Trimming and Last Call Optimization Environment trimming and last call optimization (LCO) are among the most prominent optimizations in the WAM; for a discussion we refer to [AK91] and <ref> [BR92b] </ref>. The necessary ARGUMENT REGISTERS PROPERTY as formulated in [BR92b] can be ensured by the compiler by generating a put unsafe value (y n ,x j ) instruction instead of put value (y n ,x j ) for each un safe occurrence of Y n . <p> Additional WAM optimizations in the PAM 5.1. Environment Trimming and Last Call Optimization Environment trimming and last call optimization (LCO) are among the most prominent optimizations in the WAM; for a discussion we refer to [AK91] and <ref> [BR92b] </ref>. The necessary ARGUMENT REGISTERS PROPERTY as formulated in [BR92b] can be ensured by the compiler by generating a put unsafe value (y n ,x j ) instruction instead of put value (y n ,x j ) for each un safe occurrence of Y n . <p> Unlike in Prolog, in PROTOS-L the type restriction of y i must be copied to the new heap variable this is already taken into account by the bind update in our mk heap var abbreviation introduced in Section 3.4. Therefore, following the argumentation in <ref> [BR92b] </ref>, we can savely assume that the compiler enforces environment trimming and also last call optimization (LCO). Thus, every call instruction gets an additional parameter n where n is the number of variables that are still needed in the environment. <p> variables with monomorphic, polymorphic, or with no type restriction are introduced as an optimization in [BB96].) Both temporary and permanent variables can be initialized "on the fly"; for a discussion of the classification of variables into temporary and permanent ones which was introduced by [War83] we refer to [AK91] and <ref> [BR92b] </ref>. <p> Thus, the rule for allocate looses its initialization update, and the compile function is modified such that no put constraint instruction is generated any more. Moreover, the argumentation of Section3.2 and 3.2 of <ref> [BR92b] </ref> can be applied to our modified setting, implying also the correctness of special compilation of facts and chain rules where no environment needs to be allocated at all. 5.3. <p> Switching instructions and the Cut The PAM contains all switching instructions known from the WAM, and since no type specific considerations have to be taken into account, their treatment 26 C. Beierle and E. Borger in the evolving algebra approach in <ref> [BR92b] </ref> carries over to the PAM as well.
Reference: [BS91] <author> E. Borger and P. H. Schmitt. </author> <title> A formal operational semantics for languages of type Prolog III. </title> <editor> In E. Borger, H. Kleine Buning, M. M. Richter, and W. Schonfeld, editors, </editor> <booktitle> Computer Science Logic. </booktitle> <volume> LNCS 533, </volume> <pages> pages 67-79. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: A clause, depicted as fPg H &lt;-- G 1 & : : : & G n . is an ordinary Prolog clause together with a set P of type constraints for (all and only) the variables occurring in the clause head and body. As in <ref> [BS91] </ref> we use three obvious projection functions clhead: CLAUSE ! LIT clbody: CLAUSE ! LIT fl clconstraint: CLAUSE ! TYPEPREFIX where LIT is the universe of literals. Literals as used in ordinary logic programming are (non-negated) atomic first-order formulas.
Reference: [BS95] <author> E. Borger and R. Salamone. </author> <title> CLAM specification for provably correct compilation of CLP(R) programs. </title> <editor> In E. Borger, editor, </editor> <booktitle> Specification and Validation Methods, </booktitle> <pages> pages 97-130. </pages> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Although our description in this paper is oriented towards type constraints, it is modular in the sense that it can be extended to other constraint formalisms, like Prolog III [Col90] or CLP (R) [JL87], [JMSY90], as well. For instance, in <ref> [BS95] </ref> a specification of the CLAM, an abstract machine for CLP (R), is given along these lines, together with a correctness proof for CLP (R) compilation. [Bei94] extends the work reported here by studying a general implementation scheme for CLP (X) and designing a generic extension WAM (X) of the WAM.
Reference: [Col90] <author> A. Colmerauer. </author> <title> An introduction to Prolog-III. </title> <journal> Communications of the ACM, </journal> <volume> 33(7) </volume> <pages> 69-906, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Although our description in this paper is oriented towards type constraints, it is modular in the sense that it can be extended to other constraint formalisms, like Prolog III <ref> [Col90] </ref> or CLP (R) [JL87], [JMSY90], as well.
Reference: [EM89] <author> H. Ehrig and B. Mahr. </author> <title> Fundamentals of Algebraic Specification 2. </title> <booktitle> EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year>
Reference-contexts: Beierle and E. Borger In accordance to terminology used in abstract data type theory <ref> [EM89] </ref> we call F also an abstraction function.
Reference: [GM86] <author> J. A. Goguen and J. Meseguer. </author> <title> Eqlog: Equality, types, and generic modules for logic programming. </title> <editor> In D. DeGroot and G. Lindstrom, editors, </editor> <title> Logic Programming, Functions, Relations, </title> <booktitle> and Equations, </booktitle> <pages> pages 295-363. </pages> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: The extension of logic programming by types requires in general not only static type checking, but types are also present at run time (see e.g. [MO84], <ref> [GM86] </ref>, [NM88], [Han88], [Han91], [Smo89]). For instance, if there are types and subtypes, restricting a variable to a subtype represents a constraint in the spirit of constraint logic programming.
Reference: [Gur88] <author> Y. Gurevich. </author> <title> Logic and the challenge of computer science. </title> <editor> In E. Borger, editor, </editor> <booktitle> Trends in Theoretical Computer Science, </booktitle> <pages> pages 1-57. </pages> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: 1. Introduction Recently, Gurevich's notion of evolving algebra <ref> [Gur88] </ref> has not only been used for the description of the (operational) semantics of various programming languages (Modula-2, Occam, Prolog, Prolog III, Smalltalk, Parlog, C; see [Gur91]), but also for the description and analysis of implementation methods: Borger and Rosenzweig ([BR91, BR92b, BR92a]) provide a mathematical elaboration of Warren's Abstract Machine
Reference: [Gur91] <author> Y. Gurevich. </author> <title> Evolving algebras. A tutorial introduction. </title> <journal> EATCS Bulletin, </journal> <volume> 43, </volume> <month> February </month> <year> 1991. </year>
Reference-contexts: 1. Introduction Recently, Gurevich's notion of evolving algebra [Gur88] has not only been used for the description of the (operational) semantics of various programming languages (Modula-2, Occam, Prolog, Prolog III, Smalltalk, Parlog, C; see <ref> [Gur91] </ref>), but also for the description and analysis of implementation methods: Borger and Rosenzweig ([BR91, BR92b, BR92a]) provide a mathematical elaboration of Warren's Abstract Machine ([War83], [AK91]) for executing Prolog. The description consists of several refinement levels together with correctness proofs, and a correctness proof w.r.t. <p> Gurevich see <ref> [Gur91] </ref>). The abstract data comes as elements of (not further analysed) sets (domains, universes). The operations allowed on universes will be represented by partial functions. <p> This construct, which does not appear in Gurevich's original definition in <ref> [Gur91] </ref> is obviously reducible to rules with function updates. Every evolving algebra (A; R) determines a class of structures called algebras or states of (A; R). Within such classes we will have a notion of initial and terminal algebras, expressing initial resp. final states of the target system.
Reference: [Han88] <author> M. Hanus. </author> <title> Horn Clause Specifications with Polymorphic Types. </title> <type> PhD thesis, </type> <institution> FB Informatik, Universitat Dortmund, </institution> <year> 1988. </year>
Reference-contexts: The extension of logic programming by types requires in general not only static type checking, but types are also present at run time (see e.g. [MO84], [GM86], [NM88], <ref> [Han88] </ref>, [Han91], [Smo89]). For instance, if there are types and subtypes, restricting a variable to a subtype represents a constraint in the spirit of constraint logic programming.
Reference: [Han91] <author> M. Hanus. </author> <title> Horn clause programs with polymorphic types: Semantics and resolution. </title> <journal> Theoretical Computer Science, </journal> <volume> 89 </volume> <pages> 63-106, </pages> <year> 1991. </year>
Reference-contexts: The extension of logic programming by types requires in general not only static type checking, but types are also present at run time (see e.g. [MO84], [GM86], [NM88], [Han88], <ref> [Han91] </ref>, [Smo89]). For instance, if there are types and subtypes, restricting a variable to a subtype represents a constraint in the spirit of constraint logic programming.
Reference: [JL87] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1987. </year>
Reference-contexts: Although our description in this paper is oriented towards type constraints, it is modular in the sense that it can be extended to other constraint formalisms, like Prolog III [Col90] or CLP (R) <ref> [JL87] </ref>, [JMSY90], as well.
Reference: [JMSY90] <author> J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> The CLP(R) language and system. </title> <type> Technical Report RC 16292, </type> <institution> IBM Research Devision, </institution> <year> 1990. </year>
Reference-contexts: Although our description in this paper is oriented towards type constraints, it is modular in the sense that it can be extended to other constraint formalisms, like Prolog III [Col90] or CLP (R) [JL87], <ref> [JMSY90] </ref>, as well.
Reference: [MO84] <author> A. Mycroft and R. A. O'Keefe. </author> <title> A polymorphic type system for Prolog. </title> <journal> Artificial Intelligence, </journal> <volume> 23 </volume> <pages> 295-307, </pages> <year> 1984. </year>
Reference-contexts: The extension of logic programming by types requires in general not only static type checking, but types are also present at run time (see e.g. <ref> [MO84] </ref>, [GM86], [NM88], [Han88], [Han91], [Smo89]). For instance, if there are types and subtypes, restricting a variable to a subtype represents a constraint in the spirit of constraint logic programming.
Reference: [NM88] <author> G. Nadathur and D. Miller. </author> <title> An overview of Prolog. </title> <editor> In K. Bowen and R. Kowalski, editors, </editor> <booktitle> Proceedings of the Fifth International Conference and Symposium on 28 C. </booktitle> <editor> Beierle and E. </editor> <booktitle> Borger Logic Programming, </booktitle> <pages> pages 810-827, </pages> <address> Cambridge, MA, 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: The extension of logic programming by types requires in general not only static type checking, but types are also present at run time (see e.g. [MO84], [GM86], <ref> [NM88] </ref>, [Han88], [Han91], [Smo89]). For instance, if there are types and subtypes, restricting a variable to a subtype represents a constraint in the spirit of constraint logic programming.
Reference: [Rus92] <author> D. M. Russinoff. </author> <title> A verified Prolog compiler for the Warren Abstract Machine. </title> <journal> Journal of Logic Programming, </journal> <volume> 13 </volume> <pages> 367-412, </pages> <year> 1992. </year>
Reference-contexts: Based on Borger and Rosenzweig's WAM description we provide a mathematical specification of a WAM extension to type-constraint logic programming and prove its correctness. Note that thereby our treatment can be easily extended to cover also all extra-logical features (like the Prolog cut) whereas the WAM correctness proof of <ref> [Rus92] </ref> deals merely with SLD resolution for Horn clauses. The extension of logic programming by types requires in general not only static type checking, but types are also present at run time (see e.g. [MO84], [GM86], [NM88], [Han88], [Han91], [Smo89]).
Reference: [Smo88] <author> G. Smolka. </author> <title> TEL (Version 0.9), Report and User Manual. </title> <type> SEKI-Report SR 87-17, </type> <institution> FB Informatik, Universitat Kaiserslautern, </institution> <year> 1988. </year>
Reference-contexts: PROTOS-L ([Bei92], [BBM91], [Bei95]) is a logic programming language that has a polymorphic, order-sorted type concept (similar to the slightly more general type concept of TEL <ref> [Smo88] </ref>) and a complete abstract machine implementation, called PAM ([BMS91], [BM94]) that is an extension of the WAM by the required polymorphic order-sorted unification. Our aim is to provide a full specification and correctness proof of the concrete PAM system.
Reference: [Smo89] <author> G. Smolka. </author> <title> Logic Programming over Polymorphically Order-Sorted Types. </title> <type> PhD thesis, </type> <institution> FB Informatik, Univ. Kaiserslautern, </institution> <year> 1989. </year>
Reference-contexts: The extension of logic programming by types requires in general not only static type checking, but types are also present at run time (see e.g. [MO84], [GM86], [NM88], [Han88], [Han91], <ref> [Smo89] </ref>). For instance, if there are types and subtypes, restricting a variable to a subtype represents a constraint in the spirit of constraint logic programming.

References-found: 31

