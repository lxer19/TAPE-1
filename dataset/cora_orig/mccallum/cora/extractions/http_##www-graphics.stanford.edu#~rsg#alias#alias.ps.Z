URL: http://www-graphics.stanford.edu/~rsg/alias/alias.ps.Z
Refering-URL: http://www-graphics.stanford.edu/~rsg/alias/index.html
Root-URL: http://www.cs.stanford.edu
Title: Efficient Accommodation of May-Alias Information in SSA Form  
Author: Ron Cytron Reid Gershbein 
Address: St. Louis, Missouri 63130  44074  
Affiliation: Washington University  Oberlin College Oberlin, Ohio  
Abstract: We present an algorithm for incrementally including may-alias information into Static Single Assignment (SSA) form by computing a sequence of increasingly precise (and correspondingly larger) partial SSA forms. Our experiments show significant speedup of our method over exhaustive use of may-alias information, as optimizattion problems converge well before most may-aliases are needed.
Abstract-found: 1
Intro-found: 1
Reference: [AWZ88] <author> B. Alpern, M. N. Wegman, and F. K. Zadeck. </author> <title> Detecting equality of values in programs. </title> <booktitle> Conf. Rec. Fifteenth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 1-11, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: If v is unaffected by step 6 , then no assignment to v would be necessary at step 7 . Transformation of source programs into Static Single Assignment (SSA) form [CFR + 91] results in more efficient and effective program optimization <ref> [WZ91, AWZ88] </ref>. Without SSA form, each program optimizaion would require special-case treatment of constructs that yield implicit storage references.
Reference: [BCK + 88] <author> M. Berry, D. Chen, P. Koss, D. Kuck, S. Lo, Y. Pang, R. Roloff, A. Sameh, E. Clementi, S. Chin, D. Schneider, G. Fox, P. Messina, D. Walker, C. Hsiung, J. Schwarzmeier, K. Lue, S. Orszag, F. Seidl, O. Johnson, G. Swanson, R. Goodrum, and J. Martin. </author> <title> The perfect club benchmarks: Effective performance evaluation of supercomputers the performance evaluation club (perfect). </title> <type> Technical report, </type> <institution> U. of Ill-Center for Supercomputing Research and Development, </institution> <month> November </month> <year> 1988. </year>
Reference-contexts: As an associated expense, space would have to be allocated to maintain such information per-variable, or the U seList would have to be sorted by symbol name. 5 Experiment We performed the following experiment on 139 Fortran programs taken from the Perfect <ref> [BCK + 88] </ref> (Ocean, Spice, QCD) benchmark suite and from the Eispack [SBD + 76] and Linpack [DBMS79] subroutine library.
Reference: [Bod90] <author> F. Bodin. </author> <title> Preliminary report Data structure analysis in C programs. </title> <institution> Indiana University, Bloomington, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: The use of languages whose alias behavior is sufficiently restricted <ref> [Bod90] </ref> can lessen the impact of explicit alias representation, as can recent advances in obtaining high-quality may-alias information [Lan92, LR92, CBC93].
Reference: [CBC93] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> Conference Record of the Twentieth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: The use of languages whose alias behavior is sufficiently restricted [Bod90] can lessen the impact of explicit alias representation, as can recent advances in obtaining high-quality may-alias information <ref> [Lan92, LR92, CBC93] </ref>. However, the number of aliased expressions per node can grow quite large: the make.c program serves as a worst-case in [Lan92], with 675 may-alias relations per node on average, and one node containing some 2000 relations.
Reference: [CCF91] <author> J. Choi, R. Cytron, and J. Ferrante. </author> <title> Automatic construction of sparse data flow evaluation graphs. </title> <booktitle> Conf. Rec. Eighteenth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 55-66, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: research on this problem: * Our work to date addresses only "flat" name spaces, so we hope to extend the work to accommodate information developed for structure references [LH88, CWZ90, HN90]. * Our algorithm may be suitable for including information similar to may-aliases incrementally into sparse data flow evaluation graphs <ref> [CCF91] </ref>. * Our experiments are based on simulated (probabilistic) may-alias patterns. We would like to try our algorithm in a system that actually analyzes c programs for may aliases.
Reference: [CFR + 91] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <month> October </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Consider the source program and its SSA representation <ref> [CFR + 91] </ref> shown in Figure 1. The storage referenced by a program P is logically partitioned into disjoint storage names, which correspond approximately to the variable names in P . The "store" and "load" instructions of P are statically labelled as distinct def and use sites, respectively. <p> If v is unaffected by step 6 , then no assignment to v would be necessary at step 7 . Transformation of source programs into Static Single Assignment (SSA) form <ref> [CFR + 91] </ref> results in more efficient and effective program optimization [WZ91, AWZ88]. Without SSA form, each program optimizaion would require special-case treatment of constructs that yield implicit storage references. <p> The above -function introduces one def and k uses of v into the program representation. In the traditional SSA representation <ref> [CFR + 91] </ref>, each use of v in the -function is associated with node Z, where the -function textually appears. In a departure convenient for our algorithm, we instead associate each use v Y i with node Y i.
Reference: [CWZ90] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> Proc. SIGPLAN'90 Symp. on Compiler Construction, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year> <note> Published as SIG-PLAN Notices Vol. 25, No. 6. </note>
Reference-contexts: An earlier method for accommodating alias information in SSA form <ref> [CWZ90] </ref> gains efficiency by directly propagating information to affected program sites. Our approach is complementary, since we avoid computing the bulk of may-alias information; an actual optimization problem motivates and terminates the search for alias information. <p> Operations within a node are assumed to be totally ordered, particularly those that reference storage. Storage names: Storage for P is partitioned into a set of static storage names. Where the structure of dynamically allocated objects cannot be analyzed at greater precision <ref> [LH88, CWZ90, HN90] </ref>, a single name (such as "heap") can represent all such objects. References: Each reference (ref ) r represents a store (def ) or load (use) instruction of P . <p> We suggest the following avenues of further research on this problem: * Our work to date addresses only "flat" name spaces, so we hope to extend the work to accommodate information developed for structure references <ref> [LH88, CWZ90, HN90] </ref>. * Our algorithm may be suitable for including information similar to may-aliases incrementally into sparse data flow evaluation graphs [CCF91]. * Our experiments are based on simulated (probabilistic) may-alias patterns.
Reference: [DBMS79] <author> J. J. Dongarra, J. R. Bunch, C. B. Moler, and G. W. Stewart. </author> <title> Linpack Users' Guide. </title> <publisher> SIAM Press, </publisher> <year> 1979. </year>
Reference-contexts: allocated to maintain such information per-variable, or the U seList would have to be sorted by symbol name. 5 Experiment We performed the following experiment on 139 Fortran programs taken from the Perfect [BCK + 88] (Ocean, Spice, QCD) benchmark suite and from the Eispack [SBD + 76] and Linpack <ref> [DBMS79] </ref> subroutine library. Since Fortran (77) has no pointer dereferencing capability, we randomly associated may-alias information with each program using the following two parameters: AliasRatio R: the probability that a given definition site is may-aliased with any symbols.
Reference: [HN90] <author> L. J. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <year> 1990. </year>
Reference-contexts: Operations within a node are assumed to be totally ordered, particularly those that reference storage. Storage names: Storage for P is partitioned into a set of static storage names. Where the structure of dynamically allocated objects cannot be analyzed at greater precision <ref> [LH88, CWZ90, HN90] </ref>, a single name (such as "heap") can represent all such objects. References: Each reference (ref ) r represents a store (def ) or load (use) instruction of P . <p> We suggest the following avenues of further research on this problem: * Our work to date addresses only "flat" name spaces, so we hope to extend the work to accommodate information developed for structure references <ref> [LH88, CWZ90, HN90] </ref>. * Our algorithm may be suitable for including information similar to may-aliases incrementally into sparse data flow evaluation graphs [CCF91]. * Our experiments are based on simulated (probabilistic) may-alias patterns.
Reference: [Lan92] <author> William A. Landi. </author> <title> Interprocedural Aliasing in the Presence of Pointers. </title> <type> PhD thesis, </type> <institution> Rutgers, The State University of New Jersey, </institution> <year> 1992. </year>
Reference-contexts: The use of languages whose alias behavior is sufficiently restricted [Bod90] can lessen the impact of explicit alias representation, as can recent advances in obtaining high-quality may-alias information <ref> [Lan92, LR92, CBC93] </ref>. However, the number of aliased expressions per node can grow quite large: the make.c program serves as a worst-case in [Lan92], with 675 may-alias relations per node on average, and one node containing some 2000 relations. <p> However, the number of aliased expressions per node can grow quite large: the make.c program serves as a worst-case in <ref> [Lan92] </ref>, with 675 may-alias relations per node on average, and one node containing some 2000 relations. Research is underway to determine how relations translate into effects on storage names [Lan93], but currently the impact of so many alias relations on SSA form cannot be quantified.
Reference: [Lan93] <author> William A. Landi. </author> <title> personal communication, </title> <booktitle> 1993. </booktitle> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? <volume> 0 100 200 300 400 500 600 700 800 900 1000 1100 2 6 10 </volume>
Reference-contexts: However, the number of aliased expressions per node can grow quite large: the make.c program serves as a worst-case in [Lan92], with 675 may-alias relations per node on average, and one node containing some 2000 relations. Research is underway to determine how relations translate into effects on storage names <ref> [Lan93] </ref>, but currently the impact of so many alias relations on SSA form cannot be quantified.
Reference: [LH88] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> Proc. SIGPLAN'88 Symp. on Compiler Construction, </booktitle> <pages> pages 21-34, </pages> <month> July </month> <year> 1988. </year> <journal> Published as SIGPLAN Notices Vol. </journal> <volume> 23, No. </volume> <pages> 7. </pages>
Reference-contexts: Operations within a node are assumed to be totally ordered, particularly those that reference storage. Storage names: Storage for P is partitioned into a set of static storage names. Where the structure of dynamically allocated objects cannot be analyzed at greater precision <ref> [LH88, CWZ90, HN90] </ref>, a single name (such as "heap") can represent all such objects. References: Each reference (ref ) r represents a store (def ) or load (use) instruction of P . <p> We suggest the following avenues of further research on this problem: * Our work to date addresses only "flat" name spaces, so we hope to extend the work to accommodate information developed for structure references <ref> [LH88, CWZ90, HN90] </ref>. * Our algorithm may be suitable for including information similar to may-aliases incrementally into sparse data flow evaluation graphs [CCF91]. * Our experiments are based on simulated (probabilistic) may-alias patterns.
Reference: [LR92] <author> William Landi and Barbara G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The use of languages whose alias behavior is sufficiently restricted [Bod90] can lessen the impact of explicit alias representation, as can recent advances in obtaining high-quality may-alias information <ref> [Lan92, LR92, CBC93] </ref>. However, the number of aliased expressions per node can grow quite large: the make.c program serves as a worst-case in [Lan92], with 675 may-alias relations per node on average, and one node containing some 2000 relations.
Reference: [LT79] <author> T. Lengauer and Robert Tarjan. </author> <title> A fast algorithm for finding dominators in a flowgraph. </title> <journal> TOPLAS, </journal> <month> July </month> <year> 1979. </year>
Reference-contexts: Where none exists within N ode (r), then node idom (N ode (r)) is consulted, where idom (X) is the node immediately dominating X in the flow graph <ref> [LT79] </ref>. Since each node is assumed to have at least one def site, DomDef (r) is well-defined. Aliases: As discussed above, two lists of storage names are associated with each reference r, representing M ayAlias (r) and M ustAlias (r).
Reference: [SBD + 76] <author> B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow, Y. Ikebe, V. C. Klema, and C. B. Moler. </author> <title> Matrix Eigensystem Routines - Eispack Guide. </title> <publisher> Springer-Verlag, </publisher> <year> 1976. </year>
Reference-contexts: space would have to be allocated to maintain such information per-variable, or the U seList would have to be sorted by symbol name. 5 Experiment We performed the following experiment on 139 Fortran programs taken from the Perfect [BCK + 88] (Ocean, Spice, QCD) benchmark suite and from the Eispack <ref> [SBD + 76] </ref> and Linpack [DBMS79] subroutine library. Since Fortran (77) has no pointer dereferencing capability, we randomly associated may-alias information with each program using the following two parameters: AliasRatio R: the probability that a given definition site is may-aliased with any symbols.
Reference: [Tar75] <author> Robert Tarjan. </author> <title> Efficiency of a good but not linear set union algorithm. </title> <journal> JACM, </journal> <volume> 22 </volume> <pages> 215-225, </pages> <year> 1975. </year>
Reference-contexts: While our experience with the algorithm indicates very good performance in practice (Section 5), the asymptotic performance can be improved by introducing path-compression <ref> [Tar75] </ref> into Snoop ().
Reference: [WZ91] <author> M. N. Wegman and F. K. Zadeck. </author> <title> Constant propagation with conditional branches. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 181-210, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: If v is unaffected by step 6 , then no assignment to v would be necessary at step 7 . Transformation of source programs into Static Single Assignment (SSA) form [CFR + 91] results in more efficient and effective program optimization <ref> [WZ91, AWZ88] </ref>. Without SSA form, each program optimizaion would require special-case treatment of constructs that yield implicit storage references. <p> Without SSA form, each program optimizaion would require special-case treatment of constructs that yield implicit storage references. The results of applying constant propagation based on SSA form <ref> [WZ91] </ref> to our example are dependent on the program's SSA form, which is in turn dependent on the alias information associated with storage assignments. <p> We prove in Section 4 that such modifications cannot "better" the data flow solution for any variable at any node. Thus, an incremental constant propagator can assimilate the definitions provided by step 18 without restarting any of its computations. In summary, an SSA-based constant propagator <ref> [WZ91] </ref> is incrementalized by: exposing its definition worklist: Step 15 provides the initial set of definitions, and a new list is developed each time step 18 executes; flagging its suspcious uses: Any use u can be returned to U pdate () as suspicious, in which case U pdate () will invoke
References-found: 17

