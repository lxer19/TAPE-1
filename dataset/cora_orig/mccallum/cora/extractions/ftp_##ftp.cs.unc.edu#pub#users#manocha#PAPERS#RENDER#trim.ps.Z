URL: ftp://ftp.cs.unc.edu/pub/users/manocha/PAPERS/RENDER/trim.ps.Z
Refering-URL: http://www.cs.unc.edu/~geom/RENDER/surfacepapers.html
Root-URL: http://www.cs.unc.edu
Title: (To appear in CAD special issue on visualization) Efficient Rendering of Trimmed NURBS Surfaces  
Author: Subodh Kumar Dinesh Manocha 
Date: November 28, 1994  
Address: Chapel Hill NC 27599  Chapel Hill NC 27599  
Affiliation: Department of Computer Science University of North Carolina  Department of Computer Science University of North Carolina  
Abstract: We present an algorithm for interactive display of trimmed NURBS surfaces. The algorithm converts the NURBS surfaces to Bezier surfaces and NURBS trimming curves into Bezier curves. It tessellates each trimmed Bezier surface into triangles and renders them using the triangle rendering capabilities common in current graphics systems. It makes use of tight bounds for uniform tessellation of Bezier surfaces into cells and traces the trimming curves to compute the trimmed regions of each cell. This is based on tracing trimming curves, intersection computation with the cells, and triangulation of the cells. The resulting technique also makes use of spatial and temporal coherence between successive frames for cell computation and triangulation. Polygonization anomalies like cracks and angularities are avoided as well. The algorithm can display trimmed models described using thousands of Bezier surfaces at interactive frame rates on the high end graphics systems. Additional Keywords and Phrases: NURBS, trimming curves, Bezier surface, CSG, Boundary Representation, Trimming Curves, Tessellation. fl Supported by Office of Naval Research contract, ONR N00014-94-1-0738, DARPA ISTO Order No. A410, NSF Grant No. MIP-9306208, Junior Faculty Award, University Research Award, NSF Grant CCR-9319957, ARPA Contract DABT63-93-C-0048 and NSF/ARPA Science and Technology Center for Computer Graphics and Scientific Visualization, and NSF Prime Contract No. 8920219. 
Abstract-found: 1
Intro-found: 1
Reference: [AES91] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> Tessellation of curved surfaces under highly varying transformations. </title> <booktitle> Proceedings of Eurographics'91, </booktitle> <pages> pages 385-97, </pages> <year> 1991. </year>
Reference-contexts: In particular, the current graphics systems can render up to millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. As a result, only algorithms based on polygonization come close to real time display. Many different methods of polygonization have been proposed in the literature <ref> [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86] </ref>. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these algorithms focus on trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models. <p> Another major reason for the choice of uniform tessellation is the relative simplicity and efficiency of handling trimming curves (as compared to adaptive subdivision). 3.1 Patch tessellation There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. They are base upon the size or the deviation criteria. Sometimes a normal deviation criterion is also used. This criterion bounds the deviation of the triangles' normals from the surface normal. While this bound can improve the image quality, it is relatively expensive to evaluate. <p> The size criterion can be applied in two ways for step size computation: * Compute the bounds on the surface in the object space as a preprocessing step and map these to the screen space. The step size is computed as a function of these bounds and viewing parameters <ref> [LR81, FMM86, AES91, KM94] </ref>. * Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size is a function of these bounds [Roc87, RHD89]. <p> The maximum magnitude of the second derivative is needed to calculate the stepsize satisfying the deviation criterion <ref> [AES91] </ref>. n u steps need to be taken along the dimension u for the criterion to be satisfied. n v for the patch is computed analogously. Computations of n t , the number of steps for a curve is also calculated similarly.
Reference: [AES93] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> The scaling behavior of viewing transformations. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 13(3) </volume> <pages> 48-54, </pages> <year> 1993. </year>
Reference-contexts: In particular, the current graphics systems can render up to millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. As a result, only algorithms based on polygonization come close to real time display. Many different methods of polygonization have been proposed in the literature <ref> [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86] </ref>. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these algorithms focus on trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models.
Reference: [Ake93] <author> K. Akeley. </author> <title> Reality engine graphics. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 109-1116, </pages> <year> 1993. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. In particular, the current graphics systems can render up to millions of transformed, shaded and z-buffered polygons per second <ref> [Ake93, Fea89] </ref>. As a result, only algorithms based on polygonization come close to real time display. Many different methods of polygonization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces.
Reference: [Baj90] <author> C.L. Bajaj. </author> <title> Rational hypersurface display. </title> <booktitle> In Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 117-27, </pages> <address> Snowbird, UT, </address> <year> 1990. </year>
Reference: [BFHK93] <author> R. Barnhill, G. Farin, D. Hansford, and R. Klass. </author> <title> Adaptive surface triangulation. </title> <type> Manuscript, </type> <year> 1993. </year>
Reference: [Cat74] <author> E. Catmull. </author> <title> A subdivision algorithm for computer display of curved surfaces. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1974. </year>
Reference-contexts: In this paper we focus on trimmed surface models, typically obtained after surface intersection or other boolean operations. The problem of rendering curved surfaces (both trimmed and untrimmed) has been extensively studied in the literature and main techniques include pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Kaj82, NSK90, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. In particular, the current graphics systems can render up to millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89].
Reference: [Che93] <author> F. Cheng. </author> <title> Computation techniques on nurb surfaces. </title> <booktitle> In SIAM Conference on Geometric Design, </booktitle> <address> Tempe, AZ, </address> <year> 1993. </year>
Reference-contexts: Many different methods of polygonization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these algorithms focus on trimmed surface models <ref> [RHD89, Luk93, LC93, Che93, SC88, Vla90] </ref>. We present a fast algorithm for rendering trimmed NURBS models. Our approach shares its principle with the algorithm presented by Rockwood et. al. [RHD89].
Reference: [Cla79] <author> J. H. Clark. </author> <title> A fast algorithm for rendering parametric surfaces. </title> <booktitle> Proceedings of ACM Siggraph, </booktitle> <pages> pages 289-99, </pages> <year> 1979. </year>
Reference: [CTV89] <author> K. Clarkson, R. E. Tarjan, and C. J. Van Wyk. </author> <title> A fast Las Vegas algorithm for triangulating a simple polygon. </title> <journal> Discrete Comput. Geom., </journal> <volume> 4 </volume> <pages> 423-432, </pages> <year> 1989. </year>
Reference-contexts: If we use the external point A instead of b, we get a correct triangulation there. Similarly we can replace all crossings with the corresponding external points, and avoid creating extra tessellants on the curve. This polygon can now be triangulated using any polygon triangulation algorithms <ref> [PS85, CTV89, Sei91] </ref>. Our current implementation uses Fortune's algorithm and robust implementation of Delaunay triangulation [For87]. There are two new problems with this method of polygon generation, though: 1. The external point of one cell is the exit point of another.
Reference: [DN93] <author> M.F. Deering and S.R. Nelson. Leo: </author> <title> A system for cost effective 3d shaded graphics. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 101-108, </pages> <year> 1993. </year>
Reference: [Dea89] <author> T. Derose et. al. Apex: </author> <title> two architectures for generating parametric curves and surfaces. </title> <journal> The Visual Computer, </journal> <volume> 5 </volume> <pages> 264-276, </pages> <year> 1989. </year>
Reference-contexts: In particular, the current graphics systems can render up to millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. As a result, only algorithms based on polygonization come close to real time display. Many different methods of polygonization have been proposed in the literature <ref> [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86] </ref>. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these algorithms focus on trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models.
Reference: [Bea91] <author> R. Bedichek et. al. </author> <title> Rapid low-cost display of spline surfaces. </title> <booktitle> In Proceedings of advanced reserach in VLSI, </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year> <month> 25 </month>
Reference: [Far90] <author> G. Farin. </author> <title> Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide. </title> <publisher> Academic Press Inc., </publisher> <year> 1990. </year>
Reference-contexts: In this paper we have demonstrated these techniques on tensor-product surface models only. They can be generalized to triangular patches as well. 3 2 Problem Definition Given a trimmed NURBS surface model, we use knot insertion algorithms to decompose it into a series of Bezier patches <ref> [Far90] </ref>. We also subdivide the NURBS trimming curves at the patch boundaries and transform them into Bezier curves. Piecewise linear trimming curve representations are decomposed at the patch boundaries as well. All these steps are part of the preprocessing phase.
Reference: [Fea89] <author> H. Fuchs and J. Poulton et. al. </author> <title> Pixel-planes 5: A heterogeneous multiprocessor graphics system using processor-enhanced memories. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 79-88, </pages> <year> 1989. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. In particular, the current graphics systems can render up to millions of transformed, shaded and z-buffered polygons per second <ref> [Ake93, Fea89] </ref>. As a result, only algorithms based on polygonization come close to real time display. Many different methods of polygonization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. <p> We implemented this algorithm on two platforms - SGI-Onyx and the Pixelplanes 5 system at UNC. The Onyx was used with a single processors. The Pixelplanes 5 configuration included 30 graphic processors (though one of them is a master processor and does not perform the computations) and 14 renderers <ref> [Fea89] </ref>. The algorithm achieves load balancing by distributing neighboring patches onto different processors statically. No inter-processor communication is required. As a result it can be easily ported to any other multiple processor machine. The performance of the algorithm on the SGI has been shown in Table 6.
Reference: [FK90] <author> D.R. Forsey and V. Klassen. </author> <title> An adaptive subdivision algorithm for crack prevention in the display of parametric surfaces. </title> <booktitle> Proceedings of Graphics Interface, </booktitle> <pages> pages 1-8, </pages> <year> 1990. </year>
Reference: [FMM86] <author> D. Filip, R. Magedson, and R. Markot. </author> <title> Surface algorithms using bounds on derivatives. </title> <journal> CAGD, </journal> <volume> 3 </volume> <pages> 295-311, </pages> <year> 1986. </year>
Reference-contexts: In particular, the current graphics systems can render up to millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. As a result, only algorithms based on polygonization come close to real time display. Many different methods of polygonization have been proposed in the literature <ref> [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86] </ref>. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these algorithms focus on trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models. <p> Uniform tessellation involves choosing constant step sizes along each parameter. Adaptive tessellation uses a recursive approach to subdivision with a stopping condition (normally based on some "flatness" and "surface area" criteria). For large scale models, uniform subdivision methods have been found to be faster in practice <ref> [FMM86, KM94] </ref>. In practice, large scaled NURBS models typically consist of relatively flat surfaces. This is indeed the case after converting B-spline models into Bezier surfaces. Adaptive subdivision performs well on surfaces with highly varying curvatures and large areas. In such cases uniform tessellation may oversample them. <p> Another major reason for the choice of uniform tessellation is the relative simplicity and efficiency of handling trimming curves (as compared to adaptive subdivision). 3.1 Patch tessellation There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. They are base upon the size or the deviation criteria. Sometimes a normal deviation criterion is also used. This criterion bounds the deviation of the triangles' normals from the surface normal. While this bound can improve the image quality, it is relatively expensive to evaluate. <p> The size criterion can be applied in two ways for step size computation: * Compute the bounds on the surface in the object space as a preprocessing step and map these to the screen space. The step size is computed as a function of these bounds and viewing parameters <ref> [LR81, FMM86, AES91, KM94] </ref>. * Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size is a function of these bounds [Roc87, RHD89].
Reference: [For87] <author> S.J. Fortune. </author> <title> A sweepline algorithm for voronoi diagrams. </title> (2):153-174, 1987. 
Reference-contexts: Similarly we can replace all crossings with the corresponding external points, and avoid creating extra tessellants on the curve. This polygon can now be triangulated using any polygon triangulation algorithms [PS85, CTV89, Sei91]. Our current implementation uses Fortune's algorithm and robust implementation of Delaunay triangulation <ref> [For87] </ref>. There are two new problems with this method of polygon generation, though: 1. The external point of one cell is the exit point of another. If these points are included in polygons for both the cells, some overlapping triangles can be created. e.g.
Reference: [GL] <institution> The SGI Graphics Library manual. </institution>
Reference-contexts: We compare the surface triangulation of the two algorithms in Fig. 1. Fig. 1 (a) corresponds to the SGI-GL implementation based on Rockwood et. al.'s algorithm <ref> [Nas93, GL] </ref>. Our algorithm makes use of coherence between successive frames and performs incremental computation at each frame. This has a significant impact on the speed of the overall algorithm The rest of the paper is organized in the following manner.
Reference: [Kaj82] <author> J. Kajiya. </author> <title> Ray tracing parametric patches. </title> <journal> Computer Graphics, </journal> <volume> 16(3) </volume> <pages> 245-254, </pages> <year> 1982. </year>
Reference-contexts: In this paper we focus on trimmed surface models, typically obtained after surface intersection or other boolean operations. The problem of rendering curved surfaces (both trimmed and untrimmed) has been extensively studied in the literature and main techniques include pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Kaj82, NSK90, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. In particular, the current graphics systems can render up to millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89].
Reference: [KM94] <author> S. Kumar and D. Manocha. </author> <title> Interactive display of large scale nurbs models. </title> <type> Technical Report TR94-008, </type> <institution> Department of Computer Science, University of North Carolina, </institution> <year> 1994. </year>
Reference-contexts: The second criterion is referred as the size criterion. These two are used to obtain a good polygonization of the surface such that we obtain a smooth image after Gouraud or Phong shading of the polygons <ref> [KM94] </ref>. 3 Tessellation Computation In this section, we highlight the algorithm for tessellating the surface as a function of the viewing parameters. More details are given in [KM94]. In particular, we dynamically compute the polygo-nization of the surfaces as the viewing parameters are changing. <p> to obtain a good polygonization of the surface such that we obtain a smooth image after Gouraud or Phong shading of the polygons <ref> [KM94] </ref>. 3 Tessellation Computation In this section, we highlight the algorithm for tessellating the surface as a function of the viewing parameters. More details are given in [KM94]. In particular, we dynamically compute the polygo-nization of the surfaces as the viewing parameters are changing. Polygonization can be computed using uniform or adaptive subdivision for each frame. Uniform tessellation involves choosing constant step sizes along each parameter. <p> Uniform tessellation involves choosing constant step sizes along each parameter. Adaptive tessellation uses a recursive approach to subdivision with a stopping condition (normally based on some "flatness" and "surface area" criteria). For large scale models, uniform subdivision methods have been found to be faster in practice <ref> [FMM86, KM94] </ref>. In practice, large scaled NURBS models typically consist of relatively flat surfaces. This is indeed the case after converting B-spline models into Bezier surfaces. Adaptive subdivision performs well on surfaces with highly varying curvatures and large areas. In such cases uniform tessellation may oversample them. <p> The size criterion by itself may not result in a good approximation on patches with small area and highly varying curvature. A simple technique to account for such cases has been described in <ref> [KM94] </ref>. The size criterion can be applied in two ways for step size computation: * Compute the bounds on the surface in the object space as a preprocessing step and map these to the screen space. <p> The size criterion can be applied in two ways for step size computation: * Compute the bounds on the surface in the object space as a preprocessing step and map these to the screen space. The step size is computed as a function of these bounds and viewing parameters <ref> [LR81, FMM86, AES91, KM94] </ref>. * Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size is a function of these bounds [Roc87, RHD89]. <p> Computations of n t , the number of steps for a curve is also calculated similarly. More details are given in <ref> [KM94] </ref>. 3.2 Boundary Curve Tessellation The number of steps that two adjacent patches are tessellated into, need not be the same. This can result in cracks in the rendered image. <p> This is done by finding the common curves on different patches and choosing one of the representations for all adjacent patches for the purpose of computing bounds: for each boundary curve we associate with it, one of the patches it lies on. For further details refer to <ref> [KM94] </ref>. Note that the both these steps are preprocessing steps and are not done at the display time. If a patch abuts another patch, as in a T-junction, they do not have a common boundary; cracks still may appear. <p> When memory is not at a premium, we can retain these extra points. It turns out that, triangle rendering takes more time than triangle generation (and can easily become a bottleneck) <ref> [KM94] </ref>. So while extra points may be retained, the triangulation must be redone using only the correct set of points. In our experience, we hardly ever need to store more than 60 70 thousand triangles, needing about 3 4 megabytes of memory.
Reference: [LC93] <author> W.L. Luken and Fuhua Cheng. </author> <title> Rendering trimmed nurb surfaces. </title> <institution> Computer science research report 18669(81711), IBM Research Division, </institution> <year> 1993. </year>
Reference-contexts: Many different methods of polygonization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these algorithms focus on trimmed surface models <ref> [RHD89, Luk93, LC93, Che93, SC88, Vla90] </ref>. We present a fast algorithm for rendering trimmed NURBS models. Our approach shares its principle with the algorithm presented by Rockwood et. al. [RHD89]. <p> This is in terms of converting the NURBS models into Bezier surfaces, using uniform tessellation and computing the untrimmed regions of each cell and triangulating it. This is in contrast with direct rendering of trimmed NURBS surfaces using the B-spline representation <ref> [Luk93, LC93] </ref>. The rendering algorithm involves the computation of intersections of the trimming curve with the domain cells, visible region determination and triangulation. These operations are relatively simpler and faster to perform on a Bezier representation than on B-splines. The algorithm in [RHD89] partitions each trimming curve into monotonic segments.
Reference: [LCWB80] <author> J.M. Lane, L.C. Carpenter, J. T. Whitted, and J.F. </author> <title> Blinn. Scan line methods for displaying parametrically defined surfaces. </title> <journal> Communications of ACM, </journal> <volume> 23(1) </volume> <pages> 23-34, </pages> <year> 1980. </year>
Reference-contexts: In this paper we focus on trimmed surface models, typically obtained after surface intersection or other boolean operations. The problem of rendering curved surfaces (both trimmed and untrimmed) has been extensively studied in the literature and main techniques include pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Kaj82, NSK90, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. In particular, the current graphics systems can render up to millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89].
Reference: [LR81] <author> J.M. Lane and R.F. Riesenfeld. </author> <title> Bounds on polynomials. </title> <journal> BIT, </journal> <volume> 2 </volume> <pages> 112-117, </pages> <year> 1981. </year>
Reference-contexts: In particular, the current graphics systems can render up to millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. As a result, only algorithms based on polygonization come close to real time display. Many different methods of polygonization have been proposed in the literature <ref> [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86] </ref>. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these algorithms focus on trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models. <p> Another major reason for the choice of uniform tessellation is the relative simplicity and efficiency of handling trimming curves (as compared to adaptive subdivision). 3.1 Patch tessellation There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. They are base upon the size or the deviation criteria. Sometimes a normal deviation criterion is also used. This criterion bounds the deviation of the triangles' normals from the surface normal. While this bound can improve the image quality, it is relatively expensive to evaluate. <p> The size criterion can be applied in two ways for step size computation: * Compute the bounds on the surface in the object space as a preprocessing step and map these to the screen space. The step size is computed as a function of these bounds and viewing parameters <ref> [LR81, FMM86, AES91, KM94] </ref>. * Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size is a function of these bounds [Roc87, RHD89].
Reference: [Luk93] <institution> W.L. Luken. Tessellation of trimmed nurb surfaces. Computer science research report 19322(84059), IBM Research Division, </institution> <year> 1993. </year>
Reference-contexts: Many different methods of polygonization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these algorithms focus on trimmed surface models <ref> [RHD89, Luk93, LC93, Che93, SC88, Vla90] </ref>. We present a fast algorithm for rendering trimmed NURBS models. Our approach shares its principle with the algorithm presented by Rockwood et. al. [RHD89]. <p> This is in terms of converting the NURBS models into Bezier surfaces, using uniform tessellation and computing the untrimmed regions of each cell and triangulating it. This is in contrast with direct rendering of trimmed NURBS surfaces using the B-spline representation <ref> [Luk93, LC93] </ref>. The rendering algorithm involves the computation of intersections of the trimming curve with the domain cells, visible region determination and triangulation. These operations are relatively simpler and faster to perform on a Bezier representation than on B-splines. The algorithm in [RHD89] partitions each trimming curve into monotonic segments.
Reference: [MD94] <author> D. Manocha and J. Demmel. </author> <title> Algorithms for intersecting parametric and algebraic curves i: simple intersections. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 13(1) </volume> <pages> 73-100, </pages> <year> 1994. </year>
Reference-contexts: For each active strip For each active cell in the strip Triangulate the cell. 11 4.1 Intersection Initially we calculate all pairwise intersections between curves whose bounding boxes overlap. We use the recently developed algorithms for intersecting parametric and algebraic curves, which reduce the problem to an eigenvalue problem <ref> [MD94] </ref>. We merge two intersecting curves into one by eliminating sections of the curves. When a part of a curve lies in a region trimmed out by another curve, that part is redundant and can be discarded. Fig. 6 demonstrates how this is done. The basic idea is very simple.
Reference: [Nas93] <author> R. Nash. </author> <title> Silicon Graphics, </title> <type> Personal Communication, </type> <year> 1993. </year> <month> 26 </month>
Reference-contexts: We compare the surface triangulation of the two algorithms in Fig. 1. Fig. 1 (a) corresponds to the SGI-GL implementation based on Rockwood et. al.'s algorithm <ref> [Nas93, GL] </ref>. Our algorithm makes use of coherence between successive frames and performs incremental computation at each frame. This has a significant impact on the speed of the overall algorithm The rest of the paper is organized in the following manner. <p> The algorithm achieves load balancing by distributing neighboring patches onto different processors statically. No inter-processor communication is required. As a result it can be easily ported to any other multiple processor machine. The performance of the algorithm on the SGI has been shown in Table 6. The SGI-GL implementation <ref> [Nas93] </ref> is based on the algorithm presented in [RHD89] and has a microcoded geometry engine implementation for surface evaluations. This implementation works in immediate mode.
Reference: [NSK90] <author> T. Nishita, T.W. Sederberg, and M. Kakimoto. </author> <title> Ray tracing trimmed rational surface patches. </title> <journal> Computer Graphics, </journal> <volume> 24(4) </volume> <pages> 337-345, </pages> <year> 1990. </year>
Reference-contexts: In this paper we focus on trimmed surface models, typically obtained after surface intersection or other boolean operations. The problem of rendering curved surfaces (both trimmed and untrimmed) has been extensively studied in the literature and main techniques include pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Kaj82, NSK90, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. In particular, the current graphics systems can render up to millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. <p> Note that some redundant curves that do not intersect any curve (curve D in Fig. 5) may still remain. This happens when a clockwise loop lies inside another (or is tangent to it) 2 . This containment is tested for each pair of non-intersecting curves whose bounding boxes overlap <ref> [NSK90] </ref>. We tessellate each curve on-line and get a piecewise linear representation: a sequence of points p 0 : : : p n . Note that the points of intersection must appear in this sequence. While the actual curves do not intersect, their piecewise approximations might.
Reference: [PS85] <author> F.P. Preparata and M. I. Shamos. </author> <title> Computational Geometry. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: If we use the external point A instead of b, we get a correct triangulation there. Similarly we can replace all crossings with the corresponding external points, and avoid creating extra tessellants on the curve. This polygon can now be triangulated using any polygon triangulation algorithms <ref> [PS85, CTV89, Sei91] </ref>. Our current implementation uses Fortune's algorithm and robust implementation of Delaunay triangulation [For87]. There are two new problems with this method of polygon generation, though: 1. The external point of one cell is the exit point of another.
Reference: [RHD89] <author> A. Rockwood, K. Heaton, and T. Davis. </author> <title> Real-time rendering of trimmed surfaces. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 107-17, </pages> <year> 1989. </year>
Reference-contexts: Many different methods of polygonization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these algorithms focus on trimmed surface models <ref> [RHD89, Luk93, LC93, Che93, SC88, Vla90] </ref>. We present a fast algorithm for rendering trimmed NURBS models. Our approach shares its principle with the algorithm presented by Rockwood et. al. [RHD89]. <p> Many of these algorithms focus on trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models. Our approach shares its principle with the algorithm presented by Rockwood et. al. <ref> [RHD89] </ref>. This is in terms of converting the NURBS models into Bezier surfaces, using uniform tessellation and computing the untrimmed regions of each cell and triangulating it. This is in contrast with direct rendering of trimmed NURBS surfaces using the B-spline representation [Luk93, LC93]. <p> The rendering algorithm involves the computation of intersections of the trimming curve with the domain cells, visible region determination and triangulation. These operations are relatively simpler and faster to perform on a Bezier representation than on B-splines. The algorithm in <ref> [RHD89] </ref> partitions each trimming curve into monotonic segments. This monotonic subdivision followed by special triangulation at the patch boundaries sometimes becomes a bottleneck for the [RHD89] algorithm. We overcome these problems with handling trimming curves and present efficient algorithms for trimmed cell computation and triangulation (Fig 1). <p> These operations are relatively simpler and faster to perform on a Bezier representation than on B-splines. The algorithm in <ref> [RHD89] </ref> partitions each trimming curve into monotonic segments. This monotonic subdivision followed by special triangulation at the patch boundaries sometimes becomes a bottleneck for the [RHD89] algorithm. We overcome these problems with handling trimming curves and present efficient algorithms for trimmed cell computation and triangulation (Fig 1). We also devise better bounds for uniformly tessellating the surface domain into fewer cells and compute the 2 (a) [RHD89]'s Triangulation (b) Our Triangulation trimming regions without partitioning them <p> The step size is computed as a function of these bounds and viewing parameters [LR81, FMM86, AES91, KM94]. * Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size is a function of these bounds <ref> [Roc87, RHD89] </ref>. The advantage of the first method is that it reduces the on-line time for bounds computation. Little computation is required to calculate the desired step size for a patch given the viewing parameters (the transformation matrix). <p> This is easily achieved by generating triangle-strips (called coving triangles) at the boundaries (see Fig. 3) as described in <ref> [RHD89] </ref> for the boundaries of untrimmed patches. Since the trimming curves can themselves be boundary curves (especially when they arise from intersection of surfaces), we need an extension of the same concept here also. <p> We simply retriangulate the region. u-lines are handled similarly. 6 Implementation & Performance Our algorithm performs well in practice and coving is no longer the bottleneck. The polygonization produced by our algorithm is compared to that of the implementation in SGI-GL library based on <ref> [RHD89] </ref> in Figs. 1 and 15. We implemented this algorithm on two platforms - SGI-Onyx and the Pixelplanes 5 system at UNC. The Onyx was used with a single processors. <p> No inter-processor communication is required. As a result it can be easily ported to any other multiple processor machine. The performance of the algorithm on the SGI has been shown in Table 6. The SGI-GL implementation [Nas93] is based on the algorithm presented in <ref> [RHD89] </ref> and has a microcoded geometry engine implementation for surface evaluations. This implementation works in immediate mode. So, even though we had turned off all usage of coherence in our algorithm, we did not have to do any monotonic decomposition, while the GL implementation needlessly did it for every frame.
Reference: [Roc87] <author> A. Rockwood. </author> <title> A generalized scanning technique for display of parametrically defined surface. </title> <journal> IEEE Computer Graphics and Applications, </journal> <pages> pages 15-26, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: In particular, the current graphics systems can render up to millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. As a result, only algorithms based on polygonization come close to real time display. Many different methods of polygonization have been proposed in the literature <ref> [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86] </ref>. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these algorithms focus on trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models. <p> In the context of uniform tessellation, the evaluation of Bezier polynomials can be optimized if we use points that lie on an isoparametric 6 curve: we can reuse one of the factors of the tensor product or use forward differencing <ref> [Roc87] </ref>. Another major reason for the choice of uniform tessellation is the relative simplicity and efficiency of handling trimming curves (as compared to adaptive subdivision). 3.1 Patch tessellation There is considerable literature on computation of bounds on polynomials [LR81, FMM86, Roc87, AES91]. <p> Another major reason for the choice of uniform tessellation is the relative simplicity and efficiency of handling trimming curves (as compared to adaptive subdivision). 3.1 Patch tessellation There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. They are base upon the size or the deviation criteria. Sometimes a normal deviation criterion is also used. This criterion bounds the deviation of the triangles' normals from the surface normal. While this bound can improve the image quality, it is relatively expensive to evaluate. <p> The step size is computed as a function of these bounds and viewing parameters [LR81, FMM86, AES91, KM94]. * Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size is a function of these bounds <ref> [Roc87, RHD89] </ref>. The advantage of the first method is that it reduces the on-line time for bounds computation. Little computation is required to calculate the desired step size for a patch given the viewing parameters (the transformation matrix).
Reference: [SC88] <author> M. Shantz and S. Chang. </author> <title> Rendering trimmed nurbs with adaptive forward differencing. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 189-198, </pages> <year> 1988. </year>
Reference-contexts: Many different methods of polygonization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these algorithms focus on trimmed surface models <ref> [RHD89, Luk93, LC93, Che93, SC88, Vla90] </ref>. We present a fast algorithm for rendering trimmed NURBS models. Our approach shares its principle with the algorithm presented by Rockwood et. al. [RHD89].
Reference: [Sei91] <author> R. Seidel. </author> <title> A simple and fast randomized algorithm for computing trapezoidal decompositions and for triangulating polygons. </title> <journal> Computational Geometry Theory & Applications, </journal> <volume> 1(1) </volume> <pages> 51-64, </pages> <year> 1991. </year>
Reference-contexts: If we use the external point A instead of b, we get a correct triangulation there. Similarly we can replace all crossings with the corresponding external points, and avoid creating extra tessellants on the curve. This polygon can now be triangulated using any polygon triangulation algorithms <ref> [PS85, CTV89, Sei91] </ref>. Our current implementation uses Fortune's algorithm and robust implementation of Delaunay triangulation [For87]. There are two new problems with this method of polygon generation, though: 1. The external point of one cell is the exit point of another.
Reference: [SL87] <author> M. Shantz and S. Lien. </author> <title> Shading bicubic patches. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 189-196, </pages> <year> 1987. </year>
Reference-contexts: In particular, the current graphics systems can render up to millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. As a result, only algorithms based on polygonization come close to real time display. Many different methods of polygonization have been proposed in the literature <ref> [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86] </ref>. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these algorithms focus on trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models.
Reference: [Vla90] <author> V. Vlassopoulos. </author> <title> Adaptive polygonization of parametric surface. </title> <journal> Visual Computer, </journal> <volume> 6 </volume> <pages> 291-298, </pages> <month> November </month> <year> 1990. </year> <pages> 27 28 </pages>
Reference-contexts: Many different methods of polygonization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these algorithms focus on trimmed surface models <ref> [RHD89, Luk93, LC93, Che93, SC88, Vla90] </ref>. We present a fast algorithm for rendering trimmed NURBS models. Our approach shares its principle with the algorithm presented by Rockwood et. al. [RHD89].
References-found: 34

