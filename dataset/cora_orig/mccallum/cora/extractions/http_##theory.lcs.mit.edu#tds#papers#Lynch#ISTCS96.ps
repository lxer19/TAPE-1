URL: http://theory.lcs.mit.edu/tds/papers/Lynch/ISTCS96.ps
Refering-URL: http://theory.lcs.mit.edu/tds/papers/Lynch/ISTCS96.html
Root-URL: 
Email: lynch@theory.lcs.mit.edu  rajsbaum@servidor.unam.mx  
Title: On the Borowsky-Gafni Simulation Algorithm (Extended Abstract)  
Author: Nancy Lynch Sergio Rajsbaum Instituto de Matem aticas, UNAM Ciudad Universitaria D.F. , M exico 
Address: Cambridge, MA 02139  
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  
Abstract: The first precise description of a version of the Borowsky-Gafni fault-tolerant simulation algorithm is given, along with a careful description of what it accomplishes and a proof of correctness. The algorithm implements a notion of fault-tolerant reducibility between decision problems. This notion of reducibility is defined, and examples of its use are provided. The algorithm is presented and verified in terms of I/O automata. The presentation has a great deal of interesting modularity, expressed by I/O automaton composition and both forward and backward simulation relations. Composition is used to include a safe agreement module as a subroutine. Forward and backward simulation relations are used to view the algorithm as implementing a multi-try snapshot strategy. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Afek, H. Attiya, D. Dolev, E. Gafni, M. Merritt and N. Shavit, </author> <title> Atomic Snapshots of Shared Memory, </title> <journal> Journal of the ACM, </journal> <volume> Vol. 40, No. 4, </volume> <month> September </month> <year> 1993, </year> <pages> 873-890. </pages>
Reference-contexts: Likewise, a system using snapshot shared memory can be implemented in terms of single-writer multi-reader read/write shared variables, again with no change in externally-observable behavior; see, e.g., <ref> [1] </ref> for a construction. 3 Decision Problems and Fault-Tolerant Re ducibility First we define decision problems and say what it means for a system to solve a decision problem (e.g. [8]). Then we define the fault-tolerant reducibility between decision problems.
Reference: [2] <author> Hagit Attiya, Amotz Bar-Noy, Danny Dolev, David Peleg, and Rudiger Reischuk, </author> <title> Renaming in an asynchronous environment, </title> <journal> Journal of the ACM, </journal> <volume> Vol. 37, No. 3, </volume> <month> July </month> <year> 1990, </year> <pages> 524-548. </pages>
Reference: [3] <author> E. Borowsky and E. Gafni, </author> <title> Generalized FLP impossibility result for t-resilient asynchronous computations, </title> <booktitle> in Proceedings of the 1993 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993, </year> <pages> 91-100. </pages>
Reference-contexts: 1 Introduction Consider a read/write asynchronous shared memory system. In <ref> [3] </ref>, Borowsky and Gafni describe an algorithm that allows a set of f + 1 processes, any f of which may exhibit stopping failures, to simulate a larger number n of processes, also with at most f failures. <p> In the n-process k-set-agreement problem [6], all n processes propose values and decide on at most k of the proposed values. The simulation algorithm is used in <ref> [3] </ref> to convert an arbitrary k-fault-tolerant n-process solution for the k-set-agreement problem into a wait-free k + 1-process solution for the same fl Supported by Air Force Contract AFOSR F49620-92-J-0125, NSF contract 9225124CCR, and DARPA contracts N00014-92-J-4033 and F19628-95-C-0118. y Part of this work was done at the Laboratory for Computer <p> Supported by DGAPA and CONACYT Projects. problem. A wait-free algorithm is one in which any non-failing process terminates, regardless of the failure of any number of the other processes. Since the k + 1-process k-set-agreement problem has been shown to have no wait-free solution <ref> [3, 8, 12] </ref>, this transformation implies that there is no k-fault-tolerant solution to the n-process k-set-agreement problem, for any n. Other applications of the simulation algorithm appear in [4] and in [5]. <p> However, in order for this to happen, it must be clear exactly what the simulation guarantees. Borowsky and Gafni's presentation is brief and informal, and does not include a careful specification of what the algorithm provides to its users. In fact, the emphasis in <ref> [3] </ref> is mainly on the application to the k-set-agreement problem rather than on the simulation itself. We began this research with the modest aim of stating and proving precise correctness guarantees for the Borowsky-Gafni simulation algorithm, using the I/O automaton model and standard proof techniques (invariants, simulation relations, composition, etc.). <p> However, the job turned out to be more difficult than we expected, because the description in <ref> [3] </ref> left some ambiguities that we needed to resolve. 1 The final product of our work is a complete and careful description of a version of the Borowsky-Gafni simulation algorithm, plus a careful description of what it accomplishes, plus a proof of correctness. <p> In order to specify what the simulation accomplishes, we define a notion of fault-tolerant reducibility between decision problems, and show that the algorithm implements this reducibility, in a precise sense. Although this notion 1 For example, the read/write shared memory model that we believe is intended in <ref> [3] </ref> turns out not to provide enough coherence among the data read by different processes. <p> For example, the n-process k-set-agreement problem is f -reducible to the n 0 -process k 0 -set-agreement problem if k k 0 and f min fn; n 0 g. (The particular case where n = k + 1 and f = k = k 0 was used in <ref> [3] </ref>.) On the other hand, these problems are not reducible if k f &lt; k 0 . Moreover, we only know trivial instances of the renaming problem that satisfy the reducibility. <p> The presentation has a great deal of interesting modularity, expressed by I/O automaton composition and both forward and backward simulation relations (see [11], for example, for definitions). Composition is used to include a safe agreement module, a simplification of one in <ref> [3] </ref>, as a subroutine. Forward and backward simulation relations are used to view the algorithm as implementing a multi-try snapshot strategy. <p> But this contradicts the results of <ref> [3, 7, 8, 12] </ref>. Example 3: (2; 2)-renaming (2-process renaming to a 2-valued name space) is 1-reducible to (n 0 ; n 0 )-renaming, for any n 0 2. <p> The following is an informal description of a simple design (using snapshot shared memory) for a safe agreement module. The formal description in the Appendix is a simplification of the one in <ref> [3] </ref>. The snapshot shared memory contains a val component and a level component for each process i. When process i receives a propose (v) i , it records the value v in its val component and raises its level to 1.
Reference: [4] <author> E. Borowsky and E. Gafni, </author> <title> The implication of the Borowsky-Gafni simulation on the set consensus hierarchy, </title> <type> Technical Report 930021, </type> <institution> UCLA Computer Science Dept., </institution> <year> 1993. </year>
Reference-contexts: Since the k + 1-process k-set-agreement problem has been shown to have no wait-free solution [3, 8, 12], this transformation implies that there is no k-fault-tolerant solution to the n-process k-set-agreement problem, for any n. Other applications of the simulation algorithm appear in <ref> [4] </ref> and in [5]. These initial examples suggest that the Borowsky-Gafni simulation can become a powerful tool for proving solvability and unsolvability results for fault-prone asynchronous systems. However, in order for this to happen, it must be clear exactly what the simulation guarantees. <p> More sophisticated extensions are required in applications in <ref> [4, 5] </ref>, where algorithms with access to set consensus objects need to be simulated 2 . We believe that an important contribution of this paper is providing the basis for the development of an interesting variety of extensions to the Borowsky-Gafni simulation algorithm.
Reference: [5] <author> E. Borowsky and E. Gafni, </author> <title> A Computability Theorem for t-Resilient Computation Using Any Set Consensus Objects, </title> <type> manuscript, </type> <month> November 30, </month> <year> 1994. </year> <title> 2 It is argued in [4] that this type of extension of the basic (read/write) Borowsky-Gafni simulation algorithm is simple, by using a variant of the safe-agreement algorithm. </title>
Reference-contexts: Since the k + 1-process k-set-agreement problem has been shown to have no wait-free solution [3, 8, 12], this transformation implies that there is no k-fault-tolerant solution to the n-process k-set-agreement problem, for any n. Other applications of the simulation algorithm appear in [4] and in <ref> [5] </ref>. These initial examples suggest that the Borowsky-Gafni simulation can become a powerful tool for proving solvability and unsolvability results for fault-prone asynchronous systems. However, in order for this to happen, it must be clear exactly what the simulation guarantees. <p> More sophisticated extensions are required in applications in <ref> [4, 5] </ref>, where algorithms with access to set consensus objects need to be simulated 2 . We believe that an important contribution of this paper is providing the basis for the development of an interesting variety of extensions to the Borowsky-Gafni simulation algorithm.
Reference: [6] <author> S. Chaudhuri, </author> <title> Agreement is harder than consensus: set consensus problems in totally asynchronous systems, </title> <booktitle> In Proceedings of the Ninth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1990, </year> <pages> 311-234. </pages>
Reference-contexts: In [3], Borowsky and Gafni describe an algorithm that allows a set of f + 1 processes, any f of which may exhibit stopping failures, to simulate a larger number n of processes, also with at most f failures. In the n-process k-set-agreement problem <ref> [6] </ref>, all n processes propose values and decide on at most k of the proposed values. <p> If this reducibility held, then the main theorem of this paper, Theorem 6.9, together with the fact that (n 0 ; k 0 )-set agreement is solvable when f &lt; k 0 <ref> [6] </ref>, would imply the existence of an f -fault-tolerant algorithm to solve (n; k)-set-agreement. But this contradicts the results of [3, 7, 8, 12]. Example 3: (2; 2)-renaming (2-process renaming to a 2-valued name space) is 1-reducible to (n 0 ; n 0 )-renaming, for any n 0 2.
Reference: [7] <author> M.J. Fischer, N.A. Lynch, </author> <title> M.S. Paterson, Impossibility of distributed consensus with one faulty process, </title> <journal> Journal of the ACM, </journal> <volume> Vol. 32, No. 2, </volume> <month> April </month> <year> 1985, </year> <pages> 374-382. </pages>
Reference-contexts: But this contradicts the results of <ref> [3, 7, 8, 12] </ref>. Example 3: (2; 2)-renaming (2-process renaming to a 2-valued name space) is 1-reducible to (n 0 ; n 0 )-renaming, for any n 0 2.
Reference: [8] <author> M.P. Herlihy and N. Shavit, </author> <title> The asynchronous computability theorem for t-resilient tasks, </title> <booktitle> In Proceedings of the 1993 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993, </year> <pages> 111-120. </pages>
Reference-contexts: Supported by DGAPA and CONACYT Projects. problem. A wait-free algorithm is one in which any non-failing process terminates, regardless of the failure of any number of the other processes. Since the k + 1-process k-set-agreement problem has been shown to have no wait-free solution <ref> [3, 8, 12] </ref>, this transformation implies that there is no k-fault-tolerant solution to the n-process k-set-agreement problem, for any n. Other applications of the simulation algorithm appear in [4] and in [5]. <p> can be implemented in terms of single-writer multi-reader read/write shared variables, again with no change in externally-observable behavior; see, e.g., [1] for a construction. 3 Decision Problems and Fault-Tolerant Re ducibility First we define decision problems and say what it means for a system to solve a decision problem (e.g. <ref> [8] </ref>). Then we define the fault-tolerant reducibility between decision problems. A relation from X to Y is a subset of X fi Y . <p> But this contradicts the results of <ref> [3, 7, 8, 12] </ref>. Example 3: (2; 2)-renaming (2-process renaming to a 2-valued name space) is 1-reducible to (n 0 ; n 0 )-renaming, for any n 0 2.
Reference: [9] <author> N.A. Lynch, </author> <title> Distributed Algorithms, </title> <publisher> Morgan Kauf-mann Publishers, Inc. </publisher> <year> 1996. </year>
Reference-contexts: Some of the formal descriptions and proofs are omitted from this extended abstract. 2 The Model The underlying model is the I/O automaton model of Lynch and Tuttle [10], as described, for example, in Chapter 8 of <ref> [9] </ref>. Briefly, an I/O automaton is a simple state machine whose transitions are labelled with actions. Actions are classified as input, output, or internal. The automaton need not be finite-state, and may have multiple start states. <p> Most of the systems in this paper are asynchronous shared memory systems, as defined, for example, in Chapter 9 of <ref> [9] </ref>. Briefly, an n-process asynchronous shared memory system consists of n processes interacting via instantaneously-accessible shared variables. We allow finitely many or infinitely many shared variables. (Allowing infinitely many shared variables is a slight generalization over what appears in [9], but it does not affect any of the properties we require.) <p> shared memory systems, as defined, for example, in Chapter 9 of <ref> [9] </ref>. Briefly, an n-process asynchronous shared memory system consists of n processes interacting via instantaneously-accessible shared variables. We allow finitely many or infinitely many shared variables. (Allowing infinitely many shared variables is a slight generalization over what appears in [9], but it does not affect any of the properties we require.) Formally, we model the system as a single I/O automaton, whose state consists of all the process local state information plus the values of the shared variables, and whose task structure respects the division into processes.
Reference: [10] <author> N.A. Lynch, </author> <title> M.R. Tuttle, An Introduction to input/output automata, </title> <institution> TM-373, MIT Laboratory for Computer Science, </institution> <month> November </month> <year> 1988. </year>
Reference-contexts: The moral is that one must be careful in applying the simulation it does not work for all pairs of problems, but only those that satisfy the reducibility. We present and verify the algorithm in terms of I/O automata <ref> [10] </ref>. The presentation has a great deal of interesting modularity, expressed by I/O automaton composition and both forward and backward simulation relations (see [11], for example, for definitions). Composition is used to include a safe agreement module, a simplification of one in [3], as a subroutine. <p> Some of the formal descriptions and proofs are omitted from this extended abstract. 2 The Model The underlying model is the I/O automaton model of Lynch and Tuttle <ref> [10] </ref>, as described, for example, in Chapter 8 of [9]. Briefly, an I/O automaton is a simple state machine whose transitions are labelled with actions. Actions are classified as input, output, or internal. The automaton need not be finite-state, and may have multiple start states.
Reference: [11] <author> Nancy Lynch and Frits Vaandrager. </author> <title> Forward and Backward Simulations Part I: </title> <journal> Untimed Systems, Information and Computation, </journal> <volume> Vol. 121, No. 2, </volume> <month> Septem-ber </month> <year> 1995, </year> <pages> 214-233. </pages>
Reference-contexts: We present and verify the algorithm in terms of I/O automata [10]. The presentation has a great deal of interesting modularity, expressed by I/O automaton composition and both forward and backward simulation relations (see <ref> [11] </ref>, for example, for definitions). Composition is used to include a safe agreement module, a simplification of one in [3], as a subroutine. Forward and backward simulation relations are used to view the algorithm as implementing a multi-try snapshot strategy. <p> Informally, forward and backward simulation relations are techniques to show that one I/O automaton implements another <ref> [11] </ref>; they have nothing to do with simulations in the sense of the Borowsky-Gafni simulation algorithm. 6.1. The SimpleSpec Automaton Our highest level is expressed by the SimpleSpec automaton, which directly simulates system P 0 , in a centralized manner.
Reference: [12] <author> M. Saks and F. Zaharoglou, </author> <title> Wait-free k-set agreement is impossible: The topology of public knowledge, </title> <booktitle> In Proceedings of the 1993 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993, </year> <pages> 101-110. </pages>
Reference-contexts: Supported by DGAPA and CONACYT Projects. problem. A wait-free algorithm is one in which any non-failing process terminates, regardless of the failure of any number of the other processes. Since the k + 1-process k-set-agreement problem has been shown to have no wait-free solution <ref> [3, 8, 12] </ref>, this transformation implies that there is no k-fault-tolerant solution to the n-process k-set-agreement problem, for any n. Other applications of the simulation algorithm appear in [4] and in [5]. <p> But this contradicts the results of <ref> [3, 7, 8, 12] </ref>. Example 3: (2; 2)-renaming (2-process renaming to a 2-valued name space) is 1-reducible to (n 0 ; n 0 )-renaming, for any n 0 2.
References-found: 12

