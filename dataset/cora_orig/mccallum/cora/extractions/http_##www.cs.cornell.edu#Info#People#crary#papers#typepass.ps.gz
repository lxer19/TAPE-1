URL: http://www.cs.cornell.edu/Info/People/crary/papers/typepass.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/crary/papers/
Root-URL: 
Title: Intensional Polymorphism in Type-Erasure Semantics  
Author: Karl Crary Stephanie Weirich Greg Morrisett 
Affiliation: Cornell University  
Abstract: Intensional polymorphism, the ability to dispatch to different routines based on types at run time, enables a variety of advanced implementation techniques for polymorphic languages, including tag-free garbage collection, unboxed function arguments, polymorphic marshalling, and flattened data structures. To date, languages that support intensional polymorphism have required a type-passing (as opposed to type-erasure) interpretation where types are constructed and passed to polymorphic functions at run time. Unfortunately, type-passing suffers from a number of drawbacks; it requires duplication of constructs at the term and type levels, it prevents abstraction, and it severely complicates polymorphic closure conversion. We present a type-theoretic framework that supports intensional polymorphism, but avoids many of the disadvantages of type passing. In our approach, run-time type information is represented by ordinary terms. This avoids the duplication problem, allows us to recover abstraction, and avoids complications with closure conversion. In addition, our type system provides another improvement in expressiveness; it allows unknown types to be refined in place thereby avoiding certain beta-expansions required by other frameworks. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Birkedal, M. Tofte, and M. Vejlstrup. </author> <title> From region inference to von Neumann machines via region representation inference. </title> <booktitle> In Twenty-Third ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 171-183, </pages> <address> St. Pe-tersburg, </address> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Type-directed compilers use type information to enable optimizations and transformations that are impossible (or prohibitively difficult) without such information <ref> [12, 10, 16, 1, 22, 24, etc.] </ref>. However, type-directed compilers for some languages such as Modula-3 and ML face the difficulty that some type information cannot be known at compile time.
Reference: [2] <author> R. L. Constable. </author> <title> Intensional analysis of functions and types. </title> <type> Technical Report CSR-118-82, </type> <institution> Department of Computer Science, University of Edin-burgh, </institution> <month> June </month> <year> 1982. </year>
Reference-contexts: In this paper we focus on the latter area of applications. To lay a solid foundation for programs that analyze types at run time, Harper and Morrisett devised an internal language, called ML i , that supports the first-class intensional analysis 1 of types (following earlier work by Constable <ref> [2, 3] </ref>). The ML i language and its derivatives were then used extensively in the high-performance ML compilers TIL/ML [26, 19] and FLINT [25].
Reference: [3] <author> R. L. Constable and D. R. Zlatin. </author> <title> The type theory of PL/CV3. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(1) </volume> <pages> 94-117, </pages> <month> Jan. </month> <year> 1984. </year>
Reference-contexts: In this paper we focus on the latter area of applications. To lay a solid foundation for programs that analyze types at run time, Harper and Morrisett devised an internal language, called ML i , that supports the first-class intensional analysis 1 of types (following earlier work by Constable <ref> [2, 3] </ref>). The ML i language and its derivatives were then used extensively in the high-performance ML compilers TIL/ML [26, 19] and FLINT [25].
Reference: [4] <author> J. Despeyroux, F. Pfenning, and Carsten Schurmann. </author> <title> Primitive recursion for higher-order abstract syntax. </title> <booktitle> In Third International Conference on Typed Lambda Calculi and Applications, volume 1210 of Lecture Notes in Computer Science, </booktitle> <pages> pages 147-163, </pages> <address> Nancy, France, </address> <month> Apr. </month> <year> 1997. </year> <note> Springer-Verlag. Extended version published as Carnegie Mellon University technical report CMU-CS-96-172. </note>
Reference: [5] <author> C. Dubois, F. Rouaix, and P. Weis. </author> <title> Extensional polymorphism. </title> <booktitle> In Twenty-Second ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 118-129, </pages> <address> San Francisco, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Dubois at al. <ref> [5] </ref> also pass explicit type representations to polymorphic functions when compiling ad-hoc poly-morphism.
Reference: [6] <author> D. Duggan. </author> <title> A type-based semantics for user-defined marshalling in polymorphic languages. </title> <booktitle> In Second Workshop on Types in Compilation, </booktitle> <month> Mar. </month> <year> 1998. </year>
Reference-contexts: However, their system differs from ours and Minamide's in that no mechanism is provided for con necting representations to the types they denote, and consequently, information gained by analyzing type representations does not propagate into the type system. Duggan <ref> [6] </ref> proposes another typed framework for intensional type analysis that is similar in some ways to ML i . Like ML i , Duggan's system passes types implicitly and allows for the intensional analysis of types at the term level.
Reference: [7] <author> J.-Y. Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination de coupures dans l'analyse et la theorie des types. </title> <editor> In J. E. Fenstad, editor, </editor> <booktitle> Proceedings of the Second Scandinavian Logic Symposium, </booktitle> <pages> pages 63-92. </pages> <publisher> North-Holland Publishing Co., </publisher> <year> 1971. </year>
Reference-contexts: The ML i calculus provides these tools in a form that is relatively simple, but already quite powerful. The syntax of ML i appears below (modified slightly for presentation). The backbone of ML i is a predicative variant of Girard's F ! <ref> [8, 7] </ref> in which the quantified type 8ff:: ranges only over type constructors and "small" types (i.e., monotypes), which do not include the quan tified types.
Reference: [8] <author> J.-Y. Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: The ML i calculus provides these tools in a form that is relatively simple, but already quite powerful. The syntax of ML i appears below (modified slightly for presentation). The backbone of ML i is a predicative variant of Girard's F ! <ref> [8, 7] </ref> in which the quantified type 8ff:: ranges only over type constructors and "small" types (i.e., monotypes), which do not include the quan tified types.
Reference: [9] <author> R. Harper and M. Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Twenty-First ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 123-137, </pages> <address> Portland, Oregon, </address> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: The former requires the use of abstract kinds and the latter requires the use of translucent types <ref> [9] </ref>.
Reference: [10] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymor-phism using intensional type analysis. </title> <booktitle> In Twenty-Second ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 130-141, </pages> <address> San Francisco, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Type-directed compilers use type information to enable optimizations and transformations that are impossible (or prohibitively difficult) without such information <ref> [12, 10, 16, 1, 22, 24, etc.] </ref>. However, type-directed compilers for some languages such as Modula-3 and ML face the difficulty that some type information cannot be known at compile time. <p> In order to use type information in contexts where it cannot be provided statically, a number of advanced implementation techniques process type information at run time <ref> [10, 16, 27, 18, 24] </ref>. Such type information is used in two ways: behind the scenes, typically by tag-free garbage collectors [27], and explicitly in program code, for a variety of purposes such as efficient data representation and marshalling [16, 10]. <p> Such type information is used in two ways: behind the scenes, typically by tag-free garbage collectors [27], and explicitly in program code, for a variety of purposes such as efficient data representation and marshalling <ref> [16, 10] </ref>. In this paper we focus on the latter area of applications. <p> =&gt; array [int] | =&gt; array [ff] val packedsub : 8ff: PackedArray [ff] * int -&gt; ff = Fn [ff] =&gt; typecase ff of bool =&gt; bitsub | =&gt; sub i calculus To formalize the tools of intensional type analysis, we begin by summarizing Harper and Morrisett's ML i calculus <ref> [10] </ref>. The ML i calculus provides these tools in a form that is relatively simple, but already quite powerful. The syntax of ML i appears below (modified slightly for presentation). <p> Typerec allows the creation of new types by similar intensional analysis. Several examples of this appear in Harper and Morrisett <ref> [10] </ref>, including type-directed data layout, marshalling and unboxing. While recursion in the term-level typecase is handled by fix, at the the constructor level there is no such mechanism. For this reason, Typerec is essentially a "fold" operation (or catamorphism) over inductively defined types.
Reference: [11] <author> M. P. Jones. </author> <title> A theory of qualified types. </title> <booktitle> In Fourth European Symposium on Programming, volume 582 of Lecture Notes in Computer Science, Rennes, </booktitle> <address> France, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The principal difference between Minamide's system and ours is that Minamide did not consider intensional type analysis or first-class polymorphism. Mi-namide's system also makes a distinction between type representations (which he calls evidence, following Jones <ref> [11] </ref>) and ordinary terms, while R type representations are fully first-class. The issue of type parameter lifting is an important one for compilers based on R .
Reference: [12] <author> X. Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 177-188, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Type-directed compilers use type information to enable optimizations and transformations that are impossible (or prohibitively difficult) without such information <ref> [12, 10, 16, 1, 22, 24, etc.] </ref>. However, type-directed compilers for some languages such as Modula-3 and ML face the difficulty that some type information cannot be known at compile time.
Reference: [13] <author> Y. Minamide. </author> <title> Full lifting of type parameters. </title> <note> Submitted for publication. Earlier version published as "Compilation Based on a Calculus for Explicit Type-Passing" in the Second Fuji International Workshop on Functional and Logic Programming, </note> <year> 1996. </year>
Reference-contexts: On the other hand, abstract kinds do not appear in the process, suggesting them to be an artifact of true type-passing (but see Appendix B). 5 Related Work Closely related to our work is the work of Minamide on lifting of type parameters for tag-free garbage collection <ref> [13] </ref>. Minamide was interested in lifting type parameters out of code so they could be preallocated at compile time.
Reference: [14] <author> Y. Minamide, G. Morrisett, and R. Harper. </author> <title> Typed closure conversion. </title> <booktitle> In Twenty-Third ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 271-283, </pages> <address> St. Pe-tersburg, Florida, </address> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: and initializing types, which in turn requires the typing machinery for allocation and initialization to be lifted an additional level into the kind struc ture. * As a particularly important example of the preceding issue, type passing severely complicates typed closure conversion (compare the type-passing system of Minamide et al. <ref> [14] </ref> to the type-erasure system of Morrisett et al. [20]). <p> In a type-passing framework, the instantiation with a type environment can have some run-time effect, so it must be delayed until the function is invoked. Consequently, closures must include a type environment, necessitating complicated mechanisms including abstract kinds and translucent types <ref> [14] </ref>. In this paper we propose a typed calculus, called R , that ameliorates the problems of type passing without sacrificing intensional type analysis. If run-time type dispatch is to be supported, then clearly on some level types must be passed. <p> Hence, the code may be hoisted to the top-level, allocated at compile time, and shared among all substitution instances. Application is rewritten so that the code of a closure is first applied to its environment and then to its arguments. In the monomorphic case no discrepancy arises between type-passing <ref> [14] </ref> and type-erasure [20] closure conversion. An existential type is used to hold the type of the closure's environment abstract, so a closure for a t 1 ! t 2 function is given the type 9ff:((t 1 fiff) ! t 2 )fiff. <p> The kind of the type environment must be hidden (as did the type of the value environment in the monomorphic case), and the closure's type must enforce the requirement that the code be applied only to the proper type environment (see Minamide et al. <ref> [14] </ref> for detailed explanations of why). The former requires the use of abstract kinds and the latter requires the use of translucent types [9]. This results in a closure having the considerably more complicated type (again, see Minamide et al. [14] for a 6 formalization of the necessary type theory): 9k <p> only to the proper type environment (see Minamide et al. <ref> [14] </ref> for detailed explanations of why). The former requires the use of abstract kinds and the latter requires the use of translucent types [9]. This results in a closure having the considerably more complicated type (again, see Minamide et al. [14] for a 6 formalization of the necessary type theory): 9k tenv :Kind: 9ff venv :Type: 9fi tenv :k tenv : (8fl:k tenv =fi tenv : (t 1 fi ff venv ) ! t 2 ) fi ff venv In the above type, k tenv abstracts the kind of the type
Reference: [15] <author> J. C. Mitchell and G. D. Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Perhaps more importantly, the ability not to pass types allows abstraction and parametricity to be recovered. In most type systems abstraction may be achieved by hiding the identity of types either through parametric poly-morphism [21] or through existential types <ref> [15] </ref>. However, when all types are passed and may be analyzed (as in ML i ), the identity of types cannot be hidden and consequently abstraction is impossible.
Reference: [16] <author> G. Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, School of Computer Science, Pittsburgh, Pennsylvania, </institution> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Type-directed compilers use type information to enable optimizations and transformations that are impossible (or prohibitively difficult) without such information <ref> [12, 10, 16, 1, 22, 24, etc.] </ref>. However, type-directed compilers for some languages such as Modula-3 and ML face the difficulty that some type information cannot be known at compile time. <p> In order to use type information in contexts where it cannot be provided statically, a number of advanced implementation techniques process type information at run time <ref> [10, 16, 27, 18, 24] </ref>. Such type information is used in two ways: behind the scenes, typically by tag-free garbage collectors [27], and explicitly in program code, for a variety of purposes such as efficient data representation and marshalling [16, 10]. <p> Such type information is used in two ways: behind the scenes, typically by tag-free garbage collectors [27], and explicitly in program code, for a variety of purposes such as efficient data representation and marshalling <ref> [16, 10] </ref>. In this paper we focus on the latter area of applications. <p> Based upon the equivalence rules in Figure 7 we can define a notion of constructor reduction to a normal form in an obvious manner. This reduction relation can be proved to be strongly normalizing and confluent (in a manner similar to Morrisett <ref> [16] </ref>) from which it follows that constructor equivalence is decidable. Therefore we can state the following theo rem: Theorem 3.1 (Decidability) It is decidable whether or not ` e : t is derivable in R .
Reference: [17] <author> G. Morrisett, M. Felleisen, and R. Harper. </author> <title> Abstract models of memory management. </title> <booktitle> In Conference on Functional Programming Languages and Computer Architecture, </booktitle> <year> 1995. </year>
Reference-contexts: For example, in semantics that make memory allocation explicit <ref> [17, 18] </ref> a central device is a formal heap in which data is stored; in a type-erasure framework one such heap 1 "Intensional" since types are analyzed by the structure of their names, rather than by what terms they contain.
Reference: [18] <author> G. Morrisett and R. Harper. </author> <title> Semantics of memory management for polymorphic languages. </title> <editor> In A. D. Gordon and A. M. Pitts, editors, </editor> <title> Higher Order Operational Techniques in Semantics. </title> <publisher> Cambridge University Press, </publisher> <year> 1997. </year>
Reference-contexts: In order to use type information in contexts where it cannot be provided statically, a number of advanced implementation techniques process type information at run time <ref> [10, 16, 27, 18, 24] </ref>. Such type information is used in two ways: behind the scenes, typically by tag-free garbage collectors [27], and explicitly in program code, for a variety of purposes such as efficient data representation and marshalling [16, 10]. <p> For example, in semantics that make memory allocation explicit <ref> [17, 18] </ref> a central device is a formal heap in which data is stored; in a type-erasure framework one such heap 1 "Intensional" since types are analyzed by the structure of their names, rather than by what terms they contain.
Reference: [19] <author> G. Morrisett, D. Tarditi, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> The TIL/ML compiler: Performance and safety through types. </title> <booktitle> In Workshop on Compiler Support for Systems Software, </booktitle> <address> Tucson, </address> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: The ML i language and its derivatives were then used extensively in the high-performance ML compilers TIL/ML <ref> [26, 19] </ref> and FLINT [25]. The primary novelty of ML i is the presence of "typecase" oper ators at the level of terms and types, that allow computations and type expressions to depend upon the values of other type expressions at run time. <p> Unfortunately, the shortcomings of type-passing semantics made it incompatible with some of those low-level typing mechanisms. This unfortunate incompatibility has made it infeasible to use the mechanisms of Morrisett et al. in type-analyzing compilers such as TIL/ML <ref> [26, 19] </ref> and FLINT [25], and has made it infeasible to use intensional type analysis in the end to-end typed compiler TALC [20]. This framework in this paper makes it possible to unify these two lines of work for the first time.
Reference: [20] <author> G. Morrisett, D. Walker, K. Crary, and N. Glew. </author> <title> From System F to typed assembly language. </title> <booktitle> In Twenty-Fifth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> 8 pages 85-97, </pages> <address> San Diego, </address> <month> Jan. </month> <year> 1998. </year> <note> Extended ver- sion published as Cornell University technical re port TR97-1651. </note>
Reference-contexts: This can pose a serious problem for typed intermediate languages, because these devices can disrupt the essential symmetries on which elegant type systems depend. For example, a type-passing semantics for Typed Assembly Language <ref> [20] </ref> requires additional instructions for allocating and initializing types, which in turn requires the typing machinery for allocation and initialization to be lifted an additional level into the kind struc ture. * As a particularly important example of the preceding issue, type passing severely complicates typed closure conversion (compare the type-passing <p> machinery for allocation and initialization to be lifted an additional level into the kind struc ture. * As a particularly important example of the preceding issue, type passing severely complicates typed closure conversion (compare the type-passing system of Minamide et al. [14] to the type-erasure system of Morrisett et al. <ref> [20] </ref>). In a type-erasure framework, the partial application of a polymorphic function to a type may still be considered a value (since the application has no run-time significance), which means that closed code may simply be instantiated with its type environment when a closure is created. <p> Application is rewritten so that the code of a closure is first applied to its environment and then to its arguments. In the monomorphic case no discrepancy arises between type-passing [14] and type-erasure <ref> [20] </ref> closure conversion. An existential type is used to hold the type of the closure's environment abstract, so a closure for a t 1 ! t 2 function is given the type 9ff:((t 1 fiff) ! t 2 )fiff. <p> This new framework makes it feasible to use intensional type analysis in settings where the shortcomings previously made it impractical. For example, Morrisett et al. <ref> [20] </ref> developed typing mechanisms for low-level intermediate and target languages that allow type information to be used all the way to the end of compilation. It would be desirable, in a system based on those mechanisms, to be able to exploit fully that type information using intensional type analysis. <p> This unfortunate incompatibility has made it infeasible to use the mechanisms of Morrisett et al. in type-analyzing compilers such as TIL/ML [26, 19] and FLINT [25], and has made it infeasible to use intensional type analysis in the end to-end typed compiler TALC <ref> [20] </ref>. This framework in this paper makes it possible to unify these two lines of work for the first time. In pursuance of this aim, an important direction for future work is to extend the mechanisms of R into lower 7 level typed intermediate languages such as typed as-sembly language [20]. <p> <ref> [20] </ref>. This framework in this paper makes it possible to unify these two lines of work for the first time. In pursuance of this aim, an important direction for future work is to extend the mechanisms of R into lower 7 level typed intermediate languages such as typed as-sembly language [20]. Among the issues to be explored in such research is how to analyze the more complicated types used in typed assembly language, and how to perform type-directed dispatch without an atomic typecase construct.
Reference: [21] <author> J. C. Reynolds. </author> <title> Types, abstraction and paramet ric polymorphism. </title> <booktitle> In Information Processing '83, </booktitle> <pages> pages 513-523. </pages> <publisher> North-Holland, </publisher> <year> 1983. </year> <booktitle> Proceedings of the IFIP 9th World Computer Congress. </booktitle>
Reference-contexts: Perhaps more importantly, the ability not to pass types allows abstraction and parametricity to be recovered. In most type systems abstraction may be achieved by hiding the identity of types either through parametric poly-morphism <ref> [21] </ref> or through existential types [15]. However, when all types are passed and may be analyzed (as in ML i ), the identity of types cannot be hidden and consequently abstraction is impossible. <p> Another issue to explore is better mechanisms for analysis of quantified types (some initial ideas appear in Appendix B), and whether such mechanisms are merited in practice. Another important question is whether a parametricity theorem like that of Reynolds <ref> [21] </ref> can be shown for R . Polymorphism is clearly non-parametric in ML i , but the lowering of type analysis to explicit term-level representatives makes it plausible that some sort of parametric-ity could be shown for R .
Reference: [22] <author> E. Ruf. </author> <title> Partitioning dataflow analyses using types. </title> <booktitle> In Twenty-Fourth ACM SIGACT-SIGPLAN Sym posium on Principles of Programming Languages, </booktitle> <pages> pages 15-26, </pages> <address> Paris, </address> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: 1 Introduction Type-directed compilers use type information to enable optimizations and transformations that are impossible (or prohibitively difficult) without such information <ref> [12, 10, 16, 1, 22, 24, etc.] </ref>. However, type-directed compilers for some languages such as Modula-3 and ML face the difficulty that some type information cannot be known at compile time.
Reference: [23] <author> B. Saha and Z. Shao. </author> <title> Optimal type lifting. </title> <booktitle> In Second Workshop on Types in Compilation, </booktitle> <month> Mar. </month> <year> 1998. </year>
Reference-contexts: to significant cost and should in practice be lifted out to compile time whenever possible. (Unfortunately, in the presence of polymorphic recursion, which R supports, it cannot always be possible.) Mechanisms for lifting such lifting have been developed by Minamide (in the work discussed above) and by Saha and Shao <ref> [23] </ref>. Dubois at al. [5] also pass explicit type representations to polymorphic functions when compiling ad-hoc poly-morphism.
Reference: [24] <author> Z. Shao. </author> <title> Flexible representation analysis. </title> <booktitle> In 1997 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 85-98, </pages> <address> Amster dam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: 1 Introduction Type-directed compilers use type information to enable optimizations and transformations that are impossible (or prohibitively difficult) without such information <ref> [12, 10, 16, 1, 22, 24, etc.] </ref>. However, type-directed compilers for some languages such as Modula-3 and ML face the difficulty that some type information cannot be known at compile time. <p> In order to use type information in contexts where it cannot be provided statically, a number of advanced implementation techniques process type information at run time <ref> [10, 16, 27, 18, 24] </ref>. Such type information is used in two ways: behind the scenes, typically by tag-free garbage collectors [27], and explicitly in program code, for a variety of purposes such as efficient data representation and marshalling [16, 10].
Reference: [25] <author> Z. Shao. </author> <title> An overview of the FLINT/ML compiler. </title> <booktitle> In 1997 Workshop on Types in Compilation, </booktitle> <address> Am sterdam, </address> <month> June </month> <year> 1997. </year> <journal> ACM SIGPLAN. </journal> <note> Published as Boston College Computer Science Department Technical Report BCCS-97-03. </note>
Reference-contexts: The ML i language and its derivatives were then used extensively in the high-performance ML compilers TIL/ML [26, 19] and FLINT <ref> [25] </ref>. The primary novelty of ML i is the presence of "typecase" oper ators at the level of terms and types, that allow computations and type expressions to depend upon the values of other type expressions at run time. <p> Unfortunately, the shortcomings of type-passing semantics made it incompatible with some of those low-level typing mechanisms. This unfortunate incompatibility has made it infeasible to use the mechanisms of Morrisett et al. in type-analyzing compilers such as TIL/ML [26, 19] and FLINT <ref> [25] </ref>, and has made it infeasible to use intensional type analysis in the end to-end typed compiler TALC [20]. This framework in this paper makes it possible to unify these two lines of work for the first time.
Reference: [26] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed opti mizing compiler for ML. </title> <booktitle> In 1996 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 181-192, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: The ML i language and its derivatives were then used extensively in the high-performance ML compilers TIL/ML <ref> [26, 19] </ref> and FLINT [25]. The primary novelty of ML i is the presence of "typecase" oper ators at the level of terms and types, that allow computations and type expressions to depend upon the values of other type expressions at run time. <p> Unfortunately, the shortcomings of type-passing semantics made it incompatible with some of those low-level typing mechanisms. This unfortunate incompatibility has made it infeasible to use the mechanisms of Morrisett et al. in type-analyzing compilers such as TIL/ML <ref> [26, 19] </ref> and FLINT [25], and has made it infeasible to use intensional type analysis in the end to-end typed compiler TALC [20]. This framework in this paper makes it possible to unify these two lines of work for the first time.
Reference: [27] <author> A. Tolmach. </author> <title> Tag-free garbage collection using ex plicit type parameters. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <address> Or lando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: In order to use type information in contexts where it cannot be provided statically, a number of advanced implementation techniques process type information at run time <ref> [10, 16, 27, 18, 24] </ref>. Such type information is used in two ways: behind the scenes, typically by tag-free garbage collectors [27], and explicitly in program code, for a variety of purposes such as efficient data representation and marshalling [16, 10]. <p> In order to use type information in contexts where it cannot be provided statically, a number of advanced implementation techniques process type information at run time [10, 16, 27, 18, 24]. Such type information is used in two ways: behind the scenes, typically by tag-free garbage collectors <ref> [27] </ref>, and explicitly in program code, for a variety of purposes such as efficient data representation and marshalling [16, 10]. In this paper we focus on the latter area of applications.
References-found: 27

