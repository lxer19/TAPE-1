URL: ftp://ftp.cs.brown.edu/pub/techreports/92/cs92-45.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-92-45.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G.M. </author> <title> Adel'son-Vel'skii and E.M. Landis, "An Information Organization Algorithm," </title> <journal> Doklady Akad. Nauk SSSR 146 (1962), </journal> <pages> 263-266. </pages>
Reference-contexts: Dynamic trees were introduced as internal data structures in sequential maximum flow algorithms [24,55,100]. Since then, a large number of dynamic algorithms [27,28, 48,49,50,51,69,83,122] have used dynamic trees as part of their data structures. Initial data structures [24,55] based on balanced binary trees (e.g. AVL-trees <ref> [1] </ref> or Red-Black trees [57]), take O (log 2 n) time per operation.
Reference: [2] <author> B. Alpern, R. Hoover, B. Rosen, P. Sweeney, and F.K. Zadeck, </author> <title> "Incremental Evaluation of Computational Circuits," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1990), </booktitle> <pages> 32-42. </pages>
Reference-contexts: In general, a = O (n) for an attribute grammar of size n. Incremental evaluation of general circuits is studied in <ref> [2] </ref>. The precedence graph for an attribute grammar T is a digraph consisting of a vertex for each attribute x i () and a directed edge from x i () to x j (-) if the value x i () is used in the calculation of x j (-).
Reference: [3] <author> S. Arnborg, </author> <title> "Reduced State Enumeration-Another Algorithm for Reliability Evaluation," </title> <journal> IEE Transactions on Reliability R-27 (1978), </journal> <pages> 101-105. </pages>
Reference-contexts: The concept of bounded tree-width graph was introduced by Robertson and Seymour [94] as a generalization of series-parallel graphs. Graphs of tree-width two have been extensively studied owing to their role in fault-tolerant communication networks [43,44,78,119], concurrent broadcasting in common medium networks [23], reliability evaluation in complex systems <ref> [3] </ref>, and evaluation of queries in relational data base systems [4]. Note that tree-width two graphs include the important subclasses of trees and series-parallel graphs. <p> Graphs of tree-width one are forests. Graphs of tree-width two have been extensively studied due to their role in fault-tolerant communication networks [43,44,78,119], concurrent broadcasting in common medium networks [23], reliability evaluation in complex systems <ref> [3] </ref>, and evaluation of queries in relational data base systems [4]. Note that tree-width two graphs include the important subclasses of trees and series-parallel graphs. The notion of the tree width of a graph was introduced by Robertson and Sey-mour [94].
Reference: [4] <author> S. Arnborg, </author> <title> "Efficient Algorithms for Combinatorial Problems on Graphs with Bounded Decomposbility, A Survey ," BIT 25 (1985), </title> <type> 2-33. </type>
Reference-contexts: Graphs of tree-width two have been extensively studied owing to their role in fault-tolerant communication networks [43,44,78,119], concurrent broadcasting in common medium networks [23], reliability evaluation in complex systems [3], and evaluation of queries in relational data base systems <ref> [4] </ref>. Note that tree-width two graphs include the important subclasses of trees and series-parallel graphs. Bounded tree-width graphs also have theoretical interest, since a large number of generally NP-complete problems have polynomial time solutions when restricted to graphs of a bounded tree-width [94]. <p> Graphs of tree-width one are forests. Graphs of tree-width two have been extensively studied due to their role in fault-tolerant communication networks [43,44,78,119], concurrent broadcasting in common medium networks [23], reliability evaluation in complex systems [3], and evaluation of queries in relational data base systems <ref> [4] </ref>. Note that tree-width two graphs include the important subclasses of trees and series-parallel graphs. The notion of the tree width of a graph was introduced by Robertson and Sey-mour [94].
Reference: [5] <author> Stefan Arnborg, Derek. G. Corneil, and Andrej Proskurowski, </author> <title> "Complexity of Finding Embeddings in a k-Tree," </title> <journal> SIAM. J. Alg. Disc. </journal> <volume> Meth 8 (1987), </volume> <pages> 277-284. </pages>
Reference-contexts: A graph G is a partial k-tree if it is the subgraph of a k-tree. Arnborg and Proskurowski <ref> [5] </ref> proved that the class of partial k-trees is the same as T W (k). Therefore, we use the terms interchangeably to denote the same class of graphs. 47 Also, they proved that it is NP-Complete to determine the tree-width of a graph.
Reference: [6] <author> G. Ausiello, G.F. Italiano, A. Marchetti-Spaccamela, and U. Nanni, </author> <title> "Incremental Algorithms for Minimal Length Paths," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1990), </booktitle> <pages> 12-21. </pages>
Reference: [7] <author> S.W. Bent, D.D. Sleator, and R.E. Tarjan, </author> <title> "Biased Search Trees," </title> <journal> SIAM J. Computing 14 (1985), </journal> <pages> 545-568. </pages>
Reference-contexts: Initial data structures [24,55] based on balanced binary trees (e.g. AVL-trees [1] or Red-Black trees [57]), take O (log 2 n) time per operation. Sleator and Tarjan improve this to O (log n) time per operation by basing their data structure on the weight-biased binary trees <ref> [7] </ref>. 2.2 Transitive Closure Given a directed graph G and two vertices u and v of G, a transitive closure query determines if there is a directed path in G from u to v. This is also referred to as a reachability query. <p> An edge (; -) of T is solid if size () &gt; size ()=2 . If the partition satisfies the size invariant, then every path of T has O (log n) dashed edges. In order to achieve the logarithmic time per dynamic operation, we use biased search trees <ref> [7] </ref> to represent the path-trees. For a node of a solid path we define the node-attribute weight () as one plus the sum of the sizes of the subtrees connected to by dashed edges.
Reference: [8] <author> A.M. Berman, M.C. Paull, and B.G. Ryder, </author> <title> "Proving Relative Lower Bounds for Incremental Algorithms," </title> <note> Acta Informatica (to appear). </note>
Reference-contexts: For many problems, efficient semi-dynamic algorithms are known, even though no efficient fully-dynamic counterpart has been found. A general lower bound technique for incremental algorithms, with applications to dynamic graph algorithms, is discussed in <ref> [8] </ref>. 2.1 Dynamic Tree Algorithms A fundamental data structure for the dynamization of graph algorithms is the dynamic tree. Suppose we are given a collection of trees such that each node has associated numeric values such as a weight.
Reference: [9] <author> P. Bertolazzi, R.F. Cohen, G. Di Battista, R. Tamassia, and I.G. Tollis, </author> <title> "How to Draw a Series-Parallel Digraph," </title> <booktitle> Proc. </booktitle> <month> SWAT </month> <year> (1992). </year>
Reference-contexts: Quadratic-Area: The drawing has O (n 2 ) area. It is important to note that in order to get polynomial area the embedding cannot be completely preserved. Namely, it is shown in <ref> [9] </ref> that there exists a class of embedded series-parallel digraphs for which any upward straight-line drawing that preserves the embedding requires exponential area under any resolution rule. -drawings of series-parallel digraphs are introduced in [9] and satisfy the above static drawing predicate. <p> Namely, it is shown in <ref> [9] </ref> that there exists a class of embedded series-parallel digraphs for which any upward straight-line drawing that preserves the embedding requires exponential area under any resolution rule. -drawings of series-parallel digraphs are introduced in [9] and satisfy the above static drawing predicate. In -drawings the embedding is modified so that all the transitive edges are embedded on one side, say, the right side. We call such embedding right-pushed. <p> In a parallel composition, the subdrawings are placed one to the right of the other and are deformed in order to identify the poles, guaranteeing that their edges do not cross. The algorithm is outlined below. More details can be found in <ref> [9] </ref>. * Modify the embedding of G into a right-pushed embedding. * If G consists of a single edge, it is drawn as a vertical segment of height 2, with bounding triangle having width 1 (see Fig. 5.2.a). * If G is the series composition of G 0 and G 00 <p> Notice that in both series and parallel compositions the height of () is equal to the sum of the heights of ( 0 ) and ( 00 ). Hence, the height of () is exactly 2m, and the area of the drawing is m 2 . Lemma 5.3 <ref> [9] </ref> Given an n-node series-parallel digraph G, the -drawing of G satisfies the static drawing predicate P S , and can be constructed in O (n) time. 5.3.2 Dynamic Environment We create an addition node type, the P Q -node, to handle right-pushed embeddings.
Reference: [10] <author> P. Bertolazzi and G. Di Battista, </author> <title> "On Upward Drawing Testing of Triconnected Digraphs," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1991). </booktitle>
Reference: [11] <author> G. M. Beshers and R. H. Campbell, </author> <title> "Maintained and Constructor Attributes," </title> <booktitle> Proc. ACM Symp. on Language Issues in Programming Environments, ACM SIG-PLAN Notices (1985), </booktitle> <pages> 34-42. </pages>
Reference: [12] <author> Hans. L. Bodlaender, </author> <title> "NC-Algorithms for Graphs with small Treewidth," </title> <institution> Dept. of Computer Science, University of Utrechet, Utrechet, </institution> <type> Technical Report RUUU-CS-88-4, </type> <year> 1988. </year>
Reference-contexts: Robertson and Seymour [93] showed the existence of a polynomial time algorithm to determine if a graph has tree width k for some constant k; later Bodlaender <ref> [12] </ref> and Matousk and Thomas [76] gave NC algorithms to construct a tree decomposition of any partial k-tree (for some constant k), whose width is within a constant factor of k. Recently Lagergren [71] has given a linear processor NC algorithm to construct such a tree decomposition.
Reference: [13] <author> K. Booth and G. Lueker, </author> <title> "Testing for the Consecutive Ones Property, Interval Graphs, and Graph Planarity Using PQ-Tree Algorithms," </title> <editor> J. </editor> <booktitle> of Computer and System Sciences 13 (1976), </booktitle> <pages> 335-379. </pages>
Reference: [14] <author> A.L. Buchsbaum, P.C. Kanellakis, and J.S. Vitter, </author> <title> "A Data Structure for Arc Insertion and Regular Path Finding," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1990), </booktitle> <pages> 22-31. </pages>
Reference-contexts: A data structure for arbitrary digraphs that support edge insertions in amortized O (n) time, queries in O (1) time, and use O (n 2 ) space are given in [64]. An extension of this result to finding regular paths for a regular language is given in <ref> [14] </ref>. A semi-dynamic algorithm for acyclic digraphs that support edge deletions in in amortized O (n) time, queries in O (1) time, and use O (n 2 ) space is presented in [65]. La Poutre and van Leeuwen [85] present two semi-dynamic data structures supporting transitive closure on general digraphs.
Reference: [15] <author> Y.-J. Chiang, F.P. Preparata, and R. Tamassia, </author> <title> "A Unified Approach to Dynamic Point Location, Ray Shooting and Shortest Paths in Planar Maps," </title> <institution> Dept. Computer Science, Brown Univ., </institution> <type> Technical Report CS-92-07, </type> <year> 1992. </year>
Reference-contexts: Previous approaches try to keep the binary space partition balanced [86,99]. With a selection function one can use unbalanced partitions. A specialized version of this technique was introduced in <ref> [15] </ref>.
Reference: [16] <author> Y.-J. Chiang and R. Tamassia, </author> <title> "Dynamic Algorithms in Computational Geometry," </title> <institution> Dept. of Computer Science, Brown Univ., </institution> <type> Technical Report CS-91-24, </type> <year> 1991. </year>
Reference-contexts: a fully dynamic planarity testing technique with O (n 2=3 ) query and update time has been discovered [52]. 8 Chapter 3 Attribute Systems 3.1 Introduction In the past years considerable progress has been made in the development of dynamic algorithms for geometric searching problems (see, e.g., the survey paper <ref> [16] </ref>). However, considerably fewer results exist on the dynamization of graph algorithms. A crucial development in the area of dynamic geometric searching has been the identification of general methods that apply to a large class of problems.
Reference: [17] <author> Y.-J. Chiang and R. Tamassia, </author> <title> "Dynamization of the Trapezoid Method for Planar Point Location," </title> <note> Int. J. of Computational Geometry Applications (to appear). </note>
Reference-contexts: If = 00 then p is in regions I or III. If = 0 then p is in regions II. If node = find (; S 6 ; p), then p is in region III. The trapezoid method for planar point location described in <ref> [17] </ref> is an example of an existing method that can be expressed as a selection function. 3.5.5 Slicing Floorplan Compaction Linear attribute grammars have immediate application to the problem of compacting slicing floorplans, a layout technique widely used in VLSI (see, e.g., [103]).
Reference: [18] <author> N. Chiba, T. Nishizeki, S. Abe, and T. Ozawa, </author> <title> "A Linear Algorithm for Embedding Planar Graphs Using PQ-Trees," </title> <editor> J. </editor> <booktitle> of Computer and System Sciences 30 (1985), </booktitle> <pages> 54-76. </pages>
Reference: [19] <author> F. Chin and D. Houk, </author> <title> "Algorithms for Updating Minimum Spanning Trees," </title> <editor> J. </editor> <booktitle> Computer Systems Sciences 16 (1978), </booktitle> <pages> 333-344. </pages>
Reference: [20] <author> R. F. Cohen, S. Sairam, R. Tamassia, and J. S. Vitter, </author> <title> "An Algorithmic Framework for Dynamic Property Systems in Bounded Tree Width Graphs," </title> <note> 1991, (submitted for publication). </note>
Reference-contexts: set * Bipartite Subgraph * Maximum Cut The following problems are shown to be in DLCC: * Minimum Maximal Matching * Partition into Triangles * Partition into Hamiltonian Subgraphs * Partition into Cliques * Monochromatic Triangle * Transitive Subgraph * Cubic Subgraph * Kernel * Chromatic Index 66 Lemma 4.7 <ref> [20] </ref> Suppose the tree decomposition of a collection of graphs G of some bounded tree-width can be maintained such that each update or query operation requires O (T (n)) dynamic operations of theorem 3.3. Consider a DECC problem 1 . <p> Now consider a DLCC problem 2 . If the degree of any vertex of any graph in G is bounded to some constant, then the solution to 2 can be maintained in O (T (n)log n) time over G. Lemma 4.8 <ref> [20] </ref> Suppose the SPQC-trees of a collection of tree-width two graphs G can be maintained such that each update or query operation requires O (T (n)) dynamic operations of theorem 3.3. Consider a DECC problem 1 .
Reference: [21] <author> R.F. Cohen, S. Sairam, R. Tamassia, and J.S. Vitter, </author> <title> "Dynamic Algorithms for Bounded Tree-Width Graphs," </title> <institution> Brown University, </institution> <type> Manuscript, </type> <year> 1992. </year>
Reference-contexts: Namely, we consider the classes of graph problems DECC and DLCC introduced in <ref> [21] </ref> which can be represented as tree attribute systems. <p> A framework for dynamic algorithms in bounded tree-width graphs is presented in <ref> [21] </ref>. They present two classes of problems on graphs, DECC and DLCC. The solution to problems in DECC can be represented as a tree attribute system for graphs of a bounded tree-width. <p> Recently, an on-line algorithm has been presented for the maintenance of tree width three graphs <ref> [21] </ref>. * Lower the complexity of returning a connectible-pair shortest path / minimum cut to O (k + log n) (or O (k + log 2 n)). * Lower the complexity of window queries in trees and series-parallel digraphs to O (k + log n). * Extend the techniques for planar
Reference: [22] <author> R.F. Cohen and R. Tamassia, </author> <title> "Dynamic Expression Trees and their Applications," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1991), </booktitle> <pages> 52-61. </pages>
Reference-contexts: LCA, PathFind, TreeFind, Parent, Expand, and Contract take each O (log n) time, where n is the total size of the trees involved in the operation. 3.3 Linear Expression Trees In this section, we consider the dynamic evaluation of linear expressions, which extends and generalizes the dynamic expression trees of <ref> [22] </ref>. <p> The inverse operation DeleteVertex (e; v; e 0 ; e 00 ) is implemented similarly with a constant number of MakeDigraph, DeleteDigraph, Link, Cut, and Expand operations. The restructuring of the SPQ-tree caused by InsertEdge and DeleteEdge is more complex. It is known <ref> [22] </ref> that if G is a series-parallel digraph with SPQ-tree T , and v 0 and v 00 be two vertices of G.
Reference: [23] <author> C. J. Colbourn and A. Proskurowski, </author> <title> "Concurrent Transmissions in Broadcast Networks," </title> <booktitle> Proc. ICALP, Springer-Verlag , Berlin-Heidelberg-New York, Lecture Notes in Computer Science 172 (1984), </booktitle> <pages> 128-136. </pages>
Reference-contexts: The concept of bounded tree-width graph was introduced by Robertson and Seymour [94] as a generalization of series-parallel graphs. Graphs of tree-width two have been extensively studied owing to their role in fault-tolerant communication networks [43,44,78,119], concurrent broadcasting in common medium networks <ref> [23] </ref>, reliability evaluation in complex systems [3], and evaluation of queries in relational data base systems [4]. Note that tree-width two graphs include the important subclasses of trees and series-parallel graphs. <p> Graphs of tree-width one are forests. Graphs of tree-width two have been extensively studied due to their role in fault-tolerant communication networks [43,44,78,119], concurrent broadcasting in common medium networks <ref> [23] </ref>, reliability evaluation in complex systems [3], and evaluation of queries in relational data base systems [4]. Note that tree-width two graphs include the important subclasses of trees and series-parallel graphs. The notion of the tree width of a graph was introduced by Robertson and Sey-mour [94].
Reference: [24] <author> C. Crane, </author> <title> "Linear Lists and Priority Queues as Balanced Binary Trees," </title> <institution> Computer Science Dept., Stanford Univ., </institution> <type> Technical Report STAN-CS-72-259 (Ph.D. Dissertation), </type> <year> 1972. </year>
Reference: [25] <author> G. Di Battista, W.-P. Liu, and I. </author> <title> Rival, "Bipartite Graphs, Upward Drawings, </title> <booktitle> and Planarity," Information Processing Letters 36 (1990), </booktitle> <pages> 317-322. </pages>
Reference: [26] <author> G. Di Battista and R. Tamassia, </author> <title> "Algorithms for Plane Representations of Acyclic Digraphs," </title> <booktitle> Theoretical Computer Science 61 (1988), </booktitle> <pages> 175-198. </pages>
Reference: [27] <author> G. Di Battista and R. Tamassia, </author> <title> "Incremental Planarity Testing," </title> <booktitle> Proc. 30th IEEE Symp. on Foundations of Computer Science (1989), </booktitle> <pages> 436-441. </pages>
Reference-contexts: When only considering planar graphs, the time bound is reduced to O (log 2 n) time per update. For fixed embeddings of planar graphs, this result is improved to O (log n) time per dynamic operation in [39]. The semi-dynamic data structure of <ref> [27] </ref> for embedding-independent, biconnected planar graphs uses O (n) space and supports insertions in O (log n) time (amortized for edge-insertions). 2.6 Planarity Testing In a static environment we can test planarity and compute a planar embedding in optimal O (n) time (see, e.g. [13,42,47,60,72]). <p> The dynamic maintenance of a planar embedding under a sequence of edge insertions can be done in time O (log n) per operation [107]. Di Battista and Tamassia <ref> [27] </ref> have investigated how to test if a new edge can be added to a planar graph G so that G remains planar, and how to add vertices and edges so that planarity is preserved. The semidynamic data structure of [27] for biconnected graphs uses O (n) space and supports queries <p> Di Battista and Tamassia <ref> [27] </ref> have investigated how to test if a new edge can be added to a planar graph G so that G remains planar, and how to add vertices and edges so that planarity is preserved. The semidynamic data structure of [27] for biconnected graphs uses O (n) space and supports queries and insertions in O (log n) time (amortized for edge-insertions). The extension to general graphs is reported in [28]. Westbrook [121] has improved this result to achieve O (ff (m; n)) amortized time per operation. <p> As shown in <ref> [27] </ref>, this repertory of operation is complete; i.e., any n-vertex bicon-nected planar graph can be assembled by means of O (n) operations of the repertory. <p> This can be done using the techniques of [107]. We can extend Theorem 5.5 to support the insertion of an edge between two vertices that are not on the same face of the current embedding, using the techniques of <ref> [27] </ref>. In this case the embedding has to be modified in order to preserve planarity, and the time complexity of operation InsertEdge is amortized. <p> Static algorithms that perform this test are known only for triconnected digraphs [10]and for single-source digraphs [62]. Semidynamic planarity testing can be done with O (log n) query and insertion time <ref> [27] </ref>. Recently, a fully dynamic planarity testing technique with O (n 2=3 ) query and update time has been discovered [52]. 119
Reference: [28] <author> G. Di Battista and R. Tamassia, </author> <title> "On-Line Graph Algorithms with SPQR-Trees," Automata, </title> <booktitle> Languages and Programming (Proc. 17th ICALP), Lecture Notes in Computer Science 442 (1990), </booktitle> <pages> 598-611. 121 </pages>
Reference-contexts: For 2-connectivity, Westbrook and Tarjan [120,122] present two algorithms. The first is a simple algorithm which takes O (q + n log n) time. The second is an optimal algorithm with amortized O (qff (q; n)) time per edge insertion. In the case of 3-connectivity, Di Battista and Tamassia <ref> [28] </ref> give an algorithm which requires a total of O (q + n log n) time in general. If we start with an initially biconnected graph, then the algorithm runs optimally in amortized O (ff (q; n)) time per dynamic operation. <p> The semidynamic data structure of [27] for biconnected graphs uses O (n) space and supports queries and insertions in O (log n) time (amortized for edge-insertions). The extension to general graphs is reported in <ref> [28] </ref>. Westbrook [121] has improved this result to achieve O (ff (m; n)) amortized time per operation. This time bound is deterministic for queries and expected for updates. The randomization is due to the use of on dynamic perfect hashing [31]. <p> Dynamic trees were first presented as an internal data structure in several (sequential) maximum flow algorithms. A number of data structures have been presented which maintain the recursive decomposition of graphs into subgraphs with constant size overlap. SPQR-trees <ref> [28] </ref> are used to maintain the tri-connected components of an initially biconnected graph. FWRT-trees [69] used to maintain the 4-connected components of an initially tri-connected graph. These last two data structures have a specialized PathFind operation to find the closest ancestor of a given type.
Reference: [29] <author> G. Di Battista, R. Tamassia, and I.G. Tollis, </author> <title> "Area Requirement and Symmetry Display in Drawing Graphs," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1989), </booktitle> <pages> 51-60. </pages>
Reference-contexts: Isomorphic: Isomorphic components have drawings that are congruent up to a trans lation. Symmetric: Symmetric components have drawings that are congruent up to a transla tion and a reflection. Quadratic-Area: The drawing has O (n 2 ) area. We dynamize the polyline drawing method of <ref> [29] </ref>, which has the important property of displaying symmetries and isomorphisms of subgraphs. Note that we do not consider straight-line drawings because they may require exponential area [29]. Dynamic Environment We consider a fully dynamic environment for the maintenance of upward drawings on a collection of embedded planar st-digraphs. <p> Quadratic-Area: The drawing has O (n 2 ) area. We dynamize the polyline drawing method of <ref> [29] </ref>, which has the important property of displaying symmetries and isomorphisms of subgraphs. Note that we do not consider straight-line drawings because they may require exponential area [29]. Dynamic Environment We consider a fully dynamic environment for the maintenance of upward drawings on a collection of embedded planar st-digraphs.
Reference: [30] <author> G. Di Battista, R. Tamassia, and I.G. Tollis, </author> <title> "Area Requirement and Symmetry Display of Planar Upward Drawings," </title> <booktitle> Discrete & Computational Geometry 7 (1992), </booktitle> <pages> 381-401. </pages>
Reference: [31] <author> M. Dietzfelbinger, A. Karlin, K. Mehlhorn, F. Meyer auf der Heide, H. Rohnert, and R.E. Tarjan, </author> <title> "Dynamic Perfect Hashing: Upper and Lower Bounds," </title> <booktitle> Proc. 29th IEEE Symp. on Foundations of Computer Science (1988), </booktitle> <pages> 524-531. </pages>
Reference-contexts: The extension to general graphs is reported in [28]. Westbrook [121] has improved this result to achieve O (ff (m; n)) amortized time per operation. This time bound is deterministic for queries and expected for updates. The randomization is due to the use of on dynamic perfect hashing <ref> [31] </ref>.
Reference: [32] <author> D. Dolev, F.T. Leighton, and H. Trickey, </author> <title> "Planar Embedding of Planar Graphs," </title> <booktitle> in Advances in Computing Research, </booktitle> <volume> vol. 2, </volume> <editor> F.P. Preparata, ed., </editor> <publisher> JAI Press Inc., </publisher> <address> Greenwich, CT, </address> <year> 1984, </year> <pages> 147-161. </pages>
Reference-contexts: Two typical resolution rules are integer coordinates for the vertices, or a minimum distance ffi between any two vertices. When a resolution rule is given, it is meaningful to consider the problem of finding drawings with minimum area. Planar drawings require (n 2 ) area in the worst-case <ref> [32] </ref>. Further results on the area of planar drawings appear in [9,30,46,98]. 5.1.2 Model Here we describe a framework for dynamic graph drawing algorithms.
Reference: [33] <author> P. Duchet, Y. Hamidoune, M. Las Vergnas, and H. Meyniel, </author> <title> "Representing a Planar Graph by Vertical Lines Joining Different Levels," </title> <booktitle> Discrete Mathematics 46 (1983), </booktitle> <pages> 319-321. </pages>
Reference: [34] <author> R.J. Duffin, </author> <title> "Topology of Series Parallel Networks," </title> <journal> J. Math. Anal. Appl. </journal> <volume> 10 (1965), </volume> <pages> 303-318. </pages>
Reference-contexts: The swap status of a node is the exclusive-or of all swaps done by ancestors of . 4.2.2 Biconnected Series-Parallel Graphs Biconnected series-parallel graphs are exactly the class of biconnected graphs that exclude the complete graph with 4 vertices, K 4 , as a minor <ref> [34] </ref>. Hence, biconnected tree-width two graphs are biconnected series-parallel graphs. Lemma 4.2 [34] Suppose G is a tree-width two graph and B is a biconnected component of G. Then B is a biconnected series-parallel graph. We call the biconnected components of G blocks. <p> the exclusive-or of all swaps done by ancestors of . 4.2.2 Biconnected Series-Parallel Graphs Biconnected series-parallel graphs are exactly the class of biconnected graphs that exclude the complete graph with 4 vertices, K 4 , as a minor <ref> [34] </ref>. Hence, biconnected tree-width two graphs are biconnected series-parallel graphs. Lemma 4.2 [34] Suppose G is a tree-width two graph and B is a biconnected component of G. Then B is a biconnected series-parallel graph. We call the biconnected components of G blocks. If T is a SPQ-tree representing a biconnected series-parallel graph, then the root of T is a P-node.
Reference: [35] <author> P. Eades and X. Lin, </author> <title> "How to Draw Directed Graphs," </title> <booktitle> Proc. IEEE Workshop on Visual Languages (VL'89) (1989), </booktitle> <pages> 13-17. </pages>
Reference: [36] <author> P. Eades and R. Tamassia, </author> <title> "Algorithms for Automatic Graph Drawing: An Annotated Bibliography," </title> <institution> Dept. of Computer Science, Brown Univ., </institution> <type> Technical Report CS-89-09, </type> <year> 1989. </year>
Reference-contexts: Applications can be found in a variety of areas including circuit layout, network management, software engineering, and graphics. For a survey on graph drawing, see <ref> [36] </ref>. While this area has recently received increasing attention (see, e.g., [10,30,45,46,62,75,98]), the study of drawing graphs in a dynamic setting has been an open problem.
Reference: [37] <author> H. Edelsbrunner, L.J. Guibas, and J. Stolfi, </author> <title> "Optimal Point Location in a Monotone Subdivision," </title> <journal> SIAM J. Computing 15 (1986), </journal> <pages> 317-340. </pages>
Reference: [38] <author> D. Eppstein, G.F. Italiano, R. Tamassia, R.E. Tarjan, J. Westbrook, and M. Yung, </author> <title> "Maintenance of a Minimum Spanning Forest in a Dynamic Planar Graph," </title> <booktitle> Proc. First ACM-SIAM Symp. on Discrete Algorithms (1990), </booktitle> <pages> 1-11. </pages>
Reference-contexts: SPQR-trees [28] are used to maintain the tri-connected components of an initially biconnected graph. FWRT-trees [69] used to maintain the 4-connected components of an initially tri-connected graph. These last two data structures have a specialized PathFind operation to find the closest ancestor of a given type. Edge-ordered trees <ref> [38] </ref> are ordered, unbounded, rooted trees supporting operations Link, Cut , Expand , Contract, Cycle and Evert . Each node stores a locally updatable cost associated with the edge from to its parent. A specialized PathFind operator is included to find the minimum cost edge on a path. <p> There is a dual-vertex f in G fl for every face in F . Dual-vertices f 1 and f 2 are connected by dual-edge e fl if edge e is adjacent to both faces f 1 and f 2 . We use the following lemmas from <ref> [38] </ref>: Lemma 4.13 [38] Suppose U is a spanning tree of planar graph G. Then the set of dual-edges U fl defined by fe fl je not in Sg form a spanning tree of G fl . Lemma 4.14 [38] U is a minimum spanning tree of planar graph G if <p> There is a dual-vertex f in G fl for every face in F . Dual-vertices f 1 and f 2 are connected by dual-edge e fl if edge e is adjacent to both faces f 1 and f 2 . We use the following lemmas from <ref> [38] </ref>: Lemma 4.13 [38] Suppose U is a spanning tree of planar graph G. Then the set of dual-edges U fl defined by fe fl je not in Sg form a spanning tree of G fl . Lemma 4.14 [38] U is a minimum spanning tree of planar graph G if and only if <p> We use the following lemmas from <ref> [38] </ref>: Lemma 4.13 [38] Suppose U is a spanning tree of planar graph G. Then the set of dual-edges U fl defined by fe fl je not in Sg form a spanning tree of G fl . Lemma 4.14 [38] U is a minimum spanning tree of planar graph G if and only if U fl is a maximum spanning tree of dual-graph G fl . Consider the graph ^ G formed by the following process.
Reference: [39] <author> D. Eppstein, G.F. Italiano, R. Tamassia, R.E. Tarjan, J. Westbrook, and M. Yung, </author> <title> "Maintenance of a Minimum Spanning Forest in a Dynamic Plane Graph," </title> <editor> J. </editor> <booktitle> of Algorithms 13 (1992), </booktitle> <pages> 33-54. </pages>
Reference-contexts: When only considering planar graphs, the time bound is reduced to O (log 2 n) time per update. For fixed embeddings of planar graphs, this result is improved to O (log n) time per dynamic operation in <ref> [39] </ref>. <p> A minimum spanning tree is a spanning tree of minimum weight. <ref> [39] </ref> show a fully dynamic algorithm to maintain a minimum (or maximum) spanning tree for embedded planar graphs. Edge insertions are supported only across faces of a given embedding.
Reference: [40] <author> S. Even and H. Gazit, </author> <title> "Updating Distances in Dynamic Graphs," </title> <booktitle> Methods of Operations Research 49 (1985), </booktitle> <pages> 371-387. </pages>
Reference: [41] <author> S. Even and Y. Shiloach, </author> <title> "An On-Line Edge Deletion Problem," </title> <editor> J. </editor> <booktitle> ACM 28 (1981), </booktitle> <pages> 1-4. </pages>
Reference-contexts: Therefore, we have amortized O (ff (m; n)) time per operation. The fully dynamic data structure of [48] takes O ( p m) time per operation. This is the best result handling edge deletions. Other semi-dynamic techniques supporting only edge deletions are shown in <ref> [41] </ref>, where a data structure is presented supporting constant time queries and O (q + mn) time to perform q edge deletions; and in [89] where q edge deletions are performed in O (mg + m log m) time for a graph of genus g.
Reference: [42] <author> S. Even and R.E. Tarjan, </author> <title> "Computing an st-Numbering," </title> <booktitle> Theoretical Computer Science 2 (1976), </booktitle> <pages> 339-344. </pages>
Reference: [43] <author> A. M. Farley, </author> <title> "Networks Immune to Isolated Failures," </title> <booktitle> Networks 11 (1981), </booktitle> <pages> 255-268. </pages>
Reference: [44] <author> A. M. Farley and A. Proskurowski, </author> <title> "Networks Immune to Isolated Line Failures," </title> <booktitle> Networks 12 (1982), </booktitle> <pages> 393-403. 122 </pages>
Reference: [45] <author> M. Formann, T. Hagerup, J. Haralambides, M. Kaufmann, F.T. Leighton, A. Simvonis, E. Welzl, and G. Woeginger, </author> <title> "Drawing Graphs in the Plane with High Resolution," </title> <booktitle> Proc. IEEE Symp. on Foundations of Computer Science (1990), </booktitle> <pages> 86-95. </pages>
Reference: [46] <author> H. de Fraysseix, J. Pach, and R. Pollack, </author> <title> "How to Draw a Planar Graph on a Grid," </title> <booktitle> Combinatorica 10 (1990), </booktitle> <pages> 41-51. </pages>
Reference: [47] <author> H. de Fraysseix and P. Rosenstiehl, </author> <title> "A Depth-First-Search Characterization of Planarity," </title> <booktitle> Annals of Discrete Mathematics 13 (1982), </booktitle> <pages> 75-80. </pages>
Reference: [48] <author> G.N. Frederickson, </author> <title> "Data Structures for On-Line Updating of Minimum Spanning Trees, with Applications," </title> <journal> SIAM J. Computing 14 (1985), </journal> <pages> 781-798. </pages>
Reference-contexts: Therefore, we have amortized O (ff (m; n)) time per operation. The fully dynamic data structure of <ref> [48] </ref> takes O ( p m) time per operation. This is the best result handling edge deletions. <p> Early data structures for this problem [19,102] have O (n) space, O (n) time for edge insertions, O (n 2 ) time for edge deletions and the changing of edge weights, and O (1) time queries. The best result for general graphs is <ref> [48] </ref>, which presents a fully-dynamic data structure with O ( p m) time per update and O (m) space. When only considering planar graphs, the time bound is reduced to O (log 2 n) time per update. <p> Next consider the case where edge e fl is in S fl and ffi &lt; 0. It is well known (e.g. <ref> [48] </ref>) that for edge e to move to minimum spanning tree S, the weight of e must be less than the weight of the maximum weight edge e 0 on the cycle induced by adding e to S.
Reference: [49] <author> G.N. Frederickson, </author> <title> "Ambivalent Data Structures for Dynamic 2-Edge-Connectivity and k Smallest Spanning Trees," </title> <booktitle> Proc. 32th IEEE Symp. on Foundations of Computer Science (1991). </booktitle>
Reference-contexts: A fully dynamic data structure for 2-edge connectivity is presented in [50,53]. In general, dynamic operations take each O (m 2=3 ) time. For planar graphs this time bound is reduced to O ( p n log log n). Recently, Frederick-son <ref> [49] </ref> presented a fully dynamic data structure such that queries take O (log n) time, and edge insertions and deletions are performed in O ( p m) time.
Reference: [50] <author> Z. </author> <title> Galil and G.F. Italiano, "Fully Dynamic Algorithms for Edge-Connectivity Problems," </title> <booktitle> Proc. 23th ACM Symp. on Theory of Computing (1991), </booktitle> <pages> 317-327. </pages>
Reference: [51] <author> Z. </author> <title> Galil and G.F. Italiano, "Maintaining Biconnected Components of Dynamic Planar Graphs," Automata, </title> <booktitle> Languages and Programming (Proc. 18th ICALP), Lecture Notes in Computer Science (1991). </booktitle>
Reference: [52] <author> Z. </author> <title> Galil and G.F. Italiano, "Fully Dynamic Planarity Testing ," Proc. </title> <note> 24th ACM Symp. on Theory of Computing (to appear) (1992). </note>
Reference-contexts: This time bound is deterministic for queries and expected for updates. The randomization is due to the use of on dynamic perfect hashing [31]. Recently, a fully dynamic planarity testing technique with O (n 2=3 ) query and update time has been discovered <ref> [52] </ref>. 8 Chapter 3 Attribute Systems 3.1 Introduction In the past years considerable progress has been made in the development of dynamic algorithms for geometric searching problems (see, e.g., the survey paper [16]). However, considerably fewer results exist on the dynamization of graph algorithms. <p> Semidynamic planarity testing can be done with O (log n) query and insertion time [27]. Recently, a fully dynamic planarity testing technique with O (n 2=3 ) query and update time has been discovered <ref> [52] </ref>. 119
Reference: [53] <author> Z. </author> <title> Galil and G.F. Italiano, "Fully Dynamic Algorithms for 2-Edge Connectivity," </title> <note> SIAM J. on Computing (to appear). </note>
Reference: [54] <author> Z. </author> <title> Galil and G.F. Italiano, "Maintaining the 3-Edge Connected Components of a Graph On-Line.," </title> <note> SIAM J. on Computing (to appear). </note>
Reference: [55] <author> Z. Galil and A. Naamad, </author> <title> "An O(EV log 2 V ) algorithm for the maximal flow problem," </title> <editor> J. </editor> <booktitle> Computer and System Sciences 21 (1980), </booktitle> <pages> 203-217. </pages>
Reference: [56] <author> M.T. Goodrich and R. Tamassia, </author> <title> "Dynamic Trees and Dynamic Point Location," </title> <booktitle> Proc. 23th ACM Symp. on Theory of Computing (1991), </booktitle> <pages> 523-533. </pages>
Reference: [57] <author> L.J. Guibas and R. Sedgewick, </author> <title> "A Dichromatic Framework for Balanced Trees," </title> <booktitle> Proc. 19th IEEE Symp. on Foundations of Computer Science (1978), </booktitle> <pages> 8-21. </pages>
Reference-contexts: Dynamic trees were introduced as internal data structures in sequential maximum flow algorithms [24,55,100]. Since then, a large number of dynamic algorithms [27,28, 48,49,50,51,69,83,122] have used dynamic trees as part of their data structures. Initial data structures [24,55] based on balanced binary trees (e.g. AVL-trees [1] or Red-Black trees <ref> [57] </ref>), take O (log 2 n) time per operation.
Reference: [58] <author> L.J. Guibas and F.F. Yao, </author> <title> "On Translating a Set of Rectangles," </title> <booktitle> in Advances in Computing Research, </booktitle> <volume> vol. 1, </volume> <editor> F.P. Preparata, ed., </editor> <publisher> JAI Press Inc., </publisher> <address> Greenwich, CT, </address> <year> 1983, </year> <pages> 61-77. </pages>
Reference-contexts: We conclude that our dynamic data structure uses O (n) space and supports each operation in O (log n) time. 5.4.2 Visibility Drawings The concept of visibility plays a fundamental role in a variety of geometric problems and applications, such as art gallery problems [80], VLSI layout [61,97,123], motion planning <ref> [58] </ref>, and graph drawing [26,110].
Reference: [59] <author> X. </author> <title> He, "Efficient Parallel Algorithms for Series Parallel Graphs," </title> <editor> J. </editor> <booktitle> Algorithms 12 (1991), </booktitle> <pages> 409-430. </pages>
Reference-contexts: They thus demonstrated that a large number of problems which are NP-Complete for general graphs can be solved very efficiently for graphs of constant tree width, both sequentially and in parallel. No equivalent dynamic result has been shown. (Efficient parallel algorithms for problems on series-parallel graphs are given in <ref> [59] </ref>.) Using tree attribute systems, we find the following results: * We show that a tree decomposition for a tree-width two graph with m edges can be maintained in a fully dynamic environment so that an update operation takes worst-case time O (log 2 m). * We provide a framework for
Reference: [60] <author> J. Hopcroft and R.E. Tarjan, </author> <title> "Efficient Planarity Testing," </title> <editor> J. </editor> <booktitle> ACM 21 (1974), </booktitle> <pages> 549-568. </pages>
Reference: [61] <author> M.Y. Hsueh and D.O. Pederson, </author> <title> "Computer-Aided Layout of LSI Circuit Building-Blocks," </title> <booktitle> Proc. IEEE Int. Symp. on Circuits and Systems (1979), </booktitle> <pages> 474-477. 123 </pages>
Reference: [62] <author> M.D. Hutton and A. Lubiw, </author> <title> "Upward Planar Drawing of Single Source Acyclic Digraphs," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1991), </booktitle> <pages> 203-211. </pages>
Reference-contexts: The static algorithm of [106] is based on network flow techniques for which no dynamic methods are known. * Devise dynamic algorithms to test whether a digraph admits an upward planar drawing. Static algorithms that perform this test are known only for triconnected digraphs [10]and for single-source digraphs <ref> [62] </ref>. Semidynamic planarity testing can be done with O (log n) query and insertion time [27]. Recently, a fully dynamic planarity testing technique with O (n 2=3 ) query and update time has been discovered [52]. 119
Reference: [63] <author> T. Ibaraki and N. Katoh, </author> <title> "On-Line Computation of Transitive Closure of Graphs," </title> <booktitle> Information Processing Letters 16 (1983), </booktitle> <pages> 95-97. </pages>
Reference-contexts: This is also referred to as a reachability query. A basic data structure is presented in <ref> [63] </ref>. Each transitive closure query takes O (1) time, while a sequence of additions takes O (n 3 ) time, which amortizes to O (n) time per edge addition in dense digraphs.
Reference: [64] <author> G.F. </author> <title> Italiano, "Amortized Efficiency of a Path Retrieval Data Structure," </title> <booktitle> Theoretical Computer Science 48 (1986), </booktitle> <pages> 273-281. </pages>
Reference-contexts: The data structure uses O (n 2 ) space. Semi-dynamic algorithms were presented which improve this result. A data structure for arbitrary digraphs that support edge insertions in amortized O (n) time, queries in O (1) time, and use O (n 2 ) space are given in <ref> [64] </ref>. An extension of this result to finding regular paths for a regular language is given in [14]. A semi-dynamic algorithm for acyclic digraphs that support edge deletions in in amortized O (n) time, queries in O (1) time, and use O (n 2 ) space is presented in [65].
Reference: [65] <author> G.F. </author> <title> Italiano, "Finding Paths and Deleting Edges in Directed Acyclic Graphs," </title> <booktitle> Information Processing Letters 28 (1988), </booktitle> <pages> 5-11. </pages>
Reference-contexts: An extension of this result to finding regular paths for a regular language is given in [14]. A semi-dynamic algorithm for acyclic digraphs that support edge deletions in in amortized O (n) time, queries in O (1) time, and use O (n 2 ) space is presented in <ref> [65] </ref>. La Poutre and van Leeuwen [85] present two semi-dynamic data structures supporting transitive closure on general digraphs. The first supports edge insertions in amortized O (n) time. The second supports edge deletions in amortized O (n 2 ) time.
Reference: [66] <author> G.F. Italiano, A. Marchetti-Spaccamela, and U. Nanni, </author> <title> "Dynamic Data Structures for Series-Parallel Graphs," </title> <booktitle> Proc. WADS' 89, LNCS 382 (1989), </booktitle> <pages> 352-372. </pages>
Reference-contexts: Better results can be achieved for specific classes of digraphs. In particular, there are fully dynamic data structures for dynamic reachability in planar st-graphs [87, 108], spherical st-graphs [112], and series-parallel digraphs <ref> [66] </ref>. Each of these require O (log m) time per query and update using O (m) space. 2.3 Connectivity Connectivity is a fundamental property of graphs. Dynamic algorithms have been presented for both vertex and edge connectivity.
Reference: [67] <author> L. G. Jones, </author> <title> "Incremental Compaction of Flat Symbolic IC Layouts," </title> <institution> Department of Computer Science, University of Illinois, Urbana, Illinois, </institution> <type> Technical Report No. </type> <institution> UIUCDCS-R-87-1386, </institution> <year> 1987. </year>
Reference: [68] <author> L. G. Jones and J. Simon, </author> <title> "Hierarchical VLSI Design Systems Based on Attribute Grammars," </title> <booktitle> Proc. 13th ACM Symp. on Principles of Programming Languages (1986), </booktitle> <pages> 58-69. </pages>
Reference-contexts: A binary attribute grammar is an attribute grammar on a binary tree. We consider attribute grammars where the values of each attribute are taken from a semiring S. Attribute grammars [70] are much studied and have applications in areas such as language based editors [11,92], and VLSI design <ref> [68] </ref>. Incremental algorithms for attribute grammars have been presented [67,91] which give a O (a t) running time per operation where a is the number of attributes affected by a change and t is the time to make a single change.
Reference: [69] <author> A. Kanevsky, R. Tamassia, J. Chen, and G. Di Battista, </author> <title> "On-Line Maintenance of the Four-Connected Components of a Graph," </title> <booktitle> Proc. 32th IEEE Symp. on Foundations of Computer Science (1991), </booktitle> <pages> 793-801. </pages>
Reference-contexts: La Poutre [83,84] extends this to an optimal algorithm with amortized O (qff (q; n)) time per edge insertion for general graphs. For 4-connectivity, the algorithm of <ref> [69] </ref> takes O (q +n log n) time.. If we start with an initially triconnected graph, then the algorithm runs optimally in amortized O (ff (q; n)) time per dynamic operation. The results of [83,120,122] also apply to 2-edge connectivity. <p> A number of data structures have been presented which maintain the recursive decomposition of graphs into subgraphs with constant size overlap. SPQR-trees [28] are used to maintain the tri-connected components of an initially biconnected graph. FWRT-trees <ref> [69] </ref> used to maintain the 4-connected components of an initially tri-connected graph. These last two data structures have a specialized PathFind operation to find the closest ancestor of a given type.
Reference: [70] <author> D. E. Knuth, </author> <title> "Semantics of Context-Free Languages," </title> <booktitle> Mathematical Systems Theory 2 (1968), </booktitle> <pages> 127-145. </pages>
Reference-contexts: We assume, without loss of generality, that the synthesized attributes of precede the inherited attributes of . A binary attribute grammar is an attribute grammar on a binary tree. We consider attribute grammars where the values of each attribute are taken from a semiring S. Attribute grammars <ref> [70] </ref> are much studied and have applications in areas such as language based editors [11,92], and VLSI design [68].
Reference: [71] <author> J. Lagergren, </author> <title> "Efficient Parallel Algorithms for Tree-Decomposition and Related Problems," </title> <booktitle> Proc. 31rst Foundations of Computer Science (1990), </booktitle> <pages> 173-182. </pages>
Reference-contexts: Recently Lagergren <ref> [71] </ref> has given a linear processor NC algorithm to construct such a tree decomposition. They thus demonstrated that a large number of problems which are NP-Complete for general graphs can be solved very efficiently for graphs of constant tree width, both sequentially and in parallel.
Reference: [72] <author> A. Lempel, S. Even, and I. Cederbaum, </author> <title> "An Algorithm for Planarity Testing of Graphs," in Theory of Graphs, </title> <booktitle> Int. Symposium (Rome, 1966), </booktitle> <publisher> Gordon and Breach, </publisher> <address> New York, </address> <year> 1967, </year> <pages> 215-232. </pages>
Reference-contexts: First, we discuss upward drawings of planar st-digraphs, and next we extend the results to (undi-rected) biconnected planar graphs. Planar st-digraphs, which include series-parallel digraphs as a special case, were first introduced by Lempel, Even, and Cederbaum <ref> [72] </ref> in connection with a planarity testing algorithm, and they have subsequently been used in several applications, including planar graph embedding [18,27,107], graph drawing [26,29], and planar point location [37,56,88,114].
Reference: [73] <author> C.C. Lin and R.C. Chang, </author> <title> "On the Dynamic Shortest Path Problem," </title> <booktitle> Proc. Int. Workshop on Discrete Algorithms and Complexity (1989), </booktitle> <pages> 203-212. </pages>
Reference: [74] <author> R. Lipton, D. Rose, and R.E. Tarjan, </author> <title> "Generalized Nested Dissection," </title> <note> SIAM J. Numerical Analysis 16 (1979), 346-358. </note>
Reference-contexts: The tree width of graph G is the minimum width of any tree decomposition of G. Let T W (k) be the class of graphs of tree width k. If G 2 T W (k) then clearly any subgraph of G is in T W (k). Rose <ref> [74] </ref> gives an alternate characterization of T W (k) graphs as subgraphs of k-trees. The class of k-trees is defined recursively as follows. The complete graph with k vertices is a k tree.
Reference: [75] <author> S.M. Malitz and A. Papakostas, </author> <title> "On the Angular Resolution of Planar Graphs," </title> <booktitle> Proc. ACM Symp. on Theory of Computing (1992). </booktitle>
Reference: [76] <author> J. Mataousk and R. Thomas, </author> <title> "Algorithms Finding Tree-Decomposition of Graphs," </title> <booktitle> Journal of Algorithms 12 (1991), </booktitle> <pages> 1-22. </pages>
Reference-contexts: Robertson and Seymour [93] showed the existence of a polynomial time algorithm to determine if a graph has tree width k for some constant k; later Bodlaender [12] and Matousk and Thomas <ref> [76] </ref> gave NC algorithms to construct a tree decomposition of any partial k-tree (for some constant k), whose width is within a constant factor of k. Recently Lagergren [71] has given a linear processor NC algorithm to construct such a tree decomposition.
Reference: [77] <author> S. Moen, </author> <title> "Drawing Dynamic Trees," </title> <booktitle> IEEE Software 7 (1990), </booktitle> <pages> 21-28. </pages>
Reference-contexts: The motivation for investigating dynamic graph 3 drawing algorithms arises when very large graphs need to be visualized in a dynamic environment, where vertices and edges are inserted and deleted, and subgraphs are displayed. Previous work <ref> [77] </ref> only considers trees and presents a technique that restructures the drawing of a tree in time proportional to its height, and hence linear in the worst case. We further the study of dynamic graph drawing by devising a model for dynamic graph drawing algorithms. <p> For a survey on graph drawing, see [36]. While this area has recently received increasing attention (see, e.g., [10,30,45,46,62,75,98]), the study of drawing graphs in a dynamic setting has been an open problem. Previous work <ref> [77] </ref> only considers trees and presents a technique that restructures the drawing of a tree in time proportional to its height, and hence linear in the worst case.
Reference: [78] <author> E. M. Neufeldt and C. J. Colbourn, </author> <title> "The Most Reliable Series Parallel Networks," </title> <institution> Dept. of Computing Science, University of Saskatchewan., </institution> <type> Technical Report TR-83-7, </type> <year> 1983. </year>
Reference: [79] <author> T. Nishizeki and N. Chiba, </author> <title> Planar Graphs: Theory and Algorithms, </title> <booktitle> Annals of Discrete Mathematics 32, </booktitle> <publisher> North-Holland, </publisher> <year> 1988. </year> <month> 124 </month>
Reference-contexts: A planar embedding specifies the circular order of the edges around a vertex in a planar drawing. Hence, different drawings may have the same planar embedding. Note that a planar graph may have an exponential number of planar embeddings (see, e.g. <ref> [79] </ref>). An upward drawing of an acyclic digraph has all the edges flowing from bottom to top. Planar upward drawings are attracting increasing theoretical and practical interest [10,25,26,29,35,62,104,117]. A visibility representation maps vertices to horizontal segments and edges to vertical segments that intersect only the two corresponding vertex segments.
Reference: [80] <author> J. O'Rourke, </author> <title> Art Gallery Theorems and Algorithms, </title> <publisher> Oxford University Press, </publisher> <year> 1987. </year>
Reference-contexts: We conclude that our dynamic data structure uses O (n) space and supports each operation in O (log n) time. 5.4.2 Visibility Drawings The concept of visibility plays a fundamental role in a variety of geometric problems and applications, such as art gallery problems <ref> [80] </ref>, VLSI layout [61,97,123], motion planning [58], and graph drawing [26,110].
Reference: [81] <author> M. Overmars, </author> <title> "The Design of Dynamic Data Structures," </title> <booktitle> Lecture Notes in Computer Science 156 (1983). </booktitle>
Reference-contexts: We consider dynamic algorithms where processing is done on-line, which means that a sequence of update and query operations are performed over time, and we must complete each operation before beginning the next. Generalized techniques have been developed to dynamize large classes of geometric algorithms (summarized in <ref> [81] </ref>). In the area of graph algorithms such techniques are lacking. The goal of this thesis is to demonstrate generalized techniques to maintain the solutions of dynamic algorithms for graph problems, and to present dynamic algorithms based on our techniques. <p> We provide an extensive collection of query and update operations. Queries include returning the value of attributes. Additionally, we extend the decomposable search problems of <ref> [81] </ref> to trees in order to find a distinguished node of a tree. Updates include changing the values of node attributes. We also describe update operations that alter the structure of trees. <p> However, considerably fewer results exist on the dynamization of graph algorithms. A crucial development in the area of dynamic geometric searching has been the identification of general methods that apply to a large class of problems. In particular, the techniques developed by Overmars et al. (summarized in <ref> [81] </ref>) for the class of decomposable search problems constitute a fundamental contribution toward the dynamization of large classes of geometric problems. The availability of such general techniques appears instead to be lacking in the area of dynamic graph algorithms. <p> A decomposable search problem <ref> [81] </ref> on a set D, locates a distinguished element x = (D) such that given any partition of D into subsets D 0 and D 00 , we can determine in constant time if x is in D 0 or D 00 .
Reference: [82] <author> M.S. Patterson and F.F. Yao, </author> <title> "Optimal Binary Space Partitions for Orthoganal Objects," </title> <booktitle> Proc. 1st ACM-SIAM Symp. on Discrete Algorithms (1990), </booktitle> <pages> 100-106. </pages>
Reference-contexts: E.g. a node corresponds to a trapezoid and to a segment that divides it into two trapezoids (for details see <ref> [82] </ref>). Each leaf of binary space partition T represents a region referred to as region ().
Reference: [83] <author> J.A. La Poutre, </author> <title> "Dynamic Graph Algorithms and Data Structures," </title> <institution> Dept. of Computer Science, University of Utrechet, Utrechet, </institution> <type> Ph.D. Thesis, </type> <year> 1991. </year>
Reference: [84] <author> J.A. La Poutre, </author> <title> "Maintenance of Triconnected Components of Graphs," Automata, </title> <booktitle> Languages and Programming (Proc. 19th ICALP), Lecture Notes in Computer Science (to appear) (1992). </booktitle>
Reference: [85] <author> J.A. La Poutre and J. van Leeuwen, </author> <title> "Maintenance of Transitive Closures and Transitive Reductions of Graphs," </title> <booktitle> Proc. WG '87, LNCS 314 (1988), </booktitle> <pages> 106-120. </pages>
Reference-contexts: A semi-dynamic algorithm for acyclic digraphs that support edge deletions in in amortized O (n) time, queries in O (1) time, and use O (n 2 ) space is presented in [65]. La Poutre and van Leeuwen <ref> [85] </ref> present two semi-dynamic data structures supporting transitive closure on general digraphs. The first supports edge insertions in amortized O (n) time. The second supports edge deletions in amortized O (n 2 ) time.
Reference: [86] <author> F.P. Preparata, </author> <title> "A New Approach to Planar Point Location," </title> <journal> SIAM J. Computing 10 (1981), </journal> <pages> 473-483. </pages>
Reference: [87] <author> F.P. Preparata and R. Tamassia, </author> <title> "Fully Dynamic Techniques for Point Location and Transitive Closure in Planar Structures," </title> <booktitle> Proc. 29th IEEE Symp. on Foundations of Computer Science (1988), </booktitle> <pages> 558-567. </pages>
Reference-contexts: Both data structures use O (n 2 ) space and can be used to answer transitive closure queries in O (1) time. Better results can be achieved for specific classes of digraphs. In particular, there are fully dynamic data structures for dynamic reachability in planar st-graphs <ref> [87, 108] </ref>, spherical st-graphs [112], and series-parallel digraphs [66]. Each of these require O (log m) time per query and update using O (m) space. 2.3 Connectivity Connectivity is a fundamental property of graphs. Dynamic algorithms have been presented for both vertex and edge connectivity.
Reference: [88] <author> F.P. Preparata and R. Tamassia, </author> <title> "Fully Dynamic Point Location in a Monotone Subdivision," </title> <journal> SIAM J. Computing 18 (1989), </journal> <pages> 811-830. </pages>
Reference: [89] <author> J.H. Reif, </author> <title> "A Topological Approach to Dynamic Graph Connectivity," </title> <booktitle> Information Processing Letters 25 (1987), </booktitle> <pages> 65-70. </pages>
Reference-contexts: This is the best result handling edge deletions. Other semi-dynamic techniques supporting only edge deletions are shown in [41], where a data structure is presented supporting constant time queries and O (q + mn) time to perform q edge deletions; and in <ref> [89] </ref> where q edge deletions are performed in O (mg + m log m) time for a graph of genus g. These results have been extended to the maintenance of 2, 3, and 4-connectivity. Each of the following is implemented with a semi-dynamic data structure, supporting only insertions.
Reference: [90] <author> E. Reingold and J. Tilford, </author> <title> "Tidier Drawing of Trees," </title> <journal> IEEE Trans. on Software Engineering SE-7 (1981), </journal> <pages> 223-228. </pages>
Reference-contexts: Symmetric: Symmetric subtrees have drawings that are congruent up to a translation and a reflection. Quadratic-Area: The drawing has O (n 2 ) area. Reingold and Tilford <ref> [90] </ref> argue that drawings satisfying P S are aesthetically pleasing and show how to construct them in O (n) time. We give a fully dynamic algorithm for constructing such drawings. However, in general the drawings produced by the algorithm of [90] are less wide than those produced by our algorithm. <p> Reingold and Tilford <ref> [90] </ref> argue that drawings satisfying P S are aesthetically pleasing and show how to construct them in O (n) time. We give a fully dynamic algorithm for constructing such drawings. However, in general the drawings produced by the algorithm of [90] are less wide than those produced by our algorithm. Note that finding drawings of minimum width that satisfy the above properties is NP-hard [105].
Reference: [91] <author> T.W. Reps, </author> <title> Generating Language-Based Environments, </title> <publisher> The MIT Press, </publisher> <year> 1984. </year>
Reference: [92] <author> T.W. Reps and T. Teitelbaum, </author> <title> The Synthesizer Generator, </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference: [93] <author> Neil Robertson and P. D. Seymour, </author> <title> "Graph Minors. XIII. Disjoint Paths Problem," </title> <note> Submitted for Publication. </note>
Reference-contexts: Arnborg and Proskurowski [5] proved that the class of partial k-trees is the same as T W (k). Therefore, we use the terms interchangeably to denote the same class of graphs. 47 Also, they proved that it is NP-Complete to determine the tree-width of a graph. Robertson and Seymour <ref> [93] </ref> showed the existence of a polynomial time algorithm to determine if a graph has tree width k for some constant k; later Bodlaender [12] and Matousk and Thomas [76] gave NC algorithms to construct a tree decomposition of any partial k-tree (for some constant k), whose width is within a <p> Graph H is a minor of G if H can be obtained by a series of contractions from a subgraph of G. Robertson and Seymour <ref> [93] </ref> gave a nonconstructive proof of the fact that for any k 2 N the class of graphs with tree width at most k, can be characterized by a finite set of forbidden minors.
Reference: [94] <author> Neil Robertson and P. D. Seymour, </author> <title> "Graph Minors. II. Algorithmic Aspects of Tree-Width," </title> <booktitle> Journal of Algorithms 7 (1986), </booktitle> <pages> 309-322. </pages>
Reference-contexts: Chapter 4 uses a tree attribute system to develop fully dynamic data structures to answer a large class of queries on tree-width two graphs. Many of these queries are NP-complete in general. The concept of bounded tree-width graph was introduced by Robertson and Seymour <ref> [94] </ref> as a generalization of series-parallel graphs. Graphs of tree-width two have been extensively studied owing to their role in fault-tolerant communication networks [43,44,78,119], concurrent broadcasting in common medium networks [23], reliability evaluation in complex systems [3], and evaluation of queries in relational data base systems [4]. <p> Note that tree-width two graphs include the important subclasses of trees and series-parallel graphs. Bounded tree-width graphs also have theoretical interest, since a large number of generally NP-complete problems have polynomial time solutions when restricted to graphs of a bounded tree-width <ref> [94] </ref>. While extensive research has been accomplished to find parallel algorithms to recognize bounded tree-width graphs [12,71,76], no equivalent dynamic result has been presented. We demonstrate a fully-dynamic data structure to maintain the decomposition of tree-width two graphs. <p> Note that tree-width two graphs include the important subclasses of trees and series-parallel graphs. The notion of the tree width of a graph was introduced by Robertson and Sey-mour <ref> [94] </ref>.
Reference: [95] <author> H. Rohnert, </author> <title> "A Dynamization of the All-Pairs Least Cost Problem," </title> <booktitle> Proc. STACS '85 (1985), </booktitle> <pages> 279-286. </pages>
Reference: [96] <author> P. Rosenstiehl and R.E. Tarjan, </author> <title> "Rectilinear Planar Layouts of Planar Graphs and Bipolar Orientations," </title> <booktitle> Discrete & Computational Geometry 1 (1986), </booktitle> <pages> 343-353. </pages>
Reference: [97] <author> M. Schlag, F. Luccio, P. Maestrini, D.T. Lee, and C.K. Wong, </author> <title> "A Visibility Problem in VLSI Layout Compaction," </title> <booktitle> in Advances in Computing Research, </booktitle> <volume> vol. 2, </volume> <editor> F.P. Preparata, ed., </editor> <publisher> JAI Press Inc., </publisher> <address> Greenwich, CT, </address> <year> 1985, </year> <pages> 259-282. </pages>
Reference: [98] <author> W. Schnyder, </author> <title> "Embedding Planar Graphs on the Grid," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1990), </booktitle> <pages> 138-148. 125 </pages>
Reference: [99] <author> C. Schwarz, M. Smid, and J. Snoeyink, </author> <title> "An Optimal Algorithm for the On-line Closest-Pair Problem," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1992). </booktitle>
Reference: [100] <author> D.D. Sleator and R.E. Tarjan, </author> <title> "A Data Structure for Dynamic Trees," </title> <editor> J. </editor> <booktitle> Computer Systems Sciences 24 (1983), </booktitle> <pages> 362-381. </pages>
Reference-contexts: Our algorithm performs queries and updates in O (log n) time using O (n) space. This is a significant extension of the dynamic trees of Sleator and Tarjan <ref> [100] </ref>. We introduce two new data structures based on tree attribute systems. Suppose S is a semiring and r is a constant. A linear expression tree is a tree-based expression where each node contains an attribute taken from S r . <p> following fundamental idea: Decompose a graph into subgraphs with limited overlap, and represent such a decomposition by means of a tree so that dynamic operations on the graph are reflected into corresponding dynamic tree operations, which are in turn supported by variations of the link-cut trees of Sleator and Tarjan <ref> [100] </ref>. We associate values, called attributes, with the nodes, paths, and subtrees of our trees. Path attributes form a path attribute system, if they are maintained in constant time under path concatenation. <p> A linear attribute grammar, is an attribute grammar where all dependencies are linear. The results of this chapter can be summarized as follows: * We provide a framework for maintaining attribute systems on trees in a fully 9 dynamic environment. Our technique extends and generalizes the dynamic trees of <ref> [100] </ref>. * We show that given a semiring S, a set of linear expressions with binary and unary operators over S k can be dynamically maintained in a fully dynamic environment using linear space and logarithmic time per operation. * We show that a linear attribute grammar can be dynamically maintained <p> We introduce the concept of path attribute systems and tree attribute systems which significantly extend and generalize the dynamic trees of <ref> [100] </ref>. We begin by discussing dynamic algorithms on a collection of paths, and then show that trees can be maintained as a collection of paths. 3.2.1 Path Attribute Systems Paths are directed. <p> This is done with the following operations, derived from dynamic trees <ref> [100] </ref>: * splice (path ) | This operation assumes that is a solid path ending at 6= . Convert the dashed edge leaving to solid and convert the solid edge (if it exists) entering the parent of to dashed. <p> This list includes dynamic trees and edge ordered trees. In this section, we review these data structures, and existing applications for tree attribute systems, linear expression trees, and linear attribute grammars. Dynamic trees <ref> [100] </ref> are unordered, unbounded, rooted trees supporting operations Link, Cut and Evert. Each node stores a globally updatable cost associated with the edge from to its parent. Global updates are only performed on the path from a node to the root.
Reference: [101] <author> D.D. Sleator and R.E. Tarjan, </author> <title> "Self-Adjusting Binary Search Trees," </title> <editor> J. </editor> <booktitle> ACM 32 (1985), </booktitle> <pages> 652-686. </pages>
Reference-contexts: The value of P () may change only if is on the path from to in B. Therefore, we calculate these values starting at and ending at . This takes O (d ) time where d is the depth of in B. We need the following operation from <ref> [101] </ref> in our implementation of find (; S; q): * splaystep (node ) | For binary tree B with root and node a grandchild of , restructure B such that the relative order of the leaves of B remain fixed, and every node in the subtree rooted at has its depth
Reference: [102] <author> P.M. Spira and A. Pan, </author> <title> "On Finding and Updating Spanning Trees and Shortest Paths," </title> <journal> SIAM J. Computing 4 (1975), </journal> <pages> 375-380. </pages>
Reference: [103] <author> L. Stockmeyer, </author> <title> "Optimal Orientation of Cells in Slicing Floorplan Design," </title> <booktitle> Information and Control 57 (1983), </booktitle> <pages> 91-101. </pages>
Reference-contexts: trapezoid method for planar point location described in [17] is an example of an existing method that can be expressed as a selection function. 3.5.5 Slicing Floorplan Compaction Linear attribute grammars have immediate application to the problem of compacting slicing floorplans, a layout technique widely used in VLSI (see, e.g., <ref> [103] </ref>). A slicing floorplan is either a rectangle (called basic rectangle), or is the union of two slicing floorplans that share a horizontal side (called horizontal slice) or a vertical side (called vertical slice). <p> An important problem in VLSI layout is determining the location of basic rectangles while minimizing the area of the slicing floorplan, subject to the above constraints on the height and width of the basic rectangles. (For full details, see <ref> [103] </ref>.) This problem can be solved using a linear attribute grammar T . Leaves of T represent basic rectangles, and internal nodes represent horizontal or vertical slices (see Fig. 3.9). The reference point of a sub-floorplan is its bottom-left corner.
Reference: [104] <author> K. Sugiyama, S. Tagawa, and M. </author> <title> Toda, "Methods for Visual Understanding of Hierarchical Systems," </title> <journal> IEEE Trans. on Systems, Man, and Cybernetics SMC-11 (1981), </journal> <pages> 109-125. </pages>
Reference: [105] <author> K.J. Supowit and E.M. Reingold, </author> <title> "The Complexity of Drawing Trees Nicely," </title> <journal> Acta Informatica 18 (1983), </journal> <pages> 377-392. </pages>
Reference-contexts: We give a fully dynamic algorithm for constructing such drawings. However, in general the drawings produced by the algorithm of [90] are less wide than those produced by our algorithm. Note that finding drawings of minimum width that satisfy the above properties is NP-hard <ref> [105] </ref>.
Reference: [106] <author> R. Tamassia, </author> <title> "On Embedding a Graph in the Grid with the Minimum Number of Bends," </title> <journal> SIAM J. Computing 16 (1987), </journal> <pages> 421-444. </pages>
Reference-contexts: The techniques of [46,98] appear difficult to dynamize. * Dynamically maintain orthogonal drawings with the minimum number of bends. The static algorithm of <ref> [106] </ref> is based on network flow techniques for which no dynamic methods are known. * Devise dynamic algorithms to test whether a digraph admits an upward planar drawing. Static algorithms that perform this test are known only for triconnected digraphs [10]and for single-source digraphs [62].
Reference: [107] <author> R. Tamassia, </author> <title> "A Dynamic Data Structure for Planar Graph Embedding," </title> <booktitle> Proc. 15th ICALP, LNCS 317 (1988), </booktitle> <pages> 576-590. </pages>
Reference-contexts: The dynamic maintenance of a planar embedding under a sequence of edge insertions can be done in time O (log n) per operation <ref> [107] </ref>. Di Battista and Tamassia [27] have investigated how to test if a new edge can be added to a planar graph G so that G remains planar, and how to add vertices and edges so that planarity is preserved. <p> Each of these steps can be implemented in O (log n) time. Therefore, operation Locate is performed in O (log n) time. To implement operation Window we keep the data structure of <ref> [107] </ref> to to maintain the planar embedding of G. In particular given a face f of G in an upward embedding of series-parallel digraph G, we can find two lists of edges and vertices that comprise the left and right boundary of f . <p> Note that we do not maintain a dynamic drawing predicate. Data Structure We maintain on-line an orientation of G into a planar st-digraph. This can be done using the techniques of <ref> [107] </ref>. We can extend Theorem 5.5 to support the insertion of an edge between two vertices that are not on the same face of the current embedding, using the techniques of [27].
Reference: [108] <author> R. Tamassia and F.P. Preparata, </author> <title> "Dynamic Maintenance of Planar Digraphs, with Applications," </title> <booktitle> Algorithmica 5 (1990), </booktitle> <pages> 509-527. </pages>
Reference-contexts: Both data structures use O (n 2 ) space and can be used to answer transitive closure queries in O (1) time. Better results can be achieved for specific classes of digraphs. In particular, there are fully dynamic data structures for dynamic reachability in planar st-graphs <ref> [87, 108] </ref>, spherical st-graphs [112], and series-parallel digraphs [66]. Each of these require O (log m) time per query and update using O (m) space. 2.3 Connectivity Connectivity is a fundamental property of graphs. Dynamic algorithms have been presented for both vertex and edge connectivity. <p> The corresponding modifications of node attributes can be done in O (log n) time. Also, sequences &lt; L and &lt; R are updated by means of O (1) split/concatenate operations <ref> [108] </ref>, so that the corresponding updates on L and R take O (log n) time. <p> Draw each edge-segment fi (e) at x-coordinate X (left (e)) and between y-coordinates Y (low (e)) and Y (high (e)). Consider the orderings L and R defined in Section 5.4.2. The restriction of sequence L (or R) to V is a topological ordering <ref> [108] </ref>.
Reference: [109] <author> R. Tamassia and I.G. Tollis, </author> <title> "A Unified Approach to Visibility Representations of Planar Graphs," </title> <booktitle> Discrete & Computational Geometry 1 (1986), </booktitle> <pages> 321-341. </pages>
Reference-contexts: Data Structure We recall that in a planar st-digraph the incoming edges of each vertex appear consecutively around the vertex, and so do the outgoing edges <ref> [109] </ref>. The faces separating the incoming and outgoing edges of vertex v to the left and right of v are called left (v) and right (v), respectively.
Reference: [110] <author> R. Tamassia and I.G. Tollis, </author> <title> "Planar Grid Embedding in Linear Time," </title> <journal> IEEE Trans. on Circuits and Systems CAS-36 (1989), </journal> <pages> 1230-1234. </pages>
Reference: [111] <author> R. Tamassia and I.G. Tollis, </author> <title> "Tessellation Representations of Planar Graphs," </title> <booktitle> Proc. 27th Annual Allerton Conf. </booktitle> <year> (1989), </year> <pages> 48-57. </pages>
Reference: [112] <author> R. Tamassia and I.G. Tollis, </author> <title> "Reachability in Planar Digraphs," </title> <institution> Computer Science Program, Univ. of Texas at Dallas, </institution> <type> Technical Report UTDCS-29-90, </type> <year> 1990. </year>
Reference-contexts: Better results can be achieved for specific classes of digraphs. In particular, there are fully dynamic data structures for dynamic reachability in planar st-graphs [87, 108], spherical st-graphs <ref> [112] </ref>, and series-parallel digraphs [66]. Each of these require O (log m) time per query and update using O (m) space. 2.3 Connectivity Connectivity is a fundamental property of graphs. Dynamic algorithms have been presented for both vertex and edge connectivity.
Reference: [113] <author> R. Tamassia and I.G. Tollis, </author> <title> "Representations of Graphs on a Cylinder," </title> <note> SIAM J. on Discrete Mathematics 4 (1991), 139-149. </note>
Reference: [114] <author> R. Tamassia and J.S. Vitter, </author> <title> "Parallel Transitive Closure and Point Location in Planar Structures," </title> <journal> SIAM J. Computing 20 (1991), </journal> <pages> 708-725. </pages>
Reference: [115] <author> R.E. Tarjan, </author> <title> "Amortized Computational Complexity," </title> <booktitle> SIAM J. Algebraic Discrete Methods 6 (1985), </booktitle> <pages> 306-318. </pages>
Reference-contexts: Amortized analysis of a dynamic algorithm consists of determining the worst-case time complexity T (n; q) to perform these operations. The amortized time to perform each operation is then T (n; q)=q. For a full discussion of amortized analysis, see <ref> [115] </ref>. A dynamic algorithm or data structure is semi-dynamic if the repertory of update operations consists of only "insertions" or "deletions", while a fully dynamic algorithm supports an intermixed sequence of insertions and deletions.
Reference: [116] <author> R.E. Tarjan and J. van Leeuwen, </author> <title> "Worst-Case Analysis of Set-Union Algorithms," </title> <editor> J. </editor> <booktitle> ACM 31 (1984), </booktitle> <pages> 245-281. </pages>
Reference-contexts: This is the undirected version of the reachability query. If we allow only edge insertions, this problem reduces to the set union-find problem <ref> [116] </ref>, where a sequence of q queries and insertions takes O (qn + mff (m; n)) time, where ff (m; n) is a very slowly increasing function [116]. Therefore, we have amortized O (ff (m; n)) time per operation. <p> If we allow only edge insertions, this problem reduces to the set union-find problem <ref> [116] </ref>, where a sequence of q queries and insertions takes O (qn + mff (m; n)) time, where ff (m; n) is a very slowly increasing function [116]. Therefore, we have amortized O (ff (m; n)) time per operation. The fully dynamic data structure of [48] takes O ( p m) time per operation. This is the best result handling edge deletions.
Reference: [117] <author> C. Thomassen, </author> <title> "Planar Acyclic Oriented Graphs," </title> <booktitle> Order 5 (1989), </booktitle> <pages> 349-361. 126 </pages>
Reference: [118] <author> J. Valdes, R.E. Tarjan, and E.L. Lawler, </author> <title> "The Recognition of Series Parallel Digraphs," </title> <journal> SIAM J. on Computing 11 (1982), </journal> <pages> 298-313. </pages>
Reference-contexts: The terminals of node are the terminals of G . If G t has m edges, then T has O (m) nodes. Tree T can be constructed in O (m) time using the recognition algorithm of <ref> [118] </ref>. The following corollary to lemma 4.1 shows the connection between swapping a TTSP and reflecting the associated SPQ-tree. Corollary 4.1 Consider a TTSP G t and associated SPQ-tree T . Let T be the reflection of T . <p> Proof: (If ) If v 0 and v 00 meet either condition in the lemma, then G is clearly a series-parallel graph with an additional parallel composition. (Only If ) We use the property that a series-parallel graph has no subgraph homeomorphic to the digraph W shown in Fig. 4.11 <ref> [118] </ref>. Suppose that v 0 and v 00 do not meet either condition of the lemma. Let be the least common ancestor in T of the proper nodes of v 0 and v 00 . Let e be the edge from v 0 to v 00 .
Reference: [119] <author> A. Wald and C. J. Colbourn, </author> <title> "Steiner Trees, Partial 2-Trees, and Minimum IFI networks," </title> <booktitle> Networks 13 (1983), </booktitle> <pages> 159-167. </pages>
Reference-contexts: Robertson and Seymour [93] gave a nonconstructive proof of the fact that for any k 2 N the class of graphs with tree width at most k, can be characterized by a finite set of forbidden minors. Wald and Colbourn <ref> [119] </ref> show that tree-width two graphs are exactly the graphs which exclude the complete graph with four vertices, K 4 , as a minor. 4.2.1 Preliminaries Definition 4.1 A two-terminal graph G t = (V; E; t ) consists of a graph G = (V; E) and an ordered pair of
Reference: [120] <author> J. Westbrook, </author> <title> "Algorithms and Data Structures for Dynamic Graph Problems," </title> <institution> Dept. Computer Science, Princeton Univ., </institution> <type> Ph.D. dissertation (Technical Report CS-TR-229-89), </type> <year> 1989. </year>
Reference: [121] <author> J. Westbrook, </author> <title> "Fast Incremental Planarity Testing," Automata, </title> <booktitle> Languages and Programming (Proc. 19th ICALP), Lecture Notes in Computer Science (to appear) (1992). </booktitle>
Reference-contexts: The semidynamic data structure of [27] for biconnected graphs uses O (n) space and supports queries and insertions in O (log n) time (amortized for edge-insertions). The extension to general graphs is reported in [28]. Westbrook <ref> [121] </ref> has improved this result to achieve O (ff (m; n)) amortized time per operation. This time bound is deterministic for queries and expected for updates. The randomization is due to the use of on dynamic perfect hashing [31].
Reference: [122] <author> J. Westbrook and R.E. Tarjan, </author> <title> "Maintaining Bridge-Connected and Biconnected Components On-Line," </title> <note> Algorithmica (1989 (to appear in Algorithmica)). </note>
Reference: [123] <author> S. Wimer, I. Koren, and I. Cederbaum, "Floorplans, </author> <title> Planar Graphs, and Layouts," </title> <journal> IEEE Trans. on Circuits and Systems 35 (1988), </journal> <pages> 267-278. </pages>
Reference: [124] <author> S.K. Wismath, </author> <title> "Characterizing Bar Line-of-Sight Graphs," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1985), </booktitle> <pages> 147-152. </pages>
Reference: [125] <author> S.K. Wismath, </author> <title> "Weighted Visibility Graphs of Bars and Related Flow Problems," </title> <booktitle> Algorithms and Data Structures (Proc. WADS'89) (1989), </booktitle> <pages> 325-334. </pages>
Reference: [126] <author> D. Yellin, </author> <title> "A Dynamic Transitive Closure Algorithm," </title> <institution> IBM T.J. Watson Research Center, Research Report, </institution> <year> 1988. </year> <month> 127 </month>
References-found: 126

