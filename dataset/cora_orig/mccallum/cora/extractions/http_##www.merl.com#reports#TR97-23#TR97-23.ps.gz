URL: http://www.merl.com/reports/TR97-23/TR97-23.ps.gz
Refering-URL: http://www.merl.com/reports/TR97-23/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Efficient Algorithms for Two-Phase Collision Detection  Practical Motion Planning in Robotics: Current Approaches and Future Directions,  
Author: Brian Mirtich K. Gupta and A.P. del Pobil, editors. 
Address: 1997 201 Broadway, Cambridge, Massachusetts 02139  
Affiliation: Mitsubishi Electric Information Technology Center America,  
Date: December 1997  
Web: http://www.merl.com  
Note: MERL A MITSUBISHI ELECTRIC RESEARCH LABORATORY  To appear in  Copyright c  
Pubnum: TR-97-23  
Abstract: This article describes practical collision detection algorithms for robot motion planning. Attention is restricted to algorithms that handle rigid, polyhedral geometries. Both broad phase and narrow phase detection strategies are discussed. For the broad phase, an algorithm using axes-aligned bounding boxes and a hierarchical spatial hash table is described. For the narrow-phase, the Lin-Canny algorithm is presented. Alternatives to these algorithms are also discussed. Finally, the article describes a scheduling paradigm for managing collision checks that can further reduce computation time. Pointers to downloadable software are included. This work may not be copied or reproduced in whole or in part for any commercial purpose. Permission to copy in whole or in part without payment of fee is granted for nonprofit educational and research purposes provided that all such whole or partial copies include the following: a notice that such copying is by permission of Mitsubishi Electric Information Technology Center America; an acknowledgment of the authors and individual contributions to the work; and all applicable portions of the copyright notice. Copying, reproduction, or republishing for any other purpose shall require a license with payment of fee to Mitsubishi Electric Information Technology Center America. All rights reserved. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Ayala, P. Brunet, R. Juan, and I. Navazo. </author> <title> Object representation by means of nonminimal division quadtrees and octrees. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 4(1) </volume> <pages> 41-59, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Other types of collision detection algorithms are then more suitable, such as those based on oc-trees <ref> [1] </ref>, binary space partitioning trees [22], sphere hierarchies [15], or oriented bounding boxes (OBBs). These algorithms also often provide robustness in the presence of modeling errors, such as improperly oriented or missing facets.
Reference: [2] <author> David Baraff. </author> <title> Curved surfaces and coherence for non-penetrating rigid body simulation. </title> <journal> Computer Graphics, </journal> <volume> 24(4) </volume> <pages> 19-28, </pages> <month> August </month> <year> 1990. </year> <booktitle> SIGGRAPH Conference Proceedings, </booktitle> <year> 1990. </year> <month> MERL-TR-97-23 December </month> <year> 1997 </year> <month> 23 </month>
Reference-contexts: This separating plane is cached along with points from each polyhedron that are closest to it. Given the plane and the closest point to it, one can verify disjointness in constant time <ref> [2] </ref>. This algorithm is simpler in principle than Lin-Canny, and might be suitable in some applications. Baraff does not describe the update step that must occur when the current pair of witnesses fails to verify disjointness. <p> One solution is to apply detection algorithms to the four-dimensional hyper-polyhedra swept out in space-time [5]. This method is slow and has not seen wide practical use. Most simulation systems simply ignore the problem <ref> [8, 21, 12, 2] </ref>. There is an alternative paradigm for performing collision checks that can reduce the number of collision checks performed, and also prevent missed collisions. It relies on computing a lower bound on the time of impact (TOI) between a pair of objects.
Reference: [3] <author> David Baraff. </author> <title> Dynamic Simulation of Non-Penetrating Rigid Bodies. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Caching results from previous invocations greatly reduces the amortized cost of collision detection. Gilbert, et. al. describe an adaptation of their algorithm to take advantage of coherence when it exists [10]. Coherence is also used in Baraff's witness plane algorithm <ref> [3] </ref>, Cameron's enhancement of the Gilbert algorithm [4], the Lin-Canny closest features algorithm [18, 17], and the V-Clip algorithm [20]. Use of locality often goes hand-in-hand with coherence in many algorithms. This property allows an algorithm to verify that the cached result is still valid using only local geometric tests. <p> One such algorithm is based on sorting the coordinates of the boundaries of the bounding boxes along each of the three coordinate axes; it is used in the I-Collide system [7] and also in <ref> [3] </ref>. The algorithm works as follows. The minimum and maximum x-coordinates of each axes-aligned box are maintained in a sorted list. The same is done for the y and z coordinates. Two boxes overlap if and only if their coordinates overlap in each of the three coordinate directions.
Reference: [4] <author> Stephen Cameron. </author> <title> Enhancing GJK: Computing minimum penetration distances between convex polyhedra. </title> <booktitle> In Proceedings of International Conference on Robotics and Automation. IEEE, </booktitle> <month> April </month> <year> 1997. </year>
Reference-contexts: Caching results from previous invocations greatly reduces the amortized cost of collision detection. Gilbert, et. al. describe an adaptation of their algorithm to take advantage of coherence when it exists [10]. Coherence is also used in Baraff's witness plane algorithm [3], Cameron's enhancement of the Gilbert algorithm <ref> [4] </ref>, the Lin-Canny closest features algorithm [18, 17], and the V-Clip algorithm [20]. Use of locality often goes hand-in-hand with coherence in many algorithms. This property allows an algorithm to verify that the cached result is still valid using only local geometric tests. <p> With these improvements, the algorithm attains the same almost constant time complexity as Lin-Canny <ref> [4] </ref>. The Voronoi-clip, or V-Clip, algorithm is a polyhedral collision detection algorithm, derived from similar principles as the Lin-Canny algorithm. It overcomes the principle limitations of Lin-Canny. In particular, 1. V-Clip handles the penetration case. 2. V-Clip is robust in the presence of degenerate configurations. 3.
Reference: [5] <author> John Canny. </author> <title> Collision detection for moving polyhedra. </title> <type> Technical Report MIT A.I. </type> <institution> Lab Memo 806, Massachusetts Institute of Technology, </institution> <month> October </month> <year> 1984. </year>
Reference-contexts: One solution is to apply detection algorithms to the four-dimensional hyper-polyhedra swept out in space-time <ref> [5] </ref>. This method is slow and has not seen wide practical use. Most simulation systems simply ignore the problem [8, 21, 12, 2]. There is an alternative paradigm for performing collision checks that can reduce the number of collision checks performed, and also prevent missed collisions.
Reference: [6] <author> Kelvin Chung. </author> <title> An efficient collision detection algorithm for polytopes in virtual environments. </title> <type> Master's thesis, </type> <institution> University of Hong Kong, </institution> <month> September </month> <year> 1996. </year>
Reference-contexts: Rabbitz advanced the original GJK algorithm by making better use of coherence [25]. Q-Collide is a collision detection library spawned from I-Collide, which replaces Lin-Canny with Rabbitz's algorithm for the low-level distance computation <ref> [6] </ref>. It shares I-Collide's broad phase detection scheme. Cameron has recently developed the fastest descendent of GJK: it includes mechanisms to exploit coherence, and also uses topological vertex information to more carefully choose new simplices when the current simplices fail to satisfy the termination criteria.
Reference: [7] <author> Jonathan D. Cohen, Ming C. Lin, Dinesh Manocha, and Madhav K. Ponamgi. I-collide: </author> <title> An interactive and exact collision detection system for large-scaled environments. </title> <booktitle> In Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 189-196. </pages> <note> ACM Siggraph, ACM Siggraph, </note> <month> April </month> <year> 1995. </year>
Reference-contexts: One such algorithm is based on sorting the coordinates of the boundaries of the bounding boxes along each of the three coordinate axes; it is used in the I-Collide system <ref> [7] </ref> and also in [3]. The algorithm works as follows. The minimum and maximum x-coordinates of each axes-aligned box are maintained in a sorted list. The same is done for the y and z coordinates. <p> Cohen, et. al. discuss the relative merits of using a fixed size, cubical box that can accommodate an object at any orientation versus tighter fitting boxes that change in shape as the object rotates <ref> [7] </ref>. Coherence is exploited by updating previously sorted lists to obtain new sorted lists. In this way, the number of exchanges needed to obtain the new sorted list is expected to be O (n). It can, however, be O (n 2 ). Consider the situation depicted in Figure 6. <p> The algorithm's output can easily be used to compute the distance between the polyhedra, which serves as a basis for collision detection. The I-Collide collision detection package for large environments uses the Lin-Canny algorithm for its narrow phase detection <ref> [7] </ref>. Lin-Canny has some drawbacks. The two most limiting are that it does not terminate when presented with penetrating polyhedra, 2 and that it sometimes exhibits poor convergence in degenerate situations. Despite these drawbacks, it can be a useful tool for motion planning. <p> In this case, the Lin-Canny algorithm is O ( p N ). Figure 10 and Graph 2 in Cohen, et. al. <ref> [7] </ref> also illustrate that the running time of the Lin-Canny algorithm depends on the number of features. One difficulty of assigning a complexity to the algorithm is that it is very dependent on how the objects are moving.
Reference: [8] <author> James F. Cremer and A. James Stewart. </author> <title> The architecture of newton, a general-purpose dynamics simulator. </title> <booktitle> In Proceedings of International Conference on Robotics and Automation, </booktitle> <pages> pages 1806-1811. </pages> <publisher> IEEE, </publisher> <month> May </month> <year> 1989. </year>
Reference-contexts: One solution is to apply detection algorithms to the four-dimensional hyper-polyhedra swept out in space-time [5]. This method is slow and has not seen wide practical use. Most simulation systems simply ignore the problem <ref> [8, 21, 12, 2] </ref>. There is an alternative paradigm for performing collision checks that can reduce the number of collision checks performed, and also prevent missed collisions. It relies on computing a lower bound on the time of impact (TOI) between a pair of objects.
Reference: [9] <author> H. Edelsbrunner. </author> <title> A new approach to rectangle intersections, part i. </title> <journal> International Journal of Computational Mathematics, </journal> <volume> 13 </volume> <pages> 209-219, </pages> <year> 1983. </year>
Reference-contexts: One way of handling the clustering problem is to perform a less drastic dimension reduction, projecting the three-dimensional boxes first into two-dimensional rectangles in the plane, and reporting intersections among the rectangles in O (n log n + k) time, where k is the number of intersections <ref> [9] </ref>. Another alternative is to skew the axes to which the bounding boxes are aligned, so that all three coordinates vary along surfaces like table tops. This may cause the boxes to be much larger than in the unskewed system. Hashing schemes do not suffer from the clustering problem.
Reference: [10] <author> Elmer G. Gilbert, Daniel W. Johnson, and S. Sathiya Keerthi. </author> <title> A fast procedure for computing the distance between complex objects in three-dimensional space. </title> <journal> IEEE Journal of Robotics and Automation, </journal> <volume> 4(2) </volume> <pages> 193-203, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: These algorithms required running time that was quadratic in the complexity of the polyhedra to determine if the objects were disjoint [21, 12]; they are too slow for many motion planning applications. Some early linear time algorithms were also proposed <ref> [10] </ref>. The biggest improvement over these early algorithms came from the use of coherence: the fact that the collision detection system solves a series of related problems, each one only slightly different than the one before. <p> MERL-TR-97-23 December 1997 2 case in motion planning as well as dynamic simulation. Caching results from previous invocations greatly reduces the amortized cost of collision detection. Gilbert, et. al. describe an adaptation of their algorithm to take advantage of coherence when it exists <ref> [10] </ref>. Coherence is also used in Baraff's witness plane algorithm [3], Cameron's enhancement of the Gilbert algorithm [4], the Lin-Canny closest features algorithm [18, 17], and the V-Clip algorithm [20]. Use of locality often goes hand-in-hand with coherence in many algorithms. <p> Rather than focusing on polyhedral features, some algorithms treat a polyhedron as the convex hull of a point set, and perform operations on simplices defined by subsets of these points. An algorithm designed by Gilbert, Johnson and Keerthi (GJK) was one of the earliest examples of this type <ref> [10] </ref>. Given two polyhedra, GJK searches for a simplex, defined by vertices of the Minkowski difference polyhedron, that either encloses or is nearest to the origin.
Reference: [11] <author> S. Gottschalk, M. C. Lin, and D. Manocha. Obb-tree: </author> <title> A hierarchical structure for rapid interference detection. </title> <booktitle> In Computer Graphics Proceedings, Annual Conference Series, Proceedings of SIGGRAPH 96. ACM SIGGRAPH, </booktitle> <year> 1996. </year>
Reference-contexts: These claims are largely mitigated with a hierarchical hash table based on multiple cell sizes. In passing, we note that Rapid is a very efficient collision detection algorithm based on oriented bounding boxes, that is, boxes boxes that are not axes aligned. See <ref> [11] </ref> for details. 3 Narrow phase collision detection Narrow phase collision detectors more carefully analyze the pairs of objects that are not culled by the broad phase detector. <p> These algorithms also often provide robustness in the presence of modeling errors, such as improperly oriented or missing facets. For example, the Rapid collision detection library, based on the OBB algorithm by Gottschalk, et. al., adeptly handles "polygon soup" <ref> [11] </ref>. Algorithms like Rapid are the best choice in applications such as complex walk through environments.
Reference: [12] <author> James K. Hahn. </author> <title> Realistic animation of rigid bodies. </title> <journal> Computer Graphics, </journal> <volume> 22(4) </volume> <pages> 299-308, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: For this reason, collision detection algorithms must be fast. In the context of rigid-body simulation, Hahn found collision detection often required over 95% of the computation time <ref> [12] </ref>. Algorithms have improved since then, however, they remain a bottleneck in many situations. Collision detection algorithms have roots in computational geometry, where the basic problem is to report intersections among a group of static objects. In motion planning, the problem is more difficult because the objects are moving. <p> These algorithms required running time that was quadratic in the complexity of the polyhedra to determine if the objects were disjoint <ref> [21, 12] </ref>; they are too slow for many motion planning applications. Some early linear time algorithms were also proposed [10]. <p> One solution is to apply detection algorithms to the four-dimensional hyper-polyhedra swept out in space-time [5]. This method is slow and has not seen wide practical use. Most simulation systems simply ignore the problem <ref> [8, 21, 12, 2] </ref>. There is an alternative paradigm for performing collision checks that can reduce the number of collision checks performed, and also prevent missed collisions. It relies on computing a lower bound on the time of impact (TOI) between a pair of objects.
Reference: [13] <author> Brian Von Herzen, Alan H. Barr, and Harold R. Zatz. </author> <title> Geometric collisions for time-dependent parametric surfaces. </title> <booktitle> In Computer Graphics Proceedings, Annual Conference Series, Proceedings of SIGGRAPH 90, </booktitle> <pages> pages 39-48. </pages> <publisher> ACM SIGGRAPH, </publisher> <year> 1990. </year>
Reference-contexts: The conservative bounds force the algorithm to detect collisions in the order they occur, and prevent the system from missing a collision. Other systems have also adopted the scheduling paradigm for collision checking. Von Herzen, et. al. <ref> [13] </ref> present an algorithm that uses Lipschitz bounds to derive limits on how far parts of a parametric surfaces can move over a time interval; their system is guaranteed to catch all collisions. The bounds must be supplied by the user when the surface is defined.
Reference: [14] <author> Philip M. Hubbard. </author> <title> Collision Detection for Interactive Graphics Applications. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Brown University, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: We also restrict attention to exact algorithms: those that ultimately use the underlying polyhedral models in their computations. The alternatives are approximate methods, which are less concerned with the true geometry and more concerned with real-time performance. 1 A good reference list of work in collision detection is in <ref> [14] </ref>. 1.1 Coherence and locality Early collision detection algorithms for moving polyhedral objects solved problem instances from scratch at every time step.
Reference: [15] <author> Philip M. Hubbard. </author> <title> Approximating polyhedra with spheres for time-critical collision detection. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 15(3), </volume> <month> July </month> <year> 1996. </year>
Reference-contexts: This is the usual 1 See, for example, Hubbard's work on collision detection for time-critical applications using bounding sphere hierarchies <ref> [15] </ref>. MERL-TR-97-23 December 1997 2 case in motion planning as well as dynamic simulation. Caching results from previous invocations greatly reduces the amortized cost of collision detection. Gilbert, et. al. describe an adaptation of their algorithm to take advantage of coherence when it exists [10]. <p> Other types of collision detection algorithms are then more suitable, such as those based on oc-trees [1], binary space partitioning trees [22], sphere hierarchies <ref> [15] </ref>, or oriented bounding boxes (OBBs). These algorithms also often provide robustness in the presence of modeling errors, such as improperly oriented or missing facets. For example, the Rapid collision detection library, based on the OBB algorithm by Gottschalk, et. al., adeptly handles "polygon soup" [11]. <p> One problem with this paradigm is that the system might miss collisions. A pathological example is a bullet speeding toward a thin wall; no matter what MERL-TR-97-23 December 1997 20 the minimum sampling period of the collision detection system (the minimum temporal resolution <ref> [15] </ref>), one can choose a bullet speed and wall thickness such that the bullet passes completely through the wall between collision checks. One solution is to apply detection algorithms to the four-dimensional hyper-polyhedra swept out in space-time [5]. This method is slow and has not seen wide practical use.
Reference: [16] <author> M.C. Lin and Dinesh Manocha. </author> <title> Interference detection between curved objects for computer animation. </title> <booktitle> In Models and Techniques in Computer Animation, </booktitle> <pages> pages 431-57. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: system, slowdown is negligible when when polyhedral models of spheres with a few hundred facets are replaced with polyhedral models with over 20,000 facets (over 60,000 features). 3.3 Alternative narrow-phase collision detection algorithms The extension of the basic Lin-Canny algorithm to curved objects has been studied by Lin and Manocha <ref> [16] </ref>. Curved objects are approximated with a polyhedral mesh, and closest points are tracked between these meshes. The closest points on the meshes are projected onto the actual curved surfaces, and a numerical root finding method uses these points as a starting point to locate the true closest points.
Reference: [17] <author> Ming C. Lin. </author> <title> Efficient Collision Detection for Animation and Robotics. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Gilbert, et. al. describe an adaptation of their algorithm to take advantage of coherence when it exists [10]. Coherence is also used in Baraff's witness plane algorithm [3], Cameron's enhancement of the Gilbert algorithm [4], the Lin-Canny closest features algorithm <ref> [18, 17] </ref>, and the V-Clip algorithm [20]. Use of locality often goes hand-in-hand with coherence in many algorithms. This property allows an algorithm to verify that the cached result is still valid using only local geometric tests. Locality usually relies on convexity of the objects. <p> Unfortunately, this is not an efficient solution. MERL-TR-97-23 December 1997 13 3.1 The Lin-Canny closest features algorithm The Lin-Canny closest features algorithm <ref> [17, 18] </ref> is an extremely fast method for tracking the closest features (faces, edges, or vertices) between a pair of convex polyhedra moving through space. The principle behind the algorithm is best described with a two-dimensional example. A fundamental concept in the Lin-Canny algorithm is that of a Voronoi region. <p> A similar results holds if b =2 V (F a ). 2 The fundamental basis of the Lin-Canny algorithm is the converse of Theorem 5, which is true for convex objects (see <ref> [17] </ref> for the proof). Theorem 5 Given non-intersecting convex polygons A and B, let a and b be the closest points between feature F a of A, and feature F b of B, respectively. <p> Now b is still in the Voronoi region of F a , however, 3 For simplicity, degenerate cases where the points are on the boundary of Voronoi regions are ignored here. See <ref> [17] </ref> for more details. MERL-TR-97-23 December 1997 15 a is no longer in the Voronoi region of F b . Specifically, a lies on the wrong side of ray y. <p> The objects in question are polyhedra, the features are vertices, edges, and faces, the Voronoi regions are infinite regions of space bounded by constraint planes rather than rays (Figure 9). The basic algorithm remains the same. For details, see <ref> [17, 18] </ref>. Although designed to track the closest features, the Lin-Canny algorithm is easily extended to a collision detection algorithm. The distance between two polyhedra is computable from simple geometric formulae, given the closest features. The closest points are obtained as a by-product of these calculations.
Reference: [18] <author> Ming C. Lin and John F. Canny. </author> <title> A fast algorithm for incremental distance calculation. </title> <booktitle> In Proceedings of International Conference on Robotics and Automation, </booktitle> <pages> pages 1008-1014. </pages> <publisher> IEEE, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: Gilbert, et. al. describe an adaptation of their algorithm to take advantage of coherence when it exists [10]. Coherence is also used in Baraff's witness plane algorithm [3], Cameron's enhancement of the Gilbert algorithm [4], the Lin-Canny closest features algorithm <ref> [18, 17] </ref>, and the V-Clip algorithm [20]. Use of locality often goes hand-in-hand with coherence in many algorithms. This property allows an algorithm to verify that the cached result is still valid using only local geometric tests. Locality usually relies on convexity of the objects. <p> Unfortunately, this is not an efficient solution. MERL-TR-97-23 December 1997 13 3.1 The Lin-Canny closest features algorithm The Lin-Canny closest features algorithm <ref> [17, 18] </ref> is an extremely fast method for tracking the closest features (faces, edges, or vertices) between a pair of convex polyhedra moving through space. The principle behind the algorithm is best described with a two-dimensional example. A fundamental concept in the Lin-Canny algorithm is that of a Voronoi region. <p> The objects in question are polyhedra, the features are vertices, edges, and faces, the Voronoi regions are infinite regions of space bounded by constraint planes rather than rays (Figure 9). The basic algorithm remains the same. For details, see <ref> [17, 18] </ref>. Although designed to track the closest features, the Lin-Canny algorithm is easily extended to a collision detection algorithm. The distance between two polyhedra is computable from simple geometric formulae, given the closest features. The closest points are obtained as a by-product of these calculations.
Reference: [19] <author> Brian Mirtich. </author> <title> Impulse-based Dynamic Simulation of Rigid Body Systems. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <month> December </month> <year> 1996. </year>
Reference-contexts: Many of the algorithms discussed have implementations in the public domain. Section 5 contains pointers to downloadable code. It is impossible to recommend collision detection algorithms that are best for all applications. The ones emphasized here were effectively used in the Impulse simulation system, described in detail in <ref> [19] </ref>. Impulse places demanding requirements on the collision detection system that are similar to the requirements of many motion planning systems. 2 Broad phase collision detection The function of the broad phase collision detection algorithm is to quickly remove most of the pairs of objects from consideration. <p> Table 1: Comparison of hashing schemes. The table shows the number of cycles spent on broad phase collision detection for four example rigid-body simulations, using both the standard hashing algorithm and the coherence hashing algorithm. The simulations themselves are described in detail in <ref> [19] </ref>. <p> If the objects obey the laws of Newtonian dynamics, one can derive lower bounds on the TOI, based on the current positions and velocities of the objects, and some assumptions about the types of forces acting on them <ref> [19] </ref>. Bounds on robot joint accelerations are also useful for computing lower bounds on the TOI. The basic idea is to schedule collision checks in a priority queue. Each element in the queue corresponds to a particular pair of objects currently subject to narrow phase collision detection.
Reference: [20] <author> Brian Mirtich. V-Clip: </author> <title> fast and robust polyhedral collision detection. </title> <type> Technical Report TR97-05, </type> <institution> Mitsubishi Electric Research Lab, </institution> <address> Cambridge, MA, </address> <month> July </month> <year> 1997. </year>
Reference-contexts: Gilbert, et. al. describe an adaptation of their algorithm to take advantage of coherence when it exists [10]. Coherence is also used in Baraff's witness plane algorithm [3], Cameron's enhancement of the Gilbert algorithm [4], the Lin-Canny closest features algorithm [18, 17], and the V-Clip algorithm <ref> [20] </ref>. Use of locality often goes hand-in-hand with coherence in many algorithms. This property allows an algorithm to verify that the cached result is still valid using only local geometric tests. Locality usually relies on convexity of the objects. <p> In particular, 1. V-Clip handles the penetration case. 2. V-Clip is robust in the presence of degenerate configurations. 3. The code for V-Clip is significantly simpler than that of Lin-Canny. Enhanced GJK also exhibits many of these advantages but usually at the cost of 50-100% more floating point operations <ref> [20] </ref>. 3.4 Nonconvex objects Algorithms for convex polyhedra can be adapted to nonconvex polyhedra by convex decomposition. <p> Details of this scheme may be found in Ponamgi, et. al. [24]. Facilities for performing collision detection between these convex hierarchies are provided in the V-Clip package <ref> [20] </ref>. The strategy described above works well when a convex decomposition is available with a moderate number of pieces, and a hierarchy not more than a few levels deep; it breaks down for utterly nonconvex objects.
Reference: [21] <author> Matthew Moore and Jane Wilhems. </author> <title> Collision detection and response for computer animation. </title> <journal> Computer Graphics, </journal> <volume> 22(4) </volume> <pages> 289-298, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: These algorithms required running time that was quadratic in the complexity of the polyhedra to determine if the objects were disjoint <ref> [21, 12] </ref>; they are too slow for many motion planning applications. Some early linear time algorithms were also proposed [10]. <p> One solution is to apply detection algorithms to the four-dimensional hyper-polyhedra swept out in space-time [5]. This method is slow and has not seen wide practical use. Most simulation systems simply ignore the problem <ref> [8, 21, 12, 2] </ref>. There is an alternative paradigm for performing collision checks that can reduce the number of collision checks performed, and also prevent missed collisions. It relies on computing a lower bound on the time of impact (TOI) between a pair of objects.
Reference: [22] <author> Bruce F. Naylor. </author> <title> Interactive solid modeling via partitioning trees. </title> <booktitle> In Graphics Interface, </booktitle> <pages> pages 11-18, </pages> <month> May </month> <year> 1992. </year> <month> MERL-TR-97-23 December </month> <year> 1997 </year> <month> 24 </month>
Reference-contexts: Other types of collision detection algorithms are then more suitable, such as those based on oc-trees [1], binary space partitioning trees <ref> [22] </ref>, sphere hierarchies [15], or oriented bounding boxes (OBBs). These algorithms also often provide robustness in the presence of modeling errors, such as improperly oriented or missing facets. For example, the Rapid collision detection library, based on the OBB algorithm by Gottschalk, et. al., adeptly handles "polygon soup" [11].
Reference: [23] <author> M. Overmars. </author> <title> Point location in fat subdivisions. </title> <journal> Information Processing Letters, </journal> <volume> 44 </volume> <pages> 261-265, </pages> <year> 1992. </year>
Reference-contexts: Here, a cell is a connected region of space. Overmars presents two solutions to this problem under certain restrictions in the cell shape <ref> [23] </ref>. The more efficient solution involves surrounding each cell by an axes-aligned bounding box, and storing the location of these boxes in a hash table.
Reference: [24] <author> Madhav K. Ponamgi, Dinesh Manocha, and Ming C. Lin. </author> <title> Incremental algorithms for collision detection between solid models. </title> <booktitle> In Proceedings of Third ACM Symposium on Solid Modeling and Applications, </booktitle> <pages> pages 293-304, </pages> <address> New York, May 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The collision detection algorithm proceeds only as far down the tree as necessary to verify disjointness: if the distance to a hull polyhedron is positive, checking stops at the corresponding node, otherwise it proceeds to the node's children. Details of this scheme may be found in Ponamgi, et. al. <ref> [24] </ref>. Facilities for performing collision detection between these convex hierarchies are provided in the V-Clip package [20].
Reference: [25] <author> Rich Rabbitz. </author> <title> Fast collision detection of moving convex polyhedra. </title> <editor> In Paul S. Heckbert, editor, </editor> <booktitle> Graphics Gems IV, </booktitle> <pages> pages 83-109, </pages> <address> Cambridge, 1994. </address> <publisher> Academic Press, Inc. </publisher>
Reference-contexts: If the origin is enclosed, the polyhedra are penetrating, and a measure of the penetration is available. Rabbitz advanced the original GJK algorithm by making better use of coherence <ref> [25] </ref>. Q-Collide is a collision detection library spawned from I-Collide, which replaces Lin-Canny with Rabbitz's algorithm for the low-level distance computation [6]. It shares I-Collide's broad phase detection scheme.
Reference: [26] <author> John M. Snyder, Adam R. Woodbury, Kurt Fleischer, Bena Currin, and Alan H. Barr. </author> <title> Interval methods for multi-point collisions between time-dependent curved surfaces. </title> <booktitle> In Computer Graphics Proceedings, Annual Conference Series, Proceedings of SIGGRAPH 93, </booktitle> <pages> pages 321-333. </pages> <publisher> ACM SIGGRAPH, </publisher> <year> 1993. </year> <month> MERL-TR-97-23 December </month> <year> 1997 </year>
Reference-contexts: The bounds must be supplied by the user when the surface is defined. The algorithm of Snyder, et. al. uses an interval version of Newton's root finding method to achieve the same goal: guaranteeing that the very next collision will be detected <ref> [26] </ref>. Here, Lipschitz bounds are not needed since the exact trajectories of the surfaces over time are input data for the problem. The scheduling scheme can still be used if the computed TOI is not a lower bound on the true TOI but simply an estimate of it.
References-found: 26

