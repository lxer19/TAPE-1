URL: http://www.cs.iastate.edu/tech-reports/TR94-03.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Chambers Leavens Type Checking and Modules for Multi-Methods  
Author: Craig Chambers and Gary T. Leavens Craig Chambers and Gary T. Leavens. 
Keyword: Multi-methods, object-oriented programming, encapsulation, modules, packages, static typechecking, typechecking algorithms, conformance, completeness, and consistency, subtype, inheritance abstract classes, Cecil language.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: A shorter version of this report has been submitted for publication..  1994  
Date: March 1994  
Pubnum: TR #94-03  
Abstract: 1994 CR Categories: D.3.2 [Programming Languages] Language Classifications Object-oriented languages; D.3.3 [Programming Language] Language Constructs and Features Modules, packages; D.3.m [Programming Language] Miscellaneous type systems; F.2.m [Analysis of Algorithms and Problem Complexity] Miscellaneous type checking algorithms; F.3.3 [Logics and Meanings of Programs] Studies of Program Constructs type structure. 
Abstract-found: 1
Intro-found: 1
Reference: [Ada 83] <institution> Reference Manual for the Ada Programming Language, ANSI/MIL-STD 1815A, </institution> <year> 1983. </year>
Reference-contexts: 88, Steele 90, Paepcke 93] and Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in C++, Ada <ref> [Ada 83, Barnes 91] </ref>, and Haskell [Hudak et al. 92].
Reference: [Agrawal et al. 91] <author> Rakesh Agrawal, Linda G. DeMichiel, and Bruce G. Lindsay. </author> <title> Static Type Checking of Multi-Methods. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 113-128, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(11), </note> <month> November, </month> <year> 1991. </year>
Reference-contexts: Section 5 introduces our module mechanism and discusses its impact on the typechecking algorithm. Section 6 offers our conclusions. 2 Related Work 2.1 Type Checking Agrawal, DeMichiel, and Lindsay present a polynomial-time algorithm for typechecking Polyglot, a CLOS-like database type system <ref> [Agrawal et al. 91] </ref>. Their algorithm divides the typechecking problem into two components: checking that the collection of multi-methods comprising a generic function is consistent, and checking that calls of generic functions are type-correct.
Reference: [America 87] <author> Pierre America. </author> <title> Inheritance and Subtyping in a Parallel Object-Oriented Language. </title> <booktitle> In ECOOP 87 Conference Proceedings, </booktitle> <pages> pp. 234-242, </pages> <address> Paris, France, </address> <month> June, </month> <year> 1987. </year> <note> Published as Lecture Notes in Computer Science 276, Springer-Verlag, Berlin, </note> <year> 1987. </year>
Reference-contexts: Snyder 86, Cook et al. 90, Leavens & Weihl 90], and some more recent languages including Cecil, POOL <ref> [America 87, America & van der Linden 90] </ref>, and Strongtalk [Bracha & Griswold 93] do in fact separate the two graphs.
Reference: [America & van der Linden 90] <author> Pierre America and Frank van der Linden. </author> <title> A Parallel Object-Oriented Language with Inheritance and Subtyping. </title> <booktitle> In OOPSLA/ECOOP 90 Conference Proceedings, </booktitle> <pages> pp. 161-168, </pages> <address> Ottawa, Canada, </address> <month> October, </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(10), </note> <month> October, </month> <year> 1990. </year>
Reference-contexts: Snyder 86, Cook et al. 90, Leavens & Weihl 90], and some more recent languages including Cecil, POOL <ref> [America 87, America & van der Linden 90] </ref>, and Strongtalk [Bracha & Griswold 93] do in fact separate the two graphs.
Reference: [Barnes 91] <author> J. G. P. Barnes. </author> <title> Programming in Ada (third edition). </title> <publisher> Addison-Wesley, </publisher> <address> Wokingham, England, </address> <year> 1991. </year>
Reference-contexts: 88, Steele 90, Paepcke 93] and Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in C++, Ada <ref> [Ada 83, Barnes 91] </ref>, and Haskell [Hudak et al. 92].
Reference: [Bobrow et al. 88] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. E. Keene, G. Kiczales, D. A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <journal> In SIGPLAN Notices 23(Special Issue), </journal> <month> September, </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Multiple dispatching of multi-methods as found in CLOS <ref> [Bobrow et al. 88, Steele 90, Paepcke 93] </ref> and Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in
Reference: [Bracha & Griswold 93] <author> Gilad Bracha and David Griswold. Strongtalk: </author> <title> Typechecking Smalltalk in a Production Environment. </title> <booktitle> In OOPSLA 93 Conference Proceedings, </booktitle> <pages> pp. 215-230, </pages> <address> Washington, D.C., </address> <month> September, </month> <year> 1993. </year> <note> Published as SIGPLAN Notices 28(10), </note> <month> October, </month> <year> 1993. </year>
Reference-contexts: Snyder 86, Cook et al. 90, Leavens & Weihl 90], and some more recent languages including Cecil, POOL [America 87, America & van der Linden 90], and Strongtalk <ref> [Bracha & Griswold 93] </ref> do in fact separate the two graphs. Our algorithm allows the type partial order to be specified independently of the code inheritance graph, and the set of legal messages (described by signatures) to be defined independently of the set of multi-method implementations. All arguments are dispatched.
Reference: [Bruce et al. 93] <author> Kim B. Bruce, Jon Crabtree, Thomas P. Mutagh, Robert van Gent, Allyn Dimock, and Robert Muller. </author> <title> Safe and Decidable Type Checking in an Object-Oriented Language. </title> <booktitle> In OOPSLA 93 Conference Proceedings, </booktitle> <pages> pp. 29-46, </pages> <address> Washington, D.C., </address> <month> September, </month> <year> 1993. </year> <note> Published as SIGPLAN Notices 28(10), </note> <month> October, </month> <year> 1993. </year>
Reference-contexts: These two degrees of complexity also appear in singly-dispatched languages, where languages that link subtyping and inheritance make no check of the implicit receiver argument, while languages that separate the two require additional checking in subclasses or place restrictions on inheritance to ensure that subclasses do not misuse inherited methods <ref> [Bruce et al. 93] </ref>. During checking of completeness and consistency, our algorithm deals with the independence of subtyping and code inheritance by passing the signature being checked to all the various subproblems.
Reference: [Canning et al. 89] <author> Peter S. Canning, William R. Cook, Walter L. Hill, and Walter G. Olthoff. </author> <title> Interfaces for Strongly-Typed Object-Oriented Programming. </title> <booktitle> In OOPSLA 89 Conference Proceedings, </booktitle> <pages> pp. 457-467, </pages> <address> New Orleans, LA, </address> <month> October, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year>
Reference-contexts: Our module design supports these various degrees of visibility. Trellis supports these notions except for friends [Schaffert et al. 86] and Eiffel supports public and protected levels of visibility [Meyer 88, Meyer 92]. Canning, Cook, Hill, and Olthoff define a notion of interfaces for languages like Smalltalk <ref> [Canning et al. 89] </ref>. Their notation distinguishes types from classes, as do we, and they are concerned with type checking against such interfaces. They also have an interesting notion of interface inheritance. However, they do not consider multi-methods or encapsulation issues.
Reference: [Cardelli & Wegner 85] <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding Types, Data Abstraction, and Polymorphism. </title> <booktitle> In Computing Surveys 17(4), </booktitle> <pages> pp. 471-522, </pages> <month> December, </month> <year> 1985. </year>
Reference: [Cardelli & Mitchell 89] <author> Luca Cardelli and John C. Mitchell. </author> <title> Operations on Records. </title> <booktitle> In Proceedings of the International Conference on the Mathematical Foundation of Programming Semantics, </booktitle> <address> New Orleans, LA, </address> <year> 1989. </year>
Reference: [Caseau 93] <author> Yves Caseau. </author> <title> Efficient Handling of Multiple Inheritance Hierarchies. </title> <booktitle> In OOPSLA 93 Conference Proceedings, </booktitle> <pages> pp. 271-287, </pages> <address> Washington, D.C., </address> <month> September, </month> <year> 1993. </year> <note> Published as SIGPLAN Notices 28(10), </note> <month> October, </month> <year> 1993. </year>
Reference: [Castagna et al. 92] <author> Giuseppe Castagna, Giorgio Ghelli, and Giuseppe Longo. </author> <title> A Calculus for Overloaded Functions with Subtyping. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 182-192, </pages> <address> San Francisco, </address> <month> June, </month> <year> 1992. </year> <note> Published as Lisp Pointers 5(1), January-March, </note> <year> 1992. </year>
Reference: [Chambers 92] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <booktitle> In ECOOP 92 Conference Proceedings, </booktitle> <pages> pp. 33-56, </pages> <address> Utrecht, the Netherlands, June/July, </address> <year> 1992. </year> <note> Published as Lecture Notes in Computer Science 615, Springer-Verlag, Berlin, </note> <year> 1992. </year>
Reference-contexts: 1 Introduction Multiple dispatching of multi-methods as found in CLOS [Bobrow et al. 88, Steele 90, Paepcke 93] and Cecil <ref> [Chambers 92, Chambers 93] </ref> is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in C++, Ada [Ada 83, Barnes 91], and Haskell [Hudak et <p> This problem was addressed in an earlier paper that described a programming methodology, language design, and programming environment for multi-methods that preserves much of the avor of object-centered programming <ref> [Chambers 92] </ref>. The semantics of multi-method lookup is considered extremely complicated. This problem also was addressed in the earlier paper, where a simple lookup semantics was presented which was based on deriving the partial ordering over methods from the partial ordering over their specializers. <p> In ADT-based or singly-dispatched languages, direct access to an objects representation can be limited to a statically-determined region of the program. An earlier approach to encapsulation in Cecil suffered from the problem that privileged access could always be gained by writing methods that specialized on the desired data structures <ref> [Chambers 92] </ref>. We have developed a module system for Cecil that addresses these shortcomings of existing multi-method languages. This system can restrict access to parts of an implementation to a bounded region of program text while preserving the exibility of multi-methods.
Reference: [Chambers 93] <author> Craig Chambers. </author> <title> The Cecil Language: Specification and Rationale. </title> <type> Technical report #93-03-05, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> March, </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Multiple dispatching of multi-methods as found in CLOS [Bobrow et al. 88, Steele 90, Paepcke 93] and Cecil <ref> [Chambers 92, Chambers 93] </ref> is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in C++, Ada [Ada 83, Barnes 91], and Haskell [Hudak et
Reference: [Cook et al. 90] <author> William Cook, Walter Hill, and Peter Canning. </author> <title> Inheritance is not Subtyping. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January, </month> <year> 1990. </year>
Reference-contexts: Inheritance and subtyping is synonymous in Polyglot. While many common object-oriented languages link code inheritance with subtyping, many researchers have noted that conceptually the two relations are different and more exible and extensible organizations of code can result if the two relations are allowed to be distinct <ref> [e.g. Snyder 86, Cook et al. 90, Leavens & Weihl 90] </ref>, and some more recent languages including Cecil, POOL [America 87, America & van der Linden 90], and Strongtalk [Bracha & Griswold 93] do in fact separate the two graphs.
Reference: [Ghelli 91] <author> Giorgio Ghelli. </author> <title> A Static Type System for Message Passing. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 129-145, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(11), </note> <month> November, </month> <year> 1991. </year>
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation,.Addison-Wesley, </title> <address> Reading, Mass., </address> <year> 1983. </year>
Reference-contexts: 1 Introduction Multiple dispatching of multi-methods as found in CLOS [Bobrow et al. 88, Steele 90, Paepcke 93] and Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk <ref> [Goldberg & Robson 83] </ref> and C++ [Stroustrup 91] or static overloading of functions as found in C++, Ada [Ada 83, Barnes 91], and Haskell [Hudak et al. 92].
Reference: [Goguen 84] <author> Joseph A. Goguen. </author> <title> Parameterized Programming. </title> <journal> In IEEE Transactions on Software Engineering 10(5), </journal> <pages> pp. 528-543, </pages> <month> September, </month> <year> 1984. </year>
Reference-contexts: They also have an interesting notion of interface inheritance. However, they do not consider multi-methods or encapsulation issues. More sophisticated module systems than ours are found in the functional language Standard ML [Milner et al. 90, Paulson 91] and in the equational specification language OBJ2 <ref> [Goguen 84] </ref>. SMLs modules are first-class and can be parameterized. OBJ2s theories are like SMLs signatures (the interfaces to SML modules), but allow for behavioral specifications as well as type information. Both SML and OBJ2 have ways of importing modules that allow for sophisticated kinds of renaming.
Reference: [Gries 91] <author> David Gries. </author> <title> Teaching Calculation and Discrimination: A More Effective Curriculum. </title> <booktitle> In Communications of the ACM 34(3), </booktitle> <pages> pp. 44-55, </pages> <month> March, </month> <year> 1991. </year>
Reference: [Hudak et al. 92] <author> Paul Hudak, Simon Peyton Jones, Philip Wadler, Brian Boutel, Jon Fairbairn, Joseph Fasel, Mara M. Guzmn, Kevin Hammond, John Hughes, Thomas Johnsson, Dick Kieburtz, Rishiyur Nikhil, Will Partain, and John Peterson. </author> <title> Report on the Programming Language Haskell: A Non-strict, Purely Functional Language, Version 1.2. </title> <booktitle> In SIGPLAN Notices 27(5), </booktitle> <month> May, </month> <year> 1992. </year> <title> 23 Typechecking and Modules for Multi-Methods Chambers & Leavens </title>
Reference-contexts: Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in C++, Ada [Ada 83, Barnes 91], and Haskell <ref> [Hudak et al. 92] </ref>. With multiple dispatching, method lookup can depend on the dynamic type or class of any of the arguments to a message, not just the dynamic type of the first as in singly-dispatched systems and not just the arguments static type as in systems with static overloading.
Reference: [Leavens 91] <author> Gary T. Leavens. </author> <title> Modular Specification and Verification of Object-Oriented Programs. </title> <booktitle> IEEE Software 8(4), </booktitle> <pages> pp. 72-80, </pages> <month> July, </month> <year> 1991. </year>
Reference-contexts: This split between checking clients against explicitly imported interfaces and checking extensions of the interface resembles the modularity obtained by the use of legal subtyping in the verification of object-oriented languages with subtyping <ref> [Leavens & Weihl 90, Leavens 91] </ref>. To provide more exact control over the interface seen by extension modules, declarations in a module may be tagged protected.
Reference: [Leavens & Weihl 90] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about Object-Oriented Programs that use Subtypes. </title> <booktitle> In OOPSLA/ECOOP 90 Conference Proceedings, </booktitle> <pages> pp. 212-223, </pages> <address> Ottawa, Canada, </address> <month> October, </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(10), </note> <month> October, </month> <year> 1990. </year>
Reference-contexts: Inheritance and subtyping is synonymous in Polyglot. While many common object-oriented languages link code inheritance with subtyping, many researchers have noted that conceptually the two relations are different and more exible and extensible organizations of code can result if the two relations are allowed to be distinct <ref> [e.g. Snyder 86, Cook et al. 90, Leavens & Weihl 90] </ref>, and some more recent languages including Cecil, POOL [America 87, America & van der Linden 90], and Strongtalk [Bracha & Griswold 93] do in fact separate the two graphs. <p> This split between checking clients against explicitly imported interfaces and checking extensions of the interface resembles the modularity obtained by the use of legal subtyping in the verification of object-oriented languages with subtyping <ref> [Leavens & Weihl 90, Leavens 91] </ref>. To provide more exact control over the interface seen by extension modules, declarations in a module may be tagged protected.
Reference: [Liskov et al. 77] <author> Barbara Liskov, Alan Snyder, Russell Atkinson, and J. Craig Schaffert. </author> <title> Abstraction Mechanisms in CLU. </title> <booktitle> In Communications of the ACM 20(8), </booktitle> <pages> pp. 564-576, </pages> <month> August, </month> <year> 1977. </year>
Reference-contexts: To support careful reasoning and to ease maintenance, a data structures implementation may be encapsulated [Parnas71, Parnas72, Liskov & Zilles 74]. But existing multi-method languages do not provide the same support for encapsulation as abstract data type-based languages such as CLU <ref> [Liskov et al. 77, Liskov et al. 81] </ref> or singly-dispatched object-oriented languages such as C++ and even Smalltalk. In ADT-based or singly-dispatched languages, direct access to an objects representation can be limited to a statically-determined region of the program.
Reference: [Liskov et al. 81] <author> Barbara Liskov, Russell Atkinson, Toby Bloom, Eliot Moss, J. Craig Schaffert, Robert Scheier, and Alan Snyder. </author> <title> CLU Reference Manual. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 114, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1981. </year>
Reference-contexts: To support careful reasoning and to ease maintenance, a data structures implementation may be encapsulated [Parnas71, Parnas72, Liskov & Zilles 74]. But existing multi-method languages do not provide the same support for encapsulation as abstract data type-based languages such as CLU <ref> [Liskov et al. 77, Liskov et al. 81] </ref> or singly-dispatched object-oriented languages such as C++ and even Smalltalk. In ADT-based or singly-dispatched languages, direct access to an objects representation can be limited to a statically-determined region of the program.
Reference: [Liskov & Zilles 74] <author> Barbara H. Liskov and Stephen N. Zilles. </author> <title> Programming with Abstract Data Types. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Very High Level Languages, </booktitle> <pages> pp. 50-59, </pages> <month> April, </month> <year> 1974. </year> <note> Published as SIGPLAN Notices 9(4), </note> <year> 1974. </year>
Reference-contexts: Encapsulation and modularity of multi-methods is a related problem. To support careful reasoning and to ease maintenance, a data structures implementation may be encapsulated <ref> [Parnas71, Parnas72, Liskov & Zilles 74] </ref>. But existing multi-method languages do not provide the same support for encapsulation as abstract data type-based languages such as CLU [Liskov et al. 77, Liskov et al. 81] or singly-dispatched object-oriented languages such as C++ and even Smalltalk.
Reference: [Meyer 88] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1998. </year>
Reference-contexts: Our module design supports these various degrees of visibility. Trellis supports these notions except for friends [Schaffert et al. 86] and Eiffel supports public and protected levels of visibility <ref> [Meyer 88, Meyer 92] </ref>. Canning, Cook, Hill, and Olthoff define a notion of interfaces for languages like Smalltalk [Canning et al. 89]. Their notation distinguishes types from classes, as do we, and they are concerned with type checking against such interfaces. They also have an interesting notion of interface inheritance.
Reference: [Meyer 92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Our module design supports these various degrees of visibility. Trellis supports these notions except for friends [Schaffert et al. 86] and Eiffel supports public and protected levels of visibility <ref> [Meyer 88, Meyer 92] </ref>. Canning, Cook, Hill, and Olthoff define a notion of interfaces for languages like Smalltalk [Canning et al. 89]. Their notation distinguishes types from classes, as do we, and they are concerned with type checking against such interfaces. They also have an interesting notion of interface inheritance.
Reference: [Milner et al. 90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: They also have an interesting notion of interface inheritance. However, they do not consider multi-methods or encapsulation issues. More sophisticated module systems than ours are found in the functional language Standard ML <ref> [Milner et al. 90, Paulson 91] </ref> and in the equational specification language OBJ2 [Goguen 84]. SMLs modules are first-class and can be parameterized. OBJ2s theories are like SMLs signatures (the interfaces to SML modules), but allow for behavioral specifications as well as type information.
Reference: [Mssenbck & Wirth 91] <author> H. Mssenbck and Niklaus Wirth. </author> <booktitle> The Programming Language Oberon-2. Structured Programming 12(4), </booktitle> <year> 1991. </year>
Reference-contexts: Common Lisp does not include static type checking. Encapsulation can be enforced in our module system and our module system cooperates with our static typechecking algorithm. Other object-oriented languages include some form of separate module system, including Modular Smalltalk [Wirfs-Brock & Wilkerson 88], Modula-3 [Nelson 91], and Oberon-2 <ref> [Mssenbck & Wirth 91] </ref>. In Modular Smalltalk, modules provide name space management for class names, and a separate mechanism provides access control for the methods of a class.
Reference: [Mugridge et al. 91] <author> W. B. Mugridge, J. G. Hosking, and J. Hamer. </author> <title> Multi-Methods in a Statically-Typed Programming Language. </title> <type> Technical report #50, </type> <institution> Department of Computer Science, University of Auckland, </institution> <year> 1991. </year> <note> Also appears in ECOOP 91 Conference Proceedings, </note> <institution> Geneva, Switzerland, </institution> <month> July, </month> <year> 1991. </year>
Reference-contexts: As a result, our algorithm includes the standard contravariant method typechecking rules of singly-dispatched languages as a special case. Kea is a higher-order polymorphic functional language supporting multi-methods <ref> [Mugridge et al. 91] </ref>. Like Polyglot, code inheritance and subtyping in Kea are unified. Keas type checking includes the notion that a collection of multi-methods must be exhaustive and unambiguous, and these notions appear in our type system as well.
Reference: [Nelson 91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: Common Lisp does not include static type checking. Encapsulation can be enforced in our module system and our module system cooperates with our static typechecking algorithm. Other object-oriented languages include some form of separate module system, including Modular Smalltalk [Wirfs-Brock & Wilkerson 88], Modula-3 <ref> [Nelson 91] </ref>, and Oberon-2 [Mssenbck & Wirth 91]. In Modular Smalltalk, modules provide name space management for class names, and a separate mechanism provides access control for the methods of a class.
Reference: [Paepcke 93] <author> Andreas Paepcke. </author> <title> Object-Oriented Programming: The CLOS Perspective. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction Multiple dispatching of multi-methods as found in CLOS <ref> [Bobrow et al. 88, Steele 90, Paepcke 93] </ref> and Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in
Reference: [Palsberg & Schwartzbach 94] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-Oriented Type Systems. </title> <publisher> John Wiley & Sons, </publisher> <year> 1994. </year>
Reference: [Parnas 71] <author> D. L. Parnas. </author> <title> Information Distribution Aspects of Design Methodology. </title> <booktitle> Proceedings of IFIP Congress 71. IFIP, </booktitle> <year> 1971. </year>
Reference: [Parnas 72] <author> D. L. Parnas. </author> <title> On the Criteria to be Used in Decomposing Systems into Modules. </title> <booktitle> In Communications of the ACM 15(5), </booktitle> <pages> pp. 330-336, </pages> <month> May, </month> <year> 1972. </year>
Reference: [Paulson 91] <author> Laurence C. Paulson. </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: They also have an interesting notion of interface inheritance. However, they do not consider multi-methods or encapsulation issues. More sophisticated module systems than ours are found in the functional language Standard ML <ref> [Milner et al. 90, Paulson 91] </ref> and in the equational specification language OBJ2 [Goguen 84]. SMLs modules are first-class and can be parameterized. OBJ2s theories are like SMLs signatures (the interfaces to SML modules), but allow for behavioral specifications as well as type information.
Reference: [Pierce & Turner 92] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Statically Typed Multi-Methods via Partially Abstract Types. </title> <type> Unpublished manuscript, </type> <month> October, </month> <year> 1992. </year>
Reference: [Rouaix 90] <author> Francois Rouaix. </author> <title> Safe Run-Time Overloading. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 355-366, </pages> <address> San Francisco, CA, </address> <month> January, </month> <year> 1990. </year>
Reference: [Schaffert et al. 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An Introduction to Trellis/Owl. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 9-16, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Because of C++s friend mechanism, one can write software that has privileged access to more than one type of data, while still textually limiting private access. Our module design supports these various degrees of visibility. Trellis supports these notions except for friends <ref> [Schaffert et al. 86] </ref> and Eiffel supports public and protected levels of visibility [Meyer 88, Meyer 92]. Canning, Cook, Hill, and Olthoff define a notion of interfaces for languages like Smalltalk [Canning et al. 89].
Reference: [Snyder 86] <author> Alan Snyder. </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Languages. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 38-45, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: However, their algorithm depends on a number of assumptions about the language they typecheck: The multi-methods within a generic function can be totally ordered in terms of specificity. Graph-based method lookup semantics found in most object-oriented languages with multiple inheritance <ref> [Snyder 86] </ref>, where the method overriding relationship only forms a partial order, cannot be handled.
Reference: [Steele 90] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language (second edition). </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Multiple dispatching of multi-methods as found in CLOS <ref> [Bobrow et al. 88, Steele 90, Paepcke 93] </ref> and Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ [Stroustrup 91] or static overloading of functions as found in <p> Cardelli & Wegner 85, Cardelli & Mitchell 89, Bruce et al. 93, Palsberg & Schwartzbach 94] only deals with single-dispatching languages. 2.2 Module Systems The only module system for a multi-method-based language of which we are aware is the Common Lisp package system <ref> [Steele 90] </ref>. This system provides name space management only, and users may always circumvent the encapsulation of a package p by writing p::internal_sym. Common Lisp does not include static type checking. Encapsulation can be enforced in our module system and our module system cooperates with our static typechecking algorithm.
Reference: [Stroustrup 91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language (second edition). </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1991. </year>
Reference-contexts: Introduction Multiple dispatching of multi-methods as found in CLOS [Bobrow et al. 88, Steele 90, Paepcke 93] and Cecil [Chambers 92, Chambers 93] is a more general form of message passing (dynamic binding) than traditional single dispatching of receiver-based methods as found in Smalltalk [Goldberg & Robson 83] and C++ <ref> [Stroustrup 91] </ref> or static overloading of functions as found in C++, Ada [Ada 83, Barnes 91], and Haskell [Hudak et al. 92].
Reference: [Szyperski 92] <author> Clemens A. Szyperski. </author> <title> Import is Not Inheritance - Why We Need Both: Modules and Classes. </title> <booktitle> In ECOOP 92 Conference Proceedings, </booktitle> <pages> pp. 19-32, </pages> <address> Utrecht, the Netherlands, June/July, </address> <year> 1992. </year> <note> Published as Lecture Notes in Computer Science 615, Springer-Verlag, Berlin, </note> <year> 1992. </year>
Reference-contexts: Like Common Lisp and Oberon-2, we do not tie the module notion to the notion of classes or types <ref> [Szyperski 92] </ref>. A program is a sequence of one or more modules, one of which is called Main.
Reference: [Touretzky 86] <author> D. Touretzky. </author> <title> The Mathematics of Inheritance Systems. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1986. </year>
Reference-contexts: Because vectors of classes are ordered pointwise, with no priority assigned to the position of the vector element, the specializers of a method are equally important in determining the methods overriding relationships <ref> [Touretzky 86] </ref>. This matches Cecils semantics, but may not match other languages. For example, CLOS prioritizes argument positions with earlier argument orderings completely dominating later argument orderings.
Reference: [Wirfs-Brock & Wilkerson 88] <author> Allen Wirfs-Brock and Brian Wilkerson. </author> <title> An Overview of Modular Smalltalk. </title> <booktitle> In OOPSLA 88 Conference Proceedings, </booktitle> <pages> pp. 123-134, </pages> <address> San Diego, CA, </address> <month> October, </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(11), </note> <month> November, </month> <year> 1988. </year>
Reference-contexts: Common Lisp does not include static type checking. Encapsulation can be enforced in our module system and our module system cooperates with our static typechecking algorithm. Other object-oriented languages include some form of separate module system, including Modular Smalltalk <ref> [Wirfs-Brock & Wilkerson 88] </ref>, Modula-3 [Nelson 91], and Oberon-2 [Mssenbck & Wirth 91]. In Modular Smalltalk, modules provide name space management for class names, and a separate mechanism provides access control for the methods of a class.
Reference: [Wirth 88] <author> Niklaus Wirth. </author> <title> Programming in Modula-2 (fourth edition). </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988. </year> <title> 24 Typechecking and Modules for Multi-Methods Chambers & Leavens </title>
Reference-contexts: A simple check for the presence of the necessary resolving modules is all that is needed at link-time to guarantee type safety. 5.1 Module Basics The core of our module system provides standard name space management, as in Modula-2 <ref> [Wirth 88] </ref>. Like Common Lisp and Oberon-2, we do not tie the module notion to the notion of classes or types [Szyperski 92]. A program is a sequence of one or more modules, one of which is called Main.
References-found: 47

