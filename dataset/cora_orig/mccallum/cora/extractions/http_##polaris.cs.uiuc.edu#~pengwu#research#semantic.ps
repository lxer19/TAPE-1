URL: http://polaris.cs.uiuc.edu/~pengwu/research/semantic.ps
Refering-URL: http://polaris.cs.uiuc.edu/~pengwu/research/
Root-URL: http://www.cs.uiuc.edu
Email: pengwu@uiuc.edu fsmidkiff,jmoreira,mguptag@us.ibm.com  
Title: Improving Java Performance through Semantic Inlining  
Author: Peng Wu Sam Midkiff Jose Moreira Manish Gupta 
Address: P. O. Box 218 Urbana, IL 61801 Yorktown Heights, NY 10598-0218  
Affiliation: Department of Computer Science IBM T. J. Watson Research Center University of Illinois at Urbana-Champaign  
Abstract: This paper describes a new compilation technique called semantic inlining. Unlike traditional lexical inlining, which only incorporates a lexical representation of a method into the calling context, semantic inlining incorporates into the calling context semantic information about the method and its class. This is accomplished by treating selected classes and methods, which are crucial to performance, as primitive data types and primitive operations on those data types. We show that, in our numerical benchmarks which use complex numbers and multidimensional arrays, semantic inlining yields speedups of between 35 and 81, delivering performance between 65% to 90% of Fortran. The speed and effectiveness of semantic inlining make it practical for both static and dynamic compilers, and make it an effective technique for extending the primitive data types and operations of the Java programming language without altering the Java Virtual Machine specification.
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> American National Standards Institute, </institution> <address> New York, New York. </address> <booktitle> American National Standards Programming Language PL/I, </booktitle> <address> X3.53, </address> <year> 1976. </year>
Reference-contexts: However, for Java to become a major programming language in these fields, its implementations must deliver performance comparable to that from more traditional languages, such as Fortran and C. The modern trend in programming language design is to move the complexity from the language (e.g., as in PL/I <ref> [1] </ref>) into class libraries. The benefit of this approach is a cleaner, simpler language, and an extensive collection of (often complicated) standard data types and methods. The downside is that data types and operations that are important in some problem domains are no longer primitives, which adversely affects performance. <p> = new double [m][n]; - public Complex get (int i, int j) return new Complex (re [i][j],im [i][j]); - public void set (int i, int j, Complex z) - re [i][j] = z.re; im [i][j] = z.im; - - 8 A junk im re - ? . . . re <ref> [1] </ref> junk - - junk re [m][1] re [m][2] re [m][n] junk junk re [2][1] re [2][2] re [2][n] junk re [1][1] re [1][2] re [1][n] (a) Reference implementation form of the object.
Reference: [2] <author> M. Cierniak and W. Li. </author> <title> Just-in-time optimization for high-performance Java programs. Concurrency, Pract. Exp. </title> <address> (UK), 9(11):106373, </address> <month> November </month> <year> 1997. </year> <title> Java for Computational Science and Engineering Simulation and Modeling II, </title> <address> Las Vegas, NV, </address> <month> June 21, </month> <year> 1997. </year>
Reference-contexts: O vcomplex (P) " " P vcomplex plus (vcomplex,vcomplex) " " Q vcomplex times (vcomplex,double) O vcomplex (P) " " P 4:0 display (Object) " (c) Expression trees after inlining. 7 A (1 : m; 1 : n) A (1; 1) A (1; 2) A (1; n) A [m] A <ref> [2] </ref> - - A [m][1] A [m][2] A [m][n m ] A [2][1] A [2][2] A [2][n 2 ] (a) m fi n array (b) m array of arrays public final class ComplexArray2D - double [][] re; double [][] im; ComplexArray2D (int m, int n) - re = new double [m][n]; <p> It is unlikely their handling of primitives could do the sort of transformations we perform on multidimensional arrays. They do not do method substitutions to enhance the possibility of optimizations, and do not incorporate semantics from more complicated operations directly into their IL. In <ref> [2] </ref>, Cierniak and Li describe a global analysis technique for determining that the shape of a Java array of arrays is indeed rectangular and not modified. The array representation is then transformed to a dense storage and element access is performed through index arithmetic.
Reference: [3] <author> IBM Corporation. </author> <title> IBM High Performance Compiler for Java, </title> <note> 1997. Information available in Web page at http://simont01.torolab.ibm.com/hpj/hpj.html, available for download at http://www.alphaWorks.ibm.com/formula. </note>
Reference-contexts: It also highlights the freedom the compiler has with semantic inlining in altering both the data representation and operator implementation. Our prototype implementation is based on the IBM High Performance Compiler for Java (HPCJ) <ref> [3, 21] </ref>, which generates native code for different IBM platforms. HPCJ compiles Java class files (bytecodes) into an intermediate stack language called W-code. W-code supports a rich variety of data types, including complex and decimal numbers. W-code, and W-code based optimizers provide a comprehensive optimization and analysis infrastructure.
Reference: [4] <institution> IBM Corporation. IBM San Francisco, </institution> <year> 1998. </year> <note> Information available in Web page at http://http://www.ibm.com/Java/Sanfrancisco. </note>
Reference-contexts: 1 Introduction The Java (TM) 1 programming language, with its portability, extensibility, and expanding programmer base, has drawn serious attention from the technical and commercial computing community, with important applications in these domains already being developed in Java <ref> [4, 13] </ref>. However, for Java to become a major programming language in these fields, its implementations must deliver performance comparable to that from more traditional languages, such as Fortran and C.
Reference: [5] <author> J. Dolby. </author> <title> Automatic inline allocation of objects. </title> <booktitle> In Proc. ACM SIGPLAN'97 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 717, </pages> <year> 1997. </year>
Reference-contexts: Instead, the semantics are used to help data flow analysis and detect parallelizable loops. Their work illustrates how semantic information about standard classes exposes new optimization and parallelization opportunities. The work of Dolby <ref> [5] </ref> (targeting C++) and the work of Hall, et.al. [11] (targeting Haskell) is of interest to us in that it appears to duplicate our results with complex numbers, albeit in a different environment. In [5], aggressive interprocedural analysis identifies all uses of the fields of an object, and cloning creates specialized <p> The work of Dolby <ref> [5] </ref> (targeting C++) and the work of Hall, et.al. [11] (targeting Haskell) is of interest to us in that it appears to duplicate our results with complex numbers, albeit in a different environment. In [5], aggressive interprocedural analysis identifies all uses of the fields of an object, and cloning creates specialized methods for each possible type of a field. This in turn allows the objects themselves to be inlined.
Reference: [6] <author> T. C. Edwards. </author> <title> Foundations for Microstrip Circuit Design. </title> <publisher> John Wiley & Sons, </publisher> <address> Chichester, NY, </address> <year> 1992. </year> <month> 17 </month>
Reference-contexts: Loop nests are arranged in each of the Java and Fortran versions of a benchmark to favor the data layout of the corresponding language. 4.1 MICROSTRIP The MICROSTRIP benchmark [16] computes the value of the potential field (x; y) in a two-dimensional microstrip structure <ref> [6] </ref>.
Reference: [7] <author> Java Grande Forum. </author> <title> Issues in numerical computing with Java. </title> <note> Document available at URL http://math.nist.gov/javanumerics/issues.html, March 1998. </note>
Reference-contexts: Many of the performance deficiencies of object oriented languages relative to procedural languages follow from the treatment of objects. Therefore, the use of lightweight objects is an important class of optimizations enabled by semantic inlining. Several authors <ref> [9, 7] </ref> have advocated the explicit introduction of lightweight objects (also called value objects) in Java. We create lightweight objects only at the IL representation of the program, using them as replacements for regular objects when possible. <p> corresponding formal argument is a regular object, we must apply the conversion O P (obj P ). 2.2 Semantic inlining of Complex In this section we discuss semantic inlining of a Complex class that is part of a proposal by the Java Grande Forum for consideration as a Java standard <ref> [7] </ref>. The Complex class represents a complex number as two doubles, corresponding to the real and imaginary parts. Selected methods from this class are shown in Figure 2. The lightweight representation of an object OBJ of the Complex class is the value complex object obj vcomplex of type vcomplex.
Reference: [8] <author> G. H. Golub and C. F. van Loan. </author> <title> Matrix Computations. Johns Hopkins Series in Mathematical Sciences. </title> <publisher> The Johns Hopkins University Press, </publisher> <year> 1989. </year>
Reference-contexts: The i, j, and k loops are blocked, and the i and j loops are unrolled, to improve performance. LU is a straightforward implementation of Crout's algorithm for performing the LU decomposition of a square matrix A <ref> [8] </ref>, with partial pivoting. The factorization is performed in place and, in the benchmark, A is of size 500 fi 500. FFT computes the discrete Fourier transform of a two-dimensional complex function, represented by an n fi m complex array.
Reference: [9] <author> James Gosling. </author> <title> The evolution of numerical computing in Java. </title> <note> Document available at Web-page http://java.sun.com/people/jag/FP.html. Sun Microsystems. </note>
Reference-contexts: Many of the performance deficiencies of object oriented languages relative to procedural languages follow from the treatment of objects. Therefore, the use of lightweight objects is an important class of optimizations enabled by semantic inlining. Several authors <ref> [9, 7] </ref> have advocated the explicit introduction of lightweight objects (also called value objects) in Java. We create lightweight objects only at the IL representation of the program, using them as replacements for regular objects when possible.
Reference: [10] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java (TM) Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: With regards to bounds checking, the transformations described in [15, 17] can be applied to a two-dimensional rectangular array without the need to pre-compute the minimum length of rows. Also, the privatization of arrays to a thread's working memory <ref> [10] </ref> (a crucial step for thread safety of those transformations with Java arrays) is unnecessary. Aliasing information is easier to extract with multidimensional rectangular arrays.
Reference: [11] <author> C. Hall, S. Peyton-Jones, and P. Sansom. </author> <title> Unboxing using specialisation. </title> <booktitle> In Functional Programming: Workshops in Computing, </booktitle> <year> 1996. </year>
Reference-contexts: Instead, the semantics are used to help data flow analysis and detect parallelizable loops. Their work illustrates how semantic information about standard classes exposes new optimization and parallelization opportunities. The work of Dolby [5] (targeting C++) and the work of Hall, et.al. <ref> [11] </ref> (targeting Haskell) is of interest to us in that it appears to duplicate our results with complex numbers, albeit in a different environment. In [5], aggressive interprocedural analysis identifies all uses of the fields of an object, and cloning creates specialized methods for each possible type of a field. <p> This in turn allows the objects themselves to be inlined. Savings accrue from reducing the number of virtual function dispatches, and from reducing the dereferencing overhead necessary to access objects fields. The techniques in <ref> [11] </ref> allows programmers to specify a base data type (consisting only of the primitive fields of a declared object), and propagate this new type through the methods operating on the declared object.
Reference: [12] <author> N.C. Hutchinson. </author> <title> Emerald: An Object-Based Language for Distributed Programming. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <year> 1987. </year>
Reference-contexts: Given that Fortran represents close to a practical upper bound on the gain from these optimizations, we have achieved most of the potential gain with little compile time complexity. Object representation in the Emerald system is described in <ref> [12] </ref>. Emerald supports distributed objects, and with type inferencing analysis they can determine that objects are local (i.e., not distributed) and can therefore be represented more efficiently. They recognize primitive objects, which are small and immutable.
Reference: [13] <author> M. Jacob, M. Philipsen, and M. Karrenbach. </author> <title> Large-scale parallel geophysical algorithms in Java: A feasibility study. </title> <journal> Concurrency: Practice & Experience, </journal> <volume> 10, </volume> <year> 1998. </year>
Reference-contexts: 1 Introduction The Java (TM) 1 programming language, with its portability, extensibility, and expanding programmer base, has drawn serious attention from the technical and commercial computing community, with important applications in these domains already being developed in Java <ref> [4, 13] </ref>. However, for Java to become a major programming language in these fields, its implementations must deliver performance comparable to that from more traditional languages, such as Fortran and C.
Reference: [14] <author> Sun Microsystems. </author> <title> Sun proposes modification to Java programming languages's floating point specification. </title> <note> http://www.sun.com/smi/Press/sunflash/9803/sunflash.980324.17.html, 1998. </note>
Reference-contexts: in those two benchmarks. (It does not affect MICROSTRIP, FFT, or CFD significantly.) A 13 (a) Memory usage in DC mode (a) Memory usage in AC mode 14 proposal for extending the floating-point semantics of Java, that would allow it to use the fma instruction, is currently under public review <ref> [14] </ref>. 5 Related work Most of the early work on inlining [18] concentrated on lexical inlining of functions and subroutines. Section 2 discusses in some detail the differences between our techniques for semantic inlining and this more traditional lexical inlining.
Reference: [15] <author> S.P. Midkiff, J.E. Moreira, and M. Snir. </author> <title> Optimizing bounds checking in java programs. </title> <journal> IBM Systems Journal, </journal> <volume> 37(3):409453, </volume> <month> August </month> <year> 1998. </year>
Reference-contexts: For compilers that understand their semantics, multidimensional array classes offer more opportunities for optimization than regular Java arrays. Because the shape of an array is rectangular and immutable after its creation, bounds checking optimization and aliasing analysis is greatly facilitated. With regards to bounds checking, the transformations described in <ref> [15, 17] </ref> can be applied to a two-dimensional rectangular array without the need to pre-compute the minimum length of rows. Also, the privatization of arrays to a thread's working memory [10] (a crucial step for thread safety of those transformations with Java arrays) is unnecessary.
Reference: [16] <author> J. E. Moreira and S. P. Midkiff. </author> <title> Fortran 90 in CSE: A case study. </title> <journal> IEEE Computational Science & Engineering, </journal> <volume> 5(2):3949, </volume> <month> April-June </month> <year> 1998. </year>
Reference-contexts: As an example of the performance improvements that can be achieved using semantic inlining, consider the MICROSTRIP benchmark <ref> [16] </ref> (see Section 4 for a detailed analysis of this benchmark). In the DC mode of operation, with computations performed in the real domain, Java performance is approximately 50% of Fortran. <p> Loop nests are arranged in each of the Java and Fortran versions of a benchmark to favor the data layout of the corresponding language. 4.1 MICROSTRIP The MICROSTRIP benchmark <ref> [16] </ref> computes the value of the potential field (x; y) in a two-dimensional microstrip structure [6]. <p> The structure is discretized by an (w + 1) fi (h + 1) mesh and the potential is calculated through the iterative solution of a partial differential equation. (For benchmarking we set w = h = 999 and we use a structure with 4 microstrips, as described in <ref> [16] </ref>.) At each step of the solver, two Jacobi relaxation operations and an error reduction are performed. The key computation in the relaxation is the evaluation of 0 1 ( i+1;j + i1;j + i;j+1 + i;j1 ) (1) for each point (i; j) of the mesh.
Reference: [17] <author> J. E. Moreira, S. P. Midkiff, and M. Gupta. </author> <title> From flop to megaflops: Java for technical computing. </title> <booktitle> In Proceedings of the 11th International Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> LCPC'98, </address> <year> 1998. </year> <note> IBM Research Report 21166. </note>
Reference-contexts: For compilers that understand their semantics, multidimensional array classes offer more opportunities for optimization than regular Java arrays. Because the shape of an array is rectangular and immutable after its creation, bounds checking optimization and aliasing analysis is greatly facilitated. With regards to bounds checking, the transformations described in <ref> [15, 17] </ref> can be applied to a two-dimensional rectangular array without the need to pre-compute the minimum length of rows. Also, the privatization of arrays to a thread's working memory [10] (a crucial step for thread safety of those transformations with Java arrays) is unnecessary. <p> Fortran programs are compiled with a production version of the IBM XLF compiler with the highest level of optimization (-O3 -qhot). Java programs are statically compiled with a development version of the IBM HPCJ compiler and array bounds checking is optimized using the methods 11 described in <ref> [17] </ref>. In accordance to current Java floating-point semantics, the fma (fused multiply-add) instruction of the POWER architecture is disabled for Java programs but enabled for Fortran programs.
Reference: [18] <author> S. Muchnick. </author> <title> Advanced Compiler Design and Implementation. </title> <publisher> Morgan Kaufman, </publisher> <year> 1997. </year>
Reference-contexts: CFD significantly.) A 13 (a) Memory usage in DC mode (a) Memory usage in AC mode 14 proposal for extending the floating-point semantics of Java, that would allow it to use the fma instruction, is currently under public review [14]. 5 Related work Most of the early work on inlining <ref> [18] </ref> concentrated on lexical inlining of functions and subroutines. Section 2 discusses in some detail the differences between our techniques for semantic inlining and this more traditional lexical inlining. Our semantic inlining technique is similar to the approach taken by Fortran compilers in implementing some intrinsic procedures.
Reference: [19] <author> W. H. Press, S. A. Teukolsky, W. T. Vetterling, and B. P. Flannery. </author> <title> Numerical Recipes in FORTRAN: </title> <booktitle> The Art of Scientific Computing. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: The factorization is performed in place and, in the benchmark, A is of size 500 fi 500. FFT computes the discrete Fourier transform of a two-dimensional complex function, represented by an n fi m complex array. We use the Daniel-Lanczos method described in <ref> [19] </ref> to compute the one-dimensional FFTs in the two-dimensional FFT. For our experiments we use n = m = 256. CFD is a kernel from a computational fluid dynamics application. It performs three convolutions between pairs of two-dimensional complex functions.
Reference: [20] <author> Vivek Sarkar. </author> <title> Private conversation, </title> <month> October, </month> <year> 1998. </year>
Reference-contexts: We are currently working on the implementation of lightweight objects for String. By integrating known semantic information about the String class into our compiler, optimizations such as the ones we discussed will be possible <ref> [20] </ref>. 3 An implementation of semantic inlining In this section, we describe a prototype implementation of semantic inlining for the Complex and multidimensional array classes.
Reference: [21] <author> V. Seshadri. </author> <title> IBM high performance compiler for Java. </title> <journal> AIXpert Magazine, </journal> <month> September </month> <year> 1997. </year> <note> Electronic publication available at URL http://www.developer.ibm.com/library/aixpert. </note>
Reference-contexts: It also highlights the freedom the compiler has with semantic inlining in altering both the data representation and operator implementation. Our prototype implementation is based on the IBM High Performance Compiler for Java (HPCJ) <ref> [3, 21] </ref>, which generates native code for different IBM platforms. HPCJ compiles Java class files (bytecodes) into an intermediate stack language called W-code. W-code supports a rich variety of data types, including complex and decimal numbers. W-code, and W-code based optimizers provide a comprehensive optimization and analysis infrastructure.
Reference: [22] <author> Peng Wu and David Padua. </author> <title> Beyond arrays a container-centric approach for paralllelization of real-world symbolic applications. </title> <booktitle> In Proceedings of the 11th International Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> LCPC'98, </address> <year> 1998. </year> <month> 18 </month>
Reference-contexts: Intrinsic procedures can be treated by the Fortran compiler as language primitives. Semantic inlining differs from Fortran's handling of intrinsics in that both new data types and operations on the new data types are treated as language primitives. Work by Peng and Padua <ref> [22] </ref> targets standard container classes for semantic inlining. In their paper, the inlined container semantics are not used for local optimizations or transformations inside the container. Instead, the semantics are used to help data flow analysis and detect parallelizable loops.
References-found: 22

