URL: ftp://ftp.cs.utexas.edu/pub/boyer/ics-reports/cmp32.ps.Z
Refering-URL: ftp://ftp.cs.utexas.edu/pub/boyer/ics-reports/index.html
Root-URL: http://www.cs.utexas.edu
Title: A Fast Majority Vote Algorithm  
Author: J Strother Moore 
Address: Austin, Texas 78712  
Affiliation: Institute for Computing Science and Computer Applications The University of Texas at Austin  
Date: #32  
Pubnum: Technical Report  
Abstract: Institute for Computing Science 2100 Main Building The University of Texas at Austin Austin, Texas 78712 (512) 471-1901 This work was done while the author was in the Computer Science Laboratory of SRI International, Menlo Park, California, 94025. The research reported here was supported in part by NASA Contract NAS1-15528, NSF Grant MCS-7904081, and ONR Contract N00014-75-C-0816. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. S. Boyer and J S. Moore. </author> <title> A Verification Condition Generator for FORTRAN. In The Correctness Problem in Computer Science, </title> <editor> R. S. Boyer and J S. Moore, Eds., </editor> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: The algorithm can then be implemented to poll the delegates in real time (rather than store the votes for batch processing). A FORTRAN version of this algorithm has been mechanically proved correct by the FORTRAN verification system described in <ref> [1] </ref>. In [3], Misra and Gries describe a generalized version of this algorithm that finds the candidates that receive more than n/k votes. They also discuss the complexity of finding repeated elements and show that this algorithm is optimal among algorithms based on comparing candidates. 3
Reference: 2. <author> D. E. Knuth. </author> <title> The Art of Computer Programming. Volume 3/ Searching and Sorting. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, MA, </address> <year> 1973. </year>
Reference-contexts: If the votes can be simply ordered, an algorithm with order n execution time can be coded first to find the median using the Rivest-Tarjan algorithm <ref> [2] </ref> and then to check whether the median received more than half the votes. The Rivest-Tarjan algorithm is bounded above by 5.43 n - 163 comparisons, when n&gt;32. In this paper we describe an algorithm that requires at most 2n comparisons.
Reference: 3. <author> J. Misra and D. Gries. </author> <title> Finding Repeated Elements. </title> <booktitle> In Science of Computer Programming 2, </booktitle> <publisher> North Holland, </publisher> <year> 1982, </year> <pages> pp. 143-152. </pages> <note> Table of Contents </note>
Reference-contexts: The algorithm can then be implemented to poll the delegates in real time (rather than store the votes for batch processing). A FORTRAN version of this algorithm has been mechanically proved correct by the FORTRAN verification system described in [1]. In <ref> [3] </ref>, Misra and Gries describe a generalized version of this algorithm that finds the candidates that receive more than n/k votes. They also discuss the complexity of finding repeated elements and show that this algorithm is optimal among algorithms based on comparing candidates. 3
Reference: 1. <institution> Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 </institution>
Reference-contexts: The algorithm can then be implemented to poll the delegates in real time (rather than store the votes for batch processing). A FORTRAN version of this algorithm has been mechanically proved correct by the FORTRAN verification system described in <ref> [1] </ref>. In [3], Misra and Gries describe a generalized version of this algorithm that finds the candidates that receive more than n/k votes. They also discuss the complexity of finding repeated elements and show that this algorithm is optimal among algorithms based on comparing candidates. 3
Reference: 2. <institution> The Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 </institution>
Reference-contexts: If the votes can be simply ordered, an algorithm with order n execution time can be coded first to find the median using the Rivest-Tarjan algorithm <ref> [2] </ref> and then to check whether the median received more than half the votes. The Rivest-Tarjan algorithm is bounded above by 5.43 n - 163 comparisons, when n&gt;32. In this paper we describe an algorithm that requires at most 2n comparisons.
Reference: 3. <institution> Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 i </institution>
Reference-contexts: The algorithm can then be implemented to poll the delegates in real time (rather than store the votes for batch processing). A FORTRAN version of this algorithm has been mechanically proved correct by the FORTRAN verification system described in [1]. In <ref> [3] </ref>, Misra and Gries describe a generalized version of this algorithm that finds the candidates that receive more than n/k votes. They also discuss the complexity of finding repeated elements and show that this algorithm is optimal among algorithms based on comparing candidates. 3
References-found: 6

