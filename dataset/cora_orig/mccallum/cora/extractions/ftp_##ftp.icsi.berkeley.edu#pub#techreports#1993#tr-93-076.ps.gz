URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1993/tr-93-076.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1993.html
Root-URL: http://www.icsi.berkeley.edu
Email: E-mail: eyalk@cs.technion.ac.il  E-mail: rafail@melody.berkeley.edu.  
Title: Any Non-Private Boolean Function Is Complete For Private Multi-Party Computations  
Author: Eyal Kushilevitz Silvio Micali Rafail Ostrovsky 
Address: Berkeley.  
Note: Research was partially done while the author was at  Supported by research contracts ONR-N0001491-J-1981 and NSF-CCR-90-07677.  Supported by NSF postdoctoral fellowship and ICSI.  
Affiliation: Department of Computer Science, Technion.  Aiken Computation Lab., Harvard University,  Laboratory for Computer Science, MIT. University of California at Berkeley Computer Science Division, and International Computer Science Institute at  
Date: Novemeber, 1993  
Pubnum: TR-93-076  
Abstract: Let g be an n-argument boolean function. Suppose we are given a black-box for g, to which n honest-but-curious players can secretly give inputs and it broadcasts the result of operating g on these inputs to all the players. We say that g is complete (for multi-party private computations) if for every function f, the n players can compute the function f n-privately, given the black-box for g. In this paper, we characterize the boolean functions which are complete: we show that a boolean function g is complete if and only if g itself cannot be computed n-privately (when there is no black-box available). Namely, for boolean functions, the notions of completeness and n-privacy are complementary. On the other hand, for non-boolean functions, we show that this two notions are not complementary. Our result can be viewed as a generalization (for multi-party protocols and for (n 2)-argument functions) of the two-party case, where it was known that two-argument functions which contain "embedded-OR" are complete. 
Abstract-found: 1
Intro-found: 1
Reference: [BB-89] <author> Bar-Ilan J., and D. Beaver, </author> <title> Non-Cryptographic Fault-Tolerant Computing in a Constant Number of Rounds, </title> <booktitle> Proc. of 8th ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1989, </year> <pages> pp. 201-209. </pages>
Reference-contexts: The first general protocol for secure computation were given in [Yao-82, Yao-86] for the two-party case, and by [GMW-87] for the multi-party case. Other solutions were given in, e.g., <ref> [GHY-87, GV-87, BGW-88, CCD-88, BB-89, RB-89] </ref> based on various assumptions (either intractability assumptions or the existence of private (untappable) communication channels between each pair of players). These solutions give t-privacy for t &lt; 1 2 3 depending on the assumption made. Secure computation for honest-but-curious players. <p> In our setting, we do not put any computational restrictions on the power of the players, hence the notion of privacy is information-theoretic. 1 Information-theoretic privacy was examined by [BGW-88, CCD-88] which prove that every function is n=2-private, and was then the subject of considerable work (e.g., <ref> [CKu-89, CGK-92, BB-89, CGK-90] </ref>). Particularly, [CKu-89] have succeeded in characterizing the 1 This is in oppose to other works, e.g, [GMW-87], that give computational-privacy.
Reference: [BGW-88] <author> Ben-or M., S. Goldwasser, and A. Wigderson, </author> <title> Completeness Theorems for Non-Cryptographic Fault-Tolerant Distributed Computation, </title> <booktitle> Proc. of 20th STOC, </booktitle> <year> 1988, </year> <pages> pp. 1-10. </pages>
Reference-contexts: The first general protocol for secure computation were given in [Yao-82, Yao-86] for the two-party case, and by [GMW-87] for the multi-party case. Other solutions were given in, e.g., <ref> [GHY-87, GV-87, BGW-88, CCD-88, BB-89, RB-89] </ref> based on various assumptions (either intractability assumptions or the existence of private (untappable) communication channels between each pair of players). These solutions give t-privacy for t &lt; 1 2 3 depending on the assumption made. Secure computation for honest-but-curious players. <p> The honest-but-curious scenario is not only interesting on its own (e.g., for modeling security against outside listeners). Its importance also stems from compiler-type theorems, such as the one proved by [GMW-87] (with further extensions in many subsequent papers, for example, <ref> [BGW-88, CCD-88, RB-89] </ref>). Namely, there are algorithms transforming t-private protocol with respect to honest-but-curious players into a t`-private protocol with respect to malicious players (t` t). <p> In this paper we examine the latter setting. Information Theoretic Privacy. In our setting, we do not put any computational restrictions on the power of the players, hence the notion of privacy is information-theoretic. 1 Information-theoretic privacy was examined by <ref> [BGW-88, CCD-88] </ref> which prove that every function is n=2-private, and was then the subject of considerable work (e.g., [CKu-89, CGK-92, BB-89, CGK-90]). Particularly, [CKu-89] have succeeded in characterizing the 1 This is in oppose to other works, e.g, [GMW-87], that give computational-privacy. <p> We remark, that one can relax the above definition of privacy to require only statistical indistinguishability of distributions or only computational indistinguishability of distributions. For these definitions we refer the reader to the papers mentioned in the introduction (e.g., <ref> [GMW-87, BGW-88, CKu-89] </ref>). 6 It follows from the construction that without loss of generality the sequence of permutations can be made oblivious at a price of O (n 2 ). <p> At this point we already get the following corollary: Corollary 1 Let g be a non-n-private Boolean function. Given a black-box g, it is possible to compute any function f b (n 1)=2c-privately. Proof: We use the protocols of <ref> [BGW-88, CCD-88] </ref> that can compute any function f b (n 1)=2c-privately, assuming the existence of point-to-point communication channels, and we simulate these channels using the above lemma. <p> Notice, however, that under the appropriate definition of the model, if we are given as a black-box the two-argument OR function we can still implement private channels, and hence by <ref> [BGW-88, CCD-88] </ref> can implement any f , n=3-privately with respect to Byzantine players.
Reference: [B-86] <author> Blum M., </author> <title> Applications of Oblivious Transfer, </title> <type> Unpublished manuscript. </type>
Reference-contexts: It was first defined by Rabin [R-81] and was then studied in many works (e.g., [R-81, FMR-85, OVY-90, IL-89, K-88, K-91]). The variant of OT protocol that we use here was originally defined in [EGL-85]. It was shown equivalent to other notions of OT (see, for example <ref> [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91] </ref>). Definition 4 Oblivious Transfer (OT): Let k be a security parameter. The Sender S initially has two bits b 0 and b 1 and the Receiver R has a selection bit c.
Reference: [BCC-88] <author> G. Brassard, D. Chaum and C. Crepeau, </author> <title> Minimum Disclosure Proofs of Knowledge, </title> <journal> JCSS, v. </journal> <volume> 37, </volume> <pages> pp 156-189. </pages>
Reference: [BCR-86] <author> G. Brassard, C. Crepeau and J.-M. Robert, </author> <title> Information Theoretic Reductions among Disclosure Problems, </title> <booktitle> IEEE Symp. on Foundations of Computer Science, 1986 pp. </booktitle> <pages> 168-173. </pages>
Reference-contexts: It was first defined by Rabin [R-81] and was then studied in many works (e.g., [R-81, FMR-85, OVY-90, IL-89, K-88, K-91]). The variant of OT protocol that we use here was originally defined in [EGL-85]. It was shown equivalent to other notions of OT (see, for example <ref> [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91] </ref>). Definition 4 Oblivious Transfer (OT): Let k be a security parameter. The Sender S initially has two bits b 0 and b 1 and the Receiver R has a selection bit c.
Reference: [BG-89] <author> D. Beaver, S. </author> <title> Goldwasser Multiparty Computation with Faulty Majority, </title> <booktitle> FOCS 1989. </booktitle>
Reference-contexts: It should be emphasized that OT in a multi-party setting has the additional requirement that listeners will not get any information. This additional requirement is handled by the implementation of the private channels. Finally, it follows from the work of <ref> [GHY-87, GV-87, BG-89] </ref> that a n-private computation of any function f can be implemented given private channels and OT. All together, our main theorem follows. 1.1 Organization of the paper In section 2 we specify our model and definitions. <p> It is based on a protocol that can tolerate n 1 "curious" players, assuming the existence of OT-channels, private channels and a broadcast channel. Such a protocol can be obtained by combining results from <ref> [GHY-87, GV-87, BG-89] </ref> (these works deal also with Byzantine players). Both the protocol and proof of security appear in appendix B.
Reference: [CCD-88] <author> Chaum, D., C. Crepeau, and I. Damgard, </author> <title> Multiparty Unconditionally Secure Protocols Proc. </title> <booktitle> of 20th STOC, </booktitle> <year> 1988, </year> <pages> pp. 11-19. </pages>
Reference-contexts: The first general protocol for secure computation were given in [Yao-82, Yao-86] for the two-party case, and by [GMW-87] for the multi-party case. Other solutions were given in, e.g., <ref> [GHY-87, GV-87, BGW-88, CCD-88, BB-89, RB-89] </ref> based on various assumptions (either intractability assumptions or the existence of private (untappable) communication channels between each pair of players). These solutions give t-privacy for t &lt; 1 2 3 depending on the assumption made. Secure computation for honest-but-curious players. <p> The honest-but-curious scenario is not only interesting on its own (e.g., for modeling security against outside listeners). Its importance also stems from compiler-type theorems, such as the one proved by [GMW-87] (with further extensions in many subsequent papers, for example, <ref> [BGW-88, CCD-88, RB-89] </ref>). Namely, there are algorithms transforming t-private protocol with respect to honest-but-curious players into a t`-private protocol with respect to malicious players (t` t). <p> In this paper we examine the latter setting. Information Theoretic Privacy. In our setting, we do not put any computational restrictions on the power of the players, hence the notion of privacy is information-theoretic. 1 Information-theoretic privacy was examined by <ref> [BGW-88, CCD-88] </ref> which prove that every function is n=2-private, and was then the subject of considerable work (e.g., [CKu-89, CGK-92, BB-89, CGK-90]). Particularly, [CKu-89] have succeeded in characterizing the 1 This is in oppose to other works, e.g, [GMW-87], that give computational-privacy. <p> At this point we already get the following corollary: Corollary 1 Let g be a non-n-private Boolean function. Given a black-box g, it is possible to compute any function f b (n 1)=2c-privately. Proof: We use the protocols of <ref> [BGW-88, CCD-88] </ref> that can compute any function f b (n 1)=2c-privately, assuming the existence of point-to-point communication channels, and we simulate these channels using the above lemma. <p> Notice, however, that under the appropriate definition of the model, if we are given as a black-box the two-argument OR function we can still implement private channels, and hence by <ref> [BGW-88, CCD-88] </ref> can implement any f , n=3-privately with respect to Byzantine players.
Reference: [CKu-89] <author> B. Chor, E. </author> <note> Kushilevitz A Zero-One Law for Boolean Privacy STOC 21 (1989) 62-72. Journal version in SIAM J. Disc. Math. 4 (1991) 36-47. </note>
Reference-contexts: In our setting, we do not put any computational restrictions on the power of the players, hence the notion of privacy is information-theoretic. 1 Information-theoretic privacy was examined by [BGW-88, CCD-88] which prove that every function is n=2-private, and was then the subject of considerable work (e.g., <ref> [CKu-89, CGK-92, BB-89, CGK-90] </ref>). Particularly, [CKu-89] have succeeded in characterizing the 1 This is in oppose to other works, e.g, [GMW-87], that give computational-privacy. <p> Particularly, <ref> [CKu-89] </ref> have succeeded in characterizing the 1 This is in oppose to other works, e.g, [GMW-87], that give computational-privacy. <p> That is, we show that there are (non-boolean) functions which are not n-private, yet are not complete. Sub-contributions. As mentioned, the special case of two-party computations and two-argument functions is implicit in previous works: <ref> [Ku-89, CKu-89] </ref> showed that if a two-argument function is not private then it contains an embedded-OR 3 . [K-91] showed that if a two-argument function g contains an embedded-OR then with a black-box for g it is possible to implement an Oblivious Transfer (OT) 4 . <p> We appropriately generalize the notion of embedded-OR for n-argument functions. We then show that if an n-argument function is not private then it contains an embedded OR (this does not follow from the characterization of <ref> [CKu-89] </ref>). 2. We show that if an n-argument function g (boolean or not boolean) contains an embedded-OR then with a black-box for g it is possible to implement private channels between any two players. 3. <p> We remark, that one can relax the above definition of privacy to require only statistical indistinguishability of distributions or only computational indistinguishability of distributions. For these definitions we refer the reader to the papers mentioned in the introduction (e.g., <ref> [GMW-87, BGW-88, CKu-89] </ref>). 6 It follows from the construction that without loss of generality the sequence of permutations can be made oblivious at a price of O (n 2 ). <p> The following facts are proven in <ref> [CKu-89] </ref> (or follow trivially from it): 1. <p> This implies that all functions are n-private (as instead of using the black-box g the players can evaluate g by using the n-private protocol for it). This however contradicts the results of <ref> [CKu-89] </ref> that shows that most functions are not n-private. It is important to note that this negative result of [CKu-89] does not depend on the running time of the protocol, and it allows a probability of error. 10 10 This impossibility result holds even if we allow the players to communicate <p> This however contradicts the results of <ref> [CKu-89] </ref> that shows that most functions are not n-private. It is important to note that this negative result of [CKu-89] does not depend on the running time of the protocol, and it allows a probability of error. 10 10 This impossibility result holds even if we allow the players to communicate not only using the black-box but also using broadcast channel and point-to-point communication channels. 12 ((=) Next (and this <p> Combining these lemmas we get the result. (We remark that the proof of Lemma 4 utilizes Lemma 3.) The theorem implies that "most" boolean functions are complete! That is, any function which is not of the XOR-form of <ref> [CKu-89] </ref> is complete. 7 Conclusions and further extensions 7.1 Non-boolean functions We have shown that any non-n-private boolean function g is complete. Namely, a black-box g can be used for computing any function f in a totally private way. Finally, let us turn our attention to non-boolean functions.
Reference: [CGK-90] <author> B. Chor, M. Gereb-Graus, and E. Kushilevitz, </author> <title> Private Computations Over the Integers, </title> <booktitle> FOCS 90, </booktitle> <pages> pp. 335-344. </pages>
Reference-contexts: In our setting, we do not put any computational restrictions on the power of the players, hence the notion of privacy is information-theoretic. 1 Information-theoretic privacy was examined by [BGW-88, CCD-88] which prove that every function is n=2-private, and was then the subject of considerable work (e.g., <ref> [CKu-89, CGK-92, BB-89, CGK-90] </ref>). Particularly, [CKu-89] have succeeded in characterizing the 1 This is in oppose to other works, e.g, [GMW-87], that give computational-privacy.
Reference: [CGK-92] <author> B. Chor, M. Gereb-Graus, and E. Kushilevitz, </author> <title> On the Structure of the Privacy Hierarchy, </title> <note> To appear in Journal of Cryptology. </note>
Reference-contexts: In our setting, we do not put any computational restrictions on the power of the players, hence the notion of privacy is information-theoretic. 1 Information-theoretic privacy was examined by [BGW-88, CCD-88] which prove that every function is n=2-private, and was then the subject of considerable work (e.g., <ref> [CKu-89, CGK-92, BB-89, CGK-90] </ref>). Particularly, [CKu-89] have succeeded in characterizing the 1 This is in oppose to other works, e.g, [GMW-87], that give computational-privacy.
Reference: [C-87] <author> C. Crepeau, </author> <title> Equivalence between Two Flavors of Oblivious Transfer, </title> <type> Crypto 87. </type>
Reference-contexts: It was first defined by Rabin [R-81] and was then studied in many works (e.g., [R-81, FMR-85, OVY-90, IL-89, K-88, K-91]). The variant of OT protocol that we use here was originally defined in [EGL-85]. It was shown equivalent to other notions of OT (see, for example <ref> [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91] </ref>). Definition 4 Oblivious Transfer (OT): Let k be a security parameter. The Sender S initially has two bits b 0 and b 1 and the Receiver R has a selection bit c.
Reference: [CK-88] <author> C. Crepeau, J. </author> <title> Kilian Achieving Oblivious Transfer Using Weakened Security Assumptions , Proc. </title> <booktitle> IEEE Symp. on Foundations of Computer Science, </booktitle> <year> 1988. </year>
Reference-contexts: It was first defined by Rabin [R-81] and was then studied in many works (e.g., [R-81, FMR-85, OVY-90, IL-89, K-88, K-91]). The variant of OT protocol that we use here was originally defined in [EGL-85]. It was shown equivalent to other notions of OT (see, for example <ref> [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91] </ref>). Definition 4 Oblivious Transfer (OT): Let k be a security parameter. The Sender S initially has two bits b 0 and b 1 and the Receiver R has a selection bit c. <p> The resulting protocol would be more efficient in terms of communication complexity but the proof that the protocol is private becomes much more involved. Thus, in this extended abstract, we preset a less efficient, but simpler proof. 11 Proof: We start with an OT protocol of <ref> [K-91, CK-88] </ref>.
Reference: [EGL-85] <author> S. Even, O. Goldreich and A. Lempel, </author> <title> A Randomized Protocol for Signing Contracts, </title> <journal> Comm. of ACM v. </journal> <volume> 28, </volume> <pages> 1985 pp. 637-647. </pages>
Reference-contexts: It was first defined by Rabin [R-81] and was then studied in many works (e.g., [R-81, FMR-85, OVY-90, IL-89, K-88, K-91]). The variant of OT protocol that we use here was originally defined in <ref> [EGL-85] </ref>. It was shown equivalent to other notions of OT (see, for example [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91]). Definition 4 Oblivious Transfer (OT): Let k be a security parameter. <p> It was first defined by Rabin [R-81] and was then studied in many works (e.g., [R-81, FMR-85, OVY-90, IL-89, K-88, K-91]). The variant of OT protocol that we use here was originally defined in [EGL-85]. It was shown equivalent to other notions of OT (see, for example <ref> [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91] </ref>). Definition 4 Oblivious Transfer (OT): Let k be a security parameter. The Sender S initially has two bits b 0 and b 1 and the Receiver R has a selection bit c.
Reference: [FMR-85] <author> Fischer M., S. Micali, C. </author> <title> Rackoff An Oblivious Transfer Protocol Equivalent to Factoring, </title> <type> Manuscript. </type>
Reference-contexts: Oblivious Transfer is a protocol for two players S, the Sender , and R, the Receiver. It was first defined by Rabin [R-81] and was then studied in many works (e.g., <ref> [R-81, FMR-85, OVY-90, IL-89, K-88, K-91] </ref>). The variant of OT protocol that we use here was originally defined in [EGL-85]. It was shown equivalent to other notions of OT (see, for example [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91]).
Reference: [GHY-87] <author> Z. Galil, S, Haber, and M. Yung, </author> <title> Cryptographic Computation: Secure Fault-Tolerant Protocols and the Public-Key Model, </title> <booktitle> CRYPTO, </booktitle> <year> 1987. </year>
Reference-contexts: The first general protocol for secure computation were given in [Yao-82, Yao-86] for the two-party case, and by [GMW-87] for the multi-party case. Other solutions were given in, e.g., <ref> [GHY-87, GV-87, BGW-88, CCD-88, BB-89, RB-89] </ref> based on various assumptions (either intractability assumptions or the existence of private (untappable) communication channels between each pair of players). These solutions give t-privacy for t &lt; 1 2 3 depending on the assumption made. Secure computation for honest-but-curious players. <p> It should be emphasized that OT in a multi-party setting has the additional requirement that listeners will not get any information. This additional requirement is handled by the implementation of the private channels. Finally, it follows from the work of <ref> [GHY-87, GV-87, BG-89] </ref> that a n-private computation of any function f can be implemented given private channels and OT. All together, our main theorem follows. 1.1 Organization of the paper In section 2 we specify our model and definitions. <p> It is based on a protocol that can tolerate n 1 "curious" players, assuming the existence of OT-channels, private channels and a broadcast channel. Such a protocol can be obtained by combining results from <ref> [GHY-87, GV-87, BG-89] </ref> (these works deal also with Byzantine players). Both the protocol and proof of security appear in appendix B.
Reference: [GMW-87] <author> O. Goldreich, S. Micali and A. Wigderson, </author> <title> How to Play any Mental Game , Proc. </title> <booktitle> ACM Symp. on Theory of Computing, </booktitle> <year> 1987. </year>
Reference-contexts: Byzantine) players and honest-but-curios players: Secure Computation for malicious players. Malicious players can deviate from the prescribed protocol in an arbitrary manner, in order to violate the correctness and privacy constraints. The first general protocol for secure computation were given in [Yao-82, Yao-86] for the two-party case, and by <ref> [GMW-87] </ref> for the multi-party case. Other solutions were given in, e.g., [GHY-87, GV-87, BGW-88, CCD-88, BB-89, RB-89] based on various assumptions (either intractability assumptions or the existence of private (untappable) communication channels between each pair of players). <p> The honest-but-curious scenario is not only interesting on its own (e.g., for modeling security against outside listeners). Its importance also stems from compiler-type theorems, such as the one proved by <ref> [GMW-87] </ref> (with further extensions in many subsequent papers, for example, [BGW-88, CCD-88, RB-89]). Namely, there are algorithms transforming t-private protocol with respect to honest-but-curious players into a t`-private protocol with respect to malicious players (t` t). <p> Particularly, [CKu-89] have succeeded in characterizing the 1 This is in oppose to other works, e.g, <ref> [GMW-87] </ref>, that give computational-privacy. <p> Completeness for secure computation. Sometimes, instead of giving an explicit t-private protocol for evaluating a function f , one can show that a protocol is reducible to an implementation of some other, simpler protocol. In <ref> [R-81, Yao-82, GMW-87] </ref> first such results were shown based on some assumptions. In particular, [GMW-87] gave the first such result for a multi-party protocols, assuming the existence of a one-way function. <p> Completeness for secure computation. Sometimes, instead of giving an explicit t-private protocol for evaluating a function f , one can show that a protocol is reducible to an implementation of some other, simpler protocol. In [R-81, Yao-82, GMW-87] first such results were shown based on some assumptions. In particular, <ref> [GMW-87] </ref> gave the first such result for a multi-party protocols, assuming the existence of a one-way function. <p> We remark, that one can relax the above definition of privacy to require only statistical indistinguishability of distributions or only computational indistinguishability of distributions. For these definitions we refer the reader to the papers mentioned in the introduction (e.g., <ref> [GMW-87, BGW-88, CKu-89] </ref>). 6 It follows from the construction that without loss of generality the sequence of permutations can be made oblivious at a price of O (n 2 ). <p> (which is computationally n-private) of any (information-theoretically) non-n-private complete function implies the existence of a one-way function (basically, since we have shown that it is equivalent to the implementation of OT, which implies a one-way function by [IL-89].) The best-known implementations of OT for polynomially-bounded players requires trapdoor one-way permutations <ref> [GMW-87] </ref>, and [IR-89] have shown that if using black-box reductions, then implementing OT for polynomially-bounded players using one-way permutations (without trapdoor) is as difficult as separating P from N P. Thus, using black-box reductions, complete functions are hard to implement (with computational privacy) without a trapdoor property.
Reference: [GV-87] <author> O. Goldreich, and R. Vainish, </author> <title> How to Solve any Protocol Problem An efficiency Improvement, </title> <type> CRYPTO 87. </type>
Reference-contexts: The first general protocol for secure computation were given in [Yao-82, Yao-86] for the two-party case, and by [GMW-87] for the multi-party case. Other solutions were given in, e.g., <ref> [GHY-87, GV-87, BGW-88, CCD-88, BB-89, RB-89] </ref> based on various assumptions (either intractability assumptions or the existence of private (untappable) communication channels between each pair of players). These solutions give t-privacy for t &lt; 1 2 3 depending on the assumption made. Secure computation for honest-but-curious players. <p> It should be emphasized that OT in a multi-party setting has the additional requirement that listeners will not get any information. This additional requirement is handled by the implementation of the private channels. Finally, it follows from the work of <ref> [GHY-87, GV-87, BG-89] </ref> that a n-private computation of any function f can be implemented given private channels and OT. All together, our main theorem follows. 1.1 Organization of the paper In section 2 we specify our model and definitions. <p> It is based on a protocol that can tolerate n 1 "curious" players, assuming the existence of OT-channels, private channels and a broadcast channel. Such a protocol can be obtained by combining results from <ref> [GHY-87, GV-87, BG-89] </ref> (these works deal also with Byzantine players). Both the protocol and proof of security appear in appendix B.
Reference: [GMR-85] <author> S. Goldwasser, S. Micali and C. Rackoff, </author> <title> The Knowledge Complexity of Interactive Proof-Systems, </title> <booktitle> Proc. ACM Symp. on Theory of Computing, </booktitle> <pages> pp. </pages> <month> 291-304 </month> <year> 1985. </year>
Reference: [IL-89] <author> R. Impagliazzo and M. Luby, </author> <title> One-way Functions are Essential for Complexity-Based Cryptography Proc. </title> <booktitle> IEEE Symp. on Foundations of Computer Science, </booktitle> <year> 1989. </year> <month> 15 </month>
Reference-contexts: Oblivious Transfer is a protocol for two players S, the Sender , and R, the Receiver. It was first defined by Rabin [R-81] and was then studied in many works (e.g., <ref> [R-81, FMR-85, OVY-90, IL-89, K-88, K-91] </ref>). The variant of OT protocol that we use here was originally defined in [EGL-85]. It was shown equivalent to other notions of OT (see, for example [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91]). <p> in a computational sense then it is possible to show that an implementation (which is computationally n-private) of any (information-theoretically) non-n-private complete function implies the existence of a one-way function (basically, since we have shown that it is equivalent to the implementation of OT, which implies a one-way function by <ref> [IL-89] </ref>.) The best-known implementations of OT for polynomially-bounded players requires trapdoor one-way permutations [GMW-87], and [IR-89] have shown that if using black-box reductions, then implementing OT for polynomially-bounded players using one-way permutations (without trapdoor) is as difficult as separating P from N P.
Reference: [IR-89] <author> R. Impagliazzo and S. Rudich, </author> <title> On the Limitations of certain One-Way Permutations, </title> <booktitle> Proc. ACM Symp. on Theory of Computing, </booktitle> <pages> pp 44-61, </pages> <year> 1989. </year>
Reference-contexts: computationally n-private) of any (information-theoretically) non-n-private complete function implies the existence of a one-way function (basically, since we have shown that it is equivalent to the implementation of OT, which implies a one-way function by [IL-89].) The best-known implementations of OT for polynomially-bounded players requires trapdoor one-way permutations [GMW-87], and <ref> [IR-89] </ref> have shown that if using black-box reductions, then implementing OT for polynomially-bounded players using one-way permutations (without trapdoor) is as difficult as separating P from N P. Thus, using black-box reductions, complete functions are hard to implement (with computational privacy) without a trapdoor property. <p> An interesting open question to study is the complexity assumptions needed to implement polynomial-time protocols for computing (with computational privacy) functions which are non-n-private and, at the same time, are not complete, as the results <ref> [IR-89] </ref> do not apply to this case, yet, the best known polynomially-bounded implementation still seems to require a trapdoor one-way permutation. Acknowledgments We wish to thank Oded Goldreich for helpful discussions.
Reference: [K-88] <author> J. Kilian, </author> <booktitle> Basing Cryptography on Oblivious Transfer , Proc. ACM Symp. on Theory of Computing, </booktitle> <pages> pp 20-31, </pages> <year> 1988. </year>
Reference-contexts: In [R-81, Yao-82, GMW-87] first such results were shown based on some assumptions. In particular, [GMW-87] gave the first such result for a multi-party protocols, assuming the existence of a one-way function. Without additional assumptions, a stronger result was established in <ref> [K-88, K-91] </ref> for two-party protocols: most generally, [K-91] shows that any two-argument function with an embedded-OR (to be discussed later) is complete for two-party secure computation. No result of this generality is, unfortunately, known for the multi-party scenario. Our Contribution. <p> Finally, <ref> [K-88] </ref> showed that a black-box for OT is sufficient for computing any two-argument function privately; The combination 2 Which player submits which argument is a permutation specified by the protocol. 3 A function g (i; j) contains an embedded-OR if (9i 0 ; i 1 ; j 0 ; j 1 <p> Oblivious Transfer is a protocol for two players S, the Sender , and R, the Receiver. It was first defined by Rabin [R-81] and was then studied in many works (e.g., <ref> [R-81, FMR-85, OVY-90, IL-89, K-88, K-91] </ref>). The variant of OT protocol that we use here was originally defined in [EGL-85]. It was shown equivalent to other notions of OT (see, for example [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91]). <p> It was first defined by Rabin [R-81] and was then studied in many works (e.g., [R-81, FMR-85, OVY-90, IL-89, K-88, K-91]). The variant of OT protocol that we use here was originally defined in [EGL-85]. It was shown equivalent to other notions of OT (see, for example <ref> [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91] </ref>). Definition 4 Oblivious Transfer (OT): Let k be a security parameter. The Sender S initially has two bits b 0 and b 1 and the Receiver R has a selection bit c.
Reference: [K-91] <author> J. Kilian, </author> <title> Completeness Theorem for Two-party Secure Computation , Proc. </title> <booktitle> ACM Symp. on Theory of Computing, </booktitle> <year> 1991. </year>
Reference-contexts: In [R-81, Yao-82, GMW-87] first such results were shown based on some assumptions. In particular, [GMW-87] gave the first such result for a multi-party protocols, assuming the existence of a one-way function. Without additional assumptions, a stronger result was established in <ref> [K-88, K-91] </ref> for two-party protocols: most generally, [K-91] shows that any two-argument function with an embedded-OR (to be discussed later) is complete for two-party secure computation. No result of this generality is, unfortunately, known for the multi-party scenario. Our Contribution. <p> In [R-81, Yao-82, GMW-87] first such results were shown based on some assumptions. In particular, [GMW-87] gave the first such result for a multi-party protocols, assuming the existence of a one-way function. Without additional assumptions, a stronger result was established in [K-88, K-91] for two-party protocols: most generally, <ref> [K-91] </ref> shows that any two-argument function with an embedded-OR (to be discussed later) is complete for two-party secure computation. No result of this generality is, unfortunately, known for the multi-party scenario. Our Contribution. We formally define the notion of reducibility among multi-party protocol problems. <p> Sub-contributions. As mentioned, the special case of two-party computations and two-argument functions is implicit in previous works: [Ku-89, CKu-89] showed that if a two-argument function is not private then it contains an embedded-OR 3 . <ref> [K-91] </ref> showed that if a two-argument function g contains an embedded-OR then with a black-box for g it is possible to implement an Oblivious Transfer (OT) 4 . <p> We show that if an n-argument function g (boolean or not boolean) contains an embedded-OR then with a black-box for g it is possible to implement private channels between any two players. 3. We use a construction similar to this of <ref> [K-91] </ref> together with the private channels (we already implemented) to implement OT. It should be emphasized that OT in a multi-party setting has the additional requirement that listeners will not get any information. This additional requirement is handled by the implementation of the private channels. <p> Oblivious Transfer is a protocol for two players S, the Sender , and R, the Receiver. It was first defined by Rabin [R-81] and was then studied in many works (e.g., <ref> [R-81, FMR-85, OVY-90, IL-89, K-88, K-91] </ref>). The variant of OT protocol that we use here was originally defined in [EGL-85]. It was shown equivalent to other notions of OT (see, for example [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91]). <p> It was first defined by Rabin [R-81] and was then studied in many works (e.g., [R-81, FMR-85, OVY-90, IL-89, K-88, K-91]). The variant of OT protocol that we use here was originally defined in [EGL-85]. It was shown equivalent to other notions of OT (see, for example <ref> [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91] </ref>). Definition 4 Oblivious Transfer (OT): Let k be a security parameter. The Sender S initially has two bits b 0 and b 1 and the Receiver R has a selection bit c. <p> The resulting two-argument function is an OR function, which by the results of <ref> [K-91] </ref> is sufficient to implement OT between two players. <p> The resulting protocol would be more efficient in terms of communication complexity but the proof that the protocol is private becomes much more involved. Thus, in this extended abstract, we preset a less efficient, but simpler proof. 11 Proof: We start with an OT protocol of <ref> [K-91, CK-88] </ref>. <p> For sake of completeness we present a complete protocol and its proof of security in appendix A. It is simpler than the one presented in <ref> [K-91] </ref>. 6 A completeness theorem for multi-party boolean black box reductions In this section we state the main theorem and provide its proof. It is based on a protocol that can tolerate n 1 "curious" players, assuming the existence of OT-channels, private channels and a broadcast channel. <p> Since it can be used to compute an OR function, we can use it to implement OT (see appendix A). Hence, there exists an implementation of OT based on some f which does not have an embedded-OR. However, <ref> [K-91] </ref> have shown that for two-argument functions, only the ones that contain an embedded-OR, can be used to implement OT, deriving contradiction.
Reference: [Ku-89] <author> E. Kushilevitz, </author> <title> Privacy and Communication Complexity, FOCS89, </title> <journal> and SIAM Jour. on Disc. Math., </journal> <volume> Vol. 5, No. 2, </volume> <month> May </month> <year> 1992, </year> <pages> pp. 273-284. </pages>
Reference-contexts: That is, we show that there are (non-boolean) functions which are not n-private, yet are not complete. Sub-contributions. As mentioned, the special case of two-party computations and two-argument functions is implicit in previous works: <ref> [Ku-89, CKu-89] </ref> showed that if a two-argument function is not private then it contains an embedded-OR 3 . [K-91] showed that if a two-argument function g contains an embedded-OR then with a black-box for g it is possible to implement an Oblivious Transfer (OT) 4 . <p> Proof: The proof for 2-argument g is simple: there are non-private two-argument functions which do not contain an embedded OR. Examples of such functions were shown in <ref> [Ku-89] </ref> (see Figure 1). We now show that with no embedded-OR one can not compute an OR function. Assume, towards the contradiction, that we can, i.e., that there is some function f which does not have an embedded-OR, yet it could be used to compute an OR function.
Reference: [OVY-90] <author> R. Ostrovsky, R. Venkatesan, and M. Yung. </author> <title> Fair Games Against an All-Powerful Adversary, extended abstract in the proceedings of Sequences '91, </title> <address> June 1991, Positano, Italy. </address> <note> See also DIMACS Series on Discrete Mathematics and Theoretical Computer Science, </note> <year> 1993. </year>
Reference-contexts: Oblivious Transfer is a protocol for two players S, the Sender , and R, the Receiver. It was first defined by Rabin [R-81] and was then studied in many works (e.g., <ref> [R-81, FMR-85, OVY-90, IL-89, K-88, K-91] </ref>). The variant of OT protocol that we use here was originally defined in [EGL-85]. It was shown equivalent to other notions of OT (see, for example [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91]).
Reference: [RB-89] <author> T. Rabin and M. Ben-Or, </author> <title> Verifiable Secret Sharing and Multiparty Protocols with Honest Majority, </title> <booktitle> STOC 1989, ACM, </booktitle> <pages> pp. 73-85. </pages>
Reference-contexts: The first general protocol for secure computation were given in [Yao-82, Yao-86] for the two-party case, and by [GMW-87] for the multi-party case. Other solutions were given in, e.g., <ref> [GHY-87, GV-87, BGW-88, CCD-88, BB-89, RB-89] </ref> based on various assumptions (either intractability assumptions or the existence of private (untappable) communication channels between each pair of players). These solutions give t-privacy for t &lt; 1 2 3 depending on the assumption made. Secure computation for honest-but-curious players. <p> The honest-but-curious scenario is not only interesting on its own (e.g., for modeling security against outside listeners). Its importance also stems from compiler-type theorems, such as the one proved by [GMW-87] (with further extensions in many subsequent papers, for example, <ref> [BGW-88, CCD-88, RB-89] </ref>). Namely, there are algorithms transforming t-private protocol with respect to honest-but-curious players into a t`-private protocol with respect to malicious players (t` t).
Reference: [R-81] <author> M. </author> <title> Rabin How to Exchange Secrets by Oblivious Transfer TR-81 Aiken Computation Laboratory, </title> <publisher> Harvard, </publisher> <year> 1981. </year>
Reference-contexts: Completeness for secure computation. Sometimes, instead of giving an explicit t-private protocol for evaluating a function f , one can show that a protocol is reducible to an implementation of some other, simpler protocol. In <ref> [R-81, Yao-82, GMW-87] </ref> first such results were shown based on some assumptions. In particular, [GMW-87] gave the first such result for a multi-party protocols, assuming the existence of a one-way function. <p> We say that the black-box g (alternatively, the function g) is complete if every function f is n-private with respect to the black-box g. Oblivious Transfer is a protocol for two players S, the Sender , and R, the Receiver. It was first defined by Rabin <ref> [R-81] </ref> and was then studied in many works (e.g., [R-81, FMR-85, OVY-90, IL-89, K-88, K-91]). The variant of OT protocol that we use here was originally defined in [EGL-85]. It was shown equivalent to other notions of OT (see, for example [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91]). <p> Oblivious Transfer is a protocol for two players S, the Sender , and R, the Receiver. It was first defined by Rabin [R-81] and was then studied in many works (e.g., <ref> [R-81, FMR-85, OVY-90, IL-89, K-88, K-91] </ref>). The variant of OT protocol that we use here was originally defined in [EGL-85]. It was shown equivalent to other notions of OT (see, for example [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91]). <p> It was first defined by Rabin [R-81] and was then studied in many works (e.g., [R-81, FMR-85, OVY-90, IL-89, K-88, K-91]). The variant of OT protocol that we use here was originally defined in [EGL-85]. It was shown equivalent to other notions of OT (see, for example <ref> [R-81, EGL-85, BCR-86, B-86, C-87, K-88, CK-88, K-91] </ref>). Definition 4 Oblivious Transfer (OT): Let k be a security parameter. The Sender S initially has two bits b 0 and b 1 and the Receiver R has a selection bit c.
Reference: [Yao-82] <author> A.C. Yao, </author> <title> Protocols for Secure Computations, </title> <booktitle> Proc. of 23th FOCS, </booktitle> <pages> pp. 160-164, </pages> <year> 1982. </year>
Reference-contexts: Byzantine) players and honest-but-curios players: Secure Computation for malicious players. Malicious players can deviate from the prescribed protocol in an arbitrary manner, in order to violate the correctness and privacy constraints. The first general protocol for secure computation were given in <ref> [Yao-82, Yao-86] </ref> for the two-party case, and by [GMW-87] for the multi-party case. Other solutions were given in, e.g., [GHY-87, GV-87, BGW-88, CCD-88, BB-89, RB-89] based on various assumptions (either intractability assumptions or the existence of private (untappable) communication channels between each pair of players). <p> Completeness for secure computation. Sometimes, instead of giving an explicit t-private protocol for evaluating a function f , one can show that a protocol is reducible to an implementation of some other, simpler protocol. In <ref> [R-81, Yao-82, GMW-87] </ref> first such results were shown based on some assumptions. In particular, [GMW-87] gave the first such result for a multi-party protocols, assuming the existence of a one-way function.
Reference: [Yao-86] <author> A.C. </author> <title> Yao How to Generate and Exchange Secrets Proc. </title> <booktitle> of 27th FOCS, </booktitle> <pages> pp. 162-167, </pages> <year> 1986. </year> <month> 16 </month>
Reference-contexts: Byzantine) players and honest-but-curios players: Secure Computation for malicious players. Malicious players can deviate from the prescribed protocol in an arbitrary manner, in order to violate the correctness and privacy constraints. The first general protocol for secure computation were given in <ref> [Yao-82, Yao-86] </ref> for the two-party case, and by [GMW-87] for the multi-party case. Other solutions were given in, e.g., [GHY-87, GV-87, BGW-88, CCD-88, BB-89, RB-89] based on various assumptions (either intractability assumptions or the existence of private (untappable) communication channels between each pair of players).
References-found: 28

