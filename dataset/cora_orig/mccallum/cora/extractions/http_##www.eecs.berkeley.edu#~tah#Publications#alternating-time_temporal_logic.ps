URL: http://www.eecs.berkeley.edu/~tah/Publications/alternating-time_temporal_logic.ps
Refering-URL: http://www.eecs.berkeley.edu/~tah/Publications/alternating-time_temporal_logic.html
Root-URL: 
Email: Email: alur@cis.upenn.edu.  Email: tah@eecs.berkeley.edu.  Email: orna@eecs.berkeley.edu.  
Title: Alternating-time Temporal Logic  
Author: Rajeev Alur Thomas A. Henzinger Orna Kupferman 
Web: URL: www.cis.upenn.edu/~alur.  URL: www.eecs.berkeley.edu/~tah.  URL: www.eecs.berkeley.edu/~orna.  
Address: Philadelphia, PA 19104, and  Murray Hill, NJ 07974.  Berkeley, CA 94720.  Berkeley, CA 94720.  
Affiliation: Department of Computer and Information Science, University of Pennsylvania,  Computing Science Research Center, Bell Laboratories,  Department of Electrical Engineering and Computer Sciences, University of California,  Department of Electrical Engineering and Computer Sciences, University of California,  
Note: This work was supported in part by the ONR YIP award N00014-95-1-0520, by the NSF CAREER award CCR-9501708, by the NSF grant CCR-9504469, by the AFOSR contract F49620-93-1-0056, by the ARO MURI grant DAAH-04-96-1-0341, by the ARPA grant NAG2-892, and by the SRC contract 97-DC-324.041.  
Abstract: Temporal logic comes in two varieties: linear-time temporal logic assumes implicit universal quantification over all paths that are generated by system moves; branching-time temporal logic allows explicit existential and universal quantification over all paths. We introduce a third, more general variety of temporal logic: alternating-time temporal logic offers selective quantification over those paths that are possible outcomes of games, such as the game in which the system and the environment alternate moves. While linear-time and branching-time logics are natural specification languages for closed systems, alternating-time logics are natural specification languages for open systems. For example, by preceding the temporal operator "eventually" with a selective path quantifier, we can specify that in the game between the system and the environment, the system has a strategy to reach a certain state. Also the problems of receptiveness, realizability, and controllability can be formulated as model-checking problems for alternating-time formulas. Depending on whether we admit arbitrary nesting of selective path quantifiers and temporal operators, we obtain the two alternating-time temporal logics ATL and ATL ? . We interpret the formulas of ATL and ATL ? over alternating transition systems. While in ordinary transition systems, each transition corresponds to a possible step of the system, in alternating transition systems, each transition corresponds to a possible move in the game between the system and the environment. Fair alternating transition systems can capture both synchronous and asynchronous compositions of open systems. For synchronous systems, the expressive power of ATL beyond CTL comes at no cost: the model-checking complexity of synchronous ATL is linear in the size of the system and the length of the formula. The symbolic model-checking algorithm for CTL extends with few modifications to synchronous ATL, and with some work, also to asynchronous ATL, whose model-checking complexity is quadratic. This makes ATL an obvious candidate for the automatic verification of open systems. In the case of ATL ? , the model-checking problem is closely related to the synthesis problem for linear-time formulas, and requires doubly exponential time for both synchronous and asynchronous systems. fl A preliminary version of this paper appeared in the Proceedings of the 38th IEEE Symposium on Foundations of Computer Science (FOCS 1997), pp. 100-109. 
Abstract-found: 1
Intro-found: 1
Reference: [AH96] <author> R. Alur and T.A. Henzinger. </author> <title> Reactive modules. </title> <booktitle> In Proc. 11th IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 207-218, </pages> <year> 1996. </year> <title> 30 Closed System Open System ATL joint complexity PTIME PTIME </title>
Reference-contexts: Models for open systems, such as CSP [Hoa85], I/O automata [Lyn96], and Reactive Modules <ref> [AH96] </ref>, distinguish between internal nondeterminism, choices made by the system, and external nondeterminism, choices made by the environment.
Reference: [CES86] <institution> O(m`) ATL structure complexity NLOGSPACE PTIME [BVW94] Fair-ATL joint complexity PTIME PTIME </institution>
Reference-contexts: It is interesting to compare the model-checking complexities of turn-based synchronous ATL and CTL. While the two problems can be solved in time O (m`) <ref> [CES86] </ref>, the structure complexity of CTL model checking is only NLOGSPACE-complete [BVW94]. <p> While closed systems are naturally modeled as labeled transition systems (Kripke structures), we model open systems as alternating transition systems. In the case of closed systems, ATL degenerates to CTL, Fair-ATL to Fair-CTL <ref> [CES86] </ref>, and ATL ? to CTL ? . Our model-checking complexity results are summarized in Table 1. All complexities in the table denote tight bounds, where m is the size of the system and ` is the length of the formula. Acknowledgments.
Reference: [CES86] <institution> O(m 2 ` 2 ) Fair-ATL structure complexity NLOGSPACE PTIME [KV95] ATL ? joint complexity PSPACE 2EXPTIME [CES86] m 2 O(`) ATL ? sstructure complexity NLOGSPACE PTIME [BVW94] Table 1: Model-checking complexity results </institution>
Reference-contexts: It is interesting to compare the model-checking complexities of turn-based synchronous ATL and CTL. While the two problems can be solved in time O (m`) <ref> [CES86] </ref>, the structure complexity of CTL model checking is only NLOGSPACE-complete [BVW94]. <p> While closed systems are naturally modeled as labeled transition systems (Kripke structures), we model open systems as alternating transition systems. In the case of closed systems, ATL degenerates to CTL, Fair-ATL to Fair-CTL <ref> [CES86] </ref>, and ATL ? to CTL ? . Our model-checking complexity results are summarized in Table 1. All complexities in the table denote tight bounds, where m is the size of the system and ` is the length of the formula. Acknowledgments.
Reference: [AL93] <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <year> 1993. </year>
Reference-contexts: Alternation is a natural generalization of existential and universal branching, and has been studied extensively in theoretical computer science [CKS81]. Different researchers have argued for game-like interpretations of LTL and CTL specifications for open systems. We list four such instances here. Receptiveness <ref> [Dil89, AL93, GSSL94] </ref>: Given a reactive system, specified by a set of safe computations (typically, generated by a transition relation) and a set of live computations (typically, expressed by an LTL formula), the receptiveness problem is to determine whether every finite safe computation can be extended to an infinite live computation
Reference: [ALW89] <author> M. Abadi, L. Lamport, and P. Wolper. </author> <title> Realizable and unrealizable concurrent program specifications. </title> <booktitle> In Proc. 16th Int. Colloquium on Automata, Languages, and Programming, volume 372 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pages 1-17, </pages> <year> 1989. </year>
Reference-contexts: It is sensible, and necessary for compositionality, to require an affirmative answer to the receptiveness problem. Realizability (program synthesis) <ref> [ALW89, PR89a, PR89b] </ref>: Given an LTL formula over sets of input and output signals, the synthesis problem requires the construction of a reactive system that assigns to every possible input sequence an output sequence so that the resulting computation satisfies . <p> The verification problem for open systems, more than it corresponds to the model-checking problem for temporal logics, corresponds, in the case of linear time, to the realizability problem <ref> [ALW89, PR89a, PR89b] </ref>, and in the case of branching time, to the module-checking problem [KV96]; that is, to a search for winning strategies. Indeed, existing methods for the verification of open systems could not circumvent the computational price caused by solving infinite games.
Reference: [BBG + 94] <author> I. Beer, S. Ben-David, D. Geist, R. Gewirtzman, and M. Yoeli. </author> <title> Methodology and system for practical formal verification of reactive hardware. </title> <booktitle> In Proc. 6th Conference on Computer-aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pages 182-193, </pages> <year> 1994. </year>
Reference-contexts: Writing and understanding formulas in the -calculus is hard already in the context of closed systems, and in practice, designers avoid the nonintuitive use of fixed points and prefer simple temporal operators (see <ref> [BBG + 94] </ref>). Using AMC as a specification language for open systems would require even more complicated formulas, with extra nesting of fixed points, making the -calculus even less appealing.
Reference: [BCM + 90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proc. 5th Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: ATL Model checking is similar to CTL model checking <ref> [CE81, QS81, BCM + 90] </ref>. We present a symbolic algorithm, which manipulates state sets of S.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <booktitle> In Proc. 6th Conference on Computer-aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pages 142-155, </pages> <year> 1994. </year>
Reference-contexts: It is interesting to compare the model-checking complexities of turn-based synchronous ATL and CTL. While the two problems can be solved in time O (m`) [CES86], the structure complexity of CTL model checking is only NLOGSPACE-complete <ref> [BVW94] </ref>. This is because CTL model checking is related to graph reachability, whereas turn-based synchronous ATL model checking is related to AND-OR graph reachability. 20 5.2 Fair-ATL Model-checking Complexity As in Section 4.2, we consider the case of fairness constraints.
Reference: [CE81] <author> E.M. Clarke and E.A. Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching-time temporal logic. </title> <booktitle> In Proc. Workshop on Logic of Programs, volume 131 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pages 52-71, </pages> <year> 1981. </year>
Reference-contexts: Due to the implicit use of universal quantification over the set of computations, LTL cannot express existential, or possibility, properties. Branching-time temporal logics such as CTL and CTL ? , on the other hand, do provide explicit quantification over the set of computations <ref> [CE81, EH86] </ref>. For instance, for a state predicate ', the CTL formula 83 ' requires that a state satisfying ' is visited in all computations, and the CTL formula 93 ' requires that there exists a computation that visits a state satisfying '. <p> The problem of model checking is to verify whether a finite-state abstraction of a reactive system satisfies a temporal-logic specification <ref> [CE81, QS81] </ref>. Efficient model checkers exist for both LTL (e.g., SPIN [Hol97]) and CTL (e.g., SMV [McM93]), and are increasingly being used as debugging aids for industrial designs. <p> ATL Model checking is similar to CTL model checking <ref> [CE81, QS81, BCM + 90] </ref>. We present a symbolic algorithm, which manipulates state sets of S.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal-logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: It is interesting to compare the model-checking complexities of turn-based synchronous ATL and CTL. While the two problems can be solved in time O (m`) <ref> [CES86] </ref>, the structure complexity of CTL model checking is only NLOGSPACE-complete [BVW94]. <p> While closed systems are naturally modeled as labeled transition systems (Kripke structures), we model open systems as alternating transition systems. In the case of closed systems, ATL degenerates to CTL, Fair-ATL to Fair-CTL <ref> [CES86] </ref>, and ATL ? to CTL ? . Our model-checking complexity results are summarized in Table 1. All complexities in the table denote tight bounds, where m is the size of the system and ` is the length of the formula. Acknowledgments.
Reference: [CKS81] <author> A.K. Chandra, D.C. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the ACM, </journal> <volume> 28(1) </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference-contexts: Alternation is a natural generalization of existential and universal branching, and has been studied extensively in theoretical computer science <ref> [CKS81] </ref>. Different researchers have argued for game-like interpretations of LTL and CTL specifications for open systems. We list four such instances here.
Reference: [Cle93] <author> R. Cleaveland. </author> <title> A linear-time model-checking algorithm for the alternation-free modal - calculus. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 2 </volume> <pages> 121-147, </pages> <year> 1993. </year>
Reference-contexts: To see this, observe that the size of Sub (') is bounded by `, and that executing each of the case statements in the algorithm involves, at most, a calculation of a single fixed point, which can be done in time linear in m (see <ref> [Cle93] </ref>). Since reachability in AND-OR graphs is known to be PTIME-hard [Imm81], and can be specified using the fixed ATL formula hhaii3p interpreted over a turn-based synchronous ATS, hardness in PTIME, for both the joint and the structure complexity, is immediate.
Reference: [Dil89] <author> D.L. Dill. </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-independent Circuits. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Alternation is a natural generalization of existential and universal branching, and has been studied extensively in theoretical computer science [CKS81]. Different researchers have argued for game-like interpretations of LTL and CTL specifications for open systems. We list four such instances here. Receptiveness <ref> [Dil89, AL93, GSSL94] </ref>: Given a reactive system, specified by a set of safe computations (typically, generated by a transition relation) and a set of live computations (typically, expressed by an LTL formula), the receptiveness problem is to determine whether every finite safe computation can be extended to an infinite live computation
Reference: [EH86] <author> E.A. Emerson and J.Y. Halpern. </author> <title> Sometimes and not never revisited: On branching versus linear time. </title> <journal> Journal of the ACM, </journal> <volume> 33(1) </volume> <pages> 151-178, </pages> <year> 1986. </year>
Reference-contexts: Due to the implicit use of universal quantification over the set of computations, LTL cannot express existential, or possibility, properties. Branching-time temporal logics such as CTL and CTL ? , on the other hand, do provide explicit quantification over the set of computations <ref> [CE81, EH86] </ref>. For instance, for a state predicate ', the CTL formula 83 ' requires that a state satisfying ' is visited in all computations, and the CTL formula 93 ' requires that there exists a computation that visits a state satisfying '.
Reference: [EJ88] <author> E.A. Emerson and C. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proc. 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 368-377, </pages> <year> 1988. </year>
Reference-contexts: Then, for an appropriate definition of parallel composition, finite-state strategies can be implemented using finite ATS. Indeed, for the finite reachability games and generalized Buchi games of ATL, it suffices to consider memory-free strategies <ref> [EJ88] </ref>, which can be implemented as control maps (i.e., controllers without state). <p> Hence, q j= hhAii iff the product automaton is nonempty. The nonemptiness problem for a Rabin tree automaton with n states and r pairs can be solved in time O (nr) 3r <ref> [EJ88, PR89a] </ref>. Hence, labeling a single state with ' 0 requires at most time (jQj 2 2 j j ) 2 O (j j) . Since there are jQj states and at most j'j subformulas, membership in 2EXPTIME follows.
Reference: [EL85] <author> E.A. Emerson and C.-L. Lei. </author> <title> Modalities for model checking: Branching time logic strikes back. </title> <booktitle> In Proc. 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-96, </pages> <year> 1985. </year>
Reference-contexts: Before we discuss ATL ? model checking, let us briefly recall CTL ? model checking <ref> [EL85] </ref>. The computationally difficult case corresponds to evaluating a state formula of the form 9 , for an LTL formula . The solution is to construct a Buchi automaton A that accepts all computations that satisfy . <p> Hence, from a computational viewpoint, ATL is advantageous. GL model checking The model-checking problem for CTL ? can be solved by repeatedly applying, in a bottom-up fashion, an LTL model-checking procedure on subformulas <ref> [EL85] </ref>. The same technique can be used in order to solve the model-checking problem for GL by repeatedly applying the CTL ? module-checking algorithm from [KV96]. The complexity of CTL ? module checking then implies the following. Theorem 6.3 The model-checking problem for GL is 2EXPTIME-complete.
Reference: [EL86] <author> E.A. Emerson and C.-L. Lei. </author> <title> Efficient model checking in fragments of the propositional -calculus. </title> <booktitle> In Proc. 1st Symposium on Logic in Computer Science, </booktitle> <pages> pages 267-278, </pages> <year> 1986. </year>
Reference-contexts: Theorem 6.1 AMC is more expressive than ATL ? . The alternation-free fragment of AMC is more expressive than ATL. Proof. The translation from alternating-time temporal logics to AMC is very similar to the translation from branching-time temporal logics to -calculus <ref> [EL86] </ref>, with hhAii replacing 9 . We describe here the translation of ATL formulas to the alternation-free fragment of AMC. For this, we present a function g : ATL formulas ! alternation-free AMC formulas such that for every ATL formula ', the formulas ' and g (') are equivalent. <p> Indeed, the only difference between the -calculus and AMC is the definition of the next operator, which has a game-like interpretation in AMC. Hence, as in Section 4.1, the modification involves only the Pre function. Therefore, the complexity of the model-checking problem for the -calculus <ref> [EL86] </ref> implies the following. Theorem 6.2 The model-checking problem for the alternation-free fragment of AMC can be solved in time O (m`) for an ATS with m transitions and a formula of size `.
Reference: [ES84] <author> E.A. Emerson and A.P. Sistla. </author> <title> Deciding branching-time logic. </title> <booktitle> In Proc. 16th ACM Symposium on Theory of Computing, </booktitle> <year> 1984. </year>
Reference-contexts: The automaton A has 2 2 O (j j) states and 2 O (j j) Rabin pairs <ref> [ES84] </ref>. The automaton A S;q;A has jQj states. The product of the two automata A and A S;q;A is a Rabin tree automaton that accepts precisely the hq; Ai-execution trees satisfying 8 . Hence, q j= hhAii iff the product automaton is nonempty.
Reference: [FL79] <author> M.J. Fischer and R.E. Ladner. </author> <title> Propositional dynamic logic of regular programs. </title> <journal> Journal of Computer and Systems Sciences, </journal> <volume> 18 </volume> <pages> 194-211, </pages> <year> 1979. </year>
Reference-contexts: AMC and propositional logic of games In [Par83], Parikh defines a propositional logic of games. Parikh's logic extends dynamic logics (e.g., PDL <ref> [FL79] </ref>) in a way similar to the way in which AMC extends the -calculus. The formulas in Parikh's logic are built with respect to a set of atomic games, which correspond to the choices of agents in an ATS.
Reference: [GSSL94] <author> R. Gawlick, R. Segala, J. Sogaard-Andersen, and N. Lynch. </author> <title> Liveness in timed and untimed systems. </title> <booktitle> In Proc. 23rd Int. Colloquium on Automata, Languages, and Programming, volume 820 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pages 166-177, </pages> <year> 1994. </year>
Reference-contexts: Alternation is a natural generalization of existential and universal branching, and has been studied extensively in theoretical computer science [CKS81]. Different researchers have argued for game-like interpretations of LTL and CTL specifications for open systems. We list four such instances here. Receptiveness <ref> [Dil89, AL93, GSSL94] </ref>: Given a reactive system, specified by a set of safe computations (typically, generated by a transition relation) and a set of live computations (typically, expressed by an LTL formula), the receptiveness problem is to determine whether every finite safe computation can be extended to an infinite live computation
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: Models for open systems, such as CSP <ref> [Hoa85] </ref>, I/O automata [Lyn96], and Reactive Modules [AH96], distinguish between internal nondeterminism, choices made by the system, and external nondeterminism, choices made by the environment.
Reference: [Hol97] <author> G.J. Holzmann. </author> <title> The model checker SPIN. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 23(5) </volume> <pages> 279-295, </pages> <year> 1997. </year>
Reference-contexts: The problem of model checking is to verify whether a finite-state abstraction of a reactive system satisfies a temporal-logic specification [CE81, QS81]. Efficient model checkers exist for both LTL (e.g., SPIN <ref> [Hol97] </ref>) and CTL (e.g., SMV [McM93]), and are increasingly being used as debugging aids for industrial designs. The logics LTL and CTL have their natural interpretation over the computations of closed systems, where a closed system is a system whose behavior is completely determined by the state of the system.
Reference: [Imm81] <author> N. Immerman. </author> <title> Number of quantifiers is better than number of tape cells. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 22(3) </volume> <pages> 384-406, </pages> <year> 1981. </year>
Reference-contexts: Since reachability in AND-OR graphs is known to be PTIME-hard <ref> [Imm81] </ref>, and can be specified using the fixed ATL formula hhaii3p interpreted over a turn-based synchronous ATS, hardness in PTIME, for both the joint and the structure complexity, is immediate. It is interesting to compare the model-checking complexities of turn-based synchronous ATL and CTL.
Reference: [Koz83] <author> D. Kozen. </author> <title> Results on the propositional -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 27 </volume> <pages> 333-354, </pages> <year> 1983. </year>
Reference-contexts: The logic AMC is similar to the -calculus of <ref> [Koz83] </ref>, only that the next operator is parameterized by sets of agents rather than by a universal or an existential path quantifier. Additional boolean connectives are defined from : and _ in the usual manner.
Reference: [KV95] <author> O. Kupferman and M.Y. Vardi. </author> <title> On the complexity of branching modular model checking. </title> <booktitle> In Proc. 6th Conferance on Concurrency Theory, volume 962 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pages 408-422, </pages> <year> 1995. </year>
Reference: [KV96] <author> O. Kupferman and M.Y. Vardi. </author> <title> Module checking. </title> <booktitle> In Proc. 8th Conference on Computer-aided Verification, volume 1102 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pages 75-86, </pages> <year> 1996. </year>
Reference-contexts: Module checking <ref> [KV96] </ref>: Given an open system and a CTL ? formula ', the module-checking 2 problem is to determine if, no matter how the environment restricts the external choices, the system satisfies '. <p> We do this in a bottom-up fashion, starting from the innermost state subformulas of '. For subformulas generated by the rules (S1-2), the labeling procedure is straightforward. For subformulas ' 0 generated by (S3), we employ the algorithm for CTL ? module checking <ref> [KV96] </ref> as follows. Let ' 0 = hhAii ; since the satisfaction of all state subformulas of has already been determined, we can assume that is an LTL formula. <p> Since the formula 99A: (92 p ^ 92 q) is not equivalent to any ATL ? formula, GL is more expressive than ATL ? . Another syntactic fragment of GL is studied in module checking <ref> [KV96] </ref>. There, one considers formulas of the form 99A: , with a single outermost strategy quantifier followed by a CTL or CTL ? formula . <p> Since the GL formula hhA 1 ii3hhA 2 ii3p is not equivalent to any formula with a single outermost strategy quantifier, GL is more expressive than module checking. Furthermore, from an expressiveness viewpoint, alternating-time logics and module checking identify incomparable fragments of game logic. In <ref> [KV96] </ref>, it is shown that the module-checking complexity is EXPTIME-complete for CTL and 2EXPTIME-complete for CTL ? , and the structure complexity of both problems is PTIME-complete. Hence, from a computational viewpoint, ATL is advantageous. <p> The same technique can be used in order to solve the model-checking problem for GL by repeatedly applying the CTL ? module-checking algorithm from <ref> [KV96] </ref>. The complexity of CTL ? module checking then implies the following. Theorem 6.3 The model-checking problem for GL is 2EXPTIME-complete. The structure complexity of the problem is PTIME-complete. Thus, game logic is not more expensive than ATL ? . <p> The verification problem for open systems, more than it corresponds to the model-checking problem for temporal logics, corresponds, in the case of linear time, to the realizability problem [ALW89, PR89a, PR89b], and in the case of branching time, to the module-checking problem <ref> [KV96] </ref>; that is, to a search for winning strategies. Indeed, existing methods for the verification of open systems could not circumvent the computational price caused by solving infinite games.
Reference: [LP85] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite-state concurrent programs satisfy their linear specification. </title> <booktitle> In Proc. 12th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107, </pages> <year> 1985. </year>
Reference-contexts: Since the structure is typically much larger than the formula, and its size is the most common computational bottle-neck <ref> [LP85] </ref>, the structure-complexity measure is of particular practical interest. 5.1 ATL Model-checking Complexity Theorem 5.1 The model-checking problem for ATL is PTIME-complete, and can be solved in time O (m`) for an ATS with m transitions and an ATL formula of length `.
Reference: [Lyn96] <author> N.A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1996. </year> <month> 32 </month>
Reference-contexts: Models for open systems, such as CSP [Hoa85], I/O automata <ref> [Lyn96] </ref>, and Reactive Modules [AH96], distinguish between internal nondeterminism, choices made by the system, and external nondeterminism, choices made by the environment.
Reference: [McM93] <author> K.L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: The problem of model checking is to verify whether a finite-state abstraction of a reactive system satisfies a temporal-logic specification [CE81, QS81]. Efficient model checkers exist for both LTL (e.g., SPIN [Hol97]) and CTL (e.g., SMV <ref> [McM93] </ref>), and are increasingly being used as debugging aids for industrial designs. The logics LTL and CTL have their natural interpretation over the computations of closed systems, where a closed system is a system whose behavior is completely determined by the state of the system. <p> In a multi-process distributed system, we can require any subset of processes to attain a goal, irrespective of the behavior of the remaining processes. Consider, for example, the cache-coherence protocol for Gigamax verified using SMV <ref> [McM93] </ref>. One of the desired properties is the absence of deadlocks, where a deadlocked state is one in which a processor, say a, is permanently blocked from accessing a memory cell. <p> These primitives can be implemented using symbolic representations, such as binary decision diagrams, for state sets and the transition relation. If given a symbolic model checker for CTL, such as SMV <ref> [McM93] </ref>, only the Pre operation needs to be modified for checking ATL. In the special case that the ATS S is turn-based synchronous, the computation of the function Pre used in the symbolic model checking is particularly simple.
Reference: [Par83] <author> R. Parikh. </author> <title> Propositional game logic. </title> <booktitle> In Proc. 24th IEEE Symposium on Foundation of Computer Science, </booktitle> <pages> pages 195-200, </pages> <year> 1983. </year>
Reference-contexts: The model-checking problem for AMC can be solved in time O (m d+1 ) for an ATS with m transitions and an formula of alternation depth d 1. AMC and propositional logic of games In <ref> [Par83] </ref>, Parikh defines a propositional logic of games. Parikh's logic extends dynamic logics (e.g., PDL [FL79]) in a way similar to the way in which AMC extends the -calculus. <p> The alternation-free fragment of AMC can be embedded into Parikh's logic. For example, the AMC formula X:p _ hha; bii X corresponds to the formula h (a _ b)flip in Parikh's logic. In <ref> [Par83] </ref>, Parikh's logic is shown to be decidable and a complete set of axioms is given; the model-checking problem is not studied. 6.2 Game Logic The parameterized path quantifier hhAii first stipulates the existence of strategies for the agents in A and then universally quantifies over the outcomes of the stipulated
Reference: [Pnu77] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proc. 18th IEEE Symposium on Foundation of Computer Science, </booktitle> <pages> pages 46-57, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction In 1977, Pnueli proposed to use linear-time temporal logic (LTL) to specify requirements for reactive systems <ref> [Pnu77] </ref>. A formula of LTL is interpreted over a computation, which is an infinite sequence of states. A reactive system satisfies an LTL formula if all its computations do. Due to the implicit use of universal quantification over the set of computations, LTL cannot express existential, or possibility, properties.
Reference: [PR79] <author> G.L. Peterson and J.H. Reif. </author> <title> Multiple-person alternation. </title> <booktitle> In Proc. 20th IEEE Symposium on Foundation of Computer Science, </booktitle> <pages> pages 348-363, </pages> <year> 1979. </year>
Reference-contexts: This problem is identical to the model-checking problem for the ATL formula hhAii3p on a turn-based synchronous ATS with incomplete information. We note that for Fair-ATL, proving undecidability is easier, and follows from undecidability results on asynchronous multi-player games with incomplete information <ref> [PR79, PR90] </ref>. 7.3 Single-agent ATL with Incomplete Information Single-agent ATL is the fragment of ATL in which every path quantifier is parameterized by a singleton set of agents. In this case, where agents cannot cooperate, the model-checking problem is decidable also for incomplete information.
Reference: [PR89a] <author> A. Pnueli and R. Rosner. </author> <title> On the synthesis of a reactive module. </title> <booktitle> In Proc. 16th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1989. </year>
Reference-contexts: It is sensible, and necessary for compositionality, to require an affirmative answer to the receptiveness problem. Realizability (program synthesis) <ref> [ALW89, PR89a, PR89b] </ref>: Given an LTL formula over sets of input and output signals, the synthesis problem requires the construction of a reactive system that assigns to every possible input sequence an output sequence so that the resulting computation satisfies . <p> Hence, q j= hhAii iff the product automaton is nonempty. The nonemptiness problem for a Rabin tree automaton with n states and r pairs can be solved in time O (nr) 3r <ref> [EJ88, PR89a] </ref>. Hence, labeling a single state with ' 0 requires at most time (jQj 2 2 j j ) 2 O (j j) . Since there are jQj states and at most j'j subformulas, membership in 2EXPTIME follows. <p> Since there are jQj states and at most j'j subformulas, membership in 2EXPTIME follows. For the lower bound, we use a reduction from the realizability problem for LTL <ref> [PR89a] </ref>, which is shown to be 2EXPTIME-hard in [Ros92]. <p> The verification problem for open systems, more than it corresponds to the model-checking problem for temporal logics, corresponds, in the case of linear time, to the realizability problem <ref> [ALW89, PR89a, PR89b] </ref>, and in the case of branching time, to the module-checking problem [KV96]; that is, to a search for winning strategies. Indeed, existing methods for the verification of open systems could not circumvent the computational price caused by solving infinite games.
Reference: [PR89b] <author> A. Pnueli and R. Rosner. </author> <title> On the synthesis of an asynchronous reactive module. </title> <booktitle> In Proc. 16th Int. Colloquium on Automata, Languages, and Programming, volume 372 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pages 652-671, </pages> <year> 1989. </year>
Reference-contexts: It is sensible, and necessary for compositionality, to require an affirmative answer to the receptiveness problem. Realizability (program synthesis) <ref> [ALW89, PR89a, PR89b] </ref>: Given an LTL formula over sets of input and output signals, the synthesis problem requires the construction of a reactive system that assigns to every possible input sequence an output sequence so that the resulting computation satisfies . <p> The verification problem for open systems, more than it corresponds to the model-checking problem for temporal logics, corresponds, in the case of linear time, to the realizability problem <ref> [ALW89, PR89a, PR89b] </ref>, and in the case of branching time, to the module-checking problem [KV96]; that is, to a search for winning strategies. Indeed, existing methods for the verification of open systems could not circumvent the computational price caused by solving infinite games.
Reference: [PR90] <author> A. Pnueli and R. Rosner. </author> <title> Distributed reactive systems are hard to synthesize. </title> <booktitle> In Proc. 31st IEEE Symposium on Foundation of Computer Science, </booktitle> <pages> pages 746-757, </pages> <year> 1990. </year>
Reference-contexts: This problem is identical to the model-checking problem for the ATL formula hhAii3p on a turn-based synchronous ATS with incomplete information. We note that for Fair-ATL, proving undecidability is easier, and follows from undecidability results on asynchronous multi-player games with incomplete information <ref> [PR79, PR90] </ref>. 7.3 Single-agent ATL with Incomplete Information Single-agent ATL is the fragment of ATL in which every path quantifier is parameterized by a singleton set of agents. In this case, where agents cannot cooperate, the model-checking problem is decidable also for incomplete information.
Reference: [QS81] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in Cesar. </title> <booktitle> In Proc. 5th International Symposium on Programming, volume 137 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pages 337-351, </pages> <year> 1981. </year>
Reference-contexts: The problem of model checking is to verify whether a finite-state abstraction of a reactive system satisfies a temporal-logic specification <ref> [CE81, QS81] </ref>. Efficient model checkers exist for both LTL (e.g., SPIN [Hol97]) and CTL (e.g., SMV [McM93]), and are increasingly being used as debugging aids for industrial designs. <p> ATL Model checking is similar to CTL model checking <ref> [CE81, QS81, BCM + 90] </ref>. We present a symbolic algorithm, which manipulates state sets of S.
Reference: [Rab70] <author> M.O. Rabin. </author> <title> Weakly definable relations and special automata. </title> <booktitle> In Proc. Symposium on Mathematical Logic and Foundations of Set Theory, </booktitle> <pages> pages 1-23. </pages> <publisher> North Holland, </publisher> <year> 1970. </year>
Reference-contexts: When we consider finite ATS, all involved games are !-regular. Then, the existence of a winning strategy implies the existence of a winning finite-state strategy <ref> [Rab70] </ref>, which depends only on a finite amount of information about the history of the game. Thus, the semantics of ATL and ATL ? with respect to finite ATS can be defined, equivalently, using the outcomes of finite-state strategies only.
Reference: [Rei84] <author> J.H. Reif. </author> <title> The complexity of two-player games of incomplete information. </title> <journal> Journal on Computer and System Sciences, </journal> <volume> 29 </volume> <pages> 274-301, </pages> <year> 1984. </year>
Reference-contexts: The latter problem is known to be EXPTIME-hard <ref> [Rei84] </ref>. 8 Conclusions Methods for reasoning about closed systems are, in general, not applicable for reasoning about open systems.
Reference: [Ros92] <author> R. Rosner. </author> <title> Modular Synthesis of Reactive Systems. </title> <type> PhD thesis, </type> <institution> Weizmann Institute of Science, Rehovot, Israel, </institution> <year> 1992. </year>
Reference-contexts: Since there are jQj states and at most j'j subformulas, membership in 2EXPTIME follows. For the lower bound, we use a reduction from the realizability problem for LTL [PR89a], which is shown to be 2EXPTIME-hard in <ref> [Ros92] </ref>.
Reference: [RW89] <author> P.J.G. Ramadge and W.M. Wonham. </author> <title> The control of descrete event systems. </title> <journal> IEEE Transactions on Control Theory, </journal> <volume> 77 </volume> <pages> 81-98, </pages> <year> 1989. </year>
Reference-contexts: Realizability (program synthesis) [ALW89, PR89a, PR89b]: Given an LTL formula over sets of input and output signals, the synthesis problem requires the construction of a reactive system that assigns to every possible input sequence an output sequence so that the resulting computation satisfies . Supervisory control <ref> [RW89] </ref>: Given a finite-state machine whose transitions are partitioned into controllable and uncontrollable, and a set of safe states, the control problem requires the construction of a controller that chooses the controllable transitions so that the machine always stays within the safe set (or satisfies some more general LTL formula).
Reference: [Tho95] <author> W. Thomas. </author> <title> On the synthesis of strategies in infinite games. </title> <booktitle> In Proc. 12th Symposium on Theoretical Aspects of Computer Science, volume 900 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pages 1-13, </pages> <year> 1995. </year>
Reference-contexts: Indeed, for the finite reachability games and generalized Buchi games of ATL, it suffices to consider memory-free strategies [EJ88], which can be implemented as control maps (i.e., controllers without state). This is not the case for ATL ? , whose formulas can specify the winning positions of Streett games <ref> [Tho95] </ref>. 4 Symbolic Model Checking 4.1 ATL Symbolic Model Checking The model-checking problem for ATL asks, given an ATS S = h; ; Q; ; ffii and an ATL formula ', for the set ['] Q of states of S that satisfy '.
Reference: [VW86a] <author> M.Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proc. 1st IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 322-331, </pages> <year> 1986. </year>
Reference-contexts: od; return ^ := [true] n t 5 Model-checking Complexity We measure the complexity of the model-checking problem in two different ways: the joint complexity of model checking considers the complexity in terms of both the structure and the formula; the structure complexity of model checking (called "program complexity" in <ref> [VW86a] </ref>) considers the complexity in terms of the structure, assuming the formula is fixed.
Reference: [VW86b] <author> M.Y. Vardi and P. Wolper. </author> <title> Automata-theoretic techniques for modal logics of programs. </title> <journal> Journal of Computer and System Science, </journal> <volume> 32(2) </volume> <pages> 182-221, </pages> <year> 1986. </year>
Reference-contexts: In the asynchronous model, due to the presence of fairness constraints, ATL model checking requires the solution of infinite games, namely, generalized Buchi games <ref> [VW86b] </ref>. Consequently, the model-checking complexity is quadratic in the size of the system, and the symbolic algorithm involves a nested fixed-point computation. The model-checking problem for ATL ? is much harder: we show it to be complete for 2EXPTIME in both the synchronous and asynchronous cases.
Reference: [Yan97] <author> M. Yannakakis. </author> <title> Synchronous multi-player games with incomplete information are undecidable. </title> <type> Personal communication, </type> <year> 1997. </year> <month> 33 </month>
Reference-contexts: Theorem 7.1 The model-checking problem for ATL with incomplete information is undecidable, even in the special case of turn-based synchronous ATS. Proof. The outcome problem for multi-player games with incomplete information has been proved undecidable by <ref> [Yan97] </ref>. This problem is identical to the model-checking problem for the ATL formula hhAii3p on a turn-based synchronous ATS with incomplete information.
References-found: 44

