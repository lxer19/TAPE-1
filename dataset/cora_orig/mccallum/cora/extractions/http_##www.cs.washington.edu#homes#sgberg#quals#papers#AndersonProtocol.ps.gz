URL: http://www.cs.washington.edu/homes/sgberg/quals/papers/AndersonProtocol.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/sgberg/quals/index.html
Root-URL: 
Email: craig@cs.washington.edu, baer@cs.washington.edu  
Phone: Telephone: (206) 543-7798 FAX  
Title: Design and Evaluation of a Subblock Cache Coherence Protocol for Bus-Based Multiprocessors  
Author: Craig Anderson and Jean-Loup Baer 
Keyword: cache coherence protocol, multiprocessor  
Note: Email addresses:  number:  This work was supported by the National Science Foundation under Grants CCR-91 01541 and CCR-87 02195  
Date: May 11, 1994  (206) 543-2969  
Abstract: In this paper, we describe a snoopy cache coherence protocol that uses a large sized transfer block (to take advantage of spatial locality) while using a small coherence block in order to avoid false sharing. To further illustrate the protocol, we present an example of its workings. We then present the results of simulating our protocol on 5 applications that exhibit a variety of reference patterns. We find that our protocol effectively takes advantage of spatial locality while avoiding the increase in false sharing that often occurs when using large line sizes. 
Abstract-found: 1
Intro-found: 1
Reference: [AB86] <author> James Archibald and Jean-Loup Baer. </author> <title> Cache coherence protocols: Evaluation using a multiprocessor simulation model. </title> <journal> ACM TOCS, </journal> <volume> 4(4) </volume> <pages> 273-298, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: The protocol is snoopy-based <ref> [AB86] </ref>. It incorporates features from the Illinois protocol [PP84] (the Illinois protocol will be the basis for comparisons with usual caches) and from protocols or write policies with subblock (in)validations [CD93, Jou93]. The basic philosophy behind the protocol is as follows.
Reference: [AB93] <author> Craig Anderson and Jean-Loup Baer. </author> <title> A multi-level hierarchical cache coherence protocol for multiprocessors. </title> <booktitle> In Proc. of 7th Int. Parallel Processing Symoposium, </booktitle> <pages> pages 142-148, </pages> <year> 1993. </year>
Reference-contexts: This is to prevent stale data from memory from being marked valid in a cache. In our example, the a + 1 block is not marked valid in P3's cache, because it is cached and dirty in P2. 4 Methodology 4.1 Benchmarks We modified the Cerberus multiprocessor instruction-level simulator <ref> [Bro89, AB93] </ref> to evaluate the sector cache protocol. The basis for comparison with usual caches is the Illinois protocol.
Reference: [Bro89] <author> Brooks III, E. D., T. S. Axelrod, and G. H. Darmohray. </author> <title> The Cerberus multiprocessor simulator. </title> <editor> In G. Rodrigue, editor, </editor> <booktitle> Parallel Processing for Scientific Computing, </booktitle> <pages> pages 384-390. </pages> <publisher> SIAM, </publisher> <year> 1989. </year>
Reference-contexts: This is to prevent stale data from memory from being marked valid in a cache. In our example, the a + 1 block is not marked valid in P3's cache, because it is cached and dirty in P2. 4 Methodology 4.1 Benchmarks We modified the Cerberus multiprocessor instruction-level simulator <ref> [Bro89, AB93] </ref> to evaluate the sector cache protocol. The basis for comparison with usual caches is the Illinois protocol.
Reference: [CD93] <author> Yung-Syau Chen and Michel Dubois. </author> <title> Cache protocols with partial block invalidations. </title> <booktitle> In 7th International Parallel Processing Symposium, </booktitle> <pages> pages 16-24, </pages> <year> 1993. </year>
Reference-contexts: Most often, an architecture is implemented with a given protocol and a block size used for both transfer (memory to cache or cache to cache) and coherence. Protocols with varying block sizes [DL92] or with partial block invalidations <ref> [CD93] </ref> have been proposed in order to reduce the number of invalidations or the amount of bytes transferred between the various components of the memory hierarchy. The choices can be made either statically (compile-time) or dynamically (run-time). <p> The protocol is snoopy-based [AB86]. It incorporates features from the Illinois protocol [PP84] (the Illinois protocol will be the basis for comparisons with usual caches) and from protocols or write policies with subblock (in)validations <ref> [CD93, Jou93] </ref>. The basic philosophy behind the protocol is as follows. As much as possible, we favor cache to cache transfers. On read misses, we transfer as many valid subblocks in the line as possible. <p> However, at some point increased traffic from false sharing misses will cause an overall increase in memory latency and bus traffic. Other authors have proposed directory based schemes in which the unit of coherence is smaller than an address block. Chen and Dubois <ref> [CD93] </ref> describe an extension to Censier and Feautrier's full-map directory protocol in which a valid bit is associated with each invalidation block. They show a substantial decrease in both miss rates and memory traffic when partial invalidations are used.
Reference: [Dar88] <author> Darmohray, G. A. </author> <title> Gaussian techniques on shared-memory multiprocessors. </title> <type> Master's thesis, </type> <institution> University of California, Davis, </institution> <month> April </month> <year> 1988. </year>
Reference-contexts: The first phase, which is the reduction of a square matrix to upper triangular form, lends itself well to parallelism <ref> [Dar88] </ref>. The second phase is back substitution that takes much less time than the triangularization. We ran our simulation on a 250x250 matrix, comprising approximately 161 million instructions on a single processor. Relax is a successive over-relaxation program on a 256x256 array of 8 byte floating point numbers.
Reference: [DL92] <author> Czarek Dubnicki and Thomas LeBlanc. </author> <title> Adjustable block size coherent caches. </title> <booktitle> In Proc. of 19th Int. Symp. on Computer Architecture, </booktitle> <pages> pages 170-180, </pages> <year> 1992. </year>
Reference-contexts: Most often, an architecture is implemented with a given protocol and a block size used for both transfer (memory to cache or cache to cache) and coherence. Protocols with varying block sizes <ref> [DL92] </ref> or with partial block invalidations [CD93] have been proposed in order to reduce the number of invalidations or the amount of bytes transferred between the various components of the memory hierarchy. The choices can be made either statically (compile-time) or dynamically (run-time). <p> Chen and Dubois [CD93] describe an extension to Censier and Feautrier's full-map directory protocol in which a valid bit is associated with each invalidation block. They show a substantial decrease in both miss rates and memory traffic when partial invalidations are used. Dubnicki and LeBlanc <ref> [DL92] </ref> propose adjustable block size caches which dynamically grow or shrink the size of an address block in response to various patterns of write sharing. A counter is associated with each cache line.
Reference: [DN87] <author> S. Devadas and A. R. </author> <title> Newton. Topological optimization of multiple level array logic. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <month> November </month> <year> 1987. </year>
Reference-contexts: Processors interfere with one another when attempting to take work off the queue, and when making modifications to the same destination column. Our simulation used the BCSSTK14 input file, which ran for 65 million instructions. Topopt performs topological optimization on VLSI circuits using a parallel simulated annealing algorithm <ref> [DN87] </ref>. This application exhibits a fair amount of both true and false sharing [EJ91]. We used the cpla1.lomim input file, approximately 1.7 billion instructions. 4.2 Simulated architectures Our experiments simulated a variety of usual and sector caches. We varied C, the cache capacity, and L, the line size.
Reference: [EJ91] <author> Susan Eggers and Tor Jeremiassen. </author> <title> Eliminating false-sharing. </title> <booktitle> In Proc. of Int. Conf. on Parallel Processing, </booktitle> <pages> pages I-377-381, </pages> <year> 1991. </year>
Reference-contexts: Our simulation used the BCSSTK14 input file, which ran for 65 million instructions. Topopt performs topological optimization on VLSI circuits using a parallel simulated annealing algorithm [DN87]. This application exhibits a fair amount of both true and false sharing <ref> [EJ91] </ref>. We used the cpla1.lomim input file, approximately 1.7 billion instructions. 4.2 Simulated architectures Our experiments simulated a variety of usual and sector caches. We varied C, the cache capacity, and L, the line size.
Reference: [EK88] <author> Susan Eggers and Randy Katz. </author> <title> A characterization of sharing in parallel programs and its application to coherency protocol evaluation. </title> <booktitle> In Proc. of 15th Int. Symp. on Computer Architecture, </booktitle> <pages> pages 373-382, </pages> <year> 1988. </year>
Reference-contexts: Coherence protocols are either invalidation based the write invalidation (WI) protocols or update based the write update (WU) protocols. It is well known that depending on the application, either WI or WU performs best <ref> [EK88] </ref>. Similarly, some applications run better when small cache block sizes are used because of the presence of migratory data or because false sharing is avoided, while others execute more quickly with larger block sizes because they exhibit good spatial locality.
Reference: [EK89] <author> Susan Eggers and Randy Katz. </author> <title> Evaluating the performance of four snooping cache coherence protocols. </title> <booktitle> In Proc. of 16th Int. Symp. on Computer Architecture, </booktitle> <pages> pages 2-15, </pages> <year> 1989. </year>
Reference-contexts: We also implemented read broadcasting (also called snarfing): when a cache or main memory responds to a read request, all other caches use the data on the bus to update an invalid subblock (or subblocks) if the address of the invalid subblock matches that of the data on the bus <ref> [SR84, EK89] </ref>. Unlike Eggers' study, we assumed that read-broadcasting would not lock out the processor from accessing the cache. In contrast to the Illinois protocol, dirty subblocks that are transferred on read misses are not copied to memory.
Reference: [Goo87] <author> James Goodman. </author> <title> Coherency for multiprocessor virtual caches. </title> <booktitle> In Proc. of 2nd Int. Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 72-81, </pages> <year> 1987. </year>
Reference-contexts: subblock protocol. 6 Related Work Goodman introduced the concept of a coherence block which can be different in size from either an address block (the amount of storage associated with a cache address tag) or a transfer block, which is the amount of data transferred from memory on a miss <ref> [Goo87] </ref>. Goodman advocates using a large size for the coherence block to reduce the number of coherence operations that must be done to read or write a given amount of data.
Reference: [Jou93] <author> Norm Jouppi. </author> <title> Cache write policies and performance. </title> <booktitle> In Proc. of 20th Int. Symp. on Computer Architecture, </booktitle> <pages> pages 191-201, </pages> <year> 1993. </year>
Reference-contexts: The protocol is snoopy-based [AB86]. It incorporates features from the Illinois protocol [PP84] (the Illinois protocol will be the basis for comparisons with usual caches) and from protocols or write policies with subblock (in)validations <ref> [CD93, Jou93] </ref>. The basic philosophy behind the protocol is as follows. As much as possible, we favor cache to cache transfers. On read misses, we transfer as many valid subblocks in the line as possible.
Reference: [KMRS88] <author> Anna Karlin, Mark Manasse, Larry Rudolf, and Daniel Sleator. </author> <title> Competitive snoopy caching. </title> <journal> Algorithmica, </journal> <volume> 3 </volume> <pages> 79-119, </pages> <year> 1988. </year>
Reference-contexts: The choices can be made either statically (compile-time) or dynamically (run-time). For example, some architectures [MIP91] allow the choice of a coherence protocol to be determined on a page per page basis. Competitive snooping <ref> [KMRS88] </ref> and hybrid protocols such as the one implemented on the DEC Alpha [TCS92] allow dynamic switching between WI and WU protocols. Compiler optimizations have been advocated for the choice of a protocol at compile time [VF92] on a block per block basis.
Reference: [MIP91] <institution> MIPS Computer Systems. </institution> <note> MIPS R4000 microprocessor user's manual, </note> <year> 1991. </year>
Reference-contexts: The choices can be made either statically (compile-time) or dynamically (run-time). For example, some architectures <ref> [MIP91] </ref> allow the choice of a coherence protocol to be determined on a page per page basis. Competitive snooping [KMRS88] and hybrid protocols such as the one implemented on the DEC Alpha [TCS92] allow dynamic switching between WI and WU protocols.
Reference: [PP84] <author> Mark Papamarcos and Janak Patel. </author> <title> A low overhead coherence solution for multiprocessors with private cache memories. </title> <booktitle> In Proc. of 11th Int. Symp. on Computer Architecture, </booktitle> <pages> pages 348-354, </pages> <year> 1984. </year>
Reference-contexts: The protocol is snoopy-based [AB86]. It incorporates features from the Illinois protocol <ref> [PP84] </ref> (the Illinois protocol will be the basis for comparisons with usual caches) and from protocols or write policies with subblock (in)validations [CD93, Jou93]. The basic philosophy behind the protocol is as follows. As much as possible, we favor cache to cache transfers.
Reference: [SBS93] <author> Per Stenstrom, Mats Brorsson, and Lars Sandberg. </author> <title> An adaptive cache coherence pro-tocol optimized for migratory sharing. </title> <booktitle> In Proc. of 20th Int. Symp. on Computer Architecture, </booktitle> <pages> pages 109-118, </pages> <year> 1993. </year>
Reference-contexts: In future work we will modify the protocol to work in a hierarchical bus system. We plan to evaluate the effectiveness of using different transfer and coherence sizes at different levels in the system. We will also investigate incorporating the detection of migratory sharing into our subblock protocol <ref> [SBS93] </ref>.
Reference: [Sin92] <author> Sing, J., W.-D. Weber and A. Gupta. </author> <title> SPLASH: Stanford Parallel Applications for Shared Memory. </title> <booktitle> Computer Architecture News, </booktitle> <pages> pages 5-44, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: For our study, we executed 10 iterations of the algorithm, gathering statistics for only the final 5 iterations to eliminate cold-start effects. This represents the simulation of 62 million instructions. MP3D is a 3-dimensional particle simulator from the SPLASH suite <ref> [Sin92] </ref>. The program evaluates the positions and velocities of molecules over a sequence of time steps. Although it appears that the program is well suited for parallelization, speed-ups are hampered by changes in localities when molecules move from one "space" cached in one processor to another. <p> As a consequence, most of the cache misses are coherence misses. We ran MP3D on 50000 molecules for 50 steps, approximately 21 million instructions. Cholesky is a program from the SPLASH benchmark suite for sparse matrix factorization <ref> [Sin92] </ref>. Columns of the matrix are grouped into supernodes to obtain adequate granularity. Each free processor takes a supernode off the task list and modifies the appropriate parts of the main matrix.
Reference: [SR84] <author> Z. Segall and L. Rudolph. </author> <title> Dynamic decentralized cache schemes for an mimd parallel processor. </title> <booktitle> In Proc. of 11th Int. Symp. on Computer Architecture, </booktitle> <pages> pages 340-347, </pages> <year> 1984. </year>
Reference-contexts: We also implemented read broadcasting (also called snarfing): when a cache or main memory responds to a read request, all other caches use the data on the bus to update an invalid subblock (or subblocks) if the address of the invalid subblock matches that of the data on the bus <ref> [SR84, EK89] </ref>. Unlike Eggers' study, we assumed that read-broadcasting would not lock out the processor from accessing the cache. In contrast to the Illinois protocol, dirty subblocks that are transferred on read misses are not copied to memory.
Reference: [TCS92] <author> Charles Thacker, David Conroy, and Lawrence Stewart. </author> <title> The Alpha demonstration unit: A high-performance multiprocessor for software and chip development. </title> <journal> Digital Technical Journal, </journal> <volume> 4(4) </volume> <pages> 51-65, </pages> <year> 1992. </year>
Reference-contexts: The choices can be made either statically (compile-time) or dynamically (run-time). For example, some architectures [MIP91] allow the choice of a coherence protocol to be determined on a page per page basis. Competitive snooping [KMRS88] and hybrid protocols such as the one implemented on the DEC Alpha <ref> [TCS92] </ref> allow dynamic switching between WI and WU protocols. Compiler optimizations have been advocated for the choice of a protocol at compile time [VF92] on a block per block basis.
Reference: [VF92] <author> Jack Veenstra and Robert Fowler. </author> <title> A performance evaluation of optimal hybrid cache coherency protocols. </title> <booktitle> In Proc. of 5th Int. Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 149-160, </pages> <year> 1992. </year>
Reference-contexts: Competitive snooping [KMRS88] and hybrid protocols such as the one implemented on the DEC Alpha [TCS92] allow dynamic switching between WI and WU protocols. Compiler optimizations have been advocated for the choice of a protocol at compile time <ref> [VF92] </ref> on a block per block basis. In this paper we present a dynamic technique, namely a snoopy cache coherence protocol, that uses different block sizes for transfer and coherence.
References-found: 20

