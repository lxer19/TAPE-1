URL: http://www.cs.wisc.edu/~venkatar/papers/pdis.ps
Refering-URL: http://www.cs.wisc.edu/~venkatar/venkatar.html
Root-URL: 
Title: ParSets for Parallelizing OODBMS Traversals: Implementation and Performance  
Author: David J. DeWitt Jeffrey F. Naughton John C. Shafer Shivakumar Venkataraman 
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Abstract: In this paper we describe the design and implementation of ParSets, a means of exploiting parallelism in the SHORE OODBMS. We used ParSets to create and parallelize the graph traversals of the OO7 OODBMS benchmark, and present speedup and scaleup results from parallel SHORE running these traversals on a cluster of commodity workstations connected by a standard ethernet. For some OO7 traversals, SHORE achieved excellent speedup and scaleup; for other OO7 traversals, only marginal speedup and scaleup occurred. The characteristics of these traversals shed light on when the ParSet approach to parallelism can and cannot be applied to speed up an application. 
Abstract-found: 1
Intro-found: 1
Reference: [BBKV87] <author> F. Bancilhon, T. Briggs, S. Khoshafian, and P. Valduriez. </author> <title> FAD, a powerful and simple database language. </title> <booktitle> In Proc. VLDB Conf., </booktitle> <address> Brighton, England, </address> <year> 1987. </year>
Reference-contexts: facility is a variation of an idea that has appeared in many places before: essentially, it allows a program to invoke a method on every object in a set in parallel. (One place this idea appeared in a database context was the "filter" operation in the Bubba project at MCC <ref> [BBKV87] </ref>. Our ParSets were inspired by the "Parallel Set" construct proposed by Kilian [Kil92].
Reference: [Cat93] <author> R. Cattell. </author> <title> The Object Database Standard: ODMG-93. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: Shore ParSets differ from Kil-ian's ParSets in a number of ways, as will be discussed below. A ParSet is simply a set of objects of the same type (or an appropriate subtype). The Shore Data Language (SDL), which is our interpretation of the ODMG standard data definition language ODL <ref> [Cat93] </ref>, is used as the type language for ParSet objects. As envisioned by Kilian, ParSets support five basic operations: Add, Remove, Apply, Select and Reduce. Add adds an object to a ParSet. Remove removes an object from the ParSet.
Reference: [CDN93] <author> M. Carey, D. DeWitt, and J. Naughton. </author> <title> The OO7 benchmark. </title> <booktitle> In Proc of the 1993 ACM-SIGMOD Conf, </booktitle> <address> Washington D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Army Research Laboratory under contract DAAB07-91-C-Q518. for a programmer to consciously and explicitly par-allelize his or her OODBMS application. This paper describes the design and implementation of one primitive we have provided (the ParSet facility), discusses how ParSets can be used to parallelize the OO7 OODBMS benchmark traversals <ref> [CDN93] </ref>, and finally presents performance results from an implementation on a cluster of Sun workstations. <p> Storage Manager (although only the Catalog Service will require persistent storage). 4 The OO7 Benchmark Overview In this section we describe enough of the OO7 benchmark to make this paper self-contained; a more detailed description of the benchmark, along with performance results from a number of commercial systems, appears in <ref> [CDN93] </ref>. 4.1 The OO7 Database The OO7 benchmark is intended to be suggestive of many different CAD/CAM/CASE applications, although in its details it does not model any specific application. The goal of the benchmark is to test many aspects of system performance.
Reference: [CDNK] <author> M. Carey, D. DeWitt, J. Naughton, and C. Kant. </author> <title> The OO7 multiuser benchmark: Preliminary studies. </title> <note> Submitted for publication. </note>
Reference-contexts: The way we did so was to increase the number of modules in the database in proportion to the number of processors. (This same scaleup is being used in the multiuser OO7 benchmark that is currently under development <ref> [CDNK] </ref>.) The only required change to the traversal code is that now the initial assembly traversal that gathers the OIDs of composite parts must traverse the assembly hierarchy of all modules. "small" modules. Recall that for this workload the database fits entirely in memory.
Reference: [CS92] <author> R. Cattell and J. Skeen. </author> <title> Object operations benchmark. </title> <journal> ACM TODS, </journal> <volume> 17(1), </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: Return a count of the number of atomic parts visited when done. This traversal is a test of raw pointer traversal speed, and that it is essentially equivalent to the performance metric most frequently cited from the OO1 benchmark <ref> [CS92] </ref>. Note that due to the high degree of locality in the benchmark, there should be a nontrivial number of cache hits even in the "cold" case.
Reference: [DG92] <author> D. DeWitt and J. Gray. </author> <title> Parallel database systems: The future of high performance database processing. </title> <journal> Comm of the ACM, </journal> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction The commercial success of parallel relational database systems (RDBMS) demonstrates convincingly that for RDBMS, parallelism is a highly effective tool for providing high performance <ref> [DG92] </ref>. However, it is much less clear whether parallelism can be effectively applied in object-oriented database systems (OODBMS.) This is primarily because of the difference in workloads between RDBMS and OODBMS: while RDBMS typically execute queries specified in a set-oriented declarative language (SQL), OODBMS typically execute arbitrary C++ code.
Reference: [eta94] <author> M. J. Carey etal. </author> <title> Shoring up persistent applications. </title> <booktitle> In Proc of the 1994 ACM-SIGMOD Conf, </booktitle> <address> Min-neapolis, MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: A main goal of the SHORE Persistent Object Store project <ref> [eta94] </ref> is to exploit parallelism to improve the performance of OODBMS applications. Our goal is not, however, to solve the problem of automatically parallelizing arbitrary C++ code. <p> In this section we present an overview of the SHORE system in order to make this paper self-contained. This section is a greatly abridged version of material in <ref> [eta94] </ref>. A primary goal for SHORE is to provide a robust, high-performance, persistent object system that is flexible enough to be employed in a wide range of applications and computing environments. To meet this requirement, SHORE's implementation is based on a novel peer-to-peer process structure.
Reference: [Kil92] <author> Michael F. Kilian. </author> <title> Parallel Sets: An Object-Oriented Methodology for Massively Parallel Programming. </title> <type> PhD thesis, </type> <institution> Harvard Center for Research in Computing Technology, </institution> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: Our ParSets were inspired by the "Parallel Set" construct proposed by Kilian <ref> [Kil92] </ref>. <p> The programmer does not need to write any slave code; this is generated automatically by the system. The programmer instead writes the code executed by the master, with the necessary ParSet operations. 3.1 What is a ParSet? The idea of a ParSet was first proposed by Michael Kilian <ref> [Kil92] </ref> (under the name "Parallel Set") as a way of adopting the data parallel approach to object-oriented parallel programming, although the ideas used in ParSets have appeared earlier in other data-parallel languages. Shore ParSets differ from Kil-ian's ParSets in a number of ways, as will be discussed below.
Reference: [Kil93] <author> M. Kilian, </author> <year> 1993. </year> <type> Personal Communication. </type>
Reference-contexts: Our ParSets were inspired by the "Parallel Set" construct proposed by Kilian [Kil92]. Currently this Parallel Set facility is being implemented at Kendall Square Research, under the name "ParaSet", on top of the Matisse OODBMS <ref> [Kil93] </ref>.) Since this not a new idea, this is not the contribution of this paper; rather, the contributions of this paper are (1) a description of how the ParSet facility is actually implemented within Shore, and (2) a description of how the ParSet facility can be used to parallelize the traversals
References-found: 9

