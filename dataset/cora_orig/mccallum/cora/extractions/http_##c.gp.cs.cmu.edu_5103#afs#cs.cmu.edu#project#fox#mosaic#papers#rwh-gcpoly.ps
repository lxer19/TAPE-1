URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/project/fox/mosaic/papers/rwh-gcpoly.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/project/fox/mosaic/papers.html
Root-URL: http://www.cs.cmu.edu
Title: Semantics of Memory Management for Polymorphic Languages  
Author: Greg Morrisett Robert Harper 
Note: Also published as Fox Memorandum CMU-CS-FOX-96-04. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing official policies, either expressed or implied, of the Advanced Research Projects Agency or the U.S. Government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: September, 1996  
Pubnum: CMU-CS-96-176  
Abstract: This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No. C533, issued by ESC/ENS under Contract No. F19628-95-C-0050, and in part by the National Science Foundation under Grant No. CCR-9502674. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Shail Aditya and Alejandro Caro. </author> <title> Compiler-directed type reconstruction for 40 polymorphic languages. </title> <booktitle> In ACM Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 74-82, </pages> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: [nat](VH [l 7! 0]; l) = 0 print [nat](VH [l 7! succ l 0 ]; l) = 1 + print [nat](VH ; l 0 ) print [unit](VH [l 7! hi]; l) = hi print [ 1 fi 2 ](VH [l 7! hl 1 ; l 2 i]; l) = hprint <ref> [ 1 ] </ref>(VH ; l 1 ); print [ 2 ](VH ; l 2 )i print [ 1 ! 2 ](VH [l 7! hhE; fix x:t (x 1 :t 2 ):eii]; l) = *fix* print [8t:](VH [l 7! hhE; flt: eii]; l) = *tabs* print prog ((TH ; VH ); [] <p> Aditya and Caro gave a type-recovery algorithm for an implementation of Id that uses a technique that appears to be equivalent to type passing <ref> [1] </ref>; Aditya, Flood, and Hicks extended this work to garbage collection for Id [2]. Over the past few years, a number of papers on inference-based, tag-free collection in monomorphic [11, 43, 12] and polymorphic [3, 25, 26, 23] languages appeared in the literature.
Reference: [2] <author> Shail Aditya, Christine Flood, and James Hicks. </author> <title> Garbage collection for strongly-typed languages using run-time type reconstruction. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 12-23, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: [nat](VH [l 7! succ l 0 ]; l) = 1 + print [nat](VH ; l 0 ) print [unit](VH [l 7! hi]; l) = hi print [ 1 fi 2 ](VH [l 7! hl 1 ; l 2 i]; l) = hprint [ 1 ](VH ; l 1 ); print <ref> [ 2 ] </ref>(VH ; l 2 )i print [ 1 ! 2 ](VH [l 7! hhE; fix x:t (x 1 :t 2 ):eii]; l) = *fix* print [8t:](VH [l 7! hhE; flt: eii]; l) = *tabs* print prog ((TH ; VH ); [] ; (TE ; VE ); x) = print <p> Aditya and Caro gave a type-recovery algorithm for an implementation of Id that uses a technique that appears to be equivalent to type passing [1]; Aditya, Flood, and Hicks extended this work to garbage collection for Id <ref> [2] </ref>. Over the past few years, a number of papers on inference-based, tag-free collection in monomorphic [11, 43, 12] and polymorphic [3, 25, 26, 23] languages appeared in the literature.
Reference: [3] <author> Andrew W. Appel. </author> <title> Run-time tags aren't necessary. </title> <journal> LISP and Symbolic Computation, </journal> <volume> 2 </volume> <pages> 153-162, </pages> <year> 1989. </year>
Reference-contexts: Over the past few years, a number of papers on inference-based, tag-free collection in monomorphic [11, 43, 12] and polymorphic <ref> [3, 25, 26, 23] </ref> languages appeared in the literature. <p> Over the past few years, a number of papers on inference-based, tag-free collection in monomorphic [11, 43, 12] and polymorphic [3, 25, 26, 23] languages appeared in the literature. Appel <ref> [3] </ref> argued informally that "tag-free" collection is possible for polymorphic languages, such as SML, by a combination of recording information statically and performing what amounts to type inference during the collection process, though the connections between inference and collection were not made clear.
Reference: [4] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: In this case it is essential to make storage allocation decisions explicit in the semantics. Otherwise, important notions, such as "space safety" <ref> [4, 37] </ref>, "tail recursion" [17], and "garbage collection" [42], remain vague notions outside of the scope of a rigorous semantics. In this paper we propose to explore the use of operational semantics to define not only the high-level execution behavior of programs, but also their low-level allocation behavior. <p> In particular, Appel suggests that a space-safe implementation strategy for closures is to trim their environment only to those variables that occur free in the associated code <ref> [4] </ref>. However, it is often impractical to trim the current environment (at every instruction), or to even trim the environments of closures as they are pushed on the stack. <p> Instead, some implementations, including the TIL/ML compiler, delay trimming the current environment and the environments of stack frames until garbage collection is invoked. Many implementations of functional languages perform a program transformation known as closure conversion <ref> [6, 4, 29] </ref> to eliminate nested, higher-order functions.
Reference: [5] <author> Andrew W. Appel. </author> <title> A critique of Standard ML. </title> <type> Technical Report CS-TR-364-92, </type> <institution> Princeton University, Princeton, NJ, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: This is not an oversight! Rather, the intention is to free the programmer from the details of memory management, and to allow the compiler to make representation choices based on contingencies not entirely within the programmer's control. (See Appel's critique for a discussion of this and related points <ref> [5] </ref>.) Applying the full abstraction criterion discussed above, the operational semantics of such languages should abstract away the details of memory management from the definition of the language.
Reference: [6] <author> Andrew W. Appel and Trevor Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 293-302, </pages> <address> Austin, TX, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: Instead, some implementations, including the TIL/ML compiler, delay trimming the current environment and the environments of stack frames until garbage collection is invoked. Many implementations of functional languages perform a program transformation known as closure conversion <ref> [6, 4, 29] </ref> to eliminate nested, higher-order functions.
Reference: [7] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In J. Maluszynski and M. Wirsing, editors, </editor> <booktitle> Third Int'l Symp. on Prog. Lang. Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: Intuitively, by composing the closures that make up the stack frame, we obtain the current "continuation" for the abstract machine. If we chose to restrict !8 gc expressions to continuation-passing style (CPS) as in the SML/NJ compiler <ref> [7] </ref>, there would be no need for a stack in the abstract machine. However, many implementations do not use a CPS representation, and memory management of the stack is a key issue for these systems.
Reference: [8] <author> Henry Baker. </author> <title> Unify and conquer (garbage, updating, aliasing ...) in functional languages. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 218-226, </pages> <address> Nice, </address> <year> 1990. </year>
Reference-contexts: Appel [3] argued informally that "tag-free" collection is possible for polymorphic languages, such as SML, by a combination of recording information statically and performing what amounts to type inference during the collection process, though the connections between inference and collection were not made clear. Baker <ref> [8] </ref> recognized that Milner-style type inference can be used to prove that reachable objects can be safely collected, but did not give a formal account of this result.
Reference: [9] <author> Erik Barendsen and Sjaak Smetsers. </author> <title> Conventional and uniqueness typing in graph rewrite systems. </title> <booktitle> In Proceedings of the 13th Conference on the Foundations of Software Technology and Theoretical Computer Science 1993, </booktitle> <address> Bombay, New York, </address> <year> 1993. </year> <note> Springer-Verlag. Extended abstract. </note>
Reference-contexts: Their low-level semantics specifies explicit memory management based on reference counting. Both Hudak and Chirimar et al. assume a weak approximation of garbage (reference counts). Barendsen and Smet-sers give a Curry-like type system for functional languages extended with uniqueness information that guarantees an object is only "locally accessible" <ref> [9] </ref>. This provides a compiler enough information to determine when certain objects may be garbage collected or over-written.
Reference: [10] <author> Guy E. Blelloch and John Greiner. </author> <title> A provable time and space efficient implementation of NESL. </title> <booktitle> In ACM Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 213-225, </pages> <address> Philadelphia, PA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: None of these papers give a complete formulation of the underlying dynamic and static semantics of the language and thus, the proofs of correctness are necessarily ad hoc. Blelloch and Greiner give an abstract machine for evaluation of the parallel programming language NESL <ref> [10] </ref>. The goal of their work was to provide provable space and time bounds for an implementation of NESL. Their machine is based directly on the CESK machine [20].
Reference: [11] <author> P. Branquart and J. Lewi. </author> <title> A scheme for storage allocation and garbage collection for Algol-68. In Algol-68 Implementation. </title> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1970. </year>
Reference-contexts: Over the past few years, a number of papers on inference-based, tag-free collection in monomorphic <ref> [11, 43, 12] </ref> and polymorphic [3, 25, 26, 23] languages appeared in the literature.
Reference: [12] <author> Dianne Ellen Britton. </author> <title> Heap storage management for the programming language Pascal. </title> <type> Master's thesis, </type> <institution> University of Arizona, </institution> <year> 1975. </year> <month> 41 </month>
Reference-contexts: Over the past few years, a number of papers on inference-based, tag-free collection in monomorphic <ref> [11, 43, 12] </ref> and polymorphic [3, 25, 26, 23] languages appeared in the literature.
Reference: [13] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <type> Technical Report 45, </type> <institution> DEC Systems Research Center, </institution> <year> 1989. </year>
Reference-contexts: 1 Introduction Type theory and operational semantics are remarkably effective tools for programming language design and implementation <ref> [28, 13] </ref>. An important and influential example is provided by The Definition of Standard ML (SML) [28]. The static semantics of SML is specified as a collection of elaboration rules that defines the context-sensitive constraints on the formation of programs.
Reference: [14] <author> David Chase. </author> <title> Safety considerations for storage allocation optimizations. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> Atlanta, GA, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: various environments that may arise in an abstract machine state: (SE-th) hhTE 1 ; t ii STE 7! hhTE 2 ; t ii (H [p 7! hhTE 1 ; t ii]; S; E; e) SE-th 7! (H [p 7! hhTE 2 ; t ii]; S; E; e) 2 See Chase <ref> [14] </ref> for a further discussion of practical space safety issues. 36 (SE-vh) SE (H [l 7! hhE 1 ; e 0 ii]; S; E; e) 7! (H [l 7! hhE 2 ; e 0 ii]; S; E; e) (SE-stack) hhE 1 ; x 0 :t 0 :e 0 ii 7! hhE
Reference: [15] <author> Jawahar Chirimar, Carl A. Gunter, and Jon G. Riecke. </author> <title> Proving memory management invariants for a language based on linear logic. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 139-150, </pages> <address> San Francisco, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: He presents an abstraction of the model and gives an algorithm for computing approximations of reference counts statically. Chirimar, Gunter, and 38 Riecke give a framework for proving invariants regarding memory management for a language with a linear type system <ref> [15] </ref>. Their low-level semantics specifies explicit memory management based on reference counting. Both Hudak and Chirimar et al. assume a weak approximation of garbage (reference counts). Barendsen and Smet-sers give a Curry-like type system for functional languages extended with uniqueness information that guarantees an object is only "locally accessible" [9].
Reference: [16] <author> Dominique Clement, Joelle Despeyroux, Thierry Despeyroux, Laurent Hascoet, and Gilles Kahn. </author> <title> Natural semantics on the computer. </title> <type> Technical Report RR 416, </type> <institution> INRIA, Sophia-Antipolis, France, </institution> <month> June </month> <year> 1985. </year>
Reference-contexts: Of particular interest for purposes of this paper is the variety of methods for defining the operational semantics of deterministic, sequential languages. Two main approaches have emerged, one based on evaluation relations, the other based on transition systems. The evaluation-based approach is typified by Kahn's natural semantics <ref> [16] </ref> and is used extensively in The Definition of Standard ML. The transition-based approach is typified by Plotkin's structured operational semantics [33], but also includes approaches based on abstract machines [18] and program rewriting [21, 44].
Reference: [17] <author> William Clinger and Jonathan Rees. </author> <title> Revised 4 report on the algorithmic language Scheme. LISP Pointers, </title> <address> IV(3):1-55, July-Sep. </address> <year> 1991. </year>
Reference-contexts: In this case it is essential to make storage allocation decisions explicit in the semantics. Otherwise, important notions, such as "space safety" [4, 37], "tail recursion" <ref> [17] </ref>, and "garbage collection" [42], remain vague notions outside of the scope of a rigorous semantics. In this paper we propose to explore the use of operational semantics to define not only the high-level execution behavior of programs, but also their low-level allocation behavior. <p> Furthermore, a heap garbage collector must process and preserve all 35 objects that are reachable from these unnecessary frames, so the total amount of garbage in the state of the abstract machine grows quickly. Some languages, notably Scheme <ref> [17] </ref>, require that all implementations faithfully implement tail-call elimination in order to address these practical concerns 2 . Yet, the standard models for Scheme make neither the control stack nor heap explicit [17], and thus the tail-call requirement is at best an informal contract between the language specification and its implementors. <p> Some languages, notably Scheme <ref> [17] </ref>, require that all implementations faithfully implement tail-call elimination in order to address these practical concerns 2 . Yet, the standard models for Scheme make neither the control stack nor heap explicit [17], and thus the tail-call requirement is at best an informal contract between the language specification and its implementors.
Reference: [18] <author> Guy Cousineau, Pierre-Louis Curien, and Michel Mauny. </author> <title> The categorical abstract machine. </title> <editor> In J. P. Jouannaud, editor, </editor> <booktitle> 1985 Conference on Functional Programming and Computer Architecture, volume 201 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The evaluation-based approach is typified by Kahn's natural semantics [16] and is used extensively in The Definition of Standard ML. The transition-based approach is typified by Plotkin's structured operational semantics [33], but also includes approaches based on abstract machines <ref> [18] </ref> and program rewriting [21, 44]. Both approaches share the goal of achieving a "fully abstract" semantics that suppresses irrelevant details, avoids over-specification, and facilitates reasoning about programs. Experience has shown that these goals are difficult to achieve in a single framework. <p> It is also possible for different closures to share portions of the same environment. In particular, many implementations, such as the CAM <ref> [18] </ref>, allow closures in the same lexical scope to share an environment for that scope. However, care must be taken when two closures share an environment in order to avoid a class of space leaks [37].
Reference: [19] <author> A. Demers, M. Weiser, B. Hayes, H. Boehm, D. Bobrow, and S. Shenker. </author> <title> Combining generational and conservative garbage collection: Framework and implementations. </title> <booktitle> In Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 261-269, </pages> <address> San Francisco, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: The literature on garbage collection in sequential programming languages contains few papers that attempt to provide a compact characterization of algorithms or correctness proofs. Demers et al. <ref> [19] </ref> give a model of memory parameterized by an abstract notion of a "points-to" relation. As a result, they can characterize reachability-based algorithms including mark-sweep, copying, generational, "conservative," and other sophisticated forms of garbage collection.
Reference: [20] <author> Matthias Felleisen and Daniel P. Friedman. </author> <title> A calculus for assignments in higher-order languages. </title> <booktitle> In Thirteenth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1987. </year>
Reference-contexts: The abstract machine is derived from the CESK machine of Felleisen and Friedman <ref> [20] </ref>. States of the machine are a quadruple (H; S; E; e) where H is a heap, S is a stack, E is an environment, and e is an expression of the !8 gc language. <p> Blelloch and Greiner give an abstract machine for evaluation of the parallel programming language NESL [10]. The goal of their work was to provide provable space and time bounds for an implementation of NESL. Their machine is based directly on the CESK machine <ref> [20] </ref>. However, some details in their formulation, such as the representation of control information, are left implicit. 39 8 Summary and Conclusions We have presented an abstract machine for describing the evaluation of polymorphically-typed, functional programs.
Reference: [21] <author> Matthias Felleisen and Robert Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 10(2) </volume> <pages> 235-271, </pages> <year> 1992. </year>
Reference-contexts: The evaluation-based approach is typified by Kahn's natural semantics [16] and is used extensively in The Definition of Standard ML. The transition-based approach is typified by Plotkin's structured operational semantics [33], but also includes approaches based on abstract machines [18] and program rewriting <ref> [21, 44] </ref>. Both approaches share the goal of achieving a "fully abstract" semantics that suppresses irrelevant details, avoids over-specification, and facilitates reasoning about programs. Experience has shown that these goals are difficult to achieve in a single framework.
Reference: [22] <author> Michael J. Fischer. </author> <title> Lambda-calculus schemata. </title> <journal> LISP and Symbolic Computation, </journal> 6(3/4):259-288, November 1993. 
Reference-contexts: For certain classes of programs, this optimization is crucial in order to bound the amount of stack space needed to run programs. In particular, when programs are written in continuation-passing style (CPS) <ref> [22] </ref>, then the return transition is never enabled until the end of the computation, assuming the computation terminates. Instead, each function is passed an extra argument function (the continuation), and the result of the function is passed to the continuation. In effect, all function applications turn into potential tail-app transitions.
Reference: [23] <author> Pascal Fradet. </author> <title> Collecting more garbage. </title> <booktitle> In ACM Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 24-33, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Over the past few years, a number of papers on inference-based, tag-free collection in monomorphic [11, 43, 12] and polymorphic <ref> [3, 25, 26, 23] </ref> languages appeared in the literature. <p> They gave an informal argument based on traversal of stack frames to show that such values are semantically garbage. Fradet <ref> [23] </ref> gave another argument based on Reynolds's abstraction/parametricity theorem [35]. None of these papers give a complete formulation of the underlying dynamic and static semantics of the language and thus, the proofs of correctness are necessarily ad hoc.
Reference: [24] <author> Jean-Yves Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieure. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year> <month> 42 </month>
Reference-contexts: Finally, we discuss related work in Section 7, and we summarize and conclude in Section 8. 2 The gc Language In this section, we present !8 gc , a call-by-value variant of the Girard-Reynolds polymorphic -calculus <ref> [24, 34] </ref>. In the following section, we define an abstract machine for evaluating !8 gc expressions. The abstract machine makes explicit many operational details that are pertinent to memory management, such as the heap, the control stack, and the environment.
Reference: [25] <author> Benjamin Goldberg. </author> <title> Tag-free garbage collection for strongly typed program-ming languages. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 165-176, </pages> <address> Toronto, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Over the past few years, a number of papers on inference-based, tag-free collection in monomorphic [11, 43, 12] and polymorphic <ref> [3, 25, 26, 23] </ref> languages appeared in the literature.
Reference: [26] <author> Benjamin Goldberg and Michael Gloger. </author> <title> Polymorphic type reconstruction for garbage collection without tags. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 53-65, </pages> <address> San Francisco, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Over the past few years, a number of papers on inference-based, tag-free collection in monomorphic [11, 43, 12] and polymorphic <ref> [3, 25, 26, 23] </ref> languages appeared in the literature. <p> Baker [8] recognized that Milner-style type inference can be used to prove that reachable objects can be safely collected, but did not give a formal account of this result. Goldberg and Gloger <ref> [26] </ref> recognized that it is not possible to reconstruct the concrete types of all reachable values in an implementation of an ML-style language that does not pass types to polymorphic routines. They gave an informal argument based on traversal of stack frames to show that such values are semantically garbage.
Reference: [27] <author> Paul Hudak. </author> <title> A semantic model of reference counting and its abstraction. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 351-363, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Our GC 7! transition rule is essentially a high-level, one-line description of his specification, and the tf-gc 7! rule is a particu lar implementation. Hudak gives a denotational model that tracks reference counts for a first-order language <ref> [27] </ref>. He presents an abstraction of the model and gives an algorithm for computing approximations of reference counts statically. Chirimar, Gunter, and 38 Riecke give a framework for proving invariants regarding memory management for a language with a linear type system [15].
Reference: [28] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Type theory and operational semantics are remarkably effective tools for programming language design and implementation <ref> [28, 13] </ref>. An important and influential example is provided by The Definition of Standard ML (SML) [28]. The static semantics of SML is specified as a collection of elaboration rules that defines the context-sensitive constraints on the formation of programs. <p> 1 Introduction Type theory and operational semantics are remarkably effective tools for programming language design and implementation [28, 13]. An important and influential example is provided by The Definition of Standard ML (SML) <ref> [28] </ref>. The static semantics of SML is specified as a collection of elaboration rules that defines the context-sensitive constraints on the formation of programs. The dynamic semantics is specified as a collection of evaluation rules that defines the operational semantics of a program.
Reference: [29] <author> Yasuhiko Minamide, Greg Morrisett, and Robert Harper. </author> <title> Typed closure conversion. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 271-283, </pages> <address> St. Petersburg, FL, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: This organization faithfully reflects a conventional implementation of the !8 gc language, except that it abstracts from the allocation of environments. (For a treatment of this topic, see Minamide, Morrisett, and Harper's account of closure conversion for a typed language <ref> [29] </ref>.) In particular, this organization is a fairly accurate model of the run-time data structures used by the TIL/ML compiler [38]. To establish soundness of the type system we, define a syntactic typing discipline for the states of the abstract machine, and prove progress and preservation lemmas for it. <p> Instead, some implementations, including the TIL/ML compiler, delay trimming the current environment and the environments of stack frames until garbage collection is invoked. Many implementations of functional languages perform a program transformation known as closure conversion <ref> [6, 4, 29] </ref> to eliminate nested, higher-order functions.
Reference: [30] <author> Greg Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1995. </year> <note> (Available as Carnegie Mellon University School of Computer Science technical report CMU-CS-95-226.). </note>
Reference-contexts: the abstract machine presented here does not support shared environments, it is fairly straightforward to add environments to the set of heap-allocated values so that they may be shared. 7 Related Work The ideas in this paper are derived from our previous work with Matthias Felleisen [31] and Morrisett's dissertation <ref> [30] </ref>, where we presented a much simpler abstract machine that relied upon meta-level substitution and meta-level evaluation contexts to implicitly represent the control state and environment of a computation. <p> Hence, we claim that such a model provides an important intermediate step in establishing the correctness of a wide class of existing and future implementations. 9 Acknowledgments This paper is based on a preliminary version by Matthias Felleisen and the authors <ref> [31, 30] </ref>. We very gratefully acknowledge the important contributions of Matthias Felleisen to this work. We are grateful to Chris Stone, Todd Wilson, and Tanya Morrisett for their careful reading of this paper and for their many useful comments and suggestions.
Reference: [31] <author> Greg Morrisett, Matthias Felleisen, and Robert Harper. </author> <title> Abstract models of memory management. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <pages> pages 66-77, </pages> <address> La Jolla, CA, </address> <month> June </month> <year> 1995. </year> <note> ACM. </note>
Reference-contexts: It is possible to drop the well-formedness condition and consider a more semantic definition of garbage, at the expense of considerable technical complication <ref> [31] </ref>. We prefer the more restrictive definition because it is simpler and closer to practice. Implementors use one of a variety of techniques to determine which portions of the heap can be collected. One of the most important techniques is based on the 21 idea of accessibility. <p> Though the abstract machine presented here does not support shared environments, it is fairly straightforward to add environments to the set of heap-allocated values so that they may be shared. 7 Related Work The ideas in this paper are derived from our previous work with Matthias Felleisen <ref> [31] </ref> and Morrisett's dissertation [30], where we presented a much simpler abstract machine that relied upon meta-level substitution and meta-level evaluation contexts to implicitly represent the control state and environment of a computation. <p> Hence, we claim that such a model provides an important intermediate step in establishing the correctness of a wide class of existing and future implementations. 9 Acknowledgments This paper is based on a preliminary version by Matthias Felleisen and the authors <ref> [31, 30] </ref>. We very gratefully acknowledge the important contributions of Matthias Felleisen to this work. We are grateful to Chris Stone, Todd Wilson, and Tanya Morrisett for their careful reading of this paper and for their many useful comments and suggestions.
Reference: [32] <author> Scott Nettles. </author> <title> A Larch specification of copying garbage collection. </title> <type> Technical Report CMU-CS-92-219, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: However, their model is intentionally divorced from the programming language and cannot take advantage of any semantic properties of evaluation, such as type preservation. Consequently, their framework cannot model the type-based, tag-free collector of Section 5. Nettles <ref> [32] </ref> provides a concrete specification of a copying garbage collection algorithm using the Larch specification language. Our GC 7! transition rule is essentially a high-level, one-line description of his specification, and the tf-gc 7! rule is a particu lar implementation.
Reference: [33] <author> Gordon Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI-FN-19, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1981. </year>
Reference-contexts: Two main approaches have emerged, one based on evaluation relations, the other based on transition systems. The evaluation-based approach is typified by Kahn's natural semantics [16] and is used extensively in The Definition of Standard ML. The transition-based approach is typified by Plotkin's structured operational semantics <ref> [33] </ref>, but also includes approaches based on abstract machines [18] and program rewriting [21, 44]. Both approaches share the goal of achieving a "fully abstract" semantics that suppresses irrelevant details, avoids over-specification, and facilitates reasoning about programs.
Reference: [34] <author> John C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Colloq. sur la Programmation, volume 19 of Lecture Notes in Computer Science, </booktitle> <pages> pages 408-423. </pages> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: Finally, we discuss related work in Section 7, and we summarize and conclude in Section 8. 2 The gc Language In this section, we present !8 gc , a call-by-value variant of the Girard-Reynolds polymorphic -calculus <ref> [24, 34] </ref>. In the following section, we define an abstract machine for evaluating !8 gc expressions. The abstract machine makes explicit many operational details that are pertinent to memory management, such as the heap, the control stack, and the environment.
Reference: [35] <author> John C. Reynolds. </author> <title> Types, abstraction, and parametric polymorphism. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing '83, </booktitle> <pages> pages 513-523. </pages> <publisher> Elsevier Science Publishers B. V., </publisher> <year> 1983. </year> <month> 43 </month>
Reference-contexts: They gave an informal argument based on traversal of stack frames to show that such values are semantically garbage. Fradet [23] gave another argument based on Reynolds's abstraction/parametricity theorem <ref> [35] </ref>. None of these papers give a complete formulation of the underlying dynamic and static semantics of the language and thus, the proofs of correctness are necessarily ad hoc. Blelloch and Greiner give an abstract machine for evaluation of the parallel programming language NESL [10].
Reference: [36] <author> Amr Sabry and Matthias Felleisen. </author> <title> Reasoning about programs in continuation--passing style. </title> <booktitle> In 1992 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 288-298, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: Therefore, modeling allocation, sharing, and garbage collection of types is just as important as modeling memory management for values. To simplify the abstract machine, the expressions and types of !8 gc are restricted to named form, also known as A Normal Form <ref> [36] </ref>. The restriction to named form amounts to the requirement that the result of every step of evaluation or allocation be bound to a variable, which is then used to refer to the result of this computation.
Reference: [37] <author> Zhong Shao and Andrew W. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 150-161, </pages> <address> Or-lando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: In this case it is essential to make storage allocation decisions explicit in the semantics. Otherwise, important notions, such as "space safety" <ref> [4, 37] </ref>, "tail recursion" [17], and "garbage collection" [42], remain vague notions outside of the scope of a rigorous semantics. In this paper we propose to explore the use of operational semantics to define not only the high-level execution behavior of programs, but also their low-level allocation behavior. <p> In particular, many implementations, such as the CAM [18], allow closures in the same lexical scope to share an environment for that scope. However, care must be taken when two closures share an environment in order to avoid a class of space leaks <ref> [37] </ref>. In particular, the shared portion of the environment should only contain bindings for those variables that occur free in the code of both closures.
Reference: [38] <author> David Tarditi, Greg Morrisett, Perry Cheng, Chris Stone, Robert Harper, and Peter Lee. </author> <title> Til: A type-directed optimizing compiler for ml. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> pages ?-?, Philadelphia, PA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: In addition, we discuss two other forms of garbage collection: tail recursion elimination, which reduces the space required by the control stack, and black holing, which reduces the space required by environments. All of these memory management techniques are used within the TIL/ML compiler <ref> [38] </ref>, and thus the material presented here provides a faithful model of this particular implementation. Nevertheless, the framework we propose is general enough to model a variety of language implementations. <p> In Section 5, we show how to implement a particular heap-garbage collection algorithm, namely the type-based, tag-free garbage collector used by Tolmach [40], which is closely related to the mostly tag-free collector used by the TIL/ML compiler <ref> [38] </ref>. We prove the correctness of the algorithm using syntactic techniques similar to those used to prove type soundness for the abstract machine. In Section 6, we consider other kinds of garbage in the abstract machine, notably stack garbage and environment garbage. <p> Perhaps the most novel aspect of !8 gc is that, unlike traditional models of typed-languages, type information is maintained throughout evaluation in order to support type-based, tag-free garbage collection as implemented by Tolmach [40] and in the TIL/ML compiler <ref> [38] </ref>. Therefore, modeling allocation, sharing, and garbage collection of types is just as important as modeling memory management for values. To simplify the abstract machine, the expressions and types of !8 gc are restricted to named form, also known as A Normal Form [36]. <p> gc language, except that it abstracts from the allocation of environments. (For a treatment of this topic, see Minamide, Morrisett, and Harper's account of closure conversion for a typed language [29].) In particular, this organization is a fairly accurate model of the run-time data structures used by the TIL/ML compiler <ref> [38] </ref>. To establish soundness of the type system we, define a syntactic typing discipline for the states of the abstract machine, and prove progress and preservation lemmas for it. <p> The following section addresses this issue. 5 Type-Based Tag-Free Heap Collection In this section, we formulate a garbage collection rewriting rule that models type-based, tag-free copying collection in the style of Tolmach [40] and the TIL/ML compiler <ref> [38] </ref>. The key idea is to preserve all heap objects that can be reached (either directly or indirectly) from the current environment and stack. We use the type information recorded in environments during evaluation to determine the shape of heap objects.
Reference: [39] <author> Mads Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89 </volume> <pages> 1-34, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: ; VH ) (stack) S ::= [] j S ffi hhE; x:t:eii (program) P ::= (H; S; E; e) (answer) A ::= (H; [] ; E; x) gc Machine difficulties for extending the proofs of the main results. (This is in contrast to the complex fixed point constructions used elsewhere <ref> [39] </ref>.) The remainder of this section is organized as follows: In Section 3.1, we present the syntax of the constructs that make up the abstract machine. In Section 3.2, we present the static semantics for the abstract machine.
Reference: [40] <author> Andrew Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proc. 1994 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: We show the soundness of a particular class of collectors, namely those based on inaccessibility of heap objects. In Section 5, we show how to implement a particular heap-garbage collection algorithm, namely the type-based, tag-free garbage collector used by Tolmach <ref> [40] </ref>, which is closely related to the mostly tag-free collector used by the TIL/ML compiler [38]. We prove the correctness of the algorithm using syntactic techniques similar to those used to prove type soundness for the abstract machine. <p> Perhaps the most novel aspect of !8 gc is that, unlike traditional models of typed-languages, type information is maintained throughout evaluation in order to support type-based, tag-free garbage collection as implemented by Tolmach <ref> [40] </ref> and in the TIL/ML compiler [38]. Therefore, modeling allocation, sharing, and garbage collection of types is just as important as modeling memory management for values. To simplify the abstract machine, the expressions and types of !8 gc are restricted to named form, also known as A Normal Form [36]. <p> Some mechanism is needed to determine efficiently which pointers and locations can be safely garbage collected. The following section addresses this issue. 5 Type-Based Tag-Free Heap Collection In this section, we formulate a garbage collection rewriting rule that models type-based, tag-free copying collection in the style of Tolmach <ref> [40] </ref> and the TIL/ML compiler [38]. The key idea is to preserve all heap objects that can be reached (either directly or indirectly) from the current environment and stack. We use the type information recorded in environments during evaluation to determine the shape of heap objects. <p> Barendsen and Smet-sers give a Curry-like type system for functional languages extended with uniqueness information that guarantees an object is only "locally accessible" [9]. This provides a compiler enough information to determine when certain objects may be garbage collected or over-written. Tolmach <ref> [40] </ref> built a type-recovery collector for a variant of SML that passes type information to polymorphic routines during execution, effectively implementing our !8 gc language and the type-based, tag-free collector of Section 5. <p> For each class of garbage, we presented an abstract specification of a collector which reclaims the garbage objects, and proved that these collectors do not affect the observable behavior of well-formed programs. In addition, we gave a detailed specification of Tolmach's type-based, tag-free, copying garbage collector <ref> [40] </ref> and proved its correctness. The techniques used to specify and prove correctness for all of the collectors were based on those used to establish type soundness for the abstract machine. Admittedly, our machine abstracts many important low-level implementation details for memory management.
Reference: [41] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <editor> In Yves Bekkers and Jacques Cohen, editors, </editor> <booktitle> International Workshop on Memory Management, number 637 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-42, </pages> <address> St. Malo, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference: [42] <author> Paul R. Wilson. </author> <title> Garbage collection. </title> <journal> Computing Surveys, </journal> <note> 1995. Expanded version of [41]. Draft available via anonymous internet FTP from cs.utexas.edu as pub/garbage/bigsurv.ps. In revision, to appear. </note>
Reference-contexts: In this case it is essential to make storage allocation decisions explicit in the semantics. Otherwise, important notions, such as "space safety" [4, 37], "tail recursion" [17], and "garbage collection" <ref> [42] </ref>, remain vague notions outside of the scope of a rigorous semantics. In this paper we propose to explore the use of operational semantics to define not only the high-level execution behavior of programs, but also their low-level allocation behavior.
Reference: [43] <author> P.L. Wodon. </author> <title> Methods of garbage collection for Algol-68. In Algol-68 Implementation. </title> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1970. </year>
Reference-contexts: Over the past few years, a number of papers on inference-based, tag-free collection in monomorphic <ref> [11, 43, 12] </ref> and polymorphic [3, 25, 26, 23] languages appeared in the literature.
Reference: [44] <author> Andrew K. Wright and Matthias Felleisen. </author> <title> A syntactic approach to type soundness. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 38-94, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: The evaluation-based approach is typified by Kahn's natural semantics [16] and is used extensively in The Definition of Standard ML. The transition-based approach is typified by Plotkin's structured operational semantics [33], but also includes approaches based on abstract machines [18] and program rewriting <ref> [21, 44] </ref>. Both approaches share the goal of achieving a "fully abstract" semantics that suppresses irrelevant details, avoids over-specification, and facilitates reasoning about programs. Experience has shown that these goals are difficult to achieve in a single framework. <p> 2 ). 19 3.4 Type Soundness We prove the soundness of the type system (with respect to execution by the abstract machine) by establishing that the transition system preserves typability, and that well-typed programs are either answers, or admit a further transition. (This viewpoint is inspired by Wright and Felleisen <ref> [44] </ref>.) We state the important lemmas and give the proof of soundness here. Proofs of the most important lemmas, Preservation and Progress, may be found in Appendix B.
References-found: 44

