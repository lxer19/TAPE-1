URL: ftp://dirleton.csres.utexas.edu/pub/reports/054.ps
Refering-URL: http://www.cli.com/reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: A Theorem Prover for a Computational Logic  
Author:  Robert S. Boyer J Strother Moore 
Address: 1717 W. 6th St. Suite 290 Austin, Texas 78703 USA  
Affiliation: Computational Logic Inc.  
Abstract: Technical Report 54 April, 1990 (512) 322-9951 This report was the keynote address at the 10th International Conference on Automated Deduction, July, 1990 in Kaiserslautern, W. Germany. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, or Computational Logic, Inc. or the U.S. Government. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> W. Bevier. </author> <title> A Verified Operating System Kernel. </title> <type> Ph.D. </type> <institution> Th., University of Texas at Austin, </institution> <year> 1987. </year>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in <ref> [1, 31, 32, 33, 40, 75, 3] </ref>, [48, 44, 41, 42], [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 2. <author> W. R. Bevier. </author> <title> "Kit and the Short Stack". </title> <journal> Journal of Automated Reasoning 5, </journal> <volume> 4 (1989), </volume> <pages> 519-530. </pages>
Reference-contexts: We have also seen a proof of correctness of a small operating system kernel (KIT) <ref> [2] </ref>. Except for the Piton work, all of these projects represent Ph.D. dissertations in computer science which we supervised at the University of Texas.
Reference: 3. <author> William Bevier, Matt Kaufmann, and William Young. </author> <title> Translation of a Gypsy Compiler Example into the Boyer-Moore Logic. Internal Note 169, Computational Logic, </title> <publisher> Inc., </publisher> <month> January, </month> <year> 1990. </year>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in <ref> [1, 31, 32, 33, 40, 75, 3] </ref>, [48, 44, 41, 42], [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 4. <author> W.W. Bledsoe. </author> <title> "Splitting and Reduction Heuristics in Automatic Theorem Proving". </title> <booktitle> Artificial Intelligence 2 (1971), </booktitle> <pages> 55-77. </pages>
Reference-contexts: We were inspired in part to build a theorem prover that is heuristic by the success of W. W. Bledsoe <ref> [4] </ref>, [5] in writing such theorem provers, including one that guessed inductions based upon the terms in the conjecture. One of the major concerns in the literature on automated reasoning in the 60's and 70's was with the completeness of proof procedures. <p> This heuristic is startlingly successful for the NQTHM logic. 5 3.5 Simplification Besides induction, the other most important theorem proving component in NQTHM is the simplifier. The simplifier combines rewriting (cf. [74] and <ref> [4] </ref>) with linear and binary resolution and subsumption (cf. [65] and [53]). The simplifier also includes a semi-decision procedure for a part of arithmetic, based upon ideas in [36].
Reference: 5. <author> W. Bledsoe, R. Boyer, and W. Henneman. </author> <title> "Computer Proofs of Limit Theorems". </title> <booktitle> Artificial Intelligence 3 (1972), </booktitle> <pages> 27-60. </pages>
Reference-contexts: We were inspired in part to build a theorem prover that is heuristic by the success of W. W. Bledsoe [4], <ref> [5] </ref> in writing such theorem provers, including one that guessed inductions based upon the terms in the conjecture. One of the major concerns in the literature on automated reasoning in the 60's and 70's was with the completeness of proof procedures.
Reference: 6. <author> N. Bourbaki. </author> <title> Elements of Mathematics. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1968. </year>
Reference-contexts: There has been much doubt cast on the feasibility of formal proofs, even by such respected authorities as Bourbaki <ref> [6] </ref> But formalized mathematics cannot in practice be written down in full, and therefore we must have confidence in what might be called the common sense of the mathematician ... We shall therefore very quickly abandon formalized mathematics ...
Reference: 7. <author> R. S. Boyer and J S. Moore. </author> <title> "Program Verification". </title> <journal> Journal of Automated Reasoning 1, </journal> <volume> 1 (1985), </volume> <pages> 17-23. </pages>
Reference-contexts: The tediousness and error level are perhaps due to this length and also to the fact that many parts of computing systems are mathematically boring. The idea of mechanically checking proofs of correctness of computing systems has been pursued by many researchers, e.g. those mentioned in the review article <ref> [7] </ref>.
Reference: 8. <author> R. S. Boyer, D. M. Goldschlag, M. Kaufmann, and J S. Moore. </author> <title> Functional Instantiation in First Order Logic, Report 44. </title> <booktitle> Computational Logic, 1717 W. 6th St., </booktitle> <address> Austin, Texas, 78703, U.S.A., </address> <year> 1989. </year> <booktitle> To appear in the proceedings of the 1989 Workshop on Programming Logic, Programming Methodology Group, </booktitle> <institution> University of Goteborg. </institution>
Reference-contexts: addition of metafunctions and an efficient representation for large constant terms, described in [12], (c) some simplifications of the induction machinery that have never been documented, (d) the axiomatization of an interpreter for partial recursive functions [20], and (e) an implementation of a derived rule of inference called ``functional instantiation'' <ref> [8] </ref>. 4 The Importance of the User in Finding Proofs Although NQTHM is quite capable of finding proofs for some simple theorems with which even graduate students may struggle, we think of NQTHM as more of a proof checker than as a theorem-prover.
Reference: 9. <author> R. S. Boyer and J S. Moore. </author> <title> "Proving Theorems about LISP Functions". </title> <journal> JACM 22, </journal> <volume> 1 (1975), </volume> <pages> 129-144. </pages>
Reference-contexts: We thank Mark Stickel and the program committee for the invitation. It has been suggested that we discuss our theorem prover and its application to proving the correctness of computations. We have been working on our prover, on and off, since about 1972 <ref> [9] </ref>. This prover is known both as the Boyer-Moore theorem prover and as NQTHM. (pronounced en-que-thum, an acronym for ``New, Quantified THeoreM Prover,'' an uninspired parochialism that has taken on a life of its own). <p> This schema would be merely a derived rule of inference were we to cast our induction axioms in the traditional form. The syntax of our logic is close to that of Lisp. In fact, from the time we started writing our prover <ref> [9] </ref> we have regarded it as a theorem prover for a theory of Lisp functions. Some of the earliest theorems we proved mechanically were inspired by some of McCarthy's seminal papers on the logic of Lisp, including [54], [56], and [58]. <p> The situation is entirely different for some ``real theorem-provers,'' such as those of Wu and Chou [27], which one expects to decide quickly any theorem in their domain. The earliest version of NQTHM <ref> [9] </ref> had no facility for user guidance.
Reference: 10. <author> R. S. Boyer and J S. Moore. </author> <title> A Lemma Driven Automatic Theorem Prover for Recursive Function Theory. </title> <booktitle> Proceedings of the 5th Joint Conference on Artificial Intelligence, </booktitle> <year> 1977, </year> <pages> pp. 511-519. </pages>
Reference-contexts: prove theorems harder than these (without ``cheating'' by adding additional formulas as axioms), the most important step we took was to permit the user to suggest ``lemmas,'' i.e. intermediate theorems, which would first be proved by NQTHM and then made available for use in subsequent proofs, mainly by the simplifier <ref> [10] </ref>.
Reference: 11. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: In the subsequent discussion, we will make reference to two books, which are the main references on NQTHM. They are (a) A Computational Logic <ref> [11] </ref> which we will abbreviate as ``ACL'' and (b) A Computational Logic Handbook [18] which we will abbreviate as ``ACLH''. <p> However, by using 3 recursive functions, we are able to express many of the things that one usually expresses with quantifiers when dealing with ``finite'' objects such as trees of integers. For example, to state and prove the uniqueness and existence of prime factorizations <ref> [11] </ref>, we define recursive functions which factor integers and which compute whether two finite sequences of integers are permutations of one another.
Reference: 12. <author> R. S. Boyer and J S. Moore. Metafunctions: </author> <title> Proving Them Correct and Using Them Efficiently as New Proof Procedures. In The Correctness Problem in Computer Science, </title> <editor> R. S. Boyer and J S. Moore, Eds., </editor> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: That work remains a largely accurate description of NQTHM except for (a) the integration of the arithmetic decision procedure, described in [19], (b) the addition of metafunctions and an efficient representation for large constant terms, described in <ref> [12] </ref>, (c) some simplifications of the induction machinery that have never been documented, (d) the axiomatization of an interpreter for partial recursive functions [20], and (e) an implementation of a derived rule of inference called ``functional instantiation'' [8]. 4 The Importance of the User in Finding Proofs Although NQTHM is quite <p> On pp. 4-9 of ACLH, we enumerate many other applications of NQTHM, including those in list processing, elementary number theory, metamathematics, set theory, and concurrent algorithms. Descriptions of some of these applications may be found in <ref> [16, 66, 12, 21, 17, 67] </ref>, [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25].
Reference: 13. <author> R. S. Boyer and J S. Moore. </author> <title> A Verification Condition Generator for FORTRAN. In The Correctness Problem in Computer Science, </title> <editor> R. S. Boyer and J S. Moore, Eds., </editor> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], <ref> [13, 14, 15, 22, 77] </ref>, and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 14. <author> R. S. Boyer and J S. Moore. </author> <title> The Mechanical Verification of a FORTRAN Square Root Program. </title> <booktitle> SRI International, </booktitle> <year> 1981. </year>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], <ref> [13, 14, 15, 22, 77] </ref>, and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 15. <author> R. S. Boyer and J S. Moore. </author> <title> MJRTY - A Fast Majority Vote Algorithm. </title> <type> Technical Report ICSCA-CMP-32, </type> <institution> Institute for Computing Science and Computer Applications, University of Texas at Austin, </institution> <year> 1982. </year> <month> 14 </month>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], <ref> [13, 14, 15, 22, 77] </ref>, and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 16. <author> R. S. Boyer and J S. Moore. </author> <title> "Proof Checking the RSA Public Key Encryption Algorithm". </title> <journal> American Mathematical Monthly 91, </journal> <volume> 3 (1984), </volume> <pages> 181-189. </pages>
Reference-contexts: feel more like a proof checker than a theorem prover, but on the other hand it permits the 6 checking of a very substantial part of elementary number theory [66], even including Gauss's law of quadratic reciprocity (the crown jewel of number theory), and the correctness of some interesting algorithms <ref> [16] </ref>. 5 Our Motivation: Computer System Correctness Given that NQTHM is not a very ``smart'' theorem prover, one might well ask why we have kept working on it for so many years! Our main motivation has been to develop NQTHM into a system that can be used in a practical way <p> On pp. 4-9 of ACLH, we enumerate many other applications of NQTHM, including those in list processing, elementary number theory, metamathematics, set theory, and concurrent algorithms. Descriptions of some of these applications may be found in <ref> [16, 66, 12, 21, 17, 67] </ref>, [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25].
Reference: 17. <author> R. S. Boyer and J S. Moore. </author> <title> "A Mechanical Proof of the Unsolvability of the Halting Problem". </title> <journal> JACM 31, </journal> <volume> 3 (1984), </volume> <pages> 441-458. </pages>
Reference-contexts: On pp. 4-9 of ACLH, we enumerate many other applications of NQTHM, including those in list processing, elementary number theory, metamathematics, set theory, and concurrent algorithms. Descriptions of some of these applications may be found in <ref> [16, 66, 12, 21, 17, 67] </ref>, [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25].
Reference: 18. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: In the subsequent discussion, we will make reference to two books, which are the main references on NQTHM. They are (a) A Computational Logic [11] which we will abbreviate as ``ACL'' and (b) A Computational Logic Handbook <ref> [18] </ref> which we will abbreviate as ``ACLH''.
Reference: 19. <author> R. S. Boyer and J S. Moore. </author> <title> Integrating Decision Procedures into Heuristic Theorem Provers: A Case Study with Linear Arithmetic. </title> <booktitle> In Machine Intelligence 11, </booktitle> <publisher> Oxford University Press, </publisher> <year> 1988. </year>
Reference-contexts: That work remains a largely accurate description of NQTHM except for (a) the integration of the arithmetic decision procedure, described in <ref> [19] </ref>, (b) the addition of metafunctions and an efficient representation for large constant terms, described in [12], (c) some simplifications of the induction machinery that have never been documented, (d) the axiomatization of an interpreter for partial recursive functions [20], and (e) an implementation of a derived rule of inference called
Reference: 20. <author> R. S. Boyer and J S. Moore. </author> <title> "The Addition of Bounded Quantification and Partial Functions to A Computational Logic and Its Theorem Prover". </title> <booktitle> Journal of Automated Reasoning 4 (1988), </booktitle> <pages> 117-172. </pages>
Reference-contexts: for (a) the integration of the arithmetic decision procedure, described in [19], (b) the addition of metafunctions and an efficient representation for large constant terms, described in [12], (c) some simplifications of the induction machinery that have never been documented, (d) the axiomatization of an interpreter for partial recursive functions <ref> [20] </ref>, and (e) an implementation of a derived rule of inference called ``functional instantiation'' [8]. 4 The Importance of the User in Finding Proofs Although NQTHM is quite capable of finding proofs for some simple theorems with which even graduate students may struggle, we think of NQTHM as more of a <p> On pp. 4-9 of ACLH, we enumerate many other applications of NQTHM, including those in list processing, elementary number theory, metamathematics, set theory, and concurrent algorithms. Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], <ref> [68, 69, 20, 60, 28, 51, 37, 52] </ref>, [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25].
Reference: 21. <author> R. S. Boyer and J S. Moore. </author> <title> A Mechanical Proof of the Turing Completeness of Pure Lisp. In Automated Theorem Proving: After 25 Years, W.W. </title> <editor> Bledsoe and D.W. Loveland, Eds., </editor> <publisher> American Mathematical Society, </publisher> <address> Providence, R.I., </address> <year> 1984, </year> <pages> pp. 133-167. </pages>
Reference-contexts: On pp. 4-9 of ACLH, we enumerate many other applications of NQTHM, including those in list processing, elementary number theory, metamathematics, set theory, and concurrent algorithms. Descriptions of some of these applications may be found in <ref> [16, 66, 12, 21, 17, 67] </ref>, [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25].
Reference: 22. <author> R. S. Boyer, M. W. Green and J S. Moore. </author> <title> The Use of a Formal Simulator to Verify a Simple Real Time Control Program. </title> <editor> In D. Gries, et. al, Ed., </editor> <title> Beauty Is Our Business, </title> <publisher> Springer, </publisher> <year> 1990. </year> <note> To Appear. </note>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], <ref> [13, 14, 15, 22, 77] </ref>, and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 23. <author> A. Bronstein and C. Talcott. </author> <title> String-Functional Semantics for Formal Verification of Synchronous Circuits, </title> <type> Report No. </type> <institution> STAN-CS-88-1210. Computer Science Department, Stanford University, </institution> <year> 1988. </year>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], <ref> [39, 45, 23, 24, 25] </ref>. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 24. <author> A. Bronstein. </author> <title> MLP: String-functional semantics and Boyer-Moore mechanization for the formal verification of synchronous circuits. </title> <type> Ph.D. </type> <institution> Th., Stanford University, </institution> <year> 1989. </year>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], <ref> [39, 45, 23, 24, 25] </ref>. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 25. <author> A. Bronstein and C. Talcott. </author> <title> Formal Verification of Synchronous Circuits based on String-Functional Semantics: The 7 Paillet Circuits in Boyer-Moore. C-Cube 1989 Workshop on Automatic Verification Methods for Finite State Systems. </title> <publisher> LNCS 407, </publisher> <year> 1989, </year> <pages> pp. 317-333. </pages>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], <ref> [39, 45, 23, 24, 25] </ref>. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 26. <author> R. Burstall. </author> <title> "Proving Properties of Programs by Structural Induction". </title> <journal> The Computer Journal 12, </journal> <volume> 1 (1969), </volume> <pages> 41-48. </pages>
Reference-contexts: In those papers fifteen programs, including a sort routine, are specified, coded in machine language, and proved correct. Although correctness proofs were undoubtedly constructed by many early programmers, publications about this idea seem rare until the 60s, when McCarthy [56], Floyd [30], Hoare [35], and Burstall <ref> [26] </ref> described means for proving the correctness of programs written in higher level languages. Subsequently a rather sizable literature on the subject has developed. Proofs of the correctness of computing systems seem to be much longer, much more tedious, and much more error prone than proofs in ordinary mathematics. <p> We have mentioned above Woody Bledsoe's influence on our work in showing how to write heuristic theorem provers similar to ours. We thank Rod Burstall for his inspiring and elegant paper on structural induction <ref> [26] </ref>. We thank Burstall, Michie, and Popplestone for use of the POP2 system running on an ICL 4130 on which we coded the earliest version of our prover.
Reference: 27. <author> S. Chou. </author> <title> Mechancial Geometry Theorem Proving. </title> <publisher> Reidel, </publisher> <year> 1988. </year>
Reference-contexts: And when filling in such minor details, NQTHM very often exposes minor oversights in our statement of theorems. The situation is entirely different for some ``real theorem-provers,'' such as those of Wu and Chou <ref> [27] </ref>, which one expects to decide quickly any theorem in their domain. The earliest version of NQTHM [9] had no facility for user guidance. <p> In a few areas of mathematics, such as those described by <ref> [27] </ref> the cost is much less than doing careful hand proofs.
Reference: 28. <author> Benedetto Lorenzo Di Vito. </author> <title> Verification of Communications Protocols and Abstract Process Models. </title> <type> Ph.D. </type> <institution> Th., University of Texas at Austin, </institution> <year> 1982. </year>
Reference-contexts: On pp. 4-9 of ACLH, we enumerate many other applications of NQTHM, including those in list processing, elementary number theory, metamathematics, set theory, and concurrent algorithms. Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], <ref> [68, 69, 20, 60, 28, 51, 37, 52] </ref>, [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25].
Reference: 29. <author> T. L. </author> <title> Heath (translation and commentary). The Thirteen Books of Euclid's Elements. </title> <publisher> Dover, </publisher> <address> New York , 1908. p. </address> <note> 298, Vol 2., i.e. Proposition 2, Book VII. </note>
Reference-contexts: The idea of proving the correctness of algorithms is at least as old as Euclid's demonstration of the correctness of an algorithm for finding the greatest common divisor of two integers <ref> [29] </ref>. The idea of correctness proofs is also clearly stated in the classic papers of Goldstine and von Neumann [73] that describe the first von Neumann machine and how to use it. In those papers fifteen programs, including a sort routine, are specified, coded in machine language, and proved correct.
Reference: 30. <author> R. Floyd. </author> <title> Assigning Meanings to Programs. </title> <booktitle> In Mathematical Aspects of Computer Science, Proceedings of Symposia in Applied Mathematics, </booktitle> <publisher> American Mathematical Society, </publisher> <address> Providence, Rhode Island, </address> <year> 1967, </year> <pages> pp. 19-32. </pages>
Reference-contexts: In those papers fifteen programs, including a sort routine, are specified, coded in machine language, and proved correct. Although correctness proofs were undoubtedly constructed by many early programmers, publications about this idea seem rare until the 60s, when McCarthy [56], Floyd <ref> [30] </ref>, Hoare [35], and Burstall [26] described means for proving the correctness of programs written in higher level languages. Subsequently a rather sizable literature on the subject has developed.
Reference: 31. <author> David M. Goldschlag. </author> <title> "Mechanically Verifying Concurrent Programs with the Boyer-Moore Prover". </title> <journal> IEEE Transactions on Software Engineering (September 1990). </journal> <note> To appear. 15 </note>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in <ref> [1, 31, 32, 33, 40, 75, 3] </ref>, [48, 44, 41, 42], [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 32. <author> David M. Goldschlag. </author> <title> Mechanizing Unity. </title> <booktitle> In Proceedings of the IFIP TC2/WG2.3 Working Conference on Programming Concepts and Methods, </booktitle> <editor> M. Broy and C. B. Jones, Eds., </editor> <publisher> Elsevier, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in <ref> [1, 31, 32, 33, 40, 75, 3] </ref>, [48, 44, 41, 42], [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 33. <author> David M. Goldschlag. </author> <title> "Proving Proof Rules: A Proof System for Concurrent Programs". </title> <note> Compass '90 (June 1990). </note>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in <ref> [1, 31, 32, 33, 40, 75, 3] </ref>, [48, 44, 41, 42], [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 34. <author> R. L. Goodstein. </author> <title> Recursive Number Theory. </title> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1964. </year>
Reference-contexts: This practice of using recursive functions to do work one might do with quantifiers may have been originated by Skolem in [71], who was perhaps the earliest to demonstrate that arithmetic could be built up using entirely constructive methods. Skolem's program is further carried out in <ref> [34] </ref>.
Reference: 35. <author> C. A. R. Hoare. </author> <title> "An Axiomatic Basis for Computer Programming". </title> <journal> Comm. ACM 12, </journal> <volume> 10 (1969), </volume> <pages> 576-583. </pages>
Reference-contexts: In those papers fifteen programs, including a sort routine, are specified, coded in machine language, and proved correct. Although correctness proofs were undoubtedly constructed by many early programmers, publications about this idea seem rare until the 60s, when McCarthy [56], Floyd [30], Hoare <ref> [35] </ref>, and Burstall [26] described means for proving the correctness of programs written in higher level languages. Subsequently a rather sizable literature on the subject has developed.
Reference: 36. <author> L. Hodes. </author> <title> Solving Problems by Formula Manipulation. </title> <booktitle> Proc. Second Inter. Joint Conf. on Art. Intell., The British Computer Society, </booktitle> <year> 1971, </year> <pages> pp. 553-559. </pages>
Reference-contexts: The simplifier combines rewriting (cf. [74] and [4]) with linear and binary resolution and subsumption (cf. [65] and [53]). The simplifier also includes a semi-decision procedure for a part of arithmetic, based upon ideas in <ref> [36] </ref>.
Reference: 37. <author> C.-H. Huang and C. Lengauer. </author> <title> "The Automated Proof of a Trace Transformation for a Bitonic Sort". </title> <booktitle> Theoretical Computer Science 1, 46 (1986), </booktitle> <pages> 261-284. </pages>
Reference-contexts: On pp. 4-9 of ACLH, we enumerate many other applications of NQTHM, including those in list processing, elementary number theory, metamathematics, set theory, and concurrent algorithms. Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], <ref> [68, 69, 20, 60, 28, 51, 37, 52] </ref>, [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25].
Reference: 38. <author> W. A. Hunt. </author> <title> "Microprocessor Design Verification". </title> <journal> Journal of Automated Reasoning 5, </journal> <volume> 4 (1989), </volume> <pages> 429-460. </pages>
Reference-contexts: By far, the most significant application of NQTHM has been to a prove the correctness of a computing system known as the CLI Stack, which includes (a) a microprocessor design (FM8502) based on gates and registers <ref> [38] </ref>, (b) an assembler (Piton) [61] that targets FM8502, and (c) a higher level language (micro Gypsy) [76] that targets Piton. We have also seen a proof of correctness of a small operating system kernel (KIT) [2].
Reference: 39. <author> Matt Kaufmann. </author> <title> A Formal Semantics and Proof of Soundness for the Logic of the NQTHM Version of the Boyer-Moore Theorem Prover. Internal Note 229, </title> <institution> Institute for Computing Science, University of Texas at Austin, </institution> <month> February, </month> <year> 1987. </year>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], <ref> [39, 45, 23, 24, 25] </ref>. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 40. <author> Matt Kaufmann. </author> <title> A Mechanically-checked Semi-interactive Proof of Correctness of Gries's Algorithm for Finding the Largest Size of a Square True Submatrix. Internal Note 236, </title> <institution> Institute for Computing Science, University of Texas at Austin, </institution> <month> October, </month> <year> 1986. </year>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in <ref> [1, 31, 32, 33, 40, 75, 3] </ref>, [48, 44, 41, 42], [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance. <p> Among the theorems which Kaufmann has checked with PC-NQTHM are: Ramsey's theorem for exponent 2 (both finite and infinite versions), with explicit bound in the finite case [41, 46]. Correctness of an algorithm of Gries for finding the largest ``true square'' submatrix of a boolean matrix <ref> [40] </ref>. The Cantor-Schroeder-Bernstein theorem [46]. The correctness of a Towers of Hanoi program. The irrationality of the square root of 2. Correctness of a finite version of the collapsing function of Cohen forcing. 7 Work in Progress: ACL2 We are currently constructing an entirely new version of our prover.
Reference: 41. <author> Matt Kaufmann. </author> <title> An Example in NQTHM: Ramsey's Theorem. Internal Note 100, Computational Logic, </title> <publisher> Inc., </publisher> <month> November, </month> <year> 1988. </year>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], <ref> [48, 44, 41, 42] </ref>, [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance. <p> Information about PC-NQTHM and some extensions and applications may be found in [46, 49, 45, 47, 63, 43, 76]. Among the theorems which Kaufmann has checked with PC-NQTHM are: Ramsey's theorem for exponent 2 (both finite and infinite versions), with explicit bound in the finite case <ref> [41, 46] </ref>. Correctness of an algorithm of Gries for finding the largest ``true square'' submatrix of a boolean matrix [40]. The Cantor-Schroeder-Bernstein theorem [46]. The correctness of a Towers of Hanoi program. The irrationality of the square root of 2.
Reference: 42. <author> Matt Kaufmann. </author> <title> Boyer-Moore-ish Micro Gypsy and a Prototype Hardware Expander. Internal Note 73, Computational Logic, </title> <publisher> Inc., </publisher> <month> August, </month> <year> 1988. </year>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], <ref> [48, 44, 41, 42] </ref>, [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 43. <author> Matt Kaufmann. </author> <title> A Mutual Recursion and Dependency Analysis Tool for NQTHM. Internal Note 99, Computational Logic, </title> <publisher> Inc., </publisher> <year> 1988. </year>
Reference-contexts: Matt Kaufmann, of Computational Logic, Inc., has made extensive additions to NQTHM, building a system called ``PC-NQTHM'' on top of NQTHM, which many find more convenient than NQTHM for checking proofs. Information about PC-NQTHM and some extensions and applications may be found in <ref> [46, 49, 45, 47, 63, 43, 76] </ref>. Among the theorems which Kaufmann has checked with PC-NQTHM are: Ramsey's theorem for exponent 2 (both finite and infinite versions), with explicit bound in the finite case [41, 46].
Reference: 44. <author> Matt Kaufmann. </author> <title> A User's Manual for RCL. Internal Note 157, Computational Logic, </title> <publisher> Inc., </publisher> <month> October, </month> <year> 1989. </year>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], <ref> [48, 44, 41, 42] </ref>, [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 45. <author> Matt Kaufmann and Matt Wilding. </author> <title> A Parallel Version of the Boyer-Moore Prover. </title> <type> Tech. </type> <institution> Rept. </institution> <month> 39, </month> <title> Computational Logic, </title> <publisher> Inc., </publisher> <month> February, </month> <year> 1989. </year>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], <ref> [39, 45, 23, 24, 25] </ref>. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance. <p> Matt Kaufmann, of Computational Logic, Inc., has made extensive additions to NQTHM, building a system called ``PC-NQTHM'' on top of NQTHM, which many find more convenient than NQTHM for checking proofs. Information about PC-NQTHM and some extensions and applications may be found in <ref> [46, 49, 45, 47, 63, 43, 76] </ref>. Among the theorems which Kaufmann has checked with PC-NQTHM are: Ramsey's theorem for exponent 2 (both finite and infinite versions), with explicit bound in the finite case [41, 46].
Reference: 46. <author> Matt Kaufmann. DEFN-SK: </author> <title> An Extension of the Boyer-Moore Theorem Prover to Handle First-Order Quantifiers. </title> <type> Tech. </type> <institution> Rept. </institution> <month> 43, </month> <title> Computational Logic, </title> <publisher> Inc., 1717 W. </publisher> <address> 6th St, Suite 290, Austin, Texas, </address> <month> June, </month> <year> 1989. </year>
Reference-contexts: Matt Kaufmann, of Computational Logic, Inc., has made extensive additions to NQTHM, building a system called ``PC-NQTHM'' on top of NQTHM, which many find more convenient than NQTHM for checking proofs. Information about PC-NQTHM and some extensions and applications may be found in <ref> [46, 49, 45, 47, 63, 43, 76] </ref>. Among the theorems which Kaufmann has checked with PC-NQTHM are: Ramsey's theorem for exponent 2 (both finite and infinite versions), with explicit bound in the finite case [41, 46]. <p> Information about PC-NQTHM and some extensions and applications may be found in [46, 49, 45, 47, 63, 43, 76]. Among the theorems which Kaufmann has checked with PC-NQTHM are: Ramsey's theorem for exponent 2 (both finite and infinite versions), with explicit bound in the finite case <ref> [41, 46] </ref>. Correctness of an algorithm of Gries for finding the largest ``true square'' submatrix of a boolean matrix [40]. The Cantor-Schroeder-Bernstein theorem [46]. The correctness of a Towers of Hanoi program. The irrationality of the square root of 2. <p> Correctness of an algorithm of Gries for finding the largest ``true square'' submatrix of a boolean matrix [40]. The Cantor-Schroeder-Bernstein theorem <ref> [46] </ref>. The correctness of a Towers of Hanoi program. The irrationality of the square root of 2. Correctness of a finite version of the collapsing function of Cohen forcing. 7 Work in Progress: ACL2 We are currently constructing an entirely new version of our prover.
Reference: 47. <author> Matt Kaufmann. </author> <title> Addition of Free Variables to an Interactive Enhancement of the Boyer-Moore Theorem Prover. </title> <type> Tech. </type> <institution> Rept. 42, Computational Logic, Inc., Austin, Texas, </institution> <month> May, </month> <year> 1989. </year> <month> 16 </month>
Reference-contexts: Matt Kaufmann, of Computational Logic, Inc., has made extensive additions to NQTHM, building a system called ``PC-NQTHM'' on top of NQTHM, which many find more convenient than NQTHM for checking proofs. Information about PC-NQTHM and some extensions and applications may be found in <ref> [46, 49, 45, 47, 63, 43, 76] </ref>. Among the theorems which Kaufmann has checked with PC-NQTHM are: Ramsey's theorem for exponent 2 (both finite and infinite versions), with explicit bound in the finite case [41, 46].
Reference: 48. <author> Matt Kaufmann. </author> <title> A Mechanically-checked Correctness Proof for Generalization in the Presence of Free Variables. </title> <type> Tech. </type> <institution> Rept. 53, Computational Logic, Inc., Austin, Texas, </institution> <month> March, </month> <year> 1990. </year>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], <ref> [48, 44, 41, 42] </ref>, [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 49. <author> Matt Kaufmann. </author> <title> An Integer Library for NQTHM. Internal Note 182, Computational Logic, </title> <publisher> Inc., </publisher> <month> March, </month> <year> 1990. </year>
Reference-contexts: Matt Kaufmann, of Computational Logic, Inc., has made extensive additions to NQTHM, building a system called ``PC-NQTHM'' on top of NQTHM, which many find more convenient than NQTHM for checking proofs. Information about PC-NQTHM and some extensions and applications may be found in <ref> [46, 49, 45, 47, 63, 43, 76] </ref>. Among the theorems which Kaufmann has checked with PC-NQTHM are: Ramsey's theorem for exponent 2 (both finite and infinite versions), with explicit bound in the finite case [41, 46].
Reference: 50. <author> Leslie Lamport, Robert Shostak, and Marshall Pease. </author> <title> "The Byzantine Generals Problem". </title> <journal> ACM TOPLAS 4, </journal> <month> 3 (July </month> <year> 1982), </year> <pages> 382-401. </pages>
Reference-contexts: This problem, called the Byzantine Generals problem or the problem of achieving interactive consistency, was posed and solved by Pease, Shostak, and Lamport <ref> [64, 50] </ref>. They proved that the problem is solvable if and only if the total number of processors exceeds three times the number of faulty processors and devised an extremely clever algorithm (the ``Oral Messages'' Algorithm) which implements a solution to this problem.
Reference: 51. <author> C. Lengauer. </author> <title> "On the Role of Automated Theorem Proving in the Compile-Time Derivation of Concurrency". </title> <journal> Journal of Automated Reasoning 1, </journal> <volume> 1 (1985), </volume> <pages> 75-101. </pages>
Reference-contexts: On pp. 4-9 of ACLH, we enumerate many other applications of NQTHM, including those in list processing, elementary number theory, metamathematics, set theory, and concurrent algorithms. Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], <ref> [68, 69, 20, 60, 28, 51, 37, 52] </ref>, [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25].
Reference: 52. <author> C. Lengauer and C.-H. Huang. </author> <title> A Mechanically Certified Theorem about Optimal Concurrency of Sorting Networks. </title> <booktitle> Proc. 13th Ann. ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1986, </year> <pages> pp. 307-317. </pages>
Reference-contexts: On pp. 4-9 of ACLH, we enumerate many other applications of NQTHM, including those in list processing, elementary number theory, metamathematics, set theory, and concurrent algorithms. Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], <ref> [68, 69, 20, 60, 28, 51, 37, 52] </ref>, [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25].
Reference: 53. <author> D. Loveland. </author> <title> Automated Theorem Proving: A Logical Basis. </title> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1978. </year>
Reference-contexts: This heuristic is startlingly successful for the NQTHM logic. 5 3.5 Simplification Besides induction, the other most important theorem proving component in NQTHM is the simplifier. The simplifier combines rewriting (cf. [74] and [4]) with linear and binary resolution and subsumption (cf. [65] and <ref> [53] </ref>). The simplifier also includes a semi-decision procedure for a part of arithmetic, based upon ideas in [36].
Reference: 54. <author> J. McCarthy. </author> <title> "Recursive Functions of Symbolics Expressions and their Computation by Machine". </title> <journal> Communications of the Association for Computing Machinery 3, </journal> <volume> 4 (1960), </volume> <pages> 184-195. </pages>
Reference-contexts: In fact, from the time we started writing our prover [9] we have regarded it as a theorem prover for a theory of Lisp functions. Some of the earliest theorems we proved mechanically were inspired by some of McCarthy's seminal papers on the logic of Lisp, including <ref> [54] </ref>, [56], and [58]. Because Lisp may be viewed as both a logic and a programming language, we have always found it a most natural setting in which to express theorems about computations and other parts of constructive mathematics.
Reference: 55. <author> J. McCarthy. </author> <title> The Lisp Programmer's Manual. </title> <publisher> M.I.T. Computation Center, </publisher> <year> 1960. </year>
Reference-contexts: The time and place seemed to be embued with quiet inspiration. It is hard for us to imagine that our prover could have put down its roots anyplace else. John McCarthy's influence on our work has been major. His invention of Lisp gave us a language <ref> [55, 59] </ref> in which to write NQTHM. His papers on proof checking, e.g. [57], and the mathematical theory of computation [58] gave us incentive to write a prover for program verification, reasoning techniques to encode, and sample theorems on which to work.
Reference: 56. <author> J. McCarthy. </author> <title> Towards a Mathematical Science of Computation. </title> <booktitle> Proceedings of IFIP Congress, </booktitle> <year> 1962, </year> <pages> pp. 21-28. </pages>
Reference-contexts: In fact, from the time we started writing our prover [9] we have regarded it as a theorem prover for a theory of Lisp functions. Some of the earliest theorems we proved mechanically were inspired by some of McCarthy's seminal papers on the logic of Lisp, including [54], <ref> [56] </ref>, and [58]. Because Lisp may be viewed as both a logic and a programming language, we have always found it a most natural setting in which to express theorems about computations and other parts of constructive mathematics. <p> In those papers fifteen programs, including a sort routine, are specified, coded in machine language, and proved correct. Although correctness proofs were undoubtedly constructed by many early programmers, publications about this idea seem rare until the 60s, when McCarthy <ref> [56] </ref>, Floyd [30], Hoare [35], and Burstall [26] described means for proving the correctness of programs written in higher level languages. Subsequently a rather sizable literature on the subject has developed.
Reference: 57. <author> J. McCarthy. </author> <title> Computer Programs for Checking Mathematical Proofs. Recursive Function Theory, </title> <booktitle> Proceedings of a Symposium in Pure Mathematics, </booktitle> <address> Providence, Rhode Island, </address> <year> 1962, </year> <pages> pp. 219-227. </pages>
Reference-contexts: It is hard for us to imagine that our prover could have put down its roots anyplace else. John McCarthy's influence on our work has been major. His invention of Lisp gave us a language [55, 59] in which to write NQTHM. His papers on proof checking, e.g. <ref> [57] </ref>, and the mathematical theory of computation [58] gave us incentive to write a prover for program verification, reasoning techniques to encode, and sample theorems on which to work. We have mentioned above Woody Bledsoe's influence on our work in showing how to write heuristic theorem provers similar to ours.
Reference: 58. <author> J. McCarthy. </author> <title> A Basis for a Mathematical Theory of Computation. In Computer Programming and Formal Systems, </title> <editor> P. Braffort and D. Hershberg, Eds., </editor> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, The Netherlands, </address> <year> 1963. </year>
Reference-contexts: Some of the earliest theorems we proved mechanically were inspired by some of McCarthy's seminal papers on the logic of Lisp, including [54], [56], and <ref> [58] </ref>. Because Lisp may be viewed as both a logic and a programming language, we have always found it a most natural setting in which to express theorems about computations and other parts of constructive mathematics. <p> John McCarthy's influence on our work has been major. His invention of Lisp gave us a language [55, 59] in which to write NQTHM. His papers on proof checking, e.g. [57], and the mathematical theory of computation <ref> [58] </ref> gave us incentive to write a prover for program verification, reasoning techniques to encode, and sample theorems on which to work. We have mentioned above Woody Bledsoe's influence on our work in showing how to write heuristic theorem provers similar to ours.
Reference: 59. <author> J. McCarthy, et al. </author> <title> LISP 1.5 Programmer's Manual. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1965. </year>
Reference-contexts: The time and place seemed to be embued with quiet inspiration. It is hard for us to imagine that our prover could have put down its roots anyplace else. John McCarthy's influence on our work has been major. His invention of Lisp gave us a language <ref> [55, 59] </ref> in which to write NQTHM. His papers on proof checking, e.g. [57], and the mathematical theory of computation [58] gave us incentive to write a prover for program verification, reasoning techniques to encode, and sample theorems on which to work.
Reference: 60. <author> J S. Moore. </author> <title> "A Mechanical Proof of the Termination of Takeuchi's Function". </title> <journal> Information Processing Letters 9, </journal> <volume> 4 (1979), </volume> <pages> 176-181. </pages>
Reference-contexts: On pp. 4-9 of ACLH, we enumerate many other applications of NQTHM, including those in list processing, elementary number theory, metamathematics, set theory, and concurrent algorithms. Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], <ref> [68, 69, 20, 60, 28, 51, 37, 52] </ref>, [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25].
Reference: 61. <author> J. S. Moore. </author> <title> "A Mechanically Verified Language Implementation". </title> <journal> Journal of Automated Reasoning 5, </journal> <volume> 4 (1989), </volume> <pages> 461-492. </pages>
Reference-contexts: By far, the most significant application of NQTHM has been to a prove the correctness of a computing system known as the CLI Stack, which includes (a) a microprocessor design (FM8502) based on gates and registers [38], (b) an assembler (Piton) <ref> [61] </ref> that targets FM8502, and (c) a higher level language (micro Gypsy) [76] that targets Piton. We have also seen a proof of correctness of a small operating system kernel (KIT) [2].
Reference: 62. <author> J. S. Moore, et. al. </author> <note> "Special Issue on System Verification". Journal of Automated Reasoning 5, </note> <month> 4 </month> <year> (1989), </year> <pages> 409-530. </pages>
Reference-contexts: Except for the Piton work, all of these projects represent Ph.D. dissertations in computer science which we supervised at the University of Texas. FM8502, Piton, micro Gypsy, and Kit are documented in one place, a special issue of the Journal of Automated Reasoning <ref> [62] </ref>. 7 Another major application of NQTHM is the Ph.D. work of N. Shankar in proof checking Godel's incompleteness theorem [69]. The text of this proof effort is included in the standard distribution of NQTHM, along with Shankar's checking of the Church-Rosser theorem.
Reference: 63. <author> Matt Kaufmann. </author> <title> A User's Manual for an Interactive Enhancement to the Boyer-Moore Theorem Prover. </title> <type> Tech. </type> <institution> Rept. 19, Computational Logic, Inc., Austin, Texas, </institution> <month> May, </month> <year> 1988. </year>
Reference-contexts: Matt Kaufmann, of Computational Logic, Inc., has made extensive additions to NQTHM, building a system called ``PC-NQTHM'' on top of NQTHM, which many find more convenient than NQTHM for checking proofs. Information about PC-NQTHM and some extensions and applications may be found in <ref> [46, 49, 45, 47, 63, 43, 76] </ref>. Among the theorems which Kaufmann has checked with PC-NQTHM are: Ramsey's theorem for exponent 2 (both finite and infinite versions), with explicit bound in the finite case [41, 46].
Reference: 64. <author> Marshall Pease, Robert Shostak, and Leslie Lamport. </author> <title> "Reaching Agreement in the Presence of Faults". </title> <type> JACM 27, </type> <month> 2 (April </month> <year> 1980), </year> <pages> 228-234. 17 </pages>
Reference-contexts: This problem, called the Byzantine Generals problem or the problem of achieving interactive consistency, was posed and solved by Pease, Shostak, and Lamport <ref> [64, 50] </ref>. They proved that the problem is solvable if and only if the total number of processors exceeds three times the number of faulty processors and devised an extremely clever algorithm (the ``Oral Messages'' Algorithm) which implements a solution to this problem.
Reference: 65. <author> J. A. Robinson. </author> <title> "A Machine-oriented Logic Based on the Resolution Principle". </title> <journal> JACM 12, </journal> <volume> 1 (1965), </volume> <pages> 23-41. </pages>
Reference-contexts: This heuristic is startlingly successful for the NQTHM logic. 5 3.5 Simplification Besides induction, the other most important theorem proving component in NQTHM is the simplifier. The simplifier combines rewriting (cf. [74] and [4]) with linear and binary resolution and subsumption (cf. <ref> [65] </ref> and [53]). The simplifier also includes a semi-decision procedure for a part of arithmetic, based upon ideas in [36].
Reference: 66. <author> David M. Russinoff. </author> <title> "An Experiment with the Boyer-Moore Theorem Prover: A Proof of Wilson's Theorem". </title> <journal> Journal of Automated Reasoning 1, </journal> <volume> 2 (1985), </volume> <pages> 121-139. </pages>
Reference-contexts: Permitting the use of lemmas on the one hand makes NQTHM feel more like a proof checker than a theorem prover, but on the other hand it permits the 6 checking of a very substantial part of elementary number theory <ref> [66] </ref>, even including Gauss's law of quadratic reciprocity (the crown jewel of number theory), and the correctness of some interesting algorithms [16]. 5 Our Motivation: Computer System Correctness Given that NQTHM is not a very ``smart'' theorem prover, one might well ask why we have kept working on it for so <p> On pp. 4-9 of ACLH, we enumerate many other applications of NQTHM, including those in list processing, elementary number theory, metamathematics, set theory, and concurrent algorithms. Descriptions of some of these applications may be found in <ref> [16, 66, 12, 21, 17, 67] </ref>, [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25].
Reference: 67. <author> N. Shankar. </author> <title> "Towards Mechanical Metamathematics". </title> <journal> Journal of Automated Reasoning 1, </journal> <volume> 4 (1985), </volume> <pages> 407-434. </pages>
Reference-contexts: On pp. 4-9 of ACLH, we enumerate many other applications of NQTHM, including those in list processing, elementary number theory, metamathematics, set theory, and concurrent algorithms. Descriptions of some of these applications may be found in <ref> [16, 66, 12, 21, 17, 67] </ref>, [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25].
Reference: 68. <author> N. Shankar. </author> <title> A Mechanical Proof of the Church-Rosser Theorem. </title> <type> Tech. </type> <institution> Rept. ICSCA-CMP-45, Institute for Computing Science, University of Texas at Austin, </institution> <year> 1985. </year>
Reference-contexts: On pp. 4-9 of ACLH, we enumerate many other applications of NQTHM, including those in list processing, elementary number theory, metamathematics, set theory, and concurrent algorithms. Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], <ref> [68, 69, 20, 60, 28, 51, 37, 52] </ref>, [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25].
Reference: 69. <author> N. Shankar. </author> <title> Proof Checking Metamathematics. </title> <type> Ph.D. </type> <institution> Th., University of Texas at Austin, </institution> <year> 1986. </year>
Reference-contexts: FM8502, Piton, micro Gypsy, and Kit are documented in one place, a special issue of the Journal of Automated Reasoning [62]. 7 Another major application of NQTHM is the Ph.D. work of N. Shankar in proof checking Godel's incompleteness theorem <ref> [69] </ref>. The text of this proof effort is included in the standard distribution of NQTHM, along with Shankar's checking of the Church-Rosser theorem. On pp. 4-9 of ACLH, we enumerate many other applications of NQTHM, including those in list processing, elementary number theory, metamathematics, set theory, and concurrent algorithms. <p> On pp. 4-9 of ACLH, we enumerate many other applications of NQTHM, including those in list processing, elementary number theory, metamathematics, set theory, and concurrent algorithms. Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], <ref> [68, 69, 20, 60, 28, 51, 37, 52] </ref>, [13, 14, 15, 22, 77], and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25].
Reference: 70. <author> J. R. Shoenfield. </author> <title> Mathematical Logic. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Ma., </address> <year> 1967. </year>
Reference-contexts: Roughly speaking, in that chapter, we present our logic (the Boyer-Moore Logic or NQTHM Logic, as it is sometimes known) by starting from standard first order logic as in <ref> [70] </ref> and then adding some axioms that describe certain data structures, including the integers, ordered pairs, and symbols. We include in the logic a principle of definition for recursive functions over these data structures. Among our rules of inference is a schema for proof by induction.
Reference: 71. <author> T. </author> <title> Skolem. The Foundations of Elementary Arithmetic Established by Means of the Recursive Mode of Thought, without the Use of Apparent Variables Ranging over Infinite Domains. In From Frege to Godel, </title> <editor> J. van Heijenoort, Ed., </editor> <publisher> Harvard University Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1967. </year>
Reference-contexts: This practice of using recursive functions to do work one might do with quantifiers may have been originated by Skolem in <ref> [71] </ref>, who was perhaps the earliest to demonstrate that arithmetic could be built up using entirely constructive methods. Skolem's program is further carried out in [34].
Reference: 72. <author> G. L. Steele, Jr. </author> <title> Common Lisp The Language. </title> <publisher> Digital Press, </publisher> <address> 30 North Avenue, Burlington, MA 01803, </address> <year> 1984. </year>
Reference-contexts: That is, ACL2 is to applicative Common Lisp what NQTHM is to the ``Boyer-Moore logic'', a programming/theorem proving environment for an executable logic of recursive functions. More precisely, we have identified an applicative subset of Common Lisp and axiomatized it, following Steele's <ref> [72] </ref> carefully. Because arrays, property lists, input/output and certain other commonly used programming features are not provided applicatively in Common Lisp (i.e., they all involve the notion of explicit state changes), we axiomatized applicative versions of these features.
Reference: 73. <author> J. von Neumann. John von Neumann, </author> <title> Collected Works, Volume V. </title> <publisher> Pergamon Press, Oxford, </publisher> <year> 1961. </year>
Reference-contexts: The idea of correctness proofs is also clearly stated in the classic papers of Goldstine and von Neumann <ref> [73] </ref> that describe the first von Neumann machine and how to use it. In those papers fifteen programs, including a sort routine, are specified, coded in machine language, and proved correct.
Reference: 74. <author> L. Wos, et al. </author> <title> "The concept of demodulation in theorem proving". </title> <journal> Journal of the ACM 14 (1967), </journal> <pages> 698-709. </pages>
Reference-contexts: This heuristic is startlingly successful for the NQTHM logic. 5 3.5 Simplification Besides induction, the other most important theorem proving component in NQTHM is the simplifier. The simplifier combines rewriting (cf. <ref> [74] </ref> and [4]) with linear and binary resolution and subsumption (cf. [65] and [53]). The simplifier also includes a semi-decision procedure for a part of arithmetic, based upon ideas in [36].
Reference: 75. <author> Matt Kaufmann and William D. Young. </author> <title> Comparing Gypsy and the Boyer-Moore Logic for Specifying Secure Systems. </title> <institution> Institute for Computing Science, University of Texas at Austin, </institution> <month> May, </month> <year> 1987. </year> <month> ICSCA-CMP-59. </month>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in <ref> [1, 31, 32, 33, 40, 75, 3] </ref>, [48, 44, 41, 42], [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 76. <author> W. D. Young. </author> <title> "A Mechanically Verified Code Generator". </title> <journal> Journal of Automated Reasoning 5, </journal> <volume> 4 (1989), </volume> <pages> 493-518. </pages>
Reference-contexts: most significant application of NQTHM has been to a prove the correctness of a computing system known as the CLI Stack, which includes (a) a microprocessor design (FM8502) based on gates and registers [38], (b) an assembler (Piton) [61] that targets FM8502, and (c) a higher level language (micro Gypsy) <ref> [76] </ref> that targets Piton. We have also seen a proof of correctness of a small operating system kernel (KIT) [2]. Except for the Piton work, all of these projects represent Ph.D. dissertations in computer science which we supervised at the University of Texas. <p> Matt Kaufmann, of Computational Logic, Inc., has made extensive additions to NQTHM, building a system called ``PC-NQTHM'' on top of NQTHM, which many find more convenient than NQTHM for checking proofs. Information about PC-NQTHM and some extensions and applications may be found in <ref> [46, 49, 45, 47, 63, 43, 76] </ref>. Among the theorems which Kaufmann has checked with PC-NQTHM are: Ramsey's theorem for exponent 2 (both finite and infinite versions), with explicit bound in the finite case [41, 46].
Reference: 77. <author> Yuan Yu. </author> <title> "Computer Proofs in Group Theory". </title> <note> Journal of Automated Reasoning (1990). To appear. Table of Contents </note>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], <ref> [13, 14, 15, 22, 77] </ref>, and also in [1, 31, 32, 33, 40, 75, 3], [48, 44, 41, 42], [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 1. <institution> Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 </institution>
Reference-contexts: Descriptions of some of these applications may be found in [16, 66, 12, 21, 17, 67], [68, 69, 20, 60, 28, 51, 37, 52], [13, 14, 15, 22, 77], and also in <ref> [1, 31, 32, 33, 40, 75, 3] </ref>, [48, 44, 41, 42], [39, 45, 23, 24, 25]. Recently colleagues of ours at Computational Logic, Inc., Bill Young and Bill Bevier, have used NQTHM to construct mechanically checked proofs of properties relating to fault-tolerance.
Reference: 2. <institution> The Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 </institution>
Reference-contexts: We have also seen a proof of correctness of a small operating system kernel (KIT) <ref> [2] </ref>. Except for the Piton work, all of these projects represent Ph.D. dissertations in computer science which we supervised at the University of Texas.

Reference: 4. <institution> The Importance of the User in Finding Proofs . . . . . . . . . . . . . . . . . 5 </institution>
Reference-contexts: We were inspired in part to build a theorem prover that is heuristic by the success of W. W. Bledsoe <ref> [4] </ref>, [5] in writing such theorem provers, including one that guessed inductions based upon the terms in the conjecture. One of the major concerns in the literature on automated reasoning in the 60's and 70's was with the completeness of proof procedures. <p> This heuristic is startlingly successful for the NQTHM logic. 5 3.5 Simplification Besides induction, the other most important theorem proving component in NQTHM is the simplifier. The simplifier combines rewriting (cf. [74] and <ref> [4] </ref>) with linear and binary resolution and subsumption (cf. [65] and [53]). The simplifier also includes a semi-decision procedure for a part of arithmetic, based upon ideas in [36].
Reference: 5. <editor> Our Motivation: </editor> <booktitle> Computer System Correctness . . . . . . . . . . . . . . . 6 </booktitle>
Reference-contexts: We were inspired in part to build a theorem prover that is heuristic by the success of W. W. Bledsoe [4], <ref> [5] </ref> in writing such theorem provers, including one that guessed inductions based upon the terms in the conjecture. One of the major concerns in the literature on automated reasoning in the 60's and 70's was with the completeness of proof procedures.
Reference: 6. <institution> Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 </institution>
Reference-contexts: There has been much doubt cast on the feasibility of formal proofs, even by such respected authorities as Bourbaki <ref> [6] </ref> But formalized mathematics cannot in practice be written down in full, and therefore we must have confidence in what might be called the common sense of the mathematician ... We shall therefore very quickly abandon formalized mathematics ...
Reference: 7. <editor> Work in Progress: </editor> <address> ACL2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 </address>
Reference-contexts: The tediousness and error level are perhaps due to this length and also to the fact that many parts of computing systems are mathematically boring. The idea of mechanically checking proofs of correctness of computing systems has been pursued by many researchers, e.g. those mentioned in the review article <ref> [7] </ref>.

Reference: 9. <institution> Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 i </institution>
Reference-contexts: We thank Mark Stickel and the program committee for the invitation. It has been suggested that we discuss our theorem prover and its application to proving the correctness of computations. We have been working on our prover, on and off, since about 1972 <ref> [9] </ref>. This prover is known both as the Boyer-Moore theorem prover and as NQTHM. (pronounced en-que-thum, an acronym for ``New, Quantified THeoreM Prover,'' an uninspired parochialism that has taken on a life of its own). <p> This schema would be merely a derived rule of inference were we to cast our induction axioms in the traditional form. The syntax of our logic is close to that of Lisp. In fact, from the time we started writing our prover <ref> [9] </ref> we have regarded it as a theorem prover for a theory of Lisp functions. Some of the earliest theorems we proved mechanically were inspired by some of McCarthy's seminal papers on the logic of Lisp, including [54], [56], and [58]. <p> The situation is entirely different for some ``real theorem-provers,'' such as those of Wu and Chou [27], which one expects to decide quickly any theorem in their domain. The earliest version of NQTHM <ref> [9] </ref> had no facility for user guidance.
References-found: 84

