URL: ftp://ftp.cs.washington.edu/tr/1993/09/UW-CSE-93-09-03.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Email: ira@radonc.washington.edu, fnotkin,sullivang@cs.washington.edu  
Title: Prism: A Case Study in Behavioral Entity-Relationship Modeling and Design  
Author: Kevin Sullivany Ira J. Kaletyz David Notkiny 
Note: This work was supported in part by grant number R01 LM04174 from the National Library of Medicine and contract number N01 CM97566 from the National Cancer Institute, and a grant from General Electric Medical Systems, and by the National Science Foundation under Grant Numbers CCR-9113367 and CCR 8858804 and by SRA (Tokyo Japan).  
Date: November 20, 1993  
Address: Seattle, WA 98195  
Affiliation: yDepartment of Computer Science and Engineering zDepartment of Radiation Oncology University of Washington  
Abstract: We describe the collaboratively developed Prism, a tightly integrated but architecturally flexible environment for modeling, visualizing, and simulating radiation treatment plans for cancer patients. Despite significant advances in function, we built Prism at low cost in effort and code size. The key was using behavioral entity-relationship (ER) modeling to craft an architecture, and objects representing abstract behavioral types (ABTs) to implement it. In more detail, we model a system as a set of independently defined entities used directly by clients but made to work together by behavioral relationships connecting them. We implement this model in an imperative programming framework by representing both entities and relationships as instances of classes that define, announce, and register with events in addition to defining and calling operations. Prism provided a realistic test of the behavioral ER modeling and design method. 
Abstract-found: 1
Intro-found: 1
Reference: [Bobrow et al. 88] <author> D.G. Bobrow et al. </author> <title> Common Lisp Object System Specification X3JI3 Document 88-002R. </title> <journal> ACM SIGPLAN Notices 23, </journal> <month> September </month> <year> 1988. </year>
Reference-contexts: An event object maintains an association between the event it represents and the objects and operations to be invoked when the event is announced [Sullivan and Notkin 92]. Events. The implementation environment for Prism is Common Lisp [Steele 90] and CLOS <ref> [Bobrow et al. 88] </ref>. Our first task was to support objects having events as well as operations in their interfaces. We used event object-valued instance variables for this.
Reference: [Dechampeaux 93] <author> D. de Champeaux, D. Lea, and P. Faure, </author> <title> Object-Oriented System Development, </title> <address> (Reading, Massachusetts: </address> <publisher> Addison Wesley), </publisher> <year> 1993. </year> <month> 28 </month>
Reference-contexts: The approach cannot be applied mechanically, but has to be internalized. Finally, we can evaluate the artifacts using well-accepted (although still imperfect) design quality criteria: coupling and cohesion [Stevens, Myers, and Constantine 74]; information hiding [Parnas 72]; structural continuity <ref> [Dechampeaux 93] </ref>; etc. Explicitly applying these concepts is outside the scope of this paper. The system is evidently factored into useful and interesting stand-alone entities integrated by mediators that represent intuitively clear behavioral relationships. New mediator types and instances can be deployed to integrate independent tools and objects.
Reference: [Fraass et al. 87] <author> B. A. Fraass and D. L. McShan, </author> <title> "3-D Treatment Planning I. Overview of a Clinical Planning System," </title> <editor> in I. A. D. Bruinvis, P. H. van der Giessen, H. J. van Kleffens and F. W. Wittkamper, eds., </editor> <booktitle> Proceedings of the Ninth International Conference on the Use of Computers in Radiation Therapy, </booktitle> <address> (Amsterdam: </address> <publisher> North-Holland), </publisher> <year> 1987, </year> <pages> pp. 273-277. </pages>
Reference: [Goitein et al. 83] <author> M. Goitein and others, </author> <title> "Multi-dimensional Treatment Planning: II. Beam's Eye-view, Back Projection, and Projection Through CT Sections," </title> <journal> International Journal of Radiation Oncology Biology and Physics 9, </journal> <year> 1983, </year> <pages> pp. 789-797. </pages>
Reference: [Griswold 91] <author> W.G. </author> <title> Griswold Program Restructuring to Aid Software Maintenance, </title> <type> Ph.D. Dissertation, Technical Report 91-08-04, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> August, </month> <year> 1991. </year>
Reference-contexts: Sullivan and Notkin sought to test their claim that their method can ease the development and evolution of sophisticated, tightly integrated environments. In earlier efforts <ref> [McCabe 91, Griswold 91, Sullivan and Notkin 92] </ref> Sullivan and Notkin or close associates controlled both the method and the requirements against which the the method was tested. In this case, Kalet had defined the requirements before collaboration began. Nor did Sullivan and Notkin control detailed design or implementation.
Reference: [Jacky and Kalet 86] <author> Jacky, J.P. and Kalet, I.J., </author> <title> "An Object-Oriented Approach to a Large Scientific Application," </title> <booktitle> OOPSLA '86 Object Oriented Programming Systems, Languages and Applications Conference Proceedings, </booktitle> <editor> Meyrowitz, N., ed., </editor> <year> 1986, </year> <pages> pp. 368-376. </pages>
Reference-contexts: These limitations make it hard quickly model and simulate patients and treatment plans. Third, to the extent that existing systems are broad and integrated, their architectures tend to be inflexible and evolution-unfriendly. For example, despite its object-oriented architecture <ref> [Jacky and Kalet 86, Jacky and Kalet 87b] </ref>, Kalet's second system does not easily accommodate integration of prototype AI-based planning tools [Kalet 92c, Paluszyn-ski 89a].
Reference: [Jacky and Kalet 87b] <author> Jacky, J.P. and Kalet, I.J., </author> <title> "An Object-Oriented Programming Discipline for Standard Pascal," </title> <journal> Communications of the ACM 30,9, </journal> <pages> pp. 772-776, </pages> <month> September, </month> <year> 1987. </year>
Reference-contexts: When a patient model or plan changes, all graphical renderings displayed by any tool should be updated accordingly, for example. 2.2 Related Systems Many RTP systems have been built [Goitein et al. 83, Kutcher 88, Fraass et al. 87, Rosenman et al. 89], including several at the University of Washington <ref> [Kalet and Jacky 82, Jacky and Kalet 87b] </ref>. None of these efforts achieved breadth of scope, integration and flexibility. <p> These limitations make it hard quickly model and simulate patients and treatment plans. Third, to the extent that existing systems are broad and integrated, their architectures tend to be inflexible and evolution-unfriendly. For example, despite its object-oriented architecture <ref> [Jacky and Kalet 86, Jacky and Kalet 87b] </ref>, Kalet's second system does not easily accommodate integration of prototype AI-based planning tools [Kalet 92c, Paluszyn-ski 89a].
Reference: [Johnson 92] <author> R.E. Johnson and V.F. Russo, </author> <title> "Reusing Object-Oriented Designs," </title> <institution> University of Illinois at Urbana-Champaign, </institution> <type> Technical Report UIUCDCS-R-91-1696, </type> <year> 1991. </year>
Reference-contexts: In the second role, Prism provides something like a framework <ref> [Johnson 92] </ref>, to be specialized and extended with additional tools. For example, a tool that computes target treatment volumes based on mathematical models of tumor shape and type, patient movement, etc. is now being devised and integrated.
Reference: [Kalet and Jacky 82] <author> I. Kalet, and J. Jacky, </author> <title> "A Research-Oriented Treatment Planning Program System," </title> <booktitle> Computer Programs in Biomedicine 14, </booktitle> <pages> pp. 85-98, </pages> <year> 1982. </year>
Reference-contexts: When a patient model or plan changes, all graphical renderings displayed by any tool should be updated accordingly, for example. 2.2 Related Systems Many RTP systems have been built [Goitein et al. 83, Kutcher 88, Fraass et al. 87, Rosenman et al. 89], including several at the University of Washington <ref> [Kalet and Jacky 82, Jacky and Kalet 87b] </ref>. None of these efforts achieved breadth of scope, integration and flexibility.
Reference: [Kalet et al. 91] <author> I. Kalet, J. Jacky, S. Kromhout-Shiro, B. Lockyear, M. Niehaus, C. Sweeney, and J. Unger, </author> <title> "The Prism Radiation Treatment Planning System," </title> <type> Technical Report 91-10-03, </type> <institution> Radiation Oncology Department, University of Washington, </institution> <address> Seattle, WA, </address> <month> October 31, </month> <year> 1991. </year>
Reference-contexts: 1 Introduction We discuss a collaboration in which Sullivan and Notkin helped Kalet and colleagues use behavioral entity-relationship (ER) modeling and design, a software analysis and design technique [Sullivan and Notkin 92], to build a tightly integrated but architecturally flexible environment for planning radiation treatments for cancer patients <ref> [Kalet et al. 91, Kalet et al. 92] </ref>. In this collaboration, each of our groups had its own goals|Sullivan and Notkin in software engineering and Kalet and his colleagues in radiation oncology.
Reference: [Kalet et al. 92] <author> I. Kalet, J. Unger, C. Sweeney, S. Kromhout-Shiro, J. Jacky, and M. Niehaus, </author> <title> "Prism Graphical User Interface Specification," </title> <type> Technical Report 92-02-02, </type> <institution> Radiation Oncology Department, University of Washington, </institution> <address> Seattle, WA, March 18, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction We discuss a collaboration in which Sullivan and Notkin helped Kalet and colleagues use behavioral entity-relationship (ER) modeling and design, a software analysis and design technique [Sullivan and Notkin 92], to build a tightly integrated but architecturally flexible environment for planning radiation treatments for cancer patients <ref> [Kalet et al. 91, Kalet et al. 92] </ref>. In this collaboration, each of our groups had its own goals|Sullivan and Notkin in software engineering and Kalet and his colleagues in radiation oncology.
Reference: [Kalet 92] <author> I. Kalet, </author> <title> "SLIK Programmer's Guide," </title> <type> Technical Report 92-02-01, </type> <institution> Radiation Oncology Department, University of Washington, </institution> <address> Seattle, WA, March 17, </address> <year> 1992. </year>
Reference-contexts: The widget we discuss is a dialbox , defined in the SLIK user interface toolkit, used to build all Prism interfaces <ref> [Kalet 92] </ref>. 10 3.1 Our Method Our method is based on the notion that the conflict between integration and architectural flexibility is reconciled by viewing and implementing systems as collection of visible, in dependent entities integrated in a network of separate behavioral relationships.
Reference: [Kalet 92c] <author> I. Kalet, </author> <title> "Artificial Intelligence Applications in Radiation Therapy," in Advances in Radiation Oncology Physics: Dosimetry, Treatment Planning, </title> <editor> and Brachyther-apy, J.A. Purdy, ed., </editor> <year> 1992, </year> <pages> pp. 1058-1085. </pages>
Reference-contexts: Third, to the extent that existing systems are broad and integrated, their architectures tend to be inflexible and evolution-unfriendly. For example, despite its object-oriented architecture [Jacky and Kalet 86, Jacky and Kalet 87b], Kalet's second system does not easily accommodate integration of prototype AI-based planning tools <ref> [Kalet 92c, Paluszyn-ski 89a] </ref>.
Reference: [Kernighan and Ritchie] <author> Kernighan and Ritchie, </author> <title> The C Programming Language. </title> <type> 29 </type>
Reference-contexts: In comparison, Kalet's first system has 47,000 Pascal lines. Kalet's second system, still in use, has 41,000 lines of Pascal, 5,000 for dose distributions. Comparing with another system, the basic functions taking 18,000 lines in Prism take about 60,000 of C <ref> [Kernighan and Ritchie] </ref> and C++ [Stroustrup 86] in GRATIS [Rosenman et al. 89], of which about 14,000 are for interface widgets. Those functions taking 4,500 lines of Pascal in Prism, take about 12,000 lines of C in GRATIS 3 Prism performs adequately on high-end workstations.
Reference: [Kutcher 88] <author> G.J. Kutcher, R. Mohan, J.S. Laughlin, G. Barest, L. Brewster, C. Chue, C. Berman, and Z. Fuks, </author> <title> "Three Dimensional Radiation Treatment Planning," </title> <booktitle> Dosimetry in Radiotherapy: Proceedings of an International Symposium on Dosimetry in Radiotherapy 2, </booktitle> <address> Vienna, </address> <month> September, </month> <year> 1988, </year> <pages> pp. 39-63. </pages>
Reference: [McCabe 91] <author> T. McCabe. </author> <title> Programming with Mediators: Developing a Graphical Mesh Environment. </title> <type> Masters Thesis, </type> <institution> University of Washington. </institution> <year> 1991. </year>
Reference-contexts: Sullivan and Notkin sought to test their claim that their method can ease the development and evolution of sophisticated, tightly integrated environments. In earlier efforts <ref> [McCabe 91, Griswold 91, Sullivan and Notkin 92] </ref> Sullivan and Notkin or close associates controlled both the method and the requirements against which the the method was tested. In this case, Kalet had defined the requirements before collaboration began. Nor did Sullivan and Notkin control detailed design or implementation.
Reference: [Notkin et al. 93] <author> D. Notkin, D. Garlan, W.G. Griswold, and K. Sullivan, </author> <title> "Adding Implicit Invocation to Languages: Three Approaches," </title> <booktitle> Proceedings of the JSSST International Symposium on Object Technologies for Advanced Software (November 1993). The proceedings will appear as a Springer-Verlag Lecture Notes in Computer Science volume. </booktitle>
Reference-contexts: The lighter solid arrows represent invocations of the operations at the heads by the operations at the tails. 3.2.3 Implementation It is straightforward to implement ABTs in common programming languages. The main problem is representing events. This is not hard <ref> [Notkin et al. 93] </ref>. It is especially easy in object-oriented languages, which already support objects with states and operations. In this case, we represent events in object interfaces as instance variables holding event objects.
Reference: [Paluszynski 89a] <author> W. Paluszynski, </author> <title> Designing Radiation Therapy for Cancer, an Approach to Knowledge-Based Optimization, </title> <type> Ph.D. Dissertation, </type> <institution> University of Washington, </institution> <year> 1990. </year>
Reference: [Parnas 72] <author> D. L. Parnas, </author> <title> "On the Criteria to Be Used in Decomposing Systems into Modules," </title> <journal> Communications of the ACM 5,12, </journal> <pages> pp. 1053-58, </pages> <month> December, </month> <year> 1972. </year>
Reference-contexts: Our experience with several members of this project shows that the shift is large. The approach cannot be applied mechanically, but has to be internalized. Finally, we can evaluate the artifacts using well-accepted (although still imperfect) design quality criteria: coupling and cohesion [Stevens, Myers, and Constantine 74]; information hiding <ref> [Parnas 72] </ref>; structural continuity [Dechampeaux 93]; etc. Explicitly applying these concepts is outside the scope of this paper. The system is evidently factored into useful and interesting stand-alone entities integrated by mediators that represent intuitively clear behavioral relationships.
Reference: [Rosenman et al. 89] <author> J. Rosenman, G.W. Sherouse, H. Fuchs, S. Pizer, A. Skinner, C. Mosher, K. Novins, and J. Tepper, </author> <title> "Three-dimensional Display Techniques in Radiation Therapy Treatment Planning", </title> <journal> International Journal of Radiation Oncology, Biology and Physics 16, </journal> <year> 1989, </year> <pages> pp. 263-269. </pages>
Reference-contexts: An RTP system helps by supporting modeling and visualization of plans, computation of dose distributions, visualization of plans and dose distributions, and management of a database of patients, plans, treatment machines, etc. An RTP system that promotes exploratory planning can lead to treatments that would otherwise be missed <ref> [Rosenman et al. 89] </ref>. A key goal for Prism is to give dosimetrists a powerful exploratory system: one providing a tool set that is broad in scope, dynamically configurable, and tightly integrated. <p> Kalet's second system, still in use, has 41,000 lines of Pascal, 5,000 for dose distributions. Comparing with another system, the basic functions taking 18,000 lines in Prism take about 60,000 of C [Kernighan and Ritchie] and C++ [Stroustrup 86] in GRATIS <ref> [Rosenman et al. 89] </ref>, of which about 14,000 are for interface widgets. Those functions taking 4,500 lines of Pascal in Prism, take about 12,000 lines of C in GRATIS 3 Prism performs adequately on high-end workstations. We use HP9000 series 700 workstations for development and production.
Reference: [Scheifler and Gettys 86] <author> R.W. Scheifler and J. Gettys. </author> <title> "The X Window System," </title> <journal> ACM Transactions on Graphics, </journal> <volume> 5 ,2, </volume> <pages> pp. 79-109, </pages> <year> 1986. </year>
Reference-contexts: The design and implementation of this model is straightforward based on the earlier examples. This structure paid off when Kalet discovered that the initial design for graphics rendering was unworkable. The problem was in using X windows <ref> [Scheifler and Gettys 86] </ref> to render multi-layered pictures, with contoured objects over background images. The mediator-based architecture made it easy to fix the problem because all graphics code was localized in the submediators: each was responsible for rendering its object in its view.
Reference: [Steele 90] <author> G. Steele, Jr. </author> <title> COMMON LISP, </title> <booktitle> the Language, second edition, </booktitle> <address> (Burlington, MA: </address> <publisher> Digital Press), </publisher> <year> 1990. </year>
Reference-contexts: An event object maintains an association between the event it represents and the objects and operations to be invoked when the event is announced [Sullivan and Notkin 92]. Events. The implementation environment for Prism is Common Lisp <ref> [Steele 90] </ref> and CLOS [Bobrow et al. 88]. Our first task was to support objects having events as well as operations in their interfaces. We used event object-valued instance variables for this. <p> We applied this approach throughout Prism, at all levels of "granularity," and in solving reasonably difficult design problems of several different kinds. 5 Development Effort Prism is implemented in about 18,000 lines of Common LISP (CL) <ref> [Steele 90] </ref> and CLOS [Bo-brow et al. 88] and 4,500 lines of Pascal. It also has 11,000 lines of L a T E X documentation. The Lisp code handles modeling, visualization, and file management. The Pascal, adapted from an earlier system, computes dose distributions.
Reference: [Stevens, Myers, and Constantine 74] <author> W. Stevens, G. Myers, and L. Constantine, </author> <title> "Structured Design," </title> <journal> IBM Systems Journal 13,2, </journal> <pages> pp. 115-39, </pages> <month> May, </month> <year> 1974. </year>
Reference-contexts: Our experience with several members of this project shows that the shift is large. The approach cannot be applied mechanically, but has to be internalized. Finally, we can evaluate the artifacts using well-accepted (although still imperfect) design quality criteria: coupling and cohesion <ref> [Stevens, Myers, and Constantine 74] </ref>; information hiding [Parnas 72]; structural continuity [Dechampeaux 93]; etc. Explicitly applying these concepts is outside the scope of this paper. The system is evidently factored into useful and interesting stand-alone entities integrated by mediators that represent intuitively clear behavioral relationships.
Reference: [Stroustrup 86] <author> B. Stroustrup, </author> <title> The C++ Programming Language, </title> <publisher> (Addison-Wesley: </publisher> <address> Reading, Massachusetts), </address> <year> 1986. </year>
Reference-contexts: In comparison, Kalet's first system has 47,000 Pascal lines. Kalet's second system, still in use, has 41,000 lines of Pascal, 5,000 for dose distributions. Comparing with another system, the basic functions taking 18,000 lines in Prism take about 60,000 of C [Kernighan and Ritchie] and C++ <ref> [Stroustrup 86] </ref> in GRATIS [Rosenman et al. 89], of which about 14,000 are for interface widgets. Those functions taking 4,500 lines of Pascal in Prism, take about 12,000 lines of C in GRATIS 3 Prism performs adequately on high-end workstations. We use HP9000 series 700 workstations for development and production.
Reference: [Sullivan and Notkin 92] <author> K. Sullivan and D. Notkin, </author> <title> "Reconciling Environment Integration and Software Evolution," </title> <journal> ACM Transactions on Software Engineering and Methods, </journal> <volume> 1, 3, </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: 1 Introduction We discuss a collaboration in which Sullivan and Notkin helped Kalet and colleagues use behavioral entity-relationship (ER) modeling and design, a software analysis and design technique <ref> [Sullivan and Notkin 92] </ref>, to build a tightly integrated but architecturally flexible environment for planning radiation treatments for cancer patients [Kalet et al. 91, Kalet et al. 92]. <p> Sullivan and Notkin sought to test their claim that their method can ease the development and evolution of sophisticated, tightly integrated environments. In earlier efforts <ref> [McCabe 91, Griswold 91, Sullivan and Notkin 92] </ref> Sullivan and Notkin or close associates controlled both the method and the requirements against which the the method was tested. In this case, Kalet had defined the requirements before collaboration began. Nor did Sullivan and Notkin control detailed design or implementation. <p> The problem was to obtain the required tight integration without losing architectural flexibility|the key to controlling development costs and easing evolution. The behavioral entity-relationship modeling and design approach developed by Sullivan and Notkin <ref> [Sullivan and Notkin 92] </ref> purported to reconcile integration with architectural flexibility, and with ease of software development and evolution. Kalet found the method sufficiently appealing that he decided to adopt it for the Prism project. Our method involves an approach to analysis, design, and implementation. <p> In many cases, existing types need not change. To provide the essential details, we sum up our analysis, design, and implementation methods in a few lines each. Then we illustrate their use for the simple case of the dialbox widget. We refer interested readers to more "theoretical" discussions elsewhere <ref> [Sullivan and Notkin 92, Sullivan 94] </ref>. 3.1.1 Analysis * First, identify and represent key entities as visible, independent objects. An object is visible if it can be directly referenced and used by any client. <p> One is for the mediator to maintain a bit indicating whether an update is in progress. When invoked, the mediator checks the bit. If not set, the mediator sets it and performs the update. If set, the mediator just returns <ref> [Sullivan and Notkin 92] </ref>. 13 DialBox TextLine Get ():string Set (x:string) NewInfo (x:string) Info:string Dial NewAngle (x:float) Angle:float Get ():float Set (x:float) Mediator UponNewAngle (x:float) t: TextLine; d: Dial Set (x:float); Get ():float UponNewInfo (x:string) The heavy lines indicate dependencies between objects. The dial and text line are independent. <p> In this case, we represent events in object interfaces as instance variables holding event objects. An event object maintains an association between the event it represents and the objects and operations to be invoked when the event is announced <ref> [Sullivan and Notkin 92] </ref>. Events. The implementation environment for Prism is Common Lisp [Steele 90] and CLOS [Bobrow et al. 88]. Our first task was to support objects having events as well as operations in their interfaces. We used event object-valued instance variables for this.
Reference: [Sullivan 94] <author> K. Sullivan, </author> <title> Reconciling Integration and Evolution: Behavioral Entity-Relationship Modeling and Design, </title> <type> Ph.D. Thesis, </type> <institution> University of Washington Department of Computer Science and Engineering, </institution> <note> Forthcoming in 1994. 30 </note>
Reference-contexts: In many cases, existing types need not change. To provide the essential details, we sum up our analysis, design, and implementation methods in a few lines each. Then we illustrate their use for the simple case of the dialbox widget. We refer interested readers to more "theoretical" discussions elsewhere <ref> [Sullivan and Notkin 92, Sullivan 94] </ref>. 3.1.1 Analysis * First, identify and represent key entities as visible, independent objects. An object is visible if it can be directly referenced and used by any client.
Reference: [Taylor 88] <author> R.N. Taylor, R.W. Selby, M. Young, F.C. Belz, L.A. Clarke, J.C. Wileden, L. Osterweil, A.L. Wolf, </author> <title> "Foundations for the Arcadia Environment Architecture," </title> <booktitle> Proceedings of ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <editor> P. Henderson, Ed., </editor> <address> Boston, Massachusetts, </address> <month> November 28-30, </month> <year> 1988, </year> <pages> pp. 1-13. </pages>
Reference-contexts: Conversely, broad and dynamic environments are typically loosely coupled and poorly integrated. Unfortunately, poorly integrated environments impose excessive burdens upon users, and small static environments are quickly outgrown <ref> [Taylor 88, p. 2] </ref>." This has clearly been the case in the radiation treatment planning domain. First, in many systems, different planning tasks are handled by different, stand-alone, "Unix-like" tools that run as separate processes and are loosely integrated through shared files.
References-found: 27

