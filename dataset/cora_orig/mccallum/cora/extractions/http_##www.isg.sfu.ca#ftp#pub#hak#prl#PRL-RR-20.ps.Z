URL: http://www.isg.sfu.ca/ftp/pub/hak/prl/PRL-RR-20.ps.Z
Refering-URL: http://www.isg.sfu.ca/life/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: 20  A Feature Constraint System for Logic Programming with Entailment  
Author: Hassan At-Kaci Andreas Podelski Gert Smolka 
Date: November 1992  
Affiliation: PARIS RESEARCH LABORATORY  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> H. At-Kaci. </author> <title> An algebraic semantics approach to the effective resolution of type equations. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 45:293--351, </address> <year> 1986. </year>
Reference-contexts: Constructor trees are useful for structuring data in modern symbolic programming languages; e.g., Prolog and ML. This gives the more flexible feature trees an interesting potential. More precisely, feature trees model extensible record structures. They form the semantics of record calculi like <ref> [1] </ref>, which are used in symbolic programming languages [5] and in computational linguistics (for example, see [3, 24] and the book [8]). Generally, these extensible record structures allow hierarchical representation of partial knowledge. They lend themselves to object-oriented programming techniques [3]. <p> This, of course, is done by our simplification system for entailment. One origin of FT is At-Kaci's -term calculus <ref> [1] </ref>, which is at the heart of the programming language LOGIN [3] and further extended in the language LIFE [5] with functions over feature structures thanks to a generalization of the concept of residuation of Le Fun [4]. 1 Other precursors of FT are the feature descriptions found in unification grammars <p> Second, it seems attractive to extend FT such that it can accommodate a sort lattice as used in <ref> [1, 3, 4, 5, 25] </ref>.
Reference: 2. <author> H. At-Kaci. </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: We conjecture it to be quasi-linear in the size of fl and , provided the available features (finitely many) are fixed a priori. Lastly, implementation techniques for FT at the level of the Warren abstract machine <ref> [2] </ref> need to be developed. November 1992 Digital PRL A Feature Constraint System 19
Reference: 3. <author> H. At-Kaci and R. Nasr. </author> <title> LOGIN: A logic programming language with built-in inheritance. </title> <journal> The Journal of Logic Programming, </journal> <volume> 3:185--215, </volume> <year> 1986. </year>
Reference-contexts: This gives the more flexible feature trees an interesting potential. More precisely, feature trees model extensible record structures. They form the semantics of record calculi like [1], which are used in symbolic programming languages [5] and in computational linguistics (for example, see <ref> [3, 24] </ref> and the book [8]). Generally, these extensible record structures allow hierarchical representation of partial knowledge. They lend themselves to object-oriented programming techniques [3]. Let us suppose that we want to say that x is a wine whose grape is riesling and whose color is white. <p> They form the semantics of record calculi like [1], which are used in symbolic programming languages [5] and in computational linguistics (for example, see [3, 24] and the book [8]). Generally, these extensible record structures allow hierarchical representation of partial knowledge. They lend themselves to object-oriented programming techniques <ref> [3] </ref>. Let us suppose that we want to say that x is a wine whose grape is riesling and whose color is white. <p> This, of course, is done by our simplification system for entailment. One origin of FT is At-Kaci's -term calculus [1], which is at the heart of the programming language LOGIN <ref> [3] </ref> and further extended in the language LIFE [5] with functions over feature structures thanks to a generalization of the concept of residuation of Le Fun [4]. 1 Other precursors of FT are the feature descriptions found in unification grammars [15, 14] developed for natural language processing, and also the formalisms <p> Example 3.1 In order to check whether the two feature descriptions x [f ) u : A] and y [f ) v : A] are unifiable, in the sense of <ref> [3] </ref>, we will simplify the basic constraint xfu ^ yfv ^ Au ^ Av ^ z = x ^ y = z. <p> Second, it seems attractive to extend FT such that it can accommodate a sort lattice as used in <ref> [1, 3, 4, 5, 25] </ref>.
Reference: 4. <author> H. At-Kaci and R. Nasr. </author> <title> Integrating logic and functional programming. Lisp and Symbolic Computation, </title> <address> 2:51--89, </address> <year> 1989. </year>
Reference-contexts: One origin of FT is At-Kaci's -term calculus [1], which is at the heart of the programming language LOGIN [3] and further extended in the language LIFE [5] with functions over feature structures thanks to a generalization of the concept of residuation of Le Fun <ref> [4] </ref>. 1 Other precursors of FT are the feature descriptions found in unification grammars [15, 14] developed for natural language processing, and also the formalisms of Mukai [19, 20] (for a thorough survey of precursors in this field, cf., [8]). <p> Feature trees, the feature tree structure T , and the axiomatization of T were first given in [7]. The technique of relative simplification of constraints was first introduced and used in [6] to explain the behavior of functions as passive 1 Le Fun <ref> [4] </ref> is an extension of Prolog seen as a constraint logic programming system over Herbrand terms extended with applicative expressions. Le Fun's constraint solver achieves implicit coroutining thanks to an automatic suspension mechanism called ``residuation'' delaying equations with unsufficiently instantiated function arguments. Resumption is triggered asynchronously by function argument matching. <p> Second, it seems attractive to extend FT such that it can accommodate a sort lattice as used in <ref> [1, 3, 4, 5, 25] </ref>.
Reference: 5. <author> H. At-Kaci and A. </author> <title> Podelski. Towards a Meaning of LIFE. </title> <booktitle> Proceedings of the 3rd International Symposium on Programming Language Implementation and Logic Programming (Passau, </booktitle> <publisher> Germany), </publisher> <editor> J. Maluszy nski and M. Wirsing, editors. </editor> <publisher> LNCS 528, pages 255--274, Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The basic operation these frameworks require of a constraint system is a test for unsatisfiability. In addition, ALPS, CCP, and KAP require a test for entailment between constraints, which is needed for advanced control mechanisms such as delaying, coroutining, synchronization, committed choice, and deep constraint propagation. LIFE <ref> [5, 6] </ref>, formally a CLP language, employs a related, but limited, suspension strategy to enforce deterministic functional application. Given this situation, constraint systems are a central issue in research on logic programming. <p> This gives the more flexible feature trees an interesting potential. More precisely, feature trees model extensible record structures. They form the semantics of record calculi like [1], which are used in symbolic programming languages <ref> [5] </ref> and in computational linguistics (for example, see [3, 24] and the book [8]). Generally, these extensible record structures allow hierarchical representation of partial knowledge. They lend themselves to object-oriented programming techniques [3]. <p> This, of course, is done by our simplification system for entailment. One origin of FT is At-Kaci's -term calculus [1], which is at the heart of the programming language LOGIN [3] and further extended in the language LIFE <ref> [5] </ref> with functions over feature structures thanks to a generalization of the concept of residuation of Le Fun [4]. 1 Other precursors of FT are the feature descriptions found in unification grammars [15, 14] developed for natural language processing, and also the formalisms of Mukai [19, 20] (for a thorough survey <p> The following basic simplification chain, leads to a solved constraint (which, as shown in <ref> [24, 5] </ref>, exhibits unifiability): xfu ^ yfv ^ Au ^ Av ^ z = x ^ y = z by Rule 4 ) xfu ^ yfv ^ Au ^ Av ^ z : : by Rule 4 ) xfu ^ xfv ^ Au ^ Av ^ z : : by Rule <p> parameter pair of feature descriptions (x [f ) u : A]; y [f ) v : B]) has to be tested upon matching of (and incompatibility with) the formal parameter pair (z; z). (This is in order to know whether that function call fires, fails, or residuates.) As shown in <ref> [24, 5] </ref>, this corresponds to testing whether the context fl = xfu ^ yfv ^ Au ^ Bv entails the guard 9z (x : : Let X = fzg. <p> Second, it seems attractive to extend FT such that it can accommodate a sort lattice as used in <ref> [1, 3, 4, 5, 25] </ref>.
Reference: 6. <author> H. At-Kaci and A. </author> <title> Podelski. Functions as Passive Constraints in LIFE. </title> <type> PRL Research Report 13. </type> <institution> Digital Equipment Corporation, Paris Research Laboratory. Rueil-Malmaison, France, </institution> <note> June 1991 (Revised, </note> <month> November </month> <year> 1992). </year>
Reference-contexts: The basic operation these frameworks require of a constraint system is a test for unsatisfiability. In addition, ALPS, CCP, and KAP require a test for entailment between constraints, which is needed for advanced control mechanisms such as delaying, coroutining, synchronization, committed choice, and deep constraint propagation. LIFE <ref> [5, 6] </ref>, formally a CLP language, employs a related, but limited, suspension strategy to enforce deterministic functional application. Given this situation, constraint systems are a central issue in research on logic programming. <p> Major steps in the process of their understanding and logical reformulation are the articles [22, 25, 13, 24]. Feature trees, the feature tree structure T , and the axiomatization of T were first given in [7]. The technique of relative simplification of constraints was first introduced and used in <ref> [6] </ref> to explain the behavior of functions as passive 1 Le Fun [4] is an extension of Prolog seen as a constraint logic programming system over Herbrand terms extended with applicative expressions. <p> Typically, fl will not determine 9X when 9X is considered first, but this may change when fl is strengthened to fl ^ fl 0 . To this end, we use the concept of relative simplification of constraints first introduced in <ref> [6] </ref>. The basic idea leading to an incremental entailment checker is to simplify with respect to (relatively to) the context fl and the local variables X. <p> The notions of normal and normal form with respect to fl are defined accordingly. Example 5.1 Assume, in the context of functions in LIFE <ref> [6] </ref> (the case of guarded Horn clauses [18] is quite similar), that a function fun is defined in the form fun (z; z) ! : : :, and that it is called as fun (x [f ) u : A]; y [f ) v : B]).
Reference: 7. <author> R. Backofen and G. Smolka. </author> <title> A complete and decidable feature theory. </title> <institution> DFKI Research Report RR-30-92, German Research Center for Artificial Intelligence, </institution> <address> Saarbr ucken, Germany (1992). </address>
Reference-contexts: The feature tree structure T fixes an algebraic semantics for FT. We will also establish a logical semantics, which is given by three axiom schemes fixing a first-order theory FT. Backofen and Smolka <ref> [7] </ref> show that T is a model of FT and that FT is in fact a complete theory, which means that FT is exactly the theory induced by T . <p> These early feature structure formalisms were presented in a non logical form. Major steps in the process of their understanding and logical reformulation are the articles [22, 25, 13, 24]. Feature trees, the feature tree structure T , and the axiomatization of T were first given in <ref> [7] </ref>. The technique of relative simplification of constraints was first introduced and used in [6] to explain the behavior of functions as passive 1 Le Fun [4] is an extension of Prolog seen as a constraint logic programming system over Herbrand terms extended with applicative expressions. <p> We will see in the next section that FT 0 plays an important role with respect to basic constraint simplification. Next we introduce some additional notation needed in the rest of the paper. This notation will also allow us to state a third axiom scheme that, as shown in <ref> [7] </ref>, extends FT 0 to a complete axiomatization of T . Throughout the paper we assume that conjunction of formulae is an associative and commutative operator that has &gt; as neutral element. <p> Since: ff (x) = fw 1 ff (y) j : : : g and, for a node w of ff (x), wff (x) = ff (y), it follows that ff (x) is a rational tree and that T ; ff j= . For another proof of this theorem see <ref> [7] </ref>, which also proves that FT is a complete theory if the alphabets of sorts and features are infinite. A practical motivation for the assumption on the infiniteness of F (and of S as well) is the need to account for dynamic record field updates.
Reference: 8. <author> B. Carpenter. </author> <title> The Logic of Typed Feature Structures, </title> <booktitle> volume 32 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1992. </year>
Reference-contexts: This gives the more flexible feature trees an interesting potential. More precisely, feature trees model extensible record structures. They form the semantics of record calculi like [1], which are used in symbolic programming languages [5] and in computational linguistics (for example, see [3, 24] and the book <ref> [8] </ref>). Generally, these extensible record structures allow hierarchical representation of partial knowledge. They lend themselves to object-oriented programming techniques [3]. Let us suppose that we want to say that x is a wine whose grape is riesling and whose color is white. <p> to a generalization of the concept of residuation of Le Fun [4]. 1 Other precursors of FT are the feature descriptions found in unification grammars [15, 14] developed for natural language processing, and also the formalisms of Mukai [19, 20] (for a thorough survey of precursors in this field, cf., <ref> [8] </ref>). These early feature structure formalisms were presented in a non logical form. Major steps in the process of their understanding and logical reformulation are the articles [22, 25, 13, 24]. Feature trees, the feature tree structure T , and the axiomatization of T were first given in [7].
Reference: 9. <author> A. Colmerauer. </author> <title> Equations and inequations on finite and infinite trees. </title> <booktitle> In Proceedings of the 2nd International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 85--99, </pages> <year> 1984. </year>
Reference-contexts: The two major technical contributions of this paper are (1) an incremental simplification system for entailment that is proven to be sound and complete, and (2) a proof showing that the ``independence of negative constraints'' property <ref> [9, 16, 17] </ref> holds for FT. The incremental entailment simplification system is the prerequisite for FT's use with either of the constraint programming frameworks ALPS, CCP, KAP or LIFE mentioned at the beginning of this section. <p> The independence property is important since it means that negative constraints on feature trees can be solved (exactly like in Colmerauer's work on disequations over infinite trees <ref> [9] </ref>). Namely, thanks to independence, a conjunction with more than one negated constraints ^ : 1 ^ : : : ^ : n can be solved by testing separately each negated constraint i for entailment, for i = 1; : : : ; n. <p> That is, the conjunction fl ^ is satisfiable if and only if fl either entails 9X, or it does not determine 9X. The independence of negative constraints <ref> [9, 16, 17] </ref> is an important property of constraint systems. If it holds, simplification of conjunctions of positive and negative constraints can be reduced to entailment simplification of conjunctions of positive constraints. <p> Since FT satisfies the independence property, the simplification system can also check satisfiability of conjunctions of positive and negative constraints. We see four directions for further research. First, FT should be strengthened such that it subsumes the expressivity of rational constructor trees <ref> [9, 10] </ref>. As is, FT cannot express that x is a tree having direct subtrees at exactly the features f 1 ; : : : ; f n .
Reference: 10. <author> A. Colmerauer, H. Kanoui, and M. V. </author> <title> Caneghem. Prolog, </title> <booktitle> theoretical principles and current trends. </booktitle> <institution> Technology and Science of Informatics, 2(4):255--292, </institution> <year> 1983. </year>
Reference-contexts: 1 Introduction An important structural property of many logic programming systems is the fact that they factorize into a constraint system and a relational facility. Colmerauer's Prolog II <ref> [10] </ref> is an early language design making explicit use of this property. <p> Since FT satisfies the independence property, the simplification system can also check satisfiability of conjunctions of positive and negative constraints. We see four directions for further research. First, FT should be strengthened such that it subsumes the expressivity of rational constructor trees <ref> [9, 10] </ref>. As is, FT cannot express that x is a tree having direct subtrees at exactly the features f 1 ; : : : ; f n .
Reference: 11. <author> S. Haridi and S. Janson. </author> <title> Kernel Andorra Prolog and its computation model. </title> <editor> In D. Warren and P. Szeredi, editors, </editor> <booktitle> Logic Programming, Proceedings of the 7th International Conference, pages 31--48, </booktitle> <address> Cambridge, MA, June 1990. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Colmerauer's Prolog II [10] is an early language design making explicit use of this property. CLP (Constraint Logic Programming [12]), ALPS [18], CCP (Concurrent Constraint Programming [23]), and KAP (Kernel Andorra Prolog <ref> [11] </ref>) are recent logic programming frameworks that exploit this property to its full extent by being parameterized with respect to an abstract class of constraint systems. The basic operation these frameworks require of a constraint system is a test for unsatisfiability.
Reference: 12. <author> J. Jaffar and J. L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Principles of Programming Languages, pages 111--119, </booktitle> <address> Munich, Germany, </address> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: 1 Introduction An important structural property of many logic programming systems is the fact that they factorize into a constraint system and a relational facility. Colmerauer's Prolog II [10] is an early language design making explicit use of this property. CLP (Constraint Logic Programming <ref> [12] </ref>), ALPS [18], CCP (Concurrent Constraint Programming [23]), and KAP (Kernel Andorra Prolog [11]) are recent logic programming frameworks that exploit this property to its full extent by being parameterized with respect to an abstract class of constraint systems.
Reference: 13. <author> M. Johnson. </author> <title> Attribute-Value Logic and the Theory of Grammar. CSLI Lecture Notes 16. Center for the Study of Language and Information, </title> <publisher> Stanford University, </publisher> <address> CA, </address> <year> 1988. </year> <note> Research Report No. 20 November 1992 20 Hassan At-Kaci, Andreas Podelski, and Gert Smolka </note>
Reference-contexts: These early feature structure formalisms were presented in a non logical form. Major steps in the process of their understanding and logical reformulation are the articles <ref> [22, 25, 13, 24] </ref>. Feature trees, the feature tree structure T , and the axiomatization of T were first given in [7].
Reference: 14. <author> R. M. Kaplan and J. Bresnan. </author> <title> Lexical-Functional Grammar: A formal system for grammatical representation. </title> <editor> In J. Bresnan, editor, </editor> <title> The Mental Representation of Grammatical Relations, </title> <publisher> pages 173--281. The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1982. </year>
Reference-contexts: which is at the heart of the programming language LOGIN [3] and further extended in the language LIFE [5] with functions over feature structures thanks to a generalization of the concept of residuation of Le Fun [4]. 1 Other precursors of FT are the feature descriptions found in unification grammars <ref> [15, 14] </ref> developed for natural language processing, and also the formalisms of Mukai [19, 20] (for a thorough survey of precursors in this field, cf., [8]). These early feature structure formalisms were presented in a non logical form.
Reference: 15. <author> M. Kay. </author> <title> Functional grammar. </title> <booktitle> In Proceedings of the Fifth Annual Meeting of the Berkeley Linguistics Society, </booktitle> <address> Berkeley, CA, </address> <year> 1979. </year> <institution> Berkeley Linguistics Society. </institution>
Reference-contexts: which is at the heart of the programming language LOGIN [3] and further extended in the language LIFE [5] with functions over feature structures thanks to a generalization of the concept of residuation of Le Fun [4]. 1 Other precursors of FT are the feature descriptions found in unification grammars <ref> [15, 14] </ref> developed for natural language processing, and also the formalisms of Mukai [19, 20] (for a thorough survey of precursors in this field, cf., [8]). These early feature structure formalisms were presented in a non logical form.
Reference: 16. <author> J. L. Lassez, M. Maher, and K. Marriot. </author> <title> Unification revisited. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming. </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: LIFE [5, 6], formally a CLP language, employs a related, but limited, suspension strategy to enforce deterministic functional application. Given this situation, constraint systems are a central issue in research on logic programming. The constraint systems of most existing logic programming languages are variations and extensions of Herbrand <ref> [16] </ref>, the constraint system underlying Prolog. The individuals of Herbrand are trees corresponding to ground terms, and the atomic constraints are equations between terms. Seen from the perspective of programming, Herbrand provides a universal data structure as a logical system. <p> The two major technical contributions of this paper are (1) an incremental simplification system for entailment that is proven to be sound and complete, and (2) a proof showing that the ``independence of negative constraints'' property <ref> [9, 16, 17] </ref> holds for FT. The incremental entailment simplification system is the prerequisite for FT's use with either of the constraint programming frameworks ALPS, CCP, KAP or LIFE mentioned at the beginning of this section. <p> That is, the conjunction fl ^ is satisfiable if and only if fl either entails 9X, or it does not determine 9X. The independence of negative constraints <ref> [9, 16, 17] </ref> is an important property of constraint systems. If it holds, simplification of conjunctions of positive and negative constraints can be reduced to entailment simplification of conjunctions of positive constraints.
Reference: 17. <author> J. L. Lassez and K. McAloon. </author> <title> A constraint sequent calculus. </title> <booktitle> In Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 52--61, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The two major technical contributions of this paper are (1) an incremental simplification system for entailment that is proven to be sound and complete, and (2) a proof showing that the ``independence of negative constraints'' property <ref> [9, 16, 17] </ref> holds for FT. The incremental entailment simplification system is the prerequisite for FT's use with either of the constraint programming frameworks ALPS, CCP, KAP or LIFE mentioned at the beginning of this section. <p> That is, the conjunction fl ^ is satisfiable if and only if fl either entails 9X, or it does not determine 9X. The independence of negative constraints <ref> [9, 16, 17] </ref> is an important property of constraint systems. If it holds, simplification of conjunctions of positive and negative constraints can be reduced to entailment simplification of conjunctions of positive constraints.
Reference: 18. <author> M. Maher. </author> <title> Logic semantics for a class of committed-choice programs. </title> <editor> In J.-L. Lassez, editor, </editor> <booktitle> Logic Programming, Proceedings of the Fourth International Conference, pages 858--876, </booktitle> <address> Cambridge, MA, 1987. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: 1 Introduction An important structural property of many logic programming systems is the fact that they factorize into a constraint system and a relational facility. Colmerauer's Prolog II [10] is an early language design making explicit use of this property. CLP (Constraint Logic Programming [12]), ALPS <ref> [18] </ref>, CCP (Concurrent Constraint Programming [23]), and KAP (Kernel Andorra Prolog [11]) are recent logic programming frameworks that exploit this property to its full extent by being parameterized with respect to an abstract class of constraint systems. <p> The notions of normal and normal form with respect to fl are defined accordingly. Example 5.1 Assume, in the context of functions in LIFE [6] (the case of guarded Horn clauses <ref> [18] </ref> is quite similar), that a function fun is defined in the form fun (z; z) ! : : :, and that it is called as fun (x [f ) u : A]; y [f ) v : B]).
Reference: 19. <author> K. Mukai. </author> <title> Partially specified terms in logic programming for linguistic analysis. </title> <booktitle> In Proceedings of the 6th International Conference on Fifth Generation Computer Systems, </booktitle> <year> 1988. </year>
Reference-contexts: extended in the language LIFE [5] with functions over feature structures thanks to a generalization of the concept of residuation of Le Fun [4]. 1 Other precursors of FT are the feature descriptions found in unification grammars [15, 14] developed for natural language processing, and also the formalisms of Mukai <ref> [19, 20] </ref> (for a thorough survey of precursors in this field, cf., [8]). These early feature structure formalisms were presented in a non logical form. Major steps in the process of their understanding and logical reformulation are the articles [22, 25, 13, 24].
Reference: 20. <author> K. Mukai. </author> <title> Constraint Logic Programming and the Unification of Information. </title> <type> PhD thesis, </type> <institution> Tokyo Institute of Technology, </institution> <address> Tokyo, Japan, </address> <year> 1991. </year>
Reference-contexts: extended in the language LIFE [5] with functions over feature structures thanks to a generalization of the concept of residuation of Le Fun [4]. 1 Other precursors of FT are the feature descriptions found in unification grammars [15, 14] developed for natural language processing, and also the formalisms of Mukai <ref> [19, 20] </ref> (for a thorough survey of precursors in this field, cf., [8]). These early feature structure formalisms were presented in a non logical form. Major steps in the process of their understanding and logical reformulation are the articles [22, 25, 13, 24].
Reference: 21. <author> M. Nivat. </author> <title> Elements of a theory of tree codes. </title> <editor> In M. Nivat, A. Podelski, editors, </editor> <title> Tree Automata (Advances and Open Problems), </title> <address> Amsterdam, NE, 1992. </address> <publisher> Elsevier Science Publishers. </publisher>
Reference-contexts: Given x 2 X, we define the ``punctual'' tree t x = f ("; A)g, where A 2 S is the sort such that Ax 2 , if it exists, and arbitrary, otherwise. Now we are going to use the notion of tree sum of Nivat <ref> [21] </ref>, where w 1 t = f (wv; A) j (v; A) 2 tg (``the tree t translated by w''), and we define: ff (x) = fw 1 t y j x ; y for some y 2 V (); w 2 F ? g: Here the relation w ; is
Reference: 22. <author> W. C. Rounds and R. T. Kasper. </author> <title> A complete logical calculus for record structures representing linguistic information. </title> <booktitle> In Proceedings of the 1st IEEE Symposium on Logic in Computer Science, pages 38--43, </booktitle> <address> Boston, MA, </address> <year> 1986. </year>
Reference-contexts: These early feature structure formalisms were presented in a non logical form. Major steps in the process of their understanding and logical reformulation are the articles <ref> [22, 25, 13, 24] </ref>. Feature trees, the feature tree structure T , and the axiomatization of T were first given in [7].
Reference: 23. <author> V. Saraswat and M. Rinard. </author> <title> Concurrent constraint programming. </title> <booktitle> In Proceedings of the 7th Annual ACM Symposium on Principles of Programming Languages, pages 232--245, </booktitle> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: Colmerauer's Prolog II [10] is an early language design making explicit use of this property. CLP (Constraint Logic Programming [12]), ALPS [18], CCP (Concurrent Constraint Programming <ref> [23] </ref>), and KAP (Kernel Andorra Prolog [11]) are recent logic programming frameworks that exploit this property to its full extent by being parameterized with respect to an abstract class of constraint systems. The basic operation these frameworks require of a constraint system is a test for unsatisfiability.
Reference: 24. <author> G. Smolka. </author> <title> Feature constraint logics for unification grammars. </title> <journal> The Journal of Logic Programming, </journal> <volume> 12:51--87, </volume> <year> 1992. </year>
Reference-contexts: This gives the more flexible feature trees an interesting potential. More precisely, feature trees model extensible record structures. They form the semantics of record calculi like [1], which are used in symbolic programming languages [5] and in computational linguistics (for example, see <ref> [3, 24] </ref> and the book [8]). Generally, these extensible record structures allow hierarchical representation of partial knowledge. They lend themselves to object-oriented programming techniques [3]. Let us suppose that we want to say that x is a wine whose grape is riesling and whose color is white. <p> These early feature structure formalisms were presented in a non logical form. Major steps in the process of their understanding and logical reformulation are the articles <ref> [22, 25, 13, 24] </ref>. Feature trees, the feature tree structure T , and the axiomatization of T were first given in [7]. <p> The following basic simplification chain, leads to a solved constraint (which, as shown in <ref> [24, 5] </ref>, exhibits unifiability): xfu ^ yfv ^ Au ^ Av ^ z = x ^ y = z by Rule 4 ) xfu ^ yfv ^ Au ^ Av ^ z : : by Rule 4 ) xfu ^ xfv ^ Au ^ Av ^ z : : by Rule <p> parameter pair of feature descriptions (x [f ) u : A]; y [f ) v : B]) has to be tested upon matching of (and incompatibility with) the formal parameter pair (z; z). (This is in order to know whether that function call fires, fails, or residuates.) As shown in <ref> [24, 5] </ref>, this corresponds to testing whether the context fl = xfu ^ yfv ^ Au ^ Bv entails the guard 9z (x : : Let X = fzg.
Reference: 25. <author> G. Smolka and H. At-Kaci. </author> <title> Inheritance hierarchies: Semantics and unification. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 7:343--370, </volume> <year> 1989. </year>
Reference-contexts: These early feature structure formalisms were presented in a non logical form. Major steps in the process of their understanding and logical reformulation are the articles <ref> [22, 25, 13, 24] </ref>. Feature trees, the feature tree structure T , and the axiomatization of T were first given in [7]. <p> Second, it seems attractive to extend FT such that it can accommodate a sort lattice as used in <ref> [1, 3, 4, 5, 25] </ref>.

References-found: 25

