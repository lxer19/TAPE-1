URL: ftp://rtcl.eecs.umich.edu/outgoing/farnam/mcast.ps.gz
Refering-URL: http://www.eecs.umich.edu/~farnam/papers/pubs.html
Root-URL: http://www.cs.umich.edu
Email: fzaher, ashaikh, farnam, kgshing@eecs.umich.edu  
Title: RTCAST: Lightweight Multicast for Real-Time Process Groups  
Author: Tarek Abdelzaher, Anees Shaikh, Farnam Jahanian, and Kang Shin 
Address: Ann Arbor, Michigan 48109-2122  
Affiliation: Real-time Computing Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: We propose a lightweight fault-tolerant multicast and membership service for real-time process groups which may exchange periodic and aperiodic messages. The service supports bounded-time message transport, atomicity, and order for multicasts within a group of communicating processes in the presence of processor crashes and communication failures. It guarantees agreement on membership among the communicating processors, and ensures that membership changes (e.g., resulting from processor joins or departures) are atomic and ordered with respect to multicast messages. We provide the flexibility of an event-triggered approach with the fast message delivery time of time-triggered protocols, such as TTP [13], where messages are delivered to the application immediately upon reception. This is achieved without compromising agreement, order and atom-icity properties. In addition to the design and details of the algorithm, we describe our implementation of the protocol using the x-Kernel protocol architecture running under RT Mach 3.0. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Abdelzaher, A. Shaikh, F. Jahanian, and K. Shin. Rtcast: </author> <title> Lightweight multicast for real-time process groups. </title> <type> Technical report, </type> <institution> Dept. of Elec. Engineering and Comp. Science, University of Michigan, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: Order, atomicity and agreement are proved more formally in <ref> [1] </ref>. Section 4.1 presents the steady state operation of the algorithm (with no receive omissions, processor crashes or membership changes). Section 4.2 then describes how receive omissions are detected and handled. Section 4.3 describes processor crashes and member elimination. <p> The proof of the theorem is detailed <ref> [1] </ref>. Theorem 1 A set of messages G presented by node N j is schedulable if P C i n i T j , where n i = b (d i 4)/P c. 6. <p> It was verified that all messages guaranteed by ACSA made it to all destinations by their respective deadlines, unless the destination crashed. The messages themselves, in all experiments, were generated synthetically. More details regarding performance evaluation are reported in <ref> [1] </ref>. 7. Conclusions In this paper we presented RTCast, a new multicast and membership protocol to support fault-tolerant real-time applications. Our approach follows the process group paradigm in which a group of cooperating processes perform application tasks.
Reference: [2] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. </author> <title> Membership algorithms for multicast communication groups. </title> <booktitle> In Proc. 6th International Workshop on Distributed Algorithms, number 647 in Lecture Notes in Computer Science, </booktitle> <pages> pages 292-312, </pages> <address> Haifa, Israel, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: Additional work on group membership protocols appears in <ref> [2, 10, 17] </ref>. Common to the above mentioned protocols is that they do not explicitly consider the needs of hard real-time applications. Thus these techniques are not suitable for the applications in which we are interested. There are, however, several protocols that target real-time applications.
Reference: [3] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. Transis: </author> <title> A communication sub-system for high availability. </title> <type> Technical Report TR CS91-13, </type> <institution> Dept. of Computer Science, Hebrew University, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: 1. Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous <ref> [6, 3, 19, 15] </ref> and synchronous [13, 4, 11] environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. <p> The ordering task, however, is simplified by assuming a ring network. In addition to ISIS, several other systems have adopted the notion of fault-tolerant process groups, using similar abstractions to support distributed applications. Some of these include Consul [15], Transis <ref> [3] </ref>, and Horus [19]. The Strong Group Membership protocol [12] performs atomic ordered group membership changes using a two phase commit protocol whereby a leader first multicasts a prepare to commit message, and then multicasts a commit message to install the change after receiving acknowledg ments.
Reference: [4] <author> Y. Amir, L. Moser, P. Melliar-Smith, D. Agarwal, and P. Cia-rfella. </author> <title> The Totem single-ring ordering and membership protocol. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 13(4) </volume> <pages> 311-342, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: 1. Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous [6, 3, 19, 15] and synchronous <ref> [13, 4, 11] </ref> environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. <p> Common to the above mentioned protocols is that they do not explicitly consider the needs of hard real-time applications. Thus these techniques are not suitable for the applications in which we are interested. There are, however, several protocols that target real-time applications. Totem <ref> [4] </ref> is an example of a protocol that provides probabilistic real-time guarantees. It is based on a token ring, and guarantees atomic ordered delivery of messages within two token rounds (in the absence of message loss). RTCast, on the other hand, achieves atomicity and order within a single round.
Reference: [5] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Failure of the token site will delay message reception even if both the source and destination are operational. In contrast, RTCast does not acknowledge each message, and need not involve an intermediate node on the path of each message. ISIS <ref> [5, 6] </ref> introduced the concept of virtual synchrony, and integrated a membership protocol into the multicast communication subsystem, whereby membership changes take place in response to communication failure.
Reference: [6] <author> K. P. Birman. </author> <title> The process group approach to reliable distributed computing. </title> <journal> Communications of the ACM, </journal> <volume> 36(12) </volume> <pages> 37-53, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: 1. Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous <ref> [6, 3, 19, 15] </ref> and synchronous [13, 4, 11] environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. <p> Failure of the token site will delay message reception even if both the source and destination are operational. In contrast, RTCast does not acknowledge each message, and need not involve an intermediate node on the path of each message. ISIS <ref> [5, 6] </ref> introduced the concept of virtual synchrony, and integrated a membership protocol into the multicast communication subsystem, whereby membership changes take place in response to communication failure.
Reference: [7] <author> J.-M. Chang and N. Maxemchuk. </author> <title> Reliable broadcast protocols. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 251-273, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Section 7 concludes the paper by discussing the limitations of this work and future research directions. 2 Related work Several fault-tolerant, atomic ordered multicast and membership protocols have been proposed for use in asynchronous distributed systems. In some of the earliest work, Chang and Maxemchuk <ref> [7] </ref> proposed a token based algorithm for a process group where each member sends its messages to a token site which orders the messages and broadcasts acknowledgments. Destinations use the acknowledgments to order messages as specified by the token site.
Reference: [8] <author> B. Chen, S. Kamat, and W. Zhao. </author> <title> Fault-tolerant real-time communication in fddi-based networks. </title> <booktitle> In Proc. 16th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 141-150, </pages> <address> Pisa, Italy, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Finally, a research effort complementary to ours is reported in <ref> [8] </ref>. While we consider fault tolerance with respect to processor failure, we do not suggest a mechanism for implementing fault-tolerant message communication. For example, we do not specify whether or not redundancy is used to tolerate link failures. <p> Permanent link failures (resulting in network partitions) are not considered. We believe that the proper way to handle permanent link failures in fault-tolerant real-time systems is to employ hardware redundancy, for example, as in TTP [13] or suggested in <ref> [8] </ref>. 4. Multicast and membership service Our primary purpose is to provide a multicast service for distributed real-time systems that achieves atomicity and total ordering on messages. The latter is trivially achieved under assumptions P1 - P3.
Reference: [9] <author> F. Cristian. </author> <title> Probabilistic clock synchronization. </title> <journal> Distributed Computing, </journal> <volume> 3 </volume> <pages> 146-158, </pages> <year> 1989. </year>
Reference-contexts: The RTCast layer implements the mul-ticast and membership service as described in Section 4. The Retransmission layer is responsible for handling re-transmissions as described in Section 4.6. ClockSync implements a clock synchronization service. In our present system, ClockSync uses the probabilistic clock synchronization algorithm developed by Cristian <ref> [9] </ref>. It uses the under lying unreliable messaging service provided in the x-Kernel environment.
Reference: [10] <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4 </volume> <pages> 175-187, </pages> <year> 1991. </year>
Reference-contexts: Additional work on group membership protocols appears in <ref> [2, 10, 17] </ref>. Common to the above mentioned protocols is that they do not explicitly consider the needs of hard real-time applications. Thus these techniques are not suitable for the applications in which we are interested. There are, however, several protocols that target real-time applications.
Reference: [11] <author> F. Cristian, B. Dancy, and J. Dehn. </author> <title> Fault-tolerance in the advanced automation system. </title> <booktitle> In Proc. of Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 6-17, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: 1. Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous [6, 3, 19, 15] and synchronous <ref> [13, 4, 11] </ref> environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application.
Reference: [12] <author> F. Jahanian, S. Fakhouri, and R. Rajkumar. </author> <title> Processor group membership protocols: Specification, </title> <booktitle> design, and implementation. In Proc. 12th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <year> 1993. </year>
Reference-contexts: The ordering task, however, is simplified by assuming a ring network. In addition to ISIS, several other systems have adopted the notion of fault-tolerant process groups, using similar abstractions to support distributed applications. Some of these include Consul [15], Transis [3], and Horus [19]. The Strong Group Membership protocol <ref> [12] </ref> performs atomic ordered group membership changes using a two phase commit protocol whereby a leader first multicasts a prepare to commit message, and then multicasts a commit message to install the change after receiving acknowledg ments.
Reference: [13] <author> H. Kopetz and G. Grunsteidl. </author> <title> TTP a protocol for fault-tolerant real-time systems. </title> <journal> IEEE Computer, </journal> <volume> 27(1) </volume> <pages> 14-23, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: 1. Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous [6, 3, 19, 15] and synchronous <ref> [13, 4, 11] </ref> environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. <p> The abstraction hides a portable, analyzable, scalable and efficient mechanism for group communication. It does not, however, attempt to guarantee atomicity and order in the presence of failures, which may compromise consistency. TTP <ref> [13] </ref> is similar to RTCast in many respects. It uses a time-triggered scheme to provide predictable immediate message delivery, membership service, and redundancy management in fault-tolerant real-time systems. <p> Permanent link failures (resulting in network partitions) are not considered. We believe that the proper way to handle permanent link failures in fault-tolerant real-time systems is to employ hardware redundancy, for example, as in TTP <ref> [13] </ref> or suggested in [8]. 4. Multicast and membership service Our primary purpose is to provide a multicast service for distributed real-time systems that achieves atomicity and total ordering on messages. The latter is trivially achieved under assumptions P1 - P3.
Reference: [14] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: ISIS [5, 6] introduced the concept of virtual synchrony, and integrated a membership protocol into the multicast communication subsystem, whereby membership changes take place in response to communication failure. ISIS implements an atomic ordered multicast on top of a vector clock-based <ref> [14] </ref> causal multicast service, using an idea similar to that of Chang and Maxemchuk. While we integrate membership and multicast services, we implement ordered atomic multicast directly without constructing a partial order first. The ordering task, however, is simplified by assuming a ring network. <p> It turns out, a better decision is to eliminate only the transitive closure of immediate predecessors from which a heartbeat has not been received, if any. The rationale for this is best illustrated by an example. Consider Figure 5 4 This is different from using vector clocks <ref> [14] </ref> where a vector is communicated in each message. In our scheme, the message carries only its sequence number and sender id. 5 We know who the sender is because we know from whom a message is missing where processor H has just timed out.
Reference: [15] <author> S. Mishra, L. Peterson, and R. Schlichting. </author> <title> Consul: A communication substrate for fault-tolerant distributed programs. </title> <journal> Distributed Systems Engineering Journal, </journal> <volume> 1(2) </volume> <pages> 87-103, </pages> <month> De-cember </month> <year> 1993. </year>
Reference-contexts: 1. Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous <ref> [6, 3, 19, 15] </ref> and synchronous [13, 4, 11] environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. <p> The ordering task, however, is simplified by assuming a ring network. In addition to ISIS, several other systems have adopted the notion of fault-tolerant process groups, using similar abstractions to support distributed applications. Some of these include Consul <ref> [15] </ref>, Transis [3], and Horus [19]. The Strong Group Membership protocol [12] performs atomic ordered group membership changes using a two phase commit protocol whereby a leader first multicasts a prepare to commit message, and then multicasts a commit message to install the change after receiving acknowledg ments.
Reference: [16] <author> R. Rajkumar, M. Gagliardi, and L. Sha. </author> <title> The real-time publisher/subscriber inter-process communication model for distributed real-time systems: </title> <booktitle> Design and implementation. In Proc. Real Time Technology and Applications Symposium, </booktitle> <pages> pages 66-75, </pages> <address> Chicago, IL, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: The intuitive reason why immediate delivery does not interfere with atomicity in RTCast is that processors failing to receive a message take themselves out of the group. Rajkumar et. al. <ref> [16] </ref> present an elegant publisher/subscriber model for distributed real-time systems. It provides a simple user interface for publishing messages on a logical channel, and for subscribing to selected channels as needed by each application.
Reference: [17] <author> A. M. Ricciardi and K. P. Birman. </author> <title> Process membership in asynchronous environments. </title> <type> Technical Report TR93-1328, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Additional work on group membership protocols appears in <ref> [2, 10, 17] </ref>. Common to the above mentioned protocols is that they do not explicitly consider the needs of hard real-time applications. Thus these techniques are not suitable for the applications in which we are interested. There are, however, several protocols that target real-time applications.
Reference: [18] <author> L. Rodrigues, P. Ver issimo, and J. Rufino. </author> <title> A low-level processor group membership protocol for LANs. </title> <booktitle> In Proc. Int. Conf. on Distributed Computer Systems, </booktitle> <pages> pages 541-550, </pages> <year> 1993. </year>
Reference-contexts: The Strong Group Membership protocol [12] performs atomic ordered group membership changes using a two phase commit protocol whereby a leader first multicasts a prepare to commit message, and then multicasts a commit message to install the change after receiving acknowledg ments. The MGS protocol <ref> [18] </ref> for processor group mem-bership uses three phases: the first to request/acquire a lock (by the group leader) on the membership state table of each member, the next to send new data and collect acknowledgments, and the third to retransmit changes to processors from which acknowledgments are missing.
Reference: [19] <author> R. van Renesse, T. Hickey, and K. Birman. </author> <title> Design and performance of Horus: A lightweight group communications system. </title> <type> Technical Report TR94-1442, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: 1. Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous <ref> [6, 3, 19, 15] </ref> and synchronous [13, 4, 11] environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. <p> The ordering task, however, is simplified by assuming a ring network. In addition to ISIS, several other systems have adopted the notion of fault-tolerant process groups, using similar abstractions to support distributed applications. Some of these include Consul [15], Transis [3], and Horus <ref> [19] </ref>. The Strong Group Membership protocol [12] performs atomic ordered group membership changes using a two phase commit protocol whereby a leader first multicasts a prepare to commit message, and then multicasts a commit message to install the change after receiving acknowledg ments.
References-found: 19

