URL: http://www.acm.org/jacm/papers/269.ps
Refering-URL: http://www.acm.org/jacm/Upcoming.html
Root-URL: 
Email: kifer@cs.sunysb.edu  
Title: On the Decidability and Axiomatization of Query Finiteness in Deductive Databases  
Author: Michael Kifer 
Keyword: Categories and Subject Descriptors: H.2.1 [Database Management]: Systems query processing; I.2.3 [Computing Methodologies]: Deduction and Theorem Proving logic programming. General Terms: Algorithms, languages, theory. Additional Keywords and Phrases: Query processing, finiteness constraints, finite queries, horizon tal decompositions, partial constraints, computability, axiomatization.  
Date: April 21, 1998  
Address: NY 11794  
Affiliation: Department of Computer Science SUNY at Stony Brook Stony Brook,  
Abstract: A database query is finite 1 if its result consists of a finite set of tuples. For queries formulated as sets of pure Horn rules, the problem of determining finiteness is, in general, undecidable. In this paper we consider superfiniteness|a stronger kind of finiteness, which applies to Horn queries whose function symbols are replaced by the abstraction of infinite relations with finiteness constraints (abbr., FC's). We show that superfiniteness is not only decidable but also axiomatizable, and the axiomatization yields an effective decision procedure. Although there are finite queries that are not superfinite, we demonstrate that superfinite queries represent an interesting and nontrivial subclass within the class of all finite queries. Then we turn to the issue of inference of finiteness constraints|an important practical problem that is instrumental in deciding if a query is evaluable by a bottom-up algorithm. Although it is not known whether FC-entailment is decidable for sets of function-free Horn rules, we show that super-entailment, a stronger form of entailment, is decidable. We also show how a decision procedure for super-entailment can be used to enhance tests for query finiteness. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and R. Hull. </author> <title> Data functions, Datalog and negation. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 143-154, </pages> <address> New York, 1988. </address> <publisher> ACM. </publisher>
Reference-contexts: It should be noted that projections of trivial constraints may be non-trivial. For example, consider the PRD r = p <ref> [1; 1] </ref>. Then r : 1 &gt; 2 and r : 2 &gt; 1 both are nontrivial projections of the trivial FC p : 1 &gt; 1. <p> It is also unknown whether superfiniteness is decidable for Extended Datalog with FD's. (As mentioned earlier, this problem is undecidable for the regular finiteness.) Furthermore, decidability of weak finiteness for Datalog with function symbols is also an open problem. Abiteboul and Hull <ref> [1] </ref> have shown that a related problem of whether a given FD holds in a relation computed by a Datalog IDB from an EDB that satisfies certain FD's is undecidable. The answer to a similar question for FC's is unknown.
Reference: [2] <author> K.R. Apt, H. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kauf-mann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: Then any fixpoint of T P [edb is a model of P [ edb and thus of P [22]. We call such models fixpoint models of P (note: edb is a variable parameter here). Fixpoints of T P [edb are sometimes also called supported models <ref> [2] </ref>, and the class of all such models is known to coincide with the class of all models of Clark's completion [22] of P [ edb. For an example of a model that is not a fixpoint model, consider the following rule: p (X) q (X). <p> It holds in an (ordinary) database instance if and only if r = p [ ~ X ], where r and p are relations assigned to r and p by that database instance. The position-number notation is often convenient for dealing with projections. For instance, we can write p <ref> [3; 2; 2] </ref> to denote the projection of p on the third and then twice the second attribute. Let r = p [i 1 ; : : : ; i m ] be a PRD in the position-number notation. <p> Associated with this PRD is a natural attribute mapping t from the attributes of r to those of p. It is defined as follows: t (r : j) = p : i j , for j = 1; : : : ; m. Thus, for r = p <ref> [3; 2; 2] </ref>, the associated attribute mapping is fr : 1 7! p : 3; r : 2 7! p : 2; r : 3 7! p : 2g. <p> There may exist several such Y 0 and Z 0 , since t does not have to be a 1-1 mapping; therefore, an FC may have several projections. For the above PRD r = p <ref> [3; 2; 2] </ref> and the FC p : 2 &gt; f1; 3g, the projections of this FC on r are r : 2 &gt; 1, r : 3 &gt; 1, and r : f2; 3g &gt; 1 (because both r : 2 and r : 3 are mapped to p :
Reference: [3] <author> C. Beeri and P.A. Bernstein. </author> <title> Computational problems related to the design of normal form relational schemes. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(1) </volume> <pages> 30-59, </pages> <month> March </month> <year> 1979. </year>
Reference-contexts: By the proof of Proposition 4.2, if ffi is X &gt; Y then F ` ffi if and only if Y X + F . Closure of any set can be computed in linear time, as in <ref> [3] </ref>, so checking the implication F j= G takes quadratic time in the size of F and G. 2 5 Motivating Examples In this section, we motivate the need for various integrity constraints and illustrate how they can be used for proving finiteness. <p> It holds in an (ordinary) database instance if and only if r = p [ ~ X ], where r and p are relations assigned to r and p by that database instance. The position-number notation is often convenient for dealing with projections. For instance, we can write p <ref> [3; 2; 2] </ref> to denote the projection of p on the third and then twice the second attribute. Let r = p [i 1 ; : : : ; i m ] be a PRD in the position-number notation. <p> Associated with this PRD is a natural attribute mapping t from the attributes of r to those of p. It is defined as follows: t (r : j) = p : i j , for j = 1; : : : ; m. Thus, for r = p <ref> [3; 2; 2] </ref>, the associated attribute mapping is fr : 1 7! p : 3; r : 2 7! p : 2; r : 3 7! p : 2g. <p> There may exist several such Y 0 and Z 0 , since t does not have to be a 1-1 mapping; therefore, an FC may have several projections. For the above PRD r = p <ref> [3; 2; 2] </ref> and the FC p : 2 &gt; f1; 3g, the projections of this FC on r are r : 2 &gt; 1, r : 3 &gt; 1, and r : f2; 3g &gt; 1 (because both r : 2 and r : 3 are mapped to p : <p> We do not know if there is a substantially more efficient way to determine whether a given FC holds in an IDB-predicate. There is a linear procedure for testing this in case of a single predicate <ref> [3] </ref>, but it is unclear how this procedure can be used to help optimize FC-inference over IDB-predicates. Examples As a first application of the semi-naive algorithm, we shall prove superfiniteness of the IDB in Example 5.2.
Reference: [4] <author> A. Brodsky and Y. Sagiv. </author> <title> On termination of Datalog programs. </title> <booktitle> In Intl. Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 47-64. </pages> <publisher> Elsevier Science Publ., </publisher> <year> 1989. </year>
Reference-contexts: The reader is referred to [38, 39] for the introductory material on deductive databases. Most of this paper is concerned with Extended Datalog. Extended Datalog was introduced in [26] as an approximation of Datalog with function symbols 4 and has been extensively studied since then <ref> [32, 16, 4, 31, 30] </ref>. The interest in this approximation is fueled primarily by the fact that finiteness and computability of Extended Datalog queries is easier to study, and the corresponding algorithms can be converted into sufficient tests for finiteness and termination of queries over Horn databases with function symbols.
Reference: [5] <author> M.A. Casanova, R. Fagin, and C.H. Papadimitriou. </author> <title> Inclusion dependencies and their interaction with functional dependencies. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 28 </volume> <pages> 29-59, </pages> <year> 1984. </year>
Reference-contexts: We show that superfiniteness is not only decidable, but also axiomatizable, and that the axiomatization leads to an effective decision procedure. An interesting aspect of our axiomatization is that it involves inclusion dependencies (IND's) <ref> [5] </ref> in addition to finiteness constraints. It follows from our results that despite a number of common properties of FD's and FC's, including the common Armstrong's axiomatization, the inference problem for FC's and IND's is decidable and axiomatizable. <p> It follows from our results that despite a number of common properties of FD's and FC's, including the common Armstrong's axiomatization, the inference problem for FC's and IND's is decidable and axiomatizable. In contrast, the corresponding problem for FD's and IND's is neither axiomatizable (in the conventional sense) <ref> [5] </ref>, nor decidable [24, 6]. This may seem even more surprising in view of the fact that FC's are not first-order entities (i.e., they cannot be expressed as a first-order formula), while the notion of an FD is first-order. <p> If, for some 10 In fact, if Claims 2 and 4 were true for FD's, we could have used the techniques of Proposition 9.1, below, to establish a completeness result for FD's and inclusion dependencies, which is impossible according to <ref> [5] </ref>. 20 C 2 Y and b k , we have t 1 [C] = t 2 [C] = = b k , then, by the definition of F -simplicity, for all i, the value t i [B] can be either b k or a, in which case we are done. <p> The termination condition can be effectively checked, since equivalence of PC's is decidable, by Corollary 6.4. 2 26 The result of Theorem 9.2 is somewhat unexpected since the corresponding result for FD's and IND's is negative: the inference problem is neither axiomatizable (in the conventional sense) <ref> [5] </ref>, nor decidable [24, 6]. Axiomatizability is particularly surprising because FC's cannot be expressed in first-order logic, while FD's are easily expressible as first-order formulas. Despite the many similarities between FC's and FD's there are some important differences. <p> Despite the many similarities between FC's and FD's there are some important differences. First, if all relations are finite then all FC's become trivial, and the problem reduces to that of inferring IND's only, which is decidable <ref> [5] </ref>. Second, one of the axioms for FD's and IND's is no longer sound for FC's. 12 Corollary 9.3 The time complexity of the algorithm in Theorem 9.2 has exponential upper bound in the size of and ff. <p> is correct for FC's only (but PC's are used in the process). 12 The axiom in question is: from (U [ V ) (X [ Y ); (U [ W ) (X [ Z) and X &gt; Y infer (U [ V [ W ) (X [ Y [ Z) <ref> [5, 24] </ref>. Reduction of Super-entailment and Superfiniteness to PC Inference The reduction was already informally described in Examples 5.1, 5.2, and 7.1. To make this construction precise, we associate database schemas to Horn IDBs as follows.
Reference: [6] <author> A.K. Chandra and M.Y. Vardi. </author> <title> The implication problem for functional and inclusion dependencies is undecidable. </title> <journal> SIAM Journal on Computing, </journal> <volume> 14 </volume> <pages> 671-677, </pages> <year> 1985. </year>
Reference-contexts: In contrast, the corresponding problem for FD's and IND's is neither axiomatizable (in the conventional sense) [5], nor decidable <ref> [24, 6] </ref>. This may seem even more surprising in view of the fact that FC's are not first-order entities (i.e., they cannot be expressed as a first-order formula), while the notion of an FD is first-order. <p> The termination condition can be effectively checked, since equivalence of PC's is decidable, by Corollary 6.4. 2 26 The result of Theorem 9.2 is somewhat unexpected since the corresponding result for FD's and IND's is negative: the inference problem is neither axiomatizable (in the conventional sense) [5], nor decidable <ref> [24, 6] </ref>. Axiomatizability is particularly surprising because FC's cannot be expressed in first-order logic, while FD's are easily expressible as first-order formulas. Despite the many similarities between FC's and FD's there are some important differences.
Reference: [7] <author> B. Convent. </author> <title> Deciding finiteness, groundedness and domain independence of pure Datalog queries. </title> <journal> J. of Information Processing and Cybernatics, </journal> <volume> 25 </volume> <pages> 401-416, </pages> <year> 1989. </year> <month> 44 </month>
Reference-contexts: Moreover, we believe that, from the practical point of view, FC-inference is more important than query finiteness, since knowing the FC's may help to determine if a query evaluation process terminates <ref> [20, 7, 17] </ref>, while mere knowledge that some query is finite is usually insufficient for detecting termination. We remind that an FC ff is super-entailed by an IDB P and a set of FC's F if ff holds in every fixpoint of P that satisfies F . <p> For instance, Kifer [16, 17] has shown that finiteness is decidable for extended Horn databases where the only FC's are of the form Finite (i 1 ; : : : ; i k ). Independently, Convent <ref> [7] </ref> proposed a similar decision procedure for the case when all EDB-predicates are finite, but IDBs need not be range-restricted. 22 Sagiv and Vardi [32] developed a decision procedure for finiteness of monadic IDBs, i.e., IDBs where all recursive predicates are unary. <p> To see how a combined procedure might work, we shall describe a slightly improved version of the algorithm from <ref> [16, 7, 17] </ref>. Algorithm 12.1 An improved version of the finiteness test from [16, 7, 17] Input: Horn IDB P and a set F of FC's of the form d : Finite (i 1 ; : : : ; i k ), where d is an EDB-predicate of P. <p> To see how a combined procedure might work, we shall describe a slightly improved version of the algorithm from <ref> [16, 7, 17] </ref>. Algorithm 12.1 An improved version of the finiteness test from [16, 7, 17] Input: Horn IDB P and a set F of FC's of the form d : Finite (i 1 ; : : : ; i k ), where d is an EDB-predicate of P.
Reference: [8] <author> S.S. </author> <title> Cosmadakis and P.C. Kanellakis. Functional and inclusion dependencies: A graph theoretic approach. In P.C. </title> <editor> Kanellakis, editor, </editor> <booktitle> Advances in Computing Research, </booktitle> <volume> volume 3, </volume> <pages> pages 163-184. </pages> <publisher> Plenum Press, </publisher> <year> 1986. </year>
Reference-contexts: Observe further that no inference rule needs to be applied more than an exponential number of times. This is because no rule needs to be applied twice with the same premises, and the number of all possible PC's is at most exponential. 2 In <ref> [8] </ref>, it is shown that the corresponding inference problem for FD's and acyclic IND's is decidable, but is NP-hard. We do not know if the inference problem for FC's is also NP-hard.
Reference: [9] <author> P. De Bra. </author> <title> Horizontal decompositions based on functional-dependency-set implications. </title> <booktitle> In Intl. Conference on Database Theory, volume 243 of Lecture Notes in Computer Science, </booktitle> <pages> pages 157-170, </pages> <address> Rome, Italy, 1986. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We also note that partial constraints are quite different from conditional functional dependencies studied in <ref> [10, 9] </ref>, although both classes of constraints are intended to deal with problems arising when relations have non-uniform horizontal structure.
Reference: [10] <author> P. De Bra and J. Paredaens. </author> <title> Horizontal decompositions for handling exceptions to functional dependencies. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> volume 154, </volume> <pages> pages 67-82. </pages> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: We also note that partial constraints are quite different from conditional functional dependencies studied in <ref> [10, 9] </ref>, although both classes of constraints are intended to deal with problems arising when relations have non-uniform horizontal structure.
Reference: [11] <author> R.A. Di Paola. </author> <title> The recursive unsolvability of the decision problem for the class of definite formulas. </title> <journal> Journal of ACM, </journal> <pages> pages 324-327, </pages> <month> April </month> <year> 1969. </year>
Reference-contexts: An important issue, therefore, is the design of algorithms that can capture various interesting subclasses of finite queries. A special case of this problem is the question of whether a database query is finite. Finiteness is known to be undecidable for first-order queries without function symbols (but with negation) <ref> [11, 40] </ref>. 2 A sound (albeit incomplete) algorithm for testing finiteness for this class of queries was proposed in [41]. Finiteness is also undecidable for Horn queries with function symbols [36]. However, this problem is decidable for Horn queries without function symbols, even in the presence of infinite relations [16].
Reference: [12] <author> P.C. Fischer, J.H. Jou, </author> <title> and D.M. Tsou. Succinctness in dependency systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 24 </volume> <pages> 323-329, </pages> <year> 1983. </year>
Reference-contexts: However, it does hold in the part of r generated by the rule R. The complexity of producing PC's for the head predicate may be exponential in k|the number of distinct variables in R|as shown in <ref> [12] </ref>. In fact, Fischer et al. [12] have shown that for certain sets of FC's, the size of F [ ~ X] may be exponential in the size of F . <p> However, it does hold in the part of r generated by the rule R. The complexity of producing PC's for the head predicate may be exponential in k|the number of distinct variables in R|as shown in <ref> [12] </ref>. In fact, Fischer et al. [12] have shown that for certain sets of FC's, the size of F [ ~ X] may be exponential in the size of F . <p> If pc (r) ` ff (using the inference rules for PC's only) then P and F super-entail r : ff. Otherwise, r : ff is not super-entailed. 20 In <ref> [12] </ref> and [14], the results were actually obtained for FD's. <p> This follows from the fact that in the realm of FD's (and FC's) over a single relation 21 the size of the set of projected FD's may be exponential in the input <ref> [12] </ref>. Nevertheless, the results in [14] indicate that this happens only in pathological cases and that the use of the projection algorithm in [14] could make our semi-naive algorithm quite practical.
Reference: [13] <author> A N. Goodman and A O. Shmueli. </author> <title> Tree queries: A simple class of queries. </title> <journal> ACM Transactions on Database Systems, </journal> <pages> pages 653-677, </pages> <month> December </month> <year> 1982. </year>
Reference-contexts: We extend this mapping to sets and sequences of attributes in the usual way. 9 Our notion of projection dependencies should not be confused with that of <ref> [13] </ref>, which is a different concept. 17 Consider a PRD r = p [ ~ X], and let t be the associated mapping.
Reference: [14] <author> G. Gottlob. </author> <title> Computing covers for embedded functional dependencies. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 58-69, </pages> <address> New York, </address> <month> March </month> <year> 1987. </year> <note> ACM. </note>
Reference-contexts: In fact, Fischer et al. [12] have shown that for certain sets of FC's, the size of F [ ~ X] may be exponential in the size of F . However, Gottlob <ref> [14] </ref> later proposed an efficient algorithm that runs in polynomial time in many practical cases. 20 Algorithm 10.3 Semi-naive Inference of FC's over IDB Predicates Input: IDB P and a set F of FC's for the EDB-predicates. <p> If pc (r) ` ff (using the inference rules for PC's only) then P and F super-entail r : ff. Otherwise, r : ff is not super-entailed. 20 In [12] and <ref> [14] </ref>, the results were actually obtained for FD's. <p> This follows from the fact that in the realm of FD's (and FC's) over a single relation 21 the size of the set of projected FD's may be exponential in the input [12]. Nevertheless, the results in <ref> [14] </ref> indicate that this happens only in pathological cases and that the use of the projection algorithm in [14] could make our semi-naive algorithm quite practical. We do not know if there is a substantially more efficient way to determine whether a given FC holds in an IDB-predicate. <p> Nevertheless, the results in <ref> [14] </ref> indicate that this happens only in pathological cases and that the use of the projection algorithm in [14] could make our semi-naive algorithm quite practical. We do not know if there is a substantially more efficient way to determine whether a given FC holds in an IDB-predicate.
Reference: [15] <author> D.S. Johnson and A. Klug. </author> <title> Testing containment of conjunctive queries under functional and inclusion dependencies. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 28 </volume> <pages> 167-189, </pages> <year> 1984. </year>
Reference-contexts: Starting with D 0 , we construct a -simple database instance that, in addition, will satisfy all PRD's, IND's, and DD's in . The construction uses a chase process that is akin to that used for inclusion dependencies <ref> [15] </ref>. The chase process consists in applying compensating rules to an intermediate database instance D, which initially is identical to D 0 but subsequently is changed by rule applications. Given D and a predicate r, we shall use r to denote the decomposition instance that D assigns to r.
Reference: [16] <author> M. Kifer. </author> <title> On safety, domain independence, and capturability of database queries. </title> <booktitle> In 3-d Intl. Conference on Data and Knowledge Bases, </booktitle> <pages> pages 405-415, </pages> <address> Jerusalem, Israel, June 1988. </address> <publisher> Morgan-Kaufmann. </publisher>
Reference-contexts: Finiteness is also undecidable for Horn queries with function symbols [36]. However, this problem is decidable for Horn queries without function symbols, even in the presence of infinite relations <ref> [16] </ref>. As finiteness is undecidable in the presence of function symbols, [26] proposed an elegant abstraction of this problem using function-free Horn queries with infinite relations and finiteness constraints (abbr., FC's). <p> Clearly, a query is finite if it is superfinite. 2 These papers dealt with domain independence, but a simple modification of the proofs shows undecidability of finiteness as well <ref> [16, 17] </ref>. 2 Although the converse is not always true, superfinite queries represent an interesting and nontrivial subclass within the class of all finite queries. We show that superfiniteness is not only decidable, but also axiomatizable, and that the axiomatization leads to an effective decision procedure. <p> The reader is referred to [38, 39] for the introductory material on deductive databases. Most of this paper is concerned with Extended Datalog. Extended Datalog was introduced in [26] as an approximation of Datalog with function symbols 4 and has been extensively studied since then <ref> [32, 16, 4, 31, 30] </ref>. The interest in this approximation is fueled primarily by the fact that finiteness and computability of Extended Datalog queries is easier to study, and the corresponding algorithms can be converted into sufficient tests for finiteness and termination of queries over Horn databases with function symbols. <p> As for the usual notion of finiteness, there are decidability results for special classes of IDBs. Consider Extended Datalog. If only constraints of the form Finite (X) are allowed, finiteness is decidable <ref> [16, 17] </ref>. If we allow FC's, the problem is known to be decidable (in polynomial time, in fact) for monadic IDBs [32]. The finiteness problem is also decidable for the following non-recursive IDBs: 40 1. Extended Datalog with FC's. <p> But then, since the Herbrand universe is recursively enumerable, this would be an algorithm for enumerating all negative ground atoms such that comp (P) j= :l, contrary to the aforesaid Theorem 13 in [35]. 2 Although many results exist regarding the various forms of finiteness, <ref> [16, 17, 20, 32, 36] </ref>, several problems still remain open. The foremost among them is the question of whether query finiteness for Extended Datalog with FC's is decidable. <p> As remarked earlier, it is unknown whether finiteness is decidable, let alone axiomatizable. Nevertheless, our semi-naive algorithm, which is complete only for super-entailment of FC's, can be combined with other algorithms for FC-inference to yield stronger results. For instance, Kifer <ref> [16, 17] </ref> has shown that finiteness is decidable for extended Horn databases where the only FC's are of the form Finite (i 1 ; : : : ; i k ). <p> To see how a combined procedure might work, we shall describe a slightly improved version of the algorithm from <ref> [16, 7, 17] </ref>. Algorithm 12.1 An improved version of the finiteness test from [16, 7, 17] Input: Horn IDB P and a set F of FC's of the form d : Finite (i 1 ; : : : ; i k ), where d is an EDB-predicate of P. <p> To see how a combined procedure might work, we shall describe a slightly improved version of the algorithm from <ref> [16, 7, 17] </ref>. Algorithm 12.1 An improved version of the finiteness test from [16, 7, 17] Input: Horn IDB P and a set F of FC's of the form d : Finite (i 1 ; : : : ; i k ), where d is an EDB-predicate of P.
Reference: [17] <author> M. Kifer. </author> <title> The relationship among finiteness, domain independence and capturability. </title> <journal> Unpublished maniscript, </journal> <year> 1990. </year>
Reference-contexts: It is generally agreed now that this abstraction is a useful tool for studying the problems of finiteness and computability when function symbols must be taken into account. The interest in finiteness constraints was further stimulated by the works <ref> [30, 20, 17] </ref> that showed that the knowledge of certain FC's over some database predicates may help prove that the query is evaluable by a bottom-up algorithm in a finite number of steps. These studies, thus, suggest that algorithms for FC-inference may become an important part of query processing. <p> Clearly, a query is finite if it is superfinite. 2 These papers dealt with domain independence, but a simple modification of the proofs shows undecidability of finiteness as well <ref> [16, 17] </ref>. 2 Although the converse is not always true, superfinite queries represent an interesting and nontrivial subclass within the class of all finite queries. We show that superfiniteness is not only decidable, but also axiomatizable, and that the axiomatization leads to an effective decision procedure. <p> Moreover, we believe that, from the practical point of view, FC-inference is more important than query finiteness, since knowing the FC's may help to determine if a query evaluation process terminates <ref> [20, 7, 17] </ref>, while mere knowledge that some query is finite is usually insufficient for detecting termination. We remind that an FC ff is super-entailed by an IDB P and a set of FC's F if ff holds in every fixpoint of P that satisfies F . <p> As for the usual notion of finiteness, there are decidability results for special classes of IDBs. Consider Extended Datalog. If only constraints of the form Finite (X) are allowed, finiteness is decidable <ref> [16, 17] </ref>. If we allow FC's, the problem is known to be decidable (in polynomial time, in fact) for monadic IDBs [32]. The finiteness problem is also decidable for the following non-recursive IDBs: 40 1. Extended Datalog with FC's. <p> Extended Datalog with FD's (as opposed to FC's). This follows from [32], since weak finiteness is the same as finiteness for non-recursive IDBs. 3. Datalog with function symbols <ref> [17] </ref>. On the other hand, Shmueli [36] has shown that finiteness is undecidable for (recursive) Datalog with function symbols. Sagiv and Vardi [32] proved that finiteness is undecidable for Extended Datalog with FD's, even for monadic IDBs. <p> But then, since the Herbrand universe is recursively enumerable, this would be an algorithm for enumerating all negative ground atoms such that comp (P) j= :l, contrary to the aforesaid Theorem 13 in [35]. 2 Although many results exist regarding the various forms of finiteness, <ref> [16, 17, 20, 32, 36] </ref>, several problems still remain open. The foremost among them is the question of whether query finiteness for Extended Datalog with FC's is decidable. <p> As remarked earlier, it is unknown whether finiteness is decidable, let alone axiomatizable. Nevertheless, our semi-naive algorithm, which is complete only for super-entailment of FC's, can be combined with other algorithms for FC-inference to yield stronger results. For instance, Kifer <ref> [16, 17] </ref> has shown that finiteness is decidable for extended Horn databases where the only FC's are of the form Finite (i 1 ; : : : ; i k ). <p> To see how a combined procedure might work, we shall describe a slightly improved version of the algorithm from <ref> [16, 7, 17] </ref>. Algorithm 12.1 An improved version of the finiteness test from [16, 7, 17] Input: Horn IDB P and a set F of FC's of the form d : Finite (i 1 ; : : : ; i k ), where d is an EDB-predicate of P. <p> To see how a combined procedure might work, we shall describe a slightly improved version of the algorithm from <ref> [16, 7, 17] </ref>. Algorithm 12.1 An improved version of the finiteness test from [16, 7, 17] Input: Horn IDB P and a set F of FC's of the form d : Finite (i 1 ; : : : ; i k ), where d is an EDB-predicate of P. <p> This axiomatization yields an effective algorithm to decide the problem. The same machinery was then applied to the problem of inference of finiteness constraints over IDB-predicates in Horn databases|an important issue in processing queries with function symbols <ref> [30, 20, 17] </ref>. Although it is unknown whether entailment of finiteness constraints is decidable for Extended Datalog queries, we have shown that a stronger notion, super-entailment, is decidable. We have also shown how a decision procedure for super-entailment can enhance tests for query finiteness.
Reference: [18] <author> M. Kifer and E.L. Lozinskii. SYGRAF: </author> <title> Implementing logic programs in a database style. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 14(7) </volume> <pages> 922-935, </pages> <year> 1988. </year>
Reference-contexts: Unfortunately, function symbols make the class of all queries expressible via sets of Horn rules (Horn queries) non-capturable <ref> [18] </ref>, i.e., there is no single algorithm that can take any set of database facts and a finite query|i.e., a query with only a finite number of answers for any finite set of database facts|and will terminate after finding all answers to the query.
Reference: [19] <author> M. Kifer, R. Ramakrishnan, and A. Silberschatz. </author> <title> An axiomatic approach to deciding query safety in deductive databases. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 52-60, </pages> <address> New York, </address> <month> March </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: 1 Introduction Query evaluation has been central to deductive database research since the inception of the field. It is known that queries specified via sets of function-free Horn rules are evaluable in finite time. However, fl A preliminary report with some of the results in this paper has appeared in <ref> [19] </ref>. y Work sponsored in part by NSF grants DCR-8603676, IRI-8903507, and CCR-9102159. 1 Finiteness is often called "safety". <p> The foremost among them is the question of whether query finiteness for Extended Datalog with FC's is decidable. This problem has inspired a number of studies <ref> [26, 19, 32] </ref>, including the present work, but no solution has been found as of yet.
Reference: [20] <author> R. Krishnamurthy, R. Ramakrishnan, and O. Shmueli. </author> <title> A framework for testing safety and effective computability. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 52(1) </volume> <pages> 100-124, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: It is generally agreed now that this abstraction is a useful tool for studying the problems of finiteness and computability when function symbols must be taken into account. The interest in finiteness constraints was further stimulated by the works <ref> [30, 20, 17] </ref> that showed that the knowledge of certain FC's over some database predicates may help prove that the query is evaluable by a bottom-up algorithm in a finite number of steps. These studies, thus, suggest that algorithms for FC-inference may become an important part of query processing. <p> Moreover, we believe that, from the practical point of view, FC-inference is more important than query finiteness, since knowing the FC's may help to determine if a query evaluation process terminates <ref> [20, 7, 17] </ref>, while mere knowledge that some query is finite is usually insufficient for detecting termination. We remind that an FC ff is super-entailed by an IDB P and a set of FC's F if ff holds in every fixpoint of P that satisfies F . <p> But then, since the Herbrand universe is recursively enumerable, this would be an algorithm for enumerating all negative ground atoms such that comp (P) j= :l, contrary to the aforesaid Theorem 13 in [35]. 2 Although many results exist regarding the various forms of finiteness, <ref> [16, 17, 20, 32, 36] </ref>, several problems still remain open. The foremost among them is the question of whether query finiteness for Extended Datalog with FC's is decidable. <p> This axiomatization yields an effective algorithm to decide the problem. The same machinery was then applied to the problem of inference of finiteness constraints over IDB-predicates in Horn databases|an important issue in processing queries with function symbols <ref> [30, 20, 17] </ref>. Although it is unknown whether entailment of finiteness constraints is decidable for Extended Datalog queries, we have shown that a stronger notion, super-entailment, is decidable. We have also shown how a decision procedure for super-entailment can enhance tests for query finiteness.
Reference: [21] <author> V.S. Lakshmanan and D.A. Nonen. </author> <title> Superfiniteness of query answers in deductive databases: An automata-theoretic approach. </title> <booktitle> In 12th Intl. Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <month> Dec </month> <year> 1992. </year> <month> 45 </month>
Reference-contexts: ) b (X 1 ) R 3 : p (X 3 ; Y 3 ) b (X 3 ); g (Y 3 ; V 3 ); h (Y 3 ; W 3 ); p (V 3 ; W 3 ) h : 2 &gt; 1 6 As an amusing aside, <ref> [21] </ref> points out that this database has a "real-life" interpretation as a definition of the concept of "founding fathers and mothers." 10 where b is a finite EDB-predicate and g, h are infinite EDB-predicates. Is p finite? We begin to argue as in Example 5.1.
Reference: [22] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming (Second Edition). </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Let P be a set of Horn rules (the intensional part of the database) and edb be a set of database facts (the extensional part of the database). Let T P [edb be the corresponding immediate-consequence operator <ref> [22] </ref> that maps Herbrand interpretations of P to other such interpretations. Then any fixpoint of T P [edb is a model of P [ edb and thus of P [22]. We call such models fixpoint models of P (note: edb is a variable parameter here). <p> Let T P [edb be the corresponding immediate-consequence operator <ref> [22] </ref> that maps Herbrand interpretations of P to other such interpretations. Then any fixpoint of T P [edb is a model of P [ edb and thus of P [22]. We call such models fixpoint models of P (note: edb is a variable parameter here). Fixpoints of T P [edb are sometimes also called supported models [2], and the class of all such models is known to coincide with the class of all models of Clark's completion [22] of P <p> of P <ref> [22] </ref>. We call such models fixpoint models of P (note: edb is a variable parameter here). Fixpoints of T P [edb are sometimes also called supported models [2], and the class of all such models is known to coincide with the class of all models of Clark's completion [22] of P [ edb. For an example of a model that is not a fixpoint model, consider the following rule: p (X) q (X). The assignment of the empty relation to q and of the relation f&lt; 7 &gt;g to p constitutes a model, but not a fixpoint model. <p> Section 13 concludes the paper. 2 Preliminaries For future reference, we shall briefly review the standard notions of logic programming and deductive databases. The reader is referred to <ref> [22, 38, 39] </ref> for more details. 3 In [32] this property is called "weak safety." 3 Terms, Rules, Databases A term is either a variable, or a function symbol applied to the number of terms appropriate for the arity of that symbol. <p> A well-known fact about Horn databases is that intersection of any number of models of such a database D is also a model. Intersection of all models is thus the least (by inclusion) model of D <ref> [22] </ref>. This model can also be characterized as the unique least fixpoint of the operator T D that maps the interpretations of D into other such interpretations, as defined next. Let I be an interpretation. <p> A pre-fixpoint is an interpretation such that T D (I) I. It is well-known <ref> [22] </ref> that I is a model of D if and only if it is a pre-fixpoint of D; it is the least model of D if and only if it is the least fixpoint of T D . <p> Likewise, any least fixpoint of T P [edb is said to be a least fixpoint model of P (which is also the least model of P [ edb <ref> [22] </ref>). Note that here edb acts as a parameter that gives rise to different fixpoint (and least fixpoint) models of P. <p> To show that M is a fixpoint, we need to establish that T P [edb (M ) M and M T P [edb (M ). The former is just a re-statement of the fact that M is a model of P [ edb <ref> [22] </ref>, as mentioned in Section 2. The latter property is called supportedness; it means that every fact in M is either an edb-fact, or it can be derived with an appropriate rule of P applied to the appropriate facts of M . <p> This brittleness is not that surprising, if we recall the well-known fact that Clark's completion of any logic program breaks down under a similar transformation <ref> [22] </ref>. After all, superfiniteness means finiteness in all models of the Clark's completion of the program. <p> Proof: It is shown in [35, Theorem 13] that there exists a Horn IDB P such that the set S of all negative ground literals that are true in all Herbrand models of comp (P) (the Clark's completion of P <ref> [22] </ref>), is not recursively enumerable. We will show that if superfiniteness for Datalog with function symbols were decidable, there would then be an algorithm to enumerate S. Consider the IDB P mentioned above, and let l be a ground atom taken from the Herbrand base of P. <p> By deleting all g-literals from M 0 , we obtain a fixpoint model M of P such that M j= l. Statement (12) above is equivalent to comp (P) j= :l, since the set of fixpoint models of P coincides with the set of all models of comp (P) <ref> [22] </ref>. Therefore, if we could decide superfiniteness, we could then determine, for each atom in the Herbrand universe of P, whether or not comp (P) j= :l.
Reference: [23] <author> D. Maier and D.S. Warren. </author> <title> Computing with Logic: Logic Programming with Prolog. </title> <address> Benjamin-Cummings, Menlo Park, CA, </address> <year> 1988. </year>
Reference-contexts: Augmented with infinite EDB-relations, such databases 5 are called Extended Datalog. In comparative studies of various kinds of databases, it has also become common to talk about "Datalog with function symbols," although this is somewhat of a misnomer, since the very term "Datalog" was introduced in <ref> [23] </ref> specifically to indicate the absence of function symbols. The reader is referred to [38, 39] for the introductory material on deductive databases. Most of this paper is concerned with Extended Datalog.
Reference: [24] <author> J.C. Mitchell. </author> <title> The implication problem for functional and inclusion dependencies. </title> <journal> Information and Control, </journal> <volume> 56 </volume> <pages> 154-173, </pages> <year> 1983. </year>
Reference-contexts: In contrast, the corresponding problem for FD's and IND's is neither axiomatizable (in the conventional sense) [5], nor decidable <ref> [24, 6] </ref>. This may seem even more surprising in view of the fact that FC's are not first-order entities (i.e., they cannot be expressed as a first-order formula), while the notion of an FD is first-order. <p> The termination condition can be effectively checked, since equivalence of PC's is decidable, by Corollary 6.4. 2 26 The result of Theorem 9.2 is somewhat unexpected since the corresponding result for FD's and IND's is negative: the inference problem is neither axiomatizable (in the conventional sense) [5], nor decidable <ref> [24, 6] </ref>. Axiomatizability is particularly surprising because FC's cannot be expressed in first-order logic, while FD's are easily expressible as first-order formulas. Despite the many similarities between FC's and FD's there are some important differences. <p> talk about super-entailment of PC's, our decision procedure is correct for FC's only (but PC's are used in the process). 12 The axiom in question is: from (U [ V ) (X [ Y ); (U [ W ) (X [ Z) and X &gt; Y infer (U [ V <ref> [ W ) (X [ Y [ Z) [5, 24] </ref>. Reduction of Super-entailment and Superfiniteness to PC Inference The reduction was already informally described in Examples 5.1, 5.2, and 7.1. To make this construction precise, we associate database schemas to Horn IDBs as follows. <p> PC's, our decision procedure is correct for FC's only (but PC's are used in the process). 12 The axiom in question is: from (U [ V ) (X [ Y ); (U [ W ) (X [ Z) and X &gt; Y infer (U [ V [ W ) (X <ref> [ Y [ Z) [5, 24] </ref>. Reduction of Super-entailment and Superfiniteness to PC Inference The reduction was already informally described in Examples 5.1, 5.2, and 7.1. To make this construction precise, we associate database schemas to Horn IDBs as follows. <p> decision procedure is correct for FC's only (but PC's are used in the process). 12 The axiom in question is: from (U [ V ) (X [ Y ); (U [ W ) (X [ Z) and X &gt; Y infer (U [ V [ W ) (X [ Y <ref> [ Z) [5, 24] </ref>. Reduction of Super-entailment and Superfiniteness to PC Inference The reduction was already informally described in Examples 5.1, 5.2, and 7.1. To make this construction precise, we associate database schemas to Horn IDBs as follows. <p> is correct for FC's only (but PC's are used in the process). 12 The axiom in question is: from (U [ V ) (X [ Y ); (U [ W ) (X [ Z) and X &gt; Y infer (U [ V [ W ) (X [ Y [ Z) <ref> [5, 24] </ref>. Reduction of Super-entailment and Superfiniteness to PC Inference The reduction was already informally described in Examples 5.1, 5.2, and 7.1. To make this construction precise, we associate database schemas to Horn IDBs as follows.
Reference: [25] <author> S. Naqvi and S. Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year>
Reference-contexts: We prefer "finiteness" over "safety," as it is more descriptive and less overloaded. function-free rules have limited expressive power and advanced deductive database systems, such as LDL <ref> [25] </ref>, Coral [27, 28], and XSB [33], do not prohibit the use of function symbols.
Reference: [26] <author> R. Ramakrishnan, F. Bancilhon, and A. Silberschatz. </author> <title> Safety of recursive horn clauses with infinite relations. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 328-339, </pages> <address> New York, </address> <month> March </month> <year> 1987. </year> <note> ACM. </note>
Reference-contexts: Finiteness is also undecidable for Horn queries with function symbols [36]. However, this problem is decidable for Horn queries without function symbols, even in the presence of infinite relations [16]. As finiteness is undecidable in the presence of function symbols, <ref> [26] </ref> proposed an elegant abstraction of this problem using function-free Horn queries with infinite relations and finiteness constraints (abbr., FC's). It is generally agreed now that this abstraction is a useful tool for studying the problems of finiteness and computability when function symbols must be taken into account. <p> These studies, thus, suggest that algorithms for FC-inference may become an important part of query processing. The first step towards the theory of FC-inference was made in <ref> [26] </ref>, where it was noted that finiteness constraints over a single relation have axiomatization similar to Armstrong's axioms for functional dependencies (abbr., FD's) [37]. <p> We show that, like superfiniteness, super-entailment is decidable and axiomatizable. In <ref> [26] </ref>, it was claimed that finiteness is decidable for Horn queries with FC's and infinite relations. Unfortunately, it was later discovered that the proposed algorithm is incomplete. In [32] the finiteness problem was split into weak finiteness 3 and termination. <p> The reader is referred to [38, 39] for the introductory material on deductive databases. Most of this paper is concerned with Extended Datalog. Extended Datalog was introduced in <ref> [26] </ref> as an approximation of Datalog with function symbols 4 and has been extensively studied since then [32, 16, 4, 31, 30]. <p> Nevertheless, as we shall see, superfinite queries form a useful, non-trivial class. 4 Finiteness Constraints The main type of integrity constraints to be considered in this paper is the finiteness constraint. A finiteness constraint (abbr., FC) <ref> [26] </ref> over an EDB-predicate p is a statement of the form p : X &gt; Y , where X and Y are sets of attributes. The name of the predicate may be omitted if it is immaterial or clear from the context. <p> For instance, when we say that p (X; Y ) is a finite relation, we simply mean that there is a constraint p : Finite (X; Y ). Apart from specifying finiteness, FC's can be used to approximate function symbols, which is the main reason behind their introduction in <ref> [26] </ref>. <p> Details of this process can be found in <ref> [26] </ref>, where it is also shown that finiteness of the transformed query implies finiteness of the original query. <p> We say that F (semantically) implies G, denoted F j= G, if G holds in every relation in which F holds. The following result is from <ref> [26] </ref>; its proof is presented here for completeness of the exposition. Proposition 4.2 FC-rules are sound and complete for inferring FC's, i.e., F ` G if and only if F j= G, for any pair of sets of FC's. <p> Apart from the predicates, D has a set of constraints, denoted C (P). These constraints include the FC's that come originally with P (usually they are obtained from the information about finiteness of the base predicates and via the process of function symbol elimination from <ref> [26] </ref>, which is outlined in Section 4). Other constraints are derived from the structure of P. <p> The foremost among them is the question of whether query finiteness for Extended Datalog with FC's is decidable. This problem has inspired a number of studies <ref> [26, 19, 32] </ref>, including the present work, but no solution has been found as of yet.
Reference: [27] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> CORAL: Control, relations and logic. </title> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <pages> pages 238-250. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: We prefer "finiteness" over "safety," as it is more descriptive and less overloaded. function-free rules have limited expressive power and advanced deductive database systems, such as LDL [25], Coral <ref> [27, 28] </ref>, and XSB [33], do not prohibit the use of function symbols.
Reference: [28] <author> R. Ramakrishnan, D. Srivastava, S. Sudarshan, and P. Seshadri. </author> <title> Implementation of the CORAL deductive database system. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 167-176, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1993. </year> <note> ACM. </note>
Reference-contexts: We prefer "finiteness" over "safety," as it is more descriptive and less overloaded. function-free rules have limited expressive power and advanced deductive database systems, such as LDL [25], Coral <ref> [27, 28] </ref>, and XSB [33], do not prohibit the use of function symbols.
Reference: [29] <author> Y. Sagiv. </author> <title> Optimizing Datalog programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 659-698. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: An equivalence transformation may turn a superfinite query into a non-superfinite one. (Of course, here we are talking about equivalence with respect to the least fixpoint of the database; superfiniteness is obviously preserved under uniform equivalence introduced by Sagiv <ref> [29] </ref>.) Example 10.6 (Superfiniteness and query equivalence) Clearly, predicate p in the following IDB is superfinite: p (X) d (X) d : Finite (1) 39 However, the addition of a seemingly innocuous rule, p (Y ) p (Y ), turns p into a finite, but not a superfinite predicate. <p> First, finiteness is preserved under query equivalence, while superfiniteness is preserved only under uniform equivalence of <ref> [29] </ref>. Second, superfiniteness may fail to materialize when the query predicate can accommodate an infinite number of self-supporting facts, which is often caused by, so called, "cyclic facts" in the database (such as p (a; a)). As remarked earlier, it is unknown whether finiteness is decidable, let alone axiomatizable.
Reference: [30] <author> Y. Sagiv. </author> <title> On testing effective computability of magic programs. </title> <booktitle> In Intl. Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 244-262, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: It is generally agreed now that this abstraction is a useful tool for studying the problems of finiteness and computability when function symbols must be taken into account. The interest in finiteness constraints was further stimulated by the works <ref> [30, 20, 17] </ref> that showed that the knowledge of certain FC's over some database predicates may help prove that the query is evaluable by a bottom-up algorithm in a finite number of steps. These studies, thus, suggest that algorithms for FC-inference may become an important part of query processing. <p> The reader is referred to [38, 39] for the introductory material on deductive databases. Most of this paper is concerned with Extended Datalog. Extended Datalog was introduced in [26] as an approximation of Datalog with function symbols 4 and has been extensively studied since then <ref> [32, 16, 4, 31, 30] </ref>. The interest in this approximation is fueled primarily by the fact that finiteness and computability of Extended Datalog queries is easier to study, and the corresponding algorithms can be converted into sufficient tests for finiteness and termination of queries over Horn databases with function symbols. <p> This axiomatization yields an effective algorithm to decide the problem. The same machinery was then applied to the problem of inference of finiteness constraints over IDB-predicates in Horn databases|an important issue in processing queries with function symbols <ref> [30, 20, 17] </ref>. Although it is unknown whether entailment of finiteness constraints is decidable for Extended Datalog queries, we have shown that a stronger notion, super-entailment, is decidable. We have also shown how a decision procedure for super-entailment can enhance tests for query finiteness.
Reference: [31] <author> Y. Sagiv. </author> <title> A termination test for logic programs. </title> <booktitle> In Intl. Logic Programming Symposium, </booktitle> <pages> pages 518-532, </pages> <address> Cambridge, MA, November 1991. </address> <publisher> MIT Press. </publisher>
Reference-contexts: The reader is referred to [38, 39] for the introductory material on deductive databases. Most of this paper is concerned with Extended Datalog. Extended Datalog was introduced in [26] as an approximation of Datalog with function symbols 4 and has been extensively studied since then <ref> [32, 16, 4, 31, 30] </ref>. The interest in this approximation is fueled primarily by the fact that finiteness and computability of Extended Datalog queries is easier to study, and the corresponding algorithms can be converted into sufficient tests for finiteness and termination of queries over Horn databases with function symbols.
Reference: [32] <author> Y. Sagiv and M.Y. Vardi. </author> <title> Safety of queries over infinite databases. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 160-171, </pages> <address> New York, </address> <month> April </month> <year> 1989. </year> <note> ACM. </note>
Reference-contexts: We show that, like superfiniteness, super-entailment is decidable and axiomatizable. In [26], it was claimed that finiteness is decidable for Horn queries with FC's and infinite relations. Unfortunately, it was later discovered that the proposed algorithm is incomplete. In <ref> [32] </ref> the finiteness problem was split into weak finiteness 3 and termination. It was then shown that weak finiteness|a property of Horn queries that guarantees that all intermediate relations remain finite in the course of a bottom-up fixpoint computation|is decidable. <p> Section 13 concludes the paper. 2 Preliminaries For future reference, we shall briefly review the standard notions of logic programming and deductive databases. The reader is referred to [22, 38, 39] for more details. 3 In <ref> [32] </ref> this property is called "weak safety." 3 Terms, Rules, Databases A term is either a variable, or a function symbol applied to the number of terms appropriate for the arity of that symbol. <p> The reader is referred to [38, 39] for the introductory material on deductive databases. Most of this paper is concerned with Extended Datalog. Extended Datalog was introduced in [26] as an approximation of Datalog with function symbols 4 and has been extensively studied since then <ref> [32, 16, 4, 31, 30] </ref>. The interest in this approximation is fueled primarily by the fact that finiteness and computability of Extended Datalog queries is easier to study, and the corresponding algorithms can be converted into sufficient tests for finiteness and termination of queries over Horn databases with function symbols. <p> We have shown that a notion stronger than finiteness, namely superfiniteness, is decidable for Extended Datalog with FC's. Sagiv and Vardi proved that a weaker notion, weak finiteness, is decidable for Extended Datalog both with FC's and FD's <ref> [32] </ref>. As for the usual notion of finiteness, there are decidability results for special classes of IDBs. Consider Extended Datalog. If only constraints of the form Finite (X) are allowed, finiteness is decidable [16, 17]. <p> Consider Extended Datalog. If only constraints of the form Finite (X) are allowed, finiteness is decidable [16, 17]. If we allow FC's, the problem is known to be decidable (in polynomial time, in fact) for monadic IDBs <ref> [32] </ref>. The finiteness problem is also decidable for the following non-recursive IDBs: 40 1. Extended Datalog with FC's. This follows either from the results of this paper or from [32], since for non-recursive IDBs superfiniteness and weak finiteness coincide with finiteness. 2. Extended Datalog with FD's (as opposed to FC's). <p> If we allow FC's, the problem is known to be decidable (in polynomial time, in fact) for monadic IDBs <ref> [32] </ref>. The finiteness problem is also decidable for the following non-recursive IDBs: 40 1. Extended Datalog with FC's. This follows either from the results of this paper or from [32], since for non-recursive IDBs superfiniteness and weak finiteness coincide with finiteness. 2. Extended Datalog with FD's (as opposed to FC's). This follows from [32], since weak finiteness is the same as finiteness for non-recursive IDBs. 3. Datalog with function symbols [17]. <p> Extended Datalog with FC's. This follows either from the results of this paper or from <ref> [32] </ref>, since for non-recursive IDBs superfiniteness and weak finiteness coincide with finiteness. 2. Extended Datalog with FD's (as opposed to FC's). This follows from [32], since weak finiteness is the same as finiteness for non-recursive IDBs. 3. Datalog with function symbols [17]. On the other hand, Shmueli [36] has shown that finiteness is undecidable for (recursive) Datalog with function symbols. Sagiv and Vardi [32] proved that finiteness is undecidable for Extended Datalog with FD's, even <p> This follows from <ref> [32] </ref>, since weak finiteness is the same as finiteness for non-recursive IDBs. 3. Datalog with function symbols [17]. On the other hand, Shmueli [36] has shown that finiteness is undecidable for (recursive) Datalog with function symbols. Sagiv and Vardi [32] proved that finiteness is undecidable for Extended Datalog with FD's, even for monadic IDBs. The following proposition shows that superfiniteness is also undecidable for Datalog with function symbols. Proposition 11.1 Superfiniteness of a query in Datalog with function symbols is recursively unsolvable. <p> But then, since the Herbrand universe is recursively enumerable, this would be an algorithm for enumerating all negative ground atoms such that comp (P) j= :l, contrary to the aforesaid Theorem 13 in [35]. 2 Although many results exist regarding the various forms of finiteness, <ref> [16, 17, 20, 32, 36] </ref>, several problems still remain open. The foremost among them is the question of whether query finiteness for Extended Datalog with FC's is decidable. <p> The foremost among them is the question of whether query finiteness for Extended Datalog with FC's is decidable. This problem has inspired a number of studies <ref> [26, 19, 32] </ref>, including the present work, but no solution has been found as of yet. <p> Independently, Convent [7] proposed a similar decision procedure for the case when all EDB-predicates are finite, but IDBs need not be range-restricted. 22 Sagiv and Vardi <ref> [32] </ref> developed a decision procedure for finiteness of monadic IDBs, i.e., IDBs where all recursive predicates are unary. To see how a combined procedure might work, we shall describe a slightly improved version of the algorithm from [16, 7, 17].
Reference: [33] <author> K. Sagonas, T. Swift, and D.S. Warren. </author> <title> XSB as an efficient deductive database engine. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 442-453, </pages> <address> New York, </address> <month> May </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: We prefer "finiteness" over "safety," as it is more descriptive and less overloaded. function-free rules have limited expressive power and advanced deductive database systems, such as LDL [25], Coral [27, 28], and XSB <ref> [33] </ref>, do not prohibit the use of function symbols.
Reference: [34] <author> E. Sciore. </author> <title> Improving database schemes by adding attributes. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 379-383, </pages> <address> New York, </address> <month> March </month> <year> 1983. </year> <note> ACM. </note>
Reference-contexts: We will often need to extend decompositions over p [ ~ X] that satisfy a set [ ~ X ] of PC's to decompositions over p that satisfy . In general, this cannot be done for every possible decomposition, which is consistent with the corresponding result about functional dependencies <ref> [34] </ref>. Fortunately, we only need to extend a very special class of decompositions, called simple decompositions. Let p be a relation for p and let F be a set of FC's on p.
Reference: [35] <author> J.C. Shepherdson. </author> <title> Negation in logic programming. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 19-88. </pages> <publisher> Morgan-Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: The following proposition shows that superfiniteness is also undecidable for Datalog with function symbols. Proposition 11.1 Superfiniteness of a query in Datalog with function symbols is recursively unsolvable. Proof: It is shown in <ref> [35, Theorem 13] </ref> that there exists a Horn IDB P such that the set S of all negative ground literals that are true in all Herbrand models of comp (P) (the Clark's completion of P [22]), is not recursively enumerable. <p> But then, since the Herbrand universe is recursively enumerable, this would be an algorithm for enumerating all negative ground atoms such that comp (P) j= :l, contrary to the aforesaid Theorem 13 in <ref> [35] </ref>. 2 Although many results exist regarding the various forms of finiteness, [16, 17, 20, 32, 36], several problems still remain open. The foremost among them is the question of whether query finiteness for Extended Datalog with FC's is decidable.
Reference: [36] <author> O. Shmueli. </author> <title> Decidability and expressiveness aspects of logic queries. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 237-249, </pages> <address> New York, </address> <month> March </month> <year> 1987. </year> <note> ACM. </note>
Reference-contexts: Finiteness is known to be undecidable for first-order queries without function symbols (but with negation) [11, 40]. 2 A sound (albeit incomplete) algorithm for testing finiteness for this class of queries was proposed in [41]. Finiteness is also undecidable for Horn queries with function symbols <ref> [36] </ref>. However, this problem is decidable for Horn queries without function symbols, even in the presence of infinite relations [16]. As finiteness is undecidable in the presence of function symbols, [26] proposed an elegant abstraction of this problem using function-free Horn queries with infinite relations and finiteness constraints (abbr., FC's). <p> Extended Datalog with FD's (as opposed to FC's). This follows from [32], since weak finiteness is the same as finiteness for non-recursive IDBs. 3. Datalog with function symbols [17]. On the other hand, Shmueli <ref> [36] </ref> has shown that finiteness is undecidable for (recursive) Datalog with function symbols. Sagiv and Vardi [32] proved that finiteness is undecidable for Extended Datalog with FD's, even for monadic IDBs. The following proposition shows that superfiniteness is also undecidable for Datalog with function symbols. <p> But then, since the Herbrand universe is recursively enumerable, this would be an algorithm for enumerating all negative ground atoms such that comp (P) j= :l, contrary to the aforesaid Theorem 13 in [35]. 2 Although many results exist regarding the various forms of finiteness, <ref> [16, 17, 20, 32, 36] </ref>, several problems still remain open. The foremost among them is the question of whether query finiteness for Extended Datalog with FC's is decidable.
Reference: [37] <author> J.D. Ullman. </author> <title> Principles of Database Systems. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1982. </year> <month> 46 </month>
Reference-contexts: The first step towards the theory of FC-inference was made in [26], where it was noted that finiteness constraints over a single relation have axiomatization similar to Armstrong's axioms for functional dependencies (abbr., FD's) <ref> [37] </ref>. Nevertheless, it was clear that this result had a long way to go before it could be used for Horn queries, as the latter involve multiple predicates that are intricately connected via logical rules. <p> Let ~ X be a sequence of attributes (where the same attribute may have multiple occurrences) of a predicate symbol p and let p be a relation instance for p. We shall use p [ ~ X ] to denote the projection of p on ~ X (see <ref> [37] </ref>). 3 Finiteness and Superfiniteness Informally, a given query is finite if it has a finite set of answers for all instances of the EDB that satisfy all integrity constraints supplied with the database. <p> Proposition 4.2 FC-rules are sound and complete for inferring FC's, i.e., F ` G if and only if F j= G, for any pair of sets of FC's. Proof: The proof follows the lines of the corresponding proof for functional dependencies in <ref> [37] </ref>. Soundness of the rules is an easy consequence of the definitions. For completeness, let us define the closure of X, denoted X + F , as fA j X &gt; A follows from F by the inference rulesg. <p> First, we claim that X &gt; Y follows by the FC-rules if and only if Y is a subset of X + F . The proof is identical to the proof of the corresponding fact for functional dependencies <ref> [37] </ref>. 8 X + F a a a :::::: a b 2 b 2 b 2 :::::: b 2 . . . . . . . . . <p> In the theory of FC's, F - simple relations play the role analogous to that of the 2-tuple relations in the theory of functional and multivalued dependencies (cf. <ref> [37] </ref>). So far, the properties of FC's were similar to those of functional dependencies|even the inference rules were the same. The next lemma (Claims 2 and 4) shows that FC's have certain properties that do not hold for FD's, even in the world of 2-tuple relations. 10 Lemma 7.4 1.
Reference: [38] <author> J.F. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> Volume 1. </volume> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1988. </year>
Reference-contexts: Section 13 concludes the paper. 2 Preliminaries For future reference, we shall briefly review the standard notions of logic programming and deductive databases. The reader is referred to <ref> [22, 38, 39] </ref> for more details. 3 In [32] this property is called "weak safety." 3 Terms, Rules, Databases A term is either a variable, or a function symbol applied to the number of terms appropriate for the arity of that symbol. <p> In particular, our queries do not contain constants and function symbols. Although this notion at first seems less general than the usual definition of queries <ref> [38] </ref>, the two are known to be essentially equivalent. The set of answers to the above query is the set of all facts for the query predicate in the least model of D. <p> In comparative studies of various kinds of databases, it has also become common to talk about "Datalog with function symbols," although this is somewhat of a misnomer, since the very term "Datalog" was introduced in [23] specifically to indicate the absence of function symbols. The reader is referred to <ref> [38, 39] </ref> for the introductory material on deductive databases. Most of this paper is concerned with Extended Datalog. Extended Datalog was introduced in [26] as an approximation of Datalog with function symbols 4 and has been extensively studied since then [32, 16, 4, 31, 30].
Reference: [39] <author> J.F. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> Volume 2. </volume> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year>
Reference-contexts: Section 13 concludes the paper. 2 Preliminaries For future reference, we shall briefly review the standard notions of logic programming and deductive databases. The reader is referred to <ref> [22, 38, 39] </ref> for more details. 3 In [32] this property is called "weak safety." 3 Terms, Rules, Databases A term is either a variable, or a function symbol applied to the number of terms appropriate for the arity of that symbol. <p> In comparative studies of various kinds of databases, it has also become common to talk about "Datalog with function symbols," although this is somewhat of a misnomer, since the very term "Datalog" was introduced in [23] specifically to indicate the absence of function symbols. The reader is referred to <ref> [38, 39] </ref> for the introductory material on deductive databases. Most of this paper is concerned with Extended Datalog. Extended Datalog was introduced in [26] as an approximation of Datalog with function symbols 4 and has been extensively studied since then [32, 16, 4, 31, 30].
Reference: [40] <author> M.Y. Vardi. </author> <title> The decision problem for database dependencies. </title> <journal> Information Processing Letters, </journal> <pages> pages 251-254, </pages> <month> October </month> <year> 1981. </year>
Reference-contexts: An important issue, therefore, is the design of algorithms that can capture various interesting subclasses of finite queries. A special case of this problem is the question of whether a database query is finite. Finiteness is known to be undecidable for first-order queries without function symbols (but with negation) <ref> [11, 40] </ref>. 2 A sound (albeit incomplete) algorithm for testing finiteness for this class of queries was proposed in [41]. Finiteness is also undecidable for Horn queries with function symbols [36]. However, this problem is decidable for Horn queries without function symbols, even in the presence of infinite relations [16].
Reference: [41] <author> C. Zaniolo. </author> <title> Safety and compilation of non-recursive horn clauses. </title> <booktitle> In First Intl. Workshop on Expert Database Systems, </booktitle> <pages> pages 63-73, </pages> <address> Kiawah Island, South Carolina, </address> <month> October </month> <year> 1984. </year> <month> 47 </month>
Reference-contexts: Finiteness is known to be undecidable for first-order queries without function symbols (but with negation) [11, 40]. 2 A sound (albeit incomplete) algorithm for testing finiteness for this class of queries was proposed in <ref> [41] </ref>. Finiteness is also undecidable for Horn queries with function symbols [36]. However, this problem is decidable for Horn queries without function symbols, even in the presence of infinite relations [16].
References-found: 41

