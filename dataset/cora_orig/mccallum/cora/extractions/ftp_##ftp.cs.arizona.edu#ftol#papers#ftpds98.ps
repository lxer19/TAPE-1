URL: ftp://ftp.cs.arizona.edu/ftol/papers/ftpds98.ps
Refering-URL: http://www.cs.arizona.edu/people/hiltunen/hiltunen.html
Root-URL: http://www.cs.arizona.edu
Title: Affordable Fault Tolerance through Adaptation  
Author: Ilwoo Chang Matti A. Hiltunen, and Richard D. Schlichting 
Address: Tucson, AZ 85712  
Affiliation: Department of Computer Science University of Arizona  
Abstract: Fault-tolerant programs are typically not only difficult to implement but also incur extra costs in terms of performance or resource consumption. Failures are typically relatively rare but the fault-tolerance overhead must be paid regardless if any failures occur during the program execution. This paper presents an approach that reduces the cost of fault-tolerance, namely, adaptations to a change in failure model. In particular, a program that assumes no failures (or only benign failures) is combined with a component that is responsible for detecting if failures occur and then switching to a fault-tolerant algorithm. Provided that the detection and adaptation mechanisms are not too expensive, this approach results in a program with smaller fault-tolerance overhead and thus a better performance than a traditional fault-tolerant program. Thus, the high cost of fault-tolerance is only paid when failures actually occur.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Arora, M. Gouda, and T. Herman. </author> <title> Composite routing protocols. </title> <booktitle> In Proceedings of the IEEE Symposium on Parallel and Distributed Processing, </booktitle> <month> Dec </month> <year> 1990. </year>
Reference-contexts: Note that adaptivity and self-stabilization can be used together to gain the benefits of both. For example, <ref> [1] </ref> presents an adaptive routing protocol that adapts between two self-stabilizing algorithms, while [11] proposes combining traditional fault-tolerance and self-stabilization to construct programs that tolerate both systemic and process failures. 6 Conclusions This paper has presented an approach for reducing the cost of fault tolerance using adaptation.
Reference: 2. <author> P. Bell and K. Jabbour. </author> <title> Review of point-to-point network routing algorithms. </title> <journal> IEEE Communications Magazine, </journal> <volume> 24(1) </volume> <pages> 34-38, </pages> <year> 1986. </year>
Reference-contexts: In some cases, such protocols change their behavior based on the execution environment (e.g., adaptive routing algorithms <ref> [2] </ref>) or their input (e.g., adaptive sorting algorithms [9]). In other cases, the adaptation is required because of some type of failure, such as the failure of a link or a switch in a computer network. There has also been some work specifically addressing adaptation to failures [10, 4, 14].
Reference: 3. <author> R. Bianchini, K. Goodwin, and D. Nydick. </author> <title> Practical application and implementation of distributed system-level diagnosis theory. </title> <booktitle> In Proceedings of the 20th Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 332-339, </pages> <month> Jun </month> <year> 1990. </year>
Reference-contexts: Thus, depending of the network topology, messages may be delivered much earlier than in the masking algorithm. Second, we describe the detection modules for each of the failure models. Note that, although related, the traditional membership, e.g., [15, 5, 19], and system diagnosis, e.g., <ref> [18, 3, 22] </ref>, protocols do not provide adequate detection mechanisms. For example, failure detection mechanisms such as exchanging alive messages are not adequate even for detecting omission failures since a processor may omit to send some application messages but still send all the required alive messages.
Reference: 4. <author> A. Bondavalli, F. Di Giandomenico, and J. Xu. </author> <title> A cost-effective and flexible scheme for software fault tolerance. </title> <journal> Journal of Computer Systems Science and Engineering, </journal> <volume> 8 </volume> <pages> 234-244, </pages> <year> 1993. </year>
Reference-contexts: In other cases, the adaptation is required because of some type of failure, such as the failure of a link or a switch in a computer network. There has also been some work specifically addressing adaptation to failures <ref> [10, 4, 14] </ref>. Furthermore, non-masking fault-tolerant programs can typically be viewed as adaptive programs in the sense that they adapt or react to failures. Despite this work, however, no-one to date has attempted to adapt to a change in failure model in the way done here.
Reference: 5. <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4 </volume> <pages> 175-187, </pages> <year> 1991. </year>
Reference-contexts: Thus, depending of the network topology, messages may be delivered much earlier than in the masking algorithm. Second, we describe the detection modules for each of the failure models. Note that, although related, the traditional membership, e.g., <ref> [15, 5, 19] </ref>, and system diagnosis, e.g., [18, 3, 22], protocols do not provide adequate detection mechanisms.
Reference: 6. <author> F. Cristian, H. Aghili, R. Strong, and D. Dolev. </author> <title> Atomic broadcast: From simple message diffusion to Byzantine agreement. </title> <booktitle> In Proceedings of the 15th Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 200-206, </pages> <address> Ann Arbor, MI, </address> <month> Jun </month> <year> 1985. </year>
Reference-contexts: more efficient solution would be to do a corrective action after each single failure and only switch into a more expensive algorithm when failures become more frequent. 3 An Adaptive Atomic Broadcast Protocol 3.1 Failure Masking Protocols As an example, we consider the problem of atomic broadcast as presented in <ref> [6] </ref>, and later in more detail in [7]. <p> Three atomic broadcast protocols are presented in <ref> [6] </ref>: one that tolerates omission failures, one that tolerates timing failures, and one that tolerates Byzantine failures detectable using authentication.
Reference: 7. <author> F. Cristian, H. Aghili, R. Strong, and D. Dolev. </author> <title> Atomic broadcast: From simple message diffusion to Byzantine agreement. </title> <journal> Information and Computation, </journal> <volume> 118(1) </volume> <pages> 158-179, </pages> <year> 1995. </year>
Reference-contexts: The basic idea is to use a simple efficient algorithm when no failures occur and only switch into a more expensive fault-tolerant algorithm if failures occur during execution. As an example, we apply the approach to a family of atomic broadcast protocols <ref> [7] </ref>. <p> a corrective action after each single failure and only switch into a more expensive algorithm when failures become more frequent. 3 An Adaptive Atomic Broadcast Protocol 3.1 Failure Masking Protocols As an example, we consider the problem of atomic broadcast as presented in [6], and later in more detail in <ref> [7] </ref>. <p> Thus, a system designer will have to decide for each task what failure model is to be tolerated and choose the corresponding detection module accordingly. Fig. 2. Basic structure of the adaptive broadcast protocol We make the same assumptions about the underlying system as <ref> [7] </ref>. In particular, we assume the following: 1. The system is composed of a network G of n processors connected by point-to-point links. <p> We assume that this notification is done by sending a special broadcast message using a masking algorithm. At the reception of such message, a processor will start sending any subsequent messages using the masking algorithms of <ref> [7] </ref>. This switching procedure is omitted from the following detection pseudo-code, but we assume it will be executed when a detection module detects and announces a failure. <p> Atomicity is guaranteed since all processors are included in every spanning tree and thus, if a (correct) processor sends a message, all (correct) processors will eventually receive it and deliver it. Order is guaranteed and implemented the same way as the masking algorithm in <ref> [7] </ref>. By scheduling the Delivery task s time units from the time T the message was sent, it is guaranteed that all message sent at (or before) time T will be received by every processor at time T + s . <p> For this algorithm, we use m = ffi + d m ffi + " similar to the omission failure masking algorithm in <ref> [7] </ref>. Note that for brevity, we only present the additions to the Basic algorithm and not the complete algorithm. <p> For the timing failure case, s is still the same (since the basic protocol assumes no failures) but m = (ffi + ") + dffi + " similar to the t in the timing failure masking protocol in <ref> [7] </ref>. <p> We have also demonstrated that if a failure occurs, it will be detected by the detection modules and the system will switch to use a masking protocol and again the atomicity, order, and termination properties will be guaranteed based on <ref> [7] </ref>. However, between the time the failure occurs and the switch is made to the masking protocol, the atomicity, order, and termination properties are not guaranteed for a period of time. We divide this time period into detection and adaptation periods.
Reference: 8. <author> E. W. Dijkstra. </author> <title> Self-stabilization in spite of distributed control. </title> <journal> Communications of the ACM, </journal> <volume> 17(11) </volume> <pages> 643-644, </pages> <month> Nov </month> <year> 1974. </year>
Reference-contexts: However, in our approach, if a failure is detected in the failure model that we are prepared to adapt to, the algorithm being executed is changed. Finally, our approach, as well as adaptive programming in general, resembles self-stabilization <ref> [8, 21] </ref>. A self-stabilizing distributed program is one that is guaranteed to reach a legitimate state regardless of its initial state. This guarantee also applies if the program is in an illegal state during execution, due to a transient failure for example.
Reference: 9. <author> V. Estivill-Castro and D. Woods. </author> <title> A survey of adaptive sorting algorithms. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(4) </volume> <pages> 441-476, </pages> <month> Dec </month> <year> 1992. </year>
Reference-contexts: In some cases, such protocols change their behavior based on the execution environment (e.g., adaptive routing algorithms [2]) or their input (e.g., adaptive sorting algorithms <ref> [9] </ref>). In other cases, the adaptation is required because of some type of failure, such as the failure of a link or a switch in a computer network. There has also been some work specifically addressing adaptation to failures [10, 4, 14].
Reference: 10. <author> J. Goldberg, I. Greenberg, and T. Lawrence. </author> <title> Adaptive fault tolerance. </title> <booktitle> In Proceedings of the IEEE Workshop on Advances in Parallel and Distributed Systems, </booktitle> <pages> pages 127-132, </pages> <address> Princeton, NJ, </address> <month> Oct </month> <year> 1993. </year>
Reference-contexts: In other cases, the adaptation is required because of some type of failure, such as the failure of a link or a switch in a computer network. There has also been some work specifically addressing adaptation to failures <ref> [10, 4, 14] </ref>. Furthermore, non-masking fault-tolerant programs can typically be viewed as adaptive programs in the sense that they adapt or react to failures. Despite this work, however, no-one to date has attempted to adapt to a change in failure model in the way done here.
Reference: 11. <author> A. Gopal and K. Perry. </author> <title> Unifying self-stabilization and fault-tolerance. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 195-206, </pages> <year> 1993. </year>
Reference-contexts: Note that adaptivity and self-stabilization can be used together to gain the benefits of both. For example, [1] presents an adaptive routing protocol that adapts between two self-stabilizing algorithms, while <ref> [11] </ref> proposes combining traditional fault-tolerance and self-stabilization to construct programs that tolerate both systemic and process failures. 6 Conclusions This paper has presented an approach for reducing the cost of fault tolerance using adaptation.
Reference: 12. <author> M. Gouda and T. Herman. </author> <title> Adaptive programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-17:911-921, </volume> <year> 1991. </year>
Reference-contexts: Furthermore, an adaptive program actually detects that a change has occurred whereas traditional self-stabilizing algorithms guarantee convergence to a legitimate state without first detecting the existence of an illegal state. The relationship between adaptive programming and self-stabilization is explored in more detail in <ref> [12] </ref>, which demonstrates that at least a form of adaptive programming can be considered a generalization of self-stabilization.
Reference: 13. <author> M. Hiltunen, X. Han, and R. Schlichting. </author> <booktitle> Real-time issues in Cactus. In Proceedings of the IEEE Workshop on Middleware for Distributed Real-Time Systems and Services, </booktitle> <pages> pages 214-221, </pages> <address> San Francisco, CA, </address> <month> Dec </month> <year> 1997. </year>
Reference-contexts: Future work will include implementing and testing the protocols presented in this paper using the Cactus system <ref> [20, 13] </ref>, as well as applying the approach to other fault-tolerant distributed algorithms.
Reference: 14. <author> M. Hiltunen and R. Schlichting. </author> <title> Adaptive distributed and fault-tolerant systems. </title> <journal> Computer Systems Science and Engineering, </journal> <volume> 11(5) </volume> <pages> 125-133, </pages> <month> Sep </month> <year> 1996. </year>
Reference-contexts: In other cases, the adaptation is required because of some type of failure, such as the failure of a link or a switch in a computer network. There has also been some work specifically addressing adaptation to failures <ref> [10, 4, 14] </ref>. Furthermore, non-masking fault-tolerant programs can typically be viewed as adaptive programs in the sense that they adapt or react to failures. Despite this work, however, no-one to date has attempted to adapt to a change in failure model in the way done here.
Reference: 15. <author> H. Kopetz, G. Grunsteidl, and J. Reisinger. </author> <title> Fault-tolerant membership service in a synchronous distributed real-time system. </title> <editor> In A. Avizienis and J. Laprie, editors, </editor> <booktitle> Dependable Computing for Critical Applications, </booktitle> <pages> pages 411-429. </pages> <publisher> Springer-Verlag, Wien, </publisher> <year> 1991. </year>
Reference-contexts: Thus, depending of the network topology, messages may be delivered much earlier than in the masking algorithm. Second, we describe the detection modules for each of the failure models. Note that, although related, the traditional membership, e.g., <ref> [15, 5, 19] </ref>, and system diagnosis, e.g., [18, 3, 22], protocols do not provide adequate detection mechanisms.
Reference: 16. <author> L. Lamport, R. Shostak, and P. M. </author> <title> The Byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> Jul </month> <year> 1982. </year>
Reference-contexts: However, fault tolerance can be expensive, with the cost depending on what types of faults are to be tolerated. Typically, the type of faults to be tolerated is expressed in terms of failure models that range from relatively benign crash or omission failures to arbitrary (or Byzantine <ref> [16] </ref>) failures. Note that the cost is determined not only by the failure model, but in many cases also by the number or frequency of the failures expected to occur. For example, a simple replication scheme intended to tolerate n crash failures requires n + 1 replicas.
Reference: 17. <author> L. Peterson, N. Buchholz, and R. Schlichting. </author> <title> Preserving and using context information in interprocess communication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(3) </volume> <pages> 217-246, </pages> <month> Aug </month> <year> 1989. </year>
Reference-contexts: However, it would be possible to detect failures without explicit detection messages, namely, by encoding the necessary detection information in the application messages. In particular, we can apply the idea of a context graph introduced in the Psync system <ref> [17] </ref>. A context graph is a graph where nodes are messages and edges are causal dependencies between messages. In particular, if a processor sends message m 2 after it has delivered message m 1 , there will be an edge from m 2 to m 1 .
Reference: 18. <author> F. Preparata, G. Metze, and R. Chien. </author> <title> On the connection assignment problem of diagnosable systems. </title> <journal> IEEE Transactions on Electronic Computer, </journal> <volume> EC-16(6):848-854, </volume> <month> Dec </month> <year> 1967. </year>
Reference-contexts: Thus, depending of the network topology, messages may be delivered much earlier than in the masking algorithm. Second, we describe the detection modules for each of the failure models. Note that, although related, the traditional membership, e.g., [15, 5, 19], and system diagnosis, e.g., <ref> [18, 3, 22] </ref>, protocols do not provide adequate detection mechanisms. For example, failure detection mechanisms such as exchanging alive messages are not adequate even for detecting omission failures since a processor may omit to send some application messages but still send all the required alive messages.
Reference: 19. <author> R. Rajkumar, S. Fakhouri, and F. Jahanian. </author> <title> Processor group membership protocols: Specification, </title> <booktitle> design, and implementation. In Proceedings of the 12th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <address> Princeton, NJ, </address> <month> Oct </month> <year> 1993. </year>
Reference-contexts: Thus, depending of the network topology, messages may be delivered much earlier than in the masking algorithm. Second, we describe the detection modules for each of the failure models. Note that, although related, the traditional membership, e.g., <ref> [15, 5, 19] </ref>, and system diagnosis, e.g., [18, 3, 22], protocols do not provide adequate detection mechanisms.
Reference: 20. <author> R. Schlichting and M. Hiltunen. </author> <title> The Cactus project. </title> <address> http://www.cs.arizona.edu/cactus/. </address>
Reference-contexts: Future work will include implementing and testing the protocols presented in this paper using the Cactus system <ref> [20, 13] </ref>, as well as applying the approach to other fault-tolerant distributed algorithms.
Reference: 21. <author> M. Schneider. </author> <title> Self-stabilization. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(1) </volume> <pages> 45-67, </pages> <month> Mar </month> <year> 1993. </year>
Reference-contexts: However, in our approach, if a failure is detected in the failure model that we are prepared to adapt to, the algorithm being executed is changed. Finally, our approach, as well as adaptive programming in general, resembles self-stabilization <ref> [8, 21] </ref>. A self-stabilizing distributed program is one that is guaranteed to reach a legitimate state regardless of its initial state. This guarantee also applies if the program is in an illegal state during execution, due to a transient failure for example.
Reference: 22. <author> C. Walter, M. Hugue, and N. Suri. </author> <title> Continual on-line diagnosis of hybrid faults. </title> <editor> In F. Cristian, G. Le Lann, and T. Lunt, editors, </editor> <booktitle> Dependable Computing for Critical Applications 4, </booktitle> <pages> pages 233-249. </pages> <publisher> Springer-Verlag, Wien, </publisher> <year> 1995. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Thus, depending of the network topology, messages may be delivered much earlier than in the masking algorithm. Second, we describe the detection modules for each of the failure models. Note that, although related, the traditional membership, e.g., [15, 5, 19], and system diagnosis, e.g., <ref> [18, 3, 22] </ref>, protocols do not provide adequate detection mechanisms. For example, failure detection mechanisms such as exchanging alive messages are not adequate even for detecting omission failures since a processor may omit to send some application messages but still send all the required alive messages.
References-found: 22

