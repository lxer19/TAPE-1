URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1997/TR12.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Email: e-mail: neelam@cis.ohio-state.edu  
Title: Refining Interactions in a Distributed System (Extended Abstract)  
Author: Neelam Soundarajan 
Address: Columbus, OH 43210 USA  
Affiliation: Computer and Information Science The Ohio State University  
Abstract: We identify a new type of refinement that we call interaction refinement that is of great value in designing distributed systems. An interaction refinement step is one in which a system designer decides to implement a given `high-level' interaction as a particular sequence of `low-level' interactions. For example a particular high-level interaction may be specified as `identify-client' involving a `client process' and a `server process'. The designer may decide to implement this interaction as a series of low-level interactions between the two processes, with the client process first sending to the server process an id, followed by a password, and perhaps allow the client several attempts at getting the password right, etc. Here the designer is not refining the internal structure of either the client process or the server process; rather she is deciding to implement the `identify-client' interaction between the two processes in terms of a sequence of low-level communications between them. By contrast, other types of refinment that are normally considered are concerned with refining the internal structure of one or more of the processes, the interactions between the processes being taken as a given. We motivate the idea of interaction refinement with simple and natural examples, present a precise definition of the concept, and develop a preliminary formalism that can be used to establish correctness of systems developed using interaction refinement. We also compare our work with previous work which allow one to deal with restricted kinds of interaction refinement. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> K Apt, N Francez, W deRoever, </author> <title> A proof system for CSP, </title> <journal> ACM TOPLAS, </journal> <year> 1980. </year>
Reference-contexts: CR is much harder to use than SR which is just another way of saying concurrent programs are much harder to design than sequential programs. Not surprisingly, the formalisms for establishing that these programs do exhibit the behavior we desire, such as those of <ref> [7, 1, 6, 8] </ref> are much more involved than the earlier formalisms for dealing with programs developed using only SR. The third kind of refinement, and the focus of this paper, is Interaction refinement or IR. We believe that IR plays a critical role in the design of distributed systems.
Reference: 2. <author> R Buhr, R Casselman, </author> <title> Use case maps for OO systems, </title> <publisher> Prentice-Hall, </publisher> <year> 1995. </year>
Reference-contexts: At a high level, this would require a sequence of three actions: Establish a connection between M 1 and M 2 , send the document from M 1 5 This example is inspired by Buhr and Casselman's book <ref> [2] </ref> on `use-cases' for dealing with object-oriented systems. Use-cases, since they record the sequence of method calls to various objects in an OO system, are similar to 6 to M 2 , and finally break the connection between M 1 and M 2 . <p> Thus IR and the other two kinds of refinement are really complementary and are all needed when designing a complete system. traces. The main point of <ref> [2] </ref> is to develop pictorial use-case-maps that can be used in an informal manner to understand the behavior of OO systems.
Reference: 3. <author> KM Chandy, J Misra, </author> <title> Parallel program design, </title> <publisher> Addison-Wesley. </publisher>
Reference-contexts: They go through a series of design steps to arrive at their final router, and several of these steps are interaction refinements; in particular these steps introduce additional communications in the system. Creveuil and Roman formally establish using the approach of <ref> [3] </ref>, that their router meets its specifications.
Reference: 4. <author> C Creveuil, </author> <title> GC Roman, Formal specification and design of a message router, </title> <journal> ACM TOSEM, </journal> <volume> vol. 3, </volume> <pages> pp. 271-308, </pages> <year> 1994. </year>
Reference-contexts: Rather we try to refine its internal structure, so that it will exhibit the specified external communication behavior. 3 of distributed systems. We also compare our work with earlier work <ref> [4, 5] </ref> that allows us to deal with certain restricted kinds of interaction refinements. 2 Specifying and Verifying Interaction Refinements We will use a trace-based approach to specify processes. <p> That is what we have tried to do. Interestingly, there have been some attempts to establish the correctness of systems that have clearly used interaction refinement without depending on a formalism that allows for this. For instance, Creveuil and Roman <ref> [4] </ref> tackle the problem of verifying the correctness of a message router. They go through a series of design steps to arrive at their final router, and several of these steps are interaction refinements; in particular these steps introduce additional communications in the system.
Reference: 5. <author> N Francez, </author> <title> I Forman, Interacting processes, </title> <publisher> Addison-Wesley. </publisher>
Reference-contexts: Rather we try to refine its internal structure, so that it will exhibit the specified external communication behavior. 3 of distributed systems. We also compare our work with earlier work <ref> [4, 5] </ref> that allows us to deal with certain restricted kinds of interaction refinements. 2 Specifying and Verifying Interaction Refinements We will use a trace-based approach to specify processes. <p> Before concluding, we should mention also the work of Francez and Forman <ref> [5] </ref> on Interacting Processes. They generalize the notion of communication between two processes to a multi-party interaction. Their language notation allows us to define a team which is a kind of template for a particular kind of multi-party interaction.
Reference: 6. <author> J Misra, KM Chandy, </author> <title> Proofs of networks of processes, </title> <journal> IEEE Trans. on Software Eng., </journal> <year> 1981. </year>
Reference-contexts: CR is much harder to use than SR which is just another way of saying concurrent programs are much harder to design than sequential programs. Not surprisingly, the formalisms for establishing that these programs do exhibit the behavior we desire, such as those of <ref> [7, 1, 6, 8] </ref> are much more involved than the earlier formalisms for dealing with programs developed using only SR. The third kind of refinement, and the focus of this paper, is Interaction refinement or IR. We believe that IR plays a critical role in the design of distributed systems.
Reference: 7. <author> S Owicki, D Gries, </author> <title> Verifying properties of parallel processes, </title> <journal> CACM, </journal> <year> 1976. </year>
Reference-contexts: CR is much harder to use than SR which is just another way of saying concurrent programs are much harder to design than sequential programs. Not surprisingly, the formalisms for establishing that these programs do exhibit the behavior we desire, such as those of <ref> [7, 1, 6, 8] </ref> are much more involved than the earlier formalisms for dealing with programs developed using only SR. The third kind of refinement, and the focus of this paper, is Interaction refinement or IR. We believe that IR plays a critical role in the design of distributed systems.
Reference: 8. <author> N Soundarajan, </author> <title> Axiomatic semantics of communicating sequential processes, </title> <journal> ACM TOPLAS, </journal> <year> 1984. </year> <month> 9 </month>
Reference-contexts: CR is much harder to use than SR which is just another way of saying concurrent programs are much harder to design than sequential programs. Not surprisingly, the formalisms for establishing that these programs do exhibit the behavior we desire, such as those of <ref> [7, 1, 6, 8] </ref> are much more involved than the earlier formalisms for dealing with programs developed using only SR. The third kind of refinement, and the focus of this paper, is Interaction refinement or IR. We believe that IR plays a critical role in the design of distributed systems.
References-found: 8

