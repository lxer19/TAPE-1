URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/project/vit/ftp/ProgCodif.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/project/vit/www/paper_abstracts/ProgCodif.html
Root-URL: http://www.cs.cmu.edu
Title: Formulations and Formalisms in Software Architecture  
Author: Mary Shaw and David Garlan 
Address: Pittsburgh, PA 15213, USA  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: Software architecture is the level of software design that addresses the overall structure and properties of software systems. It provides a focus for certain aspects of design and development that are not appropriately addressed within the constituent modules. Architectural design depends heavily on accurate specifications of subsystems and their interactions. These specifications must cover a wide variety of properties, so the specification notations and associated methods must be selected or developed to match the properties of interest. Unfortunately, the available formal methods are only a partial match for architectural needs, which entail description of structure, packaging, environmental assumptions, representation, and performance as well as functionality. A prerequisite for devising or selecting a formal method is sound understanding of what needs to be formalized. For software architecture, much of this understanding is arising through progressive codification, which begins with real-world examples and creates progressively more precise models that eventually support formalization. This paper explores the progressive codification of software architecture: the relation between emerging models and the selection, development, and use of formal systems.
Abstract-found: 1
Intro-found: 1
Reference: [AAG93] <author> Gregory Abowd, Robert Allen, and David Garlan. </author> <title> Using style to understand descriptions of software architecture. </title> <booktitle> In Proceedings of SIGSOFT'93: Foundations of Software Engineering, Software Engineering Notes 18(5), </booktitle> <pages> pages 9-20. </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1993. </year>
Reference-contexts: For example, Allen and Gar-lan [AG92] provide a formalization of a pipe-filter architectural style, while [GN91] develops a formalization of implicit-invocation architectural style. Both of these use the Z specification language [Spi89] Generalizing from these examples, Abowd, Allen, and Garlan <ref> [AAG93] </ref> describe a denotational framework for developing formal models of architectural style (also in Z). The idea of the framework is that each style can be defined using three functions that indicate how the syntactic, structural aspects of the style are mapped into semantic entities.
Reference: [AG92] <author> Robert Allen and David Garlan. </author> <title> A formal approach to software architectures. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Proceedings of IFIP'92. </booktitle> <publisher> Elsevier Science Publishers B.V., </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: For example, are cycles allowed? Must a pipe have a single reader and a single writer? Can filters share global state? In an attempt to provide more complete semantics for some specific styles a number of styles have been completely formalized. For example, Allen and Gar-lan <ref> [AG92] </ref> provide a formalization of a pipe-filter architectural style, while [GN91] develops a formalization of implicit-invocation architectural style. Both of these use the Z specification language [Spi89] Generalizing from these examples, Abowd, Allen, and Garlan [AAG93] describe a denotational framework for developing formal models of architectural style (also in Z).
Reference: [AG94] <author> Robert Allen and David Garlan. </author> <title> Formalizing architectural connection. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 71-80, </pages> <address> Sorrento, Italy, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: They often provide a graphical interface so that developers can express architectures using diagrams of the kind that have proven useful. Current ADLs include Aesop [GAO94], ArTek [T + 94], Dar-win [MK95], Rapide [LAK + 95], UniCon [SDK + 95], and Wright <ref> [AG94] </ref>. While all of these ADLs are concerned with architectural structure, they differ in their level of genericity. There are three basic levels. Some are primarily concerned with architectural instances. <p> When considering architectural design broadly, a number of formal questions arise: What does it mean to have a consistent or a complete architectural description? What is the formal nature of architectural connection? The Wright specification language represents first steps toward answering these kinds of questions <ref> [AG94] </ref>. In this language, connectors are viewed as first class entities, defined as a set of protocols. Similarly, interfaces to components are described in terms of the protocols of interaction with their environment.
Reference: [BB92] <author> G. Berry and G. Boudol. </author> <title> The chemical abstract machine. </title> <journal> Theoretical Computer Science, </journal> (96):217-248, 1992. 
Reference-contexts: These ADLs, and their supporting tools, capture relevant information, repackage it into the formats required by real-time analysis tools, which are then invoked to perform the analyses. 4. Wolf and Inverardi have explored the use of Chemical Abstract Machine notation <ref> [BB92] </ref> for modelling architectural designs [IW95]. This model also deals well with dynamic behavior of a system, essentially providing a kind of structural rewrite system. Capture of Architectural Styles. When people refer to a system as being in a pipe-filter style it may not be clear precisely what they mean.
Reference: [Boo86] <author> Grady Booch. </author> <title> Object-oriented development. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(2):211-221, </volume> <month> February </month> <year> 1986. </year>
Reference-contexts: A few of the patterns, or styles, (e.g., object organizations <ref> [Boo86] </ref> and blackboards [Nii86]) have been carefully refined, but others are still used quite informally, even unconsciously. Nevertheless, the architectural patterns are widely recognized.
Reference: [BV93] <author> Pam Binns and Steve Vestal. </author> <title> Formal real-time architecture specification and analysis. </title> <booktitle> In Tenth IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <address> New York, NY, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: A number of such "domain-specific" software architectures have been formalized. One of the more prominent is in the avionics domain <ref> [BV93] </ref>. Here a language, called Meta-H, was developed to capture the architectural commonality among the applications, and to provide high-level syntactic support for instantiating the framework for a specific product.
Reference: [CBKA95] <author> Paul Clements, Len Bass, Rick Kazman, and Gregory Abowd. </author> <title> Predicting software quality by architecture-level evaluation. </title> <booktitle> In Proceedings of the Fifth International Conference on Software Quality, </booktitle> <address> Austin, Texas, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Extra-functional Properties. In addition to functionality and packaging, archi-tectural specifications must be capable of expressing extra-functional properties related to performance, capacity, environmental assumptions, and global properties such as reliability and security <ref> [Sha85, MCN92, CBKA95] </ref>. Many of these additional properties are qualitative, so they may require different kinds of support from more formal specifications.
Reference: [Com95] <author> DeLorme Mapping Company. </author> <note> WWW page describing MapExpert product, 1995. URL: http://www.delorme.com/catalog/mex.htm. </note>
Reference-contexts: services space requirements conformance to an interface standard space variability conformance to implementation standard adaptability intended profile of operation usage precision and accuracy minimum hardware configuration security need to access specialized hardware For example, this product description specifies the interface between a software product and the operating system/hardware it requires <ref> [Com95] </ref>. 1. IBM or 100% IBM-compatible microcomputer with Intel 80386 microprocessor or higher or 100%-compatible processor. 2. Minimum 4 MB RAM. 3. 3 MB of available space on a hard disk. 4. ISO 9660-compatible CD-ROM drive with 640+ MB read capacity and Microsoft CD-ROM extensions. 5.
Reference: [DAR90] <institution> Proceedings of the Workshop on Domain-Specific Software Architectures, </institution> <address> Hidden Vallen, PA, </address> <month> July </month> <year> 1990. </year> <institution> Software Engineering Institute. </institution>
Reference-contexts: The second category is addressing codification of architectural expertise [GHJV94, GS93]. Work in this area is concerned with cataloging and rationalizing the variety of architectural principles and patterns that engineers have developed through software practice. The third category is addressing frameworks for specific domains <ref> [DAR90, Tra94] </ref>. This work typically results in an architectural framework for a specific class of software such as avionics control systems, mobile robotics, or user interfaces. When successful, such frameworks can be easily instantiated to produce new products in the domain. The fourth category addresses formal underpinnings for architecture.
Reference: [FO85] <author> Marek Fridrich and William Older. </author> <title> Helix: The architecture of the XMS distributed file system. </title> <journal> IEEE Software, </journal> <volume> 2(3) </volume> <pages> 21-29, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: The architecture encourages a client-server model for the structuring of applications." <ref> [FO85] </ref> - "We have chosen a distributed, object-oriented approach to managing informa tion." [Lin87] - "The easiest way to make the canonical sequential compiler into a concurrent compiler is to pipeline the execution of the compiler phases over a number of processors. : : : A more effective way [is to]
Reference: [GAO94] <author> David Garlan, Robert Allen, and John Ockerbloom. </author> <title> Exploiting style in architectural design environments. </title> <booktitle> In Proceedings of SIGSOFT'94: The Second ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 179-185. </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1994. </year>
Reference-contexts: They often provide a graphical interface so that developers can express architectures using diagrams of the kind that have proven useful. Current ADLs include Aesop <ref> [GAO94] </ref>, ArTek [T + 94], Dar-win [MK95], Rapide [LAK + 95], UniCon [SDK + 95], and Wright [AG94]. While all of these ADLs are concerned with architectural structure, they differ in their level of genericity. There are three basic levels. Some are primarily concerned with architectural instances. <p> For example, it can guarantee that processes only talk over channels of the correct type, even though the number and connectivity of those channels may change during runtime. 3. UniCon [SDK + 95] and Aesop <ref> [GAO94] </ref> support methods for real-time analysis| RMA and EDF, respectively. These ADLs, and their supporting tools, capture relevant information, repackage it into the formats required by real-time analysis tools, which are then invoked to perform the analyses. 4.
Reference: [GAO95] <author> David Garlan, Robert Allen, and John Ockerbloom. </author> <title> Architectural mismatch, or, why it's hard to build systems out of existing parts. </title> <booktitle> In Proceedings of the 17th International Conference on Software Engineering, </booktitle> <address> Seattle, Washington, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: Strict adherence to a single style throughout a system is often impractical, so articulation between styles will be required. Furthermore, components with the desired functionality will often be packaged in different ways. Therefore, we need to find ways to handle packaging incompatibility <ref> [GAO95] </ref>. Heterogeneity arises from multiple packaging standards, from legacy systems that will not or cannot be rewritten, and from differences in usage within a single standard. At present, many ad hoc techniques are used to compensate for the incompatibility of parts. <p> Specifications are incomplete and evolving. Moreover, gathering specification information incurs costs; even for common properties, completeness may be impractical, and the cost may be prohibitive for uncommon properties. Even worse, interesting properties may emerge after a component is released (e.g., "upward compatible with Fenestre version 4.5") <ref> [GAO95] </ref>. Notably, we often make progress with only minimal information. Sometime we can take advantage of new information when it comes along. A promising research opportunity is understanding how to make architectural specifications partial, incremental, and evolving.
Reference: [Gar95] <editor> David Garlan, editor. </editor> <booktitle> Proceedings of the First International Workshop on Architectures for Software Systems, </booktitle> <address> Seattle, WA, </address> <month> April </month> <year> 1995. </year> <note> Published as CMU Technical Report CMU-CS-95-151, </note> <month> April </month> <year> 1995. </year>
Reference-contexts: Five general types of models appear with some regularity: structural, framework, dynamic, process, and functional. Of these, structural and dynamic models are most common. The representative examples here were discussed at the First International Workshop on Architectures for Software Systems <ref> [Gar95] </ref> and the Dagstuhl Workshop on Software Architecture [GPT95]. Structural Models. The most common model views architecture as primarily structural. This family of models shares the view that architecture is based on components, connectors, and "other stuff". The "other stuff" in various ways reaches beyond structure to capture important semantics.
Reference: [GHJV94] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: As detailed later, these languages are aimed at giving practitioners better ways of writing down architectures so that they can be communicated to others, and in many cases analyzed with tools. The second category is addressing codification of architectural expertise <ref> [GHJV94, GS93] </ref>. Work in this area is concerned with cataloging and rationalizing the variety of architectural principles and patterns that engineers have developed through software practice. The third category is addressing frameworks for specific domains [DAR90, Tra94].
Reference: [GN91] <author> David Garlan and David Notkin. </author> <title> Formalizing design spaces: Implicit invocation mechanisms. </title> <booktitle> In VDM'91: Formal Software Development Methods, </booktitle> <pages> pages 31-44, </pages> <address> Noordwijkerhout, The Netherlands, </address> <month> October </month> <year> 1991. </year> <note> Springer-Verlag, LNCS 551. </note>
Reference-contexts: For example, Allen and Gar-lan [AG92] provide a formalization of a pipe-filter architectural style, while <ref> [GN91] </ref> develops a formalization of implicit-invocation architectural style. Both of these use the Z specification language [Spi89] Generalizing from these examples, Abowd, Allen, and Garlan [AAG93] describe a denotational framework for developing formal models of architectural style (also in Z).
Reference: [GPT95] <author> David Garlan, Frances Newberry Paulisch, and Walter F. Tichy, </author> <title> editors. </title> <booktitle> Summary of the Dagstuhl Workshop on Software Architecture, </booktitle> <month> February </month> <year> 1995. </year> <booktitle> Reprinted in ACM Software Engineering Notes, </booktitle> <pages> pages 63-83, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Five general types of models appear with some regularity: structural, framework, dynamic, process, and functional. Of these, structural and dynamic models are most common. The representative examples here were discussed at the First International Workshop on Architectures for Software Systems [Gar95] and the Dagstuhl Workshop on Software Architecture <ref> [GPT95] </ref>. Structural Models. The most common model views architecture as primarily structural. This family of models shares the view that architecture is based on components, connectors, and "other stuff". The "other stuff" in various ways reaches beyond structure to capture important semantics.
Reference: [GS93] <author> David Garlan and Mary Shaw. </author> <title> An introduction to software architecture. </title> <editor> In V. Ambriola and G. Tortora, editors, </editor> <booktitle> Advances in Software Engineering and Knowledge Engineering, </booktitle> <pages> pages 1-39, </pages> <address> Singapore, </address> <year> 1993. </year> <title> World Scientific Publishing Company. </title> <note> Also appears as SCS and SEI technical reports: CMU-CS-94-166, CMU/SEI-94-TR-21, ESC-TR-94-021. </note>
Reference-contexts: This level of system design has come to be known as software architecture <ref> [GS93, PW92] </ref>. In an architectural design, systems are typically viewed as compositions of module-scale, interacting components. Components are such things as clients and servers, databases, filters, and layers in a hierarchical system. <p> As detailed later, these languages are aimed at giving practitioners better ways of writing down architectures so that they can be communicated to others, and in many cases analyzed with tools. The second category is addressing codification of architectural expertise <ref> [GHJV94, GS93] </ref>. Work in this area is concerned with cataloging and rationalizing the variety of architectural principles and patterns that engineers have developed through software practice. The third category is addressing frameworks for specific domains [DAR90, Tra94]. <p> It consists of physical and data layers, a network layer, and transport, session, and presentation layers." [Pau85] We studied sets of such descriptions and found a number of abstractions that govern the overall organization of the components and their interactions <ref> [GS93] </ref>. A few of the patterns, or styles, (e.g., object organizations [Boo86] and blackboards [Nii86]) have been carefully refined, but others are still used quite informally, even unconsciously. Nevertheless, the architectural patterns are widely recognized.
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: Given this formal basis, it is possible to ask whether a given connector can be legally associated with a given component interface. This amounts to a test for protocol compatibility. Wright protocols are defined as CSP processes <ref> [Hoa85] </ref>, and protocol compatibility can be reduced to a check of process refinement. The result of such a check is a strong guarantee that components interacting over a given connector will never deadlock. 4.2 What's Missing? Standing back from the specific formalisms currently under development, two salient facts stand out.
Reference: [IW95] <author> Paola Inverardi and Alex Wolf. </author> <title> Formal specification and analysis of software architectures using the chemical, abstract machine model. </title> <journal> IEEE Transactions on Software Engineering, Special Issue on Software Architecture, </journal> <volume> 21(4) </volume> <pages> 373-386, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: These ADLs, and their supporting tools, capture relevant information, repackage it into the formats required by real-time analysis tools, which are then invoked to perform the analyses. 4. Wolf and Inverardi have explored the use of Chemical Abstract Machine notation [BB92] for modelling architectural designs <ref> [IW95] </ref>. This model also deals well with dynamic behavior of a system, essentially providing a kind of structural rewrite system. Capture of Architectural Styles. When people refer to a system as being in a pipe-filter style it may not be clear precisely what they mean.
Reference: [Jac94] <author> Michael Jackson. </author> <title> Problems, methods and specialisation (a contribution to the special issue on software engineering in the year 2001). </title> <journal> IEE Software Engineering Journal, </journal> <month> November </month> <year> 1994. </year> <note> A shortened version of this paper also appears in IEEE Software, </note> <month> November </month> <year> 1994, </year> <month> 11(6). </month>
Reference-contexts: A promising research opportunity is understanding how to make architectural specifications partial, incremental, and evolving. This entails adding new properties, declaring what properties are required for specific kinds of analysis, checking consistency, and propagating new information to improve old analyses. Work on using partial specifications will help <ref> [Jac94, Per87] </ref>, as will a fresh approach that views them as evolving entities rather than static documents. 5.3 Extra-functional Properties We have already noted the failure of most existing formalisms to handle properties that go beyond the computational behavior of the system.
Reference: [LAK + 95] <author> David C Luckham, Lary M. Augustin, John J. Kenney, James Veera, Doug Bryan, and Walter Mann. </author> <title> Specification and analysis of system architecture using Rapide. </title> <journal> IEEE Transactions on Software Engineering, Special Issue on Software Architecture, </journal> <volume> 21(4) </volume> <pages> 336-355, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: They often provide a graphical interface so that developers can express architectures using diagrams of the kind that have proven useful. Current ADLs include Aesop [GAO94], ArTek [T + 94], Dar-win [MK95], Rapide <ref> [LAK + 95] </ref>, UniCon [SDK + 95], and Wright [AG94]. While all of these ADLs are concerned with architectural structure, they differ in their level of genericity. There are three basic levels. Some are primarily concerned with architectural instances. <p> Several such models have been proposed. These differ substantially depending on the kind of model they consider. To take four representative examples: 1. Rapide models the behavior of a system in terms of partially ordered sets of events <ref> [LAK + 95] </ref>. Components are assigned specifications that allow the system's event behavior to be simulated and then analyzed. Typical kinds of analyses reveal whether there is a causal dependency between certain kinds of computations.
Reference: [Lan90] <author> Thomas G. Lane. </author> <title> Studying software architecture through design spaces and rules. </title> <type> Technical Report CMU/SEI-90-TR-18 ESD-90-TR-219, </type> <institution> Carnegie Mellon University, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: Failure to do so leads to mismatches between user expectations and specification power. Architecture description languages provide a notation for capturing system descriptions. Several have associated tools that will construct instances from modules of some programming language. At least one technique for design selection has been developed <ref> [Lan90] </ref>. Support for other levels of aspiration is spotty. No matter how badly we would like to leap directly to fully formal architectural specifications that support analysis and automation, history says we must first make our informal understanding explicit, then gradually make it more rigorous as it matures.
Reference: [Lin87] <author> Mark A. Linton. </author> <title> Distributed management of a software database. </title> <journal> IEEE Software, </journal> <volume> 4(6) </volume> <pages> 70-76, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: The architecture encourages a client-server model for the structuring of applications." [FO85] - "We have chosen a distributed, object-oriented approach to managing informa tion." <ref> [Lin87] </ref> - "The easiest way to make the canonical sequential compiler into a concurrent compiler is to pipeline the execution of the compiler phases over a number of processors. : : : A more effective way [is to] split the source code into many segments, which are concurrently processed through the
Reference: [MCN92] <author> John Mylopoulos, Lawrence Chung, and Brian Nixon. </author> <title> Representing and using nonfunctional requirements: A process-oriented approach. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(6), </volume> <month> June </month> <year> 1992. </year>
Reference-contexts: Extra-functional Properties. In addition to functionality and packaging, archi-tectural specifications must be capable of expressing extra-functional properties related to performance, capacity, environmental assumptions, and global properties such as reliability and security <ref> [Sha85, MCN92, CBKA95] </ref>. Many of these additional properties are qualitative, so they may require different kinds of support from more formal specifications.
Reference: [MK95] <author> Jeff Magee and Jeff Kramer. </author> <title> Modelling distributed software architectures. </title> <booktitle> In Proceedings of the First International Workshop on Architectures for Software Systems. </booktitle> <institution> Reissued as Carnegie Mellon University Technical Report CMU-CS-95-151, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: They often provide a graphical interface so that developers can express architectures using diagrams of the kind that have proven useful. Current ADLs include Aesop [GAO94], ArTek [T + 94], Dar-win <ref> [MK95] </ref>, Rapide [LAK + 95], UniCon [SDK + 95], and Wright [AG94]. While all of these ADLs are concerned with architectural structure, they differ in their level of genericity. There are three basic levels. Some are primarily concerned with architectural instances. <p> Typical kinds of analyses reveal whether there is a causal dependency between certain kinds of computations. The presence (or absence) of these causality relationships can sometimes indicate errors in the architectural design. 2. Darwin <ref> [MK95] </ref> models system behavior in terms of the -calculus [MPW92]. The flexibility of this model permits the encoding of highly dynamic architectures, while the strong typing system of the -calculus permits certain static checks.
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes. </title> <journal> Journal of Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year>
Reference-contexts: Typical kinds of analyses reveal whether there is a causal dependency between certain kinds of computations. The presence (or absence) of these causality relationships can sometimes indicate errors in the architectural design. 2. Darwin [MK95] models system behavior in terms of the -calculus <ref> [MPW92] </ref>. The flexibility of this model permits the encoding of highly dynamic architectures, while the strong typing system of the -calculus permits certain static checks.
Reference: [MQR95] <author> M. Moriconi, X. Qian, and R. Riemenschneider. </author> <title> Correct architecture refinement. </title> <journal> IEEE Transactions on Software Engineering, Special Issue on Software Architecture, </journal> <volume> 21(4) </volume> <pages> 356-372, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Moriconi and his colleagues have observed that it is possible to exploit patterns of refinement between different levels of architectural description <ref> [MQR95] </ref>. For instance, refining a dataflow connector to a shared variable connector involves a stylized transformation of asynchronous reading/writing to synchronized data access. To capitalize on this observation they have proposed formalisms that encode transformations between architectural styles. In the above example, they might provide a pipe-to-shared-data transformation.
Reference: [Nii86] <author> H. Penny Nii. </author> <title> Blackboard systems Parts 1 & 2. </title> <journal> AI Magazine, </journal> <pages> 7 nos 3 (pp. 38-53) and 4 (pp. 62-69), </pages> <year> 1986. </year>
Reference-contexts: A few of the patterns, or styles, (e.g., object organizations [Boo86] and blackboards <ref> [Nii86] </ref>) have been carefully refined, but others are still used quite informally, even unconsciously. Nevertheless, the architectural patterns are widely recognized.
Reference: [Pau85] <author> Mark C. Paulk. </author> <title> The ARC Network: A case study. </title> <journal> IEEE Software, </journal> <volume> 2(3) </volume> <pages> 61-69, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: It consists of physical and data layers, a network layer, and transport, session, and presentation layers." <ref> [Pau85] </ref> We studied sets of such descriptions and found a number of abstractions that govern the overall organization of the components and their interactions [GS93].
Reference: [Per87] <author> Dewayne E. Perry. </author> <title> Software interconnection models. </title> <booktitle> In Proceedings of the Ninth International Conference on Software Engineering, </booktitle> <pages> pages 61-68, </pages> <address> Monterey, CA, March 1987. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: A promising research opportunity is understanding how to make architectural specifications partial, incremental, and evolving. This entails adding new properties, declaring what properties are required for specific kinds of analysis, checking consistency, and propagating new information to improve old analyses. Work on using partial specifications will help <ref> [Jac94, Per87] </ref>, as will a fresh approach that views them as evolving entities rather than static documents. 5.3 Extra-functional Properties We have already noted the failure of most existing formalisms to handle properties that go beyond the computational behavior of the system.
Reference: [PW92] <author> Dewayne E. Perry and Alexander L. Wolf. </author> <title> Foundations for the study of software architecture. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 17(4) </volume> <pages> 40-52, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: This level of system design has come to be known as software architecture <ref> [GS93, PW92] </ref>. In an architectural design, systems are typically viewed as compositions of module-scale, interacting components. Components are such things as clients and servers, databases, filters, and layers in a hierarchical system.
Reference: [Red88] <author> Raj Reddy. </author> <title> Foundations and grand challenges of artificial intelligence. </title> <journal> AI Magazine, </journal> <volume> 9(4) </volume> <pages> 9-21, </pages> <month> Winter </month> <year> 1988. </year> <title> 1988 presidential address, </title> <publisher> AAAI. </publisher>
Reference-contexts: This is true across a wide range of problem domains; studies have demonstrated it for medical diagnosis, physics, chess, financial analysis, architecture, scientific research, policy decision making, and others <ref> [Red88, Sim87] </ref>. An expert in a field must know around 50,000 chunks of information, where a chunk is any cluster of knowledge sufficiently familiar that it can be remembered rather than derived. Chunks are typically operational: "in this situation, do that".
Reference: [S + 87] <author> Alfred Z. Spector et al. Camelot: </author> <title> A distributed transaction facility for Mach and the Internet|an interim report. </title> <type> Technical Report CMU-CS-87-129, </type> <institution> Carnegie Mellon University, </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: The diagrams are supported by prose descriptions. This prose uses terms with common, if informal, definitions (italics ours): - "Camelot is based on the client-server model and uses remote procedure calls both locally and remotely to provide communication among applications and servers." <ref> [S + 87] </ref> - "Abstraction layering and system decomposition provide the appearance of system uniformity to clients, yet allow Helix to accommodate a diversity of autonomous devices.
Reference: [S + 88] <author> V. Seshadri et al. </author> <title> Semantic analysis in a concurrent compiler. </title> <booktitle> In Proceedings of ACM SIGPLAN '88 Conference on Programming Language Design and Implementation. ACM SIGPLAN Notices, </booktitle> <year> 1988. </year>
Reference-contexts: compiler phases over a number of processors. : : : A more effective way [is to] split the source code into many segments, which are concurrently processed through the various phases of compilation [by multiple compiler processes] before a final, merging pass recombines the object code into a single program." <ref> [S + 88] </ref> - "The ARC network [follows] the general network architecture specified by the ISO in the Open Systems Interconnection Reference Model.
Reference: [SDK + 95] <author> Mary Shaw, Robert DeLine, Daniel V. Klein, Theodore L. Ross, David M. Young, and Gregory Zelesnik. </author> <title> Abstractions for software architecture and tools to support them. </title> <journal> IEEE Transactions on Software Engineering, Special Issue on Software Architecture, </journal> <volume> 21(4) </volume> <pages> 314-335, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: They often provide a graphical interface so that developers can express architectures using diagrams of the kind that have proven useful. Current ADLs include Aesop [GAO94], ArTek [T + 94], Dar-win [MK95], Rapide [LAK + 95], UniCon <ref> [SDK + 95] </ref>, and Wright [AG94]. While all of these ADLs are concerned with architectural structure, they differ in their level of genericity. There are three basic levels. Some are primarily concerned with architectural instances. <p> For example, it can guarantee that processes only talk over channels of the correct type, even though the number and connectivity of those channels may change during runtime. 3. UniCon <ref> [SDK + 95] </ref> and Aesop [GAO94] support methods for real-time analysis| RMA and EDF, respectively. These ADLs, and their supporting tools, capture relevant information, repackage it into the formats required by real-time analysis tools, which are then invoked to perform the analyses. 4.
Reference: [Sha80] <author> Mary Shaw. </author> <title> The impact of abstraction concerns on modern programming languages. </title> <journal> In Proceedings of the IEEE Special Issue on Software Engineering, </journal> <volume> volume 68, </volume> <pages> pages 1119-1130, </pages> <month> September </month> <year> 1980. </year>
Reference-contexts: This development can bee seen in the development of data types and type theory <ref> [Sha80] </ref>. In the early 1960s, type declarations were added to programming languages. Initially they were little more than comments to remind the programmer of the underlying machine representation.
Reference: [Sha85] <author> Mary Shaw. </author> <title> What can we specify? Questions in the domains of software specifications. </title> <booktitle> In Proceedings of the Third International Workshop on Software Specification and Design, </booktitle> <pages> pages 214-215. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> August </month> <year> 1985. </year>
Reference-contexts: Extra-functional Properties. In addition to functionality and packaging, archi-tectural specifications must be capable of expressing extra-functional properties related to performance, capacity, environmental assumptions, and global properties such as reliability and security <ref> [Sha85, MCN92, CBKA95] </ref>. Many of these additional properties are qualitative, so they may require different kinds of support from more formal specifications.
Reference: [Sha95] <author> Mary Shaw. </author> <title> Architectural issues in software reuse: It's not just the functionality, it's the packaging. </title> <booktitle> In Proceedings of the Symposium on Software Reuse, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: At present, many ad hoc techniques are used to compensate for the incompatibility of parts. It would be useful to develop a systematic model that explains these and provides guidance for choosing the appropriate technique for a given situation <ref> [Sha95] </ref>. 5.2 Incomplete and Evolving Specifications According to conventional doctrine, component specifications are 1. sufficient (say everything you need to know) 2. complete (are the only source of information) However, architectural elements violate this doctrine. Architectural needs are open-ended, and a designer cannot anticipate all the properties of interest.
Reference: [Sim87] <author> Herbert A. Simon. </author> <title> Human experts and knowledge-based systems, </title> <month> November 9-12 </month> <year> 1987. </year>
Reference-contexts: This is true across a wide range of problem domains; studies have demonstrated it for medical diagnosis, physics, chess, financial analysis, architecture, scientific research, policy decision making, and others <ref> [Red88, Sim87] </ref>. An expert in a field must know around 50,000 chunks of information, where a chunk is any cluster of knowledge sufficiently familiar that it can be remembered rather than derived. Chunks are typically operational: "in this situation, do that".
Reference: [Spi89] <author> J.M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: For example, Allen and Gar-lan [AG92] provide a formalization of a pipe-filter architectural style, while [GN91] develops a formalization of implicit-invocation architectural style. Both of these use the Z specification language <ref> [Spi89] </ref> Generalizing from these examples, Abowd, Allen, and Garlan [AAG93] describe a denotational framework for developing formal models of architectural style (also in Z).
Reference: [T + 94] <author> Allan Terry et al. </author> <title> Overview of teknowledge's domain-specific software architecture program. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 19(4) </volume> <pages> 68-76, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: They often provide a graphical interface so that developers can express architectures using diagrams of the kind that have proven useful. Current ADLs include Aesop [GAO94], ArTek <ref> [T + 94] </ref>, Dar-win [MK95], Rapide [LAK + 95], UniCon [SDK + 95], and Wright [AG94]. While all of these ADLs are concerned with architectural structure, they differ in their level of genericity. There are three basic levels. Some are primarily concerned with architectural instances.
Reference: [Tra94] <author> Will Tracz. </author> <title> Collected overview reports from the DSSA project. </title> <institution> Loral Federal Systems Owego, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: The second category is addressing codification of architectural expertise [GHJV94, GS93]. Work in this area is concerned with cataloging and rationalizing the variety of architectural principles and patterns that engineers have developed through software practice. The third category is addressing frameworks for specific domains <ref> [DAR90, Tra94] </ref>. This work typically results in an architectural framework for a specific class of software such as avionics control systems, mobile robotics, or user interfaces. When successful, such frameworks can be easily instantiated to produce new products in the domain. The fourth category addresses formal underpinnings for architecture.
References-found: 42

