URL: ftp://ftp.eecs.umich.edu/groups/gasm/clam.ps.gz
Refering-URL: http://www.eecs.umich.edu/gasm/proglang.html
Root-URL: http://www.eecs.umich.edu
Email: boerger@di.unipi.it  salamone@di.unipi.it  
Title: CLAM Specification for Provably Correct Compilation of CLP(R) Programs  
Author: Egon B orger Rosario F. Salamone 
Address: Corso Italia 40 I-56125 PISA  
Affiliation: Dipartimento di Informatica Universita di Pisa  
Abstract: The paper extends the correctness proof in [4] for compilation of Prolog programs on the WAM to CLP(R) programs on the Constraint Logic Arithmetic Machine (CLAM [8, 10]). This serves to illustrate, through a complex case study, how the evolving algebra specification methodology allows to incorporate modularity and ex-tendability principles in system design. 1 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> H.Ait-Kaci, </author> <title> Warren's Abstract Machine. A tutorial reconstruction, </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: It is similar to the instruction set variable used in <ref> [1] </ref>. if code (p) = set svariable (x i ) then mk s unbound (x i ) succeed The instruction set svariable will be optimized away in the sequel.
Reference: 2. <author> C.Beierle & E.Borger, </author> <title> Correctness proof for the WAM with types. </title> <booktitle> In: Computer Science Logic (Eds. </booktitle> <editor> E. Borger, G. Jager, H. Kleine Buning, M. Richter), </editor> <publisher> Springer LNCS 626, </publisher> <year> 1992, </year> <pages> 15-34. </pages>
Reference-contexts: obtain a primary model for CLP (R), characterized by the programmer's view and close to resolution trees, it suffices to paraphrase the Pro-log model of [5] by replacing substitution by constraints and unification by constraint solving, similar to what has been done for the type constraints extension of Prolog in <ref> [2] </ref>. In the following we define in some detail the primary CLP (R) model and 4 The CLAM specification and compiler correctness then explain shortly how to refine this model to the level where predicates and clauses are not anymore abstract but compiled. <p> The reader who is acquainted with [5] or <ref> [2] </ref> might skip this section. 3.1 CLP Trees A CLP (R) computation can be seen as systematic search of a space of possible solutions to an initially given query.
Reference: 3. <author> E.Borger & D.Rosenzweig, </author> <title> An analysis of Prolog Database Views and their Uniform Implementation, In: Prolog. </title> <note> Paris Papers-2. ISO/IEC JTC1 SC22 WG17 Prolog Standardization Report no. 80, </note> <month> July </month> <year> 1991, </year> <pages> pp. 87-130. </pages> = <institution> CSE-TR-89-91, University of Michigan, </institution> <address> Ann Arbor, </address> <month> Michigan </month> <year> 1991. </year> <title> 15 The brace notation stands for the instructions addpf var +, addpf var -, ad-dpf val +, addpf val -. 34 The CLAM specification and compiler correctness </title>
Reference-contexts: accumulated constraints are copied and the selected node is cancelled from wants to view CLP (R) as returning all solutions, all he has to do is to modify this rule so as to trigger backtracking. 4 Given database operations of full Prolog this rule formalizes the so-called logical view, see <ref> [3] </ref>. 8 The CLAM specification and compiler correctness the cands list. if is user defined (act) & mode = Select then if cands = [ ] then backtrack else let clause = rename (clause (cll (fst (cands ))); vi) currnode := fst (cands ) c (fst (cands)) := c decglseq (fst
Reference: 4. <author> E.Borger & D.Rosenzweig, </author> <title> The WAM|Definition and Compiler Correctness, to appear in Logic Programming: Formal Methods and Practical Applications (Eds. </title> <booktitle> C.Beierle, L.Plumer), Studies in Computer Science and Artificial Intelligence, </booktitle> <publisher> North-Holland, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction This paper extends, to the Constraint Logic Arithmetic Machine (CLAM) and CLP (R) programs, the mathematical analysis of the Warren Abstract Machine (WAM) for executing Prolog and the resulting correctness proof for a general compilation scheme of Prolog to the WAM given in <ref> [4] </ref>. Starting from an abstract CLP (R) model|which paraphrases the primary model for Prolog defined in [5]|we follow the stepwise refinement of Prolog models to the WAM model given in [4] and enrich both the specification and the correctness proofs by what is needed to cover CLP (R) constraints and their <p> for executing Prolog and the resulting correctness proof for a general compilation scheme of Prolog to the WAM given in <ref> [4] </ref>. Starting from an abstract CLP (R) model|which paraphrases the primary model for Prolog defined in [5]|we follow the stepwise refinement of Prolog models to the WAM model given in [4] and enrich both the specification and the correctness proofs by what is needed to cover CLP (R) constraints and their implementation in the CLAM. Use of Gurevich's evolving algebras [6] as our specification vehicle allows to couple smoothly the modularity of the WAM specification in [4] to extendability of unification <p> WAM model given in <ref> [4] </ref> and enrich both the specification and the correctness proofs by what is needed to cover CLP (R) constraints and their implementation in the CLAM. Use of Gurevich's evolving algebras [6] as our specification vehicle allows to couple smoothly the modularity of the WAM specification in [4] to extendability of unification to handling of CLP (R) constraints. For expository reasons we start (in section 3) from scratch by defining an operational semantics of CLP (R) through CLP (R) trees, close to the usual intuitive picture and to its proof theoretical logical background (resolution-trees). <p> We thus arrive at a specification of the full CLAM which allows us to prove the Theorem 1.1. (Main Theorem) Each compiler which satisfies the assumptions for predicate, clause, term compilation listed in <ref> [4] </ref> and the assumptions for constraint compilation listed in this paper, compiles CLP (R) programs correctly with respect to CLP (R) trees and CLAM algebras. All we assume of the reader is general understanding of CLP (R) and Prolog as programming languages. <p> All we assume of the reader is general understanding of CLP (R) and Prolog as programming languages. In order to keep the paper within reasonable bounds we refer to <ref> [4] </ref> each time we can take from there without crucial modifications. To help readability we list however in section 2 the basic notions from evolving algebras. 2 Prerequisites on evolving algebras The CLAM model constructed in this paper is an evolving algebra, a notion introduced by Gurevich in [7]. <p> preceding section can easily be refined to reflect WAM code for creation, reuse and discarding of choicepoints (including switching) and for (de-)allocation of environments (representing clause structure): just apply to the primary CLP (R) tree model the same refinement steps as defined (and proved to be correct) for Prolog in <ref> [4] </ref>. This goes through embedding of the tree into a stack, reuse of choicepoints, de-terminacy detection, try- retry- trust- and switching-code (where switching will be canonically extended to arithmetical terms) and environment handling code (where to instructions call (G) also instructions resolve (C) for constraints C will be added). <p> Thus the modularity of the WAM specification in <ref> [4] </ref> allows us to naturally embed that specification into the CLP (R) context and to proceed directly to compilation of terms and constraints. 4 Representation of Constraints When passing to the level of term representation, the CLAM requires to properly extend all corresponding WAM data structures and to introduce new data <p> Notationally we often suppress the value functions and write tag (l) for tag (val (l)), ref (l) for ref (val (l)), svar lpf (l) for svar lpf (sval (l)) etc. We borrow from <ref> [4] </ref> the following abbreviations: l 1 l 2 j val (l 1 ) : = val (l 2 ); l h T; R i j tag (l) : = T; ref (l) : = R l unbound (l) j ( tag (l) = L var & ref (l) = l) mk <p> occ (l) : = []; svar value (l) : = nil mk s unbound (l) j l hS var ; svtopi; mk id unbound (svtop); svtop := svtop + We extend the WAM dereferencing and term reconstructing functions deref : DATAAREA ! DATAAREA and term : DATAAREA ! TERM &gt;from <ref> [4] </ref> to include solver variables. We add the analogues for reconstructing linear parametric forms lpf : PF AREA ! TERM and solver variable values svar : SVAR AREA ! TERM . <p> equality solver for the two arithmetic terms stored at l 1 and l 2 , see below. bind (l 1 ; l 2 ), a "logical operation", is always consistent with the current collection of arithmetic constraints. 14 The CLAM specification and compiler correctness To the assumptions for bind in <ref> [4] </ref> we add an assumption for equate: Bind Assumption Let l 1 ; l 2 2 DATAAREA and cs be the current constraint system. <p> The function put seq|defining the compilation of a body goal, see <ref> [4] </ref>| is here extended to specify how constraints are to be compiled. <p> Its content function accval has to yield constants or pairs (constant,solver identifier). Also a 0-ary function add counter is added containing the number of parametric variables which appeared so far in the linear form being read. For the WAM putting instructions the rules defined in <ref> [4] </ref> are taken. For the CLAM instructions the rules are defined now. <p> the appropriate "nonlinear" instruction 12 : set seq ([]) = [] set seq ([X i j T ]) = [set svariable (x i ) j set seq (T )] set seq ([c j T ]) = set seq (T ) In addition to the rules for WAM's getting instructions (see <ref> [4] </ref>), we define now the rules for new CLAM instructions. <p> Modifying put- and get-code (to generate unify local value instead of unify value for all occurrences of local variables), as in the WAM one can preserve the Heap Variable Constraint (that no heap variable points outside the heap), see <ref> [4] </ref>. 7 CLAM In this section we obtain a description of the CLAM by embedding the compilation of terms and constraints into the CLP (R) model with predicate and clause compilation (outlined in section 3). 7.1 Stack and Trail The first step is, as in the WAM, to refine the choicepoint <p> The distinguished elements b and e stand for the (address of the) topmost choicepoint and environment, respectively. The environment frame is taken unchanged from the WAM (see <ref> [4] </ref>), while the choicepoint frame gets extended by information on constraints as described in Fig. 4, formally: 28 The CLAM specification and compiler correctness cp . (continuation environment) (number of arguments) h ttop p e (heap pointer) (trail pointer) svtop x n top nl top &gt; (topmost linear equation) (topmost nonlinear <p> j l + n + 10 top = (l) j l + n + 11 hb j val (h (b)) Thus we have the same form of environment (de-)allocation and choicepoint handling rules as for the WAM (including the conditions on binding and HEAP &lt; STACK &lt; AREGS , see <ref> [4] </ref>). We have to refine in particular the trail update, which allows to undo, on backtracking, all the modifications to the constraint system made after creation of the choicepoint where the system backtracks to. <p> The classification of variables|which is crucial for environment trimming and last call optimization|can be taken together with all the proofs almost literally from the WAM model of <ref> [4] </ref> thanks to the modularity of the specification introduced here.
Reference: 5. <author> E.Borger & D.Rosenzweig, </author> <title> Mathematical Definition of Full Prolog, </title> <note> to appear in Science of Computer Programming, </note> <year> 1994. </year>
Reference-contexts: This definition, which serves as our primary mathematical model, is easily shown to be correct wrt resolution (for CLP (R) programs without built-in predicates), and can be extended to a transparent rigorous formulation of the full language using the definitions given in <ref> [5] </ref>. 1 in: E.Borger (Ed.), Specification and Validation Methods, Oxford University Press (to appear) 2 The CLAM specification and compiler correctness The first major refinement steps are devoted to analysis and implementation of the disjunctive and conjunctive structure of CLP (R) programs. <p> As CLP (R) is a sequential language, our rules are organized in such a way that at every moment at most one rule is applicable. 3 CLP (R) with Predicate and Clause Compilation In this section we show how one can adapt the Prolog tree model of <ref> [5] </ref> to CLP (R) ([8]) and its refinement with predicate and clause compilation. We suppose the reader to be acquainted with the fundamentals of Prolog and of CLP (R). <p> We suppose the reader to be acquainted with the fundamentals of Prolog and of CLP (R). To obtain a primary model for CLP (R), characterized by the programmer's view and close to resolution trees, it suffices to paraphrase the Pro-log model of <ref> [5] </ref> by replacing substitution by constraints and unification by constraint solving, similar to what has been done for the type constraints extension of Prolog in [2]. <p> In the following we define in some detail the primary CLP (R) model and 4 The CLAM specification and compiler correctness then explain shortly how to refine this model to the level where predicates and clauses are not anymore abstract but compiled. The reader who is acquainted with <ref> [5] </ref> or [2] might skip this section. 3.1 CLP Trees A CLP (R) computation can be seen as systematic search of a space of possible solutions to an initially given query. <p> This concludes the description of the primary CLP (R) model as far as user-defined predicates are concerned. For built-in predicates one can now proceed as in Prolog; we refer for this to the full description given in <ref> [5] </ref> and show here only the example of the cut.
Reference: 6. <author> Y.Gurevich, </author> <title> Evolving Algebras. A Tutorial Introduction in: </title> <journal> Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> no.43, </volume> <month> February </month> <year> 1991, </year> <pages> pp. 264-284. </pages>
Reference-contexts: Use of Gurevich's evolving algebras <ref> [6] </ref> as our specification vehicle allows to couple smoothly the modularity of the WAM specification in [4] to extendability of unification to handling of CLP (R) constraints. <p> In <ref> [6] </ref> Gurevich has shown how to reduce such setups to the above basic model of a homogenous signature (with one universe) and function updates only. The forms obviously reducible to the above basic syntax, which we shall freely use as abbreviations, are let, case and if then else.
Reference: 7. <author> Y.Gurevich, </author> <title> Logic and the Challenge of Computer Science, </title> <editor> in: E.Borger (Ed.), </editor> <booktitle> Trends in Theoretical Computer Science. </booktitle> <publisher> Computer Science Press, </publisher> <address> Rockville MA 1988, </address> <pages> pp. 1-57. </pages>
Reference-contexts: To help readability we list however in section 2 the basic notions from evolving algebras. 2 Prerequisites on evolving algebras The CLAM model constructed in this paper is an evolving algebra, a notion introduced by Gurevich in <ref> [7] </ref>. Since this notion is a mathematically rigorous form of fundamental operational intuitions of computing, the paper can be followed without any particular theoretical prerequisites: indeed our rules can be read as `pseudocode over abstract data'. For completeness we nevertheless list in this section the basic definitions for evolving algebras.
Reference: 8. <author> J.Jaffar, S.Michaylov, P.J.Stuckey & R.H.C.Yap, </author> <title> The CLP(R) Language and System, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <month> July </month> <year> 1992, </year> <pages> pp 339-395. </pages>
Reference: 9. <author> Nevin C.Heintze, Joxan Jaffar, Spiro Michaylov, Peter J.Stuckey & Roland H.C.Yap, </author> <note> The CLP(R) Programming Manual, Version 1.2, </note> <month> September </month> <year> 1992. </year>
Reference: 10. <author> J.Jaffar, S.Michaylov, P.J.Stuckey & R.H.C.Yap, </author> <title> An Abstract Machine for CLP(R), </title> <month> November </month> <year> 1992. </year>
Reference-contexts: For each nonlinear operation, instructions are provided for creating a nonlinear constraint of any degree. For example we could define five instructions for pow, corresponding to the various wakeup degrees (see <ref> [10] </ref>): * pow vvv (V i ; V j ; V k ) for V i = pow (V j ; V k ), pow cvv (c; V j ; V k ) for c = * pow vcv (V i ; c; V k ) for V i = pow <p> Note also that get lpf (x i ) can be replaced by addpf val (x i ); solve eq0 : The instruction get lpf may then be entirely dispensed with. Through elimination of set svariable, put lpf and get lpf we obtain the same instruction set as described in <ref> [10] </ref>.
Reference: 11. <author> R.F.Salamone, </author> <title> An Abstract Modular Specification of the CLAM, </title> <institution> Tesi di Laurea, Dipartimento di Informatica, Universita di Pisa, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: assume that the elements of the list of occurrences of an identifier are formed by the address of a linear or nonlinear form in which the identifier appears, and its relative position within this form (a sort of offset with respect to the address of the form, for details see <ref> [11] </ref>). Notationally we often suppress the value functions and write tag (l) for tag (val (l)), ref (l) for ref (val (l)), svar lpf (l) for svar lpf (sval (l)) etc. <p> Putting together all the assumptions made for compilation of predicates, clauses, terms and constraints one can prove the main theorem stated in the introduction, see <ref> [11] </ref>. 7.2 Optimizations In this section we outline some of the major optimizations for the CLAM.
References-found: 11

