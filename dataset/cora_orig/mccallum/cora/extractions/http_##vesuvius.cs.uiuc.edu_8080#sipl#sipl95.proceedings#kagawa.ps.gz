URL: http://vesuvius.cs.uiuc.edu:8080/sipl/sipl95.proceedings/kagawa.ps.gz
Refering-URL: http://vesuvius.cs.uiuc.edu:8080/sipl/sipl95.proceedings.html
Root-URL: http://www.cs.uiuc.edu
Email: E-mail: kagawa@kurims.kyoto-u.ac.jp  
Title: Mutable Data Structures and Composable References in a Pure Functional Language  
Author: Koji Kagawa 
Address: Kyoto 606-01, Japan  
Affiliation: Research Institute for Mathematical Sciences Kyoto University  
Abstract: We propose composable references as tools to handle mutable data structures in monadic-style functional programs. They enable us to express mutable data structures efficiently, for example, to avoid unnecessary indirections and to avoid copying. A composable reference is a reference which is parameterized over the type of the underlying mutable data structure used as the state and intuitively is a location of a field (or more generally, a substructure) relative to the parameterized state. Composable references can be composed as functions. Composable references make stateful programs concise by allowing mutable data structures to be passed implicitly.
Abstract-found: 1
Intro-found: 1
Reference: [AvGP93] <author> Peter Achten, John van Groningen, and Rinus Plasmeijer. </author> <title> High level specification of I/O in functional languages. </title> <editor> In Launchburyet al., editors, </editor> <booktitle> Proceedings of Glasgow Workshop on Functional Programming. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: This is problematic when we need an efficient representation of mutable graph structures. What is lacking seems to be an appropriate method to handle such primitive mutable data structures. 1.3 Concurrent Clean In <ref> [AvGP93] </ref>, Achten, van Groningen and Plasmeijer proposed Unique types to ensure uniqueness of data structures and thus to make in-place updating possible. Though this is an approach quite different from using monads, unique types in Concurrent Clean are another motivation of this work.
Reference: [CHO92] <author> Kung Chen, Paul Hudak, and Martin Odersky. </author> <title> Parametric type classes. </title> <booktitle> In ACM Conf. on LISP and Functional Programming, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: The notion of parametric type classes <ref> [CHO92] </ref> is a generalization of type classes. We write a placeholder type variable (a type variable which is constrained by the class) before "::" and parameters after the name of the class.
Reference: [Jon92] <author> Mark P. Jones. </author> <title> A theory of qualified types. </title> <booktitle> In ESOP '92: European Symposium on Programming, Rennes, </booktitle> <address> France, New York, </address> <month> February </month> <year> 1992. </year> <note> Springer-Verlag. Lecture Notes in Computer Science, 582. </note>
Reference-contexts: For example, the following is not allowed: instance [Int] :: List Int where ... instance [Char] :: List Char where ... This is a restriction specific to Haskell-style type classes and can be eased when used in Gofer-style type classes <ref> [Jon92] </ref>. Therefore we will not follow this restriction in the following. We can declare types with the same top level constructor as instances of a class, as far as they do not overlap.
Reference: [Lau93] <author> Konstantin Laufer. </author> <title> An extension of Haskell with first-class abstract types, </title> <month> September </month> <year> 1993. </year> <note> Submitted to the Journal of Functional Programming. </note>
Reference-contexts: Suppose we have pt :: CR s Point and cpt :: CR s ColoredPoint, then pts = [pt, cpt-*&gt;pointOf] has type [CR s Point]. It seems desirable to express pts without explicit coercion as pts = [pt, cpt]. But this will need an extension of the type system. In <ref> [Lau93] </ref>, Laufer used first-class abstract types in order to express heterogeneous aggregates. However, we can not access additional fields any longer once they are packed as an abstract type.
Reference: [Ler93] <author> Xavier Leroy. </author> <title> The Caml Light system, release 0.6 Documentation and user's manual. </title> <institution> INRIA, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: These are different from those data structures whose fields are of MutVar type in the sense that we need indirections in the latter as is shown in Figure 2. Mutable objects should have representations as efficient as those used in conventional imperative languages (such as C). Caml Light <ref> [Ler93] </ref> has already such mutable data structures, but it is a strict, impure language and referential transparency does not need to be maintained.
Reference: [LP94] <author> John Launchbury and Simon L. Peyton Jones. </author> <title> Lazy functional state threads. </title> <booktitle> In Programming Languages Design and Implementation (PLDI) '94, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Some solutions have been proposed to this problem and some of them, notably that of Launchbury and Peyton Jones <ref> [LP94] </ref>, have been already incorporated into existing implementations. In their proposal, however, only two data structures (MutVar (reference cells) and MutArr (mutable arrays)) are essentially mutable. <p> In order to solve this problem, Launchbury and Peyton Jones proposed the primitive operator newVar <ref> [LP94] </ref> which creates new reference cells (of type MutVar): newVar :: a -&gt; ST s (MutVar s a) and associated operators readVar and writeVar: readVar :: MutVar s a -&gt; ST s a writeVar :: MutVar s a -&gt; a -&gt; ST s () Here, MutVar is parameterized over the type <p> This extracted state is passed to a state transformer ((-!&gt;)) or another composable reference ((-*&gt;)). If we use the diagram notation of <ref> [LP94] </ref>, a composable reference and associated operators would be expressed as in Figure 4. 2.2 Composable references for field access As state transformers can be implemented so that they can do in-place updating by restricting their expressiveness, composable references can be implemented so that they do not need to create actual <p> The precise implementations differ according to the type; they depend on the size of objects. Therefore we should declare a type class. Note that freeze is an overloaded version of freezeArr of <ref> [LP94] </ref>. class Plastic s where freeze :: ST s s replace :: s -&gt; ST s () freezeR :: SR s s Then we declare instances for this class. instance Plastic (a, b) where freeze = l_1 -!&gt; fetch `thenST` " a -&gt; l_2 -!&gt; fetch `thenST` " b -&gt; returnST <p> For example, the following operator might be useful. deref :: SR s (CR s a) -&gt; CR s a deref (MkSR sr) = MkCR (" s -&gt; let (MkCR r) = sr s in r s) Then we can think of MutVar type of <ref> [LP94] </ref> as a CRV to a record with only one component. type MutVar s a = CRV s (Maybe a) newVar a = melt (Just a) writeVar v a = unitCR v -!&gt; assign a readVar v = unitCR v -!&gt; fetch 2.7 Mutable lists We define the type of mutable
Reference: [Mog89] <author> Eugenio Moggi. </author> <title> Computational lambda-calculus and monads. </title> <booktitle> In IEEE Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: In this paper, we do not get into details and only introduce some monadic operators which are used to express stateful computations. Figure 1 explains the monad of state transformers. For examples and motivations, see <ref> [Mog89, Wad90, Wad92] </ref>. The two monads used here | the monad of state transformers and the monad of state readers | are in fact families of monads which differ only in the type of the state. In-place updating is crucial in stateful computations.
Reference: [PJW93] <editor> Simon L. Peyton Jones and Philip Wadler. </editor> <title> Imperative functional programming. </title> <booktitle> In Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <year> 1993. </year>
Reference-contexts: Monads (and therefore the work presented here) can be useful also for strict languages. The reason is as follows. First, we do not need weak type variables as is pointed out in <ref> [PJW93] </ref>. Second, we have more opportunities to find type errors; we can not place expressions which have no side effect where those with side effect are expected. And last, we can distinguish the pure functional parts from the imperative parts.
Reference: [Wad90] <author> Philip Wadler. </author> <title> Comprehending monads. </title> <booktitle> In ACM Symp. on Lisp and Functional Programming, </booktitle> <pages> pp. 61-78, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction The notion of multiple mutable objects or references was a problematic issue in purely functional languages such as Haskell, when the monad of state transformers <ref> [Wad90, Wad92] </ref> was introduced to express stateful computations, that is, to enable in-place updating while retaining referential transparency. Some solutions have been proposed to this problem and some of them, notably that of Launchbury and Peyton Jones [LP94], have been already incorporated into existing implementations. <p> In this paper, we do not get into details and only introduce some monadic operators which are used to express stateful computations. Figure 1 explains the monad of state transformers. For examples and motivations, see <ref> [Mog89, Wad90, Wad92] </ref>. The two monads used here | the monad of state transformers and the monad of state readers | are in fact families of monads which differ only in the type of the state. In-place updating is crucial in stateful computations. <p> Monad morphisms are functions between two monads with some pleasant properties. For the definition and examples, please refer to e.g. <ref> [Wad90] </ref>. We assume these operators bind tighter than `thenfl` and associate to left. We use these operators to compose stateful programs. The meanings of these operator are as follows.
Reference: [Wad92] <editor> Philip Wadler. </editor> <booktitle> The essence of functional programming. In Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <year> 1992. </year>
Reference-contexts: 1 Introduction The notion of multiple mutable objects or references was a problematic issue in purely functional languages such as Haskell, when the monad of state transformers <ref> [Wad90, Wad92] </ref> was introduced to express stateful computations, that is, to enable in-place updating while retaining referential transparency. Some solutions have been proposed to this problem and some of them, notably that of Launchbury and Peyton Jones [LP94], have been already incorporated into existing implementations. <p> In this paper, we do not get into details and only introduce some monadic operators which are used to express stateful computations. Figure 1 explains the monad of state transformers. For examples and motivations, see <ref> [Mog89, Wad90, Wad92] </ref>. The two monads used here | the monad of state transformers and the monad of state readers | are in fact families of monads which differ only in the type of the state. In-place updating is crucial in stateful computations.
References-found: 10

