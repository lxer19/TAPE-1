URL: ftp://ftp.cs.caltech.edu/tr/cs-tr-95-02.ps.Z
Refering-URL: ftp://ftp.cs.caltech.edu/tr/INDEX.html
Root-URL: http://www.cs.caltech.edu
Title: An Energy-Complexity Model for VLSI Computations  
Author: Jose Andres Tierno 
Degree: Thesis by  In Partial Fulfillment of the Requirements for the Degree of Doctor of Philosophy  
Date: 1995 (Submitted January 11)  
Address: Pasadena, California  
Affiliation: California Institute of Technology  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Y. S. Abu-Mostafa, </author> <title> Complexity of information extraction, </title> <type> Ph.D. thesis, </type> <institution> California Institute of Technology, </institution> <year> 1983. </year>
Reference-contexts: = 0 (4.1) We start with the following specification for the zero detection circuit: Zero (n) *[[ Z ! Z !(B [1 ::n] = 0 ) ]] The following program uses lazy evaluation to reduce energy consumption: Zero (n) Zero1 k Zero (n 1 ) Zero1 *[[ Z ^ B <ref> [1 ] </ref> ! Z !false [] Z ^ :B [1 ] ! Z !(Z1 ?) Zero (n 1 ) *[[ Z1 ! Z1 !(B [2 ::n] = 0 ) ]] The energy consumption of Zero (n) can be computed as: C (Zero (n)) = C (Zero1 ) + Pr (B [1] <p> for the zero detection circuit: Zero (n) *[[ Z ! Z !(B [1 ::n] = 0 ) ]] The following program uses lazy evaluation to reduce energy consumption: Zero (n) Zero1 k Zero (n 1 ) Zero1 *[[ Z ^ B <ref> [1 ] </ref> ! Z !false [] Z ^ :B [1 ] ! Z !(Z1 ?) Zero (n 1 ) *[[ Z1 ! Z1 !(B [2 ::n] = 0 ) ]] The energy consumption of Zero (n) can be computed as: C (Zero (n)) = C (Zero1 ) + Pr (B [1] = false)C (Zero (n 1)) = K 1 + <p> [1 ] ! Z !false [] Z ^ :B [1 ] ! Z !(Z1 ?) Zero (n 1 ) *[[ Z1 ! Z1 !(B [2 ::n] = 0 ) ]] The energy consumption of Zero (n) can be computed as: C (Zero (n)) = C (Zero1 ) + Pr (B <ref> [1] </ref> = false)C (Zero (n 1)) = K 1 + 2 C (Zero (n 1)) (4.2) 70 where K 1 is the energy cost of executing Zero1, which is independent of n. <p> Nevertheless we differentiate between the instructions that only increment pc to the next consecutive memory location, and those that replace pc with a new value. The reason is based on the entropy of the instruction address sequence. Let A <ref> [1] </ref>; : : : ; A [i]; : : : be this sequence. <p> Ipc [] Ipc ^ pc [0 ] ! pc [0 ]# k Ipc1 k Ipc [] Rpc ! Rpc!pc ]] PCinc1 *[[ Ipc1 ! pc := pc + 2 ; Ipc1 ]] We can use the same transformation as before to improve the PCinc1 process: PCinc1 *[[ Ipc1 ^ :pc <ref> [1 ] </ref> ! pc [1 ]"; Ipc1 [] Ipc1 ^ pc [1 ] ! pc [1 ]#; Ipc2 ; Ipc1 PCinc2 *[[ Ipc2 ! pc := pc + 4 ; Ipc2 ]] We transform PCinc2 in the same way recursively until all bits from pc have been taken care of. 8.5 <p> pc [0 ] ! pc [0 ]# k Ipc1 k Ipc [] Rpc ! Rpc!pc ]] PCinc1 *[[ Ipc1 ! pc := pc + 2 ; Ipc1 ]] We can use the same transformation as before to improve the PCinc1 process: PCinc1 *[[ Ipc1 ^ :pc <ref> [1 ] </ref> ! pc [1 ]"; Ipc1 [] Ipc1 ^ pc [1 ] ! pc [1 ]#; Ipc2 ; Ipc1 PCinc2 *[[ Ipc2 ! pc := pc + 4 ; Ipc2 ]] We transform PCinc2 in the same way recursively until all bits from pc have been taken care of. 8.5 Summary & Conclusion We <p> k Ipc1 k Ipc [] Rpc ! Rpc!pc ]] PCinc1 *[[ Ipc1 ! pc := pc + 2 ; Ipc1 ]] We can use the same transformation as before to improve the PCinc1 process: PCinc1 *[[ Ipc1 ^ :pc <ref> [1 ] </ref> ! pc [1 ]"; Ipc1 [] Ipc1 ^ pc [1 ] ! pc [1 ]#; Ipc2 ; Ipc1 PCinc2 *[[ Ipc2 ! pc := pc + 4 ; Ipc2 ]] We transform PCinc2 in the same way recursively until all bits from pc have been taken care of. 8.5 Summary & Conclusion We have shown in this chapter how to <p> [] Rpc ! Rpc!pc ]] PCinc1 *[[ Ipc1 ! pc := pc + 2 ; Ipc1 ]] We can use the same transformation as before to improve the PCinc1 process: PCinc1 *[[ Ipc1 ^ :pc <ref> [1 ] </ref> ! pc [1 ]"; Ipc1 [] Ipc1 ^ pc [1 ] ! pc [1 ]#; Ipc2 ; Ipc1 PCinc2 *[[ Ipc2 ! pc := pc + 4 ; Ipc2 ]] We transform PCinc2 in the same way recursively until all bits from pc have been taken care of. 8.5 Summary & Conclusion We have shown in this chapter how to apply a number of
Reference: [2] <author> C. H. Bennett, </author> <title> The thermodynamics of computation|a review, </title> <journal> International J. of Theoretical Physics 21 (1982), </journal> <volume> no. 12, </volume> <pages> 905-940. </pages>
Reference: [3] <author> S. M. Burns, </author> <title> Automated compilation of concurrent programs into self-timed circuits, </title> <institution> Cs-tr-88-2, California Institute of Technology, </institution> <month> December </month> <year> 1987. </year>
Reference: [4] <author> Steven M. Burns, </author> <title> Performance analysis and optimization of asynchronous circuits, </title> <type> Ph.D. thesis, </type> <institution> California Institute of Technology, </institution> <year> 1991. </year>
Reference-contexts: Next, we assume that the delay function for the circuit is based on the 2 A posynomial is a polynomial with positive coefficients, positive variables, and integer exponents 89 timed simulation of the circuit <ref> [4] </ref>. In that case, the other gate parameters that are relevant to the sizing problem are delay, transition time, and input capacitance. Delays are used to compute the timing function. <p> Assigning a discreet number of sizes to the gates in a circuit, however, converts a continuous optimization problem into an integer optimization problem, and it is, therefore, computationally harder. The algorithms described in <ref> [4] </ref> to compute the performance of asynchronous circuits, generate an integer linear programming problem in this case, which only has exponential-time known solutions. The table can be used to bridge the gap between the integer and continuous optimization problem.
Reference: [5] <author> G. Chaitin, </author> <title> Information-theoretic computational complexity, </title> <journal> IEEE Trans. on Information Theory IT-20 (1974), </journal> <pages> 10-15. </pages>
Reference: [6] <author> H. Y. Chen, </author> <title> Design automation for high performance CMOS VLSI, </title> <type> Ph.D. thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> December </month> <year> 1988. </year>
Reference: [7] <author> S. T. Chu, J. Dikken, C. D. Hartgring, F. J. </author> <title> List, </title> <editor> J. G. Raemaekers, S. A. Bell, B. Walsh, and R. H. W. Salters, A 25-ns low-power full-CMOS 1-Mbit (128Kfi8) SRAM, IEEE J. </editor> <booktitle> of Solid-State Circuits SC-23 (1988), </booktitle> <volume> no. 5, </volume> <pages> 1078-1084. </pages>
Reference-contexts: The optimum energy per access, E 2D;R (n; b) is: E 2D;R (n; b) = n (log 2 n + 2b + 1) (2.41) Memory designed for speed usually has l = b fi w <ref> [7] </ref>. A completely square bit-array optimizes the access time per bit, but does not take into account the energy savings derived from selecting only the bits that are part of the desired word. This extra selection step takes time and area, and saves energy.
Reference: [8] <author> W. E. Donath, </author> <title> Placement and average interconnection lengths of computer logic, </title> <journal> IEEE Transactions on Circuits and Systems CAS-26 (1979), </journal> <pages> 272-277. </pages>
Reference-contexts: of the circuit. 4 A positive definite matrix is a symmetric matrix with positive eigenvalues. 96 For control-type circuits that are going to be laid-out in a "standard-cell place-and-route" style, the wiring capacitance becomes a larger part of the load capacitance (compared to gate capacitance), as the circuit becomes larger <ref> [8] </ref>. As a consequence, the placement algorithm becomes more critical than sizing. This, together with the use of two-stage gates for generalized C-elements, greatly reduces the sensitivity of the delay with respect to individual gate sizes.
Reference: [9] <author> W. C. </author> <title> Elmore, The transient response of damped linear networks with particular regard to wideband amplifiers, </title> <editor> J. </editor> <booktitle> of Applied Physics 19 (1948), </booktitle> <pages> 55-63. </pages>
Reference-contexts: As a consequence, transistor sizing requires some trade-offs between accuracy and computation time. The weak point of sizing methods such as [11,4, 27] is the use of the Elmore delay model <ref> [9] </ref>. In exchange, the global measure of performance is computationally simple, and the optimization problem turns out to be convex in many interesting cases. The accuracy of the energy/delay model can be increased significantly by using more elaborate transistor models.
Reference: [10] <author> R. P. </author> <title> Feynman, </title> <booktitle> Quantum mechanical computers, Foundations of Physics 16 (1986), </booktitle> <volume> no. 6, </volume> <pages> 507-531. 156 </pages>
Reference: [11] <author> J. P. Fishburn and A. E. Dunlop, TILOS: </author> <title> A posynomial approach to transistor sizing, </title> <booktitle> Proceedings of the 1985 International Conference on Computer-aided Design, </booktitle> <month> November </month> <year> 1985, </year> <pages> pp. 326-328. </pages>
Reference-contexts: 88 true for control logic), and to the probability of transistor failure (assuming that fabrication flaws are the most critical on transistor gates); it also has the fundamental property of being a posynomial 2 on the transistor widths and, therefore, a convex function of the logarithms of the transistor widths <ref> [11] </ref>. When the purpose of the optimization is to minimize the energy dissipation in absolute terms, we have to use a better model.
Reference: [12] <author> E. Fredkin and T. Toffoli, </author> <title> Conservative logic, </title> <journal> International J. of Theoretical Physics 21 (1982), </journal> <volume> no. 3/4, </volume> <pages> 219-253. </pages>
Reference: [13] <author> J. L. Hennessy and D. A. Patterson, </author> <title> Computer Architecture a Quantitative Approach, </title> <journal> ch. </journal> <volume> 6, </volume> <pages> pp. 273-278, </pages> <publisher> Morgan Kaufmann Publishers Inc., </publisher> <year> 1990, </year> <pages> pp. 273-278. </pages>
Reference-contexts: Also, delayed branching requires that more than one pc register be kept, since the instructions in the shadow are not necessarily sequential. It is estimated that delayed branching can be filled with a useful instruction about 80% of the time <ref> [13] </ref>. Assuming that one out of 6 instructions is a branch, we have that one out of 30 instructions is overhead in energy for a delayed branching strategy. In this Chapter we will explore a different strategy for removing entropy from the instruction stream.
Reference: [14] <author> C. A. R. Hoare, </author> <title> Communicating sequential processes, </title> <journal> Communications of the ACM 21 (1978), </journal> <volume> no. 8, </volume> <pages> 666-677. </pages>
Reference: [15] <author> J. S. Hwang and C. Y. Wu, </author> <title> Efficient techniques in the sizing and constrained optimisation of CMOS combinational logic circuits, </title> <journal> IEE Proceedings-E 138 (1991), </journal> <volume> no. 3, </volume> <pages> 154-164. </pages>
Reference-contexts: This method is very accurate, but it requires large tables to be useful, especially if each gate has several parameters. The size of the look-up table can be reduced by combining the effect of some of the parameters into scaling laws. The method presented in <ref> [15] </ref> derives the delay equations from the nonlinear equations for the transistor circuit, and the theoretical parameters are adjusted from SPICE simulations. These equations are developed for simple combinational gates (nand, nor, AOI, OAI, inverters) under all possible triggering conditions.
Reference: [16] <author> T. K. Lee, </author> <title> Communication behavior of linear arrays of processes, </title> <institution> Cs-tr-89-12, California Institute of Technology, </institution> <month> December </month> <year> 1989. </year> <title> [17] , Energy and delay measurements of an asynchronous 3x+1 engine, </title> <type> Personal Communication, </type> <year> 1993. </year>
Reference-contexts: In the best case, where put and get alternate, it takes 2N time-steps to execute N puts and N gets. In order for put to be CRT, the order of the communications push!x; put?x has to be inverted <ref> [16] </ref>. To make the get operation CRT, the pop?x communication has to be done ahead of time and whenever the stack element becomes empty. 1 CRT = Constant Response Time 65 These two conditions can be met with an extra register in the stack element.
Reference: [18] <author> Alain J. Martin, </author> <title> Compiling communicating processes into delay-insensitive VLSI circuits, </title> <booktitle> Distributed Computing 1 (1986), </booktitle> <volume> no. 4, </volume> <pages> 226-234. </pages>
Reference: [19] <author> Alain J. Martin, </author> <title> The design of a delay-insensitive microprocessor: An example of circuit synthesis by program transformation, Hardware Specification, Verification and Synthesis: Mathematical Aspects (M. </title> <editor> Leeser and G. Brown, eds.), </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 408, </volume> <publisher> Springer-Verlag, </publisher> <year> 1989, </year> <pages> pp. 244-259. </pages>
Reference: [20] <author> Alain J. Martin, </author> <title> Asynchronous datapaths and the design of an asynchronous adder, </title> <booktitle> Formal Methods in System Design 1 (1992), </booktitle> <volume> no. 1, </volume> <pages> 119-137. </pages>
Reference: [21] <author> Alain J. Martin, Steven M. Burns, T. K. Lee, Drazen Borkovic, and Pieter J. Hazewindus, </author> <title> The design of an asynchronous microprocessor, </title> <booktitle> Advanced Research in VLSI: Proceedings of the Decennial Caltech Conference on VLSI (Charles L. Seitz, </booktitle> <publisher> ed.), MIT Press, </publisher> <year> 1989, </year> <pages> pp. </pages> <month> 351-373. </month> <title> [22] , The first asynchronous microprocessor: the test results, </title> <booktitle> Computer Architecture News 17 (1989), </booktitle> <volume> no. 4, </volume> <pages> 95-110. 157 </pages>
Reference: [23] <author> M. Matson, </author> <title> Macromodeling and optimization of digital MOS VLSI circuits, </title> <type> Ph.D. thesis, </type> <institution> MIT, </institution> <month> February </month> <year> 1985. </year>
Reference-contexts: All internal nodes to the gate are eliminated, and the gate is replaced by an equivalent and simpler electrical model. Gate modeling can be done in many different ways. In <ref> [23] </ref>, complex gates are mapped into simple gates as inverters. Sizes are computed and optimized on those inverters and then mapped back to the original gate.
Reference: [24] <author> L. Nagel, </author> <title> SPICE2: A computer program to simulate semiconductor circuits., </title> <type> Tech. Report ERL-M520, </type> <institution> University of California, Berkeley, </institution> <month> May </month> <year> 1975. </year>
Reference-contexts: those models in two categories: those that model the behavior of individual transistors and those that model the behavior of individual gates. 5.2.1 Transistor Modeling The most accurate way to compute gate delay is to solve the transistor equations for each gate in the same way that, for example, SPICE2 <ref> [24] </ref> simulates a circuit. This type of transistor modeling will generate the right answer with very few assumptions about the input signal. Even though this approach can be used for small circuits, its computational complexity is very high, especially if we use it as a model for global sizing optimization.
Reference: [25] <author> V. B. Rao, </author> <title> Switch-level timing simulation of MOS VLSI circuits, </title> <type> Ph.D. thesis, </type> <institution> University of Illinois at Urbana Champaign, </institution> <month> January </month> <year> 1985. </year>
Reference-contexts: This type of modeling is more adequate for asynchronous design because it can deal better with feedback loops. In <ref> [25] </ref>, a look-up table approach is used. The delay computation is tabulated for different gate types and configurations. This method is very accurate, but it requires large tables to be useful, especially if each gate has several parameters.
Reference: [26] <author> J. Rubenstein, P. Penfield, and M. A. Horowitz, </author> <title> Signal delay in RC tree networks, </title> <journal> IEEE Transactions on Computer-aided Design of Integrated Circuits and Systems 2 (1983), </journal> <volume> no. 3, </volume> <pages> 202-211. </pages>
Reference-contexts: Based on this model, it is possible to make predictions on the upper and lower bound to the signal delay through the RC-network <ref> [26] </ref>. The RC-model for transistors is not very accurate for submicron devices because of velocity-saturation effects.
Reference: [27] <author> S. S. Sapatnekar and S. M. Kang, </author> <title> Design Automation for Timing-Driven Layout Synthesis, </title> <journal> ch. </journal> <volume> 4, </volume> <pages> pp. 113-140, </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993, </year> <pages> pp. 113-140. </pages>
Reference-contexts: As a consequence, transistor sizing requires some trade-offs between accuracy and computation time. The weak point of sizing methods such as <ref> [11,4, 27] </ref> is the use of the Elmore delay model [9]. In exchange, the global measure of performance is computationally simple, and the optimization problem turns out to be convex in many interesting cases. The accuracy of the energy/delay model can be increased significantly by using more elaborate transistor models.
Reference: [28] <author> C. Shannon, </author> <title> A mathematical theory of communication, </title> <journal> Bell Systems Tech. J. </journal> <volume> 27 (1948), </volume> <pages> 379-423. </pages>
Reference-contexts: The entropy of the command sequences of length m, H (A 1 ; : : : ; A m ), is defined in the usual way <ref> [28] </ref>: Definition 3.2 The entropy of a sequence (A 1 ; : : : ; A m ) of random variables, H (A 1 ; : : : ; A m ), is defined as: H (A 1 ; : : : ; A m ) = (a 1::m )2S m <p> (P) C (HP) (3.12) Proof: K 1 ; : : : ; K l (HP;m) is a prefix-code 3 for A 1 ; : : : ; A m ; therefore we know that the average length of the code is at least the entropy of the source of symbols <ref> [28] </ref>, and we can write: H (A 1 ; : : : ; A m ) Pr (a 1 ; : : : ; a m )l (HP; a 1::m ) X Dividing by m and taking lim sup on both sides of the inequality, we get the thesis.
Reference: [29] <author> P. </author> <title> Single, The theory of logical effort and overhead, </title> <booktitle> Proceedings 7 th Aus-tralian Microelectronics Conference, </booktitle> <month> May </month> <year> 1988. </year>
Reference-contexts: The accuracy of the method is dependent on the accuracy of the mapping function. A similar approach is followed by [30], where the concept of logical effort <ref> [29] </ref> is used to separate the logic function that the gate is computing from the physical modeling of that gate with an inverter. This type of modeling is more adequate for asynchronous design because it can deal better with feedback loops. In [25], a look-up table approach is used.
Reference: [30] <author> I. E. Sutherland and R. E. Sproull, </author> <title> Logical effort: Designing for speed on the back of an envelope, Advanced Research in VLSI (C. </title> <editor> H. Sequin, ed.), </editor> <publisher> The MIT Press, </publisher> <year> 1991, </year> <pages> pp. 1-16. </pages>
Reference-contexts: The reduction in complexity corresponds to the reduction in the number of degrees of freedom of the complex gate, to the number of degrees of freedom of the inverter. The accuracy of the method is dependent on the accuracy of the mapping function. A similar approach is followed by <ref> [30] </ref>, where the concept of logical effort [29] is used to separate the logic function that the gate is computing from the physical modeling of that gate with an inverter. This type of modeling is more adequate for asynchronous design because it can deal better with feedback loops.
Reference: [31] <author> Ivan E. Sutherland, </author> <title> Micropipelines, </title> <journal> Communications of the ACM 32 (1989), </journal> <volume> no. 6, </volume> <pages> 720-738. </pages>
Reference-contexts: A simple implementation of a bundled data transfer is shown in Fig. 6.6. It requires two separate control signals for the read circuit, but each signal 109 copy; (b) indirect copy. goes to only one transistor per bit. This circuit is ideally suited for micro-pipeline style design <ref> [31] </ref>. The transfer can be done either in one step or two. The one-step transfer is simpler and faster, but it requires that both registers be placed close to each other.
Reference: [32] <author> Jose A. Tierno and Alain J. Martin, </author> <title> Low-energy asynchronous memory design, </title> <booktitle> Proc. International Symposium on Advanced Research in Asynchronous Circuits and Systems, </booktitle> <month> November </month> <year> 1994, </year> <pages> pp. 176-185. </pages>
Reference-contexts: The energy model previously developed is used to express the architectural trade-offs in the partitioning of such an array <ref> [32] </ref>.
Reference: [33] <author> R. R. Troutman, </author> <title> Subthreshold design considerations for insulated gate field effect transistors, </title> <journal> IEEE J. of Solid State Circuits SC-9 (1974), </journal> <pages> 55-60. </pages>
Reference: [34] <author> H. J. M. Veendrick, </author> <title> Short circuit dissipation of static CMOS circuitry and its impact on the design of buffer circuits, </title> <journal> IEEE J. of Solid-State Circuits SC-19 (1984), </journal> <volume> no. 4, </volume> <pages> 468-473. </pages>
Reference: [35] <author> M. Yoshimoto, K. Anami, H. Shinohara, T. Yoshihara, T. Takagi, and T. Nakano, </author> <title> A divided word-line structure in the static RAM and its application to a 64K full CMOS RAM, </title> <journal> IEEE J. of Solid-State Circuits SC-18 (1983), </journal> <volume> no. 5, </volume> <pages> 479-485. </pages>
Reference-contexts: can be derived from that program. 2.4.2 Multi-bank Memory Array We can further reduce the energy per access by breaking up the memory into several sub-arrays so that only one of the smaller sub-arrays is accessed in each memory reference; this technique is also known as the divided word-line method <ref> [35] </ref>. We obtain the CSP for the multi-banked memory by applying a divide-and-conquer strategy to the MEM program.
References-found: 33

