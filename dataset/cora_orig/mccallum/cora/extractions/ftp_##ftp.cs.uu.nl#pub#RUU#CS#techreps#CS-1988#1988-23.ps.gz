URL: ftp://ftp.cs.uu.nl/pub/RUU/CS/techreps/CS-1988/1988-23.ps.gz
Refering-URL: http://www.cs.ruu.nl/docs/research/publication/TechList1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Phone: Tel. 31 30 531454  
Title: Optimal Synchronization of ABD Networks  
Author: Gerard Tel Ephraim Korach Shmuel Zaks 
Address: Padualaan 14, P.O. Box 80.089, 3508 TB Utrecht, The Netherlands,  
Affiliation: Utrecht University Department of Computer Science  
Pubnum: RUU-CS-88-23  
Abstract-found: 0
Intro-found: 0
Reference: [Awe85] <author> Awerbuch, B. </author> <title> Complexity of network synchronization. </title> <editor> J. </editor> <booktitle> ACM 32 (1985), </booktitle> <pages> 804-823. </pages>
Reference-contexts: Email: zaks@cs.technion.ac.il. 1 The synchronous model is stronger than the asynchronous model. Consequently, distributed algorithms for synchronous networks are more efficient and easier to design than algorithms for asynchronous networks. Therefore simulation algorithms have been designed to simulate synchronous computations on asynchronous networks. These simulation algorithms are called synchronizers <ref> [Awe85] </ref>. The simplest of these mechanisms ensures that exactly one message is sent over each link of the network in every round. If the simulated algorithm sends more messages over some link in some round, these messages must be packed into one larger (logical) message.
Reference: [CCGZ90] <author> Chou, C. T., Cidon, I., Gopal, I. S., and Zaks, S. </author> <title> Synchronizing asynchronous bounded delay networks. </title> <journal> IEEE Trans. Commun. </journal> <volume> 38, 2 (1990), </volume> <pages> 144-147. </pages>
Reference-contexts: These algorithms use a number of messages linear in the number of edges, but they are exponential in time. The simple synchronizer would increase the message complexity to exponential. 1.1 Asynchronous Bounded Delay Networks Chou et al. <ref> [CCGZ90] </ref> proposed a network model, referred to as Asynchronous Bounded Delay networks (ABD networks). This model is weaker than the synchronous model, but stronger than the asynchronous model. It is assumed that processes have local clocks. These clocks run at the same speed, but they are not synchronized. <p> Thus, the simple synchronizer is time-optimal, but it uses a lot of messages. From now on we only consider the message-efficient type of synchronizer for ABD networks. Chou et al. <ref> [CCGZ90] </ref> presented two synchronizers. The first synchronizer has a round time of 2. To meet requirement R2, one bit is added to every basic message (i.e., every message of the simulated algorithm) as described in Theorem 2.2. <p> This extra bit is avoided in the second synchronizer, but this is paid for with a round time of 3. In this article we present a synchronizer with a round time of 2 that works without the extra bit. This clearly improves on the results of <ref> [CCGZ90] </ref>. It remained an open question, whether a round time of 2 is optimal for the message-efficient ABD synchronizers under consideration (those that exchange control messages only during initialization). We develop a mathematical model and answer this question with "yes" for some cases and with "no" for others. <p> Depending on their topology, some networks can be synchronized with a round time smaller than 2, while for others 2 is optimal. We also consider the case where clocks do not run at exactly the same speed, but instead suffer from drift. Again we improve on the results of <ref> [CCGZ90] </ref>. 3 var started p : boolean init false ; ffi pq : real for each neighbor q ; procedure INIT : (* Executed only if not started p , either spontaneously or upon receipt of the first h start i message *) begin C p := 0 ; started p <p> Algorithm 1 gives the program for an arbitrary process p. Because the receiving times of h start i messages are stored, our algorithm uses more internal storage than the algorithms in <ref> [CCGZ90] </ref>. By w p we denote the global time at which p executes IN IT , and by C (t) p we denote p's clock reading at global time t. At time w p , C p is set to 0, and we assume clocks run accurately. <p> We adhere to the original bounded delay axiom BD. 3.1 A Linear Algorithm In this section we will present an algorithm that resembles Algorithm 1. Round i is simulated at local time ffi for some ff &gt; 2. It will turn out, as in <ref> [CCGZ90] </ref>, that after a finite number of rounds a new execution of the initialization phase is necessary. The initialization phase of this algorithm (and the algorithm in Section 3.2) is the same as for Algorithm 1. <p> In the first case the synchronizer can be implemented in O (1) storage per process, in the second case storage in a process equals its degree in the network. To get a feeling of the values actually involved, and compare this algorithm with the algorithm in <ref> [CCGZ90] </ref>, we include an example computation. Assume the timers may drift a tenth of a second a day, which makes * = 1 864000 , and set ff = 7. <p> Using I1 we find that 308571 rounds can be simulated before reinitialization is necessary if an extra bit is used in messages. Using I2 we find that 154286 rounds can be simulated before reinitialization is necessary if no extra bit is used. The algorithm of <ref> [CCGZ90] </ref> simulates 142045 rounds when ff = 8, using no extra bit. (We compare with ff = 8 because already without drift the algorithm of [CCGZ90] has a round time one higer than ours, and here we aim to compute the effect of drift.) 3.2 An Exponential Algorithm In this section <p> Using I2 we find that 154286 rounds can be simulated before reinitialization is necessary if no extra bit is used. The algorithm of <ref> [CCGZ90] </ref> simulates 142045 rounds when ff = 8, using no extra bit. (We compare with ff = 8 because already without drift the algorithm of [CCGZ90] has a round time one higer than ours, and here we aim to compute the effect of drift.) 3.2 An Exponential Algorithm In this section we develop a faster algorithm to synchronize ABD networks with drifting clocks. No reinitialization will be necessary at all during simulation. <p> The synchronizers in this class use extra control messages only during the initialization phase. Our starting point was a simple synchronizer by Chou et al. <ref> [CCGZ90] </ref>. In Section 1.2 we improved on this synchronizer: in our version no extra bit in a message is necessary to determine its round number. We studied the effect of three changes in the model on the synchronizer algorithm and its performance. In Section 1.3 we studied unidirectional networks.
Reference: [LL84] <author> Lundelius, J., and Lynch, N. A. </author> <title> An upper and lower bound for clock synchronization. </title> <booktitle> Information and Control 62 (1984), </booktitle> <pages> 190-204. </pages>
Reference-contexts: It is easy to see that a process can now simulate round i at local time (1 + )i, and R1 and R2 19 are satisfied. In <ref> [LL84] </ref> it is shown that clocks in the K n cannot be synchronized tighter than within 1 1 n . This corresponds with our results in Section 2.2.
Reference: [Vit85] <author> Vit anyi, P. M. B. </author> <title> Time-driven algorithms for distributed control. </title> <type> Tech. Rep. </type> <institution> CS-R8510, Centre for Mathematics and Computer Science, </institution> <address> Amsterdam, </address> <year> 1985. </year>
Reference-contexts: A simple synchronous algorithm uses 2E messages and time D. When the simple synchronizer is used to simulate this algorithm, 2ED messages are sent in time O (D). The situation is even worse for the simulation of some recent election and spanning tree algorithms by Vitanyi <ref> [Vit85] </ref>. These algorithms use a number of messages linear in the number of edges, but they are exponential in time.
References-found: 4

