URL: ftp://ftp.ifi.unizh.ch/pub/techreports/other_docs/Executable_Specifications.ps.gz
Refering-URL: http://www.ifi.unizh.ch/staff/fuchs.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fuchs@ifi.unizh.ch  
Title: Specifications Are (Preferably) Executable The validation of software specifications with respect to explicit and implicit
Author: Norbert E. Fuchs However, Hayes and Jones [Hayes, Jones 
Address: Zurich  
Affiliation: Department of Computer Science University of  
Date: September 1992  
Note: Software Engineering Journal,  89] argue that executable specifications should be avoided because executability  
Abstract: In this paper I will argue for executable specifications by showing that nonexecutable formal specifications can be made executable on almost the same level of abstraction and without essentially changing their structure. No new algorithms have to be introduced to get executability. In many cases the combination of property-orientation and search results in specifications based on the generate-and-test approach. Furthermore, I will demonstrate that declarative specification languages allow to combine high expressiveness and executability. 
Abstract-found: 1
Intro-found: 1
Reference: [Agresti 86] <author> W. W. Agresti (Ed.), </author> <title> New Paradigms in Software Development, </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1986 </year>
Reference-contexts: To precisely and concisely define the required characteristics, specifications must be written in formal and highly expressive languages [Wing 90]. For an immediate reflection of the consequences of the specifications and for an early validation, it has been suggested that specifications should furthermore be executable <ref> [Agresti 86] </ref>. Hayes and Jones [Hayes, Jones 89] however, argue that the demands for high expressiveness and executability exclude each other, and that executable specifications should be avoided. In addition, they state that executable specifications can negatively affect implementations. <p> Especially attractive are the combinations with prototyping, and with the operational and the transformational approaches <ref> [Agresti 86] </ref>. If we combine executable specifications with the transformational approach the executable specification will form the only relevant document for all phases of software development. 2.2 Hayes' and Jones' Critique of Executable Specifications Hayes and Jones argue that executable specifications should be avoided. <p> Specifications should be expressed in terms of the problem domain, and they should be abstract, concise, and extremely readable. Implementations, on the other hand, are usually much less readable because of their amount of detail and their optimized structure. The transformational approach <ref> [Agresti 86] </ref> is an especially attractive way to generate an implementation. With the help of transformations we can gradually introduce refinements and details into an executable specification, and in this way transform it step by step into the implementation. We may even start with an incomplete specification.
Reference: [Bry 89] <author> F. Bry, </author> <title> Logic Programming as Constructivism: A Formalization and its Application to Databases, </title> <booktitle> Proc. 8th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pp. 34-50, </pages> <year> 1989 </year>
Reference: [Bundy et al. 90] <author> A. Bundy, A. Smaill, G. Wiggins, </author> <title> The Synthesis of Logic Programs from Inductive Proofs, </title> <editor> in J. W. Lloyd (Ed.), </editor> <booktitle> Computational Logic, Symposium Proceedings, </booktitle> <address> Brussels November 1990, </address> <publisher> Springer, </publisher> <year> 1990 </year>
Reference-contexts: Quine [Quine 70] defines as constructive a mathematics which is intolerant of methods affirming the existence of things of some sort without showing how to find them. Constructive methods especially constructive logics are also proposed by other researchers ([Bry 89], <ref> [Bundy et al. 90] </ref>, [Deville 90], [Flener 91], [Fribourg 90], [Lau, Prestwich 91]). 4.4 Degree of Abstraction of the Specification Borrowing a saying of Einstein's, I maintain that specifications should be as abstract as possible, but not more abstract. I see three limitations to the degree of abstraction.
Reference: [Burstall, Darlington 77] <author> R. M. Burstall, J. Darlington, </author> <title> A Transformation System for Developing Recursive Programs, </title> <journal> Journal of the ACM, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pp. 44-67, </pages> <month> January </month> <year> 1977 </year>
Reference: [Deville 90] <author> Y. Deville, </author> <title> Logic Programming, Systematic Program Development, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1990 </year>
Reference-contexts: Quine [Quine 70] defines as constructive a mathematics which is intolerant of methods affirming the existence of things of some sort without showing how to find them. Constructive methods especially constructive logics are also proposed by other researchers ([Bry 89], [Bundy et al. 90], <ref> [Deville 90] </ref>, [Flener 91], [Fribourg 90], [Lau, Prestwich 91]). 4.4 Degree of Abstraction of the Specification Borrowing a saying of Einstein's, I maintain that specifications should be as abstract as possible, but not more abstract. I see three limitations to the degree of abstraction.
Reference: [Dijkstra 76] <author> E. W. Dijkstra, </author> <title> A Discipline of Programming, </title> <publisher> Prentice Hall, </publisher> <year> 1976 </year>
Reference-contexts: Using their example I will show that their nonexecutable specification leads directly to an executable one. Hamming Numbers Hamming numbers are those natural numbers whose only prime factors are 2, 3, and 5 <ref> [Dijkstra 76] </ref>. The problem is to generate the sequence of Hamming numbers in increasing order.
Reference: [Flener 91] <author> P. Flener, </author> <title> Towards Stepwise, Schema-Guided Synthesis of Logic Programs, </title> <editor> in: K.-K. Lau, T. Clement (eds.), </editor> <booktitle> Proceedings of LOPSTR '91, </booktitle> <publisher> Springer, </publisher> <year> 1992 </year> <month> 20 </month>
Reference-contexts: Quine [Quine 70] defines as constructive a mathematics which is intolerant of methods affirming the existence of things of some sort without showing how to find them. Constructive methods especially constructive logics are also proposed by other researchers ([Bry 89], [Bundy et al. 90], [Deville 90], <ref> [Flener 91] </ref>, [Fribourg 90], [Lau, Prestwich 91]). 4.4 Degree of Abstraction of the Specification Borrowing a saying of Einstein's, I maintain that specifications should be as abstract as possible, but not more abstract. I see three limitations to the degree of abstraction.
Reference: [Fribourg 90] <author> L. </author> <title> Fribourg, Extracting logic programs from proofs that use extended Prolog execution and induction, </title> <booktitle> in: Proceedings 7th International Conference on Logic programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1990 </year>
Reference-contexts: Quine [Quine 70] defines as constructive a mathematics which is intolerant of methods affirming the existence of things of some sort without showing how to find them. Constructive methods especially constructive logics are also proposed by other researchers ([Bry 89], [Bundy et al. 90], [Deville 90], [Flener 91], <ref> [Fribourg 90] </ref>, [Lau, Prestwich 91]). 4.4 Degree of Abstraction of the Specification Borrowing a saying of Einstein's, I maintain that specifications should be as abstract as possible, but not more abstract. I see three limitations to the degree of abstraction.
Reference: [Fromherz 89] <author> M. P. J. Fromherz, </author> <title> A Survey of Executable Specification Methodologies, </title> <type> Technical Report 89.05, </type> <institution> Department of Computer Science, University of Zurich </institution>
Reference-contexts: Descriptions in natural language will be called requirements. If the formal specification language is executable there is an additional advantage: an executable specification represents not only a conceptual, but also a behavioral model of the software system to be implemented <ref> [Fromherz 89] </ref>. The behavior of the system interacting with its environment can be demonstrated and observed before it actually exists in its final form. This quality of executable specifications promises to remedy the most serious problem of software its lack of correctness and reliability. <p> Their very executability makes executable specifications an optimal communication vehicle between users and developers in their discussion of the intended system behavior. Even persons uncomfortable with formality can experience the behavior generated by executing the specifications and check whether it conforms to their intentions <ref> [Fromherz 89] </ref>. 3 Executable specifications can be embedded in various software development paradigms. Especially attractive are the combinations with prototyping, and with the operational and the transformational approaches [Agresti 86].
Reference: [Fromherz 91] <author> M. P. J. Fromherz, </author> <title> A Methodology for Executable Specifications - Combining Logic Programming, ObjectOrientation and Visualization, </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Zurich </institution>
Reference-contexts: Logic specification languages have enjoyed much interest. Accounts of research directions in logic specification languages can be found in [Goguen 86] and in [Levi 86]. Recent publications on logic specification languages are e.g. <ref> [Fromherz 91] </ref>, [Ghezzi et al. 90], [Stadler 90], [Terwilliger, Campbell 89], [Terwilliger 90], and [Ural 90]. In the following, I will express example specifications in a logic specification language for conciseness called LSL which is based on the extended Horn clause syntax proposed by Lloyd and Topor [Lloyd, Topor 84]. <p> Their specification poses a third limitation to abstraction since they have to be specified in great detail. This limitation can be partially removed if in addition to the usual predefined functions powerful I/O functions are available to specify user interfaces abstractly. Fromherz <ref> [Fromherz 91] </ref> proposes an object-oriented specification framework that provides default I/O operations which can be used as defaults, tailored to the required functionality, or replaced by custom operations. One distinguishes between property-oriented and model-oriented specifications [Wing 90]. <p> These source-to-source transformations can change data structures and algorithms, and can generate implementations that are orders of magnitude more efficient than the specification. If we succeed in automating the transformations to a large extent <ref> [Fuchs, Fromherz 91] </ref> the executable specifications will form the only relevant document for software development. In this context it is worthwhile to briefly discuss prototypes. Many people consider executable specifications as prototypes.
Reference: [Fuchs 92] <author> N. E. Fuchs, </author> <title> Hoare Logic, Executable Specifications, and Logic Programs, Structured Programming 13, </title> <booktitle> 1992, </booktitle> <pages> pp. </pages> <note> 129-135; also: Technical Report 92.02, </note> <institution> Department of Computer Science, University of Zurich </institution>
Reference-contexts: In LSL, I specify the update operation by the predicate update. The predicate is defined as an implication of the conjunction of its pre and postconditions <ref> [Fuchs 92] </ref>, and thus completely reflects Hayes' and Jones' original nonexecutable definition. update (File, Deletes, AddBefore, AddsAfter, UpdatedFile) &lt;- domain (File, DomainOfFile) % domain (File) subset (Deletes, DomainOfFile) % Deletes domain (File) domain (AddsAfter, DomainOfFile) % domain (AddsAfter) = domain (File) delete_add (File, DomainOfFile, Deletes, AddsAfter, IntermediateFile) concatenate (IntermediateFile, ConcatenatedIntermediateFile) append <p> Thus, my specification stays much closer to the original definition than Turner's specification [Turner 85] which introduces additional algorithmic details by generating and merging three streams of numbers. A recursive solution for the Hamming problem can be constructed by induction <ref> [Fuchs 92] </ref>. 3.4 NonDeterministic Operations Nondeterministic operations can produce more than one result for a given input. Hayes and Jones emphasize that the semantics of a specification language needs to cover non-determinism, even if the final implementation is deterministic.
Reference: [Fuchs, Fromherz 91] <author> N. E. Fuchs, M. Fromherz, </author> <title> Schema-Based Transformations of Logic Programs, </title> <editor> in T. P. Clement, K.-K. Lau (eds.), </editor> <title> Logic Program Synthesis and Transformations, </title> <booktitle> Proceedings of LOPSTR '91, </booktitle> <publisher> University of Manchester, Springer Verlag, </publisher> <year> 1992 </year>
Reference-contexts: These source-to-source transformations can change data structures and algorithms, and can generate implementations that are orders of magnitude more efficient than the specification. If we succeed in automating the transformations to a large extent <ref> [Fuchs, Fromherz 91] </ref> the executable specifications will form the only relevant document for software development. In this context it is worthwhile to briefly discuss prototypes. Many people consider executable specifications as prototypes.
Reference: [Gardner, Shepherdson 89] <author> P. A. Gardner, J. C. Shepherdson, </author> <title> Unfold/Fold Transformations of Logic Programs, </title> <institution> PM-89-01, School of Mathematics, University of Bristol, </institution> <year> 1989 </year>
Reference-contexts: We may even start with an incomplete specification. If the transformation steps preserve the meaning of the specification the verification of the implementation becomes unnecessary, i.e. the approach is constructive. For declarative languages the unfold/fold transformations ([Burstall, Darlington 77], [Tamaki, Sato 84], <ref> [Gardner, Shepherdson 89] </ref>) can be used. These source-to-source transformations can change data structures and algorithms, and can generate implementations that are orders of magnitude more efficient than the specification.
Reference: [Gehani 86] <author> N. Gehani, </author> <title> Specifications: Formal and Informal A Case Study, </title> <journal> Software Practice and Experience, </journal> <volume> 12, </volume> <pages> pp. 433-444, </pages> <note> 1982; reprinted in [Gehani, McGettrick 86] </note>
Reference-contexts: Traditionally, specifications have been written in natural language, but today more and more specifications are written in formal specification languages [Wing 90]. Compared with specifications in natural language, formal specifications have many advantages <ref> [Gehani 86] </ref>. Since a formal language has a well-defined syntax and a well-defined semantics, all details of a specification must be stated explicitly; thus missing, ambiguous, or inconsistent information can much easier be found.
Reference: [Gehani, McGettrick 86] <author> N. Gehani, A. D. McGettrick (Eds.), </author> <title> Software Specification Techniques, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1986 </year>
Reference: [Ghezzi et al. 90] <author> C. Ghezzi, D. Madrioli, A. Morzenti, </author> <title> TRIO: A Language for Executable Specifications of Real-Time Systems, </title> <journal> Journal of Systems and Software, </journal> <volume> 12, </volume> <pages> pp. 107-123, </pages> <year> 1990 </year>
Reference-contexts: Logic specification languages have enjoyed much interest. Accounts of research directions in logic specification languages can be found in [Goguen 86] and in [Levi 86]. Recent publications on logic specification languages are e.g. [Fromherz 91], <ref> [Ghezzi et al. 90] </ref>, [Stadler 90], [Terwilliger, Campbell 89], [Terwilliger 90], and [Ural 90]. In the following, I will express example specifications in a logic specification language for conciseness called LSL which is based on the extended Horn clause syntax proposed by Lloyd and Topor [Lloyd, Topor 84].
Reference: [Goguen 86] <author> J. A. Goguen, </author> <title> One, None, A Hundred Thousand Specification Languages, </title> <editor> in: H.-J. Kugler (Ed.), </editor> <booktitle> Information Processing 86 (IFIP), </booktitle> <publisher> Elsevier Science Publisher, </publisher> <pages> pp. 995-1003, </pages> <year> 1986 </year>
Reference-contexts: The restriction to Horn clause logic and the mechanization of proofs which lead to logic languages like Prolog makes these specifications executable [Kowalski 85]. Logic specification languages have enjoyed much interest. Accounts of research directions in logic specification languages can be found in <ref> [Goguen 86] </ref> and in [Levi 86]. Recent publications on logic specification languages are e.g. [Fromherz 91], [Ghezzi et al. 90], [Stadler 90], [Terwilliger, Campbell 89], [Terwilliger 90], and [Ural 90].
Reference: [Hayes, Jones 89] <author> I. J. Hayes, C. B. Jones, </author> <title> Specifications are not (necessarily) executable, </title> <journal> Software Engineering Journal, </journal> <volume> Vol. 4, No. 6, </volume> <pages> pp. 330-338, </pages> <month> November </month> <year> 1989 </year>
Reference-contexts: For an immediate reflection of the consequences of the specifications and for an early validation, it has been suggested that specifications should furthermore be executable [Agresti 86]. Hayes and Jones <ref> [Hayes, Jones 89] </ref> however, argue that the demands for high expressiveness and executability exclude each other, and that executable specifications should be avoided. In addition, they state that executable specifications can negatively affect implementations. <p> Some of these aspects are also addressed by Hayes and Jones. Chapter 5 summarizes the main results. In the remainder of this paper Hayes and Jones stands for <ref> [Hayes, Jones 89] </ref>. 2 Software Specifications 2.1 Executable Software Specifications A software specification should describe the required behavior of a future software system in problem-oriented terms, i.e. the specification should form a conceptual model of the system. The description should be as abstract as the requirements permit.
Reference: [Hill, Lloyd 91] <author> P. M. Hill, J. W. Lloyd, </author> <title> The Gdel Report, </title> <institution> TR-91-02, Computer Science Department, University of Bristol, </institution> <month> March </month> <year> 1991 </year>
Reference-contexts: In the following, I will express example specifications in a logic specification language for conciseness called LSL which is based on the extended Horn clause syntax proposed by Lloyd and Topor [Lloyd, Topor 84]. LSL can be considered a subset of the logic programming language Gdel <ref> [Hill, Lloyd 91] </ref>. A specification consists of a finite number of LSL statements of the form H &lt;- B. 4 where the head H is an atomic formula and the body B is a (not necessarily closed) first-order formula containing the usual connectives and quantifiers.
Reference: [Hoare 87] <author> C. A. R. Hoare, </author> <title> An overview of some formal methods for program design, </title> <journal> IEEE Computer, </journal> <volume> 20(9), </volume> <pages> pp. 85-91, </pages> <note> September 1987; reprinted in C. </note> <editor> A. R. Hoare, C. B. Jones (ed.), </editor> <booktitle> Essays in Computing Science, </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1989 </year>
Reference-contexts: During the translation I replaced the predicate by a recursive generator which generates natural numbers up to a given limit, i.e. I used a specific property of the problem to control the enumeration and to enforce termination. Hoare uses the same reasoning in his paper on formal methods <ref> [Hoare 87] </ref>. Hayes and Jones doubt the generality of this approach. They argue that it can be difficult to find such a property, and if found the property is possibly not as simple as in the example. This can actually be the case. <p> Validation means checking the correspondence between informal requirements and formal specifications. Principally, there can be no formal method to check this correspondence <ref> [Hoare 87] </ref>. This means, that we have to rely on other means to convince ourselves of the correctness of the specifications with respect to the requirements, viz. inspection, reasoning and execution. Formal, nonexecutable specifications can be validated by reasoning.
Reference: [Kemmerer et al. 87] <author> R. A. Kemmerer, S. White, A. Mili, N. Davis, </author> <title> Problem Set for the Fourth Int. </title> <booktitle> Workshop on Software Specification and Design, in: IEEE, ACM, Proc. Fourth Int. Workshop on Software Specification and Design, </booktitle> <address> Monterey, CA, </address> <month> April </month> <year> 1987, </year> <pages> pp. </pages> <address> ix-x 21 </address>
Reference-contexts: Considering that a growing percentage of the code of current programs pertains to input and output, i.e. nonfunctional behavior, the emphasis on functional behavior seems most unfortunate. There are other still relatively small specification examples, like the library data base <ref> [Kemmerer et al. 87] </ref>, that could provide a more realistic point of view.
Reference: [Kowalski 85] <author> R. A. Kowalski, </author> <title> The relation between logic programming and logic specification, </title> <editor> in: C. A. R. Hoare, J. C. Shepherdson (Eds.), </editor> <booktitle> Mathematical Logic and Programming Languages, Prentice-Hall International, </booktitle> <year> 1985 </year>
Reference-contexts: Thus declarative languages are especially suitable as specification languages. Traditionally, logic has been used as a powerful, concise, and declarative language for software specifications. The restriction to Horn clause logic and the mechanization of proofs which lead to logic languages like Prolog makes these specifications executable <ref> [Kowalski 85] </ref>. Logic specification languages have enjoyed much interest. Accounts of research directions in logic specification languages can be found in [Goguen 86] and in [Levi 86].
Reference: [Lau, Prestwich 91] <author> K.-K. Lau, S. D. Prestwich, </author> <title> Synthesis of a Family of Recursive Sorting Procedures, </title> <editor> in: V. Saraswat, K. Ueda (eds.), </editor> <booktitle> Proceedings of the 1991 International Symposium on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1991 </year>
Reference-contexts: Constructive methods especially constructive logics are also proposed by other researchers ([Bry 89], [Bundy et al. 90], [Deville 90], [Flener 91], [Fribourg 90], <ref> [Lau, Prestwich 91] </ref>). 4.4 Degree of Abstraction of the Specification Borrowing a saying of Einstein's, I maintain that specifications should be as abstract as possible, but not more abstract. I see three limitations to the degree of abstraction.
Reference: [Levi 86] <author> G. Levi, </author> <title> New Research Directions in Logic Specification Languages, </title> <editor> in: H.-J. Kugler (Ed.), </editor> <booktitle> Information Processing 86 (IFIP), </booktitle> <publisher> Elsevier Science Publisher, </publisher> <pages> pp. 1005-1008, </pages> <year> 1986 </year>
Reference-contexts: The restriction to Horn clause logic and the mechanization of proofs which lead to logic languages like Prolog makes these specifications executable [Kowalski 85]. Logic specification languages have enjoyed much interest. Accounts of research directions in logic specification languages can be found in [Goguen 86] and in <ref> [Levi 86] </ref>. Recent publications on logic specification languages are e.g. [Fromherz 91], [Ghezzi et al. 90], [Stadler 90], [Terwilliger, Campbell 89], [Terwilliger 90], and [Ural 90]. <p> If we remain on the abstraction level of nonexecutable specifications and do not introduce additional algorithms, executable specifications are often based on generate-and-test, i.e. on search ([Fuchs 92], <ref> [Levi 86] </ref>). As a consequence the execution of an executable specification is usually much less efficient than the execution of an implementation, though it may appear to be similar.
Reference: [Lloyd 87] <author> J. W. Lloyd, </author> <title> Declarative Error Diagnosis, </title> <journal> New Generation Computing, </journal> <volume> Vol. 5, No. 2, </volume> <pages> pp. 133-154, </pages> <year> 1987 </year>
Reference-contexts: Other forms of reasoning are available to prove properties of the specification and to verify it, e.g. to show its consistency. Meta-interpreters can derive information that is not directly related to specified properties, or can provide alternative proof methods. Declarative debugging <ref> [Lloyd 87] </ref> can locate the exact cause of errors. These forms of reasoning are only available because the specification is executable. But reasoning as a means for validation has also its limitations. Usually, nonfunctional behavior cannot be validated by inference, it can only be tested.
Reference: [Lloyd, Topor 84] <author> J. W. Lloyd, R. W. Topor, </author> <title> Making Prolog More Expressive, </title> <journal> Journal of Logic Programming, </journal> <volume> Vol. 1, No. 3, </volume> <pages> pp. 225-240, </pages> <year> 1984 </year>
Reference-contexts: In the following, I will express example specifications in a logic specification language for conciseness called LSL which is based on the extended Horn clause syntax proposed by Lloyd and Topor <ref> [Lloyd, Topor 84] </ref>. LSL can be considered a subset of the logic programming language Gdel [Hill, Lloyd 91]. <p> Second, the readability of the specifications is increased because LSL statements allow to state facts more directly and more concisely. In spite of their greater expressiveness, LSL statements remain within the Horn clause subset of predicate logic. In fact, Lloyd and Topor <ref> [Lloyd, Topor 84] </ref> demonstrated that statements can easily be transformed into equivalent Horn clauses provided that negation as failure is safe. The above LSL statement for the subset predicate can be transformed into the Horn clauses X Y &lt;- not p (X, Y).
Reference: [Milner et al. 90] <author> R. Milner, M. Tofte, R. Harper, </author> <title> The Definition of Standard ML, </title> <publisher> MIT Press, </publisher> <year> 1990 </year>
Reference-contexts: In each case, they argue that executable specifications are not able, or not adequate, to represent the pertinent aspect, or to solve the pertinent problem. They illustrate their arguments by a number of example specifications. 2.3 Logic Specification Languages Declarative languages, e.g. the functional language ML <ref> [Milner et al. 90] </ref> or the logic language Prolog [Sterling, Shapiro 86], state what is to be computed in a form that is largely independent of how the computation is performed.
Reference: [O'Keefe 90] <author> R. A. O'Keefe, </author> <title> The Craft of Prolog, </title> <publisher> MIT Press, </publisher> <year> 1990 </year>
Reference-contexts: This can actually be the case. On the other hand, it is always possible to enforce the termination of an enumeration by an educated guess. A similar guessing is used in limited depth-first search. Iterative deepening shows how the guessing can even be automated <ref> [O'Keefe 90] </ref>. 3.2 Specifying by Inverse Sometimes it is impossible to specify an unknown function directly in terms of given functions. Hayes and Jones state that in this case the function can possibly be specified indirectly by constraining its inverse by available functions.
Reference: [Partsch 90] <author> H. A. Partsch, </author> <title> Specification and Transformation of Programs, A Formal Approach to Software Development, </title> <publisher> Springer Verlag, </publisher> <year> 1990 </year>
Reference-contexts: Generators are usually recursively defined, though for a finite domain its extension could be used. Some recursive generators need upper limits to ensure termination of the specification. Transformations that make nonexecutable specifications executable are also discussed by Partsch <ref> [Partsch 90] </ref>. Executable specifications generated in this way are direct translations of their nonexecutable counterparts. Since they are built from available powerful predicates they are property-oriented, declarative, and highly abstract, though the addition of constructive elements results in a level of abstraction slightly lower than that of nonexecutable specifications.
Reference: [Quine 70] <author> W. V. O. Quine, </author> <title> Philosophy of Logic, </title> <publisher> Prentice-Hall, </publisher> <year> 1970. </year>
Reference-contexts: I am convinced that a specification as an abstract definition of something that will have to be concretely realized must be constructive in the sense of constructive mathematics. Quine <ref> [Quine 70] </ref> defines as constructive a mathematics which is intolerant of methods affirming the existence of things of some sort without showing how to find them.
Reference: [Stadler 90] <author> R. Stadler, </author> <title> Ausfhrbare Beschreibung von Directory-Systemen - Prolog-basierte Spezifikation der Architektur von Directory-Systemen, </title> <type> PhD thesis, </type> <institution> Department of Computer Science, </institution> <note> University of Zurich; also to appear in the Informatik-Fachberichte series, Springer, </note> <year> 1991) </year>
Reference-contexts: Logic specification languages have enjoyed much interest. Accounts of research directions in logic specification languages can be found in [Goguen 86] and in [Levi 86]. Recent publications on logic specification languages are e.g. [Fromherz 91], [Ghezzi et al. 90], <ref> [Stadler 90] </ref>, [Terwilliger, Campbell 89], [Terwilliger 90], and [Ural 90]. In the following, I will express example specifications in a logic specification language for conciseness called LSL which is based on the extended Horn clause syntax proposed by Lloyd and Topor [Lloyd, Topor 84].
Reference: [Sterling, Shapiro 86] <author> L. Sterling, E. Shapiro, </author> <title> The Art of Prolog, Advanced Programming Techniques, </title> <publisher> MIT Press, </publisher> <year> 1986 </year>
Reference-contexts: They illustrate their arguments by a number of example specifications. 2.3 Logic Specification Languages Declarative languages, e.g. the functional language ML [Milner et al. 90] or the logic language Prolog <ref> [Sterling, Shapiro 86] </ref>, state what is to be computed in a form that is largely independent of how the computation is performed. Declarative languages are based on sound mathematical foundations, have well-defined semantics, permit descriptions at a very high level of abstraction, and are referentially transparent.
Reference: [Stolze et al. 91] <author> M. Stolze, M. Gutknecht, R. Pfeifer, </author> <title> Integrated Knowledge Acquisition: Toward Adaptive Expert System Design, </title> <type> Technical Report 91.04, </type> <institution> Department of Computer Science, University of Zurich </institution>
Reference-contexts: As experience shows, these problems of knowledge acquisition become even worse when several people are involved since everyone may have different ideas about the undocumented information. We can explicitly acknowledge that an application field is ill-defined, and use an evolutionary approach to develop a system <ref> [Stolze et al. 91] </ref>. We start by implementing only a part of the system, and let users work with this partial system. From the experience gained we derive further requirements, and augment the system until we are satisfied.
Reference: [Tamaki, Sato 84] <author> H. Tamaki, T. Sato, </author> <title> Unfold/Fold Transformation of Logic Programs, </title> <booktitle> Proc. of the Second Internatl. Conference on Logic Programming, S.-. Trnlund (Ed.), </booktitle> <pages> pp. 127-138, </pages> <year> 1984 </year>
Reference-contexts: We may even start with an incomplete specification. If the transformation steps preserve the meaning of the specification the verification of the implementation becomes unnecessary, i.e. the approach is constructive. For declarative languages the unfold/fold transformations ([Burstall, Darlington 77], <ref> [Tamaki, Sato 84] </ref>, [Gardner, Shepherdson 89]) can be used. These source-to-source transformations can change data structures and algorithms, and can generate implementations that are orders of magnitude more efficient than the specification.
Reference: [Terwilliger, Campbell 89] <author> R. B. Terwilliger, R. H. Campbell, </author> <title> PLEASE: Executable Specifications for Incremental Software Development, </title> <journal> Journal of Systems and Software, </journal> <volume> 10, </volume> <pages> pp. 97-112, </pages> <year> 1989 </year>
Reference-contexts: Logic specification languages have enjoyed much interest. Accounts of research directions in logic specification languages can be found in [Goguen 86] and in [Levi 86]. Recent publications on logic specification languages are e.g. [Fromherz 91], [Ghezzi et al. 90], [Stadler 90], <ref> [Terwilliger, Campbell 89] </ref>, [Terwilliger 90], and [Ural 90]. In the following, I will express example specifications in a logic specification language for conciseness called LSL which is based on the extended Horn clause syntax proposed by Lloyd and Topor [Lloyd, Topor 84].
Reference: [Terwilliger 90] <author> R. B. Terwilliger, </author> <title> An Overview and Bibliography of ENCOMPASS, an Environment for Incremental Software Development Using Executable, Logic-Based Specifications, </title> <booktitle> ACM SIGSOFT, Software Engineering Notes, </booktitle> <volume> Vol. 15, No. 1, </volume> <pages> pp. 93-94, </pages> <month> January </month> <year> 1990 </year>
Reference-contexts: Logic specification languages have enjoyed much interest. Accounts of research directions in logic specification languages can be found in [Goguen 86] and in [Levi 86]. Recent publications on logic specification languages are e.g. [Fromherz 91], [Ghezzi et al. 90], [Stadler 90], [Terwilliger, Campbell 89], <ref> [Terwilliger 90] </ref>, and [Ural 90]. In the following, I will express example specifications in a logic specification language for conciseness called LSL which is based on the extended Horn clause syntax proposed by Lloyd and Topor [Lloyd, Topor 84].
Reference: [Turner 85] <author> D. A. Turner, </author> <title> Functional programs as executable specifications, </title> <editor> in: C. A. R. Hoare, J. C. Shepherdson (Eds.), </editor> <booktitle> Mathematical Logic and Programming Languages, Prentice-Hall International, </booktitle> <year> 1985 </year> <month> 22 </month>
Reference-contexts: Thus, my specification stays much closer to the original definition than Turner's specification <ref> [Turner 85] </ref> which introduces additional algorithmic details by generating and merging three streams of numbers. A recursive solution for the Hamming problem can be constructed by induction [Fuchs 92]. 3.4 NonDeterministic Operations Nondeterministic operations can produce more than one result for a given input.
Reference: [Ural 90] <author> H. Ural, </author> <title> Specifications of Distributed Systems in Prolog, </title> <journal> Journal of Systems and Software, </journal> <volume> 11, </volume> <pages> pp. 143-154, </pages> <year> 1990 </year>
Reference-contexts: Logic specification languages have enjoyed much interest. Accounts of research directions in logic specification languages can be found in [Goguen 86] and in [Levi 86]. Recent publications on logic specification languages are e.g. [Fromherz 91], [Ghezzi et al. 90], [Stadler 90], [Terwilliger, Campbell 89], [Terwilliger 90], and <ref> [Ural 90] </ref>. In the following, I will express example specifications in a logic specification language for conciseness called LSL which is based on the extended Horn clause syntax proposed by Lloyd and Topor [Lloyd, Topor 84].
Reference: [Wing 90] <author> J. M. Wing, </author> <title> A Specifier's Introduction to Formal Methods, </title> <journal> IEEE Computer, </journal> <volume> Vol. 7, No. 5, </volume> <pages> pp. 8-24, </pages> <month> September </month> <year> 1990 </year>
Reference-contexts: As formalized expressions of the requirements, specifications stand at the borderline between informal and formal descriptions of an application area. To precisely and concisely define the required characteristics, specifications must be written in formal and highly expressive languages <ref> [Wing 90] </ref>. For an immediate reflection of the consequences of the specifications and for an early validation, it has been suggested that specifications should furthermore be executable [Agresti 86]. <p> The description should be as abstract as the requirements permit. This is only possible if the specification language is sufficiently powerful to express the required behavior adequately. Traditionally, specifications have been written in natural language, but today more and more specifications are written in formal specification languages <ref> [Wing 90] </ref>. Compared with specifications in natural language, formal specifications have many advantages [Gehani 86]. Since a formal language has a well-defined syntax and a well-defined semantics, all details of a specification must be stated explicitly; thus missing, ambiguous, or inconsistent information can much easier be found. <p> Fromherz [Fromherz 91] proposes an object-oriented specification framework that provides default I/O operations which can be used as defaults, tailored to the required functionality, or replaced by custom operations. One distinguishes between property-oriented and model-oriented specifications <ref> [Wing 90] </ref>. A property-oriented specification defines the behavior of a system indirectly by a set of properties in the form of axioms that the system must satisfy. A model-oriented specification defines the behavior of a system directly by constructing a model of the system.
Reference: [Zave 82] <author> P. Zave, </author> <title> An Operational Approach to Requirements Specification for Embedded Systems, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-8, No. 3, </volume> <pages> pp. 250-269, </pages> <note> May 1982; reprinted in [Agresti 86] and [Gehani, McGettrick 86] </note>
Reference-contexts: Implementations, on the other hand, should efficiently generate the specified behavior in the targeted environment using all available algorithms and data structures. This view is shared by Zave and Yeh ([Zave, Yeh 81], <ref> [Zave 82] </ref>) who state that the borderline between executable specifications and implementations is resource management. Specifications should only specify the functional and performance properties of the proposed system. Implementations, however, have to meet performance goals in the intended environment by an optimal use of resources.
Reference: [Zave, Yeh 81] <author> P. Zave, R. T. Yeh, </author> <title> Executable Requirements Specification for Embedded Systems, </title> <booktitle> Proceedings of the 5th International Conference on Software Engineering, </booktitle> <pages> pp. 295-304, </pages> <address> San Diego, </address> <note> 1981; reprinted in [Gehani, McGettrick 86] </note>
References-found: 41

