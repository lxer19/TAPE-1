URL: http://www.isi.edu/sims/minton/papers/final-paper-with-fig.ps
Refering-URL: http://www.isi.edu/sims/minton/homepage.html
Root-URL: 
Title: Automatically Configuring Constraint Satisfaction Programs: A Case Study  
Author: STEVEN MINTON 
Keyword: constraint satisfaction algorithms, machine learning, configurable systems  
Address: 4676 Admiralty Way, Marina del Rey, CA 90292  
Affiliation: USC Information Sciences Institute,  
Note: TO APPEAR IN Constraints, Volume 1, Number 1, pages unknown, 1-40 (1996) c 1996 Kluwer Academic Publishers, Boston. Manufactured in The Netherlands.  
Email: minton@isi.edu  
Date: Received  
Abstract: Multi-tac is a learning system that synthesizes heuristic constraint satisfaction programs. The system takes a library of generic algorithms and heuristics and specializes them for a particular application. We present a detailed case study with three different distributions of a single combinatorial problem, "Minimum Maximal Matching", and show that Multi-tac can synthesize programs for these different distributions that perform on par with hand-coded programs and that exceed the performance of some well-known satisfiability algorithms. In synthesizing a program, Multi-tac bases its choice of heuristics on an instance distribution, and we demonstrate that this capability has a significant impact on the results. 
Abstract-found: 1
Intro-found: 1
Reference: <author> J. Allen and S. Minton. </author> <title> Selecting the right heuristic algorithm: Runtime performance predictors. </title> <booktitle> In Proceedings of the Canadian AI Conference, </booktitle> <year> 1996. </year>
Reference-contexts: For certain families of heuristic algorithms, we have found that we can predict which algorithm will do best after running each of them for a very short time <ref> (Allen and Minton, 1996) </ref>. We do this by identifying "secondary performance characteristics" that tell us whether the heuristic is having a positive effect. If this approach generalizes, we can incorporate similar methods into Multi-tac, so that significantly harder problems can be solved.
Reference: <author> D. Barstow. </author> <title> Automatic programming for device-control software. In M.R. </title> <editor> Lowry and R.D. McCartney, editors, </editor> <title> Automating Software Design. </title> <publisher> AAAI Press, </publisher> <year> 1991. </year>
Reference-contexts: While all of the research projects we have mentioned have addressed the problem of tailoring general algorithms to particular applications, none have used machine learning to assist in the customization. Many program synthesis systems make domain-specific design decisions, but the decision-making process is often guided interactively by the user <ref> (as in Smith, 1991 and Barstow, 1991) </ref> or guided by heuristic rules given in advance by the system designers (Setliff, 1991; Kant et al., 1991). Few systems explicitly search through the space of possible designs.
Reference: <author> J. Bitner and E.M. Reingold. </author> <title> Backtrack programming techniques. </title> <journal> Communications of the ACM, </journal> <volume> 18 </volume> <pages> 651-655, </pages> <year> 1975. </year>
Reference: <author> W. Braudaway and C. Tong. </author> <title> Automated synthesis of constrained generators. </title> <booktitle> In Proceedings of the Eleventh International Joint Conference on Artificial Intelligence, </booktitle> <year> 1989. </year>
Reference: <author> D. Brelaz. </author> <title> New methods to color the vertices of a graph. </title> <journal> Communications of the ACM, </journal> <volume> 22 </volume> <pages> 251-256, </pages> <year> 1979. </year>
Reference: <author> J. Carbonell, O. Etzioni, Y. Gil, R. Joseph, C. Knoblock, S. Minton, and M. Veloso. </author> <title> Planning and learning in Prodigy: Overview of an integrated archetecture. </title> <editor> In A. Ram and D.B. Leake (Eds.), editors, </editor> <title> Goal Driven Learning. </title> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Configuration Plasticity Configurable systems come in many varieties <ref> (Carbonell et al., 1995) </ref>. One of the dimensions along which they can be characterized is their plasticity. Some systems are relatively rigid, in that they can be configured only in very limited ways.
Reference: <editor> P. R. Cohen and E. A. Feigenbaum, editors. </editor> <booktitle> The Handbook of Artificial Intelligence, Volume III, </booktitle> <volume> volume Volume 3. </volume> <publisher> William Kaufmann, Inc., </publisher> <address> Los Altos, California, </address> <year> 1982. </year>
Reference-contexts: Each configuration corresponds to an algorithm schema plus a list of search control rules and mechanism flags. The space of possible configurations is exponential in the number of available control rules and flags. Since this space is much too large to search exhaustively, Multi-tac employs a beam search <ref> (Cohen and Feigenbaum, 1982) </ref>, a form of parallel hill-climbing that heuristically searches only a small portion of the space. 13 The beam search takes a beam width B, a set of training instances, and an instance time bound T .
Reference: <author> J.M. Crawford and L.D. Auton. </author> <title> Experimental results on the crossover point in satisfiability problems. </title> <booktitle> In Proceedings of the Eleventh National Conference on Artificial Intelligence, </booktitle> <year> 1993. </year>
Reference: <author> J.M. Crawford and L.D. Auton. </author> <title> Experimental results on the crossover point in random 3SAT. </title> <note> To Appear in Artificial Intelligence, 1996. 39 M. </note> <author> Davis, G. Logemann, and D. Loveland. </author> <title> A machine program for theorem proving. </title> <journal> CACM, </journal> <year> 1962. </year>
Reference: <author> D.S. Day. </author> <title> Learning variable descriptors for applying heuristics across CSP problems. </title> <booktitle> In Proceedings of the Machine Learning Workshop, </booktitle> <year> 1991. </year>
Reference: <author> G.F. DeJong and R. Mooney. </author> <title> Explanation-based learning: An alternative view. </title> <journal> Machine Learning, </journal> <volume> 1(2), </volume> <year> 1986. </year>
Reference: <author> T. </author> <title> Ellman. Abstraction via approximate symmetry. </title> <booktitle> In Proceedings of the Thirteenth International Joint Conference on Artificial Intelligence, </booktitle> <year> 1993. </year>
Reference: <author> O. Etzioni and R. Etzioni. </author> <title> Statistical methods for analyzing speedup learning experiments. </title> <journal> Machine Learning, </journal> <volume> 14(3) </volume> <pages> 333-347, </pages> <year> 1993. </year>
Reference: <author> D. Fisher, D. Subramanian, and P. </author> <title> Tadepalli, </title> <editor> editors. </editor> <booktitle> Proceedings of the Third International Workshop on Knowledge Compilation and Speedup Learning, </booktitle> <year> 1993. </year>
Reference-contexts: For comparative purposes, we also tested a simple backtracking algorithm on the same distribution. This was essentially Multi-tac's backtracking algorithm without any heuristics, i.e., the "empty" configuration. This serves as a baseline against which we can evaluate Multi-tac as a "speedup learning" system <ref> (c.f., Fisher, Subramanian, and Tadepalli, 1993) </ref>. Table 1, Distribution1, shows the results on 100 randomly generated instances of the mmm problem, with a 10-cpu-second time bound per instance.
Reference: <author> Z. Galil. </author> <title> Efficient algorithms for finding maximum matchings in graphs. </title> <journal> Computing Surveys, </journal> <volume> 18(1), </volume> <year> 1986. </year>
Reference: <author> M.R. Garey and D.S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. W.H. </title> <publisher> Freeman and Co., </publisher> <year> 1979. </year>
Reference-contexts: Moreover, we did not specially engineer Multi-tac to solve the mmm problem, nor did we do any deep analysis of the problem before embarking on this case study. We selected mmm <ref> (from a list of NP-hard problems, Garey and Johnson, 1979) </ref> both because it was reasonably straightforward to specify in our constraint language and because we were unfamiliar with it. We wanted to avoid any possibility that the problem might have influenced the design of the system.
Reference: <author> J. Gratch. </author> <title> On efficient approaches to the utility problem in adaptive problem solving. </title> <type> Technical Report 1916, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana, Illinois, </institution> <year> 1995. </year>
Reference: <author> J Gratch and G. DeJong. </author> <title> A hybrid approach to guaranteed effective control strategies. </title> <booktitle> In Proceedings of the Eighth International Machine Learning Workshop, </booktitle> <year> 1991. </year>
Reference: <author> K. Kahn. </author> <title> Partial evaluation as an example of the relationship between programming methodology and AI. </title> <journal> AI Magazine, </journal> <volume> 5(1), </volume> <year> 1984. </year>
Reference-contexts: The use of program transformations, including partial evaluation and unfolding, is common in program synthesis systems and compilers <ref> (Kahn, 1984) </ref>; the types of transformations used in Multi-tac were also motivated by previous work in the area of knowledge compilation (e.g., Mostow, 1991; Tong, 1991; Braudaway and Tong, 1989). 36 Several program synthesis systems have been used to generate combinatorial search programs.
Reference: <author> E. Kant, F. Daube, W. MacGregor, and J. Wald. </author> <title> Automatic programming for device-control software. In M.R. </title> <editor> Lowry and R.D. McCartney, editors, </editor> <title> Automating Software Design. </title> <publisher> AAAI Press, </publisher> <year> 1991. </year>
Reference: <author> V. Kumar. </author> <title> Algorithms for constraint satisfaction problems. </title> <journal> AI Magazine, </journal> <volume> 13, </volume> <year> 1992. </year>
Reference-contexts: Figure 3 shows a simplified pseudo-code description of Multi-tac's backtracking schema. The schema refers to rules for variable ordering, value ordering, and pruning that can be used to direct the search process. There are also flags that control whether heuristic mechanisms such as forward checking <ref> (Kumar, 1992) </ref> are used. Once the rules, flags, and problem constraints are given, the schema can be optimized via partial evaluation.
Reference: <author> O. Lassila and S.F. Smith. </author> <title> Flexible, constraint-based tools for complex scheduling applications. </title> <booktitle> In Proceedings of the 4th Annual Dual-Use Technologies and Applications Conference, </booktitle> <pages> pages 131-138, </pages> <year> 1994. </year>
Reference: <author> J.L. Lauriere. </author> <title> A language and a program for stating and solving combinatorial problems. </title> <journal> Artificial Intelligence, </journal> <volume> 10 </volume> <pages> 29-127, </pages> <year> 1978. </year>
Reference-contexts: Nevertheless, there is a small, but growing, body of work in the area of constraint compilation that is related in spirit to the work presented here. The most related systems are the COASTOOL system (Yoshikawa et al., 1994) (and its predecessor, Yoshikawa and Wada, 1992), the ALICE system <ref> (Lauriere, 1978) </ref>, and Ellman's (1993) abstraction problem solver. All take declarative descriptions of CSPs and compile specialized algorithms for solving them. However, none of these compilers search for the best configuration, so they have a very different emphasis.
Reference: <author> S. Minton. </author> <title> Learning Search Control Knowledge: An Explanation-based Approach. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, Massachusetts, </address> <year> 1988. </year>
Reference: <author> S. Minton. </author> <title> Quantitative results concerning the utility of explanation-based learning. </title> <journal> Artificial Intelligence, </journal> <volume> 42, </volume> <year> 1990. </year>
Reference-contexts: GSAT Results As alluded to earlier, we also tested GSAT (Selman, Levesque, and Mitchell, 1992), a heuristic iterative repair algorithm <ref> (Minton et al., 1990) </ref>, on our three distributions. GSAT begins with an initialization phase, in which all variables are assigned an initial value. In the repair phase, each iteration involves choosing a variable and flipping its value.
Reference: <author> S. Minton. </author> <title> An analytic learning system for specializing heuristics. </title> <booktitle> In Proceedings of the Thirteenth International Joint Conference on Artificial Intelligence, </booktitle> <year> 1993. </year>
Reference-contexts: The sorting process produces a total order, whereas the control rules may only induce a partial order. 11. The experimental results were all produced using Multi-tac 1.0 <ref> (as reported in Minton, 1993) </ref>. This version of Multi-tac did not include the method for pre-sorting semi-static rules, described in Section 6.2. Thus only static rules were pre-sorted. In addition, Multi-tac 1.0 used only the analytic method for generating rules.
Reference: <author> S. Minton. </author> <title> Integratingheuristics for constraint satisfactionproblems: A case study. </title> <booktitle> In Proceedings of the Eleventh National Conference on Artificial Intelligence, </booktitle> <year> 1993. </year>
Reference-contexts: The sorting process produces a total order, whereas the control rules may only induce a partial order. 11. The experimental results were all produced using Multi-tac 1.0 <ref> (as reported in Minton, 1993) </ref>. This version of Multi-tac did not include the method for pre-sorting semi-static rules, described in Section 6.2. Thus only static rules were pre-sorted. In addition, Multi-tac 1.0 used only the analytic method for generating rules.
Reference: <author> S. Minton, M. Johnston, A.B. Philips, and P. Laird. </author> <title> Minimizing conflicts: A heuristic repair method for constraint satisfaction and scheduling problems. </title> <journal> Artificial Intelligence, </journal> <volume> 58 </volume> <pages> 161-205, </pages> <year> 1992. </year>
Reference-contexts: Two algorithm schemas are currently implemented in Multi-tac: a backtracking schema and a more recently developed iterative repair <ref> (Minton et al., 1992) </ref> schema. We are also developing a branch-and-bound schema. 3 All of these schemas can be configured to produce either an "optimizing" or a "satisfying" algorithm.
Reference: <author> S. Minton and I. Underwood. </author> <title> Small is beautiful: A brute-force approach to learning first-order formulas. </title> <booktitle> In Proceedings of the Twelfth National Conference on Artificial Intelligence, </booktitle> <year> 1994. </year>
Reference-contexts: Thus, the useful rules often tend to be relatively small <ref> (Minton and Underwood, 1994) </ref>. <p> In a comparison of the inductive and analytic learning components <ref> (Minton and Underwood, 1994) </ref>, we found that the two components tend to complement one another, because they have different strengths. In many cases, the inductive component will generate a small rule that the analytic component missed, because the analytic component considers only a limited set of specializations.
Reference: <author> T. Mitchell, R. Keller, and S. Kedar-Cabelli. </author> <title> Explanation-based generalization: A unifying view. </title> <journal> Machine Learning, </journal> <volume> 1(1) </volume> <pages> 47-80, </pages> <year> 1986. </year>
Reference: <author> T. M. Mitchell. </author> <title> The need for biases in learning generalizations. </title> <type> Technical Report CBM-TR-117, </type> <institution> Rutgers University, </institution> <year> 1980. </year>
Reference-contexts: The generator produces only well-formed formulas expressible in a subset of the constraint language; this is referred to as a language bias <ref> (Mitchell, 1980) </ref>. While the sublanguage allows for an arbitrary number of quantifiers and variables, and includes all the built-in and user-defined (i.e., problem-specific) relations, the only constants and integers allowed are those mentioned in the problem specification.
Reference: <author> D. J. Mostow. </author> <title> Machine transformation of advice into a heuristic search procedure. </title> <booktitle> In Machine Learning, An Artificial Intelligence Approach, </booktitle> <pages> pages 367-403. </pages> <publisher> Tioga Press, </publisher> <address> Palo Alto, CA, </address> <year> 1983. </year>
Reference-contexts: For instance, a variable score rule can have the form "If (P score var) then (Assign-Positive-Score score var)", where (P score var) is a formula that is true if variable var should be assigned positive score score. 4 Multi-tac acquires control rules for a problem domain by operationalizing generic heuristics <ref> (Mostow, 1983) </ref>. The generic heuristics are relatively inefficient to execute, and therefore they cannot be used directly. The operationalization process converts these inefficient generic heuristics into domain-specific control rules that are more efficient to execute.
Reference: <author> J. Mostow. </author> <title> A transformational approach to knowledge compilation. In M.R. </title> <editor> Lowry and R.D. McCartney, editors, </editor> <title> Automating Software Design. </title> <publisher> AAAI Press, </publisher> <year> 1991. </year>
Reference: <author> P.W. Purdom, Jr. </author> <title> Search rearrangement backtracking and polynomial average time. </title> <journal> Artificial Intelligence, </journal> <volume> 21 </volume> <pages> 117-133, </pages> <year> 1983. </year> <note> 40 B. </note> <author> Selman, H. Levesque, and D. Mitchell. </author> <title> A new method for solving hard satisfiability problems. </title> <booktitle> In Proceedings of the Tenth National Conference on Artificial Intelligence, </booktitle> <address> San Jose, CA, </address> <year> 1992. </year>
Reference: <author> D. E. Setliff. </author> <title> On the automatic selection of data structure and algorithms. In M.R. </title> <editor> Lowry and R.D. McCartney, editors, </editor> <title> Automating Software Design. </title> <publisher> AAAI Press, </publisher> <year> 1991. </year>
Reference: <author> D. R. Smith and E. A. </author> <title> Parra. Transformational approach to transportation scheduling. </title> <booktitle> In Proceedings of the Eighth Conference on Knowledge-Based Software Engineering, </booktitle> <year> 1993. </year>
Reference-contexts: For instance, kids was used to develop a transportation scheduler that significantly outperforms more general schedulers <ref> (Smith and Parra, 1993) </ref>, illustrating the benefits of domain-specific customization. Srinivasan and Sterling (1993) presented a framework for tailoring a generic scheduler to particular scheduling domains.
Reference: <author> D.R. Smith. KIDS: </author> <title> A knowledge-based software development system. In M.R. </title> <editor> Lowry and R.D. McCartney, editors, </editor> <title> Automating Software Design. </title> <publisher> AAAI Press, </publisher> <year> 1991. </year>
Reference-contexts: An algorithm schema is a high-level, abstract algorithm description that can be automatically refined to produce an application-specific algorithm. Our concept of an algorithm schema was adopted from the kids algorithm synthesis system <ref> (Smith, 1991) </ref>. In kids, the schemas are based on mathematical abstractions, and a formal transformation process (guided by a human) is used to derive an algorithm from an algorithm schema. <p> However, none of these compilers search for the best configuration, so they have a very different emphasis. Insofar as Multi-tac's program synthesis methods are concerned, our approach was motivated by work in automated software design, most notably Smith's kids system <ref> (Smith, 1991) </ref>, which employs algorithm schemas as the framework for program refinement. <p> While all of the research projects we have mentioned have addressed the problem of tailoring general algorithms to particular applications, none have used machine learning to assist in the customization. Many program synthesis systems make domain-specific design decisions, but the decision-making process is often guided interactively by the user <ref> (as in Smith, 1991 and Barstow, 1991) </ref> or guided by heuristic rules given in advance by the system designers (Setliff, 1991; Kant et al., 1991). Few systems explicitly search through the space of possible designs.
Reference: <author> T. E. Smith and D. E. Setliff. </author> <title> Knowledge-based constraint-driven software synthesis. </title> <booktitle> In Proceedings of the Seventh Conference on Knowledge-Based Software Engineering, </booktitle> <year> 1992. </year>
Reference: <author> R.M. Smullyan. </author> <title> First Order Logic. </title> <publisher> Springer Verlag New York Inc., </publisher> <year> 1968. </year>
Reference: <author> V. Srinivasan and L. Sterling. </author> <title> A knowledge based framework for developing and customizing schedulers. </title> <booktitle> In Proceedings of the Eighth Conference on Knowledge-Based Software Engineering, </booktitle> <year> 1993. </year>
Reference: <author> C. Tong. </author> <title> A divide and conquer approach to knowledge compilation. In M.R. </title> <editor> Lowry and R.D. McCartney, editors, </editor> <title> Automating Software Design. </title> <publisher> AAAI Press, </publisher> <year> 1991. </year>
Reference: <author> J.S. Turner. </author> <title> Almost all k-colorable graphs are easy to color. </title> <journal> Journal of Algorithms, </journal> <volume> 9 </volume> <pages> 63-82, </pages> <year> 1988. </year>
Reference: <author> P. Van Hentenryk, Y. Deville, and C-M. Teng. </author> <title> A generic arc-consistency algorithm and its specializations. </title> <journal> Artificial Intelligence, </journal> <volume> 57 </volume> <pages> 291-321, </pages> <year> 1992. </year>
Reference-contexts: The idea of specializing generic constraint satisfaction algorithms for particular applications is itself not new. For instance, the AC-5 algorithm <ref> (Van Hentenryk, Deville, and Teng, 1992) </ref> is a generic arc-consistency method that can be specialized for functional, anti-functional or monotonic constraints to improve efficiency. Various "toolbox" systems have been proposed as frameworks for creating specialized algorithms, such as Lassila and Smith's (1994) ditops transportation scheduling system.
Reference: <author> M. Yoshikawa, K. Kaneko, Y. Nomura, and M. Watanabe. </author> <title> A constraint-based approach to high school timetabling problems: A case study. </title> <booktitle> In Proceedings of the Twelfth National Conference on Artificial Intelligence, </booktitle> <year> 1994. </year>
Reference-contexts: Nevertheless, there is a small, but growing, body of work in the area of constraint compilation that is related in spirit to the work presented here. The most related systems are the COASTOOL system <ref> (Yoshikawa et al., 1994) </ref> (and its predecessor, Yoshikawa and Wada, 1992), the ALICE system (Lauriere, 1978), and Ellman's (1993) abstraction problem solver. All take declarative descriptions of CSPs and compile specialized algorithms for solving them.
Reference: <author> M. Yoshikawa and S. Wada. </author> <title> Constraint satisfaction with multi-dimensional domain. </title> <booktitle> In Proceedings of the First International Conference on Planning Systems, </booktitle> <year> 1992. </year>
Reference-contexts: As we have pointed out, mmm is relatively simple to specify, in that the resulting specification is relatively concise. But some problems require more complex specifications. For instance, in a multidimensional crew-scheduling problem <ref> (Yoshikawa and Wada, 1992) </ref>, one might have to assign crew members to tasks and tasks to time slots. Thus there are two "types" of variables. <p> Nevertheless, there is a small, but growing, body of work in the area of constraint compilation that is related in spirit to the work presented here. The most related systems are the COASTOOL system (Yoshikawa et al., 1994) <ref> (and its predecessor, Yoshikawa and Wada, 1992) </ref>, the ALICE system (Lauriere, 1978), and Ellman's (1993) abstraction problem solver. All take declarative descriptions of CSPs and compile specialized algorithms for solving them. However, none of these compilers search for the best configuration, so they have a very different emphasis.
Reference: <author> M. Zweben, E. Davis, B. Daun, E. Drascher, M. Deale, and M. Eskey. </author> <title> Learning to improve constraint-based scheduling. </title> <journal> Artificial Intelligence, </journal> <volume> 58 </volume> <pages> 271-296, </pages> <year> 1992. </year> <note> Received Date Accepted Date Final Manuscript Date </note>
References-found: 46

