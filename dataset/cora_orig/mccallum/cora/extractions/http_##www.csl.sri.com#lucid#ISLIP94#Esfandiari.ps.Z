URL: http://www.csl.sri.com/lucid/ISLIP94/Esfandiari.ps.Z
Refering-URL: http://www.csl.sri.com/lucid/ISLIP94/electronic-proceedings.html
Root-URL: 
Email: fard@dcs.qmw.ac.uk  
Title: Isomorphisms between Two Groupoids An Experiment in Program Synthesis and Transformation  
Author: F Esfandiari 
Date: November 8, 1994  
Address: London  
Affiliation: Dept. of Computer Science Queen Mary and Westfield College University of  
Abstract: The research work which comes under the heading `program transformation' started in the seventies. The term coveres both the conversion of specifications to runnable programs (though the term `program synthesis' is sometimes preferred here) and also the conversion of existing programs into equivalent and more efficient ones. Our main concern in this paper is on transforming programs, in particular finding efficient programs. The problem of finding the isomorphisms between two finite groupoids has been considered. Initially, by using unfold/fold method, a program for this problem is derived from its definition which then leads to the efficient program by using promotion (fusion), unfold/fold method and necessary proved lemmas. We show that during the process of both synthesis and transformation there are some stages for which we need some lemmas to proceed on. Then generalizations of these lemmas are proved. 
Abstract-found: 1
Intro-found: 1
Reference: [BrD77] <author> Burstall R.M. and Darlington J.: </author> <title> A Transformation System for Developing Recursive Programs. </title> <journal> Journal of the ACM, </journal> <volume> 24, 1, </volume> <pages> pp. </pages> <month> 44-67 </month> <year> (1977). </year>
Reference-contexts: Our main concern in this paper is on transforming programs, in particular finding efficient programs. Many different tactics have been suggested for program transformation. Three of them should be mentioned here, as unfold/fold <ref> [BrD77] </ref>, accumulation [B84], and [B88] and promotion [W88], [C90] and [B88]. In the first section a problem will be defined and a program will be derived from its definition. In the second section the derived program is transformed to an efficient one via a series of steps.
Reference: [B84] <author> Bird R.S.: </author> <title> The promotion and Accumulation Strategies in Transformational Programming. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6, 4, </volume> <year> (1984). </year>
Reference-contexts: Our main concern in this paper is on transforming programs, in particular finding efficient programs. Many different tactics have been suggested for program transformation. Three of them should be mentioned here, as unfold/fold [BrD77], accumulation <ref> [B84] </ref>, and [B88] and promotion [W88], [C90] and [B88]. In the first section a problem will be defined and a program will be derived from its definition. In the second section the derived program is transformed to an efficient one via a series of steps.
Reference: [B88] <author> Bird R.S.: </author> <title> Lectures on Constructive Functional Programming. </title> <type> Technical Monograph PRG-69, </type> <institution> Oxford University Computing Laboratory, Programming Research Group, </institution> <month> Sep. </month> <year> 1988. </year>
Reference-contexts: Our main concern in this paper is on transforming programs, in particular finding efficient programs. Many different tactics have been suggested for program transformation. Three of them should be mentioned here, as unfold/fold [BrD77], accumulation [B84], and <ref> [B88] </ref> and promotion [W88], [C90] and [B88]. In the first section a problem will be defined and a program will be derived from its definition. In the second section the derived program is transformed to an efficient one via a series of steps. <p> Our main concern in this paper is on transforming programs, in particular finding efficient programs. Many different tactics have been suggested for program transformation. Three of them should be mentioned here, as unfold/fold [BrD77], accumulation [B84], and <ref> [B88] </ref> and promotion [W88], [C90] and [B88]. In the first section a problem will be defined and a program will be derived from its definition. In the second section the derived program is transformed to an efficient one via a series of steps.
Reference: [C90] <author> Chin W.N.: </author> <title> Automatic Methods for Program Transforming. </title> <type> PhD Dissertation, </type> <institution> University of London, Imperial College. </institution> <year> (1990). </year>
Reference-contexts: Our main concern in this paper is on transforming programs, in particular finding efficient programs. Many different tactics have been suggested for program transformation. Three of them should be mentioned here, as unfold/fold [BrD77], accumulation [B84], and [B88] and promotion [W88], <ref> [C90] </ref> and [B88]. In the first section a problem will be defined and a program will be derived from its definition. In the second section the derived program is transformed to an efficient one via a series of steps. <p> In this section, we embark on step by step improvement of these programs. First, to improve rs two functions ps and cp can be combined to avoid building unnecessary structures. This method is called `deforestation' and `fusion' by Wadler [W88] and Chin <ref> [C90] </ref> respectively, though Chin's work is not the same as Wadler. Both of them give some strategies to remove unnecessary construction of certain structures in an automatic fashion. However, we are going to apply another approach for transforming rs. <p> To do this, some equations, that will be used in the fusion process, should be proved. These fusions have specific characteristics that make them special in the sense that they can not be done automatically by the algorithms which have been suggested in [W88] and in <ref> [C90] </ref>. This is because of the nature of the test functions, i.e. is-f un, is-inj, is-surj and is-hom, which we have in our program. These test functions have such properties that allow us to delete some parts of the constructions of the program for being completely unnecessary.
Reference: [D75] <author> Darlington J.: </author> <title> Application of program transformation to program synthesis. </title> <booktitle> Proc. IRIA symp. Proving and Improving Programs. Arc-et-Senans. France, </booktitle> <pages> pp. </pages> <month> 133-144 </month> <year> (1975). </year>
Reference-contexts: This function can be defined by: cp (s 1 ; s 2 ) = f (A; B) j A 2 s 1 ^ B 2 s 2 g Using the unfold/fold method we may end up with the following definition for cp <ref> [D75] </ref>: cp (;; s 2 ) = ; cp (fag [ x; s 2 ) = map (pair a) s 2 [ cp (x; s 2 ) where pair a b = (a; b).
Reference: [MW71] <author> Manna Z. and Waldinger R.: </author> <title> Towards automatic program synthesis. </title> <journal> CACM, </journal> <volume> 14, 3, </volume> <pages> pp. </pages> <month> 151-165 </month> <year> (1971). </year>
Reference: [Re85] <author> Reddy U.S.: </author> <title> Narrowing as the Operational Semantics of Functional Language Symposium on Logic Programming, </title> <publisher> IEEE, Boston, </publisher> <pages> pp. </pages> <month> 138-151 </month> <year> (1985). </year>
Reference: [W88] <author> Wadler P.: </author> <title> Deforestation: Transforming Programs to Eliminate Trees. </title> <booktitle> European Symposium on Programming, Nancy, France. </booktitle> <pages> pp. </pages> <month> 344-358 </month> <year> (1988). </year> <month> 8 </month>
Reference-contexts: Our main concern in this paper is on transforming programs, in particular finding efficient programs. Many different tactics have been suggested for program transformation. Three of them should be mentioned here, as unfold/fold [BrD77], accumulation [B84], and [B88] and promotion <ref> [W88] </ref>, [C90] and [B88]. In the first section a problem will be defined and a program will be derived from its definition. In the second section the derived program is transformed to an efficient one via a series of steps. <p> In this section, we embark on step by step improvement of these programs. First, to improve rs two functions ps and cp can be combined to avoid building unnecessary structures. This method is called `deforestation' and `fusion' by Wadler <ref> [W88] </ref> and Chin [C90] respectively, though Chin's work is not the same as Wadler. Both of them give some strategies to remove unnecessary construction of certain structures in an automatic fashion. However, we are going to apply another approach for transforming rs. <p> To do this, some equations, that will be used in the fusion process, should be proved. These fusions have specific characteristics that make them special in the sense that they can not be done automatically by the algorithms which have been suggested in <ref> [W88] </ref> and in [C90]. This is because of the nature of the test functions, i.e. is-f un, is-inj, is-surj and is-hom, which we have in our program. These test functions have such properties that allow us to delete some parts of the constructions of the program for being completely unnecessary.
References-found: 8

