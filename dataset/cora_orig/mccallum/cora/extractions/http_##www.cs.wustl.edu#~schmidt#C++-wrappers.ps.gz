URL: http://www.cs.wustl.edu/~schmidt/C++-wrappers.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/resume.html
Root-URL: http://www.cs.wustl.edu
Email: schmidt@ics.uci.edu  
Title: Systems Programming with C++ Wrappers Encapsulating Interprocess Communication Mechanisms with Object-Oriented Interfaces  
Author: Douglas C. Schmidt 
Address: Irvine, CA 92717, (714) 856-4105  
Affiliation: Department of Information and Computer Science University of California,  
Abstract: An earlier version of this paper appeared in the Septem-ber/October 1992 issue of the C++ Report. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, D. F. Box, and T. Suda, </author> <title> ADAPTIVE: A Flexible and Adaptive Transport System Architecture to Support Lightweight Protocols for Multimedia Applications on High-Speed Networks, </title> <booktitle> in Proceedings of the 1 st Symposium on High-Performance Distributed Computing (HPDC-1), </booktitle> <address> (Syra-cuse, New York), </address> <pages> pp. 174-186, </pages> <publisher> IEEE, </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: IPC SAP is currently being used in the ADAPTIVE system, which is a flexible development and evaluation environment for producing customized lightweight transport-layer communication protocols <ref> [1] </ref>. 2 Systems Programming and IPC Systems software programs (such as databases, window-ing systems, network file servers, compilers, linkers, editors, and device drivers) typically access and manipulate operating system resources such as I/O controllers and information located in data structures residing within an OS kernel.
Reference: [2] <author> D. C. Schmidt, </author> <title> The Reactor: An Object-Oriented Interface for Event-Driven UNIX I/O Multiplexing (Part 1 of 2), </title> <journal> C++ Report, </journal> <volume> vol. 5, </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: The server receives the messages and displays them on one or more output devices (such as a printer, persistent storage device, or monitoring console). Subsequent articles will address this client/server architecture in greater detail using the Reactor I/O-based and timer-based service multiplexing facility <ref> [2, 3] </ref>. 2.1 Limitations with Existing Operating Sys tem Interfaces Developing communication system software is difficult since it requires detailed knowledge of many concepts such as (1) network addressing and remote service identification, (2) creation, synchronization, and communication mechanisms for processes and threads, (3) system call Application Programmatic Interfaces (API)s for
Reference: [3] <author> D. C. Schmidt, </author> <title> The Object-Oriented Design and Implementation of the Reactor: A C++ Wrapper for UNIX I/O Multiplexing (Part 2 of 2), </title> <journal> C++ Report, </journal> <volume> vol. 5, </volume> <month> September </month> <year> 1993. </year> <month> 6 </month>
Reference-contexts: The server receives the messages and displays them on one or more output devices (such as a printer, persistent storage device, or monitoring console). Subsequent articles will address this client/server architecture in greater detail using the Reactor I/O-based and timer-based service multiplexing facility <ref> [2, 3] </ref>. 2.1 Limitations with Existing Operating Sys tem Interfaces Developing communication system software is difficult since it requires detailed knowledge of many concepts such as (1) network addressing and remote service identification, (2) creation, synchronization, and communication mechanisms for processes and threads, (3) system call Application Programmatic Interfaces (API)s for <p> On the other hand, APIs that use object-oriented features such as inheritance and dynamic binding are typically easy to extended transparently <ref> [3] </ref>. <p> This is accomplished by carefully separating application policies from the networking and operating system mechanisms. The goal is to allow applications to extend the original APIs without modifying the design or implementation of the existing wrapper infrastructure <ref> [3] </ref>. This series of articles on C++ wrappers is intended to (1) increase software developers' knowledge of available UNIX IPC mechanisms, (2) describe an object-oriented methodology for designing and implementing distributed applications, and (3) present a strategy for organizations to migrate to OOD and C++.
Reference: [4] <author> R. Campbell, V. Russo, and G. Johnson, </author> <title> The Design of a Mul--tiprocessor Operating System, </title> <booktitle> in Proceedings of the USENIX C++ Workshop, </booktitle> <pages> pp. 109-126, </pages> <publisher> USENIX Association, </publisher> <month> Novem-ber </month> <year> 1987. </year>
Reference-contexts: Extensibility becomes particularly important when dealing with C++ wrapper that provide more complex semantics (such as event multiplexing and multi-processing). 2.2 The C++ Wrapper Alternative Switching to a consistently designed, strongly-typed, object-oriented operating system (such as the Choices OS from University of Illinois <ref> [4] </ref>) helps ameliorate some of the problems described in the preceding section. However, adopting a completely different OS is often impractical, due to factors such as the lack of application portability, platform availability, and user and developer familiarity.
Reference: [5] <author> D. C. Schmidt and T. Suda, </author> <title> ADAPTIVE: A Framework for Experimenting with High-Performance Transport System Process Architectures, </title> <booktitle> in Proceedings of the 2 nd International Conference on Computer Communication Networks, </booktitle> <address> (San Diego, California), </address> <publisher> ISCA, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: In particular, inline functions avoid making an extra function call for each access to an underlying OS system call or library routine. 2.3 Benefits of C++ Wrappers My Ph.D. research project focuses on a framework for developing and experimenting with alternative process architectures for shared memory, symmetric multi-processor platforms <ref> [5] </ref>. One portion of this project is the ADAPTIVE Communication Environment (ACE) [6], which is a collection of C++ wrappers that encapsulate existing OS mechanisms for local and remote IPC such as sockets, select (), message queues, shared memory, semaphores, and remote procedure calls.
Reference: [6] <author> D. C. Schmidt, </author> <title> The ADAPTIVE Communication Environment: An Object-Oriented Network Programming Toolkit for Developing Communication Software, </title> <booktitle> in Proceedings of the 12 th Annual Sun Users Group Conference, </booktitle> <address> (San Jose, CA), </address> <pages> pp. 214-225, </pages> <address> SUG, </address> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: One portion of this project is the ADAPTIVE Communication Environment (ACE) <ref> [6] </ref>, which is a collection of C++ wrappers that encapsulate existing OS mechanisms for local and remote IPC such as sockets, select (), message queues, shared memory, semaphores, and remote procedure calls.
Reference: [7] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year>
Reference-contexts: Providing simpler and more compact interfaces allows developers to concentrate on designing and implementing applications, instead of wrestling with the low-level details of the underlying networking code. * Portability: Wrappers also improve application portability. For example, Figure 3 depicts how the IPC SAP API (described in <ref> [7] </ref>) provides a portable veneer for many services offered in common by both BSD sockets and System V TLI. Application programs may then be written using a single object-oriented API, which is mapped transparently onto the appropriate system calls that access the particular underlying OS mechanisms.
Reference: [8] <author> W. R. Stevens, </author> <title> UNIX Network Programming. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Difficulties arise both from inadequate documentation, as well as from the complexity of the existing non-object-oriented IPC system call interfaces. For example, it is difficult to understand and use System V semaphores correctly since the API is quite general and sparsely documented <ref> [8] </ref>. The C++ wrapper semaphore interface developed for the ACE, on the other hand, shields developers from a myriad of unnecessary details.
Reference: [9] <author> W. W. Ho and R. Olsson, </author> <title> An Approach to Genuine Dynamic Linking, </title> <journal> Software: Practice and Experience, </journal> <volume> vol. 21, </volume> <pages> pp. 375-390, </pages> <month> Apr. </month> <year> 1991. </year> <month> 7 </month>
Reference-contexts: System V message queues, named pipes, and STREAM pipes * Shared memory mechanisms such as System V shared memory and the BSD mmap () family of functions that support shared memory via a memory-mapped file abstraction. 1 * System V Semaphores * Remote Procedure Calls (RPCs) * Explicit dynamic linking <ref> [9] </ref> facilities that enable the development of dynamically configured, multi-service network daemons * The ADAPTIVE Service eXecutive (ASX), which provides a framework for developing and configuring con current stackable subservices * The distributed rwho (drwho) integration framework, which extends and improves the functionality of the rwhod family of monitoring services (e.g.,
References-found: 9

