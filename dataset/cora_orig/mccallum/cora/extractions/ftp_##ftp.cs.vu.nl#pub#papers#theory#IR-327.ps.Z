URL: ftp://ftp.cs.vu.nl/pub/papers/theory/IR-327.ps.Z
Refering-URL: http://www.cs.vu.nl/vakgroepen/ti/ftpindex.html
Root-URL: 
Title: Combinatory Reduction Systems: introduction and survey  
Author: Jan Willem Klop Vincent van Oostrom Femke van Raamsdonk Corrado Bohm 
Keyword: Key Words and Phrases: term rewriting systems, -calculus, higher-order rewriting, combi-natory reduction systems, orthogonality, confluence, finite developments.  
Note: Dedicated to  1991 Mathematics Subject Classification: 68Q50 1991 CR Categories:  
Address: Kruislaan 413, 1098 SJ Amsterdam  Boelelaan 1081, 1081 HV Amsterdam  Boelelaan 1081, 1081 HV Amsterdam  Kruislaan 413, 1098 SJ Amsterdam  
Affiliation: CWI,  Department of Mathematics and Computer Science Free University, de  Department of Mathematics and Computer Science Free University, de  CWI,  
Email: email: jwk@cwi.nl  email: oostrom@cs.vu.nl  email: femke@cwi.nl  
Web: F.4.1.1, F.3.3.3.  
Abstract: Combinatory Reduction Systems, or CRSs for short, were designed to combine the usual first-order format of term rewriting with the presence of bound variables as in pure -calculus and various typed -calculi. Bound variables are also present in many other rewrite systems, such as systems with simplification rules for proof normalization. The original idea of CRSs is due to Aczel, who introduced a restricted class of CRSs and, under the assumption of orthogonality, proved confluence. Orthogonality means that the rules are non-ambiguous (no overlap leading to a critical pair) and left-linear (no global comparison of terms necessary). We introduce the class of orthogonal CRSs, illustrated with many examples, discuss its expressive power, and give an outline of a short proof of confluence. This proof is a direct generalization of Aczel's original proof, which is close to the well-known confluence proof for -calculus by Tait and Martin-Lof. There is a well-known connection between the parallel reduction featuring in the latter proof, and the concept of `developments', and a classical lemma in the theory of -calculus is that of `Finite Developments', a strong normalization result. It turns out that the notion of `parallel reduction' used in Aczel's proof gives rise to a generalized form of developments, which we call `superdevelopments' and on which we will briefly comment. We conclude with mentioning the results of a comparison of CRSs with the recently proposed and strongly related format of higher-order rewriting: Nipkow's HRSs (Higher-order Rewrite Systems). Note: The research of the first author is partially supported by ESPRIT BRA 6454 CONFER (CONcurrency and Functions: Evaluation and Reduction). The research of the third author is in the framework of NWO/SION project 612-316-606 "Extensions of orthogonal rewrite systems syntactic properties". 
Abstract-found: 1
Intro-found: 1
Reference: [ACCL90] <author> M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. Levy. </author> <title> Explicit substitutions. </title> <booktitle> In Proceedings of the ACM Conference on Principles of Programming Langueges, </booktitle> <address> San Francisco, </address> <year> 1990. </year>
Reference-contexts: Roughly, there is an analogy with the relation of -calculus to -calculus or -calculus with explicit substitution: in the latter one fi-step is simulated by several steps (see <ref> [ACCL90] </ref>). Thus we can say that CRSs have a more `explicit' substitution mechanism than HRSs. This can be considered both as an advantage or a disadvantage, depending on one's point of view or needs. <p> More and more typed -calculi are emerging at present; likewise for calculi such as -calculus. It will be profitable to show that they are in fact CRSs. Then the uniform confluence proof can be applied. h Developing versions of CRSs with `explicit substitution', analogous to the -calculi for -calculus <ref> [ACCL90] </ref>. i As pointed out in [Nip93] there is a need to extend the notion of CRSs (and of HRSs) in such a way that metavariables in left-hand sides of rewrite rules may require their arguments to be instances of patterns.
Reference: [Acz78] <author> P. Aczel. </author> <title> A general Church-Rosser theorem. </title> <type> Technical report, </type> <institution> University of Manch-ester, </institution> <year> 1978. </year>
Reference-contexts: However, in the sequel we will give a perfectly rigorous semantics to this up to now sloppy notation. This leads us (after Aczel <ref> [Acz78] </ref>) to introduce metavariables with arity. E.g. M (x) is a unary metavariable. Also, we will employ henceforth a special notation for metavariables: Z n k where n denotes the arity, n 0, and k 0 is an enumerating index. <p> A format like this, combining term rewriting and binding structures for variables has been developed in [Klo80], generalizing an idea of Aczel <ref> [Acz78] </ref>. The resulting Combinatory Reduction Systems (CRSs for short) employ a notation of meta-variables with arity. <p> For full proofs see [Raa93]. 13.1 Confluence The proof of confluence for orthogonal CRSs proceeds along the lines of the proof by Aczel of confluence for orthogonal Contraction Schemes, which form a subclass of CRSs <ref> [Acz78] </ref>. The proof strategy in Aczel's proof is the same as in the proof of confluence of -calculus with fi-reduction by Tait and Martin-Lof. In several other proofs this strategy is employed [Nip93, Tak93]. The idea is roughly as follows. <p> Proposition 13.2 The transitive closure of equals reduction. The crucial step in proving the diamond property for is proving that satisfies a property named `coherence'. This notion is originally introduced by Aczel <ref> [Acz78] </ref>. <p> They combine -calculus with orthogonal TRSs, thus containing all orthogonal -TRSs. In fact they contain more than -TRSs, since right-hand sides of rules may include -terms. They also contain Church's ffi-rules (see Example A1). The fundamental idea leading to the present framework of CRSs was formulated by Aczel <ref> [Acz78] </ref>, who devised `contraction schemes'. They do not support arbitrary complex pattern matching as in first-order TRSs, but apart from that they introduce variable-binding as in the present CRSs. 16 Wolfram [Wol91] describes a general notion of higher-order rewriting. <p> : M n and ffiM 1 : : : M m , with m n. (So every left-hand side of a ffi-rule is a normal form with respect to the other ffi-rules.) Thus we obtain an orthogonal CRS. 19 A.2 -calculus with pairing, definition by cases, and iterator From Aczel <ref> [Acz78] </ref>. Note that this is an example of a definable extension of -calculus.
Reference: [And86] <author> P.B. Andrews. </author> <title> An Introduction to Mathematical Logic and Type Theory: To Truth Through Proof. </title> <publisher> Academic Press, </publisher> <year> 1986. </year>
Reference-contexts: Above, we only established confluence for terms, not metaterms. A stronger confluence result can be obtained at once, however, admitting metavariables; let's call this for the moment `meta-confluence'. For non-orthogonal systems, the notions separate however. f Developing a model theory (semantics) for CRSs, cf. <ref> [Wol93, And86] </ref>. Whereas for first-order TRSs there is a good model theory given by the usual notion of algebra, no analogous concept is available when bound variables are present.
Reference: [Bar74] <author> H.P. Barendregt. </author> <title> Pairing without conventional restraints. </title> <journal> Z. Math. Logik Grundlag. Math., </journal> <volume> 20 </volume> <pages> 289-306, </pages> <year> 1974. </year>
Reference-contexts: If we add the rule pair (leftM )(rightM ) ! M 2 to the pair rules the system is no longer a directly definable one. Hence, this extension (called -calculus with Surjective Pairing) is a proper extension of -calculus. This has been proved by Barendregt <ref> [Bar74] </ref>. In both cases above the problem is the double occurrence of the meta-variable M in the lefthand-side of a rule. Such a rule is called `not left-linear'.
Reference: [Bar84] <author> H.P. Barendregt. </author> <title> The Lambda Calculus, its Syntax and Semantics. </title> <publisher> North Holland, </publisher> <address> second edition, </address> <year> 1984. </year>
Reference-contexts: Redexes that are created along the way are not allowed to be contracted. Both confluence proofs are related in the following way: M 7! 1 N if and only if a (complete) development M N exists (see <ref> [Bar84] </ref>). A natural question is now whether reduction sequences corresponding exactly to the relation can be characterized, and if so, whether they are always finite.
Reference: [Bar89] <author> H.P. Barendregt. </author> <title> Functional programming and lambda-calculus. </title> <editor> In J. van Leeuwen, editor, </editor> <title> Formal Methods and Semantics, </title> <booktitle> Handbook of Theoretical Computer Science, Volume B, chapter 7, </booktitle> <pages> pages 321-364. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference: [Bar92] <editor> H.P. Barendregt. Typed lambda-calculi. In S. Abramsky, D. Gabbay, and T. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, Volume I. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: We will take this property as the defining property for a substructure. In the theory of typed -calculi it is known as the subject reduction property. See also <ref> [Bar92, Definition 12.9] </ref>. Next to `full' CRSs, we now admit also all its substructures as CRSs. We will call CRSs which are not full (which have restricted term formation), restricted CRSs. <p> In the first case we have immediately confluence by invoking the confluence proof for orthogonal CRSs. For treatments of second-order polymorphic -calculus, we refer to e.g. [Hue90] (several articles in Chapter 2), <ref> [Bar92, Sce90, Gal90] </ref>. The basic intuition is as follows. In simply typed -calculus there is, e.g. an identity function x : :x for each type .
Reference: [BB92] <author> A. Berarducci and C. Bohm. </author> <title> A self-interpreter of -calculus having a normal form. </title> <type> Technical report, </type> <institution> Universita di Aquila, 1992. Rapporto Technico 16, Dip. di Matem-atica Pura ed Applicata. </institution>
Reference-contexts: For recent progress on this subject, see <ref> [BB92] </ref>. But the three examples of the previous section show that it is worthwhile to study extensions of -calculus with term rewriting rules. Let us indicate -calculus, with as only rule the one of fi-reduction, by and abbreviate a term rewriting system without bound variables as TRS.
Reference: [Ber78] <author> G. Berry. Sequentialite de l'evaluation formelle des -expressions. </author> <booktitle> In Proceedings 3ieme Colloque International sur la Programmation, </booktitle> <address> Paris, </address> <month> mars </month> <year> 1978. </year> <month> Dunod. </month>
Reference-contexts: Now the problem is not non-left-linearity, but the inherent parallelism in the rules for or; and -calculus has a sequential evaluation <ref> [Ber78] </ref>. 4 -rewrite systems Here we are not concerned with a study of definability in -calculus, an issue that has not yet been explored extensively. For recent progress on this subject, see [BB92].
Reference: [BT88] <author> V. Breazu-Tannen. </author> <title> Combining algebra and higher-order types. </title> <booktitle> In Proceedings of the 3rd annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 80-90, </pages> <address> Edinburgh, </address> <year> 1988. </year>
Reference-contexts: The three examples of extensions of -calculus above are of the latter kind and illustrate the expressiveness of the class of -TRSs. We note that in recent years several studies have appeared of extensions of various typed -calculi with ordinary term rewriting rules, sometimes called `algebraic rewriting' <ref> [BT88, BTG89] </ref>. 5 Meta-variables with arity In the next section we will investigate the expressiveness of -TRSs. We will especially be concerned with the study of rules with bound variables. In this section a notational device is introduced for writing rules with binding structures in an easy way.
Reference: [BTG89] <author> V. Breazu-Tannen and J. Gallier. </author> <title> Polymorphic rewriting conserves algebraic strong normalization and confluence. </title> <booktitle> In Proceedings of the 16th international colloquium on automata, languages and programming, </booktitle> <pages> pages 137-150, </pages> <year> 1989. </year> <note> Lecture Notes in Computer Science 372. </note>
Reference-contexts: The three examples of extensions of -calculus above are of the latter kind and illustrate the expressiveness of the class of -TRSs. We note that in recent years several studies have appeared of extensions of various typed -calculi with ordinary term rewriting rules, sometimes called `algebraic rewriting' <ref> [BT88, BTG89] </ref>. 5 Meta-variables with arity In the next section we will investigate the expressiveness of -TRSs. We will especially be concerned with the study of rules with bound variables. In this section a notational device is introduced for writing rules with binding structures in an easy way.
Reference: [Chu41] <author> A. Church. </author> <title> The Calculi of Lambda Conversion, </title> <booktitle> volume 6 of Annals of Mathematics Studies. </booktitle> <publisher> Princeton University Press, </publisher> <year> 1941. </year>
Reference: [Chu56] <author> A. Church. </author> <title> Introduction to Mathematical Logic. </title> <publisher> Princeton University Press, </publisher> <year> 1956. </year>
Reference: [Cur86] <author> P.-L. Curien. </author> <title> Categorical Combinators, Sequential Algorithms and Functional Programming. </title> <booktitle> Research Notes in Theoretical Computer Science. </booktitle> <publisher> Pitman, </publisher> <address> London, </address> <year> 1986. </year>
Reference: [dB80] <author> J.W. de Bakker. </author> <title> Mathematical Theory of Program Correctness. </title> <booktitle> Prentice-Hall International Series in Computer Science, </booktitle> <year> 1980. </year>
Reference-contexts: For example: x:M ! M [x := x:M ] as in the operational semantics for recursively defined concepts (e.g. in recursive procedures as in <ref> [dB80] </ref> and in processes defined by recursion [Mil84]).
Reference: [DJ89] <author> N. Dershowitz and J.-P. Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <title> Formal Methods and Semantics, </title> <booktitle> Handbook of Theoretical Computer Science, Volume B, chapter 6, </booktitle> <pages> pages 243-320. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference: [Gal90] <author> J. Gallier. </author> <title> On Girard's `Candidats de reductibilite'. </title> <editor> In P. Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 123-203. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year> <booktitle> Volume 32 in `APIC Studies in Data Processing'. </booktitle>
Reference-contexts: 1 ) :::ff n )Z 0 ! (Z (Z 0ff 1 :::ff n )) ff 1 :::ff n A.4 Second-order polymorphic -calculus In this example we consider second-order polymorphic -calculus (or polymorphic typed - calculus, or second order typed -calculus, or system F, or 2), based on the presentation in <ref> [Gal90] </ref>. We will show that it is an orthogonal CRS when only fi-reduction (both for term application and type application) is considered, and a weakly orthogonal CRS when also - reduction (for terms and types) is taken into account. <p> In the first case we have immediately confluence by invoking the confluence proof for orthogonal CRSs. For treatments of second-order polymorphic -calculus, we refer to e.g. [Hue90] (several articles in Chapter 2), <ref> [Bar92, Sce90, Gal90] </ref>. The basic intuition is as follows. In simply typed -calculus there is, e.g. an identity function x : :x for each type . <p> Definitions of free and bound type variable occurrences and of closed type expressions are as usual. Likewise notions of renaming bound type variables (ff-conversion) are as usual. For a precise treatment of these issues see <ref> [Gal90] </ref>. We assume the presence of a set S of constant symbols c, each with its own type, written type (c), which is required to be a closed type. As in [Gal90] we introduce `raw' terms, i.e. terms that are not yet subject to a typing discipline. <p> For a precise treatment of these issues see <ref> [Gal90] </ref>. We assume the presence of a set S of constant symbols c, each with its own type, written type (c), which is required to be a closed type. As in [Gal90] we introduce `raw' terms, i.e. terms that are not yet subject to a typing discipline. <p> We will now state the reduction rules on P fl as in <ref> [Gal90] </ref>: (x : :M )N ! fi M [x := N ] (fi-reduction rule) x : :M x ! M (-reduction rule) (flt:M )t ! tfi M [t := t ] (type fi-reduction rule) flt:M t ! t M (type -reduction rule) Note that the raw terms are very raw indeed: <p> With fi- and -rules there is a harmful overlap causing non-confluence; see <ref> [Gal90] </ref>. Proto-2 is an extension of pure -calculus, with respect to the set of terms, not rules. It contains many garbage terms, but 22 also intended terms, coding the polymorphic terms we are aiming for. <p> M : . We now restrict the set of proto-terms to the set of typable proto-terms, and we claim that (with the same rewrite rules as above) this yields a sub-CRS of proto-2. The statement of this claim is known as the subject-reduction property. This is Lemma 5.2 in <ref> [Gal90] </ref>, although here for a larger set of proto-terms than the raw terms there; the proof is according to [Gal90] tedious but not difficult. The sub-CRS of typable proto-terms is the intended one: polymorphic second-order -calculus. With only the fi-rules it is orthogonal, with fi- and -rules it is weakly orthogonal. <p> The statement of this claim is known as the subject-reduction property. This is Lemma 5.2 in <ref> [Gal90] </ref>, although here for a larger set of proto-terms than the raw terms there; the proof is according to [Gal90] tedious but not difficult. The sub-CRS of typable proto-terms is the intended one: polymorphic second-order -calculus. With only the fi-rules it is orthogonal, with fi- and -rules it is weakly orthogonal.
Reference: [Gan80] <author> R.O. </author> <title> Gandy. Proofs of strong normalization. </title> <editor> In J.P. Seldin and J.R. Hindley, editors, </editor> <booktitle> To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 457-477. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference: [Gir87] <author> J.-Y. Girard. </author> <title> Proof Theory and Logical Complexity, volume I. </title> <type> Bibliopolis, </type> <institution> Napoli, </institution> <year> 1987. </year>
Reference-contexts: Usually instead of B the infix notation employing `ffi' is used, rendering as Y T ffi . 4 Another example stems from proof theory. There one is concerned with proof normaliza-tion (cf. <ref> [Pra71, Gir87] </ref>): P (LZ)(x:Z 0 (x))(x:Z 00 (x)) ! Z 0 (Z) These rules are easily defined in (e.g. by taking P = x:x, L = xyz:yx and R = xyz:zx).
Reference: [Hin77] <author> J.R. Hindley. </author> <title> The equivalence of complete reductions. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 229 </volume> <pages> 227-248, </pages> <year> 1977. </year>
Reference: [Hin78] <author> J.R. Hindley. </author> <title> Standard and normal reductions. </title> <journal> Transactions of the American Mathematical Society, </journal> <year> 1978. </year>
Reference: [HS86] <editor> J.R. Hindley and J.P. Seldin. </editor> <title> Introduction to Combinators and -calculus, volume 1 of London Mathematical Society Student Texts. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference: [Hue90] <editor> G. Huet, editor. </editor> <booktitle> Logical Foundations of Functional Programming. University of Texas at Austin Year of Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: In the first case we have immediately confluence by invoking the confluence proof for orthogonal CRSs. For treatments of second-order polymorphic -calculus, we refer to e.g. <ref> [Hue90] </ref> (several articles in Chapter 2), [Bar92, Sce90, Gal90]. The basic intuition is as follows. In simply typed -calculus there is, e.g. an identity function x : :x for each type .
Reference: [Kah91] <author> S. Kahrs. -rewriting. </author> <type> PhD thesis, </type> <institution> Universitat Bremen, </institution> <year> 1991. </year>
Reference-contexts: Application is here expressed by the binary function symbol @. 12 Extracting the reduction relation It requires some subtlety to extract from the rewrite rules the actual rewrite relation that they generate. First we define substitutes (we adopt this name from Kahrs <ref> [Kah91] </ref>). Definition 12.1 Let t be a term. (1) Let (x 1 ; : : : ; x n ) be an n-tuple of pairwise distinct variables. Then the expression (x 1 ; : : : ; x n ):t is an n-ary substitute.
Reference: [Kah92] <author> S. Kahrs. </author> <title> Compilation of combinatory reduction systems. </title> <institution> University of Edinburgh, </institution> <year> 1992. </year>
Reference: [KdV89] <author> J.W. Klop and R.C. de Vrijer. </author> <title> Unique normal forms for lambda calculus with sur-jective pairing. </title> <journal> Information and Computation, </journal> <volume> 80(2) </volume> <pages> 97-113, </pages> <year> 1989. </year>
Reference: [Ken89] <author> J.R. Kennaway. </author> <title> Sequential evaluation strategies for parallel-or and related systems. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 43 </volume> <pages> 31-56, </pages> <year> 1989. </year> <month> 25 </month>
Reference: [Kha90] <author> Z. Khasidashvili. </author> <title> Expression reduction systems. </title> <type> Technical report, </type> <institution> I. Vekua Institute of Applied Mathematics, University of Tblisi, Georgia, </institution> <year> 1990. </year>
Reference-contexts: This can be considered both as an advantage or a disadvantage, depending on one's point of view or needs. In the figure we have referred to the more explicit (i.e. `slower') way of CRSs to evaluate substitutions as `lazy simulation'. The format of higher-order rewriting developed by <ref> [Kha90, Kha92] </ref> is equivalent to that of CRSs but the set-up is closer to the one of -calculus and of first-order logic. Extensions of -calculus by means of conditions are studied in [Tak89, Tak93].
Reference: [Kha92] <author> Z. Khasidashvili. </author> <title> Church-Rosser Theorem in Orthogonal Combinatory Reduction Systems. </title> <type> INRIA Rocquencourt report no. 1825, </type> <year> 1992. </year>
Reference-contexts: This can be considered both as an advantage or a disadvantage, depending on one's point of view or needs. In the figure we have referred to the more explicit (i.e. `slower') way of CRSs to evaluate substitutions as `lazy simulation'. The format of higher-order rewriting developed by <ref> [Kha90, Kha92] </ref> is equivalent to that of CRSs but the set-up is closer to the one of -calculus and of first-order logic. Extensions of -calculus by means of conditions are studied in [Tak89, Tak93].
Reference: [Klo80] <author> J.W. Klop. </author> <title> Combinatory Reduction Systems. </title> <publisher> Mathematical Centre Tracts Nr. 127. CWI, </publisher> <address> Amsterdam, </address> <year> 1980. </year> <type> PhD Thesis. </type>
Reference-contexts: The compare rule of the previous section is a typical example of a reduction system for which this is not the case (for a reasonable notion of definability) (cf. <ref> [Klo80] </ref>). If we add the rule pair (leftM )(rightM ) ! M 2 to the pair rules the system is no longer a directly definable one. Hence, this extension (called -calculus with Surjective Pairing) is a proper extension of -calculus. This has been proved by Barendregt [Bar74]. <p> A format like this, combining term rewriting and binding structures for variables has been developed in <ref> [Klo80] </ref>, generalizing an idea of Aczel [Acz78]. The resulting Combinatory Reduction Systems (CRSs for short) employ a notation of meta-variables with arity. <p> Let M be a term in R, having a normal form N , but also admitting an infinite reduction. Then N has an infinite expansion, i.e. an inverse reduction. (See Figure 1) For a proof, see <ref> [Klo80] </ref>. Obviously, this `N-property' does not hold in general for restricted orthogonal CRSs, since the set of terms need not be closed under expansion (inverse reduction). <p> Without attempting to give a complete historical survey of such approaches, we mention some of the most noteworthy ones, referring for a more elaborate discussion to <ref> [Klo80] </ref> or to the original references. One of the first extended formats consists of Hindley's (a)-reductions. They combine -calculus with orthogonal TRSs, thus containing all orthogonal -TRSs. In fact they contain more than -TRSs, since right-hand sides of rules may include -terms. They also contain Church's ffi-rules (see Example A1). <p> In summary, there seems to be a convergence of several proposals for notions of higher-order rewriting. 17 15 Concluding remarks and questions We have presented the framework for higher-order rewriting as first fully described in <ref> [Klo80] </ref>, where Aczel's original idea was extended with general pattern-matching as in first-order TRSs. In the present introduction we have given a more precise exposition than in [Klo80] of the substitution mechanism that is involved, and we have also sketched a confluence proof (recently obtained by [Raa93], but also present in <p> notions of higher-order rewriting. 17 15 Concluding remarks and questions We have presented the framework for higher-order rewriting as first fully described in <ref> [Klo80] </ref>, where Aczel's original idea was extended with general pattern-matching as in first-order TRSs. In the present introduction we have given a more precise exposition than in [Klo80] of the substitution mechanism that is involved, and we have also sketched a confluence proof (recently obtained by [Raa93], but also present in the work of Nipkow and Takahashi) adapting Aczel's original one to the present framework. The phrase `higher-order' may need an explanation. <p> It is an extremely useful tool in giving precise definitions of notions such as descendants, equivalence of reductions etc. They were introduced in Levy [Lev75]; a simplified version is in Klop <ref> [Klo80] </ref>. Levy-labels are unary-binary trees with end-nodes labeled by a; b; c; : : : (see the example).
Reference: [Klo92] <author> J.W. Klop. </author> <title> Term rewriting systems. </title> <editor> In S. Abramsky, D. Gabbay, and T. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, Volume II. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference: [Lev75] <author> J.-J. Levy. </author> <title> An algebraic interpretation of the fiK-calculus and a labelled -calculus. </title> <editor> In C. Bohm, editor, </editor> <booktitle> -calculus and Computer Science Theory, Proceedings Rome Conference 1975, </booktitle> <pages> pages 147-165. </pages> <publisher> Springer Verlag, </publisher> <year> 1975. </year> <note> Lecture Notes in Computer Science 37. </note>
Reference-contexts: This is done by defining a set of labelled -terms fl l and labelled fi-reduction ! fi l on them. The difference between developments and superdevelopments in -calculus can be understood by considering the different ways in which fi-redexes can be created. This has been studied by Levy <ref> [Lev75] </ref>. <p> It is an extremely useful tool in giving precise definitions of notions such as descendants, equivalence of reductions etc. They were introduced in Levy <ref> [Lev75] </ref>; a simplified version is in Klop [Klo80]. Levy-labels are unary-binary trees with end-nodes labeled by a; b; c; : : : (see the example).
Reference: [Mid90] <author> A. Middeldorp. </author> <title> Modular Properties of Term Rewriting Systems. </title> <type> PhD thesis, </type> <institution> Vrije Universiteit, </institution> <address> Amsterdam, </address> <year> 1990. </year>
Reference: [Mil84] <author> R. Milner. </author> <title> A complete inference system for a class of regular behaviours. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 28(3) </volume> <pages> 439-466, </pages> <year> 1984. </year>
Reference-contexts: For example: x:M ! M [x := x:M ] as in the operational semantics for recursively defined concepts (e.g. in recursive procedures as in [dB80] and in processes defined by recursion <ref> [Mil84] </ref>). In the notation just introduced this rule is written as: x:Z (x) ! Z (x:Z (x)) This rule is definable in pure -calculus by defining x:Z (x) as Y T (x:Z (x)), with Y T = (xf:f (xxf ))(xf:f (xxf )), Turing's fixed point combinator.
Reference: [Mul92] <author> F. Muller. </author> <title> Confluence of the lambda-calculus with left-linear algebraic rewriting. </title> <journal> Information Processing Letters, </journal> <volume> 41 </volume> <pages> 293-299, </pages> <year> 1992. </year>
Reference: [Ned73] <author> R.P. </author> <title> Nederpelt. Strong Normalization for a Typed Lambda-calculus with Lambda Structured Types. </title> <type> PhD thesis, </type> <institution> Technische Universiteit Eindhoven, </institution> <year> 1973. </year>
Reference: [Nip91] <author> T. Nipkow. </author> <title> Higher-order critical pairs. </title> <booktitle> In Proceedings of the 6th annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 342-349, </pages> <year> 1991. </year>
Reference-contexts: This is the starting point for a recent formulation of higher-order rewriting that is given by Nipkow <ref> [Nip91] </ref> in his Higher-Order Rewrite Systems (HRSs). The meta-language employed for HRSs is the simply typed -calculus, facilitating the definition of substitution. For a comparison of CRSs and HRSs, see [OR93]. It turns out that both formats are roughly said co-extensive, and have the same expressive power.
Reference: [Nip93] <author> T. Nipkow. </author> <title> Orthogonal Higher-Order Rewrite Systems are Confluent. </title> <editor> In M. Bezem and J.F. Groote, editors, </editor> <booktitle> Proceedings of the International Conference on Typed Lambda Calculi and Applications, </booktitle> <pages> pages 306-317, </pages> <address> Utrecht, 1993. </address> <publisher> Springer LNCS 664. </publisher>
Reference-contexts: The proof strategy in Aczel's proof is the same as in the proof of confluence of -calculus with fi-reduction by Tait and Martin-Lof. In several other proofs this strategy is employed <ref> [Nip93, Tak93] </ref>. The idea is roughly as follows. A relation on terms is defined such that its transitive closure equals reduction. For this relation the diamond property is proved. <p> It will be profitable to show that they are in fact CRSs. Then the uniform confluence proof can be applied. h Developing versions of CRSs with `explicit substitution', analogous to the -calculi for -calculus [ACCL90]. i As pointed out in <ref> [Nip93] </ref> there is a need to extend the notion of CRSs (and of HRSs) in such a way that metavariables in left-hand sides of rewrite rules may require their arguments to be instances of patterns.
Reference: [OR93] <author> V. van Oostrom and F. van Raamsdonk. </author> <title> Comparing CRSs and HRSs. </title> <type> Manuscript, </type> <year> 1993. </year>
Reference-contexts: This is the starting point for a recent formulation of higher-order rewriting that is given by Nipkow [Nip91] in his Higher-Order Rewrite Systems (HRSs). The meta-language employed for HRSs is the simply typed -calculus, facilitating the definition of substitution. For a comparison of CRSs and HRSs, see <ref> [OR93] </ref>. It turns out that both formats are roughly said co-extensive, and have the same expressive power.
Reference: [Plo77] <author> G.D. Plotkin. </author> <title> LCF as a programming language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5 </volume> <pages> 223-257, </pages> <year> 1977. </year>
Reference: [Pra71] <author> D. Prawitz. </author> <title> Ideas and results in proof theory. </title> <editor> In J.E. Fenstad, editor, </editor> <booktitle> Proceedings of the 2nd Scandinavian Logic Symposium, </booktitle> <pages> pages 235-307. </pages> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference-contexts: Usually instead of B the infix notation employing `ffi' is used, rendering as Y T ffi . 4 Another example stems from proof theory. There one is concerned with proof normaliza-tion (cf. <ref> [Pra71, Gir87] </ref>): P (LZ)(x:Z 0 (x))(x:Z 00 (x)) ! Z 0 (Z) These rules are easily defined in (e.g. by taking P = x:x, L = xyz:yx and R = xyz:zx).
Reference: [Raa93] <editor> F. van Raamsdonk. Confluence and superdevelopments. In C. Kirchner, editor, </editor> <booktitle> Proceedings of the 5th International Conference on Rewrite Techniques and Applications, </booktitle> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: For full proofs see <ref> [Raa93] </ref>. 13.1 Confluence The proof of confluence for orthogonal CRSs proceeds along the lines of the proof by Aczel of confluence for orthogonal Contraction Schemes, which form a subclass of CRSs [Acz78]. <p> In the last case, on the other hand, the redex isn't created upwards, and may not be contracted in a superdevelopment. It is proved in <ref> [Raa93] </ref> that (complete) superdevelopments correspond exactly to the relation and moreover that all superdevelopments are finite. <p> If M 2 fl l is a good term such that all 's occurring in M have a different label, and M fi l N is a fi l -reduction then this reduction sequence is a superdevelopment after erasing all labels. The following results are proved in <ref> [Raa93] </ref>. Theorem 13.8 (Finite Superdevelopments) If a -term M is labelled such that all 's have a different label then all its fi l -reductions are finite. <p> In the present introduction we have given a more precise exposition than in [Klo80] of the substitution mechanism that is involved, and we have also sketched a confluence proof (recently obtained by <ref> [Raa93] </ref>, but also present in the work of Nipkow and Takahashi) adapting Aczel's original one to the present framework. The phrase `higher-order' may need an explanation. It is meant as contrast to the usual `first-order' format of term rewriting.
Reference: [Sce90] <author> A. Scedrov. </author> <title> A guide to polymorphic types. </title> <editor> In P. Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 123-203. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year> <booktitle> Volume 32 in `APIC Studies in Data Processing'. </booktitle> <pages> 26 </pages>
Reference-contexts: In the first case we have immediately confluence by invoking the confluence proof for orthogonal CRSs. For treatments of second-order polymorphic -calculus, we refer to e.g. [Hue90] (several articles in Chapter 2), <ref> [Bar92, Sce90, Gal90] </ref>. The basic intuition is as follows. In simply typed -calculus there is, e.g. an identity function x : :x for each type .
Reference: [Ste72] <author> S. Stenlund. </author> <title> Combinators, -terms and Proof Theory. </title> <publisher> Reidel, </publisher> <address> Dordrecht, </address> <year> 1972. </year>
Reference: [Tak89] <author> M. Takahashi. </author> <title> Parallel reductions in -calculus. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 7 </volume> <pages> 113-123, </pages> <year> 1989. </year> <note> Revised version as Report C-103, </note> <month> April </month> <year> 1992, </year> <institution> Tokyo Institute of Technology. </institution>
Reference-contexts: The format of higher-order rewriting developed by [Kha90, Kha92] is equivalent to that of CRSs but the set-up is closer to the one of -calculus and of first-order logic. Extensions of -calculus by means of conditions are studied in <ref> [Tak89, Tak93] </ref>. These `conditional -calculi' comprise many CRSs; in personal communication we have learned that a slight generalization of the conditions leads to the whole class of CRSs (in fact, even a somewhat larger class).
Reference: [Tak93] <author> M. Takahashi. </author> <title> -calculi with conditional rules. </title> <editor> In M. Bezem and J.F. Groote, editors, </editor> <booktitle> Proceedings of the International Conference on Typed Lambda Calculi and Applications, </booktitle> <pages> pages 306-317, </pages> <address> Utrecht, 1993. </address> <publisher> Springer LNCS 664. </publisher>
Reference-contexts: The proof strategy in Aczel's proof is the same as in the proof of confluence of -calculus with fi-reduction by Tait and Martin-Lof. In several other proofs this strategy is employed <ref> [Nip93, Tak93] </ref>. The idea is roughly as follows. A relation on terms is defined such that its transitive closure equals reduction. For this relation the diamond property is proved. <p> The format of higher-order rewriting developed by [Kha90, Kha92] is equivalent to that of CRSs but the set-up is closer to the one of -calculus and of first-order logic. Extensions of -calculus by means of conditions are studied in <ref> [Tak89, Tak93] </ref>. These `conditional -calculi' comprise many CRSs; in personal communication we have learned that a slight generalization of the conditions leads to the whole class of CRSs (in fact, even a somewhat larger class).
Reference: [Tal91] <author> C. Talcott. </author> <title> A theory of binding structures and applications to rewriting. </title> <type> Technical report, </type> <institution> Stanford University, </institution> <year> 1991. </year>
Reference: [Wol91] <author> D.A. Wolfram. </author> <title> Rewriting, and equational unification: the higher-order cases. </title> <editor> In R.V. Book, editor, </editor> <booktitle> Proceedings of the 4th International Conference on Rewriting Techniques and Applications, </booktitle> <pages> pages 25-37. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The fundamental idea leading to the present framework of CRSs was formulated by Aczel [Acz78], who devised `contraction schemes'. They do not support arbitrary complex pattern matching as in first-order TRSs, but apart from that they introduce variable-binding as in the present CRSs. 16 Wolfram <ref> [Wol91] </ref> describes a general notion of higher-order rewriting. This is the starting point for a recent formulation of higher-order rewriting that is given by Nipkow [Nip91] in his Higher-Order Rewrite Systems (HRSs). The meta-language employed for HRSs is the simply typed -calculus, facilitating the definition of substitution.
Reference: [Wol93] <author> D.A. Wolfram. </author> <title> The Clausal Theory of Types. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year> <month> 27 </month>
Reference-contexts: Above, we only established confluence for terms, not metaterms. A stronger confluence result can be obtained at once, however, admitting metavariables; let's call this for the moment `meta-confluence'. For non-orthogonal systems, the notions separate however. f Developing a model theory (semantics) for CRSs, cf. <ref> [Wol93, And86] </ref>. Whereas for first-order TRSs there is a good model theory given by the usual notion of algebra, no analogous concept is available when bound variables are present.
References-found: 49

