URL: ftp://ftp.comlab.ox.ac.uk/pub/Documents/techpapers/Tony.Hoare/hhs94.ps
Refering-URL: http://www.comlab.ox.ac.uk/oucl/users/tony.hoare/publications.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Algebraic Derivation of an Operational Semantics  
Author: C.A.R. Hoare He Jifeng Augusto Sampaio 
Abstract: Gordon Plotkin has shown how the operational semantics of a programming language can be presented in an elegantly structured style. Robin Milner has pioneered the use of various kinds of bisimulation to obtain a range of more abstract semantics of a language in the form of algebraic laws. The laws can then be used more widely in practice to reason about specifications, to transform designs and to optimise programs. In tribute to Robin Milner, we reverse the direction of the derivation. Starting with a sufficiently powerful collection of algebraic laws, we prove the correctness of an operational interpreter of the same language. The proof takes full advantage of algebraic reasoning based on the laws. The technique is illustrated on a sequential non-deterministic language suggested by Dijkstra.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. A. Bergstra and J. W. Klop. </author> <title> Algebra of Communicating Processes with Abstraction. </title> <journal> Theoretical Computer Science, </journal> <volume> 37(1) </volume> <pages> 77-121, </pages> <year> 1985. </year>
Reference-contexts: The algebraic style characterises a programming language by a somewhat complete collection of equations which are postulated to hold between programs. These can be used directly to reason about specifications, to transform designs, and to optimise programs for efficient execution. The process language ACP <ref> [1] </ref> has been defined primarily in algebraic style by Jan Bergstra and his colleagues in Amsterdam. The operational style [13] gives meaning to a program by showing how its execution can 1 be split into a sequence of atomic steps performed by a simple abstract mechanism.
Reference: [2] <author> S. D. Brooks, C. A. R. Hoare, and A. W. Roscoe. </author> <title> A Theory of Communicating Sequential Processes. </title> <journal> Journal of the ACM, </journal> <volume> 31 </volume> <pages> 560-599, </pages> <year> 1984. </year>
Reference-contexts: This style is most directly applicable to capture of requirements, and the establishment of correctness of specifications and designs, even before the program has been written. The process languages CSP and occam have been given a semantics in this style by Bill Roscoe and his colleagues at Oxford <ref> [2, 4, 5] </ref>. The algebraic style characterises a programming language by a somewhat complete collection of equations which are postulated to hold between programs. These can be used directly to reason about specifications, to transform designs, and to optimise programs for efficient execution.
Reference: [3] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, </address> <year> 1976. </year>
Reference-contexts: It is essentially the sequential non-deterministic language introduced by Dijkstra to explore the Discipline of Programming <ref> [3] </ref>. It already has a denotational semantics in terms of predicate transformers. It already has an algebraic semantics very similar to that of the relational calculus [9].
Reference: [4] <author> M. Goldsmith, A. W. Roscoe, and B. G. O. Scott. </author> <title> Denotational Semantics for occam2, </title> <journal> Part1. Transputer Communications, </journal> <volume> 1(2) </volume> <pages> 65-91, </pages> <year> 1993. </year> <month> 21 </month>
Reference-contexts: This style is most directly applicable to capture of requirements, and the establishment of correctness of specifications and designs, even before the program has been written. The process languages CSP and occam have been given a semantics in this style by Bill Roscoe and his colleagues at Oxford <ref> [2, 4, 5] </ref>. The algebraic style characterises a programming language by a somewhat complete collection of equations which are postulated to hold between programs. These can be used directly to reason about specifications, to transform designs, and to optimise programs for efficient execution.
Reference: [5] <author> M. Goldsmith, A. W. Roscoe, and B. G. O. Scott. </author> <title> Denotational Semantics for occam2, </title> <journal> Part2. Transputer Communications, </journal> <volume> 2(1) </volume> <pages> 25-67, </pages> <year> 1993. </year>
Reference-contexts: This style is most directly applicable to capture of requirements, and the establishment of correctness of specifications and designs, even before the program has been written. The process languages CSP and occam have been given a semantics in this style by Bill Roscoe and his colleagues at Oxford <ref> [2, 4, 5] </ref>. The algebraic style characterises a programming language by a somewhat complete collection of equations which are postulated to hold between programs. These can be used directly to reason about specifications, to transform designs, and to optimise programs for efficient execution.
Reference: [6] <author> M.C. Hennessy and R. Milner. </author> <title> Algebraic Laws for Nondeterminism and Concurrency. </title> <journal> Journal of ACM, </journal> <volume> 32(1): </volume> <pages> 137-161, </pages> <year> 1985. </year>
Reference-contexts: Ideally, all the presentations should be equally simple, and even the proof of their consistency should be accessible and elegant. An inspiring example is the correspondence proved between CCS modulo bisimulation and the Hennessy-Milner modal -calculus <ref> [6] </ref>, a language recommended for specification of important properties of reactive systems. Another important linkage between definitional styles is that between operational and algebraic semantics.
Reference: [7] <author> C. A. R. Hoare. </author> <title> Unified Theories of Programming. </title> <type> Technical report, </type> <institution> Oxford University Computing Laboratory, </institution> <year> 1994. </year>
Reference-contexts: The validity of the theorem depends utterly on the validity of the algebraic laws which are needed to prove it. These may be proved as theorems from one suitable model, like those used in a traditional denotational semantics of the language, as suggested in <ref> [7] </ref>. Or they may just be postulated as axioms, like those of group theory; they then constitute an axiomatic semantics of the language. <p> But no matter what the starting point, the essential goal is the same: a consistent unified theory about programming <ref> [7] </ref>, which can combine the merits of many styles of presentation, without being unduly influenced by any of them.
Reference: [8] <author> C. A. R. Hoare, J. He, and A. Sampaio. </author> <title> Normal Form Approach to Compiler Design. </title> <journal> Acta Informatica, </journal> <volume> 30 </volume> <pages> 701-739, </pages> <year> 1993. </year>
Reference-contexts: The proof is conducted exclusively at the higher conceptual level of the programming language using algebraic transformations, and avoiding more operational or inductive modes of reasoning. A similar technique has been applied in the ProCoS project to prove the correctness of a translator to machine code <ref> [8] </ref>. 2 The Language and its Algebraic Semantics The programming language contains the following operators: ? abort II skip (do nothing) x; y; . . . ; z := e; f; . . . ; g multiple assignment P ; Q sequential composition P u Q non-determinism P &lt; b &gt; <p> They are all special cases of more general theorems stated and proved in <ref> [8] </ref>. The iteration b fl P establishes the condition :b on its termination. Law 2.23 (b fl P ) = (b fl P ); (:b) ? hfl assertioni The following law allows the combination of loops with the same body.
Reference: [9] <author> C. A. R. </author> <title> Hoare et al . Laws of Programming. </title> <journal> Communications of the ACM, </journal> <volume> 30(8) </volume> <pages> 672-686, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: It is essentially the sequential non-deterministic language introduced by Dijkstra to explore the Discipline of Programming [3]. It already has a denotational semantics in terms of predicate transformers. It already has an algebraic semantics very similar to that of the relational calculus <ref> [9] </ref>. It is not difficult to write down the obviously intended operational semantics; the only challenge is to prove its correctness in an elegant fashion, one which may be generalised to more complex languages in due course. <p> In the remainder of this section we present a selection of algebraic laws which will be used to prove the correctness of an operational semantics for the language. A complete set of laws for Dijkstra's language is given in <ref> [9] </ref> 1 . To ease future reference, we associate both a number and a name with each law. skip, Abort and Sequential Composition The execution of II always terminates and leaves everything unchanged; therefore to precede or follow a program by II does not change its effect.
Reference: [10] <author> INMOS Ltd. </author> <title> occam 2 Reference Manual. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1988. </year>
Reference-contexts: An alternative goal is to define a programming language at the highest level of abstraction, so that it can be implemented, with equivalent logical effect but with differing efficiency, in a number of radically different ways. A good example is the parallelism and communication of occam <ref> [10] </ref>, which has a distributed implementation on multiprocessors, and a timeshared implementation on a single processor; or it can even be implemented by transformation to a single sequential program. That is why CSP started with a denotational and algebraic presentation rather than an operational one.
Reference: [11] <author> R. Milner. </author> <title> A Calculus of Communicating Systems. Springer-Verlag, </title> <booktitle> Lecture Notes in Computer Science 92, </booktitle> <year> 1980. </year>
Reference-contexts: This gives an essential insight into the efficiency and even the computability of the language. An operational semantics is the starting point for the process notations CCS <ref> [11] </ref>, designed and explored by Robin Milner and his colleagues at Edinburgh and elsewhere. One of the main inspirations of scientific research is the pursuit of simplicity. And simple theories are also easier to use in engineering practice.
Reference: [12] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1989. </year>
Reference-contexts: Or they may just be postulated as axioms, like those of group theory; they then constitute an axiomatic semantics of the language. Or they may be derived by some kind of bisimulation <ref> [12] </ref> from an operational semantics; in this case Theorem 4 is still a useful check of the completeness of the laws and the appropriateness of the choice of bisimulation.
Reference: [13] <author> G. D. Plotkin. </author> <title> A Structural Approach to Operational Semantics. </title> <type> Technical report, </type> <institution> DAIMI-FN-19, Aarhus University, Denmark, </institution> <year> 1981. </year> <month> 22 </month>
Reference-contexts: These can be used directly to reason about specifications, to transform designs, and to optimise programs for efficient execution. The process language ACP [1] has been defined primarily in algebraic style by Jan Bergstra and his colleagues in Amsterdam. The operational style <ref> [13] </ref> gives meaning to a program by showing how its execution can 1 be split into a sequence of atomic steps performed by a simple abstract mechanism. This gives an essential insight into the efficiency and even the computability of the language.
References-found: 13

