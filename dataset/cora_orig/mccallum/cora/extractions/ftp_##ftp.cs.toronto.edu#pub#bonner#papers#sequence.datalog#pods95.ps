URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/sequence.datalog/pods95.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: mecca@infokit.dis.uniroma1.it  bonner@db.toronto.edu  
Title: Sequences, Datalog and Transducers  
Author: Giansalvatore Mecca Anthony J. Bonner 
Note: Appears in Proceedings of the Fourteenth ACM Symposium on Principles of Database Systems (PODS), pages 23-35. Symposium held May 22-25 1995, San Jose, Ca. Invited to a special issue of Journal of Computer and System Sciences (JCSS). Research partially supported by MURST and Consiglio Nazionale delle Ricerche (CNR). Research partially supported by an operating grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).  
Address: "La Sapienza" Italy  Toronto Canada  
Affiliation: Dipartimento di Informatica e Sistemistica Universita di Roma  Department of Computer Science University of  
Abstract: This paper develops a query language for sequence databases, such as genome databases and text databases. The language, called Sequence Datalog, extends classical Datalog with interpreted function symbols for manipulating sequences. It has both a clear operational and declarative semantics, based on a new notion called the extended active domain of a database. The extended domain contains all the sequences in the database and all their subsequences. This idea leads to a clear distinction between safe and unsafe recursion over sequences: safe recursion stays inside the extended active domain, while unsafe recursion does not. By carefully limiting the amount of unsafe recursion, the paper develops a safe and expressive subset of Sequence Datalog. As part of the development, a new type of transducer is introduced, called a generalized sequence transducer. Unsafe recursion is allowed only within these generalized transducers. Generalized transducers extend ordinary transducers by allowing them to invoke other transducers as "subroutines." Generalized transducers can be implemented in Sequence Data-log in a straightforward way. Moreover, their introduction into the language leads to simple conditions that guarantee safety and finiteness. This paper develops two such conditions. The first condition expresses exactly the class of ptime sequence functions; and the second expresses exactly the class of elementary sequence functions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <journal> Journal of Comp. and Syst. Sci., </journal> <volume> 43(1), </volume> <year> 1991. </year>
Reference-contexts: where the predicate answer is defined by the following rules, where * is the empty sequence: answer (X) r (X); abc n (X [1:N 1 ]; X [N 1 + 1:N 2 ]; X [N 2 + 1:end]): abc n (*; *; *) true. abc n (X; Y; Z) X <ref> [1] </ref> = a; Y [1] = b; Z [1] = c; The formula answer (X) is true for a sequence X in r if it is possible to split X in three parts such that abc n is true. <p> is defined by the following rules, where * is the empty sequence: answer (X) r (X); abc n (X [1:N 1 ]; X [N 1 + 1:N 2 ]; X [N 2 + 1:end]): abc n (*; *; *) true. abc n (X; Y; Z) X <ref> [1] </ref> = a; Y [1] = b; Z [1] = c; The formula answer (X) is true for a sequence X in r if it is possible to split X in three parts such that abc n is true. <p> following rules, where * is the empty sequence: answer (X) r (X); abc n (X [1:N 1 ]; X [N 1 + 1:N 2 ]; X [N 2 + 1:end]): abc n (*; *; *) true. abc n (X; Y; Z) X <ref> [1] </ref> = a; Y [1] = b; Z [1] = c; The formula answer (X) is true for a sequence X in r if it is possible to split X in three parts such that abc n is true. <p> We say that a variable, X, is guarded in a clause if X occurs in the body of the clause as an argument of some predicate. Otherwise, we say that X is unguarded. For example, X is guarded in p (X <ref> [1] </ref>) q (X), whereas it is unguarded in p (X) q (X [1]). <p> Otherwise, we say that X is unguarded. For example, X is guarded in p (X <ref> [1] </ref>) q (X), whereas it is unguarded in p (X) q (X [1]). Because of the active domain semantics, variables in Sequence Datalog clauses need not to be guarded. 3.2 Semantics A substitution, , is a mapping that associates a sequence with each sequence variable in V , and an integer with each index variable in V I . <p> Note that the least fixpoint can be an infinite set. In this case, we say that the semantics of P over db is infinite; otherwise, it is finite. Also note that our semantics for sequence creation resembles the semantics of value invention in <ref> [1] </ref> in that sequences are added to the active domain as a side-effect of rule evaluation.
Reference: [2] <author> A. Albano, L. Cardelli and R. Orsini. </author> <title> Galileo: A strongly typed language for complex objects. </title> <journal> In ACM TODS, </journal> <volume> 10(2), </volume> <year> 1985. </year>
Reference-contexts: A prominent example is genome databases, in which long sequences representing genetic information are stored, and sophisticated pattern matching and restructuring facilities are needed [11]. These new applications have led to the introduction of sequence types in recent data models and query languages (e.g. <ref> [2, 4, 5, 28] </ref>). In many cases, however, queries over sequences are described only by means of a set of predefined, ad hoc operators, and are not investigated in a theoretical framework.
Reference: [3] <author> M. Atkinson, F. Bancilhon, D. DeWitt, K. Dittrich, D. Maier and Z. Zdonik. </author> <title> The object oriented database manifesto. </title> <booktitle> In DOOD, </booktitle> <year> 1989. </year>
Reference-contexts: 1 Introduction Sequences represent an important feature of Next Generation Database Systems <ref> [3, 27] </ref>. In recent years, new applications have arisen in which the storage and manipulation of sequences of unbounded length is a crucial feature. A prominent example is genome databases, in which long sequences representing genetic information are stored, and sophisticated pattern matching and restructuring facilities are needed [11].
Reference: [4] <editor> P. Atzeni, editor. LOGIDATA+: </editor> <title> Deductive Databases with Complex Objects. </title> <publisher> LNCS 701 - Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: A prominent example is genome databases, in which long sequences representing genetic information are stored, and sophisticated pattern matching and restructuring facilities are needed [11]. These new applications have led to the introduction of sequence types in recent data models and query languages (e.g. <ref> [2, 4, 5, 28] </ref>). In many cases, however, queries over sequences are described only by means of a set of predefined, ad hoc operators, and are not investigated in a theoretical framework. <p> If s 1 ; s 2 are sequence terms, then s 1 * s 2 is a constructive sequence term. Thus, if S 1 and S 2 are sequence variables, and N is an index variable, then S 1 <ref> [4] </ref>, S 1 [1:N ], and ccgt * S 1 [1:end 3] * S 2 are all sequence terms. As in most logics, the language of formulas for SequenceDatalog includes a countable set of predicate symbols, p; q; r; :::, where each predicate symbol has an associated arity.
Reference: [5] <author> F. Bancilhon, S. Cluet and C. Delobel. </author> <title> A query language for the O 2 object-oriented database system. </title> <booktitle> In DBPL, </booktitle> <year> 1989. </year>
Reference-contexts: A prominent example is genome databases, in which long sequences representing genetic information are stored, and sophisticated pattern matching and restructuring facilities are needed [11]. These new applications have led to the introduction of sequence types in recent data models and query languages (e.g. <ref> [2, 4, 5, 28] </ref>). In many cases, however, queries over sequences are described only by means of a set of predefined, ad hoc operators, and are not investigated in a theoretical framework.
Reference: [6] <author> S. Bellantoni and S. Cook. </author> <title> A new recursion-theoretic characterization of the polytime functions. </title> <booktitle> In ACM STOC, </booktitle> <year> 1992. </year>
Reference-contexts: Building on Theorem 4, we get the following result. Theorem 5 Acyclic transducer networks of order 2 express exactly the class of sequence functions computable in ptime. This theorem provides a characterization of ptime in terms of transducer networks. Other ptime characterizations have been presented in the literature (e:g:, <ref> [10, 6, 15] </ref>); but transducer networks admit a fine-grained characterization in terms of network diameter [21]. When the order of transducer networks increases from 2 to 3, the complexity of the resulting sequence functions increases dramatically, as the following theorem shows.
Reference: [7] <author> A. J. Bonner. </author> <title> Hypothetical Datalog: complexity and expressibility. </title> <journal> Theoretical Computer Science, </journal> <volume> 76, </volume> <year> 1990. </year>
Reference: [8] <author> V. Breazu-Tannen, P. Buneman and L. Wong. </author> <title> Naturally embedded query languages. </title> <booktitle> In ICDT, </booktitle> <year> 1992. </year>
Reference-contexts: This language, called Sequence Datalog, is a Horn-like logic with special, interpreted function symbols that allow for structural recursion over sequences. 2 Structural recursion has been extensively investigated in the context of set based query languages, and many interesting results have been presented (see for example <ref> [8, 19] </ref>). Unfortunately, as clearly argued in [10], such results cannot be extended to sequences. In fact, structural recursion over sequences has many peculiar aspects, the main one being that, while the number of possible sets over a finite alphabet is finite, the number of possible sequences is not.
Reference: [9] <author> A. K. Chandra and D. Harel. </author> <title> Computable queries for relational databases. </title> <journal> Journal of Comp. and Syst. Sci., </journal> <volume> 21, </volume> <year> 1980. </year>
Reference-contexts: Given a sequence query, Q, and a database, db, Q (db) is the result of evaluating Q over db. Similarly, a sequence function [10] is a partial mapping from fl to itself. A sequence function f is computable if it is partial recursive. Usually, a notion of genericity <ref> [9] </ref> is introduced for queries. The notion can be extended to sequence queries in a natural way. We say that a sequence query Q is computable [9] if it is generic and partial recursive. <p> A sequence function f is computable if it is partial recursive. Usually, a notion of genericity <ref> [9] </ref> is introduced for queries. The notion can be extended to sequence queries in a natural way. We say that a sequence query Q is computable [9] if it is generic and partial recursive. In this paper, we address the complexity of sequence functions, and the data complexity [29] of sequence queries.
Reference: [10] <author> L. S. Colby, E. L. Robertson, L. V. Saxton and D. Van Gucht. </author> <title> A query language for list based complex objects. </title> <booktitle> In ACM PODS, </booktitle> <year> 1994. </year>
Reference-contexts: Unfortunately, as clearly argued in <ref> [10] </ref>, such results cannot be extended to sequences. In fact, structural recursion over sequences has many peculiar aspects, the main one being that, while the number of possible sets over a finite alphabet is finite, the number of possible sequences is not. <p> The first kind is a sequence query, which is a straightforward generalization of relational query, i:e:, a mapping from sequences databases to sequence relations. The second kind of transformation is a sequence function, which has no counterpart in traditional database languages. Following <ref> [10] </ref>, we define a sequence function to be a mapping that takes a sequence as input and returns a sequence as output. <p> In this paper, we characterize the expressive power of subsets of Sequence Datalog in terms of sequence functions. We prove expressibility results for both the class of ptime sequence functions and the class of elementary sequence functions [23]. ptime expressibility results were first reported in <ref> [10, 15] </ref> with respect to list-based databases of complex-objects. Here, we extend those results to any hyper-exponential time function. In [17], expressibility results for intermediate types were proved in terms of hyper-exponential time. We extend these results to sequences. <p> A sequence query is a partial mapping from the set of databases over to itself. Given a sequence query, Q, and a database, db, Q (db) is the result of evaluating Q over db. Similarly, a sequence function <ref> [10] </ref> is a partial mapping from fl to itself. A sequence function f is computable if it is partial recursive. Usually, a notion of genericity [9] is introduced for queries. The notion can be extended to sequence queries in a natural way. <p> Building on Theorem 4, we get the following result. Theorem 5 Acyclic transducer networks of order 2 express exactly the class of sequence functions computable in ptime. This theorem provides a characterization of ptime in terms of transducer networks. Other ptime characterizations have been presented in the literature (e:g:, <ref> [10, 6, 15] </ref>); but transducer networks admit a fine-grained characterization in terms of network diameter [21]. When the order of transducer networks increases from 2 to 3, the complexity of the resulting sequence functions increases dramatically, as the following theorem shows.
Reference: [11] <institution> Communications of the ACM. </institution> <note> Special issue on the Human Genome project. vol.34, n.11. </note> <month> November </month> <year> 1991. </year>
Reference-contexts: In recent years, new applications have arisen in which the storage and manipulation of sequences of unbounded length is a crucial feature. A prominent example is genome databases, in which long sequences representing genetic information are stored, and sophisticated pattern matching and restructuring facilities are needed <ref> [11] </ref>. These new applications have led to the introduction of sequence types in recent data models and query languages (e.g. [2, 4, 5, 28]).
Reference: [12] <author> S. Ginsburg and X. Wang. </author> <title> Pattern matching by RS-Operations: Towards a unified approach to querying sequenced data. </title> <booktitle> In ACM PODS, </booktitle> <year> 1992. </year>
Reference-contexts: To achieve expressiveness, database researchers have developed sequence query languages based on abstract machines, such as transducers (finite automata that can generate strings as well as read them). Unfortunately, to achieve safety, they have had to impose restrictions that severely limit expressiveness (e:g:, <ref> [12, 30, 14] </ref>). 1 To address this problem, we propose a new logic called Sequence Datalog for reasoning about sequences. Sequence Datalog has both a clear declarative semantics and an operational semantics. The semantics are based on fixpoint theory, as in classical Logic Programming [20]. <p> In other cases, both expressiveness and finiteness were achieved, but at expense of an effective procedure for evaluating queries, i:e:, at the expense of an operational semantics. In <ref> [12, 30] </ref>, for example, an extended relational model is defined, where each relation is a set of tuples of sequences over a fixed alphabet. A sequence logic [12] is then developed based on the notion of rs-operations. Each rs-operation is either a merger or an extractor. <p> In [12, 30], for example, an extended relational model is defined, where each relation is a set of tuples of sequences over a fixed alphabet. A sequence logic <ref> [12] </ref> is then developed based on the notion of rs-operations. Each rs-operation is either a merger or an extractor. <p> cannot be used to express some simple properties of sequences, such as whether a certain predicate is true at every even position of a list, or whether a sequence contains one or more copies of another sequence [32]. 1.2 Overview of the Language This paper builds on the works of <ref> [12, 14, 24] </ref> to propose a query language that is safe, expressive and has a clear declarative and operational semantics. <p> Instead, the approach taken in this paper is to allow constructive recursion only in the context of a precise (and novel) computational model. The model we develop is called generalized sequence transducers (or generalized transducers, for short), which are a simple extension of ordinary transducers. Typically <ref> [12, 26, 13] </ref>, a transducer is defined as a machine with n input lines, one output line and an internal state. The machine sequentially "reads" the input strings, and progressively "computes" the output. <p> For example, the contiguous subsequences of the sequence abc are: *; a; b; c; ab; bc; abc. We now describe an extension of the relational model, in the spirit of <ref> [12, 14] </ref>. The model allows for tuples containing sequences of elements, instead of just constant symbols. A relation of arity k over is a finite subset of the k-fold cartesian product of fl with itself. A database over is a finite set of relations over . <p> To increase these capabilities|while preserving finiteness|we use an abstract computational device called a generalized sequence transducer. Transducers are low-complexity devices that take sequences as input and produce new sequences as output. They are therefore natural devices for restructuring sequences (see also <ref> [12, 14, 13, 26] </ref>). Moreover, we can exploit the low complexity of transducers to guarantee finiteness. A transducer is usually defined as a machine with n input lines, one output line, and an internal state. The 7 machine sequentially "reads" the input strings, and pro-gressively "computes" the output. <p> Although the following definition is for deterministic transducers, it can easily be generalized to allow nondeterministic computations. As such, it generalizes many of the transducer models proposed in the literature (see for example <ref> [12, 26] </ref>). Definition 1 [Generalized Transducers] A generalized n-ary sequence transducer of order k &gt; 0 is a 4-tuple hK; q 0 ; ; ffii where: 1.
Reference: [13] <author> G. H. Gonnet. </author> <title> Text dominated databases: Theory, practice and experience. </title> <booktitle> Tutorial presented at ACM PODS, </booktitle> <year> 1994. </year>
Reference-contexts: Instead, the approach taken in this paper is to allow constructive recursion only in the context of a precise (and novel) computational model. The model we develop is called generalized sequence transducers (or generalized transducers, for short), which are a simple extension of ordinary transducers. Typically <ref> [12, 26, 13] </ref>, a transducer is defined as a machine with n input lines, one output line and an internal state. The machine sequentially "reads" the input strings, and progressively "computes" the output. <p> To increase these capabilities|while preserving finiteness|we use an abstract computational device called a generalized sequence transducer. Transducers are low-complexity devices that take sequences as input and produce new sequences as output. They are therefore natural devices for restructuring sequences (see also <ref> [12, 14, 13, 26] </ref>). Moreover, we can exploit the low complexity of transducers to guarantee finiteness. A transducer is usually defined as a machine with n input lines, one output line, and an internal state. The 7 machine sequentially "reads" the input strings, and pro-gressively "computes" the output.
Reference: [14] <author> G. Grahne, M. Nykanen and E. Ukkonen. </author> <title> Reasoning about strings in databases. </title> <booktitle> In ACM PODS, </booktitle> <year> 1994. </year>
Reference-contexts: To achieve expressiveness, database researchers have developed sequence query languages based on abstract machines, such as transducers (finite automata that can generate strings as well as read them). Unfortunately, to achieve safety, they have had to impose restrictions that severely limit expressiveness (e:g:, <ref> [12, 30, 14] </ref>). 1 To address this problem, we propose a new logic called Sequence Datalog for reasoning about sequences. Sequence Datalog has both a clear declarative semantics and an operational semantics. The semantics are based on fixpoint theory, as in classical Logic Programming [20]. <p> This means that queries for which the length of the result depends on the database (such as the reverse of a sequence) cannot be expressed in the safe version of the language. This problem is partially solved in the alignment logic of <ref> [14] </ref>, an elegant and expressive first-order logic for a relational model with sequences. The computational counterpart of the logic is the class of multi-tape, nondeterministic, two-way, finite-state automata, which are used to accept or reject tuples of sequences. <p> cannot be used to express some simple properties of sequences, such as whether a certain predicate is true at every even position of a list, or whether a sequence contains one or more copies of another sequence [32]. 1.2 Overview of the Language This paper builds on the works of <ref> [12, 14, 24] </ref> to propose a query language that is safe, expressive and has a clear declarative and operational semantics. <p> For example, the contiguous subsequences of the sequence abc are: *; a; b; c; ab; bc; abc. We now describe an extension of the relational model, in the spirit of <ref> [12, 14] </ref>. The model allows for tuples containing sequences of elements, instead of just constant symbols. A relation of arity k over is a finite subset of the k-fold cartesian product of fl with itself. A database over is a finite set of relations over . <p> To increase these capabilities|while preserving finiteness|we use an abstract computational device called a generalized sequence transducer. Transducers are low-complexity devices that take sequences as input and produce new sequences as output. They are therefore natural devices for restructuring sequences (see also <ref> [12, 14, 13, 26] </ref>). Moreover, we can exploit the low complexity of transducers to guarantee finiteness. A transducer is usually defined as a machine with n input lines, one output line, and an internal state. The 7 machine sequentially "reads" the input strings, and pro-gressively "computes" the output.
Reference: [15] <author> S. Grumbach and T. Milo. </author> <title> An algebra for POMSETS. </title> <booktitle> In ICDT, </booktitle> <year> 1995. </year>
Reference-contexts: In this paper, we characterize the expressive power of subsets of Sequence Datalog in terms of sequence functions. We prove expressibility results for both the class of ptime sequence functions and the class of elementary sequence functions [23]. ptime expressibility results were first reported in <ref> [10, 15] </ref> with respect to list-based databases of complex-objects. Here, we extend those results to any hyper-exponential time function. In [17], expressibility results for intermediate types were proved in terms of hyper-exponential time. We extend these results to sequences. <p> Building on Theorem 4, we get the following result. Theorem 5 Acyclic transducer networks of order 2 express exactly the class of sequence functions computable in ptime. This theorem provides a characterization of ptime in terms of transducer networks. Other ptime characterizations have been presented in the literature (e:g:, <ref> [10, 6, 15] </ref>); but transducer networks admit a fine-grained characterization in terms of network diameter [21]. When the order of transducer networks increases from 2 to 3, the complexity of the resulting sequence functions increases dramatically, as the following theorem shows.
Reference: [16] <author> C. Hegelsen and P. R. Sibbald. </author> <title> PALM A pattern language for molecular biology. </title> <booktitle> In Proc. First Int. Conf. on Intelligent Systems for Molecular Biology (ISMB), </booktitle> <year> 1993. </year>
Reference-contexts: In many cases, however, queries over sequences are described only by means of a set of predefined, ad hoc operators, and are not investigated in a theoretical framework. In other cases, (e.g. <ref> [16, 25] </ref>) query languages concentrate on pattern extraction capabilities and do not consider sequence restructurings. Although pattern recognition is a fundamental feature of any language for querying sequences, sequence re-structurings are equally important.
Reference: [17] <author> R. Hull and J. Su. </author> <title> On the expressive power of database queries with intermediate types. </title> <journal> Journal of Comp. and System Sc., </journal> <volume> 43(1), </volume> <year> 1991. </year>
Reference-contexts: We prove expressibility results for both the class of ptime sequence functions and the class of elementary sequence functions [23]. ptime expressibility results were first reported in [10, 15] with respect to list-based databases of complex-objects. Here, we extend those results to any hyper-exponential time function. In <ref> [17] </ref>, expressibility results for intermediate types were proved in terms of hyper-exponential time. We extend these results to sequences.
Reference: [18] <author> N. Immerman. </author> <title> Relational queries computable in polynomial time. </title> <journal> Information and Control, </journal> <volume> 68, </volume> <year> 1986. </year>
Reference: [19] <author> N. Immerman, S. Patnaik and D. Stemple. </author> <title> The expressiveness of a family of finite set languages. </title> <booktitle> In ACM PODS, </booktitle> <year> 1991. </year>
Reference-contexts: This language, called Sequence Datalog, is a Horn-like logic with special, interpreted function symbols that allow for structural recursion over sequences. 2 Structural recursion has been extensively investigated in the context of set based query languages, and many interesting results have been presented (see for example <ref> [8, 19] </ref>). Unfortunately, as clearly argued in [10], such results cannot be extended to sequences. In fact, structural recursion over sequences has many peculiar aspects, the main one being that, while the number of possible sets over a finite alphabet is finite, the number of possible sequences is not.
Reference: [20] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming, Second Edition. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Sequence Datalog has both a clear declarative semantics and an operational semantics. The semantics are based on fixpoint theory, as in classical Logic Programming <ref> [20] </ref>. Thus, each Sequence Datalog program, P , has an associated operator, T P , that maps databases to databases. Each application of T P may create new atoms, which may contain new sequences. T P is monotonic and continuous and has a least fixpoint [22]. <p> Moreover, if s 1 and s 2 are sequence terms, then s 1 = s 2 and s 1 6= s 2 are also atoms. From atoms, we build rules, facts and clauses in the usual way <ref> [20] </ref>. The head and body of a clause, fl, are denoted head (fl) and body (fl), respectively. A clause that contains a constructive term in its head is called a constructive clause. <p> Thus, (s [n:end]) is a suffix of (s). Finally, (s 1 * s 2 ) is interpreted as the concatenation of (s 1 ) and (s 2 ). The semantics of rules is defined in terms of a least fixpoint theory. As in classical logic programming <ref> [20] </ref>, each Sequence Datalog program, P , has an associated operator, T P , that maps databases to databases. Each application of T P may create new atoms, which may contain new sequences. <p> db and P ; (ii) all the contiguous subsequences of the sequences in the active domain; and (iii) the set of integers f0; 1; 2; : : :; l 0 + 1g, where l 0 is the maximum length of a sequence in the active domain. * The least fixpoint <ref> [20] </ref> of the operator T P is computed in a bottom-up fashion, by starting at the database, db, and applying the operator T P repeatedly until a fixpoint is reached. <p> At each step, and for each ground instantiation of each rule in P , if the premise of the rule has been inferred, then the head of the rule is added to the set of inferred facts. Because T P is continuous, this process is complete <ref> [20] </ref>; that is, any atom in the least fixpoint of T P will eventually be inferred. * At each step, if an inferred fact contains a new sequence (i:e:, a sequence not currently in the extended active domain), then it is added to the active domain.
Reference: [21] <author> G. Mecca and A. J. Bonner. </author> <title> Generalized Sequence Transducers. </title> <note> In preparation. </note> <year> 1995. </year>
Reference-contexts: When the network has only one output, the network computes a sequence function. This section presents basic results about the complexity of generalized transducer networks. A more detailed analysis is beyond the scope of this paper and will be reported elsewhere <ref> [21] </ref>. The computational complexity of the sequence function computed by a transducer network depends on two parameters. The first is the diameter of the network, i:e:, the maximum length of a path in the network. <p> The theorems below characterize the complexity and expressibility of two classes of transducer networks, those of order 2 and 3, respectively. Higher order networks will be investigated in <ref> [21] </ref>. Our first results concern the output size of transducer networks. <p> This theorem provides a characterization of ptime in terms of transducer networks. Other ptime characterizations have been presented in the literature (e:g:, [10, 6, 15]); but transducer networks admit a fine-grained characterization in terms of network diameter <ref> [21] </ref>. When the order of transducer networks increases from 2 to 3, the complexity of the resulting sequence functions increases dramatically, as the following theorem shows. Theorem 6 Acyclic transducer networks of order 3 express exactly the class of elementary sequence functions. <p> There is a close relationship between the diameter of transducer networks and levels in the hyper-exponential hierarchy. For instance, any sequence function in exptime can be expressed by a single transducer of order 3. These ideas are developed in <ref> [21] </ref>. 5 Sequence Datalog with Transducers This section develops a new language by introducing generalized transducers into Sequence Datalog. This new language forms the basis of a safe and finite query language for sequence databases in the next section.
Reference: [22] <author> G. Mecca and A. J. Bonner. </author> <title> Sequences, Datalog and Transducers. </title> <type> Technical Report. </type> <note> In preparation. </note> <year> 1995. </year>
Reference-contexts: Thus, each Sequence Datalog program, P , has an associated operator, T P , that maps databases to databases. Each application of T P may create new atoms, which may contain new sequences. T P is monotonic and continuous and has a least fixpoint <ref> [22] </ref>. If the least fixpoint is finite, then we say that the program has a finite semantics; otherwise, it has an infinite semantics. We show that Sequence Datalog can express all computable sequence functions. <p> Here, we extend those results to any hyper-exponential time function. In [17], expressibility results for intermediate types were proved in terms of hyper-exponential time. We extend these results to sequences. In <ref> [22] </ref>, we extend our results 4 about function expressibility to results about query ex--pressibility by introducing negation into the language. 2 Preliminary Definitions This section provides technical definitions used in the rest of the paper, including sequence database, sequence query and sequence function. <p> The predicate comp specifies that 0 and 1 are complementary. 2 The rest of this section presents the syntax and semantics of Sequence Datalog. Due to space limitations, only informal definitions are possible. A complete, formal development can be found in <ref> [22] </ref>. 3.1 Syntax SequenceDatalog has two interpreted function symbols for constructing complex terms, one for concatenating sequences and one for extracting subsequences. Intuitively, if X and Y are sequences, then the term X * Y denotes the concatenation of X and Y . <p> Each application of T P may create new atoms, which may contain new sequences. The operator T P is monotonic and continuous, and thus has a least fixpoint that can be computed in a bottom-up, iterative fashion <ref> [22] </ref>. Based on this fixpoint semantics, a model theory for Sequence Datalog can be developed in a straightforward way [22]. <p> The operator T P is monotonic and continuous, and thus has a least fixpoint that can be computed in a bottom-up, iterative fashion <ref> [22] </ref>. Based on this fixpoint semantics, a model theory for Sequence Datalog can be developed in a straightforward way [22]. To be more precise, we define the fixpoint semantics of a program, P , over a database, db, as follows: * The extended active domain of a database, db, with respect to a program, P , is denoted D ext P;db . <p> Theorem 1 Sequence Datalog expresses exactly the class of computable sequence functions. Note that although Sequence Datalog is function complete, it is not query complete, since it only expresses monotonic queries. Functional completeness is, however, a necessary condition for query completeness. In <ref> [22] </ref>, we show that Sequence Datalog with negation can express any computable query. Theorem 1 implies that the property of finiteness is undecidable. Theorem 2 The finiteness property is undecidable for Sequence Datalog programs. Subsequent sections define subsets of Sequence Dat-alog that are finite. <p> That is, if the least fixpoint of a Transducer Datalog program over a database can be computed in time t, then the fixpoint of the translation can be computed in time O (t) <ref> [22] </ref>.
Reference: [23] <author> C. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: For instance, with one level of transducer subroutine calls, it can express any mapping from sequences to sequences computable in ptime. With two levels of subroutine calls, it can express any mapping from sequences to sequences in the elementary functions <ref> [23] </ref>. The semantics, the finiteness property and the expressive power represent the main contributions of this paper. 1.1 Background The trade-off between expressiveness, finiteness and effective computability is typically a hard one. <p> The computational counterpart of the logic is the class of multi-tape, nondeterministic, two-way, finite-state automata, which are used to accept or reject tuples of sequences. In its full version, alignment logic has the power of recursively enumerable sets <ref> [23] </ref>. A subset of the language, called right restricted formulas is then presented. For this subset, the safety problem is shown to be decidable, and some complexity results related to the polynomial-time hierarchy are presented. Unfortunately, the nondeterministic nature of the computational model makes the evaluation of queries problematic. <p> In short, function expressibility is necessary for query expressibility. In this paper, we characterize the expressive power of subsets of Sequence Datalog in terms of sequence functions. We prove expressibility results for both the class of ptime sequence functions and the class of elementary sequence functions <ref> [23] </ref>. ptime expressibility results were first reported in [10, 15] with respect to list-based databases of complex-objects. Here, we extend those results to any hyper-exponential time function. In [17], expressibility results for intermediate types were proved in terms of hyper-exponential time. We extend these results to sequences. <p> Intuitively, the order of a network is the maximum depth of subtransducer nesting. We now establish a basic result about the complexity of acyclic networks. This result involves the elementary sequence functions <ref> [23] </ref>, which are defined in terms of the hyper-exponential functions, hyp i (n). These latter functions are defined recursively as follows: * hyp 0 (n) = n hyp i is called the hyper-exponential function of level i.
Reference: [24] <author> J. Richardson. </author> <title> Supporting lists in a data model (A timely approach). </title> <booktitle> In VLDB, </booktitle> <year> 1992. </year>
Reference-contexts: In fact, existential quantification over the infinite universe of sequences, fl , is allowed; thus, even when the query is known to be safe, it is not easy to determine the maximum length of the result. Another interesting proposal for the use of logic in querying sequences is <ref> [24] </ref>. In this case, temporal logic is used as a base for a list query language. Conceptually, each successive position in a list is interpreted as a successive instance in time. This yields a query language in which temporal predicates can be used to investigate the properties of lists. <p> cannot be used to express some simple properties of sequences, such as whether a certain predicate is true at every even position of a list, or whether a sequence contains one or more copies of another sequence [32]. 1.2 Overview of the Language This paper builds on the works of <ref> [12, 14, 24] </ref> to propose a query language that is safe, expressive and has a clear declarative and operational semantics.
Reference: [25] <author> D. B. </author> <title> Searls. String Variable Grammars: a logic grammar formalism for DNA sequences. </title> <type> Tech. Report, </type> <institution> University of Pennsylvania School of Medicine, </institution> <year> 1993. </year>
Reference-contexts: In many cases, however, queries over sequences are described only by means of a set of predefined, ad hoc operators, and are not investigated in a theoretical framework. In other cases, (e.g. <ref> [16, 25] </ref>) query languages concentrate on pattern extraction capabilities and do not consider sequence restructurings. Although pattern recognition is a fundamental feature of any language for querying sequences, sequence re-structurings are equally important. <p> in Sequence Datalog: rep 1 (X; X) true: rep 1 (X; X [1:N ])) rep 1 (X [N + 1:end]; X [1:N ]): rep 2 (X; X) true: rep 2 (X * Y; Y ) rep 2 (X; Y ): 3 Repetitive patterns are of great importance in Molecular Biology <ref> [25] </ref>. 3 The formulas rep 1 (X; Y ) and rep 2 (X; Y ) both mean that X has the form Y n for some n. However, rep 2 has an infinite semantics, while rep 1 has a finite semantics. <p> Termination is therefore guaranteed for finite-length inputs. Unfortunately, ordinary transducers have very low complexity, essentially linear time. This means that they cannot perform complex operations, such as detecting context-free or context-sensitive languages, as it is often needed in genome databases <ref> [25] </ref>. We generalize this machine model by allowing one transducer to call other transducers, in the style of subroutines. At each step, a generalized transducer can append a symbol to its output or it can transform its output by invoking a sub-transducer.
Reference: [26] <author> D. Stott Parker, E. Simon and P. Valduriez. </author> <title> SVP a model capturing sets, streams and parallelism. </title> <booktitle> In VLDB, </booktitle> <year> 1992. </year>
Reference-contexts: Instead, the approach taken in this paper is to allow constructive recursion only in the context of a precise (and novel) computational model. The model we develop is called generalized sequence transducers (or generalized transducers, for short), which are a simple extension of ordinary transducers. Typically <ref> [12, 26, 13] </ref>, a transducer is defined as a machine with n input lines, one output line and an internal state. The machine sequentially "reads" the input strings, and progressively "computes" the output. <p> To increase these capabilities|while preserving finiteness|we use an abstract computational device called a generalized sequence transducer. Transducers are low-complexity devices that take sequences as input and produce new sequences as output. They are therefore natural devices for restructuring sequences (see also <ref> [12, 14, 13, 26] </ref>). Moreover, we can exploit the low complexity of transducers to guarantee finiteness. A transducer is usually defined as a machine with n input lines, one output line, and an internal state. The 7 machine sequentially "reads" the input strings, and pro-gressively "computes" the output. <p> Although the following definition is for deterministic transducers, it can easily be generalized to allow nondeterministic computations. As such, it generalizes many of the transducer models proposed in the literature (see for example <ref> [12, 26] </ref>). Definition 1 [Generalized Transducers] A generalized n-ary sequence transducer of order k &gt; 0 is a 4-tuple hK; q 0 ; ; ffii where: 1.
Reference: [27] <author> The Committee for Advanced DBMS functions. </author> <title> Third-generation database system manifesto. </title> <booktitle> In SIGMOD Record, </booktitle> <volume> 19(3), </volume> <year> 1990. </year>
Reference-contexts: 1 Introduction Sequences represent an important feature of Next Generation Database Systems <ref> [3, 27] </ref>. In recent years, new applications have arisen in which the storage and manipulation of sequences of unbounded length is a crucial feature. A prominent example is genome databases, in which long sequences representing genetic information are stored, and sophisticated pattern matching and restructuring facilities are needed [11].
Reference: [28] <author> S. Vandenberg and D. De Witt. </author> <title> Algebraic support for complex objects with arrays, identity and inheritance. </title> <booktitle> In ACM SIGMOD, </booktitle> <year> 1991. </year>
Reference-contexts: A prominent example is genome databases, in which long sequences representing genetic information are stored, and sophisticated pattern matching and restructuring facilities are needed [11]. These new applications have led to the introduction of sequence types in recent data models and query languages (e.g. <ref> [2, 4, 5, 28] </ref>). In many cases, however, queries over sequences are described only by means of a set of predefined, ad hoc operators, and are not investigated in a theoretical framework.
Reference: [29] <author> M. Vardi. </author> <title> The complexity of relational query languages. </title> <booktitle> In ACM STOC, </booktitle> <year> 1982. </year>
Reference-contexts: The notion can be extended to sequence queries in a natural way. We say that a sequence query Q is computable [9] if it is generic and partial recursive. In this paper, we address the complexity of sequence functions, and the data complexity <ref> [29] </ref> of sequence queries. Given a sequence function, f, the complexity of f is defined in the usual way, as the complexity of computing f (), measured with respect to the length of the sequence .
Reference: [30] <author> X. Wang. </author> <title> Pattern matching by RS-Operations: towards a unified approach to querying sequenced data. </title> <type> PhD Dissertation, </type> <institution> University of Southern California, </institution> <year> 1992. </year>
Reference-contexts: To achieve expressiveness, database researchers have developed sequence query languages based on abstract machines, such as transducers (finite automata that can generate strings as well as read them). Unfortunately, to achieve safety, they have had to impose restrictions that severely limit expressiveness (e:g:, <ref> [12, 30, 14] </ref>). 1 To address this problem, we propose a new logic called Sequence Datalog for reasoning about sequences. Sequence Datalog has both a clear declarative semantics and an operational semantics. The semantics are based on fixpoint theory, as in classical Logic Programming [20]. <p> In other cases, both expressiveness and finiteness were achieved, but at expense of an effective procedure for evaluating queries, i:e:, at the expense of an operational semantics. In <ref> [12, 30] </ref>, for example, an extended relational model is defined, where each relation is a set of tuples of sequences over a fixed alphabet. A sequence logic [12] is then developed based on the notion of rs-operations. Each rs-operation is either a merger or an extractor. <p> A safe subset of the language is then defined and proven equivalent to the s-algebra. Intuitively, the safe version of the s-calculus is restricted to queries for which it is possible to bound, independently of the database, the length of sequences in the final result and in intermediate results <ref> [30] </ref>. This means that queries for which the length of the result depends on the database (such as the reverse of a sequence) cannot be expressed in the safe version of the language.
Reference: [31] <author> J.D. Watson, et al. </author> <title> Molecular Biology of the Gene, Fourth Edition. </title> <publisher> Benjamin/Cummings Publishing Company, </publisher> <year> 1987. </year> <month> 13 </month>
Reference-contexts: To translate RNA into protein, ribonucleotides are grouped into triplets, called codons, such as aug, acg, ggu, : : : 5 Each codon is then translated into a 4 For simplicity, this example ignores complications such as intron splicing <ref> [31] </ref>, even though it can be encoded in Transducer Datalog without difficulty. 5 This grouping is analogous to the grouping of bits into bytes in computers. single amino-acid. Different codons may have the same translation. <p> Example 5.3 [Simulating Transducers] The Sequence Datalog program below simulates the Transducer Datalog rule in Example 5.1: 6 For simplicity, this example ignores complications such as reading frames, ribosomal binding sites, and stop codons <ref> [31] </ref>. 11 rna seq (R) dna seq (D); transcribe (D; R): transcribe (D [1:N + 1]; R * T ) dna seq (D); transcribe (D [1:N ]; R); trans (D [N + 1]; T ): transcribe (*; *) true: trans (a; u) true: trans (t; a) true: trans (g; c) true:
Reference: [32] <author> P. Wolper. </author> <title> Temporal logic can be more expressive. </title> <journal> Information and Control, </journal> <volume> 56, </volume> <year> 1983. </year> <month> 14 </month>
Reference-contexts: However, temporal logic cannot be used to express some simple properties of sequences, such as whether a certain predicate is true at every even position of a list, or whether a sequence contains one or more copies of another sequence <ref> [32] </ref>. 1.2 Overview of the Language This paper builds on the works of [12, 14, 24] to propose a query language that is safe, expressive and has a clear declarative and operational semantics.
References-found: 32

