URL: http://www.cs.jhu.edu/labs/pll/papers/constrained.ps
Refering-URL: http://www.cs.jhu.edu/labs/pll/home.html
Root-URL: http://www.cs.jhu.edu
Title: Constrained Types: A Personal Perspective  
Author: Scott Fraser Smith 
Date: September 18, 1996  
Address: Baltimore, MD 21218  
Affiliation: Department of Computer Science The Johns Hopkins University  
Abstract-found: 0
Intro-found: 1
Reference: [AC95] <author> Martn Abadi and Luca Cardelli. </author> <title> On subtyping and matching. </title> <editor> In W. Olthoff, editor, </editor> <booktitle> Proceedings ECOOP '95, </booktitle> <volume> LNCS 952, </volume> <pages> pages 145-167, </pages> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: The objects created from these class types have recursive type. So, the two special forms of type needed for objects are F-bounded polymorphic types (or the closely related second-order polymorphic types <ref> [AC95] </ref>), and recursive types. There are many other approaches to typing objects and new ones are still being proposed at a rapid rate [Cas95, BM96, PS94]; a comparison of these schools is beyond the scope of this paper.
Reference: [AC96] <author> M. Abadi and L. Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: We follow what could be called the standard school of object-oriented programming which is based around the concepts of class, object, message send, inheritance, method, dynamic dispatch, method override, public/private, and self. Concepts we are less directly concerned with include multiple dispatch [Cas95], object method override <ref> [AC96] </ref>, and object extension [MHF93]. We follow the standard school with the aim to make our work the most relevant, although many of the ideas do have application to the nonstandard schools.
Reference: [Aik94] <author> A. Aiken. </author> <title> The illyria system. </title> <note> http://http.cs.berkeley.edu/~aiken/, 1994. </note>
Reference-contexts: At module boundaries, type information must be shown, for it also serves as the module specification. The key tool required to deal with type complexity is constraint simplification. Most constraint sets contain significantly more verbose types than are necessary. Curtis and Aiken both early recognized the importance of simplification <ref> [Cur90, Aik94] </ref>. 4 Result 5 We have developed a set of powerful constrained type simplifications, such as detecting and removing inaccessible ("garbage") constraints. Furthermore, the simplifications have been proven correct [EST95a, appendix].
Reference: [AW93] <author> A. Aiken and E. L. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <year> 1993. </year> <title> 2 The flow analysis of [JW95b] does not exactly correspond to polymorphic constrained type inference for two technical reasons: (1) the splitting they perform is somewhat less general than let-polymorphism, to possibly achieve more efficiency; and (2) they perform some additional analysis on if-expressions. </title> <type> 7 </type>
Reference-contexts: This flexibility allowed in the constraint sets means the types are quite expressive. The notion of constrained type that we use was originally formulated in [Cur90]; <ref> [AW93, AWL94] </ref> formulate a similar version with a somewhat richer collection of type operations including limited union and intersection types, a type complement, and a notion of conditional type. <p> However it could infer an inconsistent constraint set, e.g. 5 (2) will infer the inconsistent constraint Int t 0 !t 1 . It is possible to perform let-polymorphic type inference for constrained types, generalizing the Hindley/Milner algorithm found in languages such as Standard ML and Haskell to constrained types <ref> [Cur90, AW93] </ref>. Polymorphic type inference in a setting with constraints produces type schemes of the form 8t 1 ; : : : ; t n : t n C, generalizing the type schemes 8t 1 ; : : : ; t n : t produced by the Hindley/Milner algorithm. <p> This required an extension of the subject-reduction proof technique to a form which preserves the constraint sets during reduction. The ideal model used in previous soundness proofs <ref> [AW93] </ref> models functional languages only. One foundational problem we wish to address is to better connect constrained types with constraint-free type theories to better understand their fundamental nature.
Reference: [AWL94] <author> A. Aiken, E. L. Wimmers, and T. K. Lakshman. </author> <title> Soft typing with conditional types. </title> <booktitle> In Conference Record of the Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <year> 1994. </year>
Reference-contexts: This flexibility allowed in the constraint sets means the types are quite expressive. The notion of constrained type that we use was originally formulated in [Cur90]; <ref> [AW93, AWL94] </ref> formulate a similar version with a somewhat richer collection of type operations including limited union and intersection types, a type complement, and a notion of conditional type. <p> We then prove 8 obs is the same as 8 sem , a novel full type abstraction property that confirms our choice of type model. The ideal model [MPS86] may also be used as a basis of a constrained type ordering 8 ideal <ref> [AWL94] </ref>, but it is not fully abstract in this sense. 8 sem is a complex relation: it is open whether 8 sem is decidable, and we develop a powerful decidable approximation 8 dec . These results improve on previous work which defined weaker relations [EST95a, Pot96, Jim96].
Reference: [BCC + 95] <author> Kim Bruce, Luca Cardelli, Giuseppe Castagna, Valery Trifonov) The Hopkins Objects Group (Scott Smith, Jonathan Eifrig, Gary T. Leavens, and Benjamin Pierce. </author> <title> On binary methods. </title> <journal> Theory and Practice of Object Systems, </journal> <volume> 1(3) </volume> <pages> 217-238, </pages> <year> 1995. </year>
Reference-contexts: We did participate in an effort to compare at least some of the schools. Result 6 In collaboration with other researchers in the area, we wrote a paper comparing some of the different approaches to typing object-oriented programs <ref> [BCC + 95] </ref>, focusing on the difficult problem of typing binary methods. Our original work in the area of object typing was a precise reformulation of the Abel group's work.
Reference: [BM96] <author> Fran~cois Bourdoncle and Stephan Merz. </author> <title> On the integration of functional programming, class-based object-oriented programming, and multi-methods. </title> <type> Technical Report 26, </type> <institution> Centre des Mathematiques Appliquees, Ecole des Mines de Paris, </institution> <year> 1996. </year> <note> Available at http://www.ensmp.fr/~bourdonc/. </note>
Reference-contexts: Versions of constrained types which either disallow recursive constraints <ref> [Smi94, Kae92, BM96] </ref> or use a notion of subtyping which relates types with the same structure only [Mit84, Mit91, MR85, FM88] have also been studied but are of less interest for our approach to typing classes and objects (discussed in Section 6 below) which requires recursion and record subtyping. 1 One <p> These results improve on previous work which defined weaker relations [EST95a, Pot96, Jim96]. Subtyping relations for constrained types have also been studied for non-recursive constraint sets <ref> [Smi94, BM96] </ref>. <p> So, the two special forms of type needed for objects are F-bounded polymorphic types (or the closely related second-order polymorphic types [AC95]), and recursive types. There are many other approaches to typing objects and new ones are still being proposed at a rapid rate <ref> [Cas95, BM96, PS94] </ref>; a comparison of these schools is beyond the scope of this paper. We did participate in an effort to compare at least some of the schools.
Reference: [Bru94] <author> Kim Bruce. </author> <title> A paradigmatic object-oriented programming language: Design, static typing and semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 4 </volume> <pages> 127-206, </pages> <year> 1994. </year>
Reference-contexts: We generally follow the Abel group's methodology for typing classes and objects [CCH + 89, CHC90]; this approach has been modified and extended extended by Bruce <ref> [Bru94, BSvG95] </ref>. The key idea used to type classes and objects is as follows. Classes may have so-called binary methods whose types refer to the type of objects of their own class; for instance an object with an equal method takes as parameter another object of its own type.
Reference: [BSvG95] <author> Kim B. Bruce, Angela Schuett, and Robert van Gent. PolyTOIL: </author> <title> A type-safe polymorphic object-oriented language. </title> <booktitle> In ECOOP '95, </booktitle> <year> 1995. </year>
Reference-contexts: We generally follow the Abel group's methodology for typing classes and objects [CCH + 89, CHC90]; this approach has been modified and extended extended by Bruce <ref> [Bru94, BSvG95] </ref>. The key idea used to type classes and objects is as follows. Classes may have so-called binary methods whose types refer to the type of objects of their own class; for instance an object with an equal method takes as parameter another object of its own type. <p> In particular, there is a well-known trade-off between subtyping and inheritance. Most object-oriented languages require the choice of one approach exclusive of the other. For instance in C++ and Object Pascal, inheritance is subtyping, so binary methods will not inherit properly. In PolyTOIL <ref> [BSvG95] </ref> and our Loop language [ESTZ94], inheritance is not subtyping, so binary methods inherit properly but object subtyping is restricted in some cases.
Reference: [Cas95] <author> Giuseppe Castagna. </author> <title> Covariance and contravariance: conflict without a cause. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(3), </volume> <year> 1995. </year>
Reference-contexts: Module signatures are also of interest. We follow what could be called the standard school of object-oriented programming which is based around the concepts of class, object, message send, inheritance, method, dynamic dispatch, method override, public/private, and self. Concepts we are less directly concerned with include multiple dispatch <ref> [Cas95] </ref>, object method override [AC96], and object extension [MHF93]. We follow the standard school with the aim to make our work the most relevant, although many of the ideas do have application to the nonstandard schools. <p> So, the two special forms of type needed for objects are F-bounded polymorphic types (or the closely related second-order polymorphic types [AC95]), and recursive types. There are many other approaches to typing objects and new ones are still being proposed at a rapid rate <ref> [Cas95, BM96, PS94] </ref>; a comparison of these schools is beyond the scope of this paper. We did participate in an effort to compare at least some of the schools.
Reference: [CCH + 89] <author> P. Canning, W. Cook, W. Hill, J. Mitchell, and W. Olthoff. </author> <title> F-bounded polymorphism for object-oriented programming. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <year> 1989. </year>
Reference-contexts: We generally follow the Abel group's methodology for typing classes and objects <ref> [CCH + 89, CHC90] </ref>; this approach has been modified and extended extended by Bruce [Bru94, BSvG95]. The key idea used to type classes and objects is as follows. <p> An appropriate type that expresses this is of the general form 8selfTy Obj (: : : ; equal : selfTy ! Bool; : : :):t , a so-called F-bounded polymorphic type <ref> [CCH + 89] </ref>. The objects created from these class types have recursive type. So, the two special forms of type needed for objects are F-bounded polymorphic types (or the closely related second-order polymorphic types [AC95]), and recursive types.
Reference: [CHC90] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: We generally follow the Abel group's methodology for typing classes and objects <ref> [CCH + 89, CHC90] </ref>; this approach has been modified and extended extended by Bruce [Bru94, BSvG95]. The key idea used to type classes and objects is as follows.
Reference: [Cur90] <author> Pavel Curtis. </author> <title> Constrained quantification in polymorphic type analysis. </title> <type> Technical Report CSL-90-1, </type> <institution> XEROX Palo Alto Research Center, CSLPubs.parc@xerox.com, </institution> <year> 1990. </year>
Reference-contexts: This flexibility allowed in the constraint sets means the types are quite expressive. The notion of constrained type that we use was originally formulated in <ref> [Cur90] </ref>; [AW93, AWL94] formulate a similar version with a somewhat richer collection of type operations including limited union and intersection types, a type complement, and a notion of conditional type. <p> However it could infer an inconsistent constraint set, e.g. 5 (2) will infer the inconsistent constraint Int t 0 !t 1 . It is possible to perform let-polymorphic type inference for constrained types, generalizing the Hindley/Milner algorithm found in languages such as Standard ML and Haskell to constrained types <ref> [Cur90, AW93] </ref>. Polymorphic type inference in a setting with constraints produces type schemes of the form 8t 1 ; : : : ; t n : t n C, generalizing the type schemes 8t 1 ; : : : ; t n : t produced by the Hindley/Milner algorithm. <p> At module boundaries, type information must be shown, for it also serves as the module specification. The key tool required to deal with type complexity is constraint simplification. Most constraint sets contain significantly more verbose types than are necessary. Curtis and Aiken both early recognized the importance of simplification <ref> [Cur90, Aik94] </ref>. 4 Result 5 We have developed a set of powerful constrained type simplifications, such as detecting and removing inaccessible ("garbage") constraints. Furthermore, the simplifications have been proven correct [EST95a, appendix].
Reference: [EST95a] <author> J. Eifrig, S. Smith, and V. Trifonov. </author> <title> Sound polymorphic type inference for objects. </title> <booktitle> In OOPSLA '95, </booktitle> <pages> pages 169-184, </pages> <year> 1995. </year>
Reference-contexts: These results improve on previous work which defined weaker relations <ref> [EST95a, Pot96, Jim96] </ref>. Subtyping relations for constrained types have also been studied for non-recursive constraint sets [Smi94, BM96]. <p> Curtis and Aiken both early recognized the importance of simplification [Cur90, Aik94]. 4 Result 5 We have developed a set of powerful constrained type simplifications, such as detecting and removing inaccessible ("garbage") constraints. Furthermore, the simplifications have been proven correct <ref> [EST95a, appendix] </ref>. Simplification as defined above proceeds without loss of type information (the simplified type is both 8 and 8 the original). There is an additional need for an interactive tool for simplification which may simplify with loss of generality. <p> Next, we developed an object-oriented, stateful, constrained type language, I-Loop, to show how constrained type inference may be concretely applied in an object-oriented setting <ref> [EST95a] </ref>. To give an idea of the I-Loop language and type system we present a very simple example.
Reference: [EST95b] <author> J. Eifrig, S. Smith, and V. Trifonov. </author> <title> Type inference for recursively constrained types and its application to OOP. </title> <booktitle> In Proceedings of the 1995 Mathematical Foundations of Programming Semantics Conference, volume 1 of Electronic Notes in Theoretical Computer Science. </booktitle> <publisher> Elsevier, </publisher> <year> 1995. </year> <note> http://www.elsevier.nl/locate/entcs/volume1.html. </note>
Reference-contexts: Thus, in presence of subtyping constraints it is appropriate to preserve the constraints inferred explicitly, and infer constrained types t n C. 2 Result 1 <ref> [EST95b] </ref> develops a constrained type inference algorithm for languages with references. This required an extension of the subject-reduction proof technique to a form which preserves the constraint sets during reduction. The ideal model used in previous soundness proofs [AW93] models functional languages only. <p> Result 7 We directly verified the Abel group's informal methodology by developing the first type-sound, context-free encoding of class-based, stateful, objects into a typed language with state, F-bounded polymorphic types, and recursive types <ref> [EST95b] </ref>. In order to do this we had to develop more powerful type rules for recursive types and F-bounded types than previously existed, and prove soundness of these rules. We also established the decidability of type-checking for this language [ESTZ94]. <p> Result 8 We initially showed how, via an encoding of classes and objects in terms of records and references, constrained types produce expressive types for objects <ref> [EST95b] </ref>. Next, we developed an object-oriented, stateful, constrained type language, I-Loop, to show how constrained type inference may be concretely applied in an object-oriented setting [EST95a]. To give an idea of the I-Loop language and type system we present a very simple example.
Reference: [ESTZ94] <author> J. Eifrig, S. Smith, V. Trifonov, and A. Zwarico. </author> <title> Application of OOP type theory: State, decidability, integration. </title> <booktitle> In OOPSLA '94, </booktitle> <pages> pages 16-30, </pages> <year> 1994. </year>
Reference-contexts: In order to do this we had to develop more powerful type rules for recursive types and F-bounded types than previously existed, and prove soundness of these rules. We also established the decidability of type-checking for this language <ref> [ESTZ94] </ref>. The afore-cited paper was one of the first studies to show the feasibility of obtaining fully satisfactory semantics for typed object-oriented languages via type-based encodings into non-object-oriented typed languages. <p> In particular, there is a well-known trade-off between subtyping and inheritance. Most object-oriented languages require the choice of one approach exclusive of the other. For instance in C++ and Object Pascal, inheritance is subtyping, so binary methods will not inherit properly. In PolyTOIL [BSvG95] and our Loop language <ref> [ESTZ94] </ref>, inheritance is not subtyping, so binary methods inherit properly but object subtyping is restricted in some cases.
Reference: [FFK + 96] <author> Cormac Flanagan, Matthew Flatt, Shriram Krishnamurthi, Stephanie Weirich, and Matthias Felleisen. </author> <title> Catching bugs in the web of program invariants. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 23-32, </pages> <year> 1996. </year>
Reference-contexts: However, CASE tools can be developed which show the flow to the programmer and thus sidestep the requirement for explicit type information. MrSpidey, a CASE tool for Scheme, analyzes programs and can illustrate a potentially bad flow by a sequence of arrows decorating the program syntax <ref> [FFK + 96] </ref>. Their system is based on SBA. We independently have developed a different scheme. Result 4 A prototype system has been developed to illustrates the flow leading to a type error [Wan96].
Reference: [FM88] <author> Y.-C. Fuh and P. Mishra. </author> <title> Type inference with subtypes. </title> <booktitle> In European Symposium on Programming, </booktitle> <year> 1988. </year> <month> 8 </month>
Reference-contexts: Versions of constrained types which either disallow recursive constraints [Smi94, Kae92, BM96] or use a notion of subtyping which relates types with the same structure only <ref> [Mit84, Mit91, MR85, FM88] </ref> have also been studied but are of less interest for our approach to typing classes and objects (discussed in Section 6 below) which requires recursion and record subtyping. 1 One consequence of such a type representation is the possibility for over-constraining a type, for instance t !
Reference: [Hei94] <author> N. Heintze. </author> <title> Set based analysis of ML programs. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 306-317, </pages> <year> 1994. </year>
Reference-contexts: Result 9 In [PS96] we establish an isomorphism between a 0CFA-based [Shi88] type-checking algorithm [PS92] and a monomorphic constrained type system studied: the two systems accept precisely the same programs. Monomorphic constrained types are also (nearly) isomorphic to Heintze's Set-Based Analysis (SBA) technique <ref> [Hei94] </ref>, a fact proved directly in [McA96], and also provable by combining a proof of equivalence of 0CFA and SBA in [JW95a] with Previous Result 9.
Reference: [Jim96] <author> Trevor Jim. </author> <title> Principal typings and type inference. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: These results improve on previous work which defined weaker relations <ref> [EST95a, Pot96, Jim96] </ref>. Subtyping relations for constrained types have also been studied for non-recursive constraint sets [Smi94, BM96].
Reference: [JW95a] <author> Suresh Jagannathan and Stephen Weeks. </author> <title> A unified treatment of flow analysis in higher-order languages. </title> <booktitle> In Conference Record of the Twenty-Second Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 393-408, </pages> <year> 1995. </year>
Reference-contexts: Monomorphic constrained types are also (nearly) isomorphic to Heintze's Set-Based Analysis (SBA) technique [Hei94], a fact proved directly in [McA96], and also provable by combining a proof of equivalence of 0CFA and SBA in <ref> [JW95a] </ref> with Previous Result 9.
Reference: [JW95b] <author> Suresh Jagannathan and Andrew Wright. </author> <title> Effective flow analysis for avoiding run-time checks. </title> <booktitle> In Proceedings of the 2nd International Static Analysis Symposium, volume 983 of LNCS, </booktitle> <pages> pages 207-224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: However, these constraints contain flow information for subterms, and so from the flow perspective are not garbage. (They can be considered garbage once flow information for subterms is no longer needed.) Polymorphic constrained types are closely related to the idea of polymorphic splitting found in the flow analysis of <ref> [JW95b] </ref>.
Reference: [Kae92] <author> S. Kaes. </author> <title> Type inference in the presence of overloading, subtyping and recursive types. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 193-204, </pages> <year> 1992. </year>
Reference-contexts: Versions of constrained types which either disallow recursive constraints <ref> [Smi94, Kae92, BM96] </ref> or use a notion of subtyping which relates types with the same structure only [Mit84, Mit91, MR85, FM88] have also been studied but are of less interest for our approach to typing classes and objects (discussed in Section 6 below) which requires recursion and record subtyping. 1 One
Reference: [KPS94] <author> D. Kozen, J. Palsberg, and M. I. Schwartzbach. </author> <title> Efficient inference of partial types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 49(2) </volume> <pages> 306-324, </pages> <year> 1994. </year>
Reference-contexts: For (i), the monomorphic inference algorithm is known to be O (n 3 ) <ref> [KPS94] </ref>. Monomorphic constrained type inference is very similar to Heintze's Set Based Analysis (SBA; a topic discussed in Section 7), and Heintze asserts his algorithm is "almost linear in practice". Let-polymorphism is theoretically exponential but "linear in practice", so the question is how these two will compose.
Reference: [McA96] <author> David McAllester. </author> <title> Recursion polymorphism in soft typing. </title> <type> Preprint, </type> <month> July </month> <year> 1996. </year>
Reference-contexts: Result 9 In [PS96] we establish an isomorphism between a 0CFA-based [Shi88] type-checking algorithm [PS92] and a monomorphic constrained type system studied: the two systems accept precisely the same programs. Monomorphic constrained types are also (nearly) isomorphic to Heintze's Set-Based Analysis (SBA) technique [Hei94], a fact proved directly in <ref> [McA96] </ref>, and also provable by combining a proof of equivalence of 0CFA and SBA in [JW95a] with Previous Result 9.
Reference: [MHF93] <author> J. C. Mitchell, F. Honsell, and K. Fisher. </author> <title> A lambda calculus of objects and method specialization. </title> <booktitle> In Proceedings of the Eighth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 26-38, </pages> <year> 1993. </year>
Reference-contexts: Concepts we are less directly concerned with include multiple dispatch [Cas95], object method override [AC96], and object extension <ref> [MHF93] </ref>. We follow the standard school with the aim to make our work the most relevant, although many of the ideas do have application to the nonstandard schools.
Reference: [Mit84] <author> John C. Mitchell. </author> <title> Coercion and type inference (summary). </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1984. </year>
Reference-contexts: Versions of constrained types which either disallow recursive constraints [Smi94, Kae92, BM96] or use a notion of subtyping which relates types with the same structure only <ref> [Mit84, Mit91, MR85, FM88] </ref> have also been studied but are of less interest for our approach to typing classes and objects (discussed in Section 6 below) which requires recursion and record subtyping. 1 One consequence of such a type representation is the possibility for over-constraining a type, for instance t !
Reference: [Mit91] <author> John C. Mitchell. </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 245-285, </pages> <year> 1991. </year>
Reference-contexts: Versions of constrained types which either disallow recursive constraints [Smi94, Kae92, BM96] or use a notion of subtyping which relates types with the same structure only <ref> [Mit84, Mit91, MR85, FM88] </ref> have also been studied but are of less interest for our approach to typing classes and objects (discussed in Section 6 below) which requires recursion and record subtyping. 1 One consequence of such a type representation is the possibility for over-constraining a type, for instance t !
Reference: [MPS86] <author> D. B. MacQueen, G. Plotkin, and R. Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> <volume> 71 </volume> <pages> 95-130, </pages> <year> 1986. </year>
Reference-contexts: We also define an observational version 8 obs by analogy with Leibnitz/Morris/Plotkin contextual equivalence. We then prove 8 obs is the same as 8 sem , a novel full type abstraction property that confirms our choice of type model. The ideal model <ref> [MPS86] </ref> may also be used as a basis of a constrained type ordering 8 ideal [AWL94], but it is not fully abstract in this sense. 8 sem is a complex relation: it is open whether 8 sem is decidable, and we develop a powerful decidable approximation 8 dec .
Reference: [MR85] <author> P. Mishra and U. Reddy. </author> <title> Declaration-free type checking. </title> <booktitle> In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 7-21, </pages> <year> 1985. </year>
Reference-contexts: Versions of constrained types which either disallow recursive constraints [Smi94, Kae92, BM96] or use a notion of subtyping which relates types with the same structure only <ref> [Mit84, Mit91, MR85, FM88] </ref> have also been studied but are of less interest for our approach to typing classes and objects (discussed in Section 6 below) which requires recursion and record subtyping. 1 One consequence of such a type representation is the possibility for over-constraining a type, for instance t !
Reference: [Pot96] <author> Fran~cois Pottier. </author> <title> Simplifying subtyping constraints. </title> <booktitle> In First International Conference on Functional Programming, </booktitle> <pages> pages 122-133, </pages> <year> 1996. </year>
Reference-contexts: These results improve on previous work which defined weaker relations <ref> [EST95a, Pot96, Jim96] </ref>. Subtyping relations for constrained types have also been studied for non-recursive constraint sets [Smi94, BM96].
Reference: [PS92] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Safety analysis versus type inference for partial types. </title> <journal> Information Processing Letters, </journal> <pages> pages 175-180, </pages> <year> 1992. </year>
Reference-contexts: Result 9 In [PS96] we establish an isomorphism between a 0CFA-based [Shi88] type-checking algorithm <ref> [PS92] </ref> and a monomorphic constrained type system studied: the two systems accept precisely the same programs.
Reference: [PS94] <author> J. Palsberg and M. Schwartzbach. </author> <title> Object-Oriented Type Systems. </title> <publisher> Wiley, </publisher> <year> 1994. </year>
Reference-contexts: So, the two special forms of type needed for objects are F-bounded polymorphic types (or the closely related second-order polymorphic types [AC95]), and recursive types. There are many other approaches to typing objects and new ones are still being proposed at a rapid rate <ref> [Cas95, BM96, PS94] </ref>; a comparison of these schools is beyond the scope of this paper. We did participate in an effort to compare at least some of the schools.
Reference: [PS96] <author> Jens Palsberg and Scott Smith. </author> <title> Constrained types and their expressiveness. </title> <journal> TOPLAS, </journal> <volume> 18(5), </volume> <month> September </month> <year> 1996. </year>
Reference-contexts: Result 9 In <ref> [PS96] </ref> we establish an isomorphism between a 0CFA-based [Shi88] type-checking algorithm [PS92] and a monomorphic constrained type system studied: the two systems accept precisely the same programs.
Reference: [Shi88] <author> Olin Shivers. </author> <title> Control flow analysis in Scheme. </title> <booktitle> In Proceedings of SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <year> 1988. </year>
Reference-contexts: Result 9 In [PS96] we establish an isomorphism between a 0CFA-based <ref> [Shi88] </ref> type-checking algorithm [PS92] and a monomorphic constrained type system studied: the two systems accept precisely the same programs.
Reference: [Smi94] <author> Geoffrey S. Smith. </author> <title> Principal type schemes for functional programs with overloading and subtyping. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 23, </volume> <year> 1994. </year> <month> 9 </month>
Reference-contexts: Versions of constrained types which either disallow recursive constraints <ref> [Smi94, Kae92, BM96] </ref> or use a notion of subtyping which relates types with the same structure only [Mit84, Mit91, MR85, FM88] have also been studied but are of less interest for our approach to typing classes and objects (discussed in Section 6 below) which requires recursion and record subtyping. 1 One <p> These results improve on previous work which defined weaker relations [EST95a, Pot96, Jim96]. Subtyping relations for constrained types have also been studied for non-recursive constraint sets <ref> [Smi94, BM96] </ref>.
Reference: [TS96] <author> V. Trifonov and S. Smith. </author> <title> Subtyping constrained types. </title> <booktitle> In Third Static Analysis Sym--posium, volume ? of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: A principal typing property with respect to 8 may also be established for the constrained type inference algorithm, giving it a more firm justification. Result 2 In <ref> [TS96] </ref>, we study this subtyping relation, giving a semantic model 8 sem based on an inclusion between the solution spaces of the two constrained types being compared. We also define an observational version 8 obs by analogy with Leibnitz/Morris/Plotkin contextual equivalence. <p> Result 3 We have developed a canonical form for constraint sets which simplifies the constraint set so each variable has at most one upper and one lower bound that is not another type variable. This gives a more space-efficient form of the constraints <ref> [TS96] </ref>. Work is in progress on implementing this algorithm, and we anticipate a continual iterative process to improve the quality of the algorithm. Question (ii) above is perhaps the most difficult. The problem is one of readability for the programmer, since these types may be large in practice.
Reference: [Wan87] <author> Mitchell Wand. </author> <title> A simple algorithm and proof for type inference. </title> <journal> Fundamenta Infor-maticae, </journal> <volume> 10 </volume> <pages> 115-122, </pages> <year> 1987. </year>
Reference-contexts: The classic Hindley/Milner inference algorithm is more similar in spirit to constrained type inference than would first appear; this can be better seen when the Hindley/Milner algorithm is rephrased as inferring a set of equations between types <ref> [Wan87] </ref>. <p> In the standard presentation of Hindley/Milner type inference, these equations are eagerly unified, and the most general unifying substitution immediately applied to the result type t 1 . Wand <ref> [Wan87] </ref> shows how unification and substitution can be delayed, defining a type inference algorithm by collecting a set of equivalence constraints on types as outlined above. The act of eager substitution is reasonable for Hind-ley/Milner inference because substitution of equals for equals proceeds without loss of generality.
Reference: [Wan96] <author> Tiejun Wang. </author> <title> Explaining inferred type errors: the I-Loop type checker. </title> <type> Preprint, </type> <year> 1996. </year> <month> 10 </month>
Reference-contexts: Their system is based on SBA. We independently have developed a different scheme. Result 4 A prototype system has been developed to illustrates the flow leading to a type error <ref> [Wan96] </ref>. It uses a coloring scheme with a spectrum of colors to illustrate the program flow from source to sink that produced the error.
References-found: 39

