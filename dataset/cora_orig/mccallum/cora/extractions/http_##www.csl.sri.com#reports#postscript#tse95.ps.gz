URL: http://www.csl.sri.com/reports/postscript/tse95.ps.gz
Refering-URL: http://www.csl.sri.com/fm-papers.html
Root-URL: 
Title: Formal Verification for Fault-Tolerant Architectures: Prolegomena to the Design of PVS  
Author: Sam Owre, John Rushby, Natarajan Shankar, Friedrich von Henke 
Keyword: Byzantine agreement, clock synchronization, fault tolerance, flight control, formal methods, formal specification, hardware verification, theorem proving, verification systems, PVS.  
Date: 2, FEBRUARY 1995, pp. 107-125 1  
Note: IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 21, NO.  
Abstract: PVS is the most recent in a series of verification systems developed at SRI. Its design was strongly influenced, and later refined, by our experiences in developing formal specifications and mechanically checked verifications for the fault-tolerant architecture, algorithms, and implementations of a model "reliable computing platform" (RCP) for life-critical digital flight-control applications, and by a collaborative project to formally verify the design of a commercial avionics processor called AAMP5. Several of the formal specifications and verifications performed in support of RCP and AAMP5 are individually of considerable complexity and difficulty. But in order to contribute to the overall goal, it has often been necessary to modify completed verifications to accommodate changed assumptions or requirements, and people other than the original developer have often needed to understand, review, build on, modify, or extract part of an intricate verification. In this paper, we outline the verifications performed, present the lessons learned, and describe some of the design decisions taken in PVS to better support these large, difficult, iterative, and collaborative verifications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Federal Aviation Administration, System Design and Analysis, </institution> <month> June 21, </month> <year> 1988, </year> <title> Advisory Circular 25.1309-1A. </title>
Reference: [2] <author> R. W. Dennis and A. D. </author> <title> Hills, "A fault tolerant fly by wire system for maintenance free applications", </title> <booktitle> in 9th AIAA/IEEE Digital Avionics Systems Conference, </booktitle> <address> Virginia Beach, VA, </address> <month> Oct. </month> <year> 1990, </year> <booktitle> The Institute of Electrical and Electronics Engineers, </booktitle> <pages> pp. 11-20. </pages>
Reference: [3] <author> Dale A. Mackall, </author> <title> "Development and flight test experiences with a flight-crucial digital control system", </title> <type> NASA Technical Paper 2857, </type> <institution> NASA Ames Research Center, Dryden Flight Research Facility, Edwards, </institution> <address> CA, </address> <year> 1988. </year>
Reference: [4] <author> John H. Wensley, Leslie Lamport, Jack Goldberg, Milton W. Green, Karl N. Levitt, P. M. Melliar-Smith, Robert E. Shostak, and Charles B. Weinstock, "SIFT: </author> <title> Design and analysis of a fault-tolerant computer for aircraft control", </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> vol. 66, no. 10, </volume> <pages> pp. 1240-1255, </pages> <month> Oct. </month> <year> 1978. </year>
Reference: [5] <author> M. Pease, R. Shostak, and L. Lamport, </author> <title> "Reaching agreement in the presence of faults", </title> <journal> Journal of the ACM, </journal> <volume> vol. 27, no. 2, </volume> <pages> pp. 228-234, </pages> <month> Apr. </month> <year> 1980. </year>
Reference-contexts: Eventually we were able to construct the necessary proofs interactively in under an hour (starting from the specification and a couple of minor lemmas). 4 Interactive consistency is the problem of distributing consistent values to multiple channels in the presence of faults <ref> [5] </ref>. It is the symmetric version of the Byzantine Generals problem, and should not be confused with interactive convergence, which is an algorithm for clock synchronization. <p> One of these is a version of the algorithm for the architecture of the "Fault Tolerant Processor" (FTP) developed at the C. S. Draper Laboratory [45], [46]. A fundamental result regarding Interactive Consistency states that at least 3n+1 processors are required to withstand n simultaneous Byzantine faults <ref> [5] </ref>; thus, in particular, four processors are required to withstand a single fault. Traditionally, the fault-tolerant architecture is symmetrical, and all four processors are identical.
Reference: [6] <author> R. M. Kieckhafer, C. J. Walter, A. M. Finn, and P. M. Tham-bidurai, </author> <title> "The MAFT architecture for distributed fault tolerance", </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. 37, no. 4, </volume> <pages> pp. 398-405, </pages> <month> Apr. </month> <year> 1988. </year>
Reference-contexts: Symmetric faults deliver wrong values but do so consistently. Manifest faults are those that can be detected by all nonfaulty receivers. 2 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 21, NO. 2, FEBRUARY 1995, pp. 107-125 including one (called MAFT) by a manufacturer of flight-control systems <ref> [6] </ref>. These fault-tolerant architectures must be able to withstand multiple faults, and it can require an excessive amount of redundancy to do this if failed channels are left operating (e.g., seven channels are required to withstand two simultaneously active Byzantine faults).
Reference: [7] <author> Philip Thambidurai and You-Keun Park, </author> <title> "Interactive consistency with multiple failure modes", </title> <booktitle> in 7th Symposium on Reliable Distributed Systems, </booktitle> <address> Columbus, OH, Oct. 1988, </address> <publisher> IEEE Computer Society, </publisher> <pages> pp. 93-100. </pages>
Reference-contexts: Yet a conventional Byzantine fault-tolerant algorithm is only good for one fault of any kind in a five-channel system. To overcome this, the MAFT project introduced the idea of hybrid fault models and of algorithms that are maximally resistant to simultaneous combinations of faults of different types <ref> [7] </ref>. <p> It is the symmetric version of the Byzantine Generals problem, and should not be confused with interactive convergence, which is an algorithm for clock synchronization. Thus equipped, we turned to an important variation on the algorithm due to Thambidurai and Park <ref> [7] </ref> that uses a hybrid fault model, and thereby provides greater fault tolerance than the classical algorithm. Here we found not merely that the journal-style argument for the correctness of the algorithm was flawed, but that the algorithm contained an outright bug.
Reference: [8] <author> P. M. Melliar-Smith and R. L. Schwartz, </author> <title> "Formal specification and verification of SIFT: A fault-tolerant flight control system", </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-31, no. 7, </volume> <pages> pp. 616-630, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Ehdm's specifica 2 Some aspects of SIFT|which was built for NASA Langley|were subjected to formal verification <ref> [8] </ref>, but the treatment was far from complete. 3 CLI Inc., and ORA Corporation also participate in the program, using their own tools. Descriptions of some of their work can be found in [9] and [10], respectively.
Reference: [9] <author> William R. Bevier and William D. Young, </author> <title> "Machine checked proofs of the design of a fault-tolerant circuit", </title> <journal> Formal Aspects of Computing, </journal> <volume> vol. 4, no. 6A, </volume> <pages> pp. 755-775, </pages> <year> 1992. </year>
Reference-contexts: Ehdm's specifica 2 Some aspects of SIFT|which was built for NASA Langley|were subjected to formal verification [8], but the treatment was far from complete. 3 CLI Inc., and ORA Corporation also participate in the program, using their own tools. Descriptions of some of their work can be found in <ref> [9] </ref> and [10], respectively. The overall program is not large; it is equivalent to about three full-time staff at NASA, and about one each at CLI, ORA, and SRI.
Reference: [10] <author> Mandayam Srivas and Mark Bickford, </author> <title> "Verification of the Ft-Cayuga fault-tolerant microprocessor system, volume 1: A case-study in theorem prover-based verification", </title> <type> Contractor Report 4381, </type> <institution> NASA Langley Research Center, Hampton, VA, </institution> <month> July </month> <year> 1991, </year> <title> (Work performed by ORA Corporation). </title>
Reference-contexts: Descriptions of some of their work can be found in [9] and <ref> [10] </ref>, respectively. The overall program is not large; it is equivalent to about three full-time staff at NASA, and about one each at CLI, ORA, and SRI.
Reference: [11] <author> P. Michael Melliar-Smith and John Rushby, </author> <title> "The Enhanced HDM system for specification and verification", </title> <booktitle> in Proc. Verk-Shop III, </booktitle> <address> Watsonville, CA, </address> <month> Feb. </month> <year> 1985, </year> <pages> pp. 41-43, </pages> <booktitle> Published as ACM Software Engineering Notes, </booktitle> <volume> Vol. 10, No. 4, </volume> <month> Aug. 85. </month>
Reference-contexts: This stressed our tools to their limits and led to further refinements in their implementation. Before describing the verifications performed with them in more detail, we briefly introduce our tools. B. Our Verification Systems Ehdm, which first became operational in 1984 <ref> [11] </ref> but whose development still continues, is a system for the development, management, and analysis of formal specifications and abstract programs that extends a line of development that began with SRI's original Hierarchical Development Methodology (HDM) of the 1970's [12].
Reference: [12] <author> Jay M. Spitzen, Karl N. Levitt, and Lawrence Robinson, </author> <title> "An example of hierarchical design and proof", </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. 12, </volume> <pages> pp. 1064-1075, </pages> <month> Dec. </month> <year> 1978. </year>
Reference-contexts: Our Verification Systems Ehdm, which first became operational in 1984 [11] but whose development still continues, is a system for the development, management, and analysis of formal specifications and abstract programs that extends a line of development that began with SRI's original Hierarchical Development Methodology (HDM) of the 1970's <ref> [12] </ref>. Ehdm's specifica 2 Some aspects of SIFT|which was built for NASA Langley|were subjected to formal verification [8], but the treatment was far from complete. 3 CLI Inc., and ORA Corporation also participate in the program, using their own tools.
Reference: [13] <author> Robert E. Shostak, </author> <title> "Deciding combinations of theories", </title> <journal> Journal of the ACM, </journal> <volume> vol. 31, no. 1, </volume> <pages> pp. 1-12, </pages> <month> Jan. </month> <year> 1984. </year>
Reference-contexts: The Ehdm tools include a parser, prettyprinter, typechecker, proof checker, and many browsing and documentation aids, all of which use a customized GNU Emacs as their interface. Its proof checker is built on a decision procedure (due to Shostak <ref> [13] </ref>) for a combination of ground theories that includes linear arithmetic over both integers and rationals. Ehdm's proof-checker is not interactive; it is guided by proof descriptions prepared by the user and included as part of the specification text [14]. <p> Most of the techniques we employ were pioneered by others. For example, Nuprl [74] and Veritas [75] provide predicate subtypes and dependent types; theory interpretations were used in Iota [76]; our theorem proving techniques draw on LCF [16], the Boyer-Moore prover [19], [20], and on earlier work at SRI <ref> [13] </ref>. Our systems differ from others in tightly integrating capabilities that usually occur separately; this has allowed us to provide expressive specification languages and powerful and very effective mechanization within a classical framework.
Reference: [14] <author> John Rushby, Friedrich von Henke, and Sam Owre, </author> <title> "An introduction to formal specification and verification using Ehdm", </title> <type> Tech. Rep. </type> <institution> SRI-CSL-91-2, Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> Feb. </month> <year> 1991. </year>
Reference-contexts: Ehdm's proof-checker is not interactive; it is guided by proof descriptions prepared by the user and included as part of the specification text <ref> [14] </ref>. Development of PVS, our most recent verification system, started in 1991; it was built as a lightweight prototype for a "next generation" version of Ehdm, and in order to explore ideas in interactive proof checking.
Reference: [15] <author> S. Owre, J. M. Rushby, and N. Shankar, "PVS: </author> <title> A prototype verification system", </title> <booktitle> in 11th International Conference on Automated Deduction (CADE), </booktitle> <editor> Deepak Kapur, Ed., </editor> <address> Saratoga, NY, </address> <month> June </month> <year> 1992, </year> <title> vol. </title> <booktitle> 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pp. 748-752, </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The PVS theorem prover includes similar decision procedures to Ehdm, but provides much additional automation|including an automatic rewriter, and use of Binary Decision Diagrams (BDDs) for propositional simplification|within an interactive environment that uses a sequent calculus presentation <ref> [15] </ref>. The primitive inference steps of the PVS prover are rather powerful and highly automated, but the selection and composition of those primitive steps into an overall proof is performed interactively in response to commands from the user.
Reference: [16] <author> M. Gordon, R. Milner, and C. Wadsworth, </author> <title> Edinburgh LCF: A Mechanized Logic of Computation, </title> <booktitle> vol. 78 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Proof steps can be composed into higher-level "strategies" that are similar to the tactics of LCF-style provers <ref> [16] </ref>. Specifications in Ehdm and PVS can be stated constructively using a number of definitional forms that provide conservative extension, or they can be given axiomatically, or a mixture of both styles can be used. <p> Most of the techniques we employ were pioneered by others. For example, Nuprl [74] and Veritas [75] provide predicate subtypes and dependent types; theory interpretations were used in Iota [76]; our theorem proving techniques draw on LCF <ref> [16] </ref>, the Boyer-Moore prover [19], [20], and on earlier work at SRI [13]. Our systems differ from others in tightly integrating capabilities that usually occur separately; this has allowed us to provide expressive specification languages and powerful and very effective mechanization within a classical framework.
Reference: [17] <author> J. M. Spivey, Ed., </author> <title> The Z Notation: A Reference Manual, </title> <booktitle> Pren-tice Hall International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Hemel Hempstead, UK, </address> <note> second edition, </note> <year> 1993. </year>
Reference-contexts: Conversely, type predicates provide additional information to the theorem prover and thereby increase the effectiveness of its automation. It is not easy to directly compare Ehdm and PVS with other approaches to formal methods, such as those embodied in the Z <ref> [17] </ref> and VDM [18] notations, or the Boyer-Moore theorem prover [19], [20], since they are based on very different foundations. The HOL system [21] is based on similar foundations to Ehdm and PVS, but its language, proof-checker, and environment are much more austere than those of our systems.
Reference: [18] <author> Cliff B. Jones, </author> <title> Systematic Software Development Using VDM, </title> <publisher> Prentice Hall International Series in Computer Science. Prentice Hall, </publisher> <address> Hemel Hempstead, UK, </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: Conversely, type predicates provide additional information to the theorem prover and thereby increase the effectiveness of its automation. It is not easy to directly compare Ehdm and PVS with other approaches to formal methods, such as those embodied in the Z [17] and VDM <ref> [18] </ref> notations, or the Boyer-Moore theorem prover [19], [20], since they are based on very different foundations. The HOL system [21] is based on similar foundations to Ehdm and PVS, but its language, proof-checker, and environment are much more austere than those of our systems.
Reference: [19] <author> R. S. Boyer and J S. Moore, </author> <title> A Computational Logic, </title> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1979. </year>
Reference-contexts: It is not easy to directly compare Ehdm and PVS with other approaches to formal methods, such as those embodied in the Z [17] and VDM [18] notations, or the Boyer-Moore theorem prover <ref> [19] </ref>, [20], since they are based on very different foundations. The HOL system [21] is based on similar foundations to Ehdm and PVS, but its language, proof-checker, and environment are much more austere than those of our systems. <p> Most of the techniques we employ were pioneered by others. For example, Nuprl [74] and Veritas [75] provide predicate subtypes and dependent types; theory interpretations were used in Iota [76]; our theorem proving techniques draw on LCF [16], the Boyer-Moore prover <ref> [19] </ref>, [20], and on earlier work at SRI [13]. Our systems differ from others in tightly integrating capabilities that usually occur separately; this has allowed us to provide expressive specification languages and powerful and very effective mechanization within a classical framework.
Reference: [20] <author> R. S. Boyer and J S. Moore, </author> <title> A Computational Logic Handbook, </title> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: It is not easy to directly compare Ehdm and PVS with other approaches to formal methods, such as those embodied in the Z [17] and VDM [18] notations, or the Boyer-Moore theorem prover [19], <ref> [20] </ref>, since they are based on very different foundations. The HOL system [21] is based on similar foundations to Ehdm and PVS, but its language, proof-checker, and environment are much more austere than those of our systems. <p> Most of the techniques we employ were pioneered by others. For example, Nuprl [74] and Veritas [75] provide predicate subtypes and dependent types; theory interpretations were used in Iota [76]; our theorem proving techniques draw on LCF [16], the Boyer-Moore prover [19], <ref> [20] </ref>, and on earlier work at SRI [13]. Our systems differ from others in tightly integrating capabilities that usually occur separately; this has allowed us to provide expressive specification languages and powerful and very effective mechanization within a classical framework.
Reference: [21] <author> M. J. C. Gordon and T. F. Melham, Eds., </author> <title> Introduction to HOL: </title>
Reference-contexts: It is not easy to directly compare Ehdm and PVS with other approaches to formal methods, such as those embodied in the Z [17] and VDM [18] notations, or the Boyer-Moore theorem prover [19], [20], since they are based on very different foundations. The HOL system <ref> [21] </ref> is based on similar foundations to Ehdm and PVS, but its language, proof-checker, and environment are much more austere than those of our systems. <p> Some receive this guidance indirectly through the order and selection of results they are invited to consider (the Boyer-Moore prover is like this), others in the form of a program that specifies the proof strategy to be used (the "tactics" of LCF-style provers such as HOL <ref> [21] </ref> are like this). We have found that direct instruction by the user seems the most productive and most easily understood method of guidance, provided the basic repertoire of operations is not too large (no more than a dozen or so). <p> This technique generally keeps the rewriter on a productive path, and the case-splits under control. Our use of strategies may be contrasted to the use of tactics in LCF-style provers such as HOL <ref> [21] </ref>. Whereas we use powerful primitive inferences and employ strategies to build yet higher-level automation, HOL builds almost everything using tactics, since its built-in proof procedures perform only the elementary inferences of its logic.
References-found: 21

