URL: ftp://ftp.eecs.umich.edu/groups/gasm/cea.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: dean@cromath.math.hr  
Title: Communicating Evolving Algebras  
Author: Paola Glavan Dean Rosenzweig 
Web: dean.rosenzweig@uni-zg.ac.mail.yu  
Address: FSB, Salajeva 5 41000 Zagreb, Croatia  
Affiliation: University of Zagreb  
Abstract: We develop the first steps of a theory of concurrency within the framework of evolving algebras of Gurevich, with the aim of investigating its suitability for the role of a general framework for modeling concurrent computation. As a basic tool we introduce a `modal' logic of transition rules and runs, which is, in the context of evolving algebras, just a definitional extension of ordinary first order logic. A notion of independence of rules and runs enables us to introduce a notion of (and notation for) concurrent runs, on which a logical theory of (`true') con-currency may be based. The notion of concurrent run also has (but does not depend on) an interleaving interpretation. Some basic constructs (concurrent composition, addition of guards and updates) and some derived constructs (internal and external choice, sequential composition) on evolving algebras are introduced and investigated. The power of the framework is demonstrated by developing simple and transparent evolving algebra models for the Chemical Abstract Machine of Berry and Boudol and for the -calculus of Milner. Their respective notions of parallelism map directly and faithfully to native concurrency of evolving algebras. 
Abstract-found: 1
Intro-found: 1
Reference: [Abramsky 92] <author> S.Abramsky, </author> <title> Computational Interpretations of Linear Logic, </title> <note> to appear in Theoretical Computer Science. </note>
Reference-contexts: motivation and explanation can be found in [BerBou 92]|let us just remark that cham models of TCCS and CCS are given there, as well as an embedding of a higher-order concurrent -calculus, and that these models have had considerable influence on subsequent development of the -calculus [MiPaWa 92, Milner 92]. <ref> [Abramsky 92] </ref> has provided a cham-based computational interpretation of classical linear logic. We argue that chams are just special evolving algebras. In view of inductive definition of molecules and solutions, they are trees, and this has just to be explicated with appropriate evolving algebra signatures.
Reference: [Aczel 80] <author> P.Aczel, </author> <title> Frege Structures and the Notions of Proposition, Truth and Set, </title> <booktitle> in The Kleene Symposium, North-Holland 1980, </booktitle> <pages> pp. 31-59 </pages>
Reference-contexts: If r is well defined when is true, we shall use `formulae' of form ) r and ^ ) r in the following sense: ) r = true if : r otherwise ^ ) r = false if : r otherwise (see also <ref> [Aczel 80] </ref>). 1 (Sequential) evolving algebras 1.1 Basic definitions|the logic of simple rules Definition 1.1.1.
Reference: [Beeson 85] <author> M.J.Beeson, </author> <title> Foundations of Constructive Mathematics, </title> <publisher> Springer 1985. </publisher>
Reference-contexts: Since we are going to talk explicitly about models and interpretations, we prefer to have our partial functions directly at hand, and to minimize the assumptions to be made about (the universe of) the model. Thus we adopt an alternative formulation, the logic of partial terms of <ref> [Beeson 85] </ref> (cf. also `E + - logic' in [TroDal 88] and `partial algebras' in [Wirsing 90]). There are no special `undefined' objects in the model, but not all terms need denote something there. <p> Syntactical identity of function symbols and terms will be denoted by : For the purpose of following the present paper, the above remarks on the logic of partial terms should suffice. A full account of the logic (and its reducibility to ordinary first-order logic) may however be found in <ref> [Beeson 85, TroDal 88] </ref>.
Reference: [BerBou 92] <author> G.Berry, G.Boudol, </author> <title> The Chemical Abstract Machine, </title> <booktitle> Theoretical Computer Science 96 (1992), </booktitle> <pages> pp. </pages> <note> 217-248 (an earlier version also in POPL'90). </note>
Reference-contexts: As `very abstract machines', they are interesting objects in their own right. The power of the framework is demonstrated through two applications, providing simple and transparent models of the the Chemical Abstract Machine of <ref> [BerBou 92] </ref> and the -calculus of [Milner 92]. The Chemical Abstract Machine simply is a special evolving algebra, and our model of the calculus is built very much in the `chemical' spirit. Additional flexibility of evolving algebras allows us to give `heating' and `cooling' some direction, however. <p> Some useful extensions of the language are discussed here, in order to show their conservativity wrt to the above results. Section 4 contains the applications. The model of the Chemical Abstract Machine is little more than a rewriting of the reaction law of <ref> [BerBou 92] </ref>| other laws are valid automatically. The model of the -calculus is also very simple and natural, but in order to prove that it captures the computational content of the calculus, some `chemical' analysis (of that content) is required. <p> Note also that it is the set of possible rules that counts, and it has been `state dependent' all the time. 4 Applications 4.1 The Chemical Abstract Machine A Chemical Abstract Machine <ref> [BerBou 92] </ref> (`cham' in the sequel) operates on solutions. Solutions are finite multisets of molecules, which are specified, for each cham, by giving a set of function symbols (molecule constructors) with arities|molecules are just terms built using the constructors. <p> The chemical and membrane law express just the principle of locality: transformation rules may be applied anywhere in a solution, even when it occurs deeply inside a term|transforming a part will always transform the whole. Background, motivation and explanation can be found in <ref> [BerBou 92] </ref>|let us just remark that cham models of TCCS and CCS are given there, as well as an embedding of a higher-order concurrent -calculus, and that these models have had considerable influence on subsequent development of the -calculus [MiPaWa 92, Milner 92]. [Abramsky 92] has provided a cham-based computational interpretation <p> the cardinality of solutions; the signature is hence concluded with a function card : M * IN under the constraint # card (m) , type (m) = s: The values of card will be, after initialization, updated as counters (cf. 3.3), in order to enable independent evolution within a solution. <ref> [BerBou 92] </ref> constrain the solution-subexpressions occurring inside molecule-expressions of transformation rules to be either a solution variable, or of form fj m jg, where m is a single molecule. <p> In the model of TCCS of <ref> [BerBou 92] </ref> the following rule appears: &lt; fj ff . m jg; S &gt; 7! ff . l :&lt; m; S &gt; where ff . is unary, and &lt; ; &gt;; l :&lt; ; &gt; are binary molecule constructors more pictorially, fj : : : ; ; : : : jg <p> course, given a syntactically distinguished class of molecules which can-not contain solutions as subterms (such as `agents' in the above mentioned cham model of TCCS), their structure need not be analyzed into the tree|a molecule of that kind, however complex, might be associated to a node as a single decoration. <ref> [BerBou 92] </ref> say: `A cham is an intrinsically parallel machine: one can simultaneously apply several rules to a solution provided that no molecule is involved in more than one rule; one can also transform subsolutions in parallel : : : (the expressive power of chams) does not depend on parallel evaluation, <p> to model this notion of computation with an abstract machine, there are essentially two ways to proceed: (a) reflect every step of inference by some machine action (s), or (b) obtain first a more explicit rendering of the intended notion of computation, and model it in a more direct fashion. <ref> [BerBou 92] </ref> have, developing cham models of TCCS and CCS, pursued course (a), obtaining an analysis of the `fine structure' of the calculi. <p> But the process of distilling `computational content' from the calculus is not yet complete|a (pseudo)cham model will help us make the next step. In the final version of <ref> [BerBou 92] </ref> the following cham model of the - calculus is presented (without establishing a formal relationship to the calculus). Molecules of the cham are processes. <p> For restriction, which [Milner 92] explains saying that `-xP - "new x in P " : : : declares a new unique name x : : : for use in P ', <ref> [BerBou 92] </ref> introduce an integer `name-server' n and a rule -xP; n * P fn=xg; n + 1 : In a solution containing -xP; -yQ; n the following results of restriction-heating are conceivable P fn=xg; Qfn + 1=xg; n + 2 P fn + 1=xg; Qfn=xg; n + 2 : But
Reference: [Boudol 87] <author> G.Boudol, </author> <title> Communication is an Abstraction, </title> <institution> INRIA Rapport de Recherche 636 (1987). </institution>
Reference-contexts: Taken together with known techniques for modelling assignment , such as in [GurMos 90, GurHug 92, BorRos 92a] and channel communication [GurMos 90], (cf. also <ref> [Boudol 87] </ref> and Section 4), we obtain a trivial way to construct an evolving algebra model for any given Occam program. 3.3 Extending the language|counters, universes, variables We have so far relied on a very rudimentary, spartan notion of evolving algebra.
Reference: [BorRic 92] <author> E.Borger, E.Riccobene, </author> <title> A Mathematical Model of Concurrent Prolog, </title> <note> 1992 (to appear). </note>
Reference-contexts: In [GurMos 90] the framework has for the first time accomodated the notion of concurrency, in special form of Occam, to be continued with studies of Parlog and Concurrent Prolog <ref> [BorRic 93, BorRic 92] </ref>. Generalizing this work, we undertake to develop a theory of concurrency within the framework of evolving algebras, with the aim of investigating its suitability for the role of a general framework for modeling concurrent computation.
Reference: [BorRic 93] <author> E.Borger, E.Riccobene, </author> <title> A formal specification of Parlog. </title> <editor> In: M.Droste, Y.Gurevich (Eds.): </editor> <title> Semantics of programming languages and model theory, </title> <note> 1993 (to appear). </note>
Reference-contexts: In [GurMos 90] the framework has for the first time accomodated the notion of concurrency, in special form of Occam, to be continued with studies of Parlog and Concurrent Prolog <ref> [BorRic 93, BorRic 92] </ref>. Generalizing this work, we undertake to develop a theory of concurrency within the framework of evolving algebras, with the aim of investigating its suitability for the role of a general framework for modeling concurrent computation.
Reference: [BorRos 92a] <author> E.Borger, D.Rosenzweig, </author> <title> The WAM|Definition and Compiler Correctness, </title> <institution> TR-14/92, Dipartimento di Informatica, Universita di Pisa, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: This simple framework has shown remarkable success in modeling complex computing situations, such as Modula 2 [GurMor 88], full Prolog [BorRos 92b], the Warren Abstract Machine <ref> [BorRos 92a] </ref>, C [GurHug 92] : : : , avoiding the combinatorial explosion of formalism and/or mathematics, too characteristical of attempts to give a formal semantics of real systems. <p> Taken together with known techniques for modelling assignment , such as in <ref> [GurMos 90, GurHug 92, BorRos 92a] </ref> and channel communication [GurMos 90], (cf. also [Boudol 87] and Section 4), we obtain a trivial way to construct an evolving algebra model for any given Occam program. 3.3 Extending the language|counters, universes, variables We have so far relied on a very rudimentary, spartan notion <p> should suffice. 13 For the reader familiar with compilation of logic languages, let us just remark that checking of lhs corresponds to (a simplification of) getting instructions of the WAM, construction of rhs to (a simplification of) putting instructions, and preserving with reattachment to some aspects of variable classification|cf. also <ref> [BorRos 92a] </ref>.
Reference: [BorRos 92b] <author> E.Borger, D.Rosenzweig, </author> <title> A Simple Mathematical Model for Full Pro-log, </title> <institution> TR-33/92, Dipartimento di Informatica, Universita di Pisa, </institution> <month> Octo-ber </month> <year> 1992. </year>
Reference-contexts: The metaphor of a `daemon', attempting to fire a rule selected nondeter-ministically from those allowed by their guards, may be useful in forming an intuitive picture. This simple framework has shown remarkable success in modeling complex computing situations, such as Modula 2 [GurMor 88], full Prolog <ref> [BorRos 92b] </ref>, the Warren Abstract Machine [BorRos 92a], C [GurHug 92] : : : , avoiding the combinatorial explosion of formalism and/or mathematics, too characteristical of attempts to give a formal semantics of real systems.
Reference: [Gurevich 88] <author> Y.Gurevich, </author> <title> Logic and the challenge of computer science. </title> <editor> in: E.Borger (Ed.), </editor> <booktitle> Trends in Theoretical Computer Science, </booktitle> <publisher> Computer Science Press, </publisher> <address> Rockville MA 1988, pp.1-57. </address>
Reference-contexts: Introduction The notion of evolving algebra of <ref> [Gurevich 88, Gurevich 91] </ref> captures two basic ideas which should help logic meet `the challenge of computer science'. The basic objects (of the system to be modelled) had better be expressed directly, without encoding, as abstract entities, such as they appear in the system. <p> The actions could then be represented as local modifications, guarded by simple conditions. These two ideas are captured by putting together a first-order signature and a finite set of transition rules, i.e. sets of local modifications guarded by a simple formula (cf. <ref> [Gurevich 88, Gurevich 91] </ref> and also Section 1). This determines a transition system, whose states are first-order structures (of the signature), and the transition relation is given by the rules, understood as structure transformers . <p> A `higher order' kind of jar is provided by dynamic universes of <ref> [Gurevich 88, Gurevich 91] </ref>. Several universes of a heterogenous signature are seen as embedded in a superuniverse U . Whenever we mention S U , we are talking about its characteristic function S , and a 2 S is just shorthand for S (a) = tt.
Reference: [Gurevich 91] <author> Y.Gurevich, </author> <title> Evolving Algebras. A Tutorial Introduction. </title> <booktitle> in: Bulletin of the European Association for Theoretical Computer Science, </booktitle> <address> no.43, </address> <month> February </month> <year> 1991, </year> <pages> pp. 264-284 </pages>
Reference-contexts: Introduction The notion of evolving algebra of <ref> [Gurevich 88, Gurevich 91] </ref> captures two basic ideas which should help logic meet `the challenge of computer science'. The basic objects (of the system to be modelled) had better be expressed directly, without encoding, as abstract entities, such as they appear in the system. <p> The actions could then be represented as local modifications, guarded by simple conditions. These two ideas are captured by putting together a first-order signature and a finite set of transition rules, i.e. sets of local modifications guarded by a simple formula (cf. <ref> [Gurevich 88, Gurevich 91] </ref> and also Section 1). This determines a transition system, whose states are first-order structures (of the signature), and the transition relation is given by the rules, understood as structure transformers . <p> In Section 3 we display the basic and derived constructs on evolving alge 1 Since the notion of evolving algebra is understood by its creator as being `open ended' <ref> [Gurevich 91] </ref>, as a methodology rather than formalism, these definitions may be taken with a grain of salt|yet we have to start somewhere. bras and investigate their properties. Some useful extensions of the language are discussed here, in order to show their conservativity wrt to the above results. <p> The language is the usual one, built from variables, function symbols with fixed arities, true, false, =; :; ^; _; ); 8; 9. There are several ways to formalize first-order reasoning with function symbols understood as representing partial functions. One is adopted by <ref> [Gurevich 91] </ref>: assume an `undefined' element of the model, and a corresponding constant undef in the signature. <p> A full account of the logic (and its reducibility to ordinary first-order logic) may however be found in [Beeson 85, TroDal 88]. The reader familiar with the undef approach of <ref> [Gurevich 91] </ref> may easily translate our notation to that framework according to the following table # t ! t 6= undef s ' t ! s = t s = t ! s 6= undef ^ s = t I (f ) : U n * U ! I (f ) <p> In applications of evolving algebras one usually encounters a heterogenous signature with several universes, which may in general grow and shrink in time|update forms are pro vided to extend or restrict a universe. <ref> [Gurevich 91] </ref> has however shown how to reduce such setups to the above basic model of a homogenous signature (with one universe) and function updates only (see also Section 3). Assumption. <p> I R! (f (u)) ' I (t i ) if f = f i ; I R! (u) = I (s i ); i = 1; : : : ; n I (f )(I R! (u)) otherwise 3 <ref> [Gurevich 91] </ref> allows such contradictory updates, imagining the daemon as selecting nondeterministically what to execute. We confine nondeterminism to selection of a rule, all of whose updates must be executed simultaneously once the guard has been checked, going back to the concept of [GurMos 90]. <p> formulae, updates, rules) Df (t 1 ; : : : ; t n ) = ( i=1 D = fDt j t occurs in g D (f (t 1 ; : : : ; t n ) : = t) = ( i=1 5 We are more stringent here than <ref> [Gurevich 91] </ref>, who allows simultaneous execution of any set of rules allowed by their guards, `leaving it to the daemon' to select between eventual contradictory updates. DR! = u2R! DR = DR? [ DR! Then the following condition will allow two rules to act concurrently without conflict. <p> The following rule of inference is obviously valid (upwards as well as downwards) A ! fi?A j= b b?R We shall often use the pseudoconstruct ff gA, where f is a function symbol, indicating the intention to keep f internal <ref> [Gurevich 91] </ref>, private to A: whenever ff gA is composed with some B, we assume f 62 (B). <p> Since ? is a while-loop, taken together with (concurrent) composition this constitutes already a reasonable concurrent programming language. It is convenient to assume a distinction between dynamic and static function symbols|those which are modified, either within the algebra or by the environment, and those which are not (cf. also <ref> [Gurevich 91] </ref>). We shall assume here, without further mention, static booleans tt, ff. It is also convenient to assume that initially all dynamic functions are empty (`everywhere undefined')|composing (sequentially, cf. below) with appropriate initialization updates we may still obtain any (finite) initial states we want. <p> A `higher order' kind of jar is provided by dynamic universes of <ref> [Gurevich 88, Gurevich 91] </ref>. Several universes of a heterogenous signature are seen as embedded in a superuniverse U . Whenever we mention S U , we are talking about its characteristic function S , and a 2 S is just shorthand for S (a) = tt.
Reference: [GurHug 92] <author> Y.Gurevich, J.Huggins, </author> <title> The Evolving Algebra Semantics of C , CSE-TR-141-92, </title> <institution> EECS Department, University of Michigan, </institution> <year> 1992. </year>
Reference-contexts: This simple framework has shown remarkable success in modeling complex computing situations, such as Modula 2 [GurMor 88], full Prolog [BorRos 92b], the Warren Abstract Machine [BorRos 92a], C <ref> [GurHug 92] </ref> : : : , avoiding the combinatorial explosion of formalism and/or mathematics, too characteristical of attempts to give a formal semantics of real systems. <p> Taken together with known techniques for modelling assignment , such as in <ref> [GurMos 90, GurHug 92, BorRos 92a] </ref> and channel communication [GurMos 90], (cf. also [Boudol 87] and Section 4), we obtain a trivial way to construct an evolving algebra model for any given Occam program. 3.3 Extending the language|counters, universes, variables We have so far relied on a very rudimentary, spartan notion
Reference: [GurMor 88] <author> Y.Gurevich, J.Morris, </author> <title> Algebraic operational semantics and Modula-2 , in CSL'87, </title> <booktitle> 1st Workshop on Computer Science Logic, </booktitle> <publisher> Springer LNCS 329 (1988), </publisher> <pages> 81-101. </pages>
Reference-contexts: The metaphor of a `daemon', attempting to fire a rule selected nondeter-ministically from those allowed by their guards, may be useful in forming an intuitive picture. This simple framework has shown remarkable success in modeling complex computing situations, such as Modula 2 <ref> [GurMor 88] </ref>, full Prolog [BorRos 92b], the Warren Abstract Machine [BorRos 92a], C [GurHug 92] : : : , avoiding the combinatorial explosion of formalism and/or mathematics, too characteristical of attempts to give a formal semantics of real systems.
Reference: [GurMos 90] <author> Y.Gurevich, L.S.Moss, </author> <title> Algebraic Operational Semantics and Occam, </title> <booktitle> in CSL'89, Proceedings of 3rd Workshop on Computer Science Logic, </booktitle> <publisher> Springer LNCS 440 (1990), </publisher> <pages> pp. 176-196. </pages>
Reference-contexts: In <ref> [GurMos 90] </ref> the framework has for the first time accomodated the notion of concurrency, in special form of Occam, to be continued with studies of Parlog and Concurrent Prolog [BorRic 93, BorRic 92]. <p> We confine nondeterminism to selection of a rule, all of whose updates must be executed simultaneously once the guard has been checked, going back to the concept of <ref> [GurMos 90] </ref>. <p> We introduce then run expression which explicitly indicate concurrency| (jt )(j-) means executing first, then concurrently and t , and, when that is completed, concurrently and -. Such concurrent runs provide a proper generalization of the notion of run used in <ref> [GurMos 90] </ref>, by providing a partial ordering of states involved. We say when is a concurrent run possible, and characterize its effect by term transformer and modal operators. We show how to collapse a concurrent run to an equivalent sequential one, providing an interleaving semantics as well. <p> Taken together with known techniques for modelling assignment , such as in <ref> [GurMos 90, GurHug 92, BorRos 92a] </ref> and channel communication [GurMos 90], (cf. also [Boudol 87] and Section 4), we obtain a trivial way to construct an evolving algebra model for any given Occam program. 3.3 Extending the language|counters, universes, variables We have so far relied on a very rudimentary, spartan notion <p> Taken together with known techniques for modelling assignment , such as in [GurMos 90, GurHug 92, BorRos 92a] and channel communication <ref> [GurMos 90] </ref>, (cf. also [Boudol 87] and Section 4), we obtain a trivial way to construct an evolving algebra model for any given Occam program. 3.3 Extending the language|counters, universes, variables We have so far relied on a very rudimentary, spartan notion of evolving algebra.
Reference: [Harel 84] <author> D.Harel, </author> <title> Dynamic Logic, </title> <editor> in D.M.Gabbay, F.Guenthner (Eds.): </editor> <booktitle> Handbook of Philosophical Logic 2, Reidel 1984, </booktitle> <pages> pp. 497-604. </pages>
Reference-contexts: Simple special cases are the well known Hoare's rule, [a : = b] , (b=a), and the array assignment rule of dynamic logic <ref> [Harel 84] </ref>, whose simplest basis-of-induction case takes the form [f (a) : = b] (f (x) = y) , (x = a ) y = b) ^ (x 6= a ) y = f (x)) (if # a; f doesn't occur in x; y).
Reference: [Milner 89] <author> R.Milner, </author> <title> Communication and Concurrency, </title> <publisher> Prentice Hall 1989. </publisher>
Reference-contexts: In order to say all this precisely, without relying on daemon, locking, or any other metaphor, we have to develop a logic of evolving algebras, up to a point, not unlike the modal logics of processes developed in the context of CCS and -calculus of Milner <ref> [Milner 89, MiPaWa 91, Milner 92] </ref>. Happily, the needed fragment of the logic of evolving algebras turns out to be (a definitional extension of) ordinary first order logic. Having fixed our model of concurrency, we define some basic operations on evolving algebras, starting from (concurrent) composition.
Reference: [Milner 92] <author> R.Milner, </author> <title> The Polyadixc -Calculus: A Tutorial, </title> <booktitle> in Proceedings of the International Summer School on Logic and Algebra of Specification, Marktoberdorf 1991 (to appear). </booktitle>
Reference-contexts: In order to say all this precisely, without relying on daemon, locking, or any other metaphor, we have to develop a logic of evolving algebras, up to a point, not unlike the modal logics of processes developed in the context of CCS and -calculus of Milner <ref> [Milner 89, MiPaWa 91, Milner 92] </ref>. Happily, the needed fragment of the logic of evolving algebras turns out to be (a definitional extension of) ordinary first order logic. Having fixed our model of concurrency, we define some basic operations on evolving algebras, starting from (concurrent) composition. <p> As `very abstract machines', they are interesting objects in their own right. The power of the framework is demonstrated through two applications, providing simple and transparent models of the the Chemical Abstract Machine of [BerBou 92] and the -calculus of <ref> [Milner 92] </ref>. The Chemical Abstract Machine simply is a special evolving algebra, and our model of the calculus is built very much in the `chemical' spirit. Additional flexibility of evolving algebras allows us to give `heating' and `cooling' some direction, however. <p> Background, motivation and explanation can be found in [BerBou 92]|let us just remark that cham models of TCCS and CCS are given there, as well as an embedding of a higher-order concurrent -calculus, and that these models have had considerable influence on subsequent development of the -calculus <ref> [MiPaWa 92, Milner 92] </ref>. [Abramsky 92] has provided a cham-based computational interpretation of classical linear logic. We argue that chams are just special evolving algebras. In view of inductive definition of molecules and solutions, they are trees, and this has just to be explicated with appropriate evolving algebra signatures. <p> not so much on the simple and direct representation-by-explication (in spite of apparent tension between `geometry' of cham pictures and our `arithmetization' of it), as in the circumstance that the intended cham notion of parallelism maps so precisely to evolving algebra notion of concurrency. 4.2 The -calculus The -calculus of <ref> [Milner 92] </ref> relates processes, i.e. expressions built from a set of names (to be understood as names of communication ports or links) according to the following syntax: P ! i2I where I a finite index set, each i a prefix of form x (y) or xy, x; y are names. <p> Note that, with this syntax, P is an atomic constructor, represented, say, by a vector of prefixes, and acting, in the fashion of scalar product, on a vector of processes. For (rich) background, motivation and explanation the reader is referred to <ref> [Milner 92, MiPaWa 92] </ref> and their references. <p> Computation-as communication is all in the Q fl ! l Q 00 part|the Q 00 Q 0 part may be viewed as just `beautifying' the result. Such decomposition is made possible by Milner's decision to stick to guarded sums in the latest version <ref> [Milner 92] </ref> of the - calculus, feeling that `...forms such as (P jQ) + R have very little significance'. <p> Process constructors can be seen here as `encapsulating computations', which might trigger when heated. Note how replication heats into spawning a replicant, and how 0 evaporates under heat, and gets created ex nihilo by cooling. For restriction, which <ref> [Milner 92] </ref> explains saying that `-xP - "new x in P " : : : declares a new unique name x : : : for use in P ', [BerBou 92] introduce an integer `name-server' n and a rule -xP; n * P fn=xg; n + 1 : In a solution <p> Otherwise the rules are applied independently. Lemma 4.2.5. If S + S 0 7! S 00 , then, for some solution S 000 , S 7! S 000 + S 00 . 14 `Extrusion' (of scope) is line 4. of definition, cf. <ref> [Milner 92] </ref> for discussion. Proof. A sum is never a result of cooling|the rules are applied independently. Possibility to postpone cooling is succinctly expressed by a further decom position theorem (if fl def Proposition 4.2.3. <p> A construct like (h), `perpetual external choice', might be the right building block to define several other kinds of choice, such as +; h and constructs like |` until choosing to cool'. A reader familiar with <ref> [Milner 92] </ref> would probably by now find it a straight-forward excercise to adapt our model to the polyadic calculus, refining the syntax of processes with abstractions and concretions, and decomposing our communication rule to handshake and value-passing|other evolving algebra rules might remain. The carefully designed rules of [Milner 92], regulating when <p> reader familiar with <ref> [Milner 92] </ref> would probably by now find it a straight-forward excercise to adapt our model to the polyadic calculus, refining the syntax of processes with abstractions and concretions, and decomposing our communication rule to handshake and value-passing|other evolving algebra rules might remain. The carefully designed rules of [Milner 92], regulating when and with what a restriction may commute in this context, would be automatically validated by the present restriction-heating rule, when applied to arbitrary abstractions and conretions.
Reference: [MiPaWa 91] <author> R.Milner, J. Parrow, D.Walker, </author> <title> Modal Logics for Mobile Processes, </title> <booktitle> in Proceedings of CONCUR'91, </booktitle> <publisher> Springer LNCS 527 (1991), </publisher> <pages> pp. 45-60. </pages>
Reference-contexts: In order to say all this precisely, without relying on daemon, locking, or any other metaphor, we have to develop a logic of evolving algebras, up to a point, not unlike the modal logics of processes developed in the context of CCS and -calculus of Milner <ref> [Milner 89, MiPaWa 91, Milner 92] </ref>. Happily, the needed fragment of the logic of evolving algebras turns out to be (a definitional extension of) ordinary first order logic. Having fixed our model of concurrency, we define some basic operations on evolving algebras, starting from (concurrent) composition.
Reference: [MiPaWa 92] <editor> R.Milner, J.Parrow, D.Walker, </editor> <booktitle> A Calculus of Mobile Processes 1,2 , Information and Computation 100, </booktitle> <volume> 1(1992), </volume> <pages> pp. 1-77. </pages>
Reference-contexts: Background, motivation and explanation can be found in [BerBou 92]|let us just remark that cham models of TCCS and CCS are given there, as well as an embedding of a higher-order concurrent -calculus, and that these models have had considerable influence on subsequent development of the -calculus <ref> [MiPaWa 92, Milner 92] </ref>. [Abramsky 92] has provided a cham-based computational interpretation of classical linear logic. We argue that chams are just special evolving algebras. In view of inductive definition of molecules and solutions, they are trees, and this has just to be explicated with appropriate evolving algebra signatures. <p> Note that, with this syntax, P is an atomic constructor, represented, say, by a vector of prefixes, and acting, in the fashion of scalar product, on a vector of processes. For (rich) background, motivation and explanation the reader is referred to <ref> [Milner 92, MiPaWa 92] </ref> and their references.
Reference: [TroDal 88] <author> A.S.Troelstra, D. van Dalen, </author> <title> Constructivism in Mathematics, </title> <publisher> North-Holland 1988. </publisher>
Reference-contexts: Thus we adopt an alternative formulation, the logic of partial terms of [Beeson 85] (cf. also `E + - logic' in <ref> [TroDal 88] </ref> and `partial algebras' in [Wirsing 90]). There are no special `undefined' objects in the model, but not all terms need denote something there. Those which do are distinguished by an additional unary predicate #, such that # t intuitively means `t is defined', or `t denotes'. <p> Syntactical identity of function symbols and terms will be denoted by : For the purpose of following the present paper, the above remarks on the logic of partial terms should suffice. A full account of the logic (and its reducibility to ordinary first-order logic) may however be found in <ref> [Beeson 85, TroDal 88] </ref>.
Reference: [Wirsing 90] <author> M. Wirsing, </author> <title> Algebraic Specification, </title> <editor> in J. van Leeuwen (Ed.): </editor> <booktitle> Handbook of Theoretical Computer Science B, </booktitle> <publisher> Elsevier 1990, </publisher> <pages> pp. </pages> <month> 675-788. </month> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Thus we adopt an alternative formulation, the logic of partial terms of [Beeson 85] (cf. also `E + - logic' in [TroDal 88] and `partial algebras' in <ref> [Wirsing 90] </ref>). There are no special `undefined' objects in the model, but not all terms need denote something there. Those which do are distinguished by an additional unary predicate #, such that # t intuitively means `t is defined', or `t denotes'.
References-found: 21

