URL: ftp://softlib.rice.edu/pub/CRPC-TRs/reports/CRPC-TR98735-S.ps.gz
Refering-URL: http://www.crpc.rice.edu/CRPC/softlib/TRs_online.html
Root-URL: 
Email: adam-@cs.caltech.edu  
Title: Providing Easier Access to Remote Objects in ClientServer Systems  
Author: Jonathan Aldrich, James Dooley, Scott Mandelsohn, and Adam Rifkin -jonal, jdooley, scott, 
Affiliation: California Institute of Technology  
Abstract: The Java Environment for Distributed Invocation (JEDI) is efficient, dynamic, and easier to use than alternative communication systems for distributed Java objects. Existing state-of-the-art mechanisms for remote method calls on Java objects, such as RMI, require users to perform a complicated series of steps. Furthermore, the compiled static interfaces these systems use limit their functionality. This paper presents the design and implementation of JEDI's simpler approach utilizing dynamic proxies. We discuss a means of integrating JEDI with a publicly available CORBA ORB, followed by the tests used to ensure the robustness of the JEDI system. Comparing this system's performance with that of other communication facilities such as UDP, TCP, and RMI demonstrates the efficiency of JEDI. A calendar-scheduling application illustrates the flexibility and usability tradeoffs of employing JEDI in distributed clientserver applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Berners-Lee, R. Cailliau, J. Groff and B. Pollermann, </author> <title> World Wide Web: The Information Universe, </title> <journal> Electronic Networking: Research, Applications, and Policy , Volume 1, </journal> <volume> Number 2, </volume> <year> 1992. </year>
Reference-contexts: Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA [17] or DCOM [6]. Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI <ref> [1] </ref>. Method calls on remote objects may be made using Open Network Computing Remote Procedure Calls [29] or Java's Remote Method Invocation [12].
Reference: [2] <author> K. Mani Chandy, Jonathan Aldrich, and Dan Zimmerman, </author> <title> The Infospheres Infrastructure 2.0 Specification, </title> <institution> California Institute of Technology Computer Science Technical Report, </institution> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Providing a security filter mechanism for incoming JEDI method calls, perhaps allowing for trustsigned method invocation chains [13]. As a mechanism for dynamic method invocations, JEDI has become the communication substrate used with Caltech's current work on Infospheres 2.0, allowing the development of location-independent mobile objects with RPCs <ref> [2] </ref>. In the future, this system will be integrated with both events and the Infospheres mailbox and message packages, creating a JavaBeans-based infrastructure that supports RPCs and messages.
Reference: [3] <author> K. Mani Chandy and Adam Rifkin, </author> <title> Systematic Composition of Objects in Distributed Internet Applications: </title> <booktitle> Processes And Sessions, Conference Proceedings of the Thirtieth Hawaii International Conference on System Sciences (HICSS), Maui, </booktitle> <volume> Volume 1, </volume> <month> January </month> <year> 1997, </year> <pages> pp. 395-404. </pages>
Reference-contexts: The Infospheres Infrastructure [4] offers a solution to the scaling problem by providing mailboxes that can send and receive typed messages. With these mechanisms, developers can set up sessions of persistent communicating objects <ref> [3] </ref>. JEDI was originally constructed as an invocation layer built on top of the Infospheres message-passing communication layer. As the package evolved, the Infospheres plumbing was replaced by a more performant communication layer using UDP. <p> When a group leader decides to hold a meeting, he queries the other group members in a peer-to-peer session <ref> [3] </ref> to determine an appropriate meeting time. The calendar application then locks in the appropriate slots for the group meeting in each of the respective group members' schedules. Because of the request-response nature of the scheduling algorithm we used, this application maps naturally to remote method call semantics.
Reference: [4] <author> K. Mani Chandy, Adam Rifkin, Paolo A.G. Sivilotti, Jacob Mandelson, Matthew Richardson, Wesley Tanaka, and Luke Weisman, </author> <title> A WorldWide Distributed System Using Java and the Internet, </title> <booktitle> IEEE International Symposium on High Performance Distributed Computing (HPDC-5) , Syracuse, </booktitle> <address> New York, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: 1. Introduction Java programs can use the Internet for distributed computations in many different ways [8]. One such technique involves message passing [9] between objects on different machines, as exemplified by Caltech's Infospheres <ref> [4] </ref>, IBM's Aglets [14], and the iBus multicast system [16]. Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA [17] or DCOM [6]. Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI [1]. <p> Furthermore, although CORBA was designed to scale to accommodate communication among many objects, neither DCOM nor RMI presently seems suitable for communication among more than a handful of objects [19]. The Infospheres Infrastructure <ref> [4] </ref> offers a solution to the scaling problem by providing mailboxes that can send and receive typed messages. With these mechanisms, developers can set up sessions of persistent communicating objects [3]. JEDI was originally constructed as an invocation layer built on top of the Infospheres message-passing communication layer. <p> JEDI's focus therefore shifted to making robust distributed systems easier to implement. 2.7. A Simple, Dynamic, and Global Vision for Distributed Computing We envision a distributed computing model with billions of objects scattered over the globe, interacting with each other via the Internet <ref> [4] </ref>. Because objects in one Java VM usually communicate with method calls, we believe that a communications system based on remote method calls is conceptually more simple than a message-passing system. <p> JEDI's niche is in low-end distributed system development as an efficient, easier-to-use alternative to RMI in Java programs. An example of this use is the calendar application we describe next. 11 4.4. Comparing Implementations of a Simple Distributed Application As illustrated in figure 10, a calendar scheduling application <ref> [4] </ref> is an example of distributed resource management [23]. For comparison of the application of different techniques for distributed program development, we implemented this calendar application using Java with simple local method calls, after which we distributed the program using RMI, Infospheres, and JEDI.
Reference: [5] <author> K. Mani Chandy, Joe Kiniry, Adam Rifkin, and Dan Zimmerman, </author> <title> A Framework for Structured Distributed Object Computing, </title> <booktitle> Parallel Computing, </booktitle> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: We plan to provide the option of using this transport in future versions of JEDI. Because of the Infospheres work being done here at Caltech, we initially used the info.net library of the Infospheres Infrastructure <ref> [5] </ref> as our communications protocol. However, this system provides rich features that slow its performance, such as ensured ordered messages. Performance tuning has not yet begun in earnest for the info.net library, so using it incurs a considerable performance penalty (100 back-and-forth messages took 5.0 seconds). <p> Further integrating JEDI with CORBA. 5. Allowing secure transactions on JEDI objects, including rollback and two-phase commit capabilities. 6. Allowing persistent objects that are woken up when a remote method call is made on them, as is permitted by Infospheres Djinns <ref> [5] </ref>. 7. Providing a security filter mechanism for incoming JEDI method calls, perhaps allowing for trustsigned method invocation chains [13].
Reference: [6] <author> David Chappell, </author> <title> Understanding ActiveX and OLE , Microsoft Press, </title> <year> 1996. </year>
Reference-contexts: One such technique involves message passing [9] between objects on different machines, as exemplified by Caltech's Infospheres [4], IBM's Aglets [14], and the iBus multicast system [16]. Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA [17] or DCOM <ref> [6] </ref>. Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI [1]. Method calls on remote objects may be made using Open Network Computing Remote Procedure Calls [29] or Java's Remote Method Invocation [12]. <p> Caffeine, a part of VisiBroker, includes a compiler that generates IDL code from a Java interface, making the CORBA development process in Java much like that of RMI. 4 2.4. DCOM Microsoft has recently developed a Java interface to their Distributed Component Object Model (DCOM) <ref> [6] </ref>. DCOM is another system that allows RPC-like calls on remote objects; it uses a DCE-like IDL language to define interfaces. Note that Microsoft's IDL (MIDL) is compliant with neither CORBA IDL nor DCE IDL.
Reference: [7] <author> Ben Eng, </author> <title> ORB Core Feature Matrix, </title> <note> http://www.vex.net/~ben/orbmatrix.html , 1997. </note>
Reference-contexts: We looked at two particular ORB implementations. Xerox PARC's Inter-Language Unification (ILU) system [11] interoperates with other CORBA ORBs using the Internet Inter-ORB Protocol (IIOP). Although ILU does not implement many features of the commercial ORBs <ref> [7] </ref>, it provides DII and is freely available. As described in our section "Experiments in ClientServer Computing", we have worked on an ILU interface that allows CORBA objects to call methods on JEDI objects. VisiBroker, Visigenic's implementation of CORBA, has similar features to ILU but includes more complete functionality.
Reference: [8] <author> James Gosling, Bill Joy, and Guy Steele, </author> <title> The Java Language Specification, Addison-Wesley Developers Press, Sunsoft Java Series, </title> <year> 1996. </year>
Reference-contexts: 1. Introduction Java programs can use the Internet for distributed computations in many different ways <ref> [8] </ref>. One such technique involves message passing [9] between objects on different machines, as exemplified by Caltech's Infospheres [4], IBM's Aglets [14], and the iBus multicast system [16]. Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA [17] or DCOM [6].
Reference: [9] <author> C.A.R. Hoare, </author> <title> Communicating Sequential Processes, </title> <journal> Communications of the ACM , Volume 21, </journal> <volume> Number 8, </volume> <pages> Pages 666-677, </pages> <year> 1978. </year>
Reference-contexts: 1. Introduction Java programs can use the Internet for distributed computations in many different ways [8]. One such technique involves message passing <ref> [9] </ref> between objects on different machines, as exemplified by Caltech's Infospheres [4], IBM's Aglets [14], and the iBus multicast system [16]. Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA [17] or DCOM [6].
Reference: [10] <author> Prashant Jain and Douglas C. Schmidt, </author> <title> Experiences Converting a C++ Communication Software Framework to Java, The C++ Report, </title> <month> January </month> <year> 1997. </year>
Reference: [11] <author> Bill Janssen and Mike Spreitzer, </author> <note> ILU Reference Manual . Xerox PARC, </note> <year> 1997. </year>
Reference-contexts: Any method invoked through the DSI is passed through a single upcall method (written by the programmer) that is responsible for checking the method name and forwarding it to the correct implementation method. We looked at two particular ORB implementations. Xerox PARC's Inter-Language Unification (ILU) system <ref> [11] </ref> interoperates with other CORBA ORBs using the Internet Inter-ORB Protocol (IIOP). Although ILU does not implement many features of the commercial ORBs [7], it provides DII and is freely available.
Reference: [12] <author> Javasoft Java RMI Team, </author> <title> Java Remote Method Invocation Specification, Sun Microsystems, </title> <year> 1997. </year>
Reference-contexts: Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI [1]. Method calls on remote objects may be made using Open Network Computing Remote Procedure Calls [29] or Java's Remote Method Invocation <ref> [12] </ref>. With each of these techniques, the programmer must deal with creating extra interfaces (often in a different language) and must do other setup work to handle low-level communication details. This paper explores remote method calling facilities that automatically handle some of the more cumbersome communication and synchronization responsibilities [21]. <p> Java's Remote Method Invocation The Remote Method Invocation (RMI) system furnished by Java 1.1 allows RPC-like access to remote objects <ref> [12] </ref>. RMI includes support for data serialization, remote class loading, and socket manipulation.
Reference: [13] <author> Rohit Khare and Adam Rifkin, </author> <title> Weaving a Web of Trust, </title> <journal> World Wide Web Journal special issue on security, </journal> <volume> Volume 2, Number 3, </volume> <pages> pages 77-112, </pages> <month> summer </month> <year> 1997. </year>
Reference-contexts: Allowing persistent objects that are woken up when a remote method call is made on them, as is permitted by Infospheres Djinns [5]. 7. Providing a security filter mechanism for incoming JEDI method calls, perhaps allowing for trustsigned method invocation chains <ref> [13] </ref>. As a mechanism for dynamic method invocations, JEDI has become the communication substrate used with Caltech's current work on Infospheres 2.0, allowing the development of location-independent mobile objects with RPCs [2].
Reference: [14] <author> D.B. Lange and M. </author> <title> Oshima , Programming Mobile Agents in Java With the Java Aglet API, </title> <institution> IBM Research, </institution> <year> 1997 </year>
Reference-contexts: 1. Introduction Java programs can use the Internet for distributed computations in many different ways [8]. One such technique involves message passing [9] between objects on different machines, as exemplified by Caltech's Infospheres [4], IBM's Aglets <ref> [14] </ref>, and the iBus multicast system [16]. Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA [17] or DCOM [6]. Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI [1].
Reference: [15] <author> Doug Lea. </author> <title> Design for Open Systems in Java, </title> <booktitle> Proceedings of the Second International Conference on Coordination Models and Languages, </booktitle> <address> Berlin, </address> <month> September </month> <year> 1997. </year>
Reference-contexts: For comparison of the application of different techniques for distributed program development, we implemented this calendar application using Java with simple local method calls, after which we distributed the program using RMI, Infospheres, and JEDI. We used a responsibility-driven design <ref> [15] </ref> to coordinate the scheduling activities of multiple distributed calendar programs for each port of the system.
Reference: [16] <author> Silvano Maffeis, iBus: </author> <title> The Java Internet Software Bus, </title> <note> available at http://www.olsen.ch/export/ftp/ users/maffeis/ibus/ibus_overview.ps.gz , Olsen & Associates, </note> <institution> Zurich, </institution> <year> 1997. </year>
Reference-contexts: 1. Introduction Java programs can use the Internet for distributed computations in many different ways [8]. One such technique involves message passing [9] between objects on different machines, as exemplified by Caltech's Infospheres [4], IBM's Aglets [14], and the iBus multicast system <ref> [16] </ref>. Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA [17] or DCOM [6]. Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI [1]. <p> RMI can use only a few wire protocols (currently TCP/IP and HTTP), but some applications would benefit from the use of custom transport protocols available through a generic message infrastructure. The ACE framework [25][10] and the iBus project <ref> [16] </ref> both provide a layered component-based Java communication system that allows plug-in custom transport protocols to provide different quality of service facilities to applications. ObjectSpace Voyager [18] provides remote method invocation facilities much like RMI's, but makes the development process much simpler and provides additional features. <p> A Tour of the JEDI Architecture JEDI includes a simple but powerful general messaging infrastructure. This infrastructure is designed to be both efficient and modular, and is implemented in several layers with a protocol stack architecture similar to that of iBus <ref> [16] </ref>. One layer can use the services of another; thus the remote method call facility uses the reliability layer to make robust remote method calls over an unreliable network connections.
Reference: [17] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification (CORBA ), revision 2.0, </title> <year> 1995. </year>
Reference-contexts: One such technique involves message passing [9] between objects on different machines, as exemplified by Caltech's Infospheres [4], IBM's Aglets [14], and the iBus multicast system [16]. Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA <ref> [17] </ref> or DCOM [6]. Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI [1]. Method calls on remote objects may be made using Open Network Computing Remote Procedure Calls [29] or Java's Remote Method Invocation [12]. <p> Then the programmer writes the client program and an object that implements the server's interface. The client and server can then be compiled and run. CORBA has support for clients to discover and use interfaces dynamically through its Dynamic Invocation Interface (DII) <ref> [17] </ref>. When using DII, the client creates its method calls at runtime, rather than calling methods in the stub. A CORBA specification for the Dynamic Skeleton Interface (DSI), allows server objects to update their interfaces at runtime [17]. <p> clients to discover and use interfaces dynamically through its Dynamic Invocation Interface (DII) <ref> [17] </ref>. When using DII, the client creates its method calls at runtime, rather than calling methods in the stub. A CORBA specification for the Dynamic Skeleton Interface (DSI), allows server objects to update their interfaces at runtime [17]. Any method invoked through the DSI is passed through a single upcall method (written by the programmer) that is responsible for checking the method name and forwarding it to the correct implementation method. We looked at two particular ORB implementations.
Reference: [18] <author> ObjectSpace Voyager Development Team, </author> <title> ObjectSpace Voyager Core Package Technical Overview, </title> <note> available at http://www.objectspace.com/voyager/VoyagerT echOviewNEWTAGLINE.pdf , ObjectSpace, </note> <institution> Dallas, </institution> <year> 1997. </year>
Reference-contexts: The ACE framework [25][10] and the iBus project [16] both provide a layered component-based Java communication system that allows plug-in custom transport protocols to provide different quality of service facilities to applications. ObjectSpace Voyager <ref> [18] </ref> provides remote method invocation facilities much like RMI's, but makes the development process much simpler and provides additional features. Developers run an existing class through the Voyager preprocessor to create a stub class with all the methods the original class had.
Reference: [19] <editor> Robert Orfali and Dan Harkey , Client/Server Programming with Java and CORBA , John Wiley & Sons, </editor> <publisher> Inc., </publisher> <address> New York, </address> <year> 1997. </year>
Reference-contexts: When the Invoke call reaches the server, the destination object must check the ID in order to discover which method is being called before unpacking the variant parameters and implementing the call. 2.5. Comparing RMI, CORBA, and DCOM Comparing each of these distributed object communication mechanisms <ref> [19] </ref>, we note that RMI, CORBA, and DCOM all offer somewhat seamless Java integration, typed parameter support, and reasonable performance. <p> Furthermore, although CORBA was designed to scale to accommodate communication among many objects, neither DCOM nor RMI presently seems suitable for communication among more than a handful of objects <ref> [19] </ref>. The Infospheres Infrastructure [4] offers a solution to the scaling problem by providing mailboxes that can send and receive typed messages. With these mechanisms, developers can set up sessions of persistent communicating objects [3]. <p> RPC requires a static, compile-time interface, and standard CORBA 5 requires the same. Through the Dynamic Invocation Interface facilities, CORBA clients can discover resources dynamically. However, DII is somewhat difficult to use many steps are required to construct a dynamic request object <ref> [19] </ref>. If the client must query the server for the interface of the method it wants to call, performance may decrease dramatically. DCOM Automation is likewise complicated and difficult to use.
Reference: [20] <author> Robert Orfali, Dan Harkey, and Jeri Edward, </author> <title> The Essential Distributed Objects Survival Guide , John Wiley & Sons, </title> <publisher> Inc., </publisher> <address> New York, </address> <year> 1996. </year>
Reference-contexts: We note that using the dynamic capabilities of CORBA comparable to those provided by JEDI can result in a performance degradation of more than an order of magnitude in some ORB implementations <ref> [20] </ref>. JEDI's niche is in low-end distributed system development as an efficient, easier-to-use alternative to RMI in Java programs. An example of this use is the calendar application we describe next. 11 4.4.
Reference: [21] <author> L.L. Peterson and B.S. Davie, </author> <title> Computer Networks: A Systems Approach, </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: With each of these techniques, the programmer must deal with creating extra interfaces (often in a different language) and must do other setup work to handle low-level communication details. This paper explores remote method calling facilities that automatically handle some of the more cumbersome communication and synchronization responsibilities <ref> [21] </ref>. Many existing systems, including Java's RMI, require a programmer to run interface code through a preprocessor to create stub and skeleton objects. We have developed an alternative system for remote method calling, offering the programmer complete control over communication while simplifying the model of distributed computing.
Reference: [22] <author> Ernest N. Prabhakar, </author> <title> Implementing Distributed Objects: Doing It the Easy Way with NeXT's Portable Distributed Objects, </title> <journal> Dr. Dobb's Journal, </journal> <month> August </month> <year> 1995. </year> <month> 16 </month>
Reference-contexts: However, all three approaches suffer from high setup costs due to programming complexity, lack of configuration ease, evolving wire-level security, and limited dynamic discovery and dynamic dispatch when compared with systems such as NeXT's Portable Distributed Objects <ref> [22] </ref>. Furthermore, although CORBA was designed to scale to accommodate communication among many objects, neither DCOM nor RMI presently seems suitable for communication among more than a handful of objects [19].
Reference: [23] <author> Ravi Ramamoorthi, Adam Rifkin, Boris Dimitrov, and K. Mani Chandy, </author> <title> A General Resource Reservation Framework for Scientific Computing, </title> <booktitle> Proceedings of the First International Scientific Computing in ObjectOriented Parallel Environments (ISCOPE) Conference, </booktitle> <address> Marina del Rey, </address> <month> December </month> <year> 1997. </year>
Reference-contexts: An example of this use is the calendar application we describe next. 11 4.4. Comparing Implementations of a Simple Distributed Application As illustrated in figure 10, a calendar scheduling application [4] is an example of distributed resource management <ref> [23] </ref>. For comparison of the application of different techniques for distributed program development, we implemented this calendar application using Java with simple local method calls, after which we distributed the program using RMI, Infospheres, and JEDI.
Reference: [24] <author> Ron Resnick, </author> <title> Bringing Distributed Objects to the World Wide Web, </title> <note> http://www.interlog.com/~resnick/ javacorb.html , 1996. Excerpted in Dr. Dobbs Sourcebook special issue on distributed objects, </note> <month> January </month> <year> 1997. </year>
Reference-contexts: These experiments include studying the integration of JEDI with CORBA, testing the performance and reliability of JEDI, and using JEDI to develop an application from scratch. We conclude with a short summary of our JEDI findings. 2. Existing Systems Until recently, Java lacked a native clientserver method invocation paradigm <ref> [24] </ref>, but several supplementary systems are available to provide this functionality. In this section, we explore and compare some of the current communication mechanisms in clientserver systems: RPC, RMI, CORBA and IIOP, DCOM, and the Infospheres Infrastructure. 2.1.
Reference: [25] <author> Douglas C. Schmidt, </author> <title> ACE: an ObjectOriented Framework for Developing Distributed Applications, </title> <booktitle> Proceedings of the Sixth USENIX C++ Technical Conference , Cambridge, </booktitle> <month> April </month> <year> 1994. </year>
Reference-contexts: Because the layers are loosely connected, a separate messaging service layer could make use of the reliability layer to provide robust message passing, as is done with the ACE system <ref> [25] </ref>. Socket 1 2 PingHandler ReliableHandler RMCHandler UDP Packets Other Handlers waiting for UDP packets. Upon receipt of a UDP packet, it routes the packet accordingly to the PingHandler , the RMCHandler , the ReliableHandler , or some other packet handler.
Reference: [26] <author> Douglas C. Schmidt and Andy Gokhale, </author> <title> Evaluating CORBA Latency and Scaleability Over HighSpeed ATM Networks, </title> <booktitle> IEEE 17th International Conference on Distributed Systems (ICDCS 97), </booktitle> <address> Baltimore, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: We plan to add the capability to send structured data more efficiently in a future release of JEDI. During our performance experiments, we did not compare our JEDI mechanisms with CORBA invocations, because significant research is being conducted to make CORBA more performant and scaleable over highspeed networks <ref> [26] </ref>, resulting in several techniques for optimizing IIOP performance [28]. We note that using the dynamic capabilities of CORBA comparable to those provided by JEDI can result in a performance degradation of more than an order of magnitude in some ORB implementations [20].
Reference: [27] <author> Douglas C. Schmidt and Andy Gokhale, </author> <title> Measuring the Performance of Communication Middleware on HighSpeed Networks, </title> <booktitle> SIGCOMM Conference , Stanford University, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: Research has shown the importance of measuring not only two-way ping latency in distributed object oriented systems, but also throughput and latency for sending different kinds of data structures <ref> [27] </ref>. We tested JEDI and RMI by passing a 35 Kb, richly typed, treelike data structure in a remote method call. In this case RMI sent the structure in 0.85 seconds, while JEDI took 1.56 seconds.
Reference: [28] <author> Douglas C. Schmidt and Andy Gokhale, </author> <title> Principles for Optimizing CORBA Internet Inter-ORB Protocol Performance, </title> <booktitle> Thirty-first Hawaii International Conference on System Sciences (HICSS), </booktitle> <month> January </month> <year> 1998. </year>
Reference-contexts: During our performance experiments, we did not compare our JEDI mechanisms with CORBA invocations, because significant research is being conducted to make CORBA more performant and scaleable over highspeed networks [26], resulting in several techniques for optimizing IIOP performance <ref> [28] </ref>. We note that using the dynamic capabilities of CORBA comparable to those provided by JEDI can result in a performance degradation of more than an order of magnitude in some ORB implementations [20].
Reference: [29] <author> R. Srinivasan, </author> <title> RFC 1831 - Open Network Computing RPC: Remote Procedure Call Protocol Specification , Version 2, </title> <month> August </month> <year> 1995. </year>
Reference-contexts: Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI [1]. Method calls on remote objects may be made using Open Network Computing Remote Procedure Calls <ref> [29] </ref> or Java's Remote Method Invocation [12]. With each of these techniques, the programmer must deal with creating extra interfaces (often in a different language) and must do other setup work to handle low-level communication details. <p> In this section, we explore and compare some of the current communication mechanisms in clientserver systems: RPC, RMI, CORBA and IIOP, DCOM, and the Infospheres Infrastructure. 2.1. ONC Remote Procedure Calls For years, programmers have used ONC's Remote Procedure Call (RPC) system <ref> [29] </ref> to automate some of 2 the communication tasks between client programs and their servers. Although RPC was one of the first systems to simplify the development of distributed applications over the use of plain socket connections, RPC does not handle remote procedure calls automatically.
Reference: [30] <author> Steve Vinoski, </author> <title> CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments, </title> <journal> IEEE Communications Magazine , Volume 14, </journal> <volume> Number 2, </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: Although Voyager allows dynamic method calls, it requires developers to specify methods with the unintelligible method signature syntax used by the Java virtual machine. 2.3. CORBA The Object Management Group's (OMG) Common Object Request Broker Architecture (CORBA) allows the development of distributed applications with component objects <ref> [30] </ref>. CORBA's language-independence allows objects written in different languages to communicate with one another. All object interaction is routed through intermediary Object Request Brokers (ORBs) which communicate through the industry-standard IIOP protocol (see figure 3).
Reference: [31] <author> Jim Waldo, Geoff Wyant, Ann Wollrath, </author> <title> and Sam Kendall, </title>
Reference-contexts: As the package developed, we realized that complete transparency is not always desirable in distributed systems. Several unique characteristics of distributed systems, including uncertain delays and distributed failure, must be considered when designing such a system <ref> [31] </ref>. Unfortunately, when the distributed nature of a system is not hidden, programmers must often deal with low-level coding issues and with complicated development tools such as RMI. JEDI's focus therefore shifted to making robust distributed systems easier to implement. 2.7.
References-found: 31

