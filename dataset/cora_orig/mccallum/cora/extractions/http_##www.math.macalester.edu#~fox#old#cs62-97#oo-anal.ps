URL: http://www.math.macalester.edu/~fox/old/cs62-97/oo-anal.ps
Refering-URL: http://www.math.macalester.edu/~fox/old/cs62-97/page.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Simple and Effective Analysis of Statically-Typed Object-Oriented Programs  
Author: Amer Diwan J. Eliot B. Moss Kathryn S. M c Kinley 
Address: Amherst, MA 01003  
Affiliation: Department of Computer Science University of Massachusetts,  
Abstract: To use modern hardware effectively, compilers need extensive control-flow information. Unfortunately, the frequent method invocations in object-oriented languages obscure control flow. In this paper, we describe and evaluate a range of analysis techniques to convert method invocations into direct calls for statically-typed object-oriented languages and thus improve control-flow information in object-oriented languages. We present simple algorithms for type hierarchy analysis, aggregate analysis, and inter-procedural and intraprocedural type propagation. These algorithms are also fast, O(jproceduresj fl P procedures p n p fl v p ) worst case time (linear in practice) for our slowest analysis, where n p is the size of procedure p and v p is the number of variables in procedure p, and are thus practical for use in a compiler. When they fail, we introduce cause analysis to reveal the source of imprecision and suggest where more powerful algorithms may be warranted. We show that our simple analyses perform almost as well as an oracle that resolves all method invocations that invoke only a single procedure. fl The authors can be reached electronically via Internet addresses fdiwan,moss,mckinleyg@cs.umass.edu. This work was supported by the National Science Foundation under grants CCR-9211272 and CCR-9525767 and by gifts from Sun Microsystems Laboratories, Inc. To appear in OOPSLA 96: Eleventh Annual Conference on Object-Oriented Programming Systems, Languages, and Applications. Copyright 1996 by ACM. Permission to copy and distribute this document is hereby granted provided that this notice is retained on all copies, that copies are not altered, and that ACM is credited when the material is used to form other copyright policies. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ole Agesen and Urs Holzle. </author> <title> Type feedback vs. concrete type inference: A comparison of optimization techniques for object-oriented languages. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 91-107, </pages> <address> Austin, Texas, </address> <month> October </month> <year> 1995. </year> <note> ACM. </note>
Reference-contexts: With such frequent unknown control transfers, it is unlikely that the compiler can fully exploit prefetch instructions or instruction level parallelism. There are two ways of improving the control-flow information in the compiler. First, program analysis may reduce the set of possible procedures called at each method invocation <ref> [1, 10, 12] </ref>. This analysis is effective only on monomorphic method invocations. Second, a program may be transformed so that the performance-critical method invocations can be converted to direct calls. An example is splitting, which duplicates code in order to improve type information [8]. <p> They find that type hierarchy analysis is a worthwhile technique that resolves many method invocations. Our work confirms these results. In addition to type hierarchy analysis, we evaluate a range of other techniques. Palsberg and Schwartzbach [20], Agesen and Holzle <ref> [1] </ref>, and Plevyak and Chien [22] describe type inference 6 for dynamically typed object-oriented languages. Agesen and Holzle's, and Plevyak and Chien's analyses are more powerful than ours since they are context sensitive (polyvariant). They are also more complex and expensive.
Reference: [2] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: For every method invocation that our analyses do not resolve, our cause assignment algorithm finds the merges that result in the loss of type information for the receiver of the method invocation. The analyzer finds the merge by following use-def chains <ref> [2] </ref> to the point where information is lost. We use this information to expose the reason when our analyses fail. The reason suggests what analyses or transformations may be effective on the unresolved method invocations.
Reference: [3] <author> Gerald Aigner and Urs Holzle. </author> <title> Eliminating virtual function calls in C++ programs. </title> <booktitle> In European conference on object-oriented programming, </booktitle> <address> Linz, Austria, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: We focus solely on analysis here. Plevyak and Chien discuss reasons for loss of type information, but do not present any results. We present detailed data giving reasons for loss of type information. In work done concurrently with ours, Bacon and Sweeney [4] and Aigner and Holzle <ref> [3] </ref> evaluate techniques for resolving method invocations in C++ programs. Bacon and Sweeney evaluate three fast analyses, including type hierarchy analysis, for resolving method invocations in C++ programs. Unlike us, Bacon and Sweeney evaluate only flow insensitive analyses.
Reference: [4] <author> David Bacon and Peter Sweeney. </author> <title> Fast static analysis of C++ virtual function calls. </title> <booktitle> In OOPSLA'96 Conference Proceedings: Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> San Jose, CA, </address> <month> October </month> <year> 1996. </year> <title> ACM, </title> <publisher> ACM Press. </publisher>
Reference-contexts: We focus solely on analysis here. Plevyak and Chien discuss reasons for loss of type information, but do not present any results. We present detailed data giving reasons for loss of type information. In work done concurrently with ours, Bacon and Sweeney <ref> [4] </ref> and Aigner and Holzle [3] evaluate techniques for resolving method invocations in C++ programs. Bacon and Sweeney evaluate three fast analyses, including type hierarchy analysis, for resolving method invocations in C++ programs. Unlike us, Bacon and Sweeney evaluate only flow insensitive analyses.
Reference: [5] <author> Brad Calder and Dirk Grunwald. </author> <title> Reducing indirect function call overhead in C++ programs. </title> <booktitle> In Conference Record of the Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 397-408, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: These method invocations are a lower bound on the polymorphic method invocations since in another run of the benchmark, additional method invocations may be polymorphic. one type of object is stored in a heap slot. Two techniques, explicit type test <ref> [5, 15] </ref> and cloning combined with aggressive aggregate analysis, may be able to resolve these method invocations. Merges in control are another important cause of the run-time polymorphism, especially for trestle, and can be resolved by code splitting and cloning [7, 14, 9]. <p> This result is partly due to Modula-3's language semantics which restrict aliasing; a more powerful alias analysis may be more useful for C++ than for Modula-3, but this need has not yet been demonstrated. Chambers [6], Calder and Grunwald <ref> [5] </ref>, Holzle and Ungar [15], and Grove et al. [13] describe transformations for converting method invocations to direct calls. We focus solely on analysis here. Shivers [23] describes and classifies a range of analyses to discover control flow in Scheme programs. Our interprocedural type propagation is similar to his 0CFA.
Reference: [6] <author> Craig Chambers. </author> <title> The design and evaluation of the SELF compiler, an optimizing compiler for object-oriented programming languages. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <address> CA, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: In object-oriented languages, programmers use a type hierarchy and method invocations to improve code reuse and correctness. Unfortunately, method invocations obscure which procedure is actually being invoked. In dynamically-typed languages, frequent method look-up is costly in itself <ref> [6] </ref> but in statically-typed languages, it is typically not a significant cost. For both static and dynamic languages however, method invocations inhibit optimization. <p> This result is partly due to Modula-3's language semantics which restrict aliasing; a more powerful alias analysis may be more useful for C++ than for Modula-3, but this need has not yet been demonstrated. Chambers <ref> [6] </ref>, Calder and Grunwald [5], Holzle and Ungar [15], and Grove et al. [13] describe transformations for converting method invocations to direct calls. We focus solely on analysis here. Shivers [23] describes and classifies a range of analyses to discover control flow in Scheme programs.
Reference: [7] <author> Craig Chambers and David Ungar. </author> <title> Customization: Optimizing compiler technology for SELF, a dynamically-typed object-oriented programming language. </title> <booktitle> In Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 146-160, </pages> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year> <journal> ACM SIGPLAN Notices 24, </journal> <month> 7 (July </month> <year> 1989). </year>
Reference-contexts: Two techniques, explicit type test [5, 15] and cloning combined with aggressive aggregate analysis, may be able to resolve these method invocations. Merges in control are another important cause of the run-time polymorphism, especially for trestle, and can be resolved by code splitting and cloning <ref> [7, 14, 9] </ref>. From the static counts above the bars, we see that while the number of run-time polymorphic sites in the benchmarks is usually small, they are executed relatively frequently.
Reference: [8] <author> Craig Chambers and David Ungar. </author> <title> Iterative type analysis and extended message splitting: Optimizing dynamically-typed object-oriented programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 150-164, </pages> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year> <journal> ACM SIGPLAN Notices 25, </journal> <month> 6 (June </month> <year> 1990). </year>
Reference-contexts: This analysis is effective only on monomorphic method invocations. Second, a program may be transformed so that the performance-critical method invocations can be converted to direct calls. An example is splitting, which duplicates code in order to improve type information <ref> [8] </ref>. Program transformations are effective on polymorphic and monomorphic method invocations. Since transformations may degrade performance, a good strategy for a compiled language is first to analyze, and only then to apply transformations to convert the remaining, frequently executed, polymorphic method invocations.
Reference: [9] <author> Craig Chambers and David Ungar. </author> <title> Making pure object oriented languages practical. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 1-15, </pages> <address> Phoenix, Arizona, </address> <month> October </month> <year> 1991. </year> <journal> ACM SIGPLAN Notices 26, </journal> <month> 11 (November </month> <year> 1991). </year>
Reference-contexts: Two techniques, explicit type test [5, 15] and cloning combined with aggressive aggregate analysis, may be able to resolve these method invocations. Merges in control are another important cause of the run-time polymorphism, especially for trestle, and can be resolved by code splitting and cloning <ref> [7, 14, 9] </ref>. From the static counts above the bars, we see that while the number of run-time polymorphic sites in the benchmarks is usually small, they are executed relatively frequently.
Reference: [10] <author> Jeffery Dean, David Grove, and Craig Chambers. </author> <title> Optimization of object-oriented programs using static class hierarchy analysis. </title> <booktitle> In Proceedings of European Conference on Object-Oriented Programming, </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: With such frequent unknown control transfers, it is unlikely that the compiler can fully exploit prefetch instructions or instruction level parallelism. There are two ways of improving the control-flow information in the compiler. First, program analysis may reduce the set of possible procedures called at each method invocation <ref> [1, 10, 12] </ref>. This analysis is effective only on monomorphic method invocations. Second, a program may be transformed so that the performance-critical method invocations can be converted to direct calls. An example is splitting, which duplicates code in order to improve type information [8]. <p> Fernandez [12] and Dean et al. <ref> [10] </ref> evaluate type hierarchy analysis for Modula-3 and Cecil respectively. They find that type hierarchy analysis is a worthwhile technique that resolves many method invocations. Our work confirms these results. In addition to type hierarchy analysis, we evaluate a range of other techniques.
Reference: [11] <author> Digital Equipment Corporation. </author> <title> DEC3000 300/400/500/600/800 Models: System Programmer's Manual, first printing edition, </title> <month> September </month> <year> 1993. </year>
Reference-contexts: For example, the memory latency of some modern machines is around 70-100 cycles <ref> [11] </ref> and thus the compiler needs to know which instruction will be executed 70 cycles in advance in order to prefetch data or instructions most effectively.
Reference: [12] <author> Mary F. Fernandez. </author> <title> Simple and effective link-time optimization of Modula-3 programs. </title> <booktitle> In Proceedings of Conference on Programming Language Design and Implementation, </booktitle> <address> La Jolla, CA, </address> <month> June </month> <year> 1995. </year> <title> SIGPLAN, </title> <publisher> ACM Press. </publisher>
Reference-contexts: With such frequent unknown control transfers, it is unlikely that the compiler can fully exploit prefetch instructions or instruction level parallelism. There are two ways of improving the control-flow information in the compiler. First, program analysis may reduce the set of possible procedures called at each method invocation <ref> [1, 10, 12] </ref>. This analysis is effective only on monomorphic method invocations. Second, a program may be transformed so that the performance-critical method invocations can be converted to direct calls. An example is splitting, which duplicates code in order to improve type information [8]. <p> Fernandez <ref> [12] </ref> and Dean et al. [10] evaluate type hierarchy analysis for Modula-3 and Cecil respectively. They find that type hierarchy analysis is a worthwhile technique that resolves many method invocations. Our work confirms these results. In addition to type hierarchy analysis, we evaluate a range of other techniques.
Reference: [13] <author> David Grove, Jeffery Dean, Charles Garrett, and Craig Chambers. </author> <title> Profile-guided receiver class prediction. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 108-123, </pages> <address> Austin, Texas, </address> <month> October </month> <year> 1995. </year> <note> ACM. </note>
Reference-contexts: This result is partly due to Modula-3's language semantics which restrict aliasing; a more powerful alias analysis may be more useful for C++ than for Modula-3, but this need has not yet been demonstrated. Chambers [6], Calder and Grunwald [5], Holzle and Ungar [15], and Grove et al. <ref> [13] </ref> describe transformations for converting method invocations to direct calls. We focus solely on analysis here. Shivers [23] describes and classifies a range of analyses to discover control flow in Scheme programs. Our interprocedural type propagation is similar to his 0CFA.
Reference: [14] <author> Mary Wolcott Hall. </author> <title> Managing Interprocedural Optimizations. </title> <type> PhD thesis, </type> <institution> Rice University, Houston, Texas, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: Two techniques, explicit type test [5, 15] and cloning combined with aggressive aggregate analysis, may be able to resolve these method invocations. Merges in control are another important cause of the run-time polymorphism, especially for trestle, and can be resolved by code splitting and cloning <ref> [7, 14, 9] </ref>. From the static counts above the bars, we see that while the number of run-time polymorphic sites in the benchmarks is usually small, they are executed relatively frequently.
Reference: [15] <author> Urs Holzle and David Ungar. </author> <title> Optimizing dynamically-dispatched calls with run-time type feedback. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 326-336. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: These method invocations are a lower bound on the polymorphic method invocations since in another run of the benchmark, additional method invocations may be polymorphic. one type of object is stored in a heap slot. Two techniques, explicit type test <ref> [5, 15] </ref> and cloning combined with aggressive aggregate analysis, may be able to resolve these method invocations. Merges in control are another important cause of the run-time polymorphism, especially for trestle, and can be resolved by code splitting and cloning [7, 14, 9]. <p> This result is partly due to Modula-3's language semantics which restrict aliasing; a more powerful alias analysis may be more useful for C++ than for Modula-3, but this need has not yet been demonstrated. Chambers [6], Calder and Grunwald [5], Holzle and Ungar <ref> [15] </ref>, and Grove et al. [13] describe transformations for converting method invocations to direct calls. We focus solely on analysis here. Shivers [23] describes and classifies a range of analyses to discover control flow in Scheme programs. Our interprocedural type propagation is similar to his 0CFA.
Reference: [16] <author> Bill Kalsow and Eric Muller. </author> <note> SRC Modula-3 Version 3.5. </note> <institution> Systems Research Center, Digital Equipment Corporation, </institution> <address> Palo Alto, CA, </address> <year> 1995. </year>
Reference-contexts: We implemented the analyses for Modula-3 programs [19] in the SRC Modula-3 compiler version 3.5 <ref> [16] </ref>. Modula-3 is a statically-typed object-oriented systems programming language similar (for present purposes) to C++ and even more so to Java. We evaluated the analyses on ten Modula-3 programs ranging in size from 400 to 29,000 lines of non-blank, non-comment lines of code (76,122 total lines).
Reference: [17] <author> J. B. Kam and J. D. Ullman. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> Journal of the ACM, </journal> <volume> 7(3) </volume> <pages> 305-318, </pages> <year> 1976. </year>
Reference-contexts: Thus, the union and intersection operators are set union and set intersection respectively. This problem formulation is monotone and distributive. 1 Since Modula-3 programs are always reducible and type propagation is rapid <ref> [17] </ref>, we use a O (n fl v) solution, where n is the number of statements in a procedure and v is the number of variables in the procedure and each step of the algorithm is a bit vector operation. 4.3 Aggregate Analysis The goal of our aggregate analysis is to
Reference: [18] <author> Farshad Nayeri, Benjamin Hurwitz, and Frank Manola. </author> <title> Generalizing dispatching in a distributed object system. </title> <booktitle> In Proceedings of European Conference on Object-Oriented Programming, </booktitle> <address> Bologna, Italy, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: Description format 395 37 47,064 Text formatter dformat 602 95 30,775 Text formatter k-tree 726 13 714,619 Builds and traverses a tree structure slisp 1645 223 67,253 Small lisp interpreter pp 2328 24 458 A pretty printer for Modula-3 programs dom 6186 222 12,377 A system for building distributed applications <ref> [18] </ref> postcard 8214 293 3,076 A graphical mail reader m2tom3 10574 1821 19,886,862 Converts Modula-2 code to Modula-3 m3cg 16475 1808 32,850 M3 v. 3.5.1 code generator + extensions trestle 28977 430 10,756 Window system + small application Total 76,122 4966 Table 2: Benchmark Programs benchmark run and thus the impact
Reference: [19] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1991. </year>
Reference-contexts: Using the cause analysis, we present detailed experimental results that characterize which language and programming features affect the procedure (s) called at run-time from a method invocation site and the ability of the analysis to resolve the method invocations. We implemented the analyses for Modula-3 programs <ref> [19] </ref> in the SRC Modula-3 compiler version 3.5 [16]. Modula-3 is a statically-typed object-oriented systems programming language similar (for present purposes) to C++ and even more so to Java.
Reference: [20] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 146-162, </pages> <address> Pheonix, Arizona, </address> <month> October </month> <year> 1991. </year> <title> SIGPLAN, </title> <publisher> ACM Press. </publisher>
Reference-contexts: They find that type hierarchy analysis is a worthwhile technique that resolves many method invocations. Our work confirms these results. In addition to type hierarchy analysis, we evaluate a range of other techniques. Palsberg and Schwartzbach <ref> [20] </ref>, Agesen and Holzle [1], and Plevyak and Chien [22] describe type inference 6 for dynamically typed object-oriented languages. Agesen and Holzle's, and Plevyak and Chien's analyses are more powerful than ours since they are context sensitive (polyvariant). They are also more complex and expensive.
Reference: [21] <author> Hemant Pande and Barbara G Ryder. </author> <title> Static type determination and aliasing for C++. </title> <type> Technical Report LCSR-TR-250, </type> <institution> Rutgers University, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: Unlike us, Bacon and Sweeney evaluate only flow insensitive analyses. Aigner and Holzle evaluate type feedback and type hierarchy analysis and find that they are both effective at resolving method invocations. Pande and Ryder <ref> [21] </ref> describe a pointer analysis algorithm for C++ programs. Plevyak and Chien's type inference algorithm also does some pointer analysis [22]. Both algorithms consider the control flow in a program and are thus more powerful than our simple aggregate analysis, which also deals with pointer analysis.
Reference: [22] <author> J. Plevyak and A. Chien. </author> <title> Precise concrete type inference for object-oriented languages. </title> <booktitle> In Proceedings of conference on object-oriented programming systems, languages, and applications, </booktitle> <pages> pages 324-340. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: They find that type hierarchy analysis is a worthwhile technique that resolves many method invocations. Our work confirms these results. In addition to type hierarchy analysis, we evaluate a range of other techniques. Palsberg and Schwartzbach [20], Agesen and Holzle [1], and Plevyak and Chien <ref> [22] </ref> describe type inference 6 for dynamically typed object-oriented languages. Agesen and Holzle's, and Plevyak and Chien's analyses are more powerful than ours since they are context sensitive (polyvariant). They are also more complex and expensive. Polyvariant analyses can be used in conjunction with transformations to resolve polymorphic method invocations. <p> Aigner and Holzle evaluate type feedback and type hierarchy analysis and find that they are both effective at resolving method invocations. Pande and Ryder [21] describe a pointer analysis algorithm for C++ programs. Plevyak and Chien's type inference algorithm also does some pointer analysis <ref> [22] </ref>. Both algorithms consider the control flow in a program and are thus more powerful than our simple aggregate analysis, which also deals with pointer analysis. However, they are also much slower than our aggregate analysis.
Reference: [23] <author> Olin Shivers. </author> <title> Control-flow analysis of higher-order languages. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Chambers [6], Calder and Grunwald [5], Holzle and Ungar [15], and Grove et al. [13] describe transformations for converting method invocations to direct calls. We focus solely on analysis here. Shivers <ref> [23] </ref> describes and classifies a range of analyses to discover control flow in Scheme programs. Our interprocedural type propagation is similar to his 0CFA. While Shivers focuses on powerful (and slow) analyses|0CFA is the least powerful analysis he considers|we focus on simple and fast analyses.
References-found: 23

