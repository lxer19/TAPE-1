URL: http://elysium.cs.ucdavis.edu/~benson/publications/mksr-pdpta96.ps
Refering-URL: http://elysium.cs.ucdavis.edu/~benson/publications/publications.html
Root-URL: http://www.cs.ucdavis.edu
Email: fbenson,olssong@cs.ucdavis.edu  
Title: Towards Microkernel Support for the SR Concurrent Programming Language 1  
Author: Gregory D. Benson Ronald A. Olsson tel:()- fax:()- 
Keyword: Concurrent Programming Language Implementation, Distributed and Parallel Computing, SR, Microkernels  
Address: CA 95616, U.S.A  
Affiliation: Department of Computer Science University of California, Davis,  
Abstract: Microkernels provide a core set of abstractions; these usually include threads, interprocess communication (IPC), and memory regions. These abstractions are used to implement higher-level operating system functionality, such as file systems and network protocols. However, programming these low-level abstractions is cumbersome and error-prone. Using a concurrent programming language can raise the level of abstraction in which users write programs, thus hiding details such as thread management, data marshaling, and error handling. The MkSR project focuses on developing high-performance, microkernel-based implementations of the SR concurrent programming language. This paper describes experience implementing a version of MkSR on the Mach microkernel, and presents design rationale and initial performance results. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Cooper and R. Draves. </author> <title> C threads. </title> <type> Technical Report CMU-CS-88-154, </type> <institution> Carnegie Mellon University, Department of Computer Science, </institution> <year> 1988. </year>
Reference-contexts: Many system-level programs implemented with microkernel interfaces use multiple threads and IPC to communicate with the kernel or other programs. To ensure proper execution, these multi-threaded programs must enforce proper synchronization of threads that manipulate shared data. Even with thread libraries, such as Cthreads <ref> [1] </ref> and Pthreads [2], and interface definition languages (IDLs) it is still difficult to implement multi-threaded, communicating programs in C or C++. SR [3] is a concurrent programming language that provides abstractions such as threads and communication channels.
Reference: [2] <author> F. Mueller. </author> <title> A library implementation of POSIX threads under UNIX. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 29-41, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: Many system-level programs implemented with microkernel interfaces use multiple threads and IPC to communicate with the kernel or other programs. To ensure proper execution, these multi-threaded programs must enforce proper synchronization of threads that manipulate shared data. Even with thread libraries, such as Cthreads [1] and Pthreads <ref> [2] </ref>, and interface definition languages (IDLs) it is still difficult to implement multi-threaded, communicating programs in C or C++. SR [3] is a concurrent programming language that provides abstractions such as threads and communication channels.
Reference: [3] <author> G. R. Andrews and R. A. Olsson. </author> <title> The SR Programming Language: Concurrency in Practice. </title> <publisher> The Benjamin/Cummings Publishing Co., </publisher> <address> Redwood City, California, </address> <year> 1993. </year>
Reference-contexts: To ensure proper execution, these multi-threaded programs must enforce proper synchronization of threads that manipulate shared data. Even with thread libraries, such as Cthreads [1] and Pthreads [2], and interface definition languages (IDLs) it is still difficult to implement multi-threaded, communicating programs in C or C++. SR <ref> [3] </ref> is a concurrent programming language that provides abstractions such as threads and communication channels. Like the microkernel abstractions, the SR model reflects the 1 Appears in Proceedings of the International Conference on Parallel and Distributed Processing Techniques and Applications, pages 1513-1524, Sunnyvale, CA, August 1996. underlying hardware. <p> Thus, even though CtuSR does not require locking, it uses locking and thereby incurs a slight performance penalty. Microbenchmark UnixSR CtuSR CtkSR asynchronous send/receive 16.60 22.30 22.40 message passing requiring context switch 25.60 56.80 314.00 rendezvous 54.50 109.50 318.10 Table 3: Intra-VM Communication Performance (in microseconds) As described in <ref> [3] </ref>, an SR local call is more expensive than a C local call because an SR call contains four hidden arguments that are used to address variables and arguments and to handle the general case that a call might be remote.
Reference: [4] <author> D. C. Swinehart, P. T. Zellweger, and R. B. Hagmann. </author> <title> The structure of Cedar. </title> <booktitle> In Proceeding of ACM SIGPLAN 85 Symposium on Language Issues in Programming Environments, SIGPLAN Notices (ACM) 20, </booktitle> <volume> 7, </volume> <pages> pages 230-244, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: The idea is to determine the positive and negative aspects of microkernel design and implementation with respect to programming language implementation, and thus provide feedback to kernel designers. Using a communication-based concurrent programming language for system-level applications is not a new idea. For example, Cedar <ref> [4] </ref> is both a language and an operation system, which is mostly written in Cedar itself. The Cedar language was derived from the Mesa programming language [5] and is based on monitors and remote procedure call.
Reference: [5] <author> B. W. Lampson and D. D. Redell. </author> <title> Experience with processes and monitors in Mesa. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 105-117, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: Using a communication-based concurrent programming language for system-level applications is not a new idea. For example, Cedar [4] is both a language and an operation system, which is mostly written in Cedar itself. The Cedar language was derived from the Mesa programming language <ref> [5] </ref> and is based on monitors and remote procedure call. More recently, Alef [6], a concurrent programming language, is being used to implement parts of the Brazil distributed operating system at Lucent Technologies.
Reference: [6] <author> P. Winterbottom. </author> <title> ALEF language reference manual. </title> <type> Technical report, </type> <institution> AT&T Bell Laboratories, </institution> <year> 1993. </year>
Reference-contexts: For example, Cedar [4] is both a language and an operation system, which is mostly written in Cedar itself. The Cedar language was derived from the Mesa programming language [5] and is based on monitors and remote procedure call. More recently, Alef <ref> [6] </ref>, a concurrent programming language, is being used to implement parts of the Brazil distributed operating system at Lucent Technologies. However, there are few current efforts to achieve high-performance language implementations and none that we know of that target microkernels.
Reference: [7] <author> G.D. Benson and R.A. Olsson. </author> <title> The Design of Microkernel Support for the SR Concurrent Programming Language, </title> <booktitle> chapter 17, </booktitle> <pages> pages 227-240. </pages> <booktitle> Languages, Compilers, and Run-Time Systems for Scalable Computers. </booktitle> <publisher> Kluwer Academic Publishing, </publisher> <address> Boston, MA, </address> <year> 1996. </year> <editor> B. K. Szymanski and B. </editor> <title> Sinharoy (editors). </title>
Reference-contexts: More recently, Alef [6], a concurrent programming language, is being used to implement parts of the Brazil distributed operating system at Lucent Technologies. However, there are few current efforts to achieve high-performance language implementations and none that we know of that target microkernels. In previous work <ref> [7] </ref>, we presented the design of several RTS systems for implementing SR on top of the Mach [8] microkernel. We have implemented many of these ideas and can now begin to quantitatively evaluate our initial designs. This paper presents our experience implementing different Mach-based versions of SR. <p> Section 3 presents several design issues in mapping SR semantics onto the Mach abstractions. Section 4 describes our current implementations and summarizes their performance. Finally, Section 5 offers some concluding remarks and directions for future work. 2 Background The MkSR project grew out a project called SRMach <ref> [7] </ref> in which we aimed to develop a Mach-based implementation of SR. Recent advances in microkernel technology, including extensible microkernels, has prompted us to consider other interfaces in addition to the Mach interfaces. Still, however, our current experimental system is implemented on top of Mach. <p> Therefore, a tool called MIG (Mach Interface Generator) is used to create client and server stubs for RPC (remote procedure call) [14]. 3 Design Issues SR's semantics can be mapped onto Mach's abstractions in several ways. In <ref> [7] </ref>, we presented several different design options for implementing SR on top of Mach. Since then, we have implemented some of these designs. Our implementation effort has provided qualitative and quantitative insight into many implementation issues. <p> In addition, SR's "in" statement provides a powerful mechanism for selecting incoming invocations. In this section, we present different design choices for the communication in different localities. 3.4.1 Intra-VM Communication Intra-VM communication constitutes any form of communication that occurs between processes running in the same virtual machine. In <ref> [7] </ref> we proposed using Mach IPC for all forms of SR communication. The idea was to simplify the RTS as much as possible by utilizing Mach's abstractions. However, on further review, using Mach IPC for intra-VM communication is undesirable.
Reference: [8] <author> M. Accetta et al. </author> <title> A new kernel foundation for UNIX development. </title> <booktitle> In Proceedings of the Summer 1986 USENIX Conference, </booktitle> <pages> pages 93-112, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: However, there are few current efforts to achieve high-performance language implementations and none that we know of that target microkernels. In previous work [7], we presented the design of several RTS systems for implementing SR on top of the Mach <ref> [8] </ref> microkernel. We have implemented many of these ideas and can now begin to quantitatively evaluate our initial designs. This paper presents our experience implementing different Mach-based versions of SR. Section 2 briefly describes the major features of the SR programming language and the Mach microkernel. <p> MkLinux only recently became available and may prove to be a good environment for working with the OSF/1 RI microkernel. The Mach microkernel <ref> [8] </ref> supports a small number of powerful abstractions including tasks, threads, ports, messages, and memory objects. Tasks contain threads and threads communicate with each other by sending messages through ports. In fact, all kernel requests are sent as messages from a thread to the kernel.
Reference: [9] <author> H. E. Bal, M. F. Kaashoek, and A. S. Tanenbaum. Orca: </author> <title> A language for parallel programming of distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(3) </volume> <pages> 190-205, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Many of SR's abstractions corresponding to modern hardware, including share memory multiprocessors and networks of workstations. While SR does not provide expensive abstractions such as distributed shared memory (DSM) or distributed shared objects <ref> [9] </ref>, it does provide simple and consistent mechanisms for expressing several forms of explicit communication. SR's syntax and semantics allow the programmer to concentrate on the communication and synchronization structure of a program without having to be concerned with low-level interfaces or IDLs.
Reference: [10] <author> J. Liedtke. </author> <title> On micro-kernel construction. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating System Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: The microkernel versus monolithic kernel is still a debated topic in the operating systems community. For example, Liedtke presented some very impressive performance results using the L4 microkernel and argued that microkernels can be very efficient and still maintain the IPC abstraction <ref> [10] </ref>. <p> Unfortunately, to our knowledge scheduler activations have not been incorporated into mainstream kernels and more recent versions of Mach. Finally, the overhead for thread creation and context switching in Mach is high relative to other microkernels. Systems such as L3 and L4 <ref> [17, 10] </ref>, QNX [18], SPIN [12], and Exoker-nel [13] all exhibit superior thread performance, thus mitigating the negative aspects of using kernel threads. The SR RTS uses two types of synchronization. For guaranteeing mutual exclusion to internal data structures, simple mutual exclusion locks can be used. <p> To implement the full semantics of the "in" statement, the RTS must buffer invocations, as is currently implemented in the RTS. Therefore, using Mach IPC would not achieve our original goal of simplifying the RTS. Finally, unlike Mach, other microkernels such as L3 and L4 <ref> [10] </ref>, and Amoeba [19] only provide synchronous IPC. Even newer versions of Mach, such as Mach 4 from the University of Utah [20], and OSF/1 MK [11] have implemented synchronous, cross address space communication to improve IPC performance. <p> The University of Utah is also working on adding efficient low-level network interfaces to the Mach 4 kernel. As part of the general MkSR work, we will also begin evaluating as possible MkSR targets different microkernels and extensible kernels such as L4 <ref> [10] </ref>, SPIN [12], and Exokernel [13]. Targeting another microkernel will increase the usability of MkSR and also provide additional insight into structuring the MkSR RTS for different microkernel interfaces and abstractions. So far, we have only looked at mapping SR's mechanisms for expressing parallelism, synchronization, and communication.
Reference: [11] <author> F. Barbou des Places, N. Stephen, and F. Reynolds. </author> <title> Linux on the OSF Mach3 microker--nel. </title> <type> Technical report, </type> <institution> OSF Research Institute, Grenoble, France and Cambridge, </institution> <address> MA, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: The microkernel versus monolithic kernel is still a debated topic in the operating systems community. For example, Liedtke presented some very impressive performance results using the L4 microkernel and argued that microkernels can be very efficient and still maintain the IPC abstraction [10]. Recently, the MkLinux project <ref> [11] </ref> has exhibited the portability advantages of basing an operating system on top of a microkernel In any case, a trend in operating systems research is to minimize the functionality of the kernel, thus allowing user-level applications to have greater control of system resources and implement higher-level abstractions. <p> Finally, unlike Mach, other microkernels such as L3 and L4 [10], and Amoeba [19] only provide synchronous IPC. Even newer versions of Mach, such as Mach 4 from the University of Utah [20], and OSF/1 MK <ref> [11] </ref> have implemented synchronous, cross address space communication to improve IPC performance. Consequently, RTS invocation buffer management is required by systems that only provide synchronous IPC. 3.4.2 Inter-VM Communication Inter-VM communication occurs when a process on one virtual machine invokes an operation on another virtual machine.
Reference: [12] <author> B. N. Bershad et al. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Proceedings of the Fifteenth Symposium on Operating System Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: Extensible kernels <ref> [12, 13] </ref> take the microkernel concept one step further by allowing user-level applications to download code into the kernel in a safe manner. We chose to use Mach as our experimental platform because it was the most accessible microkernel at the time we started the MkSR project. <p> Unfortunately, to our knowledge scheduler activations have not been incorporated into mainstream kernels and more recent versions of Mach. Finally, the overhead for thread creation and context switching in Mach is high relative to other microkernels. Systems such as L3 and L4 [17, 10], QNX [18], SPIN <ref> [12] </ref>, and Exoker-nel [13] all exhibit superior thread performance, thus mitigating the negative aspects of using kernel threads. The SR RTS uses two types of synchronization. For guaranteeing mutual exclusion to internal data structures, simple mutual exclusion locks can be used. <p> The University of Utah is also working on adding efficient low-level network interfaces to the Mach 4 kernel. As part of the general MkSR work, we will also begin evaluating as possible MkSR targets different microkernels and extensible kernels such as L4 [10], SPIN <ref> [12] </ref>, and Exokernel [13]. Targeting another microkernel will increase the usability of MkSR and also provide additional insight into structuring the MkSR RTS for different microkernel interfaces and abstractions. So far, we have only looked at mapping SR's mechanisms for expressing parallelism, synchronization, and communication.
Reference: [13] <author> D. R. Engler, M. F. Kaashoek, and J. O'Toole Jr. Exokernel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Proceedings of the Fifteenth Symposium on Operating System Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: Extensible kernels <ref> [12, 13] </ref> take the microkernel concept one step further by allowing user-level applications to download code into the kernel in a safe manner. We chose to use Mach as our experimental platform because it was the most accessible microkernel at the time we started the MkSR project. <p> Finally, the overhead for thread creation and context switching in Mach is high relative to other microkernels. Systems such as L3 and L4 [17, 10], QNX [18], SPIN [12], and Exoker-nel <ref> [13] </ref> all exhibit superior thread performance, thus mitigating the negative aspects of using kernel threads. The SR RTS uses two types of synchronization. For guaranteeing mutual exclusion to internal data structures, simple mutual exclusion locks can be used. <p> The University of Utah is also working on adding efficient low-level network interfaces to the Mach 4 kernel. As part of the general MkSR work, we will also begin evaluating as possible MkSR targets different microkernels and extensible kernels such as L4 [10], SPIN [12], and Exokernel <ref> [13] </ref>. Targeting another microkernel will increase the usability of MkSR and also provide additional insight into structuring the MkSR RTS for different microkernel interfaces and abstractions. So far, we have only looked at mapping SR's mechanisms for expressing parallelism, synchronization, and communication.
Reference: [14] <author> J. Boykin, D. Kirschen, A. Langerman, and S. LoVerso. </author> <title> Programming under Mach. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1993. </year>
Reference-contexts: Although Mach supports asynchronous message passing, the syntax and semantics associated with the system calls to send and receive messages is quite complex. Therefore, a tool called MIG (Mach Interface Generator) is used to create client and server stubs for RPC (remote procedure call) <ref> [14] </ref>. 3 Design Issues SR's semantics can be mapped onto Mach's abstractions in several ways. In [7], we presented several different design options for implementing SR on top of Mach. Since then, we have implemented some of these designs.
Reference: [15] <author> T. E. Anderson, B. N. Bershad, E. D. Lazowska, and H. M. Levy. </author> <title> Scheduler activations: Effective kernel support for the user-level management of parallelism. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 53-70, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: The problems associated with user-level threads, kernel threads, and mapping user-level threads onto kernel threads led to a new abstraction, called the scheduler activation, that gives a user-level thread library tighter control over scheduling decisions made by the kernel <ref> [15] </ref>. An implementation of scheduler activations on the Mach 3.0 microkernel was presented in [16]. Unfortunately, to our knowledge scheduler activations have not been incorporated into mainstream kernels and more recent versions of Mach.
Reference: [16] <author> P. Barton-Davis, D. McNamee, R. Vaswani, and E. D. Lazowska. </author> <title> Adding scheduler activations to Mach 3.0. </title> <booktitle> In Proceedings of the USENIX Mach III Symposium, </booktitle> <pages> pages 119-136, </pages> <month> April </month> <year> 1993. </year> <note> Also as Tech report UW-CSE-92-08-03, </note> <institution> University of Washington, Department of Computer Science and Engineering. </institution>
Reference-contexts: An implementation of scheduler activations on the Mach 3.0 microkernel was presented in <ref> [16] </ref>. Unfortunately, to our knowledge scheduler activations have not been incorporated into mainstream kernels and more recent versions of Mach. Finally, the overhead for thread creation and context switching in Mach is high relative to other microkernels.
Reference: [17] <author> J. Liedtke. </author> <title> Fast thread management and communication without continuations. </title> <booktitle> In Proceedings of the USENIX Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 213-221, </pages> <address> Seattle, WA, USA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Unfortunately, to our knowledge scheduler activations have not been incorporated into mainstream kernels and more recent versions of Mach. Finally, the overhead for thread creation and context switching in Mach is high relative to other microkernels. Systems such as L3 and L4 <ref> [17, 10] </ref>, QNX [18], SPIN [12], and Exoker-nel [13] all exhibit superior thread performance, thus mitigating the negative aspects of using kernel threads. The SR RTS uses two types of synchronization. For guaranteeing mutual exclusion to internal data structures, simple mutual exclusion locks can be used.
Reference: [18] <author> D. Hildebrand. </author> <title> An architectural overview of QNX. </title> <booktitle> In Proceeding of the Usenix Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <address> Seattle, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Unfortunately, to our knowledge scheduler activations have not been incorporated into mainstream kernels and more recent versions of Mach. Finally, the overhead for thread creation and context switching in Mach is high relative to other microkernels. Systems such as L3 and L4 [17, 10], QNX <ref> [18] </ref>, SPIN [12], and Exoker-nel [13] all exhibit superior thread performance, thus mitigating the negative aspects of using kernel threads. The SR RTS uses two types of synchronization. For guaranteeing mutual exclusion to internal data structures, simple mutual exclusion locks can be used.
Reference: [19] <author> A. S. Tanenbaum, R. van Renesse, H. van Stareren, G. J. Sharp, S. J. Mullender, J. Jansen, and G. van Rossum. </author> <title> Experience with the Amoeba distributed operating system. </title> <journal> Communications of the ACM, </journal> <volume> 33(12) </volume> <pages> 46-63, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: To implement the full semantics of the "in" statement, the RTS must buffer invocations, as is currently implemented in the RTS. Therefore, using Mach IPC would not achieve our original goal of simplifying the RTS. Finally, unlike Mach, other microkernels such as L3 and L4 [10], and Amoeba <ref> [19] </ref> only provide synchronous IPC. Even newer versions of Mach, such as Mach 4 from the University of Utah [20], and OSF/1 MK [11] have implemented synchronous, cross address space communication to improve IPC performance.
Reference: [20] <author> B. Ford and J. Lepreau. </author> <title> Evolving mach 3.0 to a migrating thread model. </title> <booktitle> In Proceedings of the Winter 1994 USENIX Technical Conference and Exhibition, </booktitle> <pages> pages 97-114, </pages> <month> January </month> <year> 1994. </year> <note> Also tech report UUCS-93-022, </note> <institution> University of Utah, Department of Computer Science. </institution>
Reference-contexts: Therefore, using Mach IPC would not achieve our original goal of simplifying the RTS. Finally, unlike Mach, other microkernels such as L3 and L4 [10], and Amoeba [19] only provide synchronous IPC. Even newer versions of Mach, such as Mach 4 from the University of Utah <ref> [20] </ref>, and OSF/1 MK [11] have implemented synchronous, cross address space communication to improve IPC performance. Consequently, RTS invocation buffer management is required by systems that only provide synchronous IPC. 3.4.2 Inter-VM Communication Inter-VM communication occurs when a process on one virtual machine invokes an operation on another virtual machine.
Reference: [21] <author> N. C. Hutchinson and L. L. Peterson. </author> <title> The x-Kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The socket-based implementation uses the socket interface provided by the Lites Unix server. We have yet to explore alternatives for cross-machine communication. Recently, versions of the Mach 3.0 net message server and the xKernel <ref> [21, 22] </ref> have been made available for Mach 4. 3.4.3 Interoperability SR programs running on top of Mach will not exist in isolation, they will need to interact with non-SR programs. System-level SR programs will require access to systems services and will also provide services.
Reference: [22] <author> H. Orman, E. Menze III, S. O'Malley, and L. Peterson. </author> <title> A fast and general implementation of Mach IPC in a network. </title> <booktitle> In Mach III Symposium, </booktitle> <pages> pages 75-88, </pages> <address> Santa Fe, New Mexico, </address> <month> April </month> <year> 1993. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: The socket-based implementation uses the socket interface provided by the Lites Unix server. We have yet to explore alternatives for cross-machine communication. Recently, versions of the Mach 3.0 net message server and the xKernel <ref> [21, 22] </ref> have been made available for Mach 4. 3.4.3 Interoperability SR programs running on top of Mach will not exist in isolation, they will need to interact with non-SR programs. System-level SR programs will require access to systems services and will also provide services.
Reference: [23] <author> M. S. Atkins and R. A. Olsson. </author> <title> Performance of multi-tasking and synchronization mechanisms in the programming language SR. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 879-895, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Many of the microbenchmarks presented in this section come from a set of benchmarks designed to evaluated the performance of SR's concurrency mechanisms <ref> [23] </ref>. The benchmarks were run on a lightly loaded system. The results are the medians of several runs, where each run consisted of 10 5 to 10 7 iterations depending on the benchmark. All of the operations in the benchmarks are parameterless.
Reference: [24] <author> V. W. Freeh. </author> <title> A comparison of implicit and explicit parallel programming. </title> <type> Technical Report TR 93-30b, </type> <institution> Department of Computer Science, University of Arizona, </institution> <year> 1993. </year>
Reference-contexts: So far, we have only looked at mapping SR's mechanisms for expressing parallelism, synchronization, and communication. However, sequential performance is also crucial to system-level programs. SR's current sequential performance is poor compared to sequential C code <ref> [24] </ref>. As discussed in [25], attempting to use an SR resource as an abstract data type is currently too expensive for practical use.
Reference: [25] <author> H. E. Bal. </author> <title> Parallel programming in SR. </title> <booktitle> In IEEE CS International Conference on Computer Languages, </booktitle> <pages> pages 310-319. </pages> <publisher> IEEE Press, </publisher> <year> 1992. </year>
Reference-contexts: So far, we have only looked at mapping SR's mechanisms for expressing parallelism, synchronization, and communication. However, sequential performance is also crucial to system-level programs. SR's current sequential performance is poor compared to sequential C code [24]. As discussed in <ref> [25] </ref>, attempting to use an SR resource as an abstract data type is currently too expensive for practical use. We plan to evaluate SR's sequential performance and determine if the inefficiency is inherent in the SR's semantics or due to the current SR code generator and RTS interface.
References-found: 25

