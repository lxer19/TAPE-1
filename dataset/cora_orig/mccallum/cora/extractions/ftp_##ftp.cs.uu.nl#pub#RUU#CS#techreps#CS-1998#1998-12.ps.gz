URL: ftp://ftp.cs.uu.nl/pub/RUU/CS/techreps/CS-1998/1998-12.ps.gz
Refering-URL: http://www.cs.ruu.nl/docs/research/publication/TechList1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Linear Size Binary Space Partitions for Uncluttered Scenes  
Author: Mark de Berg 
Address: P.O.Box 80.089, 3508 TB Utrecht, the Netherlands.  
Affiliation: Department of Computer Science, Utrecht University,  
Abstract: We describe a new and simple method for constructing binary space partitions in arbitrary dimensions. We also introduce the concept of uncluttered scenes, which are scenes with a certain property that we suspect many realistic scenes exhibit, and we show that our method constructs a BSP of size O(n) for an uncluttered scene consisting of n objects. The construction time is O(n log n). Because any set of disjoint fat objects is uncluttered, our result implies an efficient method to construct a linear size BSP for fat objects. We use our BSP to develop a data structure for point location in uncluttered scenes. The query time of our structure is O(log n), and the amount of storage is O(n). This result can in turn be used to perform range queries with not-too-small ranges in scenes consisting of disjoint fat objects or, more generally, in so-called low-density scenes.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Pankaj K. Agarwal, M. J. Katz, and M. Sharir. </author> <title> Computing depth orders and related problems. </title> <booktitle> In Proc. 4th Scand. Workshop Algorithm Theory, </booktitle> <pages> pages 1-12, </pages> <year> 1994. </year>
Reference-contexts: Fat objects are objects that do not have long and skinny 2 parts; a formal definition is given in Section 2.3. Recently, fat objects have attracted a lot of attention in computational geometry <ref> [1, 9, 28, 13, 15, 26, 27] </ref>. De Berg et al. proved that scenes of fat objects always admit a BSP of linear size. Their algorithm for constructing a BSP runs in O (n log n log log n) time, where n is the number of objects.
Reference: [2] <author> S. Arya, D. M. Mount, N. S. Netanyahu, R. Silverman, and A. Wu. </author> <title> An optimal algorithm for approximate nearest neighbor searching. </title> <booktitle> In Proc. 5th ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 573-582, </pages> <year> 1994. </year>
Reference: [3] <author> C. Ballieux. </author> <title> Motion planning using binary space partitions. </title> <type> Technical Report Inf/src/93-25, </type> <institution> Utrecht University, </institution> <year> 1993. </year>
Reference-contexts: Binary space partitions are used for many purposes. For example, they are used for hidden surface removal with the painter's algorithm [10], for shadow generation [8], for set operations on polyhedra [14, 24], for visibility preprocessing for interactive walkthroughs [23], and for cell decomposition methods in motion planning <ref> [3] </ref>. The efficiency of algorithms based on BSPs depends crucially on the size of the BSP, that is, on the number of cells of the decomposition.
Reference: [4] <author> M. de Berg. </author> <title> Linear size binary space partitions for fat objects. </title> <booktitle> In Proc. 3rd Annual European Symposium on Algorithms (ESA '95), volume 979 of Lecture Notes in Computer Science, </booktitle> <pages> pages 252-263. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Although the method works in arbitrary dimensions we shall mostly use three-dimensional terminology from now on. 1 In a preliminary version of this paper <ref> [4] </ref> and in Vleugels's thesis [30] the term "bounding-box fitness" was used to express this condition. 3 2.1 The Partitioning Strategy Before we start we need a few definitions. The bounding box of an object o is the smallest axis-aligned box that contains the object.
Reference: [5] <author> M. de Berg, M. de Groot, and M. Overmars. </author> <title> New results on binary space partitions in the plane. </title> <booktitle> In Proc. 4th Scand. Workshop Algorithm Theory, volume 824 of Lecture Notes Comput. Sci., </booktitle> <pages> pages 61-72. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Indeed, the example proving the (n 2 ) lower bound on the size of BSPs is a quite artificial construction, which uses long and thin triangles in a grid-like pattern. The discrepancy between theory and practice lead de Berg et al. <ref> [5] </ref> to study BSPs for scenes consisting of fat objects. Fat objects are objects that do not have long and skinny 2 parts; a formal definition is given in Section 2.3. Recently, fat objects have attracted a lot of attention in computational geometry [1, 9, 28, 13, 15, 26, 27].
Reference: [6] <author> M. de Berg, M.J. Katz, A. F. van der Stappen, and J. Vleugels. </author> <title> Realistic input models for geometric algorithms. </title> <booktitle> In Proc. 13th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 294-303, </pages> <year> 1997. </year>
Reference-contexts: Although this is a rather technical condition, we believe it is usually satisfied in practice. To obtain the result for fat objects, we show that any set of fat objects is uncluttered. (In a recent paper by de Berg et al. <ref> [6] </ref> the relation between various of these so-called realistic input models is studied extensively.) BSP trees are often used to perform point location queries (report the objects in a scene that contain a query point) and range searching queries (report the objects in a scene intersecting a query range).
Reference: [7] <author> P. B. Callahan and S. R. Kosaraju. </author> <title> A decomposition of multidimensional point sets with applications to k-nearest-neighbors and n-body potential fields. </title> <journal> J. ACM, </journal> <volume> 42 </volume> <pages> 67-90, </pages> <year> 1995. </year>
Reference-contexts: So if we spend linear time on each split and the splits are very unbalanced, then the running time T (n) would satisfy a recurrence like T (n) = O (n) + T (n 1), leading to a quadratic running time. Vaidya [25] and Callahan and Kosaraju <ref> [7] </ref> describe techniques for building an octree-like structure, where this problem is solved. Both techniques are directly applicable in our situation and lead to a contruction time of O (n log n). The second stage. <p> We can maintain the objects intersecting a cell during the recursive calls, but this will take too much time for unbalanced splits. To get around this problem we could try to use a technique similar to the technique of Vaidya [25] or Callahan and Kosaraju <ref> [7] </ref>, like in the first stage, but there are some difficulties with the approach when we deal with object fragments.
Reference: [8] <author> N. Chin and S. Feiner. </author> <title> Near real time shadow generation using bsp trees. </title> <booktitle> In Proc. SIGGRAPH'89, </booktitle> <pages> pages 99-106, </pages> <year> 1989. </year>
Reference-contexts: Such a tree is called a binary space partition tree, or BSP tree. Binary space partitions are used for many purposes. For example, they are used for hidden surface removal with the painter's algorithm [10], for shadow generation <ref> [8] </ref>, for set operations on polyhedra [14, 24], for visibility preprocessing for interactive walkthroughs [23], and for cell decomposition methods in motion planning [3]. The efficiency of algorithms based on BSPs depends crucially on the size of the BSP, that is, on the number of cells of the decomposition.
Reference: [9] <author> A. Efrat, M. Sharir, and G. </author> <title> Rote. On the union of fat wedges and separating a collection of segments by a line. </title> <journal> Comput. Geom. Theory Appl., </journal> <volume> 3 </volume> <pages> 277-288, </pages> <year> 1994. </year>
Reference-contexts: Fat objects are objects that do not have long and skinny 2 parts; a formal definition is given in Section 2.3. Recently, fat objects have attracted a lot of attention in computational geometry <ref> [1, 9, 28, 13, 15, 26, 27] </ref>. De Berg et al. proved that scenes of fat objects always admit a BSP of linear size. Their algorithm for constructing a BSP runs in O (n log n log log n) time, where n is the number of objects.
Reference: [10] <author> H. Fuchs, Z. M. Kedem, and B. Naylor. </author> <title> On visible surface generation by a priori tree structures. </title> <journal> Comput. Graph., </journal> <volume> 14(3) </volume> <pages> 124-133, </pages> <year> 1980. </year> <note> Proc. SIGGRAPH '80. </note>
Reference-contexts: Such a tree is called a binary space partition tree, or BSP tree. Binary space partitions are used for many purposes. For example, they are used for hidden surface removal with the painter's algorithm <ref> [10] </ref>, for shadow generation [8], for set operations on polyhedra [14, 24], for visibility preprocessing for interactive walkthroughs [23], and for cell decomposition methods in motion planning [3].
Reference: [11] <author> L. J. Guibas, J. Hershberger, D. Leven, M. Sharir, and R. E. Tarjan. </author> <title> Linear-time algorithms for visibility and shortest path problems inside triangulated simple polygons. </title> <journal> Algorithmica, </journal> <volume> 2 </volume> <pages> 209-233, </pages> <year> 1987. </year> <month> 13 </month>
Reference: [12] <author> D. Harel and R. E. Tarjan. </author> <title> Fast algorithms for finding nearest common ancestors. </title> <journal> SIAM J. Comput., </journal> <volume> 13 </volume> <pages> 338-355, </pages> <year> 1984. </year>
Reference-contexts: The first is the structure of Schwarz et al. [21] to do point location in the BSP subdivision. The second component of the structure is the BSP tree itself, preprocessed for lowest-common-ancestor queries. Such queries can be answered in O (1) time after linear preprocessing <ref> [12] </ref>. (In our application O (log m) query time would also be sufficient.) The query algorithm works as follows: First we determine the highest node in the BSP tree whose splitting plane cuts Q. (More precisely, we should restrict our attention to the 10 part of the splitting plane lying inside <p> Proof: The bounds on the preprocessing time and the storage follow immediately from the fact that the point location structure of Schwarz et al. [21] uses linear preprocessing, and the fact that preprocessing a binary tree for lowest common ancestor queries takes linear time <ref> [12] </ref>. It remains to prove the bound on the query time.
Reference: [13] <author> J. Matousek, J. Pach, M. Sharir, S. Sifrony, and E. Welzl. </author> <title> Fat triangles determine linearly many holes. </title> <journal> SIAM J. Comput., </journal> <volume> 23 </volume> <pages> 154-169, </pages> <year> 1994. </year>
Reference-contexts: Fat objects are objects that do not have long and skinny 2 parts; a formal definition is given in Section 2.3. Recently, fat objects have attracted a lot of attention in computational geometry <ref> [1, 9, 28, 13, 15, 26, 27] </ref>. De Berg et al. proved that scenes of fat objects always admit a BSP of linear size. Their algorithm for constructing a BSP runs in O (n log n log log n) time, where n is the number of objects.
Reference: [14] <author> B. Naylor, J. A. Amanatides, and W. Thibault. </author> <title> Merging BSP trees yields polyhedral set operations. </title> <journal> Comput. Graph., </journal> <volume> 24(4) </volume> <pages> 115-124, </pages> <month> August </month> <year> 1990. </year> <note> Proc. SIGGRAPH '90. </note>
Reference-contexts: Such a tree is called a binary space partition tree, or BSP tree. Binary space partitions are used for many purposes. For example, they are used for hidden surface removal with the painter's algorithm [10], for shadow generation [8], for set operations on polyhedra <ref> [14, 24] </ref>, for visibility preprocessing for interactive walkthroughs [23], and for cell decomposition methods in motion planning [3]. The efficiency of algorithms based on BSPs depends crucially on the size of the BSP, that is, on the number of cells of the decomposition.
Reference: [15] <author> M. H. Overmars. </author> <title> Point location in fat subdivisions. </title> <journal> Inform. Process. Lett., </journal> <volume> 44 </volume> <pages> 261-265, </pages> <year> 1992. </year>
Reference-contexts: Fat objects are objects that do not have long and skinny 2 parts; a formal definition is given in Section 2.3. Recently, fat objects have attracted a lot of attention in computational geometry <ref> [1, 9, 28, 13, 15, 26, 27] </ref>. De Berg et al. proved that scenes of fat objects always admit a BSP of linear size. Their algorithm for constructing a BSP runs in O (n log n log log n) time, where n is the number of objects. <p> This improves and generalizes a result of Overmars <ref> [15] </ref>, who showed that point location queries in a set of n disjoint fat objects can be done in O (log d1 n) time with a structure using O (n log d1 n) storage.
Reference: [16] <author> M. H. Overmars and A. F. van der Stappen. </author> <title> Range searching and point location among fat objects. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Algorithms - ESA'94, volume 855 of Lecture Notes Comput. Sci., </booktitle> <pages> pages 240-253, </pages> <address> Berlin, 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The query time for range searching is then O (log n)|the assumptions imply that the number of reported objects is O (1), so no extra term is needed for this|and the amount of storage is still O (n). This improves results by Overmars and van der Stappen <ref> [16] </ref> and by Schwarzkopf and Vleugels [22], who obtain O (log d1 n) query time with a structure using O (n log d1 n) storage. 2 The BSP construction Let S be a set of n non-intersecting objects in R d , where d &gt; 2. <p> Since low density implies unclutteredness (Lemma 2.8) it now follows from Theorem 3.1 that the point location queries on S fl can be performed in O (log n) time, from which the corollary follows. fl This result improves results by Overmars and Van der Stappen <ref> [16] </ref> and Schwarzkopf and Vleugels [22] by a factor of O (log d1 n) in storage and of O (log d2 n) in query time. 3.3 Range searching in rectilinear BSPs There is one issue that still needs attention: we have to show that we can find for each object in
Reference: [17] <author> M. S. Paterson and F. F. Yao. </author> <title> Efficient binary space partitions for hidden-surface removal and solid modeling. </title> <journal> Discrete Comput. Geom., </journal> <volume> 5 </volume> <pages> 485-503, </pages> <year> 1990. </year>
Reference-contexts: Hence, when constructing a BSP of a given scene, one should choose the splitting hyperplanes carefully, so that the fragmentation of the objects is kept small. In two-dimensional space it is always possible to keep the fragmentation reasonably small: Paterson and Yao <ref> [17] </ref> proved that any set of polygons in the plane with n edges in total admits a BSP of size O (n log n) and that any set of axis-parallel polygons admits a linear size BSP. <p> More precisely, one would like to compute 12 the clutter factors of various typical architectural models, say, and see whether the clutter factor is indeed a fairly small. A theoretical problem that still remains wide open is whether the conjecture of Paterson and Yao <ref> [17] </ref> (any set of line segments in the plane admits a linear size BSP) is true. Acknowledgment With David Kirkpatrick I discussed the preprocessing of the BSP extensively, and he was the one who discovered that Vaidya's result can be used for this.
Reference: [18] <author> M. S. Paterson and F. F. Yao. </author> <title> Optimal binary space partitions for orthogonal objects. </title> <journal> J. Algorithms, </journal> <volume> 13 </volume> <pages> 99-113, </pages> <year> 1992. </year>
Reference-contexts: In three-dimensional space|the setting most relevant to computer graphics|the situation is less rosy: the method of Paterson and Yao is only guaranteed to produce a BSP of size O (n 2 ). (For axis-parallel polyhedra one can obtain a BSP of size O (n p n) <ref> [18] </ref>.) They also gave an example of a three-dimensional scene such that any BSP must have quadratic size, which shows that their method is optimal in the worst case. A quadratic size BSP is, of course, useless in most practical applications. Nevertheless, BSPs usually perform fine in practice.
Reference: [19] <author> H. Samet. </author> <title> Applications of Spatial Data Structures. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Therefore decompositions of two-, three-, or higher-dimensional scenes play an important role in areas like computer graphics, geographic information systems, and robotics. There is a variety of schemes available to construct decompositions. Quadtrees and oc-trees, and kd-trees are among the most popular ones <ref> [19, 20] </ref>. Another popular decomposition scheme is the binary space partition, or BSP. In this scheme the space is split into two sub-spaces with a hyperplane, so in R 2 it is split with a line and in R 3 with a plane.
Reference: [20] <author> H. Samet. </author> <title> The Design and Analysis of Spatial Data Structures. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Therefore decompositions of two-, three-, or higher-dimensional scenes play an important role in areas like computer graphics, geographic information systems, and robotics. There is a variety of schemes available to construct decompositions. Quadtrees and oc-trees, and kd-trees are among the most popular ones <ref> [19, 20] </ref>. Another popular decomposition scheme is the binary space partition, or BSP. In this scheme the space is split into two sub-spaces with a hyperplane, so in R 2 it is split with a line and in R 3 with a plane.
Reference: [21] <author> C. Schwarz, M. Smid, and J. Snoeyink. </author> <title> An optimal algorithm for the on-line closest-pair problem. </title> <journal> Algorithmica, </journal> <volume> 12 </volume> <pages> 18-29, </pages> <year> 1994. </year>
Reference-contexts: A rectilinear BSP tree is a BSP tree whose underlying binary space partition is rectilinear. Recall that the intermediate BSP resulting from the first stage of the algorithm of Section 2.1 is rectilinear. Schwarz et al. <ref> [21] </ref> show that a rectilinear BSP can be preprocessed in linear time such that one can do point location in logarithmic time. To perform point location in an arbitrary scene S we proceed as follows. <p> Hence, we have to preprocess the rectilinear BSP in a different manner for range searching. Our structure to report which cells of the rectilinear BSP are intersected by a query range has two components. The first is the structure of Schwarz et al. <ref> [21] </ref> to do point location in the BSP subdivision. The second component of the structure is the BSP tree itself, preprocessed for lowest-common-ancestor queries. <p> Proof: The bounds on the preprocessing time and the storage follow immediately from the fact that the point location structure of Schwarz et al. <ref> [21] </ref> uses linear preprocessing, and the fact that preprocessing a binary tree for lowest common ancestor queries takes linear time [12]. It remains to prove the bound on the query time.
Reference: [22] <author> Otfried Schwarzkopf and Jules Vleugels. </author> <title> Range searching in low-density environments. </title> <journal> Inform. Process. Lett., </journal> <volume> 60 </volume> <pages> 121-127, </pages> <year> 1996. </year>
Reference-contexts: This improves results by Overmars and van der Stappen [16] and by Schwarzkopf and Vleugels <ref> [22] </ref>, who obtain O (log d1 n) query time with a structure using O (n log d1 n) storage. 2 The BSP construction Let S be a set of n non-intersecting objects in R d , where d &gt; 2. <p> Then the set S can be preprocessed in O (n log n) time into a data structure that uses O (n) storage, such that range queries with constant-complexity ranges Q for which (mes (Q)) 6 min can be answered in O (log n) time. Proof: Schwarzkopf and Vleugels <ref> [22] </ref> have shown that range searching queries on S can be answered by performing a number of point location queries on a set S fl , which is obtained by taking the Minkowski sums of the objects in S with a hypercube of edge length min . <p> Since low density implies unclutteredness (Lemma 2.8) it now follows from Theorem 3.1 that the point location queries on S fl can be performed in O (log n) time, from which the corollary follows. fl This result improves results by Overmars and Van der Stappen [16] and Schwarzkopf and Vleugels <ref> [22] </ref> by a factor of O (log d1 n) in storage and of O (log d2 n) in query time. 3.3 Range searching in rectilinear BSPs There is one issue that still needs attention: we have to show that we can find for each object in the set S which cells
Reference: [23] <author> S. J. Teller and C. H. Sequin. </author> <title> Visibility preprocessing for interactive walkthroughs. </title> <journal> Comput. Graph., </journal> <volume> 25(4) </volume> <pages> 61-69, </pages> <month> July </month> <year> 1991. </year> <note> Proc. SIGGRAPH '91. </note>
Reference-contexts: Binary space partitions are used for many purposes. For example, they are used for hidden surface removal with the painter's algorithm [10], for shadow generation [8], for set operations on polyhedra [14, 24], for visibility preprocessing for interactive walkthroughs <ref> [23] </ref>, and for cell decomposition methods in motion planning [3]. The efficiency of algorithms based on BSPs depends crucially on the size of the BSP, that is, on the number of cells of the decomposition.
Reference: [24] <author> W. C. Thibault and B. F. Naylor. </author> <title> Set operations on polyhedra using binary space partitioning trees. </title> <journal> Comput. Graph., </journal> <volume> 21(4) </volume> <pages> 153-162, </pages> <year> 1987. </year> <note> Proc. SIGGRAPH '87. </note>
Reference-contexts: Such a tree is called a binary space partition tree, or BSP tree. Binary space partitions are used for many purposes. For example, they are used for hidden surface removal with the painter's algorithm [10], for shadow generation [8], for set operations on polyhedra <ref> [14, 24] </ref>, for visibility preprocessing for interactive walkthroughs [23], and for cell decomposition methods in motion planning [3]. The efficiency of algorithms based on BSPs depends crucially on the size of the BSP, that is, on the number of cells of the decomposition.
Reference: [25] <author> P. M. Vaidya. </author> <title> An O(n log n) algorithm for the all-nearest-neighbors problem. </title> <journal> Discrete Comput. Geom., </journal> <volume> 4 </volume> <pages> 101-115, </pages> <year> 1989. </year>
Reference-contexts: In fact, a kd-split is always unbalanced. So if we spend linear time on each split and the splits are very unbalanced, then the running time T (n) would satisfy a recurrence like T (n) = O (n) + T (n 1), leading to a quadratic running time. Vaidya <ref> [25] </ref> and Callahan and Kosaraju [7] describe techniques for building an octree-like structure, where this problem is solved. Both techniques are directly applicable in our situation and lead to a contruction time of O (n log n). The second stage. <p> We can maintain the objects intersecting a cell during the recursive calls, but this will take too much time for unbalanced splits. To get around this problem we could try to use a technique similar to the technique of Vaidya <ref> [25] </ref> or Callahan and Kosaraju [7], like in the first stage, but there are some difficulties with the approach when we deal with object fragments.
Reference: [26] <author> A. F. van der Stappen. </author> <title> Motion Planning amidst Fat Obstacles. </title> <type> Ph.D. dissertation, </type> <institution> Dept. Comput. Sci., Utrecht Univ., </institution> <address> Utrecht, Netherlands, </address> <year> 1994. </year>
Reference-contexts: Fat objects are objects that do not have long and skinny 2 parts; a formal definition is given in Section 2.3. Recently, fat objects have attracted a lot of attention in computational geometry <ref> [1, 9, 28, 13, 15, 26, 27] </ref>. De Berg et al. proved that scenes of fat objects always admit a BSP of linear size. Their algorithm for constructing a BSP runs in O (n log n log log n) time, where n is the number of objects. <p> For example, a linear size BSP exists for any uncluttered scene consisting of convex curved objects. Fat objects. We now prove that fatness implies unclutteredness. Intuitively, an object is called fat if it does not contain any long and skinny parts. Van der Stappen <ref> [26] </ref> gives an extensive treatment of fatness in the context of motion planning. Fatness can be defined formally in various ways, which are basically all equivalent. We follow the Van der Stappen's definition. Definition 2.6 Let 0 6 ff 6 1 be a constant. <p> Van der Stappen <ref> [26] </ref> proves that any set of disjoint fat objects has low density, which is defined as follows. Let () denote the radius of the hypersphere , and let mes (o) denote the minimal enclosing hypersphere of the object o. Definition 2.7 Let &gt; 0 be a constant. <p> Because S has -low-density, this means that C 0 is intersected by at most objects, which proves that C is intersected by at most b p dc d objects. fl Because of the result of Van der Stappen <ref> [26] </ref> that a scene consisting of disjoint fat objects has low density, this lemma implies that such a scene is uncluttered. (Formulated more precisely: Let ff be a fixed positive constant, and consider the family of all sets of ff-fat objects.
Reference: [27] <author> A. F. van der Stappen and M. H. Overmars. </author> <title> Motion planning amidst fat obstacles. </title> <booktitle> In Proc. 10th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 31-40, </pages> <year> 1994. </year>
Reference-contexts: Fat objects are objects that do not have long and skinny 2 parts; a formal definition is given in Section 2.3. Recently, fat objects have attracted a lot of attention in computational geometry <ref> [1, 9, 28, 13, 15, 26, 27] </ref>. De Berg et al. proved that scenes of fat objects always admit a BSP of linear size. Their algorithm for constructing a BSP runs in O (n log n log log n) time, where n is the number of objects.
Reference: [28] <author> Marc van Kreveld. </author> <title> On fat partitioning, fat covering, and the union size of polygons. </title> <booktitle> In Proc. 3rd Workshop Algorithms Data Struct., volume 709 of Lecture Notes Comput. Sci., </booktitle> <pages> pages 452-463. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <month> 14 </month>
Reference-contexts: Fat objects are objects that do not have long and skinny 2 parts; a formal definition is given in Section 2.3. Recently, fat objects have attracted a lot of attention in computational geometry <ref> [1, 9, 28, 13, 15, 26, 27] </ref>. De Berg et al. proved that scenes of fat objects always admit a BSP of linear size. Their algorithm for constructing a BSP runs in O (n log n log log n) time, where n is the number of objects.
Reference: [29] <author> A.F. vander Stappen, M.H. Overmars, M. de Berg, and J. Vleugels. </author> <title> Motion planning in environments with low obstacle density. </title> <type> Technical Report UU-CS-1997-19, </type> <institution> Utrecht University, </institution> <year> 1997. </year>
Reference-contexts: If S is a low-density scene and the query range is small, then the number of point locations is O (1) and the number of objects reported per query is O (1). Van der Stappen et al. <ref> [29] </ref> have shown that if S has low density, then S fl has low density as well.
Reference: [30] <author> J. Vleugels. </author> <title> On Fatness and Fitness: Realistic Input Models for Geometric Algorithms. </title> <type> Ph.D. dissertation, </type> <institution> Dept. Comput. Sci., Utrecht Univ., </institution> <address> Utrecht, Netherlands, </address> <year> 1997. </year> <month> 15 </month>
Reference-contexts: Although the method works in arbitrary dimensions we shall mostly use three-dimensional terminology from now on. 1 In a preliminary version of this paper [4] and in Vleugels's thesis <ref> [30] </ref> the term "bounding-box fitness" was used to express this condition. 3 2.1 The Partitioning Strategy Before we start we need a few definitions. The bounding box of an object o is the smallest axis-aligned box that contains the object.
References-found: 30

