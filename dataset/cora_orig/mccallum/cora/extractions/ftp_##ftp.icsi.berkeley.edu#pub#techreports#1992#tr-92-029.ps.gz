URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1992/tr-92-029.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1992.html
Root-URL: http://www.icsi.berkeley.edu
Email: guenther@faw9370.faw.uni-ulm.de  
Title: Efficient Computation of Spatial Joins  
Author: Oliver Gunther 
Note: Parts of this work have been carried out while the author was visiting the International  
Address: Postfach 2060, 7900 Ulm, Germany  
Affiliation: FAW Ulm,  Computer Science Institute and the University of California at Berkeley.  
Abstract: Spatial joins are join operations that involve spatial data types and operators. Due to some basic properties of spatial data, many conventional join processing strategies suffer serious performance penalties or are not applicable at all in this case. In this paper we explore which of the join strategies known from conventional databases can be applied to spatial joins as well, and how some of these techniques can be modified to be more efficient in the context of spatial data. Furthermore, we describe a class of tree structures, called generalization trees, that can be applied efficiently to compute spatial joins in a hierarchical manner. Finally, we model the performance of the most promising strategies analytically and conduct a comparative study. 
Abstract-found: 1
Intro-found: 1
Reference: [Gutt84] <author> A. Guttman, R-Trees: </author> <title> A dynamic index structure for spatial searching, </title> <booktitle> in Proc. ACM SIGMOD Conference on Management of Data, </booktitle> <year> 1984. </year>
Reference-contexts: This type of query can be viewed as a degenerate spatial join: it is really just a spatial selection, and spatial access methods can be used efficiently to answer it. One could, for example, define a search range corresponding to the Northwest of Lake Tahoe and use R-trees <ref> [Gutt84] </ref> to compute the resulting search query. In query (2), however, this approach would not be feasible. This query is a general spatial join query, where two potentially large sets of database objects are related to each other. <p> The class investigated is called generalization trees, and it includes common spatial access methods such as the R-tree <ref> [Gutt84] </ref> as well as application-specific hierarchies that are typical for cartographic applications. 3 Generalization Trees 3.1 Description A generalization tree is a tree structure where each node corresponds to a spatial object. Except for the root object, each object is completely contained in the object corresponding to its parent node. <p> Finally, the objects at any one height do not have to cover the total space, i.e., so-called dead space is allowed. This very general definition includes several common spatial access methods, such as Guttman's R-trees <ref> [Gutt84] </ref>, a structure that is based on a hierarchy of nested rectangles (Figure 2). In this case, the spatial objects corresponding to interior nodes are usually just technical entities that are of no interest to the user.
Reference: [Niev84] <author> J. Nievergelt, H. Hinterberger and K. C. Sevcik, </author> <title> The grid file: An adaptable, symmetric multikey file structure, </title> <journal> ACM Trans. on Database Systems, </journal> <volume> Vol. 9, No. 1, </volume> <year> 1984. </year>
Reference-contexts: Another promising strategy is the index-supported join, based on the availability of spatial indices on one or more of the relations involved. Rotem [Rote91] has demonstrated the potential of this approach for the case of the grid file <ref> [Niev84] </ref>, a spatial access method based on address computation. In this paper, we explore the feasibility and efficiency of tree-structured access methods with regard to spatial joins.
Reference: [Oren86] <author> J. Orenstein, </author> <title> Spatial query processing in an object-oriented database system, </title> <booktitle> in Proc. ACM SIGMOD Conference on Management of Data, </booktitle> <year> 1986. </year>
Reference-contexts: For example, let us consider a common way of spatial sorting, the so-called Peano curves (also called z-ordering) <ref> [Oren86] </ref>. A two-dimensional example is given in Figure 1, where the space is divided into quadratic cells by means of a grid, and objects occupy one grid cell each. <p> Similar examples can be constructed for any other spatial ordering. One notable exception from this rule is the -operator overlaps, for which a sort-merge strategy can be used rather efficiently. One possible implementation based on z-ordering has been described in detail by Orenstein <ref> [Oren86] </ref>. Note that any overlap is likely to be reported more than once. In the z-ordering implementation, for example, any overlap between two objects is reported once for each grid cell that the objects have in common.
Reference: [Rote91] <author> D. Rotem, </author> <title> Spatial join indices, </title> <booktitle> in Proc. Seventh International Conference on Data Engineering, </booktitle> <year> 1991. </year>
Reference-contexts: Nevertheless, as we will see in section 4, join indices remain a reasonably attractive option for the processing of spatial joins. Another promising strategy is the index-supported join, based on the availability of spatial indices on one or more of the relations involved. Rotem <ref> [Rote91] </ref> has demonstrated the potential of this approach for the case of the grid file [Niev84], a spatial access method based on address computation. In this paper, we explore the feasibility and efficiency of tree-structured access methods with regard to spatial joins.
Reference: [Sche90] <author> H.-J. Schek, H.-B. Paul, M. H. Scholl and G. Weikum, </author> <title> The DASDBS project: objectives, experiences, and future prospects, </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> Vol. 2, No. 1, </volume> <year> 1990. </year>
Reference-contexts: In this paper we explore which of the traditional join strategies can be applied to spatial 2 joins as well. For simplicity, we assume a relational data model that is extended by spatial data types and operators. Prototypical systems with these features include POSTGRES [Ston86, Ston90] or DASDBS <ref> [Sche90] </ref>. Our results, however, are not specific for the relational data model and can be applied to object-oriented systems in a straightforward manner. In section 2 we give a more concise definition of spatial joins and discuss how traditional join processing strategies can be applied in that context.
Reference: [Ston86] <author> M. Stonebraker and L. Rowe, </author> <title> The design of POSTGRES, </title> <booktitle> in Proc. ACM SIG-MOD Conference on Management of Data, </booktitle> <year> 1986. </year>
Reference-contexts: In this paper we explore which of the traditional join strategies can be applied to spatial 2 joins as well. For simplicity, we assume a relational data model that is extended by spatial data types and operators. Prototypical systems with these features include POSTGRES <ref> [Ston86, Ston90] </ref> or DASDBS [Sche90]. Our results, however, are not specific for the relational data model and can be applied to object-oriented systems in a straightforward manner.
Reference: [Ston90] <author> M. Stonebraker, L. Rowe and M. Hirohama, </author> <title> The implementation of POST-GRES, </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> Vol. 2, No. 1, </volume> <year> 1990. </year>
Reference-contexts: In this paper we explore which of the traditional join strategies can be applied to spatial 2 joins as well. For simplicity, we assume a relational data model that is extended by spatial data types and operators. Prototypical systems with these features include POSTGRES <ref> [Ston86, Ston90] </ref> or DASDBS [Sche90]. Our results, however, are not specific for the relational data model and can be applied to object-oriented systems in a straightforward manner.
Reference: [Ullm90] <author> J. Ullman, </author> <title> Principles of database and knowledge base systems: </title> <publisher> Volume I , Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1988. </year>
Reference-contexts: We give algorithms for both the spatial selection and the general spatial join problem. In section 4 we model the performance of the most promising strategies analytically and conduct a comparative study. Section 5 summarizes our results. 2 Joins and Their Computation 2.1 Relational Join Operations Ullman <ref> [Ullm90] </ref> defines the join of two relations R and S on columns i and j, denoted by R 1 S, as those tuples in the cross product R fi S where the i-th column of R stands in relation to the j-th column of S.
Reference: [Vald87] <author> P. Valduriez, </author> <title> Join indices, </title> <journal> ACM Trans. on Database Systems, </journal> <volume> Vol. 12, No. 2, </volume> <year> 1987. </year>
Reference-contexts: This property of join queries has been utilized in traditional relational databases to speed up join processing, most notably by so-called join indices <ref> [Vald87] </ref>. In this paper we explore which of the traditional join strategies can be applied to spatial 2 joins as well. For simplicity, we assume a relational data model that is extended by spatial data types and operators. Prototypical systems with these features include POSTGRES [Ston86, Ston90] or DASDBS [Sche90]. <p> Finally, if the database does not encounter too many updates, it is usually worthwhile to precompute the result of frequent joins altogether and store it in a so-called join index <ref> [Vald87] </ref>. A join index is nothing but a two-column relation that stores the tuple IDs of matching tuples. Each join then corresponds to a simple look-up in the join index relation followed by a retrieval of the tuples involved from the disk. <p> Join indices can also be used although they lose some efficiency as well when applied to spatial data. First, updates become even more expensive because the computations involved are more complicated. Second, the efficient implementation of join indices, as described by Valduriez <ref> [Vald87] </ref>, relies on an ordering along the join attributes, which can not be maintained in the spatial case. Nevertheless, as we will see in section 4, join indices remain a reasonably attractive option for the processing of spatial joins. <p> add an entry (a 00 ; b 00 ) to QualP airs [j + 1]. 11 4 Performance Comparison 4.1 Modeling Assumptions In this section we define cost formulas for the following three strategies to compute spatial joins: I Nested Loop II Generalization Trees III Join Indices, as described in <ref> [Vald87] </ref> In order to model the performance of these different strategies we make a few simplifying assumptions. S1. All generalization trees are balanced k-ary trees of height n. S2. Each generalization tree node corresponds to an object that is relevant to the user. S3. <p> This leads to a total computation cost of N 2 C fi . To minimize I/O requirements, we use a simplified version of a main memory utilization technique described by Valduriez <ref> [Vald87] </ref>. Here we first fill most of main memory (say, M 10 pages) with the contents of one relation (say R), then scan the other relation (say S) for matching tuples. <p> For the computation of a general spatial join, on the other hand, the results are mixed, depending on join selectivity. For a low join selectivity, join indices usually provide the best join performance. This result is consistent with the observation of Valduriez 25 <ref> [Vald87] </ref> that join indices are most efficient for very selective joins. For higher selectivities, generalization trees are usually the better option. The differences between the clustered and unclustered case have been negligible in most of our examples. <p> More research is required to find the exact crossover points where join indices become more efficient than generalization trees and vice versa. More detailed cost formulas and more comparative studies are required for this purpose; in particular, we intend to apply the analysis in <ref> [Vald87] </ref> to our setting. Furthermore, we want to explore the concept of so-called local join indices between objects that are indexed by the same generalization tree and have some ancestor in common.
Reference: [Yao77] <author> B. S. Yao, </author> <title> Approximating block accesses in database organizations, </title> <journal> Comm. ACM , Vol. </journal> <volume> 20, No. 4, </volume> <year> 1977. </year> <month> 27 </month>
Reference-contexts: In the first case, there is no clustering at all (strategy IIa) and the participating nodes are randomly distributed in the file containing the relation. One can then approximate the number of I/Os required at each tree height by the so-called Yao number <ref> [Yao77] </ref>. Here Y (x; y; z) denotes the expected number of I/Os for accessing x records randomly distributed in a file of z records stored on y disk pages.
References-found: 10

