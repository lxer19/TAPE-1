URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR469.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Email: chaynes@indiana.edu  
Title: Compiling: A High-level Introduction Using Scheme*  
Author: Christopher T. Haynes 
Address: Bloomington, IN 47405  
Affiliation: Computer Science Department Indiana University  
Abstract: Traditional compiler courses use formal methods for parsing, but treat the more important semantic aspects informally. We present a one semester course in which compiler development is reduced to a number of transformation steps, each of which is formally specified, easily tested, and clearly motivated by semantic considerations. Furthermore, the source language is substantial (essentially the host language of the compiler) and the target is a popular RISC architecture. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> AIKEN, A. </author> <title> Cool: a portable project for teaching compiler construction. </title> <journal> SIGPLAN Notices 31, </journal> <month> 7 (July </month> <year> 1996), </year> <pages> 19-24. </pages>
Reference-contexts: time and results of general utility have been elusive.) Furthermore, the complexity of code generation is such that if a compiler is to be completed in one semester, either the source or target language must be simplified to such an extent that the compiler no longer represents a practical tool <ref> [1] </ref>. In this paper we present an alternative approach, inspired by recent research. It rests on two key elements. First, the host language is Scheme [2].
Reference: [2] <editor> CLINGER, W., AND (EDITORS), J. R. </editor> <title> Revised 4 report on the algorithmic language Scheme. Lisp Pointers 5, </title> <booktitle> 3 (July-September 1991), </booktitle> <pages> 1-55. </pages>
Reference-contexts: In this paper we present an alternative approach, inspired by recent research. It rests on two key elements. First, the host language is Scheme <ref> [2] </ref>. A very-high level symbol-manipulation language such as Scheme provides a critical advantage that allows a compiler with both source and target languages that are realistic to be implemented in one semester. (It also happens that our source language is a substantial subset of Scheme, but this is not critical. <p> The other differences from full R4RS Scheme syntax are: * There are no top-level definitions: hence interactive program development is not supported. * Only integer numbers are supported: integers suffice for programs such as compilers. 2 VLISP is a dialect of Scheme. 3 R4RS refers to the unofficial Scheme standard <ref> [2] </ref>. Students benefit from exposure to the entire specification of a practical language, which in this case is only 46 pages long and freely available.
Reference: [3] <author> CLINGER, W. D., AND HANSEN, L. T. </author> <title> Lambda, the ultimate label, or a simple optimizing compiler for scheme. </title> <booktitle> In Proceedings of the 1994 ACM Conference on LISP and Functional Programming (1994), </booktitle> <pages> pp. 128-139. </pages>
Reference-contexts: These developments have been tested both in class and in a summer workshop attended by college teachers, who were uniformly enthusiastic about this approach. 1 The use of executable intermediate languages was inspired by Clinger's TwoBit Scheme compiler <ref> [3] </ref>. The destination-driven code generation technique used in the final step is that of Dybvig, Hieb, and Butler [4], who use it in the Chez Scheme compiler. In general, the techniques employed in this course are representative of those used in industrial-quality compilers.
Reference: [4] <author> DYBVIG, R. K., HIEB, R., AND BUTLER, T. </author> <title> Destination-driven code generation. </title> <type> Tech. Rep. 302, </type> <institution> Indiana University, </institution> <month> February </month> <year> 1990. </year>
Reference-contexts: The destination-driven code generation technique used in the final step is that of Dybvig, Hieb, and Butler <ref> [4] </ref>, who use it in the Chez Scheme compiler. In general, the techniques employed in this course are representative of those used in industrial-quality compilers. The next section reviews our general approach and considers the benefits of formal methods in this context. <p> It certainly requires the largest volume of code for its solution, but thanks to the previous transformations, this step is conceptually straightforward and clearly connected with the semantics of the source language. Having tried several approaches with students, we feel that the little-known destination-driven technique <ref> [4] </ref> is the most satisfactory. The code generation procedure is passed both control and data destinations, as well as an expression in code-generation form.
Reference: [5] <author> GUTTMAN, J. D., AND WAND, M., Eds. VLISP: </author> <title> A Verified Implementation of Scheme. </title> <publisher> Kluwer, </publisher> <address> Boston, </address> <year> 1995. </year> <note> Originally published as a special double issue of the journal Lisp and Symbolic Computation (Volume 8, Issue 1/2). </note>
Reference-contexts: This is a major area of research, well beyond the scope of this course. To the author's knowledge, only one practical compiler has been proved correct in this (or any other) way: that of the VLISP 2 project <ref> [5] </ref>. Nonetheless, this course is believed to make much more use of practical formal techniques than other approaches to teaching compilation.
Reference: [6] <author> HILSDALE, E., ASHLEY, J. M., DYBVIG, R. K., AND FRIEDMAN, D. P. </author> <title> Compiler construction using scheme. </title> <booktitle> In Functional programming languages in education (FPLE), LNCS 1022 (Nijmegen, The Nether-lands, </booktitle> <month> Dec </month> <year> 1995), </year> <editor> P. H. Hartel and M. J. Plasmeijer, Eds., </editor> <publisher> Springer-Verlag, Heidelberg, </publisher> <pages> pp. 251-268. </pages>
Reference-contexts: The general approach to teaching compilers outlined here builds upon more than a decade of course development, primarily by R. Kent Dybvig <ref> [6] </ref>. This paper emphasizes a number of recent developments not previously reported, including the pedagogic use of executable intermediate languages, a single collection pass, and destination-driven code generation. <p> Previous references to these variables are replaced expressions that dereference the new cells, and variable assignment expressions are replaced by reference assignment expressions. This is necessitated by the display representation of closures in the run-time model. The general outlines of the run-time model (see <ref> [6] </ref>) are presented prior to this point in the course to motivate this transformation. Immediate-literal Form All non-immediate literals are eliminated in this transformation to immediate-literal form (Figure 5). <p> The most important optimization is for the code generator to recognize calls in which the operator is a lambda expression. It is then possible to avoid closure creation and call, as when let expressions are in the core <ref> [6] </ref>. For a fully-functional run-time environment capable of, say, running the compiler itself, it is necessary to implement a garbage collector and the procedures read and write.
Reference: [7] <institution> URL withheld for anonymity, </institution> <note> to appear in final paper. </note>
Reference-contexts: The reader is assumed to be familiar with traditional compilation technique. Some fl This research supported by NSF grant CDA-9312614. 1 This brief paper gives a general impression of our approach, but must necessarily omit many details that are documented in the workshop web structure <ref> [7] </ref>. familiarity with Scheme would be helpful, but not necessary. Formal Methods in Compilation The core of the course is a cumulative series of assignments. This breaks the work into moderate-sized chunks, while maintaining the experience of completing a large project.
References-found: 7

