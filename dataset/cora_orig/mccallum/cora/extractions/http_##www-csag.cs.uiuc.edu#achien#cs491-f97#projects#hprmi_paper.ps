URL: http://www-csag.cs.uiuc.edu/achien/cs491-f97/projects/hprmi_paper.ps
Refering-URL: http://www-csag.cs.uiuc.edu/achien/cs491-f97/projects/index.html
Root-URL: http://www.cs.uiuc.edu
Email: flrivera,l-zhang,geta,krishnamg@cs.uiuc.edu  
Title: HP-RMI: High Performance Java RMI over FM  
Author: Luis Rivera Lynn Zhang Geetanjali Sampemane Sudha Krishnamurthy 
Abstract: Java Remote Method Invocation (RMI)[7] is a convenient mechanism for making remote method calls in distributed object systems. However, from our experiments with Java RMI, we found that the available TCP/IP implementation is not particularly fast. It is our contention that marshalling and the transport mechanism are the main sources of overhead. We focus here on reducing network delays. Our approach is to trace the network path of an RMI call, and provide a more efficient transport layer as an alternative to (the default) TCP. We selected Illinois Fast Messages (FM)[6] as the alternative transport layer because of its low overhead and ability to deliver a large part of the underlying network capacity to the application. We implemented an FM sockets interface in Java, using the Java Native Interface (JNI)[5] and attempted to provide the application a choice between TCP/IP or FM as the transport layer. To measure the performance speedup, we designed a testbed that repeatedly runs a set of RMI calls on a network of 2 Pentium II machines running Windows NT connected by Ethernet and Myrinet[9]. The RMI calls sent and received data over the network and we measured the time taken on the standard TCP/IP and our FM implementation. We observed a significant improvement in performance (upto 60x for an RMI call sending 1500 bytes). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> The component object model specification. </institution> <note> Available from http://www.microsoft.com. </note>
Reference-contexts: As applications became object-based, RPC systems had to follow suit to remain useful. Distributed objects were thus the natural successor to conventional RPC systems, and many such systems were developed, e.g. OMG's CORBA [4], Microsoft's COM-based <ref> [1] </ref> technologies, Java RMI and so on. 4 3.1 Java RMI Java RMI (Remote Method Invocation) is an API standard for building distributed Java systems [10]. It allows applications to pass objects between JVMs and invoke remote methods on them.
Reference: [2] <author> A.D. Birrell and B.J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> In ACM Transactions in Computer Systems, </journal> <volume> volume 2, </volume> <month> Feb </month> <year> 1984. </year>
Reference-contexts: client-server program using RMI and Myrinet FM it works with a few glitches. * Took measurements with the integrated FM-RMI system as well as the FM sockets without RMI. * Wrote up this report. * Prepare for presentation. 3 Technical Background Traditional distributed computing environments generally used remote procedure calls <ref> [2, 8] </ref> for communication across a network. When optimizing those, the designers tried to minimize network access, since that was the slowest component of the system. In modern distributed systems, the network is no longer the bottleneck.
Reference: [3] <author> K. Connelly and A. Chien. </author> <title> Fm-qos : Real-time communication using self-synchronizing schedules. </title> <booktitle> In Proceedings of Supercomputing, </booktitle> <year> 1997. </year>
Reference-contexts: To achieve that goal, FM's few, simple primitives provide a number of important guarantees, saving higher-level messaging layers the burden and performance penalty of having to implement them themselves <ref> [3] </ref>. * reliable delivery * in-order delivery * decoupling of communication and computation FM's interface is carefully designed to enable efficient composition into higher level layers. This composition eliminates copies and buffer pool overruns, which often reduce performance significantly.
Reference: [4] <institution> The corba 2.0 specification. </institution> <note> Available from http://www.omg.org. </note>
Reference-contexts: As applications became object-based, RPC systems had to follow suit to remain useful. Distributed objects were thus the natural successor to conventional RPC systems, and many such systems were developed, e.g. OMG's CORBA <ref> [4] </ref>, Microsoft's COM-based [1] technologies, Java RMI and so on. 4 3.1 Java RMI Java RMI (Remote Method Invocation) is an API standard for building distributed Java systems [10]. It allows applications to pass objects between JVMs and invoke remote methods on them.
Reference: [5] <institution> JNI Specification. </institution> <note> Available from http://www.javasoft.com/. </note>
Reference-contexts: The Socket class implements a reliable, stream based connection while the DatagramSocket class implements an unreliable datagram protocol. Both of these classes provide a high level abstraction to the actual socket implementation which is done in C. These wrapper classes use the Java Native Interface <ref> [5] </ref> to interact with their corresponding C implementation. JDK1.1.4 provides implementations of these two classes and allows custom sockets to be added to its library. This enabled us to implement FM sockets using the FM library and add it to the java.net package.
Reference: [6] <author> S. Pakin et al. HPVM 1.0 User Documentation, </author> <month> August </month> <year> 1997. </year>
Reference: [7] <institution> Java RMI Specification. </institution> <note> Available from http://www.javasoft.com/products/jdk/1.1/docs/guide/rmi/spec/rmiTOC.doc.html. </note>
Reference: [8] <author> M.D. Schroeder and M. Burrows. </author> <title> Performance of firefly rpc. </title> <booktitle> In ACM Symposium on Operating System Principles, </booktitle> <month> December </month> <year> 1989. </year>
Reference-contexts: client-server program using RMI and Myrinet FM it works with a few glitches. * Took measurements with the integrated FM-RMI system as well as the FM sockets without RMI. * Wrote up this report. * Prepare for presentation. 3 Technical Background Traditional distributed computing environments generally used remote procedure calls <ref> [2, 8] </ref> for communication across a network. When optimizing those, the designers tried to minimize network access, since that was the slowest component of the system. In modern distributed systems, the network is no longer the bottleneck.
Reference: [9] <author> Charles Seitz. </author> <title> Myrinet a gigabit-per-second local-area network. </title> <booktitle> In Proceedings of the IEEE Symposium on Hot Interconnects, </booktitle> <year> 1994. </year>
Reference-contexts: This composition eliminates copies and buffer pool overruns, which often reduce performance significantly. Receiver flow control enables messaging layers to pace the rate at which data is removed from the network layer. 8 Myricom's Myrinet <ref> [9] </ref> is a high-speed local area network with full duplex 1.28Gbps links. Derived from multicomputer routers, current Myrinet offerings employ wormhole routing and 8x8 crossbar switch. The network interface has a programmable 33MHz CPU (the LANai) with 256KB of SRAM that attaches to the I/O bus of the host processor.
Reference: [10] <author> A. Wollrath, R. Riggs, and J. Waldo. </author> <title> A distributed object model for the java system. </title> <booktitle> In COOTS, </booktitle> <month> June </month> <year> 1996. </year> <month> 20 </month>
Reference-contexts: Distributed objects were thus the natural successor to conventional RPC systems, and many such systems were developed, e.g. OMG's CORBA [4], Microsoft's COM-based [1] technologies, Java RMI and so on. 4 3.1 Java RMI Java RMI (Remote Method Invocation) is an API standard for building distributed Java systems <ref> [10] </ref>. It allows applications to pass objects between JVMs and invoke remote methods on them. By using RMI in a pure Java environment, one gains the benefits of distributed garbage collection and full Java semantics.
References-found: 10

