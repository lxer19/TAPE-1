URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1996/TR44.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Email: e-mail: neelam@cis.ohio-state.edu  
Title: Classes as Assertions  
Author: Neelam Soundarajan 
Address: Columbus, OH 43210  
Affiliation: Computer and Information Science The Ohio State University  
Abstract: How do we formally specify the relation between a base class and a derived class? This question has two parts, a syntactic one, and a semantic one. The syntactic part is of course the easier of the two and the answer to that part is the standard contra/co- variance requirement on the arguments and result of any base class method redefined in the derived class. Our concern in the current paper is with the semantic part of the question, i.e., how do we specify the behavioral relation between the base class and the derived class? We show that the standard answer -which is the semantic counterpart of contra/co-variance- is too rigid, and does not allow some natural and common forms of inheritance. We then propose a more flexible way to specify the relation, and show how different types of behavioral relations between base classes and derived classes may be specified using our notation. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> P. </author> <title> America, A parallel OO language with inheritance and subtyping, </title> <journal> SIG PLAN, </journal> <volume> vol. 25, </volume> <pages> pp. 161-168. </pages>
Reference-contexts: This is essentially the approach of Liskov and Wing [8] as well as that of America <ref> [1] </ref>. <p> The goal of our work is to develop such a method. The rest of the paper is organized as follows: In the next section we recall the `is-a' concept that is usually used to characterize inheritance and discuss the approaches of <ref> [8, 1] </ref> which are essentially formalizations of the is-a notion. We then argue that the is-a notion if interpreted strictly, as in [8, 1], is too strong a requirement. <p> of the paper is organized as follows: In the next section we recall the `is-a' concept that is usually used to characterize inheritance and discuss the approaches of <ref> [8, 1] </ref> which are essentially formalizations of the is-a notion. We then argue that the is-a notion if interpreted strictly, as in [8, 1], is too strong a requirement. We proceed to introduce a weaker concept which we call `is-like-a', to allow for a wider variety of relations between base class and derived class behaviors, that inheritance gives rise to in practice. <p> This will, of course, prevent us from considering the stack as a derived class of queue since the value returned by the get methods of the two classes are quite different from each other, so the requirement on the post-conditions will not be satisfied. The approach America <ref> [1] </ref> develops is similar but not as general. This seems like a reasonable approach; after all, who would want to consider a queue as a stack or vice-versa? The problem is that in other examples, the Liskov-Wing-America requirement turns out to forbid what seem to be reasonable inheritance relations. <p> Suppose, for instance, we have a function called distance-to-origin. Clearly this method would have to be redefined in the 3-d-point class, but the redefinition would not be permitted by the restrictions of <ref> [8, 1] </ref> since the results returned by the two distance-to-origin functions will be quite different in general. If we wanted to remain true to the restrictions of [8, 1], we would probably have to define a new function called, say, 3-d-distance-to-origin in the 3-d-point class, and leave the distance-to-origin function to <p> Clearly this method would have to be redefined in the 3-d-point class, but the redefinition would not be permitted by the restrictions of <ref> [8, 1] </ref> since the results returned by the two distance-to-origin functions will be quite different in general. If we wanted to remain true to the restrictions of [8, 1], we would probably have to define a new function called, say, 3-d-distance-to-origin in the 3-d-point class, and leave the distance-to-origin function to return the same value as it does in the base 2-d-point class. We believe this is undesirable. <p> The right solution, we believe, is for the notation to allow fairly general relations, and trust the good judgment of the system designer not to misuse the flexibility. The alternative of forbidding all but the simplest relations, which is essentially the approach of <ref> [8, 1] </ref> will reduce the usefulness of inheritance. As Liskov and Wing point out, with their restrictions, the only occasions we will able be to use inheritance would be one of the following: 1. <p> This is not the case with the approach of <ref> [8, 1] </ref>, and that is, of course, the main advantage of the restrictions that they impose; if the method redefinition in the derived class is required to be consistent with its behavior in the base class, there is no need to redo any correctness argument that only assumes the behavior specified <p> At the same time, its power can easily misused to develop systems that are difficult to understand or maintain. One solution, and this is and this is what [8] and <ref> [1] </ref> propose, is to impose severe restrictions on this power. The disadvantage of this approach is that these restrictions forbid many uses of inheritance that most OO designers would consider reasonable.
Reference: 2. <author> R. Ben-Natan, </author> <title> CORBA, </title> <publisher> McGraw-Hill, </publisher> <year> 1995. </year>
Reference-contexts: about it; or, that for every object o1 of type B there is an object o2 of type D such that the behavior of every program (defined in terms of B) is unchanged when o2 is substituted for o1. (These are usually called respectively Liskov's weak and strong substitution principles <ref> [2] </ref>.) Consider an example. Suppose we have a stack of integers and a queue of integers. Each provides a get operation and a put operation. So if we only required the weak substitution principle above, a stack could be considered a derived type of queue or vice-versa.
Reference: 3. <author> L. Cardelli, P. Wegner, </author> <title> On understanding, types, data abstraction, </title> <journal> and poly morphism, Computing Surveys, </journal> <volume> Vol. 17, </volume> <pages> pp. 471-523, </pages> <year> 1985. </year>
Reference-contexts: The standard contra/covariance requirement <ref> [3] </ref> to avoid such mismatches is that the types of the arguments accepted by m1 as defined in D must be supertypes of the corresponding argument types of m1 as defined in B, and its result type must be a subtype of the result type produced by m1 as defined in
Reference: 4. <author> G. Castagna, </author> <title> Covariance and contravariance, </title> <journal> ACM TOPLAS, </journal> <volume> 17, </volume> <pages> 431-447, </pages> <year> 1995. </year>
Reference: 5. <author> W. Hursch, </author> <title> Should superclasses be abstract, </title> <booktitle> Proceedings of ECOOP '94. </booktitle>
Reference: 6. <author> J. Lampiang, M. Abadi, </author> <title> Methods as assertions, </title> <booktitle> ECOOP '94, </booktitle> <pages> pp. 60-80. </pages>
Reference-contexts: We intend to try both of these approaches in developing 4 Perhaps the title of this paper should have been classes in assertions, rather than classes as assertions. We chose our title following that of <ref> [6] </ref> which deals with a somewhat analogous, although mainly syntactic, problem. 6 useful notations for specifying (the class dependent) behaviors of the methods in question, and using these specifications to validate correctness properties of code that use these methods. 4 Conclusion Inheritance is perhaps single most important tool of the OO
Reference: 7. <author> B. Liskov, J. Wing, </author> <title> A behavioral notion of subtyping, </title> <journal> ACM TOPLAS, </journal> <volume> vol. 16, </volume> <pages> pp. 1811-1841, </pages> <year> 1994. </year>
Reference: 8. <author> B. Liskov, J. Wing, </author> <title> A new definition of the subtype relation, </title> <booktitle> ECOOP '93, </booktitle> <pages> pp. 118-141. </pages>
Reference-contexts: This is essentially the approach of Liskov and Wing <ref> [8] </ref> as well as that of America [1]. <p> The goal of our work is to develop such a method. The rest of the paper is organized as follows: In the next section we recall the `is-a' concept that is usually used to characterize inheritance and discuss the approaches of <ref> [8, 1] </ref> which are essentially formalizations of the is-a notion. We then argue that the is-a notion if interpreted strictly, as in [8, 1], is too strong a requirement. <p> of the paper is organized as follows: In the next section we recall the `is-a' concept that is usually used to characterize inheritance and discuss the approaches of <ref> [8, 1] </ref> which are essentially formalizations of the is-a notion. We then argue that the is-a notion if interpreted strictly, as in [8, 1], is too strong a requirement. We proceed to introduce a weaker concept which we call `is-like-a', to allow for a wider variety of relations between base class and derived class behaviors, that inheritance gives rise to in practice. <p> But a program that works correctly when we use a stack 3 object will almost certainly not do so if we replaced that object with a queue object. In other words, a stack object is-not-a queue object, nor is a queue object a stack object. Hence, Liskov and Wing <ref> [8] </ref> argue, we must use the strong substitution principle. <p> This seems like a reasonable approach; after all, who would want to consider a queue as a stack or vice-versa? The problem is that in other examples, the Liskov-Wing-America requirement turns out to forbid what seem to be reasonable inheritance relations. Taking another example from <ref> [8] </ref>, consider a class of 2-d-points (points on a plane). Suppose we have another class, 3-d-points. Many system developers would treat the latter class as a derived class of the former since they have similar functionalities. <p> Suppose, for instance, we have a function called distance-to-origin. Clearly this method would have to be redefined in the 3-d-point class, but the redefinition would not be permitted by the restrictions of <ref> [8, 1] </ref> since the results returned by the two distance-to-origin functions will be quite different in general. If we wanted to remain true to the restrictions of [8, 1], we would probably have to define a new function called, say, 3-d-distance-to-origin in the 3-d-point class, and leave the distance-to-origin function to <p> Clearly this method would have to be redefined in the 3-d-point class, but the redefinition would not be permitted by the restrictions of <ref> [8, 1] </ref> since the results returned by the two distance-to-origin functions will be quite different in general. If we wanted to remain true to the restrictions of [8, 1], we would probably have to define a new function called, say, 3-d-distance-to-origin in the 3-d-point class, and leave the distance-to-origin function to return the same value as it does in the base 2-d-point class. We believe this is undesirable. <p> The right solution, we believe, is for the notation to allow fairly general relations, and trust the good judgment of the system designer not to misuse the flexibility. The alternative of forbidding all but the simplest relations, which is essentially the approach of <ref> [8, 1] </ref> will reduce the usefulness of inheritance. As Liskov and Wing point out, with their restrictions, the only occasions we will able be to use inheritance would be one of the following: 1. <p> This is not the case with the approach of <ref> [8, 1] </ref>, and that is, of course, the main advantage of the restrictions that they impose; if the method redefinition in the derived class is required to be consistent with its behavior in the base class, there is no need to redo any correctness argument that only assumes the behavior specified <p> At the same time, its power can easily misused to develop systems that are difficult to understand or maintain. One solution, and this is and this is what <ref> [8] </ref> and [1] propose, is to impose severe restrictions on this power. The disadvantage of this approach is that these restrictions forbid many uses of inheritance that most OO designers would consider reasonable.
Reference: 9. <author> B. Meyer, </author> <title> Object oriented software construction, </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: While their formalism is clean, we believe that the resulting restrictions are too strong, disallowing many natural uses of inheritance. 1 We use `supertype' and `base class' interchangeably; as also `subtype' and `derived class'. 2 Not all authors accept this requirement; see <ref> [9] </ref>, for instance. 2 Indeed, we believe that any universal requirements on the relation between the behaviors of the base class and the derived class are likely to cause problems because different systems and even different designers for the same system tend to use inheritance in different ways and such universal
Reference: 10. <author> N. Soundarajan, </author> <title> Covariance, contravariance, and synchronization con straints, </title> <institution> Ohio State University tech. </institution> <type> report, </type> <year> 1996. </year>
Reference-contexts: Suppose we have a bounded-buffer-n class that implements a traditional bounded-buffer of size n. Suppose we want to use inheritance from this class to define bounded buffers of other sizes. Then, with a strict intepretation of the is-a relation, we will only be able, as we argue in <ref> [10] </ref>, to define buffers larger than n. So if we want to define a smaller buffer, we will have to essentially re-do all the work that has been already done in designing and implementing the bounded-buffer-n class.
Reference: 11. <author> P. Wegner, </author> <title> The object oriented classification paradigm, </title> <editor> in Research direc tions in OOP, ed. Wegner, Shriver, </editor> <publisher> MIT Press, </publisher> <year> 1987. </year> <month> 8 </month>
Reference-contexts: And, perhaps more importantly, when combined with polymorphism and run-time binding, it allows us to treat in a uniform and simple manner objects of different but related types. Indeed, some authors like Wegner <ref> [11] </ref> do not consider as object-oriented, any approach that does not include inheritance. How do we specify the relation between a base class B and a derived class D defined by inheriting from B? There are two parts to this question.
References-found: 11

