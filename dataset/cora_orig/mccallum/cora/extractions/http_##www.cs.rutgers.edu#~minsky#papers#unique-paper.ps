URL: http://www.cs.rutgers.edu/~minsky/papers/unique-paper.ps
Refering-URL: http://www.cs.rutgers.edu/~minsky/pubs.html
Root-URL: http://www.cs.rutgers.edu
Email: e-mail: minsky@cs.rutgers.edu  
Phone: Tel: (908) 445-2085;  
Title: Towards Alias-Free Pointers  
Author: Naftaly H. Minsky 
Keyword: Key Words and Phrases: pointer-induced aliasing, hiding, encapsulation, programming with threads, storage management.  
Note: Work supported by NSF grant No. CCR-9308773.  
Address: New Brusnwick NJ 08903 USA  
Affiliation: Rutgers University,  
Abstract: This paper argues that pointer-induced aliasing can be avoided in many cases by means of a concept of unique pointer. The use of such pointers is expected to fortify the concept of encapsulation, to make systems easier to reason about, to provide better control over the interaction between threads, and to make storage management safer and more efficient. We show that unique pointers can be implemented by means of few minor and virtually costless modifications in conventional OO languages, such as Eiffel or C++; and that they can be used conveniently in a broad range of algorithms and data structures. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> H.G. Baker. </author> <title> Use-once variables and linear objects | storage management, </title> <journal> reflec tion and multi-threading. ACM SIGPLAN Notices, </journal> <month> January </month> <year> 1995. </year>
Reference-contexts: This particular difficulty is even more serious in Baker's proposal discussed next. The second work has been recently reported in a paper 9 by Baker <ref> [1] </ref>. Baker introduces a concept of use-once variable, which point to what he calls linear object. His concept of linear object, which was inspired by Girard's linear logic [3], is equivalent to our u-object. But we find the manner these objects are handled, via use-once variables, problematic.
Reference: 2. <author> L. Cardelli, J. Donahue, L. Glassman, M. Jordan, and G. Nelson. </author> <type> Modula-3 report (revised). Technical Report 52, </type> <institution> Digital System Research Center, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: by the scope rules of the language. 2 But if c is a dynamic object, addressed via a reference variable p c contained in x then, the scope rules are not 2 Actually, even the hiding of such components is rarely, if ever, completely ensured, because of the unsafe features <ref> [2] </ref> that most languages have, such as the ability to use naked C-code in C++, or in procedures of Eiffel. We ignore the effect of such unsafe features in this paper. sufficient to hide it.
Reference: 3. <author> J. Y. Girard. </author> <title> Linear logic. </title> <booktitle> Theoretical Computer Science, </booktitle> <pages> pages 1-102, </pages> <year> 1987. </year>
Reference-contexts: The second work has been recently reported in a paper 9 by Baker [1]. Baker introduces a concept of use-once variable, which point to what he calls linear object. His concept of linear object, which was inspired by Girard's linear logic <ref> [3] </ref>, is equivalent to our u-object. But we find the manner these objects are handled, via use-once variables, problematic. The term "use-once" variables, indicates that every use of such a variable consumes its value.
Reference: 4. <author> Dougles E. Harms and Bruce W. Weide. </author> <title> Copying and swapping: Influences on the design of reusable software components. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 424-434, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: But there are deficiencies in both of these proposals, particularly for object-oriented programming (which, in fairness, was not the context in which these proposal were made.) One of these efforts is by Harms and Weide <ref> [4] </ref>, who may have been the first to challenge the conventional use of copying as the primary mechanism for transferring data in programming.
Reference: 5. <author> W Landi. </author> <title> Undecidebility of static analysis. Lett. Program. </title> <journal> Lang. Syst., </journal> <volume> 1(4), </volume> <month> De-cember </month> <year> 1992. </year>
Reference-contexts: Fig. 1. The Difficulty in Hiding Dynamic Components Moreover, under conventional languages, it is virtually impossible to control the dispersal of pointers for a given object throughout a system, or to figure out the extent of such dispersal <ref> [5] </ref>. This is due to the fact that information is generally transferred from one place in a system to another by copy | the copy of pointers when dealing with dynamic objects.
Reference: 6. <author> B. Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: This is a serious problem because invariant properties are essential for meaningful encapsulation, and for abstract data types. Yet, although this problem with encapsulation is not unknown (see <ref> [6] </ref> page 159, in particular) it is rarely discussed in the literature, and has not been satisfactorily resolved so far. 2.4 A Difficulty with Threads The dispersal of pointers also has an adverse effect on programming with threads [11]. <p> But the swapping paradigm would replace this statement with a swap of values which, in particular, will place the value of v1 into v2, violating the requirement that a variable should not hold instances of its superclasses <ref> [6] </ref>. Another problem with the scheme proposed by Harms and Weide is that it fails to protect u-parameters from being consumed by the procedure they are submitted to. This particular difficulty is even more serious in Baker's proposal discussed next.
Reference: 7. <author> B. Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: And we show that it takes no more than minor, and virtually costless, modifications to a typical imperative programming language to support such objects. For the sake of specificity we couch our discussion in terms of the object-oriented language Eiffel <ref> [7] </ref>.
Reference: 8. <author> N.H. Minsky. </author> <title> On the use of tokens in programming. </title> <type> Technical report, </type> <institution> Rutgers University, LCSR, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: Making the component parts of an object unshareable would facilitate, in particular, the construction of reliable class invariants, and the prevention of race conditions between threads. Another natural application of u-objects is discussed in <ref> [8] </ref>, where we show how such objects can be used to implement tokens | objects that, like the capabilities of operating systems, represent certain authority.
Reference: 9. <author> D.L. Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Communications of the ACM, </journal> <volume> 15(12), </volume> <month> December </month> <year> 1972. </year>
Reference-contexts: We then briefly discuss the difficulties caused by conventional dynamic objects to storage management, to encapsulation, and to programming with threads. 2.1 The Difficulty in Hiding Dynamic Objects Although the concept of hiding in software is well known <ref> [9] </ref> | and is widely considered the bedrock of modularization and of encapsulation | it is a somewhat slippery concept, that may have several definitions reflecting different concerns. The following is one such definition, whose full significance will become clear in due course.
Reference: 10. <author> R. Sethi. </author> <title> Programming Languages, Concepts and Constructions. </title> <publisher> Addison Wesley, </publisher> <year> 1989. </year>

References-found: 10

