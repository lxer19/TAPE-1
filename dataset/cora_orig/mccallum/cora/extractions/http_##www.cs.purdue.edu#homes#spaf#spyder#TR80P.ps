URL: http://www.cs.purdue.edu/homes/spaf/spyder/TR80P.ps
Refering-URL: http://www.cs.purdue.edu/homes/spaf/spyder.html
Root-URL: http://www.cs.purdue.edu
Title: Efficient Debugging with Slicing and Backtracking SERC-TR-80-P  
Author: Hiralal Agrawal Richard A. DeMillo Eugene H. Spafford 
Keyword: program debugging, execution backtracking, reverse program execution, program slic ing, dynamic program slicing  
Address: W. Lafayette, IN 47907-2004  
Affiliation: Software Engineering Research Center Department of Computer Sciences Purdue University  
Abstract: Programmers spend considerable time debugging code. Several tools are available to help them in this task, varying from hexadecimal dumps of program state to window- and mouse-based interactive debuggers, but the task still remains complex and difficult. Most of these conventional debuggers provide breakpoints and traces as their main debugging aids. These features have changed little in the past 15-20 years desp-te the increased complexity of software systems on which debuggers are used. In this paper we present a prototype tool that enables users to follow their natural thought process while debugging. It combines dynamic program slicing and execution backtracking techniques in a novel way. With the help of this powerful combination, program bugs may be localized and removed very quickly. Examples are given to show how our debugger may be used, and how it relates to other research in the area. 
Abstract-found: 1
Intro-found: 1
Reference: [ACS84] <author> James E. Archer, Jr., Richard Conway, and Fred B. Schneider. </author> <title> User recovery and reversal in interactive systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(1) </volume> <pages> 1-19, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: Such problems frequently arise in artificial intelligence applications, for instance. However, because the user must program the RETRACE statements into the code, this approach does not provide an interactive control over backtracking while debugging. Systems like IGOR [FB88] and COPE <ref> [ACS84] </ref> perform periodic checkpointing of memory pages or file blocks modified during program execution. Using these checkpoints program execution can be restarted at arbitrary points.
Reference: [ADS90] <author> Hiralal Agrawal, Richard A. DeMillo, and Eugene H. Spafford. </author> <title> An execution backtracking approach to program debugging. </title> <type> Technical Report SERC-TR-22-P, </type> <institution> Software Engineering Research Center, Purdue University, West Lafayette, </institution> <note> IN, 1990. Revised from the August, 1988 report. 22 </note>
Reference-contexts: Rather, we would have had to backtrack to the beginning of the loop itself and execute forwards to the given statement. This can be implemented in a manner transparent to the user; a more complete explanation is available in <ref> [AS88, ADS90] </ref>. 6 Related Work The concept of static program slicing was first proposed by Weiser [Wei84, Wei82]. He also presented an algorithm to compute static slices based on iterative solution of data-flow equations.
Reference: [AH90] <author> Hiralal Agrawal and Joseph R. Horgan. </author> <title> Dynamic program slicing. </title> <booktitle> In Proceedings of the SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year> <journal> ACM SIGPLAN. SIGPLAN Notices, </journal> <volume> 25(6) </volume> <pages> 246-256, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The first taskgiven a variable and a program location, determining which statements in the program affected the value of that variable at that location when the program is executed for a given testcaseis referred to as Dynamic Program Slicing <ref> [AH90] </ref>. Our debugger can find dynamic slices for us automatically. It can also restore the program state at any desired location by backtracking the program execution without having to reexecute the program from the beginning [AS88]. In this paper we discuss these two functionsslicing and backtrackingof our prototype debugging tool. <p> It is up to the user to judiciously select the slicing criterionstatic, dynamic, or approximate dynamic 7 Actually, the intersection is performed by doing the static slicing analysis only over the nodes in the program dependence graph that are visited during the program execution. See <ref> [AH90] </ref> for details. 10 that best suits his needs. The three alternatives provide a span of space-time-accuracy trade-offs. The selection may also be changed during the debugging session. <p> Thus, it is possible to start with less expensive static analysis and identify a smaller program region that most likely contains the bug, and then use the more expensive dynamic analysis only within that small region. The reader is referred to <ref> [AH90] </ref> for a detailed discussion on these approaches to computing program slices and their relative costs. 11 Reaching Definitions In some situations, looking at the whole slice at once may be overwhelming. In these situations, it may be useful to analyze the inter-statement program dependencies one at a time. <p> The definintion of data-dependence remains the same in both cases. Korel and Laski extended Weiser's static slicing algorithms for the dynamic case [KL88]. Their definition of a dynamic slice is different from ours <ref> [AH90] </ref>.
Reference: [AM86] <author> Evan Adams and Steven S. Muchnick. Dbxtool: </author> <title> a window-based symbolic debugger for Sun work-stations. </title> <journal> Software Practice and Experience, </journal> <volume> 16(7) </volume> <pages> 653-669, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Average programmers may spend considerable amounts (possibly more than 50%) of their program development time debugging. Several tools are available to help them in this task [AS89, MH89], varying from hexadecimal dumps of program state at the time of failure to window- and mouse-based interactive debuggers using bit-mapped displays <ref> [AM86, Car86] </ref>. Most interactive debuggers provide breakpoints and traces as their main debugging aids fl This paper has been submitted to SoftwarePractice & Experience.
Reference: [AS88] <author> Hiralal Agrawal and Eugene H. Spafford. </author> <title> An execution backtracking approach to program debugging. </title> <booktitle> In Proceedings of the Sixth Annual Pacific Northwest Software Quality Conference, </booktitle> <pages> pages 283-299, </pages> <address> Portland, Oregon, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: Our debugger can find dynamic slices for us automatically. It can also restore the program state at any desired location by backtracking the program execution without having to reexecute the program from the beginning <ref> [AS88] </ref>. In this paper we discuss these two functionsslicing and backtrackingof our prototype debugging tool. In the next section we discuss the notion of program slicing. In Section 3 we examine the usefulness of an execution backtracking facility in a debugging tool. <p> This gives the user considerable power at the possible expense of the need for unbounded storage. Bugs that produce infinite loops, for instance, may exhaust the storage available to the debugger. Alternatively, it is possible to use structured backtracking as described in <ref> [AS88] </ref>. This approach provides the user with almost the same capabilities, but allows the storage needed to be bounded at compile time in most cases. <p> Rather, we would have had to backtrack to the beginning of the loop itself and execute forwards to the given statement. This can be implemented in a manner transparent to the user; a more complete explanation is available in <ref> [AS88, ADS90] </ref>. 6 Related Work The concept of static program slicing was first proposed by Weiser [Wei84, Wei82]. He also presented an algorithm to compute static slices based on iterative solution of data-flow equations.
Reference: [AS89] <author> Hiralal Agrawal and Eugene H. Spafford. </author> <title> A bibliography on debugging and backtracking. </title> <journal> ACM Software Engineering Notes, </journal> <volume> 14(2) </volume> <pages> 49-56, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: 1 Introduction The importance of good debugging tools cannot be overemphasized. Average programmers may spend considerable amounts (possibly more than 50%) of their program development time debugging. Several tools are available to help them in this task <ref> [AS89, MH89] </ref>, varying from hexadecimal dumps of program state at the time of failure to window- and mouse-based interactive debuggers using bit-mapped displays [AM86, Car86]. Most interactive debuggers provide breakpoints and traces as their main debugging aids fl This paper has been submitted to SoftwarePractice & Experience.
Reference: [Bal69] <author> R. M. Balzer. </author> <title> Exdams: Extendible debugging and monitoring system. </title> <booktitle> In AFIPS Proceedings, Spring Joint Computer Conference, </booktitle> <volume> volume 34, </volume> <pages> pages 567-580, </pages> <address> Montvale, New Jersey, 1969. </address> <publisher> AFIPS Press. </publisher>
Reference-contexts: The corresponding slice produced by our tool is shown in Figure 4. The concept of reverting program state in a debugging system is not new. EXDAMS, an interactive debugging tool for Fortran developed in the late 1960s, also provided an execution replay facility <ref> [Bal69] </ref>. In that system, first the complete history tape of the program being debugged for a testcase was saved. Then the program was executed through a playback of this tape.
Reference: [BC85] <author> Jean-Francois Bergeretti and Bernard A. Carr e. </author> <title> Information-flow and data-flow analysis of while programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 37-61, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Bergeretti and Carr e have also defined information-flow relations somewhat similar to data- and control dependence relations, that can be used to obtain static program slices (referred to as partial statements by them) <ref> [BC85] </ref>. Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, automatic integration of program versions, etc. (see, e.g., [Wei84, BC85, HPR89]). <p> Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, automatic integration of program versions, etc. (see, e.g., <ref> [Wei84, BC85, HPR89] </ref>). When a program slice is defined with respect to a variable occurrence, it is assumed that control does eventually reach the corresponding program location. The issue of non-termination of program execution is not addressed under this definition.
Reference: [Car86] <author> Thomas A. Cargill. </author> <title> Pi: a case study in object-oriented programming. </title> <booktitle> In OOPSLA'86 Conference Proceedings, </booktitle> <address> Portland, OR, </address> <month> September </month> <year> 1986. </year> <journal> ACM SIGPLAN. SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 350-360, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Average programmers may spend considerable amounts (possibly more than 50%) of their program development time debugging. Several tools are available to help them in this task [AS89, MH89], varying from hexadecimal dumps of program state at the time of failure to window- and mouse-based interactive debuggers using bit-mapped displays <ref> [AM86, Car86] </ref>. Most interactive debuggers provide breakpoints and traces as their main debugging aids fl This paper has been submitted to SoftwarePractice & Experience.
Reference: [Dun86] <author> Kevin J. Dunlap. </author> <title> Debugging with Dbx. In Unix Programmers Manual, </title> <type> Supplementary Documents 1. </type> <institution> 4.3 Berkeley Software Distribution, Computer Science Division, University of Califor-nia, Berkeley, </institution> <address> CA, </address> <month> April </month> <year> 1986. </year>
Reference-contexts: Most interactive debuggers provide breakpoints and traces as their main debugging aids fl This paper has been submitted to SoftwarePractice & Experience. This work was funded by a grant from the Purdue University/University of Florida Software Engineering Research Center (SERC), and by National Science Foundation grant 8910306-CCR. 1 <ref> [Kat79, MB79, Dun86, Wei82] </ref>. Unfortunately, these traditional mechanisms are often inadequate for the task of isolating specific program faults. In this paper we present the results of our preliminary experiment in integrating new approaches to software fault localization with conventional debugging techniques.
Reference: [FB88] <author> Stuart I. Feldman and Channing B. Brown. Igor: </author> <title> a system for program debugging via reversible execution. </title> <booktitle> In Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <address> Madison, WI, </address> <month> May </month> <year> 1988. </year> <journal> ACM SIGPLAN/SIGOPS. SIGPLAN Notices, </journal> <volume> 24(1) </volume> <pages> 112-123, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Such problems frequently arise in artificial intelligence applications, for instance. However, because the user must program the RETRACE statements into the code, this approach does not provide an interactive control over backtracking while debugging. Systems like IGOR <ref> [FB88] </ref> and COPE [ACS84] perform periodic checkpointing of memory pages or file blocks modified during program execution. Using these checkpoints program execution can be restarted at arbitrary points.
Reference: [FOW87] <author> Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. </author> <title> The program dependence graph and its uses in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Although this choice has led to some problems, it has allowed us to rapidly develop a prototype that will work for full ANSI C. We have modified gcc to produce a program dependence graph <ref> [FOW87, OO84, HRB90] </ref> along with the object code of the given program.
Reference: [Gou74] <author> J. D. Gould. </author> <title> An exploratory study of computer program debugging. </title> <booktitle> Human Factors, </booktitle> <volume> 16 </volume> <pages> 258-277, </pages> <year> 1974. </year>
Reference-contexts: However, for many programs, especially lengthy ones, such analysis is much too difficult to perform. One logical way to proceed in such situations would be to think backwardsdeduce the conditions under which the program produces the incorrect output <ref> [Sch71, Gou74, Luk80] </ref>. Consider, for example, the program in the main window panel of Figure 1. 1 This program computes the sum of the areas of N triangles. It reads the value of N , followed by the lengths of the three sides of each of these N triangles.
Reference: [HPR89] <author> Susan Horwitz, Jan Prins, and Thomas Reps. </author> <title> Integrating noninterfering versions of programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(3) </volume> <pages> 345-387, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, automatic integration of program versions, etc. (see, e.g., <ref> [Wei84, BC85, HPR89] </ref>). When a program slice is defined with respect to a variable occurrence, it is assumed that control does eventually reach the corresponding program location. The issue of non-termination of program execution is not addressed under this definition.
Reference: [HRB90] <author> Susan Horwitz, Thomas Reps, and David Binkeley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Although this choice has led to some problems, it has allowed us to rapidly develop a prototype that will work for full ANSI C. We have modified gcc to produce a program dependence graph <ref> [FOW87, OO84, HRB90] </ref> along with the object code of the given program. <p> Horwitz, Reps, and Binkley have extended 20 the program dependence graph representation to what they call the system dependence graph to find inter-procedural static slices under the same graph-reachability framework <ref> [HRB90] </ref>. Bergeretti and Carr e have also defined information-flow relations somewhat similar to data- and control dependence relations, that can be used to obtain static program slices (referred to as partial statements by them) [BC85].
Reference: [Kat79] <author> H. Katsoff. Sdb: </author> <title> a symbolic debugger. Unix Programmer's Manual, </title> <booktitle> 1979. </booktitle> <pages> 23 </pages>
Reference-contexts: Most interactive debuggers provide breakpoints and traces as their main debugging aids fl This paper has been submitted to SoftwarePractice & Experience. This work was funded by a grant from the Purdue University/University of Florida Software Engineering Research Center (SERC), and by National Science Foundation grant 8910306-CCR. 1 <ref> [Kat79, MB79, Dun86, Wei82] </ref>. Unfortunately, these traditional mechanisms are often inadequate for the task of isolating specific program faults. In this paper we present the results of our preliminary experiment in integrating new approaches to software fault localization with conventional debugging techniques.
Reference: [KL88] <author> Bogdan Korel and Janusz Laski. </author> <title> Dynamic program slicing. </title> <journal> Information Processing Letters, </journal> <volume> 29 </volume> <pages> 155-163, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: To detect program faults other than infinite loops, however, strong control dependence gives much finer slices compared to weak control dependence. The definintion of data-dependence remains the same in both cases. Korel and Laski extended Weiser's static slicing algorithms for the dynamic case <ref> [KL88] </ref>. Their definition of a dynamic slice is different from ours [AH90].
Reference: [Luk80] <author> F. J. Lukey. </author> <title> Understanding and debugging programs. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 12(2) </volume> <pages> 189-202, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: However, for many programs, especially lengthy ones, such analysis is much too difficult to perform. One logical way to proceed in such situations would be to think backwardsdeduce the conditions under which the program produces the incorrect output <ref> [Sch71, Gou74, Luk80] </ref>. Consider, for example, the program in the main window panel of Figure 1. 1 This program computes the sum of the areas of N triangles. It reads the value of N , followed by the lengths of the three sides of each of these N triangles.
Reference: [MB79] <author> J. Maranzano and S. Bourne. </author> <title> A tutorial introduction to ADB. Unix Programmers Manual, </title> <year> 1979. </year>
Reference-contexts: Most interactive debuggers provide breakpoints and traces as their main debugging aids fl This paper has been submitted to SoftwarePractice & Experience. This work was funded by a grant from the Purdue University/University of Florida Software Engineering Research Center (SERC), and by National Science Foundation grant 8910306-CCR. 1 <ref> [Kat79, MB79, Dun86, Wei82] </ref>. Unfortunately, these traditional mechanisms are often inadequate for the task of isolating specific program faults. In this paper we present the results of our preliminary experiment in integrating new approaches to software fault localization with conventional debugging techniques.
Reference: [MC88] <author> Barton P. Miller and Jong-Deok Choi. </author> <title> A mechanism for efficient debugging of parallel programs. </title> <booktitle> In Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <address> Atlanta, GA, </address> <month> June </month> <year> 1988. </year> <journal> ACM SIGPLAN. SIGPLAN Notices, </journal> <volume> 23(7) </volume> <pages> 135-144, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: It provides UNDO and REDO functions whose implementations are embedded within the language processor. INTERLISP provides these backtracking facilities in a functional programming environment, whereas our interest has been to provide a backtracking facility for debugging in the more common procedural environment. Miller and Choi's PPD <ref> [MC88] </ref> performs flow-back analysis of parallel programs like EXDAMS does for sequential programs. They use a notion of incremental tracing where portions of the program state are checkpointed at the start and the end of segments of program-code called emulation-blocks.
Reference: [MH89] <author> Charles E. McDowell and David P. Helmbold. </author> <title> Debugging concurrent programs. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(4) </volume> <pages> 593-623, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: 1 Introduction The importance of good debugging tools cannot be overemphasized. Average programmers may spend considerable amounts (possibly more than 50%) of their program development time debugging. Several tools are available to help them in this task <ref> [AS89, MH89] </ref>, varying from hexadecimal dumps of program state at the time of failure to window- and mouse-based interactive debuggers using bit-mapped displays [AM86, Car86]. Most interactive debuggers provide breakpoints and traces as their main debugging aids fl This paper has been submitted to SoftwarePractice & Experience.
Reference: [OO84] <author> Karl J. Ottenstein and Linda M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Symposium on Practical Software Development Environments, </booktitle> <address> Pittaburgh, PA, </address> <month> April </month> <year> 1984. </year> <journal> ACM SIGSOFT/SIGPLAN. SIGPLAN Notices, </journal> <volume> 19(5) </volume> <pages> 177-184, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: Although this choice has led to some problems, it has allowed us to rapidly develop a prototype that will work for full ANSI C. We have modified gcc to produce a program dependence graph <ref> [FOW87, OO84, HRB90] </ref> along with the object code of the given program. <p> He also presented an algorithm to compute static slices based on iterative solution of data-flow equations. Ottenstein and Ottenstein later presented an algorithm in terms of graph reachability in the Program Dependence Graph, but they only considered the intra-procedural case <ref> [OO84] </ref>. Horwitz, Reps, and Binkley have extended 20 the program dependence graph representation to what they call the system dependence graph to find inter-procedural static slices under the same graph-reachability framework [HRB90].
Reference: [PC90] <author> Andy Podgurski and Lori A. Clarke. </author> <title> A formal model of program dependences and its implications for software testing, debugging, and maintenance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 965-979, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The issue of non-termination of program execution is not addressed under this definition. Podgurski and Clark have extended the regular notion of control dependence (which they refer to as strong control dependence) to weak control dependence that includes inter-statement dependencies involving program non-termination <ref> [PC90] </ref>. To detect program faults other than infinite loops, however, strong control dependence gives much finer slices compared to weak control dependence. The definintion of data-dependence remains the same in both cases. Korel and Laski extended Weiser's static slicing algorithms for the dynamic case [KL88].
Reference: [Sch71] <author> Jacob T. Schwartz. </author> <title> An overview of bugs. </title> <editor> In Randall Rustin, editor, </editor> <booktitle> Debugging Techniques in Large Systems, </booktitle> <pages> pages 1-16. </pages> <publisher> Prentice-Hall, </publisher> <address> Engelwood Cliffs, NJ, </address> <year> 1971. </year>
Reference-contexts: However, for many programs, especially lengthy ones, such analysis is much too difficult to perform. One logical way to proceed in such situations would be to think backwardsdeduce the conditions under which the program produces the incorrect output <ref> [Sch71, Gou74, Luk80] </ref>. Consider, for example, the program in the main window panel of Figure 1. 1 This program computes the sum of the areas of N triangles. It reads the value of N , followed by the lengths of the three sides of each of these N triangles.
Reference: [Sta89] <author> Richard M. Stallman. </author> <title> GDB Manual, third edition, GDB version 3.4. Free Software Foundation, </title> <address> Cambridge, MA, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: The tool screen at this time is shown in Figure 14. Note the values of sides [i] before and after the backup is done. 5 Implementation Our debugging system is built into versions of the GNU C compiler gcc and the GNU source-level debugger gdb <ref> [Sta89] </ref>. Our intent has not been to write a production-quality tool but to show the feasibility of the above mechanisms. We decided, therefore, to modify an existing compiler and debugger rather than write a new system.
Reference: [Tei78] <author> Warren Teitelman. </author> <note> Interlisp Reference Manual, Fourth Edition. </note> <institution> Xerox Palo Alto Research Center, </institution> <address> Palo Alto, CA, </address> <year> 1978. </year>
Reference-contexts: The INTERLISP system, a program development environment for the LISP language, also provides recovery facilities within the language framework <ref> [Tei78] </ref>. It provides UNDO and REDO functions whose implementations are embedded within the language processor. INTERLISP provides these backtracking facilities in a functional programming environment, whereas our interest has been to provide a backtracking facility for debugging in the more common procedural environment.
Reference: [Wei82] <author> Mark Weiser. </author> <title> Programmers use slices when debugging. </title> <journal> Communications of the ACM, </journal> <volume> 25(7) </volume> <pages> 446-452, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Most interactive debuggers provide breakpoints and traces as their main debugging aids fl This paper has been submitted to SoftwarePractice & Experience. This work was funded by a grant from the Purdue University/University of Florida Software Engineering Research Center (SERC), and by National Science Foundation grant 8910306-CCR. 1 <ref> [Kat79, MB79, Dun86, Wei82] </ref>. Unfortunately, these traditional mechanisms are often inadequate for the task of isolating specific program faults. In this paper we present the results of our preliminary experiment in integrating new approaches to software fault localization with conventional debugging techniques. <p> This can be implemented in a manner transparent to the user; a more complete explanation is available in [AS88, ADS90]. 6 Related Work The concept of static program slicing was first proposed by Weiser <ref> [Wei84, Wei82] </ref>. He also presented an algorithm to compute static slices based on iterative solution of data-flow equations. Ottenstein and Ottenstein later presented an algorithm in terms of graph reachability in the Program Dependence Graph, but they only considered the intra-procedural case [OO84].
Reference: [Wei84] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: In Section 5 we briefly discuss some implementation issues. Finally, in Section 6, we outline related work. 2 Program Slicing Program Slicing is finding all those statements in a program that directly or indirectly affect the value of a given variable occurrence in the program <ref> [Wei84] </ref>. The statements that affect the value constitute the slice of the program with respect to the given variable occurrence (variable name and statement location). A slice has a simple meaning: it should evaluate the variable occurrence identically to the original program for all testcases. <p> This can be implemented in a manner transparent to the user; a more complete explanation is available in [AS88, ADS90]. 6 Related Work The concept of static program slicing was first proposed by Weiser <ref> [Wei84, Wei82] </ref>. He also presented an algorithm to compute static slices based on iterative solution of data-flow equations. Ottenstein and Ottenstein later presented an algorithm in terms of graph reachability in the Program Dependence Graph, but they only considered the intra-procedural case [OO84]. <p> Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, automatic integration of program versions, etc. (see, e.g., <ref> [Wei84, BC85, HPR89] </ref>). When a program slice is defined with respect to a variable occurrence, it is assumed that control does eventually reach the corresponding program location. The issue of non-termination of program execution is not addressed under this definition.
Reference: [Zel71] <author> M. V. Zelkowitz. </author> <title> Reversible Execution As a Diagnostic Tool. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <month> January </month> <year> 1971. </year> <month> 24 </month>
Reference-contexts: However, if a program was stopped at some location it was not possible to change values of variables before executing forward again because EXDAMS simply replayed the program behavior recorded earlier. Zelkowitz incorporated a backtracking facility within the programming language PL/1 by adding a RETRACE statement to the language <ref> [Zel71] </ref>. With this statement, execution could be backtracked over a desired number of statements, up to a statement with a given label, or until the program state matched a certain condition.
References-found: 29

