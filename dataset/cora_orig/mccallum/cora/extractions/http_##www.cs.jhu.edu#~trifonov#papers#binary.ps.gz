URL: http://www.cs.jhu.edu/~trifonov/papers/binary.ps.gz
Refering-URL: http://www.cs.jhu.edu/~trifonov/papers/
Root-URL: http://www.cs.jhu.edu
Title: On Binary Methods Keywords: object-oriented programming, type checking, binary method, matching, subtyping, precise type, multi-method,
Author: Kim Bruce, Luca Cardelli, Giuseppe Castagna, Gary T. Leavens, and Benjamin Pierce TR #-a 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Note: To appear in Theory and Practice of Object Systems. Copyright c assigned to John Wiley and Sons, Inc, 1995.  
Date: May 1995, Revised December 1995  
Affiliation: The Hopkins Objects Group,  Department of Computer Science  Iowa Sate University  
Abstract: 1994 CR Categories: D.1.5 [Programming Techniques] Object-oriented Programming; D.2.2 [Software Engineering] Tools and Techniques | modules and interfaces; D.3.1 [Programming Languages] Formal Definitions and Theory | semantics; D.3.2 [Programming Languages] Language Classifications | object-oriented languages; D.3.3 [Programming Languages] Language Constructs | Abstract data types, modules, packages; F.3.2 [Logics and Meanings of Programs] Studies of Program Constructs | type structure. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Luca Cardelli. </author> <title> On subtyping and matching. </title> <booktitle> In Proceedings ECOOP '95, </booktitle> <pages> pages 145-167. </pages> <publisher> LNCS 952, Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The introduction of a matching relation is thus one, but not the only, solution to the problem of typing inherited binary methods. In the next subsection we explore the mathematical aspects of the matching relation. 4.1.2 Matching and Object Types As described in <ref> [1] </ref>, matching can consistently be defined in terms of pointwise subtyping on operators from types to types. In this case an object type is used to define a function from types to types by replacing all oc currences of MyType by a type variable.
Reference: [2] <author> Rakesh Agrawal, Lindga G. DeMichiel, and Bruce G. Lindsay. </author> <title> Static type checking of multi-methods. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 26(11) </volume> <pages> 113-128, </pages> <month> November </month> <year> 1991. </year> <booktitle> OOPSLA '91 Conference Proceedings, </booktitle> <editor> Andreas Paepcke (editor), </editor> <month> October </month> <year> 1991, </year> <type> Phoenix, </type> <institution> Arizona. </institution>
Reference-contexts: In Section 4.1, we show one way this may be done using the concept of matching [12, 13]. The other important solution was presented in two papers at the 1991 OOPSLA conference <ref> [2, 31] </ref>. These papers deal with the static type-checking of languages with multi-methods (also called generic functions or overloaded functions). Multi-methods as in CLOS allow, as we show in Section 4.2.1, the Point/ColorPoint example to be typed preserving the subtyping of the two classes. <p> Note also that multi-methods allow one to specialize equal in a different way for each possible combination 6 Some further conditions are required to assure that a best matching branch always exists for the selection (see <ref> [2] </ref>, [22], and [18]). 12 To appear in THEORY AND PRACTICE OF OBJECT SYSTEMS 1 (Number:3) class Point includes xValue: real yValue: real end class class ColorPoint subclass of Point includes -- xValue and yValue are inherited cValue : string end class method x (p: Point):real is return (p.xValue) method y <p> Most of the languages that use multi-methods are untyped (e.g. CLOS [27], Dy-lan [7], which use classes instead of types to drive the selection of multi-methods). The only strongly-typed languages in our ken that use multi-methods are Ce-cil [22], and Polyglot <ref> [2] </ref>. The lack of encapsulation in multi-methods is both an advantage and a drawback. The drawback is methodological: an object (or a class of objects) is no longer associated with a fixed set of methods that have privileged access to its internal representation.
Reference: [3] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyp-ing recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4), </volume> <month> Septem-ber </month> <year> 1993. </year>
Reference-contexts: On the other hand if a method's return type is MyType, this will not stand in the way of subtyping. Both of these follow easily from the subtyping rule for recursive types in <ref> [3] </ref>, and the fact that MyType can be seen as an abbreviation for a recursive definition of types.
Reference: [4] <author> Pierre America. </author> <title> Inheritance and subtyping in a parallel object-oriented language. </title> <editor> In Jean Bezivin et al., editors, </editor> <booktitle> ECOOP '87, European Conference on Object-Oriented Programming, Paris, France, </booktitle> <pages> pages 234-242, </pages> <address> New York, NY, </address> <month> June </month> <year> 1987. </year> <title> Springer-Verlag. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 276. </volume>
Reference-contexts: Behavioral subtyping is a stronger relationship than subtyping, and, in addition to guarantees about lack of type errors, makes behavioral guarantees <ref> [4, 5, 38, 37, 41, 39] </ref>.
Reference: [5] <author> Pierre America. </author> <title> Designing an object-oriented programming language with behavioural subtyping. </title> <editor> In J. W. de Bakker, W. P. de Roever, and G. Rozen-berg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop, Noordwijkerhout, The Netherlands, May/June 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pages 60-90. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: Behavioral subtyping is a stronger relationship than subtyping, and, in addition to guarantees about lack of type errors, makes behavioral guarantees <ref> [4, 5, 38, 37, 41, 39] </ref>.
Reference: [6] <author> Eric Amiel, Oliver Gruber, and Eric Simon. </author> <title> Optimizing multi-method dispatch using compressed dispatch tables. </title> <booktitle> In OOPSLA '94 Conference Proceedings, volume 29(10) of SIGPLAN Notices, </booktitle> <pages> pages 244-258. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: In a single dispatch language, a single table lookup can find the best argument branch. With multiple dispatch, it may be more expensive to compute the branch of a multi-method that matches the arguments best, although various techniques have been designed to minimize the added expense <ref> [6, 23, 26] </ref>. However, in a language where the compiler can tell which argument positions need dispatching (as in CLOS), one can implement multi-method dispatch as a chain of single dispatches [36].
Reference: [7] <institution> Apple Computer Inc., Eastern Research and Technology. </institution> <month> Dylan: </month> <title> an object-oriented dynamic language, </title> <month> April </month> <year> 1992. </year> <note> To appear in THEORY AND PRACTICE OF OBJECT SYSTEMS 1(Number:3) 21 </note>
Reference-contexts: Most of the languages that use multi-methods are untyped (e.g. CLOS [27], Dy-lan <ref> [7] </ref>, which use classes instead of types to drive the selection of multi-methods). The only strongly-typed languages in our ken that use multi-methods are Ce-cil [22], and Polyglot [2]. The lack of encapsulation in multi-methods is both an advantage and a drawback.
Reference: [8] <author> Fran~cois Bancilhon, Claude De-lobel, and Paris Kanellakis (eds.). </author> <title> Implementing an Object-Oriented database system: </title> <publisher> The story of O 2 . Morgan Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: As illustrated in the sorting example above, the matching relation is very useful in defining bounded polymorphic functions. In fact, the use of these two features should provide a type-safe replacement for the (unsafe) uses of covariant argument specialization typing in languages like Eiffel or O 2 <ref> [8] </ref>, while providing comparable expressiveness.
Reference: [9] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> Object structure in the Emerald system. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 78-86, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: The informal idea is thus to give methods smaller types <ref> [9, 10] </ref>. By subsumption, these types can always be lifted to "true binary" form, allowing objects of the same class to be passed as arguments to the method. Thus, specifying a smaller type of a method can only increase its usability.
Reference: [10] <author> Andrew P. Black and Norman Hutchinson. </author> <title> Type-checking polymorphism in Emerald. </title> <type> Technical Report CRL 91/1 (Revised), </type> <institution> Digital Equipment Corporation, Cambridge Research Lab, </institution> <address> Cambridge, Mass., </address> <month> July </month> <year> 1991. </year>
Reference-contexts: This is similar to the sort procedure written with bounded matching. Object-oriented languages containing similar constructs are Emerald <ref> [10] </ref>, School [50], and Theta [40]. <p> The informal idea is thus to give methods smaller types <ref> [9, 10] </ref>. By subsumption, these types can always be lifted to "true binary" form, allowing objects of the same class to be passed as arguments to the method. Thus, specifying a smaller type of a method can only increase its usability.
Reference: [11] <author> John Boyland and Giuseppe Castagna. </author> <title> Type-safe compiling of covariant specialization: a practical case. </title> <type> Technical Report CSD-95-890, </type> <institution> University of California, Berkeley, </institution> <month> November </month> <year> 1995. </year> <note> Currently available by anonymous ftp from ftp.ens.fr in file /pub/dmi/users/castagna/o2.ps.Z. </note>
Reference-contexts: Thus, like the solution given in the next section, this solution can be directly applied to languages with covariant argument specialization without requiring any modification of the code: a recompilation of existing code will suffice (see <ref> [11] </ref>). On the other hand this approach has some disadvantages. One disadvantage compared to multi-methods a la CLOS is that it does not solve the problem of obtaining privileged access to other arguments in a binary method.
Reference: [12] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented programming language: design, static typing and semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 127-206, </pages> <year> 1994. </year>
Reference-contexts: That is, it means Link in the class LinkClass, but means DoubleLink in the class DoubleLinkClass and in the instance variables and methods it inherits from LinkClass. MyType will be discussed in more detail in Section 4.1 below; also cf. <ref> [51, 12, 13, 29] </ref>. The objects now have only one interesting method, append , which is inherited by DoubleLinkClass. This method uses setNext , a binary method, to set the pointer next, and setNext is overridden in DoubleLinkClass to also properly maintain the prev link to the previous object. <p> As they put it, "Inheritance is not subtyping." They did not, however, propose a concrete mechanism for realizing their ideas in an object-oriented language. In Section 4.1, we show one way this may be done using the concept of matching <ref> [12, 13] </ref>. The other important solution was presented in two papers at the 1991 OOPSLA conference [2, 31]. These papers deal with the static type-checking of languages with multi-methods (also called generic functions or overloaded functions). <p> of giving more "precise" types to binary methods produces more flexible typings across a range of approaches, even in the case where binary operations are not treated as methods. 4.1 Matching This section describes how a relation called "matching," which is weaker than subtyping, can replace subtyping in many situations <ref> [12] </ref>. <p> &lt;# OT hhm 1 : t 1 ; : : : ; m k : t k ii holds iff k n. (In fact, a more general definition is possible in which the types of corresponding methods of the first are all subtypes of the corresponding types of the second <ref> [12] </ref>. This means that the corresponding result types are subtypes|vary in a covariant way|while the corresponding parameter types are supertypes|vary in a contravariant way. <p> In order to obtain type safety, it is necessary to type check the methods of a class under the assumption that MyType only matches the type of objects being defined by the class. This ensures that these methods will continue to be type-safe when inherited in subclasses <ref> [12] </ref>. While some routines will not type check with this assumption, even though they would have passed under the stronger assumption that MyType is exactly the type of objects generated by this class, in our (admittedly not comprehensive) experience, very few routines fail.
Reference: [13] <author> Kim B. Bruce, Angela Schuett, and Robert van Gent. PolyTOIL: </author> <title> A type-safe polymorphic object-oriented language. </title> <booktitle> In Proceedings ECOOP '95, </booktitle> <pages> pages 27-51. </pages> <publisher> LNCS 952, Springer-Verlag, </publisher> <year> 1995. </year> <note> A complete version of this paper with full proofs is available via http://www.cs.williams.edu/~kim/. </note>
Reference-contexts: That is, it means Link in the class LinkClass, but means DoubleLink in the class DoubleLinkClass and in the instance variables and methods it inherits from LinkClass. MyType will be discussed in more detail in Section 4.1 below; also cf. <ref> [51, 12, 13, 29] </ref>. The objects now have only one interesting method, append , which is inherited by DoubleLinkClass. This method uses setNext , a binary method, to set the pointer next, and setNext is overridden in DoubleLinkClass to also properly maintain the prev link to the previous object. <p> As they put it, "Inheritance is not subtyping." They did not, however, propose a concrete mechanism for realizing their ideas in an object-oriented language. In Section 4.1, we show one way this may be done using the concept of matching <ref> [12, 13] </ref>. The other important solution was presented in two papers at the 1991 OOPSLA conference [2, 31]. These papers deal with the static type-checking of languages with multi-methods (also called generic functions or overloaded functions). <p> It is then relatively easy to write an implementation for lists which takes a type parameter which matches singly-linked node. By applying this to either the type for singly-linked node or doubly-linked node, the corresponding kind of list can be generated without code duplication. (See <ref> [13] </ref> for the details of this parameterized example.) The use of MyType in class definitions makes it easier to write useful subclasses in statically typed object-oriented languages, especially when the superclasses contain binary methods.
Reference: [14] <author> Peter Canning, William Cook, Walter Hill, Walter Olthoff, and John Mitchell. </author> <title> F-bounded quantification for object-oriented programming. </title> <booktitle> In Fourth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Thus, if the bounds on type parameters were only expressed in terms of subtyping, it would be impossible to apply the sort routine to any interesting arguments. The use of bounded matching is equivalent to the use of F-bounded polymorphism suggested in <ref> [14] </ref>. It is also very similar in effect to the restrictions on type parameters expressible in CLU and Ada (as well as the type classes of Haskell).
Reference: [15] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In G. Kahn, D. MacQueen, and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 51-67. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year> <note> Full version in Information and Computation </note> 76(2/3):138-164, 1988. 
Reference-contexts: Informally, a type is a subtype of t , written &lt;: t , if an expression of type can be used in any context that expects an expression of type t (cf. <ref> [15, 16, 49] </ref>). Associated with subtyping is the principle of subsump-tion (subtype polymorphism): if &lt;: t and a program fragment has type , it also has type t . <p> The rule for subtyping functions states that ! t &lt;: 0 ! t 0 if and only if 0 &lt;: and t &lt;: t 0 <ref> [15] </ref>. (This is sometimes called the "contravariant rule" because it is contravariant in the left argument of !.) This rule is informally justified by the following. <p> There are some theoretical benefits to taking this step. For example, aside from binary methods, the types of methods are always positive, in the sense that the object type itself appears only in result positions. In this case, the classic encoding of object types as recursive records <ref> [15, 25] </ref> may be replaced by an encoding where objects are modeled by existential types [48, 33]. It may also be argued that keeping binary operations separate from their arguments avoids conceptual confusion.
Reference: [16] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, </title> <journal> and polymor-phism. Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> Decem-ber </month> <year> 1985. </year>
Reference-contexts: Informally, a type is a subtype of t , written &lt;: t , if an expression of type can be used in any context that expects an expression of type t (cf. <ref> [15, 16, 49] </ref>). Associated with subtyping is the principle of subsump-tion (subtype polymorphism): if &lt;: t and a program fragment has type , it also has type t . <p> For this, we generalize Mitchell and Plotkin's motto that "abstract types have existential type" [44], combining it with the idea of object interfaces as type operators from Cardelli and Wegner's partially abstract types <ref> [16] </ref>. The interface of the exposed integer set objects can be written as follows.
Reference: [17] <author> Giuseppe Castagna. </author> <title> Covariance and contravari-ance: conflict without a cause. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(3) </volume> <pages> 431-447, </pages> <year> 1995. </year>
Reference-contexts: In Sec 8 To appear in THEORY AND PRACTICE OF OBJECT SYSTEMS 1 (Number:3) tion 4.2.2 we show how to reconcile multi-methods with objects encapsulating data and code <ref> [17, 45] </ref>. Closely related to the solutions of Section 4.2 is In-galls' solution to the multiple dispatch problem [34]. He presented his solution in an untyped framework, but it can be adapted to a typed language, as Section 4.3 shows. <p> In this survey we distinguish two different kinds of multi-methods: the ones used by the language CLOS [27], and the encapsulated multi-methods of <ref> [17, 45] </ref>. A unified analysis of both kinds of multi-methods is given in [17]. <p> In this survey we distinguish two different kinds of multi-methods: the ones used by the language CLOS [27], and the encapsulated multi-methods of [17, 45]. A unified analysis of both kinds of multi-methods is given in <ref> [17] </ref>. We now describe each kind in turn. 4.2.1 Multi-methods a la CLOS Intuitively the idea is to consider (multi-)methods (in CLOS jargon, generic functions) as global functions that are dynamically bound to different method bodies according to the classes of the actual arguments. <p> Instead of defining multi-methods as global functions, the idea is to use them to define the bodies of some methods in a class definition <ref> [17] </ref>. In this way a multi-method is always associated to a message m of a class C . When m is sent to an object of class C , it is dispatched to the corresponding method. <p> ColorPoint OT hhx : real; y : real; c: string; equal : fPoint ! bool; ColorPoint ! boolgii and ColorPoint &lt;: Point holds, since, for subtyping, ordinary methods are considered as multi-methods with just one branch (their type is a singleton set) and in a type system for multi-methods (see <ref> [17] </ref>) one can deduce: fPoint ! bool ; ColorPoint ! bool g &lt;: fPoint ! boolg.
Reference: [18] <author> Giuseppe Castagna, Giorgio Ghelli, and Giuseppe Longo. </author> <title> A calculus for overloaded functions with subtyping. </title> <journal> Information and Computation, </journal> <volume> 117(1) </volume> <pages> 115-135, </pages> <month> February </month> <year> 1995. </year> <note> A preliminary version appeared in ACM Conference on LISP and Functional Programming, June 1992 (pp. 182-192). </note>
Reference-contexts: This selection is performed at run-time. In this way one obtains dynamic dispatch. Note that in this paradigm binary methods are really binary, since the implicit argument given by the receiver of the message is, in this case, explicit. In <ref> [18] </ref> it is proved that to have a sound type system it suffices that every multi-method of type fS 1 ! T 1 ; S 2 ! T 2 ; : : : ; S n ! T n g satisfies the following condition. 6 8i; j 2 [1::n] if S <p> Note also that multi-methods allow one to specialize equal in a different way for each possible combination 6 Some further conditions are required to assure that a best matching branch always exists for the selection (see [2], [22], and <ref> [18] </ref>). 12 To appear in THEORY AND PRACTICE OF OBJECT SYSTEMS 1 (Number:3) class Point includes xValue: real yValue: real end class class ColorPoint subclass of Point includes -- xValue and yValue are inherited cValue : string end class method x (p: Point):real is return (p.xValue) method y (p: Point):real is <p> branches c 1 ; c 2 with the same name and number of arguments, 10 if the parameter types of c 1 are smaller than the corresponding parameter types of c 2 , then the result type of c 1 must be smaller than the result type of c 2 <ref> [49, 18] </ref>. important to be clear that, in the formalization we use, a new definition of a (multi-)method completely overrides the old one (i.e. it is not possible to inherit some branches and override others: this could by obtained by adding some extra syntax.) 8 This example is due to John <p> See the conclusion for further discussion of this issue. Some further consistency conditions are required in case of multiple inheritance <ref> [31, 45, 18, 22] </ref>. One of the main advantages of this approach is that the extra branch required to assure type safety of sub-typing can be generated in an automatic way.
Reference: [19] <author> Giuseppe Castagna and Gary T. Leavens. </author> <title> Foundations of object-oriented languages: 2nd workshop report. </title> <journal> SIGPLAN Notices, </journal> <volume> 30(2) </volume> <pages> 5-11, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: This paper grew from presentations and discussions at the 2nd Workshop on Foundations of Object-Oriented Languages, which was sponsored by NSF and ESPRIT and held in Paris in June, 1994 <ref> [19] </ref>. Let us begin by fixing some basic terminology. A class is the code that defines the instance variables and methods of some objects.
Reference: [20] <author> Craig Chambers. </author> <title> Object-oriented multi-methods in Cecil. </title> <editor> In Ole Lehrmann Madsen, editor, </editor> <booktitle> ECOOP '92, European Conference on Object-Oriented Programming, Utrecht, The Netherlands, volume 615 of Lecture Notes in Computer Science, </booktitle> <pages> pages 33-56. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference-contexts: One possibility is to use the notation of Cecil <ref> [20, 22] </ref>, which does separate these concepts. method bodies). <p> In particular, [47] demonstrates that the mechanism shown here is compatible with inheritance (though it requires some additional machinery). These ideas give a semantic basis for some aspects of the encapsulation via friends found in C++ and the encapsulation in Cecil <ref> [20] </ref>.
Reference: [21] <author> Craig Chambers. </author> <title> multi-method implementation question. </title> <type> personal communication via e-mail, </type> <month> August and November </month> <year> 1995. </year>
Reference-contexts: Moreover, if a program in a single-dispatching language is written by using additional dispatching after methods are called to resolve problems caused by binary methods (as in Section 4.3), then such a program will be no faster than the equivalent multi-method program <ref> [21] </ref>. A final drawback of multi-methods a la CLOS is the difficulty of combining independently developed systems of multi-methods [24].
Reference: [22] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typecheck-ing and modules for multi-methods. </title> <journal> ACM SIG-PLAN Notices, </journal> <volume> 29(10) </volume> <pages> 1-15, </pages> <month> October </month> <year> 1994. </year> <booktitle> OOP-SLA '94 Conference Proceedings, </booktitle> <month> October </month> <year> 1994, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: One possibility is to use the notation of Cecil <ref> [20, 22] </ref>, which does separate these concepts. method bodies). <p> Note also that multi-methods allow one to specialize equal in a different way for each possible combination 6 Some further conditions are required to assure that a best matching branch always exists for the selection (see [2], <ref> [22] </ref>, and [18]). 12 To appear in THEORY AND PRACTICE OF OBJECT SYSTEMS 1 (Number:3) class Point includes xValue: real yValue: real end class class ColorPoint subclass of Point includes -- xValue and yValue are inherited cValue : string end class method x (p: Point):real is return (p.xValue) method y (p: <p> Most of the languages that use multi-methods are untyped (e.g. CLOS [27], Dy-lan [7], which use classes instead of types to drive the selection of multi-methods). The only strongly-typed languages in our ken that use multi-methods are Ce-cil <ref> [22] </ref>, and Polyglot [2]. The lack of encapsulation in multi-methods is both an advantage and a drawback. The drawback is methodological: an object (or a class of objects) is no longer associated with a fixed set of methods that have privileged access to its internal representation. <p> However, because such methods can be defined anywhere in the program, one cannot restrict direct access to instance variables to a small area of the program text. One way to fix such problems may be to add a separate module system to control instance variable access <ref> [22] </ref>. Instead of pursuing that idea, in the next subsection, we show how to apply the ideas of multi-methods in more traditional object-oriented languages with single dispatching and classes. Conventional wisdom is that multiple dispatch is more expensive than single dispatch. <p> A final drawback of multi-methods a la CLOS is the difficulty of combining independently developed systems of multi-methods [24]. While other ways to solve this problem have been studied <ref> [22] </ref>, the problem nearly disappears when multi-methods are combined with single dispatching, as described next. 4.2.2 Encapsulated multi-methods To solve the encapsulation problems of multi-methods a la CLOS, we seek to emulate the Smalltalk model, where every method is the method of one object. <p> See the conclusion for further discussion of this issue. Some further consistency conditions are required in case of multiple inheritance <ref> [31, 45, 18, 22] </ref>. One of the main advantages of this approach is that the extra branch required to assure type safety of sub-typing can be generated in an automatic way. <p> the modularity of programming [24], since the addition To appear in THEORY AND PRACTICE OF OBJECT SYSTEMS 1 (Number:3) 15 of a new class to the system might require the addition of some new code in a different class to assure the existence of the best branch (see, for example, <ref> [22] </ref>). However the problem with modularity is less critical than in the case of multi-method a la CLOS. An additional disadvantage is again the performance penalty imposed by multi-methods. One extra test and branch is required to decide which code is to be executed.
Reference: [23] <author> Weimin Chen, Volker Turau, and Wolfgang Klas. </author> <title> Efficient dynamic look-up strategy for multi-methods. </title> <editor> In Mario Tokoro and Remo Pareschi, editors, </editor> <booktitle> ECOOP '94, European Conference on Object-Oriented Programming, Bologna, Italy, volume 821 of Lecture Notes in Computer Science, </booktitle> <pages> pages 408-431, </pages> <address> New York, NY, July 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In a single dispatch language, a single table lookup can find the best argument branch. With multiple dispatch, it may be more expensive to compute the branch of a multi-method that matches the arguments best, although various techniques have been designed to minimize the added expense <ref> [6, 23, 26] </ref>. However, in a language where the compiler can tell which argument positions need dispatching (as in CLOS), one can implement multi-method dispatch as a chain of single dispatches [36].
Reference: [24] <author> William R. Cook. </author> <title> Object-oriented programming versus abstract data types. </title> <editor> In J. W. de Bakker, W. P. de Roever, and G. Rozen-berg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop, Noordwijkerhout, The Netherlands, May/June 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pages 151-178. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: A final drawback of multi-methods a la CLOS is the difficulty of combining independently developed systems of multi-methods <ref> [24] </ref>. <p> The problem is that when multiple inheritance is used, the notion of a "best matching branch" to select or to inherit may be lost. Consequently, unconstrained use of multi-methods can break the modularity of programming <ref> [24] </ref>, since the addition To appear in THEORY AND PRACTICE OF OBJECT SYSTEMS 1 (Number:3) 15 of a new class to the system might require the addition of some new code in a different class to assure the existence of the best branch (see, for example, [22]).
Reference: [25] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Proc. 17th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: There are some theoretical benefits to taking this step. For example, aside from binary methods, the types of methods are always positive, in the sense that the object type itself appears only in result positions. In this case, the classic encoding of object types as recursive records <ref> [15, 25] </ref> may be replaced by an encoding where objects are modeled by existential types [48, 33]. It may also be argued that keeping binary operations separate from their arguments avoids conceptual confusion. <p> Two important solutions have been proposed to the typing problems posed by binary methods. One solution, first proposed by the Abel project at HP labs <ref> [25] </ref>, develops a method that partially solves the Point /ColorPoint problem by relaxing the requirement that subclasses generate subtypes. As they put it, "Inheritance is not subtyping." They did not, however, propose a concrete mechanism for realizing their ideas in an object-oriented language.
Reference: [26] <author> Jeffrey Dean, David Grove, and Craig Chambers. </author> <title> Efficient dynamic look-up strategy for multi-methods. </title> <editor> In Walter Olthoff, editor, </editor> <booktitle> ECOOP '95, European Conference on Object-Oriented Programming, Aarhus, Denmark, volume 952 of Lecture Notes in Computer Science, </booktitle> <pages> pages 77-101, </pages> <address> New York, NY, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. 22 To appear in THEORY AND PRACTICE OF OBJECT SYSTEMS 1(Number:3) </note>
Reference-contexts: In a single dispatch language, a single table lookup can find the best argument branch. With multiple dispatch, it may be more expensive to compute the branch of a multi-method that matches the arguments best, although various techniques have been designed to minimize the added expense <ref> [6, 23, 26] </ref>. However, in a language where the compiler can tell which argument positions need dispatching (as in CLOS), one can implement multi-method dispatch as a chain of single dispatches [36].
Reference: [27] <author> L.G. DeMichiel and R.P. Gabriel. </author> <title> Common Lisp Object System overview. </title> <editor> In Bezivin, Hullot, Cointe, and Lieberman, editors, </editor> <booktitle> Proc. of ECOOP '87 European Conference on Object-Oriented Programming, number 276 in LNCS, </booktitle> <pages> pages 151-170, </pages> <address> Paris, France, June 1987. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In this survey we distinguish two different kinds of multi-methods: the ones used by the language CLOS <ref> [27] </ref>, and the encapsulated multi-methods of [17, 45]. A unified analysis of both kinds of multi-methods is given in [17]. <p> Most of the languages that use multi-methods are untyped (e.g. CLOS <ref> [27] </ref>, Dy-lan [7], which use classes instead of types to drive the selection of multi-methods). The only strongly-typed languages in our ken that use multi-methods are Ce-cil [22], and Polyglot [2]. The lack of encapsulation in multi-methods is both an advantage and a drawback.
Reference: [28] <author> J. Eifrig, S. Smith, and V. Trifonov. </author> <title> Sound polymorphic type inference for objects. </title> <booktitle> In Proceedings of OOPSLA '95, </booktitle> <pages> pages 169-184, </pages> <year> 1995. </year>
Reference-contexts: Typing this "heterogeneous" invocation is crucial for a class defining binary methods intended to be inherited without redefinition and able to take as arguments objects of any subclass <ref> [28] </ref>. In a type system based on matching, a method declared to take arguments of type MyType cannot, in general, accept an object of a subclass as argument; it is necessary to use bounded matching to realize this (see the discussion at the end of Section 4.1.1). <p> The relation with the types of the "true binary" methods is more direct in an implicitly typed language, where the precise types are smaller <ref> [30, 28] </ref>. With this typing, taking the max of two elements of ColorMPoint returns a ColorMPoint; any other combination returns a MPoint , the best static type possible. Note that ColorMPoint is still a subtype of MPoint in a system with implicit unfolding of recursive types. <p> Soop and PolyTOIL are two languages in which all of the precise typings of this section may be expressed. Precise types are complex, however, and it is difficult to imagine programmers writing them routinely. A solution to this problem is to automatically infer minimal types. See <ref> [28] </ref> for a type inference algorithm for the I-Loop object-oriented language. The algorithm infers a form of F-bounded polymorphic type for classes and objects. It infers minimal types for the original Point/ColorPoint example that are very similar to the "small" types presented above. <p> This allows more flexibility than matching. However, it seems to require type inference to be practical <ref> [28] </ref>, and the resulting types may be more complicated than programmers want to see. To solve the problem of privileged access to additional arguments, we discussed adding additional layers of abstraction.
Reference: [29] <author> J. Eifrig, S. Smith, V. Trifonov, and A. Zwarico. </author> <title> Application of OOP type theory: State, decidabil-ity, integration. </title> <booktitle> In Proceedings of OOPSLA '94, </booktitle> <pages> pages 16-30, </pages> <year> 1994. </year>
Reference-contexts: That is, it means Link in the class LinkClass, but means DoubleLink in the class DoubleLinkClass and in the instance variables and methods it inherits from LinkClass. MyType will be discussed in more detail in Section 4.1 below; also cf. <ref> [51, 12, 13, 29] </ref>. The objects now have only one interesting method, append , which is inherited by DoubleLinkClass. This method uses setNext , a binary method, to set the pointer next, and setNext is overridden in DoubleLinkClass to also properly maintain the prev link to the previous object. <p> In fact, the use of these two features should provide a type-safe replacement for the (unsafe) uses of covariant argument specialization typing in languages like Eiffel or O 2 [8], while providing comparable expressiveness. The object-oriented language Loop <ref> [29] </ref>, on the other hand, has no matching relation per se, but has similar expressivity, achieved by circular subtype assertions t &lt;: where t and may share free type variable X; this can be viewed as a form of operator subtyping t (X) &lt;: (X).
Reference: [30] <author> Jonathan Eifrig, Scott Smith, and Valery Tri-fonov. </author> <title> Type inference for recursively constrained types and its application to OOP. </title> <booktitle> In Mathematical Foundations of Programming Semantics, </booktitle> <address> New Orleans, </address> <booktitle> volume 1 of Electronic Notes in Theoretical Computer Science. </booktitle> <publisher> Elsevier, </publisher> <year> 1995. </year> <note> http://www.elsevier.nl:80/mcs/tcs/pc/volume01.htm. </note>
Reference-contexts: The relation with the types of the "true binary" methods is more direct in an implicitly typed language, where the precise types are smaller <ref> [30, 28] </ref>. With this typing, taking the max of two elements of ColorMPoint returns a ColorMPoint; any other combination returns a MPoint , the best static type possible. Note that ColorMPoint is still a subtype of MPoint in a system with implicit unfolding of recursive types.
Reference: [31] <author> Giorgio Ghelli. </author> <title> A static type system for message passing. </title> <booktitle> In OOPSLA '91 Conference Proceedings, </booktitle> <pages> pages 129-145, </pages> <year> 1991. </year>
Reference-contexts: In Section 4.1, we show one way this may be done using the concept of matching [12, 13]. The other important solution was presented in two papers at the 1991 OOPSLA conference <ref> [2, 31] </ref>. These papers deal with the static type-checking of languages with multi-methods (also called generic functions or overloaded functions). Multi-methods as in CLOS allow, as we show in Section 4.2.1, the Point/ColorPoint example to be typed preserving the subtyping of the two classes. <p> See the conclusion for further discussion of this issue. Some further consistency conditions are required in case of multiple inheritance <ref> [31, 45, 18, 22] </ref>. One of the main advantages of this approach is that the extra branch required to assure type safety of sub-typing can be generated in an automatic way.
Reference: [32] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: His solution to the binary method problem, offered in the context of single-dispatching languages such as Smalltalk-80 <ref> [32] </ref>, was to use two message dispatches, one to resolve the polymorphism of each argument. In the example of points, colored points, and equality, the equal method would be coded as in Figure 9. As usual, the class ColorPointClass inherits the method equalPoint from the class PointClass.
Reference: [33] <author> Martin Hofmann and Benjamin Pierce. </author> <title> A unifying type-theoretic framework for objects. </title> <journal> Journal of Functional Programming, </journal> <note> 1995. Previous versions appeared in the Symposium on Theoretical Aspects of Computer Science, </note> <year> 1994, </year> <title> (pages 251-262) and, under the title "An Abstract View of Objects and Subtyping (Preliminary Report)," as University of Edinburgh, </title> <type> LFCS technical report ECS-LFCS-92-226, </type> <year> 1992. </year>
Reference-contexts: In this case, the classic encoding of object types as recursive records [15, 25] may be replaced by an encoding where objects are modeled by existential types <ref> [48, 33] </ref>. It may also be argued that keeping binary operations separate from their arguments avoids conceptual confusion.
Reference: [34] <author> Daniel H. H. Ingalls. </author> <title> A simple technique for handling multiple polymorphism. </title> <editor> In Norman Mey-rowitz, editor, </editor> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <address> Portland, Oregon, </address> <month> September </month> <year> 1986, </year> <journal> volume 21(11) of ACM SIGPLAN Notices, </journal> <pages> pages 347-349. </pages> <publisher> ACM, </publisher> <month> November </month> <year> 1986. </year>
Reference-contexts: In Sec 8 To appear in THEORY AND PRACTICE OF OBJECT SYSTEMS 1 (Number:3) tion 4.2.2 we show how to reconcile multi-methods with objects encapsulating data and code [17, 45]. Closely related to the solutions of Section 4.2 is In-galls' solution to the multiple dispatch problem <ref> [34] </ref>. He presented his solution in an untyped framework, but it can be adapted to a typed language, as Section 4.3 shows. <p> Some further negative remarks are to be found at the end of the next section. 4.3 Simulating Multi-methods in a Single-Dispatching Language Ingalls offered a solution to what he called the problem of "multiple polymorphism" at the first OOPSLA conference <ref> [34] </ref>. His solution to the binary method problem, offered in the context of single-dispatching languages such as Smalltalk-80 [32], was to use two message dispatches, one to resolve the polymorphism of each argument.
Reference: [35] <author> Dinesh Katiyar, David Luckham, and John Mitchell. </author> <title> A type system for prototyping languages. </title> <booktitle> In Conference Record of POPL '94: 21st ACM SIGPLAN-SIGACT Symposium of Principles of Programming Languages, Portland, Oregon, </booktitle> <pages> pages 138-150. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: This section sketches a technique whereby such "overexposed objects" can be wrapped in an additional layer of abstraction, creating a limited scope in which their internal structure is visible. The technique was developed by Pierce and Turner [47] and by Katiyar, Luckham, and Mitchell <ref> [35] </ref>; we refer the reader to these papers for further details. In particular, [47] demonstrates that the mechanism shown here is compatible with inheritance (though it requires some additional machinery).
Reference: [36] <author> Gregor Kiczales and Luis H. Rodriguez Jr. </author> <title> Efficient method dispatch in PCL. </title> <editor> In Andreas Paepcke, editor, </editor> <booktitle> Object-Oriented Programming: the CLOS Perspective, chapter 14, </booktitle> <pages> pages 335-348. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference-contexts: However, in a language where the compiler can tell which argument positions need dispatching (as in CLOS), one can implement multi-method dispatch as a chain of single dispatches <ref> [36] </ref>. If this is done, then there is no extra cost for multiple dispatch in programs that do not use it; that is, in a multiple-dispatching language, programs that only use single dispatch have the same cost as in a single-dispatching language.
Reference: [37] <author> Gary T. Leavens. </author> <title> Modular specification and verification of object-oriented programs. </title> <journal> IEEE Software, </journal> <volume> 8(4) </volume> <pages> 72-80, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Behavioral subtyping is a stronger relationship than subtyping, and, in addition to guarantees about lack of type errors, makes behavioral guarantees <ref> [4, 5, 38, 37, 41, 39] </ref>.
Reference: [38] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about object-oriented programs that use sub-types (extended abstract). </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> OOPSLA ECOOP '90 Proceedings, volume 25(10) of ACM SIGPLAN Notices, </booktitle> <pages> pages 212-223. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1990. </year>
Reference-contexts: Behavioral subtyping is a stronger relationship than subtyping, and, in addition to guarantees about lack of type errors, makes behavioral guarantees <ref> [4, 5, 38, 37, 41, 39] </ref>.
Reference: [39] <author> Gary T. Leavens and William E. Weihl. </author> <title> Specification and verification of object-oriented programs using supertype abstraction. </title> <journal> Acta Informatica, </journal> <note> 1994. To appear. An expanded version is Department of Computer Science, </note> <institution> Iowa State University, </institution> <type> Technical Report 92-28d, </type> <month> August </month> <year> 1994. </year>
Reference-contexts: Behavioral subtyping is a stronger relationship than subtyping, and, in addition to guarantees about lack of type errors, makes behavioral guarantees <ref> [4, 5, 38, 37, 41, 39] </ref>.
Reference: [40] <author> Barbara Liskov, Dorothy Curtis, Mark Day, Sanjay Ghemawat, Robert Gruber, Paul Johnson, and An-drew C. Myers. </author> <title> Theta reference manual. Technical Report Programming Methodology Group Memo 88, </title> <publisher> MIT, </publisher> <month> February </month> <year> 1995. </year>
Reference-contexts: This is similar to the sort procedure written with bounded matching. Object-oriented languages containing similar constructs are Emerald [10], School [50], and Theta <ref> [40] </ref>. Returning to our example with Point, if f (p: Point) is a function accepting an argument of type Point then it can often be rewritten in the form f (T &lt;#Point; p:T) so that it accepts a type parameter matching Point and an object of that type.
Reference: [41] <author> Barbara Liskov and Jeannette Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(6) </volume> <pages> 1811-1841, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Behavioral subtyping is a stronger relationship than subtyping, and, in addition to guarantees about lack of type errors, makes behavioral guarantees <ref> [4, 5, 38, 37, 41, 39] </ref>.
Reference: [42] <author> Narciso Mart-Oliet and Jose Meseguer. </author> <title> Inclusions and subtypes. </title> <type> Technical Report SRI-CSL-90-16, </type> <institution> Computer Science Laboratory, SRI International, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: ! T 1 ; S 2 ! T 2 ; : : : ; S n ! T n g satisfies the following condition. 6 8i; j 2 [1::n] if S i &lt;: S j then T i &lt;: T j (1) (This is similar to the monotonicity condition of <ref> [49, 42] </ref>.) Note that all the multi-methods defined in Figure 7 (and in particular equal ) satisfy this condition. Therefore ColorPoint &lt;: Point does not cause type insecurities.
Reference: [43] <author> Bertrand Meyer. </author> <title> Eiffel: the language. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: For Eiffel there is a proposal to compensate for the resulting insecurity in the type system by a link-time data-flow analysis of the program (called a system validity check), which would, if implemented, catch possible type errors <ref> [43] </ref>. But even if that were done, the "subtype" relation would have no clear meaning: Eiffel would claim ColorPoint to be a subtype of Point, but would not allow anything but a Point to be passed to breakit.
Reference: [44] <author> John Mitchell and Gordon Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3), </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: It remains to show how to package the class IntSetExposedClass so that the rep method can only be called by other instances of the same class. For this, we generalize Mitchell and Plotkin's motto that "abstract types have existential type" <ref> [44] </ref>, combining it with the idea of object interfaces as type operators from Cardelli and Wegner's partially abstract types [16]. The interface of the exposed integer set objects can be written as follows.
Reference: [45] <author> W. B. Mugridge, J. G. Hosking, and J. Hamer. </author> <title> Multi-methods in a statically-typed programming language. </title> <editor> In Pierre America, editor, </editor> <booktitle> ECOOP '91 Conference Proceedings, Geneva, Switzerland, volume 512 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In Sec 8 To appear in THEORY AND PRACTICE OF OBJECT SYSTEMS 1 (Number:3) tion 4.2.2 we show how to reconcile multi-methods with objects encapsulating data and code <ref> [17, 45] </ref>. Closely related to the solutions of Section 4.2 is In-galls' solution to the multiple dispatch problem [34]. He presented his solution in an untyped framework, but it can be adapted to a typed language, as Section 4.3 shows. <p> In this survey we distinguish two different kinds of multi-methods: the ones used by the language CLOS [27], and the encapsulated multi-methods of <ref> [17, 45] </ref>. A unified analysis of both kinds of multi-methods is given in [17]. <p> See the conclusion for further discussion of this issue. Some further consistency conditions are required in case of multiple inheritance <ref> [31, 45, 18, 22] </ref>. One of the main advantages of this approach is that the extra branch required to assure type safety of sub-typing can be generated in an automatic way.
Reference: [46] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: One type requirement that has been used to this end is that the types of methods may not be changed upon inheritance; this is done, for example, in C++ [52] Object Pascal [53], and Modula-3 <ref> [46] </ref>. In such languages, one cannot write ColorPointClass as in Figure 2, with the typing discussed above. Eiffel does allow argument types to be specialized in a subclass's methods; for example, it would allow ColorPointClass to be written as in Figure 2.
Reference: [47] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Statically typed friendly functions via partially abstract types. </title> <type> Technical Report ECS-LFCS-93-256, </type> <institution> University of Edinburgh, LFCS, </institution> <month> April </month> <year> 1993. </year> <note> Also available as INRIA-Rocquencourt Rapport de Recherche No. 1899. </note>
Reference-contexts: This section sketches a technique whereby such "overexposed objects" can be wrapped in an additional layer of abstraction, creating a limited scope in which their internal structure is visible. The technique was developed by Pierce and Turner <ref> [47] </ref> and by Katiyar, Luckham, and Mitchell [35]; we refer the reader to these papers for further details. In particular, [47] demonstrates that the mechanism shown here is compatible with inheritance (though it requires some additional machinery). <p> The technique was developed by Pierce and Turner <ref> [47] </ref> and by Katiyar, Luckham, and Mitchell [35]; we refer the reader to these papers for further details. In particular, [47] demonstrates that the mechanism shown here is compatible with inheritance (though it requires some additional machinery). These ideas give a semantic basis for some aspects of the encapsulation via friends found in C++ and the encapsulation in Cecil [20].
Reference: [48] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented To appear in THEORY AND PRACTICE OF OBJECT SYSTEMS 1(Number:3) 23 programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <month> April </month> <year> 1994. </year> <note> A preliminary version appeared in Principles of Programming Languages, </note> <year> 1993, </year> <title> and as University of Edinburgh technical report ECS-LFCS-92-225, under the title "Object-Oriented Programming Without Recursive Types". </title>
Reference-contexts: In this case, the classic encoding of object types as recursive records [15, 25] may be replaced by an encoding where objects are modeled by existential types <ref> [48, 33] </ref>. It may also be argued that keeping binary operations separate from their arguments avoids conceptual confusion.
Reference: [49] <author> John Reynolds. </author> <title> Three approaches to type structure. </title> <booktitle> In Mathematical Foundations of Software Development. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <note> Lecture Notes in Computer Science No. 185. </note>
Reference-contexts: Informally, a type is a subtype of t , written &lt;: t , if an expression of type can be used in any context that expects an expression of type t (cf. <ref> [15, 16, 49] </ref>). Associated with subtyping is the principle of subsump-tion (subtype polymorphism): if &lt;: t and a program fragment has type , it also has type t . <p> ! T 1 ; S 2 ! T 2 ; : : : ; S n ! T n g satisfies the following condition. 6 8i; j 2 [1::n] if S i &lt;: S j then T i &lt;: T j (1) (This is similar to the monotonicity condition of <ref> [49, 42] </ref>.) Note that all the multi-methods defined in Figure 7 (and in particular equal ) satisfy this condition. Therefore ColorPoint &lt;: Point does not cause type insecurities. <p> branches c 1 ; c 2 with the same name and number of arguments, 10 if the parameter types of c 1 are smaller than the corresponding parameter types of c 2 , then the result type of c 1 must be smaller than the result type of c 2 <ref> [49, 18] </ref>. important to be clear that, in the formalization we use, a new definition of a (multi-)method completely overrides the old one (i.e. it is not possible to inherit some branches and override others: this could by obtained by adding some extra syntax.) 8 This example is due to John
Reference: [50] <author> N. Rodriguez, R. Ierusalimschy, and J. L. Rangel. </author> <title> Types in school. </title> <journal> SIGPLAN Notices, </journal> <volume> 28(8), </volume> <year> 1993. </year>
Reference-contexts: This is similar to the sort procedure written with bounded matching. Object-oriented languages containing similar constructs are Emerald [10], School <ref> [50] </ref>, and Theta [40].
Reference: [51] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An introduction to Trellis/Owl. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> OOP-SLA '86 Conference Proceedings, </booktitle> <address> Portland, Ore-gon, </address> <month> September </month> <year> 1986, </year> <journal> volume 21(11) of ACM SIG-PLAN Notices, </journal> <pages> pages 9-16. </pages> <publisher> ACM, </publisher> <month> November </month> <year> 1986. </year>
Reference-contexts: That is, it means Link in the class LinkClass, but means DoubleLink in the class DoubleLinkClass and in the instance variables and methods it inherits from LinkClass. MyType will be discussed in more detail in Section 4.1 below; also cf. <ref> [51, 12, 13, 29] </ref>. The objects now have only one interesting method, append , which is inherited by DoubleLinkClass. This method uses setNext , a binary method, to set the pointer next, and setNext is overridden in DoubleLinkClass to also properly maintain the prev link to the previous object. <p> Most object-oriented languages provide a name for the receiver of a message (e.g., self or this), which can be used inside method bodies. Similarly, we use MyType as a keyword that denotes the type of the receiver <ref> [51] </ref>. It may be used in the definition of methods whose parameters or return types should be the same as that of the receiver.
Reference: [52] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass, </address> <year> 1986. </year>
Reference-contexts: One type requirement that has been used to this end is that the types of methods may not be changed upon inheritance; this is done, for example, in C++ <ref> [52] </ref> Object Pascal [53], and Modula-3 [46]. In such languages, one cannot write ColorPointClass as in Figure 2, with the typing discussed above. Eiffel does allow argument types to be specialized in a subclass's methods; for example, it would allow ColorPointClass to be written as in Figure 2.
Reference: [53] <author> Larry Tesler. </author> <title> Object Pascal report. </title> <type> Technical Report 1, </type> <institution> Apple Computer, </institution> <year> 1985. </year>
Reference-contexts: One type requirement that has been used to this end is that the types of methods may not be changed upon inheritance; this is done, for example, in C++ [52] Object Pascal <ref> [53] </ref>, and Modula-3 [46]. In such languages, one cannot write ColorPointClass as in Figure 2, with the typing discussed above. Eiffel does allow argument types to be specialized in a subclass's methods; for example, it would allow ColorPointClass to be written as in Figure 2.
References-found: 53

