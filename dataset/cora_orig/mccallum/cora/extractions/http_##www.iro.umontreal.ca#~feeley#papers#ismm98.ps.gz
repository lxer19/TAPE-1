URL: http://www.iro.umontreal.ca/~feeley/papers/ismm98.ps.gz
Refering-URL: http://www.iro.umontreal.ca/~feeley/
Root-URL: http://www.iro.umontreal.ca
Email: flarosem,feeleyg@iro.umontreal.ca  
Title: A Compacting Incremental Collector and its Performance in a Production Quality Compiler  
Author: Martin Larose and Marc Feeley 
Address: Montreal  
Affiliation: Departement d'informatique et recherche operationnelle Universite de  
Abstract: We present a new near-real-time compacting collector and its implementation in a production quality Scheme compiler (Gambit-C). Our goal is to use this system as a base for an implementation of Erlang for writing soft real-time telecommunication applications. We start with a description of Gambit-C's memory organisation and its blocking collector. The design and integration of the incremental collector within Gambit-C are then explained. Finally we measure the performance of the incremental collector and compare it to the original blocking collector. We found that the overhead of the incremental collector is high (a factor of 1.3 to 8.1, with a median of 2.24) but nevertheless the collection pauses are compatible with typical soft real-time requirements (we get an average pause of 3.25 milliseconds and a maximum pause of 18 milliseconds on a 133Mhz DEC Alpha 21064). 
Abstract-found: 1
Intro-found: 1
Reference: [AVWW96] <author> J. L. Armstrong, S. R. Virding, C. Wikstrom, and M. C. Williams. </author> <title> Concurrent Programming in Erlang. </title> <publisher> Prentice Hall, </publisher> <address> second edition, </address> <year> 1996. </year>
Reference-contexts: This paper reports on the various tradeoffs we made and the performance of the collector on a wide range of benchmarks. 2 Context The work reported in this paper is part of a larger effort to implement a compiler for Erlang <ref> [AVWW96] </ref>, a concurrent mostly functional programming language for real-time telecommunication applications developed at Erics-son. Our compiler, called Etos [FL98], first compiles Erlang to Scheme and then uses the Gambit-C Scheme compiler [FM90, FMRW97] to compile the result into C.
Reference: [AXD98] <institution> AXD 301 High-performance ATM switching system. Ericsson Telecom AB, </institution> <year> 1998. </year>
Reference-contexts: These constraints are sufficient to write in Erlang the control software of an ATM switch (such as the AXD301 <ref> [AXD98] </ref> which aims to process each transaction within 7 milliseconds). To improve responsiveness we designed an incremental compacting collector for Gambit-C to replace the blocking collector in the standard distribution. Given the application domain and use of a functional programming style, we anticipated high allocation rates.
Reference: [BW88] <author> Hans-Juergen Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <year> 1988. </year>
Reference-contexts: Still: the object is never moved 3. Permanent: the object is never moved or reclaimed The allure of still objects is that C code can easily manipulate them without worrying about their address suddenly becoming invalid after the collector is run (a conservative GC approach such as <ref> [BW88] </ref> is not an acceptable solution because it is not portable). Still objects have a reference count field which indicates how many references from the "C world" exist to this object (to prevent the collector from reclaiming them if they are not reachable from the "Scheme world").
Reference: [Che70] <author> C. J. </author> <title> Cheney. A non-recursive list compacting algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 13(11) </volume> <pages> 677-8, </pages> <month> November </month> <year> 1970. </year>
Reference-contexts: A list of all marked but not yet scanned still objects is also maintained by the collector (this explains why still objects have 2 link fields). The movable objects are handled by a Cheney-style copying algorithm <ref> [Che70] </ref> which overwrites the header with the forwarding pointer. Control alternates between the stop-and-copy and mark-and-sweep algorithms until the list of all marked but not yet scanned still objects is empty and there are no remaining movable objects that have been copied to to-space but have not yet been scanned.
Reference: [DFS96] <author> Danny Dube, Marc Feeley, and Manuel Ser-rano. </author> <title> Un GC temps reel semi-compactant. </title> <editor> In Guy Lapalme and Christian Queinnec, editors, Journees Francophones des Langages Ap-plicatifs, </editor> <volume> volume 7, </volume> <pages> pages 165-181, </pages> <address> Val-Morin, Quebec, </address> <month> Janvier </month> <year> 1996. </year> <note> INRIA. </note>
Reference-contexts: To improve responsiveness we designed an incremental compacting collector for Gambit-C to replace the blocking collector in the standard distribution. Given the application domain and use of a functional programming style, we anticipated high allocation rates. Our incremental collector is a refinement of Dube's collector <ref> [Dub96, DFS96] </ref>, an incremental collector developed for a small footprint interpreter-based Scheme implementation for embedded 8 bit controllers. 3 Gambit-C's Blocking Collector Gambit-C was designed to be a very portable compiler (the code generated sticks to ANSI-C and uses few OS specific features) and to allow Scheme and C code to <p> The user can configure the resizing ratio, as well as the minimum and maximum heap size, when the program is launched. 4 Integrating the Collector Into Gambit-C In replacing Gambit-C's blocking collector with Dube's collector <ref> [DFS96] </ref> we had two goals: adapt the collector to a production quality compiler and measure the performance of the collector in a realistic setting. This section describes how Dube's collector was modified. <p> Moreover, it guarantees that R i 1+L 2 . This is easy to prove by induction (see <ref> [DFS96] </ref> for a proof). An interesting corollary is that the collector can stay idle at the start of the collection cycle until the mutator has allocated enough objects to make the heap occupied to 1+L 2 .
Reference: [DLM + 78] <author> Edsgar W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. </author> <title> On-the-fly garbage collection: An exercise in cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 965-975, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: We have experimented with two write barriers to handle this case. 1. Gray X. Here the white object X is grayed by putting it in the marking list. This is the original barrier proposed by Dube and is similar to Dijkstra's barrier <ref> [DLM + 78] </ref>. 2. Gray Y . Here the black object Y is grayed by putting it back in the marking list. This is similar to Steele's barrier [Ste75]. This is less conservative than graying X (i.e.
Reference: [Dub96] <author> Danny Dube. </author> <title> Un systeme de programmation Scheme pour micro-controleur. </title> <type> Master's thesis, </type> <institution> Departement d'Informatique et de Recherche Operationnelle, Universite de Montreal, </institution> <month> April </month> <year> 1996. </year>
Reference-contexts: To improve responsiveness we designed an incremental compacting collector for Gambit-C to replace the blocking collector in the standard distribution. Given the application domain and use of a functional programming style, we anticipated high allocation rates. Our incremental collector is a refinement of Dube's collector <ref> [Dub96, DFS96] </ref>, an incremental collector developed for a small footprint interpreter-based Scheme implementation for embedded 8 bit controllers. 3 Gambit-C's Blocking Collector Gambit-C was designed to be a very portable compiler (the code generated sticks to ANSI-C and uses few OS specific features) and to allow Scheme and C code to
Reference: [Fee93] <author> Marc Feeley. </author> <title> Polling efficiently on stock hardware. </title> <booktitle> In Proceedings of the Functional Programming and Computer Architecture, </booktitle> <pages> pages 179-187, </pages> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: However, an overhead is added to the mutator for every access to the object. The overhead we measured is reported in Section 5. Because Gambit-C handles interrupts through polling <ref> [Fee93] </ref> and that polling points and heap limit checks can only occur at the end of basic-blocs, it is possible to maintain direct pointers to the movable part of objects temporarily (for the duration of a basic-bloc).
Reference: [FL98] <author> Marc Feeley and Martin Larose. </author> <title> Compiling Er-lang to Scheme. </title> <booktitle> In Proceedings of the 1998 Programming Languages, Implementations, Logics and Programs Conference, </booktitle> <month> September </month> <year> 1998. </year>
Reference-contexts: Our compiler, called Etos <ref> [FL98] </ref>, first compiles Erlang to Scheme and then uses the Gambit-C Scheme compiler [FM90, FMRW97] to compile the result into C. This approach is reasonable and efficient because Scheme and Er-lang share many similarities (e.g. use of functional style, dynamic typing, data types). <p> However this overhead must be put in perspective. Erlang programs compiled with Etos and Gambit-C 2.7 with the S&C collector are roughly 15 times faster than with the JAM 4.4.1 bytecode implementation of Erlang <ref> [FL98] </ref>. Even if a program using the incremental collector is slowed down by a factor of 2.24 compared to the S&C collector, the program is still over 6 times faster than when using JAM. Of course the overhead and pause time that is tolerable depends on the application.
Reference: [FM90] <author> Marc Feeley and James S. Miller. </author> <title> A parallel virtual machine for efficient Scheme compilation. </title> <booktitle> In Conference Record of the 1990 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 119-130, </pages> <address> Nice, France, June 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Our compiler, called Etos [FL98], first compiles Erlang to Scheme and then uses the Gambit-C Scheme compiler <ref> [FM90, FMRW97] </ref> to compile the result into C. This approach is reasonable and efficient because Scheme and Er-lang share many similarities (e.g. use of functional style, dynamic typing, data types). <p> The compiler uses an RTL-style virtual machine code (GVM <ref> [FM90] </ref>) as an intermediate representation and then translates each virtual instruction into the corresponding C code (the concept of virtual machine registers is important here because they are roots of the collector).
Reference: [FMRW97] <author> M. Feeley, J. Miller, G. Rozas, and J. Wil-son. </author> <title> Compiling Higher-Order Languages into Fully Tail-Recursive Portable C. </title> <type> Technical Report 1078, </type> <institution> Departement d'Informatique et de Recherche Operationnelle, Universite de Montreal, </institution> <month> Ao^ut </month> <year> 1997. </year>
Reference-contexts: Our compiler, called Etos [FL98], first compiles Erlang to Scheme and then uses the Gambit-C Scheme compiler <ref> [FM90, FMRW97] </ref> to compile the result into C. This approach is reasonable and efficient because Scheme and Er-lang share many similarities (e.g. use of functional style, dynamic typing, data types). <p> For portability, the Scheme heap (which contains all the reclaimable Scheme objects) is allocated from the C heap by using the malloc C library routine. 3.1 The Stack-Cache In order to properly handle tail-calls (see <ref> [FMRW97] </ref> for details) and to provide efficient first-class continuations, Gambit-C allocates continuation frames in a 36 Kbyte stack-cache which is separate from the C stack.
Reference: [Gab85] <author> Richard P. Gabriel. </author> <title> Performance and Evaluation of Lisp Systems. </title> <publisher> MIT Press Series in Computer Science. MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: The short running programs were modified to repeat the computation several times so that the total execution time would be at least 5 seconds. A first group of programs comes from the Gabriel benchmark suite <ref> [Gab85] </ref>. These programs are mostly kernels which stress specific features of the system (fixnum arithmetic, allocation, traversal, mutation, recursion, iteration). Some of these benchmarks don't perform any allocation so we ignored them (tak, takl, triangle, and the traversal phase of traverse).
Reference: [HDB90] <author> R. Hieb, R. K. Dybvig, and C. Bruggeman. </author> <title> Representing control in the presence of first-class continuations. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(6) </volume> <pages> 66-77, </pages> <year> 1990. </year>
Reference-contexts: When a continuation is captured with a call to call-with-current-continuation the base of the stack-cache is temporarily moved up so that any return to one of the captured continuation frames will cause it to be copied to the top of the stack-cache. This technique is basically the same as <ref> [HDB90] </ref> but of a finer granularity. 3.2 Memory Partitioning There are three allocation classes for Scheme objects: 1. Movable: the object may be moved by the collector 2. Still: the object is never moved 3.
Reference: [HFA + 96] <author> Pieter H. Hartel, Marc Feeley, Martin Alt, Lennart Augustsson, Peter Baumann, Mar-cel Beemster, Emmanuel Chailloux, Chris-tine H. Flood, Wolfgang Grieskamp, John H. G. van Groningen, Kevin Hammond, Bogumi lHausman, Melody Y. Ivory, Richard Jones, Peter Lee, Xavier Leroy, Rafael Lins, Sandra Loosemore, Niklas Rojemo, Manuel Serrano, Jean-Pierre Talpin, Jon Thackray, Stephen Thomas, Pierre Weis, and Peter Went-worth. </author> <title> Benchmarking implementations of functional languages with "pseudoknot", a float-intensive benchmark. </title> <journal> Journal of Functional Programming, </journal> <volume> 6(4), </volume> <year> 1996. </year>
Reference-contexts: Most constant-size allocation primitives (cons, list and vector but not make-vector) are inlined by the compiler. The compiler also keeps floating point numbers in an unboxed state within each basic block, which greatly reduces the need for allocating flonums (boxed floating point numbers) on some floating-point intensive programs <ref> [HFA + 96] </ref>. Gambit-C allows the Scheme heap to grow and shrink dynamically as the program's needs change. For this reason, we opted not to implement the Scheme heap as one large block because this would cause severe fragmentation given that C code also allocates objects in the C heap.
Reference: [NO93] <author> Scott Nettles and James O'Toole. </author> <title> Real-time replication garbage collection. </title> <booktitle> In Proceedings of the 1993 SIGPLAN Conference on Programming Language Design and Implementation. Published in SIGPLAN Notices, </booktitle> <volume> volume 28, </volume> <pages> pages 217-226, </pages> <address> Albuquerque, New Mexico, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: There is also a need for testing the collector with soft real-time Erlang applications. This will have to wait until Etos is complete and robust. Once Dube's collector is fully integrated into Gambit-C, we plan to integrate other near real-time collectors (in particular <ref> [NO93] </ref> which seems well suited to our context) and compare their performance. As our experimental results show, the incremental collector is able to meet the maximum and average pause time constraints needed by telecommunication applications.
Reference: [Ste75] <author> Guy L. Steele, Jr. </author> <title> Multiprocessing compactify-ing garbage collection. </title> <journal> Communications of the ACM, </journal> <volume> 18(9) </volume> <pages> 495-508, </pages> <month> September </month> <year> 1975. </year>
Reference-contexts: This is the original barrier proposed by Dube and is similar to Dijkstra's barrier [DLM + 78]. 2. Gray Y . Here the black object Y is grayed by putting it back in the marking list. This is similar to Steele's barrier <ref> [Ste75] </ref>. This is less conservative than graying X (i.e. X will possibly be reclaimed if the reference to X in Y is overwritten).
References-found: 16

