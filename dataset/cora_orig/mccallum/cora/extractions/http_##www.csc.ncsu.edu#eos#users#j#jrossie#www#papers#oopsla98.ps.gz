URL: http://www.csc.ncsu.edu/eos/users/j/jrossie/www/papers/oopsla98.ps.gz
Refering-URL: http://www.csc.ncsu.edu/eos/users/j/jrossie/www/interests.html
Root-URL: http://www.csc.ncsu.edu
Email: jrossie@csc.ncsu.edu  
Title: Logical Observable Entities  
Author: Jonathan G. Rossie Jr. 
Affiliation: North Carolina State University  
Abstract: We show how finite-state machines can standardize the protocol used by a component object to notify other interested objects of its state changes, resulting in a more effective use of static types to constrain both parties, and a more efficient dissemination of information. The enhanced component specification is called a logical observable entity, or LOE. We address two key issues in effectively applying such a strategy: how to extend subtyping to consider the state machines, and how to ensure some kind of compliance between the state-machine specification and its implementation. This leads to an unusual subtyping predicate for LOEs on the one hand, and a prototype code generation strategy on the other. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martjn Abadi and Luca Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Designing type systems that are both expressive and provably safe requires some care. The exploration of such type systems for object-oriented languages has been a continuing area of interest <ref> [1, 3, 4, 5, 8, 12, 30] </ref>. An intuitive basis for subtyping in object-oriented systems is given by Wegner and Zdonik [42]: An instance of a subtype can always be used in any context in which an instance of a supertype was expected.
Reference: [2] <author> Gul Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass, </address> <year> 1986. </year>
Reference-contexts: The second thread arises directly from issues in object-oriented concurrency. Nierstrasz's regular types [27] use logical finite-state machines (or regular expressions) as the basis for an extended notion of types for active objects. Starting with distributed objects in the spirit of actors <ref> [2] </ref>, Nierstrasz uses logical states to describe the dynamic availability of the object's methods. This is a kind of behavioral subtyping in which the logical states play the role of a partial specification. Subtypes in his system are, again, defined in terms of traces.
Reference: [3] <author> Kim B. Bruce, Angela Schuett, and Robert van Gent. Poly-TOIL: </author> <title> A type-safe polymorphic object-oriented language. </title> <editor> In W. Olthoff, editor, </editor> <booktitle> Proceedings of the 9th European Conference on Object-Oriented Programming (ECOOP '95), </booktitle> <pages> pages 2751. </pages> <publisher> LNCS 952, Springer-Verlag, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: Designing type systems that are both expressive and provably safe requires some care. The exploration of such type systems for object-oriented languages has been a continuing area of interest <ref> [1, 3, 4, 5, 8, 12, 30] </ref>. An intuitive basis for subtyping in object-oriented systems is given by Wegner and Zdonik [42]: An instance of a subtype can always be used in any context in which an instance of a supertype was expected.
Reference: [4] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. Information and Computation, </title> <address> 76(2/3):138164, </address> <month> February/March </month> <year> 1988. </year>
Reference-contexts: Designing type systems that are both expressive and provably safe requires some care. The exploration of such type systems for object-oriented languages has been a continuing area of interest <ref> [1, 3, 4, 5, 8, 12, 30] </ref>. An intuitive basis for subtyping in object-oriented systems is given by Wegner and Zdonik [42]: An instance of a subtype can always be used in any context in which an instance of a supertype was expected.
Reference: [5] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4):471522, </volume> <year> 1985. </year>
Reference-contexts: Designing type systems that are both expressive and provably safe requires some care. The exploration of such type systems for object-oriented languages has been a continuing area of interest <ref> [1, 3, 4, 5, 8, 12, 30] </ref>. An intuitive basis for subtyping in object-oriented systems is given by Wegner and Zdonik [42]: An instance of a subtype can always be used in any context in which an instance of a supertype was expected.
Reference: [6] <author> Rance Cleaveland, Joachim Parrow, and Bernhard Steffen. </author> <title> The concurrency workbench: A semantics based tool for the verification of concurrent systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1):3672, </volume> <year> 1993. </year>
Reference-contexts: There, substitutability is generally described in terms of bisimulation, and has a much stronger sense than subtyping; it essentially means complete observable equivalence <ref> [6, 10, 25] </ref>. The recent efforts at synthesis begin with either stat-echarts [21, 41], regular types [31], or both [34], and offer translations of those ideas into labelled transition systems or the - calculus [26]. None of these researchers has addressed anything like the problem of efferent types described here.
Reference: [7] <author> Derek Coleman, Fiona Hayes, and Stephen Bear. </author> <title> Introducing Objectcharts, or How to use statecharts in object-oriented design. </title> <journal> IEEE Transactions on Software Engineering (TSE), </journal> <volume> 18(1):918, </volume> <month> January </month> <year> 1992. </year>
Reference-contexts: In fact, several authors have offered definitions of subtyping that account, in some way, for the dynamic availability of services that a logical state machine represents <ref> [7, 15, 27, 31, 32, 34] </ref>. A common foundation among most of these approaches is the notion of traces, which are the sequences of messages that a machine can legally receive. A subtype must be able to accept at least the traces of its supertype. <p> The first thread is centered on Harel's statecharts: a compos-able, visual formalism for describing state machines for software 9 designs [14, 16]. Created for use in designing reactive systems [17], statecharts were soon being applied in object-oriented analysis and design as well <ref> [7, 15] </ref>. In fact, something like statecharts have been present in many of the leading methodologies for OOA and OOD [33, 37, 39]. <p> In fact, something like statecharts have been present in many of the leading methodologies for OOA and OOD [33, 37, 39]. A special notion of subtyping has been developed for classes enhanced with statecharts <ref> [7] </ref>: the subtype is expected to accept the same sequences of messages (traces) as its supertype. Design patterns and implementation strategies have also been proposed for coding such classes [9, 13].
Reference: [8] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1990. </year>
Reference-contexts: Designing type systems that are both expressive and provably safe requires some care. The exploration of such type systems for object-oriented languages has been a continuing area of interest <ref> [1, 3, 4, 5, 8, 12, 30] </ref>. An intuitive basis for subtyping in object-oriented systems is given by Wegner and Zdonik [42]: An instance of a subtype can always be used in any context in which an instance of a supertype was expected.
Reference: [9] <author> Stephen R. Davis. </author> <title> C++ objects that change their type. </title> <journal> The Journal of Object-Oriented Programming, </journal> <pages> pages 2732, </pages> <month> July/August </month> <year> 1992. </year>
Reference-contexts: A special notion of subtyping has been developed for classes enhanced with statecharts [7]: the subtype is expected to accept the same sequences of messages (traces) as its supertype. Design patterns and implementation strategies have also been proposed for coding such classes <ref> [9, 13] </ref>. Some authors have addressed the particular challenges of inheriting the state-machine implementation code [15, 38], a problem remarkably similar to the so-called inheritance anomaly in concurrent object-oriented languages [22, 23]. The second thread arises directly from issues in object-oriented concurrency.
Reference: [10] <author> Rocco de Nicola. </author> <title> Extensional equivalences for transition systems. </title> <journal> Acta Informatica, </journal> <volume> 24(2):211237, </volume> <year> 1987. </year>
Reference-contexts: There, substitutability is generally described in terms of bisimulation, and has a much stronger sense than subtyping; it essentially means complete observable equivalence <ref> [6, 10, 25] </ref>. The recent efforts at synthesis begin with either stat-echarts [21, 41], regular types [31], or both [34], and offer translations of those ideas into labelled transition systems or the - calculus [26]. None of these researchers has addressed anything like the problem of efferent types described here.
Reference: [11] <author> Krishna Kishore Dhara and Gary T. Leavens. </author> <title> Forcing behavioral subtyping through specification inheritance. </title> <type> Technical Report TR #95-20c, </type> <institution> Department of Computer Science, Iowa State University, </institution> <year> 1995. </year> <note> Revised, </note> <year> 1997. </year>
Reference-contexts: In Eiffel, for example, pre- and post-conditions may be specified for methods, and subclasses may neither strengthen the preconditions nor weaken the postconditions of methods they override [24]. Leavens, Liskov and others have referred to such extended notions of subtyping as behavioral subtyping <ref> [11, 19, 20] </ref>. By adding a state machine to an ordinary class definition, an LOE provides a form of semantic specification that can form the basis for behavioral subtyping.
Reference: [12] <author> Kathleen Fisher and John C. Mitchell. </author> <title> The development of type systems for object-oriented languages. Theory and Practice of Object Systems, </title> <address> 1(3):189220, </address> <year> 1995. </year>
Reference-contexts: Designing type systems that are both expressive and provably safe requires some care. The exploration of such type systems for object-oriented languages has been a continuing area of interest <ref> [1, 3, 4, 5, 8, 12, 30] </ref>. An intuitive basis for subtyping in object-oriented systems is given by Wegner and Zdonik [42]: An instance of a subtype can always be used in any context in which an instance of a supertype was expected.
Reference: [13] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlis-sides. </author> <title> Design Patterns : Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: The solution, naturally, is for view objects to register with the model objects that concern them. In the design patterns community, this pattern of object interaction is known as the Observer pattern <ref> [13] </ref>, where the anonymous To appear in OOPSLA '98, the Thirteenth Annual ACM Conference on Object-Oriented Programming, Systems, Languages and Applications, October 1822, 1998, Vancouver, British Columbia, Canada. <p> LOLA also automates the registering and unregistering of observers, the generation of detailed notifications, and the customization of notifications to different kinds of observers. This is a far greater level of sophistication than we could ever expect from most hand-coded versions of the Observer or State design patterns <ref> [13] </ref>. From the other side, clients can be relatively sure that an implementation will behave reasonably, at least with respect to its state machine. Certainly, a pathological implementation might never make transitions, might diverge, might throw unexpected exceptions, or might signal empty/screwIn/good when it screws-in a bad bulb. <p> A special notion of subtyping has been developed for classes enhanced with statecharts [7]: the subtype is expected to accept the same sequences of messages (traces) as its supertype. Design patterns and implementation strategies have also been proposed for coding such classes <ref> [9, 13] </ref>. Some authors have addressed the particular challenges of inheriting the state-machine implementation code [15, 38], a problem remarkably similar to the so-called inheritance anomaly in concurrent object-oriented languages [22, 23]. The second thread arises directly from issues in object-oriented concurrency.
Reference: [14] <author> David Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <pages> pages 231274, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: The two significant threads both come from concurrency research, where finite-state machines are frequently used to manage the complexity of coordinating distributed processes. The first thread is centered on Harel's statecharts: a compos-able, visual formalism for describing state machines for software 9 designs <ref> [14, 16] </ref>. Created for use in designing reactive systems [17], statecharts were soon being applied in object-oriented analysis and design as well [7, 15]. In fact, something like statecharts have been present in many of the leading methodologies for OOA and OOD [33, 37, 39].
Reference: [15] <author> David Harel and Eran Gery. </author> <title> Executable object modeling with statecharts. </title> <journal> IEEE Computer, </journal> <volume> 30(7):3142, </volume> <month> July </month> <year> 1997. </year>
Reference-contexts: In fact, several authors have offered definitions of subtyping that account, in some way, for the dynamic availability of services that a logical state machine represents <ref> [7, 15, 27, 31, 32, 34] </ref>. A common foundation among most of these approaches is the notion of traces, which are the sequences of messages that a machine can legally receive. A subtype must be able to accept at least the traces of its supertype. <p> The first thread is centered on Harel's statecharts: a compos-able, visual formalism for describing state machines for software 9 designs [14, 16]. Created for use in designing reactive systems [17], statecharts were soon being applied in object-oriented analysis and design as well <ref> [7, 15] </ref>. In fact, something like statecharts have been present in many of the leading methodologies for OOA and OOD [33, 37, 39]. <p> Design patterns and implementation strategies have also been proposed for coding such classes [9, 13]. Some authors have addressed the particular challenges of inheriting the state-machine implementation code <ref> [15, 38] </ref>, a problem remarkably similar to the so-called inheritance anomaly in concurrent object-oriented languages [22, 23]. The second thread arises directly from issues in object-oriented concurrency. Nierstrasz's regular types [27] use logical finite-state machines (or regular expressions) as the basis for an extended notion of types for active objects.
Reference: [16] <author> David Harel and Amnon Naamad. </author> <title> The STATEMATE semantics of statecharts. </title> <journal> ACM Transactions on Software Engineering and Methodology (TOSEM), </journal> <volume> 5(4):293333, </volume> <month> October </month> <year> 1996. </year>
Reference-contexts: The two significant threads both come from concurrency research, where finite-state machines are frequently used to manage the complexity of coordinating distributed processes. The first thread is centered on Harel's statecharts: a compos-able, visual formalism for describing state machines for software 9 designs <ref> [14, 16] </ref>. Created for use in designing reactive systems [17], statecharts were soon being applied in object-oriented analysis and design as well [7, 15]. In fact, something like statecharts have been present in many of the leading methodologies for OOA and OOD [33, 37, 39].
Reference: [17] <author> David Harel and Amir Pnueli. </author> <title> On the development of reactive systems. </title> <editor> In Krzysztof R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, volume F13 of NATO ASI Series, </booktitle> <pages> pages 477498. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: The first thread is centered on Harel's statecharts: a compos-able, visual formalism for describing state machines for software 9 designs [14, 16]. Created for use in designing reactive systems <ref> [17] </ref>, statecharts were soon being applied in object-oriented analysis and design as well [7, 15]. In fact, something like statecharts have been present in many of the leading methodologies for OOA and OOD [33, 37, 39].
Reference: [18] <author> Glenn E. Krasner and Stephen T. Pope. </author> <title> A cookbook for using the model/view/controller user interface paradigm in Smalltalk-80. Journal of Object Oriented Programming, </title> <address> 1(3):2649, </address> <year> 1988. </year>
Reference-contexts: Often, in fact, the client may register several such receivers with a given component, possibly with different behaviors. Perhaps the best-known example of this framework is the Model/View/Controller paradigm for developing object-oriented graphical user interfaces <ref> [18] </ref>. In this paradigm, objects in the modelobjects that represent elements of the application domainare developed without regard for a specific view library, but are responsible for notifying view objects whenever they change in an interesting way.
Reference: [19] <author> Barbara Liskov. </author> <title> Data abstraction and hierarchy. </title> <journal> ACM SIG-PLAN Notices, </journal> <volume> 23(5), </volume> <booktitle> 1988. OOPSLA '87 Addendum to Proceedings: </booktitle> <publisher> keynote address. </publisher>
Reference-contexts: In Eiffel, for example, pre- and post-conditions may be specified for methods, and subclasses may neither strengthen the preconditions nor weaken the postconditions of methods they override [24]. Leavens, Liskov and others have referred to such extended notions of subtyping as behavioral subtyping <ref> [11, 19, 20] </ref>. By adding a state machine to an ordinary class definition, an LOE provides a form of semantic specification that can form the basis for behavioral subtyping.
Reference: [20] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(6):18111841, </volume> <year> 1994. </year>
Reference-contexts: Consequently, queries don't appear in the generated observer interfaces, while commands do. (Ironically, some authors refer to queries as observers <ref> [20] </ref>.) Our quick analysis of the lightbulb object can be summarized in the following dictionary, which also provides useful abbreviations: Bulb states G good B blown queries r getResistance () : Ohms commands p consume (p:Pulse) We now specify the dynamic availability of methods using a finite state machine. <p> In Eiffel, for example, pre- and post-conditions may be specified for methods, and subclasses may neither strengthen the preconditions nor weaken the postconditions of methods they override [24]. Leavens, Liskov and others have referred to such extended notions of subtyping as behavioral subtyping <ref> [11, 19, 20] </ref>. By adding a state machine to an ordinary class definition, an LOE provides a form of semantic specification that can form the basis for behavioral subtyping.
Reference: [21] <author> Andrea Maggiolo-Schettini, Adriano Peron, and Simone Tini. </author> <title> Equivalences of statecharts. </title> <editor> In Ugo Montanari and Vladimiro Sassone, editors, </editor> <booktitle> CONCUR '96: Concurrency Theory, 7th International Conference. </booktitle> <publisher> LNCS 1119, Springer-Verlag, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: There, substitutability is generally described in terms of bisimulation, and has a much stronger sense than subtyping; it essentially means complete observable equivalence [6, 10, 25]. The recent efforts at synthesis begin with either stat-echarts <ref> [21, 41] </ref>, regular types [31], or both [34], and offer translations of those ideas into labelled transition systems or the - calculus [26]. None of these researchers has addressed anything like the problem of efferent types described here.
Reference: [22] <author> Satoshi Matsuoka, Kenjiro Taura, and Akinori Yonezawa. </author> <title> Highly efficient and encapsulated re-use of synchronization code in concurrent object-oriented languages. </title> <booktitle> In Paepcke [29], </booktitle> <pages> pages 109126. </pages>
Reference-contexts: As we discuss in Section 7, this is closely related to the use of guards or enabled sets in synchronization code for concurrent objects <ref> [22, 23, 40] </ref>. An important difference is that these techniques tend to partition the methods dynamically, according to the values of boolean expressions involving instance variables. Instead, we simply partition the methods according to the logical states we have defined, and allow individual implementations to resolve whatever nondeterminism we introduce. <p> Design patterns and implementation strategies have also been proposed for coding such classes [9, 13]. Some authors have addressed the particular challenges of inheriting the state-machine implementation code [15, 38], a problem remarkably similar to the so-called inheritance anomaly in concurrent object-oriented languages <ref> [22, 23] </ref>. The second thread arises directly from issues in object-oriented concurrency. Nierstrasz's regular types [27] use logical finite-state machines (or regular expressions) as the basis for an extended notion of types for active objects.
Reference: [23] <author> Satoshi Matsuoka and Akinori Yonezawa. </author> <title> Analysis of inheritance anomaly in object-oriented concurrent programming languages. </title> <editor> In Gul Agha, Peter Wegner, and Aki-nori Yonezawa, editors, </editor> <booktitle> Reseaarch Directions in Concurrent Object-Oriented Programming, </booktitle> <pages> pages 107150. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: As we discuss in Section 7, this is closely related to the use of guards or enabled sets in synchronization code for concurrent objects <ref> [22, 23, 40] </ref>. An important difference is that these techniques tend to partition the methods dynamically, according to the values of boolean expressions involving instance variables. Instead, we simply partition the methods according to the logical states we have defined, and allow individual implementations to resolve whatever nondeterminism we introduce. <p> Design patterns and implementation strategies have also been proposed for coding such classes [9, 13]. Some authors have addressed the particular challenges of inheriting the state-machine implementation code [15, 38], a problem remarkably similar to the so-called inheritance anomaly in concurrent object-oriented languages <ref> [22, 23] </ref>. The second thread arises directly from issues in object-oriented concurrency. Nierstrasz's regular types [27] use logical finite-state machines (or regular expressions) as the basis for an extended notion of types for active objects.
Reference: [24] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: In Eiffel, for example, pre- and post-conditions may be specified for methods, and subclasses may neither strengthen the preconditions nor weaken the postconditions of methods they override <ref> [24] </ref>. Leavens, Liskov and others have referred to such extended notions of subtyping as behavioral subtyping [11, 19, 20]. By adding a state machine to an ordinary class definition, an LOE provides a form of semantic specification that can form the basis for behavioral subtyping.
Reference: [25] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: There, substitutability is generally described in terms of bisimulation, and has a much stronger sense than subtyping; it essentially means complete observable equivalence <ref> [6, 10, 25] </ref>. The recent efforts at synthesis begin with either stat-echarts [21, 41], regular types [31], or both [34], and offer translations of those ideas into labelled transition systems or the - calculus [26]. None of these researchers has addressed anything like the problem of efferent types described here.
Reference: [26] <author> Robin Milner, Joachim Parrow, and David Walker. </author> <title> A calculus of mobile processes. (Parts I and II). Information and Computation, </title> <address> 100:177, </address> <year> 1992. </year>
Reference-contexts: The recent efforts at synthesis begin with either stat-echarts [21, 41], regular types [31], or both [34], and offer translations of those ideas into labelled transition systems or the - calculus <ref> [26] </ref>. None of these researchers has addressed anything like the problem of efferent types described here. But despite the differences, this is all related work in the sense that it all seeks to explain the role of finite-state machines in the type structure of a programming language.
Reference: [27] <author> Oscar Nierstrasz. </author> <title> Regular types for active objects. </title> <booktitle> In Paepcke [29], </booktitle> <pages> pages 115. </pages>
Reference-contexts: In fact, several authors have offered definitions of subtyping that account, in some way, for the dynamic availability of services that a logical state machine represents <ref> [7, 15, 27, 31, 32, 34] </ref>. A common foundation among most of these approaches is the notion of traces, which are the sequences of messages that a machine can legally receive. A subtype must be able to accept at least the traces of its supertype. <p> We formalize this consistency by defining a simulation assignment, which maps states of L into states of L 0 . We then show that simulation assignments are sufficient to ensure a formal notion of consistent observable behavior. Unlike the inferred substitutability relation defined by Nier-strasz <ref> [27] </ref>, every subtyping relationship among LOEs is explicitly declared by the programmer. Our subtyping relation is based on declared mappings from states in the sub-LOE to states in the super. <p> Some authors have addressed the particular challenges of inheriting the state-machine implementation code [15, 38], a problem remarkably similar to the so-called inheritance anomaly in concurrent object-oriented languages [22, 23]. The second thread arises directly from issues in object-oriented concurrency. Nierstrasz's regular types <ref> [27] </ref> use logical finite-state machines (or regular expressions) as the basis for an extended notion of types for active objects. Starting with distributed objects in the spirit of actors [2], Nierstrasz uses logical states to describe the dynamic availability of the object's methods.
Reference: [28] <editor> Tenth Annual Conference on Object-Oriented Programming Systems, </editor> <booktitle> Languages, and Applications (OOPSLA '95). ACM SIGPLAN Notices 30(1), </booktitle> <month> October </month> <year> 1995. </year>
Reference: [29] <editor> Andreas Paepcke, editor. </editor> <booktitle> Eighth Annual Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA '93). ACM SIGPLAN Notices 28(1), </booktitle> <month> October </month> <year> 1993. </year>
Reference: [30] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2):207247, </volume> <month> April </month> <year> 1994. </year> <month> 11 </month>
Reference-contexts: Designing type systems that are both expressive and provably safe requires some care. The exploration of such type systems for object-oriented languages has been a continuing area of interest <ref> [1, 3, 4, 5, 8, 12, 30] </ref>. An intuitive basis for subtyping in object-oriented systems is given by Wegner and Zdonik [42]: An instance of a subtype can always be used in any context in which an instance of a supertype was expected.
Reference: [31] <author> Franz Puntigam. </author> <title> Types for active objects based on trace se-mantics. </title> <booktitle> In Proceedings, FMOODS '96, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: In fact, several authors have offered definitions of subtyping that account, in some way, for the dynamic availability of services that a logical state machine represents <ref> [7, 15, 27, 31, 32, 34] </ref>. A common foundation among most of these approaches is the notion of traces, which are the sequences of messages that a machine can legally receive. A subtype must be able to accept at least the traces of its supertype. <p> There, substitutability is generally described in terms of bisimulation, and has a much stronger sense than subtyping; it essentially means complete observable equivalence [6, 10, 25]. The recent efforts at synthesis begin with either stat-echarts [21, 41], regular types <ref> [31] </ref>, or both [34], and offer translations of those ideas into labelled transition systems or the - calculus [26]. None of these researchers has addressed anything like the problem of efferent types described here.
Reference: [32] <author> Franz Puntigam. </author> <title> Types that reflect changes of object usability. </title> <booktitle> In Proceedings of the Joint Modular Languages Conference (JMLC '97). </booktitle> <publisher> LNCS 1204, Springer-Verlag, </publisher> <month> March </month> <year> 1997. </year>
Reference-contexts: In fact, several authors have offered definitions of subtyping that account, in some way, for the dynamic availability of services that a logical state machine represents <ref> [7, 15, 27, 31, 32, 34] </ref>. A common foundation among most of these approaches is the notion of traces, which are the sequences of messages that a machine can legally receive. A subtype must be able to accept at least the traces of its supertype. <p> But despite the differences, this is all related work in the sense that it all seeks to explain the role of finite-state machines in the type structure of a programming language. Using a trace semantics for subtypes, Puntigam <ref> [32] </ref> has even developed a static type discipline for determining whether a program in his calculus ever allows messages to be sent to objects that are in the wrong state to accept them.
Reference: [33] <institution> Rational Software Corporation, Cupertino, California. Unified Modeling Language, </institution> <note> Version 1.1 Document Set, Septem-ber 1997. </note>
Reference-contexts: Created for use in designing reactive systems [17], statecharts were soon being applied in object-oriented analysis and design as well [7, 15]. In fact, something like statecharts have been present in many of the leading methodologies for OOA and OOD <ref> [33, 37, 39] </ref>. A special notion of subtyping has been developed for classes enhanced with statecharts [7]: the subtype is expected to accept the same sequences of messages (traces) as its supertype. Design patterns and implementation strategies have also been proposed for coding such classes [9, 13].
Reference: [34] <author> Antonio Ravara and Vasco Vasconcelos. </author> <title> Behavioral types for a calculus of concurrent objects. </title> <booktitle> In Proceedings, Euro-Par '97, </booktitle> <pages> pages 445561. </pages> <publisher> LNCS 1300, Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: In fact, several authors have offered definitions of subtyping that account, in some way, for the dynamic availability of services that a logical state machine represents <ref> [7, 15, 27, 31, 32, 34] </ref>. A common foundation among most of these approaches is the notion of traces, which are the sequences of messages that a machine can legally receive. A subtype must be able to accept at least the traces of its supertype. <p> There, substitutability is generally described in terms of bisimulation, and has a much stronger sense than subtyping; it essentially means complete observable equivalence [6, 10, 25]. The recent efforts at synthesis begin with either stat-echarts [21, 41], regular types [31], or both <ref> [34] </ref>, and offer translations of those ideas into labelled transition systems or the - calculus [26]. None of these researchers has addressed anything like the problem of efferent types described here.
Reference: [35] <author> Jonathan G. Rossie Jr. and Daniel P. Friedman. </author> <title> An algebraic semantics of subobjects. </title> <booktitle> In OOPSLA '95 [28], </booktitle> <pages> pages 187 199. </pages>
Reference-contexts: Because subtyping among LOEs must be explicitly declared, multiple type inheritance is not currently supported. In fact, extending LOEs with a declared form of multiple inheritance raises interesting problems for implementations of LOEs: not unlike the C++ style of multiple inheritance (which we discuss elsewhere as subobject-based inheritance <ref> [35, 36] </ref>), an LOE would need to maintain subjects for each of its inheritance paths. We are currently exploring efficient implementations and intuitive semantics for such a feature. We also seek to clarify the interaction of our substitutability relation with the dynamic semantics of the language.
Reference: [36] <author> Jonathan G. Rossie Jr., Daniel P. Friedman, and Mitchell Wand. </author> <title> Modeling subobject-based inheritance. </title> <booktitle> In Proceedings of the 10th European Conference on Object-Oriented Programming (ECOOP '96), </booktitle> <pages> pages 248274. </pages> <publisher> LNCS 1098, Springer-Verlag, </publisher> <month> July </month> <year> 1996. </year>
Reference-contexts: Because subtyping among LOEs must be explicitly declared, multiple type inheritance is not currently supported. In fact, extending LOEs with a declared form of multiple inheritance raises interesting problems for implementations of LOEs: not unlike the C++ style of multiple inheritance (which we discuss elsewhere as subobject-based inheritance <ref> [35, 36] </ref>), an LOE would need to maintain subjects for each of its inheritance paths. We are currently exploring efficient implementations and intuitive semantics for such a feature. We also seek to clarify the interaction of our substitutability relation with the dynamic semantics of the language.
Reference: [37] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorenson. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Pren-tice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: Created for use in designing reactive systems [17], statecharts were soon being applied in object-oriented analysis and design as well [7, 15]. In fact, something like statecharts have been present in many of the leading methodologies for OOA and OOD <ref> [33, 37, 39] </ref>. A special notion of subtyping has been developed for classes enhanced with statecharts [7]: the subtype is expected to accept the same sequences of messages (traces) as its supertype. Design patterns and implementation strategies have also been proposed for coding such classes [9, 13].
Reference: [38] <author> Aamod Sane and Roy Campbell. </author> <title> Object-oriented state machines: Subclassing, composition, delegation, and genericity. </title> <booktitle> In OOPSLA '95 [28], </booktitle> <pages> pages 1732. </pages>
Reference-contexts: Design patterns and implementation strategies have also been proposed for coding such classes [9, 13]. Some authors have addressed the particular challenges of inheriting the state-machine implementation code <ref> [15, 38] </ref>, a problem remarkably similar to the so-called inheritance anomaly in concurrent object-oriented languages [22, 23]. The second thread arises directly from issues in object-oriented concurrency. Nierstrasz's regular types [27] use logical finite-state machines (or regular expressions) as the basis for an extended notion of types for active objects.
Reference: [39] <author> Sally Shlaer and Stephen J. Mellor. </author> <title> Object Lifecycles: Modeling the World in States. </title> <publisher> Yourdon Press Computing Series. Yourdon Press (Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey), </address> <year> 1992. </year>
Reference-contexts: Created for use in designing reactive systems [17], statecharts were soon being applied in object-oriented analysis and design as well [7, 15]. In fact, something like statecharts have been present in many of the leading methodologies for OOA and OOD <ref> [33, 37, 39] </ref>. A special notion of subtyping has been developed for classes enhanced with statecharts [7]: the subtype is expected to accept the same sequences of messages (traces) as its supertype. Design patterns and implementation strategies have also been proposed for coding such classes [9, 13].
Reference: [40] <author> Chris Tomlinson and Vineet Singh. </author> <title> Inheritance and synchronization with enabled sets. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA '89), pages 103112. ACM SIGPLAN Notices 24(1), </booktitle> <month> October </month> <year> 1989. </year>
Reference-contexts: As we discuss in Section 7, this is closely related to the use of guards or enabled sets in synchronization code for concurrent objects <ref> [22, 23, 40] </ref>. An important difference is that these techniques tend to partition the methods dynamically, according to the values of boolean expressions involving instance variables. Instead, we simply partition the methods according to the logical states we have defined, and allow individual implementations to resolve whatever nondeterminism we introduce.
Reference: [41] <author> Andrew C. Uselton and Scott A. Smolka. </author> <title> A process-algebraic semantics for statecharts via state refinement. </title> <booktitle> In Proceedings of PROCOMET '94, </booktitle> <pages> pages 267286. </pages> <address> Elsevier/North Holland, </address> <year> 1994. </year>
Reference-contexts: There, substitutability is generally described in terms of bisimulation, and has a much stronger sense than subtyping; it essentially means complete observable equivalence [6, 10, 25]. The recent efforts at synthesis begin with either stat-echarts <ref> [21, 41] </ref>, regular types [31], or both [34], and offer translations of those ideas into labelled transition systems or the - calculus [26]. None of these researchers has addressed anything like the problem of efferent types described here.
Reference: [42] <author> Peter Wegner and Stanley B. Zdonik. </author> <title> Inheritance as an incremental modification mechanism or what like is and isn't like. </title> <editor> In Stein Gjessing and Kirsten Nygaard, editors, </editor> <booktitle> European Conference on Object-Oriented Programming (ECOOP '88), </booktitle> <pages> pages 5577. </pages> <publisher> LNCS 322, Springer-Verlag, </publisher> <month> August </month> <year> 1988. </year> <month> 12 </month>
Reference-contexts: The exploration of such type systems for object-oriented languages has been a continuing area of interest [1, 3, 4, 5, 8, 12, 30]. An intuitive basis for subtyping in object-oriented systems is given by Wegner and Zdonik <ref> [42] </ref>: An instance of a subtype can always be used in any context in which an instance of a supertype was expected.
References-found: 42

