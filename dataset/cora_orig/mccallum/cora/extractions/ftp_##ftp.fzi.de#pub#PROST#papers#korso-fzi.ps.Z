URL: ftp://ftp.fzi.de/pub/PROST/papers/korso-fzi.ps.Z
Refering-URL: http://www.fzi.de/prost/publications/overview.html
Root-URL: http://www.fzi.de
Title: On Object-Oriented Design and Verification  
Author: C. Lewerentz, Th. Lindner, A. Ruping, E. Sekerinski 
Address: Haid-und-Neu Strae 10-14, 76131 Karlsruhe, Germany  
Affiliation: Forschungszentrum Informatik Karlsruhe (FZI),  
Abstract: We present a theory of object-orientation on the basis of the refinement calculus. This theory allows for specifying the behaviour of objects and provides a calculus for the proof of relationships between classes such as refinement. Given two similar, but not identical classes, we present an algorithm to construct a common superclass which is refined by both classes, and an algorithm to construct a common subclass which refines both classes. As an example, we present an account manager to illustrate design and verification. The overall approach aims at giving a simple theoretical basis for incremental object-oriented software construction. We demonstrate how formal specification and verification can be integrated into the development process, and thus can be put into practical use. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. J. Alencar and A. Goguen. </author> <title> OOZE: An object-oriented Z environment. </title> <editor> In P. America, editor, </editor> <booktitle> ECOOP 91: European Conference on Object-Oriented Programming, Lecture Notes in Computer Science 512. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: We follow the work of [27], but concentrate on single rather than multiple dispatch systems. Our approach differs from that of object-oriented specification languages like [6, 15] in that it is not just an extension of an existing specification language. It differs from the OOZE approach <ref> [1] </ref> since we aim at an imperative programming language and provide a refinement relation on both programs and classes. The calculus is presented in Section 3. Inheritance is an important feature of object-oriented languages. A new class is constructed by inheriting from existing classes. <p> Object-Ids and Modules. Object identity is considered to be an important issue in object-orientation. We define the usage of object identities in our framework. Next, we introduce modules that encapsulate cooperating classes. Several studies have expressed the need for structures that are less fine-grained than classes (cf. <ref> [26, 29, 1] </ref>). We demonstrate that modules support component-oriented specification and verification techniques in the presence of object identity. Also, modules allow for extending the notion of compatibility to groups of classes. This discussion is presented in Section 6. Problem analysis. <p> One approach to overcome this problem is to restrict the usage of object identities. 6.2 Modules We introduce modules into the specification of object-oriented systems. Modules encapsulate cooperating classes whose objects have to refer to one another (cf. <ref> [23, 24, 26, 29, 1, 11, 17] </ref>). Modules provide a precise interface to the outside world. Inside modules, object identities can be used without restrictions. However, if object identities are used in invariants specifying a system, they may not refer to objects beyond the module's border.
Reference: 2. <author> P. </author> <title> America. Inheritance and subtyping in a parallel object-oriented language. </title> <editor> In J. Bezevin, J.-M. Hullot, P. Cointe, and H. Lieberman, editors, </editor> <booktitle> ECOOP 87: European Conference on Object-Oriented Programming, Lecture Notes in Computer Science 276. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Class refinement means that the observable properties of a class are preserved. It may hold between any classes with the same signature, independently of the way they are constructed. Class refinement or subtyping has first been studied by P. America <ref> [2] </ref>. In this approach, as well as in newer ones like Z++ [15], class refinement is defined by a set of proof obligations. We extend this treatment by first giving a behavioural definition of refinement as done by T. Nipkow [20], C. A. R.
Reference: 3. <author> R. J. R. Back and J. von Wright. </author> <title> Refinement calculus, part i. </title> <booktitle> In REX Workshop for Refinement of Distributed Systems, Lecture Notes in Computer Science 430. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Furthermore, we embed formal methods in a software life cycle that is recognized to support the reuse of design, code, specification, and proofs. Object-Oriented Refinement. The refinement calculus as developed by R. Back <ref> [3] </ref>, C. Morgan [18] and J. Morris [19] provides a semantics for imperative programming constructs by weakest preconditions. The programming language is extended by several kinds of nondeterminism (angelic and demonic) which are used for specification [4]. <p> We extend this treatment by first giving a behavioural definition of refinement as done by T. Nipkow [20], C. A. R. Hoare et al. [12] for data types. From this, proof obligations can be derived which are similar to those of data refinement <ref> [3] </ref>. This is done in Section 4. In object-oriented modelling one frequently has to integrate two similar, but not identical classes. It is convenient to have a superclass which factors out their common behaviour. The superclass provides common operations which preserve the semantics of the original operations. <p> The reader is referred to the standard literature for a more comprehensive and tutorial treatment <ref> [3] </ref>, [18], [19]. 2.1 Types, States, Predicates Let : : : ; x; y; : : : stand for variable names. With each variable we associate a type. Let v be a list of variable names and T a list of types of equal length.
Reference: 4. <author> R. J. R. Back and J. von Wright. </author> <title> Duality in specification languages: A lattice-theoretical approach. </title> <journal> Acta Informatica, </journal> <volume> 27, </volume> <year> 1990. </year>
Reference-contexts: Object-Oriented Refinement. The refinement calculus as developed by R. Back [3], C. Morgan [18] and J. Morris [19] provides a semantics for imperative programming constructs by weakest preconditions. The programming language is extended by several kinds of nondeterminism (angelic and demonic) which are used for specification <ref> [4] </ref>. The core of the calculus is the refinement relation for refining non-executable programs to executable code. A brief introduction is given in Section 2. In the framework of the refinement calculus, we define objects, classes and method calls. <p> As shown in <ref> [4] </ref>, the set of predicate transformers from v : T to w : U ordered by refinement is a lattice. The top element is abort , which is refined by any other predicate transformer. The bottom element is miracle , which refines any other predicate transformer. <p> Our intention is to define class refinement in the very rich setting of the refinement calculus which includes miracles and both demonic and angelic nondeterminism. The definition is motivated by the following completeness result known for the refinement calculus <ref> [4] </ref>. Theorem (Completeness of Programs).
Reference: 5. <author> G. Booch. </author> <title> Object-oriented Design. </title> <publisher> Benjamin Cummings, </publisher> <year> 1991. </year>
Reference-contexts: To achieve these goals we use Responsibility Driven Design [30], one of several object-oriented analysis and design methods <ref> [5, 13, 22] </ref>, and adjust it to the integration of formal specification into the analysis and design process. <p> We decided to use RDD, as we regard it to be the simplest among the numerous object-oriented analysis and design methods <ref> [5, 22, 30, 13] </ref>, but also one of the most efficient ones in terms of reusability, flexibility, and comprehensibility of the resulting model. Our experiments with RDD show that RDD lacks of appropriate means to express object behaviour and object interaction.
Reference: 6. <author> D. A. Carrington, D. Duke, R. Duke, P. King, G. A. Rose, and G. Smith. Object-Z: </author> <title> An object-oriented extension to Z. </title> <editor> In S. Vuong, editor, </editor> <title> FORTE 89: Formal Description Techniques. </title> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: A brief introduction is given in Section 2. In the framework of the refinement calculus, we define objects, classes and method calls. We follow the work of [27], but concentrate on single rather than multiple dispatch systems. Our approach differs from that of object-oriented specification languages like <ref> [6, 15] </ref> in that it is not just an extension of an existing specification language. It differs from the OOZE approach [1] since we aim at an imperative programming language and provide a refinement relation on both programs and classes. The calculus is presented in Section 3.
Reference: 7. <author> E. Casais, C. Lewerentz, T. Lindner, and F. Weber. </author> <title> Formal methods and object-orientation. Technical report, </title> <booktitle> Tutorial at TOOLS Europe 93, </booktitle> <address> Versailles, France, </address> <month> Mar. </month> <year> 1993. </year>
Reference-contexts: Our approach differs from these in the choice of the design method and the role formal methods play. As we believe that object-orientation is the most promising technique for the reuse of design, code, and proofs <ref> [7] </ref>, the latter currently being the most expensive part of the development, we decided to use an object-oriented design method, namely Responsibility Driven Design (RDD) [30], as a starting point.
Reference: 8. <author> E. Gamma, R. Helm, J. Vlissides, and R. E. Johnson. </author> <title> Design patterns: Abstraction and reuse of object-oriented design. </title> <editor> In O. Nierstrasz, editor, </editor> <booktitle> Proceedings ECOOP '93, </booktitle> <volume> LNCS 707, </volume> <pages> pages 406-431. </pages> <publisher> Springer-Verlag, </publisher> <address> Kaiserslautern, Germany, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: Coffer [16] therefore provides for the application of some "reuse mechanisms", the most important being constructed out of the so-called "design patterns", described in <ref> [8] </ref>. We use certain design patterns to construct composed systems out of building blocks, be it classes, families of classes, or modules. We made some experiments in giving design patterns a formal semantics and are thus able to reuse some kind of proof work done for the composed components.
Reference: 9. <author> M. Gogolla, S. Conrad, G. Denker, R. Herzig, N. Vlachantonis, and H.-D. Ehrich. </author> <title> TROLL light the language and its development environment. </title> <editor> In M. Broy and S. Jahnichen, editors, </editor> <booktitle> KORSO Correct Software by Formal Methods. </booktitle> <year> 1994. </year>
Reference-contexts: Our experiments with RDD show that RDD lacks of appropriate means to express object behaviour and object interaction. Both aspects are very well supported by the object behaviour diagrams (OBD) and object interaction diagrams, adopted from the approach of Jacobson [13]. See also <ref> [9, 10] </ref> for the treatment of object behaviour and object interaction. Additionally, we find the treatment of inheritance in RDD not adequate (cf. Section 4) and replace this part of RDD. The complete resulting design method is described in [16].
Reference: 10. <author> M. Gogolla, S. Conrad, and R. Herzig. </author> <title> Sketching concepts and computational model of TROLL light. </title> <editor> In A. Miola, editor, </editor> <booktitle> Proceedings of DISCO '93: Design and Implementation of Symbolic Computation Systems, </booktitle> <publisher> LNCS. Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1993. </year>
Reference-contexts: Our experiments with RDD show that RDD lacks of appropriate means to express object behaviour and object interaction. Both aspects are very well supported by the object behaviour diagrams (OBD) and object interaction diagrams, adopted from the approach of Jacobson [13]. See also <ref> [9, 10] </ref> for the treatment of object behaviour and object interaction. Additionally, we find the treatment of inheritance in RDD not adequate (cf. Section 4) and replace this part of RDD. The complete resulting design method is described in [16].
Reference: 11. <author> S. P. Harbison. </author> <title> Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: One approach to overcome this problem is to restrict the usage of object identities. 6.2 Modules We introduce modules into the specification of object-oriented systems. Modules encapsulate cooperating classes whose objects have to refer to one another (cf. <ref> [23, 24, 26, 29, 1, 11, 17] </ref>). Modules provide a precise interface to the outside world. Inside modules, object identities can be used without restrictions. However, if object identities are used in invariants specifying a system, they may not refer to objects beyond the module's border.
Reference: 12. <author> C. A. R. Hoare, H. Jifeng, and J. W. Sanders. </author> <title> Prespecification in data refinement. </title> <journal> Information Processing Letters, </journal> <volume> 25 (2), </volume> <year> 1987. </year>
Reference-contexts: America [2]. In this approach, as well as in newer ones like Z++ [15], class refinement is defined by a set of proof obligations. We extend this treatment by first giving a behavioural definition of refinement as done by T. Nipkow [20], C. A. R. Hoare et al. <ref> [12] </ref> for data types. From this, proof obligations can be derived which are similar to those of data refinement [3]. This is done in Section 4. In object-oriented modelling one frequently has to integrate two similar, but not identical classes. <p> We have defined classes in a similar way to model-oriented data types as done in [20] and <ref> [12] </ref>. The main difference is that objects here are "higher-order" in the sense that they have operations on them that are part of them. Some care is necessary to ensure consistency of the definitions, as observed in [27]. Object-oriented type theory offers a way to express these higher-order features. <p> However, this also implies that any observation by method calls to an object of class C is also a possible observation of an object of class A. In this section we define an observational kind of class refinement in an analoguous way to data type refinement <ref> [12] </ref>. From this we derive proof obligation for class refinement. The behaviour of an object is observed by a program which initializes that object, performs some operations on it, and discards that object again. <p> depend on y, sequential compositions p; q, if p, q are programs respecting privacy, demonic choice (ui 2 I p i ), angelic choice (ti 2 I p i ), if p is a program respecting privacy for all i 2 I. 2 Adopting the definition of data type refinement <ref> [20, 12] </ref>, we define class refinement as follows: Class A is refined by class C if any program over some object x with inital value of A is refined by the same program over X with inital value of C. Definition.
Reference: 13. <author> I. Jacobson. </author> <title> Object-oriented Software Engineering: A Use Case Driven Approach. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: To achieve these goals we use Responsibility Driven Design [30], one of several object-oriented analysis and design methods <ref> [5, 13, 22] </ref>, and adjust it to the integration of formal specification into the analysis and design process. <p> We decided to use RDD, as we regard it to be the simplest among the numerous object-oriented analysis and design methods <ref> [5, 22, 30, 13] </ref>, but also one of the most efficient ones in terms of reusability, flexibility, and comprehensibility of the resulting model. Our experiments with RDD show that RDD lacks of appropriate means to express object behaviour and object interaction. <p> Our experiments with RDD show that RDD lacks of appropriate means to express object behaviour and object interaction. Both aspects are very well supported by the object behaviour diagrams (OBD) and object interaction diagrams, adopted from the approach of Jacobson <ref> [13] </ref>. See also [9, 10] for the treatment of object behaviour and object interaction. Additionally, we find the treatment of inheritance in RDD not adequate (cf. Section 4) and replace this part of RDD. The complete resulting design method is described in [16].
Reference: 14. <author> K. Lano. </author> <title> Using formal and structured techniques in object-oriented development. </title> <type> Technical Report BUT-TN-LR 1029, </type> <institution> Lloyds Register, </institution> <year> 1992. </year>
Reference-contexts: A few approaches to integrate formal methods into well-known development models (like SSADM, HOOD, OMT) have been made <ref> [21, 14] </ref>. Our approach differs from these in the choice of the design method and the role formal methods play.
Reference: 15. <author> K. Lano and H. Haughton. </author> <title> Reasoning and refinement in object-oriented specification languages. </title> <editor> In O. L. Madsen, editor, </editor> <booktitle> ECOOP 92: European Conference on Object-Oriented Programming, Lecture Notes in Computer Science 615. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: A brief introduction is given in Section 2. In the framework of the refinement calculus, we define objects, classes and method calls. We follow the work of [27], but concentrate on single rather than multiple dispatch systems. Our approach differs from that of object-oriented specification languages like <ref> [6, 15] </ref> in that it is not just an extension of an existing specification language. It differs from the OOZE approach [1] since we aim at an imperative programming language and provide a refinement relation on both programs and classes. The calculus is presented in Section 3. <p> It may hold between any classes with the same signature, independently of the way they are constructed. Class refinement or subtyping has first been studied by P. America [2]. In this approach, as well as in newer ones like Z++ <ref> [15] </ref>, class refinement is defined by a set of proof obligations. We extend this treatment by first giving a behavioural definition of refinement as done by T. Nipkow [20], C. A. R. Hoare et al. [12] for data types.
Reference: 16. <author> T. Lindner and A. Ruping. </author> <title> Formal object-oriented software design: The Coffer approach. </title> <type> Technical report, </type> <institution> Forschungszentrum Informatik, </institution> <address> Haid-und-Neu-Strae 10-14, D-76131 Karlsruhe, </address> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: See also [9, 10] for the treatment of object behaviour and object interaction. Additionally, we find the treatment of inheritance in RDD not adequate (cf. Section 4) and replace this part of RDD. The complete resulting design method is described in <ref> [16] </ref>. By introducing object behaviour and object interaction descriptions we succeed in coming closer to a formal specification of our classes. So far, the communication architecture of our object system is formally described (via class collaboration graphs and object behaviour descriptions) and can systematically be simulated. <p> We refer to <ref> [16] </ref> for a complete list of all proof obligations. Design Patterns. Object-orientation is said to be a strong technique for reuse and extensibility of software designs. <p> Design Patterns. Object-orientation is said to be a strong technique for reuse and extensibility of software designs. Nevertheless, most design methodologies start up from the scratch and do not tackle the situation where some work has already been done and can be reused. Coffer <ref> [16] </ref> therefore provides for the application of some "reuse mechanisms", the most important being constructed out of the so-called "design patterns", described in [8]. We use certain design patterns to construct composed systems out of building blocks, be it classes, families of classes, or modules.
Reference: 17. <author> H. Moessenboeck. </author> <title> Object-Oriented Programming in Oberon-2. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: One approach to overcome this problem is to restrict the usage of object identities. 6.2 Modules We introduce modules into the specification of object-oriented systems. Modules encapsulate cooperating classes whose objects have to refer to one another (cf. <ref> [23, 24, 26, 29, 1, 11, 17] </ref>). Modules provide a precise interface to the outside world. Inside modules, object identities can be used without restrictions. However, if object identities are used in invariants specifying a system, they may not refer to objects beyond the module's border.
Reference: 18. <author> C. C. Morgan. </author> <title> Programming from Specifications. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Furthermore, we embed formal methods in a software life cycle that is recognized to support the reuse of design, code, specification, and proofs. Object-Oriented Refinement. The refinement calculus as developed by R. Back [3], C. Morgan <ref> [18] </ref> and J. Morris [19] provides a semantics for imperative programming constructs by weakest preconditions. The programming language is extended by several kinds of nondeterminism (angelic and demonic) which are used for specification [4]. The core of the calculus is the refinement relation for refining non-executable programs to executable code. <p> The reader is referred to the standard literature for a more comprehensive and tutorial treatment [3], <ref> [18] </ref>, [19]. 2.1 Types, States, Predicates Let : : : ; x; y; : : : stand for variable names. With each variable we associate a type. Let v be a list of variable names and T a list of types of equal length.
Reference: 19. <author> J. M. Morris. </author> <title> A theoretical basis for stepwise refinement and the programming calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 9(3), </volume> <month> dec </month> <year> 1987. </year>
Reference-contexts: Furthermore, we embed formal methods in a software life cycle that is recognized to support the reuse of design, code, specification, and proofs. Object-Oriented Refinement. The refinement calculus as developed by R. Back [3], C. Morgan [18] and J. Morris <ref> [19] </ref> provides a semantics for imperative programming constructs by weakest preconditions. The programming language is extended by several kinds of nondeterminism (angelic and demonic) which are used for specification [4]. The core of the calculus is the refinement relation for refining non-executable programs to executable code. <p> The reader is referred to the standard literature for a more comprehensive and tutorial treatment [3], [18], <ref> [19] </ref>. 2.1 Types, States, Predicates Let : : : ; x; y; : : : stand for variable names. With each variable we associate a type. Let v be a list of variable names and T a list of types of equal length.
Reference: 20. <author> T. Nipkow. </author> <title> Nondeterministic data types: Models and implementations. </title> <journal> Acta Infor-matica, </journal> <volume> 11, </volume> <year> 1986. </year>
Reference-contexts: America [2]. In this approach, as well as in newer ones like Z++ [15], class refinement is defined by a set of proof obligations. We extend this treatment by first giving a behavioural definition of refinement as done by T. Nipkow <ref> [20] </ref>, C. A. R. Hoare et al. [12] for data types. From this, proof obligations can be derived which are similar to those of data refinement [3]. This is done in Section 4. In object-oriented modelling one frequently has to integrate two similar, but not identical classes. <p> We have defined classes in a similar way to model-oriented data types as done in <ref> [20] </ref> and [12]. The main difference is that objects here are "higher-order" in the sense that they have operations on them that are part of them. Some care is necessary to ensure consistency of the definitions, as observed in [27]. <p> An object x refines an object x 0 if any complete program over x 0 refines the same program over x. This definition involved quantification over all programs. As discussed in <ref> [20] </ref>, refinement (or equivalence) may depend on the programming language used to observe objects (e.g. it depends on the existence of conditionals, recursion and nondeterminism). Our intention is to define class refinement in the very rich setting of the refinement calculus which includes miracles and both demonic and angelic nondeterminism. <p> depend on y, sequential compositions p; q, if p, q are programs respecting privacy, demonic choice (ui 2 I p i ), angelic choice (ti 2 I p i ), if p is a program respecting privacy for all i 2 I. 2 Adopting the definition of data type refinement <ref> [20, 12] </ref>, we define class refinement as follows: Class A is refined by class C if any program over some object x with inital value of A is refined by the same program over X with inital value of C. Definition.
Reference: 21. <author> F. Polack, M. Whiston, and P. Hitchcock. </author> <title> Structured analysis|a draft method for writing Z specifications. </title> <editor> In J. E. Nicholls, editor, </editor> <booktitle> Z User Workshop 91, Workshops in Computing, </booktitle> <pages> pages 106-122. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: A few approaches to integrate formal methods into well-known development models (like SSADM, HOOD, OMT) have been made <ref> [21, 14] </ref>. Our approach differs from these in the choice of the design method and the role formal methods play.
Reference: 22. <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen. </author> <title> Object-oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: To achieve these goals we use Responsibility Driven Design [30], one of several object-oriented analysis and design methods <ref> [5, 13, 22] </ref>, and adjust it to the integration of formal specification into the analysis and design process. <p> We decided to use RDD, as we regard it to be the simplest among the numerous object-oriented analysis and design methods <ref> [5, 22, 30, 13] </ref>, but also one of the most efficient ones in terms of reusability, flexibility, and comprehensibility of the resulting model. Our experiments with RDD show that RDD lacks of appropriate means to express object behaviour and object interaction.
Reference: 23. <author> A. Ruping. </author> <title> Hypertext a case study of formal object-oriented software development. </title> <type> Technical Report FZI-9/93, </type> <institution> Forschungszentrum Informatik, </institution> <address> Haid-und-Neu-Strae 10-14, D-76131 Karlsruhe, </address> <year> 1993. </year>
Reference-contexts: One approach to overcome this problem is to restrict the usage of object identities. 6.2 Modules We introduce modules into the specification of object-oriented systems. Modules encapsulate cooperating classes whose objects have to refer to one another (cf. <ref> [23, 24, 26, 29, 1, 11, 17] </ref>). Modules provide a precise interface to the outside world. Inside modules, object identities can be used without restrictions. However, if object identities are used in invariants specifying a system, they may not refer to objects beyond the module's border.
Reference: 24. <author> A. Ruping. </author> <title> Modules in object-oriented specification. </title> <type> Technical Report FZI-24/93, </type> <institution> Forschungszentrum Informatik, </institution> <address> Haid-und-Neu-Strae 10-14, D-76131 Karlsruhe, </address> <year> 1993. </year>
Reference-contexts: One approach to overcome this problem is to restrict the usage of object identities. 6.2 Modules We introduce modules into the specification of object-oriented systems. Modules encapsulate cooperating classes whose objects have to refer to one another (cf. <ref> [23, 24, 26, 29, 1, 11, 17] </ref>). Modules provide a precise interface to the outside world. Inside modules, object identities can be used without restrictions. However, if object identities are used in invariants specifying a system, they may not refer to objects beyond the module's border. <p> Finally, modules allow for abstraction relationships between components that are less fine-grained than classes. We can describe a module to be compatible with its supermodule, while there may be very different relationships between the classes involved. For the details we refer to <ref> [24] </ref>. 7 The Design Process To put formal methods into industrial use, it is necessary to integrate them smoothly into a software development life cycle: it is not specification and verification, what software development is all about.
Reference: 25. <author> E. Sekerinski. </author> <title> Verfeinerung von objektorientierten spezifikationen und programmen. </title> <type> Technical report, </type> <institution> Forschungszentrum Informatik, </institution> <address> Haid-und-Neu-Strae 10-14, D-76131 Karlsruhe, </address> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: This property, togehter with the transitivity of refinement, is the basis for stepwise refinement. 3 Objects and Classes We extend the refinement calculus by objects, object types and classes. The approach is illustrated by examples from banking. The reader may consult <ref> [25] </ref> for a more complete treatment of the underlying theory. Transactions on bank accounts can be modelled by representing each account as an object with a private state and public operations on that state. <p> Some care is necessary to ensure consistency of the definitions, as observed in [27]. Object-oriented type theory offers a way to express these higher-order features. The reader is referred to <ref> [25] </ref> for a more comprehensive treatment. 4 Class Refinement and Equivalence We take the view of objects being black boxes with some internals and exhibiting a certain behaviour to their environment. Interaction with objects takes place only by method calls to them. <p> The proof of the Downward Simulation Theorem is based on induction over the structure of programs respecting privacy of x. It is omitted here for brevity. It can be found in full length in <ref> [25] </ref>, together with examples illustrating its use. There is a dual theorem which uses a disjunctive upward simulation instead. Theorem (Upward Simulation). Let A and C be classes of the same type.
Reference: 26. <author> C. Szyperski. </author> <title> Import is not inheritance why we need both: Modules and classes. </title> <editor> In O. L. Madsen, editor, </editor> <booktitle> ECOOP 92: European Conference on Object-Oriented Programming, Lecture Notes in Computer Science 615. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Object-Ids and Modules. Object identity is considered to be an important issue in object-orientation. We define the usage of object identities in our framework. Next, we introduce modules that encapsulate cooperating classes. Several studies have expressed the need for structures that are less fine-grained than classes (cf. <ref> [26, 29, 1] </ref>). We demonstrate that modules support component-oriented specification and verification techniques in the presence of object identity. Also, modules allow for extending the notion of compatibility to groups of classes. This discussion is presented in Section 6. Problem analysis. <p> One approach to overcome this problem is to restrict the usage of object identities. 6.2 Modules We introduce modules into the specification of object-oriented systems. Modules encapsulate cooperating classes whose objects have to refer to one another (cf. <ref> [23, 24, 26, 29, 1, 11, 17] </ref>). Modules provide a precise interface to the outside world. Inside modules, object identities can be used without restrictions. However, if object identities are used in invariants specifying a system, they may not refer to objects beyond the module's border.
Reference: 27. <author> M. Utting. </author> <title> An Object-Oriented Refinement Calculus with Modular Reasoning. </title> <type> PhD thesis, </type> <institution> University of New South Wales, Kensington, </institution> <year> 1992. </year>
Reference-contexts: The core of the calculus is the refinement relation for refining non-executable programs to executable code. A brief introduction is given in Section 2. In the framework of the refinement calculus, we define objects, classes and method calls. We follow the work of <ref> [27] </ref>, but concentrate on single rather than multiple dispatch systems. Our approach differs from that of object-oriented specification languages like [6, 15] in that it is not just an extension of an existing specification language. <p> The main difference is that objects here are "higher-order" in the sense that they have operations on them that are part of them. Some care is necessary to ensure consistency of the definitions, as observed in <ref> [27] </ref>. Object-oriented type theory offers a way to express these higher-order features. The reader is referred to [25] for a more comprehensive treatment. 4 Class Refinement and Equivalence We take the view of objects being black boxes with some internals and exhibiting a certain behaviour to their environment.
Reference: 28. <author> F. Weber. </author> <title> Getting class correctness and system correctness equivalent how to get co-variance right. </title> <editor> In R. Ege, editor, </editor> <booktitle> TOOLS 8: Technology of Object-Oriented Languages and Systems. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: These formalisms shall be semantically integrated into the here presented specification and verification calculus. Up to now some basic work has been done on the treatment of recursive class definitions. The refinement relation for recursive types is not easily defined. As shown in <ref> [28] </ref> the above presented compatibility relation between classes has to be further specialised into conformance and matching (imitation) relationsships. Currently, we are working on an extension of the formal foundation for further class relationships, in particular generalization and specialization. Acknowledgements.
Reference: 29. <author> A. Wills. </author> <title> Capsules and types in Fresco: Program verification in smalltalk. </title> <editor> In P. America, editor, </editor> <booktitle> ECOOP 91: European Conference on Object-Oriented Programming, Lecture Notes in Computer Science 512. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Object-Ids and Modules. Object identity is considered to be an important issue in object-orientation. We define the usage of object identities in our framework. Next, we introduce modules that encapsulate cooperating classes. Several studies have expressed the need for structures that are less fine-grained than classes (cf. <ref> [26, 29, 1] </ref>). We demonstrate that modules support component-oriented specification and verification techniques in the presence of object identity. Also, modules allow for extending the notion of compatibility to groups of classes. This discussion is presented in Section 6. Problem analysis. <p> One approach to overcome this problem is to restrict the usage of object identities. 6.2 Modules We introduce modules into the specification of object-oriented systems. Modules encapsulate cooperating classes whose objects have to refer to one another (cf. <ref> [23, 24, 26, 29, 1, 11, 17] </ref>). Modules provide a precise interface to the outside world. Inside modules, object identities can be used without restrictions. However, if object identities are used in invariants specifying a system, they may not refer to objects beyond the module's border.
Reference: 30. <author> R. Wirfs-Brock, B. Wilkerson, and R. Wiener. </author> <title> Designing Object-oriented Software. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: This integration should be smooth, in that the transition from the informal to the formal should be easy, and should be flexible, in that the developer may choose whether and where to use formal methods. To achieve these goals we use Responsibility Driven Design <ref> [30] </ref>, one of several object-oriented analysis and design methods [5, 13, 22], and adjust it to the integration of formal specification into the analysis and design process. <p> As we believe that object-orientation is the most promising technique for the reuse of design, code, and proofs [7], the latter currently being the most expensive part of the development, we decided to use an object-oriented design method, namely Responsibility Driven Design (RDD) <ref> [30] </ref>, as a starting point. We decided to use RDD, as we regard it to be the simplest among the numerous object-oriented analysis and design methods [5, 22, 30, 13], but also one of the most efficient ones in terms of reusability, flexibility, and comprehensibility of the resulting model. <p> We decided to use RDD, as we regard it to be the simplest among the numerous object-oriented analysis and design methods <ref> [5, 22, 30, 13] </ref>, but also one of the most efficient ones in terms of reusability, flexibility, and comprehensibility of the resulting model. Our experiments with RDD show that RDD lacks of appropriate means to express object behaviour and object interaction.
References-found: 30

