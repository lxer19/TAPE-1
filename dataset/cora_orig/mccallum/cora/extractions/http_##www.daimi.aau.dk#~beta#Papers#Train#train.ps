URL: http://www.daimi.aau.dk/~beta/Papers/Train/train.ps
Refering-URL: http://www.daimi.aau.dk/~beta/Papers/Train/train.abstract.html
Root-URL: http://www.daimi.aau.dk
Email: E-mail: fjacobse,grarupg@daimi.aau.dk  
Title: Incremental Mature Garbage Collection Using the Train Algorithm  
Author: Jacob Seligmann Steffen Grarup 
Address: Ny Munkegade 116, DK-8000 Arhus C, Denmark  
Affiliation: Computer Science Department, Aarhus University  
Abstract: We present an implementation of the Train Algorithm, an incremental collection scheme for reclamation of mature garbage in generation-based memory management systems. To the best of our knowledge, this is the first Train Algorithm implementation ever. Using the algorithm, the traditional mark-sweep garbage collector employed by the Mjolner run-time system for the object-oriented BETA programming language was replaced by a non-disruptive one, with only negligible time and storage overheads. 
Abstract-found: 1
Intro-found: 1
Reference: [Bar88] <author> Knut Barra: </author> <title> Mark/sweep compaction for substantially nested Beta objects, </title> <institution> NCC-Note DTEK/03/88, Norwegian Computing Center, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: The young generation (the infant object area, or IOA) consists of two fixed-sized semi-spaces reclaimed using copying collection. The old generation (the adult object area, or AOA) consists of a series of linked fixed-sized blocks reclaimed using a sophisticated three-phase mark-sweep collection scheme <ref> [Bar88] </ref>. In addition, large arrays of pointer-less objects are kept in a separate area (the large value-repetition area, or LVRA) consisting of linked fixed-sized blocks managed using free-lists and periodic compaction. The advancement age between the two generations is determined adaptively using demographic feedback-mediated tenuring [UJ92].
Reference: [GS93] <author> Steffen Grarup and Jacob Seligmann: </author> <title> Incremental Mature Garbage Collection, M.Sc. </title> <type> thesis, </type> <institution> Computer Science Department, Aarhus University, Denmark, </institution> <month> August </month> <year> 1993. </year> <note> Also published as Technical Report DAIMI IR-122, </note> <institution> Computer Science Department, Aarhus University, Denmark, </institution> <month> September </month> <year> 1994. </year> <note> Electronic version available via anonymous ftp from ftp.daimi.aau.dk as pub/thesis/gcthesis.ps.fZ,gzg. </note>
Reference-contexts: Using the algorithm, generational collectors can be extended to provide non-disruptive collection of all generational areas. In the following, we present the results from a practical implementation of the Train Algorithm <ref> [GS93] </ref>. Section 2 describes the basic ideas behind the algorithm. Section 3 concerns the practical implementation issues. Section 4 presents the measurement results. Section 5 points out future research directions. 2 The Algorithm This section deals with the theoretical aspects of the Train Algorithm. <p> Section 3 concerns the practical implementation issues. Section 4 presents the measurement results. Section 5 points out future research directions. 2 The Algorithm This section deals with the theoretical aspects of the Train Algorithm. For a more detailed presentation of the algorithm including a couple of enlightening examples, see <ref> [HM92, GS93] </ref>. Section 2.1 outlines the main ideas behind the algorithm and introduces the terminology needed in later sections. (Readers familiar with the algorithm may wish to skip this part.) Section 2.2 identifies and corrects a subtle error in the original algorithm. <p> Using this extension, it can be shown that each pass over a train will either reclaim or evacuate at least one object, and the entire Train Algorithm may be proven formally correct <ref> [GS93] </ref>. 2.3 Popular Objects Since the Train Algorithm processes only a single fixed-size car at a time, there is an upper limit on the number of bytes that are copied at each invocation. However, moving popular objects (objects with many pointers to them) could still make the algorithm disruptive. <p> With the popular object treatment outlined above, the Train Algorithm can be shown to correctly identify and reclaim all garbage <ref> [GS93] </ref>. However, such schemes may be quite costly to implement in practice. <p> By initializing a new counter each time the collection of a new train commences, estimates nevertheless become available quite often. This approach turned out to work well in practice <ref> [GS93] </ref>. 3.2.3 Popular Object Treatment Because of the complications outlined in Section 2.3, we did not implement a full popular object scheme. However, all Mjolner BETA programs contain a special object, the basic environment object, which is referenced from a large number of other objects. <p> The code for the new collector constituted about 2,000 lines of C (including extensive debug consistency checks), or about the same as the original mark-sweep collector. 4 The Results In this section, we present the main results obtained from our Train Algorithm implementation. For a more detailed account, see <ref> [GS93] </ref>. Section 4.1 describes the benchmark system. Section 4.2 presents the most important result of our implementation, namely that disruptive old generation collection pauses can be completely removed using the Train Algorithm. <p> application storage requirements of between 4% and 8%. 4.5 Copying Overhead Theoretically, the Train Algorithm may require O (M n 2 ) invocations to collect a train consisting of n cars, where M is the number of objects containing at least one reference that may fit into a single car <ref> [GS93] </ref>. In practice this behavior should not be expected because it would require extremely poor locality of reference.
Reference: [HM92] <author> Richard L. Hudson and J. Eliot B. Moss: </author> <title> Incremental Collection of Mature Objects, </title> <booktitle> Proceedings of the International Workshop on Memory Management, </booktitle> <month> September </month> <year> 1992, </year> <pages> pp. 388-403. </pages>
Reference-contexts: Traditionally, conventional techniques have been employed for old generation collection, leading to pauses which, although less frequent, are still highly disruptive. Recently, Hudson & Moss have introduced an exciting new algorithm, the Train Algorithm, for performing efficient incremental collection of old generation space <ref> [HM92] </ref>. Using the algorithm, generational collectors can be extended to provide non-disruptive collection of all generational areas. In the following, we present the results from a practical implementation of the Train Algorithm [GS93]. Section 2 describes the basic ideas behind the algorithm. Section 3 concerns the practical implementation issues. <p> Section 3 concerns the practical implementation issues. Section 4 presents the measurement results. Section 5 points out future research directions. 2 The Algorithm This section deals with the theoretical aspects of the Train Algorithm. For a more detailed presentation of the algorithm including a couple of enlightening examples, see <ref> [HM92, GS93] </ref>. Section 2.1 outlines the main ideas behind the algorithm and introduces the terminology needed in later sections. (Readers familiar with the algorithm may wish to skip this part.) Section 2.2 identifies and corrects a subtle error in the original algorithm. <p> This technique is known to induce significant run-time overheads [Ung86]. As an alternative approach, Hudson & Moss tentatively suggest that cars containing popular objects should not be collected at all. Instead, such cars should be retained, logically (but not physically) moving them to the end of the newest train <ref> [HM92, Section 6] </ref>. Unfortunately, a closer analysis shows that this approach may leave garbage undetected, so a number of refinements are needed. First, one cannot simply retain popular cars, but must evacuate all non-popular objects from them.
Reference: [HMDW91] <author> Richard L. Hudson, J. Eliot B. Moss, Amer Diwan, and Christo-pher F. </author> <title> Weight: A Language-Independent Garbage Collector Toolkit, </title> <type> COINS Technical Report 91-47, </type> <institution> University of Massachusetts, Amherst, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: Given a pointer address, the train table information can be quickly accessed by right-shifting the address n bits and using the result as an index <ref> [HMDW91] </ref>. 2.2 Correctness Given a garbage structure contained in mature object space, denote the trains holding it the set of garbage trains. The structure of this set will not be changed by the mutator because garbage objects are per definition unreachable and therefore immutable.
Reference: [HMS92] <author> Anthony L. Hosking, J. Eliot B. Moss, </author> <title> and Darko Stefanovic: </title>
Reference-contexts: For instance, the remembered set implementation seems to play a crucial role. It would be highly instructive to examine the effects of using alternative strategies, such as dirty pages, cards, etc. <ref> [HMS92] </ref>. Also, further experiments with different car sizes and evacuation strategies would be interesting, as would more work concerning the treatment of popular objects.
References-found: 5

