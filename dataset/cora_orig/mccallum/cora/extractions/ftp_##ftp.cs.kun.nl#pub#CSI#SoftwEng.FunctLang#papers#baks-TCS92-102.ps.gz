URL: ftp://ftp.cs.kun.nl/pub/CSI/SoftwEng.FunctLang/papers/baks-TCS92-102.ps.gz
Refering-URL: http://www.cs.kun.nl/~clean/Clean.Papers.html
Root-URL: 
Email: e-mail: steffen@cs.kun.nl  
Title: Complete restrictions of the intersection type discipline  
Author: Steffen van Bakel 
Address: Nijmegen, Toernooiveld 1, 6525 ED Nijmegen, The Netherlands.  
Affiliation: Department of Informatics, Faculty of Mathematics and Informatics, University of  
Abstract: In this paper the intersection type discipline as defined in [Barendregt et al. '83] is studied. We will present two different and independent complete restrictions of the intersection type discipline. The first restricted system, the strict type assignment system, is presented in section two. Its major feature is the absence of the derivation rule () and it is based on a set of strict types. We will show that these together give rise to a strict filter lambda model that is essentially different from the one presented in [Barendregt et al. '83]. We will show that the strict type assignment system is the nucleus of the full system, i.e. for every derivation in the intersection type discipline there is a derivation in which () is used only at the very end. Finally we will prove that strict type assignment is complete for inference semantics. The second restricted system is presented in section three. Its major feature is the absence of the type !. We will show that this system gives rise to a filter I-model and that type assignment without ! is complete for the I-calculus. Finally we will prove that a lambda term is typeable in this system if and only if it is strongly normalizable.
Abstract-found: 1
Intro-found: 1
Reference: [Barendregt '84] <author> Barendregt H. </author> <title> The Lambda Calculus: its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <note> revised edition, </note> <year> 1984. </year>
Reference-contexts: It is easy to check that F and G are continuous. Theorem 2.1.8 &lt;F S , &gt; with F and G as defined in 2.1.7 is a lambda model. Proof: By <ref> [Barendregt '84] </ref>.5.4.1 it is sufficient to prove that FffiG = id [F !F ] . FffiG f d = 8 "f j 9 2 d [ ! 2 "f!t j t 2 f (")g]g = ((2.1.5 (ii))) f (d). <p> the equation D ' P ! fi [D ! ? D], with D 0 = P ! (where P ! is the powerset of natural numbers) and i: D 0 !P ! fi [D 0 ! ? D 0 ] is defined by i (d) = &lt;d, x:?&gt; (see also <ref> [Barendregt '84] </ref>, exercise 18.4.26 and [Plotkin & Smyth '78].) It is straightforward to verify that F ! is a solution of the same domain equation. <p> Proof: If M is strongly normalizable, then by using the inside out reduction strategy (see <ref> [Barendregt '84] </ref>, definition 14.2.11) the normal form of M will be reached. This strategy has the special property that a redex (x:P )Q can only be contracted if Q is in normal form.
Reference: [Barendregt et al. '83] <author> Barendregt H., M. Coppo, and M. Dezani-Ciancaglini. </author> <title> A filter lambda model and the completeness of type assignment. </title> <journal> The Journal of Symbolic Logic, </journal> <volume> 48(4) </volume> <pages> 931-940, </pages> <year> 1983. </year> <month> 23 </month>
Reference-contexts: Principal type schemes for Curry's system are defined by J.R. Hindley [Hindley '69]. The intersection type discipline as presented in <ref> [Barendregt et al. '83] </ref> does not contain these drawbacks. It is based on the Curry type assignment system: in addition to the type constructor `!' it contains a type constructor `"' and a type constant `!'. These extensions were introduced to obtain a system that is closed under fi-equality. <p> A first introduction of a type assignment system with intersection types can be found in [Coppo & Dezani-Ciancaglini '80], a system with intersection types and ! is introduced in [Coppo et al. '81] and in [Salle '78]. In <ref> [Barendregt et al. '83] </ref> the system as presented in [Coppo et al. '81] was strengthened further by introducing a partial order relation `' on types as well as adding the type assignment rule (), and a more general form of the rules concerning intersection. <p> Using this model, completeness is proved. Other interesting use of filter lambda models can be found in [Coppo et al. '84], [Coppo et al. '87], [Dezani-Ciancaglini & Margaria '84] and [Dezani-Ciancaglini & Margaria '86]. For the system as defined in <ref> [Barendregt et al. '83] </ref>, principal type schemes can be defined as in [Ronchi della Rocca & Venneri '84]. <p> The elimination of induces a set of strict types, a restriction of the set of types used in the 1 Unlike in <ref> [Barendregt et al. '83] </ref>, we will use the notation `M:' for the statement ` is a type for M '. 2 intersection type assignment system. Strict types are the types that are strictly needed to assign a type to terms. <p> In this way we obtain a syntax directed system. It turns out to be the nucleus of the intersection type assignment system. The strict system gives rise to a strict filter lambda model F S that satisfies all major properties of the filter lambda model F as presented in <ref> [Barendregt et al. '83] </ref>, but is an essentially different lambda model. In constructing a complete system, the semantics of types play a crucial role. <p> There are roughly three notions of type semantics that differ in the meaning of an arrow type scheme: inference type interpretations, simple type interpretations and F type interpretations. These different notions of type interpretations induce of course different notions of semantic satisfiability. The intersection type assignment as presented in <ref> [Barendregt et al. '83] </ref>, is sound and complete with respect to the simple type semantics. In this paper we will show that soundness is lost if instead of simple type semantics, the inference type semantics is used. <p> In this section we give the definition of the intersection type discipline as presented in <ref> [Barendregt et al. '83] </ref>, together with its major features. <p> M is the subject and the predicate of M :. v) A basis is a set of statements with only variables (not necessarily distinct) as subjects. T may be considered modulo ~ . Then becomes a partial order. Notice that in the original paper <ref> [Barendregt et al. '83] </ref> the type inclusion relation is defined in a slightly different way. Instead of rule 1.1 (ii.h) the rules h.1.: t & ) " t ". are given. It is not difficult to show that these definitions are equivalent. <p> :!t (!E): M : M :t M :"t ("E): M :"t M : t M :t M :! (a): If x: is the only statement about x on which M :t depends. ii) If M : is derivable from a basis B, we write B ` M :. 4 In <ref> [Barendregt et al. '83] </ref> several properties of this type assignment system are proved. <p> Definition 1.3 The following properties are used in this paper and are listed here to be able to refer to them easily: i) <ref> [Barendregt et al. '83] </ref>.2.8 (i): B ` M N :t ) 9 2 T [ B ` M :!t & B ` N : ]. ii) [Barendregt et al. '83].2.8 (iii): B ` x:M :!t () Bnx 2 [ fx:g ` M :t . iii) [Barendregt et al. '83].4.13 (i): 9 <p> Definition 1.3 The following properties are used in this paper and are listed here to be able to refer to them easily: i) <ref> [Barendregt et al. '83] </ref>.2.8 (i): B ` M N :t ) 9 2 T [ B ` M :!t & B ` N : ]. ii) [Barendregt et al. '83].2.8 (iii): B ` x:M :!t () Bnx 2 [ fx:g ` M :t . iii) [Barendregt et al. '83].4.13 (i): 9 B, [ B ` M : & 6= ! ] ) M has a head normal form. iv) [Barendregt et al. '83].4.13 (ii): 9 B, [ <p> refer to them easily: i) <ref> [Barendregt et al. '83] </ref>.2.8 (i): B ` M N :t ) 9 2 T [ B ` M :!t & B ` N : ]. ii) [Barendregt et al. '83].2.8 (iii): B ` x:M :!t () Bnx 2 [ fx:g ` M :t . iii) [Barendregt et al. '83].4.13 (i): 9 B, [ B ` M : & 6= ! ] ) M has a head normal form. iv) [Barendregt et al. '83].4.13 (ii): 9 B, [ B ` M : & B, !-free ] () M has a normal form. v) [Barendregt et al. '83].2.7 <p> & B ` N : ]. ii) <ref> [Barendregt et al. '83] </ref>.2.8 (iii): B ` x:M :!t () Bnx 2 [ fx:g ` M :t . iii) [Barendregt et al. '83].4.13 (i): 9 B, [ B ` M : & 6= ! ] ) M has a head normal form. iv) [Barendregt et al. '83].4.13 (ii): 9 B, [ B ` M : & B, !-free ] () M has a normal form. v) [Barendregt et al. '83].2.7 (ii): B ` x:t ) 9 x:t 1 , : : : , x:t n 2 B [ t 1 " "t n t <p> :t . iii) <ref> [Barendregt et al. '83] </ref>.4.13 (i): 9 B, [ B ` M : & 6= ! ] ) M has a head normal form. iv) [Barendregt et al. '83].4.13 (ii): 9 B, [ B ` M : & B, !-free ] () M has a normal form. v) [Barendregt et al. '83].2.7 (ii): B ` x:t ) 9 x:t 1 , : : : , x:t n 2 B [ t 1 " "t n t ]. vi) [Dezani-Ciancaglini & Margaria '86].5.6: (t 1 " "t n )! ) = (t 1 n ! 1 )" "(t s n <p> To achieve the completeness result we will have to use inference semantics as defined in [Mitchell '88] as a notion of type interpretation, instead of the simple semantics as used in <ref> [Barendregt et al. '83] </ref>. <p> As in <ref> [Barendregt et al. '83] </ref> we aim to construct a filter lambda model. By use of names we will distinguish between the definition of filters in that paper and the ones given here. <p> We define application on F S , : F S fiF S !F S by: d e = "ft j 9 2 e [ !t 2 d ]g. The application on filters as defined in <ref> [Barendregt et al. '83] </ref> is not useful in our approach, since it would not be well defined. <p> FffiG f d = 8 "f j 9 2 d [ ! 2 "f!t j t 2 f (")g]g = ((2.1.5 (ii))) f (d). Remark that F S and the filter lambda model F defined in <ref> [Barendregt et al. '83] </ref> are not isomorphic as complete lattices, since for example in F the filter "("t )! is contained in "! but in F S the strict filter " S ("t )! is not contained in " S !. <p> Then by theorem 2.2.5 (ii) B' ` S M :'. 2.3 Soundness and completeness of strict type assignment In this subsection we will prove completeness for the ` S system. This is done in a way very similar to the one used in <ref> [Barendregt et al. '83] </ref>, using the strict filter lambda model as defined in subsection 2.1. At one very crucial point the completeness proof in this subsection differs from the one in [Barendregt et al. '83]. <p> This is done in a way very similar to the one used in <ref> [Barendregt et al. '83] </ref>, using the strict filter lambda model as defined in subsection 2.1. At one very crucial point the completeness proof in this subsection differs from the one in [Barendregt et al. '83]. In that paper the simple type semantic is inductively defined whereas our approach will be to give a map from T S to -(F S ) and prove that it is a type interpretation. <p> In that paper the simple type semantic is inductively defined whereas our approach will be to give a map from T S to -(F S ) and prove that it is a type interpretation. It will be a different kind of type interpretation than the one used in <ref> [Barendregt et al. '83] </ref>, because the latter would not suffice in our case. Following essentially [Mitchell '88], we distinguish between several kinds of type interpretations. Definition 2.3.1 i) Let M = &lt;D, , "&gt; be a continuous lambda model. <p> Proof: i) Because for every x, ~ B (x) is a strict filter. ii) x: 2 B ) (i) 2 ft j B ~ B ` S x:t g ) 2 [[ x ]] ~ B . The system of <ref> [Barendregt et al. '83] </ref> has been proved complete with respect to the simple type semantics. The system ` S however is not complete in this semantics. <p> Proof: By induction on the structure of derivations, using 1.3 (ii) to prove (ii). The proof given for this part in <ref> [Barendregt et al. '83] </ref> does not depend on !. Definition 3.1.3 i) A subset d of T ! is called an I-filter if a) , t 2 d ) "t 2 d. ii) F ! = fd T ! j d is an I-filterg. <p> Because M and M ' are I-terms, by corollary 3.4.3 we obtain B ` ! M :. 3.3 The type assignment without ! is complete for the I-calculus In this subsection completeness of type assignment without ! for the I-calculus is proved using the method of <ref> [Barendregt et al. '83] </ref>. The notions of type interpretation as defined in 2.3.1 lead also in the case of the I-calculus in a natural way to the following definitions for semantic satisfiability.
Reference: [Coppo & Dezani-Ciancaglini '80] <author> Coppo M. and M. Dezani-Ciancaglini. </author> <title> An Extension of the Basic Functionality Theory for the -Calculus. </title> <journal> Notre Dame, Journal of Formal Logic, </journal> <volume> 21(4) </volume> <pages> 685-693, </pages> <year> 1980. </year>
Reference-contexts: A first introduction of a type assignment system with intersection types can be found in <ref> [Coppo & Dezani-Ciancaglini '80] </ref>, a system with intersection types and ! is introduced in [Coppo et al. '81] and in [Salle '78]. <p> 1 i n, 1 j s and 1 " " s . 2 The system without derivation rule () In this section we will give an extension (without the ()-rule) of the Curry type assignment system, which in fact will be a combination of both the systems as presented in <ref> [Coppo & Dezani-Ciancaglini '80] </ref> and [Coppo et al. '81], and is almost the same as the one presented in [Coppo et al. '80]. We will prove that this system also yields a filter lambda model (subsection 2.1) and that type assignment in this system is complete (subsection 2.3). <p> This definition would cause a lot of words in the proofs and perhaps also a lot of confusion. We therefore prefer two different notions of derivability. Apart from the presence of !, the type assignment defined by ` S is in fact the same as the one presented in <ref> [Coppo & Dezani-Ciancaglini '80] </ref>. Also, the one defined by ` s is in fact the same as in [Coppo et al. '81].
Reference: [Coppo et al. '84] <author> Coppo M., M. Dezani-Ciancaglini, F. Honsell, and G. Longo. </author> <title> Extended type structures and filter lambda models. </title> <editor> In G. Lolli, G. Longo, and A. Marcja, editors, </editor> <booktitle> Logic Colloquium 82, </booktitle> <pages> pages 241-262, </pages> <address> Amsterdam, 1984. </address> <publisher> North-Holland. </publisher>
Reference-contexts: Using this model, completeness is proved. Other interesting use of filter lambda models can be found in <ref> [Coppo et al. '84] </ref>, [Coppo et al. '87], [Dezani-Ciancaglini & Margaria '84] and [Dezani-Ciancaglini & Margaria '86]. For the system as defined in [Barendregt et al. '83], principal type schemes can be defined as in [Ronchi della Rocca & Venneri '84].
Reference: [Coppo et al. '80] <author> Coppo M., M. Dezani-Ciancaglini, and B. Venneri. </author> <title> Principal type schemes and - calculus semantics. </title> <editor> In J. R. Hindley and J. P. Seldin, editors, To H. B. </editor> <booktitle> Curry, Essays in combinatory logic, lambda-calculus and formalism, </booktitle> <pages> pages 535-560. </pages> <publisher> Academic press, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: In this section we will give an extension (without the ()-rule) of the Curry type assignment system, which in fact will be a combination of both the systems as presented in [Coppo & Dezani-Ciancaglini '80] and [Coppo et al. '81], and is almost the same as the one presented in <ref> [Coppo et al. '80] </ref>. We will prove that this system also yields a filter lambda model (subsection 2.1) and that type assignment in this system is complete (subsection 2.3). <p> Also, the one defined by ` s is in fact the same as in [Coppo et al. '81]. The type assignment defined by ` S is in fact the same as the one presented in <ref> [Coppo et al. '80] </ref>, it is only different in a standard way of writing bases.
Reference: [Coppo et al. '81] <author> Coppo M., M. Dezani-Ciancaglini, and B. Venneri. </author> <title> Functional characters of solvable terms. </title> <journal> Zeitschrift fur Mathematische Logik und Grundlagen der Mathematik, </journal> <volume> 27 </volume> <pages> 45-58, </pages> <year> 1981. </year>
Reference-contexts: A first introduction of a type assignment system with intersection types can be found in [Coppo & Dezani-Ciancaglini '80], a system with intersection types and ! is introduced in <ref> [Coppo et al. '81] </ref> and in [Salle '78]. In [Barendregt et al. '83] the system as presented in [Coppo et al. '81] was strengthened further by introducing a partial order relation `' on types as well as adding the type assignment rule (), and a more general form of the rules <p> A first introduction of a type assignment system with intersection types can be found in [Coppo & Dezani-Ciancaglini '80], a system with intersection types and ! is introduced in <ref> [Coppo et al. '81] </ref> and in [Salle '78]. In [Barendregt et al. '83] the system as presented in [Coppo et al. '81] was strengthened further by introducing a partial order relation `' on types as well as adding the type assignment rule (), and a more general form of the rules concerning intersection. The rule () is introduced mainly to prove completeness of type assignment. <p> Moreover there are several ways to deduce a desired result, due to the presence of the derivation rules ("I), ("E) and (), which allow superfluous steps in derivations. In the system as presented in <ref> [Coppo et al. '81] </ref>, these rules are not present and there is a one-one relationship between terms and derivations. In other words: the system is syntax directed. <p> Strict types are the types that are strictly needed to assign a type to terms. The strict type assignment system is constructed from the set of strict types and a minor extension of the derivation rules as defined in <ref> [Coppo et al. '81] </ref>. In this way we obtain a syntax directed system. It turns out to be the nucleus of the intersection type assignment system. <p> s and 1 " " s . 2 The system without derivation rule () In this section we will give an extension (without the ()-rule) of the Curry type assignment system, which in fact will be a combination of both the systems as presented in [Coppo & Dezani-Ciancaglini '80] and <ref> [Coppo et al. '81] </ref>, and is almost the same as the one presented in [Coppo et al. '80]. We will prove that this system also yields a filter lambda model (subsection 2.1) and that type assignment in this system is complete (subsection 2.3). <p> We therefore prefer two different notions of derivability. Apart from the presence of !, the type assignment defined by ` S is in fact the same as the one presented in [Coppo & Dezani-Ciancaglini '80]. Also, the one defined by ` s is in fact the same as in <ref> [Coppo et al. '81] </ref>. The type assignment defined by ` S is in fact the same as the one presented in [Coppo et al. '80], it is only different in a standard way of writing bases. <p> The same result has been given in <ref> [Coppo et al. '81] </ref>, [Leivant '83] and [Pottinger '80]. However, the proof in [Leivant '83] is too brief, the proof in [Pottinger '80] gives few details and the proof in [Coppo et al. '81] is not complete. In this subsection we present a complete and formal proof. <p> The same result has been given in <ref> [Coppo et al. '81] </ref>, [Leivant '83] and [Pottinger '80]. However, the proof in [Leivant '83] is too brief, the proof in [Pottinger '80] gives few details and the proof in [Coppo et al. '81] is not complete. In this subsection we present a complete and formal proof. In [Ronchi della Rocca '88] a similar result is proved: B ` ! M : () M is strongly normalizable.
Reference: [Coppo et al. '87] <author> Coppo M., M. Dezani-Ciancaglini, and M. Zacchi. </author> <title> Type Theories, Normal Forms and D 1 -Lambda-Models. </title> <journal> Information and Computation, </journal> <volume> 72(2) </volume> <pages> 85-116, </pages> <year> 1987. </year>
Reference-contexts: Using this model, completeness is proved. Other interesting use of filter lambda models can be found in [Coppo et al. '84], <ref> [Coppo et al. '87] </ref>, [Dezani-Ciancaglini & Margaria '84] and [Dezani-Ciancaglini & Margaria '86]. For the system as defined in [Barendregt et al. '83], principal type schemes can be defined as in [Ronchi della Rocca & Venneri '84].
Reference: [Curry '34] <author> Curry H.B. </author> <title> Functionality in combinatory logic. </title> <journal> In Proc. Nat. Acad. Sci. U.S.A., </journal> <volume> volume 20, </volume> <pages> pages 584-590, </pages> <year> 1934. </year>
Reference-contexts: One of the first and most primitive ones was introduced by H.B. Curry in <ref> [Curry '34] </ref>. (See also [Curry & Feys '58]). His system expresses abstraction and application and has as its major advantage that it is decidable to determine whether a lambda term is typeable by this system.
Reference: [Curry & Feys '58] <author> Curry H.B. and R. </author> <title> Feys. </title> <booktitle> Combinatory Logic. </booktitle> <volume> volume 1. </volume> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1958. </year>
Reference-contexts: One of the first and most primitive ones was introduced by H.B. Curry in [Curry '34]. (See also <ref> [Curry & Feys '58] </ref>). His system expresses abstraction and application and has as its major advantage that it is decidable to determine whether a lambda term is typeable by this system. Because of this decidability it is used as a basis for type checkers used in functional programming languages.
Reference: [Dezani-Ciancaglini et al. '86] <author> Dezani-Ciancaglini M., F. Honsell, and S. Ronchi della Rocca. </author> <title> Models for theories of functions strictly depending on all their arguments. Stanford ASL Summer Meeting '85. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 51 </volume> (2):845-846, 1986. abstract. 
Reference-contexts: Moreover, in <ref> [Dezani-Ciancaglini et al. '86] </ref> the following is stated: Proposition 3.1.7 ([Dezani-Ciancaglini et al. '86]) If &lt;D, &gt; is a cpo and there are continuous maps F: D![D ! ? D] and G: [D ! ? D]!D such that: i) FffiG = id [D! ? D] ii) GffiF 2 [D ! ?
Reference: [Dezani-Ciancaglini & Margaria '84] <author> Dezani-Ciancaglini M. and I. Margaria. </author> <title> F-semantics for intersection type discipline. </title> <editor> In G. R. Kahn, D. B. Macqueen, and G. Plotkin, editors, </editor> <booktitle> Sematics of data types. International symposium Sophia Antipolis, France, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 279-300. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Using this model, completeness is proved. Other interesting use of filter lambda models can be found in [Coppo et al. '84], [Coppo et al. '87], <ref> [Dezani-Ciancaglini & Margaria '84] </ref> and [Dezani-Ciancaglini & Margaria '86]. For the system as defined in [Barendregt et al. '83], principal type schemes can be defined as in [Ronchi della Rocca & Venneri '84].
Reference: [Dezani-Ciancaglini & Margaria '86] <author> Dezani-Ciancaglini M. and I. Margaria. </author> <title> A characterisation of F-complete type assignments. </title> <journal> Theoretical Computer Science, </journal> <volume> 45 </volume> <pages> 121-157, </pages> <year> 1986. </year>
Reference-contexts: Using this model, completeness is proved. Other interesting use of filter lambda models can be found in [Coppo et al. '84], [Coppo et al. '87], [Dezani-Ciancaglini & Margaria '84] and <ref> [Dezani-Ciancaglini & Margaria '86] </ref>. For the system as defined in [Barendregt et al. '83], principal type schemes can be defined as in [Ronchi della Rocca & Venneri '84]. <p> In constructing a complete system, the semantics of types play a crucial role. As in <ref> [Dezani-Ciancaglini & Margaria '86] </ref>, [Mitchell '88] and essentially following [Hindley '82], a distinction can be made between several notions of type interpretations and semantic satis-fiability. <p> '83].4.13 (ii): 9 B, [ B ` M : & B, !-free ] () M has a normal form. v) [Barendregt et al. '83].2.7 (ii): B ` x:t ) 9 x:t 1 , : : : , x:t n 2 B [ t 1 " "t n t ]. vi) <ref> [Dezani-Ciancaglini & Margaria '86] </ref>.5.6: (t 1 " "t n )! ) = (t 1 n ! 1 )" "(t s n ! s )"', for some t j n , j , ' such that t i t i with 1 i n, 1 j s and 1 " " s
Reference: [Hindley '69] <author> Hindley J.R. </author> <title> The principal type scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 146 </volume> <pages> 29-60, </pages> <year> 1969. </year>
Reference-contexts: Curry's type assignment system has however drawbacks. It is not capable of assigning a type to x:xx, and although the lambda terms cd:d and (xyz:xz (yz))(ab:a) are fi-equal, the principal type schemes for these terms are different. Principal type schemes for Curry's system are defined by J.R. Hindley <ref> [Hindley '69] </ref>. The intersection type discipline as presented in [Barendregt et al. '83] does not contain these drawbacks. It is based on the Curry type assignment system: in addition to the type constructor `!' it contains a type constructor `"' and a type constant `!'.
Reference: [Hindley '82] <author> Hindley J.R. </author> <title> The simple semantics for Coppo-Dezani-Salle type assignment. </title> <editor> In M. Dezani and U. Montanari, editors, </editor> <booktitle> International symposium on programming, volume 137 of Lecture Notes in Computer Science, </booktitle> <pages> pages 212-226. </pages> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: In constructing a complete system, the semantics of types play a crucial role. As in [Dezani-Ciancaglini & Margaria '86], [Mitchell '88] and essentially following <ref> [Hindley '82] </ref>, a distinction can be made between several notions of type interpretations and semantic satis-fiability. There are roughly three notions of type semantics that differ in the meaning of an arrow type scheme: inference type interpretations, simple type interpretations and F type interpretations. <p> The proof is based on the fact that for every 2 T there is a ' 2 T S such that ~ ' (Lemma 2.2.2; the same result has been stated in <ref> [Hindley '82] </ref>, $4), and the approximation theorem as given in [Ronchi della Rocca & Venneri '84]. <p> Lemma 2.2.2 (cf. <ref> [Hindley '82] </ref>) For every 2 T there is a ' 2 T S such that ~ '. Proof: By induction on the structure of types in T . i) = !, or is a type variable: trivial. 11 ii) = !t .
Reference: [Hindley '83] <author> Hindley J.R. </author> <title> The Completeness Theorem for Typing -terms. </title> <journal> Theoretical Computer Science, </journal> <volume> 22(1) </volume> <pages> 1-17, </pages> <year> 1983. </year>
Reference-contexts: A mapping : T !-(D) is a type interpretation if and only if: a) f" d j 8 e [ e 2 () ) d e 2 (t) ]g (!t ). c) ("t ) = ()"(t). ii) Following <ref> [Hindley '83] </ref> we say that a type interpretation is simple if and only if: (!t ) = fd j 8 e [ e 2 () ) d e 2 (t) ]g. iii) On the other hand, a type interpretation is called an F type interpretation if it satisfies: (!t ) =
Reference: [Honsell & Ronchi della Rocca '84] <author> Honsell F. and S. Ronchi della Rocca. </author> <title> Models for theories of functions strictly depending on all their arguments. </title> <type> Internal report, </type> <institution> Department of Computer Science, Turin, Italy, </institution> <year> 1984. </year>
Reference-contexts: 2 "f!t j t 2 f (")g ]g = ((3.1.4)) f (d). ii) GffiF (;) = "f! j 2 f j 9 t 2 " [ t ! 2 ; ]gg = That the type discipline without ! gives rise to a model for the I-calculus, is also proved in <ref> [Honsell & Ronchi della Rocca '84] </ref>.
Reference: [Leivant '83] <author> Leivant D. </author> <title> Polymorphic Type Inference. </title> <booktitle> In Proceedings 10 th ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin Texas, </address> <pages> pages 88-98, </pages> <year> 1983. </year>
Reference-contexts: The same result has been given in [Coppo et al. '81], <ref> [Leivant '83] </ref> and [Pottinger '80]. However, the proof in [Leivant '83] is too brief, the proof in [Pottinger '80] gives few details and the proof in [Coppo et al. '81] is not complete. In this subsection we present a complete and formal proof. <p> The same result has been given in [Coppo et al. '81], <ref> [Leivant '83] </ref> and [Pottinger '80]. However, the proof in [Leivant '83] is too brief, the proof in [Pottinger '80] gives few details and the proof in [Coppo et al. '81] is not complete. In this subsection we present a complete and formal proof.
Reference: [Milner '78] <author> Milner R. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Because of this decidability it is used as a basis for type checkers used in functional programming languages. The functional programming language ML <ref> [Milner '78] </ref> for example, is in fact an extended lambda calculus and it contains a type checker based on Curry's system.
Reference: [Mitchell '88] <author> Mitchell J.C. </author> <title> Polymorphic Type Inference and Containment. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 211-249, </pages> <year> 1988. </year>
Reference-contexts: In constructing a complete system, the semantics of types play a crucial role. As in [Dezani-Ciancaglini & Margaria '86], <ref> [Mitchell '88] </ref> and essentially following [Hindley '82], a distinction can be made between several notions of type interpretations and semantic satis-fiability. There are roughly three notions of type semantics that differ in the meaning of an arrow type scheme: inference type interpretations, simple type interpretations and F type interpretations. <p> We will prove that this system also yields a filter lambda model (subsection 2.1) and that type assignment in this system is complete (subsection 2.3). To achieve the completeness result we will have to use inference semantics as defined in <ref> [Mitchell '88] </ref> as a notion of type interpretation, instead of the simple semantics as used in [Barendregt et al. '83]. <p> It will be a different kind of type interpretation than the one used in [Barendregt et al. '83], because the latter would not suffice in our case. Following essentially <ref> [Mitchell '88] </ref>, we distinguish between several kinds of type interpretations. Definition 2.3.1 i) Let M = &lt;D, , "&gt; be a continuous lambda model.
Reference: [Plotkin & Smyth '78] <author> Plotkin G.D. and M.B. Smyth. </author> <title> The category-theoretic solution of recursive domain equations. </title> <type> DAI Research Report 60, </type> <institution> University of Edinburgh, </institution> <address> Scotland, </address> <year> 1978. </year>
Reference-contexts: ! fi [D ! ? D], with D 0 = P ! (where P ! is the powerset of natural numbers) and i: D 0 !P ! fi [D 0 ! ? D 0 ] is defined by i (d) = &lt;d, x:?&gt; (see also [Barendregt '84], exercise 18.4.26 and <ref> [Plotkin & Smyth '78] </ref>.) It is straightforward to verify that F ! is a solution of the same domain equation.
Reference: [Pottinger '80] <author> Pottinger G. </author> <title> A type assignment for the strongly normalizable -terms. </title> <editor> In J. R. Hind-ley and J. P. Seldin, editors, To H. B. </editor> <booktitle> Curry, Essays in combinatory logic, lambda-calculus and formalism, </booktitle> <pages> pages 561-577. </pages> <publisher> Academic press, </publisher> <address> New York, </address> <year> 1980. </year> <month> 24 </month>
Reference-contexts: The same result has been given in [Coppo et al. '81], [Leivant '83] and <ref> [Pottinger '80] </ref>. However, the proof in [Leivant '83] is too brief, the proof in [Pottinger '80] gives few details and the proof in [Coppo et al. '81] is not complete. In this subsection we present a complete and formal proof. <p> The same result has been given in [Coppo et al. '81], [Leivant '83] and <ref> [Pottinger '80] </ref>. However, the proof in [Leivant '83] is too brief, the proof in [Pottinger '80] gives few details and the proof in [Coppo et al. '81] is not complete. In this subsection we present a complete and formal proof. In [Ronchi della Rocca '88] a similar result is proved: B ` ! M : () M is strongly normalizable. <p> In order to prove that each term typeable in ` ! is strongly normalizable we introduce a notion of computability. From now on, we will abbreviate `M is strongly normalizable' by SN (M ). Definition 3.4.5 (cf. <ref> [Pottinger '80] </ref>) Comp (B, M , ) is inductively defined by: i) Comp (B, M , ') () B ` ! M :' & SN (M ). ii) Comp (B, M , !t ) () (Comp (B', N , ) ) Comp (B [ B', M N , t )). iii)
Reference: [Ronchi della Rocca '88] <author> Ronchi della Rocca S. </author> <title> Principal type scheme and unification for intersection type discipline. </title> <journal> Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 181-209, </pages> <year> 1988. </year>
Reference-contexts: However, the proof in [Leivant '83] is too brief, the proof in [Pottinger '80] gives few details and the proof in [Coppo et al. '81] is not complete. In this subsection we present a complete and formal proof. In <ref> [Ronchi della Rocca '88] </ref> a similar result is proved: B ` ! M : () M is strongly normalizable. <p> To prove that each term typeable by the rules ("I), ("E), (!I) and (!E) is strongly normalizable, we will prove even more: we will show that if B ` ! M : (i.e. using also rule ()), then M is strongly normalizable. In <ref> [Ronchi della Rocca '88] </ref> this result is given in corollary 6.3 and is obtained from the theorem that the procedure PP' (as defined in [Ronchi della Rocca '88], section 6) finds a principal pair for all and nothing but the strongly normalizable terms. <p> In <ref> [Ronchi della Rocca '88] </ref> this result is given in corollary 6.3 and is obtained from the theorem that the procedure PP' (as defined in [Ronchi della Rocca '88], section 6) finds a principal pair for all and nothing but the strongly normalizable terms. In this subsection we present a proof for the same result, different from the one given in [Ronchi della Rocca '88]. <p> 6.3 and is obtained from the theorem that the procedure PP' (as defined in <ref> [Ronchi della Rocca '88] </ref>, section 6) finds a principal pair for all and nothing but the strongly normalizable terms. In this subsection we present a proof for the same result, different from the one given in [Ronchi della Rocca '88]. The proof that all strongly normalizable terms are typeable in the system without ! and () is given in corollary 3.4.4. Notice that an I-filter can be empty.
Reference: [Ronchi della Rocca & Venneri '84] <author> Ronchi della Rocca S. and B. Venneri. </author> <title> Principal type schemes for an extended type theory. </title> <journal> Theoretical Computer Science, </journal> <volume> 28 </volume> <pages> 151-169, </pages> <year> 1984. </year>
Reference-contexts: Other interesting use of filter lambda models can be found in [Coppo et al. '84], [Coppo et al. '87], [Dezani-Ciancaglini & Margaria '84] and [Dezani-Ciancaglini & Margaria '86]. For the system as defined in [Barendregt et al. '83], principal type schemes can be defined as in <ref> [Ronchi della Rocca & Venneri '84] </ref>. Instances of types can be obtained by substitution, operations of rise (applying ()) or expansion (introducing intersection types by replacing a sub-derivation by more than one sub-derivation with the same structure, followed by an intersection introduction). <p> The proof is based on the fact that for every 2 T there is a ' 2 T S such that ~ ' (Lemma 2.2.2; the same result has been stated in [Hindley '82], $4), and the approximation theorem as given in <ref> [Ronchi della Rocca & Venneri '84] </ref>. <p> Theorem 2.2.5 i) B ` M : () 9 A 2 A (M ) [ B ` A: ]. ii) B ` S M : () 9 A 2 A (M ) [ B ` S A: ]. Proof: i) <ref> [Ronchi della Rocca & Venneri '84] </ref>.2.13. ii) The structure of the proof of [Ronchi della Rocca & Venneri '84].2.13 is same as the structure of the proof for this part. <p> Proof: i) <ref> [Ronchi della Rocca & Venneri '84] </ref>.2.13. ii) The structure of the proof of [Ronchi della Rocca & Venneri '84].2.13 is same as the structure of the proof for this part. Theorem 2.2.6 If B ` M : then there are B', ' 2 T S such that B' ` S M :', ' and B' B.
Reference: [Salle '78] <author> Salle P. </author> <title> Une extension de la theorie des types. </title> <editor> In G. Ausiello and C. Bohm, editors, </editor> <booktitle> Automata, languages and programming. Fifth Colloquium, Udine, Italy, volume 62 of Lecture Notes in Computer Science, </booktitle> <pages> pages 398-410. </pages> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference-contexts: A first introduction of a type assignment system with intersection types can be found in [Coppo & Dezani-Ciancaglini '80], a system with intersection types and ! is introduced in [Coppo et al. '81] and in <ref> [Salle '78] </ref>. In [Barendregt et al. '83] the system as presented in [Coppo et al. '81] was strengthened further by introducing a partial order relation `' on types as well as adding the type assignment rule (), and a more general form of the rules concerning intersection.
Reference: [Turner '85] <author> Turner D.A. Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <booktitle> In Proceedings of the conference on Functional Programming Languages and Computer Architecture, volume 201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-16. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <month> 25 </month>
Reference-contexts: Miranda, a functional programming language designed and implemented by fl Research performed at the Department of Computer Science, Turin, Italy, and supported by the Netherlands Organisation for the advancement of pure research (N.W.O.). 1 D. Turner <ref> [Turner '85] </ref>, contains a type checker based on the ML type assignment system. Curry's type assignment system has however drawbacks. It is not capable of assigning a type to x:xx, and although the lambda terms cd:d and (xyz:xz (yz))(ab:a) are fi-equal, the principal type schemes for these terms are different.
References-found: 25

