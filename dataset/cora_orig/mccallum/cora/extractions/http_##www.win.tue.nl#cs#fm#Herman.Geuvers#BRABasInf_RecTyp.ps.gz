URL: http://www.win.tue.nl/cs/fm/Herman.Geuvers/BRABasInf_RecTyp.ps.gz
Refering-URL: http://www.win.tue.nl/cs/fm/Herman.Geuvers/
Root-URL: http://www.win.tue.nl
Title: Inductive and Coinductive types with Iteration and Recursion  
Author: Herman Geuvers 
Date: July 1992  
Address: Toernooiveld 1, 6525 ED Nijmegen, The Netherlands  
Affiliation: Faculty of Mathematics and Computer Science, University of Nijmegen,  
Abstract: We study (extensions of) simply and polymorphically typed lambda calculus from a point of view of how iterative and recursive functions on inductive types are represented. The inductive types can usually be understood as initial algebras in a certain category and then recursion can be defined in terms of iteration. However, in the syntax we often have only weak initiality, which makes the definition of recursion in terms of iteration inefficient or just impossible. We propose a categorical notion of (primitive) recursion which can easily be added as computation rule to a typed lambda calculus and gives us a clear view on what the dual of recursion, corecursion, on coinductive types is. (The same notion has, independently, been proposed by [Mendler 1991].) We look at how these syntactic notions work out in the simply typed lambda calculus and the polymorphic lambda calculus. It will turn out that in the syntax, recursion can be defined in terms of corecursion and vice versa using polymorphism: Polymorphic lambda calculus with a scheme for either recursion or corecursion suffices to be able to define the other. We compare our syntax for recursion and corecursion with that of Mendler ([Mendler 1987]) and use the latter to obtain meta properties as confluence and normalization. 
Abstract-found: 1
Intro-found: 1
Reference: [Bohm and Berarducci 1985] <author> C. Bohm and A. Berarducci, </author> <title> Automatic synthesis of typed fl-programs on term algebras Theor. </title> <journal> Comput. Science, </journal> <volume> 39, </volume> <pages> pp 135-154. </pages>
Reference-contexts: In fact, the first part of the proposition says that the algebraic inductive data types can be represented in F , which result originally goes back to <ref> [Bohm and Berarducci 1985] </ref>. Here we just want to give these representations in short; for further details one may consult [Bohm and Berarducci 1985], [Leivant 1989] or [Girard et al. 1989]. Proposition 4.6 We work in the system F . Let (ff) be a positive type scheme. Then 1. <p> In fact, the first part of the proposition says that the algebraic inductive data types can be represented in F , which result originally goes back to <ref> [Bohm and Berarducci 1985] </ref>. Here we just want to give these representations in short; for further details one may consult [Bohm and Berarducci 1985], [Leivant 1989] or [Girard et al. 1989]. Proposition 4.6 We work in the system F . Let (ff) be a positive type scheme. Then 1. There is a syntactic weakly initial -algebra. 2.
Reference: [Coquand and Huet 1988] <author> Th. Coquand and G. Huet, </author> <title> The calculus of constructions, </title> <journal> Information and Computation, </journal> <volume> 76, </volume> <pages> pp 95-120. 24 </pages>
Reference: [Coquand and Mohring 1990] <editor> Inductively defined types, In P. Martin-Lof and G. Mints editors. </editor> <booktitle> COLOG-88 : International conference on computer logic, </booktitle> <publisher> LNCS 417. </publisher>
Reference: [Dowek e.a. 1991] <author> G. Dowek, A. Felty, H. Herbelin, G. Huet, C. Paulin-Mohring, B. Werner, </author> <title> The Coq proof assistant version 5.6, user's guide. </title> <institution> INRIA Rocquencourt - CNRS ENS Lyon. </institution>
Reference: [Girard et al. 1989] <author> J.Y. Girard, Y. Lafont and P. Taylor, </author> <title> Proofs and types, Camb. </title> <booktitle> Tracts in Theoretical Computer Science 7, </booktitle> <publisher> Cambridge University Press. </publisher>
Reference-contexts: 1 Introduction In this paper we want to look at formalizations of inductive and coinductive types in different typed lambda calculi, mainly extensions of the polymorphic lambda calculus. It is well-known that in polymorphic lambda calculus, many inductive data types can be defined (see e.g.[Bohm and Berarducci 1985] and <ref> [Girard et al. 1989] </ref>). In this paper we want to look at how functions on inductive types can be represented. Therefore, two ways of using the inductive building up of a type to define functions on that type are being distinguished, the iterative way and the recursive way. <p> Here we just want to give these representations in short; for further details one may consult [Bohm and Berarducci 1985], [Leivant 1989] or <ref> [Girard et al. 1989] </ref>. Proposition 4.6 We work in the system F . Let (ff) be a positive type scheme. Then 1. There is a syntactic weakly initial -algebra. 2. There is a syntactic weakly terminal -coalgebra. 16 Proof Let (ff) be a positive type scheme. 1.
Reference: [Hagino 1987a] <author> T. Hagino, </author> <title> A categorical programming language, </title> <type> Ph. D. thesis, </type> <institution> University of Edinburgh. </institution>
Reference-contexts: We shall always use the term `recursion', because, although the function-definition-scheme has a strong flavour of primitive recursion, one can define many more functions in polymorphic lambda calculus then just the primitive recursive ones. Coinductive types were first described in <ref> [Hagino 1987a] </ref> and [Hagino 1987b], with only a scheme for coiteration and without corecursion. Here we give a quite straightforward extension of simply typed lambda calculus with recursive and corecursive types.
Reference: [Hagino 1987b] <author> T. Hagino, </author> <title> A typed lambda calculus with categorical type constructions. </title> <editor> In D.H. Pitt, A. Poigne and D.E. Rydeheard, editors. </editor> <booktitle> Category Theory and Computer Science, </booktitle> <pages> LNCS 283 pp 140-157. </pages>
Reference-contexts: We shall always use the term `recursion', because, although the function-definition-scheme has a strong flavour of primitive recursion, one can define many more functions in polymorphic lambda calculus then just the primitive recursive ones. Coinductive types were first described in [Hagino 1987a] and <ref> [Hagino 1987b] </ref>, with only a scheme for coiteration and without corecursion. Here we give a quite straightforward extension of simply typed lambda calculus with recursive and corecursive types. <p> Proof This follows by the Church-Rosser property for reduction in ! ind . (See <ref> [Hagino 1987b] </ref>.) If P (Sx) = x, then P (Sx) !! x. Analyzing the possible structure of P one can conclude that if P (Sx) !! x, then not at the same time P (S0) !! 0.
Reference: [Hayashi 1985] <author> S. Hayashi, </author> <title> Adjunction of semifunctors: categorical structures in nonextensional lambda calculus. </title> <journal> Theor. Comp. Sc. </journal> <volume> 41, </volume> <pages> pp 95-104. </pages>
Reference-contexts: The reason for not considering the strong products and coproducts in these examples is that in the syntax of typed lambda calculi product and coproduct are usually weak or semi. (The notions of semi product and semi coproduct are taken from <ref> [Hayashi 1985] </ref>.) 5 Example 2.7 (Recursion on a weak natural numbers object) Let Nat be a weakly initial X:1 + X -algebra.
Reference: [Kleene 1936] <author> S.C. Kleene, </author> <title> -definability and recursiveness. </title> <journal> Duke Math. J. </journal> <volume> 2, </volume> <pages> pp 340-353. </pages>
Reference-contexts: If one has pairing, the recursive functions can be defined using just iteration, which was essentially already shown by <ref> [Kleene 1936] </ref>. But if we work in a typed lambda calculus where pairing is not surjective, this translation of recursion in terms of iteration becomes inefficient and sometimes impossible.
Reference: [Lambek 1968] <author> J. Lambek, </author> <title> A fixed point theorem for complete categories. </title> <type> Mathematisches Zeitschrift 103 pp 151-161. </type>
Reference-contexts: The main notions in category theory related to this issue come from <ref> [Lambek 1968] </ref>. Definition 2.1 Let C be a category, T a functor from C to C. 1. A T -algebra in C is a pair (A; f ), with A an object and f : T A ! A. 2 2.
Reference: [Leivant 1989] <author> D. Leivant, </author> <title> Contracting proofs to programs. </title> <editor> In P. Odifreddi, editor. </editor> <booktitle> Logic in Computer Science, </booktitle> <publisher> Academic Press, </publisher> <pages> pp 279-327. </pages>
Reference-contexts: Here we just want to give these representations in short; for further details one may consult [Bohm and Berarducci 1985], <ref> [Leivant 1989] </ref> or [Girard et al. 1989]. Proposition 4.6 We work in the system F . Let (ff) be a positive type scheme. Then 1. There is a syntactic weakly initial -algebra. 2. There is a syntactic weakly terminal -coalgebra. 16 Proof Let (ff) be a positive type scheme. 1.
Reference: [Mendler 1987] <author> N.P. Mendler, </author> <title> Inductive types and type constraints in second-order lambda calculus. </title> <booktitle> Proceedings of the Second Symposium of Logic in Computer Science. </booktitle> <address> Ithaca, N.Y., </address> <publisher> IEEE, </publisher> <pages> pp 30-36. </pages>
Reference-contexts: We also look at a system of recursive and corecursive types defined by <ref> [Mendler 1987] </ref> and show that with either the scheme for recursive types or the scheme for corecursive types, there is a recursive -algebra and a corecursive - coalgebra in the syntax for every syntactic functor (where syntactic functors are positive type schemes.) 2 The categorical perspective As said, we shall get <p> Plotkin 1990]; roughly speaking, a functor is expressible if there is a type scheme whose interpretation in the model (as a function of the free type variable) is a the functor.) We then want to relate our extension of F with recursive (and corecursive) types to a system described by <ref> [Mendler 1987] </ref>. <p> inr)); inr&gt;)x)o (z:g ((times (id)F )z)) !! g ((times (id)F )((&lt;Reco (z:g ((times (id)F )z) ffi (times (id)(inr)); inr&gt;)x) !! g ((&lt;Reco (g ffi (times (id)F ) ffi (times (id)(inr); id&gt;)x) !! g ((&lt;Reco g; id&gt;)x) We now want to look at the system of recursive types, as defined by <ref> [Mendler 1987] </ref>, let's call it F (CO)REC . (The system also has corecursive types.) Definition 5.3 ([Mendler 1987]) The system F (CO)REC is defined by adding to the polymor phic lambda calculus the following. 1. <p> For ff:(ff) and ff:(ff) we have the extra constants in : ()! R : 8fi:(8fl:(fl!)!(fl!fi)!(fl)!fi)!!fi; 20 3. Reduction rules for and : R o g (in x) ! g (id )(R o g)x; ( abbreviates ff:(ff) and abbreviates ff:(ff).) In <ref> [Mendler 1987] </ref> it is shown that this system satisfies a lot of nice meta-properties, like strong normalization and confluence of the reduction relation. <p> Proof In order to prove strong normalization we define a mapping [] from the terms of F (co)rec to the term of F (CO)REC that preserves infinite reduction paths. Then F (co)rec is strongly normalizing by the fact that F (CO)REC is strongly normalizing (see <ref> [Mendler 1987] </ref>.) One easily verifies that the system is weakly confluent (i.e. if M ! N and M !P, then 9Q [N !! Q&P !! Q].) The confluence then follows from Newman's lemma ([Newman 1942]), stating that strong normalization and weak confluence together imply confluence. 21 The definition of [] is
Reference: [Mendler 1991] <author> N.P. Mendler, </author> <title> Predicative type universes and primitive recursion. </title> <booktitle> Proceedings of the Sixth Annual IEEE Symposium on Logic in Computer Science. </booktitle> <address> Amsterdam, The Netherlands, </address> <publisher> IEEE, </publisher> <pages> pp 173-184 </pages>
Reference-contexts: One of the trade-offs is that we can dualize all this to get a notion of corecursion on coinductive types. These categorical notions of recursion and corecursion have independently been found by Mendler (see <ref> [Mendler 1991] </ref>) who treats these constructions in Martin-Lof type theory with predicative universes. What we define as (co)recursive (co)algebras are what Mendler calls `(co)algebras that admit simple primitive recursion'.
Reference: [Newman 1942] <author> M.H.A. Newman, </author> <title> On theories with a combinatorial definition of "equivalence". </title> <journal> Ann. of Math. </journal> <volume> (2) 43, </volume> <pages> pp 223-243. </pages>
Reference: [Paulin 1992] <author> Ch. Paulin-Mohring, </author> <title> private communication. </title>
Reference-contexts: Reduction rule for ae: o ae (i ae x) ! ae x: (ae abbreviates aeff:(ff).) In this system one can construct for (ff) a positive type scheme a type ae with (ae) &lt; ae ((ae) is a retract of ae.) As pointed out to us by <ref> [Paulin 1992] </ref>, the technique of 5.2 can be applied to obtain that both the systems F rec and F corec can be defined in F ret . Also the reverse holds: F ret can be defined in both F rec and F corec .
Reference: [Parigot 1988] <author> M. Parigot, </author> <title> Programming with proofs: a second order type theory. </title> <booktitle> ESOP '88, </booktitle> <volume> LNCS 300, </volume> <pages> pp 145-159. </pages>
Reference: [Parigot 1992] <author> M. Parigot, </author> <title> Recursive programming with proofs. </title> <booktitle> Theor. Comp. Science 94, </booktitle> <pages> pp 335-356. </pages>
Reference-contexts: in-ductivity in doing proofs, which is not always straightforward (or just impossible.) We shall not go into the latter topic here; there is still a lot of work to be done in relating the work presented here to systems like AF2 by Krivine and Parigot (connections may be found in <ref> [Parigot 1992] </ref>) and Coq ([Dowek e.a. 1991].) This asks for an explicit scheme for recursion in typed lambda calculus, which yields for, say, the natural numbers the scheme of Godels T. <p> We give the syntax as it has been communicated to us by Christine Paulin; it is implicit in papers by Parigot ([Parigot 1988] and <ref> [Parigot 1992] </ref>), where extensions of the system AF2 with recursive types are studied. (AF2 is a system of second oder predicate logic with an interpretation of proofs as untyped lambda terms.) The connections between our system with recursive types and the (extensions) of AF2 is a subject which needs further investigation;
Reference: [Reynolds and Plotkin 1990] <author> J.C. Reynolds and G.D. Plotkin, </author> <title> On functors expressible in the polymorphic lambda calculus. </title> <editor> In G. Huet, editor. </editor> <booktitle> Logical Foundations of Functional Programming, In `The UT Year of Programming Series', </booktitle> <address> Austin, Texas, </address> <pages> pp 127-152. </pages>
Reference-contexts: We have the following proposition, of which the first part is a syntactic version of a result in <ref> [Reynolds and Plotkin 1990] </ref> and the second part is a result of [Wraith 1989]. In fact, the first part of the proposition says that the algebraic inductive data types can be represented in F , which result originally goes back to [Bohm and Berarducci 1985]. <p> This fact has a counterpart in semantics in the form that every K-model of polymorphic lambda calculus that has a recursive T -algebras for every expressible functor T , also has a corecursive T -coalgebra for every expressible functor T and vice versa. (The notion of K-model is in <ref> [Reynolds and Plotkin 1990] </ref>; it is a syntax dependent notion of model for F , described by giving a set of constraints that a structure and an interpretation function should satisfy in order to be a model. <p> As it covers a lot of known models it serves well as a framework for stating this property semantically. Also the notion of expressible functor comes from <ref> [Reynolds and Plotkin 1990] </ref>; roughly speaking, a functor is expressible if there is a type scheme whose interpretation in the model (as a function of the free type variable) is a the functor.) We then want to relate our extension of F with recursive (and corecursive) types to a system described
Reference: [Wraith 1989] <author> G.C. Wraith, </author> <title> A note on categorical datatypes In D.H. </title> <editor> Pitt, A. Poigne and D.E. Rydeheard, editors. </editor> <booktitle> Category Theory and Computer Science, </booktitle> <pages> LNCS 389 pp 118-127. 25 </pages>
Reference-contexts: This amounts to adding two schemes for defining a new type from a covariant functor from types to types. (In the notation of these schemes below we follow <ref> [Wraith 1989] </ref>.) These new types come together with some constants and reduction rules. <p> We have the following proposition, of which the first part is a syntactic version of a result in [Reynolds and Plotkin 1990] and the second part is a result of <ref> [Wraith 1989] </ref>. In fact, the first part of the proposition says that the algebraic inductive data types can be represented in F , which result originally goes back to [Bohm and Berarducci 1985].
References-found: 19

