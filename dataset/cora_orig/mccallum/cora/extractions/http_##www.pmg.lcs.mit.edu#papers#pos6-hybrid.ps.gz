URL: http://www.pmg.lcs.mit.edu/papers/pos6-hybrid.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/Thor-papers.html
Root-URL: 
Title: Hybrid Caching for Large-Scale Object Systems (Think Globally, Act Locally)  
Author: James O'Toole Liuba Shrira 
Address: Cambridge, Massachusetts, USA  Cambridge, Massachusetts, USA  
Affiliation: Massachusetts Institute of Technology  Massachusetts Institute of Technology  
Abstract: Object-based client caching allows clients to keep more frequently accessed objects while discarding colder objects that reside on the same page. However, when these objects are modified and sent to the server, it may need to read the corresponding page from disk to install the update. These installation reads are not required with a page-based cache because whole pages are sent to the server. We describe a hybrid system that permits clients to cache objects and pages. The system uses a simple cache design that combines the best of object caching and page caching. The client increases its cache hit ratio as in object-based caching. The client avoids some installation reads by sending pages to the server when possible. Using simulated workloads we explore the performance of our design and show that it can offer a significant performance improvement over both pure object caching and pure page caching on a range of workloads.
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Using the EXODUS Storage Manager V2.0.0. </institution> <type> Technical report, </type> <institution> Depart ment of Computer Sciences, University of Wisconsin-Madison, </institution> <month> January </month> <year> 1982. </year> <type> Technical documentation. </type>
Reference-contexts: Many persistent object systems use the more traditional page-based architecture where all interaction between clients and servers takes place at the granularity of individual pages <ref> [1, 7, 12, 9] </ref>. Other systems [5, 10] use object server architectures but do not specifically address the problem of installation reads. Dewitt et. al. [6] is one of the first studies that investigated the design choices for a persistent object system architecture.
Reference: [2] <author> Atul Adya. </author> <title> A distributed commit protocol for optimistic concurrency control. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Our focus is on disk performance, so we are ignoring these issues here. Transaction Validation We assume a server architecture similar to that of the Thor persistent object system [11]. The features that we assume are optimistic concurrency control with in-memory commit <ref> [2] </ref>. If the client and server are using a page-based architecture, then we assume that the page server also uses optimistic concur-rency control and in-memory commit. We use an optimistic concurrency control scheme, so a transaction that reads stale objects is aborted when the server rejects its commit request. <p> The server uses a concurrency control protocol to ensure that all committing transactions are serialized. Committing transactions are validated by the server using a method that does not require disk access; see Adya <ref> [2] </ref> for the details. The server notifies clients when cached objects are modified, so that client caches are "almost" up-to-date. When considering the choice between page and object servers we ignore the question of whether the server uses page level or object level concurrency control.
Reference: [3] <author> Jia bing R. Cheng and A. R. Hurson. </author> <title> On the performance issues of object based buffering. </title> <booktitle> In Proceedings of the Conference on Parallel and Distributed Information Systems, </booktitle> <pages> pages 30-37, </pages> <year> 1991. </year>
Reference-contexts: Similarly, Cheng and Hurson <ref> [3] </ref> demonstrated how an object server architecture can enable more efficient client cache utilization. Numerous studies [4, 8, 16, 17] have addressed issues related to comparing object- and page-based client cache designs, emphasizing the importance of pointer swizzling costs to the client. Some of these studies considered using hybrid approaches.
Reference: [4] <author> M. Day. </author> <title> Managing a Cache of Swizzled Objects and Surrogates. </title> <type> PhD thesis, </type> <note> miteecs, In preparation. </note>
Reference-contexts: Similarly, Cheng and Hurson [3] demonstrated how an object server architecture can enable more efficient client cache utilization. Numerous studies <ref> [4, 8, 16, 17] </ref> have addressed issues related to comparing object- and page-based client cache designs, emphasizing the importance of pointer swizzling costs to the client. Some of these studies considered using hybrid approaches. <p> a hybrid object and page based client cache design in light of the cost imposed by installation reads on the server disk. 8 Conclusion Previous studies considered the tradeoffs in the performance of an object and page-based client cache in terms of the cost of in memory data structure manipulation <ref> [4, 8, 16, 17] </ref> and in terms of recovery cost [16]. In a scalable object system, client cache design has important effects on the disk load at the server [13]. We explored a cache design that takes into account a previously overlooked aspect of the server disk load: installation reads.
Reference: [5] <author> O. </author> <title> Deux et al. </title> <journal> The story of O 2 . IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 91-108, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Many persistent object systems use the more traditional page-based architecture where all interaction between clients and servers takes place at the granularity of individual pages [1, 7, 12, 9]. Other systems <ref> [5, 10] </ref> use object server architectures but do not specifically address the problem of installation reads. Dewitt et. al. [6] is one of the first studies that investigated the design choices for a persistent object system architecture.
Reference: [6] <author> David J. DeWitt, Philippe Futtersack, David Maier, and Fernando Velez. </author> <title> A study of three alternative workstation-server architectures for object oriented database systems. </title> <booktitle> In Proceedings of the 16th Conference on Very Large Data Bases, </booktitle> <pages> pages 107-121, </pages> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: In a page-based architecture, the client and server exchange whole pages, as shown in Figure 1. Previous work shows that each approach may be superior to the other depending on how the objects (on pages) are accessed by application programs <ref> [6] </ref>. When the clustering of objects on pages corresponds to the client access pattern, the page-based architecture should work well. On the other hand, object-based systems may pack frequently accessed objects more densely into the client cache. <p> Other systems [5, 10] use object server architectures but do not specifically address the problem of installation reads. Dewitt et. al. <ref> [6] </ref> is one of the first studies that investigated the design choices for a persistent object system architecture. The study focused on the question of distributing the functionality of the persistent object system between the client and the server.
Reference: [7] <author> M. Hornick and S. Zdonik. </author> <title> A Shared, Segmented Memory System for an Object-Oriented Database, </title> <address> pages 273-285. </address> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: Many persistent object systems use the more traditional page-based architecture where all interaction between clients and servers takes place at the granularity of individual pages <ref> [1, 7, 12, 9] </ref>. Other systems [5, 10] use object server architectures but do not specifically address the problem of installation reads. Dewitt et. al. [6] is one of the first studies that investigated the design choices for a persistent object system architecture.
Reference: [8] <author> Antony L. Hosking and J. Eliot B. Moss. </author> <title> Object fault handling for persis tent programming languages: A performance evaluation. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <pages> pages 288-303, </pages> <year> 1993. </year>
Reference-contexts: Similarly, Cheng and Hurson [3] demonstrated how an object server architecture can enable more efficient client cache utilization. Numerous studies <ref> [4, 8, 16, 17] </ref> have addressed issues related to comparing object- and page-based client cache designs, emphasizing the importance of pointer swizzling costs to the client. Some of these studies considered using hybrid approaches. <p> a hybrid object and page based client cache design in light of the cost imposed by installation reads on the server disk. 8 Conclusion Previous studies considered the tradeoffs in the performance of an object and page-based client cache in terms of the cost of in memory data structure manipulation <ref> [4, 8, 16, 17] </ref> and in terms of recovery cost [16]. In a scalable object system, client cache design has important effects on the disk load at the server [13]. We explored a cache design that takes into account a previously overlooked aspect of the server disk load: installation reads.
Reference: [9] <institution> Object Design Inc. </institution> <note> An Introduction to Object Store, Release 1.0. </note> <year> 1989. </year>
Reference-contexts: Many persistent object systems use the more traditional page-based architecture where all interaction between clients and servers takes place at the granularity of individual pages <ref> [1, 7, 12, 9] </ref>. Other systems [5, 10] use object server architectures but do not specifically address the problem of installation reads. Dewitt et. al. [6] is one of the first studies that investigated the design choices for a persistent object system architecture.
Reference: [10] <author> W. Kim et al. </author> <title> Architecture of the orion next-generation database system. </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 109-124, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Many persistent object systems use the more traditional page-based architecture where all interaction between clients and servers takes place at the granularity of individual pages [1, 7, 12, 9]. Other systems <ref> [5, 10] </ref> use object server architectures but do not specifically address the problem of installation reads. Dewitt et. al. [6] is one of the first studies that investigated the design choices for a persistent object system architecture.
Reference: [11] <author> B. Liskov, M. Day, and L. Shrira. </author> <title> Distributed object management in Thor. </title> <editor> In M. Tamer Ozsu, Umesh Dayal, and Patrick Valduriez, editors, </editor> <booktitle> Distributed Object Management. </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, Califor-nia, </address> <year> 1993. </year>
Reference-contexts: There are also other issues that complicate matters: swizzling, object prefetching, object clustering strategies, etc. Our focus is on disk performance, so we are ignoring these issues here. Transaction Validation We assume a server architecture similar to that of the Thor persistent object system <ref> [11] </ref>. The features that we assume are optimistic concurrency control with in-memory commit [2]. If the client and server are using a page-based architecture, then we assume that the page server also uses optimistic concur-rency control and in-memory commit.
Reference: [12] <author> D. Maier and J. Stein. </author> <title> Development and implementation of an object oriented dbms. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Many persistent object systems use the more traditional page-based architecture where all interaction between clients and servers takes place at the granularity of individual pages <ref> [1, 7, 12, 9] </ref>. Other systems [5, 10] use object server architectures but do not specifically address the problem of installation reads. Dewitt et. al. [6] is one of the first studies that investigated the design choices for a persistent object system architecture.
Reference: [13] <author> James O'Toole and Liuba Shrira. </author> <title> Opportunistic Log: Efficient Reads in a Reliable Object Server. </title> <booktitle> In Proceedings of the First Conference on Operating Systems Design and Implementation, </booktitle> <year> 1994. </year>
Reference-contexts: To install the modified object onto its containing page, the server may need to read the page from the disk if it is not present in the server cache. In a previous study <ref> [13] </ref> we have shown that the cost of these installation reads can be significant. In this paper we present a design of a hybrid cache that manages at the client both pages and objects. <p> Note that installing an object modification may require a disk read if the corresponding page is not in the server cache. In recent work, we found that these installation reads can have a large impact on the performance of large-scale object servers <ref> [13] </ref>. We showed that the transaction log provides a large pool of pending installation reads that can be processed opportunistically, as shown in Figure 2. <p> However, the memory occupied by these cold companions might be better used to hold yet more hot objects. This is what makes object-based caching work. Also, an opportunistic log <ref> [13] </ref> can make installation reads much less expensive than disk reads produced by fetch operations, because installation reads can be deferred and scheduled, unlike fetch reads which are blocking the progress of clients and must be performed immediately. <p> When the number of empty log entries decreases below the IReadTrigger threshold the server issues an installation read to obtain the page needed for a pending log entry. The server selects the pending installation from the log opportunistically, as described in previous work <ref> [13] </ref>. An installation read is initiated for the page that has the shortest positioning time, which can be determined fairly quickly using a branch and bound implementation. <p> This is due to the effect of the opportunistic log <ref> [13] </ref>. Without this improvement, the object system would have had much worse performance than the page system. <p> In a scalable object system, client cache design has important effects on the disk load at the server <ref> [13] </ref>. We explored a cache design that takes into account a previously overlooked aspect of the server disk load: installation reads. We proposed that after first optimizing the client cache to reduce the disk load due to fetches, it is then important to concentrate on avoiding unnecessary installation reads.
Reference: [14] <author> Chris Ruemmler and John Wilkes. </author> <title> Modelling disks. </title> <type> Technical Report HPL-93-68rev1, </type> <institution> Hewlett-Packard Laboratories, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: The disk geometry and other performance characteristics are taken from the HP97560 drive described by Wilkes <ref> [14] </ref>. We chose this disk because it is simple, accurate, and available.
Reference: [15] <author> M. Seltzer, P. Chen., and J. Ousterhout. </author> <title> Disk scheduling revisited. </title> <booktitle> In Proceedings of Winter USENIX, </booktitle> <year> 1990. </year>
Reference-contexts: The server then sends a confirming message to the client. When the number of dirty pages in the cache exceeds the WriteTrigger threshold, the server writes one dirty page to the disk. The page is selected using the shortest positioning time algorithm <ref> [15] </ref>. If the client provides only the modified object in the transaction commit request, then the server adds the object to the log and sends a confirming message to the client. If the page containing the object is in the cache, then the object is installed immediately.
Reference: [16] <author> Seth J. White and David J. DeWitt. </author> <title> A performance study of alternative object faulting and pointer swizzling strategies. </title> <booktitle> In Proceedings of the 18th VLDB Conference, </booktitle> <pages> pages 419-431, </pages> <year> 1992. </year>
Reference-contexts: Similarly, Cheng and Hurson [3] demonstrated how an object server architecture can enable more efficient client cache utilization. Numerous studies <ref> [4, 8, 16, 17] </ref> have addressed issues related to comparing object- and page-based client cache designs, emphasizing the importance of pointer swizzling costs to the client. Some of these studies considered using hybrid approaches. <p> a hybrid object and page based client cache design in light of the cost imposed by installation reads on the server disk. 8 Conclusion Previous studies considered the tradeoffs in the performance of an object and page-based client cache in terms of the cost of in memory data structure manipulation <ref> [4, 8, 16, 17] </ref> and in terms of recovery cost [16]. In a scalable object system, client cache design has important effects on the disk load at the server [13]. We explored a cache design that takes into account a previously overlooked aspect of the server disk load: installation reads. <p> light of the cost imposed by installation reads on the server disk. 8 Conclusion Previous studies considered the tradeoffs in the performance of an object and page-based client cache in terms of the cost of in memory data structure manipulation [4, 8, 16, 17] and in terms of recovery cost <ref> [16] </ref>. In a scalable object system, client cache design has important effects on the disk load at the server [13]. We explored a cache design that takes into account a previously overlooked aspect of the server disk load: installation reads.
Reference: [17] <author> Paul R. Wilson and Sheetal V. Kakkad. </author> <title> Pointer swizzling at page fault time: Efficiently supporting huge address spaces on standard hardware. </title> <booktitle> In Proceedings of the International Workshop on Object-Orientation in Operating Systems, </booktitle> <pages> pages 364-377, </pages> <address> Paris, France, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: Similarly, Cheng and Hurson [3] demonstrated how an object server architecture can enable more efficient client cache utilization. Numerous studies <ref> [4, 8, 16, 17] </ref> have addressed issues related to comparing object- and page-based client cache designs, emphasizing the importance of pointer swizzling costs to the client. Some of these studies considered using hybrid approaches. <p> a hybrid object and page based client cache design in light of the cost imposed by installation reads on the server disk. 8 Conclusion Previous studies considered the tradeoffs in the performance of an object and page-based client cache in terms of the cost of in memory data structure manipulation <ref> [4, 8, 16, 17] </ref> and in terms of recovery cost [16]. In a scalable object system, client cache design has important effects on the disk load at the server [13]. We explored a cache design that takes into account a previously overlooked aspect of the server disk load: installation reads.
References-found: 17

