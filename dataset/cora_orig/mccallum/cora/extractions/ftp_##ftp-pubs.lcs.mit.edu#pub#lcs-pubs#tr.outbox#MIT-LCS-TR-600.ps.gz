URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-600.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/tr600.html
Root-URL: 
Title: Function-Based Indexing for Object-Oriented Databases  
Author: by Deborah Jing-Hwa Hwang 
Address: Cambridge, Massachusetts 02139  
Affiliation: Massachusetts Institute of Technology Laboratory for Computer Science  
Note: c 1994 Massachusetts Institute of Technology All rights reserved This research was supported in part by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research under contract N00014-91-J-4136 and in part by the National Science Foundation under Grant CCR-8822158.  
Date: February 1994  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Atul Adya. </author> <title> Transaction management for mobile objects using optimistic concurrency control. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Objects that are not made persistent by the time a client finishes a session with the database are destroyed when the FE is destroyed. Concurrent access to objects in Thor is handled using an optimistic concurrency control mechanism [39]. In our current design <ref> [1] </ref>, every persistent object has a version number (v#) that is advanced every time a transaction that modifies the object commits. An object's current v# is stored with the object and is copied to an FE when the object is fetched. <p> Details of the full protocol can be found in <ref> [1] </ref>. We will discuss our work only in the context of a single-server system, since this case covers the basic concurrency control mechanism and we believe validation for index operations can be added to the full protocol in a straightforward manner.
Reference: [2] <author> P. M. G. Apers, A. R. Hevner, and S. B. Yao. </author> <title> Optimization algorithms for distributed queries. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-9(1):57-68, </volume> <month> January </month> <year> 1983. </year>
Reference-contexts: We assume that query descriptions in Thor will be in some standard notation (e.g., OQL [18]), and many others have done research in generating (optimized) execution plans both for databases in general [33] and specifically for distributed databases <ref> [2, 19, 62] </ref>. Also, we will not address how to handle indexes for sets that have elements on more than one server (i.e., distributed sets). We leave this issue as an area for future research. We begin by describing the current Thor system architecture to provide some background.
Reference: [3] <author> M. Atkinson et al. </author> <title> The object-oriented database system manifesto. </title> <booktitle> In Proceedings of the First International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 40-57, </pages> <year> 1989. </year>
Reference-contexts: To become as successful as conventional databases, object-oriented databases must also support queries <ref> [3] </ref>. 11 12 1. Introduction Since queries are an important part of database use, indexes are used in conventional databases to make them run faster. This dissertation focuses on providing indexes in object-oriented databases. It makes two contributions. <p> In the example shown in Figure 5.2, suppose x is an instance variable, y is a local variable, and a is an argument variable (thus a refers to an object that is reachable from the environment), and we execute an assignment like y := x <ref> [3] </ref> (i.e., x is an array and now y refers to one of its elements). Figure 5.2 (a) shows the result of this assignment. Now suppose we call a method of y's object with a's object as an argument (e.g., y:f oo (a)).
Reference: [4] <author> Jay Banerjee et al. </author> <title> Data model issues for object-oriented applications. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 3-26, </pages> <month> January </month> <year> 1987. </year> <editor> Also in S. Zdonik and D. Maier, eds., </editor> <booktitle> Readings in Object-Oriented Database Systems. </booktitle>
Reference-contexts: The work done in object-oriented databases is more closely related to our work. Such systems start with a general object-oriented programming language and add support for fast associative access to collections of objects. Some representative systems are GemStone [12, 47, 48], O 2 [23, 24], Orion <ref> [4, 36, 37] </ref>, and ObjectStore [40, 52]. Work specifically dealing with 91 92 4. Related Work indexing falls into two categories: 1. Indexing schemes based on the structure of an object (that is, the values of instance variables). We will call these path-based indexing schemes. 2.
Reference: [5] <author> D. S. Batory et al. </author> <title> Genesis: An extensible database management system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(11) </volume> <pages> 1711-1729, </pages> <month> November </month> <year> 1988. </year> <editor> Also in S. Zdonik and D. Maier, eds., </editor> <booktitle> Readings in Object-Oriented Database Systems. </booktitle>
Reference-contexts: Extended relational databases are relational database systems that have added constructs to handle more complex data types than can be modeled with records of built-in base types. Some representative systems are POSTGRES [53, 55, 56, 57, 58, 59], Starburst [28, 29, 45, 54, 61], Genesis <ref> [5, 6, 7] </ref>, and Exodus [15, 16]. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types. For example, a user could define a box type with operations that compute and compare the areas of boxes.
Reference: [6] <author> D. S. Batory and C. C. Gotleib. </author> <title> A unifying model of physical databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(4) </volume> <pages> 509-539, </pages> <month> December </month> <year> 1982. </year>
Reference-contexts: Extended relational databases are relational database systems that have added constructs to handle more complex data types than can be modeled with records of built-in base types. Some representative systems are POSTGRES [53, 55, 56, 57, 58, 59], Starburst [28, 29, 45, 54, 61], Genesis <ref> [5, 6, 7] </ref>, and Exodus [15, 16]. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types. For example, a user could define a box type with operations that compute and compare the areas of boxes.
Reference: [7] <author> D. S. Batory, T. Y. Leung, and T. E. Wise. </author> <title> Implementation concepts for an extensible data model and data language. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(3) </volume> <pages> 231-262, </pages> <month> September </month> <year> 1988. </year> <institution> Also University of Texas at Austin Techreport TR-86-24. </institution>
Reference-contexts: Extended relational databases are relational database systems that have added constructs to handle more complex data types than can be modeled with records of built-in base types. Some representative systems are POSTGRES [53, 55, 56, 57, 58, 59], Starburst [28, 29, 45, 54, 61], Genesis <ref> [5, 6, 7] </ref>, and Exodus [15, 16]. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types. For example, a user could define a box type with operations that compute and compare the areas of boxes.
Reference: [8] <author> E. Bertino. </author> <title> Method precomputation in object-oriented databases. </title> <booktitle> In Proceedings of the ACM-SIOIS and IEEE-TC-OA International Conference on Organizational Computing Systems, </booktitle> <pages> pages 199-212, </pages> <address> Atlanta, Georgia, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: They require knowledge of the implementation of a type to name the path of interest, constrain types to one representation, and require that the key values of interest be represented directly in the type's implementation. Method precomputation schemes <ref> [8, 10, 35, 34] </ref> allow queries based on method results, but they do not support indexes based on other functions and the only sets that can be indexed are type extents, sets that contains all the objects of a particular type. 1.2. <p> the GemStone scheme since we would only be using the half of the index data parts that would be present in GemStone. 4.2 Function-based Indexing There are two function-based indexing schemes that have been proposed: function materialization, implemented in the GOM system [34, 35], and method precomputation proposed by Bertino <ref> [8, 10] </ref>. The idea in both schemes is that the result of a method that involves a computation can be precomputed and stored as an additional instance variable for an object. As an added benefit, these results are used to provide an index based on the precomputed method. <p> In this type of system, it would be better if the registration information for an object is stored at the same server as the registered object, so we would not use a centralized implementation. 4.2.2 Method pre-computation Bertino's method pre-computation scheme <ref> [8, 10] </ref> is another scheme for storing precomputed results of methods and using these results as keys of an index. Bertino's scheme has the same expressive power as the GOM scheme, except that it does not support methods with arguments. <p> The recomputation done during the call of set monthly rate is not necessary because of the recomputation done during the call of set bonus. One way to avoid unnecessary updates is to do the recomputation lazily. Both the GOM system [34, 35] and Bertino's scheme <ref> [8, 10] </ref> have lazy updates. In a lazy update scheme, an I:data entry would be valid if key = I:f (x); otherwise it would be invalid. A mutator of a registered object would invalidate the current index data entry for x, but not recompute it. <p> The system has some choices as to when to do the actual recomputation. It can do a recomputation of invalid index entries whenever there is a query that tries to use an index. Both the GOM system [35, 34] and Bertino's scheme <ref> [8, 10] </ref> do this. Since they are primarily interested in returning results of method calls quickly, it makes sense to delay the recomputations of invalidated results while calls are being made to other objects. <p> The GemStone implementation [47] only uses space proportional to the number of accessed objects, but it works only for path expressions. Bertino's method precomputation scheme <ref> [8, 10] </ref> attempts to provide a path-based implementation of a function 164 7. Conclusion based indexing scheme, but registers too many objects because dependency is determined at the concrete level of instance variables rather than at the abstract level of methods. <p> The major issues are how to partition indexes for distributed sets and how to keep these indexes up-to-date in the presence of the partitioning. 7.1.2 Expressive Power Precomputed results. As we pointed out in Chapter 4, the GOM scheme [34, 35] and Bertino's method precomputation scheme <ref> [8, 10] </ref> have additional expressive power to return precomputed method results. As we saw in Chapter 3, this can be very beneficial for computations that call a complex function that accesses many objects. Thus we might like to provide the same functionality for elements of an indexed set. <p> In Theta, this would allow index functions that can signaled an exception. For example, the manager method of a project object may signal no manager if there is no current manager of the project. We can use Bertino's idea of an "undefined" key <ref> [8, 10] </ref> and associate it with any set elements whose key computations signal an exception. Entries with undefined keys would not match any query. To extend the registration algorithm to support functions with multiple arguments, we would add any arguments to the initial reachability set R.
Reference: [9] <author> E. Bertino. </author> <title> A survey of indexing techniques for object-oriented databases. </title> <editor> In J. C. Freytag, G. Vossen, and D. Maier, editors, </editor> <title> Query Processing for Advanced Database Applications. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1993. </year> <month> Forthcoming. </month>
Reference-contexts: However, since our evaluation shows that our scheme has high space overhead, but not too great an impact on performance, we are primarily interested in comparing space requirements. Various strategies have been proposed for index maintenance for path-based indexes; a survey can be found in <ref> [9] </ref>. Of these the multi-index is the most commonly used scheme; it was originally proposed for GemStone [47] and is also used in the O 2 [24, 23] and ObjectStore [40, 52] databases.
Reference: [10] <author> E. Bertino and A. Quarati. </author> <title> An approach to support method invocations in object-oriented queries. </title> <booktitle> In Proceedings of the 2nd IEEE International Workshop on Research Issues on Data Engineering: Transaction and Query Processing, </booktitle> <pages> pages 163-168, </pages> <address> Tempe, Arizona, </address> <month> February </month> <year> 1992. </year>
Reference-contexts: They require knowledge of the implementation of a type to name the path of interest, constrain types to one representation, and require that the key values of interest be represented directly in the type's implementation. Method precomputation schemes <ref> [8, 10, 35, 34] </ref> allow queries based on method results, but they do not support indexes based on other functions and the only sets that can be indexed are type extents, sets that contains all the objects of a particular type. 1.2. <p> Path-based Indexing 105 set el:proj :manager :income :rate . from the data part for that index. Although registration is not discussed, we infer from the examples in <ref> [10] </ref> and [11] that Bertino and Kim's model of the world allows dependency information to be stored with the type rather than with each object, and it is a pair &lt; ivar, index &gt; that indicates index depends on the ivar instance variable of all objects of the type. <p> Bertino generalizes this technique for object-oriented databases <ref> [10] </ref>. A join index is basically a GemStone index with corresponding index data parts mapping objects to each other in the opposite direction. <p> the GemStone scheme since we would only be using the half of the index data parts that would be present in GemStone. 4.2 Function-based Indexing There are two function-based indexing schemes that have been proposed: function materialization, implemented in the GOM system [34, 35], and method precomputation proposed by Bertino <ref> [8, 10] </ref>. The idea in both schemes is that the result of a method that involves a computation can be precomputed and stored as an additional instance variable for an object. As an added benefit, these results are used to provide an index based on the precomputed method. <p> In this type of system, it would be better if the registration information for an object is stored at the same server as the registered object, so we would not use a centralized implementation. 4.2.2 Method pre-computation Bertino's method pre-computation scheme <ref> [8, 10] </ref> is another scheme for storing precomputed results of methods and using these results as keys of an index. Bertino's scheme has the same expressive power as the GOM scheme, except that it does not support methods with arguments. <p> The recomputation done during the call of set monthly rate is not necessary because of the recomputation done during the call of set bonus. One way to avoid unnecessary updates is to do the recomputation lazily. Both the GOM system [34, 35] and Bertino's scheme <ref> [8, 10] </ref> have lazy updates. In a lazy update scheme, an I:data entry would be valid if key = I:f (x); otherwise it would be invalid. A mutator of a registered object would invalidate the current index data entry for x, but not recompute it. <p> The system has some choices as to when to do the actual recomputation. It can do a recomputation of invalid index entries whenever there is a query that tries to use an index. Both the GOM system [35, 34] and Bertino's scheme <ref> [8, 10] </ref> do this. Since they are primarily interested in returning results of method calls quickly, it makes sense to delay the recomputations of invalidated results while calls are being made to other objects. <p> The GemStone implementation [47] only uses space proportional to the number of accessed objects, but it works only for path expressions. Bertino's method precomputation scheme <ref> [8, 10] </ref> attempts to provide a path-based implementation of a function 164 7. Conclusion based indexing scheme, but registers too many objects because dependency is determined at the concrete level of instance variables rather than at the abstract level of methods. <p> The major issues are how to partition indexes for distributed sets and how to keep these indexes up-to-date in the presence of the partitioning. 7.1.2 Expressive Power Precomputed results. As we pointed out in Chapter 4, the GOM scheme [34, 35] and Bertino's method precomputation scheme <ref> [8, 10] </ref> have additional expressive power to return precomputed method results. As we saw in Chapter 3, this can be very beneficial for computations that call a complex function that accesses many objects. Thus we might like to provide the same functionality for elements of an indexed set. <p> In Theta, this would allow index functions that can signaled an exception. For example, the manager method of a project object may signal no manager if there is no current manager of the project. We can use Bertino's idea of an "undefined" key <ref> [8, 10] </ref> and associate it with any set elements whose key computations signal an exception. Entries with undefined keys would not match any query. To extend the registration algorithm to support functions with multiple arguments, we would add any arguments to the initial reachability set R.
Reference: [11] <author> Elisa Bertino and Won Kim. </author> <title> Indexing techniques for queries on nested objects. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(2) </volume> <pages> 196-214, </pages> <month> June </month> <year> 1989. </year> <note> 167 168 References </note>
Reference-contexts: Path-based indexing appeared first in GemStone [47] with subsequent implementations proposed by Bertino and Kim <ref> [11] </ref> and Valduriez [60]. Note that path-based indexing guarantees that every time a path expression is evaluated, it accesses the same objects. There are several disadvantages in using path-based indexing. Path-based indexing violates abstraction and encapsulation: Users must know an object's representation to state a query. <p> We will cover the GemStone scheme in some detail, then briefly cover the nested index and path index of Bertino and Kim <ref> [11] </ref> and the join index of Valduriez [60], emphasizing their differences from the GemStone scheme and each other. 4.1.1 Multi-indexes (GemStone) In the GemStone scheme [47], the notion of a link in a path expression is introduced. <p> Two different index data part organizations that would reduce the number of index data parts have been proposed by Bertino and Kim: the nested index and the path index <ref> [11] </ref>. Bertino and Kim also compared these schemes and the GemStone scheme using an analytical cost model for both space overhead and time of execution [11]. We will come back to their conclusions after we present the alternate implementations. <p> part organizations that would reduce the number of index data parts have been proposed by Bertino and Kim: the nested index and the path index <ref> [11] </ref>. Bertino and Kim also compared these schemes and the GemStone scheme using an analytical cost model for both space overhead and time of execution [11]. We will come back to their conclusions after we present the alternate implementations. A nested index has only one data part that maps the final object of a path expression to its set element. <p> Path-based Indexing 105 set el:proj :manager :income :rate . from the data part for that index. Although registration is not discussed, we infer from the examples in [10] and <ref> [11] </ref> that Bertino and Kim's model of the world allows dependency information to be stored with the type rather than with each object, and it is a pair &lt; ivar, index &gt; that indicates index depends on the ivar instance variable of all objects of the type.
Reference: [12] <author> Paul Butterworth, Allen Otis, and Jacob Stein. </author> <title> The GemStone database management system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 64-77, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: This is the only grouping supported directly by the system and is the basis for queries in these systems. By contrast, some object-oriented databases support user-defined sets that group together specific objects of the same type (for example, GemStone <ref> [12, 47, 48] </ref>), and we would like to support queries over these user-defined sets. In such a system, an object can be an element of more than one user-defined set. For example, consider a database containing objects representing employees and departments. <p> The work done in object-oriented databases is more closely related to our work. Such systems start with a general object-oriented programming language and add support for fast associative access to collections of objects. Some representative systems are GemStone <ref> [12, 47, 48] </ref>, O 2 [23, 24], Orion [4, 36, 37], and ObjectStore [40, 52]. Work specifically dealing with 91 92 4. Related Work indexing falls into two categories: 1. Indexing schemes based on the structure of an object (that is, the values of instance variables).
Reference: [13] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 138-164, </pages> <year> 1988. </year>
Reference-contexts: Transactional Model 23 supertypes (with signatures adjusted according to Cardelli's contra/covariance rules <ref> [13] </ref>), plus it may have additional methods. A type is implemented by a class. The class defines a representation consisting of a set of instance variables and provides code to implement the type's methods and creators in terms of that representation.
Reference: [14] <author> Michael J. Carey, David J. DeWitt, and Jeffrey F. Naughton. </author> <title> The OO7 benchmark. </title> <booktitle> In Proceedings of the 1993 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 12-21, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Next we present the database used in our simulations; it is based on the OO7 benchmark database <ref> [14] </ref>. In Section 3.3, we describe the benchmarks used to measure the benefit or overhead of our scheme on queries, navigation, and updates. In Section 3.4, we present our experimental framework. <p> The default is 10 cycles, but this number can be set. (Note that methods that call methods of other objects are modeled by steps in the trace.) 3.2 Simulation Database The simulated database is based on the OO7 benchmark database <ref> [14] </ref>.
Reference: [15] <author> Michael J. Carey et al. </author> <title> Object and file management in the EXODUS extensible database system. </title> <booktitle> In Proceedings of the Twelfth International Conference on Very Large Data Bases, </booktitle> <pages> pages 91-100, </pages> <address> Kyoto, Japan, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: Some representative systems are POSTGRES [53, 55, 56, 57, 58, 59], Starburst [28, 29, 45, 54, 61], Genesis [5, 6, 7], and Exodus <ref> [15, 16] </ref>. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types. For example, a user could define a box type with operations that compute and compare the areas of boxes.
Reference: [16] <author> Michael J. Carey et al. </author> <title> The EXODUS extensible DBMS project: An overview. </title> <type> Technical Report 808, </type> <institution> Computer Science Department, University of Wisconsin - Madison, </institution> <year> 1988. </year> <editor> Also in S. Zdonik and D. Maier, eds., </editor> <booktitle> Readings in Object-Oriented Database Systems. </booktitle>
Reference-contexts: Some representative systems are POSTGRES [53, 55, 56, 57, 58, 59], Starburst [28, 29, 45, 54, 61], Genesis [5, 6, 7], and Exodus <ref> [15, 16] </ref>. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types. For example, a user could define a box type with operations that compute and compare the areas of boxes.
Reference: [17] <author> Scott Carson and Sanjeev Setia. </author> <title> Optimal write batch size in log-structured file systems. </title> <booktitle> In Proceedings of the USENIX File Systems Workshop, </booktitle> <pages> pages 79-91, </pages> <year> 1992. </year>
Reference-contexts: For disk speed, we chose three settings: slow, corresponding to a 30 millisecond overhead and a 2 megabytes per second transfer rate (this corresponds to mid-1992 off-the-shelf speeds <ref> [17] </ref>); medium, corresponding to a 15 millisecond overhead and a 5 megabytes per second transfer rate; and fast, corresponding to a 5 millisecond overhead and a 10 megabyte per second transfer rate. For segment sizes, we chose 2, 8, and 16 kilobytes (2K, 8K, and 16K segments, respectively).
Reference: [18] <author> R. G. G. Cattell, </author> <title> editor. The Object Database Standard: ODMG-93. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: We believe that in systems of the future, these limitations will be not 4.1. Path-based Indexing 93 f = project manager income. (Greek letters are OIDs). 94 4. Related Work be acceptable. For example, the proposed ODMG standard defines queries based on function results <ref> [18] </ref>. Nevertheless, it is interesting to study the implementations of path-based indexes. We are interested in whether the restrictions imposed by path-based indexing make efficient implementations possible, and if so, whether these schemes can be adapted for our scheme. <p> We will not address the question of query processing, that is, how queries are described and processed into execution plans. We assume that query descriptions in Thor will be in some standard notation (e.g., OQL <ref> [18] </ref>), and many others have done research in generating (optimized) execution plans both for databases in general [33] and specifically for distributed databases [2, 19, 62]. Also, we will not address how to handle indexes for sets that have elements on more than one server (i.e., distributed sets).
Reference: [19] <author> W. W. Chu and P. Hurley. </author> <title> Optimal query processing for distributed database systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-31(9):835-850, </volume> <month> September </month> <year> 1982. </year>
Reference-contexts: We assume that query descriptions in Thor will be in some standard notation (e.g., OQL [18]), and many others have done research in generating (optimized) execution plans both for databases in general [33] and specifically for distributed databases <ref> [2, 19, 62] </ref>. Also, we will not address how to handle indexes for sets that have elements on more than one server (i.e., distributed sets). We leave this issue as an area for future research. We begin by describing the current Thor system architecture to provide some background.
Reference: [20] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press and McGraw-Hill Book Company, </publisher> <address> Cambridge, MA and New York, </address> <year> 1990. </year>
Reference-contexts: After processing each alias graph, M fl , the transitive closure of M , is computed. (An algorithm for computing transitive closure can be found in <ref> [20] </ref>.) The last column of M fl contains the information we need.
Reference: [21] <author> Mark Day. </author> <title> Managing a Cache of Swizzled Persistent Objects. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1994. </year> <month> Forthcoming. </month>
Reference-contexts: If the object referred to is not present, a fetch request for the object is made and swizzling proceeds when the requested object is installed in the FE's cache. In either scheme, objects may be shrunk (that is, turned into empty FE-surrogates) to reclaim space in the FE cache <ref> [21] </ref>. Clients can create new objects. Initially, new objects live only at the FE. A new object can be made persistent only by mutating a persistent object to refer to the new object.
Reference: [22] <author> Mark Day et al. </author> <title> Theta Reference Manual. Programming Methodology Group, </title> <institution> MIT Laboratory for Computer Science, 545 Technology Square, </institution> <address> Cambridge, MA 02139, </address> <year> 1994. </year>
Reference-contexts: Thor is a distributed, object-oriented database being developed by the Programming Methodology Group at the MIT Laboratory for Computer Science. Objects in Thor are specified and implemented in an application-independent language called Theta <ref> [22] </ref>. In the Thor model, there is a universe of persistent objects. Every object has a unique identity (an OID), an encapsulated state, and a set of methods that can be used to observe and modify the state.
Reference: [23] <author> O. </author> <title> Deux et al. </title> <journal> The story of O 2 . IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 91-108, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: The work done in object-oriented databases is more closely related to our work. Such systems start with a general object-oriented programming language and add support for fast associative access to collections of objects. Some representative systems are GemStone [12, 47, 48], O 2 <ref> [23, 24] </ref>, Orion [4, 36, 37], and ObjectStore [40, 52]. Work specifically dealing with 91 92 4. Related Work indexing falls into two categories: 1. Indexing schemes based on the structure of an object (that is, the values of instance variables). We will call these path-based indexing schemes. 2. <p> Various strategies have been proposed for index maintenance for path-based indexes; a survey can be found in [9]. Of these the multi-index is the most commonly used scheme; it was originally proposed for GemStone [47] and is also used in the O 2 <ref> [24, 23] </ref> and ObjectStore [40, 52] databases.
Reference: [24] <editor> O. Deux et al. </editor> <title> The O 2 system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 34-48, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The work done in object-oriented databases is more closely related to our work. Such systems start with a general object-oriented programming language and add support for fast associative access to collections of objects. Some representative systems are GemStone [12, 47, 48], O 2 <ref> [23, 24] </ref>, Orion [4, 36, 37], and ObjectStore [40, 52]. Work specifically dealing with 91 92 4. Related Work indexing falls into two categories: 1. Indexing schemes based on the structure of an object (that is, the values of instance variables). We will call these path-based indexing schemes. 2. <p> Various strategies have been proposed for index maintenance for path-based indexes; a survey can be found in [9]. Of these the multi-index is the most commonly used scheme; it was originally proposed for GemStone [47] and is also used in the O 2 <ref> [24, 23] </ref> and ObjectStore [40, 52] databases.
Reference: [25] <author> K. P. Eswaran et al. </author> <title> The notions of consistency and predicate locks in a database system. </title> <journal> Communications of the ACM, </journal> <volume> 11(11) </volume> <pages> 624-633, </pages> <year> 1976. </year>
Reference-contexts: Section 6.2.2 discusses the issues and reasoning behind these choices. Concurrent use and maintenance of indexes should not cause erroneous behavior or unnecessary aborts. It is well-known that ordinary concurrency control mechanisms based on locking must be extended to handle indexes <ref> [25] </ref>. To our knowledge, this has not been done for optimistic concurrency control mechanisms. We have developed a new form of optimistic concurrency control, predicate validation, that is suitable for allowing concurrent use and maintenance of indexes in systems using optimistic concurrency control. Like its namesake, predicate locking [25], in predicate <p> handle indexes <ref> [25] </ref>. To our knowledge, this has not been done for optimistic concurrency control mechanisms. We have developed a new form of optimistic concurrency control, predicate validation, that is suitable for allowing concurrent use and maintenance of indexes in systems using optimistic concurrency control. Like its namesake, predicate locking [25], in predicate validation, index operations are converted to read and write predicates that describe the objects of interest. Unlike predicate locking, predicate validation does conflict resolution at transaction commit. <p> We call this scheme predicate validation because it is an optimistic version of Eswaran, et al.'s predicate locking technique <ref> [25] </ref>. We begin our explanation of predicate validation for indexes in Thor by describing the predicates used in indexing. Then we present two versions of the protocol. The first version is for Thor when only remote match requests are allowed.
Reference: [26] <author> Sanjay Ghemawat. </author> <title> Disk Management for Object-Oriented Databases. </title> <type> PhD thesis, </type> <institution> Mas-sachusetts Institute of Technology, </institution> <year> 1994. </year> <month> Forthcoming. </month>
Reference-contexts: The servers store their persistent objects in very large disk segments. Tentatively, we have chosen a segment size of 64 kilobytes (64K), though this is a subject of current research <ref> [26] </ref>. The segments are fetched into the server cache on demand and are removed using an LRU policy. The server cache is assumed to be very large (perhaps up to 1 gigabyte in size); thus we use large segments for more efficient use of the disk.
Reference: [27] <author> J. N. Gray. </author> <booktitle> Notes on Database Operating Systems, volume 60 of Lecture Notes in Computer Science, </booktitle> <pages> pages 393-481. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1978. </year> <note> References 169 </note>
Reference-contexts: If multiple servers are involved, the initially contacted server acts as the coordinator of a two-phase commit protocol <ref> [27] </ref>, sending the participants the v#'s of all the objects used by the transaction; otherwise committing can be done locally. Validation is done by checking the v#'s of the objects used in the transaction against the current v#'s of the objects. If any do not match, the transaction must abort.
Reference: [28] <author> Laura M. Haas et al. </author> <title> Extensible query processing in Starburst. </title> <booktitle> In Proceedings of the 1989 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 377-388, </pages> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year> <note> Also IBM Almaden Research Center Research Report RJ 6610 (63921). </note>
Reference-contexts: Extended relational databases are relational database systems that have added constructs to handle more complex data types than can be modeled with records of built-in base types. Some representative systems are POSTGRES [53, 55, 56, 57, 58, 59], Starburst <ref> [28, 29, 45, 54, 61] </ref>, Genesis [5, 6, 7], and Exodus [15, 16]. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types.
Reference: [29] <author> Laura M. Haas et al. </author> <title> Starburst mid-flight: As the dust clears. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 143-160, </pages> <month> March </month> <year> 1990. </year> <note> Also IBM Almaden Research Center Research Report RJ 7278 (68535). </note>
Reference-contexts: Extended relational databases are relational database systems that have added constructs to handle more complex data types than can be modeled with records of built-in base types. Some representative systems are POSTGRES [53, 55, 56, 57, 58, 59], Starburst <ref> [28, 29, 45, 54, 61] </ref>, Genesis [5, 6, 7], and Exodus [15, 16]. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types.
Reference: [30] <author> Maurice Herlihy. </author> <title> Optimistic concurrency control for abstract data types. </title> <booktitle> In Fifth ACM Principles of Distributed Computing Conference, </booktitle> <year> 1986. </year>
Reference-contexts: Predicate validation for user-defined types. User-defined types may be able to provide more concurrency in an optimistic scheme if conflicts are determined on the basis of semantic information rather than on the reading and writing of physical versions <ref> [30] </ref>. It would be interesting to explore whether predicates and conflict rules between predicates can capture this semantic information in a compact way.
Reference: [31] <author> Scott E. Hudson and Roger King. CACTIS: </author> <title> A database system for specifying functionally-defined data. </title> <booktitle> In Proceedings of 1986 International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 26-37, </pages> <booktitle> Asilomar Conference Center, </booktitle> <address> Pacific Grove, CA, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: In this section, we will examine these schemes in some detail. We are interested in how they differ from our scheme both in their expressive power and in their implementation details. In addition, we briefly discuss the Cactis system <ref> [31, 32] </ref>, an entity-relationship database that maintains derived attributes. 4.2.1 Function materialization The scheme most closely related to ours is the GOM scheme [34, 35]. <p> some situations it can take advantage of the sharing among objects, and it would be interesting to see if we can combine our dependency information at the abstract level with this scheme to provide a more GemStone-like implementation for our scheme. 4.2.3 Cactis The Cactis system is an entity-relationship database <ref> [31, 32] </ref>. In the entity-relationship model, every object has a type that specifies some number of attributes, which are values like integers and booleans, and some number of relationships that relate two (or more) objects and may also have attributes.
Reference: [32] <author> Scott E. Hudson and Roger King. Cactis: </author> <title> A self-adaptive, concurrent implementation of an object-oriented database management system. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(3) </volume> <pages> 291-321, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: In this section, we will examine these schemes in some detail. We are interested in how they differ from our scheme both in their expressive power and in their implementation details. In addition, we briefly discuss the Cactis system <ref> [31, 32] </ref>, an entity-relationship database that maintains derived attributes. 4.2.1 Function materialization The scheme most closely related to ours is the GOM scheme [34, 35]. <p> some situations it can take advantage of the sharing among objects, and it would be interesting to see if we can combine our dependency information at the abstract level with this scheme to provide a more GemStone-like implementation for our scheme. 4.2.3 Cactis The Cactis system is an entity-relationship database <ref> [31, 32] </ref>. In the entity-relationship model, every object has a type that specifies some number of attributes, which are values like integers and booleans, and some number of relationships that relate two (or more) objects and may also have attributes.
Reference: [33] <author> Mathias Jarke and Jurgen Koch. </author> <title> Query optimization in database systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 16(2) </volume> <pages> 111-152, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: We assume that query descriptions in Thor will be in some standard notation (e.g., OQL [18]), and many others have done research in generating (optimized) execution plans both for databases in general <ref> [33] </ref> and specifically for distributed databases [2, 19, 62]. Also, we will not address how to handle indexes for sets that have elements on more than one server (i.e., distributed sets). We leave this issue as an area for future research.
Reference: [34] <author> Alfons Kemper, Christoph Kilger, and Guido Moerkotte. </author> <title> Function materialization in object bases. </title> <type> Technical Report 28/90, </type> <institution> Universitat Karlsruhe, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: They require knowledge of the implementation of a type to name the path of interest, constrain types to one representation, and require that the key values of interest be represented directly in the type's implementation. Method precomputation schemes <ref> [8, 10, 35, 34] </ref> allow queries based on method results, but they do not support indexes based on other functions and the only sets that can be indexed are type extents, sets that contains all the objects of a particular type. 1.2. <p> This type of scheme would be similar to the compensating actions in the GOM system <ref> [34, 35] </ref> that we will see later in this chapter. <p> this scheme would be similar to that for the GemStone scheme since we would only be using the half of the index data parts that would be present in GemStone. 4.2 Function-based Indexing There are two function-based indexing schemes that have been proposed: function materialization, implemented in the GOM system <ref> [34, 35] </ref>, and method precomputation proposed by Bertino [8, 10]. The idea in both schemes is that the result of a method that involves a computation can be precomputed and stored as an additional instance variable for an object. <p> In addition, we briefly discuss the Cactis system [31, 32], an entity-relationship database that maintains derived attributes. 4.2.1 Function materialization The scheme most closely related to ours is the GOM scheme <ref> [34, 35] </ref>. The designers of the GOM scheme are primarily interested in storing the results of invocations of an object's method so that when the method is called again, the result is already available without any computation. <p> For our example (Figure 5.1), we would no longer have registration tuples for income-info object fl. 5.1.3 GOM As we saw in Chapter 4, the basic GOM system <ref> [34, 35] </ref> registers more objects than necessary to maintain function-based indexes. The GOM designers realized this, so they proposed something akin to our contained subobject analysis called "strict encapsulation" to try to avoid registering some of these objects. Strict encapsulation corresponds to complete containment in our analysis. <p> The recomputation done during the call of set monthly rate is not necessary because of the recomputation done during the call of set bonus. One way to avoid unnecessary updates is to do the recomputation lazily. Both the GOM system <ref> [34, 35] </ref> and Bertino's scheme [8, 10] have lazy updates. In a lazy update scheme, an I:data entry would be valid if key = I:f (x); otherwise it would be invalid. A mutator of a registered object would invalidate the current index data entry for x, but not recompute it. <p> The system has some choices as to when to do the actual recomputation. It can do a recomputation of invalid index entries whenever there is a query that tries to use an index. Both the GOM system <ref> [35, 34] </ref> and Bertino's scheme [8, 10] do this. Since they are primarily interested in returning results of method calls quickly, it makes sense to delay the recomputations of invalidated results while calls are being made to other objects. <p> The major issues are how to partition indexes for distributed sets and how to keep these indexes up-to-date in the presence of the partitioning. 7.1.2 Expressive Power Precomputed results. As we pointed out in Chapter 4, the GOM scheme <ref> [34, 35] </ref> and Bertino's method precomputation scheme [8, 10] have additional expressive power to return precomputed method results. As we saw in Chapter 3, this can be very beneficial for computations that call a complex function that accesses many objects. <p> Entries with undefined keys would not match any query. To extend the registration algorithm to support functions with multiple arguments, we would add any arguments to the initial reachability set R. However, as in the GOM scheme <ref> [34, 35] </ref>, support for additional arguments would require that we remember the arguments that are used to compute a key as part of our registration information.
Reference: [35] <author> Alfons Kemper, Christoph Kilger, and Guido Moerkotte. </author> <title> Function materialization in object bases. </title> <booktitle> In Proceedings of the 1991 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 258-267, </pages> <address> Denver, Colorado, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: They require knowledge of the implementation of a type to name the path of interest, constrain types to one representation, and require that the key values of interest be represented directly in the type's implementation. Method precomputation schemes <ref> [8, 10, 35, 34] </ref> allow queries based on method results, but they do not support indexes based on other functions and the only sets that can be indexed are type extents, sets that contains all the objects of a particular type. 1.2. <p> This type of scheme would be similar to the compensating actions in the GOM system <ref> [34, 35] </ref> that we will see later in this chapter. <p> this scheme would be similar to that for the GemStone scheme since we would only be using the half of the index data parts that would be present in GemStone. 4.2 Function-based Indexing There are two function-based indexing schemes that have been proposed: function materialization, implemented in the GOM system <ref> [34, 35] </ref>, and method precomputation proposed by Bertino [8, 10]. The idea in both schemes is that the result of a method that involves a computation can be precomputed and stored as an additional instance variable for an object. <p> In addition, we briefly discuss the Cactis system [31, 32], an entity-relationship database that maintains derived attributes. 4.2.1 Function materialization The scheme most closely related to ours is the GOM scheme <ref> [34, 35] </ref>. The designers of the GOM scheme are primarily interested in storing the results of invocations of an object's method so that when the method is called again, the result is already available without any computation. <p> For our example (Figure 5.1), we would no longer have registration tuples for income-info object fl. 5.1.3 GOM As we saw in Chapter 4, the basic GOM system <ref> [34, 35] </ref> registers more objects than necessary to maintain function-based indexes. The GOM designers realized this, so they proposed something akin to our contained subobject analysis called "strict encapsulation" to try to avoid registering some of these objects. Strict encapsulation corresponds to complete containment in our analysis. <p> The recomputation done during the call of set monthly rate is not necessary because of the recomputation done during the call of set bonus. One way to avoid unnecessary updates is to do the recomputation lazily. Both the GOM system <ref> [34, 35] </ref> and Bertino's scheme [8, 10] have lazy updates. In a lazy update scheme, an I:data entry would be valid if key = I:f (x); otherwise it would be invalid. A mutator of a registered object would invalidate the current index data entry for x, but not recompute it. <p> The system has some choices as to when to do the actual recomputation. It can do a recomputation of invalid index entries whenever there is a query that tries to use an index. Both the GOM system <ref> [35, 34] </ref> and Bertino's scheme [8, 10] do this. Since they are primarily interested in returning results of method calls quickly, it makes sense to delay the recomputations of invalidated results while calls are being made to other objects. <p> The major issues are how to partition indexes for distributed sets and how to keep these indexes up-to-date in the presence of the partitioning. 7.1.2 Expressive Power Precomputed results. As we pointed out in Chapter 4, the GOM scheme <ref> [34, 35] </ref> and Bertino's method precomputation scheme [8, 10] have additional expressive power to return precomputed method results. As we saw in Chapter 3, this can be very beneficial for computations that call a complex function that accesses many objects. <p> Entries with undefined keys would not match any query. To extend the registration algorithm to support functions with multiple arguments, we would add any arguments to the initial reachability set R. However, as in the GOM scheme <ref> [34, 35] </ref>, support for additional arguments would require that we remember the arguments that are used to compute a key as part of our registration information.
Reference: [36] <author> Won Kim et al. </author> <title> Integrating an object-oriented programming system with a database system. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 142-152, </pages> <address> San Diego, CA, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: The work done in object-oriented databases is more closely related to our work. Such systems start with a general object-oriented programming language and add support for fast associative access to collections of objects. Some representative systems are GemStone [12, 47, 48], O 2 [23, 24], Orion <ref> [4, 36, 37] </ref>, and ObjectStore [40, 52]. Work specifically dealing with 91 92 4. Related Work indexing falls into two categories: 1. Indexing schemes based on the structure of an object (that is, the values of instance variables). We will call these path-based indexing schemes. 2.
Reference: [37] <author> Won Kim et al. </author> <title> Architecture of the ORION next-generation database system. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 109-124, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: The work done in object-oriented databases is more closely related to our work. Such systems start with a general object-oriented programming language and add support for fast associative access to collections of objects. Some representative systems are GemStone [12, 47, 48], O 2 [23, 24], Orion <ref> [4, 36, 37] </ref>, and ObjectStore [40, 52]. Work specifically dealing with 91 92 4. Related Work indexing falls into two categories: 1. Indexing schemes based on the structure of an object (that is, the values of instance variables). We will call these path-based indexing schemes. 2.
Reference: [38] <author> Donald E. Knuth. </author> <title> The Art of Computer Programming, Volume 3: Sorting and Searching. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1973. </year>
Reference-contexts: Related Work We ignore the index structure overhead. The intermediate level indexes in GemStone are likely to be hash tables. Since lookups to these tables should always succeed, we assume that they are implemented using an algorithm like Brent's variation of open addressing with double hashing <ref> [38] </ref> that performs well and uses almost no space overhead even when the table is full, so that the size of the index is the sum of the sizes of the entries. Our index and the lowest-level GemStone index are likely to be B-trees.
Reference: [39] <author> H. T. Kung and J. T. Robinson. </author> <title> On optimistic methods of concurrency control. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(2) </volume> <pages> 213-226, </pages> <month> June </month> <year> 1981. </year>
Reference-contexts: Objects that are not made persistent by the time a client finishes a session with the database are destroyed when the FE is destroyed. Concurrent access to objects in Thor is handled using an optimistic concurrency control mechanism <ref> [39] </ref>. In our current design [1], every persistent object has a version number (v#) that is advanced every time a transaction that modifies the object commits. An object's current v# is stored with the object and is copied to an FE when the object is fetched.
Reference: [40] <author> Charles Lamb et al. </author> <title> The ObjectStore database system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Such systems start with a general object-oriented programming language and add support for fast associative access to collections of objects. Some representative systems are GemStone [12, 47, 48], O 2 [23, 24], Orion [4, 36, 37], and ObjectStore <ref> [40, 52] </ref>. Work specifically dealing with 91 92 4. Related Work indexing falls into two categories: 1. Indexing schemes based on the structure of an object (that is, the values of instance variables). We will call these path-based indexing schemes. 2. <p> Various strategies have been proposed for index maintenance for path-based indexes; a survey can be found in [9]. Of these the multi-index is the most commonly used scheme; it was originally proposed for GemStone [47] and is also used in the O 2 [24, 23] and ObjectStore <ref> [40, 52] </ref> databases.
Reference: [41] <author> James R. Larus and Paul N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <address> Atlanta, GA, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: To determine when two variables may be aliases to objects that are reachable from one another, we adapt Larus and Hilfinger's alias graph construction algorithm <ref> [41] </ref>. Briefly, alias graph construction is a data flow computation that produces a conservative approximation of the aliases visible at any point in a program. The roots of an alias graph are variables names and the interior nodes represent storage areas.
Reference: [42] <author> Barbara Liskov. </author> <title> Preliminary design of the Thor object-oriented database system, </title> <month> March </month> <year> 1992. </year> <note> Available as Programming Methodology Group Memo 74, </note> <institution> MIT Laboratory for Computer Science. </institution> <address> 170 References </address>
Reference-contexts: Likewise, key recomputation and index updates after modifications to registered objects can be done at the client or the server. Finally, there are questions about how concurrent use and maintenance of indexes interacts with concurrent access and modification of regular data objects. One such object-oriented database system is Thor <ref> [42, 43] </ref>, the context for our work. Thor performs all user computations at client nodes on cached copies and uses an optimistic con-currency control scheme. In addition, it transfers its objects from disk to the server cache in very large units. <p> These checking versions consult the registration information and cause index updates if needed. Using these techniques, we try to minimize the number of registered objects and recomputations done in our scheme. 2.2 Object Model Our object model is based on the Thor object model <ref> [42, 43] </ref>. Thor is a distributed, object-oriented database being developed by the Programming Methodology Group at the MIT Laboratory for Computer Science. Objects in Thor are specified and implemented in an application-independent language called Theta [22]. In the Thor model, there is a universe of persistent objects. <p> Also, if a mutation causes objects to become totally inaccessible, partial deregistration would not waste time removing registrations from objects that will be garbage collected anyway. Chapter 6 Indexes in Thor This research is being done in the context of Thor, an object-oriented database system <ref> [42, 43] </ref>. Thor is designed to support heterogeneous applications that concurrently share objects over a heterogeneous distributed system. Thor is still under development, so its system architecture changes from time to time, and study of alternative designs in several areas is an important part of our research.
Reference: [43] <author> Barbara Liskov et al. </author> <title> A highly available object repository for use in a heterogeneous distributed system. </title> <booktitle> In Proceedings of the Fourth International Workshop on Persistent Object Systems Design, Implementation, and Use, </booktitle> <pages> pages 255-266, </pages> <address> Martha's Vineyard, MA, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: Likewise, key recomputation and index updates after modifications to registered objects can be done at the client or the server. Finally, there are questions about how concurrent use and maintenance of indexes interacts with concurrent access and modification of regular data objects. One such object-oriented database system is Thor <ref> [42, 43] </ref>, the context for our work. Thor performs all user computations at client nodes on cached copies and uses an optimistic con-currency control scheme. In addition, it transfers its objects from disk to the server cache in very large units. <p> These checking versions consult the registration information and cause index updates if needed. Using these techniques, we try to minimize the number of registered objects and recomputations done in our scheme. 2.2 Object Model Our object model is based on the Thor object model <ref> [42, 43] </ref>. Thor is a distributed, object-oriented database being developed by the Programming Methodology Group at the MIT Laboratory for Computer Science. Objects in Thor are specified and implemented in an application-independent language called Theta [22]. In the Thor model, there is a universe of persistent objects. <p> Also, if a mutation causes objects to become totally inaccessible, partial deregistration would not waste time removing registrations from objects that will be garbage collected anyway. Chapter 6 Indexes in Thor This research is being done in the context of Thor, an object-oriented database system <ref> [42, 43] </ref>. Thor is designed to support heterogeneous applications that concurrently share objects over a heterogeneous distributed system. Thor is still under development, so its system architecture changes from time to time, and study of alternative designs in several areas is an important part of our research.
Reference: [44] <author> Barbara Liskov et al. </author> <title> Replication in the harp file system. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 226-238, </pages> <booktitle> Asilomar Conference Center, </booktitle> <address> Pacific Grove, CA, </address> <year> 1991. </year>
Reference-contexts: We are not concerned with the exact details of the scheme except to note that modifications are applied to the server cache's copies at transaction commit, and they are flushed to the physical storage of a server in the background by an "apply" process as in the Harp file system <ref> [44] </ref>. 6.2 Adding Indexes to Thor The Thor system architecture as described above is inadequate for using indexes to answer queries. Some questions that arise include the following: 1.
Reference: [45] <author> Guy M. Lohman et al. </author> <title> Extensions to Starburst: Objects, types, functions, and rules. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 94-109, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Extended relational databases are relational database systems that have added constructs to handle more complex data types than can be modeled with records of built-in base types. Some representative systems are POSTGRES [53, 55, 56, 57, 58, 59], Starburst <ref> [28, 29, 45, 54, 61] </ref>, Genesis [5, 6, 7], and Exodus [15, 16]. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types.
Reference: [46] <author> Umesh Maheshwari. </author> <title> Distributed garbage collection in a client-server, transactional, persistent object store. </title> <type> Technical Report MIT/LCS/TR-574, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> October </month> <year> 1993. </year> <type> Master's thesis. </type>
Reference-contexts: An example is shown in Figure 6.2. Server surrogates are eventually removed during server garbage collection after all objects that referred to the moved object by its old xref have been modified to contain its new xref <ref> [46] </ref>. Since objects can move from server to server, a persistent object also has a system-wide unique identifier (OID) assigned to it. The servers store their persistent objects in very large disk segments.
Reference: [47] <author> David Maier and Jacob Stein. </author> <title> Indexing in an object-oriented DBMS. </title> <booktitle> In Proceedings of 1986 International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 171-182, </pages> <booktitle> Asilomar Conference Center, </booktitle> <address> Pacific Grove, CA, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: This is the only grouping supported directly by the system and is the basis for queries in these systems. By contrast, some object-oriented databases support user-defined sets that group together specific objects of the same type (for example, GemStone <ref> [12, 47, 48] </ref>), and we would like to support queries over these user-defined sets. In such a system, an object can be an element of more than one user-defined set. For example, consider a database containing objects representing employees and departments. <p> However, objects of a type need not have the same representation; there may be objects of the same type that have different representations. Furthermore, new implementations of types can be added to the database system dynamically. Schemes that base queries on path expressions (for example, GemStone <ref> [47] </ref>) violate abstraction and encapsulation. They require knowledge of the implementation of a type to name the path of interest, constrain types to one representation, and require that the key values of interest be represented directly in the type's implementation. <p> The work done in object-oriented databases is more closely related to our work. Such systems start with a general object-oriented programming language and add support for fast associative access to collections of objects. Some representative systems are GemStone <ref> [12, 47, 48] </ref>, O 2 [23, 24], Orion [4, 36, 37], and ObjectStore [40, 52]. Work specifically dealing with 91 92 4. Related Work indexing falls into two categories: 1. Indexing schemes based on the structure of an object (that is, the values of instance variables). <p> One can think of a path expression as a limited index function in which the only kinds of calls that can be made are get methods that return the objects referenced by the instance variables of the object implementations. Path-based indexing appeared first in GemStone <ref> [47] </ref> with subsequent implementations proposed by Bertino and Kim [11] and Valduriez [60]. Note that path-based indexing guarantees that every time a path expression is evaluated, it accesses the same objects. There are several disadvantages in using path-based indexing. <p> There are several disadvantages in using path-based indexing. Path-based indexing violates abstraction and encapsulation: Users must know an object's representation to state a query. The GemStone designers rationalized this design by arguing that user-defined types usually include methods for accessing the type's instance variables anyway <ref> [47] </ref>, but this is not true for many types. Path-based indexing also has limited expressive power. The "function" of a path expression consists only of a sequence of instance variable lookups. This eliminates computed values, like our project manager income example. <p> Various strategies have been proposed for index maintenance for path-based indexes; a survey can be found in [9]. Of these the multi-index is the most commonly used scheme; it was originally proposed for GemStone <ref> [47] </ref> and is also used in the O 2 [24, 23] and ObjectStore [40, 52] databases. <p> We will cover the GemStone scheme in some detail, then briefly cover the nested index and path index of Bertino and Kim [11] and the join index of Valduriez [60], emphasizing their differences from the GemStone scheme and each other. 4.1.1 Multi-indexes (GemStone) In the GemStone scheme <ref> [47] </ref>, the notion of a link in a path expression is introduced. A link is conceptually a connection between parts of a path expression separated by a single dot. <p> We discuss them briefly in this section. 7.1.1 Implementation Registration information. As we showed in Chapter 3, our scheme has a high space requirement that is proportional the number of set elements times the number of registrations needed for each set element. The GemStone implementation <ref> [47] </ref> only uses space proportional to the number of accessed objects, but it works only for path expressions. Bertino's method precomputation scheme [8, 10] attempts to provide a path-based implementation of a function 164 7. <p> Generalized index functions. In this dissertation, we assumed index functions are total, only take one argument, the set element, and return a result of a built-in type. We might like to relax these assumptions. The GemStone scheme <ref> [47] </ref> allows path expressions that return keys of user-defined type. The keys of the index are OIDs, and the only queries allowed are ones that select on the identity of a key. However, some user-defined types have "natural" ordering properties, for example, a type representing complex numbers.
Reference: [48] <author> David Maier and Jacob Stein. </author> <title> Development and implementation of an object-oriented DBMS. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year> <editor> Also in S. Zdonik and D. Maier, eds., </editor> <booktitle> Readings in Object-Oriented Database Systems. </booktitle>
Reference-contexts: This is the only grouping supported directly by the system and is the basis for queries in these systems. By contrast, some object-oriented databases support user-defined sets that group together specific objects of the same type (for example, GemStone <ref> [12, 47, 48] </ref>), and we would like to support queries over these user-defined sets. In such a system, an object can be an element of more than one user-defined set. For example, consider a database containing objects representing employees and departments. <p> The work done in object-oriented databases is more closely related to our work. Such systems start with a general object-oriented programming language and add support for fast associative access to collections of objects. Some representative systems are GemStone <ref> [12, 47, 48] </ref>, O 2 [23, 24], Orion [4, 36, 37], and ObjectStore [40, 52]. Work specifically dealing with 91 92 4. Related Work indexing falls into two categories: 1. Indexing schemes based on the structure of an object (that is, the values of instance variables).
Reference: [49] <author> C. Mohan and Inderpal Narang. </author> <title> Algorithms for creating indexes for very large tables without quiescing updates. </title> <booktitle> In Proceedings of the 1992 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 361-370, </pages> <address> San Diego, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: that registration transactions are likely to involve only one server on the assumption that, most of the time, an f-reachable object will be stored at the same server as the set element that it can 2 This scheme is similar in spirit to the ARIES system's incremental index creation scheme <ref> [49] </ref>, but since ARIES is a relational database, the details are completely different. 154 6. Indexes in Thor affect. Thus most of the time, the non-distributed case of the commit protocol will be run.
Reference: [50] <author> J. E. B. Moss. </author> <title> Working with persistent objects: To swizzle or not to swizzle. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(3), </volume> <month> August </month> <year> 1992. </year>
Reference-contexts: When a persistent object copy is brought to an FE, its references must be swizzled before being used. That is, its xrefs must be converted into virtual memory addresses. Currently, we are looking at two forms of swizzling <ref> [50] </ref>: object swizzling, where all of the xrefs in an object are swizzled when the object is accessed for the first time, and pointer swizzling, where an individual xref is swizzled when it is used for the first time to access the object it refers to.
Reference: [51] <author> Brian M. Oki and Barbara Liskov. </author> <title> Viewstamped replication: A new primary copy method to support highly-available distributed systems. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 8-17, </pages> <address> Toronto, Ontario, Canada, </address> <year> 1988. </year>
Reference-contexts: Thus invalidation also has the added benefit of causing early aborts of transactions that cannot possibly commit, avoiding the full commit protocol for them. Thor uses a primary copy replication scheme <ref> [51] </ref> to make the servers highly available.
Reference: [52] <author> Jack Orenstein et al. </author> <title> Query processing in the ObjectStore database system. </title> <booktitle> In Proceedings of the 1992 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 403-412, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Such systems start with a general object-oriented programming language and add support for fast associative access to collections of objects. Some representative systems are GemStone [12, 47, 48], O 2 [23, 24], Orion [4, 36, 37], and ObjectStore <ref> [40, 52] </ref>. Work specifically dealing with 91 92 4. Related Work indexing falls into two categories: 1. Indexing schemes based on the structure of an object (that is, the values of instance variables). We will call these path-based indexing schemes. 2. <p> Various strategies have been proposed for index maintenance for path-based indexes; a survey can be found in [9]. Of these the multi-index is the most commonly used scheme; it was originally proposed for GemStone [47] and is also used in the O 2 [24, 23] and ObjectStore <ref> [40, 52] </ref> databases.
Reference: [53] <author> Lawrence A. Rowe and Michael R. Stonebraker. </author> <title> The POSTGRES data model. </title> <booktitle> In Proceedings of the Thirteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 83-96, </pages> <address> Brighton, England, </address> <month> September </month> <year> 1987. </year> <editor> Also in S. Zdonik and D. Maier, eds., </editor> <booktitle> Readings in Object-Oriented Database Systems. </booktitle>
Reference-contexts: Extended relational databases are relational database systems that have added constructs to handle more complex data types than can be modeled with records of built-in base types. Some representative systems are POSTGRES <ref> [53, 55, 56, 57, 58, 59] </ref>, Starburst [28, 29, 45, 54, 61], Genesis [5, 6, 7], and Exodus [15, 16]. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types.
Reference: [54] <author> P. Schwarz et al. </author> <title> Extensibility in the Starburst database system. </title> <booktitle> In Proceedings of 1986 International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 85-92, </pages> <booktitle> Asilomar Conference Center, </booktitle> <address> Pacific Grove, CA, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: Extended relational databases are relational database systems that have added constructs to handle more complex data types than can be modeled with records of built-in base types. Some representative systems are POSTGRES [53, 55, 56, 57, 58, 59], Starburst <ref> [28, 29, 45, 54, 61] </ref>, Genesis [5, 6, 7], and Exodus [15, 16]. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types.
Reference: [55] <author> Michael Stonebraker. </author> <title> Inclusion of new types in relational data base systems. </title> <booktitle> In Proceedings of the Second International Conference on Data Engineering, </booktitle> <pages> pages 262-269, </pages> <address> Los Angeles, CA, </address> <month> February </month> <year> 1986. </year> <note> References 171 </note>
Reference-contexts: Extended relational databases are relational database systems that have added constructs to handle more complex data types than can be modeled with records of built-in base types. Some representative systems are POSTGRES <ref> [53, 55, 56, 57, 58, 59] </ref>, Starburst [28, 29, 45, 54, 61], Genesis [5, 6, 7], and Exodus [15, 16]. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types.
Reference: [56] <author> Michael Stonebraker. </author> <title> Object management in Postgres using procedures. </title> <booktitle> In Proceedings of 1986 International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 66-72, </pages> <booktitle> Asilomar Conference Center, </booktitle> <address> Pacific Grove, CA, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: Extended relational databases are relational database systems that have added constructs to handle more complex data types than can be modeled with records of built-in base types. Some representative systems are POSTGRES <ref> [53, 55, 56, 57, 58, 59] </ref>, Starburst [28, 29, 45, 54, 61], Genesis [5, 6, 7], and Exodus [15, 16]. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types.
Reference: [57] <author> Michael Stonebraker et al. </author> <title> Application of abstract data types and abstract indices to CAD data bases. </title> <booktitle> In Engineering Design Applications, Proceedings from SIGMOD Database Week, </booktitle> <pages> pages 107-113, </pages> <address> San Jose, CA, </address> <month> May </month> <year> 1983. </year>
Reference-contexts: Extended relational databases are relational database systems that have added constructs to handle more complex data types than can be modeled with records of built-in base types. Some representative systems are POSTGRES <ref> [53, 55, 56, 57, 58, 59] </ref>, Starburst [28, 29, 45, 54, 61], Genesis [5, 6, 7], and Exodus [15, 16]. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types.
Reference: [58] <author> Michael Stonebraker and Greg Kemnitz. </author> <title> The POSTGRES next-generation database management system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 78-92, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Extended relational databases are relational database systems that have added constructs to handle more complex data types than can be modeled with records of built-in base types. Some representative systems are POSTGRES <ref> [53, 55, 56, 57, 58, 59] </ref>, Starburst [28, 29, 45, 54, 61], Genesis [5, 6, 7], and Exodus [15, 16]. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types.
Reference: [59] <author> Michael Stonebraker, Lawrence A. Rowe, and Michael Hirohama. </author> <title> The implementation of POSTGRES. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 125-142, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Extended relational databases are relational database systems that have added constructs to handle more complex data types than can be modeled with records of built-in base types. Some representative systems are POSTGRES <ref> [53, 55, 56, 57, 58, 59] </ref>, Starburst [28, 29, 45, 54, 61], Genesis [5, 6, 7], and Exodus [15, 16]. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types.
Reference: [60] <author> P. Valduriez. </author> <title> Join indices. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2) </volume> <pages> 218-246, </pages> <month> Octo-ber </month> <year> 1987. </year>
Reference-contexts: Path-based indexing appeared first in GemStone [47] with subsequent implementations proposed by Bertino and Kim [11] and Valduriez <ref> [60] </ref>. Note that path-based indexing guarantees that every time a path expression is evaluated, it accesses the same objects. There are several disadvantages in using path-based indexing. Path-based indexing violates abstraction and encapsulation: Users must know an object's representation to state a query. <p> We will cover the GemStone scheme in some detail, then briefly cover the nested index and path index of Bertino and Kim [11] and the join index of Valduriez <ref> [60] </ref>, emphasizing their differences from the GemStone scheme and each other. 4.1.1 Multi-indexes (GemStone) In the GemStone scheme [47], the notion of a link in a path expression is introduced. A link is conceptually a connection between parts of a path expression separated by a single dot. <p> recomputation is stored in one place, and the system might be able to use this information to preload the cache with these objects to make updates run faster. 4.1.3 Join indexes Join indexes were originally designed for distributed relational databases to make joins of sets on different machines more efficient <ref> [60] </ref>. Bertino generalizes this technique for object-oriented databases [10]. A join index is basically a GemStone index with corresponding index data parts mapping objects to each other in the opposite direction.
Reference: [61] <author> P. F. Wilms et al. </author> <title> Incorporating data types in an extensible database architecture. </title> <booktitle> In Proceedings of the Third International Conference on Data and Knowledge Bases, </booktitle> <pages> pages 180-192, </pages> <address> Jerusalem, Israel, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: Extended relational databases are relational database systems that have added constructs to handle more complex data types than can be modeled with records of built-in base types. Some representative systems are POSTGRES [53, 55, 56, 57, 58, 59], Starburst <ref> [28, 29, 45, 54, 61] </ref>, Genesis [5, 6, 7], and Exodus [15, 16]. In general, these systems allow users to define new "base" types with richer sets of operations than the built-in types.
Reference: [62] <author> C. T. Yu and C. C. Chang. </author> <title> Distributed query processing. </title> <journal> ACM Computing Surveys, </journal> <volume> 16(4) </volume> <pages> 399-433, </pages> <month> December </month> <year> 1984. </year> <note> 172 References </note>
Reference-contexts: We assume that query descriptions in Thor will be in some standard notation (e.g., OQL [18]), and many others have done research in generating (optimized) execution plans both for databases in general [33] and specifically for distributed databases <ref> [2, 19, 62] </ref>. Also, we will not address how to handle indexes for sets that have elements on more than one server (i.e., distributed sets). We leave this issue as an area for future research. We begin by describing the current Thor system architecture to provide some background.
References-found: 62

