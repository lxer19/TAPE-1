URL: http://www.cs.utexas.edu/users/marco/mythesis.final2.ps
Refering-URL: http://www.cs.utexas.edu/users/marco/
Root-URL: http://www.cs.utexas.edu
Title: by  
Author: Marco Schneider 
Date: 1997  
Note: Copyright  
Abstract-found: 0
Intro-found: 1
Reference: [AD94] <author> James Abello and Shlomi Dolev, </author> <title> "On the Computational Power of Self-Stabilizing Systems," </title> <journal> Journal of Computing and Information, </journal> <volume> Vol. 1, No. 1, </volume> <booktitle> Special Issue: Proceedings of the 6th International Conference on Computing and Information, </booktitle> <pages> pp. </pages> <address> 585-603 (B10), </address> <year> 1994. </year>
Reference-contexts: In this way the communication bandwidth usage can be dramatically reduced. Our interest in distributed and parallel systems of (identical) processors with small memory size is motivated by current microprocessor technology (See e.g., [MOOY92], <ref> [AD94] </ref>). The mass production of microprocessors motivates multiprocessing systems in which each processor is equipped with a small amount of memory. In another context, microprocessors are used in switches for high-speed networks to support distributed coordination (See e.g. [MOOY92]).
Reference: [AGB94] <author> R. Albrightson, J.J. Garcia-Luna-Aceves, and J. Boyle, </author> <title> "EIGRP a fast routing protocol based on distance vectors," </title> <booktitle> Proceedings of Net-world/Interop 94, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Enhanced IGRP is based on the same metric as IGRP, but replaces its heuristics with coordinated updates via diffusing computations. This protocol is documented in a paper available from Cisco [Far93] (see also <ref> [AGB94] </ref>), and its tree maintenance is based on the diffusing update algorithm (DUAL) of Garcia-Luna-Aceves [Gar89, Gar93]. The diffusing update algorithm was developed for shortest paths and the use of a composite metric results in a different behaviour than what is described in the respective papers.
Reference: [AG92] <author> A. Arora and M. G. Gouda, </author> <title> "Closure and Convergence: A Foundation for Fault-Tolerant Computing," </title> <booktitle> Proceedings of the 22nd International Conference on Fault-Tolerant Computing Systems, </booktitle> <year> 1992. </year>
Reference: [AG94] <author> A. Arora and M. G. Gouda, </author> <title> "Distributed Reset," </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 43, No. 9, </volume> <month> September </month> <year> 1994, </year> <pages> pp 1026-1039. </pages>
Reference-contexts: In this thesis, each of the spanning tree protocols we present is self-stabilizing. A number of authors have addressed other types of self-stabilizing spanning tree construction. Self-stabilizing shortest path tree protocols may be found in <ref> [DIM93, 15 AGH90, AKY90, AKM93, AG94] </ref>. Self-Stabilizing depth first search tree construc-tion may be found in [CD94]. Also see [GS94] and [GS95] for earlier versions of our work that form the basis for the protocols in this thesis. A particularly appealing form of self-stabilization is silent stabilization. <p> w ^ (d:w &lt; D 1)^ ! p:v; d:v; f:v := w; d:w + 1; min (f:w; c [w]) 2.3 Correctness Requirements of the Protocol In the next two sections, we prove the correctness of the above maximum flow tree protocol. (Our correctness requirements are similar to those given in <ref> [AG94] </ref>, [AGH90], and [CYH91].) In particular, we must prove that the protocol satisfies the two properties of closure and convergence stated below. Before we can formally state these properties, we need to define the concepts of protocol states, fixed points, and computations. <p> If we make #F constant we get the special case where the cost of convergence is O (D fl degree) as in <ref> [AG94] </ref>. If we also make degree constant this becomes O (D). Several of the self-stabilizing protocols for breadth first search trees have been shown to have a convergence complexity of O (D) [AKM93]. <p> As noted before when there is only one flow level, our protocol degenerates into a breadth first tree algorithm that is very similar to the ones appearing in <ref> [AG94] </ref> and [AGH90]. The protocol of [AG94] can be also be shown to be O (D) using a more careful argument [Aro96]. It is interesting to speculate as to whether the same holds true for our protocol. <p> As noted before when there is only one flow level, our protocol degenerates into a breadth first tree algorithm that is very similar to the ones appearing in <ref> [AG94] </ref> and [AGH90]. The protocol of [AG94] can be also be shown to be O (D) using a more careful argument [Aro96]. It is interesting to speculate as to whether the same holds true for our protocol. <p> A circuit of flow f may be routed along the flow tree with the least flow greater than or equal to f . The protocol for constructing an individual flow tree generalizes the technique for constructing a breadth first search tree (see <ref> [AGH90, AG94] </ref>) by restricting the edges to a minimum flow value. <p> Nevertheless, even in such a case it is still unclear as to whether (log n) bits must be communicated through the communication registers. Our results show this to be the case. 114 Constructing a spanning tree of the communication graph in a stabilizing distributed fashion is addressed in [DIM93], <ref> [AG94] </ref> and [GS94, GS95]. The constructed trees are used in [DIM93] for achieving mutual-exclusion, in [AG94] for performing distributed reset, and in [GS94, GS95] for routing virtual circuits with maximum bandwidth. <p> Our results show this to be the case. 114 Constructing a spanning tree of the communication graph in a stabilizing distributed fashion is addressed in [DIM93], <ref> [AG94] </ref> and [GS94, GS95]. The constructed trees are used in [DIM93] for achieving mutual-exclusion, in [AG94] for performing distributed reset, and in [GS94, GS95] for routing virtual circuits with maximum bandwidth. For a communication graph of diameter d, the stabilizing spanning tree construction for semi-uniform systems, presented in [DIM93] requires fi (log d) bits of memory (note that n is an upper bound for d). <p> For a communication graph of diameter d, the stabilizing spanning tree construction for semi-uniform systems, presented in [DIM93] requires fi (log d) bits of memory (note that n is an upper bound for d). The stabilizing spanning tree construction in <ref> [AG94] </ref> is for id-based systems in contrast to the others and includes the election of a distinguished leader in order to construct the tree. <p> Such a silent configuration will include z + 1 leaders. We have proved our contradiction, since for infinitely many values of z the above silent configuration represents a ring with a prime number of processors. 6.5 Tree Construction Silent stabilizing protocols for tree construction can be found in [DIM93], <ref> [AG94] </ref> and [GS94, GS95]. Each of these protocols uses fi (log n) bits per register. The protocols in [DIM93] and [GS94, GS95] are designed for semi-uniform systems. The protocol in [AG94] is designed for an id-based system and includes the election of 126 a distinguished leader in order to construct the <p> with a prime number of processors. 6.5 Tree Construction Silent stabilizing protocols for tree construction can be found in [DIM93], <ref> [AG94] </ref> and [GS94, GS95]. Each of these protocols uses fi (log n) bits per register. The protocols in [DIM93] and [GS94, GS95] are designed for semi-uniform systems. The protocol in [AG94] is designed for an id-based system and includes the election of 126 a distinguished leader in order to construct the tree. In this Section we prove that there is no silent stabilizing protocol for tree construction in semi-uniform or id-based systems that uses o (log n) bits per register.
Reference: [AGH90] <author> A. Arora, M.G. Gouda and T. Herman, </author> <title> "Composite Routing Protocols," </title> <booktitle> Proceedings of the Second IEEE Symposium on Parallel and Distributed Processing, </booktitle> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: ^ (d:w &lt; D 1)^ ! p:v; d:v; f:v := w; d:w + 1; min (f:w; c [w]) 2.3 Correctness Requirements of the Protocol In the next two sections, we prove the correctness of the above maximum flow tree protocol. (Our correctness requirements are similar to those given in [AG94], <ref> [AGH90] </ref>, and [CYH91].) In particular, we must prove that the protocol satisfies the two properties of closure and convergence stated below. Before we can formally state these properties, we need to define the concepts of protocol states, fixed points, and computations. <p> As noted before when there is only one flow level, our protocol degenerates into a breadth first tree algorithm that is very similar to the ones appearing in [AG94] and <ref> [AGH90] </ref>. The protocol of [AG94] can be also be shown to be O (D) using a more careful argument [Aro96]. It is interesting to speculate as to whether the same holds true for our protocol. <p> If we keep the first condition, remove the second condition and do not consider flow in the third condition, then we arrive at a protocol similar to the one in <ref> [AGH90] </ref>. The program for a vertex v other than the root r is given in Figure 3.2. The program of the root r is exactly the same as in the original protocol. <p> However, to keep the protocol stabilizing, the protocol needs to be augmented with another protocol for maintaining a shortest path tree whose root is r. (One such protocol is discussed in <ref> [AGH90] </ref>.) Let q:v be the parent of any vertex v, other than the root r, in the shortest path tree. Then, the conjunct (s:v &lt; s:w) in the guard of the first action of vertex v is replaced by the guard (s:v 6= s:w ^ q:v = w). <p> A circuit of flow f may be routed along the flow tree with the least flow greater than or equal to f . The protocol for constructing an individual flow tree generalizes the technique for constructing a breadth first search tree (see <ref> [AGH90, AG94] </ref>) by restricting the edges to a minimum flow value. <p> Had time permitted we wanted to implement the timeout action of the en-haned maximum flow tree protocol as a stabilizing diffusing computation. We will leave this for our future work. In <ref> [AGH90] </ref> a self-stabilizing tree construction protocol is presented that initiates update actions from the root via a diffusing computation. As the wave of a 136 diffusing computation proceeds downward each vertex is allowed to update is dis-tance and parent pointer. This method has the advantage that cycles are never introduced.
Reference: [AKM93] <author> B. Awerbuch, S Kutten, Y Mansour, B. Patt-Shamir, and G. Varghese, </author> <title> "Time Optimal Self-Stabilizing Synchronization," </title> <booktitle> Proceedings of the 25th Annual STOC, </booktitle> <pages> pp. 652 - 661, </pages> <year> 1993. </year> <month> 138 </month>
Reference-contexts: In this thesis, each of the spanning tree protocols we present is self-stabilizing. A number of authors have addressed other types of self-stabilizing spanning tree construction. Self-stabilizing shortest path tree protocols may be found in <ref> [DIM93, 15 AGH90, AKY90, AKM93, AG94] </ref>. Self-Stabilizing depth first search tree construc-tion may be found in [CD94]. Also see [GS94] and [GS95] for earlier versions of our work that form the basis for the protocols in this thesis. A particularly appealing form of self-stabilization is silent stabilization. <p> If we also make degree constant this becomes O (D). Several of the self-stabilizing protocols for breadth first search trees have been shown to have a convergence complexity of O (D) <ref> [AKM93] </ref>. As noted before when there is only one flow level, our protocol degenerates into a breadth first tree algorithm that is very similar to the ones appearing in [AG94] and [AGH90].
Reference: [AKY90] <author> B. Awerbuch, S Kutten, and M. Yung, </author> <title> "Memory Efficient Self--Stabilization On General Networks," </title> <booktitle> Proceedings of the 4th Workshop on Distributed Algorithms, </booktitle> <pages> pp. 15-18, </pages> <month> September </month> <year> 1990. </year> <note> Springer-Verlag (LNCS 486). </note>
Reference-contexts: In this thesis, each of the spanning tree protocols we present is self-stabilizing. A number of authors have addressed other types of self-stabilizing spanning tree construction. Self-stabilizing shortest path tree protocols may be found in <ref> [DIM93, 15 AGH90, AKY90, AKM93, AG94] </ref>. Self-Stabilizing depth first search tree construc-tion may be found in [CD94]. Also see [GS94] and [GS95] for earlier versions of our work that form the basis for the protocols in this thesis. A particularly appealing form of self-stabilization is silent stabilization.
Reference: [All95] <author> A. </author> <title> Alles, "ATM Internetworking," </title> <publisher> Cisco Systems Inc. </publisher>
Reference-contexts: The most commonly utilized link-state approach in the Internet is OSPF [Moy94]. The P-NNI protocol for ATM networks is also based upon a link-state approach and uses hierarchical source routing to reserve circuits <ref> [All95] </ref>. In the link-state approach to routing, each vertex broadcasts updates of its local topology (link-state) to the rest of the network. These broadcasts can be periodic or event-driven (an event-driven broadcast is triggered when there is a change in local topology including link cost).
Reference: [AO94] <author> Baruch Awerbuch and Rafail Ostrovsky, </author> <title> "Memory-Efficient and Self-Stabilizing Network RESET", </title> <booktitle> Proc. of the 13th Annual ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pp. 254-263, </pages> <year> 1994. </year>
Reference-contexts: This result also applies to the restricted case of trees and thus the protocol in [KBPG] is optimal in its memory requirements. Recently, relatively intricate randomized protocols for leader election with a small amount of memory were proposed by <ref> [AO94] </ref> and [IL94]. Our research shows that every silent leader election protocol for arbitrary graphs requires (log n) bits per communication register in a uniform system. This result also applies to uniform id-based systems where processors are augmented with unique identifiers. <p> To apply the arguments of Theorem 6.3.1 we choose c out of those system configurations in which the special processor is the leftmost processor in the chain. 6.4 Leader Election Recently, relatively intricate stabilizing randomized protocols for leader election with a small amount of memory were proposed by <ref> [AO94] </ref> and [IL94]. These protocols are not silent. Our research shows that every silent stabilizing leader election protocol for arbitrary graphs requires (log n) bits per communication register in a uniform or id-based system. Leader election in a semi-uniform system is a trivial task that does not require communication.
Reference: [Aro96] <author> A. Arora, </author> <title> Private Communication. </title>
Reference-contexts: As noted before when there is only one flow level, our protocol degenerates into a breadth first tree algorithm that is very similar to the ones appearing in [AG94] and [AGH90]. The protocol of [AG94] can be also be shown to be O (D) using a more careful argument <ref> [Aro96] </ref>. It is interesting to speculate as to whether the same holds true for our protocol. While the presence of flow levels led us to introduce an additional O (n 2 ) factor in our analysis, we have not constructed a graph that actually necessitates this.
Reference: [Bel57] <author> R. E. Bellman, </author> <title> Dynamic Programming, </title> <publisher> Princeton University Press, </publisher> <year> 1957. </year>
Reference: [BF89] <author> B. Rajagopalan and M Faiman, </author> <title> "A New Responsive Distributed Shortest-Path Routing Algorithm," </title> <booktitle> ACM SIGCOMM 1989 Symposium, </booktitle> <month> Septem-ber </month> <year> 1989. </year>
Reference-contexts: In contrast these guaranteed methods constrain the order in which vertices may update in relation to each other so that stale information is never introduced and the tree property is preserved. This is achieved through the additional exchange of information and/or explicit synchronization along subtrees. In source tracing <ref> [CRKG89, BF89, Gar89b, Gar97] </ref>, in addition to its parent vertex, every vertex maintains a last vertex hop. When a vertex advertises its path to the root, it includes its last hop vertex in addition to the distance.
Reference: [BG92] <author> D. Bertsekas and R. Gallager, </author> <title> Data Networks: Second Edition, </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference: [BZBH96] <author> R. Braden, L. Zhang, S. Berson, S. Herzog and S. Jamin, </author> <title> "Resource ReSerVation Protocol (RSVP) Version 1 Functional Specification," Internet Draft, </title> <address> draft-ietf-rsvp-spec-14, </address> <month> November </month> <year> 1996. </year>
Reference-contexts: Work is underway to rearchitecture the Internet so as to provide some of the capabilities of virtual circuits and thus compete with native ATM. The Resource ReSerVation Protocol (RSVP), as its name suggests, will enable the reservation of resources (including bandwidth) over the Internet <ref> [BZBH96] </ref>. Current routers will need to be modified to support these requests. Work is also underway in the IETF (Internet Engineering Task Force) to map IP quality of service onto ATM.
Reference: [Ble90] <author> G. E. Blelloch, </author> <title> "Prefix Sums and Their Applications," </title> <type> Technical Report CMU-CS-90-190, </type> <institution> Carnegie Mellon University, School of Computer Science. </institution>
Reference-contexts: A well known application of prefix sum is in parallel computation <ref> [Ble90] </ref>. In that particular domain is required to be associative but this is not necessary for tree construction since the order of function application is induced by the path in the tree.
Reference: [CD94] <author> Zeev Collin and Shlomi Dolev, </author> <title> "Self-Stabilizing Depth First Search," </title> <journal> Information Processing Letters, </journal> <volume> Vol. 49, </volume> <pages> pp. 297-301, </pages> <year> 1994. </year> <month> 139 </month>
Reference-contexts: A number of authors have addressed other types of self-stabilizing spanning tree construction. Self-stabilizing shortest path tree protocols may be found in [DIM93, 15 AGH90, AKY90, AKM93, AG94]. Self-Stabilizing depth first search tree construc-tion may be found in <ref> [CD94] </ref>. Also see [GS94] and [GS95] for earlier versions of our work that form the basis for the protocols in this thesis. A particularly appealing form of self-stabilization is silent stabilization. <p> w ^ (d:w &lt; D 1)^ ( d:v = D _ (f:v &gt; (f:wjjc [w]) _ (f:v = (f:wjjc [w]) ^ d:v &gt; d:w + 1))) ! p:v; d:v; f:v := w; d:w + 1; f:wjjc [w] A protocol similar to the one we have outlined may be found in <ref> [CD94] </ref>. 5.7.2 Reliability Trees We now discuss reliability trees. One of the components of the composite routing metric for IGRP was reliability of a path. <p> The stabilizing spanning tree construction in [AG94] is for id-based systems in contrast to the others and includes the election of a distinguished leader in order to construct the tree. All three protocols (as well as the protocols in <ref> [Do93, CD94, DH95] </ref>) benefit from the silence property: following the convergence, no changes to the values of the communication registers take place. A relatively intricate deterministic protocol for constructing a spanning tree in a semi-uniform system using constant size communication registers was presented in [CB95].
Reference: [CM82] <author> K. M. Chandy and J. Misra, </author> <title> "Distributed Computation on Graphs: Shortest Path Algorithms," </title> <journal> Communications of the ACM, </journal> <volume> Vol. 25, No. 11, </volume> <month> November </month> <year> 1982. </year>
Reference-contexts: The path from source to root may be traced backwards from the root by following last hops. That is, take the last hop to the last hop and so on. The method of coordinated updates via diffusing computations <ref> [MS79, JM82, CM82, Gar89, Gar93] </ref> has two parts. First a set of feasibility conditions are checked after a change in topology or distance occurs. If a feasibility condition holds, then uncoordinated updates are allowed. Otherwise a diffusing computation is initiated to coordinate updates.
Reference: [CRKG89] <author> C. Cheng, R. Riley, S. Kumar, and J. J. Garcia-Luna-Aceves, </author> <title> "A loop-free extended Bellman-Ford routing protocol without bouncing effect," </title> <booktitle> ACM SIGCOMM 1989 Symposium, </booktitle> <month> September </month> <year> 1989. </year>
Reference-contexts: In contrast these guaranteed methods constrain the order in which vertices may update in relation to each other so that stale information is never introduced and the tree property is preserved. This is achieved through the additional exchange of information and/or explicit synchronization along subtrees. In source tracing <ref> [CRKG89, BF89, Gar89b, Gar97] </ref>, in addition to its parent vertex, every vertex maintains a last vertex hop. When a vertex advertises its path to the root, it includes its last hop vertex in addition to the distance.
Reference: [CYH91] <author> N. S. Chen, F. P. Yu, and S. T. Huang, </author> <title> "A Self-Stabilizing Algorithm for Constructing Spanning Trees," </title> <journal> Information Processing Letters, </journal> <volume> 39 (1991), </volume> <pages> pp. 147-151. </pages>
Reference-contexts: &lt; D 1)^ ! p:v; d:v; f:v := w; d:w + 1; min (f:w; c [w]) 2.3 Correctness Requirements of the Protocol In the next two sections, we prove the correctness of the above maximum flow tree protocol. (Our correctness requirements are similar to those given in [AG94], [AGH90], and <ref> [CYH91] </ref>.) In particular, we must prove that the protocol satisfies the two properties of closure and convergence stated below. Before we can formally state these properties, we need to define the concepts of protocol states, fixed points, and computations. <p> It is worth noting that if we remove the second and third conditions and do not consider flow (leaving only the first condition), then we arrive at a spanning tree protocol that is similar the one in <ref> [CYH91] </ref>. If we keep the first condition, remove the second condition and do not consider flow in the third condition, then we arrive at a protocol similar to the one in [AGH90]. The program for a vertex v other than the root r is given in Figure 3.2.
Reference: [CBS94] <author> C. E. Chow, J. D. Bickell, and S. Syed, </author> <title> "Performance Analysis of Fast Distributed Link Restoration Algorithms," </title> <journal> Accepted into the International Journal of Digital and Analog Communications Systems, </journal> <year> 1994. </year>
Reference: [CLR90] <author> T.H. Cormen, C.E. Leiserson, and R.L. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> MIT Press and McGraw-Hill, </publisher> <year> 1990. </year>
Reference-contexts: This implies that all vertices can obtain their maximum flow through a path in a maximum flow tree. The following theorem establishes the relation between the maximum weight spanning trees of a network N , where the edge capacities in N are considered weights 19 <ref> [CLR90] </ref>, and the maximum flow trees of N . Theorem 2.1.1 Each maximum weight spanning tree of a network N is a maximum flow tree of N . The converse is not necessarily true.
Reference: [Com91] <author> Douglas E. Comer, </author> <title> Internetworking with TCP/IP, Volume I, Principles, Protocols, and Architecture, </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference: [DGS96] <author> Shlomi Dolev, Mohamed G. Gouda and Marco Schneider, </author> <title> "The Memory Requirements of Silent Stabilization", </title> <booktitle> Proceedings of the Fifteenth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 27-34, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: We demonstrate a lower bound of (log n) bits per communication register for each of the above tasks. An earlier version of this work appears in <ref> [DGS96] </ref>. Beyond the simplicity implied by the silence property, a silent protocol may utilize less communication operations and communication bandwidth.
Reference: [DH95] <author> Shlomi Dolev and Ted Herman, </author> <title> "SuperStabilizing Protocols for Dynamic Distributed Systems," </title> <booktitle> Proc. of the Second Workshop on Self-Stabilizing Systems,UNLV, </booktitle> <pages> pp. </pages> <address> 3.1-3.15, </address> <year> 1995. </year> <title> Short abstract in Proc. </title> <booktitle> of the 14th Annual ACM Symp. on Principles of Distributed Computing, </booktitle> <address> p. 255, </address> <year> 1995. </year> <month> 140 </month>
Reference-contexts: The stabilizing spanning tree construction in [AG94] is for id-based systems in contrast to the others and includes the election of a distinguished leader in order to construct the tree. All three protocols (as well as the protocols in <ref> [Do93, CD94, DH95] </ref>) benefit from the silence property: following the convergence, no changes to the values of the communication registers take place. A relatively intricate deterministic protocol for constructing a spanning tree in a semi-uniform system using constant size communication registers was presented in [CB95]. <p> This is impossible by our lower bound. There are silent stabilizing protocols that require a constant number of bits per register. One such example is the graph coloring protocol of <ref> [DH95] </ref>. The classification of tasks according to their memory requirements for silent stabilization may identify their level of locality.
Reference: [Dij73] <author> E. W. Dijkstra, </author> <title> "EWD391 Self-stabilization in spite of distributed con-trol," Reprinted in Selected Writings on Computing: A Personal Perspective, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1982, </year> <pages> pp. 41-46. </pages>
Reference: [Dij74] <author> E. W. Dijkstra, </author> <title> "Self stabilizing systems in spite of distributed control," </title> <journal> Communications of the ACM, </journal> <volume> 17 </volume> <pages> 643-644, </pages> <year> 1974. </year>
Reference-contexts: The means by which the silent legitimate global state is reached are not utilized in our proofs 2 . Thus, our lower bound results apply to deterministic, nondeterministic and randomized stabilizing protocols for synchronous systems, asynchronous systems, and systems that are controlled by a central-demon (See e.g. <ref> [Dij74] </ref>). <p> Stabilizing leader election protocols for prime sized uniform rings with constant memory per processor are presented in [ILS]. The protocol in [ILS] assumes that the activities in the system are controlled by a central demon <ref> [Dij74] </ref>. The central demon activates a single processor at a time. Note that the protocol of [ILS] cannot be applied to a synchronous system since symmetry cannot be broken if all processors simultaneously execute an action [Dij74]. <p> [ILS] assumes that the activities in the system are controlled by a central demon <ref> [Dij74] </ref>. The central demon activates a single processor at a time. Note that the protocol of [ILS] cannot be applied to a synchronous system since symmetry cannot be broken if all processors simultaneously execute an action [Dij74]. We also show that regardless of the level of concurrency, there is not a silent stabilizing leader election protocol 122 for primed sized rings with constant memory per processor. We prove our lower bound for a ring of processors. <p> In addition, our proofs did not rely on the atomicity level of actions. Thus our results apply to any level of action atomicity. Our results are also applicable to the case where processors can read the entire state of their neighbors as proposed in <ref> [Dij74] </ref>. In such a setting once the system reaches a silent (safe) configuration no processor changes its state.
Reference: [DIM91] <author> Shlomi Dolev, Amos Israeli and Shlomo Moran, </author> <title> "Resource Bounds for Self Stabilizing Message Driven Protocols", </title> <booktitle> Proc. of the 10th Annual ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pp. 281-293, </pages> <year> 1991. </year> <note> To appear in SIAM Journal on Computing. </note>
Reference-contexts: Moreover, when message passing is used to deliver the value of the communication registers (port buffers) as described in <ref> [DIM91] </ref> it would be enough to send some encrypted proof that the value is not changed. At each 112 delivery a key is chosen randomly and the checksum relatively to this key is sent together with the key. In this way the communication bandwidth usage can be dramatically reduced.
Reference: [DIM93] <author> Shlomi Dolev, Amos Israeli, and Shlomo Moran, </author> <title> "Self Stabilization of Dynamic Systems Assuming Only Read Write Atomicity," </title> <journal> Distributed Computing, </journal> <volume> Vol. 7, </volume> <pages> pp. 3-16, </pages> <year> 1993. </year>
Reference-contexts: In this thesis, each of the spanning tree protocols we present is self-stabilizing. A number of authors have addressed other types of self-stabilizing spanning tree construction. Self-stabilizing shortest path tree protocols may be found in <ref> [DIM93, 15 AGH90, AKY90, AKM93, AG94] </ref>. Self-Stabilizing depth first search tree construc-tion may be found in [CD94]. Also see [GS94] and [GS95] for earlier versions of our work that form the basis for the protocols in this thesis. A particularly appealing form of self-stabilization is silent stabilization. <p> There is a class of tasks that are inherently non-silent. An example of such a task is a mutual-exclusion or token passing system where the contents of the communication registers must be changed over time e.g. <ref> [DIM93, GH96, IJ90, PY94] </ref>. In order to prove our lower bounds we assume the existence of a silent legitimate global state and use this state to construct a silent global state that is illegitimate 1 . <p> Nevertheless, even in such a case it is still unclear as to whether (log n) bits must be communicated through the communication registers. Our results show this to be the case. 114 Constructing a spanning tree of the communication graph in a stabilizing distributed fashion is addressed in <ref> [DIM93] </ref>, [AG94] and [GS94, GS95]. The constructed trees are used in [DIM93] for achieving mutual-exclusion, in [AG94] for performing distributed reset, and in [GS94, GS95] for routing virtual circuits with maximum bandwidth. For a communication graph of diameter d, the stabilizing spanning tree construction for semi-uniform systems, presented in [DIM93] requires <p> Our results show this to be the case. 114 Constructing a spanning tree of the communication graph in a stabilizing distributed fashion is addressed in <ref> [DIM93] </ref>, [AG94] and [GS94, GS95]. The constructed trees are used in [DIM93] for achieving mutual-exclusion, in [AG94] for performing distributed reset, and in [GS94, GS95] for routing virtual circuits with maximum bandwidth. For a communication graph of diameter d, the stabilizing spanning tree construction for semi-uniform systems, presented in [DIM93] requires fi (log d) bits of memory (note that n is an <p> in <ref> [DIM93] </ref>, [AG94] and [GS94, GS95]. The constructed trees are used in [DIM93] for achieving mutual-exclusion, in [AG94] for performing distributed reset, and in [GS94, GS95] for routing virtual circuits with maximum bandwidth. For a communication graph of diameter d, the stabilizing spanning tree construction for semi-uniform systems, presented in [DIM93] requires fi (log d) bits of memory (note that n is an upper bound for d). The stabilizing spanning tree construction in [AG94] is for id-based systems in contrast to the others and includes the election of a distinguished leader in order to construct the tree. <p> Such a silent configuration will include z + 1 leaders. We have proved our contradiction, since for infinitely many values of z the above silent configuration represents a ring with a prime number of processors. 6.5 Tree Construction Silent stabilizing protocols for tree construction can be found in <ref> [DIM93] </ref>, [AG94] and [GS94, GS95]. Each of these protocols uses fi (log n) bits per register. The protocols in [DIM93] and [GS94, GS95] are designed for semi-uniform systems. <p> infinitely many values of z the above silent configuration represents a ring with a prime number of processors. 6.5 Tree Construction Silent stabilizing protocols for tree construction can be found in <ref> [DIM93] </ref>, [AG94] and [GS94, GS95]. Each of these protocols uses fi (log n) bits per register. The protocols in [DIM93] and [GS94, GS95] are designed for semi-uniform systems. The protocol in [AG94] is designed for an id-based system and includes the election of 126 a distinguished leader in order to construct the tree.
Reference: [DL77] <author> S. B. Dreyfus and A. M. </author> <title> Law, The Art and Theory of Dynamic Programming, </title> <booktitle> Volume 130, Mathematics in Science and Engineering, </booktitle> <publisher> Academic Press, Inc., </publisher> <year> 1977. </year>
Reference-contexts: Furthermore it is easy to see that strict monotonicity holds since for every edge value we are doing constant addition over the positive integers and this preserves their total ordering. It is interesting to note that strict monotonicity is equivalent to the principle of optimality <ref> [DL77] </ref>. In terms of routing, the principle of optimality is commonly stated as follows: If vertex w is on an optimal path from vertex v to vertex r, then an optimal path from w to r also falls along the same route.
Reference: [Do93] <author> Shlomi Dolev, </author> <title> "Optimal Time Self Stabilization in Dynamic Systems," </title> <booktitle> Proc. of the 7th International Workshop on Distributed Algorithms, </booktitle> <pages> pp. 160-173, </pages> <year> 1993. </year>
Reference-contexts: The stabilizing spanning tree construction in [AG94] is for id-based systems in contrast to the others and includes the election of a distinguished leader in order to construct the tree. All three protocols (as well as the protocols in <ref> [Do93, CD94, DH95] </ref>) benefit from the silence property: following the convergence, no changes to the values of the communication registers take place. A relatively intricate deterministic protocol for constructing a spanning tree in a semi-uniform system using constant size communication registers was presented in [CB95].
Reference: [DS80] <author> E. W. Dijkstra and C. S. Scholten, </author> <title> "Termination Detection for Diffusing Computations," </title> <journal> Information Processing Letters, </journal> <volume> vol. 11, no. 1, </volume> <month> August </month> <year> 1980. </year>
Reference: [Far93] <author> Dino Farinacci, </author> <title> "Introduction to Enhanced IGRP (EIGRP)," </title> <note> http://www.cisco.com, cisco Systems, </note> <month> July </month> <year> 1993. </year>
Reference-contexts: These two approaches are used in order to compute the shortest (least cost or minimum distance) path from every source to every destination where associated with each edge is fixed cost. Examples of protocols that utilize the distance-vector approach in the Internet include RIP [Hed88] and IGRP/EIGRP <ref> [Hed91, Far93] </ref>. The most commonly utilized link-state approach in the Internet is OSPF [Moy94]. The P-NNI protocol for ATM networks is also based upon a link-state approach and uses hierarchical source routing to reserve circuits [All95]. <p> Depending upon the method, transient routing cycles may or may not be avoided. 1.4 IGRP and EIGRP Two distance-vector protocols of particular interest and relevance to flow routing and tree maintenance are Cisco System's Inter-Gateway Routing Protocol (IGRP) and Enhanced IGRP (EIGRP) <ref> [Hed91, Far93] </ref>. See also [Hui95] for descriptions of IGRP and EIGRP. IGRP was designed with a number of goals in mind. These included cycle free routing, fast response with low overhead, multipath routing and the ability to provide multiple types of service. <p> Enhanced IGRP is based on the same metric as IGRP, but replaces its heuristics with coordinated updates via diffusing computations. This protocol is documented in a paper available from Cisco <ref> [Far93] </ref> (see also [AGB94]), and its tree maintenance is based on the diffusing update algorithm (DUAL) of Garcia-Luna-Aceves [Gar89, Gar93]. The diffusing update algorithm was developed for shortest paths and the use of a composite metric results in a different behaviour than what is described in the respective papers.
Reference: [FF62] <author> L. R. Ford Jr. and D. R. Fulkerson, </author> <title> Flows in Networks, </title> <publisher> Princeton University Press, </publisher> <year> 1962. </year> <month> 141 </month>
Reference: [Gar89] <author> J. J. Garcia-Luna-Aceves, </author> <title> "A Unified Approach to Loop-Free Routing Us--ing Distance Vectors or Link States," </title> <booktitle> ACM SIGCOMM '89 Symposium, </booktitle> <month> September </month> <year> 1989. </year>
Reference-contexts: The path from source to root may be traced backwards from the root by following last hops. That is, take the last hop to the last hop and so on. The method of coordinated updates via diffusing computations <ref> [MS79, JM82, CM82, Gar89, Gar93] </ref> has two parts. First a set of feasibility conditions are checked after a change in topology or distance occurs. If a feasibility condition holds, then uncoordinated updates are allowed. Otherwise a diffusing computation is initiated to coordinate updates. <p> The diffusing computations are numbered in an increasing manner. The fact that cycles are not introduced under non-increasing edge costs is exploited in [JM82]. The authors further exploit the fact that the coordination of actions is only required for the subtree rooted at the affected vertex. In subsequent work, <ref> [Gar89] </ref> generalized the use of diffusing computations to both distance-vector and link-state algorithms as a method to prevent cycles. In path labeling, neighboring vertices advertise both their distance and their labeled paths to the root [SC87, Gar92]. <p> Enhanced IGRP is based on the same metric as IGRP, but replaces its heuristics with coordinated updates via diffusing computations. This protocol is documented in a paper available from Cisco [Far93] (see also [AGB94]), and its tree maintenance is based on the diffusing update algorithm (DUAL) of Garcia-Luna-Aceves <ref> [Gar89, Gar93] </ref>. The diffusing update algorithm was developed for shortest paths and the use of a composite metric results in a different behaviour than what is described in the respective papers.
Reference: [Gar89a] <author> J. J. Garcia-Luna-Aceves, </author> " <title> Loop-Free Routing Using Diffusing Computations," </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> Vol. 1, No. 1, </volume> <month> February </month> <year> 1993. </year>
Reference: [Gar89b] <author> J. J. Garcia-Luna-Aceves, </author> <title> "A Minimum-hop Routing Algorithm Based on Distributed Information," </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> Vol. 16, </volume> <pages> pp. 367 - 382, </pages> <year> 1989. </year>
Reference-contexts: In contrast these guaranteed methods constrain the order in which vertices may update in relation to each other so that stale information is never introduced and the tree property is preserved. This is achieved through the additional exchange of information and/or explicit synchronization along subtrees. In source tracing <ref> [CRKG89, BF89, Gar89b, Gar97] </ref>, in addition to its parent vertex, every vertex maintains a last vertex hop. When a vertex advertises its path to the root, it includes its last hop vertex in addition to the distance.
Reference: [Gar92] <author> J. J. Garcia-Luna-Aceves, </author> <title> "Distributed Routing with Labeled Distances," </title> <booktitle> Proceedings of IEEE INFOCOM 92, </booktitle> <pages> pp 633-643. </pages>
Reference-contexts: In subsequent work, [Gar89] generalized the use of diffusing computations to both distance-vector and link-state algorithms as a method to prevent cycles. In path labeling, neighboring vertices advertise both their distance and their labeled paths to the root <ref> [SC87, Gar92] </ref>. For instance if vertex v has parent w to reach root r, then v will advertise a path of v concatenated with the path of w to the root. By utilizing this extra information, selection actions are able to avoid cycles.
Reference: [Gar93] <author> J. J. Garcia-Luna-Aceves, </author> <title> "Loop-Free Routing Using Diffusing Computations," </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> Vol 1., No. 1, </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: The path from source to root may be traced backwards from the root by following last hops. That is, take the last hop to the last hop and so on. The method of coordinated updates via diffusing computations <ref> [MS79, JM82, CM82, Gar89, Gar93] </ref> has two parts. First a set of feasibility conditions are checked after a change in topology or distance occurs. If a feasibility condition holds, then uncoordinated updates are allowed. Otherwise a diffusing computation is initiated to coordinate updates. <p> Enhanced IGRP is based on the same metric as IGRP, but replaces its heuristics with coordinated updates via diffusing computations. This protocol is documented in a paper available from Cisco [Far93] (see also [AGB94]), and its tree maintenance is based on the diffusing update algorithm (DUAL) of Garcia-Luna-Aceves <ref> [Gar89, Gar93] </ref>. The diffusing update algorithm was developed for shortest paths and the use of a composite metric results in a different behaviour than what is described in the respective papers.
Reference: [Gar97] <author> J. J. Garcia-Luna-Aceves, </author> <title> "A Path-Finding Algorithm for Loop-Free Routing," </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> Vol. 5, No. 1, </volume> <month> Febru-ary </month> <year> 1997. </year>
Reference-contexts: In contrast these guaranteed methods constrain the order in which vertices may update in relation to each other so that stale information is never introduced and the tree property is preserved. This is achieved through the additional exchange of information and/or explicit synchronization along subtrees. In source tracing <ref> [CRKG89, BF89, Gar89b, Gar97] </ref>, in addition to its parent vertex, every vertex maintains a last vertex hop. When a vertex advertises its path to the root, it includes its last hop vertex in addition to the distance.
Reference: [GE90] <author> M. G. Gouda and M. </author> <title> Evangelist, "Convergence/Response Tradeoffs in Concurrent Systems," </title> <booktitle> Proc. of the Second IEEE Symposium on Parallel and Distributed Processing, </booktitle> <year> 1990. </year>
Reference-contexts: It then times out and increments s:r again to initiate the next round. In the other method, the protocol is augmented with a protocol for detecting that all actions, other than the timeout action of r, have terminated. Several stabilizing termination detection protocols have been proposed (for example <ref> [GE90] </ref> and [Var94]), and our protocol can easily be augmented with one. Instead of using an integer sequence number s:v for every vertex v, binary sequence numbers can be used in the enhanced maximum flow tree protocol.
Reference: [GH96] <author> Mohamed G. Gouda and Furman Haddix, </author> <title> "Stabilizing Token Rings in Three Bits," </title> <journal> Journal of Parallel and Distributed Computing, </journal> <note> to appear 1996. </note>
Reference-contexts: There is a class of tasks that are inherently non-silent. An example of such a task is a mutual-exclusion or token passing system where the contents of the communication registers must be changed over time e.g. <ref> [DIM93, GH96, IJ90, PY94] </ref>. In order to prove our lower bounds we assume the existence of a silent legitimate global state and use this state to construct a silent global state that is illegitimate 1 .
Reference: [GHR90] <author> M G. Gouda, R. R. Howell and L. E. Rosier, </author> <title> "The instability of self-stabilization," </title> <journal> Acta Informatica, </journal> <volume> Vol. 27, </volume> <pages> pp. 697-724, </pages> <year> 1990. </year> <month> 142 </month>
Reference-contexts: uniform, semi-uniform and id-based systems as we now define 1 A similar approach has been proposed in [IJ90] for proving the memory required to avoid silence (deadlock in the case of mutual exclusion), also see [SRR95] for different techniques for proving impossibility results in uniform systems. 2 In contrast see <ref> [GHR90] </ref> for several impossibility results based upon convergence. 113 informally. In a uniform system all the processors are identical, in a semi-uniform system all the processors are identical except for a single distinguished leader, and in an id-based system each processor has a unique identifier.
Reference: [GS94] <author> Mohamed G. Gouda and Marco Schneider, </author> <title> "Stabilization of Maximum Flow Trees," Invited talk: </title> <booktitle> Proceedings of the Third Annual Joint Conference on Information Sciences, </booktitle> <month> November </month> <year> 1994. </year> <note> A full version is in preparation for submission to IEEE Transactions on Parallel and Distributed Systems. </note>
Reference-contexts: A number of authors have addressed other types of self-stabilizing spanning tree construction. Self-stabilizing shortest path tree protocols may be found in [DIM93, 15 AGH90, AKY90, AKM93, AG94]. Self-Stabilizing depth first search tree construc-tion may be found in [CD94]. Also see <ref> [GS94] </ref> and [GS95] for earlier versions of our work that form the basis for the protocols in this thesis. A particularly appealing form of self-stabilization is silent stabilization. <p> Our results show this to be the case. 114 Constructing a spanning tree of the communication graph in a stabilizing distributed fashion is addressed in [DIM93], [AG94] and <ref> [GS94, GS95] </ref>. The constructed trees are used in [DIM93] for achieving mutual-exclusion, in [AG94] for performing distributed reset, and in [GS94, GS95] for routing virtual circuits with maximum bandwidth. <p> Our results show this to be the case. 114 Constructing a spanning tree of the communication graph in a stabilizing distributed fashion is addressed in [DIM93], [AG94] and <ref> [GS94, GS95] </ref>. The constructed trees are used in [DIM93] for achieving mutual-exclusion, in [AG94] for performing distributed reset, and in [GS94, GS95] for routing virtual circuits with maximum bandwidth. For a communication graph of diameter d, the stabilizing spanning tree construction for semi-uniform systems, presented in [DIM93] requires fi (log d) bits of memory (note that n is an upper bound for d). <p> We have proved our contradiction, since for infinitely many values of z the above silent configuration represents a ring with a prime number of processors. 6.5 Tree Construction Silent stabilizing protocols for tree construction can be found in [DIM93], [AG94] and <ref> [GS94, GS95] </ref>. Each of these protocols uses fi (log n) bits per register. The protocols in [DIM93] and [GS94, GS95] are designed for semi-uniform systems. The protocol in [AG94] is designed for an id-based system and includes the election of 126 a distinguished leader in order to construct the tree. <p> values of z the above silent configuration represents a ring with a prime number of processors. 6.5 Tree Construction Silent stabilizing protocols for tree construction can be found in [DIM93], [AG94] and <ref> [GS94, GS95] </ref>. Each of these protocols uses fi (log n) bits per register. The protocols in [DIM93] and [GS94, GS95] are designed for semi-uniform systems. The protocol in [AG94] is designed for an id-based system and includes the election of 126 a distinguished leader in order to construct the tree.
Reference: [GS95] <author> Mohamed G. Gouda and Marco Schneider, </author> <title> "Maximum Flow Routing," </title> <booktitle> Proc. of The Second Workshop on Self-Stabilizing Systems, UNLV, </booktitle> <pages> pp. </pages> <address> 2.1 - 2.13, </address> <year> 1995. </year>
Reference-contexts: A number of authors have addressed other types of self-stabilizing spanning tree construction. Self-stabilizing shortest path tree protocols may be found in [DIM93, 15 AGH90, AKY90, AKM93, AG94]. Self-Stabilizing depth first search tree construc-tion may be found in [CD94]. Also see [GS94] and <ref> [GS95] </ref> for earlier versions of our work that form the basis for the protocols in this thesis. A particularly appealing form of self-stabilization is silent stabilization. <p> Our results show this to be the case. 114 Constructing a spanning tree of the communication graph in a stabilizing distributed fashion is addressed in [DIM93], [AG94] and <ref> [GS94, GS95] </ref>. The constructed trees are used in [DIM93] for achieving mutual-exclusion, in [AG94] for performing distributed reset, and in [GS94, GS95] for routing virtual circuits with maximum bandwidth. <p> Our results show this to be the case. 114 Constructing a spanning tree of the communication graph in a stabilizing distributed fashion is addressed in [DIM93], [AG94] and <ref> [GS94, GS95] </ref>. The constructed trees are used in [DIM93] for achieving mutual-exclusion, in [AG94] for performing distributed reset, and in [GS94, GS95] for routing virtual circuits with maximum bandwidth. For a communication graph of diameter d, the stabilizing spanning tree construction for semi-uniform systems, presented in [DIM93] requires fi (log d) bits of memory (note that n is an upper bound for d). <p> We have proved our contradiction, since for infinitely many values of z the above silent configuration represents a ring with a prime number of processors. 6.5 Tree Construction Silent stabilizing protocols for tree construction can be found in [DIM93], [AG94] and <ref> [GS94, GS95] </ref>. Each of these protocols uses fi (log n) bits per register. The protocols in [DIM93] and [GS94, GS95] are designed for semi-uniform systems. The protocol in [AG94] is designed for an id-based system and includes the election of 126 a distinguished leader in order to construct the tree. <p> values of z the above silent configuration represents a ring with a prime number of processors. 6.5 Tree Construction Silent stabilizing protocols for tree construction can be found in [DIM93], [AG94] and <ref> [GS94, GS95] </ref>. Each of these protocols uses fi (log n) bits per register. The protocols in [DIM93] and [GS94, GS95] are designed for semi-uniform systems. The protocol in [AG94] is designed for an id-based system and includes the election of 126 a distinguished leader in order to construct the tree.
Reference: [Hed88] <author> C. Hedrick, </author> <title> "Routing Information Protocol," </title> <type> RFC 1058, </type> <month> June </month> <year> 1988. </year>
Reference-contexts: These two approaches are used in order to compute the shortest (least cost or minimum distance) path from every source to every destination where associated with each edge is fixed cost. Examples of protocols that utilize the distance-vector approach in the Internet include RIP <ref> [Hed88] </ref> and IGRP/EIGRP [Hed91, Far93]. The most commonly utilized link-state approach in the Internet is OSPF [Moy94]. The P-NNI protocol for ATM networks is also based upon a link-state approach and uses hierarchical source routing to reserve circuits [All95]. <p> If the next advertisement from its parent confirms the same distance, then it will advertise the update to its children. See <ref> [Hed88, Hed91, Hui95] </ref> for more detail on how some of these heuristics were applied to RIP and IGRP.
Reference: [Hed91] <author> C. Hedrick, </author> <title> "An introduction to IGRP," </title> <institution> Center for Computer and Information Services, Laboratory for Computer Science Research, Rutgers University, </institution> <month> August 22, </month> <year> 1991. </year> <note> (Also at http://www.cisco.com). </note>
Reference-contexts: These two approaches are used in order to compute the shortest (least cost or minimum distance) path from every source to every destination where associated with each edge is fixed cost. Examples of protocols that utilize the distance-vector approach in the Internet include RIP [Hed88] and IGRP/EIGRP <ref> [Hed91, Far93] </ref>. The most commonly utilized link-state approach in the Internet is OSPF [Moy94]. The P-NNI protocol for ATM networks is also based upon a link-state approach and uses hierarchical source routing to reserve circuits [All95]. <p> If the next advertisement from its parent confirms the same distance, then it will advertise the update to its children. See <ref> [Hed88, Hed91, Hui95] </ref> for more detail on how some of these heuristics were applied to RIP and IGRP. <p> Depending upon the method, transient routing cycles may or may not be avoided. 1.4 IGRP and EIGRP Two distance-vector protocols of particular interest and relevance to flow routing and tree maintenance are Cisco System's Inter-Gateway Routing Protocol (IGRP) and Enhanced IGRP (EIGRP) <ref> [Hed91, Far93] </ref>. See also [Hui95] for descriptions of IGRP and EIGRP. IGRP was designed with a number of goals in mind. These included cycle free routing, fast response with low overhead, multipath routing and the ability to provide multiple types of service. <p> Reliability corresponds to the probability that a packet will arrive at the root. In addition to the above functions, a separate hop count is maintained. The details of how load and reliability are computed are not provided in <ref> [Hed91] </ref>. In [Hui95] the load is defined as the "load of the narrowest link in the path". This does not appear to be sensible because it is possible for a larger link to be fully loaded and this would limit the effective bandwidth.
Reference: [Hui95] <author> C. Huitema, </author> <title> Routing in The Internet, </title> <publisher> Prentice Hall PTR, </publisher> <year> 1995. </year>
Reference-contexts: The next hop towards a destination defines a vertex's parent in the tree rooted by that destination. This relationship between trees and routing tables is not made explicit 4 in much of the literature on routing. See for instance <ref> [Hui95] </ref> and [Ste95]. In this thesis we emphasize this connection. In particular we will refer to the next hop as the parent and we will refer to the destination as the root. <p> If the next advertisement from its parent confirms the same distance, then it will advertise the update to its children. See <ref> [Hed88, Hed91, Hui95] </ref> for more detail on how some of these heuristics were applied to RIP and IGRP. <p> Depending upon the method, transient routing cycles may or may not be avoided. 1.4 IGRP and EIGRP Two distance-vector protocols of particular interest and relevance to flow routing and tree maintenance are Cisco System's Inter-Gateway Routing Protocol (IGRP) and Enhanced IGRP (EIGRP) [Hed91, Far93]. See also <ref> [Hui95] </ref> for descriptions of IGRP and EIGRP. IGRP was designed with a number of goals in mind. These included cycle free routing, fast response with low overhead, multipath routing and the ability to provide multiple types of service. <p> Reliability corresponds to the probability that a packet will arrive at the root. In addition to the above functions, a separate hop count is maintained. The details of how load and reliability are computed are not provided in [Hed91]. In <ref> [Hui95] </ref> the load is defined as the "load of the narrowest link in the path". This does not appear to be sensible because it is possible for a larger link to be fully loaded and this would limit the effective bandwidth.
Reference: [CB95] <author> Colette Johnen and Joffroy Beauquier, </author> <title> "Space-Efficient Distributed Self-Stabilizing Depth-First Token Circulation," </title> <booktitle> Proc. of the Second Workshop on Self-Stabilizing Systems, UNLV, </booktitle> <pages> pp. </pages> <address> 4.1-4.15, </address> <year> 1995. </year>
Reference-contexts: A relatively intricate deterministic protocol for constructing a spanning tree in a semi-uniform system using constant size communication registers was presented in <ref> [CB95] </ref>. The protocol of [CB95] is not silent. Our results show that at least (log n) bits per processor are required for any silent stabilizing spanning tree construction protocol. The reminder of this chapter is organized as follows. In the next section we present our definitions. <p> A relatively intricate deterministic protocol for constructing a spanning tree in a semi-uniform system using constant size communication registers was presented in <ref> [CB95] </ref>. The protocol of [CB95] is not silent. Our results show that at least (log n) bits per processor are required for any silent stabilizing spanning tree construction protocol. The reminder of this chapter is organized as follows. In the next section we present our definitions.
Reference: [JBS87] <author> J. M. Jaffe, A. E. Baratz and A. Segall, </author> <title> "Subtle Design Issues in the Implementation of Distributed Dynamic Routing Algorithms," </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> Vol. 12, </volume> <pages> pp. </pages> <address> 147 -158, </address> <year> 1986. </year>
Reference-contexts: Because periodic broadcast is inefficient, event driven broadcast is more common. In order to distinguish updates, sequence numbers must be used. Because the sequence numbers must be finite and vertices can go up and down, the implementation details are quite complex <ref> [Per83, Spi89, JBS87] </ref>. In the distance-vector approach to routing, neighboring vertices exchange (advertise) vectors of distances with each other. Advertising locally is advantageous over the link-state method because it requires less communication overhead than global broadcasts.
Reference: [JM82] <author> J. M. Jaffe and F. H. Moss, </author> <title> "A Responsive Distributed Routing Algorithm for Computer Networks," </title> <journal> IEEE Transactions on Communications, </journal> <volume> Vol. COM-30, No. 7, </volume> <month> July </month> <year> 1982. </year>
Reference-contexts: The path from source to root may be traced backwards from the root by following last hops. That is, take the last hop to the last hop and so on. The method of coordinated updates via diffusing computations <ref> [MS79, JM82, CM82, Gar89, Gar93] </ref> has two parts. First a set of feasibility conditions are checked after a change in topology or distance occurs. If a feasibility condition holds, then uncoordinated updates are allowed. Otherwise a diffusing computation is initiated to coordinate updates. <p> On the way down correction is executed and on the way back up selection is executed. The diffusing computations are numbered in an increasing manner. The fact that cycles are not introduced under non-increasing edge costs is exploited in <ref> [JM82] </ref>. The authors further exploit the fact that the coordination of actions is only required for the subtree rooted at the affected vertex. In subsequent work, [Gar89] generalized the use of diffusing computations to both distance-vector and link-state algorithms as a method to prevent cycles.
Reference: [IJ90] <author> Amos Israeli and Marc Jalfon, </author> <title> "Token Management Schemes and Random Walks Yield Self Stabilizing Mutual Exclusion," </title> <booktitle> Proc. of the 9th Annual ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pp. 119-131, </pages> <year> 1990. </year> <month> 143 </month>
Reference-contexts: There is a class of tasks that are inherently non-silent. An example of such a task is a mutual-exclusion or token passing system where the contents of the communication registers must be changed over time e.g. <ref> [DIM93, GH96, IJ90, PY94] </ref>. In order to prove our lower bounds we assume the existence of a silent legitimate global state and use this state to construct a silent global state that is illegitimate 1 . <p> Thus, our lower bound results apply to deterministic, nondeterministic and randomized stabilizing protocols for synchronous systems, asynchronous systems, and systems that are controlled by a central-demon (See e.g. [Dij74]). We consider uniform, semi-uniform and id-based systems as we now define 1 A similar approach has been proposed in <ref> [IJ90] </ref> for proving the memory required to avoid silence (deadlock in the case of mutual exclusion), also see [SRR95] for different techniques for proving impossibility results in uniform systems. 2 In contrast see [GHR90] for several impossibility results based upon convergence. 113 informally.
Reference: [IL94] <author> Gene Itkis and Leonid Levin, </author> <title> "Fast and lean self-stabilizing asynchronous protocol," </title> <booktitle> Proc. of the 36th Annual IEEE Symp. on Foundations of Computer Science, </booktitle> <year> 1994. </year>
Reference-contexts: This result also applies to the restricted case of trees and thus the protocol in [KBPG] is optimal in its memory requirements. Recently, relatively intricate randomized protocols for leader election with a small amount of memory were proposed by [AO94] and <ref> [IL94] </ref>. Our research shows that every silent leader election protocol for arbitrary graphs requires (log n) bits per communication register in a uniform system. This result also applies to uniform id-based systems where processors are augmented with unique identifiers. <p> To apply the arguments of Theorem 6.3.1 we choose c out of those system configurations in which the special processor is the leftmost processor in the chain. 6.4 Leader Election Recently, relatively intricate stabilizing randomized protocols for leader election with a small amount of memory were proposed by [AO94] and <ref> [IL94] </ref>. These protocols are not silent. Our research shows that every silent stabilizing leader election protocol for arbitrary graphs requires (log n) bits per communication register in a uniform or id-based system. Leader election in a semi-uniform system is a trivial task that does not require communication.
Reference: [ILS] <author> Gene Itkis, Chengdian Lin and Janos Simon, </author> <title> "Deterministic, Constant Space, Self-Stabilizing Leader Election on Uniform Rings," </title> <booktitle> Proc. of the 9th Workshop on Distributed Algorithms, </booktitle> <year> 1995. </year>
Reference-contexts: Thus, for instance, there is no protocol with constant size registers that (somehow, say serially) communicates the identifiers and then converges to a silent configuration. Stabilizing leader election protocols for prime sized uniform rings with constant memory per processor are presented in <ref> [ILS] </ref>. The protocol in [ILS] assumes that the activities in the system are controlled by a central demon [Dij74]. The central demon activates a single processor at a time. Note that the protocol of [ILS] cannot be applied to a synchronous system since symmetry cannot be broken if all processors simultaneously <p> Thus, for instance, there is no protocol with constant size registers that (somehow, say serially) communicates the identifiers and then converges to a silent configuration. Stabilizing leader election protocols for prime sized uniform rings with constant memory per processor are presented in <ref> [ILS] </ref>. The protocol in [ILS] assumes that the activities in the system are controlled by a central demon [Dij74]. The central demon activates a single processor at a time. Note that the protocol of [ILS] cannot be applied to a synchronous system since symmetry cannot be broken if all processors simultaneously execute an action [Dij74]. <p> leader election protocols for prime sized uniform rings with constant memory per processor are presented in <ref> [ILS] </ref>. The protocol in [ILS] assumes that the activities in the system are controlled by a central demon [Dij74]. The central demon activates a single processor at a time. Note that the protocol of [ILS] cannot be applied to a synchronous system since symmetry cannot be broken if all processors simultaneously execute an action [Dij74]. We also show that regardless of the level of concurrency, there is not a silent stabilizing leader election protocol 122 for primed sized rings with constant memory per processor. <p> Thus in a uniform or id-based system of n processors, each register must be able to store at least 124 k &gt; (2n=6 1) 1=6 values. Hence the number of bits in each register is (log n). The result in <ref> [ILS] </ref> is for rings with a prime number of processors. In Theorem 6.4.1 we have used one legitimate silent configuration to construct another illegitimate silent configuration for a ring of a different (smaller) number of processors. <p> If the constructed configuration represents a ring with a composite number of processors then the result of Theorem 6.4.1 is not applicable to the protocol presented in <ref> [ILS] </ref>. In the next Theorem we prove that there is no constant size stabilizing silent protocol for the restricted case of prime sized uniform rings. Theorem 6.4.2 There is no silent stabilizing leader election protocol for prime sized uniform rings with a constant number of bits per register.
Reference: [KBPG] <author> Mehmet Hakan Karaata, Sriram V. Pemmaraju, Steven C. Bruell and Sukumar Ghosh, </author> <title> "Self-Stabilizing Algorithms for Finding Centers and Medians of Trees," </title> <booktitle> Proc. of the 13th Annual ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pp. 374, </pages> <year> 1994. </year>
Reference-contexts: The eccentricity of a vertex in a communication graph is the largest distance from the vertex to any other vertex in the graph. A vertex with minimum eccentricity is called a center of the graph. A simple silent stabilizing protocol for finding the centers of trees is presented in <ref> [KBPG] </ref>. The protocol uses fi (log n) memory per processor. Our first result shows that at least (log n) bits per communication register (and hence per processor) are required by any silent stabilizing protocol to find the centers of an arbitrary graph. <p> Our first result shows that at least (log n) bits per communication register (and hence per processor) are required by any silent stabilizing protocol to find the centers of an arbitrary graph. This result also applies to the restricted case of trees and thus the protocol in <ref> [KBPG] </ref> is optimal in its memory requirements. Recently, relatively intricate randomized protocols for leader election with a small amount of memory were proposed by [AO94] and [IL94]. Our research shows that every silent leader election protocol for arbitrary graphs requires (log n) bits per communication register in a uniform system. <p> Since all silent configurations are legitimate by the definition of a silent stabilizing system, we have a contradiction. 6.3 Centers of a Graph A simple silent stabilizing protocol for finding the centers of trees is presented in <ref> [KBPG] </ref>. The protocol is designed for uniform systems and uses fi (log n) memory bits per processor. In this section we show this is a tight lower bound for any such protocol in a uniform system.
Reference: [Ken82] <author> Hua Loo Keng, </author> <title> Introduction to Number Theory, </title> <editor> p. </editor> <volume> 243, </volume> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: Theorem 6.4.2 There is no silent stabilizing leader election protocol for prime sized uniform rings with a constant number of bits per register. Proof of Theorem 6.4.2 Let p 1 and p 2 be the number of processors in two rings R1 and R2, respectively. Dirichlet's Theorem (See e.g. <ref> [Ken82] </ref>) states that any arithmetic progression a + bn with gcd (a,b) = 1 contains infinitely many primes. Thus for infinitely many z, p 1 + zp 2 is prime.
Reference: [MFR78] <author> J. M. McQuilan, G. Falk, and I. Richer, </author> <title> "A review of the development and performance of the ARPANET routing algorithm," </title> <journal> IEEE Transactions on Communications, </journal> <volume> Vol. COM-26, </volume> <pages> pp. 1802 - 1811, </pages> <month> December </month> <year> 1978. </year>
Reference: [MOOY92] <author> A. Mayer, Y. Ofek, R. Ostrovsky and M. Yung, </author> <title> "Self-Stabilizing Symmetry Breaking in Constant-Space," </title> <booktitle> Proc. 24th ACM Symp. on Theory of Computing pp. </booktitle> <pages> 378-382, </pages> <year> 1992. </year>
Reference-contexts: In this way the communication bandwidth usage can be dramatically reduced. Our interest in distributed and parallel systems of (identical) processors with small memory size is motivated by current microprocessor technology (See e.g., <ref> [MOOY92] </ref>, [AD94]). The mass production of microprocessors motivates multiprocessing systems in which each processor is equipped with a small amount of memory. In another context, microprocessors are used in switches for high-speed networks to support distributed coordination (See e.g. [MOOY92]). <p> small memory size is motivated by current microprocessor technology (See e.g., <ref> [MOOY92] </ref>, [AD94]). The mass production of microprocessors motivates multiprocessing systems in which each processor is equipped with a small amount of memory. In another context, microprocessors are used in switches for high-speed networks to support distributed coordination (See e.g. [MOOY92]). Ideally, the amount of memory that such microprocessors are equipped with, is small. This research examines the memory requirements of silent stabilizing protocols to achieve several fundamental tasks, including finding the centers of a graph, leader election, and spanning tree construction.
Reference: [Moy94] <author> J. Moy, </author> <note> "OSPF Version 2," RFC 1583, </note> <month> March </month> <year> 1994. </year>
Reference-contexts: Examples of protocols that utilize the distance-vector approach in the Internet include RIP [Hed88] and IGRP/EIGRP [Hed91, Far93]. The most commonly utilized link-state approach in the Internet is OSPF <ref> [Moy94] </ref>. The P-NNI protocol for ATM networks is also based upon a link-state approach and uses hierarchical source routing to reserve circuits [All95]. In the link-state approach to routing, each vertex broadcasts updates of its local topology (link-state) to the rest of the network.
Reference: [MRR78] <author> J. M. McQuilan, I Richer and E. C. Rosen, </author> <title> "The new routing algorithm for the ARPANET," </title> <journal> IEEE Transactions on Communications, </journal> <volume> Vol. COM-28, </volume> <pages> pp., </pages> <month> May </month> <year> 1980. </year>
Reference: [MS79] <author> P. M. Merlin and A. Segall, </author> <title> "A failsafe distributed routing protocol," </title> <journal> IEEE Transactions on Communications, </journal> <volume> Vol. COM-27, </volume> <pages> pp. </pages> <address> 1230 -1237, </address> <month> September </month> <year> 1979. </year> <month> 144 </month>
Reference-contexts: The path from source to root may be traced backwards from the root by following last hops. That is, take the last hop to the last hop and so on. The method of coordinated updates via diffusing computations <ref> [MS79, JM82, CM82, Gar89, Gar93] </ref> has two parts. First a set of feasibility conditions are checked after a change in topology or distance occurs. If a feasibility condition holds, then uncoordinated updates are allowed. Otherwise a diffusing computation is initiated to coordinate updates. <p> This removes all stale information and ensures that that the distances along all paths in the tree will remain increasing. On the way up, the selection action is enabled. The first applications of this method were less efficient. In <ref> [MS79] </ref> when an edge fails or a cost changes, a vertex signals up the tree to the root which then triggers a series of diffusing computations each of which improves the tree until a shortest path tree is formed.
Reference: [Per83] <author> R. Perlman, </author> <title> "Fault-Tolerant Broadcast of Routing Information," </title> <booktitle> Com--puter Networks, </booktitle> <month> December </month> <year> 1983. </year>
Reference-contexts: Because periodic broadcast is inefficient, event driven broadcast is more common. In order to distinguish updates, sequence numbers must be used. Because the sequence numbers must be finite and vertices can go up and down, the implementation details are quite complex <ref> [Per83, Spi89, JBS87] </ref>. In the distance-vector approach to routing, neighboring vertices exchange (advertise) vectors of distances with each other. Advertising locally is advantageous over the link-state method because it requires less communication overhead than global broadcasts.
Reference: [PY94] <author> G. Parlati and M. Yung, </author> <title> "Non-Exploratory Self-Stabilization for Constant-Space Symmetry-Breaking," </title> <booktitle> Proc. 2nd Annual European Symposium on Algorithms, ESA, </booktitle> <pages> pp. 183-201, </pages> <year> 1994. </year>
Reference-contexts: There is a class of tasks that are inherently non-silent. An example of such a task is a mutual-exclusion or token passing system where the contents of the communication registers must be changed over time e.g. <ref> [DIM93, GH96, IJ90, PY94] </ref>. In order to prove our lower bounds we assume the existence of a silent legitimate global state and use this state to construct a silent global state that is illegitimate 1 .
Reference: [RL95] <author> Y. Rekhter and T. Li, </author> <title> "A Border Gateway Protocol 4 (BGP-$)," </title> <type> RFC 1771, </type> <month> March </month> <year> 1995. </year>
Reference-contexts: By utilizing this extra information, selection actions are able to avoid cycles. This method is used in the Border Gateway Protocol (BGP) of the Internet <ref> [RL95] </ref>. It is still possible for transient routing cycles to occur although at each step of a protocol the routing tables are consistent. This is because taken over time the tables may not be consistent.
Reference: [SC87] <author> K. G. Shin and M Chen, </author> <title> "Performance Analysis of Distributed Routing Strategies Free of Ping-Pong-Type Looping," </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 36, No. 2, </volume> <month> February </month> <year> 1987. </year>
Reference-contexts: In subsequent work, [Gar89] generalized the use of diffusing computations to both distance-vector and link-state algorithms as a method to prevent cycles. In path labeling, neighboring vertices advertise both their distance and their labeled paths to the root <ref> [SC87, Gar92] </ref>. For instance if vertex v has parent w to reach root r, then v will advertise a path of v concatenated with the path of w to the root. By utilizing this extra information, selection actions are able to avoid cycles.
Reference: [Sch93] <author> M. Schneider, </author> <title> "Self-Stabilization," </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 25, No. 1, </volume> <month> March </month> <year> 1993. </year>
Reference-contexts: The addition 14 of mobility to both hosts and networks adds an extra level of complexity to this challenge. An emerging research topic in distributed computing and networking that holds great promise in achieving the goals of greater reliability and dependability is self-stabilization <ref> [Sch93] </ref>. Implicit in the design of any protocol is a labeling of its states as legitimate or illegitimate. We identify as legitimate those states which occur under the correct (intended) execution of a protocol. All other states are considered illegitimate.
Reference: [SD94] <author> S. Sibal and A. DeSimone, </author> <title> "Controlling Alternate Routing in General-Mesh Packet Flow Networks," </title> <booktitle> ACM SIGCOMM 1994 Symposium, </booktitle> <month> August </month> <year> 1994. </year>
Reference: [Spi89] <author> J. M. Spinelli and R. Gallagher, </author> <title> "Event Driven Topology Broadcast Without Sequence Numbers," </title> <journal> IEEE Transactions on Communications, </journal> <volume> Vol. 37, No. 5, </volume> <month> May </month> <year> 1989. </year>
Reference-contexts: Because periodic broadcast is inefficient, event driven broadcast is more common. In order to distinguish updates, sequence numbers must be used. Because the sequence numbers must be finite and vertices can go up and down, the implementation details are quite complex <ref> [Per83, Spi89, JBS87] </ref>. In the distance-vector approach to routing, neighboring vertices exchange (advertise) vectors of distances with each other. Advertising locally is advantageous over the link-state method because it requires less communication overhead than global broadcasts.
Reference: [SRR95] <author> Sandeep K. Shukla, Daniel J. Rosenkrantz and S. S. Ravi, </author> <title> "Observations on Self-Stabilizing Graph Algorithms for Anonymous Networks," </title> <booktitle> Proc. of the Second Workshop on Self-Stabilizing Systems, UNLV, </booktitle> <pages> pp. </pages> <address> 7.1-7.15, </address> <year> 1995. </year>
Reference-contexts: We consider uniform, semi-uniform and id-based systems as we now define 1 A similar approach has been proposed in [IJ90] for proving the memory required to avoid silence (deadlock in the case of mutual exclusion), also see <ref> [SRR95] </ref> for different techniques for proving impossibility results in uniform systems. 2 In contrast see [GHR90] for several impossibility results based upon convergence. 113 informally.
Reference: [Sta94] <author> W. Stallings, </author> <title> Data and Computer Communications, Fourth Edition, </title> <publisher> Macmillan Publishing Company, </publisher> <year> 1994. </year> <month> 145 </month>
Reference: [Ste95] <author> M. Steenstrup, </author> <title> Routing in Communications Networks, </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1995. </year>
Reference-contexts: The next hop towards a destination defines a vertex's parent in the tree rooted by that destination. This relationship between trees and routing tables is not made explicit 4 in much of the literature on routing. See for instance [Hui95] and <ref> [Ste95] </ref>. In this thesis we emphasize this connection. In particular we will refer to the next hop as the parent and we will refer to the destination as the root. Whereas much of the literature refers to upstream and downstream neighbors, we will use the equivalent terms ancestor and descendent.
Reference: [Taj77] <author> W. D. Tajibnapis, </author> <title> "A correctness proof of a topology information maintenance protocol for distributed computer networks," </title> <journal> Communications of the ACM, </journal> <volume> vol. 20, </volume> <pages> pp. 477-485, </pages> <month> July </month> <year> 1977. </year>
Reference: [Var94] <author> G. Varghese, </author> <title> "Self-Stabilization by Counter Flushing," </title> <booktitle> Proceedings of the 1994 ACM Symposium on Principles of Distributed Computing. </booktitle>
Reference-contexts: In the other method, the protocol is augmented with a protocol for detecting that all actions, other than the timeout action of r, have terminated. Several stabilizing termination detection protocols have been proposed (for example [GE90] and <ref> [Var94] </ref>), and our protocol can easily be augmented with one. Instead of using an integer sequence number s:v for every vertex v, binary sequence numbers can be used in the enhanced maximum flow tree protocol.
Reference: [Vet95] <author> R. J. Vetter, </author> <title> "ATM Concepts, Architectures, and Protocols," </title> <journal> Communications of the ACM, </journal> <volume> Vol. 38, No. 2, </volume> <month> February </month> <year> 1995. </year> <month> 146 </month>
Reference-contexts: Asynchronous Transfer Mode (ATM) has been described as the future networking paradigm to support the requirements of the diverse set of multimedia applications we will see <ref> [Vet95] </ref>. The future multimedia applications to be supported by ATM virtual circuits will include video on demand, interactive distance learning, interactive scientific visualizations, collaborative discussions that utilize digital medical imaging, and multi-party videoconferencing.
References-found: 73

