URL: http://theory.lcs.mit.edu/tds/papers/Fekete/VSGC.ps
Refering-URL: http://theory.lcs.mit.edu/tds/vsgc.html
Root-URL: 
Email: Email: fekete@cs.usyd.edu.au  Email: lynch@theory.lcs.mit.edu.  Email: alex@theory.lcs.mit.edu.  
Title: Specifying and Using a Partitionable Group Communication Service  
Author: Alan Fekete Nancy Lynch Alex Shvartsman 
Address: Madsen Building F09, University of Sydney, NSW 2006, Australia.  545 Technology Square, NE43-365, Cam-bridge, MA 02139, USA.  545 Technology Square, NE43-371, Cam-bridge, MA 02139, USA.  
Affiliation: Basser Department of Computer Science,  Massachusetts Institute of Technology, Laboratory for Computer Science,  Massachusetts Institute of Technology, Laboratory for Computer Science,  
Date: January 29, 1998  
Abstract: Group communication services are becoming widely accepted as useful building blocks for the construction of fault-tolerant distributed applications. Many system designers and researchers have proposed formal specifications for group communication services. However, there is still no agreement about what these specifications should say, especially in cases where the services are partitionable, that is, where disjoint sets of members may simultaneously believe they constitute the whole group. In this paper, we present a new, simple specification for a partitionable group communication service. We use the specification to construct an ordered-broadcast application, using an algorithm (based on algorithms of Amir, Dolev, Keidar and others) that reconciles information derived from different instantiations of the group. We prove the correctness and analyze the performance and fault-tolerance of the resulting application. Our specification has a simple implementation, based on the membership algorithm of Cristian and Schmuck. The service we specify associates each message with a particular view of the group membership. All send and receive events for a message occur at processors when they have the associated view. The service provides a total order on the messages within each view, and each processor receives a prefix of this total order. The style of our specification is different from those of previous specifications for group communication services, in that we separate safety requirements from performance and fault-tolerance requirements. The safety requirements are expressed by an abstract, global state machine. To present the performance and fault-tolerance requirements, we include failure-status input actions in the specification; we then give properties saying that consensus on the view and timely message delivery are guaranteed in an execution provided that the execution stabilizes to a situation in which the failure status stops changing and corresponds to a consistently partitioned system. (This stabilization hypothesis can be seen as an abstract version of the "timed asynchronous model" of Cristian.) Our specification is simple; for example, it does not mention any "hidden" or "transitional" views as do some others. It is also significantly weaker than most others, for example, we do not require consensus on either knowledge of group membership or on message delivery, except in those cases where the execution stabilizes. Because consensus is not required in every execution, the specification is not subject to the existing impossibility results for partitionable systems. Despite its weakness, the specification is sufficient to allow important applications to run on top of the group communication service. In this paper, we present one such application, the ordered-broadcast application mentioned above. The application manages the view-change activity to build a shared sequence of messages, that is, the per-view total orders of the group service are combined to give a universal total order. The ordered-broadcast application can itself be used to implement sequentially consistent memory, using simple replicated data management. Our state-based specification is used in an assertional proof of the safety properties of the ordered-broadcast application; this proof requires reasoning only about 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Amir, D. Dolev, P. Melliar-Smith and L. Moser, </author> <title> "Robust and Efficient Replication Using Group Com munication" Technical Report 94-20, </title> <institution> Department of Computer Science, Hebrew University., </institution> <year> 1994. </year>
Reference-contexts: To demonstrate the value of our specification, we use it to construct an ordered-broadcast application, using an algorithm, based on algorithms of Amir, Dolev, Keidar, Melliar-Smith and Moser <ref> [18, 1] </ref>, that reconciles information derived from different views. We prove the correctness and analyze the performance and fault-tolerance of this algorithm. Our specification has a simple implementation, based on the membership algorithm of Cristian and Schmuck [10]. <p> This algorithm is based on data replication algorithms developed by Amir, Dolev, Keidar, Melliar-Smith and Moser <ref> [18, 1] </ref>. These previous algorithms implement a fault-tolerant shared memory by sending modification operations to each replica through a group communication service based on Extended Virtual Synchrony, and carrying out a state-exchange protocol when partition components merge.
Reference: [2] <author> Y. Amir, L. Moser, P. Melliar-Smith, D. Agrawal and P. Ciarfella, </author> <title> "Fast Message Ordering and Membership Using a Logical Token-Passing Ring", </title> <booktitle> in Proc. of IEEE International Conference on Distributed Computing Systems, </booktitle> <year> 1993, </year> <pages> pp 551-560. </pages>
Reference: [3] <author> O. Babaoglu, R. Davoli, L. Giachini and M. Baker, "Relacs: </author> <title> A Communication Infrastructure for Construct ing Reliable Applications in Large-Scale Distributed Systems", </title> <booktitle> in Proc. of Hawaii International Conference on Computer and System Science, 1995, </booktitle> <volume> volume II, </volume> <pages> pp 612-621. 27 </pages>
Reference-contexts: Different group communication services offer different guarantees about the order and reliability of message delivery. Examples are found in Isis [6], Transis [11], Totem [25], Newtop [13], Relacs <ref> [3] </ref> and Horus [27]. The basis of a group communication service is a group membership service. Each process, at each time, has a unique view of the membership of the group. The view includes a list of the processes that are members of the group.
Reference: [4] <author> O. Babaoglu, R. Davoli and A. Montresor, </author> <title> "Failure Detectors, Group Membership and View-Synchronous Communication in Partitionable Asynchronous Systems", </title> <type> Technical Report UBLCS-95-18, </type> <institution> Department of Computer Science, University of Bologna, Italy. </institution>
Reference-contexts: In particular, there has been a large amount of work on developing specifications for partitionable group services. Some specifications deal just with membership and views [17, 29] while others also cover message services (ordering and reliability properties) <ref> [24, 4, 5, 9, 12, 15, 16] </ref>. These specifications are all complicated, many are difficult to understand, and some seem to be ambiguous. It is not clear how to tell whether a specification is sufficient for a given application. <p> VS does not require any relationship among the membership of concurrent views held by different processors. Stronger specifications demand that these views be either disjoint or identical [5], or either disjoint or subsets <ref> [4] </ref>. 4. VS does not require consensus on whether a message is delivered. Many other specifications for group communication, including [4, 5, 12, 15, 24], insist on delivery at every processor in the intersection of the current view and a successor view. <p> Stronger specifications demand that these views be either disjoint or identical [5], or either disjoint or subsets [4]. 4. VS does not require consensus on whether a message is delivered. Many other specifications for group communication, including <ref> [4, 5, 12, 15, 24] </ref>, insist on delivery at every processor in the intersection of the current view and a successor view.
Reference: [5] <author> O. Babaoglu, R. Davoli, L. Giachini and P. Sabattini, </author> <title> "The Inherent Cost of Strong-Partial View Syn chronous Communication", </title> <booktitle> in Proc of Workshop on Distributed Algorithms on Graphs, </booktitle> <pages> pp 72-86, </pages> <year> 1995. </year>
Reference-contexts: In particular, there has been a large amount of work on developing specifications for partitionable group services. Some specifications deal just with membership and views [17, 29] while others also cover message services (ordering and reliability properties) <ref> [24, 4, 5, 9, 12, 15, 16] </ref>. These specifications are all complicated, many are difficult to understand, and some seem to be ambiguous. It is not clear how to tell whether a specification is sufficient for a given application. <p> We begin in Section 3 by giving a simple formal specification for a totally ordered broadcast service, which we call TO . This specification will be used later as the correctness definition for an algorithm 1 This is not the same as the notion of view-synchrony defined in <ref> [5] </ref>. 2 We consider "processor groups" in the formal material of this paper rather than "process groups". The distinction is unimportant here. 3 Each processor maintains a replica of the underlying memory. A read operation is performed immediately on the local copy. <p> VS does not require that a processor learn of all the views of which it is a member. 3. VS does not require any relationship among the membership of concurrent views held by different processors. Stronger specifications demand that these views be either disjoint or identical <ref> [5] </ref>, or either disjoint or subsets [4]. 4. VS does not require consensus on whether a message is delivered. Many other specifications for group communication, including [4, 5, 12, 15, 24], insist on delivery at every processor in the intersection of the current view and a successor view. <p> Stronger specifications demand that these views be either disjoint or identical [5], or either disjoint or subsets [4]. 4. VS does not require consensus on whether a message is delivered. Many other specifications for group communication, including <ref> [4, 5, 12, 15, 24] </ref>, insist on delivery at every processor in the intersection of the current view and a successor view. <p> The differences represented by points 2, 4 and 6 mean that our VS service is not subject to the impossibility results that a*ict some group communication specifications <ref> [5, 7] </ref>. Although VS is weaker in several respects than most considered in the literature, we demonstrate that it is strong enough to be useful, by showing, in Section 5, how an interesting and useful algorithm can run on top of it.
Reference: [6] <author> K.P. Birman and R. van Renesse, </author> <title> Reliable Distributed Computing with the Isis Toolkit, </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1994. </year>
Reference-contexts: Different group communication services offer different guarantees about the order and reliability of message delivery. Examples are found in Isis <ref> [6] </ref>, Transis [11], Totem [25], Newtop [13], Relacs [3] and Horus [27]. The basis of a group communication service is a group membership service. Each process, at each time, has a unique view of the membership of the group. <p> The view includes a list of the processes that are members of the group. Views can change from time to time, and may become different at different processes. Isis introduced the important concept of virtual synchrony <ref> [6] </ref>. This concept has been interpreted in various ways, but an essential requirement is that if a particular message is delivered to several processes, then all have the same view of the membership when the message is delivered.
Reference: [7] <author> T.D. Chandra, V. Hadzilacos, S. Toueg and B. Charron-Bost, </author> <title> "On the Impossibility of Group Membership", </title> <booktitle> in Proc. of 15th Annual ACM Symp. on Princ. of Distr. Comput., </booktitle> <pages> pp. 322-330, </pages> <year> 1996. </year>
Reference-contexts: The first major work on the development of specifications for fault-tolerant group-oriented membership and communication services appears to be that of Ricciardi [28], and the research area is still active (see, e.g., <ref> [26, 7] </ref>). In particular, there has been a large amount of work on developing specifications for partitionable group services. Some specifications deal just with membership and views [17, 29] while others also cover message services (ordering and reliability properties) [24, 4, 5, 9, 12, 15, 16]. <p> It is not clear how to tell whether a specification is sufficient for a given application. It is not even clear how to tell whether a specification is implementable at all; impossibility results such as those in <ref> [7] </ref> demonstrate that this is a significant issue. 2 Our contributions We present a new, simple formal specification for a partitionable view-oriented group communication service. <p> The differences represented by points 2, 4 and 6 mean that our VS service is not subject to the impossibility results that a*ict some group communication specifications <ref> [5, 7] </ref>. Although VS is weaker in several respects than most considered in the literature, we demonstrate that it is strong enough to be useful, by showing, in Section 5, how an interesting and useful algorithm can run on top of it.
Reference: [8] <author> F. Cristian, </author> <title> "Synchronous and Asynchronous Group Communication", </title> <journal> Comm. of the ACM, </journal> <volume> vol. 39, no. 4, </volume> <pages> pp. 88-97, </pages> <year> 1996. </year>
Reference-contexts: This stabilization hypothesis can be seen as an abstract version of the "timed asynchronous model" of Cristian <ref> [8] </ref>. These performance and fault-tolerance properties are expressed in precise natural language and require operational reasoning. We consider how our view-synchronous group communication service can be used in the distributed implementation of a sequentially consistent memory. <p> In contrast, our service delivers a message before it is safe and later provides a notification once delivery has happened at all other group members. 6. There are no liveness requirements that apply to all executions. Instead, we follow the "timed asynchronous model" of Cristian <ref> [8] </ref> and make conditional claims for timely delivery only in certain executions where the processors and links behave well. 7.
Reference: [9] <author> F. Cristian, </author> <title> "Group, Majority and Strict Agreement in Timed Asynchronous Distributed Systems", </title> <booktitle> in Proc. of 26th Conference on Fault-Tolerant Computer Systems, </booktitle> <year> 1996, </year> <pages> pp. 178-187. </pages>
Reference-contexts: In particular, there has been a large amount of work on developing specifications for partitionable group services. Some specifications deal just with membership and views [17, 29] while others also cover message services (ordering and reliability properties) <ref> [24, 4, 5, 9, 12, 15, 16] </ref>. These specifications are all complicated, many are difficult to understand, and some seem to be ambiguous. It is not clear how to tell whether a specification is sufficient for a given application.
Reference: [10] <author> F. Cristian and F. Schmuck, </author> <title> "Agreeing on Processor Group Membership in Asynchronous Distributed Systems", </title> <type> Technical Report CSE95-428, </type> <institution> Department of Computer Science, University of California San Diego. </institution>
Reference-contexts: We prove the correctness and analyze the performance and fault-tolerance of this algorithm. Our specification has a simple implementation, based on the membership algorithm of Cristian and Schmuck <ref> [10] </ref>. We call our specification VS , which stands for view-synchrony. 1 In VS , the views are presented to each processor 2 according to a consistent total order, though not every processor need see every view. <p> Instead, we sketch one implementation, informally. The implementation is based on the 3-round membership protocol 5 given by Cristian and Schmuck in <ref> [10] </ref>. In this protocol, once a view is formed, it is "held together" by a circulating token, which is started by a deterministically chosen leader, and travels from member to member around a logical ring. <p> * While status p = bad , processor p takes no locally controlled step. * While status pq = good , every packet sent from p to q arrives within time ffi * While status pq = bad , no packet is delivered from p to q As analyzed in <ref> [10] </ref> the protocol above implements VS (b; d; Q), where Q is any set of processors, b = 9ffi + maxf + (n + 3)ffi; g, and d = 2 + nffi. <p> Some remarks about a correctness proof for this implementation: The safety claim involves showing that any trace of the implementation is a trace of VS-machine. Since traces include only external events 5 A different implementation could use the one-round protocol of <ref> [10] </ref>. However, this would stabilize less quickly. 26 (and not internal events like createview), the implementation needn't preserve the order of createview events (in fact, the implementation needn't even have createview events). To show this trace inclusion, we use WeakVS-machine.
Reference: [11] <author> D. Dolev and D. Malki, </author> <title> "The Transis Approach to High Availability Cluster Communications", </title> <journal> Comm. of the ACM, </journal> <volume> vol. 39, no. 4, </volume> <pages> pp. 64-70, </pages> <year> 1996. </year>
Reference-contexts: Different group communication services offer different guarantees about the order and reliability of message delivery. Examples are found in Isis [6], Transis <ref> [11] </ref>, Totem [25], Newtop [13], Relacs [3] and Horus [27]. The basis of a group communication service is a group membership service. Each process, at each time, has a unique view of the membership of the group. <p> The "safe" indication is separate from the message delivery event. In Transis, Totem and Horus <ref> [11, 25, 27] </ref>, delivery can be delayed until the lower layer at each site has the message (though it might not yet have delivered it). Thus in these systems, safe delivery means that every other member is guaranteed to also provide safe delivery or crash.
Reference: [12] <author> D. Dolev, D. Malki and R. </author> <title> Strong "A Framework for Partitionable Membership Service", </title> <type> Technical Report TR94-6, </type> <institution> Department of Computer Science, Hebrew University. </institution>
Reference-contexts: In particular, there has been a large amount of work on developing specifications for partitionable group services. Some specifications deal just with membership and views [17, 29] while others also cover message services (ordering and reliability properties) <ref> [24, 4, 5, 9, 12, 15, 16] </ref>. These specifications are all complicated, many are difficult to understand, and some seem to be ambiguous. It is not clear how to tell whether a specification is sufficient for a given application. <p> Here are the most important differences between our specification VS and other group communication specifications. 1. VS does not mention any "transitional views" or "hidden views", such as are found in Extended Virtual Synchrony [24] or the specification of Dolev et al <ref> [12] </ref>. Each processor always has a well-defined view of the group membership, and all recipients of a message share the view that the sender had when the message was sent. 2. VS does not require that a processor learn of all the views of which it is a member. 3. <p> Stronger specifications demand that these views be either disjoint or identical [5], or either disjoint or subsets [4]. 4. VS does not require consensus on whether a message is delivered. Many other specifications for group communication, including <ref> [4, 5, 12, 15, 24] </ref>, insist on delivery at every processor in the intersection of the current view and a successor view.
Reference: [13] <author> P. Ezhilchelvan, R. Macedo and S. Shrivastava "Newtop: </author> <title> A Fault-Tolerant Group Communication Protocol" in Proc. </title> <booktitle> of IEEE International Conference on Distributed Computing Systems, </booktitle> <year> 1995, </year> <pages> pp 296-306. </pages>
Reference-contexts: Different group communication services offer different guarantees about the order and reliability of message delivery. Examples are found in Isis [6], Transis [11], Totem [25], Newtop <ref> [13] </ref>, Relacs [3] and Horus [27]. The basis of a group communication service is a group membership service. Each process, at each time, has a unique view of the membership of the group. The view includes a list of the processes that are members of the group.
Reference: [14] <author> A. Fekete, F. Kaashoek and N. </author> <title> Lynch "Providing Sequentially-Consistent Shared Objects Using Group and Point-to-point Communication" in Proc. </title> <booktitle> of IEEE International Conference on Distributed Computer Systems, </booktitle> <year> 1995, </year> <pages> pp 439-449. </pages>
Reference-contexts: The formal automaton definition is given in Figure 2. The finite traces of this automaton are exactly the finite prefixes of traces of a totally ordered causal broadcast layer, as defined in <ref> [14] </ref>.
Reference: [15] <author> R. Friedman and R. van Renesse, </author> <title> "Strong and Weak Virtual Synchrony in Horus", </title> <type> Technical Report TR95 1537, </type> <institution> Department of Computer Science, Cornell University. </institution>
Reference-contexts: In particular, there has been a large amount of work on developing specifications for partitionable group services. Some specifications deal just with membership and views [17, 29] while others also cover message services (ordering and reliability properties) <ref> [24, 4, 5, 9, 12, 15, 16] </ref>. These specifications are all complicated, many are difficult to understand, and some seem to be ambiguous. It is not clear how to tell whether a specification is sufficient for a given application. <p> Stronger specifications demand that these views be either disjoint or identical [5], or either disjoint or subsets [4]. 4. VS does not require consensus on whether a message is delivered. Many other specifications for group communication, including <ref> [4, 5, 12, 15, 24] </ref>, insist on delivery at every processor in the intersection of the current view and a successor view.
Reference: [16] <author> M. Hiltunen and R. </author> <title> Schlichting "Properties of Membership Services", </title> <booktitle> in Proc. of 2nd International Sympo sium on Autonomous Decentralized Systems, </booktitle> <pages> pp 200-207, </pages> <year> 1995. </year>
Reference-contexts: In particular, there has been a large amount of work on developing specifications for partitionable group services. Some specifications deal just with membership and views [17, 29] while others also cover message services (ordering and reliability properties) <ref> [24, 4, 5, 9, 12, 15, 16] </ref>. These specifications are all complicated, many are difficult to understand, and some seem to be ambiguous. It is not clear how to tell whether a specification is sufficient for a given application.
Reference: [17] <author> F. Jahanian, S. Fakhouri and R. Rajkumar, </author> <title> "Processor Group Membership Protocols: Specification, </title> <booktitle> Design and Implementation" in Proc. of 12th IEEE Symposium on Reliable Distributed Systems pp 2-11, </booktitle> <year> 1993. </year>
Reference-contexts: In particular, there has been a large amount of work on developing specifications for partitionable group services. Some specifications deal just with membership and views <ref> [17, 29] </ref> while others also cover message services (ordering and reliability properties) [24, 4, 5, 9, 12, 15, 16]. These specifications are all complicated, many are difficult to understand, and some seem to be ambiguous.
Reference: [18] <author> I. Keidar and D. Dolev, </author> <title> "Efficient Message Ordering in Dynamic Networks", </title> <booktitle> in Proc. of 15th Annual ACM Symp. on Princ. of Distr. Comput., </booktitle> <pages> pp. 68-76, </pages> <year> 1996. </year>
Reference-contexts: To demonstrate the value of our specification, we use it to construct an ordered-broadcast application, using an algorithm, based on algorithms of Amir, Dolev, Keidar, Melliar-Smith and Moser <ref> [18, 1] </ref>, that reconciles information derived from different views. We prove the correctness and analyze the performance and fault-tolerance of this algorithm. Our specification has a simple implementation, based on the membership algorithm of Cristian and Schmuck [10]. <p> This algorithm is based on data replication algorithms developed by Amir, Dolev, Keidar, Melliar-Smith and Moser <ref> [18, 1] </ref>. These previous algorithms implement a fault-tolerant shared memory by sending modification operations to each replica through a group communication service based on Extended Virtual Synchrony, and carrying out a state-exchange protocol when partition components merge.
Reference: [19] <author> L. Lamport, </author> <title> "Time, Clocks. and the Ordering of Events in a Distributed System, </title> <journal> Comm. of the ACM, </journal> <volume> vol. 21, no. 7, </volume> <pages> pp. 558-565, </pages> <year> 1978. </year>
Reference-contexts: The fact that this provides a sequentially consistent shared memory is at the heart of the "Replicated State Machine" approach to distributed system design. It was first described by Lamport <ref> [19] </ref>, a survey of this approach is given by Schneider in [30] (see also the references therein). An alternative approach is to send all operations (not just updates) through the totally ordered broadcast service; this approach constructs an atomic shared memory. 3 running over a group communication service.
Reference: [20] <author> N.A. Lynch, </author> <title> Distributed Algorithms, </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1996. </year>
Reference-contexts: Thus in these systems, safe delivery means that every other member is guaranteed to also provide safe delivery or crash. A simple "coordinated attack" argument (as in Chapter 5 of <ref> [20] </ref>) shows that in a partitionable system, this notion of safe delivery is incompatible with having all recipients in exactly the same view as the sender. <p> We present the algorithm using I/O automata <ref> [21, 20] </ref>. Finally, in Sections 6 and 7, we give a proof that the VStoTO algorithm, running on top of VS , indeed provides the service expressed by the TO specification. The safety aspect of this claim uses assertional methods. <p> Untimed models are used for the safety properties, while timed models are used for the performance and fault-tolerance properties. The untimed model we use is the I/O automaton model of Lynch and Tuttle [21], also described in Chapter 8 of <ref> [20] </ref>. We do not use the "task" construct of the model the only components we need are a set of states, a designated subset of start states, a signature specifying input, output and internal actions, and a set of (state,action,state) transitions. <p> The timed model we use is that of Lynch and Vaandrager [23], as described in Chapter 23 of <ref> [20] </ref>. This is similar to the untimed model, but also 5 includes time passage actions -(t), which indicate the passage of real time t. Time passage actions also have associated state transitions. <p> Execution fragments can be concatenated, as can timed execution fragments, traces and timed traces. I/O automata can be composed, as can timed automata; Chapters 8 and 23 of <ref> [20] </ref> contain theorems showing that composition respects the external behavior. Invariant assertion and simulation relation methods for these two models are also presented in those chapters. 3 Totally Ordered Broadcast In this section, we present TO, our specification for a totally ordered broadcast communication service. <p> Fix Q to be any set of processors containing a quorum. We first show Condition 1 of the definition of TO-property , that fi with the timing information removed is a trace of TO-machine. This follows from general composition results for timed automata (see, e.g., Chapter 23 of <ref> [20] </ref>), using what we have already proved in the safety part of the paper. In more detail, regard ff as a timed execution of the composed system composed of VStoTO 0 and A, without the interface actions being hidden.
Reference: [21] <author> N.A. Lynch and M.R. Tuttle, </author> <title> "An Introduction to Input/Output Automata", </title> <journal> CWI Quarterly, vol.2, </journal> <volume> no. 3, </volume> <pages> pp. 219-246, </pages> <year> 1989. </year>
Reference-contexts: We present the algorithm using I/O automata <ref> [21, 20] </ref>. Finally, in Sections 6 and 7, we give a proof that the VStoTO algorithm, running on top of VS , indeed provides the service expressed by the TO specification. The safety aspect of this claim uses assertional methods. <p> Our services and algorithms are described using untimed and timed state machine models. Untimed models are used for the safety properties, while timed models are used for the performance and fault-tolerance properties. The untimed model we use is the I/O automaton model of Lynch and Tuttle <ref> [21] </ref>, also described in Chapter 8 of [20]. We do not use the "task" construct of the model the only components we need are a set of states, a designated subset of start states, a signature specifying input, output and internal actions, and a set of (state,action,state) transitions.
Reference: [22] <author> N.A. Lynch and F. Vaandrager, </author> <title> "Forward and Backward Simulations | Part I: </title> <journal> Untimed Systems", Infor mation and Computation, </journal> <volume> vol. 121, no. 2, </volume> <pages> pp. 214-233, </pages> <year> 1995. </year>
Reference-contexts: In a state of the composition, we refer to the separate state variables by giving a subscript p indicating a variable that is part of the state of VStoTO p . The proof is based on a forward simulation relation <ref> [22] </ref> from VStoTO-system to TO-machine, established with the help of a series of invariant assertions for VStoTO-system.
Reference: [23] <author> N.A. Lynch and F. Vaandrager, </author> <title> "Forward and backward simulations Part II: </title> <journal> Timing-based systems", Information and Computation vol. </journal> <volume> 128, no. 1, </volume> <pages> pp 1-25, </pages> <year> 1996. </year>
Reference-contexts: The timed model we use is that of Lynch and Vaandrager <ref> [23] </ref>, as described in Chapter 23 of [20]. This is similar to the untimed model, but also 5 includes time passage actions -(t), which indicate the passage of real time t. Time passage actions also have associated state transitions. <p> To formulate our performance/fault-tolerance claim, we define TO-property (b; d; Q) as a parameterized property of a timed sequence pair over external actions of TO-fsig, as defined in <ref> [23] </ref>. This is a pair consisting of a sequence fi of timed actions (with non-decreasing times) together with an ltime. Here, we only consider cases where ltime = 1. The parameters b and d are nonnegative reals, and the parameter Q is a set of processors.
Reference: [24] <author> L. Moser, Y. Amir, P. Melliar-Smith and D. Agrawal, </author> <title> "Extended Virtual Synchrony" in Proc. </title> <booktitle> of IEEE International Conference on Distributed Computing Systems, </booktitle> <year> 1994, </year> <pages> pp 56-65. </pages>
Reference-contexts: In particular, there has been a large amount of work on developing specifications for partitionable group services. Some specifications deal just with membership and views [17, 29] while others also cover message services (ordering and reliability properties) <ref> [24, 4, 5, 9, 12, 15, 16] </ref>. These specifications are all complicated, many are difficult to understand, and some seem to be ambiguous. It is not clear how to tell whether a specification is sufficient for a given application. <p> Here are the most important differences between our specification VS and other group communication specifications. 1. VS does not mention any "transitional views" or "hidden views", such as are found in Extended Virtual Synchrony <ref> [24] </ref> or the specification of Dolev et al [12]. Each processor always has a well-defined view of the group membership, and all recipients of a message share the view that the sender had when the message was sent. 2. <p> Stronger specifications demand that these views be either disjoint or identical [5], or either disjoint or subsets [4]. 4. VS does not require consensus on whether a message is delivered. Many other specifications for group communication, including <ref> [4, 5, 12, 15, 24] </ref>, insist on delivery at every processor in the intersection of the current view and a successor view.
Reference: [25] <author> L.E. Moser, P.M. Melliar-Smith, D.A. Agarawal, R.K. Budhia and C.A. Lingley-Papadopolous, "Totem: </author> <title> A Fault-Tolerant Multicast Group Communication System", </title> <journal> Comm. of the ACM, </journal> <volume> vol. 39, no. 4, </volume> <pages> pp. 54-63, </pages> <year> 1996. </year>
Reference-contexts: Different group communication services offer different guarantees about the order and reliability of message delivery. Examples are found in Isis [6], Transis [11], Totem <ref> [25] </ref>, Newtop [13], Relacs [3] and Horus [27]. The basis of a group communication service is a group membership service. Each process, at each time, has a unique view of the membership of the group. The view includes a list of the processes that are members of the group. <p> The "safe" indication is separate from the message delivery event. In Transis, Totem and Horus <ref> [11, 25, 27] </ref>, delivery can be delayed until the lower layer at each site has the message (though it might not yet have delivered it). Thus in these systems, safe delivery means that every other member is guaranteed to also provide safe delivery or crash.
Reference: [26] <author> G. Neiger, </author> <title> "A New Look at Membership Services", </title> <booktitle> in Proc. of 15th Annual ACM Symp. on Princ. of Distr. Comput., </booktitle> <pages> pp. 331-340, </pages> <year> 1996. </year>
Reference-contexts: The first major work on the development of specifications for fault-tolerant group-oriented membership and communication services appears to be that of Ricciardi [28], and the research area is still active (see, e.g., <ref> [26, 7] </ref>). In particular, there has been a large amount of work on developing specifications for partitionable group services. Some specifications deal just with membership and views [17, 29] while others also cover message services (ordering and reliability properties) [24, 4, 5, 9, 12, 15, 16].
Reference: [27] <author> R. van Renesse, K.P. Birman and S. Maffeis, "Horus: </author> <title> A Flexible Group Communication System", </title> <journal> Comm. of the ACM, </journal> <volume> vol. 39, no. 4, </volume> <pages> pp. 76-83, </pages> <year> 1996. </year>
Reference-contexts: Different group communication services offer different guarantees about the order and reliability of message delivery. Examples are found in Isis [6], Transis [11], Totem [25], Newtop [13], Relacs [3] and Horus <ref> [27] </ref>. The basis of a group communication service is a group membership service. Each process, at each time, has a unique view of the membership of the group. The view includes a list of the processes that are members of the group. <p> The "safe" indication is separate from the message delivery event. In Transis, Totem and Horus <ref> [11, 25, 27] </ref>, delivery can be delayed until the lower layer at each site has the message (though it might not yet have delivered it). Thus in these systems, safe delivery means that every other member is guaranteed to also provide safe delivery or crash.
Reference: [28] <author> A. Ricciardi, </author> <title> "The Group Membership Problem in Asynchronous Systems", </title> <type> Technical Report TR92-1313, </type> <institution> Department of Computer Science, Cornell University. </institution>
Reference-contexts: Moreover, the specifications that most accurately describe particular implementations may not be the ones that are easiest for application programmers to use. The first major work on the development of specifications for fault-tolerant group-oriented membership and communication services appears to be that of Ricciardi <ref> [28] </ref>, and the research area is still active (see, e.g., [26, 7]). In particular, there has been a large amount of work on developing specifications for partitionable group services.
Reference: [29] <author> A. Ricciardi, A. Schiper and K. Birman, </author> <title> "Understanding Partitions and the "No Partitions" Assumption", </title> <type> Technical Report TR93-1355, </type> <institution> Department of Computer Science, Cornell University. </institution>
Reference-contexts: In particular, there has been a large amount of work on developing specifications for partitionable group services. Some specifications deal just with membership and views <ref> [17, 29] </ref> while others also cover message services (ordering and reliability properties) [24, 4, 5, 9, 12, 15, 16]. These specifications are all complicated, many are difficult to understand, and some seem to be ambiguous.
Reference: [30] <author> F. Schneider, </author> <title> "Implementing Fault-Tolerant Services using the State machine Approach: A Tutorial", </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 22, no. 4, </volume> <year> 1990. </year> <month> 28 </month>
Reference-contexts: The fact that this provides a sequentially consistent shared memory is at the heart of the "Replicated State Machine" approach to distributed system design. It was first described by Lamport [19], a survey of this approach is given by Schneider in <ref> [30] </ref> (see also the references therein). An alternative approach is to send all operations (not just updates) through the totally ordered broadcast service; this approach constructs an atomic shared memory. 3 running over a group communication service.
References-found: 30

