URL: ftp://ftp.cs.kun.nl/pub/CSI/SoftwEng.FunctLang/papers/serp97-cgfunctional.ps.gz
Refering-URL: http://www.cs.kun.nl/~clean/Clean.Papers.html
Root-URL: 
Email: e-mail: pascalrs@cs.kun.nl  
Title: Implementing the Conjugate Gradient Algorithm in a Functional Language  
Author: Pascal R. Serrarens 
Address: Netherlands  
Affiliation: Computer Science Institute University of Nijmegen, The  
Abstract: This paper evaluates the elegance and efficiency of functional programming in numerical scientific computing, an interesting area because time and space efficiency are important: many scientific programs work with large data sets and run for a long time. The example we use is the conjugate gradient algorithm, an iterative method to solve systems of linear equations. We investigated various implementations of the algorithm in the functional languages Clean and Haskell and the imperative language C. Good results are obtained when comparing the algorithm written in Clean with the same algorithm in C and Haskell. The expressive power of functional programming languages seems to equal to that of traditional imperative languages, while many current compilers produce time- and space-efficient code, using various optimisations including the important update-in-place. Two traditionally weak points of functional language implementations are speed and memory usage, which are very important in numerical scientific computing. The "pseudoknot" paper [H + 96] showed that, for a numerical algorithm, only a couple of functional-language compilers could produce code comparable with to that produced by C compilers. In this paper we investigate writing the conjugate gradient algorithm in the general purpose lazy functional language Clean [PvE93] and compare it against similar implementations in C and Haskell [HPJW92]. In Section 1 we will look at the algorithm itself. We look how the choice of data structure influences the performance in Section 2. We describe some optimisations that yield an efficient implementation in Section 3. In Section 4 we compare our implementation in Clean with implementations in the languages C and Haskell, while Section 5 concludes. 
Abstract-found: 1
Intro-found: 1
Reference: [BS93] <author> E. Barendsen and J.E.W Smetsers. </author> <title> Conventional and uniqueness typing in graph rewrite systems. </title> <type> Technical Report CSI-R9328, </type> <institution> Computer Science Institute, Faculty of Mathematics and Informatics, University of Nijmegen, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Besides generating and indexing of arrays, updating array elements is also possible in some cases. When the array type has the uniqueness attribute *, it is safe to perform an update in place. Uniqueness typing <ref> [BS93] </ref> is able to derive, or enforce, that functions have exclusive access to arguments with the uniqueness attribute.
Reference: [CSJ95] <author> S. Choi, T.K. Sarkar, and Choi J. </author> <title> Adaptive antenna array for direction-of-arrival estimation utilizing the conjugate gradient method. </title> <journal> Signal Processing (SIGPRO), </journal> <volume> 45(3) </volume> <pages> 313-327, </pages> <month> Sep </month> <year> 1995. </year>
Reference-contexts: 1 The Conjugate Gradient Algorithm An algorithm often used in scientific computing for solving a system of linear equations is the conjugate gradient algorithm <ref> [CSJ95] </ref> [EO94] [JDG92] [HS93]. The algorithm itself is an iterative approximation method to solve the linear equation Ax = b. A direct method is the gauss elimination. But, only when working with symbolic computation, which provides arbitrary precision integers, can we get an exact solution.
Reference: [EO94] <author> R.G. Ellis and D.W. </author> <title> Oldenburg. The pole-pole 3-d dc resistivity inverse problem: a conjugate gradient approach. </title> <journal> Geophysical Journal International, </journal> <volume> 119 </volume> <pages> 187-194, </pages> <year> 1994. </year>
Reference-contexts: 1 The Conjugate Gradient Algorithm An algorithm often used in scientific computing for solving a system of linear equations is the conjugate gradient algorithm [CSJ95] <ref> [EO94] </ref> [JDG92] [HS93]. The algorithm itself is an iterative approximation method to solve the linear equation Ax = b. A direct method is the gauss elimination. But, only when working with symbolic computation, which provides arbitrary precision integers, can we get an exact solution.
Reference: [GLPJ93] <author> A. Gill, J. Launchbury, and S.L. Peyton Jones. </author> <title> A short cut to deforestation. </title> <booktitle> In Proceedings of the ACM Conference on Functional Programming Languages and Computer Architecture (FPCA'93), </booktitle> <pages> pages 223-232, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Unboxed arrays with map fusion Unfortunately, map fusion must be done completely by hand at the moment. There are a number of theories to do it automatically [Wad90] [SF93], but it is very hard to implement them. Only one implementation doing cheap deforestation exists at the moment <ref> [GLPJ93] </ref>.
Reference: [H + 96] <author> P.H. Hartel et al. </author> <title> Benchmarking implementations of functional languages with "pseudoknot", a float-intensive benchmark. </title> <journal> Journal functional programming, </journal> <volume> 6(4) </volume> <pages> 621-655, </pages> <month> July </month> <year> 1996. </year>
Reference-contexts: Uniqueness typing [BS93] is able to derive, or enforce, that functions have exclusive access to arguments with the uniqueness attribute. The expression f a & [i] = x g is an update of array a at position i with x. 2.3 Vectors and matrices from arrays In <ref> [H + 96] </ref> the remark was made that arrays were not well supported in most of the languages. Now that Clean supports arrays, we can see the importance of it. In this section we do not make use of update-in-place, with one exception for the matrix-vector multiplication.
Reference: [HPJW92] <editor> P. Hudak, S.L. Peyton Jones, and P. Wadler. </editor> <title> Report on the programming language haskell, a non-strict purely functional language (version 1.2). </title> <journal> SIG-PLAN Notices, </journal> <month> Mar, </month> <year> 1992. </year>
Reference: [HS93] <author> A.G. Hoekstra and P.M.A. Sloot. </author> <title> Implementation of a parallel conjugate gradient method for simulation of elastic light. </title> <booktitle> 4th Physics Computing '92, </booktitle> <pages> pages 345-346, </pages> <year> 1993. </year>
Reference-contexts: 1 The Conjugate Gradient Algorithm An algorithm often used in scientific computing for solving a system of linear equations is the conjugate gradient algorithm [CSJ95] [EO94] [JDG92] <ref> [HS93] </ref>. The algorithm itself is an iterative approximation method to solve the linear equation Ax = b. A direct method is the gauss elimination. But, only when working with symbolic computation, which provides arbitrary precision integers, can we get an exact solution. Functional languages might be well suited for that.
Reference: [JDG92] <author> E.M. Johansson, F.U. Dowla, and D.M. Goodman. </author> <title> Backpropagation learn-ing for multi-layer feed-forward neural networks using the conjugate gradient method. </title> <journal> International Journal of Neural Systems, </journal> <volume> 2(4), </volume> <year> 1992. </year>
Reference-contexts: 1 The Conjugate Gradient Algorithm An algorithm often used in scientific computing for solving a system of linear equations is the conjugate gradient algorithm [CSJ95] [EO94] <ref> [JDG92] </ref> [HS93]. The algorithm itself is an iterative approximation method to solve the linear equation Ax = b. A direct method is the gauss elimination. But, only when working with symbolic computation, which provides arbitrary precision integers, can we get an exact solution.
Reference: [KGGK94] <author> V. Kumar, A. Grama, A. Gupta, and G. Karypis. </author> <title> Introduction to Parallel Computing, Design and Analysis of Algorithms. </title> <publisher> The Benjamin/Cummings Publishing Company, Inc., </publisher> <address> California, </address> <year> 1994. </year>
Reference-contexts: The returned x is a good approximation of the real value of x. A more detailed description of the algorithm can be found in <ref> [KGGK94] </ref>. 1.1 The Matrix The representation of the matrix we have chosen in this paper is not straightforward. The conjugate gradient algorithm is used often to solve large sparse systems of linear equations.
Reference: [LPJ94] <author> J. Launchbury and S.L. Peyton Jones. </author> <title> Lazy functional state threads. </title> <booktitle> In Programming Languages Design and Implementation, </booktitle> <address> Orlando, 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The performance of Haskell arrays for the algorithm unboxed in one memory block and both can be updated in place. Where Clean uses uniqueness typing to do save update-in-place, GHC uses a monad <ref> [LPJ94] </ref>. Monads use a state to thread all functions using the state, which are called actions.
Reference: [PJ96] <author> S.L. Peyton Jones. </author> <title> Bulk types with class. </title> <booktitle> In Proceedings of the 1996 Glas-gow Workshop on Fucntional Programming, </booktitle> <address> Ullapool, Scotland, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: However, the implementation of simple operations like addition of vectors, must be implemented separately for arrays and lists. Multi-parameter type classes could avoid this <ref> [PJ96] </ref>, but are not implemented at the moment. For every problem size 10 test-runs were made, of which the best time was taken. All tests ran on a Sun Sparcstation 20 at 50MHz with 64Mb of memory and 1Mb cache running under Solaris 2.4.
Reference: [PJL91] <author> S.L. Peyton Jones and J. Launchbury. </author> <title> Unboxed values as first class citizens. </title> <booktitle> In FPCA'91 | Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 636-666, </pages> <year> 1991. </year>
Reference-contexts: Strict arrays f ! x g are represented the same way as lazy arrays, but now the elements are always evaluated. Unboxed arrays f # x g are stored in the most efficient way. All elements are stored unboxed <ref> [PJL91] </ref> in a continuous block of memory. The overloading mechanism of Clean makes it possible to use the same function names for creating, selecting and updating of the three kinds of arrays. Therefore we can write the program independent of the array representation.
Reference: [PvE93] <author> M.J. Plasmeijer and M.C.J.D. van Eekelen. </author> <title> Functional Programming and Parallel Graph Rewriting. </title> <publisher> Addison-Wesley Publishers Ltd., </publisher> <year> 1993. </year>
Reference: [SF93] <author> T. Sheard and L. Fegaras. </author> <title> A fold for all seasons. </title> <booktitle> In Proceedings of the ACM Conference on Functional Programming Languages and Computer Architecture (FPCA'93), </booktitle> <pages> pages 233-242, </pages> <address> Orlando, April 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Unboxed arrays with map fusion Unfortunately, map fusion must be done completely by hand at the moment. There are a number of theories to do it automatically [Wad90] <ref> [SF93] </ref>, but it is very hard to implement them. Only one implementation doing cheap deforestation exists at the moment [GLPJ93].
Reference: [Wad90] <author> P. Wadler. </author> <title> Deforestation: Transforming programs to eliminate trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 73 </volume> <pages> 231-248, </pages> <year> 1990. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Unboxed arrays with map fusion Unfortunately, map fusion must be done completely by hand at the moment. There are a number of theories to do it automatically <ref> [Wad90] </ref> [SF93], but it is very hard to implement them. Only one implementation doing cheap deforestation exists at the moment [GLPJ93].
References-found: 15

