URL: http://www.it.kth.se/docs/Reports/se/classes-as-spec.ps.Z
Refering-URL: http://www.it.kth.se/docs/Reports/se/
Root-URL: http://www.it.kth.se
Email: tyugu@it.kth.se  
Title: USING CLASSES AS SPECIFICATIONS FOR AUTOMATIC CONSTRUCTION OF PROGRAMS IN THE NUT SYSTEM  
Author: Enn Tyugu 
Address: Electrum 204, S-164 40 Kista, Sweden;  
Affiliation: Royal Institute of Technology, Department of Teleinformatics,  
Abstract: It is shown how the object-oriented programming paradigm has been combined with automatic program construction in the NUT system: type information extracted from a class specification is being used for automatic construction of methods for the class. Special compute-messages are introduced as requests for program synthesis which can be done statically or dynamically. Particular features of the specification language which support the program synthesis are considered and applications of this method are outlined. 
Abstract-found: 1
Intro-found: 1
Reference: <editor> H.-M. Haav, A. Kalja. </editor> <booktitle> Knowledge-Based Data Modeling Technique,in Advances in Information Modeling and Knowledge Bases, </booktitle> <publisher> IOS Press, Amsterdam, </publisher> <pages> pp. 152 - 166, </pages> <year> 1991. </year>
Reference-contexts: It has ben explained in details in (Mints 1988) and (Tyugu 1991a). Some references to practical applications of this tech 2 nique are the following: development of data management systems <ref> (Haav 1991) </ref>, compiler construction (Penjam 1983) and simulation of hydromechanical systems (Pahapill 1985). When the idea of object-oriented computations became popular, we were still working with the PRIZ system (Mints 1988) where specifications analogical to classes were used for describing problem conditions for structural synthesis of programs.
Reference: <author> J. Jaffar, J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> in Proc. of the 14th ACM Symposium on Principles of Programming Languages, Munich, </booktitle> <pages> pp. 111 - 119, </pages> <year> 1987. </year>
Reference-contexts: Quite a success has been achieved in combining logic and constraint programming. Two very promising approaches have evolved: constraint logic programming initiated by J.-L. Lassez and J. Jaffar <ref> (Jaffar 1987) </ref>, and concurrent constraint programming introduced by V. Saraswat (Saraswat 1990). Recent works of G. Smolka (Smolka 1993) give an example of merging constraint programming with object-oriented programming. The present paper describes the combination of an automatic knowledge-based program development technique with the object-oriented programming.
Reference: <author> V. Kotov, A. Nariniani, E. Tyugu. </author> <title> The USSR Academy of Sciences START Project. </title> <booktitle> in Information Processing 89 (IFIP89), </booktitle> <publisher> North Holland, </publisher> <pages> pp. 623 - 626, </pages> <year> 1989. </year>
Reference-contexts: But the language was never implemented in the precise correspondence with it. The first implementation of a version of the NUT language was done as a part of the Soviet new generation computer project START on the Pirs workstations which were developed in the framework of the same project <ref> (Kotov 89, Tyugu 91a) </ref>. In 1990, the NUT language was revised and the system was implemented in various UNIX and X Window environments.
Reference: <author> M. Matskin, E. Tyugu. </author> <title> The NUT language. </title> <institution> TRITA-TCS-SE-92-TR, Royal Institute of Technology, Stockholm, </institution> <year> 1992. </year>
Reference-contexts: The work on implementation of the present version of NUT was completed at the Royal Institute of Technology in Stockholm where it has been put into the public domain and is available by the anonymous ftp <ref> (Matskin 1992) </ref>. We add a brief informal description of the NUT specification language as an appendix to the present paper. More information about the ideas behind the language and, especially, about the automatic program synthesis can be found in (Tyugu 91a). <p> More information about the specification language of the NUT system can be found in <ref> (Matskin 92) </ref>, and a summary of the language is given in the Appendix 1 Virtuals are variables which can be used in computations and passed as parameters to methods, but dont belong to the state variables of a class.
Reference: <author> G. Mints, E. Tyugu. </author> <title> The Programming System PRIZ. </title> <journal> Journal of Symbolic Computations, </journal> <volume> vol. 5, </volume> <pages> pp. 359 - 375, </pages> <year> 1988. </year>
Reference-contexts: The automatic program construction technique used here is called structural synthesis of programs and has been used earlier in several programming tools of the PRIZ family. It has ben explained in details in <ref> (Mints 1988) </ref> and (Tyugu 1991a). Some references to practical applications of this tech 2 nique are the following: development of data management systems (Haav 1991), compiler construction (Penjam 1983) and simulation of hydromechanical systems (Pahapill 1985). <p> Some references to practical applications of this tech 2 nique are the following: development of data management systems (Haav 1991), compiler construction (Penjam 1983) and simulation of hydromechanical systems (Pahapill 1985). When the idea of object-oriented computations became popular, we were still working with the PRIZ system <ref> (Mints 1988) </ref> where specifications analogical to classes were used for describing problem conditions for structural synthesis of programs. We attempted to add explicit message passing facilities to PRIZ, but the results remained unsatisfactory. <p> Automatic program construction in NUT We give only a very brief description of the program construction method itself here, because it has been published earlier and has been already used in the PRIZ system <ref> (Mints 1988) </ref>. Having a specification of a class, we are, in general, interested in solving the following problem: find an algorithm for computing the values of components y1,..., yn from the values of components x1,...,xm.
Reference: <author> G. Mints, E. Tyugu. </author> <title> Propositional Logic Programming and the PRIZ system. </title> <journal> Journal of Logic Programing, </journal> <volume> vol. 9, No.2-3, </volume> <pages> pp. 179 - 194, </pages> <year> 1990. </year>
Reference: <author> J. Pahapill. </author> <title> Modeling of Hydromechanical Systems. in Application Software Packages in the PRIZ Programming System, </title> <journal> Estonian Acad. Sci., Tallinn, pp. </journal> <volume> 56 - 92, </volume> <year> 1988. </year>
Reference: <author> J. Penjam. </author> <title> Synthesis of Semantic Processors from Attribute Grammars. </title> <booktitle> System Programming and Computer Software, No.1, </booktitle> <pages> pp. 50 - 60, </pages> <year> 1983. </year>
Reference-contexts: It has ben explained in details in (Mints 1988) and (Tyugu 1991a). Some references to practical applications of this tech 2 nique are the following: development of data management systems (Haav 1991), compiler construction <ref> (Penjam 1983) </ref> and simulation of hydromechanical systems (Pahapill 1985). When the idea of object-oriented computations became popular, we were still working with the PRIZ system (Mints 1988) where specifications analogical to classes were used for describing problem conditions for structural synthesis of programs.
Reference: <author> V. Saraswat. </author> <title> Concurrent Constraint Programming. </title> <booktitle> in Proc. of the 17th ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, </address> <pages> pp. 232 - 245, </pages> <year> 1990. </year>
Reference-contexts: Quite a success has been achieved in combining logic and constraint programming. Two very promising approaches have evolved: constraint logic programming initiated by J.-L. Lassez and J. Jaffar (Jaffar 1987), and concurrent constraint programming introduced by V. Saraswat <ref> (Saraswat 1990) </ref>. Recent works of G. Smolka (Smolka 1993) give an example of merging constraint programming with object-oriented programming. The present paper describes the combination of an automatic knowledge-based program development technique with the object-oriented programming.
Reference: <author> G. Smolka, M. Henz, J. Wurtz. </author> <title> (1993) Object-Oriented Concurrent Constraint Programming in Oz. </title> <institution> DFKI RR-933-16, Saarbrucken, </institution> <year> 1993. </year>
Reference-contexts: Quite a success has been achieved in combining logic and constraint programming. Two very promising approaches have evolved: constraint logic programming initiated by J.-L. Lassez and J. Jaffar (Jaffar 1987), and concurrent constraint programming introduced by V. Saraswat (Saraswat 1990). Recent works of G. Smolka <ref> (Smolka 1993) </ref> give an example of merging constraint programming with object-oriented programming. The present paper describes the combination of an automatic knowledge-based program development technique with the object-oriented programming. <p> Specification processing and constraint solving gives us a form of declarative (relational) programming. Combination of object manipulation and constraint solving is the most interesting and novel part of the NUT system. This is a kind of constraint object programming which is still different from the approach taken in <ref> (Smolka 1993) </ref>, first of all, because it applies a specific technique of constraint solving by program synthesis. Acknowledgments I am much indebted to Mari Kopp, Mihail Matskin and Benjamin Volozh for polishing the present version of the NUT system.
Reference: <author> E. Tyugu, M. Matskin, J. Penjam, P. Eomois. </author> <title> NUT - an object-oriented language. </title> <journal> Computers and Artificial Intelligence. vol.5, </journal> <volume> No. 6, </volume> <pages> pp. 521 - 542, </pages> <year> 1986. </year>
Reference-contexts: This lead us to the design of a new language called NUT. The NUT language was outlined as an extension of an object-oriented programming language with features of automatic program synthesis, and its full description appeared in <ref> (Tyugu 86) </ref>. But the language was never implemented in the precise correspondence with it.
Reference: <author> E. Tyugu. </author> <title> Three New-Generation Software Environments. </title> <journal> Communications of the ACM, </journal> <volume> vol. 34, </volume> <pages> pp. 46-59, </pages> <year> 1991a. </year>
Reference-contexts: The automatic program construction technique used here is called structural synthesis of programs and has been used earlier in several programming tools of the PRIZ family. It has ben explained in details in (Mints 1988) and <ref> (Tyugu 1991a) </ref>. Some references to practical applications of this tech 2 nique are the following: development of data management systems (Haav 1991), compiler construction (Penjam 1983) and simulation of hydromechanical systems (Pahapill 1985). <p> We add a brief informal description of the NUT specification language as an appendix to the present paper. More information about the ideas behind the language and, especially, about the automatic program synthesis can be found in <ref> (Tyugu 91a) </ref>. In the following section we describe these features of classes which are essential for automatic construction of programs, and give some example problems for synthesis. We use only very simple examples which can be followed in details and understood without hard formal work. <p> This feature provides the generality to the specification language, allowing one to specify any general recursive function using only a very limited set of predefined functions, see <ref> (Tyugu 91b) </ref>. An application example is given in section 7 where classes for simulating dynamic systems are desrcibed. 2. Classes in NUT The NUT language has features of an object-oriented language with multiple inheritance, parametric polymorphism and a exible mechanism for message passing.
Reference: <author> E. Tyugu. </author> <title> Declarative Programming in a Type Theory. </title> <editor> in: B. Moller (ed.) </editor> <title> Constructing Programs from Specifications, </title> <publisher> North-Holland, </publisher> <pages> pp. 451 - 472, </pages> <year> 1991b. </year> <month> 19 </month>
Reference-contexts: We add a brief informal description of the NUT specification language as an appendix to the present paper. More information about the ideas behind the language and, especially, about the automatic program synthesis can be found in <ref> (Tyugu 91a) </ref>. In the following section we describe these features of classes which are essential for automatic construction of programs, and give some example problems for synthesis. We use only very simple examples which can be followed in details and understood without hard formal work. <p> This feature provides the generality to the specification language, allowing one to specify any general recursive function using only a very limited set of predefined functions, see <ref> (Tyugu 91b) </ref>. An application example is given in section 7 where classes for simulating dynamic systems are desrcibed. 2. Classes in NUT The NUT language has features of an object-oriented language with multiple inheritance, parametric polymorphism and a exible mechanism for message passing. <p> The method of program construction from type specifications which is used automatically in the NUT system is described in <ref> (Tyugu 1991b) </ref>. Here we show the application of this method manually on the example of finding the maximum of function specified by the class prob-lem2 in section 2. We denote types of objects by identifiers written in capital letters. <p> The term which represents the object of the type MX * MY can be built in parallel with the derivation of the given judgement, and it is the following: g (l (function.arg). (1 - function.arg ^2)). This formalism is explained in details in <ref> (Tyugu 1991b) </ref>. Here we are satisfied with the knowledge that we have an efficient method for program construction from specifications and it has a nice formal explanation. Some words have to be said about the efficiency of the derivation. Actual algorithms still work on a network representation of the semantics.
References-found: 13

