URL: http://www.cs.unc.edu/~olano/papers/primitive/primitive.ps.gz
Refering-URL: http://www.cs.unc.edu/~olano/papers/
Root-URL: http://www.cs.unc.edu
Title: Procedural Primitives in a High Performance, Hardware Accelerated, Z-Buffer Renderer  
Author: Marc Olano, Anselmo Lastra, Jonathan Leech 
Address: Chapel Hill, NC 27599-3175  
Affiliation: Department of Computer Science University of North Carolina  
Note: UNC-CH TR 97-040 1  
Abstract: In the past, very few types of primitives have been directly supported by graphics accelerators, in spite of the fact that a great variety of complex primitives are routinely used for high-quality rendering. We explore the issues associated with the support of arbitrary procedural primitives, and describe a machine-independent language as well as an extension to OpenGL designed to support user-defined procedural primitives. We have created a prototype implementation on PixelFlow, a high-performance graphics accelerator. 
Abstract-found: 1
Intro-found: 1
Reference: [Akeley92] <author> Kurt Akeley, K. P. Smith, J. Neider, </author> <title> OpenGL Reference Manual, </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: 1. Introduction A large variety of different graphical primitives are routinely used for high-quality, offline rendering. These primitives include polygons, spheres, superquadrics, spline patches, blobs, and many others (figure 1 shows examples of several). Although libraries for interactive rendering, such as OpenGL <ref> [Akeley92] </ref>, support a subset of these primitives, graphics acceleration hardware can usually only directly render polygons. Thus, the more complex primitives are tessellated to polygons before being sent to the graphics hardware. <p> The PixelFlow API is an extension to OpenGL <ref> [Akeley92] </ref>. Our goal was to divorce the abstract programmable-primitive interface from the PixelFlow specific implementation, and to support the existing OpenGL primitives as a special case. In OpenGL, there is a notion of the current state of attributes such as color, normals, etc.
Reference: [Akeley93] <author> Kurt Akeley, </author> <booktitle> RealityEngine Graphics , Computer Graphics (SIGGRAPH 93 Proceedings) , volume 27, </booktitle> <month> August </month> <year> 1993, </year> <pages> pp. 109116. </pages>
Reference-contexts: The algorithm follows the edges from one scan line to the next, and interpolates depth and shading parameters from one pixel to the next across the scan line. One such algorithm was introduced by Pineda [Pineda88], and has been used by Silicon Graphics <ref> [Akeley93] </ref>. This algorithm uses a linear function ( ax + by + c ) of the pixel coordinates for each edge. This function is positive inside the edge and negative outside.
Reference: [Amburn86] <author> Phil Amburn and Eric Grant and Turner Whitted, </author> <title> Managing Geometric Complexity with Enhanced Procedural Models , Computer Graphics (SIGGRAPH 86 Proceedings) , volume 20(4), </title> <month> August </month> <year> 1986, </year> <pages> pp. 189195. </pages>
Reference-contexts: We are, of course, not the first to consider procedural primitives. There have been a number of papers on procedural models [Hedelman84] <ref> [Amburn86] </ref> [Green88] [Upstill90]. These are procedures for higher level objects that generate lower level primitives. They can provide some advantages for high-level culling and changes in the level of detail of the model. A number of ray tracers allow new primitives to be added [Rubin80] [Hall83] [Wyvill85] [Kuchkuda88] [Kolb92].
Reference: [Crow82] <author> F. C. Crow, </author> <title> A More Flexible Image Generation Environment, </title> <booktitle> Computer Graphics (SIGGRAPH 82 Proceedings) , volume 16(3), </booktitle> <month> July </month> <year> 1982, </year> <pages> pp. 918. </pages>
Reference-contexts: None that we are aware of use a separate language to define the new primitives. There have also been a handful of scan-line and Z-buffer systems that have allowed the addition of new primitives. <ref> [Crow82] </ref> treated primitives as separate processes, whose result is later composited separately. [Whitted82] used a well defined interface in a scan line renderer to allow new primitives to be easily written in C and added to the renderer. [Fleischer88] allowed primitives to be defined as LISP functions defining the surfaces parametrically
Reference: [Ebert94] <author> David Ebert, F. Kenton Musgrave, Darwyn Peachey, Ken Perlin and Steven Worley, </author> <title> Texturing and Modeling: A Procedural Approach , Academic Press, </title> <year> 1994. </year>
Reference-contexts: All that is left are per-primitive parameters. Obviously these can be used to define constant values, though thats not terribly interesting. They can also be used to define arbitrary value fields in space. This is equivalent to the Eberts solid spaces <ref> [Ebert94] </ref>. Using this technique, a surface shader can be turned into a volume shader, as is shown in Figure 5 . The texture coordinates are determined by two functions which are defined everywhere in space. Any surface can use these texture coordinates, no matter what primitives generated the surface.
Reference: [Fleischer88] <author> K. Fleischer and A. Witkin, </author> <title> A Modeling Testbed, </title> <booktitle> Proceedings of Graphics Interface 88 , Canadian Inf. Process. Society 1988, </booktitle> <pages> pp. 137137. </pages>
Reference-contexts: scan-line and Z-buffer systems that have allowed the addition of new primitives. [Crow82] treated primitives as separate processes, whose result is later composited separately. [Whitted82] used a well defined interface in a scan line renderer to allow new primitives to be easily written in C and added to the renderer. <ref> [Fleischer88] </ref> allowed primitives to be defined as LISP functions defining the surfaces parametrically and implicitly. [Glassner93] defines primitives with C++ code, which can be linked in fairly arbitrary ways with the other stages of his renderer.
Reference: [Fuchs82] <author> Henry Fuchs, John Poulton, </author> <month> Pixel-Planes: </month>
Reference-contexts: This algorithm can be cast, instead, in a pixel-centric form. Then an individual pixel is determined to be in the polygon if all edge functions are positive. This can also be thought of as the pixel-centric version of the Pixel-Planes scan conversion algorithm <ref> [Fuchs82] </ref>, where the polygon is defined implicitly as the region where all edge functions are positive. Some RenderMan surface shaders (notably the wall paper in Pixars KnickKnack) operate by drawing geometric shapes on the surface.
References-found: 7

