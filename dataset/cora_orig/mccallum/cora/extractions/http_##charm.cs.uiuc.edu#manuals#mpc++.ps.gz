URL: http://charm.cs.uiuc.edu/manuals/mpc++.ps.gz
Refering-URL: http://charm.cs.uiuc.edu/manuals/
Root-URL: http://www.cs.uiuc.edu
Title: TR-94024 Meta-level Architecture for Extendable C++ Draft Document meta-level architecture defines a meta system consisting
Author: Yutaka Ishikawa 
Address: Building 16F, 1-6-1 Takezono Tsukuba-shi, Ibaraki 305, Japan  
Affiliation: Tsukuba Mitsui  
Note: Tsukuba Research Center, Real World Computing Partnership  The  
Pubnum: Laboratory  
Email: ishikawa@rwcp.or.jp  
Date: Received 28 Feburary 1995  
Abstract: This document describes a meta-level architecture for the MPC ++ programming language. The MPC ++ meta-level architecture is designed so that programmers can introduce new notation and redefine default code generation with less effort. This capability is very useful for implementing extended C++ languages and some performance and debugging monitors. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Rohit Chandra, Anoop Gupta, and John L. Hennessy. </author> <title> Integrating Concurrency and Data Abstraction in the COOL Parallel Programming Language. </title> <type> Technical Report CSL-TR-92-511, </type> <institution> Stanford University, </institution> <year> 1992. </year>
Reference-contexts: New expressions and statements A remote invocation expression has been introduced to generate the RPC stab code in languages for distributed computing. Some structured statements for controlling parallel execution are found in COOL <ref> [1] </ref>, Extended-C++[17], CC++, RTC++, and so on. 4. New function capabilities New notation has been introduced to give a function new capabilities. An example is a parallel function in COOL [1]. 5. <p> Some structured statements for controlling parallel execution are found in COOL <ref> [1] </ref>, Extended-C++[17], CC++, RTC++, and so on. 4. New function capabilities New notation has been introduced to give a function new capabilities. An example is a parallel function in COOL [1]. 5. New modifier for variables New notation that declares a parallel variable as a set of storage locations allocated on processors has been introduced in parallel languages.
Reference: [2] <author> K. Mani Chandy and Carl Kesselman. </author> <title> CC++: A Declarative Concurrent Object-Oriented Programming Notation. </title> <editor> In G. Agha, P. Wegner, A. Yonezawa, editor, </editor> <booktitle> Research Directions in Concurrent Object Oriented Programming. </booktitle> <publisher> MIT press, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction User demands to extend programming language semantics or introduce new notation are growing because of the need to adapt a language to paticular application domains such as parallel/distributed environments <ref> [2, 4, 5, 12] </ref>, real-time system [11], and so on. New language notation will make it easier for users to improve program readability and maintainability. Moreover, the compiler may have a chance to generate an efficient code for a high-level abstracted notation.
Reference: [3] <author> David E. Culler, Andrea Dusseau, Seth Copen Goldstein, Arvind Krishnamurthy, Steven Lumetta, Thorsten von Eicken, and Katherine Yelick. </author> <title> Parallel programming in split-c. </title> <booktitle> In Supercomputing '93, </booktitle> <year> 1993. </year>
Reference-contexts: Rather, it must allow most C ++ extensions to be implemented. The following is a summary of existing C and C ++ extensions. 1. New type modifier In a parallel system environment, global pointers and related operations have been introduced to access the remote memory area in Split-C <ref> [3] </ref>, EM-C [16], and CC++[2]. To add an additional feature to an object, some modifiers to the class declaration are introduced in RTC++[11], Mentat [6], CHARM++[12], and so on.
Reference: [4] <author> J. K. Lee Dennis Gannon. </author> <title> Object Oriented Parallelism: pC++ Ideas and Experiments. </title> <booktitle> In Proceedings of 1991 Joint Symposium of Parallel Processing, </booktitle> <pages> pp. 13-22, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction User demands to extend programming language semantics or introduce new notation are growing because of the need to adapt a language to paticular application domains such as parallel/distributed environments <ref> [2, 4, 5, 12] </ref>, real-time system [11], and so on. New language notation will make it easier for users to improve program readability and maintainability. Moreover, the compiler may have a chance to generate an efficient code for a high-level abstracted notation.
Reference: [5] <author> Y. Gourhant and Marc Shapiro. FOG/C++: </author> <title> a Fragmented-Object Generator. </title> <booktitle> In 1990 USENIX C++ Conference, </booktitle> <pages> pp. </pages> <address> pp.63-74, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction User demands to extend programming language semantics or introduce new notation are growing because of the need to adapt a language to paticular application domains such as parallel/distributed environments <ref> [2, 4, 5, 12] </ref>, real-time system [11], and so on. New language notation will make it easier for users to improve program readability and maintainability. Moreover, the compiler may have a chance to generate an efficient code for a high-level abstracted notation. <p> New type structure In pC++[4], a new structure called collection has been introduced to describe data parallel computation. In FO <ref> [5] </ref>, MPC ++ [9], and so on, a new member declaration part in the class declaration has been introduced to describe parallel/distributed computing. New 2 DESIGN 3 invocation mechanisms have been designed for functions declared in these new member declaration parts. 3.
Reference: [6] <author> Andrew S. Grimshaw. </author> <title> Easy-to-Use Object-Oriented Parallel Processing with Mentat. </title> <journal> COMPUTER, </journal> <volume> Vol. 26, No. 5, </volume> <pages> pp. 39-51, </pages> <year> 1993. </year>
Reference-contexts: New type modifier In a parallel system environment, global pointers and related operations have been introduced to access the remote memory area in Split-C [3], EM-C [16], and CC++[2]. To add an additional feature to an object, some modifiers to the class declaration are introduced in RTC++[11], Mentat <ref> [6] </ref>, CHARM++[12], and so on. Of course, the semantics of operations on the modified type, including method invocation, has been newly defined in those extended C ++ languages.
Reference: [7] <author> Yuuji Ichisugi, Satoshi Matsuoka, and Akinori Yonezawa. RbCl: </author> <title> A Reflective Object-Oriented Concurrent Language without a Run-time Kernel. </title> <booktitle> In IMSA'92 International Workshop on Reflection and Meta-Level Architecutre, </booktitle> <pages> pp. 23-35, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: The meta-level architecture has been designed for practical rather than theoretical use. That is, meta-circularity [18] or several levels of meta systems [10, 14] are eliminated. In existing meta-level architectures for object-oriented languages such as ABCL/R [19], ABCL/R2 [15], Rbcl <ref> [7] </ref>, AL-1/D [14], and so on, language execution behavior is defined by the set of objects the base-level language can modify. Those systems do not focus on introducing new notation. The architecture proposed here focuses on this capability.
Reference: [8] <author> Yutaka Ishikawa. </author> <title> MPC++:Massively Parallel, Message Passing, Meta-Level Processing C++. </title> <address> POOMA'94, </address> <month> December </month> <year> 1994. </year> <note> The silde is obtained via http://www.rwcp.or.jp/people/ishikawa/mpc++.html. </note>
Reference-contexts: The old version of the MPC ++ meta level architecture has been partly implemented <ref> [8] </ref>. Though the core idea is the same as in the old version, the description capability has been improved. This document does not cover the following features: 1. Template handling in the meta-level We are now considering how to handle templates. 2.
Reference: [9] <author> Yutaka Ishikawa. </author> <title> The MPC++ Programming Language V1.0 Specification with Commentary Document Version 0.1 -. Technical Report TR-94014, </title> <booktitle> Real World Computing Partnership, </booktitle> <month> June </month> <year> 1994. </year> <note> REFERENCES 38 </note>
Reference-contexts: Several meta system modification facilities support easy meta-level programming. We believe that this approach is the same as the Metaobject Protocol (MOP) of CLOS [13]. The meta-level architecture is part of MPC ++ <ref> [9] </ref> which is an extension to C ++ . We use this feature to implement other extensions of MPC ++ features such as data parallel and real-time programming facilities. <p> We use this feature to implement other extensions of MPC ++ features such as data parallel and real-time programming facilities. In this paper, the proposed meta-level architecture is called the MPC ++ meta-level architecture. 2 DESIGN 2 The document, which is intended to replace the macro feature proposed in <ref> [9] </ref>, is organized as follows. In section 2, after a summary of the requirements of an extendable C ++ language, we present our design philosophy and an overview of the MPC ++ meta-level architecture. <p> New type structure In pC++[4], a new structure called collection has been introduced to describe data parallel computation. In FO [5], MPC ++ <ref> [9] </ref>, and so on, a new member declaration part in the class declaration has been introduced to describe parallel/distributed computing. New 2 DESIGN 3 invocation mechanisms have been designed for functions declared in these new member declaration parts. 3.
Reference: [10] <author> Yutaka Ishikawa and Hideaki Okamura. </author> <title> A New Reflective Architecture: AL-1 Approach. </title> <booktitle> In The Second OOPSLA 91 Workshop on Reflection and Metalevel Architecures, </booktitle> <year> 1991. </year>
Reference-contexts: To create an extendable programming language, we propose a meta-level architecture for C ++ . The meta-level architecture has been designed for practical rather than theoretical use. That is, meta-circularity [18] or several levels of meta systems <ref> [10, 14] </ref> are eliminated. In existing meta-level architectures for object-oriented languages such as ABCL/R [19], ABCL/R2 [15], Rbcl [7], AL-1/D [14], and so on, language execution behavior is defined by the set of objects the base-level language can modify. Those systems do not focus on introducing new notation. <p> 5 `- $$1 $2 [$3]; -.genCode (base_typeid (float), "f", 10); If the above examples are executed by invoking method genCode, the following code is generated: 1 10 + 20; 2 struct foo - int i; -; 3 int bar (int i) return i; - 4 int a; 5 float f <ref> [10] </ref>; 4 Meta-level Ob jects As shown in Figure 13, the abstract compiler at the meta-level consists of i) the lexical analyzer, parser, and code generator objects making up the abstract compiler, ii) syntax tree 4 META-LEVEL OBJECTS 14 objects representing the parse tree of a program, and iii) name table
Reference: [11] <author> Yutaka Ishikawa, Hideyuki Tokuda, and Clifford W. Mercer. </author> <title> Object-Oriented Real-Time Language Design: Constructs for Timing Constraints. </title> <booktitle> In Proceedings of OOPSLA-90, </booktitle> <pages> pp. 289-298, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: 1 Introduction User demands to extend programming language semantics or introduce new notation are growing because of the need to adapt a language to paticular application domains such as parallel/distributed environments [2, 4, 5, 12], real-time system <ref> [11] </ref>, and so on. New language notation will make it easier for users to improve program readability and maintainability. Moreover, the compiler may have a chance to generate an efficient code for a high-level abstracted notation. Some researchers have implemented compilers for new extended programming languages.
Reference: [12] <author> Laxmikant V. Kale and Sanjeev Krishnan. CHARM++: </author> <title> A Portable Concurrent Object Oriented System Based on C++. </title> <booktitle> In OOPSLA'93 Proceedings, </booktitle> <pages> pp. 91-108, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction User demands to extend programming language semantics or introduce new notation are growing because of the need to adapt a language to paticular application domains such as parallel/distributed environments <ref> [2, 4, 5, 12] </ref>, real-time system [11], and so on. New language notation will make it easier for users to improve program readability and maintainability. Moreover, the compiler may have a chance to generate an efficient code for a high-level abstracted notation.
Reference: [13] <author> G. Kiczales, J. des Rivieres, and D.G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Several meta system modification facilities support easy meta-level programming. We believe that this approach is the same as the Metaobject Protocol (MOP) of CLOS <ref> [13] </ref>. The meta-level architecture is part of MPC ++ [9] which is an extension to C ++ . We use this feature to implement other extensions of MPC ++ features such as data parallel and real-time programming facilities.
Reference: [14] <author> Hideaki Okamura and Yutaka Ishikawa. </author> <title> Object Location Control Using Meta-level Programming. </title> <booktitle> In Proceedings of 8th ECOOP94, Lecture Notes in Computer Science 821, </booktitle> <pages> pp. 299-319. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: To create an extendable programming language, we propose a meta-level architecture for C ++ . The meta-level architecture has been designed for practical rather than theoretical use. That is, meta-circularity [18] or several levels of meta systems <ref> [10, 14] </ref> are eliminated. In existing meta-level architectures for object-oriented languages such as ABCL/R [19], ABCL/R2 [15], Rbcl [7], AL-1/D [14], and so on, language execution behavior is defined by the set of objects the base-level language can modify. Those systems do not focus on introducing new notation. <p> The meta-level architecture has been designed for practical rather than theoretical use. That is, meta-circularity [18] or several levels of meta systems [10, 14] are eliminated. In existing meta-level architectures for object-oriented languages such as ABCL/R [19], ABCL/R2 [15], Rbcl [7], AL-1/D <ref> [14] </ref>, and so on, language execution behavior is defined by the set of objects the base-level language can modify. Those systems do not focus on introducing new notation. The architecture proposed here focuses on this capability.
Reference: [15] <author> A. Yonezawa S. Matsuoka, T. Watanabe. </author> <title> Hibrid Group Reflective Architecture for Object-Oriented Concurrent Reflective Programming. </title> <booktitle> In Fifth ECOOP, </booktitle> <month> July </month> <year> 1991. </year>
Reference-contexts: The meta-level architecture has been designed for practical rather than theoretical use. That is, meta-circularity [18] or several levels of meta systems [10, 14] are eliminated. In existing meta-level architectures for object-oriented languages such as ABCL/R [19], ABCL/R2 <ref> [15] </ref>, Rbcl [7], AL-1/D [14], and so on, language execution behavior is defined by the set of objects the base-level language can modify. Those systems do not focus on introducing new notation. The architecture proposed here focuses on this capability.
Reference: [16] <author> M. Sato, Y. Kodama, S. Sakai, Y. Yamaguchi, and S. Sekiguti. </author> <title> Distributed Data Structure in Thread-based Programming for a Highly Parallel Dataflow Machine EM-4. </title> <booktitle> In Proc. of ISCA 92 Dataflow Workshop, </booktitle> <year> 1992. </year>
Reference-contexts: The following is a summary of existing C and C ++ extensions. 1. New type modifier In a parallel system environment, global pointers and related operations have been introduced to access the remote memory area in Split-C [3], EM-C <ref> [16] </ref>, and CC++[2]. To add an additional feature to an object, some modifiers to the class declaration are introduced in RTC++[11], Mentat [6], CHARM++[12], and so on. Of course, the semantics of operations on the modified type, including method invocation, has been newly defined in those extended C ++ languages.
Reference: [17] <author> R. Seliger. </author> <title> Extending C++ to Support Remote Procedure Call, Concurrency, Exception Handling, and Garbage Collection. </title> <booktitle> In 1990 USENIX C++ Conference, </booktitle> <pages> pp. 241-264, </pages> <year> 1990. </year>
Reference: [18] <author> B. C. Smith. </author> <title> Reflection and Semantics in Lisp. </title> <booktitle> In Proceedings of 11th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 23-35, </pages> <year> 1984. </year>
Reference-contexts: To create an extendable programming language, we propose a meta-level architecture for C ++ . The meta-level architecture has been designed for practical rather than theoretical use. That is, meta-circularity <ref> [18] </ref> or several levels of meta systems [10, 14] are eliminated. In existing meta-level architectures for object-oriented languages such as ABCL/R [19], ABCL/R2 [15], Rbcl [7], AL-1/D [14], and so on, language execution behavior is defined by the set of objects the base-level language can modify.
Reference: [19] <author> T. Watanabe and A. Yonezawa. </author> <title> Reflection in an Object-Oriented Concurrent Language. </title> <booktitle> In OOPSLA'88 Proceedings, </booktitle> <pages> pp. 306-315, </pages> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: The meta-level architecture has been designed for practical rather than theoretical use. That is, meta-circularity [18] or several levels of meta systems [10, 14] are eliminated. In existing meta-level architectures for object-oriented languages such as ABCL/R <ref> [19] </ref>, ABCL/R2 [15], Rbcl [7], AL-1/D [14], and so on, language execution behavior is defined by the set of objects the base-level language can modify. Those systems do not focus on introducing new notation. The architecture proposed here focuses on this capability.
References-found: 19

