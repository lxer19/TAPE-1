URL: http://www.cs.berkeley.edu/~aiken/cs264/papers/identifying-profitable-specialization.ps.Z
Refering-URL: http://www.cs.berkeley.edu/~aiken/cs264/papers/node9.html
Root-URL: http://www.cs.berkeley.edu
Title: Identifying Profitable Specialization in Object-Oriented Languages  
Author: Jeffrey Dean, Craig Chambers, and David Grove 
Affiliation: Department of Computer Science and Engineering University of Washington  
Date: June, 1994.  
Note: To appear at the Workshop on Partial Evaluation and Semantics-Based Program Manipulation, Orlando, FL,  
Abstract: The performance of object-oriented languages can be greatly improved if methods can be specialized for particular classes of arguments. Such specialization can provide the compiler with enough class information about the receivers of messages within the specialized routine to enable these messages to be statically-bound to their target methods and subsequently inlined. We present an algorithm for automatically determining which methods are most profitable to specialize for which argument classes. This algorithm improves on previous automatic techniques by avoiding the twin problems of over and underspecialization and by being suitable for specializing programs that use multi-methods. 
Abstract-found: 1
Intro-found: 1
Reference: [Bobrow et al. 88] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. E. Keene, G. Kiczales, D. A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <journal> In SIGPLAN Notices 23(Special Issue), </journal> <month> September, </month> <year> 1988. </year>
Reference-contexts: Even for hybrid languages that promote relatively coarse-grained use of dynamic binding, such as C++ [Stroustrup 91], Modula-3 [Nelson 91], and CLOS <ref> [Bobrow et al. 88] </ref>, dynamic binding can become a performance bottleneck if the programming style in use encourages heavier use of object-oriented features. Program performance can be improved if the target of a dynamic message send can be determined at compile-time.
Reference: [Chambers & Ungar 91] <author> Craig Chambers and David Ungar. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(10), </note> <month> October, </month> <year> 1991. </year>
Reference-contexts: For example, an efficient implementation of Smalltalk-80 runs a suite of small benchmarks 5 to 10 times more slowly than does optimized C, in large part due to the overhead of dynamic binding <ref> [Chambers & Ungar 91] </ref>. Even for hybrid languages that promote relatively coarse-grained use of dynamic binding, such as C++ [Stroustrup 91], Modula-3 [Nelson 91], and CLOS [Bobrow et al. 88], dynamic binding can become a performance bottleneck if the programming style in use encourages heavier use of object-oriented features. <p> For example, hash table lookups are usually too large to inline effectively but they can benefit significantly from specialization. 3 Previous Work in Object-Oriented Languages Method specialization has been incorporated into several existing implementations of object-oriented languages, including SELF <ref> [Chambers & Ungar 91] </ref>, Trellis [Kilian 88], and Sather [Lim & Stolcke 91]. <p> Since the aggressively specialized program shows little improvement over the specialized program, we conclude that our algorithm is working well at selecting profitable methods to specialize. 6 Related Work The implementations of SELF <ref> [Chambers & Ungar 91] </ref>, Trellis [Kilian 88], and Sather [Lim & Stolcke 91] use specialization to provide the compiler with additional information about the classes of arguments to a routine, allowing many message sends within the routine to be statically-bound.
Reference: [Chambers 92a] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, Stanford University, report STAN-CS-92-1420, </institution> <month> March, </month> <year> 1992. </year>
Reference-contexts: This provides the compiler with additional information about the classes of the methods formal arguments, permitting messages sent to the formals to be statically bound and potentially inlined. This can greatly improve performance. For example, SELF programs run from 1.5 to 5 times faster as a result of specialization <ref> [Chambers 92a] </ref>. In this paper we present an algorithm that identifies automatically those points in the program where specialization is profitable using call graphs derived from dynamic profiles of the program. Section 2 provides an example motivating the benefits of specialization.
Reference: [Chambers 92b] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <booktitle> In ECOOP 92 Conference Proceedings, </booktitle> <pages> pp. 33-56, </pages> <address> Utrecht, the Netherlands, June/July, </address> <year> 1992. </year> <note> Published as Lecture Notes in Computer Science 615, Springer-Verlag, Berlin, </note> <year> 1992. </year>
Reference-contexts: Unfortunately, dynamic binding is slow, compared with a simple procedure call. In relatively pure object-oriented languages, such as Smalltalk [Goldberg & Robson 83], Eiffel [Meyer 92], Trellis [Schaffert et al. 86], SELF [Ungar & Smith 87], and Cecil <ref> [Chambers 92b] </ref>, dynamic binding occurs very frequently and consequently its impact on performance is severe.
Reference: [Chang et al. 92] <author> Pohua P. Chang, Scott A. Mahlke, William Y. Chen, and Wen-Mei W. Hwu. </author> <title> Profile-Guided Automatic Inline Expansion for C Programs. </title> <booktitle> In SoftwarePractice and Experience 22(5), </booktitle> <pages> pp. 349-369, </pages> <month> May, </month> <year> 1992. </year>
Reference-contexts: We augment the PICs to keep a counter of the number of times each argument class occurred, to provide weights on each edge in the call graph. 5 exploited dynamic profiles to guide the application of optimizations, such as the Impact-C profile-guided inliner <ref> [Chang et al. 92] </ref>. A call graph constructed from profile data is not guaranteed to be conservative; a future program execution might traverse an edge not found in the call graph.
Reference: [Cooper et al. 92] <author> Keith D. Cooper, Mary W. Hall, and Ken Kennedy. </author> <title> Procedure Cloning. </title> <booktitle> In Proceeding of the 1992 IEEE International Conference on Computer Languages, </booktitle> <pages> pp. 96-105, </pages> <address> Oakland, CA, </address> <month> April, </month> <year> 1992. </year>
Reference-contexts: We rely on standard caching techniques to reduce the overhead of dynamic dispatching [Krasner 83, Hlzle et al. 91]. Cooper, Hall, and Kennedy present a general framework for identifying when creating multiple, specialized copies of a procedure can provide additional information for solving dataow optimization problems <ref> [Cooper et al. 92] </ref>.
Reference: [Dean & Chambers 94] <author> Jeffrey Dean and Craig Chambers. </author> <title> Toward Better Inlining Decisions Using Inlining Trials. </title> <booktitle> To appear in Proceedings of the ACM Symposium on Lisp and Functional Programming Languages, </booktitle> <address> Orlando, FL, </address> <month> June, </month> <year> 1994. </year> <note> An earlier version appears as technical report 93-05-05, </note> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> May, </month> <year> 1993. </year>
Reference-contexts: In particular, they do not account for the performance improvement due to post-specialization inlining and subsequent optimization. Our profitability metric can be extended to take these secondary effects into account by incorporating a persistent database that records the costs and benefits of inlining <ref> [Dean & Chambers 94] </ref>. This information could then be combined with other cost-benefit information to improve the accuracy of the profitability estimation. Our algorithm identifies profitable places to specialize by examining the programs call graph.
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: 1 Introduction Object-oriented languages are useful for implementing abstractions and structuring programs to be more extensible and maintainable. One of the key reasons is dynamic binding (also known as message passing). Unfortunately, dynamic binding is slow, compared with a simple procedure call. In relatively pure object-oriented languages, such as Smalltalk <ref> [Goldberg & Robson 83] </ref>, Eiffel [Meyer 92], Trellis [Schaffert et al. 86], SELF [Ungar & Smith 87], and Cecil [Chambers 92b], dynamic binding occurs very frequently and consequently its impact on performance is severe.
Reference: [Grove & Torczon 93] <author> Dan Grove and Linda Torczon. </author> <title> Interprocedural Constant Propagation: A Study of Jump Function Implementations. </title> <booktitle> In Proceedings of the SIGPLAN 93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 90-99, </pages> <address> Albuquerque, NM, </address> <month> June, </month> <year> 1993. </year> <note> Published as SIGPLAN Notices 28(6), </note> <month> June, </month> <year> 1993. </year>
Reference-contexts: Our framework could be extended straightforwardly to account for more complex relationships between formals and actuals. Grove and Torczon compare the utility of several jump functions representing such relationships in the context of interprocedural constant propagation <ref> [Grove & Torczon 93] </ref>. The algorithm is presented below interspersed with discussion about its various pieces. The presentation is in the style of a literate program [Knuth 92]. When helpful, call graph diagrams illustrating the various situations which occur are presented.
Reference: [Harnett & Montenyohl 92] <author> Sheila Harnett and Margaret Montenyohl. </author> <title> Towards Efficient Compilation of a Dynamic Object-Oriented Language. </title> <booktitle> In Proceedings of the 1992 Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pp. 82-89, </pages> <address> San Francisco, CA, </address> <year> 1992. </year> <note> Published as Yale University Department of Computer Science Technical Report YALEU/DCS/RR-909. </note>
Reference-contexts: However, many dynamically-bound message sends still exist in the residual program. Other work focuses on reducing the overhead of dynamic dispatching in object-oriented programs, by partially evaluating the routines to perform method lookup with respect to the inheritance hierarchy of the program being executed <ref> [Khoo & Sundaresh 91, Harnett & Montenyohl 92] </ref>. We rely on standard caching techniques to reduce the overhead of dynamic dispatching [Krasner 83, Hlzle et al. 91].
Reference: [Hlzle et al. 91] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Optimizing Dynamically-Typed Object-Oriented Programming Languages with Polymorphic Inline Caches. </title> <booktitle> In ECOOP 91 Conference Proceedings, </booktitle> <pages> pp. 21-38, </pages> <address> Geneva, Switzerland, </address> <month> July, </month> <year> 1991. </year>
Reference-contexts: Other compilation systems have * The Cecil implementation uses polymorphic inline caches (PICs) to speed dynamic dispatch <ref> [Hlzle et al. 91] </ref>. A PIC is a call-site-specific method lookup cache, mapping argument classes for a message send to the routine which should be invoked. <p> We rely on standard caching techniques to reduce the overhead of dynamic dispatching <ref> [Krasner 83, Hlzle et al. 91] </ref>. Cooper, Hall, and Kennedy present a general framework for identifying when creating multiple, specialized copies of a procedure can provide additional information for solving dataow optimization problems [Cooper et al. 92].
Reference: [Katz & Weise 92] <author> Morry Katz and Daniel Weise. </author> <title> Towards a New Perspective on Partial Evaluation. </title> <booktitle> In Proceedings of the 1992 Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pp. 29-37, </pages> <address> San Francisco, CA, </address> <year> 1992. </year> <note> Published as Yale University Department of Computer Science Technical Report YALEU/DCS/RR-909. </note>
Reference-contexts: Our algorithm consequently works backwards from the places that demand the most precise information, rather than proceeding in two phases as does Cooper et al.s algorithm. Finally, our algorithm exploits profile information to guide its search for profitable specializations. Ruf, Katz, and Weise <ref> [Ruf & Weise 91, Katz & Weise 92] </ref> also address the problem of avoiding overspecialization. Their work seeks to identify when two specializations end up leading to the same code.
Reference: [Kilian 88] <author> Michael F. Kilian. </author> <title> Why Trellis/Owl Runs Fast. </title> <type> Unpublished manuscript, </type> <month> March, </month> <year> 1988. </year>
Reference-contexts: For example, hash table lookups are usually too large to inline effectively but they can benefit significantly from specialization. 3 Previous Work in Object-Oriented Languages Method specialization has been incorporated into several existing implementations of object-oriented languages, including SELF [Chambers & Ungar 91], Trellis <ref> [Kilian 88] </ref>, and Sather [Lim & Stolcke 91]. Each of these systems has used a fairly simple-minded strategy to determine when to specialize a method: a method is always specialized on the exact class of the receiver, for all receiver classes, and never on anything else. <p> Since the aggressively specialized program shows little improvement over the specialized program, we conclude that our algorithm is working well at selecting profitable methods to specialize. 6 Related Work The implementations of SELF [Chambers & Ungar 91], Trellis <ref> [Kilian 88] </ref>, and Sather [Lim & Stolcke 91] use specialization to provide the compiler with additional information about the classes of arguments to a routine, allowing many message sends within the routine to be statically-bound.
Reference: [Khoo & Sundaresh 91] <author> Siau Cheng Khoo and R. S. Sundaresh. </author> <title> Compiling Inheritance using Partial Evaluation. </title> <booktitle> In Proceedings of the 1991 Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pp. 211-222, </pages> <address> New Haven, CT, </address> <year> 1991. </year>
Reference-contexts: However, many dynamically-bound message sends still exist in the residual program. Other work focuses on reducing the overhead of dynamic dispatching in object-oriented programs, by partially evaluating the routines to perform method lookup with respect to the inheritance hierarchy of the program being executed <ref> [Khoo & Sundaresh 91, Harnett & Montenyohl 92] </ref>. We rely on standard caching techniques to reduce the overhead of dynamic dispatching [Krasner 83, Hlzle et al. 91].
Reference: [Knuth 92] <author> Donald E. Knuth. </author> <title> Literate Programming. Center for the Study of Language and Information, </title> <booktitle> Lecture Notes Series, </booktitle> <year> 1992. </year>
Reference-contexts: Grove and Torczon compare the utility of several jump functions representing such relationships in the context of interprocedural constant propagation [Grove & Torczon 93]. The algorithm is presented below interspersed with discussion about its various pieces. The presentation is in the style of a literate program <ref> [Knuth 92] </ref>. When helpful, call graph diagrams illustrating the various situations which occur are presented. In these diagrams, pass-through edges are indicated as solid black lines, and non pass-through edges are shown as gray lines.
Reference: [Krasner 83] <author> Glenn Krasner, </author> <title> editor. Smalltalk-80: Bits of History, Words of Advice. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: We rely on standard caching techniques to reduce the overhead of dynamic dispatching <ref> [Krasner 83, Hlzle et al. 91] </ref>. Cooper, Hall, and Kennedy present a general framework for identifying when creating multiple, specialized copies of a procedure can provide additional information for solving dataow optimization problems [Cooper et al. 92].
Reference: [Lea 90] <editor> Douglas Lea. Customization in C++. </editor> <booktitle> In Proceedings of the 1990 Usenix C++ Conference, </booktitle> <pages> pp. 301-314, </pages> <address> San Francisco, CA, </address> <month> April, </month> <year> 1990. </year>
Reference-contexts: We are developing the algorithm in the context of a language based on multi-methods. Lea has explored the potential benefits of applying specialization in the C++ language <ref> [Lea 90] </ref>. For a simple matrix multiplication benchmark where the index function was dynamically bound, Lea calculated a potential speedup of around a factor 10 if the multiply routine were specialized to the particular matrix representations, thereby statically-binding the index call.
Reference: [Lim & Stolcke 91] <author> Chu-Cheow Lim and Andreas Stolcke. </author> <title> Sather Language Design and Performance Evaluation. </title> <type> Technical report TR-91-034, </type> <institution> International Computer Science Institute, </institution> <month> May, </month> <year> 1991. </year>
Reference-contexts: For example, hash table lookups are usually too large to inline effectively but they can benefit significantly from specialization. 3 Previous Work in Object-Oriented Languages Method specialization has been incorporated into several existing implementations of object-oriented languages, including SELF [Chambers & Ungar 91], Trellis [Kilian 88], and Sather <ref> [Lim & Stolcke 91] </ref>. Each of these systems has used a fairly simple-minded strategy to determine when to specialize a method: a method is always specialized on the exact class of the receiver, for all receiver classes, and never on anything else. <p> Since the aggressively specialized program shows little improvement over the specialized program, we conclude that our algorithm is working well at selecting profitable methods to specialize. 6 Related Work The implementations of SELF [Chambers & Ungar 91], Trellis [Kilian 88], and Sather <ref> [Lim & Stolcke 91] </ref> use specialization to provide the compiler with additional information about the classes of arguments to a routine, allowing many message sends within the routine to be statically-bound.
Reference: [Meyer 92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: One of the key reasons is dynamic binding (also known as message passing). Unfortunately, dynamic binding is slow, compared with a simple procedure call. In relatively pure object-oriented languages, such as Smalltalk [Goldberg & Robson 83], Eiffel <ref> [Meyer 92] </ref>, Trellis [Schaffert et al. 86], SELF [Ungar & Smith 87], and Cecil [Chambers 92b], dynamic binding occurs very frequently and consequently its impact on performance is severe.
Reference: [Nelson 91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: Even for hybrid languages that promote relatively coarse-grained use of dynamic binding, such as C++ [Stroustrup 91], Modula-3 <ref> [Nelson 91] </ref>, and CLOS [Bobrow et al. 88], dynamic binding can become a performance bottleneck if the programming style in use encourages heavier use of object-oriented features. Program performance can be improved if the target of a dynamic message send can be determined at compile-time.
Reference: [Ruf & Weise 91] <author> Erik Ruf and Daniel Weise. </author> <title> Using Types to Avoid Redundant Specialization. </title> <booktitle> In Proceedings of the PEPM 91 Symposium on Partial Evaluation and Semantics-Based Program Manipulations, </booktitle> <pages> pp. 321-333, </pages> <address> New Haven, CT, </address> <month> June, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(9), </note> <month> September, </month> <year> 1991. </year>
Reference-contexts: Our algorithm consequently works backwards from the places that demand the most precise information, rather than proceeding in two phases as does Cooper et al.s algorithm. Finally, our algorithm exploits profile information to guide its search for profitable specializations. Ruf, Katz, and Weise <ref> [Ruf & Weise 91, Katz & Weise 92] </ref> also address the problem of avoiding overspecialization. Their work seeks to identify when two specializations end up leading to the same code.
Reference: [Schaffert et al. 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An Introduction to Trellis/Owl. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 9-16, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: One of the key reasons is dynamic binding (also known as message passing). Unfortunately, dynamic binding is slow, compared with a simple procedure call. In relatively pure object-oriented languages, such as Smalltalk [Goldberg & Robson 83], Eiffel [Meyer 92], Trellis <ref> [Schaffert et al. 86] </ref>, SELF [Ungar & Smith 87], and Cecil [Chambers 92b], dynamic binding occurs very frequently and consequently its impact on performance is severe.
Reference: [Stroustrup 91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language, Second Edition. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1991. </year>
Reference-contexts: Even for hybrid languages that promote relatively coarse-grained use of dynamic binding, such as C++ <ref> [Stroustrup 91] </ref>, Modula-3 [Nelson 91], and CLOS [Bobrow et al. 88], dynamic binding can become a performance bottleneck if the programming style in use encourages heavier use of object-oriented features. Program performance can be improved if the target of a dynamic message send can be determined at compile-time.
Reference: [Ungar & Smith 87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 227-241, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: One of the key reasons is dynamic binding (also known as message passing). Unfortunately, dynamic binding is slow, compared with a simple procedure call. In relatively pure object-oriented languages, such as Smalltalk [Goldberg & Robson 83], Eiffel [Meyer 92], Trellis [Schaffert et al. 86], SELF <ref> [Ungar & Smith 87] </ref>, and Cecil [Chambers 92b], dynamic binding occurs very frequently and consequently its impact on performance is severe.
References-found: 24

