URL: ftp://ftp.cs.ucsb.edu/pub/faculty/su/tcs97.ps
Refering-URL: ftp://ftp.cs.ucsb.edu/pub/faculty/su/tcs97.html
Root-URL: http://www.cs.ucsb.edu
Title: Dynamic Constraints and Object Migration  
Author: Jianwen Su 
Note: Communicated by M. Nivat  
Date: Received April 1992; revised April 1995  
Address: Santa Barbara, CA 93106-5110, USA  
Affiliation: Computer Science Department, University of California,  
Abstract: A role set is the set of classes in a class hierarchy where an object may reside simultaneously. A migration pattern is a sequence of role sets that an object can migrate through. We define a migration inventory, which is a set of migration patterns, as a dynamic integrity constraint on object migration. We consider three update languages: SL which has five operators, CSL + which extends SL with positive conditionals, and CSL which allows both positive and negative conditionals. Three subclasses of migration patterns of transactions are studied which are immediate-start, proper, and lazy patterns. It is shown that the family of all (immediate-start, proper, or lazy) migration patterns of every set of SL transactions is a regular set and the converse also holds. In particular, testing satisfiability of an inventory by a set of transactions is decidable. For the extended languages, we give a weaker characterization. The family of all (immediate-start, proper, or lazy) migration patterns of every set of CSL (CSL + ) transactions is recursively enumerable (r.e.). However, every r.e. inventory can be the family of all migration patterns of some set of CSL + (CSL) transactions and be a left quotient of the family of immediate-start migration patterns of another set of CSL + (CSL) transactions by a regular set. Although the exact characterizations of immediate-start, proper, lazy migration patterns of CSL + (CSL) transactions are still open, it is proved that every context-free inventory can be the family of proper and immediate-start migration patterns of some CSL + (CSL) transactions. Testing satisfiability of an inventory by a set of CSL (CSL + ) transactions is unfortunately undecidable. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and R. Hull, </author> <title> IFO: A formal semantic database model, </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 12(4) (1987) 525565. </volume>
Reference-contexts: The model is object-based and a proper subset of many existing semantic data models such as IFO <ref> [1] </ref>, SDM [20], GSM [23], etc. The data model includes classes and class hierarchies, and attributes which range over atomic values. The update language SL extends the transaction language of [4] to incorporate objects and their manipulations. There are two major differences between SL and the language of [4]: 1. <p> Intuitively, a specialization graph is acyclic and consists of several maximal weakly connected subgraphs, each of which is rooted acyclic graph. This notion is motivated 4 by the ISA Rules of IFO schemas <ref> [1] </ref>. Formally, a directed graph G = (V; E) is a specialization-graph if 1. G is acyclic, and 2. for each pair of weakly connected vertices u; v 2 V , there exists a vertex w 2 V which has directed paths from both u and v.
Reference: [2] <author> S. Abiteboul and V. Vianu, </author> <title> The connection of static constraints with determinism and boundness of dynamic specifications, </title> <editor> in: C. Beeri, J.W. Schmidt, and U. Dayal, eds., </editor> <booktitle> Proc. 3rd int. conf. on Data and Knowledge Bases (Jerusalem, </booktitle> <address> Israel, </address> <month> June, </month> <year> 1988) </year> <month> 324 334. </month>
Reference: [3] <author> S. Abiteboul and V. Vianu, </author> <title> Equivalence and optimization of relational transactions, </title> <journal> J. ACM, </journal> <volume> 35(1) (1988) 70120. </volume>
Reference: [4] <author> S. Abiteboul and V. Vianu, </author> <title> A transaction-based approach to relational database specification, </title> <journal> J. ACM, </journal> <volume> 36(4) (1989) 758789. </volume>
Reference-contexts: The model is object-based and a proper subset of many existing semantic data models such as IFO [1], SDM [20], GSM [23], etc. The data model includes classes and class hierarchies, and attributes which range over atomic values. The update language SL extends the transaction language of <ref> [4] </ref> to incorporate objects and their manipulations. There are two major differences between SL and the language of [4]: 1. SL is object-based and allows to manipulate object identifiers while [4] used the relational model and operations focus on tuple manipulations. <p> The data model includes classes and class hierarchies, and attributes which range over atomic values. The update language SL extends the transaction language of <ref> [4] </ref> to incorporate objects and their manipulations. There are two major differences between SL and the language of [4]: 1. SL is object-based and allows to manipulate object identifiers while [4] used the relational model and operations focus on tuple manipulations. For example, the object creation operation in SL always creates an object with an identifier, but the insertion operation of [4] creates a tuple only when the tuple <p> The update language SL extends the transaction language of <ref> [4] </ref> to incorporate objects and their manipulations. There are two major differences between SL and the language of [4]: 1. SL is object-based and allows to manipulate object identifiers while [4] used the relational model and operations focus on tuple manipulations. For example, the object creation operation in SL always creates an object with an identifier, but the insertion operation of [4] creates a tuple only when the tuple is not present in the database. 2. <p> differences between SL and the language of <ref> [4] </ref>: 1. SL is object-based and allows to manipulate object identifiers while [4] used the relational model and operations focus on tuple manipulations. For example, the object creation operation in SL always creates an object with an identifier, but the insertion operation of [4] creates a tuple only when the tuple is not present in the database. 2. SL has two new operators to support object migration. We start with the following definitions, assuming the reader's familiarity with graphs. <p> An Instance d = ho; a; o 6 i of D duce SL, we first note that SL is similar to the relational transaction language of Abiteboul and Vianu <ref> [4] </ref>, with two major differences: 1. Our operations manipulate object identifiers since SL is object-based, while [4] used the relational model and their operations focused on tuple manipulations. <p> An Instance d = ho; a; o 6 i of D duce SL, we first note that SL is similar to the relational transaction language of Abiteboul and Vianu <ref> [4] </ref>, with two major differences: 1. Our operations manipulate object identifiers since SL is object-based, while [4] used the relational model and their operations focused on tuple manipulations. For example, the create operator in SL always creates an object with a (new) identifier, regardless of whether there already exists an object which has exactly the same attribute values and belongs to the same set of classes. <p> For example, the create operator in SL always creates an object with a (new) identifier, regardless of whether there already exists an object which has exactly the same attribute values and belongs to the same set of classes. The insert operator in the language of <ref> [4] </ref>, however, creates a tuple only when the requested tuple does not already exist in the relation. 2. SL provides two new operators, specialize and generalize, to support object migration. On the other hand, SL does not allow the user to directly manipulate or grasp object identifiers. <p> Moreover, objects cannot migrate to classes which are not weakly connected. Consequently, we assume without loss of generality that the schema graph (i.e., the class hierarchy) is weakly connected. The assumption is similar to focusing on a single relation in <ref> [4] </ref>. The assumption will be relaxed when 11 we consider richer languages in Section 4. Informally, a role set is a set of classes where an object could possibly reside at the same time. Due to inheritance induced by the class hierarchy, each role set is closed under isa. <p> Intuitively, given a (finite) set S of attributes and a (finite) set C of constants, a separator defines a partition of the set Tuple (S) (of all tuples over S) using an extension of the notion of a hyperplane <ref> [4] </ref>. Moreover, if S is the union of the sets of attributes of classes in a role set !, then a separator for S (and some set C of constants) partitions all objects having the role set !.
Reference: [5] <author> G. R. Andrews and F. B. Schneider, </author> <title> Concepts and notations for concurrent programming, </title> <booktitle> ACM Computing Surveys 15(1) (1983) 344. </booktitle>
Reference: [6] <author> T. Andrews and C. Harris, </author> <title> Combining language and database advances in an object-oriented development environment, </title> <booktitle> in: Proc. Conf. on OOPSLA (1987) 430440. </booktitle>
Reference-contexts: The growing popularity of object--oriented databases (OODBs) is an evidence of this trend. Important work on dynamic aspects of databases includes practically-oriented research on behavior modeling and transaction design [911,24,27,28], encapsulating both structural and behavior data, e.g., object-oriented databases including Gemstone [15], Vbase <ref> [6] </ref>, O 2 [25,26], IRIS [7], etc.; and also includes theoretical studies on transactions as specification languages [2,4] and on dynamic integrity constraints [13,16,32,33]. Previous studies on modeling database behavior can be roughly categorized into two approaches.
Reference: [7] <author> D. Beech, </author> <title> A foundation for evolution from relational to object databases, </title> <editor> in: J. W. Schmidt, S. Ceri and M. Missikoff, eds., </editor> <booktitle> Advances in Database Technology EDBT'88, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 303 (Springer, </publisher> <address> Berlin, </address> <year> 1988) </year> <month> 251270. </month>
Reference-contexts: The growing popularity of object--oriented databases (OODBs) is an evidence of this trend. Important work on dynamic aspects of databases includes practically-oriented research on behavior modeling and transaction design [911,24,27,28], encapsulating both structural and behavior data, e.g., object-oriented databases including Gemstone [15], Vbase [6], O 2 [25,26], IRIS <ref> [7] </ref>, etc.; and also includes theoretical studies on transactions as specification languages [2,4] and on dynamic integrity constraints [13,16,32,33]. Previous studies on modeling database behavior can be roughly categorized into two approaches.
Reference: [8] <author> N. Bidoit and S. De Amo, </author> <title> A first step towards implementing dynamic algebraic dependencies, </title> <editor> in: G. Gottlob and M. Y. Vardi, eds., </editor> <booktitle> Proc. 5th Int. Conf. on Database Theory, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 893 (Springer, </publisher> <address> Prague, </address> <year> 1995) </year> <month> 308 321. </month>
Reference-contexts: They lead to a new view of behavior specification and dynamic constraints which extends the work in [2,4,32,33]. More recently, the interplay between transactions and dynamic constraints has been further explored in the 2 context of relational transactions augmented with regular expressions and dynamic algebraic dependencies <ref> [8] </ref>. Three transaction languages are considered in the present paper.
Reference: [9] <author> A. Borgida, J. Mylopoulos, J. W. Schmidt, and I. Wetzel, </author> <title> Support for Data-Intensive Applications: </title> <booktitle> Conceptual Design and Software Development, in: Proc. 2nd Int. Workshop on Database Programming Languages (1989). </booktitle> <pages> 41 </pages>
Reference: [10] <author> M. L. Brodie, </author> <title> On modelling behavioural semantics of databases, </title> <booktitle> in: Proc. Int. Conf. on Very Large Data Bases (1981) 3242. </booktitle>
Reference: [11] <author> M. L. Brodie and D. Ridjanovic. </author> <title> On the design and specification of database transactions. In M.L. </title> <editor> Brodie, J. Mylopoulos, and J.W. Schmidt, editors, </editor> <booktitle> On Conceptual Modelling, </booktitle> <pages> pages 277306. </pages> <publisher> Springer-Verlag New York Inc., </publisher> <year> 1984. </year>
Reference: [12] <author> R. H. Campbell and A. N. Habermann. </author> <title> The specification of process synchronization by path expression. </title> <editor> In E. Gelenbe and C. Kaiser, editors, </editor> <booktitle> Proc. of Int. Symp. on Operating Systems, Vol. 16 of Lecture Notes in Computer Science, </booktitle> <pages> pages 89102. </pages> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: In concurrent programming, operations on shared resources have to be synchro nized to ensure correctness. One mechanism to control concurrent operations is based on path expressions <ref> [12] </ref>. Intuitively, path expressions are regular expressions (over the set of operations) specifying the order in which operations are executed without causing inconsistency of resources. The next example illustrates that the path expressions can be modeled by inventories at the conceptual level.
Reference: [13] <author> M. A. Casanova and A. L. Furtado. </author> <title> On the description of database transition constraints using temporal constraints. </title> <editor> In H. Gallaire, J. Minker, and J.M. Nicolas, editors, </editor> <booktitle> Advances in Data Base Theory, </booktitle> <volume> volume 2, </volume> <pages> pages 221236. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1984. </year>
Reference: [14] <author> J. Chomicki. </author> <title> Real-time integrity constraints. </title> <booktitle> In ACM Symp. on Principles of Database Systems, </booktitle> <year> 1992. </year>
Reference: [15] <author> G. Copeland and D. Maier. </author> <title> Making Smalltalk a database system. </title> <booktitle> In Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <year> 1984. </year>
Reference-contexts: The growing popularity of object--oriented databases (OODBs) is an evidence of this trend. Important work on dynamic aspects of databases includes practically-oriented research on behavior modeling and transaction design [911,24,27,28], encapsulating both structural and behavior data, e.g., object-oriented databases including Gemstone <ref> [15] </ref>, Vbase [6], O 2 [25,26], IRIS [7], etc.; and also includes theoretical studies on transactions as specification languages [2,4] and on dynamic integrity constraints [13,16,32,33]. Previous studies on modeling database behavior can be roughly categorized into two approaches.
Reference: [16] <author> J.M.V. de Castilho, M.A. Casanova, and A.L. Furtado, </author> <title> A temporal framework for specifications, </title> <booktitle> in: Proc. Int. Conf. on Very Large Data Bases (1982) 280291. </booktitle>
Reference: [17] <author> G. Dong and Q. Li. </author> <title> A framework for object migration in object-oriented databases. </title> <journal> Data & Knowledge Engineering, </journal> <volume> 13(3):22142, </volume> <month> October </month> <year> 1994. </year>
Reference: [18] <author> G. Dong and J. Su. </author> <title> Object behaviors and scripts. </title> <booktitle> In Proc. 3rd Int. Workshop on Database Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: By a reasoning similar to the previous theorem, we can show the following results on reachability with respect to script schemas. A more refined characterization of scripts is shown in <ref> [18] </ref>.
Reference: [19] <author> M. E. El-Sharkawi and Y. Kambayashi. </author> <title> Object migration mechanisms to support updates in object-oriented databases. </title> <editor> In N. Rishe, S. Navathe, and D. Tal, editors, </editor> <booktitle> Proc. PARBASE-90. International Conference on Databases, Parallel Architectures and Their Applications, </booktitle> <pages> pages 378387, </pages> <year> 1990. </year>
Reference: [20] <author> M. Hammer and D. McLeod. </author> <title> Database description with SDM: A semantic database model. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 6(3):351386, </volume> <year> 1981. </year>
Reference-contexts: The model is object-based and a proper subset of many existing semantic data models such as IFO [1], SDM <ref> [20] </ref>, GSM [23], etc. The data model includes classes and class hierarchies, and attributes which range over atomic values. The update language SL extends the transaction language of [4] to incorporate objects and their manipulations. There are two major differences between SL and the language of [4]: 1.
Reference: [21] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison Wesley, </publisher> <year> 1979. </year>
Reference-contexts: Since the families of migration patterns of SL transaction schemas are languages of regular expressions over + and there exist algorithms to determine if one regular set contains another <ref> [21] </ref> or if two regular sets coincide, it immediately follows: Corollary 3.3 Let D be a weakly-connected database schema, a regular expression over , and T a transaction schema on D. <p> We first present an example and then generalize the argument to arbitrary context-free inventories. Example 4.1 Let L = fa i b j j i; j &gt; 0; i = jg be a language. Then both L and Init (L) are context free <ref> [21] </ref>. Suppose the database schema has four classes R; P a ; P b ; S where P a isa R, P b isa R, and S has two attributes A; B. A; B are used to hold a chain serving as a counter. <p> Without loss of generality we assume S is a single class S 2 C, A (S) fA 1 ; A 2 ; A 3 g. Since L is context free, there is a context-free grammar G L in Greibach normal form that L (G L ) = L <ref> [21] </ref>. That is, every production rule has the form: N ! aff, where a is a terminal and ff a string of nonterminals. It is assumed that the terminals and nonterminals of G L are all constants in U . <p> We may assume without loss of generality that the component S contains only one class S with four attributes A i ; 1 6 i 6 4. In the following presentation, we assume the terminology for Turing machines (e.g., <ref> [21] </ref>), although the presentation is self-contained for readers familiar with Tur-ing machines. Because L is r.e., there is a Turing machine M (with a right-infinite tape) which accepts L.
Reference: [22] <author> R. Hull and D. Jacobs. </author> <title> On the semantics of rules in database programming languages. </title> <editor> In J. W. Schmidt and A. A. Stogny, editors, </editor> <booktitle> Next Generation Information System Technology. First Int. East/West Data Base Workshop, Vol. 504 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The framework and techniques developed here provide part of the basis for type checking of dynamic types on transactions <ref> [22] </ref>, transaction design [9,11,24], and the study of methods in OODBs. They lead to a new view of behavior specification and dynamic constraints which extends the work in [2,4,32,33].
Reference: [23] <author> R. Hull and R. King. </author> <title> Semantic data modeling: Survey, applications, and research issues. </title> <journal> ACM Computing Surveys, </journal> <volume> 19(3):201260, </volume> <month> September </month> <year> 1987. </year>
Reference-contexts: We use a simple semantic data model which includes object identifiers (OIDs), classes, inheritance hierarchies, and attributes ranging over printable values. The model can be viewed as a proper subset of many semantic models such as IFO, SDM, TAXIS, GSM (see <ref> [23] </ref>), etc. In a class hierarchy, an object can belong to several classes simultaneously and objects can migrate between classes. The set of classes in which an object lives at a time instant forms a role set. <p> The model is object-based and a proper subset of many existing semantic data models such as IFO [1], SDM [20], GSM <ref> [23] </ref>, etc. The data model includes classes and class hierarchies, and attributes which range over atomic values. The update language SL extends the transaction language of [4] to incorporate objects and their manipulations. There are two major differences between SL and the language of [4]: 1.
Reference: [24] <author> R. King and D. McLeod, </author> <title> A database design methodology and tool for information systems, </title> <journal> ACM Trans. </journal> <note> on Office Information Systems 3(1) (1985) 221. </note>
Reference-contexts: Previous studies on modeling database behavior can be roughly categorized into two approaches. One uses behavioral constructs to describe semantic information in a way similar to the use of data constructs in modeling structural data. Examples are the transaction composition operators [10,11], the inflow schemas of INSYDE <ref> [24] </ref>, and the scripts in TAXIS [27,28]. The other specifies database behavior using dynamic integrity constraints. Temporal logic is a typical example of this approach [13,14,16]. In this paper, we study database behavior specification from the perspectives of both transactions and dynamic integrity constraints and explore the relationships between them. <p> The two examples are motivated by the transaction design methodology of the INSYDE model <ref> [24] </ref> and the notion of scripts of the TAXIS data model [27,28]. The essential ingredient in both frameworks is to introduce an ordering on updates to the databases.
Reference: [25] <author> C. Lecluse and P. Richard. </author> <title> Modeling complex structures in object-oriented databases. </title> <booktitle> In ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 360368, </pages> <year> 1989. </year>
Reference: [26] <author> C. Lecluse, P. Richard, and F. Velez. </author> <title> O 2 : An object-oriented data model. </title> <booktitle> In Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 424433, </pages> <address> Chicago, </address> <month> June </month> <year> 1988. </year> <month> 42 </month>
Reference: [27] <author> J. Mylopoulos, P.A. Bernstein, and H.K. Wong. </author> <title> A language facility for designing database-intensive applications. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 5(2):185207, </volume> <month> June </month> <year> 1980. </year>
Reference: [28] <author> B.A. Nixon, K.L. Chung, D. Lauzon, A. Borgida, J. Mylopoulos, and M. Stanley. </author> <title> Design of a compiler for a semantic data model. </title> <type> Tech. Rep. </type> <institution> CSRI-44, Dept. of Computer Science, Univ. of Toronto, </institution> <year> 1987. </year>
Reference: [29] <author> B. Pernici. </author> <title> Objects with roles. </title> <booktitle> In Proc. of Conf. on Office Information Systems, </booktitle> <pages> pages 205215, </pages> <year> 1990. </year>
Reference: [30] <author> E. Radeke and M. H. Scholl, </author> <title> Framework for object migration in federated database systems, </title> <booktitle> in: Proceedings of the Third International Conference on Parallel and Distributed Information Systems, </booktitle> <address> Los Alamitos, CA, </address> <publisher> (IEEE Comput. Soc. Press, </publisher> <address> Silver Spring, MD, </address> <year> 1994) </year> <month> 187194. </month>
Reference: [31] <author> E. Sciore, </author> <title> Object specialization, </title> <journal> ACM Trans. </journal> <note> on Office Information Systems 7(2) (1989) 103122. </note>
Reference-contexts: In an object-oriented database, objects belong to classes in a hierarchy. An object in a class can be viewed as playing the role of that class <ref> [31] </ref>. Hence it is quite natural to allow objects to dynamically change their roles during their presence in a database.
Reference: [32] <author> V. Vianu, </author> <title> Dynamic functional dependencies and database aging, </title> <note> Journal of the ACM 34(1) (1987) 2859. </note>
Reference: [33] <author> V. </author> <note> Vianu Database survivability under dynamic constraints Acta Informatica 25 (1988) 5584 </note>
References-found: 33

