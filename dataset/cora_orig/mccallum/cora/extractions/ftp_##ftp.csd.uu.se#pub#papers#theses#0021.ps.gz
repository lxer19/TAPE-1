URL: ftp://ftp.csd.uu.se/pub/papers/theses/0021.ps.gz
Refering-URL: http://www.csd.uu.se/papers/long-theses.html
Root-URL: 
Title: Compiling and Executing Finite Domain Constraints  
Author: Bj orn Carlson 
Date: 1995  
Address: UPPSALA  
Affiliation: Computing Science Department Uppsala University  Uppsala University Swedish Institute of Computer Science  
Note: UPPSALA THESES IN COMPUTING SCIENCE 21  
Abstract-found: 0
Intro-found: 1
Reference: [AAB + 93] <author> J. Andersson, S. Andersson, K. Boortz, M. Carlsson, H. Nilsson, T. Sjoland, and J. Widen. </author> <title> Sicstus Prolog Users Manual. </title> <institution> SICS research report, Swedish Institute of Computer Science, </institution> <year> 1993. </year>
Reference-contexts: Prolog-based finite domain language this comes out as: labeling ([]). labeling ([X|L]) :- domain_of (X, D), member (X, D), labeling (L). where domain of (x, l) is true when l is the list of domain elements of x, and member (x,l) is true when x is a member of l <ref> [AAB + 93] </ref>. Usually, the two are combined into one primitive indomain/1 [DHS + 88, Hen89, DC93b]. <p> Prolog was the first efficient programming language based on resolution [CKPR73, WP77], and has since its invention been extended and refined into being a versatile and powerful programming language <ref> [AAB + 93] </ref>. Many of the features of Prolog have also been adapted to concurrent logic programming languages, in particular, the symbol manipulation, which is very well suited for manipulating formal languages and data structures.
Reference: [AB91] <author> A. Aggoun and N. Beldiceanu. </author> <title> Overview of the CHIP Compiler System. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <year> 1991. </year>
Reference-contexts: Variable dependencies This optimization is standard in finite domain systems <ref> [Hen89, AB91, HDT92, DC93c] </ref>. Consider the indexical x in 0::max (y), and the store =fx 2 f1; 2; 3g, y 2 f1; 2; 3gg which is a fixed point of the indexical. Now suppose is updated to 0 = fx 2 f1; 2; 3g; y 2 f2; 3gg. <p> Since these new variables will take part in the constraint propagation, they will incur a runtime cost. Compilation steps The compilation consists of two steps: normalization and decomposition. A similar compilation technique has been exploited in the CHIP system <ref> [AB91] </ref>, but decomposition is not considered. In clp (FD) a similar kind of decomposition is used [Diaz, personal communication]. Normalization. The normalization step simply consists in transforming the arithmetic constraint into its normal form (Section 3.6.1). Decomposition. The decomposition step performs the actual translation of the relation. <p> AKL is a deep-guard CCP language, and its design has been deeply affected by the groundbreaking work in [Sar89]. 11.2.3 CHIP CHIP (Constraint Handling In Prolog) is a constraint logic programming language, originating at ECRC, and further developed at Cosytec <ref> [DHS + 88, AB91, AB93, BC94] </ref>. The language contains solvers for constraints over * finite domains, * booleans, and * rational numbers. We only address the finite domain part herein. The syntax of CHIP is that of Prolog, extended with operators for finite domain equalities, inequalities, and disequalities.
Reference: [AB93] <author> A. Aggoun and N. Beldiceanu. </author> <title> Extending CHIP to Solve Complex Scheduling and Packing Problems. </title> <booktitle> Mathematical and Computer Modelling, </booktitle> <address> 17:7:57-73, </address> <year> 1993. </year>
Reference-contexts: As is shown in Section 3.6.4 and 3.6.6, also negation and cardinality are thereby included. FDC thus embeds a fair part of most well-known finite domain constraints, with at least one important exception. Cumulative constraints <ref> [AB93] </ref> cannot be efficiently coded in FDC, even though such constraints can be encoded in FDC in a nave way (Section 3.6.8). We now define inductively the semantics of constraints in FDC. <p> true. atleast (u; l; v) is similarly defined as k X (b) i u; and count (n; l; v) is defined as k X (b) i = n: Operationally, these constraints are special cases of the cardinality constraint. 3.6.8 Cumulative constraints Cumulative constraints were invented to solve complex scheduling problems <ref> [AB93] </ref>. Basically, they serve as a wrapper with a logical reading around a set of highly efficient algorithms developed for scheduling. The naming "cumulative" arises from the fact that the algorithms accumulate possible values of variables, and propagate information when limits are crossed. <p> It follows that x = 4 is not consistent with c, d x , and d y , and consequently it can be removed. 2 For many constraints, the semantics of the constraints can be exploited in a nontrivial way which gives highly efficient pruning algorithms <ref> [DH91, HSD92b, HDT92, AB93, CC95] </ref>. Arc-consistency is a strictly weaker notion than true consistency, i.e. a store may be arc-consistent without being consistent. Example 3.9: Consider the constraints x 6= y 6= z 6= x 44 Finite Domain Constraints and i.e. the variables must all be assigned different values. <p> As an archetypal class consider the class of scheduling problems. 138 Related Work 11.1.1 Scheduling problems Scheduling problems were early recognized as important and computation-ally challenging <ref> [MT63, Bak74, Kan76, GJ79, AC91, Got93, AB93] </ref>. They occur everywhere, since timetables and production plans are a vital part of most workplaces. Furthermore, resource allocation problems constitute a subclass of the scheduling problems, and these are fundamental in industrial design and production. <p> Today much work is devoted to adapting the scheduling algorithms for constraint programming such that they can be used incrementally and flexibly, and also mixed with other types of solver algorithms <ref> [AB93, BC94, ILO93, Cas91, CGL93, Pug94, CL94] </ref>. 11.2 Constraint Programming Systems We will now look more into detail of those programming systems which are most closely related to AKL (FD) and which have influenced our work considerably. <p> AKL is a deep-guard CCP language, and its design has been deeply affected by the groundbreaking work in [Sar89]. 11.2.3 CHIP CHIP (Constraint Handling In Prolog) is a constraint logic programming language, originating at ECRC, and further developed at Cosytec <ref> [DHS + 88, AB91, AB93, BC94] </ref>. The language contains solvers for constraints over * finite domains, * booleans, and * rational numbers. We only address the finite domain part herein. The syntax of CHIP is that of Prolog, extended with operators for finite domain equalities, inequalities, and disequalities. <p> Furthermore, user-defined constraints are introduced in CHIP, using global declarations. Such constraints are declared as being forward-driven or lookahead-driven, thus stating suspension conditions on the constraints [Hen89]. 11.2 Constraint Programming Systems 141 Recently, cumulative and global constraints were added to CHIP to efficiently deal with scheduling and packing problems <ref> [AB93, BC94] </ref>. Finally, some primitives are provided for finding solutions to a list of constrained variables, e.g. labeling/1, labelingff/1, minimize/2, and mini mize maximum/2. In conclusion; * CHIP has been, and continues to be, very influential. Partly by being efficient and powerful, and partly by being innovative. <p> Erlang (FD) will thereby contain the necessary notions for developing large-scale control and supervision systems, reactive scheduling and verification applications, intelligent agents, and interactive planning tools, which are exciting new domains of software. 4. Disjunctive and cumulative constraints need more attention. The work on cumulative constraints and scheduling libraries <ref> [AB93, BC94, Pap94] </ref>, which constitute state-of-the-art of constraint satisfaction applied to scheduling and planning, should be complemented with fundamental investigations of how a propositional language of finite domain constraints, such as FDC, combined with the techniques addressed in item 1 and 2, can reach similar performance figures. 5.
Reference: [AC91] <author> D. Applegate and B. Cook. </author> <title> A Computational Study of the Job-shop Scheduling Problem. </title> <journal> Operations Research Society of America, </journal> <volume> 3 (2), </volume> <year> 1991. </year>
Reference-contexts: As an archetypal class consider the class of scheduling problems. 138 Related Work 11.1.1 Scheduling problems Scheduling problems were early recognized as important and computation-ally challenging <ref> [MT63, Bak74, Kan76, GJ79, AC91, Got93, AB93] </ref>. They occur everywhere, since timetables and production plans are a vital part of most workplaces. Furthermore, resource allocation problems constitute a subclass of the scheduling problems, and these are fundamental in industrial design and production.
Reference: [ASU86] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Therefore, the dependencies are: x/MIN and y/MAX. Assume A x = 0 and A y = 1. The byte code for r is thus dom_max 1 sub const 0 range halt 6.7.5 Other optimizations It should be clear that many traditional optimizations apply to the FD emulator and compiler <ref> [ASU86] </ref>. These include identifying common subexpres-sions, using a register-based machine and exploiting the registers for storing 78 Implementation of FD values frequently referred to, and perhaps compiling to low-level machine code, thereby, adapting to the underlying architecture.
Reference: [AVW93] <author> J. Armstrong, R. Virding, and M. Williams. </author> <title> Concurrent Programming in ERLANG. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: For example, we are currently using the above as a basis for adding FD to the functional concurrent programming language Erlang <ref> [AVW93] </ref>. 9.6 Lifting domain constraints Finally, we will consider lifting domain constraints in AGENTS. <p> Consequently, the system will be extended with better support for analysis of constraint graphs, dynamic generation of constraints, and intelligent backtracking. Also, tech niques developed under item 1 will be reused in here. 3. Erlang is a concurrent functional language, developed at Ellemtel Laboratories <ref> [AVW93] </ref>. It has a natural notion of processes and distribution, which makes the language perfect for building large, reactive and distributed applications. We have initiated a work on adding FD to Erlang, thus making the language applicable to a new set of problems, nicely complementing its concurrency and distribution features.
Reference: [Bak74] <author> K. R. Baker. </author> <title> Introduction to Sequencing and Scheduling. </title> <publisher> Wiley, </publisher> <year> 1974. </year>
Reference-contexts: [NS56, McC60, DP60, Dan63, Rob65, Min67], ideas which were further developed by the symbolic and integer programming communities [Hew69, CKPR73, Kow74, BM76, WP77, SS80, PS82, Col84, JL87, DHS + 88] (for good overviews see [Coh90], [Hen91], and [JM94]), and by work on constraint solving algorithms in algebra and operations research <ref> [Dan63, Bak74, GJ79, PS82] </ref>. The key idea is to specify a set C of constraints, which are first-order open formulas, such that the extension of C contains precisely the solutions to a given problem, hence the naming "constraint satisfaction" problems [Mac88]. <p> As an archetypal class consider the class of scheduling problems. 138 Related Work 11.1.1 Scheduling problems Scheduling problems were early recognized as important and computation-ally challenging <ref> [MT63, Bak74, Kan76, GJ79, AC91, Got93, AB93] </ref>. They occur everywhere, since timetables and production plans are a vital part of most workplaces. Furthermore, resource allocation problems constitute a subclass of the scheduling problems, and these are fundamental in industrial design and production.
Reference: [BC94] <author> N. Beldiceanu and E. Contejean. </author> <title> Introducing Global Constraints in CHIP. </title> <booktitle> Mathematical and Computer Modelling, </booktitle> <address> 20:12:97-123, </address> <year> 1994. </year>
Reference-contexts: Today much work is devoted to adapting the scheduling algorithms for constraint programming such that they can be used incrementally and flexibly, and also mixed with other types of solver algorithms <ref> [AB93, BC94, ILO93, Cas91, CGL93, Pug94, CL94] </ref>. 11.2 Constraint Programming Systems We will now look more into detail of those programming systems which are most closely related to AKL (FD) and which have influenced our work considerably. <p> AKL is a deep-guard CCP language, and its design has been deeply affected by the groundbreaking work in [Sar89]. 11.2.3 CHIP CHIP (Constraint Handling In Prolog) is a constraint logic programming language, originating at ECRC, and further developed at Cosytec <ref> [DHS + 88, AB91, AB93, BC94] </ref>. The language contains solvers for constraints over * finite domains, * booleans, and * rational numbers. We only address the finite domain part herein. The syntax of CHIP is that of Prolog, extended with operators for finite domain equalities, inequalities, and disequalities. <p> Furthermore, user-defined constraints are introduced in CHIP, using global declarations. Such constraints are declared as being forward-driven or lookahead-driven, thus stating suspension conditions on the constraints [Hen89]. 11.2 Constraint Programming Systems 141 Recently, cumulative and global constraints were added to CHIP to efficiently deal with scheduling and packing problems <ref> [AB93, BC94] </ref>. Finally, some primitives are provided for finding solutions to a list of constrained variables, e.g. labeling/1, labelingff/1, minimize/2, and mini mize maximum/2. In conclusion; * CHIP has been, and continues to be, very influential. Partly by being efficient and powerful, and partly by being innovative. <p> Erlang (FD) will thereby contain the necessary notions for developing large-scale control and supervision systems, reactive scheduling and verification applications, intelligent agents, and interactive planning tools, which are exciting new domains of software. 4. Disjunctive and cumulative constraints need more attention. The work on cumulative constraints and scheduling libraries <ref> [AB93, BC94, Pap94] </ref>, which constitute state-of-the-art of constraint satisfaction applied to scheduling and planning, should be complemented with fundamental investigations of how a propositional language of finite domain constraints, such as FDC, combined with the techniques addressed in item 1 and 2, can reach similar performance figures. 5.
Reference: [BM76] <author> R. S. Boyer and J.S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <year> 1976. </year>
Reference: [Car87] <author> M. Carlsson. </author> <title> Freeze, Indexing, and Other Implementation Issues in the WAM. </title> <booktitle> In Logic Programming: Proceedings of the Fourth International Conference. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Blocking implication achieves conditional reasoning by suspending the execution of goals until certain constraints are implied by the store, i.e. given c ! A, A is executed only when c is true [HSD92a]. Blocking implication can also be viewed as an extension of the suspension mechanism freeze of Prolog <ref> [Car87] </ref> with support for entailment checking.
Reference: [Cas91] <author> Y. Caseau. </author> <title> A Deductive Object-Oriented Language. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <note> 1991. 150 BIBLIOGRAPHY </note>
Reference-contexts: Today much work is devoted to adapting the scheduling algorithms for constraint programming such that they can be used incrementally and flexibly, and also mixed with other types of solver algorithms <ref> [AB93, BC94, ILO93, Cas91, CGL93, Pug94, CL94] </ref>. 11.2 Constraint Programming Systems We will now look more into detail of those programming systems which are most closely related to AKL (FD) and which have influenced our work considerably.
Reference: [CC93] <author> B. Carlson and M. Carlsson. </author> <title> Constraint Solving and Entailment Algorithms for cc(FD). </title> <booktitle> ESPRIT Project # 7195 (ACCLAIM) deliverable, SICS, </booktitle> <year> 1993. </year>
Reference-contexts: Each indexical evaluation is O (c) in time, i.e. the algorithm is O (mnecs) in time. 2 Note that in the AGENTS-implementation, installing l is delayed until the propagation in has terminated successfully. 110 Implementation of AKL (FD) 9.3 Arithmetic Constraints in AKL (FD) This section is based on <ref> [CC93] </ref>, and explains the compilation of arithmetic constraints to library calls.
Reference: [CC95] <author> B. Carlson and M. Carlsson. </author> <title> Compiling and Executing Disjunctions of Finite Domain Constraints. </title> <booktitle> In Proceedings of the Twelfth International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Hence, conjunction and blocking implication replace cardinality. 3.6.5 Disjunction Disjunctive reasoning is important in constraint programming. Traditionally, disjunctions have been used for nondeterminate programming, but, recently, uses of disjunctions in determinate programs have been discovered <ref> [HD91, HSD92a, JS93, CC95] </ref>. The basic insight is that instead of using disjunction as a means for guessing computation paths, disjunction is used for pruning fruitless computation paths. Hence, the phrase constructive disjunction, although somewhat misleading since the connection to constructive logic is not clarified. <p> It follows that x = 4 is not consistent with c, d x , and d y , and consequently it can be removed. 2 For many constraints, the semantics of the constraints can be exploited in a nontrivial way which gives highly efficient pruning algorithms <ref> [DH91, HSD92b, HDT92, AB93, CC95] </ref>. Arc-consistency is a strictly weaker notion than true consistency, i.e. a store may be arc-consistent without being consistent. Example 3.9: Consider the constraints x 6= y 6= z 6= x 44 Finite Domain Constraints and i.e. the variables must all be assigned different values. <p> However, we do not further address these issues here. Chapter 7 AKL In this chapter we describe AKL, and the constraint store and guard model of AKL [Jan94]. Our contribution to the design and implementation of AKL has been the constraint interface and constraint lifting <ref> [CJM93, CC95] </ref>. 7.1 Introduction Concurrent constraint programming (CCP) is a powerful paradigm for programming with constraints, based on simple concepts [Mah87, Sar89]. A set (or conjunction) of constraints, regarded as formulas in first-order logic, forms a constraint store. <p> Chapter 8 AKL (FD) The design of AKL (FD) is given, together with several examples of programming in AKL (FD). This chapter is based on <ref> [CJH94, CC95] </ref>. <p> is appropriate to use for finite domain problems, due to the heavy backtracking that typically occurs. 10.2.2 Evaluating the disjunctive constraints We now compare our two approaches for constructive disjunction, i.e. the indexical scheme (Section 4.2) and the constraint lifting scheme (Section 8.3) with speculative and cardinality-based disjunction (Section 3.6.5) <ref> [CC95] </ref>. As benchmarks we use two problems for scheduling and planning, the bridge-project problem [Hen89] and the squares problem (Section 2.2.1), together with the n-queens problem (Section 2.1.6). See Section 8.6 and Appendix B for the programs coding the constraints below.
Reference: [CCD94] <author> B. Carlson, M. Carlsson, and D. Diaz. </author> <title> Entailment of Finite Domain Constraints. </title> <booktitle> In Proceedings of the Eleventh International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Constraints that are builtins in a black-box language are instead defined as programs in a glass-box language <ref> [DHS + 88, HSD92a, DC93b, CCD94, CJH94] </ref>. <p> ; l; x 2 ) is equivalent to the formula x 1 i b i x 2 ^ i ^ (:c i $ b i = 0); where l = c 1 : : : c k :;, 1 i k, and $ is a conjunction of two blocking implications <ref> [CCD94] </ref>. Hence, conjunction and blocking implication replace cardinality. 3.6.5 Disjunction Disjunctive reasoning is important in constraint programming. Traditionally, disjunctions have been used for nondeterminate programming, but, recently, uses of disjunctions in determinate programs have been discovered [HD91, HSD92a, JS93, CC95].
Reference: [CF94] <author> B. Carlson and M. Fromhertz. </author> <title> Proceedings of the Workshop on Constraint Languages and Their Use in Problem Modeling at the International Symposium on Logic Programming. </title> <type> Technical Report 94-38, </type> <institution> ECRC, </institution> <year> 1994. </year> <title> Chapter: Optimal and Incremental Anytime Scheduling. </title>
Reference-contexts: In the following, we will discuss a simplified but complete form of the problem of scheduling reprographic machines. While high-end machines have more complex constraints, this simpler version already represents a realistic and non-trivial machine. Problem statement The task of scheduling networked reprographic machines is defined as follows <ref> [CF94] </ref>. A scheduler is given a machine description and a finite sequence of output sheets that are to be printed on the machine. The machine description is formulated in terms of constraints on sheets.
Reference: [CGL93] <author> Y. Caseau, P.-Y. Guillo, and E. Levenez. </author> <title> A Deductive and Object-Oriented Approach to a Complex Scheduling Problem. </title> <booktitle> In Proceedings of DOOD'93, </booktitle> <publisher> LNCS 760. Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Today much work is devoted to adapting the scheduling algorithms for constraint programming such that they can be used incrementally and flexibly, and also mixed with other types of solver algorithms <ref> [AB93, BC94, ILO93, Cas91, CGL93, Pug94, CL94] </ref>. 11.2 Constraint Programming Systems We will now look more into detail of those programming systems which are most closely related to AKL (FD) and which have influenced our work considerably.
Reference: [CJ95] <author> B. Carlson and S. </author> <title> Janson. </title> <booktitle> The Implementation of AKL(FD). Submitted to the 1995 International Symposium on Logic Programming, </booktitle> <year> 1995. </year>
Reference-contexts: This chapter is an extended version of <ref> [CJ95] </ref>. 9.1 The FD Interface The interface between FD and AGENTS consists of three parts; the constraint variable, i.e. the domain variable, the indexical, and the constraint, used for managing the hierarchy of stores. In the following we use C-syntax to describe the structures involved.
Reference: [CJH94] <author> B. Carlson, S. Janson, and S. Haridi. AKL(FD): </author> <title> a concurrent language for finite domain programming. </title> <booktitle> In Logic Programming: Proceedings of the 1994 International Symposium. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Adding concurrency notions with constraint solving [SRP91, Mah87] shows further that programming with finite domain constraints exceeds the logic programming paradigm. Constraint solving can thus be used for synchronization of and communication between processes, as well as for programming propositional and arithmetic reasoning <ref> [CJH94] </ref>. Constraint programming offers several benefits to solving finite domain problems compared to imperative programming: * The programmer is relieved of the gritty managing of search. <p> Constraints that are builtins in a black-box language are instead defined as programs in a glass-box language <ref> [DHS + 88, HSD92a, DC93b, CCD94, CJH94] </ref>. <p> languages are that the programmer is given more freedom of how to specify a problem, since the constraints can be tailored with respect to the problem at hand, and that the problem can be solved more efficiently since it need not be reduced to fit the constraints of the solver <ref> [DC93c, HSD92a, CJH94] </ref>. FD is a glass-box language adapted to programming finite domain constraints [HSD91]. The basic computational primitive provided is the in-dexical, i.e. a function computing domains of a variable. <p> The latter scheme is based on AKL (FD), a deep-guard concurrent constraint language developed at SICS <ref> [Jan94, CJH94] </ref>, which supports indexi-cals, and which performs conditional reasoning through entailment checking and constraint lifting. 1.4.1 The indexical scheme In the indexical scheme, constraints in FDC are compiled into monotone in-dexicals. Implication is treated as blocking, and disjunction as constructive [HSD92a]. <p> Implication is treated as blocking, and disjunction as constructive [HSD92a]. This is made possible by the support for conditional indexicals we have added to the original proposal for FD <ref> [HSD91, CJH94] </ref>. Furthermore, cardinality is translated into a conjunction of implications, while preserving the operational semantics of cardinality. <p> The operators _, ^ and n denote set union, intersection, and difference respectively. The conditional range r ) r 0 equals r 0 if r 6= ; and ; otherwise <ref> [CJH94] </ref>. The conditional range plays a crucial role in defining blocking implication and constructive disjunction in terms of indexicals, allowing range functions to conditionally take part in computing domain restrictions to variables (Chapter 4.2). <p> Consider for a moment element (x; l; y) which is true iff the xth element in l is equal to y <ref> [DSH88, CJH94] </ref>. <p> However, c may be entailed in a weaker store than the indexical. Experiments have shown that the indexical is weak enough for practical purposes <ref> [CJH94] </ref>. Since c is in dnf it follows that c c 1 _ : : : _ c n , where each c i is a conjunction of arithmetic constraints. <p> Of course, a large body of work on practically motivated constraint systems exists [JM94]. We have so far considered constraint systems over rational trees, feature trees, and finite domains in AGENTS <ref> [Kei94, Jan94, CJH94] </ref>. This investigation will be extended to other systems in the future, such as systems over boolean and rational numbers. The rational tree constraint system is the same as in SICStus Prolog and Prolog-II [Col84], and has been inlined in the AKL-emulator for efficiency reasons. <p> Chapter 8 AKL (FD) The design of AKL (FD) is given, together with several examples of programming in AKL (FD). This chapter is based on <ref> [CJH94, CC95] </ref>. <p> If the calls to element/3 (Appendix A) in the cars-program are replaced with calls to element/3, as defined in Section 8.5.4, the performance of the program is degraded by a factor 2.5 <ref> [CJH94] </ref>. <p> Entailment checking as used in CCP languages also provides a good mechanism for control in user-defined constraints <ref> [HSD91, CJH94, MPSW95] </ref>. 140 Related Work * Communication is handled by adding (telling) constraints to the store, which increases the amount of information in the store.
Reference: [CJM93] <author> B. Carlson, S. Janson, and J. Montelius. </author> <title> Aspects of Constraint Solving for AKL. </title> <booktitle> In Proceedings of the Concurrent Constraint Programming workshop, </booktitle> <address> ICLP93, </address> <year> 1993. </year>
Reference-contexts: However, we do not further address these issues here. Chapter 7 AKL In this chapter we describe AKL, and the constraint store and guard model of AKL [Jan94]. Our contribution to the design and implementation of AKL has been the constraint interface and constraint lifting <ref> [CJM93, CC95] </ref>. 7.1 Introduction Concurrent constraint programming (CCP) is a powerful paradigm for programming with constraints, based on simple concepts [Mah87, Sar89]. A set (or conjunction) of constraints, regarded as formulas in first-order logic, forms a constraint store.
Reference: [CKPR73] <author> A. Colmerauer, H. Kanoui, R. Pasero, and P. Roussel. </author> <title> Un systeme de communication homme-machine en francais. </title> <type> Report de recherche, </type> <institution> Groupe Intelligence Artificielle, Universite d'Aix-Marseille, </institution> <year> 1973. </year>
Reference-contexts: We focus on the FD-part, since AKL has already been thoroughly described and analyzed elsewhere [Jan94]. 11.2 Constraint Programming Systems 139 11.2.1 Forerunners There are four noteable forerunners of concurrent finite domain constraint programming; Prolog, Alice, GHC, and Prolog-III. Prolog was the first efficient programming language based on resolution <ref> [CKPR73, WP77] </ref>, and has since its invention been extended and refined into being a versatile and powerful programming language [AAB + 93].
Reference: [CL94] <author> Y. Caseau and F. Laburthe. </author> <title> Improved CLP Scheduling with Task Intervals. </title> <booktitle> In Proceedings of the Eleventh International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Today much work is devoted to adapting the scheduling algorithms for constraint programming such that they can be used incrementally and flexibly, and also mixed with other types of solver algorithms <ref> [AB93, BC94, ILO93, Cas91, CGL93, Pug94, CL94] </ref>. 11.2 Constraint Programming Systems We will now look more into detail of those programming systems which are most closely related to AKL (FD) and which have influenced our work considerably.
Reference: [Coh90] <author> J. Cohen. </author> <title> Constraint Logic Programming Languages. </title> <journal> Communications of ACM, </journal> <volume> 33 (7):54-68, 1990. BIBLIOGRAPHY 151 </volume>
Reference-contexts: solving originates with the work on symbolic logic and mathematical programming in the 50s and 60s [NS56, McC60, DP60, Dan63, Rob65, Min67], ideas which were further developed by the symbolic and integer programming communities [Hew69, CKPR73, Kow74, BM76, WP77, SS80, PS82, Col84, JL87, DHS + 88] (for good overviews see <ref> [Coh90] </ref>, [Hen91], and [JM94]), and by work on constraint solving algorithms in algebra and operations research [Dan63, Bak74, GJ79, PS82].
Reference: [Col84] <author> A. Colmerauer. </author> <title> Solving Equations and Inequations on Finite and Infinite Trees. </title> <booktitle> In Proceedings of the Conference on Fifth Generation Computer Systems, </booktitle> <year> 1984. </year>
Reference-contexts: This investigation will be extended to other systems in the future, such as systems over boolean and rational numbers. The rational tree constraint system is the same as in SICStus Prolog and Prolog-II <ref> [Col84] </ref>, and has been inlined in the AKL-emulator for efficiency reasons. Our performance evaluations indicate that AKL is as fast as Prolog in doing constraint solving over such equalities [JM92].
Reference: [Col90] <author> A. Colmerauer. </author> <title> An introduction to Prolog-III. </title> <journal> Communications of ACM, </journal> <volume> 33 (7), </volume> <year> 1990. </year>
Reference-contexts: Many of the features of Prolog have also been adapted to concurrent logic programming languages, in particular, the symbol manipulation, which is very well suited for manipulating formal languages and data structures. Prolog-III (and Prolog-II) was a sequel to Prolog <ref> [Col90] </ref>, and was seminal in its approach to constraint solving within Prolog. Its constraint system treats rational trees, lists, numbers and booleans, and showed the way for much research to come.
Reference: [Dan63] <author> G. B. Dantzig. </author> <title> Linear Programming and Extensions. </title> <publisher> Princeton University Press, </publisher> <year> 1963. </year>
Reference-contexts: However, first we give a brief background of the origins of finite domain constraints and constraint programming. 11.1 Constraint Satisfaction Problems Constraints for problem solving originates with the work on symbolic logic and mathematical programming in the 50s and 60s <ref> [NS56, McC60, DP60, Dan63, Rob65, Min67] </ref>, ideas which were further developed by the symbolic and integer programming communities [Hew69, CKPR73, Kow74, BM76, WP77, SS80, PS82, Col84, JL87, DHS + 88] (for good overviews see [Coh90], [Hen91], and [JM94]), and by work on constraint solving algorithms in algebra and operations research [Dan63, <p> [NS56, McC60, DP60, Dan63, Rob65, Min67], ideas which were further developed by the symbolic and integer programming communities [Hew69, CKPR73, Kow74, BM76, WP77, SS80, PS82, Col84, JL87, DHS + 88] (for good overviews see [Coh90], [Hen91], and [JM94]), and by work on constraint solving algorithms in algebra and operations research <ref> [Dan63, Bak74, GJ79, PS82] </ref>. The key idea is to specify a set C of constraints, which are first-order open formulas, such that the extension of C contains precisely the solutions to a given problem, hence the naming "constraint satisfaction" problems [Mac88].
Reference: [DC93a] <author> D. Diaz and P. Codognet. </author> <title> A Boolean Extension of clp(FD). </title> <booktitle> In Proceedings of the International Symposium on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: In clp (FD), and (x; y; z) is defined by a conjunction of indexicals, and only domain constraints of the kind x 2 f0g (x 2 f1g) can be propagated <ref> [DC93a] </ref>, which are weaker than constraints of the type x = y. Of course, the version of clp (FD) specialized to boolean indexicals achieves very efficient propagation of domain constraints [DC93b], however, the point we want to make is that in AKL (FD) more general constraint propagation can be implemented. <p> the point where the indexicals were defined, and henceforth we have developed efficient compilation and execution algorithms for the indexicals, as well as integrating them in a deep-guard CCP language. 11.2.5 clp (FD) clp (FD) is a constraint logic programming (CLP) language in which the indexicals have also been integrated <ref> [DC93c, DC93a, DC93b, Dia94] </ref>. This system is designed to be highly efficient, where programs are compiled to C-code containing a minimal number of procedure calls. The indexicals are compiled to abstract machine instructions, fine-tuned to optimize propagation of domain constraints. <p> A few symbolic constraints are included, such as element/3 and atmost/3, as well as primitives for branch-and-bound (minof/2 and maxof/2). Furthermore, a package of boolean constraints is predefined, which is based on an efficient specialization of FD for boolean numbers <ref> [DC93a] </ref>. In conclusion; clp (FD) is fast, and shows that user-defined constraints in terms of indexicals can in fact be made as efficient as builtin handling of constraints can be.
Reference: [DC93b] <author> D. Diaz and P. Codognet. </author> <title> Compiling constraints in clp(FD). </title> <note> Research report, INRIA, </note> <year> 1993. </year>
Reference-contexts: Constraints that are builtins in a black-box language are instead defined as programs in a glass-box language <ref> [DHS + 88, HSD92a, DC93b, CCD94, CJH94] </ref>. <p> Conjoining F c with x z and y z compiled to indexi-cals (see Section 4.1) thus gives a more powerful max/3 constraint than in clp (FD) <ref> [DC93b] </ref>. 2 Proposition 4.4 F c () = does not imply that c is arc-consistent in . 4.3 Blocking Implication 53 Proof: A counterexample is the following: Consider the disjunction c (x = y ^ x = z ^ y = 1) _ (x = y ^ x = z ^ <p> several lists can be used; one for all indexicals which depend on DOM prunings of the variable, one for all indexicals which depend on MIN prunings of the variable, one for all which depend on MAX prunings, and one for all which depend on the variable being determined (INT dependencies) <ref> [DC93b] </ref>. 6.4.2 The indexical The representation of the indexical should contain enough information to allow the indexical to be evaluated in any store, and also guarantee that the optimizations in Section 6.2 can be implemented. Consider the indexical x in r. <p> In Section 9.1 the particular representation of indexicals in AKL (FD) is given. See also <ref> [DC93c, DC93b] </ref>. 6.5 The Monotonicity Algorithm Assume we are given the indexical x in r, of which the representation contains two sets M r and A r , initially set to M r and A r (Section 3.5) respectively. <p> The programmer can thus experiment with alternatives, tailoring the constraints to fit the particular application. User-defined constraints have been recognized as crucial for the versatility of a constraint programming language <ref> [DC93b, HSD91, ECR93, ILO93] </ref>. 94 AKL (FD) We claim that AKL (FD) is a language where complex finite domain constraints can be defined purely within the concurrent constraint framework, and still execute efficiently both when used for consistency checking and when used for entailment checking. 8.5.1 Example: arithmetics First we show <p> Hence, we achieve the intended propagation of 6= [Hen89] through the monotonicity reasoning depicted in Table 3.1. Note that the same constraint in clp (FD) is defined by the use of a special val range function <ref> [DC93b] </ref>, which, thus, we do not need. Also note that enum/2 can be called anywhere in the queens/2 clause, since the stability condition of AKL guarantees that all determinate work is performed before any nondeterministic step is taken. <p> Note that the indexicals of the latter eq iff/3 behave exactly as the range functions x to b and b to x of clp (FD) <ref> [DC93b] </ref> by the combination of conditional ranges and monotonicity reasoning. Also, these indexicals are an optimized version of what the indexical scheme in Chapter 4 would generate when applied to X = V $ B = 1 and X 6= V $ B = 0. <p> Note that this definition gives the same pruning as the builtin element/3 of CHIP and clp (FD) does <ref> [DSH88, DC93b] </ref>. <p> Of course, the version of clp (FD) specialized to boolean indexicals achieves very efficient propagation of domain constraints <ref> [DC93b] </ref>, however, the point we want to make is that in AKL (FD) more general constraint propagation can be implemented. <p> Usually, the two are combined into one primitive indomain/1 <ref> [DHS + 88, Hen89, DC93b] </ref>. <p> This is mainly explained by the fact that clp (FD) compiles all source code to C, where as much as possible is inlined to avoid expensive procedure calls. Furthermore, the implementation is nicely fine-tuned to efficiently evaluate indexicals and perform propagation <ref> [DC93c, DC93b] </ref>. * The inclusion of FD in AGENTS is based on the generic constraint in terface (Chapter 9), where no FD specifics are included in the AGENTS emulator. <p> the point where the indexicals were defined, and henceforth we have developed efficient compilation and execution algorithms for the indexicals, as well as integrating them in a deep-guard CCP language. 11.2.5 clp (FD) clp (FD) is a constraint logic programming (CLP) language in which the indexicals have also been integrated <ref> [DC93c, DC93a, DC93b, Dia94] </ref>. This system is designed to be highly efficient, where programs are compiled to C-code containing a minimal number of procedure calls. The indexicals are compiled to abstract machine instructions, fine-tuned to optimize propagation of domain constraints. <p> The syntax of clp (FD) resembles the syntax of CHIP, which is its closest peer. User-defined constraints are either provided as clp (FD) programs, or as a combination of clp (FD) programs and C-functions designed using guidelines <ref> [DC93b, Dia94] </ref>. The system is built on top of the GNU C-compiler (gcc), and generates Unix-executables when compiling a source program. They basically provide the same indexical language as we do, with the exception of the conditional ranges. Their solver is similar to ours, but exploits slightly different optimizations [DC93c].
Reference: [DC93c] <author> D. Diaz and P. Codognet. </author> <title> A Minimal Extension of the WAM for clp(FD). </title> <booktitle> In Proceedings of the International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: The basic principle in finite domain constraint programming is to use arithmetical constraints as primitives, on top of which symbolic and propositional constraints are laid. Hence, by combining arithmetical reasoning with cardinality-based, relational, conditional, and disjunctive reasoning complex scheduling, packing, optimization, and satisfiability problems can be solved efficiently <ref> [DHS + 88, DSH88, Hen89, HSD92b, DC93c] </ref>. Adding concurrency notions with constraint solving [SRP91, Mah87] shows further that programming with finite domain constraints exceeds the logic programming paradigm. <p> languages are that the programmer is given more freedom of how to specify a problem, since the constraints can be tailored with respect to the problem at hand, and that the problem can be solved more efficiently since it need not be reduced to fit the constraints of the solver <ref> [DC93c, HSD92a, CJH94] </ref>. FD is a glass-box language adapted to programming finite domain constraints [HSD91]. The basic computational primitive provided is the in-dexical, i.e. a function computing domains of a variable. <p> Many of these problems are also described in [Hen89]. The first two examples are included since they are part of a set of well-known benchmark problems used for evaluating finite domain solvers <ref> [HSD92a, DC93c] </ref>. 2.1.1 10 equations The following is a simple system of linear equations over the natural numbers, where the variables range between 0 and 10, with exactly one solution. <p> Variable dependencies This optimization is standard in finite domain systems <ref> [Hen89, AB91, HDT92, DC93c] </ref>. Consider the indexical x in 0::max (y), and the store =fx 2 f1; 2; 3g, y 2 f1; 2; 3gg which is a fixed point of the indexical. Now suppose is updated to 0 = fx 2 f1; 2; 3g; y 2 f2; 3gg. <p> Hence, before executing an indexical f , suspended on a variable x, say, if the stamp of f is larger or equal than the stamp of x, ignore f . Initially, T and all stamps equal 0. This optimization is also exploited in clp (FD) <ref> [DC93c] </ref>. Propagation between equivalent indexicals The following optimization is exploited in clp (FD), but we exclude it from our algorithm since it is not always safe. Given two indexicals f 1 x in r 1 (y) and f 2 y in r 2 (x) which are equivalent. <p> In Section 9.1 the particular representation of indexicals in AKL (FD) is given. See also <ref> [DC93c, DC93b] </ref>. 6.5 The Monotonicity Algorithm Assume we are given the indexical x in r, of which the representation contains two sets M r and A r , initially set to M r and A r (Section 3.5) respectively. <p> The performance of AGENTS is somewhat degraded by this, compared to a flat implementation (Chapter 10). Chapter 10 Evaluation We compare AGENTS, the implementation of AKL (FD), with two other systems. The implementation of FD and the trailing scheme of AGENTS is compared to clp (FD) <ref> [DC93c] </ref>. We analyze * the efficiency of the FD solver, * the effect of the optimizations exploited, and * the difference in speed between AGENTS and clp (FD). <p> We now go on to analyze the speed of the solver. 10.1.2 Comparing with clp (FD) In this section we compare AGENTS with clp (FD) which is state-of-the-art among finite domain programming systems with respect to speed <ref> [DC93c] </ref>. In the following we use the trailing scheme for backtracking (Section 9.5) which closely resembles the trailing scheme of clp (FD). The machine used througout in the evaluation is a Sun 4/25 (SPARC-station ELC), running SunOs 4.1.2, and all measurements are done on this machine. <p> This is mainly explained by the fact that clp (FD) compiles all source code to C, where as much as possible is inlined to avoid expensive procedure calls. Furthermore, the implementation is nicely fine-tuned to efficiently evaluate indexicals and perform propagation <ref> [DC93c, DC93b] </ref>. * The inclusion of FD in AGENTS is based on the generic constraint in terface (Chapter 9), where no FD specifics are included in the AGENTS emulator. <p> the point where the indexicals were defined, and henceforth we have developed efficient compilation and execution algorithms for the indexicals, as well as integrating them in a deep-guard CCP language. 11.2.5 clp (FD) clp (FD) is a constraint logic programming (CLP) language in which the indexicals have also been integrated <ref> [DC93c, DC93a, DC93b, Dia94] </ref>. This system is designed to be highly efficient, where programs are compiled to C-code containing a minimal number of procedure calls. The indexicals are compiled to abstract machine instructions, fine-tuned to optimize propagation of domain constraints. <p> The system is built on top of the GNU C-compiler (gcc), and generates Unix-executables when compiling a source program. They basically provide the same indexical language as we do, with the exception of the conditional ranges. Their solver is similar to ours, but exploits slightly different optimizations <ref> [DC93c] </ref>. The system provides some primitives for meta-programming, such that certain heuristics can be programmed at source level. The arithmetic constraints in clp (FD) include both linear and nonlinear constraints. A few symbolic constraints are included, such as element/3 and atmost/3, as well as primitives for branch-and-bound (minof/2 and maxof/2).
Reference: [DH91] <author> Y. Deville and P. Van Hentenryck. </author> <title> An Efficient Arc Consistency Algorithm for a Class of CSP Problems. </title> <booktitle> In Proceedings of the International Joint Conference on Artificial Intelligence, </booktitle> <year> 1991. </year>
Reference-contexts: A partial arc-consistency algorithm only eliminates a subset of all such values <ref> [DH91] </ref>. Example 3.9: Given a constraint c x = y +1, any value n in the domain of x, for which there is no value m in the domain of y such that n = m + 1 is true, is removed, and similarly for the domain of y. <p> It follows that x = 4 is not consistent with c, d x , and d y , and consequently it can be removed. 2 For many constraints, the semantics of the constraints can be exploited in a nontrivial way which gives highly efficient pruning algorithms <ref> [DH91, HSD92b, HDT92, AB93, CC95] </ref>. Arc-consistency is a strictly weaker notion than true consistency, i.e. a store may be arc-consistent without being consistent. Example 3.9: Consider the constraints x 6= y 6= z 6= x 44 Finite Domain Constraints and i.e. the variables must all be assigned different values.
Reference: [DHS + 88] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Berthier. </author> <title> The Constraint Logic Programming Language CHIP. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <year> 1988. </year>
Reference-contexts: The basic principle in finite domain constraint programming is to use arithmetical constraints as primitives, on top of which symbolic and propositional constraints are laid. Hence, by combining arithmetical reasoning with cardinality-based, relational, conditional, and disjunctive reasoning complex scheduling, packing, optimization, and satisfiability problems can be solved efficiently <ref> [DHS + 88, DSH88, Hen89, HSD92b, DC93c] </ref>. Adding concurrency notions with constraint solving [SRP91, Mah87] shows further that programming with finite domain constraints exceeds the logic programming paradigm. <p> Constraints that are builtins in a black-box language are instead defined as programs in a glass-box language <ref> [DHS + 88, HSD92a, DC93b, CCD94, CJH94] </ref>. <p> Usually, the two are combined into one primitive indomain/1 <ref> [DHS + 88, Hen89, DC93b] </ref>. <p> AKL is a deep-guard CCP language, and its design has been deeply affected by the groundbreaking work in [Sar89]. 11.2.3 CHIP CHIP (Constraint Handling In Prolog) is a constraint logic programming language, originating at ECRC, and further developed at Cosytec <ref> [DHS + 88, AB91, AB93, BC94] </ref>. The language contains solvers for constraints over * finite domains, * booleans, and * rational numbers. We only address the finite domain part herein. The syntax of CHIP is that of Prolog, extended with operators for finite domain equalities, inequalities, and disequalities.
Reference: [Dia94] <author> D. Diaz. clp(FD): </author> <note> User's Manual. INRIA, </note> <year> 1994. </year>
Reference-contexts: the point where the indexicals were defined, and henceforth we have developed efficient compilation and execution algorithms for the indexicals, as well as integrating them in a deep-guard CCP language. 11.2.5 clp (FD) clp (FD) is a constraint logic programming (CLP) language in which the indexicals have also been integrated <ref> [DC93c, DC93a, DC93b, Dia94] </ref>. This system is designed to be highly efficient, where programs are compiled to C-code containing a minimal number of procedure calls. The indexicals are compiled to abstract machine instructions, fine-tuned to optimize propagation of domain constraints. <p> The syntax of clp (FD) resembles the syntax of CHIP, which is its closest peer. User-defined constraints are either provided as clp (FD) programs, or as a combination of clp (FD) programs and C-functions designed using guidelines <ref> [DC93b, Dia94] </ref>. The system is built on top of the GNU C-compiler (gcc), and generates Unix-executables when compiling a source program. They basically provide the same indexical language as we do, with the exception of the conditional ranges. Their solver is similar to ours, but exploits slightly different optimizations [DC93c].
Reference: [DP60] <author> M. Davis and H. Putnam. </author> <title> A Computation Procedure for Quantification Theory. </title> <journal> Journal of ACM, </journal> <volume> 7 </volume> (3):201-215, 1960. 
Reference-contexts: However, first we give a brief background of the origins of finite domain constraints and constraint programming. 11.1 Constraint Satisfaction Problems Constraints for problem solving originates with the work on symbolic logic and mathematical programming in the 50s and 60s <ref> [NS56, McC60, DP60, Dan63, Rob65, Min67] </ref>, ideas which were further developed by the symbolic and integer programming communities [Hew69, CKPR73, Kow74, BM76, WP77, SS80, PS82, Col84, JL87, DHS + 88] (for good overviews see [Coh90], [Hen91], and [JM94]), and by work on constraint solving algorithms in algebra and operations research [Dan63,
Reference: [DSH88] <author> M. Dincbas, H. Simonis, and P. Van Hentenryck. </author> <title> Solving the car sequencing problem in constraint logic programming. </title> <booktitle> In European Conference on Artificial Intelligence, </booktitle> <year> 1988. </year>
Reference-contexts: The basic principle in finite domain constraint programming is to use arithmetical constraints as primitives, on top of which symbolic and propositional constraints are laid. Hence, by combining arithmetical reasoning with cardinality-based, relational, conditional, and disjunctive reasoning complex scheduling, packing, optimization, and satisfiability problems can be solved efficiently <ref> [DHS + 88, DSH88, Hen89, HSD92b, DC93c] </ref>. Adding concurrency notions with constraint solving [SRP91, Mah87] shows further that programming with finite domain constraints exceeds the logic programming paradigm. <p> Suppose further that a set of cars to assemble is given, with corresponding requirements for options. The problem is thus to schedule the cars such that the capacities are obeyed, the requirements are satisfied, and the number of empty slots on the line is minimized <ref> [DSH88] </ref>. Consider the following problem instance. There are 10 cars, divided into 6 classes with respect to their option requirements, where there are 5 options (Table 2.1). <p> :c _ :d, :(c _ d) with :c ^ :d, and :a with a : . 3.6 FDC: a Language of Finite Domain Constraints 39 3.6.7 Symbolic constraints We now define symbolic constraints which are commonly used in finite domain constraint programming. element We now consider the definition of element/3 <ref> [DSH88] </ref>, where the constraint element (i; [x 1 ; : : : ; x k ]; v) is true iff x i equals v, i.e. iff W k is true, where we assume x j is a constant, 1 j k. <p> Consider for a moment element (x; l; y) which is true iff the xth element in l is equal to y <ref> [DSH88, CJH94] </ref>. <p> That is, atmost (U, L, V) succeeds when at most U equations X i =V are true, where L=[X 1 ,: : :,X k ]. 8.5.4 Example: element We now consider the definition of element/3 <ref> [DSH88] </ref>. The constraint applies disjunction constructively which can be captured by the use of the FD operators ) and _. <p> Note that this definition gives the same pruning as the builtin element/3 of CHIP and clp (FD) does <ref> [DSH88, DC93b] </ref>.
Reference: [ECR93] <author> ECRC. </author> <title> ECLiPSe User Manual, </title> <year> 1993. </year>
Reference-contexts: The programmer can thus experiment with alternatives, tailoring the constraints to fit the particular application. User-defined constraints have been recognized as crucial for the versatility of a constraint programming language <ref> [DC93b, HSD91, ECR93, ILO93] </ref>. 94 AKL (FD) We claim that AKL (FD) is a language where complex finite domain constraints can be defined purely within the concurrent constraint framework, and still execute efficiently both when used for consistency checking and when used for entailment checking. 8.5.1 Example: arithmetics First we show
Reference: [Fra94] <author> T. Franzen. </author> <title> Some formal aspects of the Andorra Kernel Language. </title> <institution> SICS Research Report R94:10, Swedish Institute of Computer Science, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: However, we exclude ports and aggregates. For a complete definition see [JH91], <ref> [Fra94] </ref>, or [Jan94]. 7.2.1 The language Basic statements, such as constraints, calls, composition, and hiding, are as in other CCP languages [Sar93] (see Figure 7.1). A constraint c (x) executes by calling the appropriate constraint solver, which simplifies the constraint and checks its consistency and/or entailment with the current store. <p> The state reached is called stable, and the behavior is a generalization of the Basic Andorra Model to deep guards. Up to this point, the constructs introduced belong to the strictly logical subset of AKL, which has an interpretation in first-order logic both in terms of success and failure <ref> [Fra94] </ref>. Committed choice corresponds to guarded clauses in committed-choice languages. If any of the guards is successfully reduced to a store which is entailed by the union of external stores, the corresponding clause is promoted.
Reference: [GJ79] <author> M. R. Garey and D.S. Johnson. </author> <title> Computers and Intractability. W.H. </title> <publisher> Freeman and Company, </publisher> <year> 1979. </year>
Reference-contexts: They are trivially decidable, however, many finite domain problems are NP-complete. Thus, no general efficient method exists which solves such problems automatically. However, in practice, many problem instances belonging to this class can in fact be solved in polynomial time <ref> [GJ79, PS82, HSD92b, St-a94] </ref>. Propagation-based algorithms [Mac77] for simplifying a finite domain problem use the logical and arithmetical semantics of the relations to eliminate inconsistent values and tuples of values from the solution space of the problem. <p> By using antimonotone indexicals, if F c () = , the test does not have to be repeated in any 0 such that v 0 , by Proposition 3.3. The entailment relation of FDC is NP-complete, since for example graph-coloring, or 3SAT, can be coded by FDC constraints <ref> [GJ79] </ref>. Thus, index-icals are used for describing stronger conditions than necessary, which can efficiently be checked by a solver for FD (Section 6.3). 3.9 Arc-consistency The basis for existing finite domain solvers is arc-consistency [Mac77], i.e. variable domains are pruned by eliminating values inconsistent with the current set of constraints. <p> [NS56, McC60, DP60, Dan63, Rob65, Min67], ideas which were further developed by the symbolic and integer programming communities [Hew69, CKPR73, Kow74, BM76, WP77, SS80, PS82, Col84, JL87, DHS + 88] (for good overviews see [Coh90], [Hen91], and [JM94]), and by work on constraint solving algorithms in algebra and operations research <ref> [Dan63, Bak74, GJ79, PS82] </ref>. The key idea is to specify a set C of constraints, which are first-order open formulas, such that the extension of C contains precisely the solutions to a given problem, hence the naming "constraint satisfaction" problems [Mac88]. <p> As an archetypal class consider the class of scheduling problems. 138 Related Work 11.1.1 Scheduling problems Scheduling problems were early recognized as important and computation-ally challenging <ref> [MT63, Bak74, Kan76, GJ79, AC91, Got93, AB93] </ref>. They occur everywhere, since timetables and production plans are a vital part of most workplaces. Furthermore, resource allocation problems constitute a subclass of the scheduling problems, and these are fundamental in industrial design and production.
Reference: [Got93] <author> Gotha. </author> <title> Les Problemes d'Ordonnancement. </title> <journal> Operations Research, </journal> <volume> 27 (1):77-150, 1993. 152 </volume> BIBLIOGRAPHY 
Reference-contexts: As an archetypal class consider the class of scheduling problems. 138 Related Work 11.1.1 Scheduling problems Scheduling problems were early recognized as important and computation-ally challenging <ref> [MT63, Bak74, Kan76, GJ79, AC91, Got93, AB93] </ref>. They occur everywhere, since timetables and production plans are a vital part of most workplaces. Furthermore, resource allocation problems constitute a subclass of the scheduling problems, and these are fundamental in industrial design and production.
Reference: [GY92] <author> S. Gregory and R. Yang. </author> <title> Parallel constraint solving in Andorra-I. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992. </booktitle> <publisher> ICOT, </publisher> <year> 1992. </year>
Reference-contexts: The nondeterminism can be encapsulated, so that it does not affect the process component. Nondeterminism in AKL is controlled using stability, a generalization of the Andorra principle, which has proven its usefulness in the context of constraint programming (see e.g., <ref> [GY92] </ref>).
Reference: [HD91] <author> P. Van Hentenryck and Y. Deville. </author> <title> The cardinality operator: a new logical connective in constraint logic programming. </title> <booktitle> In International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: This is possible since programs are written at a high level. * If necessary, implicit logical and arithmetical relationships can be made explicit with reasonable effort. This can be crucial to the ef ficiency <ref> [HD91] </ref>. * Different constraint systems can be combined which again can improve the efficiency and overall behavior. In particular, propositional and arithmetic reasoning are naturally merged [St-a94]. As a consequence: 1.3 Glass-box Systems 3 * Development time of constraint programs is short. <p> Thus, * x i must be equal to P k Adding the redundant constraints k X x i = k + 1 k X ix i = k + 1 to the above improves the behavior of the constraint solver by making in trinsic logical information explicit <ref> [HD91] </ref>. 20 Finite Domain Problems 2.2 Packing Packing problems consist of placing objects in a confined area such that certain objects do not overlap, the area is not too crowded, the distance between some objects is not too large nor too short, and/or such that the accumulated weight of overlapping objects <p> k ) ! c 2 (x 1 ; : : : ; x k ) is the k-ary relation R = R c 1 [ R c 2 . 3.6.4 Cardinality Cardinality reasoning has been shown to subsume the other logical connec-tives, as well as being a powerful programming primitive <ref> [HD91] </ref>. <p> Hence, conjunction and blocking implication replace cardinality. 3.6.5 Disjunction Disjunctive reasoning is important in constraint programming. Traditionally, disjunctions have been used for nondeterminate programming, but, recently, uses of disjunctions in determinate programs have been discovered <ref> [HD91, HSD92a, JS93, CC95] </ref>. The basic insight is that instead of using disjunction as a means for guessing computation paths, disjunction is used for pruning fruitless computation paths. Hence, the phrase constructive disjunction, although somewhat misleading since the connection to constructive logic is not clarified. <p> The problem with this scheme is that choices are made prematurely and that backtracking is needed to undo the effects of choices. 38 Finite Domain Constraints Cardinality-based Cardinality-based disjunction is disjunction defined by the expression c 1 _ c 2 #(1; [c 1 ; c 2 ]; 2) <ref> [HD91] </ref>, i.e. at least one of c 1 or c 2 must be true. Hence, given a store , neither c 1 nor c 2 is executed in until the other is inconsistent in .
Reference: [HDT92] <author> P. Van Hentenryck, Y. Deville, and C.-M. Teng. </author> <title> A Generic Arc Consistency Algorithm and Its Specializations. </title> <journal> Artificial Intelligence, </journal> <volume> 57 </volume> <pages> 291-321, </pages> <year> 1992. </year>
Reference-contexts: It follows that x = 4 is not consistent with c, d x , and d y , and consequently it can be removed. 2 For many constraints, the semantics of the constraints can be exploited in a nontrivial way which gives highly efficient pruning algorithms <ref> [DH91, HSD92b, HDT92, AB93, CC95] </ref>. Arc-consistency is a strictly weaker notion than true consistency, i.e. a store may be arc-consistent without being consistent. Example 3.9: Consider the constraints x 6= y 6= z 6= x 44 Finite Domain Constraints and i.e. the variables must all be assigned different values. <p> See Chapter 4 for an example of how interval-reasoning is used for maintaining partial arc-consistency of arithmetic constraints. b: special treatment of common constraints, such as linear arithmetic constraints, where optimizations, based on the semantics of the arithmetic predicates, are added to avoid useless calls to revise <ref> [HDT92] </ref> (see Chapter 6 for similar optimization techniques). 3.9.2 Arc-consistency of conjunctions and disjunctions We now consider arc-consistency of conjunctions and disjunctions Proposition 3.7 If a conjunction c 1 ^ ^ c n is arc-consistent in , then each c i is arc-consistent in . <p> Variable dependencies This optimization is standard in finite domain systems <ref> [Hen89, AB91, HDT92, DC93c] </ref>. Consider the indexical x in 0::max (y), and the store =fx 2 f1; 2; 3g, y 2 f1; 2; 3gg which is a fixed point of the indexical. Now suppose is updated to 0 = fx 2 f1; 2; 3g; y 2 f2; 3gg.
Reference: [Hen89] <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: The basic principle in finite domain constraint programming is to use arithmetical constraints as primitives, on top of which symbolic and propositional constraints are laid. Hence, by combining arithmetical reasoning with cardinality-based, relational, conditional, and disjunctive reasoning complex scheduling, packing, optimization, and satisfiability problems can be solved efficiently <ref> [DHS + 88, DSH88, Hen89, HSD92b, DC93c] </ref>. Adding concurrency notions with constraint solving [SRP91, Mah87] shows further that programming with finite domain constraints exceeds the logic programming paradigm. <p> For good introductions to general constraint programming see [Hen91, HSD92b, JM94]. 2.1 Arithmetic problems In this section we give examples of how arithmetic problems can be solved by finite domain constraints. Many of these problems are also described in <ref> [Hen89] </ref>. <p> It should be noted that refinements to the AC-3 algorithm above have been added, concerned with a: relaxing the computation of revise, such that it becomes linear in k. This is done using so called interval-reasoning (or partial lookahead) <ref> [Hen89, HSD92a] </ref>. Instead of revising all elements in x i , only the minimum and maximum values in x i are considered. <p> Variable dependencies This optimization is standard in finite domain systems <ref> [Hen89, AB91, HDT92, DC93c] </ref>. Consider the indexical x in 0::max (y), and the store =fx 2 f1; 2; 3g, y 2 f1; 2; 3gg which is a fixed point of the indexical. Now suppose is updated to 0 = fx 2 f1; 2; 3g; y 2 f2; 3gg. <p> Hence, we achieve the intended propagation of 6= <ref> [Hen89] </ref> through the monotonicity reasoning depicted in Table 3.1. Note that the same constraint in clp (FD) is defined by the use of a special val range function [DC93b], which, thus, we do not need. <p> Usually, the two are combined into one primitive indomain/1 <ref> [DHS + 88, Hen89, DC93b] </ref>. <p> Usually, the two are combined into one primitive indomain/1 [DHS + 88, Hen89, DC93b]. A heuristic rule, such as the first-fail principle, for selecting a variable in each iteration may improve the performance dramatically <ref> [Hen89] </ref>. labeling_ff ([]). labeling_ff ([X|L]) :- select_smallest_domain ([X|L], X0, L0), domain_of (X0, D), member (X0, D), labeling_ff (L0). where select smallest domain (l, x, l 0 ) is true when x is the variable with the smallest domain in l, and l 0 is l removed of x. <p> Note that lift domain/2 requires a deep-guard language. Finally, note that it is a simple matter to split the domains in subsets instead of into individual elements. This can sometimes be advantageous <ref> [Hen89] </ref>. 9.5.2 Trailing-based search We have experimented with a Prolog-style backtracking scheme instead of copying parts of the computation state, since copying becomes very expensive in the case of massive graphs of indexicals. <p> Nave label ing is used. sendmory The SEND+MORE=MONEY problem in Section 2.1.3. Nave labeling is used. alpha The cipher problem in Section 2.1.4. Nave and first-fail labeling are both used. five The combinatorial puzzle in Section 2.1.5. Nave labeling is used. queens 64 & 96 The 64 (96)-queens problem <ref> [Hen89] </ref> (Section 2.1.6), first solution. First-fail labeling is used. 10.1 Evaluating AGENTS with Trailing 121 suudoku The suudoku problem in Section 2.1.7. Nave labeling is used. magic 50 The magic series problem of size 50 in Section 2.1.8. <p> As benchmarks we use two problems for scheduling and planning, the bridge-project problem <ref> [Hen89] </ref> and the squares problem (Section 2.2.1), together with the n-queens problem (Section 2.1.6). See Section 8.6 and Appendix B for the programs coding the constraints below. The bridge and squares problems are concerned with shared resources, where the disjunctions are thus resource constraints. <p> For the n-queens problem we consider the effect of applying lookahead pruning <ref> [Hen89] </ref> through disjunctive reasoning on the number of nondeter-minate steps. <p> Furthermore, user-defined constraints are introduced in CHIP, using global declarations. Such constraints are declared as being forward-driven or lookahead-driven, thus stating suspension conditions on the constraints <ref> [Hen89] </ref>. 11.2 Constraint Programming Systems 141 Recently, cumulative and global constraints were added to CHIP to efficiently deal with scheduling and packing problems [AB93, BC94]. Finally, some primitives are provided for finding solutions to a list of constrained variables, e.g. labeling/1, labelingff/1, minimize/2, and mini mize maximum/2.
Reference: [Hen91] <author> P. Van Hentenryck. </author> <title> Constraint Logic Programming. </title> <journal> Knowledge Engineering Reviews, </journal> <volume> 6 </volume> (3):151-194, 1991. 
Reference-contexts: However, 12 Finite Domain Problems we include a complete but simple programming example at the end of this chapter, as to give a quick feel of the whole topic. For good introductions to general constraint programming see <ref> [Hen91, HSD92b, JM94] </ref>. 2.1 Arithmetic problems In this section we give examples of how arithmetic problems can be solved by finite domain constraints. Many of these problems are also described in [Hen89]. <p> originates with the work on symbolic logic and mathematical programming in the 50s and 60s [NS56, McC60, DP60, Dan63, Rob65, Min67], ideas which were further developed by the symbolic and integer programming communities [Hew69, CKPR73, Kow74, BM76, WP77, SS80, PS82, Col84, JL87, DHS + 88] (for good overviews see [Coh90], <ref> [Hen91] </ref>, and [JM94]), and by work on constraint solving algorithms in algebra and operations research [Dan63, Bak74, GJ79, PS82].
Reference: [Hen92] <author> P. Van Hentenryck. </author> <title> Scheduling and Packing in the Constraint Language cc(FD). </title> <type> Technical report, </type> <institution> Computer Science Department, Brown University, </institution> <year> 1992. </year>
Reference-contexts: consider a problem of placing squares inside a larger square, which serves as an archetypal problem in this category. 2.2.1 Square tiling The problem amounts to placing a number of squares in a larger square, in such a way that the squares do not overlap and leave no empty space <ref> [HSD92a, Hen92] </ref> (Figure 2.3). Furthermore, an additional requirement is sometimes added, which forces the small squares to be of different sizes. We solve the problem as follows. Each (small) square i is associated with two variables, x i and y i , representing the bottom-left corner of the square. <p> Most appropriately for this problem is an ordering which guarantees to place the variables in left to right order such that no empty space is allowed <ref> [Hen92] </ref>. 2.3 Scheduling Scheduling problems occur whenever scarce resources are to be used by some set of mutually dependent tasks.
Reference: [Hew69] <author> C. Hewitt. </author> <title> Planner: A Language for Proving Theorems in Robots. </title> <booktitle> In Proceedings of the First International Joint Conference on Artifical Intelligence. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1969. </year>
Reference: [HM95] <author> M. Heinz and M. Muller. </author> <title> Programming in Oz. Oz Documentation Series, </title> <institution> DFKI, German Research Center for Artificial Intelligence, </institution> <year> 1995. </year>
Reference-contexts: added. 10.2 Evaluating AGENTS with Copying 129 10.2 Evaluating AGENTS with Copying In this section we are using the copying scheme for labeling developed in Section 9.5.1. 10.2.1 Comparing with Oz We now compare AGENTS with Oz, which offers the same basic functionality for finite domain constraints as do AGENTS <ref> [Smo95, HM95, MMPS95, MPSW95] </ref>. The machine used throughout in the evaluation is a Sun 4/25 (SPARC-station ELC), running SunOs 4.1.2, and all measurements are done on this machine. In Table 10.9 we give the timings in milliseconds for the same programs run in AGENTS and in Oz. <p> the necessary primitives for constraint programming, such as constructive disjunction and cumulative constraints; however, the basic foundation has been laid upon which such constructs should fit nicely. 11.2 Constraint Programming Systems 143 11.2.6 Oz Oz is a concurrent language allowing functional, object-oriented and constraint programming, based on the CCP paradigm <ref> [Smo95, HM95, MMPS95, MPSW95] </ref>. Similar to AKL, Oz provides deep guards, and the same three guard operators for conditional, committed and nondeterminate choice are included. The language is higher-order which enables a theoretically appealing treatment of objects and inheritance [Smo94].
Reference: [HSD91] <author> P. Van Hentenryck, V. Saraswat, and Y. Deville. </author> <title> Constraint processing in cc(FD). </title> <type> Unpublished manuscript, </type> <year> 1991. </year>
Reference-contexts: FD is a glass-box language adapted to programming finite domain constraints <ref> [HSD91] </ref>. The basic computational primitive provided is the in-dexical, i.e. a function computing domains of a variable. Indexicals are used for stating arithmetical dependencies between variables such that the operational reading of the indexicals maintain constraint relations. <p> Implication is treated as blocking, and disjunction as constructive [HSD92a]. This is made possible by the support for conditional indexicals we have added to the original proposal for FD <ref> [HSD91, CJH94] </ref>. Furthermore, cardinality is translated into a conjunction of implications, while preserving the operational semantics of cardinality. <p> It has previously been recognized that implication checking is crucial in giving concurrent extensions of constraint programming a simple interpretation [Mah87, SRP91]. Throughout our thesis we therefore consider implication checking on equal terms with consistency checking. 3.3 FD We now present a variant of the indexical language FD <ref> [HSD91] </ref>. The intuitive understanding of indexicals is that they are functional rules for maintaining consistency of arithmetic finite domain constraints. FD is based on domain constraints and so called indexicals [HSD91]. A domain constraint is an expression x 2 I, where I is a set of natural numbers. <p> implication checking on equal terms with consistency checking. 3.3 FD We now present a variant of the indexical language FD <ref> [HSD91] </ref>. The intuitive understanding of indexicals is that they are functional rules for maintaining consistency of arithmetic finite domain constraints. FD is based on domain constraints and so called indexicals [HSD91]. A domain constraint is an expression x 2 I, where I is a set of natural numbers. A set of domain constraints is called a store. <p> The cardinality-operator is not speculative, but achieves insufficient propagation in many cases, typically for disjunctive scheduling problems. Constructive Constructive disjunction was proposed as a way to treat a disjunction of constraints as a constraint itself, to thereby avoid the speculative behavior, and to utilize the inherent propagation of disjunctions <ref> [HSD91, HSD92a, JS93] </ref>. We only consider propagating domain constraints from a disjunction in the following. <p> This extends the pruning that is achieved by cardinality-based disjunction <ref> [HSD91, HSD92a] </ref>. 2 Example 4.2: Let c be the constraint (x = 1 ^ y = i 1 ) _ (x = 2 ^ y = i 2 ). <p> The programmer can thus experiment with alternatives, tailoring the constraints to fit the particular application. User-defined constraints have been recognized as crucial for the versatility of a constraint programming language <ref> [DC93b, HSD91, ECR93, ILO93] </ref>. 94 AKL (FD) We claim that AKL (FD) is a language where complex finite domain constraints can be defined purely within the concurrent constraint framework, and still execute efficiently both when used for consistency checking and when used for entailment checking. 8.5.1 Example: arithmetics First we show <p> Entailment checking as used in CCP languages also provides a good mechanism for control in user-defined constraints <ref> [HSD91, CJH94, MPSW95] </ref>. 140 Related Work * Communication is handled by adding (telling) constraints to the store, which increases the amount of information in the store. <p> Search-heuristics differ between different classes of problems and it is unlikely that a fixed set of heuristic primitives will suffice for all classes. 11.2.4 cc (FD) The language cc (FD) was proposed as a remedy to some of the above mentioned problems in CHIP <ref> [HSD91, HSD92a] </ref>. In particular, the language provides better primitives for programming user-defined constraints, and is based on the CCP paradigm. As basic building blocks there are the arithmetic constraints. A distinction is made between interval-reasoning and domain-reasoning arithmetic constraints, and different operators are provided for respective case. <p> However, very little has been revealed of its implementation, and its relation to the dis junctions proposed earlier (Section 3.6.5) is unclear. cc (FD) has been the number one influence on our work. Here indexicals were first introduced <ref> [HSD91] </ref>, as well as constructive disjunction and blocking implication. The use of antimonotone indexicals for entailment checking was mentioned without being fully worked out, and the basic aspects of monotonicity of indexicals were explained.
Reference: [HSD92a] <author> P. Van Hentenryck, V. Saraswat, and Y. Deville. </author> <title> Constraint Logic Programming over Finite Domains: the Design, Implementation, and Applications of cc(FD). </title> <type> Technical report, </type> <institution> Computer Science Department, Brown University, </institution> <year> 1992. </year>
Reference-contexts: Constraints that are builtins in a black-box language are instead defined as programs in a glass-box language <ref> [DHS + 88, HSD92a, DC93b, CCD94, CJH94] </ref>. <p> languages are that the programmer is given more freedom of how to specify a problem, since the constraints can be tailored with respect to the problem at hand, and that the problem can be solved more efficiently since it need not be reduced to fit the constraints of the solver <ref> [DC93c, HSD92a, CJH94] </ref>. FD is a glass-box language adapted to programming finite domain constraints [HSD91]. The basic computational primitive provided is the in-dexical, i.e. a function computing domains of a variable. <p> Implication is treated as blocking, and disjunction as constructive <ref> [HSD92a] </ref>. This is made possible by the support for conditional indexicals we have added to the original proposal for FD [HSD91, CJH94]. Furthermore, cardinality is translated into a conjunction of implications, while preserving the operational semantics of cardinality. <p> Many of these problems are also described in [Hen89]. The first two examples are included since they are part of a set of well-known benchmark problems used for evaluating finite domain solvers <ref> [HSD92a, DC93c] </ref>. 2.1.1 10 equations The following is a simple system of linear equations over the natural numbers, where the variables range between 0 and 10, with exactly one solution. <p> consider a problem of placing squares inside a larger square, which serves as an archetypal problem in this category. 2.2.1 Square tiling The problem amounts to placing a number of squares in a larger square, in such a way that the squares do not overlap and leave no empty space <ref> [HSD92a, Hen92] </ref> (Figure 2.3). Furthermore, an additional requirement is sometimes added, which forces the small squares to be of different sizes. We solve the problem as follows. Each (small) square i is associated with two variables, x i and y i , representing the bottom-left corner of the square. <p> Blocking implication achieves conditional reasoning by suspending the execution of goals until certain constraints are implied by the store, i.e. given c ! A, A is executed only when c is true <ref> [HSD92a] </ref>. Blocking implication can also be viewed as an extension of the suspension mechanism freeze of Prolog [Car87] with support for entailment checking. <p> Hence, conjunction and blocking implication replace cardinality. 3.6.5 Disjunction Disjunctive reasoning is important in constraint programming. Traditionally, disjunctions have been used for nondeterminate programming, but, recently, uses of disjunctions in determinate programs have been discovered <ref> [HD91, HSD92a, JS93, CC95] </ref>. The basic insight is that instead of using disjunction as a means for guessing computation paths, disjunction is used for pruning fruitless computation paths. Hence, the phrase constructive disjunction, although somewhat misleading since the connection to constructive logic is not clarified. <p> The cardinality-operator is not speculative, but achieves insufficient propagation in many cases, typically for disjunctive scheduling problems. Constructive Constructive disjunction was proposed as a way to treat a disjunction of constraints as a constraint itself, to thereby avoid the speculative behavior, and to utilize the inherent propagation of disjunctions <ref> [HSD91, HSD92a, JS93] </ref>. We only consider propagating domain constraints from a disjunction in the following. <p> It should be noted that refinements to the AC-3 algorithm above have been added, concerned with a: relaxing the computation of revise, such that it becomes linear in k. This is done using so called interval-reasoning (or partial lookahead) <ref> [Hen89, HSD92a] </ref>. Instead of revising all elements in x i , only the minimum and maximum values in x i are considered. <p> A constraint over k variables is compiled into k monotone indexicals over k 1 variables, which approximate the constraint by interval arithmetic reasoning, i.e. they maintain partial arc-consistency. This is similar to the distinction made between interval and domain reasoning of constraints in cc (FD) <ref> [HSD92a] </ref>. The scheme can be modified to provide full arc-consistency (Section 4.4.3). The method is best explained by an example. <p> This extends the pruning that is achieved by cardinality-based disjunction <ref> [HSD91, HSD92a] </ref>. 2 Example 4.2: Let c be the constraint (x = 1 ^ y = i 1 ) _ (x = 2 ^ y = i 2 ). <p> Search-heuristics differ between different classes of problems and it is unlikely that a fixed set of heuristic primitives will suffice for all classes. 11.2.4 cc (FD) The language cc (FD) was proposed as a remedy to some of the above mentioned problems in CHIP <ref> [HSD91, HSD92a] </ref>. In particular, the language provides better primitives for programming user-defined constraints, and is based on the CCP paradigm. As basic building blocks there are the arithmetic constraints. A distinction is made between interval-reasoning and domain-reasoning arithmetic constraints, and different operators are provided for respective case.
Reference: [HSD92b] <author> P. Van Hentenryck, H. Simonis, and M. Dincbas. </author> <title> Constraint satisfaction using constraint logic programming. </title> <journal> Artificial Intelligence, </journal> <volume> 58 </volume> <pages> 113-159, </pages> <year> 1992. </year>
Reference-contexts: They are trivially decidable, however, many finite domain problems are NP-complete. Thus, no general efficient method exists which solves such problems automatically. However, in practice, many problem instances belonging to this class can in fact be solved in polynomial time <ref> [GJ79, PS82, HSD92b, St-a94] </ref>. Propagation-based algorithms [Mac77] for simplifying a finite domain problem use the logical and arithmetical semantics of the relations to eliminate inconsistent values and tuples of values from the solution space of the problem. <p> The basic principle in finite domain constraint programming is to use arithmetical constraints as primitives, on top of which symbolic and propositional constraints are laid. Hence, by combining arithmetical reasoning with cardinality-based, relational, conditional, and disjunctive reasoning complex scheduling, packing, optimization, and satisfiability problems can be solved efficiently <ref> [DHS + 88, DSH88, Hen89, HSD92b, DC93c] </ref>. Adding concurrency notions with constraint solving [SRP91, Mah87] shows further that programming with finite domain constraints exceeds the logic programming paradigm. <p> However, 12 Finite Domain Problems we include a complete but simple programming example at the end of this chapter, as to give a quick feel of the whole topic. For good introductions to general constraint programming see <ref> [Hen91, HSD92b, JM94] </ref>. 2.1 Arithmetic problems In this section we give examples of how arithmetic problems can be solved by finite domain constraints. Many of these problems are also described in [Hen89]. <p> It follows that x = 4 is not consistent with c, d x , and d y , and consequently it can be removed. 2 For many constraints, the semantics of the constraints can be exploited in a nontrivial way which gives highly efficient pruning algorithms <ref> [DH91, HSD92b, HDT92, AB93, CC95] </ref>. Arc-consistency is a strictly weaker notion than true consistency, i.e. a store may be arc-consistent without being consistent. Example 3.9: Consider the constraints x 6= y 6= z 6= x 44 Finite Domain Constraints and i.e. the variables must all be assigned different values. <p> It has previously been shown that element/3 can be defined in terms of cardinality disjunction <ref> [HSD92b] </ref>, however, under the assumption that i j is determined. Thus, our approach is slightly more general since i j need not be determined. 2 Example 4.2: Let c be the constraint x = z _ y = z. <p> In cc (FD), and (x; y; z) is defined by a conjunction of implications, (X=0 !Z=0, : : :, X=Y !X=Z), similar to the clauses above (omitting the fd and fd ask operators) <ref> [HSD92b] </ref>. Thus, the same constraints are propagated as in AKL (FD). However, in cc (FD) there is a problem of propagating redundant copies of constraints. Consider, for example, the atom and (X, Y, 1). In AKL (FD) this atom is replaced by fd (X=1, Y=1).
Reference: [ILO93] <author> ILOG. </author> <title> ILOG Solver User Manual, </title> <year> 1993. </year>
Reference-contexts: The programmer can thus experiment with alternatives, tailoring the constraints to fit the particular application. User-defined constraints have been recognized as crucial for the versatility of a constraint programming language <ref> [DC93b, HSD91, ECR93, ILO93] </ref>. 94 AKL (FD) We claim that AKL (FD) is a language where complex finite domain constraints can be defined purely within the concurrent constraint framework, and still execute efficiently both when used for consistency checking and when used for entailment checking. 8.5.1 Example: arithmetics First we show <p> Today much work is devoted to adapting the scheduling algorithms for constraint programming such that they can be used incrementally and flexibly, and also mixed with other types of solver algorithms <ref> [AB93, BC94, ILO93, Cas91, CGL93, Pug94, CL94] </ref>. 11.2 Constraint Programming Systems We will now look more into detail of those programming systems which are most closely related to AKL (FD) and which have influenced our work considerably. <p> neither weak nor strong constructive disjunction can be programmed. * No trailing scheme is provided for backtracking, instead copying is used. 11.2.7 ILOG SOLVER ILOG SOLVER (or SOLVER for short) is a C ++ library which embodies the CLP paradigm, i.e. the programmer is provided constraint variables, constraints, and stores <ref> [ILO93, Pug94] </ref>. Propagation is performed similar to CLP/CCP systems by applying arc-consistency, and mechanisms for search and trailing are included in the library. In SOLVER, a constraint variable is a C ++ object.
Reference: [Jan94] <author> Sverker Janson. </author> <title> AKL|a multiparadigm programming language. </title> <institution> Uppsala theses in computing science 19, Uppsala University, </institution> <month> June </month> <year> 1994. </year> <title> SICS Dissertation Series 14. BIBLIOGRAPHY 153 </title>
Reference-contexts: The latter scheme is based on AKL (FD), a deep-guard concurrent constraint language developed at SICS <ref> [Jan94, CJH94] </ref>, which supports indexi-cals, and which performs conditional reasoning through entailment checking and constraint lifting. 1.4.1 The indexical scheme In the indexical scheme, constraints in FDC are compiled into monotone in-dexicals. Implication is treated as blocking, and disjunction as constructive [HSD92a]. <p> consistency and entailment of indexicals by considering their monotonicity, as well as an efficient algorithm which derives decision information used for computing the monotonicity. 1.4.4 The design and implementation of AKL (FD) AKL (Agents Kernel Language) generalizes the basic concurrent constraint programming functionality using a small set of powerful combinators <ref> [JH91, Jan94] </ref>. The paradigm is that of agents communicating over a constraint store, but the combinators make possible also other readings, depending on the context, where agents compute functions or relations, serve as user-defined constraints, or as objects in object-oriented programs. <p> For example, as have been mentioned, a RISC-oriented instruction set is an interesting alternative if machine-code compilation is to be used. However, we do not further address these issues here. Chapter 7 AKL In this chapter we describe AKL, and the constraint store and guard model of AKL <ref> [Jan94] </ref>. Our contribution to the design and implementation of AKL has been the constraint interface and constraint lifting [CJM93, CC95]. 7.1 Introduction Concurrent constraint programming (CCP) is a powerful paradigm for programming with constraints, based on simple concepts [Mah87, Sar89]. <p> Telling and asking correspond to sending and receiving "messages", thereby providing the basic means for communication and synchronization for concurrent programming. The Agents Kernel Language (AKL) is a concurrent constraint programming language which generalizes the above functionality using a small set of powerful combinators <ref> [JH91, Jan94] </ref>. The basic paradigm is still that of agents communicating over a constraint store, but the combinators make possible also other readings, depending on the context, where agents compute functions or relations, serve as user-defined constraints, or as objects in object-oriented programs. <p> However, we exclude ports and aggregates. For a complete definition see [JH91], [Fra94], or <ref> [Jan94] </ref>. 7.2.1 The language Basic statements, such as constraints, calls, composition, and hiding, are as in other CCP languages [Sar93] (see Figure 7.1). A constraint c (x) executes by calling the appropriate constraint solver, which simplifies the constraint and checks its consistency and/or entailment with the current store. <p> Of course, a large body of work on practically motivated constraint systems exists [JM94]. We have so far considered constraint systems over rational trees, feature trees, and finite domains in AGENTS <ref> [Kei94, Jan94, CJH94] </ref>. This investigation will be extended to other systems in the future, such as systems over boolean and rational numbers. The rational tree constraint system is the same as in SICStus Prolog and Prolog-II [Col84], and has been inlined in the AKL-emulator for efficiency reasons. <p> Each conjunction P refers to a list of suspended constraints P C . The environment of P is referred to as P . The worker rewrites the configurations according to the operational semantics of AKL <ref> [JH91, Jan94] </ref>. Suppose a constraint c is executed in P . If c and P are inconsistent, the execution fails and P is marked as dead. If c is entailed, the computation succeeds. Otherwise, c is simplified with respect to P , and added to P C . <p> Being deep means having a hierarchy of constraint stores, where a computation need not be affected by the failure of a subordinate store. This makes it possible to have a reactive process/object-oriented top-level in a program, with other encapsulated components performing constraint solving. AKL is a deep CCP language <ref> [JH91, Jan94] </ref>. This enables, for example, a simple and complete implementation of constraint lifting which can be used to execute disjunctions of finite domain constraints (Section 8.3 and 9). <p> When the indexical is entailed, the flag is unified with 0. Hence, by allocating the variable in the same store as x, the unification constraint of AGENTS <ref> [Jan94] </ref> guarantees that the binding of the variable is properly deinstalled and installed such that a locally entailed indexical does not incorrectly appear entailed in an external store. <p> The abstract machine of AGENTS is an extension of the WAM [War83], with instructions for selecting clauses, saving information on the local stack, constructing terms, guarding the clause, and for executing procedure calls. For a full explanation see <ref> [Jan94] </ref>. <p> This is called the stability principle of AKL <ref> [Jan94] </ref> (Section 7.1). If several non-determinate steps are possible, the selection rule selects the smallest stable subtree to split. The basic nondeterminate primitive in finite domain constraint programming is the labeling predicate, which enumerates a list of domain variables. <p> We focus on the FD-part, since AKL has already been thoroughly described and analyzed elsewhere <ref> [Jan94] </ref>. 11.2 Constraint Programming Systems 139 11.2.1 Forerunners There are four noteable forerunners of concurrent finite domain constraint programming; Prolog, Alice, GHC, and Prolog-III.
Reference: [JH91] <author> S. Janson and S. Haridi. </author> <title> Programming paradigms of the An-dorra Kernel Language. </title> <booktitle> In Logic Programming: Proceedings of the 1991 International Symposium. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: As target language we use FD, a language of indexicals, i.e. functions computing domains of variables. Two execution schemes for FDC are developed; one scheme is based solely on using indexicals to evaluate the constraints; the other is based on deep-guard concurrent constraint programming <ref> [Sar89, Sar93, JH91] </ref> together with support for indexicals. <p> consistency and entailment of indexicals by considering their monotonicity, as well as an efficient algorithm which derives decision information used for computing the monotonicity. 1.4.4 The design and implementation of AKL (FD) AKL (Agents Kernel Language) generalizes the basic concurrent constraint programming functionality using a small set of powerful combinators <ref> [JH91, Jan94] </ref>. The paradigm is that of agents communicating over a constraint store, but the combinators make possible also other readings, depending on the context, where agents compute functions or relations, serve as user-defined constraints, or as objects in object-oriented programs. <p> Telling and asking correspond to sending and receiving "messages", thereby providing the basic means for communication and synchronization for concurrent programming. The Agents Kernel Language (AKL) is a concurrent constraint programming language which generalizes the above functionality using a small set of powerful combinators <ref> [JH91, Jan94] </ref>. The basic paradigm is still that of agents communicating over a constraint store, but the combinators make possible also other readings, depending on the context, where agents compute functions or relations, serve as user-defined constraints, or as objects in object-oriented programs. <p> However, we exclude ports and aggregates. For a complete definition see <ref> [JH91] </ref>, [Fra94], or [Jan94]. 7.2.1 The language Basic statements, such as constraints, calls, composition, and hiding, are as in other CCP languages [Sar93] (see Figure 7.1). <p> Each conjunction P refers to a list of suspended constraints P C . The environment of P is referred to as P . The worker rewrites the configurations according to the operational semantics of AKL <ref> [JH91, Jan94] </ref>. Suppose a constraint c is executed in P . If c and P are inconsistent, the execution fails and P is marked as dead. If c is entailed, the computation succeeds. Otherwise, c is simplified with respect to P , and added to P C . <p> Being deep means having a hierarchy of constraint stores, where a computation need not be affected by the failure of a subordinate store. This makes it possible to have a reactive process/object-oriented top-level in a program, with other encapsulated components performing constraint solving. AKL is a deep CCP language <ref> [JH91, Jan94] </ref>. This enables, for example, a simple and complete implementation of constraint lifting which can be used to execute disjunctions of finite domain constraints (Section 8.3 and 9). <p> Its constraint system treats rational trees, lists, numbers and booleans, and showed the way for much research to come. GHC is a concurrent logic programming language which introduced a clean model for guards, suspensions, and commit [Ued85], which was brought over into the design of AKL <ref> [JH91] </ref>. Today, however, the developments of the systems have diverged, where the GHC research is directed towards the flat part of the language, and the AKL research concerns more interoperability, distribution, and parallelism.
Reference: [JL87] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In POPL'87, </booktitle> <year> 1987. </year>
Reference-contexts: This is particularly advantageous in industrial use where the environment is dynamic. 1.2 Finite Domain Constraint Programming Logic programming is based on resolution and unification [Kow74, Rob65]. Unification is naturally replaced with constraint solvers for other algebraic theories <ref> [JL87] </ref>, resulting in constraint logic programming. In particular, by using the inherent non-determinism of logic programming, and by integrating propagation algorithms as solvers, a programming paradigm is realized by which finite domain problems can be effectively attacked. <p> An assignment which satisfies a constraint is such that the constraint is true, given its interpretation, and the values assigned to the free variables therein. A constraint store is simply a set of constraints <ref> [JL87, SRP91] </ref>. A constraint store is consistent if some assignment of values to variables can be made which satisfies all the constraints in the store. A constraint is implied by a store, if any assignment which satisfies the store, satisfies the constraint. <p> Computations are monotone, i.e. con straints are accumulated without any retractions being made. This gives several advantages; * the semantics is clean and simple <ref> [JL87] </ref>, * concurrency can naturally be added [Mah87, SRP91], and * logical combinators can be used as programming combinators, e.g. conjunction corresponds to concurrent composition, implication to conditionals, and disjunction to nondeterminism.
Reference: [JM92] <author> S. Janson and J. Montelius. </author> <title> The design of the AKL/PS 0.0 prototype implementation of the Andorra Kernel Language. ESPRIT deliverable, </title> <type> EP 2471 (PEPMA), </type> <institution> Swedish Institute of Computer Science, </institution> <year> 1992. </year>
Reference-contexts: A constraint system in AKL must provide algorithms for entailment and consistency, neither of which need to be complete. Consistency is maintained through constraint propagation and checking. A programming environment for AKL is currently being developed at SICS <ref> [JM92] </ref>. <p> The rational tree constraint system is the same as in SICStus Prolog and Prolog-II [Col84], and has been inlined in the AKL-emulator for efficiency reasons. Our performance evaluations indicate that AKL is as fast as Prolog in doing constraint solving over such equalities <ref> [JM92] </ref>. We now describe the constraint store model, and the generic constraint protocol, of AKL. 7.3 Constraint stores in AKL 85 7.3.1 Constraint stores Seen from a logical perspective, stores in an AKL computation state are of the following general form.
Reference: [JM94] <author> J. Jaffar and M. Maher. </author> <title> Constraint Logic Programming: A Survey. </title> <journal> Journal of Logic Programming, </journal> 19/20:503-581, 1994. 
Reference-contexts: However, 12 Finite Domain Problems we include a complete but simple programming example at the end of this chapter, as to give a quick feel of the whole topic. For good introductions to general constraint programming see <ref> [Hen91, HSD92b, JM94] </ref>. 2.1 Arithmetic problems In this section we give examples of how arithmetic problems can be solved by finite domain constraints. Many of these problems are also described in [Hen89]. <p> Of course, a large body of work on practically motivated constraint systems exists <ref> [JM94] </ref>. We have so far considered constraint systems over rational trees, feature trees, and finite domains in AGENTS [Kei94, Jan94, CJH94]. This investigation will be extended to other systems in the future, such as systems over boolean and rational numbers. <p> the work on symbolic logic and mathematical programming in the 50s and 60s [NS56, McC60, DP60, Dan63, Rob65, Min67], ideas which were further developed by the symbolic and integer programming communities [Hew69, CKPR73, Kow74, BM76, WP77, SS80, PS82, Col84, JL87, DHS + 88] (for good overviews see [Coh90], [Hen91], and <ref> [JM94] </ref>), and by work on constraint solving algorithms in algebra and operations research [Dan63, Bak74, GJ79, PS82]. <p> By using logical inference systems, typically based on resolution or some other proof system, and combining these with algebraic solver algorithms, efficient methods have been developed for many classes of constraint problems (for an overview see <ref> [JM94] </ref>). As an archetypal class consider the class of scheduling problems. 138 Related Work 11.1.1 Scheduling problems Scheduling problems were early recognized as important and computation-ally challenging [MT63, Bak74, Kan76, GJ79, AC91, Got93, AB93]. They occur everywhere, since timetables and production plans are a vital part of most workplaces.
Reference: [JMB + 94] <author> S. Janson, J. Montelius, K. Boortz, P. Brand, B. Carlson, R. C. Haygood, B. Danielsson, and S. Haridi. </author> <title> AGENTS User Manual. </title> <type> SICS, </type> <year> 1994. </year>
Reference-contexts: AKL is a deep-guard language, where being deep means having a hierarchy of constraint stores, where a computation need not be affected by the failure of a subordinate store. The AGENTS implementation of AKL <ref> [JMB + 94] </ref>, being developed at SICS, has rational trees as its basic constraint system, which is supported efficiently at the emulator level. Other constraint systems, such as FD are integrated using generic variables and generic constraints. <p> This chapter is based on [CJH94, CC95]. The implementation details are given in Chapter 9, and a performance evaluation of the system is given in Chapter 10. 8.1 Introduction The AGENTS implementation of AKL <ref> [JMB + 94] </ref>, being developed at SICS, has rational trees as its basic constraint system, which is supported efficiently at the emulator level. <p> We give an example of how cardinality reasoning can be programmed in AKL (FD), using the committed choice operator. The cardinality combinator can similarly be defined in AKL (FD) by using the abstraction notion of AKL <ref> [JMB + 94] </ref>, thereby calling the constraints as predicates. Consider the constraint atmost (u; l; v) which is true iff at most u elements in l are equal to v, where l = [x 1 ; : : : ; x k ].
Reference: [JS93] <author> J. Jourdan and T. Sola. </author> <title> The versatility of handling disjunctions as constraints. </title> <booktitle> In Proceedings of the Programming Language Implementation and Logic Programming Conference, </booktitle> <publisher> LNCS 714. Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Hence, conjunction and blocking implication replace cardinality. 3.6.5 Disjunction Disjunctive reasoning is important in constraint programming. Traditionally, disjunctions have been used for nondeterminate programming, but, recently, uses of disjunctions in determinate programs have been discovered <ref> [HD91, HSD92a, JS93, CC95] </ref>. The basic insight is that instead of using disjunction as a means for guessing computation paths, disjunction is used for pruning fruitless computation paths. Hence, the phrase constructive disjunction, although somewhat misleading since the connection to constructive logic is not clarified. <p> The cardinality-operator is not speculative, but achieves insufficient propagation in many cases, typically for disjunctive scheduling problems. Constructive Constructive disjunction was proposed as a way to treat a disjunction of constraints as a constraint itself, to thereby avoid the speculative behavior, and to utilize the inherent propagation of disjunctions <ref> [HSD91, HSD92a, JS93] </ref>. We only consider propagating domain constraints from a disjunction in the following.
Reference: [Kan76] <author> A. H. G. Rinnooy Kan. </author> <title> Machine Scheduling Problem: Classification, Complexity, and Computations. </title> <address> Nyhoff, </address> <year> 1976. </year>
Reference-contexts: As an archetypal class consider the class of scheduling problems. 138 Related Work 11.1.1 Scheduling problems Scheduling problems were early recognized as important and computation-ally challenging <ref> [MT63, Bak74, Kan76, GJ79, AC91, Got93, AB93] </ref>. They occur everywhere, since timetables and production plans are a vital part of most workplaces. Furthermore, resource allocation problems constitute a subclass of the scheduling problems, and these are fundamental in industrial design and production.
Reference: [Kei94] <author> Torbjorn Keisu. </author> <title> Tree Constraints. </title> <type> PhD thesis, </type> <institution> Royal Institute of Technology (KTH), </institution> <month> May </month> <year> 1994. </year> <title> SICS Dissertation Series 16. </title>
Reference-contexts: Of course, a large body of work on practically motivated constraint systems exists [JM94]. We have so far considered constraint systems over rational trees, feature trees, and finite domains in AGENTS <ref> [Kei94, Jan94, CJH94] </ref>. This investigation will be extended to other systems in the future, such as systems over boolean and rational numbers. The rational tree constraint system is the same as in SICStus Prolog and Prolog-II [Col84], and has been inlined in the AKL-emulator for efficiency reasons.
Reference: [Kow74] <author> R. Kowalski. </author> <title> Predicate logic as programming language. </title> <booktitle> In Proceedings of the IFIP Congress '74. </booktitle> <publisher> North Holland, </publisher> <year> 1974. </year>
Reference-contexts: This is particularly advantageous in industrial use where the environment is dynamic. 1.2 Finite Domain Constraint Programming Logic programming is based on resolution and unification <ref> [Kow74, Rob65] </ref>. Unification is naturally replaced with constraint solvers for other algebraic theories [JL87], resulting in constraint logic programming. In particular, by using the inherent non-determinism of logic programming, and by integrating propagation algorithms as solvers, a programming paradigm is realized by which finite domain problems can be effectively attacked.
Reference: [Lau78] <author> J. L. Lauriere. </author> <title> A Language and a Program for Stating and Solving Combinatorial Problems. </title> <journal> Journal of Artifical Intelligence, </journal> <volume> 10 </volume> (1):29-127, 1978. 
Reference-contexts: Today, however, the developments of the systems have diverged, where the GHC research is directed towards the flat part of the language, and the AKL research concerns more interoperability, distribution, and parallelism. Alice was a powerful constraint solving system which introduced many new constraints and combinators <ref> [Lau78] </ref>, some which are still neither fully understood nor widely used in the constraint programming community. For example, constraints over finite functions and sets were allowed, so that one could constrain a finite function to be bijective simply by stating bij (f ).
Reference: [Mac77] <author> A. Mackworth. </author> <title> Consistency in Networks of Relations. </title> <journal> Journal of Artifical Intelligence, </journal> <volume> 8 </volume> <pages> 99-118, </pages> <year> 1977. </year>
Reference-contexts: They are trivially decidable, however, many finite domain problems are NP-complete. Thus, no general efficient method exists which solves such problems automatically. However, in practice, many problem instances belonging to this class can in fact be solved in polynomial time [GJ79, PS82, HSD92b, St-a94]. Propagation-based algorithms <ref> [Mac77] </ref> for simplifying a finite domain problem use the logical and arithmetical semantics of the relations to eliminate inconsistent values and tuples of values from the solution space of the problem. Thereby, the size of the search space decreases, sometimes by orders of magnitude, which simplifies searching. <p> Thus, index-icals are used for describing stronger conditions than necessary, which can efficiently be checked by a solver for FD (Section 6.3). 3.9 Arc-consistency The basis for existing finite domain solvers is arc-consistency <ref> [Mac77] </ref>, i.e. variable domains are pruned by eliminating values inconsistent with the current set of constraints. <p> But, since there are three variables and only two values, all of the constraints cannot be satisfied. However, the constraints are arc-consistent. 2 3.9.1 Hyper AC-3 Finally, we include the classic AC-3 algorithm <ref> [Mac77] </ref> which stands as a model for our arc-consistency solver for indexicals (Section 6.1). We have adapted the original formulation to constraints of arbitrary arity.
Reference: [Mac88] <author> A. Mackworth. </author> <title> Encyclopedia of AI, chapter Constraint Satisfaction. </title> <publisher> John Wiley and Sons, </publisher> <year> 1988. </year>
Reference-contexts: The key idea is to specify a set C of constraints, which are first-order open formulas, such that the extension of C contains precisely the solutions to a given problem, hence the naming "constraint satisfaction" problems <ref> [Mac88] </ref>. However, a very large class of problems can be described by constraints, including the class of NP-complete problems, and thereby there is no efficient method for solving all constraint satisfaction problems.
Reference: [Mah87] <author> M. J. Maher. </author> <title> Logic semantics for a class of committed choice programs. </title> <booktitle> In Logic Programming: Proceedings of the Fourth International Conference. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Hence, by combining arithmetical reasoning with cardinality-based, relational, conditional, and disjunctive reasoning complex scheduling, packing, optimization, and satisfiability problems can be solved efficiently [DHS + 88, DSH88, Hen89, HSD92b, DC93c]. Adding concurrency notions with constraint solving <ref> [SRP91, Mah87] </ref> shows further that programming with finite domain constraints exceeds the logic programming paradigm. Constraint solving can thus be used for synchronization of and communication between processes, as well as for programming propositional and arithmetic reasoning [CJH94]. <p> Computations are monotone, i.e. con straints are accumulated without any retractions being made. This gives several advantages; * the semantics is clean and simple [JL87], * concurrency can naturally be added <ref> [Mah87, SRP91] </ref>, and * logical combinators can be used as programming combinators, e.g. conjunction corresponds to concurrent composition, implication to conditionals, and disjunction to nondeterminism. <p> Hence, implication checking is an important notion in constraint (logic) programming. It has previously been recognized that implication checking is crucial in giving concurrent extensions of constraint programming a simple interpretation <ref> [Mah87, SRP91] </ref>. Throughout our thesis we therefore consider implication checking on equal terms with consistency checking. 3.3 FD We now present a variant of the indexical language FD [HSD91]. The intuitive understanding of indexicals is that they are functional rules for maintaining consistency of arithmetic finite domain constraints. <p> Our contribution to the design and implementation of AKL has been the constraint interface and constraint lifting [CJM93, CC95]. 7.1 Introduction Concurrent constraint programming (CCP) is a powerful paradigm for programming with constraints, based on simple concepts <ref> [Mah87, Sar89] </ref>. A set (or conjunction) of constraints, regarded as formulas in first-order logic, forms a constraint store. <p> We believe that Alice struck a chord which still has much to offer modern constraint programming languages. 11.2.2 CCP The introduction of the concurrent constraint programming (CCP) languages showed how constraint solving could be used not only for problem solving, but also for communication and synchronization between processes <ref> [Mah87, Sar89, Sar93] </ref>. The basic insights are: * A set of constraints can be considered to be a store, corresponding to the memory state of a computation.
Reference: [McC60] <author> J. McCarthy. </author> <title> Recursive Functions of Symbolic Expressions and Their Computation by Machine. </title> <journal> Communications of ACM, </journal> <volume> 3 (4):184-195, 1960. 154 </volume> BIBLIOGRAPHY 
Reference-contexts: However, first we give a brief background of the origins of finite domain constraints and constraint programming. 11.1 Constraint Satisfaction Problems Constraints for problem solving originates with the work on symbolic logic and mathematical programming in the 50s and 60s <ref> [NS56, McC60, DP60, Dan63, Rob65, Min67] </ref>, ideas which were further developed by the symbolic and integer programming communities [Hew69, CKPR73, Kow74, BM76, WP77, SS80, PS82, Col84, JL87, DHS + 88] (for good overviews see [Coh90], [Hen91], and [JM94]), and by work on constraint solving algorithms in algebra and operations research [Dan63,
Reference: [MF85] <author> A. Mackworth and E. C. Freuder. </author> <title> The Complexity of Some Polynomial Network Consistency Algorithms for Constraint Satisfaction Problems. </title> <journal> Journal of Artifical Intelligence, </journal> <volume> 25 </volume> <pages> 65-74, </pages> <year> 1985. </year>
Reference-contexts: Thereby, the total runtime is O (km k+1 ne), or O (m k+1 ne) since k can be assumed to be a small constant independent of the problem. 2 In the special case of binary constraints, the time-complexity is thus O (m 3 ne) <ref> [MF85] </ref>. It should be noted that refinements to the AC-3 algorithm above have been added, concerned with a: relaxing the computation of revise, such that it becomes linear in k. This is done using so called interval-reasoning (or partial lookahead) [Hen89, HSD92a].
Reference: [Min67] <author> M. Minsky. </author> <title> Computation: Finite and Infinite Machines. </title> <publisher> Pren-tice Hall, </publisher> <year> 1967. </year>
Reference-contexts: However, first we give a brief background of the origins of finite domain constraints and constraint programming. 11.1 Constraint Satisfaction Problems Constraints for problem solving originates with the work on symbolic logic and mathematical programming in the 50s and 60s <ref> [NS56, McC60, DP60, Dan63, Rob65, Min67] </ref>, ideas which were further developed by the symbolic and integer programming communities [Hew69, CKPR73, Kow74, BM76, WP77, SS80, PS82, Col84, JL87, DHS + 88] (for good overviews see [Coh90], [Hen91], and [JM94]), and by work on constraint solving algorithms in algebra and operations research [Dan63,
Reference: [MMPS95] <author> M. Mehl, T. Muller, K. Popov, and R. Scheidhauer. </author> <title> DFKI Oz User's Manual. Oz Documentation Series, </title> <institution> DFKI, German Research Center for Artificial Intelligence, </institution> <year> 1995. </year>
Reference-contexts: We analyze * the efficiency of the FD solver, * the effect of the optimizations exploited, and * the difference in speed between AGENTS and clp (FD). Furthermore, AGENTS is compared with Oz, since Oz <ref> [Smo94, SS94, MMPS95] </ref> provides the same basic notions for deep guards as AKL does, and we compare their performance with respect to finite domain constraints and guard programming. In this comparison, the copying-based labeling is used. <p> added. 10.2 Evaluating AGENTS with Copying 129 10.2 Evaluating AGENTS with Copying In this section we are using the copying scheme for labeling developed in Section 9.5.1. 10.2.1 Comparing with Oz We now compare AGENTS with Oz, which offers the same basic functionality for finite domain constraints as do AGENTS <ref> [Smo95, HM95, MMPS95, MPSW95] </ref>. The machine used throughout in the evaluation is a Sun 4/25 (SPARC-station ELC), running SunOs 4.1.2, and all measurements are done on this machine. In Table 10.9 we give the timings in milliseconds for the same programs run in AGENTS and in Oz. <p> the necessary primitives for constraint programming, such as constructive disjunction and cumulative constraints; however, the basic foundation has been laid upon which such constructs should fit nicely. 11.2 Constraint Programming Systems 143 11.2.6 Oz Oz is a concurrent language allowing functional, object-oriented and constraint programming, based on the CCP paradigm <ref> [Smo95, HM95, MMPS95, MPSW95] </ref>. Similar to AKL, Oz provides deep guards, and the same three guard operators for conditional, committed and nondeterminate choice are included. The language is higher-order which enables a theoretically appealing treatment of objects and inheritance [Smo94].
Reference: [MPSW95] <author> T. Muller, K. Popov, C. Schulte, and J. Wurtz. </author> <title> Constraint Programming in Oz. Oz Documentation Series, </title> <institution> DFKI, German Research Center for Artificial Intelligence, </institution> <year> 1995. </year>
Reference-contexts: added. 10.2 Evaluating AGENTS with Copying 129 10.2 Evaluating AGENTS with Copying In this section we are using the copying scheme for labeling developed in Section 9.5.1. 10.2.1 Comparing with Oz We now compare AGENTS with Oz, which offers the same basic functionality for finite domain constraints as do AGENTS <ref> [Smo95, HM95, MMPS95, MPSW95] </ref>. The machine used throughout in the evaluation is a Sun 4/25 (SPARC-station ELC), running SunOs 4.1.2, and all measurements are done on this machine. In Table 10.9 we give the timings in milliseconds for the same programs run in AGENTS and in Oz. <p> Entailment checking as used in CCP languages also provides a good mechanism for control in user-defined constraints <ref> [HSD91, CJH94, MPSW95] </ref>. 140 Related Work * Communication is handled by adding (telling) constraints to the store, which increases the amount of information in the store. <p> the necessary primitives for constraint programming, such as constructive disjunction and cumulative constraints; however, the basic foundation has been laid upon which such constructs should fit nicely. 11.2 Constraint Programming Systems 143 11.2.6 Oz Oz is a concurrent language allowing functional, object-oriented and constraint programming, based on the CCP paradigm <ref> [Smo95, HM95, MMPS95, MPSW95] </ref>. Similar to AKL, Oz provides deep guards, and the same three guard operators for conditional, committed and nondeterminate choice are included. The language is higher-order which enables a theoretically appealing treatment of objects and inheritance [Smo94]. <p> Oz includes a combinator for encapsulated search [SS94], which makes many search strategies, including depth-first, breadth-first, and branch-&- bound to be programmable at source level. Furthermore, by providing primitives for accessing information related to finite domain variables, heuristics such as first-fail can also be programmed at Oz level <ref> [MPSW95] </ref>. The finite domain constraints are integrated in Oz through a set of C-builtins for arithmetic and symbolic reasoning. The execution of these builtins is controlled using guarded clauses, whereby some disjunctive and conditional reasoning can be performed [MPSW95]. <p> variables, heuristics such as first-fail can also be programmed at Oz level <ref> [MPSW95] </ref>. The finite domain constraints are integrated in Oz through a set of C-builtins for arithmetic and symbolic reasoning. The execution of these builtins is controlled using guarded clauses, whereby some disjunctive and conditional reasoning can be performed [MPSW95].
Reference: [MT63] <author> J. F. Muth and G.L. Thompson. </author> <title> Industrial Scheduling. </title> <publisher> Prentice Hall, </publisher> <year> 1963. </year>
Reference-contexts: As an archetypal class consider the class of scheduling problems. 138 Related Work 11.1.1 Scheduling problems Scheduling problems were early recognized as important and computation-ally challenging <ref> [MT63, Bak74, Kan76, GJ79, AC91, Got93, AB93] </ref>. They occur everywhere, since timetables and production plans are a vital part of most workplaces. Furthermore, resource allocation problems constitute a subclass of the scheduling problems, and these are fundamental in industrial design and production.
Reference: [NS56] <author> A. Newell and H. A. Simon. </author> <title> The Logic Theory Machine A Complex Information Processing System. </title> <journal> IRE Trans. Information Theory, </journal> <volume> 2 </volume> <pages> 61-79, </pages> <year> 1956. </year>
Reference-contexts: However, first we give a brief background of the origins of finite domain constraints and constraint programming. 11.1 Constraint Satisfaction Problems Constraints for problem solving originates with the work on symbolic logic and mathematical programming in the 50s and 60s <ref> [NS56, McC60, DP60, Dan63, Rob65, Min67] </ref>, ideas which were further developed by the symbolic and integer programming communities [Hew69, CKPR73, Kow74, BM76, WP77, SS80, PS82, Col84, JL87, DHS + 88] (for good overviews see [Coh90], [Hen91], and [JM94]), and by work on constraint solving algorithms in algebra and operations research [Dan63,
Reference: [Pap94] <author> C. Le Pape. </author> <title> Using a Constraint-Based Scheduling Library to Solve a Specific Scheduling Problem. </title> <booktitle> In Proceedings of the AAAI-SIGMAN Workshop on Artificial Intelligence Approaches to Modelling and Scheduling Manufacturing Processes, </booktitle> <year> 1994. </year>
Reference-contexts: SOLVER is a solid base for efficient and versatile constraint programming, as is shown for example by the powerful system for scheduling problems developed on top of SOLVER <ref> [Pap94] </ref>. SOLVER is imperative, thereby, constraint programming is more easily integrated in real applications; however, by paying the prize of imperative programming, i.e. memory management becomes a major concern, and programming becomes more error-prone than when using a symbolic language. <p> Erlang (FD) will thereby contain the necessary notions for developing large-scale control and supervision systems, reactive scheduling and verification applications, intelligent agents, and interactive planning tools, which are exciting new domains of software. 4. Disjunctive and cumulative constraints need more attention. The work on cumulative constraints and scheduling libraries <ref> [AB93, BC94, Pap94] </ref>, which constitute state-of-the-art of constraint satisfaction applied to scheduling and planning, should be complemented with fundamental investigations of how a propositional language of finite domain constraints, such as FDC, combined with the techniques addressed in item 1 and 2, can reach similar performance figures. 5.
Reference: [PS82] <author> C. H. Papadimitriou and K. Steiglitz. </author> <title> Combinatorial Optimization: Algorithms and Complexity. </title> <publisher> Prentice Hall, </publisher> <year> 1982. </year>
Reference-contexts: They are trivially decidable, however, many finite domain problems are NP-complete. Thus, no general efficient method exists which solves such problems automatically. However, in practice, many problem instances belonging to this class can in fact be solved in polynomial time <ref> [GJ79, PS82, HSD92b, St-a94] </ref>. Propagation-based algorithms [Mac77] for simplifying a finite domain problem use the logical and arithmetical semantics of the relations to eliminate inconsistent values and tuples of values from the solution space of the problem. <p> Of course, for certain well-analyzed problems, such as the traveling salesman problem, there exist more efficient algorithms using problem-specific knowledge, local search or approximation algorithms <ref> [PS82] </ref>. However, as a general problem-solving methodology, the combination of search with propagation is hard to beat. 2 Introduction For example, constraint-based search, compared to local search and approximation algorithms, allows naturally constraints to be added/removed to/from the problem specification to direct the search, or to slightly change the specification. <p> [NS56, McC60, DP60, Dan63, Rob65, Min67], ideas which were further developed by the symbolic and integer programming communities [Hew69, CKPR73, Kow74, BM76, WP77, SS80, PS82, Col84, JL87, DHS + 88] (for good overviews see [Coh90], [Hen91], and [JM94]), and by work on constraint solving algorithms in algebra and operations research <ref> [Dan63, Bak74, GJ79, PS82] </ref>. The key idea is to specify a set C of constraints, which are first-order open formulas, such that the extension of C contains precisely the solutions to a given problem, hence the naming "constraint satisfaction" problems [Mac88].
Reference: [Pug94] <author> J.-F. Puget. </author> <title> A C++ implementation of CLP. </title> <booktitle> In Proceedings of the Second International Workshop on Principles and Practice of Constraint Programming, </booktitle> <year> 1994. </year>
Reference-contexts: Today much work is devoted to adapting the scheduling algorithms for constraint programming such that they can be used incrementally and flexibly, and also mixed with other types of solver algorithms <ref> [AB93, BC94, ILO93, Cas91, CGL93, Pug94, CL94] </ref>. 11.2 Constraint Programming Systems We will now look more into detail of those programming systems which are most closely related to AKL (FD) and which have influenced our work considerably. <p> neither weak nor strong constructive disjunction can be programmed. * No trailing scheme is provided for backtracking, instead copying is used. 11.2.7 ILOG SOLVER ILOG SOLVER (or SOLVER for short) is a C ++ library which embodies the CLP paradigm, i.e. the programmer is provided constraint variables, constraints, and stores <ref> [ILO93, Pug94] </ref>. Propagation is performed similar to CLP/CCP systems by applying arc-consistency, and mechanisms for search and trailing are included in the library. In SOLVER, a constraint variable is a C ++ object. <p> Basically, the new constraint inherits from the basic constraint class, and extends the virtual functions (methods) of the base class. It is claimed that this is crucial to the success of a constraint programming language <ref> [Pug94] </ref>. Furthermore, the programmer has good control over search and labeling. First of all, a generic labeling procedure is defined, which can be provided a function for selecting the variable to enumerate next, i.e. a heuristic such as first-fail can be programmed.
Reference: [Rob65] <author> J. A. Robinson. </author> <title> A Machine Oriented Logic based on the Resolution Principle. </title> <journal> Journal of ACM, </journal> <volume> 12 </volume> (1):23-41, 1965. 
Reference-contexts: This is particularly advantageous in industrial use where the environment is dynamic. 1.2 Finite Domain Constraint Programming Logic programming is based on resolution and unification <ref> [Kow74, Rob65] </ref>. Unification is naturally replaced with constraint solvers for other algebraic theories [JL87], resulting in constraint logic programming. In particular, by using the inherent non-determinism of logic programming, and by integrating propagation algorithms as solvers, a programming paradigm is realized by which finite domain problems can be effectively attacked. <p> However, first we give a brief background of the origins of finite domain constraints and constraint programming. 11.1 Constraint Satisfaction Problems Constraints for problem solving originates with the work on symbolic logic and mathematical programming in the 50s and 60s <ref> [NS56, McC60, DP60, Dan63, Rob65, Min67] </ref>, ideas which were further developed by the symbolic and integer programming communities [Hew69, CKPR73, Kow74, BM76, WP77, SS80, PS82, Col84, JL87, DHS + 88] (for good overviews see [Coh90], [Hen91], and [JM94]), and by work on constraint solving algorithms in algebra and operations research [Dan63,
Reference: [Sar89] <author> V. A. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: As target language we use FD, a language of indexicals, i.e. functions computing domains of variables. Two execution schemes for FDC are developed; one scheme is based solely on using indexicals to evaluate the constraints; the other is based on deep-guard concurrent constraint programming <ref> [Sar89, Sar93, JH91] </ref> together with support for indexicals. <p> Our contribution to the design and implementation of AKL has been the constraint interface and constraint lifting [CJM93, CC95]. 7.1 Introduction Concurrent constraint programming (CCP) is a powerful paradigm for programming with constraints, based on simple concepts <ref> [Mah87, Sar89] </ref>. A set (or conjunction) of constraints, regarded as formulas in first-order logic, forms a constraint store. <p> This is solved by making indomain a builtin which suspends until a stable state is reached. Furthermore, indo-main exploits the short-circuit technique of concurrent logic programming <ref> [Sar89] </ref>, to evaluate the rest of the nondeterminate steps lazily. Thus, the call labeling ([x 1 ; : : : ; x k ]) suspends until the computation state is stable. Then, a value n is selected nondeterministically to assign to x 1 , and a copying step is executed. <p> We believe that Alice struck a chord which still has much to offer modern constraint programming languages. 11.2.2 CCP The introduction of the concurrent constraint programming (CCP) languages showed how constraint solving could be used not only for problem solving, but also for communication and synchronization between processes <ref> [Mah87, Sar89, Sar93] </ref>. The basic insights are: * A set of constraints can be considered to be a store, corresponding to the memory state of a computation. <p> Instead, CCP programs are structured around partial information which monotonically increases, which gives the programs a natural denotational semantics. AKL is a deep-guard CCP language, and its design has been deeply affected by the groundbreaking work in <ref> [Sar89] </ref>. 11.2.3 CHIP CHIP (Constraint Handling In Prolog) is a constraint logic programming language, originating at ECRC, and further developed at Cosytec [DHS + 88, AB91, AB93, BC94]. The language contains solvers for constraints over * finite domains, * booleans, and * rational numbers.
Reference: [Sar93] <author> V. A. Saraswat. </author> <title> Concurrent Constraint Programming. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: As target language we use FD, a language of indexicals, i.e. functions computing domains of variables. Two execution schemes for FDC are developed; one scheme is based solely on using indexicals to evaluate the constraints; the other is based on deep-guard concurrent constraint programming <ref> [Sar89, Sar93, JH91] </ref> together with support for indexicals. <p> However, we exclude ports and aggregates. For a complete definition see [JH91], [Fra94], or [Jan94]. 7.2.1 The language Basic statements, such as constraints, calls, composition, and hiding, are as in other CCP languages <ref> [Sar93] </ref> (see Figure 7.1). A constraint c (x) executes by calling the appropriate constraint solver, which simplifies the constraint and checks its consistency and/or entailment with the current store. <p> We believe that Alice struck a chord which still has much to offer modern constraint programming languages. 11.2.2 CCP The introduction of the concurrent constraint programming (CCP) languages showed how constraint solving could be used not only for problem solving, but also for communication and synchronization between processes <ref> [Mah87, Sar89, Sar93] </ref>. The basic insights are: * A set of constraints can be considered to be a store, corresponding to the memory state of a computation.
Reference: [Smo94] <author> G. Smolka. </author> <title> A Calculus for Higher-Order Concurrent Constraint Programming with Deep Guards. </title> <note> Research Report 3, DFKI, German Research Center for Artificial Intelligence, 1994. BIBLIOGRAPHY 155 </note>
Reference-contexts: We analyze * the efficiency of the FD solver, * the effect of the optimizations exploited, and * the difference in speed between AGENTS and clp (FD). Furthermore, AGENTS is compared with Oz, since Oz <ref> [Smo94, SS94, MMPS95] </ref> provides the same basic notions for deep guards as AKL does, and we compare their performance with respect to finite domain constraints and guard programming. In this comparison, the copying-based labeling is used. <p> Similar to AKL, Oz provides deep guards, and the same three guard operators for conditional, committed and nondeterminate choice are included. The language is higher-order which enables a theoretically appealing treatment of objects and inheritance <ref> [Smo94] </ref>. Oz includes a combinator for encapsulated search [SS94], which makes many search strategies, including depth-first, breadth-first, and branch-&- bound to be programmable at source level. Furthermore, by providing primitives for accessing information related to finite domain variables, heuristics such as first-fail can also be programmed at Oz level [MPSW95].
Reference: [Smo95] <author> G. Smolka. </author> <title> An Oz Primer. Oz Documentation Series, </title> <institution> DFKI, German Research Center for Artificial Intelligence, </institution> <year> 1995. </year>
Reference-contexts: added. 10.2 Evaluating AGENTS with Copying 129 10.2 Evaluating AGENTS with Copying In this section we are using the copying scheme for labeling developed in Section 9.5.1. 10.2.1 Comparing with Oz We now compare AGENTS with Oz, which offers the same basic functionality for finite domain constraints as do AGENTS <ref> [Smo95, HM95, MMPS95, MPSW95] </ref>. The machine used throughout in the evaluation is a Sun 4/25 (SPARC-station ELC), running SunOs 4.1.2, and all measurements are done on this machine. In Table 10.9 we give the timings in milliseconds for the same programs run in AGENTS and in Oz. <p> the necessary primitives for constraint programming, such as constructive disjunction and cumulative constraints; however, the basic foundation has been laid upon which such constructs should fit nicely. 11.2 Constraint Programming Systems 143 11.2.6 Oz Oz is a concurrent language allowing functional, object-oriented and constraint programming, based on the CCP paradigm <ref> [Smo95, HM95, MMPS95, MPSW95] </ref>. Similar to AKL, Oz provides deep guards, and the same three guard operators for conditional, committed and nondeterminate choice are included. The language is higher-order which enables a theoretically appealing treatment of objects and inheritance [Smo94].
Reference: [SRP91] <author> V. A. Saraswat, M. Rinard, and P. Panangaden. </author> <title> Semantic Foundations of Concurrent Constraint Programming. </title> <booktitle> In Symposium on the Principles of Programming Languages. </booktitle> <address> ACM/SIGPPLAN, </address> <year> 1991. </year>
Reference-contexts: Hence, by combining arithmetical reasoning with cardinality-based, relational, conditional, and disjunctive reasoning complex scheduling, packing, optimization, and satisfiability problems can be solved efficiently [DHS + 88, DSH88, Hen89, HSD92b, DC93c]. Adding concurrency notions with constraint solving <ref> [SRP91, Mah87] </ref> shows further that programming with finite domain constraints exceeds the logic programming paradigm. Constraint solving can thus be used for synchronization of and communication between processes, as well as for programming propositional and arithmetic reasoning [CJH94]. <p> An assignment which satisfies a constraint is such that the constraint is true, given its interpretation, and the values assigned to the free variables therein. A constraint store is simply a set of constraints <ref> [JL87, SRP91] </ref>. A constraint store is consistent if some assignment of values to variables can be made which satisfies all the constraints in the store. A constraint is implied by a store, if any assignment which satisfies the store, satisfies the constraint. <p> Computations are monotone, i.e. con straints are accumulated without any retractions being made. This gives several advantages; * the semantics is clean and simple [JL87], * concurrency can naturally be added <ref> [Mah87, SRP91] </ref>, and * logical combinators can be used as programming combinators, e.g. conjunction corresponds to concurrent composition, implication to conditionals, and disjunction to nondeterminism. <p> Hence, implication checking is an important notion in constraint (logic) programming. It has previously been recognized that implication checking is crucial in giving concurrent extensions of constraint programming a simple interpretation <ref> [Mah87, SRP91] </ref>. Throughout our thesis we therefore consider implication checking on equal terms with consistency checking. 3.3 FD We now present a variant of the indexical language FD [HSD91]. The intuitive understanding of indexicals is that they are functional rules for maintaining consistency of arithmetic finite domain constraints. <p> Note that a range such as max (y)::min (y) is antimonotone in any store , however, if y is determined in , the range is also monotone in (and thus constant). The final important FD notion we need to define is fixed points of in-dexicals <ref> [SRP91] </ref>. <p> In the design of AGENTS we have adopted a view of constraints mimicking the constraint view of Prolog, i.e., we represent the constraints through the variables they constrain. Thus, from the implementation point of view, we consider the store not to be a set of constraints <ref> [SRP91] </ref>, but a set of variables. Any constraint c (X) adds its information on X, ensuring that X contains enough information to recover the meaning of c. 86 AKL In the following we use C syntax in describing the outline of the struc tures involved. <p> The basic insights are: * A set of constraints can be considered to be a store, corresponding to the memory state of a computation. By associating each store with its set of solutions, stores can be partially ordered, and programs can thereby be denoted by closure operators over stores <ref> [SRP91] </ref>. * Synchronization is handled by entailment checking, i.e. a computation can be made to suspend (block) until a certain constraint is entailed by the store, i.e. until each solution of the store is a solution of the constraint.
Reference: [SS80] <author> G. J. Sussman and G. L. Steele. </author> <title> CONSTRAINTS-A Language for Expressing Almost-hierarchical Descriptions. </title> <journal> Journal of Artificial Intelligence, </journal> <volume> 14 (1), </volume> <year> 1980. </year>
Reference: [SS94] <author> C. Schulte and G. Smolka. </author> <title> Encapsulated Search in Higher-order Concurrent Constraint Programming. </title> <booktitle> In Logic Programming: Proceedings of the 1994 International Symposium. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Thereby, solve/2 replicates the solve-combinator of Oz <ref> [SS94] </ref>. Henceforth, branch-and-bound techniques and similar can be programmed at source-level. <p> We analyze * the efficiency of the FD solver, * the effect of the optimizations exploited, and * the difference in speed between AGENTS and clp (FD). Furthermore, AGENTS is compared with Oz, since Oz <ref> [Smo94, SS94, MMPS95] </ref> provides the same basic notions for deep guards as AKL does, and we compare their performance with respect to finite domain constraints and guard programming. In this comparison, the copying-based labeling is used. <p> Similar to AKL, Oz provides deep guards, and the same three guard operators for conditional, committed and nondeterminate choice are included. The language is higher-order which enables a theoretically appealing treatment of objects and inheritance [Smo94]. Oz includes a combinator for encapsulated search <ref> [SS94] </ref>, which makes many search strategies, including depth-first, breadth-first, and branch-&- bound to be programmable at source level. Furthermore, by providing primitives for accessing information related to finite domain variables, heuristics such as first-fail can also be programmed at Oz level [MPSW95].
Reference: [St-a94] <author> G. St-almarck. </author> <title> A Proof Theoretic Concept of Tautological Hardness. </title> <type> Unpublished manuscript, </type> <year> 1994. </year>
Reference-contexts: They are trivially decidable, however, many finite domain problems are NP-complete. Thus, no general efficient method exists which solves such problems automatically. However, in practice, many problem instances belonging to this class can in fact be solved in polynomial time <ref> [GJ79, PS82, HSD92b, St-a94] </ref>. Propagation-based algorithms [Mac77] for simplifying a finite domain problem use the logical and arithmetical semantics of the relations to eliminate inconsistent values and tuples of values from the solution space of the problem. <p> This can be crucial to the ef ficiency [HD91]. * Different constraint systems can be combined which again can improve the efficiency and overall behavior. In particular, propositional and arithmetic reasoning are naturally merged <ref> [St-a94] </ref>. As a consequence: 1.3 Glass-box Systems 3 * Development time of constraint programs is short. Typically, constraint programs are between 5 and 10 times shorter than their im perative counterpart. * Maintenance and refinement of constraint programs is manageable. <p> There should be no conceptual nor operational difference between assigning a constraint to be true/false from assigning a variable some values. This has previously been shown to be extremely effective for propositional logic <ref> [St-a94] </ref>, and by combining our work on FDC, with such propagation for propositional expressions, a more powerful propagation algorithm is achieved. Secondly, a constraint programming language should allow the programmer to analyze the problem at hand.
Reference: [Ued85] <author> K. Ueda. </author> <title> Guarded Horn Clauses. </title> <type> Technical Report TR-103, </type> <institution> ICOT, </institution> <month> June </month> <year> 1985. </year>
Reference-contexts: Its constraint system treats rational trees, lists, numbers and booleans, and showed the way for much research to come. GHC is a concurrent logic programming language which introduced a clean model for guards, suspensions, and commit <ref> [Ued85] </ref>, which was brought over into the design of AKL [JH91]. Today, however, the developments of the systems have diverged, where the GHC research is directed towards the flat part of the language, and the AKL research concerns more interoperability, distribution, and parallelism.
Reference: [War83] <author> David H.D. Warren. </author> <title> An abstract prolog instruction set. </title> <type> Technical Report Technical Note 309, </type> <institution> SRI International, </institution> <year> 1983. </year>
Reference-contexts: In future versions of the compiler, however, also the indexical scheme will be used (Section 4.2). The abstract machine of AGENTS is an extension of the WAM <ref> [War83] </ref>, with instructions for selecting clauses, saving information on the local stack, constructing terms, guarding the clause, and for executing procedure calls. For a full explanation see [Jan94].
Reference: [WP77] <author> D. H. Warren and L. M. Pereira. </author> <title> PROLOG-The Language and Its Implementation Compared with LISP. </title> <booktitle> In Proceedings of the Symposium on Artifical Intelligence and Programming Languages. SIGPLAN Notices 12(8), </booktitle> <year> 1977. </year>
Reference-contexts: We focus on the FD-part, since AKL has already been thoroughly described and analyzed elsewhere [Jan94]. 11.2 Constraint Programming Systems 139 11.2.1 Forerunners There are four noteable forerunners of concurrent finite domain constraint programming; Prolog, Alice, GHC, and Prolog-III. Prolog was the first efficient programming language based on resolution <ref> [CKPR73, WP77] </ref>, and has since its invention been extended and refined into being a versatile and powerful programming language [AAB + 93].
References-found: 85

