URL: ftp://cse.ogi.edu/pub/pacsoft/papers/TypeSafeMP.ps
Refering-URL: http://www.cse.ogi.edu/~hook/new/papers.htm
Root-URL: http://www.cse.ogi.edu
Title: Type Safe Meta-Programming  
Author: Tim Sheard James Hook 
Date: November 15, 1994  
Address: P.O. Box 91000 Portland, OR 07291-1000 USA  
Affiliation: Oregon Graduate Institute of Science Technology  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Jeffrey Bell et al. </author> <title> Software design for reliability and reuse: A proof-of-concept demonstration. </title> <booktitle> In Proceedings of TRI-Ada 94, </booktitle> <publisher> ACM press, </publisher> <year> 1994. </year> <month> 14 </month>
Reference-contexts: Currently, generator construction technology is in its infancy. This technology has been unable to take exploit the advantages of strongly-typed systems, one of the major advances in programming language technology in the past decade. Transferring these benefits to program generation systems is a major challenge <ref> [1] </ref>. We have demonstrated the the current state of affairs need no longer persist.
Reference: [2] <author> N. G. de Bruijn. </author> <title> Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser theorem. </title> <journal> Indagaciones Mathematische, </journal> <volume> 34 </volume> <pages> 381-392, </pages> <year> 1972. </year> <note> Also appeared in the Proceedings of the Koninklijke Nederlandse Akademie van Wetenschappen, Amsterdam, series A, 75(5). </note>
Reference-contexts: This is discussed further in Section 6. Building object abstractions via code to code functions is similar in style and purpose to using de Bruijn indicies in lambda calculus <ref> [2, 3] </ref>). 3 Semantics The traditional explanation of reflection involves an infinite tower [4, 6, 7, 23] of interpretors. We believe there is a much simpler explanation. This explanation involves a simple interpretor written in a typed language. The interpretor itself uses no meta-programming facilities. <p> We have demonstrated the the current state of affairs need no longer persist. Our system synthesizes several important ideas: * A two level language, a la Nielson and Nielson [21], which makes explicit the phase dis tinction between program generation time and runtime. * A de Bruijn indices like <ref> [2, 3] </ref> notation for construction of typeable object abstractions in a rich modern language. * Using the inductive structure of index sets to guide an inference algorithm that can type an indexed family of programs generated by a single generator.
Reference: [3] <author> N. G. de Bruijn. </author> <title> Lambda calculus with name-free formulas involving symbols that represent reference transforming mappings. </title> <booktitle> In Proceedings of the Koninklijke Nederlandse Akaemie van Wetenschappen, </booktitle> <pages> pages 348-356, </pages> <address> Amsterdam, </address> <booktitle> series A, </booktitle> <volume> volume 81(3), </volume> <month> September </month> <year> 1978. </year>
Reference-contexts: This is discussed further in Section 6. Building object abstractions via code to code functions is similar in style and purpose to using de Bruijn indicies in lambda calculus <ref> [2, 3] </ref>). 3 Semantics The traditional explanation of reflection involves an infinite tower [4, 6, 7, 23] of interpretors. We believe there is a much simpler explanation. This explanation involves a simple interpretor written in a typed language. The interpretor itself uses no meta-programming facilities. <p> We have demonstrated the the current state of affairs need no longer persist. Our system synthesizes several important ideas: * A two level language, a la Nielson and Nielson [21], which makes explicit the phase dis tinction between program generation time and runtime. * A de Bruijn indices like <ref> [2, 3] </ref> notation for construction of typeable object abstractions in a rich modern language. * Using the inductive structure of index sets to guide an inference algorithm that can type an indexed family of programs generated by a single generator.
Reference: [4] <author> Olivier Danvy and Karoline Malmkjr. </author> <title> Intensions and extensions in a reflective tower. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 327-341. </pages> <publisher> ACM Press, </publisher> <year> 1988. </year>
Reference-contexts: This is discussed further in Section 6. Building object abstractions via code to code functions is similar in style and purpose to using de Bruijn indicies in lambda calculus [2, 3]). 3 Semantics The traditional explanation of reflection involves an infinite tower <ref> [4, 6, 7, 23] </ref> of interpretors. We believe there is a much simpler explanation. This explanation involves a simple interpretor written in a typed language. The interpretor itself uses no meta-programming facilities.
Reference: [5] <author> Catherine Dubois, Francis Rouaix, and Pierre Weis. </author> <title> Extensional Polymorphism. </title> <booktitle> To appear in the 22th Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: I.e. it may not be possible to determine what expression will be produced, but we can determine its type statically. Recent results in related areas <ref> [20, 19, 11, 5] </ref> suggest this as a promising avenue of research. It is the third solution we pursue. Meta-ml has been designed carefully so that terms can be completely typed with a two level type system [21].
Reference: [6] <author> D. P. Friedman and M. Wand. </author> <title> Reification: Reflection without metaphysics. </title> <booktitle> In Proc. 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 348-355. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1984. </year>
Reference-contexts: This is discussed further in Section 6. Building object abstractions via code to code functions is similar in style and purpose to using de Bruijn indicies in lambda calculus [2, 3]). 3 Semantics The traditional explanation of reflection involves an infinite tower <ref> [4, 6, 7, 23] </ref> of interpretors. We believe there is a much simpler explanation. This explanation involves a simple interpretor written in a typed language. The interpretor itself uses no meta-programming facilities.
Reference: [7] <author> D. P. Friedman and M. Wand. </author> <title> The mystery of the tower revealed: A non-reflective description of the reflective tower. </title> <booktitle> In Proc. 1986 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 298-307. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1986. </year>
Reference-contexts: This is discussed further in Section 6. Building object abstractions via code to code functions is similar in style and purpose to using de Bruijn indicies in lambda calculus [2, 3]). 3 Semantics The traditional explanation of reflection involves an infinite tower <ref> [4, 6, 7, 23] </ref> of interpretors. We believe there is a much simpler explanation. This explanation involves a simple interpretor written in a typed language. The interpretor itself uses no meta-programming facilities.
Reference: [8] <author> David A. Fisher. </author> <title> [9] uoted from: Software's Chronic Crisis, by W. Wayt Gibbs. </title> <booktitle> [10] cientific American, </booktitle> <month> September </month> <year> 1994 </year>
Reference: [11] <author> Robert Harper and Greg Morrisett. </author> <title> Compiling Polymorphism Using Intensional Type Analysis. </title> <booktitle> To appear in the 22th Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1995. </year> <note> Also published as Fox Memorandum CMU-CS-FOX-94-07 </note>
Reference-contexts: I.e. it may not be possible to determine what expression will be produced, but we can determine its type statically. Recent results in related areas <ref> [20, 19, 11, 5] </ref> suggest this as a promising avenue of research. It is the third solution we pursue. Meta-ml has been designed carefully so that terms can be completely typed with a two level type system [21].
Reference: [12] <author> Eugene Kohlbecker and Mitch Wand. Macro-by-Example, </author> <title> Deriving Syntactic Transformations from their Specifications. </title> <booktitle> In Fourteenth Annual ACM Symposium on Principles of Programming languages. </booktitle> <address> Munich, West Germany, </address> <month> Jan. </month> <year> 1987 </year>
Reference-contexts: This is the case, so the generator is well typed. 12 6 Macros Done Right Traditional macro systems are prone to problems related to variable capture <ref> [12] </ref>. Macro expansion may inadvertently "capture" a variable declared in an outer scope.
Reference: [13] <author> Eugene Kohlbecker, Daniel Friedman, Matthias Felleisen, and Bruce Duba. </author> <title> Hygienic Macro Expansion. </title> <booktitle> The 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <address> Cambridge, Ma. </address> <month> August </month> <year> 1986 </year>
Reference-contexts: This is the case, so the generator is well typed. 12 6 Macros Done Right Traditional macro systems are prone to problems related to variable capture [12]. Macro expansion may inadvertently "capture" a variable declared in an outer scope. Consider the example (from Kohlbecker, et. al. <ref> [13] </ref>) defining an OR macro. macro OR x y = let val v = x in if v then v else y end The example is not in our language, but illustrates the problem. The let is used to avoid recomputing x.
Reference: [14] <author> Xavier Leroy and Michel Mauny. </author> <title> Dynamics in ML. </title> <journal> Journal of Functional Programming 3(4) 431-463,1994 </journal>
Reference-contexts: The programmer must declare the type of the produced term, and at run-time the type is dynamically checked. This scheme has been imple mented in the CAML language by using its type dynamic <ref> [14] </ref>. * Restrict the language so that all the reflective operators have inputs which are statically known at compile-time. Thus evaluation of escaped expressions can always be done at compile-time. The resulting produced term can be typed like any other term.
Reference: [15] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year> <month> 15 </month>
Reference-contexts: It has not, however, been integrated into strongly-typed languages. The use of strongly-typed languages has many important advantages, including the representation invariants of strong typing which guarantee that type consistent programs will not go wrong <ref> [15] </ref> and the static detection of many programmer errors by the complier. This paper advances a general theory of "generator" systems which is used to attack several well known problems associated with the use of program generators. * Reflection.
Reference: [16] <author> Robin Milner and Mads Tofte. </author> <title> Commentary on the Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: We give a precise meaning to our language by giving it an operational semantics through the use of an interpretor. The language we write our interpretor in is Standard ML <ref> [16, 17] </ref>. The interpreted language is called meta-ml. It is a subset of Standard ML with a few additional meta-programming capabilities. Excluding the meta-programming capabilities, meta-ml has a completely standard semantics. It includes variables, applications, integer and string constants, pairs, simple abstractions, and abstractions over pairs and an if expression.
Reference: [17] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: We give a precise meaning to our language by giving it an operational semantics through the use of an interpretor. The language we write our interpretor in is Standard ML <ref> [16, 17] </ref>. The interpreted language is called meta-ml. It is a subset of Standard ML with a few additional meta-programming capabilities. Excluding the meta-programming capabilities, meta-ml has a completely standard semantics. It includes variables, applications, integer and string constants, pairs, simple abstractions, and abstractions over pairs and an if expression.
Reference: [18] <author> Robert Muller. </author> <title> M-LISP: Its natural semantics and equational logic. </title> <booktitle> In Proceedings of the Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 234-242. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: 'a exp | Vcode of value exp; | If of 'a exp * 'a exp * 'a exp | Escape of 'a exp fun embed (Vcode x) = x | Brack of 'a exp | embed _ = raise ill_typed; semantic domain (of type code) back into the syntactic domain <ref> [18] </ref>. The exception ill typed should never be raised while interpreting a well typed meta-ml program. Section 4 describes how meta-ml programs are typed.
Reference: [19] <author> Neal Nelson, </author> <title> Primitive Recursive Functionals with Dependant Types. </title> <booktitle> In Mathematical Foundations of Programming Semantics LNCS 598, </booktitle> <publisher> Springer-Verlag, </publisher> <month> March </month> <year> 1991. </year>
Reference-contexts: I.e. it may not be possible to determine what expression will be produced, but we can determine its type statically. Recent results in related areas <ref> [20, 19, 11, 5] </ref> suggest this as a promising avenue of research. It is the third solution we pursue. Meta-ml has been designed carefully so that terms can be completely typed with a two level type system [21].
Reference: [20] <author> Neal Nelson, </author> <title> Type Inference and Reconstruction for First Order Dependent Types. </title> <type> Ph.D. Thesis, </type> <institution> Oregon Graduate Institute, </institution> <note> expected 1994. </note>
Reference-contexts: I.e. it may not be possible to determine what expression will be produced, but we can determine its type statically. Recent results in related areas <ref> [20, 19, 11, 5] </ref> suggest this as a promising avenue of research. It is the third solution we pursue. Meta-ml has been designed carefully so that terms can be completely typed with a two level type system [21].
Reference: [21] <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> Two-Level Functional Languages. </title> <publisher> Cambridge University Press, </publisher> <year> 1992 </year>
Reference-contexts: Recent results in related areas [20, 19, 11, 5] suggest this as a promising avenue of research. It is the third solution we pursue. Meta-ml has been designed carefully so that terms can be completely typed with a two level type system <ref> [21] </ref>. Let valid types be formed by the following rules: t ::= int jstring j bool j t fi t 0 j t ! t 0 j hti where hti is the type of a piece of code with type t. <p> Transferring these benefits to program generation systems is a major challenge [1]. We have demonstrated the the current state of affairs need no longer persist. Our system synthesizes several important ideas: * A two level language, a la Nielson and Nielson <ref> [21] </ref>, which makes explicit the phase dis tinction between program generation time and runtime. * A de Bruijn indices like [2, 3] notation for construction of typeable object abstractions in a rich modern language. * Using the inductive structure of index sets to guide an inference algorithm that can type an
Reference: [22] <author> Frank Pfenning and Peter Lee. </author> <title> Metacircularity in the polymorphic -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 89 </volume> <pages> 137-159, </pages> <year> 1991. </year>
Reference-contexts: Since the computation that produces this term can be arbitrarily complex it is not possible to always determine statically if the term so produced can be assigned a type <ref> [22] </ref>. There are at least three ways to address this dilemma. 7 * Use a form of dynamic typing. The programmer must declare the type of the produced term, and at run-time the type is dynamically checked.
Reference: [23] <author> Jim des Rivieres and Brian Cantwell Smith. </author> <booktitle> The implementation of procedurally reflective languages. In Proceedings of the 1984 Lisp and Functional Programming Conference. ACM, </booktitle> <year> 1984. </year>
Reference-contexts: This is discussed further in Section 6. Building object abstractions via code to code functions is similar in style and purpose to using de Bruijn indicies in lambda calculus [2, 3]). 3 Semantics The traditional explanation of reflection involves an infinite tower <ref> [4, 6, 7, 23] </ref> of interpretors. We believe there is a much simpler explanation. This explanation involves a simple interpretor written in a typed language. The interpretor itself uses no meta-programming facilities.
Reference: [24] <author> Tim Sheard. </author> <title> Guide to using CRML: Compile-time Reflective ML. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: Thus evaluation of escaped expressions can always be done at compile-time. The resulting produced term can be typed like any other term. This scheme has been implemented in the CRML language <ref> [24] </ref> and is similar to what happens in macro systems. * Restrict the language so that escaped expressions cannot be arbitrary computations, but only ones for which the type of the produced term can be statically determined.
Reference: [25] <author> Tim Sheard, and Leonidas Fegaras. </author> <title> A Fold for All Seasons. </title> <booktitle> In Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year> <pages> pp 233-242 </pages>
Reference-contexts: This technique can be generalized to many inductive types by extending the type system by adding a TypeFold for that type. This TypeFold can be used to type expressions which fold over that type. In previous work <ref> [25] </ref> we have shown how to construct folds for an extremely large class of inductively defined types.
References-found: 23

