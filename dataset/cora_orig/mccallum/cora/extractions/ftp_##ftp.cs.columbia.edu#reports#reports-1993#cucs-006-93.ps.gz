URL: ftp://ftp.cs.columbia.edu/reports/reports-1993/cucs-006-93.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1993.html
Root-URL: http://www.cs.columbia.edu
Email: kaiser@cs.columbia.edu  
Title: Cooperative Transactions for Multi-User Environments  
Author: Gail E. Kaiser 
Note: To appear as a chapter in Won Kim (ed.), Modern Database Management: Object-Oriented and Multidatabase Technologies, ACM Press.  
Date: March 1993 (revised December 1993)  
Address: 500 West 120th Street New York, NY 10027 212-939-7081/fax:212-666-0140  
Affiliation: Columbia University Department of Computer Science  
Pubnum: CUCS-006-93  
Abstract: This chapter surveys extended transaction models proposed to support long duration, interactive and/or cooperative activities in the context of multi-user software development and CAD/CAM environments. Many of these are variants of the checkout model, which addresses the long duration and interactive nature of the activities supported by environments but still isolates environment users, making it difficult for them to collaborate while their activities are in progress. However, a few cooperative transaction models have been proposed to facilitate collaboration, usually while maintaining some guarantees of consistency. 
Abstract-found: 1
Intro-found: 1
Reference: [Adams et al. 89] <author> Evan W. Adams, Masahiro Honda and Terrence C. Miller. </author> <title> Object Management in a CASE Environment. </title> <booktitle> In 11th International Conference on Software Engineering, </booktitle> <pages> pages 154-163. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> Pittsburgh PA, </address> <month> May, </month> <year> 1989. </year>
Reference-contexts: from creating branching versions, since all the checked in copies add versions to the original branch. (NSE uses the SCCS tool internally to manage these versions.) In effect, the validation phase of the conventional optimistic concurrency control scheme is modified to replace rollback of conflicting transactions with merging of updates. <ref> [Adams et al. 89] </ref> refers to this approach as copy/modify/merge. (a) Before Alice Checks In (b) After Alice Checks In Illustrating this approach, either Bob or Alice creates a top-level environment ENV to fix X and X,Y Y. Bob then creates his own child environment ENV to edit X.

Reference: [Davies 73] <author> Charles T. Davies, Jr. </author> <title> Recovery Semantics for A DB/DC System. </title> <booktitle> In 28th ACM National Conference, </booktitle> <pages> pages 136-141. </pages> <address> Atlanta GA, </address> <month> August, </month> <year> 1973. </year>
Reference-contexts: We are primarily concerned with concurrency control and do not explicitly address failure recovery, although recovery of some sort is usually required. Most of the papers mentioned are relatively recent, but note that many of their ideas were foreshadowed in the 1970's <ref> [Davies 73, Davies 78] </ref>.
Reference: [Davies 78] <author> C.T. Davies, Jr. </author> <title> Data processing spheres of control. </title> <journal> IBM Systems Journal 17(2) </journal> <pages> 179-198, </pages> <year> 1978. </year>
Reference-contexts: We are primarily concerned with concurrency control and do not explicitly address failure recovery, although recovery of some sort is usually required. Most of the papers mentioned are relatively recent, but note that many of their ideas were foreshadowed in the 1970's <ref> [Davies 73, Davies 78] </ref>.

Reference: [Gray et al. 75] <author> J. Gray, R. Lorie and G. Putzolu. </author> <title> Granularity of Locks and Degrees of Consistency in a Shared Database. </title> <booktitle> In International Conference on Very Large Data Bases, </booktitle> <pages> pages 428-451. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1975. </year>
Reference-contexts: The reader is assumed to be familiar with the conventional atomic transaction model [Bernstein et al. 87] and its main implementation mechanisms, such as two-phase locking [Eswaran et al. 76], multi-version timestamp ordering [Reed 78], optimistic validation [Kung and Robinson 81], multi-granularity locking <ref> [Gray et al. 75] </ref>, and nested transactions [Moss 82]. We start with a small motivating example, which will be referred to throughout the chapter.
Reference: [Heineman 93] <author> George T. Heineman. </author> <title> A Transaction Manager Component for Cooperative Transaction Models. </title> <type> Technical Report CUCS-017-93, </type> <institution> Columbia University Department of Computer Science, </institution> <month> July, </month> <year> 1993. </year>
Reference-contexts: She concedes, though, that the implementation is unwieldy and unlikely to scale up. [Barghouti 92] suggested condition/action rules for recognizing and resolving transaction conflicts. A proof-of-concept implementation was included in the Marvel 3.1 software development environment, which also supports user-defined lock modes [Ben-Shaul et al. 93]. <ref> [Heineman 93] </ref> is currently developing a formalism which provides a superset of the repair primitives used in the actions to support (at least) dynamic restructuring and participant transactions; it remains to be seen whether this approach will be practical. Thus cooperation modeling remains an important open problem for future research.
Reference: [Honda 88] <author> M. Honda. </author> <title> Support for Parallel Development in the Sun Network Software Environment. </title> <booktitle> In 2nd International Workshop on Computer-Aided Software Engineering, </booktitle> <pages> pages 5-5 - 5-7. </pages> <note> 1988. </note> <author> [Hornick and Zdonik 87] Mark F. Hornick and Stanley B. Zdonik. </author> <title> A Shared, Segmented Memory System for an Object-Oriented Database. </title> <journal> ACM Transactions on Office Automation Systems 5(1) </journal> <pages> 70-95, </pages> <month> January, </month> <note> 1987. </note> <author> [Horwitz et al. 89]Susan Horwitz, Jan Prins and Thomas Reps. </author> <title> Integrating Noninterfering Versions of Programs. </title> <journal> ACM Transactions on Programming Languages and Systems </journal> 11(3):345-387, July, 1989. 
Reference-contexts: Note this is different from domain relative addressing, where transactions may read the same version but always write distinct versions. Like Infuse, the Network Software Environment (NSE) <ref> [Honda 88] </ref> operates on a hierarchical database structure. Each node of this structure is called an environment (not to be confused with a software development or CAD/CAM environment).
Reference: [Johnson 78] <author> S.C. Johnson. </author> <title> Lint, a C Program Checker. Unix Programmer's Manual. </title> <institution> AT&T Bell Laboratories, </institution> <year> 1978. </year>
Reference-contexts: The module is the unit of checkout/checkin, and additional modules can be added to the user's experimental database at any time. When the user requests checkin of his or her experimental database, Smile analyzes all its modules using the Lint tool <ref> [Johnson 78] </ref>, recompiles them, and links them together with the unmodified modules 6 in the main database. If any errors are detected during this process, the checkin operation is automatically aborted; the user is expected to repair the problems and try again.
Reference: [Kaiser 90] <author> Gail E. Kaiser. </author> <title> A Flexible Transaction Model for Software Engineering. </title> <booktitle> In 6th International Conference on Data Engineering, </booktitle> <pages> pages 560-567. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> Los Angeles CA, </address> <month> February, </month> <year> 1990. </year>
Reference-contexts: A related approach is to define each (long) transaction as a participant in a specified domain, where participant transactions in the same domain need not appear to have been performed in some serial order with respect to each other <ref> [Kaiser 90] </ref>. (Participation domains should not be confused the domains of domain relative addressing, section 3.1.2.). A domain would typically represent the set of transactions controlled by the users collaborating on a common task.
Reference: [Kaiser 91] <author> Gail E. Kaiser. </author> <title> Interfacing Cooperative Transactions to Software Development Environments. </title> <journal> Office Knowledge Engineering 4(1) </journal> <pages> 56-78, </pages> <month> February, </month> <year> 1991. </year>
Reference-contexts: A domain would typically represent the set of transactions controlled by the users collaborating on a common task. However, unlike transaction groups, there is no implication that all the transactions in a domain commit together, or even that all of them commit (some may abort) <ref> [Kaiser 91] </ref>. Those transactions that are not participants in a particular domain are considered observers with respect to that domain. Observer transactions must be serialized with respect to the transactions in the domain, and furthermore should not view any anomalous behavior due to the interactions among participants.

Reference: [Katz 90] <author> Randy H. Katz. </author> <title> Toward a Unified Framework for Version Modeling in Engineering Databases. </title> <journal> ACM Computing Surveys 22(4) </journal> <pages> 375-408, </pages> <month> December, </month> <year> 1990. </year>
Reference-contexts: Basic Checkout Model The basic checkout model, in tandem with versions and configurations, are supported by numerous commercially marketed tools for software development (e.g., Adele [Estublier et al. 84], DSEE [Leblang and Chase 87], SMS [Schwanke et al. 89]). <ref> [Katz 90] </ref> gives a comprehensive overview of version and configuration systems oriented towards CAD/CAM environments. Most of these provide some of the capabilities outlined here, but in the text we cite only representative (and often early) examples. 3.1.1.
Reference: [Kim et al. 91] <author> Won Kim, Nat Ballou, Jorge F. Garz and Darrell Woelk. </author> <title> A Distributed Object-Oriented Database System Supporting Shared and Private Databases. </title> <journal> ACM Transactions on Information Systems 9(1) </journal> <pages> 31-51, </pages> <month> January, </month> <year> 1991. </year>
Reference-contexts: The owner of the reservation can decide to let other users access and even modify that object (e.g., through permissions granted on the private work area via the file system). Itasca (previously ORION-2 <ref> [Kim et al. 91] </ref>) solves the second problem, through a distributed database incorporating private databases, into which objects are checked out from the shared database, as well as a query facility that distinguishes between private and shared databases. There is no access to objects outside of system control.

Reference: [Moss 82] <author> J. Eliot B. Moss. </author> <title> Nested Transactions and Reliable Distributed Computing. </title> <booktitle> In 2nd Symposium on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 33-39. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> Pittsburgh PA, </address> <month> July, </month> <note> 1982. </note> <author> [Perry and Kaiser 91] Dewayne E. Perry and Gail E. Kaiser. </author> <title> Models of Software Development Environments. </title> <journal> IEEE Transactions on Software Engineering 17(3) </journal> <pages> 283-295, </pages> <month> March, </month> <year> 1991. </year>
Reference-contexts: The reader is assumed to be familiar with the conventional atomic transaction model [Bernstein et al. 87] and its main implementation mechanisms, such as two-phase locking [Eswaran et al. 76], multi-version timestamp ordering [Reed 78], optimistic validation [Kung and Robinson 81], multi-granularity locking [Gray et al. 75], and nested transactions <ref> [Moss 82] </ref>. We start with a small motivating example, which will be referred to throughout the chapter.
Reference: [Pu et al. 88] <author> Calton Pu, Gail E. Kaiser and Norman Hutchinson. </author> <title> Split-Transactions for Open-Ended Activities. </title> <editor> In Francois Bancilhon and David J. Dewitt (editor), </editor> <booktitle> 14th International Conference on Very Large Data Bases, </booktitle> <pages> pages 26-37. </pages> <publisher> Morgan Kaufman, </publisher> <address> Los Angeles CA, </address> <month> August, </month> <year> 1988. </year>
Reference-contexts: One application of split-transaction is to commit one of the new transactions in order to release all of its resources so that they can be acquired by other transactions <ref> [Pu et al. 88] </ref>.
Reference: [Reed 78] <author> David P. Reed. </author> <title> Naming and Synchronization in a Decentralized Computer System. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <month> September, </month> <year> 1978. </year>
Reference-contexts: The reader is assumed to be familiar with the conventional atomic transaction model [Bernstein et al. 87] and its main implementation mechanisms, such as two-phase locking [Eswaran et al. 76], multi-version timestamp ordering <ref> [Reed 78] </ref>, optimistic validation [Kung and Robinson 81], multi-granularity locking [Gray et al. 75], and nested transactions [Moss 82]. We start with a small motivating example, which will be referred to throughout the chapter. <p> It is necessary to group sets of versions that are consistent with each other or otherwise used together into configurations. [Walpole et al. 88a] introduced domain relative addressing, which supports versions of configurations by extending <ref> [Reed 78] </ref>'s notion of time relative addressing (multi-version concurrency control). Whereas Reed's algorithm synchronizes accesses to objects with respect to their timestamp, domain relative addressing does so with respect to their ``domain''.
Reference: [Rochkind 75] <author> M. J. Rochkind. </author> <title> The Source Code Control System. </title> <journal> IEEE Transactions on Software Engineering SE-1:364-370, </journal> <year> 1975. </year>
Reference-contexts: Versions The simplest form of coordination among members of a design or development team is to control the access to shared objects so that only one user can modify any particular object at a time. The checkout/checkin approach has been implemented by widely-used version control tools like SCCS <ref> [Rochkind 75] </ref> and RCS [Tichy 85]. Each object is considered to be a collection of multiple versions. A version represents the state of the object at some time in the history of its development.
Reference: [Salem 93] <author> Kenneth Salem. </author> <title> Impleemnting Extended Transaction Models Using Transaction Groups. </title> <type> Technical Report CS-TR-3051, </type> <institution> University of Maryland Department of Computer Science, </institution> <year> 1993. </year> <note> 21 [Schwanke et al. 89] R.W. Schwanke, E.S. </note> <author> Cohen, R. Gluecker, W.M. Hasling, D.A. Soni and M.E. Wagner. </author> <title> Configuration Management in BiiN SMS. </title> <booktitle> In 11th International Conference on Software Engineering, </booktitle> <pages> pages 383-393. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> Pittsburgh PA, </address> <month> May, </month> <year> 1989. </year>
Reference-contexts: Further, the formalism should be executable in the sense that it would be possible to prototype constructed models, albeit not necessarily in the most efficient manner. For example, <ref> [Salem 93] </ref> proposed a toolkit that seems feasible for implementing a range of extended transaction models, but concerned only with long duration and to some extent interactive control, without the possibility of cooperation.
Reference: [Skarra 91] <author> Andrea H. Skarra. </author> <title> Localized Correctness Specifications for Cooperating Transactions in an Object-Oriented Database. </title> <journal> Office Knowledge Engineering 4(1) </journal> <pages> 79-106, </pages> <month> February, </month> <year> 1991. </year>
Reference-contexts: The ACTA framework [Chrysanthis and Ramamritham 90] meets the first criterion, but was never intended to be executable. <ref> [Skarra 91] </ref> proposed a formalism, as a sample input/output protocol for 18 transaction groups, for recognizing required and prohibited patterns of transaction interactions using finite state automata.
Reference: [Tichy 85] <author> Walter F. Tichy. </author> <title> RCS A System for Version Control. </title> <journal> Software Practice & Experience 15(7) </journal> <pages> 637-654, </pages> <month> July, </month> <year> 1985. </year>
Reference-contexts: The checkout/checkin approach has been implemented by widely-used version control tools like SCCS [Rochkind 75] and RCS <ref> [Tichy 85] </ref>. Each object is considered to be a collection of multiple versions. A version represents the state of the object at some time in the history of its development.

Reference: [Walter 84] <author> B. Walter. </author> <title> Nested Transactions with Multiple Commit Points: An Approach to the Structuring of Advanced Database Applications. </title> <editor> In Umeshwar Dayal, G. Schlageter and Lim Huat Seng (editors), </editor> <booktitle> 10th International Conference on Very Large Data Bases, </booktitle> <pages> pages 161-171. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Singapore, </address> <month> August, </month> <year> 1984. </year>
Reference-contexts: Either all the changes made during the transaction are retained or none of them are. In contrast, the basic checkout model, Itasca and NSE all allow individual objects to be reserved and deposited independently, with no formal notion of maintaining consistency among multiple objects. Walter <ref> [Walter 84] </ref> proposes a middle ground with the basic structure of nested transactions but a more flexible relationship between parent and child transactions.
Reference: [Yeh et al. 87] <author> Show-way Yeh, Clarence Ellis, Aral Ege and Henry Korth. </author> <title> Performance Analysis of Two Concurrency Control Schemas for Design Environments. </title> <type> Technical Report STP-036-87, </type> <institution> MCC, </institution> <month> June, </month> <year> 1987 </year> . 
Reference-contexts: Two policies that use notification in conjunction with non-exclusive locks and versions were implemented in the Gordion system: immediate notification and delayed notification <ref> [Yeh et al. 87] </ref>. Immediate notification alerts the affected users of any attempt at conflicting access as soon as the conflict occurs.
References-found: 20

