URL: http://www.cs.man.ac.uk/~kung-kiu/pub/iclp93.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: kkl@cs.man.ac.uk  ornaghi@imiucca.csi.unimi.it  
Author: Lau Mario Ornaghi 
Address: Oxford Road, Manchester M13 9PL, United Kingdom  Via Comelico 39/41, Milano, Italy  
Affiliation: Department of Computer Science, University of Manchester  Dipartimento di Scienze dell'Informazione Universita' degli studi di Milano  
Note: Kung-Kiu  
Abstract: An Incompleteness Result for De- Abstract We formalise the derivation of logic programs from their specifications by deductive synthesis, and introduce the notion of uniform equivalence between logical systems. This enables us to present an incompleteness result for deductive synthesis of logic programs from first-order logic specifications. ductive Synthesis of Logic Programs
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Bundy, A. Smaill, and G. Wiggins. </author> <title> The synthesis of logic programs from inductive proofs. </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Proc. Esprit Symposium on Computational Logic, </booktitle> <pages> pages 135-149. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: See <ref> [1, 2] </ref> for instance. A more direct approach is to give the specification in the form of a set of axioms, and then to systematically derive a set of clauses which are logical consequences of these axioms. We shall call this approach deductive synthesis. 1 Examples include [5, 6, 9].
Reference: [2] <author> L. </author> <title> Fribourg. Extracting logic programs from proofs that use extended Prolog execution and induction. </title> <editor> In D.H.D. Warren and P. Szeredi, editors, </editor> <booktitle> Proc. 7 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 685-699. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year> <title> 20 Such a proof does not exist, otherwise we would get a uniform synthesis map, and hence absurdum. 21 Of course finding a better formulation of a problem could also give rise to more efficient solutions. 22 Our belief can be now based on intuitive reasons, and not necessarily on a formal proof. </title>
Reference-contexts: See <ref> [1, 2] </ref> for instance. A more direct approach is to give the specification in the form of a set of axioms, and then to systematically derive a set of clauses which are logical consequences of these axioms. We shall call this approach deductive synthesis. 1 Examples include [5, 6, 9].
Reference: [3] <author> L. Hallnas and P. Schroeder-Heister. </author> <title> A proof-theoretic approach to logic programming I. </title> <journal> J. Logic and Computation, </journal> <volume> 1(2), </volume> <pages> 261-283, </pages> <year> 1990. </year>
Reference-contexts: of computable functions corresponding to requirements on synthesis maps stronger than uniformity?" For example, can we isolate the polynomially computable functions as a particular class of synthesisable functions? 9 Conclusion Our approach in this paper can be broadly regarded as a proof-theoretic one, similar to that of Hallnas and Schroeder-Heister <ref> [3, 4] </ref>. We have for-malised deductive synthesis of logic programs from first-order specifications. We have also introduced and explained the concept of uniformity for logical systems, and related it to our model of deductive synthesis. Then we have shown that uniformity plays a central role in the issue of completeness.
Reference: [4] <author> L. Hallnas and P. Schroeder-Heister. </author> <title> A proof-theoretic approach to logic programming II. </title> <journal> J. Logic and Computation, </journal> <volume> 1(5), </volume> <pages> 635-660, </pages> <year> 1991. </year>
Reference-contexts: of computable functions corresponding to requirements on synthesis maps stronger than uniformity?" For example, can we isolate the polynomially computable functions as a particular class of synthesisable functions? 9 Conclusion Our approach in this paper can be broadly regarded as a proof-theoretic one, similar to that of Hallnas and Schroeder-Heister <ref> [3, 4] </ref>. We have for-malised deductive synthesis of logic programs from first-order specifications. We have also introduced and explained the concept of uniformity for logical systems, and related it to our model of deductive synthesis. Then we have shown that uniformity plays a central role in the issue of completeness.
Reference: [5] <author> A. Hansson and S.- A. </author> <title> Tarnlund. A natural programming calculus. </title> <booktitle> In Proc. IJCAI-79, </booktitle> <pages> pages 348-355, </pages> <year> 1979. </year>
Reference-contexts: See [1, 2] for instance. A more direct approach is to give the specification in the form of a set of axioms, and then to systematically derive a set of clauses which are logical consequences of these axioms. We shall call this approach deductive synthesis. 1 Examples include <ref> [5, 6, 9] </ref>. In this paper, we shall concentrate on deductive synthesis of logic programs.
Reference: [6] <author> C.J. </author> <title> Hogger. Derivation of logic programs. </title> <journal> Journal of the ACM, </journal> <volume> 28, </volume> <pages> 372-392, </pages> <year> 1981. </year>
Reference-contexts: See [1, 2] for instance. A more direct approach is to give the specification in the form of a set of axioms, and then to systematically derive a set of clauses which are logical consequences of these axioms. We shall call this approach deductive synthesis. 1 Examples include <ref> [5, 6, 9] </ref>. In this paper, we shall concentrate on deductive synthesis of logic programs. <p> We shall call this approach deductive synthesis. 1 Examples include [5, 6, 9]. In this paper, we shall concentrate on deductive synthesis of logic programs. Following Hogger <ref> [6, 7] </ref>, we represent a (logical) specification, by the pair hS; Gi, where S is a set of closed first-order axioms and G is a first-order 1 Note that Manna and Waldinger [12] use this term for proofs-as-programs. formula, called a goal. 2 hS; Gi specifies the problem of finding substitutions
Reference: [7] <author> C.J. </author> <title> Hogger. Introduction to Logic Programming. </title> <publisher> Academic Press, </publisher> <year> 1984. </year>
Reference-contexts: We shall call this approach deductive synthesis. 1 Examples include [5, 6, 9]. In this paper, we shall concentrate on deductive synthesis of logic programs. Following Hogger <ref> [6, 7] </ref>, we represent a (logical) specification, by the pair hS; Gi, where S is a set of closed first-order axioms and G is a first-order 1 Note that Manna and Waldinger [12] use this term for proofs-as-programs. formula, called a goal. 2 hS; Gi specifies the problem of finding substitutions <p> Finally, in Section 8 we discuss the relation between uniformity and completeness and present some open questions. 2 G may contain free variables, and corresponds to what Hogger <ref> [7] </ref> calls the principal specified relation. 2 Representation of Formal Systems In this section, we introduce some basic terminology for logical and mathematical systems and the notion of representability of a system in another one.
Reference: [8] <author> K.K. Lau and Y. Deville. </author> <title> Logic program synthesis a catalogue of methods. </title> <type> Technical Report, </type> <institution> Department of Computer Science, University of Manchester, </institution> <note> in preparation. </note>
Reference-contexts: Most notable among these are Clark, Hansson, Hogger, and Tarnlund. Automated (or semi-automated) synthesis, however, has only received serious attention much more recently. A preliminary survey, in the form of a catalogue, of logic program synthesis methods can be found in <ref> [8] </ref>. The goal of logic program synthesis is to systematically derive logic programs from their specifications.
Reference: [9] <author> K.K. Lau and S.D. Prestwich. </author> <title> Top-down synthesis of recursive logic procedures from first-order logic specifications. </title> <editor> In D.H.D. Warren and P. Szeredi, editors, </editor> <booktitle> Proc. 7 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 667-684. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: See [1, 2] for instance. A more direct approach is to give the specification in the form of a set of axioms, and then to systematically derive a set of clauses which are logical consequences of these axioms. We shall call this approach deductive synthesis. 1 Examples include <ref> [5, 6, 9] </ref>. In this paper, we shall concentrate on deductive synthesis of logic programs. <p> Finally, incompleteness is a negative result. However, our experience shows that for many `reasonable' specifications we can synthesise corresponding logic programs. We intend to study the positive aspects of deductive synthesis, i.e. to search for specialisations of our general model to mechanisable synthesis methods such as <ref> [9] </ref>. Acknowledgements We are grateful to the referees for their helpful and constructive comments.
Reference: [10] <author> K.K. Lau and M. Ornaghi. </author> <title> Towards a formal framework for deductive synthesis of logic programs. </title> <type> Technical Report UMCS-92-11-2, </type> <institution> Department of Computer Science, University of Manchester, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: For example, in the intermediate steps k &lt; n, we could consider a more general notion of program P k and a corresponding system SLD k extending SLD. A more detailed discussion can be found in <ref> [10] </ref>. Alternatively, we could use SLDNF. In this case, we have to obtain a final program P such that hComp fl (P ); Ans (g); SLDNF i is equivalent to the initial specification.
Reference: [11] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1987. </year>
Reference-contexts: Restrictions of systems will be called restricted systems. For such systems, the definitions of v and i are as before. 3 The Logical Systems SLD and SLDNF In this section we present the details of the systems SLD and SLDNF. We adopt the definitions and the formalism of <ref> [11] </ref>. <p> The set Comp fl (P N ) contains the following axioms: * Identity axioms (see <ref> [11] </ref>, p. 79). * Success axioms. For every normal clause C of P N , Cax (C) (defined as in the case of definite clauses) is a success axiom of Comp fl (P N ). * Default axioms. <p> The soundness of SLDNF means that SLDN F v CL. For every class of normal programs and goals for which a completeness result is known (e.g. hierarchical programs and allowed goals, see <ref> [11] </ref>), we can formulate completeness as shown in the case of SLD. 4 A Formalisation of Deductive Synthesis Now we explain a model of deductive synthesis, based on SLD and SLDNF systems, of definite or normal logic programs from specifications formalised by first order axiomatisations in classical logic.
Reference: [12] <author> Z. Manna and R. Waldinger. </author> <title> A deductive approach to program synthesis. </title> <journal> ACM TOPLAS, </journal> <volume> 2(1) </volume> <pages> 90-121, </pages> <month> Jan </month> <year> 1980. </year>
Reference-contexts: In this paper, we shall concentrate on deductive synthesis of logic programs. Following Hogger [6, 7], we represent a (logical) specification, by the pair hS; Gi, where S is a set of closed first-order axioms and G is a first-order 1 Note that Manna and Waldinger <ref> [12] </ref> use this term for proofs-as-programs. formula, called a goal. 2 hS; Gi specifies the problem of finding substitutions oe such that S ` Goe where Goe is the application of the substitution oe to the formula G. We call Goe an answer of G in S.
Reference: [13] <author> P. Miglioli and M. Ornaghi. </author> <title> A purely logical computing model: open proofs as programs. </title> <institution> Report of Gruppo di Elettronica e Cibernetica, University of Milan, </institution> <year> 1979. </year> <note> Available as a manuscript. </note>
Reference-contexts: Therefore :9y: T (e n ; e n ; y) is provable. Of course, for every natural n, such an e n exists. 16 A similar result was proven in <ref> [13] </ref>, though for a different purpose. We now prove that :9y: T (e n ; e n ; y) has a proof of degree greater than n by absurdum. Let be a proof of :9y: T (e n ; e n ; y) with degree n.
Reference: [14] <author> G. Takeuti. </author> <title> Proof Theory. </title> <booktitle> Studies in Logic and the Foundations of Mathematics 81, </booktitle> <publisher> North-Holland, </publisher> <year> 1975. </year>
Reference-contexts: sufficient to prove our result for 10 They could be infinite, the point is that there is an upper bound on the degree of the formulas and proofs involved. just one system; here we choose CL to be a system for classical logic enjoying cut-elimination, e.g. the sequent calculus of <ref> [14] </ref>. Using cut-elimination, we can prove LP v CL implies LP CL (7) as follows. 11 Since LP v CL, for every proof of LP, there is a proof of CL such that a () = a () and c () = c ().
Reference: [15] <author> A.S. Troelstra, </author> <title> editor. Metamathematical Investigation of Intuitionistic Arithmetic and Analysis. </title> <booktitle> Lecture Notes in Mathematics 344. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1973. </year>
Reference-contexts: Proof. The primitive recursive predicate "w is the Godel number of a proof of degree less than or equal to n of :9y: T (x; x; y)" can be expressed by a formula P rov n (w; x) of LN and (by the partial reflection principle, e.g. see <ref> [15] </ref>) is provable in PA. Moreover, since 9y: P rov n (y; x) is recursively enumerable, there is a numeral e n such that 8x: (9y: T (e n ; x; y) $ 9y: P rov n (y; x)) (11) is provable in PA.
Reference: [16] <author> A. Voronkov. </author> <title> On completeness of program synthesis systems. </title> <booktitle> Proc. </booktitle> <volume> CSL 91, </volume> <pages> pages 411-418. </pages> <publisher> LNCS 626. Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: L 2 is uniform iff there is a constant k such that, for every 2 P L 1 : dg (ae ()) k fi dg () : 9 Thus we deal with completeness with respect to specifications, as opposed to com pleteness with respect to (classes of) computable functions (e.g. <ref> [16] </ref>). To indicate that there is a uniform representation of L 1 in L 2 , we write L 1 L 2 . The relation is reflexive and transitive.
References-found: 16

