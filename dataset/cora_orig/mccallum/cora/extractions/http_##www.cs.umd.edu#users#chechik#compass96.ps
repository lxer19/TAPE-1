URL: http://www.cs.umd.edu/users/chechik/compass96.ps
Refering-URL: http://www.cs.toronto.edu/~chechik/publications.html
Root-URL: 
Email: fchechik, gannong@cs.umd.edu  
Phone: Tel. (301) 405-2671  
Title: Verification of Consistency Between Concurrent Program Designs and Their Requirements  
Author: Marsha Chechik John Gannon 
Address: College Park, MD 20742  
Affiliation: Computer Science Department University of Maryland  
Abstract: Writing requirements in a formal notation allows automatic assessment of such properties as ambiguity, consistency, and completeness. However, verifying that the properties expressed in the requirements are preserved in an implementation remains difficult. In our earlier work we described a technique for analyzing consistency of detailed program designs with their requirements. To ensure that our methods scale up to realistic systems, we need to develop compositional approaches. This paper describes a first step in this direction: a technique for analyzing concurrent program designs. We present a language for specifying detailed designs of concurrent programs and an analysis tool, Analyzer, which uses this language to build a finite-state abstraction of the design. This abstraction is compared with properties derived from the set of requirements to determine if the former is consistent with the latter. Some restrictions on the model and on the specification language enable Analyzer to verify global user-specified properties effectively. After a design is verified to be consistent with its requirements, an implementation can be written around the design constructs to reduce the likelihood of implementation errors. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, R. Sethi, and J. Ulman. </author> <booktitle> Compilers: Principles, Techniques, and Tools, Chapter 10. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: For clarity, we have ommited control-flow edges between buffers and the nodes using them. In the actual CDFG, there is a backward sequential edge for each synchronization edge. Our computation of system states at each node of the CDFG is similar to that for reaching definitions via dataflow techniques <ref> [1, 13, 22] </ref>. gen sets capture new values generated at each node of the CDFG. kill sets represent values that variables cannot have after each node.
Reference: [2] <author> T. Alspaugh, S. Faulk, K. Britton, R. Parker, D. Parnas, and J. Shore. </author> <title> "Software Requirements for the A-7E Aircraft". </title> <type> Technical report, </type> <institution> Naval Research Laboratory, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: In this section, we present the requirements and the program design languages and define what we mean by consistency between a design and its requirements. 2.1. Requirements The Software Cost Reduction (SCR) requirements notation <ref> [2, 15, 17] </ref> was developed by a research group at the Naval Research Laboratory. An SCR requirements specification models a system as a set of event-driven, state-transition machines. The machines' environment is abstracted as a set of monitored state variables and controlled state variables [24, 26].
Reference: [3] <author> J. Atlee. </author> <title> "Automated Analysis of Software Requirements". </title> <type> PhD thesis, </type> <institution> University of Maryland, College Park, Maryland, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: Mode transition table for the Manager. We assume that the requirements specification is correct, i.e., the specified properties have been verified with respect to the requirements (for example, using techniques in <ref> [3] </ref>). We defined a list of safety properties that we allow the user to specify. For example, reach (f ) indicates that the system should reach a state where f holds.
Reference: [4] <author> S. Caine and E. Gordon. </author> <title> "PDL: A Tool for Software Design". </title> <booktitle> In Proceedings of the National Computer Conference, </booktitle> <volume> volume 44, </volume> <pages> pages 271-276, </pages> <year> 1975. </year>
Reference: [5] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Verification of Requirements Implementations". </title> <booktitle> In Proceedings of the 1994 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 1-14, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: Designs are often expressed in special program design languages (PDLs)[4]. When a design is inspected, the reviewers seek to establish that it meets the requirements, and that it is complete and self-consistent [20]. In earlier work <ref> [5, 6] </ref>, we defined a notation which can be used as a PDL. The PDL's outer syntax is comprised of C control constructs, and its inner syntax is a set of special comments, called annotations, which describe local properties of requirements variables' values.
Reference: [6] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Analysis of Consistency Between Implementations and Requirements: A Case Study". </title> <booktitle> In Proceedings of 10th Annual Conference on Computer Assurance, </booktitle> <pages> pages 123-131, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Designs are often expressed in special program design languages (PDLs)[4]. When a design is inspected, the reviewers seek to establish that it meets the requirements, and that it is complete and self-consistent [20]. In earlier work <ref> [5, 6] </ref>, we defined a notation which can be used as a PDL. The PDL's outer syntax is comprised of C control constructs, and its inner syntax is a set of special comments, called annotations, which describe local properties of requirements variables' values. <p> Both systems cannot request permission at the same time due to the interleaving model. Mode class Manager starts in mode Stable, and both subsystems start in mode Done. The requirements designer may also specify a restricted set of system safety properties (see <ref> [6] </ref>). These properties can be local to one process or global to the whole system.
Reference: [7] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Analysis of Consistency Between Requirements and Designs". </title> <type> Technical report CS-TR-3394.1, </type> <institution> Dept. of CS, University of Maryland, College Park, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: For a complete treatment of events in CTL, please see <ref> [7] </ref>. on @T (In (SubSys2=S2Done)) (see Figure 2). <p> The last part of the notion of consistency is represented by user-specified properties, each of which can also be translated into a single-quantifier temporal logic formula (see <ref> [7] </ref>). 2.3. Detailed Design Our PDL was motivated by two factors: we wanted designs that look close to real programs, i.e., have control flow information, yet reflect changes to requirements variables. <p> Verification of User-Defined Local Properties. Algorithms for verifying local user-defined properties are the same as for sequential designs and appear in <ref> [7] </ref>. For example, reach (M anager = Grant2) involves only the Manager process, and thus is local to that process (see [8]).
Reference: [8] <author> M. Chechik and J. Gannon. </author> <title> "Verification of Consistency between Concurrent Program Designs and Their Requirements". </title> <type> Technical Report CS-TR-3554, </type> <institution> Dept. of CS, University of Maryland, College Park, </institution> <month> January </month> <year> 1996. </year> <note> (in preparation). </note>
Reference-contexts: Cond and RV sets for each buffer are the same, so only RV sets are listed. The CDFG with all sets calculated can be found in <ref> [8] </ref>. After a fixpoint is computed, Analyzer computes an intersection of RV and Cond values for each variable at every node, storing the result in this node's info set. <p> Each user-defined property is verified in a separate traversal of one or more FSMs. First, Analyzer determines processes on which it is sufficient to verify a particular property (see <ref> [8] </ref>). If a property can be verified on just one process, it is considered local. Otherwise, it is global. <p> Verification of User-Defined Local Properties. Algorithms for verifying local user-defined properties are the same as for sequential designs and appear in [7]. For example, reach (M anager = Grant2) involves only the Manager process, and thus is local to that process (see <ref> [8] </ref>). To verify this property, Analyzer searches FSM of the Manager process for a state where it is in mode Grant2, finds one (say, node 10) and decides that this property holds.
Reference: [9] <author> E. Clarke, E. Emerson, and A. Sistla. </author> <title> "Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: We say that a design is consistent with its requirements if it implements those and only those transitions specified in the requirements and preserves all of the requirements' safety properties. Analyzer automatically generates a set of global checks from the requirements which are equivalent to temporal logic <ref> [9] </ref> formulas capturing this notion of consistency, builds a finite-state abstraction of the design using dataflow analysis techniques, and uses a special-purpose model checking algorithm to determine if the formulas hold in the abstraction. <p> For example, we have a property asserting that there exists a state in which Manager is in mode Grant1 and an event @T (In (SubSys1=S1Done)) occurs, after which Manager is in mode Stable in one of its next states. In CTL <ref> [9] </ref>, a computational tree logic, a branching-time logic which permits explicit quantification over all possible futures, this property is expressed as EF (M anager = Grant1 ^ @T (In (SubSys1 = S1Done)) ^ EX (M anager = Stable)) Such properties ensure that all transitions specified in the requirements appear in the
Reference: [10] <author> M. B. Dwyer and L. A. Clarke. </author> <title> "Data Flow Analysis for Verifying Properties of Concurrent Programs". </title> <booktitle> In Proceedings of the Second ACM SIGSOFT Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 62-75, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: Most of the previous approaches to analysis of concurrent programs have generally abstracted away data values and their effects on control flow to concentrate on task interactions (e.g., <ref> [10, 11, 22, 12, 25, 23] </ref>). We perform dataflow analysis on values of requirements variables and include them into the property verification. The goal of our technique is to avoid building a global reachability graph.
Reference: [11] <author> J. Fischer and R. Gerber. </author> <title> "Compositional Model Checking of Ada Tasking Programs". </title> <booktitle> In Proceedings of the Ninth Annual IEEE Conference on Computer Assurance, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Most of the previous approaches to analysis of concurrent programs have generally abstracted away data values and their effects on control flow to concentrate on task interactions (e.g., <ref> [10, 11, 22, 12, 25, 23] </ref>). We perform dataflow analysis on values of requirements variables and include them into the property verification. The goal of our technique is to avoid building a global reachability graph.
Reference: [12] <author> R. Gerber and I. Lee. </author> <title> "A Layered Approach to Automating the Verification of Real-Time Systems". </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> 18(9) </volume> <pages> 768-784, </pages> <year> 1992. </year>
Reference-contexts: Most of the previous approaches to analysis of concurrent programs have generally abstracted away data values and their effects on control flow to concentrate on task interactions (e.g., <ref> [10, 11, 22, 12, 25, 23] </ref>). We perform dataflow analysis on values of requirements variables and include them into the property verification. The goal of our technique is to avoid building a global reachability graph.
Reference: [13] <author> D. Grunwald and H. Srinivasan. </author> <title> "Data Flow Equations for Explicitly Parallel Programs". </title> <booktitle> In Proceedings of 4th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 159-167, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Figure 4 contains a portion of CDFG corresponding to the code fragment in Figure 3. (SubSys2 is ommitted for clarity.) Sequential and synchronization edges are identified in the figure, following the convention of <ref> [13] </ref>. For clarity, we have ommited control-flow edges between buffers and the nodes using them. In the actual CDFG, there is a backward sequential edge for each synchronization edge. <p> For clarity, we have ommited control-flow edges between buffers and the nodes using them. In the actual CDFG, there is a backward sequential edge for each synchronization edge. Our computation of system states at each node of the CDFG is similar to that for reaching definitions via dataflow techniques <ref> [1, 13, 22] </ref>. gen sets capture new values generated at each node of the CDFG. kill sets represent values that variables cannot have after each node.
Reference: [14] <author> D. Harel. "StateCharts: </author> <title> A Visual Formalism for Complex Systems". </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: It would be more convenient to use arrays of modes and mode classes, as in <ref> [18, 14] </ref>. We might also need to specify exactly which variables are to be read from and written to each buffer, rather than defaulting to all variables passed between processes. Also, a useful and general semantics of communication between processes needs further investigation.
Reference: [15] <author> C. Heitmeyer and B. Labaw. </author> <title> "Consistency Checks for SCR-Style Requirements Specifications". </title> <type> Technical Report NRL Report 93-9586, </type> <institution> Naval Research Laboratory, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: In this section, we present the requirements and the program design languages and define what we mean by consistency between a design and its requirements. 2.1. Requirements The Software Cost Reduction (SCR) requirements notation <ref> [2, 15, 17] </ref> was developed by a research group at the Naval Research Laboratory. An SCR requirements specification models a system as a set of event-driven, state-transition machines. The machines' environment is abstracted as a set of monitored state variables and controlled state variables [24, 26].
Reference: [16] <author> C. Heitmeyer, B. Labaw, and D. Kiskis. </author> <title> "Consistency Checking of SCR-Style Requirements Specifications". </title> <booktitle> In Proceedings of RE'95 International Symposium of Requirements Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: A condition is a predicate on monitored or mode class variables, and denotes an event when one of their values changes. For example, @T (a) WHEN [b] occurs if condition a changes value from False to True while condition b is True, or, formally (adopted from <ref> [16] </ref>), @T (a) WHEN [b] = ~a ^ a0 ^ b; where the unprimed version of condition a denotes a in the old state and the primed version denotes a in the new state, and ~ and ^ indicate negation and conjunction, respectively. <p> We refer to @T (a) and b as Triggering and When conditions, respectively. Similarly, @F (a) occurs if condition a changes value from True to False. SCR has a formal underlying semantics <ref> [16] </ref> which permits creation of various CASE tools for creation and checking of SCR specifications 1 . Since conditions are predicates on monitored variables, we will assume that the system variables are boolean. <p> We restrict the model further by not allowing any inputs of a process to be among its outputs. Still, this model is more general than the one recently proposed in <ref> [16] </ref>. The latter assumes that there is a partial order of dependencies between variables and mode classes in every requirements document, and we make no such assumption. We illustrate the SCR model using a simple example, abstracted from a Nuclear Control Rod system [19] to preserve communication problems.
Reference: [17] <author> K. Heninger. </author> <title> "Specifying Software Requirements for Complex Systems: New Techniques and Their Applications". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):2-12, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: In this section, we present the requirements and the program design languages and define what we mean by consistency between a design and its requirements. 2.1. Requirements The Software Cost Reduction (SCR) requirements notation <ref> [2, 15, 17] </ref> was developed by a research group at the Naval Research Laboratory. An SCR requirements specification models a system as a set of event-driven, state-transition machines. The machines' environment is abstracted as a set of monitored state variables and controlled state variables [24, 26].
Reference: [18] <author> M. S. Jaffe, N. G. Levenson, M. P. Heimdahl, and B. E. Melhart. </author> <title> "Software Requirements Analysis for Real-Time Process-Control Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(3), </volume> <month> March </month> <year> 1991. </year>
Reference-contexts: It would be more convenient to use arrays of modes and mode classes, as in <ref> [18, 14] </ref>. We might also need to specify exactly which variables are to be read from and written to each buffer, rather than defaulting to all variables passed between processes. Also, a useful and general semantics of communication between processes needs further investigation.
Reference: [19] <author> F. Jahanian and A. K.-L. Mok. </author> <title> "A Graph-Theoretic Approach for Timing Analysis and Its Implementation". </title> <journal> IEEE Transactions on Computers, </journal> <volume> 8 </volume> <pages> 961-975, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: The latter assumes that there is a partial order of dependencies between variables and mode classes in every requirements document, and we make no such assumption. We illustrate the SCR model using a simple example, abstracted from a Nuclear Control Rod system <ref> [19] </ref> to preserve communication problems. We call it a Mutual Exclusion system (MES). Assume that we want to specify a system where two identical processes have critical sections, and mutual exclusion is guaranteed by having a separate process, Manager, give out permissions to the other processes.
Reference: [20] <author> D. Lamb. </author> <title> Software Engineering: Planning for Change. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Designs are often expressed in special program design languages (PDLs)[4]. When a design is inspected, the reviewers seek to establish that it meets the requirements, and that it is complete and self-consistent <ref> [20] </ref>. In earlier work [5, 6], we defined a notation which can be used as a PDL. The PDL's outer syntax is comprised of C control constructs, and its inner syntax is a set of special comments, called annotations, which describe local properties of requirements variables' values.
Reference: [21] <author> N. Levenson, M. Heimdahl, H. Hildreth, and J. Reese. </author> <title> "Requirements Specification for Process-Control Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9) </volume> <pages> 684-707, </pages> <month> September </month> <year> 1994. </year>
Reference: [22] <author> D. Long and L. A. Clarke. </author> <title> "Data Flow Analysis of Concurrent Systems That Use the Rendezvous Model of Synchronization". </title> <type> Technical Report COINS 91-31, </type> <institution> Univ. </institution> <address> Mass. Amherst, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Most of the previous approaches to analysis of concurrent programs have generally abstracted away data values and their effects on control flow to concentrate on task interactions (e.g., <ref> [10, 11, 22, 12, 25, 23] </ref>). We perform dataflow analysis on values of requirements variables and include them into the property verification. The goal of our technique is to avoid building a global reachability graph. <p> For clarity, we have ommited control-flow edges between buffers and the nodes using them. In the actual CDFG, there is a backward sequential edge for each synchronization edge. Our computation of system states at each node of the CDFG is similar to that for reaching definitions via dataflow techniques <ref> [1, 13, 22] </ref>. gen sets capture new values generated at each node of the CDFG. kill sets represent values that variables cannot have after each node.
Reference: [23] <author> S. Masticola and B. Ryder. </author> <title> "A Model for Ada Programs for Static Deadlock Detection in Polynomial Time". </title> <booktitle> Proceedings of ACM Sigplan Programming Languages Design and Implementation, ACM Sigplan Notices, </booktitle> <volume> 26(12) </volume> <pages> 97-107, </pages> <year> 1991. </year>
Reference-contexts: Most of the previous approaches to analysis of concurrent programs have generally abstracted away data values and their effects on control flow to concentrate on task interactions (e.g., <ref> [10, 11, 22, 12, 25, 23] </ref>). We perform dataflow analysis on values of requirements variables and include them into the property verification. The goal of our technique is to avoid building a global reachability graph.
Reference: [24] <author> D. Parnas and J. Madey. </author> <title> "Functional Documentation for Computer Systems Engineering(Version 2)". </title> <type> Technical Report CRL Report 237, </type> <institution> McMaster University, Department of Electrical and Computer Engineering, </institution> <year> 1991. </year>
Reference-contexts: An SCR requirements specification models a system as a set of event-driven, state-transition machines. The machines' environment is abstracted as a set of monitored state variables and controlled state variables <ref> [24, 26] </ref>. A state is a mapping of variables to values. Changes to monitored variables may cause the system to change its mode or to alter the values of its controlled variables. A mode class defines a set of states, called modes, that partition the monitored environment's state space.
Reference: [25] <author> R. N. Taylor. </author> <title> "A General-Purpose Algorithm for Analyzing Concurrent Programs". </title> <journal> Communications of the ACM, </journal> <volume> 26(5) </volume> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: Most of the previous approaches to analysis of concurrent programs have generally abstracted away data values and their effects on control flow to concentrate on task interactions (e.g., <ref> [10, 11, 22, 12, 25, 23] </ref>). We perform dataflow analysis on values of requirements variables and include them into the property verification. The goal of our technique is to avoid building a global reachability graph.
Reference: [26] <author> A. J. van Schouwen. </author> <title> "The A-7 Requirements Model: Re-examination for Real-Time Systems and an Application to Monitoring Systems". </title> <type> Technical Report TR-90-276, </type> <institution> Queen's University, Kingston, </institution> <address> Ontario, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: An SCR requirements specification models a system as a set of event-driven, state-transition machines. The machines' environment is abstracted as a set of monitored state variables and controlled state variables <ref> [24, 26] </ref>. A state is a mapping of variables to values. Changes to monitored variables may cause the system to change its mode or to alter the values of its controlled variables. A mode class defines a set of states, called modes, that partition the monitored environment's state space. <p> All these variables are state conditions, i.e., conditions specifying that a particular mode class is in a particular mode. They become True when the system enters a corresponding state, and False when it leaves this state. A state condition is a simplified version of van Schouwen's InMode () function <ref> [26] </ref>. In addition, each subsystem monitors the variable Time to determine when it is time to ask for permission, and Done to determine when critical-section processing is complete. The requirements specification for mode classes SubSys1 and Manager are shown in Tables 1 and 2, respectively.
References-found: 26

