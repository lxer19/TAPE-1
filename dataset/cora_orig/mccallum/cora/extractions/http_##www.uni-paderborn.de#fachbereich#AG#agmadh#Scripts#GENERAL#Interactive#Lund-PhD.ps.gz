URL: http://www.uni-paderborn.de/fachbereich/AG/agmadh/Scripts/GENERAL/Interactive/Lund-PhD.ps.gz
Refering-URL: http://www.uni-paderborn.de/fachbereich/AG/agmadh/WWW/english/scripts.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: THE POWER OF INTERACTION  
Author: CARSTEN LUND 
Degree: A DISSERTATION SUBMITTED TO THE FACULTY OF THE DIVISION OF THE PHYSICAL SCIENCES IN CANDIDACY FOR THE DEGREE OF DOCTOR OF PHILOSOPHY DEPARTMENT OF COMPUTER SCIENCE BY  
Date: MARCH, 1991  
Affiliation: CHICAGO, ILLINOIS  
Note: THE UNIVERSITY OF CHICAGO  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> W. Aiello, S. Goldwasser, and J. Hastad. </author> <title> On the power of interaction. </title> <journal> Combinatorica, </journal> <volume> 10(1) </volume> <pages> 3-25, </pages> <year> 1990. </year>
Reference-contexts: We will normally drop the subscript and just let (Y ) denote the measure of Y if X is obvious from the context. 60 Definition 4.4.2 Let f; g be functions over a finite set X. For ffi 2 <ref> [0; 1] </ref> we say that f ffi-approximates g if (fx 2 Xjf (x) 6= g (x)g) &lt; ffi. Definition 4.4.3 Let f : I n ! Q be a function. We call f multilinear if its restriction to any line (in the above sense) of I n is linear. <p> Definition 4.4.3 Let f : I n ! Q be a function. We call f multilinear if its restriction to any line (in the above sense) of I n is linear. Definition 4.4.4 Let f : I n ! Q. For ffi 2 <ref> [0; 1] </ref> we say that f is ffi-approximately multilinear if there exists a multilinear g such that g ffi-approximates f . If n=1, we obtain the concept of ffi-approximately linear functions. <p> In this chapter we will discuss these implications and areas for future research. 6.1 Bounded-Round Interactive Proofs It has been an open problem whether every language with an interactive proof has one with only a bounded number of rounds. Previously Aiello, Goldwasser and Hastad <ref> [1] </ref> constructed an oracle relative to which the class of languages with unbounded-round interactive proofs differs from those with bounded-round interactive proofs. Relative to any PSPACE -complete oracle the answer is the opposite. The following corollary gives strong evidence that not every language in IP has bounded round interactive proofs.
Reference: [2] <author> D. Aldous. </author> <title> On the Markov chain simulation method for uniform combinatorial distributions and simulated annealing. </title> <journal> Probability in the Engineering and Informational Sciences, </journal> <volume> 1 </volume> <pages> 33-46, </pages> <year> 1987. </year>
Reference-contexts: Lemma 4.4.8 (Expansion Lemma) Let S X n . If jSj jXj n =2 then j Sj jSj (1 + 1 proof : This was proved by Aldous <ref> [2, Lemma 3.1] </ref>.
Reference: [3] <author> L. Babai. </author> <title> Trading group theory for randomness. </title> <booktitle> In Proc. of the 17th ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 421-429, </pages> <year> 1985. </year>
Reference-contexts: Efficient proof systems were introduced in work by Cook, 3 Karp and Levin in the early 1970's and has had a great significance for the whole theory of computation. In 1985 Goldwasser, Micali and Rackoff [34] and independently Babai <ref> [3] </ref> introduced interactive proof systems. This model describes the situation where Helen is interacting with one god. Subsequently Goldwasser, Micali and Wigderson [33] gave an interactive proof for a problem which is not believed to have a short traditional proof. <p> An ATM accepts an input if and only if the formula is satisfied. 2.2.5 Interactive Proof Systems Interactive proof systems are a generalization of NTMs that incorporates randomness. This model was introduced by Goldwasser, Micali and Rackoff [34] in 1985 and independently by Babai <ref> [3] </ref> also in 1985. Interactive proof systems can be modeled as a game between 2 players: a verifier and a prover. The verifier's computation will be restricted in some way (See section 2.3.4), whereas the prover will have no restriction on his computational power. <p> Babai in <ref> [3] </ref> independently of [34] introduced similar games (Arthur-Merlin games), where the prover could see the random bits after the verifier has read them. We will call these public coin interactive proof systems. <p> Another resource that is measured in relation to interactive proofs is the number of rounds used in the proof systems. We denote the class of languages recognized by interactive proof systems in a bounded number of rounds by MA. Babai showed <ref> [3] </ref> that MA is equal to the class recognized by interactive proof systems that consist of only one message from the prover and then some local computation by the verifier. <p> The following corollary gives strong evidence that not every language in IP has bounded round interactive proofs. Corollary 6.1.1 If every language in IP has a bounded-round interactive proof, then PSPACE = P 2 . proof : This is immediate from Babai <ref> [3] </ref>, who show that any language with a bounded round interactive proof belongs to P 2 . 6.2 Zero-Knowledge The reason Goldwasser, Micali and Rackoff looked at interactive proofs was to study the amount of information that interactive protocols reveal.
Reference: [4] <author> L. Babai and P. Erd-os. </author> <title> Representation of group elements as short products. </title> <journal> Annals of Discrete Mathematics, </journal> <volume> 12 </volume> <pages> 27-30, </pages> <year> 1982. </year>
Reference-contexts: Lemma 4.4.8 (Expansion Lemma) Let S X n . If jSj jXj n =2 then j Sj jSj (1 + 1 proof : This was proved by Aldous [2, Lemma 3.1]. It is also implicit in work by Babai and Erd-os <ref> [4, Lemma] </ref>. 4.4.3 The Self-Improvement Lemma The key step in the induction argument that will yield Theorem 4.4.12 is the verification that if a function passes the Test and it is multilinear on a "fair" portion of the space then it is actually a "good" approximation to a multilinear function.
Reference: [5] <author> L. Babai and L. Fortnow. Arithmetization: </author> <title> a new method in structural complexity theory. </title> <journal> Computational Complexity, </journal> <volume> 1 </volume> <pages> 41-66, </pages> <year> 1991. </year>
Reference-contexts: Remark 3.1.5 The arithmetization in this section is from #P instances to arithmetic expressions. Babai and Fortnow, in <ref> [5] </ref>, arithmetize #P -functions as uniform families of arithmetic expressions of a special type. 30 3.1.2 Proof Systems for #P In this section we will describe interactive proof systems for every language in P #P . We use the arithmetized problem that was introduced in the previous section.
Reference: [6] <author> L. Babai, L. Fortnow, and C. Lund. </author> <title> Non-deterministic exponential time has two-prover interactive protocols. </title> <journal> Computational Complexity, </journal> <volume> 1 </volume> <pages> 3-40, </pages> <year> 1991. </year>
Reference-contexts: In Chapter 4 we show that every language in NEXP has a two prover interactive proof. This result is joint work with Babai and Fortnow <ref> [6] </ref>. In Chapter 5 be obtain a polynomial relationship between time-space bounded ATMs and single prover public coin interactive proof system with time-space bounded verifiers. This research is joint work with Fortnow [26].
Reference: [7] <author> L. Babai and S. Moran. </author> <title> Arthur-Merlin games: a randomized proof system, and a hierarchy of complexity classes. </title> <journal> J. of Computer and System Sciences, </journal> <volume> 36(2) </volume> <pages> 254-276, </pages> <year> 1988. </year>
Reference-contexts: Babai showed [3] that MA is equal to the class recognized by interactive proof systems that consist of only one message from the prover and then some local computation by the verifier. Babai and Moran <ref> [7] </ref> proved that MA P 2 P Similar we define MIP to be the class of languages recognized by multiple prover interactive proof systems. We will for some corollaries of our results need to know how many re sources the prover or provers uses. <p> seems remarkable that this result, which refers to standard concepts of structural complexity theory, has been proved via the theory of multi-prover interactive proof systems. 6.5 Further Research Many interesting open questions remain, including * Which languages L can be proven by bounded round interactive proofs? From Babai and Moran <ref> [7] </ref> we know that if L has a bounded round interactive proof, then L 2 P 2 .
Reference: [8] <author> T. Baker, J. Gill, and R. Solovay. </author> <title> Relativizations of the P = NP question. </title> <journal> SIAM J. of Computing, </journal> <volume> 4(4) </volume> <pages> 431-442, </pages> <year> 1975. </year>
Reference-contexts: Baker, Gill and Solovay <ref> [8] </ref> formalized this by considering the model of Oracle Turing Machines (OTM). An OTM is a Turing Machine that has an additional tape, called the oracle tape and 3 special states (q ? ; q 0 ; q 1 ). <p> For example given an oracle A fl the class P A consists of languages that are recognizable by polynomial time deterministic OTM with oracle A. Baker, Gill and Solovay introduced these concepts as a tool to show that some techniques will not settle the P versus NP question. In <ref> [8] </ref> Baker, Gill and Soloway found oracles A; B such that for example P A = NP A and P B 6= NP B . <p> Here is a sample of other oracle results from <ref> [8] </ref> 9C : NP C 6= coNP C 9D : P D = NP D = coNP D 9E : P E 6= NP E and P E = NP E " coNP E 24 9F : NP F 6= coNP F and P E 6= NP F " coNP F
Reference: [9] <author> D. Beaver and J. Feigenbaum. </author> <title> Hiding instances in multioracle queries. </title> <booktitle> In Proc. 7th Symp. on Theoretical Aspects of Comp. Sci., </booktitle> <pages> pages 37-48. </pages> <note> LNCS 415, </note> <year> 1990. </year>
Reference-contexts: Since a PSPACE machine can simulate an alternating polynomial-time Turing machine, and since L is PSPACE-robust, g is Turing-reducible to L. In particular, we have multilinear PSPACE-complete functions, EXP-complete functions, etc. Inspired by Beaver and Feigenbaum <ref> [9] </ref> and spelled out simultaneously by us and by Beaver and Feigenbaum, this lemma has significant consequences, as we shall see below. <p> If we apply Theorem 4.4.1 with p = 1=2 n and ff = n 2 we fulfill exactly the first two requirements above. We will use ideas of Beaver, Feigenbaum <ref> [9] </ref> and Lipton [46] to create the correcting function S. Suppose we wish to compute f (x 1 ; : : :; x n ).
Reference: [10] <author> M. Ben-Or, O. Goldreich, S. Goldwasser, J. Hastad, J. Kilian, S. Micali, and P. Rogaway. </author> <title> Everything provable is provable in zero-knowledge. </title> <booktitle> In Proc. Crypto 88, </booktitle> <pages> pages 37-56, </pages> <year> 1988. </year> <pages> 102 103 </pages>
Reference-contexts: On the other hand Impagliazzo and Yung [42] and independently Ben-Or, Goldreich, Goldwasser, Hastad, Kilian, Micali and Rogaway <ref> [10] </ref>, using a protocol by Goldwasser, Micali and Wigderson [33], showed that every language in IP has a zero-knowledge single prover interactive proof given that honest one-way functions exists.
Reference: [11] <author> M. Ben-Or, S. Goldwasser, J. Kilian, and A. Wigderson. </author> <title> Multi-prover interactive proofs: How to remove intractability assumptions. </title> <booktitle> In Proc. of the 20th ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 113-131, </pages> <year> 1988. </year>
Reference-contexts: But until the work described in this thesis it was an open problem as to how many problems have interactive proofs. In 1988 Ben-Or, Goldwasser, Kilian and Wigderson <ref> [11] </ref> introduced multiple prover interactive proof. This model describes the situation in Troy, where Helen is talking to two gods that are on opposite sides in the war and they will therefore not be in the same room. <p> A multiple prover interactive proof system. 2.2.6 Multiple Prover Interactive Proof Systems Multiple Prover Interactive Proof Systems (MIPS) is a further extension of proofs systems introduced by Ben-Or, Goldwasser, Kilian and Wigderson in <ref> [11] </ref>. In MIPS the verifier can talk to more than one prover (See figure 5). The provers can, before the computation, decide on a strategy as to how to cheat the verifier. <p> This theorem gives a natural model which is equivalent to multiple provers and can be used to prove theorems about them, for example: Theorem 4.1.2 (Ben-Or, Goldwasser, Kilian and Wigderson <ref> [11] </ref>) If a language L is accepted by a multiple prover interactive protocol then L is accepted by a two prover interactive protocol. proof : Let M be a probabilistic oracle machine that runs in time n i . <p> They 95 proved in <ref> [11] </ref> that every language in MIP has a perfect zero-knowledge multiple prover interactive proof. Hence Corollary 6.2.1 follows from Theorem 4.3.4: Corollary 6.2.1 Every language in NEXP has a perfect zero-knowledge multiple prover interactive proof.
Reference: [12] <author> C. Bennet and J. Gill. </author> <title> Relative to a random oracle, P A 6= NP A 6= coNP A with probability one. </title> <journal> SIAM J. on Computing, </journal> <volume> 10 </volume> <pages> 96-113, </pages> <year> 1981. </year>
Reference-contexts: We define non-uniform complexity classes by restricting the size and/or depth of the circuits. We define P= poly to be the class of languages that have polynomial size circuits. If we restrict our circuits to uniform polynomial size circuits we just get the class P . Bennet and Gill <ref> [12] </ref> showed that BPP P= poly. Cook [21] defined NC to be the class of languages that have polynomial size poly-logarithmic depth uniform circuits.
Reference: [13] <author> M. Blum and S. Kannan. </author> <title> Designing programs that check their work. </title> <booktitle> In Proc. of the 21st ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 86-97, </pages> <year> 1989. </year>
Reference-contexts: There are natural classes of languages satisfying the conclusion of Lemma 6.3.2 which are not known to be PSPACE-robust; P #P -complete languages being the prime example, since they are equivalent to the permanent, a multilinear function (Valiant [66]). 97 6.3.2 Instance Checking In Blum and Kannan <ref> [13] </ref>, function-restricted IP is defined as follows. The set of all languages L for which there is an interactive proof system for L such that the honest prover need only answer questions about L, and any dishonest prover must be a function from the set of questions to f0; 1g. <p> This gives a negative answer to the open question of Blum and Kannan <ref> [13] </ref> as to whether IP contains function-restricted IP. Still open is the question as to whether NP-complete languages have program checkers.
Reference: [14] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Self-testing and self-correcting programs, with applications to numerical programs. </title> <booktitle> In Proc. of the 22nd ACM Symp. on the Theory of Computing, </booktitle> <year> 1990. </year>
Reference-contexts: This is directly related to the question of whether coNP languages have protocols with NP provers. 6.3.3 Self-Testing and Self-Correcting Programs Our test of multilinear functions (Section 4.4) also has applications to program testing as described by Blum, Luby and Rubinfeld <ref> [14] </ref> and Lipton [46]. We will use the following definition from Blum, Luby and Rubinfeld: A pair of probabilistic programs (T; S) is a self-testing/correcting pair for f if given a program P as an oracle, 1. <p> If P differs from f on at most 1=n 2 of the inputs then S P will correctly compute f on every input with probability 1 1 2 n . This definition is more restrictive than the definition given by Blum, Luby and Rubinfeld <ref> [14] </ref>, which is more general in many ways (including weaker error bounds). We can use verification of multilinear functions to convert a weak self-testing program to a strong self-testing/correcting pair for a multilinear function. Corollary 6.3.7 Let f be a multilinear function.
Reference: [15] <author> A. R. Bruss and A. R. Meyer. </author> <title> On time-space classes and their relation to the theory of real addition. </title> <journal> Theoretical Computer Science, </journal> <volume> 11 </volume> <pages> 59-69, </pages> <year> 1980. </year>
Reference-contexts: So Bruss and Meyer <ref> [15] </ref> defined the class DTISP (t; s) as the class of languages recognized in deterministic time t and space s.
Reference: [16] <author> A. Chandra, D. Kozen, and L. Stockmeyer. </author> <title> Alternation. </title> <journal> J. of the ACM, </journal> <volume> 28(1) </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference-contexts: tree defines a Boolean formula with all internal nodes being OR gates and accepting leaves being true and rejecting leaves being false and that the formula is true if and only if M accepts the input. 13 2.2.4 Alternating Computations One generalization of NTMs due to Chandra, Kozen and Stockmeyer <ref> [16] </ref> is to allow AND gates also in the formula defined by the computation tree. This is formalized by partitioning the states of the Alternating Turing Machine (ATM) into two sets: the existential states and the universal states. <p> Similarly we get the classes AP, APSPACE and so on. Some relations between alternative classes and deterministic classes are known. Fact 2.3.3 (Chandra, Kozen and Stockmeyer <ref> [16] </ref>) * For s (n) log n, ASPACE (s (n)) = S c&gt;0 DTIME (c s (n) ) . * For t (n) n, ATIME (t (n)) DSPACE (t (n)) ATIME (t (n) 2 ). and therefore AP = PSPACE and APSPACE = EXP Ruzzo [53] studied the class NC, which <p> One of Ruzzo's results was that N C = k=0 A resource associated with alternating Turing Machines is the number of alternations that it performs. A alternation is a step where the machine goes from a universal state to an existential state or vice versa. Chandra, Kozen and Stockmeyer <ref> [16] </ref> looked at machines that are allowed a bounded number of alternations. <p> The results in Chapter 3 show that the set of languages accepted by an interactive proof system equals the class of languages accepted in deterministic polynomial space. Since Chandra, Kozen and Stockmeyer <ref> [16] </ref> have shown PSPACE to be equivalent to the languages accepted by a polynomial-time alternating Turing machine, in this case alternating Turing machine and interactive proof systems have identical power. <p> We also use these theorems to get strong relationships between interactive proof systems and deterministic computation similar to the relationships between alternating Turing machine and deterministic computation found in Section 2.3.3 due to Chandra, Kozen and Stockmeyer <ref> [16] </ref>. 5.1 Restricted Alternating Turing Machines In this chapter we will use the "random access input" model for an alternating Turing Machine similar to the one described by Ruzzo [53]. This will allow us to study ATMs which use sublinear time. <p> Chandra, Kozen and Stockmeyer <ref> [16] </ref> prove the existence of an alternating polynomial-time log-space Turing machine M that accepts L. <p> Corollary 5.4.2 A deterministic polynomial-time Turing machine can recognize any language accepted by a public-coin interactive proof system with a verifier using logarithmic space and polynomial time. proof : S k&gt;0 ATISP (n k ; log n) = ASPACE (log n) = P <ref> [16] </ref> 88 5.5 A hierarchy for pIPTISP (t; s) Theorem 5.1.2 gives a tight hierarchy for ATISP (t; s) . <p> We can use Theorem 5.4.1 and Corollary 5.3.5 combined with the relationships in <ref> [16] </ref> described in Fact 2.3.3 to prove more general relationships.
Reference: [17] <author> A. Condon. </author> <title> Computational models of games. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Washington at Seattle, </institution> <year> 1987. </year>
Reference-contexts: The second consequence is equivalent to pIP = PSPACE, which we proved in Chapter 3. 5.7 Private versus Public Coins In this section we will exhibit a relationship between private coin interactive proof systems and public coins. The relationship is due to Condon <ref> [17] </ref>. Theorem 5.7.1 For any t (n) n such that (t (n); log t (n)) is a fully time-space constructible pair, pIPTISP (t (n); t (n)) IPTISP (t 3 (n); log t (n)) proof : Let L 2 pIPTISP (t (n); t (n)).
Reference: [18] <author> A. Condon. </author> <title> Space bounded probabilistic game automata. </title> <booktitle> In Proc. of the 3rd Conference on Structure in Complexity Theory, </booktitle> <pages> pages 162-174, </pages> <year> 1988. </year>
Reference-contexts: Analogously we define pIPTISP (t; s) . Goldwasser and Sipser [35] showed that IP = pIP. Hence public coin are no restriction for polynomial time verifiers. But for other resource bounds there is a difference as shown by Condon <ref> [18] </ref>. She showed that pIPTISP (poly; log n) P 22 whereas she also proved IPTISP (poly; log n) = IP: The first result was independently proved by Fortnow and Sipser [28]. <p> In this Chapter we generalize the work in Chapter 3 to exhibit a broader equivalence between alternating Turing machines and interactive proof systems. We look at time-space complexity, first studied for alternating Turing machines by Ruzzo [53] and for interactive proof systems by Condon <ref> [18] </ref>. In this Chapter we will only study interactive proof systems with public coins. Goldwasser and Sipser [35] prove that the class of languages accepted by interactive proofs with a polynomial-time verifier does not depend on whether the verifier uses public or private coins. <p> By a result by Ruzzo [53] an alternating Turing Machine can evaluate each bit of the value of the initial configuration in time O (t (n) log t (n)) and space O (s (n)). Condon <ref> [18] </ref> and Fortnow and Sipser [28] independently proved the fol lowing fact, which follows from Theorem 5.4.1.
Reference: [19] <author> A. Condon and R. J. Lipton. </author> <title> On the complexity of space bounded interactive proofs. </title> <booktitle> In Proc. of the 30th IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 462-467, </pages> <year> 1989. </year>
Reference-contexts: They also proved that LOGCFL IPTISP (poly; log n) where LOGCFL NC 2 is the class of languages log-space reducible to context-free languages [61, 62]. Condon and Lipton <ref> [19] </ref> showed that if the verifier has constant work space but infinite time then interactive proof systems can recognize any recursively enumerable language. This is true, assuming we loosen our assumption that the verifier always halts. <p> Note that, since we here allow the verifier to run indefinitely then, the two definitions are not equivalent. Indeed Condon and Lipton <ref> [19] </ref> showed that, with this new variant of language recognition, interactive proof systems with constant work space and infinite time verifiers only recognize languages in ATIME (2 2 O (n) ).
Reference: [20] <author> S. Cook. </author> <title> The complexity of theorem-proving procedures. </title> <booktitle> In Proc. of the 3rd ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 151-158, </pages> <year> 1971. </year>
Reference-contexts: NTMg Recently Toda [64] showed that there are #P problems, which are hard for the polynomial time hierarchy, in the sense that given an oracle for the problem then we can recognize any language in PH in polynomial time. 2.5 Completeness One of the most important concepts introduced by Cook <ref> [20] </ref>, Levin [45] and Karp [44] to study complexity classes is reduction. Reductions enable us to talk about the relative hardness of problems. <p> Since completeness was introduced complete problems have been found for a lot of complexity classes. See Garey and Johnson's excellent book [31] on completeness for an extensive list of complete problem and a more detailed discussion of completeness. A lot of complete problems arise in logic. Cook <ref> [20] </ref> and Levin [45] found the first complete problem for NP . They showed that SAT is NP -complete. SAT is the set of CNF formula ', which has a satisfying assignment.
Reference: [21] <author> S. Cook. </author> <title> Determinstic CFLs are accepted simultaneous in polynomial time and log squared space. </title> <booktitle> In Proc. of the 11st ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 338-345, </pages> <year> 1979. </year>
Reference-contexts: We define P= poly to be the class of languages that have polynomial size circuits. If we restrict our circuits to uniform polynomial size circuits we just get the class P . Bennet and Gill [12] showed that BPP P= poly. Cook <ref> [21] </ref> defined NC to be the class of languages that have polynomial size poly-logarithmic depth uniform circuits.
Reference: [22] <author> S. A. Cook. </author> <title> A hierachy for nondeterministic time complexity. </title> <journal> J. of Computer and System Science, </journal> <volume> 7 </volume> <pages> 343-353, </pages> <year> 1973. </year> <month> 104 </month>
Reference-contexts: (n r ) pIPTIME (n s ); pIPSPACE (n r ) pIPSPACE (n s ) and pIPSPACE (log r n) pIPSPACE (log s n): proof : Given Theorem 5.5.2 the proof is similar to the proof of similar results for NSPACE (s) by Ibarra [40] and NTIME (t) by Cook <ref> [22] </ref>. 5.6 Interactive Proof Systems for Deterministic Computation Corollaries 5.3.3 and 5.3.4 exhibit interactive proof systems with verifiers having low time-space complexity for P and NC . We can use Theorem 5.4.1 and Corollary 5.3.5 combined with the relationships in [16] described in Fact 2.3.3 to prove more general relationships.
Reference: [23] <author> P. Feldman. </author> <title> The optimum prover lives in PSPACE. </title> <type> Manuscript, </type> <institution> M.I.T., </institution> <year> 1986. </year>
Reference-contexts: The verifier uses O (n 2 + nm) arithmetic operations. And since TQBF is PSPACE-complete we get that Theorem 3.2.11 (Shamir [56]) PSPACE IP Hence from the result by Papadimitriou [49] that IP PSPACE we then know that IP = PSPACE. Furthermore Feldman <ref> [23] </ref> showed that the honest prover lives in PSPACE. CHAPTER 4 THE POWER OF INTERACTION WITH TWO PROVERS In this chapter we will show that any language in NEXP has a two prover interactive proof system.
Reference: [24] <author> L. Fortnow. </author> <title> The complexity of perfect zero-knowledge. </title> <editor> In S. Micali, editor, </editor> <booktitle> Randomness and Computation, volume 5 of Advances in Computing Research, </booktitle> <pages> pages 327-343. </pages> <publisher> JAI Press, </publisher> <year> 1989. </year>
Reference-contexts: Hence Corollary 6.2.1 follows from Theorem 4.3.4: Corollary 6.2.1 Every language in NEXP has a perfect zero-knowledge multiple prover interactive proof. A corresponding result for single prover interactive proof systems would be surprising since Fortnow <ref> [24] </ref> proved that if a language L has a perfect zero-knowledge single prover interactive proof then L has a bounded round interactive proof system and therefore Corollary 6.2.2 follows from Corollary 6.1.1 and Theorem 3.2.11: Corollary 6.2.2 If every language in IP has a perfect zero-knowledge single prover interactive proof then
Reference: [25] <author> L. Fortnow. </author> <title> Complexity-theoretic aspects of interactive proof systems. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1989. </year> <note> Tech Report MIT/LCS/TR-447. </note>
Reference: [26] <author> L. Fortnow and C. Lund. </author> <title> Interactive proof systems and alternating time-space complexity. </title> <booktitle> In Proc. 8th Symp. on Theoretical Aspects of Comp. Sci., </booktitle> <pages> pages 263-274. </pages> <note> LNCS 480, 1991. To appear in Theoretical Computer Science. </note>
Reference-contexts: This result is joint work with Babai and Fortnow [6]. In Chapter 5 be obtain a polynomial relationship between time-space bounded ATMs and single prover public coin interactive proof system with time-space bounded verifiers. This research is joint work with Fortnow <ref> [26] </ref>. CHAPTER 3 THE POWER OF INTERACTION WITH ONE PROVER In this chapter we are going to describe single prover interactive proof systems for the two complexity classes #P and PSPACE.
Reference: [27] <author> L. Fortnow, J. Rompel, and M. Sipser. </author> <title> On the power of multi-prover interactive protocols. </title> <booktitle> In Proc. of the 3rd Conference on Structure in Complexity Theory, </booktitle> <pages> pages 156-161, </pages> <year> 1988. </year>
Reference-contexts: It will furthermore settle a question in a way that goes against previously published oracle results. Fact 2.3.4 (Fortnow and Sipser [29]) There exists an oracle A such that coNP A 6 IP A : Fact 2.3.5 (Fortnow, Rompel and Sipser <ref> [27] </ref>) There exists an oracle A such that coNP A 6 MIP A : 2.4 Counting Classes NTMs can be looked at as defining a function instead of defining a language. Instead of being interested in if an accepting path exists we are interested in the number of accepting paths. <p> Therefore we describe a test for multilinearity. This test has an independent interest in the field of program testing. 4.1 Another characterization of MIP Fortnow, Rompel and Sipser in <ref> [27] </ref> gave another characterization of MIP in terms of probabilistic oracle Turing Machines. Let M be a probabilistic Turing machine with access to an oracle O. <p> This differs from the single prover interactive protocol model in that 43 44 the oracle must be fixed before the queries are made while in an interactive protocol the prover may let his future answers depend on previous questions. Theorem 4.1.1 (Fortnow, Rompel and Sipser <ref> [27] </ref>) L is accepted by a polynomial time probabilistic oracle machine if and only if L is accepted by a multiple prover interactive protocol. proof : 1. Suppose L is accepted by a probabilistic oracle machine M in n k steps. <p> The probability that cheating provers are not caught this way is at most (1 n i ). Repeat this process n i+1 times to reduce error probability below e n . Theorem 4.1.3 (Fortnow, Rompel and Sipser <ref> [27] </ref>) MIP NEXP: proof : Given a language L in MIP let M be a polynomial time POTM that recognizes L. <p> We remark that if we allow a polynomial number of provers then a bounded num ber of rounds does suffice <ref> [27] </ref>. * What complexity of provers do we need to prove coNP and NEXP languages? Is there a difference in the case of coNP when we only have one prover? 101 * Can the time-space relationship in Chapter 5 be tightened? In particular can we show that the class of languages
Reference: [28] <author> L. Fortnow and M. Sipser. </author> <title> Interactive proof systems with a log-space verifier. </title> <type> Manuscript. </type> <note> Later version appears in [25]. </note>
Reference-contexts: But for other resource bounds there is a difference as shown by Condon [18]. She showed that pIPTISP (poly; log n) P 22 whereas she also proved IPTISP (poly; log n) = IP: The first result was independently proved by Fortnow and Sipser <ref> [28] </ref>. They also proved that LOGCFL IPTISP (poly; log n) where LOGCFL NC 2 is the class of languages log-space reducible to context-free languages [61, 62]. <p> The previous best result known, by Fortnow and Sipser <ref> [28] </ref>, proves that LOGCFL has a public-coin interactive proof system with a polynomial-time log-space verifier. LOGCFL consists of all languages log-space reducible to context-free languages and is known to lie in NC 2 [61, 62, 53]. Furthermore, we use this relationship to obtain a hierarchy for public-coin interactive proof systems. <p> By a result by Ruzzo [53] an alternating Turing Machine can evaluate each bit of the value of the initial configuration in time O (t (n) log t (n)) and space O (s (n)). Condon [18] and Fortnow and Sipser <ref> [28] </ref> independently proved the fol lowing fact, which follows from Theorem 5.4.1.
Reference: [29] <author> L. Fortnow and M. Sipser. </author> <title> Are there interactive protocols for co-NP languages? Information Processing Letters, </title> <booktitle> 28 </booktitle> <pages> 249-251, </pages> <year> 1988. </year>
Reference-contexts: It will furthermore settle a question in a way that goes against previously published oracle results. Fact 2.3.4 (Fortnow and Sipser <ref> [29] </ref>) There exists an oracle A such that coNP A 6 IP A : Fact 2.3.5 (Fortnow, Rompel and Sipser [27]) There exists an oracle A such that coNP A 6 MIP A : 2.4 Counting Classes NTMs can be looked at as defining a function instead of defining a language.
Reference: [30] <author> L. Fortnow and M. Sipser. </author> <title> Probabilistic computation and linear time. </title> <booktitle> In Proc. of the 21st ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 148-156, </pages> <year> 1989. </year>
Reference-contexts: As a corollary we get that public coin interactive proof systems with linear time verifiers can not recognize all of IP. This should be contrasted with the result by Fortnow and Sipser <ref> [30] </ref> that for probabilistic computation there exists an oracle A such that BPTIME (n) A contains BPP A .
Reference: [31] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and intractability. A Guide to the theory of NP-completeness. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: If a problem is complete for a class it is in a sense one of the hardest problems in that class. Since completeness was introduced complete problems have been found for a lot of complexity classes. See Garey and Johnson's excellent book <ref> [31] </ref> on completeness for an extensive list of complete problem and a more detailed discussion of completeness. A lot of complete problems arise in logic. Cook [20] and Levin [45] found the first complete problem for NP . They showed that SAT is NP -complete. <p> They showed that SAT is NP -complete. SAT is the set of CNF formula ', which has a satisfying assignment. SAT := f' j ' is satisfiable. g A variant of SAT is 3-SAT which is the same problem but where ' is a 3-CNF formula. An easy argument <ref> [31, pages 48-49] </ref> shows that SAT P m 3-SAT. Hence 3-SAT is also NP -complete. Since 3-SAT are simpler but includes the computational difficulties of SAT we will look at 3-CNF formulas instead of general CNF formulas. <p> Hence 3-SAT is also NP -complete. Since 3-SAT are simpler but includes the computational difficulties of SAT we will look at 3-CNF formulas instead of general CNF formulas. When looking on at 3-SAT it is easy to see <ref> [31, page 169] </ref> that if we instead count the number of satisfying assignments then we have a #P - complete problem. <p> The #P -complete problem we consider is #3SAT. Recall that #3SAT is this problem: given a 3-CNF formula ', find the number #' of satisfying assignments of the variables in '. This is a well known #P -complete problem <ref> [31] </ref>. First, we prove a lemma that arithmetizes the problem of checking that an assignment satisfies a 3-CNF formula. 27 28 Lemma 3.1.1 Let ' be a 3-CNF formula with n variables x 1 ; x 2 ; : : : ; x n and m clauses. <p> We can construct clauses that will be satisfied only if the assignment of the variables correspond to an accepting computation path. The construction of these clause is easy because of the local nature of the computation of a Turing Machine. For complete details see Garey and Johnson <ref> [31, pages 39-44] </ref>. So ' n (x; z) is true if and only if z corresponds to an accepting com putation path. Choose c such that n c is a bound on both the number of variables and the number of clauses in ' n for all n.
Reference: [32] <author> O. Goldreich, Y. Mansour, and M. Sipser. </author> <title> Interactive proof systems: Provers that never fail and random selection. </title> <booktitle> In Proc. of the 28th IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 449-461, </pages> <year> 1987. </year>
Reference-contexts: Goldwasser and Sipser [35] have shown that one can convert any interactive proof to one where the verifier uses public coins, i.e., the verifier can only flip coins "in front of" the prover. Goldreich, Mansour and Sipser <ref> [32] </ref> have shown how to modify an interactive proof system so that for true instances the verifier is convinced with probability one. Both of these properties already hold for our protocol.
Reference: [33] <author> O. Goldreich, S. Micali, and A. Wigderson. </author> <title> Proofs that yield nothing but their validity and a methodology of cryptographic protocol design. </title> <booktitle> In Proc. of the 27th IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 174-187, </pages> <year> 1986. </year> <month> 105 </month>
Reference-contexts: In 1985 Goldwasser, Micali and Rackoff [34] and independently Babai [3] introduced interactive proof systems. This model describes the situation where Helen is interacting with one god. Subsequently Goldwasser, Micali and Wigderson <ref> [33] </ref> gave an interactive proof for a problem which is not believed to have a short traditional proof. But until the work described in this thesis it was an open problem as to how many problems have interactive proofs. <p> On the other hand Impagliazzo and Yung [42] and independently Ben-Or, Goldreich, Goldwasser, Hastad, Kilian, Micali and Rogaway [10], using a protocol by Goldwasser, Micali and Wigderson <ref> [33] </ref>, showed that every language in IP has a zero-knowledge single prover interactive proof given that honest one-way functions exists.
Reference: [34] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The knowledge complexity of interactive proof-systems. </title> <journal> SIAM J. on Computing, </journal> <volume> 18(1) </volume> <pages> 186-208, </pages> <year> 1989. </year>
Reference-contexts: Efficient proof systems were introduced in work by Cook, 3 Karp and Levin in the early 1970's and has had a great significance for the whole theory of computation. In 1985 Goldwasser, Micali and Rackoff <ref> [34] </ref> and independently Babai [3] introduced interactive proof systems. This model describes the situation where Helen is interacting with one god. Subsequently Goldwasser, Micali and Wigderson [33] gave an interactive proof for a problem which is not believed to have a short traditional proof. <p> An ATM accepts an input if and only if the formula is satisfied. 2.2.5 Interactive Proof Systems Interactive proof systems are a generalization of NTMs that incorporates randomness. This model was introduced by Goldwasser, Micali and Rackoff <ref> [34] </ref> in 1985 and independently by Babai [3] also in 1985. Interactive proof systems can be modeled as a game between 2 players: a verifier and a prover. <p> Babai in [3] independently of <ref> [34] </ref> introduced similar games (Arthur-Merlin games), where the prover could see the random bits after the verifier has read them. We will call these public coin interactive proof systems. <p> She may phrase her questions differently than in the original protocol, in order to trick the prover into revealing extra information. Goldwasser, Micali and Rackoff <ref> [34] </ref> defined that a protocol (P; V ) does not reveal information if for all verifiers V 0 there exists a simulator M V 0 such that for all x 2 L, M V 0 can produce a distribution M V 0 [x] that is "close" to the distribution (P; V
Reference: [35] <author> S. Goldwasser and M. Sipser. </author> <title> Private coins versus public coins in interactive proof systems. </title> <editor> In S. Micali, editor, </editor> <booktitle> Randomness and Computation, volume 5 of Advances in Computing Research, </booktitle> <pages> pages 73-90. </pages> <publisher> JAI Press, </publisher> <year> 1989. </year>
Reference-contexts: We will denote pIP as the class of languages that are recognizable by a public coin interactive proof system with a polynomial time verifier. Analogously we define pIPTISP (t; s) . Goldwasser and Sipser <ref> [35] </ref> showed that IP = pIP. Hence public coin are no restriction for polynomial time verifiers. But for other resource bounds there is a difference as shown by Condon [18]. <p> Hence the verifier recognizes L (M ). 34 Since M works in polynomial time the verifier works in polynomial time. Goldwasser and Sipser <ref> [35] </ref> have shown that one can convert any interactive proof to one where the verifier uses public coins, i.e., the verifier can only flip coins "in front of" the prover. <p> CHAPTER 5 INTERACTION VERSUS ALTERNATION In this Chapter we will look at the relationship between alternating TMs and interactive proof systems. There are some obvious similarities between alternating Turing machines and interactive proof systems. In fact, Goldwasser and Sipser <ref> [35] </ref> prove the equivalence of interactive proof systems and polynomial time Turing machine alternating between nondeterministic and probabilistic moves. However, until the results described in Chapter 3 appeared, it was generally believed that alternating Turning machines had far more power than interactive proof systems. <p> We look at time-space complexity, first studied for alternating Turing machines by Ruzzo [53] and for interactive proof systems by Condon [18]. In this Chapter we will only study interactive proof systems with public coins. Goldwasser and Sipser <ref> [35] </ref> prove that the class of languages accepted by interactive proofs with a polynomial-time verifier does not depend on whether the verifier uses public or private coins. However, a difference between private and public coins does hold for time- and space-bounded verifiers as we will see in Section 5.7.
Reference: [36] <author> J. Hartmanis, P. M. Lewis II, and R. E. Stearns. </author> <title> Hierarchies of memory limited computations. </title> <booktitle> In The 6th Annual IEEE Symp. on Switching Circuit Theory and Logical Design, </booktitle> <pages> pages 179-190, </pages> <year> 1965. </year>
Reference-contexts: See a very similar argument due to Hartmanis, Lewis and Stearns <ref> [36] </ref> for DSPACE (s) in [39, Theorem 12.8]. We get a hierarchy theorem for pIPTISP (t; s), as a consequence of our correspondence between ATISP (t; s) and pIPTISP (t; s) .
Reference: [37] <author> J. Hartmanis, N. Immerman, and V. Sewelson. </author> <title> Sparse sets in NP P : EXPTIME versus NEXPTIME. </title> <journal> Inf. and Control, </journal> <volume> 65 </volume> <pages> 158-181, </pages> <year> 1985. </year>
Reference-contexts: NEXP (cf. <ref> [37] </ref>, [38]). Although there exist oracles which collapse these classes, this fact no longer seems as discouraging as it used to be, in view of a substantial mass of new techniques that do not relativize.
Reference: [38] <author> H. Heller. </author> <title> On relativized exponential and probabilistic complexity classes. </title> <journal> Information and Computation, </journal> <volume> 71 </volume> <pages> 231-243, </pages> <year> 1986. </year>
Reference-contexts: NEXP (cf. [37], <ref> [38] </ref>). Although there exist oracles which collapse these classes, this fact no longer seems as discouraging as it used to be, in view of a substantial mass of new techniques that do not relativize.
Reference: [39] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1979. </year>
Reference-contexts: It is easily observed (see for example <ref> [39, Theorem 12.10a] </ref>) that a TM that uses at most t time uses at most t space. <p> It is easily observed (see for example [39, Theorem 12.10a]) that a TM that uses at most t time uses at most t space. So DTIME (t) = DTISP (t; t) 18 For space it is observed (see for example <ref> [39, Theorem 12.10b] </ref>) that if a TM M uses at most s space then there exists a constant c such that M uses at most c s time, because we have assumed that M always halts. <p> See a very similar argument due to Hartmanis, Lewis and Stearns [36] for DSPACE (s) in <ref> [39, Theorem 12.8] </ref>. We get a hierarchy theorem for pIPTISP (t; s), as a consequence of our correspondence between ATISP (t; s) and pIPTISP (t; s) .
Reference: [40] <author> O. H. Ibarra. </author> <title> A note concerning nondeterministic tape complexities. </title> <journal> J. ACM, </journal> <volume> 19(4) </volume> <pages> 608-612, </pages> <year> 1972. </year>
Reference-contexts: reals 1 r &lt; s, pIPTIME (n r ) pIPTIME (n s ); pIPSPACE (n r ) pIPSPACE (n s ) and pIPSPACE (log r n) pIPSPACE (log s n): proof : Given Theorem 5.5.2 the proof is similar to the proof of similar results for NSPACE (s) by Ibarra <ref> [40] </ref> and NTIME (t) by Cook [22]. 5.6 Interactive Proof Systems for Deterministic Computation Corollaries 5.3.3 and 5.3.4 exhibit interactive proof systems with verifiers having low time-space complexity for P and NC .
Reference: [41] <author> N. Immerman. </author> <title> Nondeterministic space is closed under complement. </title> <booktitle> In Proc. of the 3rd Conference on Structure in Complexity Theory, </booktitle> <pages> pages 112-115, </pages> <year> 1988. </year>
Reference-contexts: Fact 2.3.2 (Immerman <ref> [41] </ref> and Szelepcsenyi [63]) Let s (n) log n then coNSPACE (s) = NSPACE (s) 20 2.3.3 Alternating Complexity We define time and space of a ATM just as for a NTM and we get the classes ATISP (t; s), ATIME (t) and ASPACE (s).
Reference: [42] <author> R. Impagliazzo and M. Yung. </author> <title> Direct minium-knowledge computation. </title> <booktitle> In Proc. Crypto 87, </booktitle> <pages> pages 40-51. </pages> <note> LNCS 293, </note> <year> 1987. </year>
Reference-contexts: On the other hand Impagliazzo and Yung <ref> [42] </ref> and independently Ben-Or, Goldreich, Goldwasser, Hastad, Kilian, Micali and Rogaway [10], using a protocol by Goldwasser, Micali and Wigderson [33], showed that every language in IP has a zero-knowledge single prover interactive proof given that honest one-way functions exists.
Reference: [43] <author> R. Karp and R. Lipton. </author> <title> Some connections between nonuniform and uniform complexity classes. </title> <booktitle> In Proc. of the 12th ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 302-309, </pages> <year> 1980. </year>
Reference-contexts: Corollary 6.3.9 There exist PSPACE-complete and EXP-complete fami lies of functions with self-testing/correcting pairs. 6.4 Circuit Results Our results give some corollaries that relate non-uniform complexity classes to uniform complexity classes. Karp and Lipton <ref> [43] </ref> showed that if every 100 language in NP has polynomial size circuits then the polynomial time hierarchy collapses to the second level. We get similar results for P #P , PSPACE and EXP.
Reference: [44] <author> R. M. Karp. </author> <title> Reducibility among combinatorial problems. </title> <editor> In R. E. Miller and J. W. Thatcher, editors, </editor> <booktitle> Complexity of Computer Computations, Advances in Computing Research, </booktitle> <pages> pages 85-103. </pages> <publisher> Plenum Press, </publisher> <year> 1972. </year>
Reference-contexts: that there are #P problems, which are hard for the polynomial time hierarchy, in the sense that given an oracle for the problem then we can recognize any language in PH in polynomial time. 2.5 Completeness One of the most important concepts introduced by Cook [20], Levin [45] and Karp <ref> [44] </ref> to study complexity classes is reduction. Reductions enable us to talk about the relative hardness of problems. So if we can reduce a problem A to a problem B with a reduction r then we can say that problem A in some way is not harder than B.
Reference: [45] <author> L. Levin. </author> <title> Universal'nye perebornye zadachi (Universal search problems : in Russian). </title> <journal> Problemy Peredachi Informatsii, </journal> <volume> 9(3) </volume> <pages> 265-266, </pages> <year> 1973. </year> <month> 106 </month>
Reference-contexts: Toda [64] showed that there are #P problems, which are hard for the polynomial time hierarchy, in the sense that given an oracle for the problem then we can recognize any language in PH in polynomial time. 2.5 Completeness One of the most important concepts introduced by Cook [20], Levin <ref> [45] </ref> and Karp [44] to study complexity classes is reduction. Reductions enable us to talk about the relative hardness of problems. <p> See Garey and Johnson's excellent book [31] on completeness for an extensive list of complete problem and a more detailed discussion of completeness. A lot of complete problems arise in logic. Cook [20] and Levin <ref> [45] </ref> found the first complete problem for NP . They showed that SAT is NP -complete. SAT is the set of CNF formula ', which has a satisfying assignment.
Reference: [46] <author> R. Lipton. </author> <title> New directions in testing. </title> <editor> In J. Feigenbaum and M. Mer-ritt, editors, </editor> <booktitle> Distributed Computing and Cryptography, volume 2 of DI-MACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <pages> pages 191-202. </pages> <publisher> American Mathematical Society, </publisher> <year> 1991. </year>
Reference-contexts: This is directly related to the question of whether coNP languages have protocols with NP provers. 6.3.3 Self-Testing and Self-Correcting Programs Our test of multilinear functions (Section 4.4) also has applications to program testing as described by Blum, Luby and Rubinfeld [14] and Lipton <ref> [46] </ref>. We will use the following definition from Blum, Luby and Rubinfeld: A pair of probabilistic programs (T; S) is a self-testing/correcting pair for f if given a program P as an oracle, 1. If P computes f correctly on every input then T P always accepts. 2. <p> If we apply Theorem 4.4.1 with p = 1=2 n and ff = n 2 we fulfill exactly the first two requirements above. We will use ideas of Beaver, Feigenbaum [9] and Lipton <ref> [46] </ref> to create the correcting function S. Suppose we wish to compute f (x 1 ; : : :; x n ).
Reference: [47] <author> C. Lund, L. Fortnow, H. Karloff, and N. Nisan. </author> <title> Algebraic methods for interactive proof systems. </title> <journal> J. of the ACM, </journal> <volume> 39(4) </volume> <pages> 859-868, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: This result is joint work with Fortnow, Karloff and Nisan <ref> [47] </ref>. We furthermore for sake of completeness present an extension of our result due to Shamir [56], which shows that every language in PSPACE has an interactive proof. In Chapter 4 we show that every language in NEXP has a two prover interactive proof.
Reference: [48] <author> P. Orponen. </author> <title> Complexity classes of alternating machines with oracles. </title> <booktitle> In Proc. of the 10th International Colloquium on Automata, Languages and Programming, </booktitle> <pages> pages 573-584. </pages> <note> LNCS 154, </note> <year> 1983. </year>
Reference-contexts: Thus by summing over all z, i.e., over invalid, rejecting and accepting computations, we get that the sum is equal to the number of accepting computations. The following result is essentially due to J. Simon [58]; similar proofs appear in Peterson and Reif [51] and Orponen <ref> [48] </ref>. It is a NEXP version of the Cook-Levin Theorem. It states that given a language L in NEXP there is for each input x a 3-CNF formula with exponential number of variables 48 and clauses that is satisfiable if and only if x 2 L.
Reference: [49] <author> C. Papadimitriou. </author> <title> Games against nature. </title> <journal> J. of Computer and System Sciences, </journal> <volume> 31 </volume> <pages> 288-301, </pages> <year> 1985. </year>
Reference-contexts: The sum of the degrees is n (3m + n). 42 3. The verifier uses O (n 2 + nm) arithmetic operations. And since TQBF is PSPACE-complete we get that Theorem 3.2.11 (Shamir [56]) PSPACE IP Hence from the result by Papadimitriou <ref> [49] </ref> that IP PSPACE we then know that IP = PSPACE. Furthermore Feldman [23] showed that the honest prover lives in PSPACE. CHAPTER 4 THE POWER OF INTERACTION WITH TWO PROVERS In this chapter we will show that any language in NEXP has a two prover interactive proof system.
Reference: [50] <author> W. J. Paul, E. J. Prau, and R. Reischuk. </author> <title> On alternation. </title> <journal> Acta Infor-matica, </journal> <volume> 14 </volume> <pages> 243-255, </pages> <year> 1980. </year>
Reference-contexts: First we will restrict the number of tapes to one and we prove that this 76 does not decrease the computational power. Paul, Prau and Reischuk in <ref> [50] </ref> proved such a theorem for ATIME (t). Theorem 5.1.1 (Paul, Prau and Reischuk [50].) Let L be a language in ATIME (t (n)). There exists a 1-tape alternating turing machine M such that M works in time O (t (n)) and L (M ) = L. <p> First we will restrict the number of tapes to one and we prove that this 76 does not decrease the computational power. Paul, Prau and Reischuk in <ref> [50] </ref> proved such a theorem for ATIME (t). Theorem 5.1.1 (Paul, Prau and Reischuk [50].) Let L be a language in ATIME (t (n)). There exists a 1-tape alternating turing machine M such that M works in time O (t (n)) and L (M ) = L. We need to extend their result to ATISP (t; s).
Reference: [51] <author> G. Peterson and J. Reif. </author> <title> Multiple-person alternation. </title> <booktitle> In Proc. of the 20th IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 348-363, </pages> <year> 1979. </year>
Reference-contexts: Thus by summing over all z, i.e., over invalid, rejecting and accepting computations, we get that the sum is equal to the number of accepting computations. The following result is essentially due to J. Simon [58]; similar proofs appear in Peterson and Reif <ref> [51] </ref> and Orponen [48]. It is a NEXP version of the Cook-Levin Theorem. It states that given a language L in NEXP there is for each input x a 3-CNF formula with exponential number of variables 48 and clauses that is satisfiable if and only if x 2 L. <p> particular can we show that the class of languages accepted by an interactive proof system with a polynomial-time, log-space verifier is equal to P? * Can we prove similar kinds of relationships as in Chapter 5 for different models? For example, consider the multiple-person alternation model of Peterson and Reif <ref> [51] </ref> and the multiple-prover interactive proof system.
Reference: [52] <author> V. Pratt. </author> <title> Every prime has a succinct certificate. </title> <journal> SIAM J. on Computing, </journal> <volume> 4 </volume> <pages> 214-220, </pages> <year> 1975. </year>
Reference-contexts: It remains for the verifier to choose proper ff i and fi i . The following observations provide the key to this. 31 Protocol 1 P!V: a prime p 2 [2 n + 1; 2 n+1 ] and a proof that p is a prime. From Pratt <ref> [52] </ref> we know that there exists a polynomial length proof for the fact that p is indeed a prime. V: fi 0 s. P!V: q i a polynomial over F p of degree at most 3m.
Reference: [53] <author> W. Ruzzo. </author> <title> On uniform circuit complexity. </title> <journal> J. of Computer and System Sciences, </journal> <volume> 22 </volume> <pages> 365-381, </pages> <year> 1981. </year>
Reference-contexts: 2.3.3 (Chandra, Kozen and Stockmeyer [16]) * For s (n) log n, ASPACE (s (n)) = S c&gt;0 DTIME (c s (n) ) . * For t (n) n, ATIME (t (n)) DSPACE (t (n)) ATIME (t (n) 2 ). and therefore AP = PSPACE and APSPACE = EXP Ruzzo <ref> [53] </ref> studied the class NC, which is the class of languages that have polynomial size and poly-logarithmic depth uniform circuits (see section 2.3.5. He looked at alternating machines which are allowed only poly-logarithmic time and logarithmic space. <p> In this Chapter we generalize the work in Chapter 3 to exhibit a broader equivalence between alternating Turing machines and interactive proof systems. We look at time-space complexity, first studied for alternating Turing machines by Ruzzo <ref> [53] </ref> and for interactive proof systems by Condon [18]. In this Chapter we will only study interactive proof systems with public coins. <p> The previous best result known, by Fortnow and Sipser [28], proves that LOGCFL has a public-coin interactive proof system with a polynomial-time log-space verifier. LOGCFL consists of all languages log-space reducible to context-free languages and is known to lie in NC 2 <ref> [61, 62, 53] </ref>. Furthermore, we use this relationship to obtain a hierarchy for public-coin interactive proof systems. <p> similar to the relationships between alternating Turing machine and deterministic computation found in Section 2.3.3 due to Chandra, Kozen and Stockmeyer [16]. 5.1 Restricted Alternating Turing Machines In this chapter we will use the "random access input" model for an alternating Turing Machine similar to the one described by Ruzzo <ref> [53] </ref>. This will allow us to study ATMs which use sublinear time. In our model, the alternating machine M has two special states, q 0 and q 1 . <p> Corollary 5.3.4 Every language in NC = S k NC k has a public-coin interactive proof system with a verifier using O (log (n)) space and O (n log 2 n) time. proof : Ruzzo <ref> [53] </ref> shows that any language in NC can be accepted by an alternating Turing machine using poly-log time and log space. <p> So the value of the initial configuration can be calculated by a uniform (space O (s (n))) circuit of depth O (t (n) log t (n)). By a result by Ruzzo <ref> [53] </ref> an alternating Turing Machine can evaluate each bit of the value of the initial configuration in time O (t (n) log t (n)) and space O (s (n)). Condon [18] and Fortnow and Sipser [28] independently proved the fol lowing fact, which follows from Theorem 5.4.1.
Reference: [54] <author> W. J. Savitch. </author> <title> Relationship between nondeterministic and deterministic tape complexities. </title> <journal> J. Computer System Science, </journal> <volume> 4 </volume> <pages> 177-192, </pages> <year> 1970. </year>
Reference-contexts: We also define NP's polynomial space and exponential time equivalents NPSPACE := 1 [ NSPACE (n k ) NEXP := 1 [ NTIME (2 n k ) There are two important results about nondeterministic space. The first relate nondeterministic space to deterministic space: Fact 2.3.1 (Savitch <ref> [54] </ref>) Let s be fully space-constructible and s (n) log 2 n then DSPACE (s) NSPACE (s) DSPACE (s 2 ) and therefore PSPACE = NPSPACE The second states that nondeterministic space is closed under complement.
Reference: [55] <author> J. T. Schwartz. </author> <title> Probabilistic algorithms for verification of polynomial identities. </title> <journal> J. of the ACM, </journal> <volume> 27 </volume> <pages> 701-717, </pages> <year> 1980. </year>
Reference-contexts: So the degree of h fi (x) is m unless fi is a root in the nonzero multivariate polynomial X P a d 1 ;d 2 ;:::;d n x d 1 2 x d n Since any nonzero multivariate polynomial has at most q n1 deg (g) q n1 nk <ref> [55] </ref> roots, if we choose fi at random and uniformly from F n q , then the degree of h fi (x) will, with probability at least 1 nk q , be deg (g).
Reference: [56] <author> A. Shamir. </author> <title> IP = PSPACE. </title> <journal> J. of the ACM, </journal> <volume> 39(4) </volume> <pages> 869-877, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: This result is joint work with Fortnow, Karloff and Nisan [47]. We furthermore for sake of completeness present an extension of our result due to Shamir <ref> [56] </ref>, which shows that every language in PSPACE has an interactive proof. In Chapter 4 we show that every language in NEXP has a two prover interactive proof. This result is joint work with Babai and Fortnow [6]. <p> So there is no way the verifier can even read this polynomial. So we need a trick to keep the degree low. Shamir in <ref> [56] </ref> introduced dummy variables to take care of this problem. We will instead use an idea by Shen [57] since Shen's trick will make the interactive proof systems very simple and similar to the protocol for #P . <p> The sum of the degrees is n (3m + n). 42 3. The verifier uses O (n 2 + nm) arithmetic operations. And since TQBF is PSPACE-complete we get that Theorem 3.2.11 (Shamir <ref> [56] </ref>) PSPACE IP Hence from the result by Papadimitriou [49] that IP PSPACE we then know that IP = PSPACE. Furthermore Feldman [23] showed that the honest prover lives in PSPACE.
Reference: [57] <author> A. Shen. </author> <title> IP = PSPACE: A simplified proof. </title> <journal> J. of the ACM, </journal> <volume> 39(4) </volume> <pages> 878-880, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: So there is no way the verifier can even read this polynomial. So we need a trick to keep the degree low. Shamir in [56] introduced dummy variables to take care of this problem. We will instead use an idea by Shen <ref> [57] </ref> since Shen's trick will make the interactive proof systems very simple and similar to the protocol for #P .
Reference: [58] <author> J. Simon. </author> <title> On some central problems in computational complexity. </title> <type> PhD thesis, </type> <institution> Cornell University, Computer Science, </institution> <year> 1975. </year> <type> Tech Report TR 75-224. 107 </type>
Reference-contexts: Thus by summing over all z, i.e., over invalid, rejecting and accepting computations, we get that the sum is equal to the number of accepting computations. The following result is essentially due to J. Simon <ref> [58] </ref>; similar proofs appear in Peterson and Reif [51] and Orponen [48]. It is a NEXP version of the Cook-Levin Theorem.
Reference: [59] <author> L. J. Stockmeyer. </author> <title> The polynomial-time hierachy. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 1-22, </pages> <year> 1976. </year>
Reference-contexts: We let P The polynomial time hierarchy PH was defined by Stockmeyer <ref> [59] </ref> as PH := i=0 i A question related to P ? = NP is whether PH collapses to a finite level, i.e., if 9k : PH = i=0 P i . Observe that if P = NP then PH = 0 . <p> So if given a CNF formula ' we let #' be the number of 26 satisfying assignments then the function #3-SAT defined by #3-SAT: ' 7! #' is #P -complete. #P -complete is defined relative to Turing reductions. A PSPACE -complete problem is TQBF (True Quantified Boolean Formula) <ref> [60, 59] </ref>.
Reference: [60] <author> L. J. Stockmeyer and A. R. Meyer. </author> <title> Word problems requiring exponential time. </title> <booktitle> In Proc. of the 5th ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 1-9, </pages> <year> 1973. </year>
Reference-contexts: So if given a CNF formula ' we let #' be the number of 26 satisfying assignments then the function #3-SAT defined by #3-SAT: ' 7! #' is #P -complete. #P -complete is defined relative to Turing reductions. A PSPACE -complete problem is TQBF (True Quantified Boolean Formula) <ref> [60, 59] </ref>.
Reference: [61] <author> I. Sudborough. </author> <title> Time and tape bounded auxiliary pushdown automata. </title> <booktitle> Mathematical Foundations of Computer Science, </booktitle> <pages> pages 493-503, </pages> <year> 1977. </year>
Reference-contexts: They also proved that LOGCFL IPTISP (poly; log n) where LOGCFL NC 2 is the class of languages log-space reducible to context-free languages <ref> [61, 62] </ref>. Condon and Lipton [19] showed that if the verifier has constant work space but infinite time then interactive proof systems can recognize any recursively enumerable language. This is true, assuming we loosen our assumption that the verifier always halts. <p> The previous best result known, by Fortnow and Sipser [28], proves that LOGCFL has a public-coin interactive proof system with a polynomial-time log-space verifier. LOGCFL consists of all languages log-space reducible to context-free languages and is known to lie in NC 2 <ref> [61, 62, 53] </ref>. Furthermore, we use this relationship to obtain a hierarchy for public-coin interactive proof systems.
Reference: [62] <author> I. Sudborough. </author> <title> On the tape complexity of deterministic context free languages. </title> <journal> J. of the ACM, </journal> <volume> 25(3) </volume> <pages> 405-414, </pages> <year> 1978. </year>
Reference-contexts: They also proved that LOGCFL IPTISP (poly; log n) where LOGCFL NC 2 is the class of languages log-space reducible to context-free languages <ref> [61, 62] </ref>. Condon and Lipton [19] showed that if the verifier has constant work space but infinite time then interactive proof systems can recognize any recursively enumerable language. This is true, assuming we loosen our assumption that the verifier always halts. <p> The previous best result known, by Fortnow and Sipser [28], proves that LOGCFL has a public-coin interactive proof system with a polynomial-time log-space verifier. LOGCFL consists of all languages log-space reducible to context-free languages and is known to lie in NC 2 <ref> [61, 62, 53] </ref>. Furthermore, we use this relationship to obtain a hierarchy for public-coin interactive proof systems.
Reference: [63] <author> R. Szelepcsenyi. </author> <title> The method of forcing for nondeterministic automata. Bull. </title> <booktitle> European Association Theoretical Computer Science, </booktitle> <pages> pages 145-152, </pages> <year> 1987. </year>
Reference-contexts: Fact 2.3.2 (Immerman [41] and Szelepcsenyi <ref> [63] </ref>) Let s (n) log n then coNSPACE (s) = NSPACE (s) 20 2.3.3 Alternating Complexity We define time and space of a ATM just as for a NTM and we get the classes ATISP (t; s), ATIME (t) and ASPACE (s).
Reference: [64] <author> S. </author> <title> Toda. </title> <booktitle> On the computational power of PP and P. In Proc. of the 30th IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 514-519, </pages> <year> 1989. </year>
Reference-contexts: The class #P of functions introduced by Valiant in [66] is the class describable as #M for some polynomial time NTM M . #P := f#M j M is a polynomial time NTMg Recently Toda <ref> [64] </ref> showed that there are #P problems, which are hard for the polynomial time hierarchy, in the sense that given an oracle for the problem then we can recognize any language in PH in polynomial time. 2.5 Completeness One of the most important concepts introduced by Cook [20], Levin [45] and <p> This implies, using a recent result by Toda <ref> [64] </ref>, that every language in PH and, in particular, every language in coNP has interactive proof systems. Before this result, there were only a few interactive proof systems known for languages not known to belong to NP.
Reference: [65] <author> A. </author> <title> Turing. On computable numbers with an application to the Entscheidungs-problem. </title> <journal> Proc. London Math. Soc., </journal> <volume> 42(2) </volume> <pages> 230-265, </pages> <year> 1936. </year> <title> A correction, </title> <journal> ibid., </journal> <volume> 43 </volume> <pages> 544-546. </pages>
Reference-contexts: Later we will define models that add features to the basic model. 2.2.1 Deterministic Computation Our basic computational device is the Deterministic k-tape Turing Machine (TM), where k is some integer constant. TMs were introduced by Turing <ref> [65] </ref> in 1936. It models the everyday computer and operates, like the computer, in discrete time steps. At each time step it will change its internal configuration according to some simple rules. A TM consists of tapes, tapeheads and a finite control.
Reference: [66] <author> L. Valiant. </author> <title> The complexity of computing the permanent. </title> <journal> Theoretical Computer Science, </journal> <volume> 8 </volume> <pages> 189-201, </pages> <year> 1979. </year>
Reference-contexts: Given a NTM M define #M : fl ! N by letting #M (x) equals the number of accepting paths of M on input x. The class #P of functions introduced by Valiant in <ref> [66] </ref> is the class describable as #M for some polynomial time NTM M . #P := f#M j M is a polynomial time NTMg Recently Toda [64] showed that there are #P problems, which are hard for the polynomial time hierarchy, in the sense that given an oracle for the problem <p> There are natural classes of languages satisfying the conclusion of Lemma 6.3.2 which are not known to be PSPACE-robust; P #P -complete languages being the prime example, since they are equivalent to the permanent, a multilinear function (Valiant <ref> [66] </ref>). 97 6.3.2 Instance Checking In Blum and Kannan [13], function-restricted IP is defined as follows.
References-found: 66

