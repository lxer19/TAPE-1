URL: http://www.eecs.umich.edu/~zuberi/research/csd.ps
Refering-URL: http://www.eecs.umich.edu/~zuberi/research/
Root-URL: http://www.cs.umich.edu
Email: fzuberi,kgshing@eecs.umich.edu  
Title: Combined EDF and RM Scheduling: A Practical Solution  
Author: Khawar M. Zuberi and Kang G. Shin 
Keyword: Real-time operating systems, implementation of scheduling algorithms, earliest-deadline-first (EDF) and rate-monotonic (RM) scheduling, schedulability and runtime over heads.  
Address: Ann Arbor, MI 48109-2122  
Affiliation: Real-Time Computing Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: The earliest-deadline-first (EDF) scheduling scheme ideally schedules workloads with utilizations of up to 100%. But this is a theoretical limit which is not achieved in practice because of the high run-time overhead incurred by EDF in sorting tasks according to deadlines. On the other hand, the rate-monotonic (RM) scheme has a much lower run-time overhead since it does not have to repeatedly re-sort the tasks, but its schedulable utilization is usually well below 100%. For a practitioner, the sum of these two overheads (the run-time overhead plus schedulable utilization being less than 100%), which we call the total scheduling overhead, is a "true" measure of the performance of a scheduler because it indicates how many CPU cycles will actually be available for execution of application tasks. We developed a mechanism to partition tasks in a given workload into two groups, and we demonstrate that when one group is scheduled by EDF and the other by RM, the resulting total scheduling overhead is less than that for either EDF or RM alone. We implemented this scheme (which we call combined static/dynamic (CSD) scheduling) and experimental measurements show that the total scheduling overhead of CSD is 20-40% less than the overheads of EDF and RM, which enables CSD to feasibly schedule workloads with as much as 10 percentage points greater utilizations than those feasible under EDF or RM when execution overheads are factored in. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. G. Shin and P. Ramanathan, </author> <title> "Real-time computing: a new discipline of computer science and engineering," </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> vol. 82, no. 1, </volume> <pages> pp. 6-24, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Real-time computing systems must behave predictably even in unpredictable environments <ref> [1] </ref>. This predictability is ensured by system-level services, most important among them being the task scheduler in the underlying real-time operating system (RTOS). fl The work reported in this paper was supported in part by the NSF under Grant MIP-9203895, and by the ONR under Grant N00014-94-1-0229.
Reference: [2] <author> C. L. Liu and J. W. Layland, </author> <title> "Scheduling algorithms for multiprogramming in a hard real-time environment," </title> <journal> Journal of the ACM, </journal> <volume> vol. 20, no. 1, </volume> <pages> pp. 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: This has led to the development of well-known scheduling schemes such as rate-monotonic (RM) <ref> [2] </ref>, earliest-deadline-first (EDF) [2], and deadline-monotonic [3]. But in recent years, the focus of research has shifted from uniprocessor task scheduling to scheduling tasks and messages in multiprocessors and distributed systems [6-8]. Uniprocessor task scheduling is treated as a "solved" problem and research in this area has tapered off. <p> This has led to the development of well-known scheduling schemes such as rate-monotonic (RM) <ref> [2] </ref>, earliest-deadline-first (EDF) [2], and deadline-monotonic [3]. But in recent years, the focus of research has shifted from uniprocessor task scheduling to scheduling tasks and messages in multiprocessors and distributed systems [6-8]. Uniprocessor task scheduling is treated as a "solved" problem and research in this area has tapered off. <p> Each task t i has a period P i , execution time c i , and deadline d i . Then this workload has utilization U = i=1 c i =P i . EDF is a dynamic-priority scheduler which gives highest priority to the earliest-deadline task <ref> [2] </ref>, and can schedule all workloads with U 1 under the ideal condition that EDF's run-time overhead is ignored. We say that U fl = 1 for EDF. Other schedulers such as RM (which schedules tasks according to fixed priorities based on the tightness of their P i [2]) can have <p> earliest-deadline task <ref> [2] </ref>, and can schedule all workloads with U 1 under the ideal condition that EDF's run-time overhead is ignored. We say that U fl = 1 for EDF. Other schedulers such as RM (which schedules tasks according to fixed priorities based on the tightness of their P i [2]) can have U fl &lt; 1. For example, a workload with U = 0:90 may be schedulable under RM, but if some c i is slightly increased so that U becomes 0:91, the workload may no longer be schedulable even under ideal conditions. <p> Considering that CSD has no schedulability overhead, it easily outperforms both EDF and RM. 3.5 Schedulability Test A task set ft i : i = 1; 2; : : :; ng with tasks sorted by their RM-priority (tasks with shorter periods have lower index i) is feasible under EDF if <ref> [2] </ref> U = i=1 P i where t (EDF ) is t for EDF. <p> A 1; where the function dxe fl excludes the last invocation of j released before time t if its deadline exceeds d i : ~ P k = &lt; l P k t m l P k 1 otherwise This test for DP2 tasks uses the critical time zone assumption <ref> [2] </ref> which is valid only if all DP1 and DP2 tasks have utilization 1 ( P r c i +t (X) 12 task, respectively). Note that because of the check for deadlines, the critical time zone assumption is not automatically valid here as it is under rate-monotonic analysis. <p> As such, our scheme is orthogonal to scheduling schemes which handle varying QoS requirements. The two can be combined by using CSD to schedule one or more queues of a QoS scheduler. Liu and Layland in their seminal paper <ref> [2] </ref> also proposed combining EDF and RM. Their motivation was to exploit fixed CPU interrupt priorities to schedule short-period tasks while using a software EDF scheduler for long-period tasks. High-priority tasks get scheduled by fixed-priority scheduling (using hardware mechanisms) while low-priority tasks are scheduled using software deadline-driven scheduling.
Reference: [3] <author> J. Y.-T. Leung and J. Whitehead, </author> <title> "On the complexity of fixed-priority scheduling of periodic, real-time tasks," </title> <journal> Performance Evaluation, </journal> <volume> vol. 2, no. 4, </volume> <pages> pp. 237-250, </pages> <month> December </month> <year> 1982. </year>
Reference-contexts: This has led to the development of well-known scheduling schemes such as rate-monotonic (RM) [2], earliest-deadline-first (EDF) [2], and deadline-monotonic <ref> [3] </ref>. But in recent years, the focus of research has shifted from uniprocessor task scheduling to scheduling tasks and messages in multiprocessors and distributed systems [6-8]. Uniprocessor task scheduling is treated as a "solved" problem and research in this area has tapered off. <p> The first queue is the dynamic-priority (DP) queue which contains tasks to be scheduled by EDF. The second queue is the fixed-priority (FP) queue which contains tasks to be scheduled by RM (or any other fixed-priority scheduler such as deadline-monotonic <ref> [3] </ref>, but for simplicity, we assume RM is the policy used for the FP queue).
Reference: [4] <author> B. Sprunt, L. Sha, and J. Lehoczky, </author> <title> "Aperiodic task scheduling for hard-real-time systems," </title> <booktitle> Real-Time Systems, </booktitle> <volume> vol. 1, no. 1, </volume> <pages> pp. 27-60, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: These schedulers do not require any costly off-line analysis, can easily handle changes in the workload during the design process, and can handle aperiodic tasks as well using, for example, a sporadic server <ref> [4] </ref>. However, since priority-driven schedulers make run-time scheduling decisions, they incur overhead which can be 5-15% of CPU time.
Reference: [5] <author> A. C. Audsley, A. Burns, and A. J. Wellings, </author> <title> "Deadline monotonic scheduling theory and application," </title> <journal> Control Engineering Practice, </journal> <volume> vol. 1, no. 1, </volume> <pages> pp. 71-78, </pages> <year> 1993. </year>
Reference: [6] <author> J. Xu, </author> <title> "Multiprocessor scheduling of processes with release times, deadlines, precedence, and exclusion relations," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 19, no. 2, </volume> <pages> pp. 139-93, </pages> <year> 1993. </year>
Reference: [7] <author> D. D. Kandlur, K. G. Shin, and D. Ferrari, </author> <title> "Real-time communication in multihop networks," </title> <journal> IEEE Trans. Parallel and Distributed Systems, </journal> <volume> vol. 5, no. 10, </volume> <pages> pp. 1044-1056, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: The ERCOS task scheduler [17] uses separate queues for preemptive and non-preemptive tasks. Multiple queues are used in network scheduling to combine different types of traffic on the same link in a switched network <ref> [7, 18, 19] </ref>. But in all these cases, multiple queues are used to share a single resource (CPU or network link) between tasks/messages with different quality of service (QoS) requirements. What is novel about CSD is the use of multiple queues to improve performance.
Reference: [8] <author> T. Abdelzaher and K. G. Shin, </author> <title> "Optimal combined task and message scheduling in distributed real-time systems," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <pages> pp. 162-171, </pages> <year> 1995. </year>
Reference: [9] <author> J. Lehoczky, L. Sha, and Y. Ding, </author> <title> "The rate monotonic scheduling algorithm: exact characterization and average case behavior," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <year> 1989. </year>
Reference-contexts: EDF incurs high run-time overhead in keeping tasks sorted by their (changing) deadlines. When this overhead is taken into consideration, the CPU capacity left for workload tasks is well below 100%. The static RM scheduler has much lower run-time overhead but its average-case schedulable utilization is only 88% <ref> [9] </ref> | well below that for EDF. In practice, neither EDF nor RM deliver good performance. In fact, for many real workloads, performance of both these schedulers is about the same [10]. The recent popularity of multimedia applications has led to renewed interest in making uniprocessor task scheduling efficient. <p> Previous work has shown that on average, U fl = 0:88 for RM <ref> [9] </ref>. To see why U fl for RM is less than that for EDF, consider the workload shown in Table 1. Each task t i has deadline d i = P i . <p> The workload is feasible under RM if <ref> [9] </ref> 8i; 1 i n; min 0 i X c j + t (RM ) & P j A 1: In practice, this equation need only be evaluated for a finite number of t values as described in [14]. Schedulability under CSD is tested as follows.
Reference: [10] <author> K. Kettler, D. Katcher, and J. Strosnider, </author> <title> "A modeling methodology for real-time/multimedia operating systems," </title> <booktitle> in Proc. Real-Time Technology and Applications Symposium, </booktitle> <pages> pp. 15-26, </pages> <year> 1996. </year>
Reference-contexts: The static RM scheduler has much lower run-time overhead but its average-case schedulable utilization is only 88% [9] | well below that for EDF. In practice, neither EDF nor RM deliver good performance. In fact, for many real workloads, performance of both these schedulers is about the same <ref> [10] </ref>. The recent popularity of multimedia applications has led to renewed interest in making uniprocessor task scheduling efficient. In [11], a delayed preemption scheme is presented in which a running task is preempted only at quantized time boundaries.
Reference: [11] <author> R. Gopalakrishnan and G. Parulkar, </author> <title> "Bringing real-time theory and practice closer for multi-media computing," </title> <booktitle> in SIGMETRICS, </booktitle> <pages> pp. 1-12, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: In practice, neither EDF nor RM deliver good performance. In fact, for many real workloads, performance of both these schedulers is about the same [10]. The recent popularity of multimedia applications has led to renewed interest in making uniprocessor task scheduling efficient. In <ref> [11] </ref>, a delayed preemption scheme is presented in which a running task is preempted only at quantized time boundaries. This scheme is useful for protocol data processing since it allows relatively short packet-handling tasks to execute to completion before being preempted.
Reference: [12] <author> M. B. Jones, D. Rosu, and M.-C. Rosu, </author> <title> "CPU reservations and time constraints: Efficient, predictable scheduling of independet activities," </title> <booktitle> in Proc. Symposium on Operating Systems Principles, </booktitle> <pages> pp. 198-211, </pages> <month> October </month> <year> 1997. </year>
Reference-contexts: This scheme is useful for protocol data processing since it allows relatively short packet-handling tasks to execute to completion before being preempted. However, utility of such delayed preemption schedulers in handling application task workloads is yet to be demonstrated. The Rialto scheduler <ref> [12] </ref> uses time-slice scheduling to reduce run-time overhead to a minimum, but it employs heuristics for constructing the schedule, resulting in non-optimal solutions. We had to face the issue of execution overheads of task schedulers in our research related to resource-constrained embedded systems.
Reference: [13] <author> K. M. Zuberi and K. G. Shin, "EMERALDS: </author> <title> A microkernel for embedded real-time systems," </title> <booktitle> in Proc. Real-Time Technology and Applications Symposium, </booktitle> <pages> pp. 241-249, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: The total scheduling overhead is a "true" measure of the performance of a scheduler. By reducing this total overhead, CSD outperforms both RM and EDF in real systems. We have implemented CSD in the EMERALDS (Extensible Microkernel for Embedded, ReAL-time, Distributed Systems) RTOS <ref> [13] </ref> which is being developed in the Real-Time Computing Laboratory at the University of Michigan. We measure the run-time overheads associated with CSD, EDF, and RM and we demonstrate that when these overheads are considered in schedulability tests, CSD feasibly schedules more workloads than EDF or RM.
Reference: [14] <author> C. M. Krishna and K. G. Shin, </author> <title> Real-Time Systems, </title> <publisher> McGraw-Hill, </publisher> <year> 1997. </year>
Reference-contexts: The workload is feasible under RM if [9] 8i; 1 i n; min 0 i X c j + t (RM ) & P j A 1: In practice, this equation need only be evaluated for a finite number of t values as described in <ref> [14] </ref>. Schedulability under CSD is tested as follows.
Reference: [15] <author> M68040 User's Manual, Motorola Inc., </author> <year> 1992. </year>
Reference-contexts: In particular, we want to know which is the best scheduler when all scheduling overheads (run-time and schedulability) are considered. The EDF and RM run-time overheads for EMERALDS measured on a 25MHz Motorola 68040 processor <ref> [15] </ref> with separate 4kB instruction and data caches are in Table 3. The run-time overhead of CSD is derived from these values as already discussed in Sections 3.4 and 4.2.
Reference: [16] <author> D. Katcher, H. Arakawa, and J. Strosnider, </author> <title> "Engineering and analysis of fixed priority sched-ulers," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 19, no. 9, </volume> <pages> pp. 920-934, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Measurements made using a 5MHz on-chip timer. Our test procedure involves generating random task workloads, then for each workload, scaling the execution times of tasks until the workload is no longer feasible for a given scheduler. The utilization at which the workload becomes infeasible is called the breakdown utilization <ref> [16] </ref>. We expect that with scheduling overheads considered, CSD will have the highest breakdown utilization. 5.1 Results Because scheduling overheads are a function of the number of tasks (n) in the workload, we tested all schedulers for workloads ranging from n = 5 to n = 50.
Reference: [17] <author> S. Poledna, T. Mocken, J. Schiemann, and T. Beck, "ERCOS: </author> <title> An operating system for automotive applications," </title> <booktitle> in SAE International Congress and Exposition, </booktitle> <pages> pp. 55-65, </pages> <year> 1996. </year> <type> SAE Technical Paper Series 960623. </type>
Reference-contexts: Increasing the number of queues gives some further improvement in performance, but the schedulability overhead starts increasing rapidly so that using more than three queues yields only a minimal improvement in performance. 6 Related Work Using multiple scheduling queues is not a new idea. The ERCOS task scheduler <ref> [17] </ref> uses separate queues for preemptive and non-preemptive tasks. Multiple queues are used in network scheduling to combine different types of traffic on the same link in a switched network [7, 18, 19].
Reference: [18] <author> D. Ferrari and D. Verma, </author> <title> "A scheme for real-time channel establishment in wide-area networks," </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> vol. 8, no. 3, </volume> <pages> pp. 368-379, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: The ERCOS task scheduler [17] uses separate queues for preemptive and non-preemptive tasks. Multiple queues are used in network scheduling to combine different types of traffic on the same link in a switched network <ref> [7, 18, 19] </ref>. But in all these cases, multiple queues are used to share a single resource (CPU or network link) between tasks/messages with different quality of service (QoS) requirements. What is novel about CSD is the use of multiple queues to improve performance.
Reference: [19] <author> S. Floyd and V. Jacobson, </author> <title> "Link-sharing and resource management models for packet networks," </title> <journal> IEEE/ACM Trans. Networking, </journal> <volume> vol. 3, no. 4, </volume> <pages> pp. 365-386, </pages> <month> August </month> <year> 1995. </year> <month> 19 </month>
Reference-contexts: The ERCOS task scheduler [17] uses separate queues for preemptive and non-preemptive tasks. Multiple queues are used in network scheduling to combine different types of traffic on the same link in a switched network <ref> [7, 18, 19] </ref>. But in all these cases, multiple queues are used to share a single resource (CPU or network link) between tasks/messages with different quality of service (QoS) requirements. What is novel about CSD is the use of multiple queues to improve performance.
References-found: 19

