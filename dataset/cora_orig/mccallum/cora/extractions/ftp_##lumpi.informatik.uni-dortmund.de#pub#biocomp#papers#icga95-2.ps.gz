URL: ftp://lumpi.informatik.uni-dortmund.de/pub/biocomp/papers/icga95-2.ps.gz
Refering-URL: http://www.cs.bham.ac.uk/~wbl/biblio/gp-bibliography.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: nordin@ls11.informatik.uni-dortmund.de  banzhaf@ls11.informatik.uni-dortmund.de  
Title: Evolving Turing-Complete Programs for a Register Machine with Self-modifying Code  
Author: Peter Nordin Wolfgang Banzhaf 
Address: D-44221 Dortmund  D-44221 Dortmund  
Affiliation: Universitat Dortmund Fachbereich Informatik Lehrstuhl fur Systemanalyse  Universitat Dortmund Fachbereich Informatik Lehrstuhl fur Systemanalyse  
Abstract: The majority of commercial computers today are register machines of von Neumann type. We have developed a method to evolve Turing-complete programs for a register machine. The described implementation enables the use of most program constructs, such as arithmetic operators, large indexed memory, automatic decomposition into subfunctions and subroutines (ADFs), conditional constructs i.e. if-then-else, jumps, loop structures, recursion, protected functions, string and list functions. Any C-function can be compiled and linked into the function set of the system. The use of register machine language allows us to work at the lowest level of binary machine code without any interpreting steps. In a von Neumann machine, programs and data reside in the same memory and the genetic operators can thus directly manipulate the binary machine code in memory. The genetic operators themselves are written in C-language but they modify individuals in binary representation. The result is an execution speed enhancement of up to 100 times compared to an interpreting C-language implementation, and up to 2000 times compared to a LISP implementation. The use of binary machine code demands a very compact coding of about one byte per node in the individual. The resulting evolved programs are disassembled into C-modules and can be incorporated into a conventional software development environment. The low memory requirements and the significant speed enhancement of this technique could be of use when applying genetic programming to new application areas, platforms and research domains. 
Abstract-found: 1
Intro-found: 1
Reference: <author> J. </author> <booktitle> Koza (1992) Genetic Programming, </booktitle> <address> Cambridge, MA: </address> <publisher> MIT Press. </publisher>
Reference-contexts: The language we have been using is C because it is efficient and gives the possibility to manipulate the memory where a program is stored. In genetic programming, the goal of the system is to evolve algorithms or programs in a given language <ref> (Koza 1992) </ref>. Most genetic programming systems use a tree structure for the representation of programs. The most used tree representation form is the S-expressions common in LISP. This representation guarantees evolved programs to be syntactically correct after the genetic operators are applied. In the original model (Koza 1992), the only genetic <p> in a given language <ref> (Koza 1992) </ref>. Most genetic programming systems use a tree structure for the representation of programs. The most used tree representation form is the S-expressions common in LISP. This representation guarantees evolved programs to be syntactically correct after the genetic operators are applied. In the original model (Koza 1992), the only genetic operator, apart from selection, is the subtree exchanging crossover. A few experiments have also been performed with fixed length character string representation showing the general difficulties of that approach (Cramer 1985).
Reference: <author> N.L. </author> <title> Cramer (1985). A representation for adaptive generation of simple sequential programs. In Proceedings of an International Conference on Genetic Algorithms and Their Applications, pp183-187 J.P Nordin (1994) A Compiling Genetic Programming System that Directly Manipulates the Machine-Code. </title>
Reference-contexts: In the original model (Koza 1992), the only genetic operator, apart from selection, is the subtree exchanging crossover. A few experiments have also been performed with fixed length character string representation showing the general difficulties of that approach <ref> (Cramer 1985) </ref>. This paper describes the first successful method to evolve a complex register machine with a genetic al-gorithm.
Reference: <editor> In Advances in Genetic Programming, K. Kinnear, Jr. (ed.), </editor> <address> Cambridge, MA: </address> <publisher> MIT Press. </publisher>
Reference: <author> W.A. </author> <title> Tackett (1994) Recombination, Selection and the Genetic Construction of Computer Programs. </title> <type> Dissertation, </type> <institution> Faculty of the Graduate School, UCLA, </institution> <address> CA. </address>
Reference-contexts: Several other implementations have been presented in other high level interpreting language, for instance Mathem-atica. Recently a few implementations of interpreting GP system in C has been presented <ref> (Tackett 1994) </ref>. Tackett has evaluated his elegantly written SGPS C-system and measured its performance against a LISP system. His conclusion is that the interpreting C-language GP system is about 25 times faster.
Reference: <author> S. </author> <title> Brave (1994) Evolution of a Recursive Program for Tree Search Using Genetic Programming. </title> <institution> Stanford University, Stanford, </institution> <address> CA. </address>
Reference-contexts: The halting problem makes it impossible to know in advance which recursive functions will stop and which will not. The solution to this problem is to have a global variable that is incremented for every time a function is called <ref> (Brave 1994) </ref>. If a certain limit value is reached, then the execution of the individual is abandoned. The code for this checking is placed in the header of each function 7.3 Leaf Procedures as Program Primitives. Loops are implemented in a manner similar to recursion.
References-found: 5

