URL: ftp://ftp.cs.man.ac.uk/pub/cbj/dag.ps.gz
Refering-URL: http://www.cs.man.ac.uk/fmethods/projects/pobl-development-method.html
Root-URL: http://www.cs.man.ac.uk
Title: NON-INTERFERENCE PROPERTIES OF A CONCURRENT OBJECT-BASED LANGUAGE: PROOFS BASED ON AN OPERATIONAL SEMANTICS  
Author: S. J. Hodges and C. B. Jones 
Address: M13 9PL, UK  
Affiliation: Department of Computer Science, Manchester University,  
Abstract: A carefully designed concurrent object-oriented language can provide a suitable target for a compositional design process that copes with the interference inherent with concurrency. The semantics of a particular object-based design language have been written using operational semantics and by a mapping to the first-order polyadic - calculus. This paper focuses on the operational semantics and indicates how proofs of some key properties about interference can be based on such a definition: the final theorems prove that certain equivalences -which can be used to enhance concurrency-are sound. The limitations of the operational semantics based proofs are discussed as is the interest in transferring intuitions from these proofs to ones based on a mapping to the -calculus. 
Abstract-found: 1
Intro-found: 1
Reference: [Ame89] <author> Pierre America. </author> <title> Issues in the design of a parallel object-oriented language. </title> <journal> Formal Aspects of Computing, </journal> <volume> 1(4), </volume> <year> 1989. </year>
Reference-contexts: the ofi design notation; it also motivates two equivalences concerned with concurrency. 2.1 Overview It is easiest to envisage the scope of ofi by considering a programming example even though the language is actually intended to be employed as a design notation via which programs written in languages like POOL <ref> [Ame89] </ref>, ABCL [Yon90], Beta [MMN93] or Modula-3 [Nel91] can be developed. <p> The ofi design notation is most strongly related to POOL <ref> [Ame89] </ref> to which a detailed comparison is provided in [Jon96]. The use of the word `islands' was prompted by Hogg (cf. [Hog91]) who had earlier come up with a concept which the current authors found independently. An interesting article on specification languages for objects has recently appeared [SSC95].
Reference: [Bes93] <editor> E. Best, editor. CONCUR'93: </editor> <booktitle> 4th International Conference on Concur-rency Theory, volume 715 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [Bru93] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design, static typing and semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 1-81, </pages> <year> 1993. </year>
Reference-contexts: Furthermore, the checks on the use of unique references are static. This can be straightforwardly formalized using -for example- the methods in <ref> [Bru93] </ref>. Type rules for ofi have been written (by SJH) but will be presented elsewhere. For the semantics itself, two levels of Structured Operational Semantic (SOS) reductions are defined [Plo81]. Some mild VDM notation (constructed objects, maps, etc.) is used in this paper see [Jon90].
Reference: [Hoa75] <author> C. A. R. Hoare. </author> <title> Recursive data structures. </title> <journal> International Journal of Computer & Information Sciences, </journal> <volume> 4(2) </volume> <pages> 105-132, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: The ofi class Sort in Figure 1 provides a (sequential) facility for maintaining a sequence of integers in ascending order. (In the envisaged development approach [Jon96], this program would actually be the result of a development process not unlike that envisaged by Hoare in <ref> [Hoa75] </ref> where the representations of recursive data structures are considered; proof obligations of a sequential development processes like [Jon90] suffice.) A class is a template for object structure and behaviour: it lists the instance variables with their corresponding types and defines each method's parameters, result type and implementation.
Reference: [Hog91] <author> John Hogg. </author> <title> Islands: Aliasing protection in object-oriented languages. </title> <booktitle> In [Pae91], </booktitle> <year> 1991. </year>
Reference-contexts: The ofi design notation is most strongly related to POOL [Ame89] to which a detailed comparison is provided in [Jon96]. The use of the word `islands' was prompted by Hogg (cf. <ref> [Hog91] </ref>) who had earlier come up with a concept which the current authors found independently. An interesting article on specification languages for objects has recently appeared [SSC95]. Much work remains to be done to support the full programme set out in [Jon96].
Reference: [IM91] <editor> T. Ito and A. R. Meyer, editors. </editor> <booktitle> TACS'91 Proceedings of the International Conference on Theoretical Aspects of Computer Science, Sendai, Japan, volume 526 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [Jon90] <author> C. B. Jones. </author> <title> Systematic Software Development using VDM. </title> <publisher> Prentice Hall International, </publisher> <address> second edition, </address> <year> 1990. </year> <note> ISBN 0-13-880733-7. </note>
Reference-contexts: maintaining a sequence of integers in ascending order. (In the envisaged development approach [Jon96], this program would actually be the result of a development process not unlike that envisaged by Hoare in [Hoa75] where the representations of recursive data structures are considered; proof obligations of a sequential development processes like <ref> [Jon90] </ref> suffice.) A class is a template for object structure and behaviour: it lists the instance variables with their corresponding types and defines each method's parameters, result type and implementation. An instance variable can have one of three types: integer, Boolean or (typed) reference. <p> Type rules for ofi have been written (by SJH) but will be presented elsewhere. For the semantics itself, two levels of Structured Operational Semantic (SOS) reductions are defined [Plo81]. Some mild VDM notation (constructed objects, maps, etc.) is used in this paper see <ref> [Jon90] </ref>. Object internal reductions rely on a state containing values of instance variables of the object (this is modelled as a `map' from Id to Val). = Id ! Val The only basic values considered here are natural numbers and Booleans; values in Oid correspond to references.
Reference: [Jon93a] <author> C. B. Jones. </author> <title> A pi-calculus semantics for an object-based design notation. </title> <booktitle> In [Bes93], </booktitle> <pages> pages 158-172, </pages> <year> 1993. </year>
Reference-contexts: The first semantics written for ofi was given by mapping to the -calculus [MPW92, Mil92]. Such a semantics is recorded (with some informal proofs of the general equivalences) in <ref> [Jon93b, Jon93a, Jon94] </ref>; but completely formal proofs of the general equivalences are difficult to obtain because of the need to state -for the side conditions- what can not happen. The initial reservation about the use of SOS was that there is no natural algebra of such definitions. <p> One of the current authors (CBJ) is now interested in tackling the general results based on the -calculus semantics again (cf. <ref> [Jon93a, Jon94] </ref>) using the intuitions from the SOS proofs: this train of thought has already led to experiments with state indices to process expressions. The ofi design notation is most strongly related to POOL [Ame89] to which a detailed comparison is provided in [Jon96].
Reference: [Jon93b] <author> C. B. Jones. </author> <title> Reasoning about interference in an object-based design method. </title> <booktitle> In [WL93], </booktitle> <pages> pages 1-18, </pages> <year> 1993. </year>
Reference-contexts: The first semantics written for ofi was given by mapping to the -calculus [MPW92, Mil92]. Such a semantics is recorded (with some informal proofs of the general equivalences) in <ref> [Jon93b, Jon93a, Jon94] </ref>; but completely formal proofs of the general equivalences are difficult to obtain because of the need to state -for the side conditions- what can not happen. The initial reservation about the use of SOS was that there is no natural algebra of such definitions.
Reference: [Jon94] <author> C. B. Jones. </author> <title> Process algebra arguments about an object-based design notation. </title> <booktitle> In [Ros94], chapter 14, </booktitle> <pages> pages 231-246. </pages> <year> 1994. </year>
Reference-contexts: The first semantics written for ofi was given by mapping to the -calculus [MPW92, Mil92]. Such a semantics is recorded (with some informal proofs of the general equivalences) in <ref> [Jon93b, Jon93a, Jon94] </ref>; but completely formal proofs of the general equivalences are difficult to obtain because of the need to state -for the side conditions- what can not happen. The initial reservation about the use of SOS was that there is no natural algebra of such definitions. <p> One of the current authors (CBJ) is now interested in tackling the general results based on the -calculus semantics again (cf. <ref> [Jon93a, Jon94] </ref>) using the intuitions from the SOS proofs: this train of thought has already led to experiments with state indices to process expressions. The ofi design notation is most strongly related to POOL [Ame89] to which a detailed comparison is provided in [Jon96].
Reference: [Jon96] <author> C. B. Jones. </author> <title> Accommodating interference in the formal design of concurrent object-based programs. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 8(2) </volume> <pages> 105-122, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: 1 INTRODUCTION The results in this paper relate to a broad programme of research which aims to provide compositional development methods for concurrent programs; this context is described in <ref> [Jon96] </ref>. In that reference, some concepts from object-oriented languages are argued to be useful in taming interference; the concurrent object-based design language proposed is known as ofi. <p> The specific aspect of the research programme which is addressed here is the soundness of equivalences which can be used to increase concurrency in ofi; <ref> [Jon96] </ref> also discusses the application of rely-/guarantee-conditions to reasoning about com 1 2 Chapter 1 plex interference in object-based programs but no further mention of these more powerful ways of reasoning about interference is made in the current paper. <p> Motivation for -and an operational semantics definition of- ofi are given in Section 2 as are examples of two equivalences used in <ref> [Jon96] </ref>; Section 3 contains a soundness argument for the equivalence concerning return statement commutation. <p> The ofi class Sort in Figure 1 provides a (sequential) facility for maintaining a sequence of integers in ascending order. (In the envisaged development approach <ref> [Jon96] </ref>, this program would actually be the result of a development process not unlike that envisaged by Hoare in [Hoa75] where the representations of recursive data structures are considered; proof obligations of a sequential development processes like [Jon90] suffice.) A class is a template for object structure and behaviour: it lists <p> Non-Interference Properties 19 4. Neither return nor delegate statements are allowed by the second side condition on Equivalence 10. 5. If S 2 Compound, use structural induction. 6. If S 2 If , use structural induction. Notice that cases 1, 5 and 6 reflect the argument in <ref> [Jon96] </ref> that ofi insulates against interference on instance variables; cases 2 and 3 indicate that unique references also provide insulation from interference. Theorem 12 Class definitions can be changed in accordance with Equivalence 10. <p> Nestmann and Steffan use a confluence argument about ofi in their paper in these proceedings. All of these proofs tackle specific instances of the equivalence rules which will not ultimately suffice for the pro-gramme set out in <ref> [Jon96] </ref> where the general transformations are to be applied by developers who need have no knowledge of the semantics (and certainly cannot be expected to have the skills of the cited authors in constructing proofs thereon). <p> The ofi design notation is most strongly related to POOL [Ame89] to which a detailed comparison is provided in <ref> [Jon96] </ref>. The use of the word `islands' was prompted by Hogg (cf. [Hog91]) who had earlier come up with a concept which the current authors found independently. An interesting article on specification languages for objects has recently appeared [SSC95]. <p> An interesting article on specification languages for objects has recently appeared [SSC95]. Much work remains to be done to support the full programme set out in <ref> [Jon96] </ref>. For example, as the interference logic used there stabilises, it will be necessary to undertake justification of its inference rules and this will require proofs about the relationship between logical expressions and ofi statements.
Reference: [LW95] <author> X. Liu and D. Walker. </author> <title> Confluence of processes and systems of objects. </title> <booktitle> In [MNS95], </booktitle> <pages> pages 217-231, </pages> <year> 1995. </year>
Reference-contexts: [Wal93] turns its attention to ofi and provides both a two-level operational semantics and a mapping to the higher-order - calculus (again noting a close correspondence); [Wal94] has a similar translation and tackles the justification of specific examples of the ofi equivalences using 20 Chapter 1 weak bi-simulation; more recently, <ref> [LW95] </ref> discuss the correctness of specific examples of the equivalences presented above; and [PW95] reviews conditions for determinacy in ofi. Nestmann and Steffan use a confluence argument about ofi in their paper in these proceedings.
Reference: [Mil92] <author> R. Milner. </author> <title> The polyadic -calculus: A tutorial. </title> <editor> In M. Broy, editor, </editor> <title> Logic and Algebra of Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <note> 22 Chapter 1 </note>
Reference-contexts: Proof Islands form a nested structure over which structural induction (using Theorem 11) can be performed. 4 DISCUSSION The proofs in this paper are based on an SOS definition of ofi. The first semantics written for ofi was given by mapping to the -calculus <ref> [MPW92, Mil92] </ref>. Such a semantics is recorded (with some informal proofs of the general equivalences) in [Jon93b, Jon93a, Jon94]; but completely formal proofs of the general equivalences are difficult to obtain because of the need to state -for the side conditions- what can not happen.
Reference: [MMN93] <author> Ole Lehrmann Madsen, Birger Moller-Pedersen, and Kristen Ny-gaard. </author> <title> Object Oriented Programming in the Beta Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: it also motivates two equivalences concerned with concurrency. 2.1 Overview It is easiest to envisage the scope of ofi by considering a programming example even though the language is actually intended to be employed as a design notation via which programs written in languages like POOL [Ame89], ABCL [Yon90], Beta <ref> [MMN93] </ref> or Modula-3 [Nel91] can be developed.
Reference: [MNS95] <author> Peter D. Mosses, Mogens Nielsen, and Michael I. </author> <title> Schwartzback, </title> <editor> editors. TAPSOFT'95: </editor> <booktitle> Theory and Practice of Software Development, volume 915 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes. </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year>
Reference-contexts: Proof Islands form a nested structure over which structural induction (using Theorem 11) can be performed. 4 DISCUSSION The proofs in this paper are based on an SOS definition of ofi. The first semantics written for ofi was given by mapping to the -calculus <ref> [MPW92, Mil92] </ref>. Such a semantics is recorded (with some informal proofs of the general equivalences) in [Jon93b, Jon93a, Jon94]; but completely formal proofs of the general equivalences are difficult to obtain because of the need to state -for the side conditions- what can not happen.
Reference: [Nel91] <author> G. Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: two equivalences concerned with concurrency. 2.1 Overview It is easiest to envisage the scope of ofi by considering a programming example even though the language is actually intended to be employed as a design notation via which programs written in languages like POOL [Ame89], ABCL [Yon90], Beta [MMN93] or Modula-3 <ref> [Nel91] </ref> can be developed.
Reference: [Pae91] <editor> Andreas Paepcke, editor. OOPSLA'91. </editor> <publisher> ACM, ACM Press, </publisher> <month> November </month> <year> 1991. </year>
Reference: [Plo81] <author> G. D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical report, </type> <institution> Aarhus University, </institution> <year> 1981. </year>
Reference-contexts: This can be straightforwardly formalized using -for example- the methods in [Bru93]. Type rules for ofi have been written (by SJH) but will be presented elsewhere. For the semantics itself, two levels of Structured Operational Semantic (SOS) reductions are defined <ref> [Plo81] </ref>. Some mild VDM notation (constructed objects, maps, etc.) is used in this paper see [Jon90].
Reference: [PW95] <author> Anna Philippou and David Walker. </author> <title> On sharing and determinacy in concurrent systems, </title> <note> 1995. to be presented at CONCUR'95. </note>
Reference-contexts: and a mapping to the higher-order - calculus (again noting a close correspondence); [Wal94] has a similar translation and tackles the justification of specific examples of the ofi equivalences using 20 Chapter 1 weak bi-simulation; more recently, [LW95] discuss the correctness of specific examples of the equivalences presented above; and <ref> [PW95] </ref> reviews conditions for determinacy in ofi. Nestmann and Steffan use a confluence argument about ofi in their paper in these proceedings.
Reference: [Ros94] <editor> A. W. Roscoe, editor. </editor> <title> A Classical Mind: Essays in Honour of C. </title> <editor> A. R. Hoare. </editor> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference: [SSC95] <author> A. Sernadas, C. Sernadas, and J. F. Costa. </author> <title> Object specification logic. </title> <journal> Journal of Logic and Computation, </journal> <volume> 5(5) </volume> <pages> 603-630, </pages> <year> 1995. </year>
Reference-contexts: The use of the word `islands' was prompted by Hogg (cf. [Hog91]) who had earlier come up with a concept which the current authors found independently. An interesting article on specification languages for objects has recently appeared <ref> [SSC95] </ref>. Much work remains to be done to support the full programme set out in [Jon96]. For example, as the interference logic used there stabilises, it will be necessary to undertake justification of its inference rules and this will require proofs about the relationship between logical expressions and ofi statements.
Reference: [Wal91] <author> D. Walker. </author> <title> -calculus semantics for object-oriented programming languages. </title> <booktitle> In [IM91], </booktitle> <pages> pages 532-547, </pages> <year> 1991. </year>
Reference-contexts: There are also several issues (including fairness) which require further study in any of the possible semantics. There is a significant corpus of work that tackles the relationship between object-oriented languages and various process calculi. David Walker is a major contributor to this line of research: <ref> [Wal91] </ref> provides a mapping from two POOL-like languages to the monadic -calculus; [Wal95] offers a mapping of a POOL-variant into the polyadic -calculus and develops a close correspondence with an operational semantics; [Wal93] turns its attention to ofi and provides both a two-level operational semantics and a mapping to the higher-order
Reference: [Wal93] <author> D. Walker. </author> <title> Process calculus and parallel object-oriented programming languages. </title> <editor> In In T. Casavant (ed), </editor> <title> Parallel Computers: </title> <journal> Theory and Practice. Computer Society Press, </journal> <note> to appear, </note> <year> 1993. </year>
Reference-contexts: David Walker is a major contributor to this line of research: [Wal91] provides a mapping from two POOL-like languages to the monadic -calculus; [Wal95] offers a mapping of a POOL-variant into the polyadic -calculus and develops a close correspondence with an operational semantics; <ref> [Wal93] </ref> turns its attention to ofi and provides both a two-level operational semantics and a mapping to the higher-order - calculus (again noting a close correspondence); [Wal94] has a similar translation and tackles the justification of specific examples of the ofi equivalences using 20 Chapter 1 weak bi-simulation; more recently, [LW95]
Reference: [Wal94] <author> D. Walker. </author> <title> Algebraic proofs of properties of objects, </title> <booktitle> 1994. Proceedings of ESOP'94. </booktitle>
Reference-contexts: to the monadic -calculus; [Wal95] offers a mapping of a POOL-variant into the polyadic -calculus and develops a close correspondence with an operational semantics; [Wal93] turns its attention to ofi and provides both a two-level operational semantics and a mapping to the higher-order - calculus (again noting a close correspondence); <ref> [Wal94] </ref> has a similar translation and tackles the justification of specific examples of the ofi equivalences using 20 Chapter 1 weak bi-simulation; more recently, [LW95] discuss the correctness of specific examples of the equivalences presented above; and [PW95] reviews conditions for determinacy in ofi.
Reference: [Wal95] <author> D. Walker. </author> <title> Objects in the -calculus. </title> <journal> Information and Computation, </journal> <volume> 116(2) </volume> <pages> 253-271, </pages> <year> 1995. </year>
Reference-contexts: There is a significant corpus of work that tackles the relationship between object-oriented languages and various process calculi. David Walker is a major contributor to this line of research: [Wal91] provides a mapping from two POOL-like languages to the monadic -calculus; <ref> [Wal95] </ref> offers a mapping of a POOL-variant into the polyadic -calculus and develops a close correspondence with an operational semantics; [Wal93] turns its attention to ofi and provides both a two-level operational semantics and a mapping to the higher-order - calculus (again noting a close correspondence); [Wal94] has a similar translation
Reference: [WL93] <author> J. C. P. Woodcock and P. G. Larsen, editors. FME'93: </author> <title> Industrial-Strength Formal Methods, </title> <booktitle> volume 670 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [Yon90] <editor> Akinori Yonezawa, editor. </editor> <title> ABCL: An Object-Oriented Concurrent System. </title> <publisher> MIT Press, </publisher> <year> 1990. </year> <note> ISBN 0-262-24029-7. </note>
Reference-contexts: design notation; it also motivates two equivalences concerned with concurrency. 2.1 Overview It is easiest to envisage the scope of ofi by considering a programming example even though the language is actually intended to be employed as a design notation via which programs written in languages like POOL [Ame89], ABCL <ref> [Yon90] </ref>, Beta [MMN93] or Modula-3 [Nel91] can be developed.
References-found: 28

