URL: http://theory.lcs.mit.edu/~madhu/papers/RS-soda.ps
Refering-URL: http://theory.lcs.mit.edu/~madhu/papers.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Chapter 1 Self-Testing Polynomial Functions Efficiently and over Rational Domains  
Author: Ronitt Rubinfeld Madhu Sudan 
Abstract: In this paper we give the first self-testers and checkers for polynomials over rational and integer domains. We also show significantly stronger bounds on the efficiency of a simple modification of the algorithm for self-testing polynomials over finite fields given in [8]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Babai, L., Fortnow, L., Lund, C., </author> <title> "Non-Deterministic Exponential Time has Two-Prover Interactive Protocols", </title> <booktitle> Proceedings of the 31st Annual Symposium on Foundations of Computer Science,, </booktitle> <year> 1990. </year>
Reference-contexts: However, similar approaches have been useful in the area of interactive proofs <ref> [1] </ref> [6] [10], which only requires that the procedure be in polynomial time. <p> Efficient degree tests are interesting for another reason in addition to program testing: they have been used as a tool in order to get multi-prover interactive proofs for nondeterministic exponential time complete functions in <ref> [1] </ref>. [6] have in turn used the interactive proof in [1] in order to obtain results about the difficulty of approximating the size of the clique, in which the strength of the result depends on the efficiency of the interactive proof. <p> Efficient degree tests are interesting for another reason in addition to program testing: they have been used as a tool in order to get multi-prover interactive proofs for nondeterministic exponential time complete functions in <ref> [1] </ref>. [6] have in turn used the interactive proof in [1] in order to obtain results about the difficulty of approximating the size of the clique, in which the strength of the result depends on the efficiency of the interactive proof. <p> We conjecture that our algorithm (or a slight modification of it) requires only O (1) tests and O (d) calls. The degree tests given in <ref> [1] </ref>,[6] both require a number of calls depending on the number of variables: the test in [1] requires O (n 6 d max ) calls to the program where n is the number of variables, and d max is the maximum degree of any variable, and the test in [6] requires O (nd max ) calls to the program.
Reference: [2] <author> Beaver, D., Feigenbaum, J., </author> <title> "Hiding Instance in Mul-tioracle Queries", </title> <booktitle> Proceedings of Symposium on Theoretical Aspects of Computer Science 1990. </booktitle>
Reference: [3] <author> Blum, M., </author> <title> "Designing programs to check their work", </title> <note> Submitted to CACM. </note>
Reference-contexts: This approach is not desirable because both the interpolation procedure and the evaluation of the polynomial at random points make the tester at least as difficult as the program, and not different in the sense defined by <ref> [3] </ref> [4]. However, similar approaches have been useful in the area of interactive proofs [1] [6] [10], which only requires that the procedure be in polynomial time.
Reference: [4] <author> Blum, M., Kannan, S., </author> <title> "Program correctness checking ... and the design of programs that check their work", </title> <booktitle> Proc. 21st ACM Symposium on Theory of Computing, </booktitle> <year> 1989. </year>
Reference-contexts: This approach is not desirable because both the interpolation procedure and the evaluation of the polynomial at random points make the tester at least as difficult as the program, and not different in the sense defined by [3] <ref> [4] </ref>. However, similar approaches have been useful in the area of interactive proofs [1] [6] [10], which only requires that the procedure be in polynomial time. <p> Furthermore, all require only a small multiplicative overhead over the running time of P and are different, simpler and faster than any correct program for f in a precise sense defined in <ref> [4] </ref>. We use x 2 R D to mean that x is chosen uniformly at random in D. We use [k] to denote the set of integers f1; 2; ; kg.
Reference: [5] <author> Blum, M., Luby, M., Rubinfeld, R., </author> <title> "Self-Testing/Correcting with Applications to Numerical Problems," </title> <booktitle> Proc. 22th ACM Symposium on Theory of Computing, </booktitle> <year> 1990. </year> <note> 10 Rubinfeld and Sudan </note>
Reference-contexts: Supported by DIMACS (Center for Discrete Mathematics and Theoretical Computer Science), NSF-STC88-09648. Part of this research was also done while the author was visiting Bellcore. y U.C. Berkeley. Research supported by NSF PYI Grant CCR 8896202. and division functions <ref> [5] </ref>, and floating point logarithm and exponentiation functions [8]). In [7] there is a checker that can also be made into a self-tester for matrix multiplication over any field, but self-correctors for matrix multiplication are only known over finite fields [5]. <p> supported by NSF PYI Grant CCR 8896202. and division functions <ref> [5] </ref>, and floating point logarithm and exponentiation functions [8]). In [7] there is a checker that can also be made into a self-tester for matrix multiplication over any field, but self-correctors for matrix multiplication are only known over finite fields [5]. Many of the self-testers, for example those for linear and polynomial functions [5][8], have been based on showing that a program which satisfies certain easy to verify conditions on randomly chosen inputs must be computing the correct function on most inputs. <p> In particular, we are interested in the efficiency of the degree test, since often testing is done online (i.e. when the user decides to use the program) <ref> [5] </ref>.
Reference: [6] <author> Feige, U., Goldwasser, S., Lovasz, L., Safra, M., Szegedy, M., </author> <title> "Approximating Clique is Almost NP-Complete", </title> <booktitle> Proceedings of the 32nd Annual Symposium on Foundations of Computer Science,, </booktitle> <year> 1991. </year>
Reference-contexts: However, similar approaches have been useful in the area of interactive proofs [1] <ref> [6] </ref> [10], which only requires that the procedure be in polynomial time. <p> Efficient degree tests are interesting for another reason in addition to program testing: they have been used as a tool in order to get multi-prover interactive proofs for nondeterministic exponential time complete functions in [1]. <ref> [6] </ref> have in turn used the interactive proof in [1] in order to obtain results about the difficulty of approximating the size of the clique, in which the strength of the result depends on the efficiency of the interactive proof. <p> in [1],<ref> [6] </ref> both require a number of calls depending on the number of variables: the test in [1] requires O (n 6 d max ) calls to the program where n is the number of variables, and d max is the maximum degree of any variable, and the test in [6] requires O (nd max ) calls to the program. All of the tests given in this paper are very simple to compute, and require only a small number of additions, subtractions and comparisons. 2 Definitions Consider a function P : X ! Y that attempts to compute f .
Reference: [7] <author> Freivalds, R., </author> <title> "Fast Probabilistic Algorithms", </title> <publisher> Springer Verlag Lecture Notes in CS No. </publisher> <pages> 74, </pages> <note> Mathematical Foundations of CS, </note> <month> 57-69 </month> <year> (1979). </year>
Reference-contexts: Supported by DIMACS (Center for Discrete Mathematics and Theoretical Computer Science), NSF-STC88-09648. Part of this research was also done while the author was visiting Bellcore. y U.C. Berkeley. Research supported by NSF PYI Grant CCR 8896202. and division functions [5], and floating point logarithm and exponentiation functions [8]). In <ref> [7] </ref> there is a checker that can also be made into a self-tester for matrix multiplication over any field, but self-correctors for matrix multiplication are only known over finite fields [5].
Reference: [8] <author> Gemmell, P., Lipton, R., Rubinfeld, R., Sudan, M., Wigderson, A., </author> <title> "Self-Testing/Correcting for Polynomials and for Approximate Functions", </title> <booktitle> Proc. 23th ACM Symposium on Theory of Computing, </booktitle> <year> 1991. </year>
Reference-contexts: Our first result concerns checking and self-testing over rational and integer domains. To date, most self-testing/correcting pairs and checkers that have been found for numerical functions (cf. [5][2][9]<ref> [8] </ref>) have been for functions over finite fields (for example polynomial functions over finite fields [2][9] [8]) or for domains for which a group structure has been imposed on a finite subset of the domain (for example integer multiplication fl Hebrew University. This work was done while the author was at Princeton University. Supported by DIMACS (Center for Discrete Mathematics and Theoretical Computer Science), NSF-STC88-09648. <p> Supported by DIMACS (Center for Discrete Mathematics and Theoretical Computer Science), NSF-STC88-09648. Part of this research was also done while the author was visiting Bellcore. y U.C. Berkeley. Research supported by NSF PYI Grant CCR 8896202. and division functions [5], and floating point logarithm and exponentiation functions <ref> [8] </ref>). In [7] there is a checker that can also be made into a self-tester for matrix multiplication over any field, but self-correctors for matrix multiplication are only known over finite fields [5]. Many of the self-testers, for example those for linear and polynomial functions [5][8], have been based on showing <p> However, functions over such fields, for example rational domains, are of great importance for application programming. A first step in the direction of finding self-testing/correcting pairs for polynomial functions is given in <ref> [8] </ref>, where a self-corrector for polynomial functions over fixed point rational domains of the form D s;r = f y s j integers jyj rg; r 2 Z; s 2 Znf0g is given (note that this includes integer domains and fixed point arithmetic domains). <p> However, similar approaches have been useful in the area of interactive proofs [1] [6] [10], which only requires that the procedure be in polynomial time. The self-tester for polynomials over finite fields in <ref> [8] </ref> is composed of two parts: One is a degree test a test which verifies that a program P is computing a function which is usually equal to some (total) degree d polynomial g. <p> Our second result concerns the self-tester for polynomials over finite fields in <ref> [8] </ref>, which has been shown to work for multivariate polynomials as well by Shen [11]. In particular, we are interested in the efficiency of the degree test, since often testing is done online (i.e. when the user decides to use the program) [5]. <p> In <ref> [8] </ref> a self-corrector for such functions is presented which can compute the correct value of a function f , from a "safe" domain D s , provided the function has been tested over a finite number of "test" domains D i t . <p> We first define the notion of "closeness" that we use in this paper and then we establish some relations among domains. (The definition as well as its properties are initially given in <ref> [8] </ref>.) Definition 3.1. ([8]) ffi (p 1 ; p 2 ) = p 1 if p 1 = p 2 0 otherwise Definition 3.2. ([8]) For domains A and B, both sub sets of a universe X , ffi (A; B) = s2X x2A y2B (Note that 0 ffi (A; B) <p> Thus P is a "good" program. 2 4 Efficient Testers for Polynomials We present an improved total degree test for polynomials in this section. The algorithm is a simple modification of the algorithm given in <ref> [8] </ref>. The algorithm given in [8] picks a random point x and a random offset t, and verifies that the values of the program at the d+2 points x + it; i 2 [0; :::; d + 1] satisfy the interpolation equations, or equivalently, lie on the same polynomial. <p> Thus P is a "good" program. 2 4 Efficient Testers for Polynomials We present an improved total degree test for polynomials in this section. The algorithm is a simple modification of the algorithm given in <ref> [8] </ref>. The algorithm given in [8] picks a random point x and a random offset t, and verifies that the values of the program at the d+2 points x + it; i 2 [0; :::; d + 1] satisfy the interpolation equations, or equivalently, lie on the same polynomial. <p> Theorem 2. If * &lt; 4 300 (d+1) , and P does not *-compute some polynomial g of total degree at most d on Z n p , then Program Improved Total Degree Test rejects P with probability 1 fi. If a program P passes the test in <ref> [8] </ref> for * &lt; 1=O (d 2 ) then one can infer that the program is essentially computing a degree d polynomial. <p> Before we prove the theorem, we first mention a technical lemma concerning a property of polynomials that will play a central role in our proof. This is a slight generalization of the techniques used in <ref> [8] </ref>. Essentially what the lemma shows is that suppose we have a (d + 2) fi (d + 2) matrix M , of points (x; y), such that y is a function of x and: 1. <p> From here on we assume that we have a program P with ffi 8 300 (d+1) . The proof follows the same basic outline as the one in <ref> [8] </ref>, but in order to achieve the better efficiency, we use ideas that can be thought of in terms of error-correction. Thus many of the steps that were quite simple in [8] require more work here. We define a self-corrector for f which uses P as an oracle. <p> The proof follows the same basic outline as the one in <ref> [8] </ref>, but in order to achieve the better efficiency, we use ideas that can be thought of in terms of error-correction. Thus many of the steps that were quite simple in [8] require more work here. We define a self-corrector for f which uses P as an oracle. We show that this self-corrector has the nice property that for every x, self-correction using two different random strings h 1 and h 2 yields the same result (with high probability). <p> We then show that any function that has the second property mentioned above is a polynomial of degree d. In <ref> [8] </ref>, the function g was defined to be the value that occurs most often (for most t) when one looks at the evaluation at x of the unique polynomial which agrees with the values of P at x+t; :::; x+(d+1)t. <p> Our first lemma shows that P and g agree at most places. 8 Rubinfeld and Sudan Lemma 10. Pr x2 R Z p [g (x) = P (x)] 1 2ffi The proof of Lemma 10 is the similar to the proof of Lemma 7 in Section 3 of <ref> [8] </ref> and is omitted here. The next two lemmas show that the self-corrector function has the property that for all x 2 Z p , it is well-defined most t's in Z p give the same answer when used to evaluate SC P (x; t): Lemma 11. <p> For all x 2 Z p , Pr fi SC P (x; t 1 ) = SC P (x; t 2 ) 6= error fl Proof: In <ref> [8] </ref>, it is shown that if one computes the value of a polynomial function at x by interpolating from the values of the function along offset t 1 which in turn are computed by interpolating from the values of the function along offset t 2 , then one would get the <p> By the definition of ffi and application of Markov's inequality we find that with probability at least 1=10, no more than d 1 columns have such elements, and so d + 1 of the columns remain (this assumes that d 4, if d &lt; 4 then the algorithm in <ref> [8] </ref> is better). Applying the Matrix Transposition Lemma to all (d + 2) fi (d + 2) submatrices shows that all the elements g (x + i), i is a good row, lie on the same polynomial. <p> A very important question along these lines is to determine whether there is an approximate self-tester <ref> [8] </ref> for programs which approximate polynomial functions over rational domains, as would occur in floating point and fixed precision computation (an approximate self-tester verifies that a program gives a good approximation to the function on a large fraction of the inputs). <p> Secondly, we have shown stronger bounds on the efficiency of a simple modification of the algorithm for self-testing polynomials in <ref> [8] </ref>. This algorithm makes O (d) tests, for a total of O (d 2 ) calls to the program.
Reference: [9] <author> Lipton, </author> <title> R.J., "New directions in Testing," </title> <booktitle> in Distributed Computing and Cryptography, DIMACS Series on Discrete Mathematics and Theoretical Computer Science, </booktitle> <volume> vol. 2, </volume> <year> 1991, </year> <pages> pp. 191-202. </pages>
Reference-contexts: Rather than trust that P works correctly, a self-testing program for f ([5]) verifies that program P is correct on most inputs (without assuming the correctness of another program that is as difficult as one that computes the function), and a self-correcting program ([5] <ref> [9] </ref>) for f takes a program P , that is correct on most inputs, and uses it to compute f correctly on every input (with high probability). Both access P only as a black-box and in some precise way are not allowed to compute the function f .
Reference: [10] <author> Lund, C., </author> <title> "The Power of Interaction", </title> <institution> University of Chicago Technical Report 91-01, </institution> <month> January 14, </month> <year> 1991. </year>
Reference-contexts: However, similar approaches have been useful in the area of interactive proofs [1] [6] <ref> [10] </ref>, which only requires that the procedure be in polynomial time.
Reference: [11] <author> Shen, Sasha, </author> <type> personal communication, </type> <month> May </month> <year> 1991. </year>
Reference-contexts: Our second result concerns the self-tester for polynomials over finite fields in [8], which has been shown to work for multivariate polynomials as well by Shen <ref> [11] </ref>. In particular, we are interested in the efficiency of the degree test, since often testing is done online (i.e. when the user decides to use the program) [5].
Reference: [12] <author> Van Der Waerden, </author> <title> B.L., </title> <journal> Algebra, </journal> <volume> Vol. 1, </volume> <publisher> Frederick Ungar Publishing Co., Inc., </publisher> <pages> pp. 86-91, </pages> <year> 1970. </year>
Reference-contexts: Furthermore P d+1 i=0 ff i f (x+i t) can be computed in O (d 2 ) time using only additions and comparisons by the method of finite differences described in the appendix <ref> [12] </ref>. 3 Testers for Polynomials over Integer and Rational Domains In this section we present a tester for polynomial functions over rational domains.
References-found: 12

