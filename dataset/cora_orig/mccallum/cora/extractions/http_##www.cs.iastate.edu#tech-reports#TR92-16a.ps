URL: http://www.cs.iastate.edu/tech-reports/TR92-16a.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: 
Title: Preliminary Design of Larch/C++  
Author: Gary T. Leavens and Yoonsik Cheon TR #-a U. Martin and J. Wing (editors), 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa Sate University  
Note: To appear in Proceedings of the First International Workshop on Larch,  Springer-Verlag, Workshops in Computer Science Series, 1992.  
Date: May, 1992 (Revised September 1992)  
Abstract: Keywords: interface specification, Larch/C++, subclass, subtype, inheritance, verification. 1991 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications | Languages; D.3.1 [Programming Languages] Formal Definitions and Theory | Semantics, syntax; F.3.1 [Logics and Meaning of Programs] Specifying and verifying and reasoning about programs | Assertions, invariants, pre- and post-conditions, specification techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [Ame87] <author> Pierre America. </author> <title> Inheritance and Subtyping in a Parallel Object-Oriented Language. </title> <editor> In Jean Bezivin et al., editors, </editor> <booktitle> ECOOP '87, European Conference on Object-Oriented Programming, Paris, France, </booktitle> <pages> pages 234-242, </pages> <address> New York, N.Y., </address> <month> June </month> <year> 1987. </year> <title> Springer-Verlag. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 276. </volume>
Reference-contexts: The above goals are directed at making Larch/C ++ practical. In addition, we have some other goals which should help make Larch/C ++ useful, but which are motivated by a particular view of object-oriented programming <ref> [Ame87] </ref> [Mey88] [LW90] [Lea90] [Lea91]. This view centers around supertype abstraction, which is the ability to reason about a program based on nominal (i.e., static) type information by letting supertypes stand for all their subtypes. <p> A correct implementation of SavingsAccount must also be a public subclass of BankAccount. Ideally the user of Larch/C ++ should prove that the subtype relationship is legal according to some accepted definition <ref> [Ame87] </ref> [Lea90] [Lea91] [Dha92]. However, it is undecidable whether an arbitrary claimed subtype relationship is legal, and so for the time being Larch/C ++ only requires that certain syntactic conditions be satisfied.
Reference: [Ame91] <author> Pierre America. </author> <title> Designing an Object-Oriented Programming Language with Behavioural Sub-typing. </title> <editor> In J. W. de Bakker, W. P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop, Noordwijkerhout, The Netherlands, May/June 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pages 60-90. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: To bring the values of the subtype up one uses a coercion function (not a relation) that maps each subtype abstract value to a single supertype abstract value [BW90] [GM87] <ref> [Ame91] </ref> [Rey80]. This allows assertions to be interpreted by mapping all values to the nominal type of the variables used in the assertion.
Reference: [BW90] <author> Kim B. Bruce and Peter Wegner. </author> <title> An Algebraic Model of Subtype and Inheritance. </title> <editor> In Francois Ban~cilhon and Peter Buneman, editors, </editor> <booktitle> Advances in Database Programming Languages, </booktitle> <pages> pages 75-96. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <month> August </month> <year> 1990. </year>
Reference-contexts: To bring the values of the subtype up one uses a coercion function (not a relation) that maps each subtype abstract value to a single supertype abstract value <ref> [BW90] </ref> [GM87] [Ame91] [Rey80]. This allows assertions to be interpreted by mapping all values to the nominal type of the variables used in the assertion.
Reference: [Car88] <author> Luca Cardelli. </author> <title> A Semantics of Multiple Inheritance. </title> <journal> Information and Computation, </journal> 76(2/3):138-164, February/March 1988. A revised version of the paper that appeared in the 1984 Semantics of Data Types Symposium, LNCS <volume> 173, </volume> pages <pages> 51-66. </pages>
Reference-contexts: Second, the interface must satisfy the C ++ type checker. Satisfying the C ++ type checker is not what a type theorist would expect <ref> [Car88] </ref>; according to Doug Lea 5 , it is impossible to change the type of the result or of any of the explicitly specified arguments (i.e., other than this) of a member function. The interface specified in Figure 7 also has an invariant clause.
Reference: [CDD + 89] <author> D. Carrington, D. Duke, R. Duke, P. King, G. Rose, and G. Smith. Object-Z: </author> <title> An object-oriented extension to Z. In Formal Description Techniques (FORTE '89), </title> <booktitle> Vancouver, </booktitle> <pages> pages 281-296. </pages> <publisher> North-Holland Publishing Co., </publisher> <month> December </month> <year> 1989. </year>
Reference-contexts: A different sense of object-oriented specification language is one which is not tailored to specifying the interfaces of programs written in a particular programming language, but one that uses ideas from object-oriented programming to aid in writing specifications. For example, the specification language Object-Z <ref> [CDD + 89] </ref> [DD90] [Cus91] extends the specification language Z with inheritance of specifications. <p> This is what is done in Object-Z <ref> [CDD + 89] </ref> [DD90] [Cus91]. 5 Private communication. 12 class SavingsAccount : public BankAccount - uses SavingsAccountTrait (SavingsAccount for SA, BankAccount for Acct); invariant forall sa:SA (balance (sa) &gt; (0/1)); public: // constructor SavingsAccount (const double initial_balance) - requires (1/100) &lt;= rational (initial_balance); modifies self; ensures approximates (initial_balance, balance (self'), 1/100);
Reference: [Che89] <author> Jolly Chen. </author> <title> The Larch/Generic Interface Language. </title> <type> Technical report, </type> <institution> Massachusetts Institute of Technology, EECS department, </institution> <month> May </month> <year> 1989. </year> <note> The author's Bachelor's thesis. </note>
Reference-contexts: Another example: one must be able to verify a subclass using the specification of the public and protected interfaces of its superclasses, independent of the implementation of the superclasses. 2 1.3 Related Work The most closely related work are other interface specification languages in the Larch family [Win83] [Win87] <ref> [Che89] </ref> [Win90] [GMP90] [Jon91] [GH91] [Che91]. The greatest influence has been from Larch/C and Larch/Smalltalk. From Larch/C we have adopted much syntax and the basic semantics of such common types as pointers. From Larch/Smalltalk we have taken much of the approach to inheritance and subtyping.
Reference: [Che91] <author> Yoonsik Cheon. Larch/Smalltalk: </author> <title> A Specification Language for Smalltalk. </title> <type> Technical Report 91-15, </type> <institution> Department of Computer Science; Iowa State University, Ames, IA, </institution> <month> June </month> <year> 1991. </year> <month> 19 </month>
Reference-contexts: be able to verify a subclass using the specification of the public and protected interfaces of its superclasses, independent of the implementation of the superclasses. 2 1.3 Related Work The most closely related work are other interface specification languages in the Larch family [Win83] [Win87] [Che89] [Win90] [GMP90] [Jon91] [GH91] <ref> [Che91] </ref>. The greatest influence has been from Larch/C and Larch/Smalltalk. From Larch/C we have adopted much syntax and the basic semantics of such common types as pointers. From Larch/Smalltalk we have taken much of the approach to inheritance and subtyping. <p> A subtype relationship is a behavioral relationship, which could be proven by examining the specifications of the types involved, while a subclass relationship is a purely implementation relationship. In Larch/Smalltalk we were able to completely separate these two notions <ref> [Che91] </ref>, since Smalltalk-80 has no static type system. Unfortunately, the C ++ type system does not distinguish completely between subtypes and subclasses. <p> We need to decide what tools to build and how to integrate them with the Larch/C tools. We would also like to build browsers similar to the prototype browser for Larch/Smalltalk <ref> [Che91] </ref>. The main effort in the summer of 1992 has been in writing examples, refining the language, and starting on a formal semantics for Larch/C ++ . We are now working on the semantics and tools. We hope eventually to specify large portions of various C ++ libraries.
Reference: [CL90] <author> Marshall P. Cline and Doug Lea. </author> <title> The Behavior of C++ Classes. </title> <booktitle> In Proceedings of the Symposium on Object Oriented Programming Emphasizing Practical Applications, </booktitle> <address> Marist College, </address> <year> 1990, 1990. </year> <note> To appear. </note>
Reference-contexts: The meaning of an assertion is unclear if the operations involved fail to terminate normally or use non-portable parts of the language. A refinement of the Eiffel specification language is found in the specification language Annotated C ++ , or A ++ <ref> [CL90] </ref>. Assertions in A ++ may use universal and existential quantification, and hence are not generally executable, although they are still expressed using the expressions of C ++ .
Reference: [Cox86] <author> Brad J. Cox. </author> <title> Object Oriented Programming: an Evolutionary Approach. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1986. </year>
Reference-contexts: 1 Introduction A pre-condition for reading this paper is that you understand the basics of object-oriented programming (see <ref> [Cox86] </ref> otherwise), have some familiarity with C or C ++ [Str91], and have a good understanding of model-oriented interface specifications using Larch [GHW85].
Reference: [Cus91] <author> Elspeth Cusack. </author> <title> Object Oriented Modelling in Z. Obtained from the Author., </title> <month> February </month> <year> 1991. </year>
Reference-contexts: A different sense of object-oriented specification language is one which is not tailored to specifying the interfaces of programs written in a particular programming language, but one that uses ideas from object-oriented programming to aid in writing specifications. For example, the specification language Object-Z [CDD + 89] [DD90] <ref> [Cus91] </ref> extends the specification language Z with inheritance of specifications. <p> This is what is done in Object-Z [CDD + 89] [DD90] <ref> [Cus91] </ref>. 5 Private communication. 12 class SavingsAccount : public BankAccount - uses SavingsAccountTrait (SavingsAccount for SA, BankAccount for Acct); invariant forall sa:SA (balance (sa) &gt; (0/1)); public: // constructor SavingsAccount (const double initial_balance) - requires (1/100) &lt;= rational (initial_balance); modifies self; ensures approximates (initial_balance, balance (self'), 1/100); virtual void deposit (const
Reference: [DD90] <author> D. Duke and R. Duke. </author> <title> Towards a Semantics for Object-Z. </title> <editor> In D. Bjorner, C. A. R. Hoare, and H. Langmaack, editors, </editor> <title> VDM '90: VDM and Z | Formal Methods in Software Development, </title> <booktitle> Third International Symposium of VDM Europe, Kiel, FRG, volume 428 of Lecture Notes in Computer Science, </booktitle> <pages> pages 244-261. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1990. </year>
Reference-contexts: A different sense of object-oriented specification language is one which is not tailored to specifying the interfaces of programs written in a particular programming language, but one that uses ideas from object-oriented programming to aid in writing specifications. For example, the specification language Object-Z [CDD + 89] <ref> [DD90] </ref> [Cus91] extends the specification language Z with inheritance of specifications. <p> This is what is done in Object-Z [CDD + 89] <ref> [DD90] </ref> [Cus91]. 5 Private communication. 12 class SavingsAccount : public BankAccount - uses SavingsAccountTrait (SavingsAccount for SA, BankAccount for Acct); invariant forall sa:SA (balance (sa) &gt; (0/1)); public: // constructor SavingsAccount (const double initial_balance) - requires (1/100) &lt;= rational (initial_balance); modifies self; ensures approximates (initial_balance, balance (self'), 1/100); virtual void deposit
Reference: [Dha92] <author> Krishna Kishore Dhara. </author> <title> Subtyping among Mutable Types in Object-Oriented Programming Languages. </title> <type> Master's thesis, </type> <institution> Iowa State University, Department of Computer Science, Ames, Iowa, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: A correct implementation of SavingsAccount must also be a public subclass of BankAccount. Ideally the user of Larch/C ++ should prove that the subtype relationship is legal according to some accepted definition [Ame87] [Lea90] [Lea91] <ref> [Dha92] </ref>. However, it is undecidable whether an arbitrary claimed subtype relationship is legal, and so for the time being Larch/C ++ only requires that certain syntactic conditions be satisfied.
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1990. </year>
Reference-contexts: The post-condition of this paper is that you should understand the rationale for our design of Larch/C ++ . 1.1 Challenges of C++ The programming language C ++ <ref> [ES90] </ref> [Str91] is an object-oriented extension to C. Although it is difficult to find hard data about language usage, anecdotal evidence, such as the amount of junk mail concerning C ++ , makes it clear that in the US C ++ is the most widely used object-oriented language. <p> In C ++ an operation (member function) of a class can be declared to be const, meaning that the member function cannot change the bits of the object of which it is a member. (However, this protection is not absolute <ref> [ES90] </ref>.) Since such declarations are enforced by C ++ , we had the idea of replacing the typical Larch modifies clause in a function specification with the use of const. Since the same mechanism is available in ANSI C, the designers of Larch/C also had the same thought.
Reference: [GH86] <author> J. V. Guttag and J. J. Horning. </author> <title> A Larch Shared Language Handbook. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 6(2) </volume> <pages> 135-157, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: It specifies objects that can be asked for their balance and to pay interest. The trait BankAccountTrait used in the specification of BankAccount is presented in Figure 4. The trait Rational which is included by BankAccountTrait, is found in the Larch Shared Language Handbook <ref> [GH86] </ref>.
Reference: [GH91] <author> J. V. Guttag and J. J. Horning. </author> <title> Introduction to LCL, A Larch/C Interface Language. </title> <type> Technical Report 74, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: must be able to verify a subclass using the specification of the public and protected interfaces of its superclasses, independent of the implementation of the superclasses. 2 1.3 Related Work The most closely related work are other interface specification languages in the Larch family [Win83] [Win87] [Che89] [Win90] [GMP90] [Jon91] <ref> [GH91] </ref> [Che91]. The greatest influence has been from Larch/C and Larch/Smalltalk. From Larch/C we have adopted much syntax and the basic semantics of such common types as pointers. From Larch/Smalltalk we have taken much of the approach to inheritance and subtyping. <p> For example, we have adopted without change the distinction between basic values and locs (locations) made in section 2.3 of <ref> [GH91] </ref>. Basic values, called abstract values below, are the abstraction of an object's state used in specifications [Hoa72]. Abstract values are specified by traits written in the Larch Shared Language. Locations are abstractions of computer memory cells. In Larch/C ++ locations are thought of as containers for abstract values. <p> The only job of a constructor is to initialize the state of the newly created object, which in the specification is referred to as self. (This is similar to the way empset is initialized in <ref> [GH91, Section 3.3] </ref>.) The specification of this constructor says that in the post-state the abstract value of the constructed 7 object should be an empty symbol table. The special specification variable self is an abbreviation for *this.
Reference: [GHM90] <author> John V. Guttag, James J. Horning, and Andres Modet. </author> <title> Report on the Larch Shared Language: Version 2.3. </title> <type> Technical Report 58, </type> <institution> Digital Equipment Corporation, Systems Research Center, Palo Alto, Calif., </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: The equals sign (=), means assignment in C and C ++ , but means equality in Larch/C and Larch/C ++ specifications, whereas == in C ++ means equality and is used in the Larch Shared Language to separate sides of an equation <ref> [GHM90] </ref>. Since a common bug in C and C ++ programs is using the wrong symbol, it may be wise to use == for equality in assertions in Larch/C ++ specifications.
Reference: [GHW85] <author> John V. Guttag, James J. Horning, and Jeannette M. Wing. </author> <title> The Larch Family of Specification Languages. </title> <journal> IEEE Software, </journal> <volume> 2(4), </volume> <month> September </month> <year> 1985. </year>
Reference-contexts: 1 Introduction A pre-condition for reading this paper is that you understand the basics of object-oriented programming (see [Cox86] otherwise), have some familiarity with C or C ++ [Str91], and have a good understanding of model-oriented interface specifications using Larch <ref> [GHW85] </ref>. The post-condition of this paper is that you should understand the rationale for our design of Larch/C ++ . 1.1 Challenges of C++ The programming language C ++ [ES90] [Str91] is an object-oriented extension to C.
Reference: [GM87] <author> Joseph A. Goguen and Jose Meseguer. </author> <title> Order-Sorted Algebra Solves the Constructor-Selector, Multiple Representation and Coercion Problems. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, NY, </address> <pages> pages 18-29. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: To bring the values of the subtype up one uses a coercion function (not a relation) that maps each subtype abstract value to a single supertype abstract value [BW90] <ref> [GM87] </ref> [Ame91] [Rey80]. This allows assertions to be interpreted by mapping all values to the nominal type of the variables used in the assertion.
Reference: [GMP90] <author> David Guaspari, Carla Marceau, and Wolfgang Polak. </author> <title> Formal Verification of Ada Programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 1058-1075, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: example: one must be able to verify a subclass using the specification of the public and protected interfaces of its superclasses, independent of the implementation of the superclasses. 2 1.3 Related Work The most closely related work are other interface specification languages in the Larch family [Win83] [Win87] [Che89] [Win90] <ref> [GMP90] </ref> [Jon91] [GH91] [Che91]. The greatest influence has been from Larch/C and Larch/Smalltalk. From Larch/C we have adopted much syntax and the basic semantics of such common types as pointers. From Larch/Smalltalk we have taken much of the approach to inheritance and subtyping.
Reference: [Hoa72] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(4) </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: For example, we have adopted without change the distinction between basic values and locs (locations) made in section 2.3 of [GH91]. Basic values, called abstract values below, are the abstraction of an object's state used in specifications <ref> [Hoa72] </ref>. Abstract values are specified by traits written in the Larch Shared Language. Locations are abstractions of computer memory cells. In Larch/C ++ locations are thought of as containers for abstract values. <p> Its importance is similar to Hoare's requirement that the abstraction map from the representation of a data abstraction to the abstract values, used to verify the correctness of an implementation of a data abstraction <ref> [Hoa72] </ref>, commute with all the type's operations. By including the SavingsAccountSubTrait, all that is left for the trait SavingsAccountTrait is to define a way to create abstract values of the sort SA, and the actual coercion function. In this example of defining a trait for a subtype, SavingsAccountSubTrait is small.
Reference: [Jon91] <author> Kevin D. Jones. LM3: </author> <title> A Larch Interface Language for Modula-3 A Definition and Introduction Version 1.0. </title> <type> Technical Report 72, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue Palo Alto, CA 94301, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: one must be able to verify a subclass using the specification of the public and protected interfaces of its superclasses, independent of the implementation of the superclasses. 2 1.3 Related Work The most closely related work are other interface specification languages in the Larch family [Win83] [Win87] [Che89] [Win90] [GMP90] <ref> [Jon91] </ref> [GH91] [Che91]. The greatest influence has been from Larch/C and Larch/Smalltalk. From Larch/C we have adopted much syntax and the basic semantics of such common types as pointers. From Larch/Smalltalk we have taken much of the approach to inheritance and subtyping.
Reference: [Lea90] <author> Gary T. Leavens. </author> <title> Modular Verification of Object-Oriented Programs with Subtypes. </title> <type> Technical Report 90-09, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, July </month> <year> 1990. </year>
Reference-contexts: The above goals are directed at making Larch/C ++ practical. In addition, we have some other goals which should help make Larch/C ++ useful, but which are motivated by a particular view of object-oriented programming [Ame87] [Mey88] [LW90] <ref> [Lea90] </ref> [Lea91]. This view centers around supertype abstraction, which is the ability to reason about a program based on nominal (i.e., static) type information by letting supertypes stand for all their subtypes. <p> Since message passing causes special difficulties in program verification it is worth taking extra trouble in specification if that will make the job of verification easier. One way to make such verification easier is by the use of legal subtype relationships [LW90] <ref> [Lea90] </ref> [Lea91]. 2.2.1 Distinguish Subtypes and Subclasses? In software engineering it is important to distinguish between the notions of type and class and the relationships of subtype and subclass. A type (i.e., an abstract data type) is a behavioral notion, and may be implemented by many different classes. <p> Bringing the trait functions down means defining the meaning of each trait function that takes supertype arguments for subtype arguments. This allows the assertion to be interpreted by a kind of dynamic overloading of trait functions <ref> [Lea90] </ref> [Lea91]. One must specify a simulation relation that relates each abstract value of the supertype to one or more abstract values of the subtype in a way that is preserved by the trait functions; this ensures that the trait functions are redefined in the subtypes in a consistent way. <p> This ensures that the coercion function homomorphically maps SavingsAccount abstract values to BankAccount abstract values. That toAcct commutes with the overloaded balance trait function, is important for verification of programs using supertype abstraction <ref> [Lea90] </ref> [Lea91]. Its importance is similar to Hoare's requirement that the abstraction map from the representation of a data abstraction to the abstract values, used to verify the correctness of an implementation of a data abstraction [Hoa72], commute with all the type's operations. <p> A correct implementation of SavingsAccount must also be a public subclass of BankAccount. Ideally the user of Larch/C ++ should prove that the subtype relationship is legal according to some accepted definition [Ame87] <ref> [Lea90] </ref> [Lea91] [Dha92]. However, it is undecidable whether an arbitrary claimed subtype relationship is legal, and so for the time being Larch/C ++ only requires that certain syntactic conditions be satisfied. <p> First, the used trait must provide overloaded trait functions that will accept arguments of the supertype's sort; the technical statement of this condition is described in <ref> [Lea90] </ref>. Second, the interface must satisfy the C ++ type checker. <p> Assertions that use user-defined trait functions, such as "eq, instead of = have the advantage that "eq can always be redefined in the traits used by a subclass, and thus give better constraints on subtypes. Such assertions are called subtype constraining <ref> [Lea90, Section 3.5.3] </ref>. An alternative that we would like to investigate is to interpret = as a behavioral equality (at the nominal type used in the assertion).
Reference: [Lea91] <author> Gary T. Leavens. </author> <title> Modular Specification and Verification of Object-Oriented Programs. </title> <journal> IEEE Software, </journal> <volume> 8(4) </volume> <pages> 72-80, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: The above goals are directed at making Larch/C ++ practical. In addition, we have some other goals which should help make Larch/C ++ useful, but which are motivated by a particular view of object-oriented programming [Ame87] [Mey88] [LW90] [Lea90] <ref> [Lea91] </ref>. This view centers around supertype abstraction, which is the ability to reason about a program based on nominal (i.e., static) type information by letting supertypes stand for all their subtypes. <p> Since message passing causes special difficulties in program verification it is worth taking extra trouble in specification if that will make the job of verification easier. One way to make such verification easier is by the use of legal subtype relationships [LW90] [Lea90] <ref> [Lea91] </ref>. 2.2.1 Distinguish Subtypes and Subclasses? In software engineering it is important to distinguish between the notions of type and class and the relationships of subtype and subclass. A type (i.e., an abstract data type) is a behavioral notion, and may be implemented by many different classes. <p> Bringing the trait functions down means defining the meaning of each trait function that takes supertype arguments for subtype arguments. This allows the assertion to be interpreted by a kind of dynamic overloading of trait functions [Lea90] <ref> [Lea91] </ref>. One must specify a simulation relation that relates each abstract value of the supertype to one or more abstract values of the subtype in a way that is preserved by the trait functions; this ensures that the trait functions are redefined in the subtypes in a consistent way. <p> This ensures that the coercion function homomorphically maps SavingsAccount abstract values to BankAccount abstract values. That toAcct commutes with the overloaded balance trait function, is important for verification of programs using supertype abstraction [Lea90] <ref> [Lea91] </ref>. Its importance is similar to Hoare's requirement that the abstraction map from the representation of a data abstraction to the abstract values, used to verify the correctness of an implementation of a data abstraction [Hoa72], commute with all the type's operations. <p> A correct implementation of SavingsAccount must also be a public subclass of BankAccount. Ideally the user of Larch/C ++ should prove that the subtype relationship is legal according to some accepted definition [Ame87] [Lea90] <ref> [Lea91] </ref> [Dha92]. However, it is undecidable whether an arbitrary claimed subtype relationship is legal, and so for the time being Larch/C ++ only requires that certain syntactic conditions be satisfied.
Reference: [LW] <author> Gary T. Leavens and William E. Weihl. </author> <title> Subtyping, Modular Specification, and Modular Verification for Applicative Object-Oriented Programs. </title> <note> Submitted for publication. </note>
Reference-contexts: The proposed short-hand notation for defining traits with coerced operations (from <ref> [LW] </ref>) is given in following the keywords by, subsort, and Acct. The meaning of the trait in Figure 6 should be exactly the same as in Figure 5.
Reference: [LW90] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about Object-oriented Programs that use Subtypes (extended abstract). </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 212-223, </pages> <month> October </month> <year> 1990. </year> <booktitle> OOPSLA ECOOP '90 Proceedings, </booktitle> <editor> N. Meyrowitz (editor). </editor> <volume> 20 </volume>
Reference-contexts: The above goals are directed at making Larch/C ++ practical. In addition, we have some other goals which should help make Larch/C ++ useful, but which are motivated by a particular view of object-oriented programming [Ame87] [Mey88] <ref> [LW90] </ref> [Lea90] [Lea91]. This view centers around supertype abstraction, which is the ability to reason about a program based on nominal (i.e., static) type information by letting supertypes stand for all their subtypes. <p> For example, one must be able to specify enough information about the relationships between subtypes and supertypes so that one can verify programs using static type information <ref> [LW90] </ref>. <p> Since message passing causes special difficulties in program verification it is worth taking extra trouble in specification if that will make the job of verification easier. One way to make such verification easier is by the use of legal subtype relationships <ref> [LW90] </ref> [Lea90] [Lea91]. 2.2.1 Distinguish Subtypes and Subclasses? In software engineering it is important to distinguish between the notions of type and class and the relationships of subtype and subclass. A type (i.e., an abstract data type) is a behavioral notion, and may be implemented by many different classes.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: The above goals are directed at making Larch/C ++ practical. In addition, we have some other goals which should help make Larch/C ++ useful, but which are motivated by a particular view of object-oriented programming [Ame87] <ref> [Mey88] </ref> [LW90] [Lea90] [Lea91]. This view centers around supertype abstraction, which is the ability to reason about a program based on nominal (i.e., static) type information by letting supertypes stand for all their subtypes. <p> Larch/Smalltalk has a completely different syntax, and does not deal with the different kinds of inheritance possible in C++. Outside the Larch family, Meyer's work on the programming language Eiffel has advanced the cause of applying formal methods to object-oriented programs <ref> [Mey88] </ref>. In Eiffel, one can specify pre- and post-conditions for operations of abstract data types using boolean expressions written in Eiffel. That is, unlike a Larch-style interface specification language, program expressions are used in pre- and post-conditions.
Reference: [Rey80] <author> John C. Reynolds. </author> <title> Using Category Theory to Design Implicit Conversions and Generic Operators. </title> <editor> In Neil D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, Proceedings of a Workshop, Aarhus, Denmark, volume 94 of Lecture Notes in Computer Science, </booktitle> <pages> pages 211-258. </pages> <publisher> Springer-Verlag, </publisher> <month> January </month> <year> 1980. </year>
Reference-contexts: To bring the values of the subtype up one uses a coercion function (not a relation) that maps each subtype abstract value to a single supertype abstract value [BW90] [GM87] [Ame91] <ref> [Rey80] </ref>. This allows assertions to be interpreted by mapping all values to the nominal type of the variables used in the assertion.
Reference: [Str91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language: Second Edition. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1991. </year>
Reference-contexts: 1 Introduction A pre-condition for reading this paper is that you understand the basics of object-oriented programming (see [Cox86] otherwise), have some familiarity with C or C ++ <ref> [Str91] </ref>, and have a good understanding of model-oriented interface specifications using Larch [GHW85]. The post-condition of this paper is that you should understand the rationale for our design of Larch/C ++ . 1.1 Challenges of C++ The programming language C ++ [ES90] [Str91] is an object-oriented extension to C. <p> have some familiarity with C or C ++ <ref> [Str91] </ref>, and have a good understanding of model-oriented interface specifications using Larch [GHW85]. The post-condition of this paper is that you should understand the rationale for our design of Larch/C ++ . 1.1 Challenges of C++ The programming language C ++ [ES90] [Str91] is an object-oriented extension to C. Although it is difficult to find hard data about language usage, anecdotal evidence, such as the amount of junk mail concerning C ++ , makes it clear that in the US C ++ is the most widely used object-oriented language.
Reference: [Win83] <author> Jeannette Marie Wing. </author> <title> A Two-Tiered Approach to Specifying Programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: Another example: one must be able to verify a subclass using the specification of the public and protected interfaces of its superclasses, independent of the implementation of the superclasses. 2 1.3 Related Work The most closely related work are other interface specification languages in the Larch family <ref> [Win83] </ref> [Win87] [Che89] [Win90] [GMP90] [Jon91] [GH91] [Che91]. The greatest influence has been from Larch/C and Larch/Smalltalk. From Larch/C we have adopted much syntax and the basic semantics of such common types as pointers. From Larch/Smalltalk we have taken much of the approach to inheritance and subtyping.
Reference: [Win87] <author> Jeannette M. Wing. </author> <title> Writing Larch Interface Language Specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 1-24, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Another example: one must be able to verify a subclass using the specification of the public and protected interfaces of its superclasses, independent of the implementation of the superclasses. 2 1.3 Related Work The most closely related work are other interface specification languages in the Larch family [Win83] <ref> [Win87] </ref> [Che89] [Win90] [GMP90] [Jon91] [GH91] [Che91]. The greatest influence has been from Larch/C and Larch/Smalltalk. From Larch/C we have adopted much syntax and the basic semantics of such common types as pointers. From Larch/Smalltalk we have taken much of the approach to inheritance and subtyping.
Reference: [Win90] <author> Jeannette M. Wing. </author> <title> Using Larch to Specify Avalon/C++ Objects. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 1076-1088, </pages> <month> September </month> <year> 1990. </year> <month> 21 </month>
Reference-contexts: Another example: one must be able to verify a subclass using the specification of the public and protected interfaces of its superclasses, independent of the implementation of the superclasses. 2 1.3 Related Work The most closely related work are other interface specification languages in the Larch family [Win83] [Win87] [Che89] <ref> [Win90] </ref> [GMP90] [Jon91] [GH91] [Che91]. The greatest influence has been from Larch/C and Larch/Smalltalk. From Larch/C we have adopted much syntax and the basic semantics of such common types as pointers. From Larch/Smalltalk we have taken much of the approach to inheritance and subtyping. <p> This abbreviation is useful because one would otherwise have to write (*this)' to refer to the post-state of the receiving object, which is error prone because of the ambiguity in (a human reader's) parsing of *this' as (*this)' or *(this'). Wing's paper on Avalon/C ++ <ref> [Win90] </ref> uses this as if it were a location containing the abstract value of the object receiving a message, but in C ++ this is a pointer to that location, not the location itself.
References-found: 31

