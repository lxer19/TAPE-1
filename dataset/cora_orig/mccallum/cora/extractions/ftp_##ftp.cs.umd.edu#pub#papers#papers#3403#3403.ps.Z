URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3403/3403.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: ksb@cs.umd.edu mauney@csc.ncsu.edu  
Title: A Parametric View of Retargetable Register Allocation  
Author: Kelvin S. Bryant Jon Mauney 
Date: January 24, 1995  
Address: College Park, MD 20742 N.C. State Univ., Raleigh, NC 27695  
Affiliation: Dept. of Computer Science Dept. of Computer Science Univ. of Maryland,  
Pubnum: 301-405-2703  
Abstract: We discuss the problems involved in building a retargetable register allocator for use in an optimizing compiler. While the popular "register coloring" method is machine-independent, the allocator as a whole must implement numerous machine-dependent decisions. We present the kinds of information that must be parameterized in order to include register allocation in a retargetable compiler back-end, and discuss a sample solution.
Abstract-found: 1
Intro-found: 1
Reference: [AG89] <author> A. V. Aho and S. W. K. Ganapathi, M. Tjiang. </author> <title> Code generation using tree matching and dynamic programming. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 491-516, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: In addition, some CISC instructions have unusual register requirements. This may cause additional spills if the requirements cannot be encoded in a form usable by the coloring routine. The interface was designed in an effort to combine automatic code generators (such as Twig <ref> [AG89] </ref> and BURG [FHP92]) with register coloring. Our approach, termed Generic Register Allocation System (GRAS) [Bry93], enhances the automatic code generator to allow the compiler writer to provide general register set information and instruction specific register information. The general register set information is provided using a Register Description File.
Reference: [BCKT89] <author> Preston Briggs, Keith D. Cooper, Ken Kennedy, and Linda Torczon. </author> <title> Coloring heuristics for register allocation. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(7) </volume> <pages> 275-284, </pages> <month> July </month> <year> 1989. </year> <booktitle> Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: For example, we will deal with what is probably the most popular register allocation technique, graph coloring, which was first described by Chaitin [CAC + 81] and subsequently improved many others <ref> [CH84, BGG + 89, BCKT89] </ref> Graph coloring is used to solve resource allocation problems where resource usage must be mutually exclusive. Nodes in the graph represent clients that use resources, edges link clients that need resources during overlapping time intervals, and finally, colors represent the resources. <p> Spill code will vary for different machines and is handled by lower-level routines in the allocator. Function getConstrained returns an unconstrained node if one exists. This process is optimized if the data structure containing the live ranges is sorted and indexed by degree <ref> [MB81, BCKT89] </ref>. Function getLowCost returns a pointer reference to the constrained node with the lowest spill cost.
Reference: [BGG + 89] <author> David Bernstein, Dina Q. Goldin, Martin C. Golumbic, Hugo Krawczyk, Yishay Man-sour, Itai Nahshon, and Ron Y. Pinter. </author> <title> Spill code minimization techniques for optimizing compilers. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(7) </volume> <pages> 258-263, </pages> <month> July </month> <year> 1989. </year> <booktitle> Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: For example, we will deal with what is probably the most popular register allocation technique, graph coloring, which was first described by Chaitin [CAC + 81] and subsequently improved many others <ref> [CH84, BGG + 89, BCKT89] </ref> Graph coloring is used to solve resource allocation problems where resource usage must be mutually exclusive. Nodes in the graph represent clients that use resources, edges link clients that need resources during overlapping time intervals, and finally, colors represent the resources.
Reference: [BHE91] <author> David G. Bradlee, Robert R. Henry, and Susan J. Eggers. </author> <title> The Marion system for retargetable instruction scheduling. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(6) </volume> <pages> 229-240, </pages> <month> June </month> <year> 1991. </year> <booktitle> Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Future efforts will combine different allocators with GRAS code generators. This will test the flexibility of our interface with different architectures. In addition, we plan to focus on some of the RISC related issues addressed by the Marion System <ref> [BHE91] </ref>.
Reference: [Bry93] <author> Kelvin S. Bryant. </author> <title> A Generic Appoach to Integrating Automatic Code Generation and Register Allocation. </title> <type> PhD thesis, </type> <institution> North Carolina State Univ., </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: This may cause additional spills if the requirements cannot be encoded in a form usable by the coloring routine. The interface was designed in an effort to combine automatic code generators (such as Twig [AG89] and BURG [FHP92]) with register coloring. Our approach, termed Generic Register Allocation System (GRAS) <ref> [Bry93] </ref>, enhances the automatic code generator to allow the compiler writer to provide general register set information and instruction specific register information. The general register set information is provided using a Register Description File.
Reference: [CAC + 81] <author> G. J. Chaitin, M. A. Auslander, A. K. Chandra, J. Cocke, M. E. Hopkins, and P. W. Markstein. </author> <title> Register allocation via coloring. </title> <journal> Computer Languages, </journal> <volume> 6(1) </volume> <pages> 47-57, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: For example, we will deal with what is probably the most popular register allocation technique, graph coloring, which was first described by Chaitin <ref> [CAC + 81] </ref> and subsequently improved many others [CH84, BGG + 89, BCKT89] Graph coloring is used to solve resource allocation problems where resource usage must be mutually exclusive.
Reference: [CH84] <author> Fred C. Chow and John L. Hennessy. </author> <title> Register allocation by priority-based coloring. </title> <journal> SIGPLAN Notices, </journal> <volume> 19(6) </volume> <pages> 222-232, </pages> <month> June </month> <year> 1984. </year> <booktitle> Proceedings of the ACM SIGPLAN '84 Symposium on Compiler Construction. </booktitle>
Reference-contexts: For example, we will deal with what is probably the most popular register allocation technique, graph coloring, which was first described by Chaitin [CAC + 81] and subsequently improved many others <ref> [CH84, BGG + 89, BCKT89] </ref> Graph coloring is used to solve resource allocation problems where resource usage must be mutually exclusive. Nodes in the graph represent clients that use resources, edges link clients that need resources during overlapping time intervals, and finally, colors represent the resources.
Reference: [FHP92] <author> C.W. Fraser, R.R. Henry, and T.A. Proebsting. </author> <title> Burg fast optimal instruction selection and tree parsing. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(4) </volume> <pages> 68-76, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: In addition, some CISC instructions have unusual register requirements. This may cause additional spills if the requirements cannot be encoded in a form usable by the coloring routine. The interface was designed in an effort to combine automatic code generators (such as Twig [AG89] and BURG <ref> [FHP92] </ref>) with register coloring. Our approach, termed Generic Register Allocation System (GRAS) [Bry93], enhances the automatic code generator to allow the compiler writer to provide general register set information and instruction specific register information. The general register set information is provided using a Register Description File.
Reference: [LH86] <author> James R. Larus and Paul N. Hilfinger. </author> <title> Register allocation in the SPUR Lisp compiler. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(7) </volume> <pages> 255-263, </pages> <month> July </month> <year> 1986. </year> <booktitle> Proceedings of the ACM SIGPLAN '86 Symposium on Compiler Construction. </booktitle>
Reference-contexts: As mentioned earlier, some coloring routines will split live ranges as part of the spill process. The split routine uses the CFG and the interference graph to locate appropriate split locations. Figure 2 shows the algorithm for a typical split routine <ref> [LH86] </ref>. The algorithm performs a breadth-first search of the given live range (using the CFG) to build two new live ranges. The first live range will be composed of the live ranges elements traversed in the breadth-first search.
Reference: [MB81] <author> D. W. Matula and L. L. Beck. </author> <title> Smallest-last ordering and clustering and graph coloring algorithms. </title> <type> Technical Report CSE-8104, </type> <institution> Southern Methodist University, Dallas, TX, </institution> <month> July </month> <year> 1981. </year> <month> 9 </month>
Reference-contexts: Spill code will vary for different machines and is handled by lower-level routines in the allocator. Function getConstrained returns an unconstrained node if one exists. This process is optimized if the data structure containing the live ranges is sorted and indexed by degree <ref> [MB81, BCKT89] </ref>. Function getLowCost returns a pointer reference to the constrained node with the lowest spill cost.
References-found: 10

