URL: ftp://ftp.elis.rug.ac.be/pub/prolog/iclp94_workshop/debosschere.ps.Z
Refering-URL: http://www.informatik.uni-trier.de/~ley/db/conf/iclp/iclp94-w1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: kdb@elis.rug.ac.be  
Title: Process-based Parallel Logic Programming: A Survey of the Basic Issues  
Author: Koen De Bosschere, 
Address: Belgium  
Affiliation: Universiteit Gent,  
Abstract: In the last 10 years several parallel logic programming languages based on the explicit creation of processes and the explicit interprocess communication have been developed. This paper gives an overview of some major issues that have influenced the development of the process-based languages such as process creation, the communication medium, the sending and the reception of messages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Almgren, S. Andersson, L. Flood, C. Frisk, H. Nilsson, and J. Sundberg. </author> <title> SICStus Prolog Library Manual. </title> <type> SICS technical report T91:12B, </type> <institution> SICS, Kista, Sweden, </institution> <year> 1991. </year> <month> 9 </month>
Reference-contexts: It runs completely independently, and can survive its creator. In this case, we should be careful not to communicate with already terminated processes. The Linda library of Sicstus-Prolog <ref> [1, 4] </ref>, Prolog-D-Linda [16], BlackLog [15], Multi-Prolog [8] and Shared Prolog [3] use spawning. And/or-parallel processes are created by a conjunction or a disjunction in the program, and the result of the parallel execution will determine the result of the conjunction or the disjunction. <p> A destructive receive physically removes a message from the communication medium while a non-destructive receive just checks its presence. Apart from this, the non-destructive receive has precisely the same semantics as the destructive receive, except for the removal of the message. The Linda library of Sicstus-Prolog <ref> [1, 4] </ref>, Prolog-D-Linda [16], Multi-Prolog [8] and Shared Prolog [3] have destructive as well as non-destructive forms of receive. <p> The non-blocking receive should be used with care because its outcome can be time-dependent [16]. The Linda library of Sicstus-Prolog <ref> [1, 4] </ref>, Prolog-D-Linda [16], BlackLog [15], Multi-Prolog [8] and Shared-Prolog [3] have suspending as well as non-suspending forms of receive. 5.5 Guards Receive can be enriched with conditions or guards to improve its functionality. <p> A typical example is that a process is waiting for data, or for a message to terminate itself. In this case, both messages will appear in the same medium. The Linda-package of Sicstus Prolog <ref> [1, 4] </ref> supports message non-determinism by specifying a list of possible messages in the receive primitive. An incoming message must unify with one of the messages in the list. 5.7 Compound receives A receive operation can read either one message or multiple messages simultaneously. <p> BlackLog blackboard [15] CS-Prolog channel [9] Delta-Prolog channel [6, 14] Prolog-D-Linda blackboard [16] MB-Prolog channel [17] Log blackboard [11] Multi-Prolog blackboard [8] PMS-Prolog channel [18] Polis Prolog blackboard [5] Shared Prolog blackboard [3] Sicstus Prolog blackboard <ref> [1, 4] </ref> Polka blackboard [7] Quintus Prolog channel [13] List of process-based parallel logic programming languages. 7 Conclusion In this paper we have described some of the major issues that are common to channel-based and blackboard-based logic programming languages.
Reference: [2] <author> H.E. Bal, J.G. </author> <title> Steiner, and A.S Tanenbaum. Programming languages for distributed comput-ing systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(2) </volume> <pages> 261-322, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: 1 Introduction In the last decade, there has been almost an explosion of parallel logic programming languages. This evolution has been fueled by the ever increasing need for more computing power and by the need of the user to implement parallel algorithms or functional specialization <ref> [2] </ref>. A second driving force was the availability of multiprocessors and multicomputers at affordable prices and a good price/performance ratio. Logic programming is actually the perfect paradigm for parallelization. The description of a problem (the logic) is separated from its execution (the control). <p> All this material should give the reader a deeper insight in the various systems that have emerged in recent years and give him or her a basis for comparison. This paper is an extension of the paper of Bal et al. <ref> [2] </ref> on distributed programming languages. In contrast to the paper of Bal we do not consider fault tolerance because most of the process-based logic programming languages do not (yet) have provisions for it. On the other hand, the communication and synchronization is further elaborated. <p> Process identifiers are generated during the execution, and hence have to be passed around. They do not need a process database anymore. 2.4 Granularity Granularity is the amount of computing between the communications <ref> [2] </ref>. The granularity can vary from very fine to very large. Generally, systems that are based on and/or parallelism will have a finer granularity than the systems that use process spawning although there is no fundamental reason for that. The granularity should be chosen in function of the communication cost. <p> Synchronous communication (see below) does not need a buffered communication medium, but asynchronous communication does. Channels in CS-Prolog [9] and Quintus Prolog [13] are buffered. All blackboard systems are buffered. Buffered communication is believed to be less deadlock-prone than unbuffered communication <ref> [2] </ref>. A buffered communication medium can hold a finite number of messages. The sender of a message does not have to wait until a receiver is ready to consume a message. The message is sent to the communication medium where it can be removed by a receiver later on.
Reference: [3] <author> Antonio Brogi and Paolo Ciancarini. </author> <title> The Concurrent Language Shared Prolog. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 99-123, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: It runs completely independently, and can survive its creator. In this case, we should be careful not to communicate with already terminated processes. The Linda library of Sicstus-Prolog [1, 4], Prolog-D-Linda [16], BlackLog [15], Multi-Prolog [8] and Shared Prolog <ref> [3] </ref> use spawning. And/or-parallel processes are created by a conjunction or a disjunction in the program, and the result of the parallel execution will determine the result of the conjunction or the disjunction. <p> Dynamic processes When all the processes that will ever run in an application have to be defined at compile-time, we call them static processes. The languages Shared Prolog <ref> [3] </ref>, and Polis Prolog [5] make use of 3 static processes, as do communication sequential processes in [10]. Most process-based languages however support the dynamic creation of processes. The dynamic creation of processes make the problem of managing the processes and balancing the load harder. <p> The object receives the update requests by means of a stream implemented as an incomplete list. Most blackboard systems are dynamic whereas many channel-based systems are static. Multi-Prolog has static blackboards. 3.6 Multiple media A program can have access to a single global communication medium (as in Shared Prolog <ref> [3] </ref> and some Linda-based systems), or to a set of communication media that are either created statically (many channel-based systems), or that can be created dynamically (as in Multi-Prolog [8], Polis Prolog [5] or BlackLog [15]). <p> Apart from this, the non-destructive receive has precisely the same semantics as the destructive receive, except for the removal of the message. The Linda library of Sicstus-Prolog [1, 4], Prolog-D-Linda [16], Multi-Prolog [8] and Shared Prolog <ref> [3] </ref> have destructive as well as non-destructive forms of receive. <p> The non-blocking receive should be used with care because its outcome can be time-dependent [16]. The Linda library of Sicstus-Prolog [1, 4], Prolog-D-Linda [16], BlackLog [15], Multi-Prolog [8] and Shared-Prolog <ref> [3] </ref> have suspending as well as non-suspending forms of receive. 5.5 Guards Receive can be enriched with conditions or guards to improve its functionality. The semantics is that a matching message must be available for consumption, and that the condition must hold. <p> This functionality is not easy to be simulated by means of the primitives discussed above because the communication itself and the evaluation of the condition must be executed atomically. Delta-Prolog [6] supports guards in the receivers as well as in the senders. Multi-Prolog [8] and Shared-Prolog <ref> [3] </ref> support guards for blackboard communication too. G. Sutcliffe proves in [16] that guards can be simulated in a language without guards by letting the sender evaluate the guard and add the result as an extra flag to the message. <p> BlackLog blackboard [15] CS-Prolog channel [9] Delta-Prolog channel [6, 14] Prolog-D-Linda blackboard [16] MB-Prolog channel [17] Log blackboard [11] Multi-Prolog blackboard [8] PMS-Prolog channel [18] Polis Prolog blackboard [5] Shared Prolog blackboard <ref> [3] </ref> Sicstus Prolog blackboard [1, 4] Polka blackboard [7] Quintus Prolog channel [13] List of process-based parallel logic programming languages. 7 Conclusion In this paper we have described some of the major issues that are common to channel-based and blackboard-based logic programming languages.
Reference: [4] <author> M. Carlsson, J. Widen, J. Andersson, S. Andersson, K. Boortz, H. Nilsson, and T. Sjoland. </author> <title> SICStus Prolog User's Manual. </title> <type> SICS technical report T91:11B, </type> <institution> SICS, Kista, Sweden, </institution> <year> 1991. </year>
Reference-contexts: It runs completely independently, and can survive its creator. In this case, we should be careful not to communicate with already terminated processes. The Linda library of Sicstus-Prolog <ref> [1, 4] </ref>, Prolog-D-Linda [16], BlackLog [15], Multi-Prolog [8] and Shared Prolog [3] use spawning. And/or-parallel processes are created by a conjunction or a disjunction in the program, and the result of the parallel execution will determine the result of the conjunction or the disjunction. <p> A destructive receive physically removes a message from the communication medium while a non-destructive receive just checks its presence. Apart from this, the non-destructive receive has precisely the same semantics as the destructive receive, except for the removal of the message. The Linda library of Sicstus-Prolog <ref> [1, 4] </ref>, Prolog-D-Linda [16], Multi-Prolog [8] and Shared Prolog [3] have destructive as well as non-destructive forms of receive. <p> The non-blocking receive should be used with care because its outcome can be time-dependent [16]. The Linda library of Sicstus-Prolog <ref> [1, 4] </ref>, Prolog-D-Linda [16], BlackLog [15], Multi-Prolog [8] and Shared-Prolog [3] have suspending as well as non-suspending forms of receive. 5.5 Guards Receive can be enriched with conditions or guards to improve its functionality. <p> A typical example is that a process is waiting for data, or for a message to terminate itself. In this case, both messages will appear in the same medium. The Linda-package of Sicstus Prolog <ref> [1, 4] </ref> supports message non-determinism by specifying a list of possible messages in the receive primitive. An incoming message must unify with one of the messages in the list. 5.7 Compound receives A receive operation can read either one message or multiple messages simultaneously. <p> BlackLog blackboard [15] CS-Prolog channel [9] Delta-Prolog channel [6, 14] Prolog-D-Linda blackboard [16] MB-Prolog channel [17] Log blackboard [11] Multi-Prolog blackboard [8] PMS-Prolog channel [18] Polis Prolog blackboard [5] Shared Prolog blackboard [3] Sicstus Prolog blackboard <ref> [1, 4] </ref> Polka blackboard [7] Quintus Prolog channel [13] List of process-based parallel logic programming languages. 7 Conclusion In this paper we have described some of the major issues that are common to channel-based and blackboard-based logic programming languages.
Reference: [5] <author> P. Ciancarini. </author> <title> Parallel Logic Programming using the Linda model of Computation. </title> <editor> In G. Goos and J. Hartmanis, editors, </editor> <booktitle> Proceedings of Research Directions in High-Level Parallel Programming Languages, </booktitle> <pages> pages 110-125. </pages> <publisher> Springer Verlag, </publisher> <address> Mont Saint Michel, France, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Dynamic processes When all the processes that will ever run in an application have to be defined at compile-time, we call them static processes. The languages Shared Prolog [3], and Polis Prolog <ref> [5] </ref> make use of 3 static processes, as do communication sequential processes in [10]. Most process-based languages however support the dynamic creation of processes. The dynamic creation of processes make the problem of managing the processes and balancing the load harder. <p> 3.6 Multiple media A program can have access to a single global communication medium (as in Shared Prolog [3] and some Linda-based systems), or to a set of communication media that are either created statically (many channel-based systems), or that can be created dynamically (as in Multi-Prolog [8], Polis Prolog <ref> [5] </ref> or BlackLog [15]). The dynamic creation of communication media implies that they can be passed around in the program, and that there should be provisions to delete them too. 3.7 Naming Naming governs the way in which a communication partner is specified. <p> Reading the messages sequentially without synchronization might give rise to a deadlocked system. 6 Languages mentioned Name type Refs. BlackLog blackboard [15] CS-Prolog channel [9] Delta-Prolog channel [6, 14] Prolog-D-Linda blackboard [16] MB-Prolog channel [17] Log blackboard [11] Multi-Prolog blackboard [8] PMS-Prolog channel [18] Polis Prolog blackboard <ref> [5] </ref> Shared Prolog blackboard [3] Sicstus Prolog blackboard [1, 4] Polka blackboard [7] Quintus Prolog channel [13] List of process-based parallel logic programming languages. 7 Conclusion In this paper we have described some of the major issues that are common to channel-based and blackboard-based logic programming languages.
Reference: [6] <author> J.C. Cunha, P.D. Medeiros, M.B. Carvalhosa, and L.M. Pereira. Delta-prolog: </author> <title> A distributed logic programming language and its implementation on distributed memory multiprocessors. </title> <booktitle> In Kacsuk and Wise [12], </booktitle> <pages> pages 335-356. </pages>
Reference-contexts: In this case, the set of parallel processes must terminate successfully in order to make the conjunction or disjunction terminate successfully. Data shared between the two components of a conjunction or a disjunction require extra synchronization. The process creation of Delta-Prolog <ref> [6, 14] </ref> is based on and-parallelism. PMS-Prolog [18] has a rather unusual mechanism of process creation: it forks a list of processes, and then waits until the child processes have all terminated before resuming. Forking one process is comparable to executing a remote procedure call. <p> The semantics of buffer overflow might vary: failure, suspension, error messages,: : : . 3.3 Data ordering This issue is related to buffered communication. It defines the order in which data is stored in (removed from) the buffer. This can be * ordered: e.g., first-in first-out <ref> [6] </ref>, last-in-first-out, lexically sorted, chronologically sorted [8]: : : * partly ordered, i.e., the messages generated by a sequential process are ordered, but there is no order between messages generated by two processes running in parallel. * no defined order, i.e., the messages are put in a bag without any order <p> Examples of languages that use synchronous communication are: Delta-Prolog <ref> [6] </ref>, Quintus Prolog [13], and PMS-Prolog [18]. For non-synchronous communication, a sender never waits for a receiver to respond. The message is sent instantaneously. It further depends on whether there is a buffered communication medium to know whether the message will be received by a receiver or is lost forever. <p> Back communication means that the variable is instantiated 6 by the receiver, and that this binding is propagated to the sender. Clearly, this only makes sense when (i) the communication is synchronous, and (ii) there is only one receiver. Delta-Prolog <ref> [6] </ref> supports back communication. Back communication is more wide-spread in goal-based parallel logic programming languages with variable sharing. 4.3 Backtracking Again four possibilities exist: 1. not undoing and not redoing (=failing): nothing happens. Once a message has been sent, it is sent forever. <p> This might imply that the receiver of a message is forced to fail and to backtrack up to the point where the communication took place. This might create a significant overhead. 4. undoing and redoing: obvious. Delta-Prolog <ref> [6] </ref> supports both the first and the third possibility. <p> The semantics is that a matching message must be available for consumption, and that the condition must hold. This functionality is not easy to be simulated by means of the primitives discussed above because the communication itself and the evaluation of the condition must be executed atomically. Delta-Prolog <ref> [6] </ref> supports guards in the receivers as well as in the senders. Multi-Prolog [8] and Shared-Prolog [3] support guards for blackboard communication too. G. <p> The medium that first provides a suitable message generates a communication event. A typical example is a channel to control a process. Even while the process is processing data, it should nevertheless look at the control channel too. Delta-Prolog <ref> [6] </ref> has choice goals to express media non-determinism. PMS-Prolog [18] has a receive primitive that accepts a list of channels to listen to. 8 2. message non-determinism. Hereby, a receive operation can receive one out of a set of message types. <p> Each process needs at least two messages in order to proceed. Reading the messages sequentially without synchronization might give rise to a deadlocked system. 6 Languages mentioned Name type Refs. BlackLog blackboard [15] CS-Prolog channel [9] Delta-Prolog channel <ref> [6, 14] </ref> Prolog-D-Linda blackboard [16] MB-Prolog channel [17] Log blackboard [11] Multi-Prolog blackboard [8] PMS-Prolog channel [18] Polis Prolog blackboard [5] Shared Prolog blackboard [3] Sicstus Prolog blackboard [1, 4] Polka blackboard [7] Quintus Prolog channel [13] List of process-based parallel logic programming languages. 7 Conclusion In this paper we have
Reference: [7] <author> A. Davison. </author> <title> Blackboard systems in polka. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 16(5) </volume> <pages> 401-421, </pages> <year> 1987. </year>
Reference-contexts: All communication requires an action of the communication manager that will take care of it. Some languages require the communication manager to be started explicitly. The blackboard system of Polka <ref> [7] </ref> is implemented as an object of the Polka language. The object runs as a parallel process and is responsible for updating the blackboard data structure. The object receives the update requests by means of a stream implemented as an incomplete list. <p> BlackLog blackboard [15] CS-Prolog channel [9] Delta-Prolog channel [6, 14] Prolog-D-Linda blackboard [16] MB-Prolog channel [17] Log blackboard [11] Multi-Prolog blackboard [8] PMS-Prolog channel [18] Polis Prolog blackboard [5] Shared Prolog blackboard [3] Sicstus Prolog blackboard [1, 4] Polka blackboard <ref> [7] </ref> Quintus Prolog channel [13] List of process-based parallel logic programming languages. 7 Conclusion In this paper we have described some of the major issues that are common to channel-based and blackboard-based logic programming languages.
Reference: [8] <author> K. De Bosschere and J.-M. Jacquet. Multi-Prolog: </author> <title> Definition, Operational Semantics and Implementation. </title> <editor> In D.S. Warren, editor, </editor> <booktitle> Proceedings of the ICLP'93 conference, </booktitle> <pages> pages 299-313, </pages> <address> Budapest, Hungary, June 1993. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: It runs completely independently, and can survive its creator. In this case, we should be careful not to communicate with already terminated processes. The Linda library of Sicstus-Prolog [1, 4], Prolog-D-Linda [16], BlackLog [15], Multi-Prolog <ref> [8] </ref> and Shared Prolog [3] use spawning. And/or-parallel processes are created by a conjunction or a disjunction in the program, and the result of the parallel execution will determine the result of the conjunction or the disjunction. <p> The order in which processes are resumed can either be random or have some order (e.g., chronological, priority based,: : : ). This issue is strongly related to fairness and to scheduling of processes. Most languages do not pay attention to this issue. In Multi-Prolog <ref> [8] </ref> and the Quintus Prolog multiprocessing package [13], suspended processes will be resumed on a first-come first-served basis. 3 The communication medium The communication medium is the system that will carry messages from one process to another. <p> It defines the order in which data is stored in (removed from) the buffer. This can be * ordered: e.g., first-in first-out [6], last-in-first-out, lexically sorted, chronologically sorted <ref> [8] </ref>: : : * partly ordered, i.e., the messages generated by a sequential process are ordered, but there is no order between messages generated by two processes running in parallel. * no defined order, i.e., the messages are put in a bag without any order at all. <p> has static blackboards. 3.6 Multiple media A program can have access to a single global communication medium (as in Shared Prolog [3] and some Linda-based systems), or to a set of communication media that are either created statically (many channel-based systems), or that can be created dynamically (as in Multi-Prolog <ref> [8] </ref>, Polis Prolog [5] or BlackLog [15]). The dynamic creation of communication media implies that they can be passed around in the program, and that there should be provisions to delete them too. 3.7 Naming Naming governs the way in which a communication partner is specified. <p> Apart from this, the non-destructive receive has precisely the same semantics as the destructive receive, except for the removal of the message. The Linda library of Sicstus-Prolog [1, 4], Prolog-D-Linda [16], Multi-Prolog <ref> [8] </ref> and Shared Prolog [3] have destructive as well as non-destructive forms of receive. <p> The non-blocking receive should be used with care because its outcome can be time-dependent [16]. The Linda library of Sicstus-Prolog [1, 4], Prolog-D-Linda [16], BlackLog [15], Multi-Prolog <ref> [8] </ref> and Shared-Prolog [3] have suspending as well as non-suspending forms of receive. 5.5 Guards Receive can be enriched with conditions or guards to improve its functionality. The semantics is that a matching message must be available for consumption, and that the condition must hold. <p> This functionality is not easy to be simulated by means of the primitives discussed above because the communication itself and the evaluation of the condition must be executed atomically. Delta-Prolog [6] supports guards in the receivers as well as in the senders. Multi-Prolog <ref> [8] </ref> and Shared-Prolog [3] support guards for blackboard communication too. G. Sutcliffe proves in [16] that guards can be simulated in a language without guards by letting the sender evaluate the guard and add the result as an extra flag to the message. <p> Reading the messages sequentially without synchronization might give rise to a deadlocked system. 6 Languages mentioned Name type Refs. BlackLog blackboard [15] CS-Prolog channel [9] Delta-Prolog channel [6, 14] Prolog-D-Linda blackboard [16] MB-Prolog channel [17] Log blackboard [11] Multi-Prolog blackboard <ref> [8] </ref> PMS-Prolog channel [18] Polis Prolog blackboard [5] Shared Prolog blackboard [3] Sicstus Prolog blackboard [1, 4] Polka blackboard [7] Quintus Prolog channel [13] List of process-based parallel logic programming languages. 7 Conclusion In this paper we have described some of the major issues that are common to channel-based and blackboard-based
Reference: [9] <author> Sz. Ferenczi and I. Futo. CS-Prolog, </author> <title> A Communicating Sequential Prolog. </title> <booktitle> In Kacsuk and Wise [12], </booktitle> <pages> pages 357-378. </pages>
Reference-contexts: PMS-Prolog [18] has a rather unusual mechanism of process creation: it forks a list of processes, and then waits until the child processes have all terminated before resuming. Forking one process is comparable to executing a remote procedure call. CS-Prolog <ref> [9] </ref> creates processes in an and-parallel way but the join is executed only at the termination of the program. A spawned process is considered a hypothesis. <p> Synchronous communication (see below) does not need a buffered communication medium, but asynchronous communication does. Channels in CS-Prolog <ref> [9] </ref> and Quintus Prolog [13] are buffered. All blackboard systems are buffered. Buffered communication is believed to be less deadlock-prone than unbuffered communication [2]. A buffered communication medium can hold a finite number of messages. <p> For non-synchronous communication, a sender never waits for a receiver to respond. The message is sent instantaneously. It further depends on whether there is a buffered communication medium to know whether the message will be received by a receiver or is lost forever. CS-Prolog <ref> [9] </ref> has non-synchronous buffered communication. All blackboard systems have nonsynchronous communication. 4.2 Back communication This is an effect that can take place during the communication and that does not exist in non logic programming languages. <p> Here, the receiver not only fails, but also returns the message previously read. Again, a significant overhead might be caused in order to do things right. Other processes might have to backtrack and to return to a previous state. 4. undoing and redoing: obvious. CS-Prolog <ref> [9] </ref> supports distributed backtracking, as a consequence of a failing communication. 7 5.2 Destructive vs. non-destructive receive A receive operation might be either destructive (usually called get), or non-destructive (usually called read). <p> Each process needs at least two messages in order to proceed. Reading the messages sequentially without synchronization might give rise to a deadlocked system. 6 Languages mentioned Name type Refs. BlackLog blackboard [15] CS-Prolog channel <ref> [9] </ref> Delta-Prolog channel [6, 14] Prolog-D-Linda blackboard [16] MB-Prolog channel [17] Log blackboard [11] Multi-Prolog blackboard [8] PMS-Prolog channel [18] Polis Prolog blackboard [5] Shared Prolog blackboard [3] Sicstus Prolog blackboard [1, 4] Polka blackboard [7] Quintus Prolog channel [13] List of process-based parallel logic programming languages. 7 Conclusion In this
Reference: [10] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <journal> CACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: Dynamic processes When all the processes that will ever run in an application have to be defined at compile-time, we call them static processes. The languages Shared Prolog [3], and Polis Prolog [5] make use of 3 static processes, as do communication sequential processes in <ref> [10] </ref>. Most process-based languages however support the dynamic creation of processes. The dynamic creation of processes make the problem of managing the processes and balancing the load harder. This issue is strongly related to the issue of naming.
Reference: [11] <author> J.-M. Jacquet and K. De Bosschere. </author> <title> On the Semantics of Log. </title> <booktitle> Future Generation Computer Systems, </booktitle> <month> February </month> <year> 1994. </year>
Reference-contexts: A spawned process is considered a hypothesis. The main program goes on, assuming the hypothesis to be true, but it will only terminate when all the hypotheses are proved to be true. Failing hypotheses will cause the program to backtrack distributedly (see below). Log <ref> [11] </ref> considers processes as active messages on the blackboard. A process is created by sending a goal message to the blackboard. Data messages are just terms on the blackboard. Consequently, processes can be killed by removing them from the blackboard. <p> Each process needs at least two messages in order to proceed. Reading the messages sequentially without synchronization might give rise to a deadlocked system. 6 Languages mentioned Name type Refs. BlackLog blackboard [15] CS-Prolog channel [9] Delta-Prolog channel [6, 14] Prolog-D-Linda blackboard [16] MB-Prolog channel [17] Log blackboard <ref> [11] </ref> Multi-Prolog blackboard [8] PMS-Prolog channel [18] Polis Prolog blackboard [5] Shared Prolog blackboard [3] Sicstus Prolog blackboard [1, 4] Polka blackboard [7] Quintus Prolog channel [13] List of process-based parallel logic programming languages. 7 Conclusion In this paper we have described some of the major issues that are common to
Reference: [12] <author> Peter Kacsuk and Michael J. Wise, </author> <title> editors. Implementations of Distributed Prolog. </title> <booktitle> Series in Parallel Computing. </booktitle> <publisher> Wiley, </publisher> <address> Chichester, </address> <year> 1992. </year>
Reference: [13] <author> R.M. Keller. </author> <title> A position on multiprocessing in prolog. </title> <booktitle> In Proceedings of the Joint Japanese/American Workshop ICOT/NSF, </booktitle> <pages> pages 27-49, </pages> <month> October 1089. </month>
Reference-contexts: This issue is strongly related to fairness and to scheduling of processes. Most languages do not pay attention to this issue. In Multi-Prolog [8] and the Quintus Prolog multiprocessing package <ref> [13] </ref>, suspended processes will be resumed on a first-come first-served basis. 3 The communication medium The communication medium is the system that will carry messages from one process to another. <p> Synchronous communication (see below) does not need a buffered communication medium, but asynchronous communication does. Channels in CS-Prolog [9] and Quintus Prolog <ref> [13] </ref> are buffered. All blackboard systems are buffered. Buffered communication is believed to be less deadlock-prone than unbuffered communication [2]. A buffered communication medium can hold a finite number of messages. The sender of a message does not have to wait until a receiver is ready to consume a message. <p> Examples of languages that use synchronous communication are: Delta-Prolog [6], Quintus Prolog <ref> [13] </ref>, and PMS-Prolog [18]. For non-synchronous communication, a sender never waits for a receiver to respond. The message is sent instantaneously. It further depends on whether there is a buffered communication medium to know whether the message will be received by a receiver or is lost forever. <p> BlackLog blackboard [15] CS-Prolog channel [9] Delta-Prolog channel [6, 14] Prolog-D-Linda blackboard [16] MB-Prolog channel [17] Log blackboard [11] Multi-Prolog blackboard [8] PMS-Prolog channel [18] Polis Prolog blackboard [5] Shared Prolog blackboard [3] Sicstus Prolog blackboard [1, 4] Polka blackboard [7] Quintus Prolog channel <ref> [13] </ref> List of process-based parallel logic programming languages. 7 Conclusion In this paper we have described some of the major issues that are common to channel-based and blackboard-based logic programming languages.
Reference: [14] <author> L.M. Pereira, L. Monteiro, J. Cunha, and J.N. Aparcio. </author> <title> Delta Prolog : A Distributed Backtracking Extension with Events. </title> <editor> In G. Goos and J. Hartmanis, editors, </editor> <booktitle> Proceedings of the Third International Conference on Logic Programming, volume 225 of Lecture Notes in Computer Science, </booktitle> <address> London, July 1986. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: In this case, the set of parallel processes must terminate successfully in order to make the conjunction or disjunction terminate successfully. Data shared between the two components of a conjunction or a disjunction require extra synchronization. The process creation of Delta-Prolog <ref> [6, 14] </ref> is based on and-parallelism. PMS-Prolog [18] has a rather unusual mechanism of process creation: it forks a list of processes, and then waits until the child processes have all terminated before resuming. Forking one process is comparable to executing a remote procedure call. <p> Each process needs at least two messages in order to proceed. Reading the messages sequentially without synchronization might give rise to a deadlocked system. 6 Languages mentioned Name type Refs. BlackLog blackboard [15] CS-Prolog channel [9] Delta-Prolog channel <ref> [6, 14] </ref> Prolog-D-Linda blackboard [16] MB-Prolog channel [17] Log blackboard [11] Multi-Prolog blackboard [8] PMS-Prolog channel [18] Polis Prolog blackboard [5] Shared Prolog blackboard [3] Sicstus Prolog blackboard [1, 4] Polka blackboard [7] Quintus Prolog channel [13] List of process-based parallel logic programming languages. 7 Conclusion In this paper we have
Reference: [15] <author> D.G. Schwartz. </author> <title> Cooperating Heterogeneous Systems: A Blackboard-based Meta Approach. </title> <type> PhD thesis, </type> <institution> Department of Computer Engineering and Science, Case Western Reserve University, </institution> <year> 1993. </year>
Reference-contexts: It runs completely independently, and can survive its creator. In this case, we should be careful not to communicate with already terminated processes. The Linda library of Sicstus-Prolog [1, 4], Prolog-D-Linda [16], BlackLog <ref> [15] </ref>, Multi-Prolog [8] and Shared Prolog [3] use spawning. And/or-parallel processes are created by a conjunction or a disjunction in the program, and the result of the parallel execution will determine the result of the conjunction or the disjunction. <p> A program can have access to a single global communication medium (as in Shared Prolog [3] and some Linda-based systems), or to a set of communication media that are either created statically (many channel-based systems), or that can be created dynamically (as in Multi-Prolog [8], Polis Prolog [5] or BlackLog <ref> [15] </ref>). The dynamic creation of communication media implies that they can be passed around in the program, and that there should be provisions to delete them too. 3.7 Naming Naming governs the way in which a communication partner is specified. <p> The non-blocking receive should be used with care because its outcome can be time-dependent [16]. The Linda library of Sicstus-Prolog [1, 4], Prolog-D-Linda [16], BlackLog <ref> [15] </ref>, Multi-Prolog [8] and Shared-Prolog [3] have suspending as well as non-suspending forms of receive. 5.5 Guards Receive can be enriched with conditions or guards to improve its functionality. The semantics is that a matching message must be available for consumption, and that the condition must hold. <p> A typical example is that several independent but identical processes are competing for a set of messages. Each process needs at least two messages in order to proceed. Reading the messages sequentially without synchronization might give rise to a deadlocked system. 6 Languages mentioned Name type Refs. BlackLog blackboard <ref> [15] </ref> CS-Prolog channel [9] Delta-Prolog channel [6, 14] Prolog-D-Linda blackboard [16] MB-Prolog channel [17] Log blackboard [11] Multi-Prolog blackboard [8] PMS-Prolog channel [18] Polis Prolog blackboard [5] Shared Prolog blackboard [3] Sicstus Prolog blackboard [1, 4] Polka blackboard [7] Quintus Prolog channel [13] List of process-based parallel logic programming languages. 7
Reference: [16] <author> G. Sutcliffe and J. Pinakis. Prolog-D-Linda: </author> <title> An Embedding of Linda in SICStus Prolog. </title> <type> Technical Report 91/7, </type> <institution> Department of Computer Science, University of Western Australia, </institution> <year> 1991. </year>
Reference-contexts: It runs completely independently, and can survive its creator. In this case, we should be careful not to communicate with already terminated processes. The Linda library of Sicstus-Prolog [1, 4], Prolog-D-Linda <ref> [16] </ref>, BlackLog [15], Multi-Prolog [8] and Shared Prolog [3] use spawning. And/or-parallel processes are created by a conjunction or a disjunction in the program, and the result of the parallel execution will determine the result of the conjunction or the disjunction. <p> A destructive receive physically removes a message from the communication medium while a non-destructive receive just checks its presence. Apart from this, the non-destructive receive has precisely the same semantics as the destructive receive, except for the removal of the message. The Linda library of Sicstus-Prolog [1, 4], Prolog-D-Linda <ref> [16] </ref>, Multi-Prolog [8] and Shared Prolog [3] have destructive as well as non-destructive forms of receive. <p> The non-blocking receive should be used with care because its outcome can be time-dependent <ref> [16] </ref>. The Linda library of Sicstus-Prolog [1, 4], Prolog-D-Linda [16], BlackLog [15], Multi-Prolog [8] and Shared-Prolog [3] have suspending as well as non-suspending forms of receive. 5.5 Guards Receive can be enriched with conditions or guards to improve its functionality. <p> The non-blocking receive should be used with care because its outcome can be time-dependent <ref> [16] </ref>. The Linda library of Sicstus-Prolog [1, 4], Prolog-D-Linda [16], BlackLog [15], Multi-Prolog [8] and Shared-Prolog [3] have suspending as well as non-suspending forms of receive. 5.5 Guards Receive can be enriched with conditions or guards to improve its functionality. The semantics is that a matching message must be available for consumption, and that the condition must hold. <p> Delta-Prolog [6] supports guards in the receivers as well as in the senders. Multi-Prolog [8] and Shared-Prolog [3] support guards for blackboard communication too. G. Sutcliffe proves in <ref> [16] </ref> that guards can be simulated in a language without guards by letting the sender evaluate the guard and add the result as an extra flag to the message. The receiver only has to check to value of that flag instead of evaluating the guard. <p> Each process needs at least two messages in order to proceed. Reading the messages sequentially without synchronization might give rise to a deadlocked system. 6 Languages mentioned Name type Refs. BlackLog blackboard [15] CS-Prolog channel [9] Delta-Prolog channel [6, 14] Prolog-D-Linda blackboard <ref> [16] </ref> MB-Prolog channel [17] Log blackboard [11] Multi-Prolog blackboard [8] PMS-Prolog channel [18] Polis Prolog blackboard [5] Shared Prolog blackboard [3] Sicstus Prolog blackboard [1, 4] Polka blackboard [7] Quintus Prolog channel [13] List of process-based parallel logic programming languages. 7 Conclusion In this paper we have described some of the
Reference: [17] <author> M.J. Wise. </author> <title> Message-brokers and communicating prolog processes. </title> <booktitle> In Proceedings of PARLE'92: Parallel Architectures and Languages Europe, volume 605 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Now, the communication medium should be static, or must be a first class object in the language. This naming is called indirect because the communication partners do not have direct contact, and do not necessarily know each other. MB-Prolog <ref> [17] </ref> has a type of naming that lies between direct and indirect naming. Processes wanting to communicate send a request to a message broker. As soon as a match is found in the message broker, the absolute addresses of the processes are returned. <p> Each process needs at least two messages in order to proceed. Reading the messages sequentially without synchronization might give rise to a deadlocked system. 6 Languages mentioned Name type Refs. BlackLog blackboard [15] CS-Prolog channel [9] Delta-Prolog channel [6, 14] Prolog-D-Linda blackboard [16] MB-Prolog channel <ref> [17] </ref> Log blackboard [11] Multi-Prolog blackboard [8] PMS-Prolog channel [18] Polis Prolog blackboard [5] Shared Prolog blackboard [3] Sicstus Prolog blackboard [1, 4] Polka blackboard [7] Quintus Prolog channel [13] List of process-based parallel logic programming languages. 7 Conclusion In this paper we have described some of the major issues that
Reference: [18] <author> M.J. Wise, D.G. Jones, and T. Hintz. PMS-Prolog: </author> <title> A Distributed Coarse-grain-parallel Prolog with Processes, Modules and Streams. </title> <booktitle> In Kacsuk and Wise [12], </booktitle> <pages> pages 379-403. 10 </pages>
Reference-contexts: In this case, the set of parallel processes must terminate successfully in order to make the conjunction or disjunction terminate successfully. Data shared between the two components of a conjunction or a disjunction require extra synchronization. The process creation of Delta-Prolog [6, 14] is based on and-parallelism. PMS-Prolog <ref> [18] </ref> has a rather unusual mechanism of process creation: it forks a list of processes, and then waits until the child processes have all terminated before resuming. Forking one process is comparable to executing a remote procedure call. <p> Examples of languages that use synchronous communication are: Delta-Prolog [6], Quintus Prolog [13], and PMS-Prolog <ref> [18] </ref>. For non-synchronous communication, a sender never waits for a receiver to respond. The message is sent instantaneously. It further depends on whether there is a buffered communication medium to know whether the message will be received by a receiver or is lost forever. CS-Prolog [9] has non-synchronous buffered communication. <p> The medium that first provides a suitable message generates a communication event. A typical example is a channel to control a process. Even while the process is processing data, it should nevertheless look at the control channel too. Delta-Prolog [6] has choice goals to express media non-determinism. PMS-Prolog <ref> [18] </ref> has a receive primitive that accepts a list of channels to listen to. 8 2. message non-determinism. Hereby, a receive operation can receive one out of a set of message types. So, it must not be waiting for one particular type, but for all at once. <p> Reading the messages sequentially without synchronization might give rise to a deadlocked system. 6 Languages mentioned Name type Refs. BlackLog blackboard [15] CS-Prolog channel [9] Delta-Prolog channel [6, 14] Prolog-D-Linda blackboard [16] MB-Prolog channel [17] Log blackboard [11] Multi-Prolog blackboard [8] PMS-Prolog channel <ref> [18] </ref> Polis Prolog blackboard [5] Shared Prolog blackboard [3] Sicstus Prolog blackboard [1, 4] Polka blackboard [7] Quintus Prolog channel [13] List of process-based parallel logic programming languages. 7 Conclusion In this paper we have described some of the major issues that are common to channel-based and blackboard-based logic programming languages.
References-found: 18

