URL: http://www.cs.wisc.edu/wpis/papers/tr890.ps
Refering-URL: http://www.cs.wisc.edu/wpis/papers/
Root-URL: http://www.cs.wisc.edu
Title: The Multi-Procedure Equivalence Theorem Program dependence graphs have been used in program optimization, vectorization, and
Author: DAVID BINKLEY, SUSAN HORWITZ, and THOMAS REPS 
Keyword: CR Categories and Subject Descriptors: D.3.3 [Programming Languages]: Language Constructs control structures, procedures, functions, and subroutines; D.3.4 [Programming Languages]: Processors compilers, optimization; E.1 [Data]: Data Structures graphs, trees General Terms: Theory Additional Key Words and Phrases: activation tree, aliasing, control dependence, control-flow graph, data dependence, data-flow analysis, program dependence graph, strong equivalence, system dependence graph  
Affiliation: University of Wisconsin Madison  
Abstract: This paper concerns the question of whether program dependence graphs are adequate as a program representation. Previous results on the adequacy of program dependence graphs have been limited to a language without procedures and procedure calls. Our main result is a theorem that extends previous results to a language with procedures and procedure calls. The theorem shows that if the program dependence graphs of two programs are isomorphic then the programs are strongly equivalent. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Banning, J.P., </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables, </title> <booktitle> 6th annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. </pages> <month> 29-41 (January </month> <year> 1979). </year>
Reference-contexts: Occurrences of formal parameters in procedure Q are implicitly dereferenced. Before returning, Q copies return values into the return temporaries, from which P retrieves them. The vertices used to represent a call statement in a PDG are determined from interprocedural summary information <ref> [1] </ref>. Two kinds of interprocedural summary information are determined for each procedure P: GMOD (P) the set of formal parameters that might be modified by P itself or by a procedure (transitively) called from P. <p> Example. Let procedure P have two formal parameters x and y. Assume that GMOD (P) = - x and GREF (P) = - x, y - (recall that which values are transferred to and from a called procedure is determined from interprocedural summary information <ref> [1] </ref>). <p> do v 2 but not v 1 fi o v 2 , and vice versa: hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 8 As with flow dependences, anti-dependence and output dependence may be further characterized as loop-independent or loop-carried. - 23 - [2] if P then [3] x := 11 [5] fi The one def-order dependence, <ref> [1] </ref> fi do ([6]) [4], exists because the assignments to x in lines [1] and [4] both reach the use in line [6]. In contrast, the output dependences are [1] fi o [3] and [3] fi o [4], but there is no output dependence [1] fi o [4]. <p> vice versa: hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 8 As with flow dependences, anti-dependence and output dependence may be further characterized as loop-independent or loop-carried. - 23 - [2] if P then [3] x := 11 [5] fi The one def-order dependence, <ref> [1] </ref> fi do ([6]) [4], exists because the assignments to x in lines [1] and [4] both reach the use in line [6]. In contrast, the output dependences are [1] fi o [3] and [3] fi o [4], but there is no output dependence [1] fi o [4]. <p> as loop-independent or loop-carried. - 23 - [2] if P then [3] x := 11 [5] fi The one def-order dependence, <ref> [1] </ref> fi do ([6]) [4], exists because the assignments to x in lines [1] and [4] both reach the use in line [6]. In contrast, the output dependences are [1] fi o [3] and [3] fi o [4], but there is no output dependence [1] fi o [4]. The Multi-Procedure Equivalence Theorem still holds if the system dependence graph is defined to have output dependence edges rather than def-order dependences edges. <p> [5] fi The one def-order dependence, <ref> [1] </ref> fi do ([6]) [4], exists because the assignments to x in lines [1] and [4] both reach the use in line [6]. In contrast, the output dependences are [1] fi o [3] and [3] fi o [4], but there is no output dependence [1] fi o [4]. The Multi-Procedure Equivalence Theorem still holds if the system dependence graph is defined to have output dependence edges rather than def-order dependences edges.
Reference: 2. <author> Cooper, K.D. and Kennedy, K., </author> <title> Fast interprocedural alias analysis, </title> <booktitle> Conference Record of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Austin, TX, </address> <month> January 11-13, </month> <year> 1989), </year> <pages> pp. 49-59 ACM, </pages> <year> (1989). </year>
Reference-contexts: possible to have a program in which there is a dependence v 1 fi do v 2 but not v 1 fi o v 2 , and vice versa: hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 8 As with flow dependences, anti-dependence and output dependence may be further characterized as loop-independent or loop-carried. - 23 - <ref> [2] </ref> if P then [3] x := 11 [5] fi The one def-order dependence, [1] fi do ([6]) [4], exists because the assignments to x in lines [1] and [4] both reach the use in line [6].
Reference: 3. <author> Cytron, R., Hind, M., and Hsieh, W., </author> <title> Automatic Generation of DAG Parallelism, </title> <booktitle> Proceedings of the ACM SIGPLAN 89 Conference on Programming Language Design and Implementation, </booktitle> <address> (Portland, OR, </address> <month> June 21-23, </month> <title> 1889), </title> <journal> ACM SIGPLAN Notices 24(7) pp. </journal> <month> 54-68 (June </month> <year> 1989). </year>
Reference-contexts: By including the additional edge, the predicate's outgoing true edges consist of every program element that is guaranteed to be executed (eventually, assuming all loops and procedures calls terminate) when the predicate evaluates to true. Our control dependence edges are technically the forward control dependence edges defined in <ref> [3] </ref>. - 5 - There is a data dependence edge from vertex v 1 to vertex v 2 if reversing the relative order of the components represented by v 1 and v 2 may alter the program's computation. <p> program in which there is a dependence v 1 fi do v 2 but not v 1 fi o v 2 , and vice versa: hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 8 As with flow dependences, anti-dependence and output dependence may be further characterized as loop-independent or loop-carried. - 23 - [2] if P then <ref> [3] </ref> x := 11 [5] fi The one def-order dependence, [1] fi do ([6]) [4], exists because the assignments to x in lines [1] and [4] both reach the use in line [6]. In contrast, the output dependences are [1] fi o [3] and [3] fi o [4], but there is <p> loop-carried. - 23 - [2] if P then <ref> [3] </ref> x := 11 [5] fi The one def-order dependence, [1] fi do ([6]) [4], exists because the assignments to x in lines [1] and [4] both reach the use in line [6]. In contrast, the output dependences are [1] fi o [3] and [3] fi o [4], but there is no output dependence [1] fi o [4]. The Multi-Procedure Equivalence Theorem still holds if the system dependence graph is defined to have output dependence edges rather than def-order dependences edges. <p> 23 - [2] if P then <ref> [3] </ref> x := 11 [5] fi The one def-order dependence, [1] fi do ([6]) [4], exists because the assignments to x in lines [1] and [4] both reach the use in line [6]. In contrast, the output dependences are [1] fi o [3] and [3] fi o [4], but there is no output dependence [1] fi o [4]. The Multi-Procedure Equivalence Theorem still holds if the system dependence graph is defined to have output dependence edges rather than def-order dependences edges.
Reference: 4. <author> Ferrante, J., Ottenstein, K., and Warren, J., </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Transactions on Programming Languages and Systems 9(3) pp. </journal> <month> 319-349 (July </month> <year> 1987). </year>
Reference-contexts: A control dependence edge v 1 fi c v 2 is labeled by the truth value of the branch in which v 2 always occurs. A method for determining control dependence edges for arbitrary programs is given in <ref> [4] </ref>; however, because we are assuming that programs include only assignment, conditional, call, and while statements, control dependence edges can be determined in a much simpler fashion. <p> not v 1 fi o v 2 , and vice versa: hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 8 As with flow dependences, anti-dependence and output dependence may be further characterized as loop-independent or loop-carried. - 23 - [2] if P then [3] x := 11 [5] fi The one def-order dependence, [1] fi do ([6]) <ref> [4] </ref>, exists because the assignments to x in lines [1] and [4] both reach the use in line [6]. In contrast, the output dependences are [1] fi o [3] and [3] fi o [4], but there is no output dependence [1] fi o [4]. <p> hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 8 As with flow dependences, anti-dependence and output dependence may be further characterized as loop-independent or loop-carried. - 23 - [2] if P then [3] x := 11 [5] fi The one def-order dependence, [1] fi do ([6]) <ref> [4] </ref>, exists because the assignments to x in lines [1] and [4] both reach the use in line [6]. In contrast, the output dependences are [1] fi o [3] and [3] fi o [4], but there is no output dependence [1] fi o [4]. <p> if P then [3] x := 11 [5] fi The one def-order dependence, [1] fi do ([6]) <ref> [4] </ref>, exists because the assignments to x in lines [1] and [4] both reach the use in line [6]. In contrast, the output dependences are [1] fi o [3] and [3] fi o [4], but there is no output dependence [1] fi o [4]. The Multi-Procedure Equivalence Theorem still holds if the system dependence graph is defined to have output dependence edges rather than def-order dependences edges. <p> one def-order dependence, [1] fi do ([6]) <ref> [4] </ref>, exists because the assignments to x in lines [1] and [4] both reach the use in line [6]. In contrast, the output dependences are [1] fi o [3] and [3] fi o [4], but there is no output dependence [1] fi o [4]. The Multi-Procedure Equivalence Theorem still holds if the system dependence graph is defined to have output dependence edges rather than def-order dependences edges.
Reference: 5. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <booktitle> Proceedings of the SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIGPLAN Notices 23(7) pp. </journal> <month> 35-46 (July </month> <year> 1988). </year>
Reference-contexts: is a dependence v 1 fi do v 2 but not v 1 fi o v 2 , and vice versa: hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 8 As with flow dependences, anti-dependence and output dependence may be further characterized as loop-independent or loop-carried. - 23 - [2] if P then [3] x := 11 <ref> [5] </ref> fi The one def-order dependence, [1] fi do ([6]) [4], exists because the assignments to x in lines [1] and [4] both reach the use in line [6]. <p> The program integration algorithm of [6] uses program slicing to identify sub-computations of a program. The slice of a program is defined as a reachability problem on the program's dependence graph. The system dependence graph was introduced in <ref> [5] </ref> to compute the interprocedural slice of a program. The definition of the system dependence graph used in this paper differs from the one given in [5] in that is does not include the summary edges defined in [5]. <p> The slice of a program is defined as a reachability problem on the program's dependence graph. The system dependence graph was introduced in <ref> [5] </ref> to compute the interprocedural slice of a program. The definition of the system dependence graph used in this paper differs from the one given in [5] in that is does not include the summary edges defined in [5]. <p> The system dependence graph was introduced in <ref> [5] </ref> to compute the interprocedural slice of a program. The definition of the system dependence graph used in this paper differs from the one given in [5] in that is does not include the summary edges defined in [5].
Reference: 6. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> Integrating non-interfering versions of programs, pp. </title> <booktitle> 133-145 in Conference Record of the 15th ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), </year> <booktitle> ACM, </booktitle> <address> New York (1988). </address>
Reference-contexts: 1. INTRODUCTION Dependence graph representations of programs have been used in program optimization, vectorization, and parallelization [9 13, 10 11], as the internal representation for programs in a language-based programming environment [12], and for automatic program integration <ref> [6] </ref>. The semantic equivalence of programs with isomorphic program dependence graphs was first demonstrated in [7], the main result of which was the proof of the following theorem: THEOREM. (EQUIVALENCE THEOREM). <p> and output dependence may be further characterized as loop-independent or loop-carried. - 23 - [2] if P then [3] x := 11 [5] fi The one def-order dependence, [1] fi do (<ref> [6] </ref>) [4], exists because the assignments to x in lines [1] and [4] both reach the use in line [6]. In contrast, the output dependences are [1] fi o [3] and [3] fi o [4], but there is no output dependence [1] fi o [4]. The Multi-Procedure Equivalence Theorem still holds if the system dependence graph is defined to have output dependence edges rather than def-order dependences edges. <p> The motivation for the (single procedure) Equivalence Theorem was as the semantic basis for the (single procedure) program integration algorithm of <ref> [6] </ref>. The Multi-Procedure Equivalence Theorem has a similar motivation; we intend to use the Multi-Procedure Equivalence Theorem as the first step in providing the semantic basis for a multi-procedure program integration algorithm. The program integration algorithm of [6] uses program slicing to identify sub-computations of a program. <p> was as the semantic basis for the (single procedure) program integration algorithm of <ref> [6] </ref>. The Multi-Procedure Equivalence Theorem has a similar motivation; we intend to use the Multi-Procedure Equivalence Theorem as the first step in providing the semantic basis for a multi-procedure program integration algorithm. The program integration algorithm of [6] uses program slicing to identify sub-computations of a program. The slice of a program is defined as a reachability problem on the program's dependence graph. The system dependence graph was introduced in [5] to compute the interprocedural slice of a program.
Reference: 7. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> On the adequacy of program dependence graphs for representing programs, pp. </title> <booktitle> 146-157 in Conference Record of the 15th ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), </year> <booktitle> ACM, </booktitle> <address> New York (1988). </address>
Reference-contexts: The semantic equivalence of programs with isomorphic program dependence graphs was first demonstrated in <ref> [7] </ref>, the main result of which was the proof of the following theorem: THEOREM. (EQUIVALENCE THEOREM). <p> Dayton St., Madison, WI 53706. Copyright 1989 by David Binkley, Susan Horwitz, and Thomas Reps. All rights reserved. - 2 - The language treated by Horwitz et al. contains scalar variables, assignment statements, conditional statements, and while-loops. This paper extends the Equivalence Theorem of <ref> [7] </ref> to the Multi-Procedure Equivalence Theorem, which applies to programs that include procedures and procedure calls. To distinguish between the more limited language of [7] and the language treated in this paper, we call programs with procedures and procedure calls systems. <p> This paper extends the Equivalence Theorem of <ref> [7] </ref> to the Multi-Procedure Equivalence Theorem, which applies to programs that include procedures and procedure calls. To distinguish between the more limited language of [7] and the language treated in this paper, we call programs with procedures and procedure calls systems. The graphs used to represent systems are called system dependence graphs. <p> Our principal result is the following theorem: THEOREM. (MULTI-PROCEDURE EQUIVALENCE THEOREM). If S and T are systems with isomorphic system dependence graphs then S and T are strongly equivalent. This theorem is an extension of the (single procedure) Equivalence Theorem <ref> [7] </ref>, which states that two programs (without procedures or procedure calls) that have isomorphic program dependence graphs are strongly equivalent. To prove the Multi-Procedure Equivalence Theorem we reduce the question of system-dependence-graph equivalence to that of program-dependence-graph equivalence. <p> This construction rewrites S and T into the simpler language used in <ref> [7] </ref>. The Multi-Procedure Equivalence Theorem then follows from the (single procedure) Equivalence Theorem. THEOREM. (MULTI-PROCEDURAL EQUIVALENCE THEOREM). If S and T are systems with isomorphic system dependence graphs then S and T are strongly equivalent. PROOF. The proof is by contradiction. <p> Because an abort statement has no incoming or outgoing data dependence edges, the Bodyless Expansion Corollary ensures that S and T have isomorphic system dependence graphs. The main programs of S and T include no call - 22 - statements, and have isomorphic program dependence graphs (as defined in <ref> [7] </ref>); thus, by the (single procedure) Equivalence Theorem, S and T produce the same final state when initiated on s. As noted above, S h and S are equivalent on s because S h executes no call statements when initiated on s. <p> Because s is an arbitrary initial state we conclude that programs S and T are strongly equivalent. ` 4. RELATED WORK This paper studies the relation between program semantics and the dependence graphs used as intermediate program representations. <ref> [7] </ref> began this study with the proof of the Equivalence Theorem. In this paper we have extended this semantic foundation for dependence graphs to a language that contains procedures and procedure calls. The data dependence edges used in this paper (as well as those in [7]) are somewhat non-standard. <p> used as intermediate program representations. <ref> [7] </ref> began this study with the proof of the Equivalence Theorem. In this paper we have extended this semantic foundation for dependence graphs to a language that contains procedures and procedure calls. The data dependence edges used in this paper (as well as those in [7]) are somewhat non-standard.
Reference: 8. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Transactions on Programming Languages and Systems 12(1) pp. </journal> <month> 26-60 (January </month> <year> 1990). </year>
Reference-contexts: The remainder of the paper is organized as follows. Section 2 summarizes the definition of the system dependence graph given in <ref> [8] </ref>. Section 3 states and proves the Multi-Procedure Equivalence Theorem. Section 4 discusses related work. 2. SYSTEMS AND SYSTEM DEPENDENCE GRAPHS A system consists of a main program and a set of auxiliary procedures (we assume that in a system all called procedures exist). <p> We also assume that systems contain no global variables; systems with global variables can be transformed into semantically equivalent systems without global variables by converting global variables into additional reference parameters. 2.1. The System Dependence Graph This section summarizes the definition of system dependence graphs given in <ref> [8] </ref>.
Reference: 9. <author> Kuck, D. J., Muraoka, Y., and Chen, S. C., </author> <title> On the number of operations simultaneously executable in FORTRAN-like programs and their resulting speed-up, </title> <journal> IEEE Transactions on Computers C-21, </journal> <pages> pp. </pages> <month> 1293-1310 (December </month> <year> 1972). </year>
Reference: 10. <author> Kuck, </author> <title> D.J., </title> <booktitle> The Structure of Computers and Computations, </booktitle> <volume> Vol. 1, </volume> <publisher> John Wiley and Sons, </publisher> <address> New York, NY (1978). </address>
Reference: 11. <author> Kuck, D.J., Kuhn, R.H., Leasure, B., Padua, D.A., and Wolfe, M., </author> <title> Dependence graphs and compiler optimizations, pp. </title> <booktitle> 207-218 in Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Williamsburg, VA, </address> <month> January 26-28, </month> <year> 1981), </year> <booktitle> ACM, </booktitle> <address> New York (1981). </address>
Reference: 12. <author> Ottenstein, K.J. and Ottenstein, L.M., </author> <title> The program dependence graph in a software development environment, </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> April 23-25, </month> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 177-184 (May </month> <year> 1984). </year>
Reference-contexts: 1. INTRODUCTION Dependence graph representations of programs have been used in program optimization, vectorization, and parallelization [9 13, 10 11], as the internal representation for programs in a language-based programming environment <ref> [12] </ref>, and for automatic program integration [6]. The semantic equivalence of programs with isomorphic program dependence graphs was first demonstrated in [7], the main result of which was the proof of the following theorem: THEOREM. (EQUIVALENCE THEOREM).
Reference: 13. <author> Towle, R., </author> <title> Control and data dependence for program transformations, </title> <type> TR 76-788, </type> <institution> Department of Computer Science, University of Illinois, Urbana-Champaign, </institution> <address> IL (March 1976). </address>
References-found: 13

