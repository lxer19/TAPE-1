URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/rowan/www/papers/circle.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/project/fox/mosaic/people/rowan/papers/abstracts.html
Root-URL: http://www.cs.cmu.edu
Email: rowan@cs.cmu.edu  
Title: A Temporal-Logic Approach to Binding-Time Analysis  
Author: Rowan Davies 
Address: Pittsburgh PA 15213, USA  
Affiliation: Carnegie Mellon University Computer Science Department  
Abstract: The Curry-Howard isomorphism identifies proofs with typed -calculus terms, and correspondingly identifies propositions with types. We show how this isomorphism can be extended to relate constructive temporal logic with binding-time analysis. In particular, we show how to extend the Curry-Howard isomorphism to include the fl (next) operator from linear-time temporal logic. This yields the simply typed fl -calculus which we prove to be equivalent to a multi-level binding-time analysis like those used in partial evaluation for functional programming languages. Further, we prove that normalization in fl can be done in an order corresponding to the times in the logic, which explains why fl is relevant to partial evaluation. We then extend fl to a small functional language, Mini-ML fl , and give an operational semantics for it. Finally, we prove that this operational semantics correctly reflects the binding-times in the language, a theorem which is the functional programming analog of time-ordered normalization. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Bondorf and O. Danvy. </author> <title> Automatic autoprojection of recursive equations with global variables and abstract types. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 16:151195, </address> <year> 1991. </year>
Reference-contexts: We claim that other methods for interpreting the binding-times can generally be formulated as binding-time preserving transformations in a language like Mini-ML fl . For example, the generation of specialization points in a partial evaluator like Similix (see <ref> [1] </ref> or [12]) can be expressed as adding memoizing functions to the binding-time separated program. The semantics of the binding-time analyzed program is then the composition of these binding-time preserving transformations with a semantics like the one we give.
Reference: [2] <author> V. Breazu-Tannen, T. Coquand, C. Gunter, and A. Scedrov. </author> <title> Inheritance as implicit coercion. Information and Computation, </title> <address> 93:172221, </address> <year> 1991. </year>
Reference-contexts: Some of the benefits of automatic binding-time analysis might then be regained by allowing the temporal term constructors to be implicit coercions in a system of sub-typing, in the style of Breazu-Tannen et.al. <ref> [2] </ref>, leading to a refinement type system [6] where each refinement of a type is obtained by some insertions of fl. The practicality of this idea has yet to be properly investigated. Our language Mini-ML fl includes pairs, natural numbers, and fixed-points.
Reference: [3] <author> D. Clement, J. Despeyroux, T. Despeyroux, and G. Kahn. </author> <title> A simple applicative language: </title> <booktitle> Mini-ML. In Proceedings of the 1986 Conference on LISP and Functional Programming, </booktitle> <pages> pages 1327. </pages> <publisher> ACM Press, </publisher> <year> 1986. </year> <month> 11 </month>
Reference-contexts: This justifies our claim that the core of binding-time type systems are the image of a temporal logic under the the Curry-Howard isomorphism. 4. A temporal functional language We now show how to extend fl to obtain Mini-ML fl , a small functional language in the style of <ref> [3] </ref>, which includes next, prev and fl to allow expression of binding-times. We give an operational semantics for this language, and then prove type preservation and value soundness. We also demonstrate that this operational semantics correctly reflects the binding-times.
Reference: [4] <author> O. Danvy. </author> <title> Type-directed partial evaluation. </title> <booktitle> In Proceed--ings of the 23rd Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 242257, </pages> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: we also have the following term with type (flA ! flB) ! fl (A ! B) which allows a form of lift on functions: f : fl A ! flB: next (x:A: prev (f (next x))) For more discussion on lift coercions in partial evaluation, including sum types, see Danvy <ref> [4] </ref>. As an example of a more realistic program in an extension of Standard ML with temporal operators, we show the regular expression matcher example from [5]. matcher without temporal operators.
Reference: [5] <author> R. Davies and F. Pfenning. </author> <title> A modal analysis of staged computation. </title> <booktitle> In Proceedings of the 23rd Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 258270, </pages> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: (prev (p m)))) n)) power 0 z ,! next (x:nat: s z) power 0 (s z) ,! next (x:nat: times x (s z)) power 0 (s (s z)) ,! next (x:nat: times x (times x (s z))) The first version corresponds exactly to the one given by Davies and Pfenning <ref> [5] </ref> for the functional language Mini-ML 2 based on the modal logic S4. The second avoids the variable for variable redices in the result of applying to the first argument. <p> However, note that the Mini-ML 2 has other features not supported by Mini-ML fl , namely an operator expressing immediate evaluation of code, and sharing of code between stages. As an example of this, the staged inner product example in <ref> [5] </ref> has no counterpart in Mini-ML fl . <p> The lift operator is essentially a coercion from one time to a later one. We now show how to define a function in fl with type nat ! flnat which performs this coercion, exactly following <ref> [5] </ref>: lift nat fixf :nat ! flnat: x:nat: case x of z ) next z | s x 0 ) next (s (prev (f x 0 ))) A similar term of type A ! flA that returns a next'ed copy of its argument will generally exist for each base type, and <p> As an example of a more realistic program in an extension of Standard ML with temporal operators, we show the regular expression matcher example from <ref> [5] </ref>. matcher without temporal operators. It makes use of a continuation function that is called with the remaining input 9 if the current matching succeeds. <p> The code assumes the following datatype declaration: datatype regexp = Empty | Plus of regexp * regexp | Times of regexp * regexp | Star of regexp | Const of string As in <ref> [5] </ref>, we introduce a local function definition in the case for acc (Star (r)) so that we can generate specialized code by applying to the first argument. <p> the staged program in Figure 2 with the following types (using O here to represent fl) val acc2 : regexp -&gt; O ((string list -&gt; bool) -&gt; (string list -&gt; bool)) val accept2 : regexp -&gt; O (string list -&gt; bool) This program is in fact identical to that in <ref> [5] </ref>, except that here we use ` for next and for prev. We can actually do better than this in fl , by making the continuations static, and avoiding variable for variable redices, as shown in figure 3. <p> In particular, Mini-ML fl allows programs that manipulate code with free variables, and we give an operational semantics which reflects this. This is in contrast to work by Davies and Pfenning <ref> [5] </ref> on Mini-ML 2 , a typed language based on modal logic that also expresses a form of binding-times, though only allows programs that manipulate closed code. However, the manipulation of code with free variables comes at a price. <p> In Mini-ML 2 we allow each stage to have several successor stages in order to allow more general forms of staged computation, in particular run-time code generation and sharing of code between stages (see <ref> [5] </ref> for details). This means that when constructing code in an arbitrary successor stage we cannot use variables that are bound further out in a possibly different successor stage.
Reference: [6] <author> T. Freeman and F. Pfenning. </author> <title> Refinement types for ML. </title> <booktitle> In Proceedings of the SIGPLAN '91 Symposium on Language Design and Implementation, </booktitle> <address> Toronto, Ontario, </address> <pages> pages 268 277. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: Some of the benefits of automatic binding-time analysis might then be regained by allowing the temporal term constructors to be implicit coercions in a system of sub-typing, in the style of Breazu-Tannen et.al. [2], leading to a refinement type system <ref> [6] </ref> where each refinement of a type is obtained by some insertions of fl. The practicality of this idea has yet to be properly investigated. Our language Mini-ML fl includes pairs, natural numbers, and fixed-points.
Reference: [7] <author> D. M. Gabbay and R. J. de Queiroz. </author> <title> Extending the Curry-Howard interpretation to linear, relevant and other resource logics. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 57:13191365, </volume> <year> 1992. </year>
Reference-contexts: This is similar to the systems of labelled natural deduction of Gabbay and de Queiroz <ref> [7] </ref>, which allow many different logics to be formulated including modal logics, though this is still a speculative direction for future research. We have implemented type checkers for the languages fl and m in the logic programming language Elf (see Pfenning [16]).
Reference: [8] <author> R. Gluck and J. Jrgensen. </author> <title> Efficient multi-level generating extensions for program specialization. </title> <editor> In S. Swierstra and M. Hermenegildo, editors, </editor> <booktitle> Programming Languages, Implementations, Logics and Programs (PLILP'95), volume 982 of Lecture Notes in Computer Science, </booktitle> <pages> pages 259278. </pages> <publisher> Springer-Verlag, </publisher> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: Gomard and Jones [9]). m additionally allows more than two binding times in the same way as the multi-level binding-time analysis of Gluck and Jrgensen <ref> [8] </ref>. Our formulation of m is basically the - calculus fragment of Gluck and Jrgensen's system, though it has some important differences. We use separate syntactic categories for the types of each level, thus avoiding side conditions regarding well-formedness of types. <p> The time annotations on terms indicate the time at which the or @ (application) are reduced, and the corresponding variable substituted for. See Gluck and Jrgensen <ref> [8] </ref> for a semantics of evaluation of multi-level terms in multiple stages.
Reference: [9] <author> C. Gomard and N. D. Jones. </author> <title> A partial evaluator for the un-typed lambda-calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(1):2169, </volume> <month> January </month> <year> 1991. </year>
Reference-contexts: To do this we consider m , a simply typed -calculus which is essentially the core of standard binding-time analyzes used in offline partial evaluation (see e.g. Gomard and Jones <ref> [9] </ref>). m additionally allows more than two binding times in the same way as the multi-level binding-time analysis of Gluck and Jrgensen [8]. Our formulation of m is basically the - calculus fragment of Gluck and Jrgensen's system, though it has some important differences. <p> This justifies the inclusion of the lift primitive for base types in binding-time type systems such as that of Gomard and Jones <ref> [9] </ref> and, in a more realistic version of our language, we would also include it as a primitive.
Reference: [10] <author> J. Hatcliff. </author> <title> Mechanically verifying the correctness of an offline partial evaluator. </title> <editor> In S. Swierstra and M. Hermenegildo, editors, </editor> <booktitle> Programming Languages, Implementations, Logics and Programs (PLILP'95), volume 982 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: The operational semantics allows for manipulation of expressions containing free variables, provided the variables have time greater than 0, and we thus depend on the fact that substitution avoids variable capture. The operational semantics for fl is similar to the specialization logic presented by Hatcliff <ref> [10] </ref> for a two-level binding-time language, and our binding-time correctness theorem is also somewhat similar to Hatcliff's.
Reference: [11] <author> W. A. Howard. </author> <title> The formulae-as-types notion of construction. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <year> 1980, </year> <pages> pages 479490. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year> <note> Hitherto unpublished note of 1969, rearranged, corrected, and annotated by Howard, </note> <year> 1979. </year>
Reference: [12] <author> N. D. Jones, C. K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall International Series in Computer Science. Prentice-Hall, </publisher> <year> 1993. </year>
Reference-contexts: We claim that other methods for interpreting the binding-times can generally be formulated as binding-time preserving transformations in a language like Mini-ML fl . For example, the generation of specialization points in a partial evaluator like Similix (see [1] or <ref> [12] </ref>) can be expressed as adding memoizing functions to the binding-time separated program. The semantics of the binding-time analyzed program is then the composition of these binding-time preserving transformations with a semantics like the one we give.
Reference: [13] <author> S. Martini and A. Masini. </author> <title> A computational interpretation of modal proofs. </title> <editor> In H. Wansing, editor, </editor> <title> Proof Theory of Modal Logics. </title> <publisher> Kluwer, </publisher> <year> 1996. </year> <note> To appear. </note>
Reference: [14] <author> F. Nielson and H. R. Nielson. </author> <title> Two-Level Functional Languages. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference: [15] <author> J. Palsberg. </author> <title> Correctness of binding time analysis. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(3):347363, </volume> <month> July </month> <year> 1993. </year>
Reference: [16] <author> F. Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In G. Huet and G. Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: We have implemented type checkers for the languages fl and m in the logic programming language Elf (see Pfenning <ref> [16] </ref>). Using logic programming variables, the same programs will also perform type inference. We have also implemented the translations and proof of equivalence between these languages in Elf. 6.
Reference: [17] <author> C. Stirling. </author> <title> Modal and temporal logics. </title> <editor> In S. Abramsky, D. M. Gabby, and T. S. E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> Vol. 2, chapter 5, </volume> <pages> pages 477563. </pages> <publisher> Oxford University Press, Oxford, </publisher> <year> 1992. </year>
Reference: [18] <author> M. Welinder. </author> <title> Very efficient conversions. </title> <editor> In E. T. Schubert, P. J. Windley, and J. Alves-Foss, editors, </editor> <booktitle> The 8th International Workshop on Higher Order Logic Theorem Proving and Its Applications, </booktitle> <address> Aspen Grove, Utah, </address> <booktitle> volume 971 of Lecture Notes in Computer Science, </booktitle> <pages> pages 340352. </pages> <publisher> Springer Verlag, </publisher> <month> September </month> <year> 1995. </year> <month> 12 </month>
Reference-contexts: By allowing the programmer to have direct control over binding-times in a language with a well defined semantics, we can place the responsibility of ensuring termination on the programmer. Welinder <ref> [18] </ref> has demonstrated that this style of programming, called hand-writing generating extensions, can be very fruitful.
References-found: 18

