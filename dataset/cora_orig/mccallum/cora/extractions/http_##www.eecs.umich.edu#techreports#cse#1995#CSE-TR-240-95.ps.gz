URL: http://www.eecs.umich.edu/techreports/cse/1995/CSE-TR-240-95.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse95.html
Root-URL: http://www.eecs.umich.edu
Title: Equivalence Is In The Eye Of The Beholder  
Author: Yuri Gurevich and James K. Huggins 
Abstract: This is a reaction to Lamport's "Processes are in the Eye of the Beholder." To illustrate the "insubstantiality of processes," Lamport represents a 2-process algorithm and an N -process algorithm by temporal formulas and proves the equivalence of the two formulas. We analyze in what sense the two algorithms are and are not equivalent, and give a more direct equivalence proof. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Gurevich. </author> <title> "Logic and the challenge of computer science." </title> <editor> In E. Borger, editor, </editor> <booktitle> Current Trends in Theoretical Computer Science, </booktitle> <pages> pp. 1-57, </pages> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: Which notion of equivalence is the best one? Naturally, it depends upon the application. We do not promote any particular notion of equivalence, but note that there are many reasonable definitions. There is no one definition of equivalence that is best for all situations <ref> [1] </ref>. R csp and C csp are indeed "strongly equivalent"; in particular, they are equivalent in the sense of definition 3 above. However, they are not equivalent in the sense of definition 4 for certain external observers, or in the sense of some space-complexity versions of definitions 2 and 3.
Reference: [2] <author> Y. Gurevich, </author> <title> "Logic Activities in Europe", </title> <journal> ACM SIGACT News 25, </journal> <volume> No. 2, </volume> <month> June </month> <year> 1994, </year> <pages> 11-24. </pages>
Reference-contexts: Our complete proof, with "Q.E.D." steps and low-level reasoning omitted, appears in Appendix A. We prefer to separate the process of explaining a proof to people from the process of computer-aided verification of the same proof <ref> [2] </ref>. An important benefit of this separation of concerns is that a human-oriented exposition is much easier for humans to read and understand than expositions attempting to satisfy both concerns at once.
Reference: [3] <author> Y. Gurevich, </author> <title> "Evolving Algebras 1993: Lipari Guide", in Specification and Validation Methods, </title> <editor> ed. E. Borger, </editor> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: R csp decomposes this graph into two rows, each row representing one of the processes of the algorithm. Similarly, C csp decomposes this graph into columns. Figures 4 and 5 show this decomposition. 3 Evolving Algebras We recall only as much of evolving algebra theory <ref> [3] </ref> as needed in this paper. The term evolving algebra is often abbreviated ealgebra or EA.
Reference: [4] <author> C.A.R. Hoare, </author> <title> "Communicating sequential processes." </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-667, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: To demonstrate his thesis, Lamport uses two different programs for a first-in, first-out ring buffer of size N , both written in a CSP-like language <ref> [4] </ref>. The first, shown in Figure 1, operates the buffer using 2-processes; the second, shown in Figure 2, uses N -processes. We call these two programs R csp and C csp , respectively (for reasons which shall become apparent).
Reference: [5] <author> L. Lamport, </author> <title> "How to write a proof." </title> <type> Research Report 94, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> February </month> <year> 1993. </year> <note> To appear in American Mathematical Monthly. </note>
Reference-contexts: Issue 3: The Formality of Proofs. Continuing, Lamport writes [7]: We now give a hierarchically structured proof that 2 and N [the TLA translations of R csp and C csp - GH] are equivalent <ref> [5] </ref>. The proof is completely formal, meaning that each step is a mathematical formula. English is used only to explain the low-level reasoning.
Reference: [6] <author> L. Lamport, </author> <title> "The temporal logic of actions." </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: We call these two programs R csp and C csp , respectively (for reasons which shall become apparent). After presenting the programs, Lamport represents them as formulas in TLA, the Temporal Logic of Actions <ref> [6] </ref>, and proves the equivalence of the two formulas in TLA. There are three issues where we disagree with Lamport. Issue 1: The Notion of Equivalence. What does it mean that two programs are equivalent? The answer to the question depends on which abstraction you find appropriate. <p> We do not know how to write a completely formal proof that two programming language representations of the ring buffer are equivalent. In Section 2, we represent the program formally in TLA, the Temporal Logic of Actions <ref> [6] </ref>. We believe that it is not only possible but also beneficial to prove the desired equivalence of programs directly.
Reference: [7] <author> L. Lamport, </author> <title> "Processes are in the Eye of the Beholder." </title> <type> Research Report 94, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> December </month> <year> 1994. </year> <month> 14 </month>
Reference-contexts: 1 Introduction In "Processes are in the Eye of the Beholder" <ref> [7] </ref>, Leslie Lamport writes: A concurrent algorithm is traditionally represented as the composition of processes. We show by an example that processes are an artifact of how an algorithm is represented. <p> However, they are not equivalent in the sense of definition 4 for certain external observers, or in the sense of some space-complexity versions of definitions 2 and 3. Issue 2: Representing Programs as Formulas. Again, we quote Lamport <ref> [7] </ref>: We will not attempt to give a rigorous meaning to the program text. Programming languages evolved as a method of describing algorithms to compilers, not as a method for reasoning about them. <p> We then define an appropriate notion of equivalence and show that R ea and C ea are equivalent in this sense. Issue 3: The Formality of Proofs. Continuing, Lamport writes <ref> [7] </ref>: We now give a hierarchically structured proof that 2 and N [the TLA translations of R csp and C csp - GH] are equivalent [5]. The proof is completely formal, meaning that each step is a mathematical formula. English is used only to explain the low-level reasoning.
References-found: 7

