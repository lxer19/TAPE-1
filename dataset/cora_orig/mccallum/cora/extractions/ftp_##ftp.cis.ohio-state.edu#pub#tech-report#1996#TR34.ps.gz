URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/1996/TR34.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~weide/rsrg/bib-overview.html
Root-URL: 
Email: E-Mail: edwards@cis.ohio-state.edu  
Title: Modeling Modular Software Structure for Human Understanding  
Author: Stephen H. Edwards 
Keyword: Mental model, model-based specification, interfaces, bindings, generics  
Web: URL: http://www.cis.ohio-state.edu/~edwards  
Address: 2015 Neil Avenue Columbus, Ohio 43210-1277  
Affiliation: Dept. of Computer and Information Science The Ohio State University  
Abstract: To address this problem, we have developed the Abstract and Concrete Templates and Instances (ACTI) model of modular, parameterized software subsystems. This model of software structure addresses the needs of human software engineers who must reason about collections of interacting software parts during design, maintenance, and evolution. ACTI is different from other module systems and models of software in several ways. In ACTI, a subsystem never has any implicit dependencies, and never depends directly on any external definitions|all external dependencies are described through an explicit interface. In addition, a subsystem specification is meaningful by itself, even without respect to any implementation. Finally, a subsystem is more than just a collection of types and operations; it also includes: an explicit model of behavior, an explicit model of all external dependencies, a collection of definitions used to construct and describe these models, and (potentially complex) substructure. There are strong parallels between ACTI and other research on the understanding of modularly structured physical devices, particularly Functional Representation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Meyer, </author> <title> Object-Oriented Software Construction. </title> <address> New York, NY: </address> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: considering module-structured languages like Ada or Modula-2, Bertrand Meyer writes: In such languages, the module is purely a syntactic construct, used to group logically related program elements; but it is not itself a meaningful program element, such as a type, a variable or a procedure, with its own semantic denotation. <ref> [1, p. 61] </ref> In this view, there is no way for one to make such building-blocks contribute directly to the understandability of the software comprising them. <p> For a discussion of previous efforts to effectively capture modular structuring techniques, Edwards [2] presents a thorough comparison of several programming languages that are representative of best current practices: RESOLVE [8, 9], OBJ [10], Standard ML [11], and Eiffel <ref> [1] </ref>. As typical of current efforts, most of these languages inadequately support the formation or maintenance of effective mental models of software parts. The complete analysis, including a detailed check list of software structuring and composition properties supported by these languages, is available electronically [2].
Reference: [2] <author> S. Edwards, </author> <title> A Formal Model of Software Subsystems. </title> <type> PhD thesis, </type> <institution> Dept. of Computer and Information Science, The Ohio State University, Columbus, OH, </institution> <year> 1995. </year> <note> Also available as technical report OSU-CISRC-4/95-TR14, by anonymous FTP from ftp://ftp.cis.ohio-state.edu/pub/tech-report/1995/TR14-DIR, </note> <institution> or through the author's home page. </institution>
Reference-contexts: It is also very effective when it comes to describing the semantics of layered programming constructs. Unfortunately, it is at odds with the way human beings form mental representations of the meanings of software parts <ref> [2] </ref>. The result of these two features of existing programming languages is that they are inadequate for effectively communicating the meaning of a software building-block to people (programmers, in particular). The semantic denotations of programming constructs in current languages only relate to how a program operates. <p> Next, Section 3 highlights the unique and novel features of the model. Section 4 then outlines how ACTI provides support for software understanding. Relationships to previous work, particularly AI-based work on the understanding of physical devices, is discussed in Section 5. 2 An Overview of ACTI The ACTI model <ref> [2] </ref> is centered around the notion of a "software subsystem," a generalization of the idea of a module or a class that serves as the building-block from which software is constructed. A subsystem can vary in grain size from a single module up to a large scale generic architecture. <p> It is rich enough to be used as the denotational semantic modeling space when designing new languages, and has been shown to subsume the run-time semantic spaces of several existing languages chosen to be representative of the modern imperative, OO, and functional philosophies <ref> [2] </ref>. ACTI has two features that specifically address the inadequacies described in the introduction: 1. In ACTI, a software subsystem (building-block) has an intrinsic meaning; it is not just a syntactic construct used for grouping declarations and controlling visibility. <p> All of these components have values taken from some complete partial order (CPO) space defined in the ACTI model. In addition to providing a behavioral model of all exported features, ACTI includes complete behavioral descriptions of all imported features <ref> [2] </ref>. The Context section shown in Figure 1 is actually one (nested, possibly empty) abstract instance that is used to completely define all of the external dependencies of the main instance shown in the figure. <p> Finally, in ACTI all entities can be parameterized. Implementations can be parameterized independently of specifications, and interpretation mappings can be parameterized independently of the subsystems they relate. Examples of the utility of this flexibility are surprisingly plentiful <ref> [2] </ref>. 4 Support For Software Understand ing It is well-accepted that people form mental models|internal representations of external artifacts|for devices and other bits of technology with which they interact [6, p. 241]. <p> For a discussion of previous efforts to effectively capture modular structuring techniques, Edwards <ref> [2] </ref> presents a thorough comparison of several programming languages that are representative of best current practices: RESOLVE [8, 9], OBJ [10], Standard ML [11], and Eiffel [1]. As typical of current efforts, most of these languages inadequately support the formation or maintenance of effective mental models of software parts. <p> As typical of current efforts, most of these languages inadequately support the formation or maintenance of effective mental models of software parts. The complete analysis, including a detailed check list of software structuring and composition properties supported by these languages, is available electronically <ref> [2] </ref>. Other efforts to provide better support for mental models have concentrated primarily on adding (possibly structured) comments to component specifications, the inadequacy of which is explained in [12]. Interestingly, there are other areas of computer science where similar work has been and is being car ried out.
Reference: [3] <author> W. F. Ogden, M. Sitaraman, B. W. Weide, and S. H. </author> <title> Zweben, "The RESOLVE framework and discipline|a research synopsis," </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> vol. 19, </volume> <pages> pp. 23-28, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: Concrete Template|A subsystem-to-subsystem function that, when applied to its argument, which is some concrete instance, will generate another concrete instance. Thus, a concrete template is a form of generic subsystem imple mentation. The terms used for this classification are all based on the work of Weide et al. <ref> [3, p. 23] </ref>, and the same ideas appear in the 3C model [4]. The name "ACTI" is an acronym derived from these four terms: "Abstract and Concrete Templates and Instances." This view of the world allows software subsystems to be partitioned along two orthogonal dimensions, as shown in Table 1.
Reference: [4] <author> W. Tracz, </author> <title> "Implementation working group summary," in Reuse in Practice Workshop Summary (J. </title> <editor> Baldo, Jr., ed.), </editor> <address> (Alexandria, VA), </address> <pages> pp. 10-19, </pages> <institution> IDA Document D-754, Institute for Defense Analyses, </institution> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: Thus, a concrete template is a form of generic subsystem imple mentation. The terms used for this classification are all based on the work of Weide et al. [3, p. 23], and the same ideas appear in the 3C model <ref> [4] </ref>. The name "ACTI" is an acronym derived from these four terms: "Abstract and Concrete Templates and Instances." This view of the world allows software subsystems to be partitioned along two orthogonal dimensions, as shown in Table 1.
Reference: [5] <author> E. Robinson, </author> <title> "Logical aspects of denotational semantics," </title> <booktitle> in Category Theory and Computer Science (D. </booktitle> <editor> H. Pitt, A. Poigne, and D. E. Rydeheard, eds.), </editor> <volume> vol. </volume> <booktitle> 283 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 238-253, </pages> <address> New York, NY: </address> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: given a semantics as an element of some abstract mathematical object, generally a partially ordered set, the semantics of the program being a function of the semantics of its constituent parts; properties of the program are then deduced from a study of the mathematical object in which the semantics lives. <ref> [5, p. 238] </ref> ACTI is not a programming language, however. Instead, it is a mathematical model that is useful for programming language designers, or researchers studying the semantics of programming languages. It is a formal, theoretical model of the structure and meaning of software subsystems.
Reference: [6] <author> D. A. Norman, </author> <title> "Some observations on mental models," in Readings In Human-Computer Interaction: A Multidisciplinary Approach (R. </title> <editor> M. Baecker and W. A. S. Buxton, </editor> <booktitle> eds.), </booktitle> <pages> pp. 241-244, </pages> <address> San Mateo, CA: </address> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1987. </year>
Reference-contexts: Examples of the utility of this flexibility are surprisingly plentiful [2]. 4 Support For Software Understand ing It is well-accepted that people form mental models|internal representations of external artifacts|for devices and other bits of technology with which they interact <ref> [6, p. 241] </ref>. From psychology, we understand that people do this naturally, and that such models help individuals in two ways [6, p. 241]: 1. A mental model allows one to predict the behavior of the person or thing with which the interaction takes place. 2. <p> [2]. 4 Support For Software Understand ing It is well-accepted that people form mental models|internal representations of external artifacts|for devices and other bits of technology with which they interact <ref> [6, p. 241] </ref>. From psychology, we understand that people do this naturally, and that such models help individuals in two ways [6, p. 241]: 1. A mental model allows one to predict the behavior of the person or thing with which the interaction takes place. 2. A mental model allows one to explain why the behavior arises. <p> Here, we are concerned with a "programmer-user's" interactions with a software subsystem, rather than with an end-user's interactions with a complete application. Following Norman's terminology <ref> [6] </ref>, target system will be used to refer to the component subsystem with which a person is interacting. The system image is the entire visible "programmer interface" to the software component seen by a (nother) software professional. <p> It may include a system specification, complete source code, manuals and instructions accompanying the software, and even the way the software behaves and responds under operating conditions. Mental models evolve naturally through interaction with the target system <ref> [6, p. 241] </ref>. Over time, people reformulate, modify, and adapt their mental models whenever these models fail to provide reasonable predictive or explanatory power. For most purposes, the models need not be completely accurate, and usually they are not, but they must be functional. <p> For most purposes, the models need not be completely accurate, and usually they are not, but they must be functional. Norman documents the following general observations about mental models <ref> [6, p. 241] </ref>: 1. Mental models are incomplete. 2. People's abilities to simulate or mentally execute their models are severely limited. 3. <p> These observations indicate that mental models are inherently limited. These limitations stem from human cognitive limitations, a person's previous experiences with similar systems, and even misleading system images <ref> [6, p. 241] </ref>. As Norman points out: In making things visible [in the system image], it is important to make the correct things visible. <p> key role. [7, p. 198] Given this information, how can one support the formation and maintenance of effective mental models for complex software systems? Norman points out 8 that the designer of a software subsystem already has a conceptual model of the system that is (presumably) accurate, consistent, and complete <ref> [6, p. 241] </ref>[7, pp. 189-190]. The goal, in the best of all possible worlds, is to ensure that the system image is completely consistent with the conceptual model of the designer, and that from this system image the user forms a mental model consistent with the designer's conceptual model.
Reference: [7] <author> D. A. Norman, </author> <title> The Design of Everyday Things. </title> <address> New York, NY: Doubleday/Currency, </address> <year> 1990. </year>
Reference-contexts: It is the designer's task to make sure that they form the correct interpretations, the correct mental models: the system image plays the key role. <ref> [7, p. 198] </ref> Given this information, how can one support the formation and maintenance of effective mental models for complex software systems? Norman points out 8 that the designer of a software subsystem already has a conceptual model of the system that is (presumably) accurate, consistent, and complete [6, p. 241][7,
Reference: [8] <author> M. Sitaraman and B. W. Weide, </author> <title> editors, "Special feature: Component-based software using RESOLVE," </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> vol. 19, </volume> <pages> pp. 21-67, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: For a discussion of previous efforts to effectively capture modular structuring techniques, Edwards [2] presents a thorough comparison of several programming languages that are representative of best current practices: RESOLVE <ref> [8, 9] </ref>, OBJ [10], Standard ML [11], and Eiffel [1]. As typical of current efforts, most of these languages inadequately support the formation or maintenance of effective mental models of software parts.
Reference: [9] <author> B. W. Weide, W. F. Ogden, and S. H. </author> <title> Zweben, "Reusable software components," </title> <booktitle> in Advances in Computers (M. </booktitle> <editor> C. Yovits, ed.), </editor> <volume> vol. 33, </volume> <pages> pp. 1-65, </pages> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: For a discussion of previous efforts to effectively capture modular structuring techniques, Edwards [2] presents a thorough comparison of several programming languages that are representative of best current practices: RESOLVE <ref> [8, 9] </ref>, OBJ [10], Standard ML [11], and Eiffel [1]. As typical of current efforts, most of these languages inadequately support the formation or maintenance of effective mental models of software parts.
Reference: [10] <author> J. A. Goguen, </author> <title> "Principles of parameterized programming," in Software Reusability, Volume I: Concepts and Models (T. </title> <editor> J. Biggerstaff and A. J. Perlis, </editor> <booktitle> eds.), </booktitle> <pages> pp. 159-225, </pages> <address> New York, NY: </address> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: For a discussion of previous efforts to effectively capture modular structuring techniques, Edwards [2] presents a thorough comparison of several programming languages that are representative of best current practices: RESOLVE [8, 9], OBJ <ref> [10] </ref>, Standard ML [11], and Eiffel [1]. As typical of current efforts, most of these languages inadequately support the formation or maintenance of effective mental models of software parts.
Reference: [11] <author> R. Milner, M. Tofte, and R. Harper, </author> <title> The Definition of Standard ML. </title> <address> Cambridge, MA: </address> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: For a discussion of previous efforts to effectively capture modular structuring techniques, Edwards [2] presents a thorough comparison of several programming languages that are representative of best current practices: RESOLVE [8, 9], OBJ [10], Standard ML <ref> [11] </ref>, and Eiffel [1]. As typical of current efforts, most of these languages inadequately support the formation or maintenance of effective mental models of software parts. The complete analysis, including a detailed check list of software structuring and composition properties supported by these languages, is available electronically [2].
Reference: [12] <author> S. H. Edwards, </author> <title> "Good mental models are necessary for understandable software," </title> <booktitle> in Proceedings of the Seventh Annual Workshop on Software Reuse (L. </booktitle> <editor> Latour, ed.), </editor> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: The complete analysis, including a detailed check list of software structuring and composition properties supported by these languages, is available electronically [2]. Other efforts to provide better support for mental models have concentrated primarily on adding (possibly structured) comments to component specifications, the inadequacy of which is explained in <ref> [12] </ref>. Interestingly, there are other areas of computer science where similar work has been and is being car ried out. Current work on Functional Representation [13, 14, 15, 16] (FR) is closely related.
Reference: [13] <author> B. Chandrasekaran, </author> <title> "Functional representation and causal processes," </title> <booktitle> in Advances in Computers (M. </booktitle> <editor> C. Yovits, ed.), </editor> <volume> vol. 38, </volume> <pages> pp. 73-143, </pages> <publisher> Academic Press, </publisher> <year> 1994. </year>
Reference-contexts: Interestingly, there are other areas of computer science where similar work has been and is being car ried out. Current work on Functional Representation <ref> [13, 14, 15, 16] </ref> (FR) is closely related. FR grew out of artificial intelligence work on reasoning about physical systems, partly motivated by diagnostic and design problem solving.
Reference: [14] <author> Y. Iwasaki, R. Fikes, M. Vescovi, and B. Chan-drasekaran, </author> <title> "How things are intended to work: Capturing functional knowledge in device design," </title> <booktitle> in Proceedings of the 13th International Joint Conference on Artificial Intelligence, </booktitle> <pages> pp. 1516-1522, </pages> <publisher> Morgan KAufmann, </publisher> <year> 1993. </year>
Reference-contexts: Interestingly, there are other areas of computer science where similar work has been and is being car ried out. Current work on Functional Representation <ref> [13, 14, 15, 16] </ref> (FR) is closely related. FR grew out of artificial intelligence work on reasoning about physical systems, partly motivated by diagnostic and design problem solving.
Reference: [15] <author> M. Vescovi, Y. Iwasaki, R. Fikes, and B. Chan-drasekaran, "CFRL: </author> <title> A language for specifying the causal functionality of engineered devices," </title> <booktitle> in Eleventh National Conference on AI, </booktitle> <pages> pp. 626-633, </pages> <publisher> AAAI Press/MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Interestingly, there are other areas of computer science where similar work has been and is being car ried out. Current work on Functional Representation <ref> [13, 14, 15, 16] </ref> (FR) is closely related. FR grew out of artificial intelligence work on reasoning about physical systems, partly motivated by diagnostic and design problem solving.
Reference: [16] <author> Y. Iwasaki and B. Chandrasekaran, </author> <title> "Design verification through function- and behavior-oriented representation," </title> <booktitle> in Artificial Intelligence in Design '92 (J. </booktitle> <editor> S. Gero, </editor> <publisher> ed.), </publisher> <pages> pp. 597-616, </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1992. </year>
Reference-contexts: Interestingly, there are other areas of computer science where similar work has been and is being car ried out. Current work on Functional Representation <ref> [13, 14, 15, 16] </ref> (FR) is closely related. FR grew out of artificial intelligence work on reasoning about physical systems, partly motivated by diagnostic and design problem solving.
Reference: [17] <author> B. Chandrasekaran, </author> <title> "An explication of function." </title> <institution> The Ohio State University, Laboratory for AI Research, </institution> <note> draft, 1996. Also available electronically from http://www.cis.ohio-state.edu/~chandra. </note>
Reference-contexts: More recently, B. Chandrasekaran has documented an ontological framework within which the notion of "function" can be explained, and which provides a unified technical vision underlying the various approaches to device understanding <ref> [17] </ref>. This more general framework has allowed Chan-drasekaran to present FR as a general theory of comprehension, along with a specific language that serves as a corresponding representation mechanism [17]. <p> the notion of "function" can be explained, and which provides a unified technical vision underlying the various approaches to device understanding <ref> [17] </ref>. This more general framework has allowed Chan-drasekaran to present FR as a general theory of comprehension, along with a specific language that serves as a corresponding representation mechanism [17].
Reference: [18] <author> D. Allemang, </author> <title> "Using functional models in automatic debugging," </title> <journal> IEEE Expert, </journal> <volume> vol. 6, </volume> <pages> pp. 13-18, </pages> <year> 1991. </year>
Reference-contexts: Earlier FR work has even been applied to software for diagnostic and explanation purposes <ref> [18, 19] </ref>. To date, this has been at the "programming-in-the-small" level of individual statements and their interactions, while ACTI addresses "programming-in-the-large" issues of subsystem meaning and composition.
Reference: [19] <author> B. Liver and D. T. Allemang, </author> <title> "A functional representation for software reuse and design," </title> <journal> International Journal of Software Engineering and Knowledge Engineering, </journal> <volume> vol. 5, </volume> <pages> pp. 227-269, </pages> <year> 1995. </year>
Reference-contexts: Earlier FR work has even been applied to software for diagnostic and explanation purposes <ref> [18, 19] </ref>. To date, this has been at the "programming-in-the-small" level of individual statements and their interactions, while ACTI addresses "programming-in-the-large" issues of subsystem meaning and composition.
References-found: 19

