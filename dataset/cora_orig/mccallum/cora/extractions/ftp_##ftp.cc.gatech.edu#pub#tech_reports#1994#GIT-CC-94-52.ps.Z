URL: ftp://ftp.cc.gatech.edu/pub/tech_reports/1994/GIT-CC-94-52.ps.Z
Refering-URL: http://www.cs.gatech.edu/computing/Architecture/Beehive/index.html
Root-URL: 
Email: e-mail: fgautam, rama, fujimotog@cc.gatech.edu  
Title: Timepatch: A Novel Technique for the Parallel Simulation of Multiprocessor Caches  
Author: Gautam Shah Umakishore Ramachandran Richard Fujimoto 
Keyword: Key Words: Parallel simulation, performance evaluation, cache consistency, execution-driven simulation, shared memory multiprocessors, performance debugging.  
Date: DEC.  
Note: This work has been funded in part by NSF PYI award MIPS-9058430 and a matching equipment grant from  
Address: Atlanta, GA 30332-0280 USA  
Affiliation: College of Computing Georgia Institute of Technology  
Pubnum: Technical Report GIT-CC-94-52  
Abstract: We present a new technique for the parallel simulation of cache coherent shared memory multiprocessors. Our technique is based on the fact that the functional correctness of the simulation can be decoupled from its timing correctness. Thus in our simulations we can exploit as much parallelism as is available in the application without being constrained by conservative scheduling mechanisms that might limit the available parallelism in order to guarantee the timing correctness of the simulation. Further, application specific details (which can be gleaned from the compiler) such as data layout in the caches of the target architecture can be exploited to reduce the overhead of the simulation. The simulation correctness is guaranteed by patching the performance related timing information at specific points in the program (commensurate with the programming model). There are two principal advantages to this technique: being able to simulate larger parallel systems (both problem size and number of processors) than is feasible to simulate sequentially; and being able to speed up the simulation compared to a sequential simulator. For proof of concept, we have implemented this technique for an execution-driven parallel simulator on the KSR-2, a cache-coherent shared memory machine, for a target architecture that uses an invalidation-based protocol. We validate the performance statistics gathered from this simulator (using traces) by comparing it against a sequential simulator. We show that the method is both viable and promises to offer significant speedups with the number of processors. We provide a detailed performance study of our technique using some benchmark application programs. 
Abstract-found: 1
Intro-found: 1
Reference: [AB86] <author> J. Archibald and J. L. Baer. </author> <title> Cache coherence protocols: Evaluation using a multiprocessor simulation model. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 4(4) </volume> <pages> 273-98, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Lastly, the traces usually do not capture OS related activities (such as interrupts, context switches, and I/O) unless hardware instrumentation is available [SA88]. Many synthetic workload models have been proposed that could avoid the problems associated with traces <ref> [AB86, Pop90] </ref>. Since application characteristics vary widely, it is difficult to generate a synthetic workload model that is representative of the memory access pattern across a wide range of applications. The drawbacks with both trace-driven and probabilistic simulation can be overcome with an execution-driven simulator.
Reference: [ASHH88] <author> A. Agarwal, R. Simoni, J. Hennessy, and M. Horowitz. </author> <title> An evaluation of directory schemes for cache coherence. </title> <booktitle> In 15th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 280-9, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Thus cache simulations play a very important role in the design cycle of building shared memory multiprocessors by aiding the choice of appropriate parameter values for a specific cache protocol and estimating the performance of the system. Various simulation techniques including trace-driven <ref> [EK88, ASHH88] </ref>, and execution-driven [Fuj83, CMM + 88, DGH91] methods have been used for this purpose. Most of the known approaches to cache simulation are sequential. Such simulations impose a heavy burden on system resources both in terms of space and time.
Reference: [BDCW91] <author> Eric A. Brewer, Chrysanthos N. Dellarocas, Adrian Colbrook, and William E. Weihl. PROTEUS: </author> <title> A high-performance parallel-architecture simulator. </title> <type> Technical Report MIT/LCS/TR-516, </type> <institution> Mas-sachusetts Institute of Technology, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: In our case, the events of interest include loads, stores and synchronization. This technique of trapping only on "interesting" events saves considerable simulation time and has been used by others <ref> [DGH91, BDCW91, CMM + 88] </ref>. This method, often referred to as "program augmentation", is certainly less expensive than execution-driven simulations in which every instruction is interpreted [Lig92]. An inherent assumption with this method is that instruction fetches do not affect the caching behavior of memory hierarchy.
Reference: [Bit89] <author> Philip Bitar. </author> <title> A critique of trace-driven simulation for shared-memory multiprocessors. </title> <booktitle> In 16th ISCA Workshop Presentation, </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: There are drawbacks to both of these approaches. Trace-driven simulation has some validity concerns as observed by several researchers <ref> [FH92, GH93, Bit89] </ref> due to the distortions that may be introduced due to the instrumentation code that is inserted for collecting the traces.
Reference: [CKP + 93] <author> D. Culler, R. Karp, D. Patterson, A. Sahay, K. E. Schauser, E. Santos, R. Subramonian, and T. v. Eicken. </author> <title> Logp: towards a realistic model of parallel computation. </title> <booktitle> In Fourth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 1-12, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: In [SSRV94], it was reported that the contention overheads observed in several applications were quite small. Recent studies <ref> [CKP + 93] </ref> have also shown that parameterized models of the network may be adequate from the point of view of developing performance-conscious parallel programs.
Reference: [CM79] <author> K. M. Chandy and J. Misra. </author> <title> Distributed simulation: A case study in design and verification of distributed programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5(5):440-452, </volume> <month> September </month> <year> 1979. </year>
Reference-contexts: Typically these techniques fall into two categories conservative and optimistic. In conservative techniques two parallel units of work can be scheduled at the same time if and only if one is guaranteed not to affect the execution of the other <ref> [Fuj90, CM79] </ref>. From the point of view of simulating cache-coherent multiprocessors, such a restriction invariably inhibits the simulation from being able to exploit the available parallelism in the application. <p> Thus the parallelism is limited to the number of events that fall within this window of size t. Further, deadlocks are a potential problem with some conservative algorithms <ref> [CM79] </ref>. In the optimistic approach [Jef85], events are processed as soon as they are generated, as though they are independent of others. Such optimism might result in incorrectness in simulating the actual behavior of the application.
Reference: [CMM + 88] <author> R. C. Covington, S. Madala, V. Mehta, J. R. Jump, and J. B. Sinclair. </author> <title> The Rice parallel processing testbed. </title> <journal> Performance Evaluation Review, </journal> <volume> 16(1) </volume> <pages> 4-11, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Thus cache simulations play a very important role in the design cycle of building shared memory multiprocessors by aiding the choice of appropriate parameter values for a specific cache protocol and estimating the performance of the system. Various simulation techniques including trace-driven [EK88, ASHH88], and execution-driven <ref> [Fuj83, CMM + 88, DGH91] </ref> methods have been used for this purpose. Most of the known approaches to cache simulation are sequential. Such simulations impose a heavy burden on system resources both in terms of space and time. <p> In our case, the events of interest include loads, stores and synchronization. This technique of trapping only on "interesting" events saves considerable simulation time and has been used by others <ref> [DGH91, BDCW91, CMM + 88] </ref>. This method, often referred to as "program augmentation", is certainly less expensive than execution-driven simulations in which every instruction is interpreted [Lig92]. An inherent assumption with this method is that instruction fetches do not affect the caching behavior of memory hierarchy.
Reference: [DGH91] <author> Helen Davis, Stephen R. Goldschmidt, and John Hennessy. </author> <title> Multiprocessor simulation and tracing using TANGO. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <pages> pages II-99-107, </pages> <year> 1991. </year>
Reference-contexts: Thus cache simulations play a very important role in the design cycle of building shared memory multiprocessors by aiding the choice of appropriate parameter values for a specific cache protocol and estimating the performance of the system. Various simulation techniques including trace-driven [EK88, ASHH88], and execution-driven <ref> [Fuj83, CMM + 88, DGH91] </ref> methods have been used for this purpose. Most of the known approaches to cache simulation are sequential. Such simulations impose a heavy burden on system resources both in terms of space and time. <p> In our case, the events of interest include loads, stores and synchronization. This technique of trapping only on "interesting" events saves considerable simulation time and has been used by others <ref> [DGH91, BDCW91, CMM + 88] </ref>. This method, often referred to as "program augmentation", is certainly less expensive than execution-driven simulations in which every instruction is interpreted [Lig92]. An inherent assumption with this method is that instruction fetches do not affect the caching behavior of memory hierarchy.
Reference: [DHN94] <author> P. M. Dickens, P. Heidelberger, and D. Nicol. </author> <title> A distributed memory LAPSE: Parallel simulation of message passing programs. </title> <booktitle> In 8th Workshop on Parallel and Distributed Simulation, </booktitle> <pages> pages 32-38, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: In [HS90], it is also shown that it is sufficient to execute the traces for a set of cache lines instead of the entire cache. An implementation of a parallel trace-driven simulation on a MasPar is discussed in [NGLR92], which offers extensions to the above approach. Dickens et al. <ref> [DHN94] </ref> suggest a technique for parallel simulation of message-passing programs. Their objective is to simulate the performance of these programs on a larger configuration of a target machine on a smaller host machine.
Reference: [EK88] <author> S. J. Eggers and R. H. Katz. </author> <title> A characterization of sharing in parallel programs and its application to coherency protocol evaluation. </title> <booktitle> In 15th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 373-82, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Thus cache simulations play a very important role in the design cycle of building shared memory multiprocessors by aiding the choice of appropriate parameter values for a specific cache protocol and estimating the performance of the system. Various simulation techniques including trace-driven <ref> [EK88, ASHH88] </ref>, and execution-driven [Fuj83, CMM + 88, DGH91] methods have been used for this purpose. Most of the known approaches to cache simulation are sequential. Such simulations impose a heavy burden on system resources both in terms of space and time.
Reference: [FH92] <author> Richard M. Fujimoto and William C. Hare. </author> <title> On the accuracy of multiprocessor tracing techniques. </title> <type> Technical Report GIT-CC-92-53, </type> <institution> Georgia Institute of Technology, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: There are drawbacks to both of these approaches. Trace-driven simulation has some validity concerns as observed by several researchers <ref> [FH92, GH93, Bit89] </ref> due to the distortions that may be introduced due to the instrumentation code that is inserted for collecting the traces.
Reference: [Fuj83] <author> R. M. Fujimoto. Simon: </author> <title> A simulator of multicomputer networks. </title> <type> Technical Report UCB/CSD 83/137, </type> <institution> ERL, University of California, Berkeley, </institution> <year> 1983. </year>
Reference-contexts: Thus cache simulations play a very important role in the design cycle of building shared memory multiprocessors by aiding the choice of appropriate parameter values for a specific cache protocol and estimating the performance of the system. Various simulation techniques including trace-driven [EK88, ASHH88], and execution-driven <ref> [Fuj83, CMM + 88, DGH91] </ref> methods have been used for this purpose. Most of the known approaches to cache simulation are sequential. Such simulations impose a heavy burden on system resources both in terms of space and time.
Reference: [Fuj90] <author> Richard M. Fujimoto. </author> <title> Parallel discrete event simulation. </title> <journal> Communications of the ACM, </journal> <volume> 33(10) </volume> <pages> 30-53, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Typically these techniques fall into two categories conservative and optimistic. In conservative techniques two parallel units of work can be scheduled at the same time if and only if one is guaranteed not to affect the execution of the other <ref> [Fuj90, CM79] </ref>. From the point of view of simulating cache-coherent multiprocessors, such a restriction invariably inhibits the simulation from being able to exploit the available parallelism in the application.
Reference: [GH93] <author> S. R. Goldschmidt and J. L. Hennessy. </author> <title> The accuracy of trace-drive simulations of multiprocessors. </title> <booktitle> In ACM Sigmetrics Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 146-57, </pages> <month> June </month> <year> 1993. </year> <month> 23 </month>
Reference-contexts: There are drawbacks to both of these approaches. Trace-driven simulation has some validity concerns as observed by several researchers <ref> [FH92, GH93, Bit89] </ref> due to the distortions that may be introduced due to the instrumentation code that is inserted for collecting the traces. <p> Since the execution path of a parallel program depends on the ordering of the events in the program, both these distortions have the potential of completely changing the execution path unless timing dependencies are carefully eliminated from the traces <ref> [GH93] </ref>. Program startup effects may also distort the results, especially if the trace length is not long. Further, the traces obtained from 3 one machine may not represent true interactions in another machine.
Reference: [HS90] <author> Philip Heidelberger and Harold S. Stone. </author> <title> Parallel trace-driven cache simulation by time parti-tioning. </title> <booktitle> In Winter Simulation Conference, </booktitle> <pages> pages 734-737, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: This state saving could be a considerable overhead in simulating the cache behavior of shared memory parallel systems, though incremental state saving may alleviate this problem somewhat. A parallel cache simulation scheme, based on a time-parallel simulation technique, using program traces has been proposed by Heidelberger and Stone <ref> [HS90] </ref>. A portion of the program trace is allocated to each processor. In this scheme, each processor assumes an initial state, and simulates its portion of the trace independent of the other processors. The statistics computed by each processor could be wrong due to an incorrect initial state. <p> The time-partitioning method is a fairly promising technique since typically there is just one repetition in a cache simulation because of the locality of references. However, it has the usual problem associated with trace-driven methods. In <ref> [HS90] </ref>, it is also shown that it is sufficient to execute the traces for a set of cache lines instead of the entire cache. An implementation of a parallel trace-driven simulation on a MasPar is discussed in [NGLR92], which offers extensions to the above approach.
Reference: [Jef85] <author> D. R. Jefferson. </author> <title> Virtual time. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(3) </volume> <pages> 404-425, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: From the point of view of simulating cache-coherent multiprocessors, such a restriction invariably inhibits the simulation from being able to exploit the available parallelism in the application. On the other hand, optimistic scheduling techniques such as Time Warp <ref> [Jef85] </ref> have not been used for simulating shared memory systems because a naive application of this technique could result in considerable state saving overhead that may dominate the execution. <p> Thus the parallelism is limited to the number of events that fall within this window of size t. Further, deadlocks are a potential problem with some conservative algorithms [CM79]. In the optimistic approach <ref> [Jef85] </ref>, events are processed as soon as they are generated, as though they are independent of others. Such optimism might result in incorrectness in simulating the actual behavior of the application.
Reference: [LH89] <author> Kai Li and Paul Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: The Wisconsin Wind Tunnel [RHL + 92] uses a direct execution approach to simulate a shared memory multiprocessor on a message-passing machine. Using a portion of the memory at each node of CM-5 as a cache, WWT simulates a fine-grained version of shared virtual memory <ref> [LH89] </ref> through the ECC bits of the CM-5 memory system. The use of ECC bits allows WWT to avoid trapping on each memory operation compared to other execution-driven simulators.
Reference: [Lig92] <author> Walt B. Ligon. </author> <title> An empirical analysis of Reconfigurable Architectures. </title> <type> PhD thesis, </type> <institution> Georgia Institute of Technology, </institution> <month> August </month> <year> 1992. </year>
Reference-contexts: This technique of trapping only on "interesting" events saves considerable simulation time and has been used by others [DGH91, BDCW91, CMM + 88]. This method, often referred to as "program augmentation", is certainly less expensive than execution-driven simulations in which every instruction is interpreted <ref> [Lig92] </ref>. An inherent assumption with this method is that instruction fetches do not affect the caching behavior of memory hierarchy. In spite of program augmentation, it may be infeasible (both in terms of space and time) to simulate large system and problem sizes with sequential simulation.
Reference: [NGLR92] <author> David M. Nicol, Albert G. Greenberg, Boris D. Lubachevsky, and Subhas Roy. </author> <title> Massively parallel algorithms for trace-driven cache simulation. </title> <booktitle> In 6th Workshop on Parallel and Distributed Simulation, </booktitle> <pages> pages 3-11, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: However, it has the usual problem associated with trace-driven methods. In [HS90], it is also shown that it is sufficient to execute the traces for a set of cache lines instead of the entire cache. An implementation of a parallel trace-driven simulation on a MasPar is discussed in <ref> [NGLR92] </ref>, which offers extensions to the above approach. Dickens et al. [DHN94] suggest a technique for parallel simulation of message-passing programs. Their objective is to simulate the performance of these programs on a larger configuration of a target machine on a smaller host machine.
Reference: [Pop90] <author> D. A. Poplawski. </author> <title> Synthetic models of distributed memory parallel programs. </title> <type> Technical Report ORNL/TM-11634, </type> <institution> Michigan Technological University, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: Lastly, the traces usually do not capture OS related activities (such as interrupts, context switches, and I/O) unless hardware instrumentation is available [SA88]. Many synthetic workload models have been proposed that could avoid the problems associated with traces <ref> [AB86, Pop90] </ref>. Since application characteristics vary widely, it is difficult to generate a synthetic workload model that is representative of the memory access pattern across a wide range of applications. The drawbacks with both trace-driven and probabilistic simulation can be overcome with an execution-driven simulator.
Reference: [Res92] <institution> Kendall Square Research. Technical summary, </institution> <year> 1992. </year>
Reference-contexts: The host machine is KSR-2 <ref> [Res92] </ref>. KSR-2 is a COMA machine with a sequentially consistent memory model implemented using an invalidation-based cache coherence protocol. The interconnection network is a hierarchy of rings with 32 processors in the lowest level ring as shown in Figure 2.
Reference: [RHL + 92] <author> Steven K. Reinhardt, Mark D. Hill, James R. Larus, Alvin R. Lebeck, James C. Lewis, and David A. Wood. </author> <title> The Wisconsin Wind Tunnel: Virtual prototyping of parallel computers. </title> <type> Technical report, </type> <institution> University of Wisconsin-Madison, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: Therefore, we explore methods of parallelizing the simulator in this research. Synchronization of parallel simulators are often characterized as being conservative or optimistic. For example, in the conservative approach employed in the Wisconsin Wind Tunnel <ref> [RHL + 92] </ref>, only events that will not be causally affected by another event are processed in parallel. <p> Dickens et al. [DHN94] suggest a technique for parallel simulation of message-passing programs. Their objective is to simulate the performance of these programs on a larger configuration of a target machine on a smaller host machine. The Wisconsin Wind Tunnel <ref> [RHL + 92] </ref> uses a direct execution approach to simulate a shared memory multiprocessor on a message-passing machine.
Reference: [RSRM93] <author> U. Ramachandran, G. Shah, S. Ravikumar, and J. Muthukumarasamy. </author> <title> Scalability study of the ksr-1. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <pages> pages I-237-240, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: For example, experimental results on a state-of-the-art machine such as the KSR-2 have shown that the latencies for remote accesses do not vary significantly for a wide variety of network loads <ref> [RSRM93] </ref>. In [SSRV94], it was reported that the contention overheads observed in several applications were quite small. Recent studies [CKP + 93] have also shown that parameterized models of the network may be adequate from the point of view of developing performance-conscious parallel programs.
Reference: [SA88] <author> R. L. Sites and A. Agarwal. </author> <title> Multiprocessor cache analysis using ATUM. </title> <booktitle> In 15th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 186-95, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Further, the traces obtained from 3 one machine may not represent true interactions in another machine. Lastly, the traces usually do not capture OS related activities (such as interrupts, context switches, and I/O) unless hardware instrumentation is available <ref> [SA88] </ref>. Many synthetic workload models have been proposed that could avoid the problems associated with traces [AB86, Pop90]. Since application characteristics vary widely, it is difficult to generate a synthetic workload model that is representative of the memory access pattern across a wide range of applications.
Reference: [Sch90] <author> Herb D. Schwetman. </author> <title> CSIM Reference Manual (Revision 14). </title> <type> Technical Report ACA-ST-252-87, </type> <institution> Microelectronics and Computer Technology Corp., Austin, TX, </institution> <year> 1990. </year>
Reference-contexts: However, this depends on how the overheads in the simulation itself gets apportioned among the participating processors. We first address the validation question. 5.1 Validation We developed a sequential simulator that models the same target machine using CSIM <ref> [Sch90] </ref>, which runs on a SPARC workstation. In order to validate our parallel simulator we used randomly generated traces to drive the sequential and parallel simulators.
Reference: [SSRV94] <author> A. Sivasubramaniam, A. Singla, U. Ramachandran, and H. Venkateswaran. </author> <title> An approach to scalability study of shared memory parallel systems. </title> <booktitle> In ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 171-180, </pages> <month> May </month> <year> 1994. </year> <month> 24 </month>
Reference-contexts: For example, experimental results on a state-of-the-art machine such as the KSR-2 have shown that the latencies for remote accesses do not vary significantly for a wide variety of network loads [RSRM93]. In <ref> [SSRV94] </ref>, it was reported that the contention overheads observed in several applications were quite small. Recent studies [CKP + 93] have also shown that parameterized models of the network may be adequate from the point of view of developing performance-conscious parallel programs.
References-found: 26

