URL: ftp://ftp.cs.utexas.edu/pub/predator/tr-92-47.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/jthomas/publications.html
Root-URL: 
Title: Database Challenge: Single Schema Database Management Systems 1  
Author: Don Batory, Vivek Singhal, Jeff Thomas 
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas  
Abstract: Many data-intensive applications require high-performance data management facilities, but utilize only a small fraction of the power of a general-purpose database system (DBMS). We believe single schema database systems (SSDs), i.e., special-purpose DBMSs that are designed for a single schema and a predeclared set of database operations, are a vital need of todays software industry. The challenge is to create a technology for economically building high-performance SSDs. SSD research will combine results from object-oriented databases, persistent object stores, module interconnection languages, rule-based optimizers, open-architecture systems, extensible databases, and generic data types.
Abstract-found: 1
Intro-found: 1
Reference: [Abb92] <author> M. B. Abbott and L. L. Peterson, </author> <title> A Language-Based Approach to Protocol Implementation, </title> <type> Tech. Rep. 92-2, </type> <institution> Department of Computer Science, University of Arizona, </institution> <year> 1992. </year>
Reference-contexts: Domain-specific compilers for open architecture systems are also promising. These compilers exploit knowledge and optimization techniques that are specific to a domain to generate efficient code. The Morpheus network protocol compiler and the Predator data structure compiler are prime examples <ref> [Abb92, Sir92, Bat92] </ref>. 5.1 SSD Query Optimizers SSDs will need modular implementations of query optimizers. Research on rule-based optimizers (e.g., Volcano [Gra92b] and Starburst [Haa89]) is relevant because of the inherent exibility of these optimizers to admit new operators and algorithms in determining efficient strategies for processing queries.
Reference: [Ara92] <author> G. Arango and B. Blum, </author> <title> editors, Special Issue: Applications of Domain Modeling to Software Construction, </title> <journal> International Journal of Software Engineering and Knowledge Engineering, </journal> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: Domain modeling, the process of designing open architectures, is at the forefront of software engineering research <ref> [Pri91, Ara92] </ref>. The distinguishing feature of an open architecture is a framework for defining a family of related systems through the use of standardized interfaces. New components can be introduced as long as they provide the same interfaces as existing system modules.
Reference: [Atk87] <author> M. P. Atkinson and O. P. Buneman, </author> <title> Types and Persistence in Database Programming Languages, </title> <journal> ACM Computing Surveys, </journal> <month> June </month> <year> 1987. </year>
Reference-contexts: For example, circular arrays cannot be used if the maximum size of a queue exceeds the predeclared array size. 4 4 SSDs and Generics SSDs and generics can be related in two different ways. One is the familiar connection of generics and data models <ref> [Atk87] </ref>. A more important, but less understood way to equate SSD components with generics. Each is considered in turn. 4.1 SSD Components as Generics Stacks and queues are classical examples of parameterized types or generics [Ghe82, Gog84]. Generics have data types as parameters. <p> Database programming language research has focused on introducing new generic and programming constructs to make database programming easier <ref> [Atk87] </ref>. We foresee two opportunities for research enroute to unification of generic data types and SSD components: support for attribute parameters and module expressions.
Reference: [Bat88] <author> D. S. Batory, J. R. Barnett, J. F. Garza, K. P. Smith, K. Tsukuda, B. C. Twichell, and T. E. Wise, </author> <title> GENESIS: An Extensible Database Management System, </title> <journal> IEEE Trans. Software Engr., </journal> <month> November </month> <year> 1988, </year> <pages> 1711-1730. </pages>
Reference-contexts: SSD technology needs precisely this capability. The benefits of open architecture designs are well-known to the database community. TIs Open-Architecture object-oriented DBMS is a prime example [Wel92]. Extensible database systems (e.g., Postgres [Sto91], Exodus [Ric87], Starburst [Loh91], and Genesis <ref> [Bat88] </ref>) by definition have open architectures. That is, extensible DBMSs were designed to accommodate certain anticipated enhancements, such as new storage structures, new data types, and rules. SSD research can benefit from this work.
Reference: [Bat92] <author> D. Batory and S. OMalley, </author> <title> The Design and Implementation of Hierarchical Software Systems With Reusable Components, </title> <journal> ACM TOSEM, </journal> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: Any or all of these features may be present in an SSD. How does one specify the particular set of choices that defines a target system and that yields a unique implementation? Research in software engineering suggests that open system architectures is a possible solution to this difficult problem <ref> [Mac90, Bat92] </ref>. Domain modeling, the process of designing open architectures, is at the forefront of software engineering research [Pri91, Ara92]. The distinguishing feature of an open architecture is a framework for defining a family of related systems through the use of standardized interfaces. <p> Domain-specific compilers for open architecture systems are also promising. These compilers exploit knowledge and optimization techniques that are specific to a domain to generate efficient code. The Morpheus network protocol compiler and the Predator data structure compiler are prime examples <ref> [Abb92, Sir92, Bat92] </ref>. 5.1 SSD Query Optimizers SSDs will need modular implementations of query optimizers. Research on rule-based optimizers (e.g., Volcano [Gra92b] and Starburst [Haa89]) is relevant because of the inherent exibility of these optimizers to admit new operators and algorithms in determining efficient strategies for processing queries.
Reference: [Boo87] <author> G. Booch, </author> <title> Software Components with Ada, </title> <publisher> Benjamin Cummings, </publisher> <year> 1987. </year>
Reference-contexts: Each alternative is a generic data type. That is, each file structure presents exactly the same interface (which makes them plug-compatible) and is parameterized by the data type (base relation or index) to be stored. Of the generic libraries that are available today (e.g., <ref> [Boo87, Fon90] </ref>), few generics provide the same interface. Consequently there is little or no plug-compatibility among functionally similar generics. For example, the Booch parts library defines different interfaces for binary trees and lists [Boo87]. <p> Of the generic libraries that are available today (e.g., [Boo87, Fon90]), few generics provide the same interface. Consequently there is little or no plug-compatibility among functionally similar generics. For example, the Booch parts library defines different interfaces for binary trees and lists <ref> [Boo87] </ref>. Modifying an application that uses binary trees to one that uses lists is not always trivial and can be time-consuming. One could easily imagine (and want!) lists and binary trees as interchangeable main-memory implementations of relations.
Reference: [Car85] <author> L. Cardelli and P. Wegner, </author> <title> On Understanding Types, Data Abstraction, and Polymorphism, </title> <journal> ACM Computing Surveys, </journal> <month> December </month> <year> 1985, </year> <pages> 471-522. </pages>
Reference: [Cat91] <author> R. G. G. Cattell, </author> <title> editor, </title> <journal> Special Issue: Next Generation Database Systems, Communications of the ACM, </journal> <month> October </month> <year> 1991. </year>
Reference-contexts: SSDs generally deal with tuple sequences, which we will call containers. A data model for containers would define a programming interface that would be similar to the programming interfaces of todays object-oriented database systems, embedded relational languages, and persistent object stores <ref> [Cat91] </ref>. For example, cursors would be the primary means by which container objects are manipulated, and object retrievals would be declaratively specified and subject to optimization. <p> To see what is needed to expand and simplify a composition of SSD components, consider todays object-oriented DBMSs. They are able to process declarative queries and high-level updates that are specified in application programs, and to generate efficient code for their fixed implementations <ref> [Cat91] </ref>. SSDs will require a much more general technology because the code for compiled queries and updates must be retargetable to any member of a large class of implementations.
Reference: [Cha91] <author> P. P. Chang, S. A. Mahlke, and W-M. W. Hwu, </author> <title> Using Profile Information to Assist Classical Code Optimizations, </title> <journal> Software-Practice and Experience, </journal> <month> December </month> <year> 1991, </year> <pages> 1301-1321. </pages>
Reference-contexts: Furthermore, the computational complexity of optimizing a single composition can be NP-hard. Early research on database optimization problems may be relevant here [Mit75]. It is worth noting that profile-based code optimization (i.e., self-tuning programs) is an active subject of research in the compiler community <ref> [Cha91] </ref>. Research on self-tuning SSDs would be an extension to this line of research. 6 Challenge Summary There are many common data-intensive applications that cannot use general-purpose DBMSs or general-purpose object stores because of unnecessary generality, inadequate performance, or lack of specific features.
Reference: [Coh91] <author> D. Cohen, </author> <title> AP5 Manual, </title> <institution> USC Information Sciences Institute, </institution> <year> 1991. </year>
Reference-contexts: SSD code generation will require a melding of coarse grain optimizations, like those of todays query opti-mizers, with fine grain optimizations of todays compilers. Work on automatic programming, such as AP5 <ref> [Coh91] </ref>, and compilers for very high level languages, such as SETL [Fre83], may be relevant. Another possibility is to apply partial evaluation techniques of compilers to intertwine and optimize modular specifications to produce an efficient monolithic implementation of a target subsystem [Fre89].
Reference: [Fon90] <author> M. Fontana, L. Oren, and M. Neath, </author> <title> COOL A C++ Object-Oriented Library, </title> <institution> Texas Instruments Inc., Computer Science Center, Dallas, Texas, </institution> <year> 1990. </year>
Reference-contexts: Each alternative is a generic data type. That is, each file structure presents exactly the same interface (which makes them plug-compatible) and is parameterized by the data type (base relation or index) to be stored. Of the generic libraries that are available today (e.g., <ref> [Boo87, Fon90] </ref>), few generics provide the same interface. Consequently there is little or no plug-compatibility among functionally similar generics. For example, the Booch parts library defines different interfaces for binary trees and lists [Boo87].
Reference: [Fre83] <author> S. M. Freudenberger, J. T. Schwartz, and M. Sharir, </author> <title> Experience with the SETL Optimizer, </title> <journal> ACM TOPLAS, </journal> <month> March </month> <year> 1983. </year>
Reference-contexts: SSD code generation will require a melding of coarse grain optimizations, like those of todays query opti-mizers, with fine grain optimizations of todays compilers. Work on automatic programming, such as AP5 [Coh91], and compilers for very high level languages, such as SETL <ref> [Fre83] </ref>, may be relevant. Another possibility is to apply partial evaluation techniques of compilers to intertwine and optimize modular specifications to produce an efficient monolithic implementation of a target subsystem [Fre89]. Domain-specific compilers for open architecture systems are also promising.
Reference: [Fre89] <author> J. C. Freytag and N. Goodman, </author> <title> On the Translation of Relational Queries into Iterative Programs, </title> <journal> ACM TODS, </journal> <month> March </month> <year> 1989, </year> <pages> 1-27. </pages>
Reference-contexts: Work on automatic programming, such as AP5 [Coh91], and compilers for very high level languages, such as SETL [Fre83], may be relevant. Another possibility is to apply partial evaluation techniques of compilers to intertwine and optimize modular specifications to produce an efficient monolithic implementation of a target subsystem <ref> [Fre89] </ref>. Domain-specific compilers for open architecture systems are also promising. These compilers exploit knowledge and optimization techniques that are specific to a domain to generate efficient code.
Reference: [Ghe82] <author> C. Ghezzi and M. Jazayeri, </author> <title> Programming Language Concepts, </title> <publisher> John Wiley & Sons, </publisher> <year> 1982. </year>
Reference-contexts: One is the familiar connection of generics and data models [Atk87]. A more important, but less understood way to equate SSD components with generics. Each is considered in turn. 4.1 SSD Components as Generics Stacks and queues are classical examples of parameterized types or generics <ref> [Ghe82, Gog84] </ref>. Generics have data types as parameters. For example, instantiating a stack generic with a type yields a software module for creating stacks of items of that type. By the same reasoning, a DBMS is also generic: it is parameterized by a schema.
Reference: [Gog84] <author> J. Goguen, </author> <title> Parameterized Programming, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> Sept. </month> <year> 1984. </year>
Reference-contexts: One is the familiar connection of generics and data models [Atk87]. A more important, but less understood way to equate SSD components with generics. Each is considered in turn. 4.1 SSD Components as Generics Stacks and queues are classical examples of parameterized types or generics <ref> [Ghe82, Gog84] </ref>. Generics have data types as parameters. For example, instantiating a stack generic with a type yields a software module for creating stacks of items of that type. By the same reasoning, a DBMS is also generic: it is parameterized by a schema. <p> If SSD components are defined as generics in a programming language, one should be able to define their compositions in the same language. Borrowing ideas from module interconnection languages may be the answer. Broadly stated, a module interconnection language (MIL) is a language for specifying compositions of components <ref> [Pri86, Gog84, Pur91] </ref>. Most MILs are aimed at using components that are written in different languages and that are located on different machines to give the appearance of a uniform-language, single-site computing environment.
Reference: [Gra89] <author> G. Graefe and K. Ward, </author> <title> Dynamic Query Evaluation Plans, </title> <booktitle> ACM SIGMOD 1989, </booktitle> <pages> 358-366. </pages>
Reference-contexts: Optimizing a query for one database is straightforward. Optimizing a query over all databases is more problematic; what might be an 6 efficient access plan for one database may be inefficient for another. Dynamic query evaluation techniques might be appropriate <ref> [Gra89] </ref>. 5 SSD Compilers The primary tool for creating SSDs will be compilers, in which SSD components are coded and their compositions are defined. Like traditional compilers, an SSD compiler should strive to generate code of comparable or better efficiency than that written by the average programmer. <p> It is possible to instrument SSD implementations (using gprof-like techniques) to gather such statistics. Two different approaches to optimize queries can then be taken. Multiple access plans could be generated by an SSD optimizer/compiler. At run-time, the best available plan would be chosen based on available statistics <ref> [Gra89] </ref>. In this way, the target SSD would automatically readjust itself to a changing environment. Alternatively, the statistics could be used to recompile and reoptimize the SSD, thus avoiding the overhead of evaluating plans dynamically.
Reference: [Gra92a] <author> J. Gray and A. Reuter, </author> <title> Transaction Processing: Concepts and Techniques, </title> <address> Morgan-Kaufman, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction There are many common data-intensive applications that do not use general-purpose database systems. Consider the lock manager of a database system (DBMS). It maintains a set of tables whose structures resemble that of relations. Each table stores a different number of tuples (e.g., lock names and lock requests <ref> [Gra92a] </ref>); operations on tables (e.g., to set or remove locks) are atomic; and in the case of locks for long transactions, the tables are persistent and recoverable. Multi-table queries (such as retrieving identifiers of transactions that are unblocked by an unlock operation) arise frequently.
Reference: [Gra92b] <author> G. Graefe and W. McKenna, </author> <title> Extensibility and Search Efficiency in the Volcano Optimizer Generator, </title> <type> Tech. Rep. </type> <institution> CU-CS-91-563, Computer Science Department, University of Colorado at Boulder, </institution> <year> 1992. </year>
Reference-contexts: The Morpheus network protocol compiler and the Predator data structure compiler are prime examples [Abb92, Sir92, Bat92]. 5.1 SSD Query Optimizers SSDs will need modular implementations of query optimizers. Research on rule-based optimizers (e.g., Volcano <ref> [Gra92b] </ref> and Starburst [Haa89]) is relevant because of the inherent exibility of these optimizers to admit new operators and algorithms in determining efficient strategies for processing queries. Optimizing queries for main-memory containers (i.e., data structures) poses a problem when statistics (that are needed for optimization) are not available.
Reference: [Haa89] <author> L. M. Haas, J. C. Freytag, G. M. Lohman, and H. Pirahesh, </author> <title> Extensible Query Processing in Starburst, </title> <booktitle> ACM SIGMOD 1989, </booktitle> <pages> 377-388. </pages>
Reference-contexts: The Morpheus network protocol compiler and the Predator data structure compiler are prime examples [Abb92, Sir92, Bat92]. 5.1 SSD Query Optimizers SSDs will need modular implementations of query optimizers. Research on rule-based optimizers (e.g., Volcano [Gra92b] and Starburst <ref> [Haa89] </ref>) is relevant because of the inherent exibility of these optimizers to admit new operators and algorithms in determining efficient strategies for processing queries. Optimizing queries for main-memory containers (i.e., data structures) poses a problem when statistics (that are needed for optimization) are not available.
Reference: [Har88] <author> R. Harper, R. Milner, and M. Tofte, </author> <title> The Definition of Standard ML (Version 2), </title> <type> Tech. Rep. </type> <institution> ECS-LFCS 88-62, Department of Computer Science, University of Edinburgh, </institution> <month> August </month> <year> 1988. </year>
Reference-contexts: To our knowledge, the only statically-typed polymorphic language that permits such functions to be defined is Machiavelli [Oho89], which is an extension of the functional language ML <ref> [Har88] </ref>. However, much remains to be done. It is an unsolved problem how to extend imperative programming languages (e.g., C++) and how to implement their compilers. Open architecture designs will also impact database programming languages. As mentioned earlier, an instance of an open architecture is a composition of components.
Reference: [Kel91] <author> T. Keller, G. Graefe, and D. Maier, </author> <title> Efficient Assembly of Complex Objects, </title> <booktitle> ACM SIGMOD 91, </booktitle> <pages> 148-157. 9 </pages>
Reference-contexts: Raising the level of abstraction beyond individual relations and classes would enable SSD users to model their applications more naturally. Work on complex objects <ref> [Kel91] </ref> and nested relations [Kor91] would be relevant here. Nested generics suggests other problems. How would queries on nested databases be specified? How would such queries be optimized? Consider a container of databases. Each database would be a different instance of the same schema, and would have different object populations.
Reference: [Kor91] <author> H. F. Korth and A. Silberschatz, </author> <title> Database System Concepts, </title> <publisher> McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: Raising the level of abstraction beyond individual relations and classes would enable SSD users to model their applications more naturally. Work on complex objects [Kel91] and nested relations <ref> [Kor91] </ref> would be relevant here. Nested generics suggests other problems. How would queries on nested databases be specified? How would such queries be optimized? Consider a container of databases. Each database would be a different instance of the same schema, and would have different object populations.
Reference: [Loh91] <author> G. M. Lohman, B. Lindsay, H. Pirahesh, and K. Bernhard Schiefer, </author> <title> Extensions to Starburst: Objects, Types, Functions, and Rules, </title> <booktitle> in [Cat91], </booktitle> <pages> 94-109. </pages>
Reference-contexts: SSD technology needs precisely this capability. The benefits of open architecture designs are well-known to the database community. TIs Open-Architecture object-oriented DBMS is a prime example [Wel92]. Extensible database systems (e.g., Postgres [Sto91], Exodus [Ric87], Starburst <ref> [Loh91] </ref>, and Genesis [Bat88]) by definition have open architectures. That is, extensible DBMSs were designed to accommodate certain anticipated enhancements, such as new storage structures, new data types, and rules. SSD research can benefit from this work.
Reference: [Mac90] <author> D. MacKinnon, W. McCrum, and D. Sheppard, </author> <title> An Introduction to Open Systems Interconnection, </title> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Any or all of these features may be present in an SSD. How does one specify the particular set of choices that defines a target system and that yields a unique implementation? Research in software engineering suggests that open system architectures is a possible solution to this difficult problem <ref> [Mac90, Bat92] </ref>. Domain modeling, the process of designing open architectures, is at the forefront of software engineering research [Pri91, Ara92]. The distinguishing feature of an open architecture is a framework for defining a family of related systems through the use of standardized interfaces.
Reference: [Min92] <author> W. H. Miner, </author> <title> private correspondence, </title> <institution> Fusion Research Center and Institute for Fusion Studies, The University of Texas at Austin, </institution> <year> 1992. </year>
Reference-contexts: Functions could then be defined to return databases as their output. For example, it is common in scientific applications to encounter functions that transform a complex data set (i.e., a database of schema S1) into another complex data set (i.e., a database of schema S2) during exploratory analysis <ref> [Wil89, Min92] </ref>. Raising the level of abstraction beyond individual relations and classes would enable SSD users to model their applications more naturally. Work on complex objects [Kel91] and nested relations [Kor91] would be relevant here. Nested generics suggests other problems.
Reference: [Mit75] <author> M. F. </author> <title> Mitoma and K.B. Irani, Automatic Database Schema Design and Optimization, </title> <booktitle> VLDB 1975, </booktitle> <pages> 286-321. </pages>
Reference-contexts: It is not at all obvious how to search this space efficiently. Furthermore, the computational complexity of optimizing a single composition can be NP-hard. Early research on database optimization problems may be relevant here <ref> [Mit75] </ref>. It is worth noting that profile-based code optimization (i.e., self-tuning programs) is an active subject of research in the compiler community [Cha91].
Reference: [Nov92] <author> G. Novak, </author> <title> Software Reuse by Compilation through View Clusters, </title> <institution> Dept. Computer Sciences, University of Texas at Austin, </institution> <year> 1992. </year>
Reference: [Oho89] <author> A. Ohori, P. Buneman, and V. Breazu-Tannen, </author> <title> Database Programming in Machiavelli A Polymorphic Language with Static Type Inference, </title> <booktitle> ACM SIGMOD 1989, </booktitle> <pages> 46-57. </pages>
Reference-contexts: By the same token, generic libraries would benefit if generics which implemented the same abstraction were given the same interface. 5 4.1.2 Database Programming Languages It is well-known that the polymorphism features of traditional programming languages are inadequate for writing common database applications <ref> [Oho89] </ref>; instead, sophisticated parameterizations of functions and components are required. Database programming language research has focused on introducing new generic and programming constructs to make database programming easier [Atk87]. <p> To our knowledge, the only statically-typed polymorphic language that permits such functions to be defined is Machiavelli <ref> [Oho89] </ref>, which is an extension of the functional language ML [Har88]. However, much remains to be done. It is an unsolved problem how to extend imperative programming languages (e.g., C++) and how to implement their compilers. Open architecture designs will also impact database programming languages.
Reference: [Pri86] <author> R. Prieto-Diaz and J. M. Neighbors, </author> <title> Module Interconnection Languages, </title> <journal> Journal of Systems and Software, </journal> <month> Nov. </month> <year> 1986, </year> <pages> 307-334. </pages> <note> Also in P. </note> <editor> Freeman, editor, </editor> <booktitle> Software Reusability, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1987. </year>
Reference-contexts: If SSD components are defined as generics in a programming language, one should be able to define their compositions in the same language. Borrowing ideas from module interconnection languages may be the answer. Broadly stated, a module interconnection language (MIL) is a language for specifying compositions of components <ref> [Pri86, Gog84, Pur91] </ref>. Most MILs are aimed at using components that are written in different languages and that are located on different machines to give the appearance of a uniform-language, single-site computing environment.
Reference: [Pri91] <author> R. Prieto-Diaz and G. Arango, </author> <title> editors, Domain Analysis and Software Systems Modeling, </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: Domain modeling, the process of designing open architectures, is at the forefront of software engineering research <ref> [Pri91, Ara92] </ref>. The distinguishing feature of an open architecture is a framework for defining a family of related systems through the use of standardized interfaces. New components can be introduced as long as they provide the same interfaces as existing system modules.
Reference: [Pur91] <author> J. R. Purtilo, R. Snodgrass, and A. L. Wolf, </author> <title> Software Bus Organization: Reference Model and Comparison of Two Existing Systems, Module Interconnection Formalism Technical Note No. </title> <type> 8, </type> <month> November </month> <year> 1991. </year>
Reference-contexts: If SSD components are defined as generics in a programming language, one should be able to define their compositions in the same language. Borrowing ideas from module interconnection languages may be the answer. Broadly stated, a module interconnection language (MIL) is a language for specifying compositions of components <ref> [Pri86, Gog84, Pur91] </ref>. Most MILs are aimed at using components that are written in different languages and that are located on different machines to give the appearance of a uniform-language, single-site computing environment.
Reference: [Ric87] <author> J. E. Richardson and M. J. Carey, </author> <title> Programming Constructs for the Database System Implementation in EXODUS, </title> <booktitle> ACM SIGMOD 1987, </booktitle> <pages> 208-219. </pages>
Reference-contexts: SSD technology needs precisely this capability. The benefits of open architecture designs are well-known to the database community. TIs Open-Architecture object-oriented DBMS is a prime example [Wel92]. Extensible database systems (e.g., Postgres [Sto91], Exodus <ref> [Ric87] </ref>, Starburst [Loh91], and Genesis [Bat88]) by definition have open architectures. That is, extensible DBMSs were designed to accommodate certain anticipated enhancements, such as new storage structures, new data types, and rules. SSD research can benefit from this work.
Reference: [Sch78] <author> J. Schmidt, </author> <title> Some High Level Language Constructs for Data of Type Relation, </title> <journal> ACM TODS, </journal> <year> 1978. </year>
Reference-contexts: To bridge the gap between database-like operations on containers and the desired application-specific operations (e.g., push and pop for stacks), an abstract data type (ADT) veneer is placed over a container and each ADT operator is defined in terms of container operations <ref> [Sch78] </ref>.
Reference: [Sir92] <author> M. Sirkin, D. Batory, and V. Singhal, </author> <title> Software Components in a Data Structure Precompiler, </title> <institution> TR-92-29, Dept. Computer Sciences, University of Texas at Austin, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Domain-specific compilers for open architecture systems are also promising. These compilers exploit knowledge and optimization techniques that are specific to a domain to generate efficient code. The Morpheus network protocol compiler and the Predator data structure compiler are prime examples <ref> [Abb92, Sir92, Bat92] </ref>. 5.1 SSD Query Optimizers SSDs will need modular implementations of query optimizers. Research on rule-based optimizers (e.g., Volcano [Gra92b] and Starburst [Haa89]) is relevant because of the inherent exibility of these optimizers to admit new operators and algorithms in determining efficient strategies for processing queries.
Reference: [Sto76] <author> M. Stonebraker, E. Wong, P. Kreps, and G. </author> <title> Held, The Design and Implementation of INGRES, </title> <journal> ACM TODS, </journal> <volume> 1 #3 (Sept. </volume> <year> 1976), </year> <pages> 189-222. </pages>
Reference-contexts: For example, Ingres allows users to select implementations for base relations and indexes from six choices (hash, heap, isam, compressed-hash, compressed-heap, and compressed-isam) <ref> [Sto76] </ref>. Each alternative is a generic data type. That is, each file structure presents exactly the same interface (which makes them plug-compatible) and is parameterized by the data type (base relation or index) to be stored.
Reference: [Sto91] <author> M. Stonebraker and G. Kemnitz, </author> <title> The POSTGRES Next-Generation Database Management System, </title> <booktitle> in [Cat91], </booktitle> <pages> 78-93. </pages>
Reference-contexts: SSD technology needs precisely this capability. The benefits of open architecture designs are well-known to the database community. TIs Open-Architecture object-oriented DBMS is a prime example [Wel92]. Extensible database systems (e.g., Postgres <ref> [Sto91] </ref>, Exodus [Ric87], Starburst [Loh91], and Genesis [Bat88]) by definition have open architectures. That is, extensible DBMSs were designed to accommodate certain anticipated enhancements, such as new storage structures, new data types, and rules. SSD research can benefit from this work.
Reference: [Str91] <author> B. Stroustrup, </author> <title> The C++ Programming Language, Second Edition, </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Instantiating SSD components would yield software modules that are customized for specific data types or schemas. We assert that generics, DBMSs, and SSD components belong to the spectrum of polymorphic types. There is clearly a tremendous gap between conventional generics (e.g., templates in C++ <ref> [Str91] </ref>) and DBMSs; generics offered by programming languages are much too simplistic to match DBMS capabilities. For example, schemas are not single record types, but large sets of interrelated record types. <p> Achieving very high efficiencies poses a challenge to the database and compiler communities. The strategy used for realizing C++ templates might be appropriate: templates are macro expanded and partially evaluated when parameters are instantiated <ref> [Str91] </ref>. The result is a software module that is both customized and optimized for the given application; the generality of the template has given way to an efficient and specialized instantiation.
Reference: [Wel92] <author> D. L. Wells, J. A. Blakeley, and C. W. Thompson, </author> <title> Architecture of an Open Object-Oriented Database Management System, </title> <journal> Computer, </journal> <volume> Vol. 25, No. 10, </volume> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: SSD technology needs precisely this capability. The benefits of open architecture designs are well-known to the database community. TIs Open-Architecture object-oriented DBMS is a prime example <ref> [Wel92] </ref>. Extensible database systems (e.g., Postgres [Sto91], Exodus [Ric87], Starburst [Loh91], and Genesis [Bat88]) by definition have open architectures. That is, extensible DBMSs were designed to accommodate certain anticipated enhancements, such as new storage structures, new data types, and rules. SSD research can benefit from this work.
Reference: [Wil89] <author> J. C. Wiley, et al., </author> <title> The TEXT data base, </title> <journal> Rev. Sci. Instrum., </journal> <volume> 60 (7), </volume> <month> July </month> <year> 1989. </year>
Reference-contexts: Functions could then be defined to return databases as their output. For example, it is common in scientific applications to encounter functions that transform a complex data set (i.e., a database of schema S1) into another complex data set (i.e., a database of schema S2) during exploratory analysis <ref> [Wil89, Min92] </ref>. Raising the level of abstraction beyond individual relations and classes would enable SSD users to model their applications more naturally. Work on complex objects [Kel91] and nested relations [Kor91] would be relevant here. Nested generics suggests other problems.
References-found: 39

