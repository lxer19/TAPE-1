URL: http://www.csl.sri.com/reports/postscript/wift-tutorial.ps.gz
Refering-URL: http://www.csl.sri.com/pvs.html
Root-URL: 
Title: A Tutorial Introduction to PVS  
Author: Judy Crow, Sam Owre, John Rushby, Natarajan Shankar, Mandayam Srivas 
Web: www: http://www.csl.sri.com/sri-csl-fm.html  
Affiliation: Computer Science Laboratory SRI International  Stanford Unversity.  
Date: April 1995  Updated June 1995  
Address: Boca Raton, Florida,  Menlo Park CA 94025 USA  
Note: Presented at WIFT '95: Workshop on Industrial-Strength Formal Specification Techniques,  Dave Stringer-Calvert provided valuable comments on earlier versions of this tutorial, and also checked the specifications and proofs appearing here. Preparation of this tutorial was partially funded by NASA Langley Research Center under Contract NAS1-18969, and by the Advanced Research Projects Agency through NASA Ames Research Center NASA-NAG-2-891 (Arpa order A721) to  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: <institution> References </institution>
Reference: [AJ90] <author> Heather Alexander and Val Jones. </author> <title> Software Design and Prototyping using me too. </title> <publisher> Prentice Hall International, </publisher> <address> Hemel Hempstead, UK, </address> <year> 1990. </year>
Reference-contexts: We do expect to provide these in a later release, but using a different approach than EHDM. 7 Directly executable specification languages (e.g., <ref> [AJ90, HI88] </ref>) support validation of specifications by running conventional test cases.
Reference: [ALW93] <author> Mark D. Aagard, Miriam E. Leeser, and Phillip J. Windley. </author> <title> Toward a super duper hardware tactic. </title> <booktitle> In Proceedings of the HOL User's Group Workshop, </booktitle> <pages> pages 401-414, </pages> <year> 1993. </year>
Reference-contexts: The proof of the microprocessor property shown below follows a certain general pattern that works successfully for most hardware proofs. This general proof pattern, variants of which have been used in other verification exercises <ref> [KSK93, ALW93] </ref>, consists of the following sequence of general proof tasks. 81 Two Hardware Examples Using PVS Quantifier elimination: Since the decision procedures work on ground formulas, the user must eliminate the relevant universal quantifiers by skolemization or selecting variables on which to induct and existential quantifiers by suitable instantiation.
Reference: [BCM + 90] <author> J. R. Burch, E. M. Clarke, K. L McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <address> Philadelphia, PA, June 1990. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: Similarly, if your interests are gate-level hardware designs, you will probably do best to consider model-checking and automatic procedures based on BDDs <ref> [BCM + 90] </ref>. The design of PVS was shaped by our experience in doing or contemplating early-lifecycle applications of formal methods. Many of the larger examples we have done concern algorithms and architectures for fault-tolerance (see [ORSvH95] for an overview). <p> The design and the property verified are both based on the processor example given in <ref> [BCM + 90] </ref>. The example has been used as a benchmark for evaluating how well finite state-enumeration based tools, such as model checkers, can handle datapath-oriented circuits with a large number of states by varying the size of the datapath.
Reference: [BJ93] <author> Ricky W. Butler and Sally C. Johnson. </author> <title> Formal methods for life-critical software. </title> <booktitle> In Computing in Aerospace Conference, </booktitle> <pages> pages 319-329, </pages> <address> San Diego, CA, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: We decide that AddPhone should take a phone book, a name, and a phone number and should add the association 1 This example is based on one by Ricky Butler and Sally Johnson of NASA Langley <ref> [BJ93] </ref>. 5 Phone Book: Simple Version Analyzing Specifications Using PVS between the name and number to the phone book; and that DelPhone should take a phone book and a name and delete the phone number associated with that name (if any).
Reference: [BM79] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1979. </year>
Reference-contexts: In following these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH [dB80], LCF [GMW79], Nuprl [Const86], Coq [CH85], and HOL [Gor88], but provides more user control over the structure of the proof than highly automated systems such as Nqthm <ref> [BM79, BM88] </ref> and Otter [McC90]. We feel that the low-level systems over-emphasize the formal correctness of proofs at the expense of their cogency, and the highly automated systems emphasize theorems at the expense of their proofs. <p> Nqthm <ref> [BM79, BM88] </ref>, Eves [PS89], and IMPS [FGT91] also rely heavily on the use of decision procedures. 58 Using PVS The PVS Proof Checker up the remaining 80% of the effort. PVS attempts to provide much of the 80% of the functionality that is easily implemented.
Reference: [BM88] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: In following these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH [dB80], LCF [GMW79], Nuprl [Const86], Coq [CH85], and HOL [Gor88], but provides more user control over the structure of the proof than highly automated systems such as Nqthm <ref> [BM79, BM88] </ref> and Otter [McC90]. We feel that the low-level systems over-emphasize the formal correctness of proofs at the expense of their cogency, and the highly automated systems emphasize theorems at the expense of their proofs. <p> Nqthm <ref> [BM79, BM88] </ref>, Eves [PS89], and IMPS [FGT91] also rely heavily on the use of decision procedures. 58 Using PVS The PVS Proof Checker up the remaining 80% of the effort. PVS attempts to provide much of the 80% of the functionality that is easily implemented.
Reference: [But93] <author> Ricky W. Butler. </author> <title> An elementary tutorial on formal specification and verification using PVS. </title> <type> NASA Technical Memorandum 108991, </type> <institution> NASA Langley Research Center, Hampton, VA, </institution> <month> June </month> <year> 1993. </year> <note> Available through www or ftp from ftp://air16.larc.nasa.gov/pub/fm/larc/PVS-tutorial/pvs-tutorial.ps. </note>
Reference-contexts: Some of these applications of PVS are summarized in [ORSvH95], which also motivates and describes some of the design decisions underlying PVS. Applications of PVS undertaken independently of SRI include <ref> [Hoo94, But93, JMC94, MPJ94] </ref>. 1.3 Getting and Using PVS At the moment, PVS is readily available only for Sun SPARC workstations running SunOS 4.1.3, although versions of the system have been run on IBM Risc 6000 (under AIX) and DECSystem 5000 (under Ultrix).
Reference: [Can94] <author> F. J. Cantu. </author> <title> Verifying an n-bit arithmetic logic unit. Blue book note 935, </title> <institution> University of Edinburgh, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: The strategy is parameterized with respect to an induction scheme and the set of rewrite rules to be used for unfolding. We have used the strategy to prove an N-bit ALU <ref> [Can94] </ref> that executes 12 microoperations by cascading N 1-bit ALU slices. 6 Exercises Problem 1 Based on the discussion of the specification of stacks, try to specify a PVS theory formalizing queues.
Reference: [CH85] <author> T. Coquand and G. P. Huet. </author> <title> Constructions: A higher order proof system for mechanizing mathematics. </title> <booktitle> In Proceedings of EUROCAL 85, </booktitle> <address> Linz (Austria), Berlin, 1985. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In following these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH [dB80], LCF [GMW79], Nuprl [Const86], Coq <ref> [CH85] </ref>, and HOL [Gor88], but provides more user control over the structure of the proof than highly automated systems such as Nqthm [BM79, BM88] and Otter [McC90].
Reference: [Const86] <author> R. L. Constable, </author> <title> et al . Implementing Mathematics with the Nuprl. </title> <publisher> Prentice-Hall, </publisher> <address> New Jersey, </address> <year> 1986. </year>
Reference-contexts: In following these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH [dB80], LCF [GMW79], Nuprl <ref> [Const86] </ref>, Coq [CH85], and HOL [Gor88], but provides more user control over the structure of the proof than highly automated systems such as Nqthm [BM79, BM88] and Otter [McC90].
Reference: [Cou93] <author> Costas Courcoubetis, </author> <title> editor. Computer-Aided Verification, </title> <booktitle> CAV '93, volume 697 of Lecture Notes in Computer Science, </booktitle> <address> Elounda, Greece, June/July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference: [CRSS94] <author> D. Cyrluk, S. Rajan, N. Shankar, and M. K. Srivas. </author> <title> Effective theorem proving for hardware verification. </title> <booktitle> In Kumar and Kropf [KK94], </booktitle> <pages> pages 203-222. </pages>
Reference-contexts: The smaller examples include the specification and verification of ordered binary tree insertion [Sha93a], a compiler for simple arithmetic expressions [Rus95], and several small hardware examples including pipeline and microcode correctness <ref> [CRSS94] </ref>. Examples of this scale can typically be completed within a day.
Reference: [dB80] <author> N. G. de Bruijn. </author> <title> A survey of the project Automath. In To H. </title> <editor> B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 589-606. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year> <note> 109 References </note>
Reference-contexts: In following these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH <ref> [dB80] </ref>, LCF [GMW79], Nuprl [Const86], Coq [CH85], and HOL [Gor88], but provides more user control over the structure of the proof than highly automated systems such as Nqthm [BM79, BM88] and Otter [McC90].
Reference: [EGMS79] <author> B. Elspas, M. Green, M. Moriconi, and R. Shostak. </author> <title> A JOVIAL verifier. </title> <type> Technical report, </type> <institution> Computer Science Laboratory, SRI International, </institution> <month> January </month> <year> 1979. </year>
Reference-contexts: PVS is the most recent in a line of specification languages, theorem provers, and verification systems developed at SRI, dating back over 20 years. That line includes the Jovial Verification System <ref> [EGMS79] </ref>, the Hierarchical Development Methodology (HDM) [RL76, RLS79], STP [SSMS82], and EHDM [MSR85, RvHO91]. We call PVS a "Prototype Verification System," because it was built partly as a lightweight prototype to explore "next generation" technology for EHDM, our main, heavyweight, verification system.
Reference: [FGT91] <author> W. M. Farmer, J. D. Guttman, and F. J. Thayer. IMPS: </author> <title> An interactive mathematical proof system. </title> <type> Technical Report M90-19, </type> <institution> Mitre Corporation, </institution> <year> 1991. </year>
Reference-contexts: Nqthm [BM79, BM88], Eves [PS89], and IMPS <ref> [FGT91] </ref> also rely heavily on the use of decision procedures. 58 Using PVS The PVS Proof Checker up the remaining 80% of the effort. PVS attempts to provide much of the 80% of the functionality that is easily implemented.
Reference: [GHW85] <author> John V. Guttag, James J. Horning, and Jeannette M. Wing. </author> <title> The Larch family of specification languages. </title> <journal> IEEE Software, </journal> <volume> 2(5) </volume> <pages> 24-36, </pages> <month> September </month> <year> 1985. </year>
Reference-contexts: If this kind of program verification is your interest, then PVS is not for you. You will probably be better served by a verification system built around a programming language, such as Penelope [Pra92] (for Ada), or by some member of the Larch family <ref> [GHW85] </ref>. Similarly, if your interests are gate-level hardware designs, you will probably do best to consider model-checking and automatic procedures based on BDDs [BCM + 90]. The design of PVS was shaped by our experience in doing or contemplating early-lifecycle applications of formal methods.
Reference: [GMW79] <author> M. Gordon, R. Milner, and C. Wadsworth. </author> <title> Edinburgh LCF: A Mechanized Logic of Computation, </title> <booktitle> volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: In following these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH [dB80], LCF <ref> [GMW79] </ref>, Nuprl [Const86], Coq [CH85], and HOL [Gor88], but provides more user control over the structure of the proof than highly automated systems such as Nqthm [BM79, BM88] and Otter [McC90].
Reference: [Gor88] <author> M. J. C. Gordon. </author> <title> HOL: A proof generating system for higher-order logic. </title> <editor> In G. Birtwistle and P. A. Subrahmanyam, editors, </editor> <booktitle> VLSI Specification, Verification and Synthesis, </booktitle> <pages> pages 73-128. </pages> <publisher> Kluwer, </publisher> <address> Dordrecht, The Netherlands, </address> <year> 1988. </year>
Reference-contexts: In following these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH [dB80], LCF [GMW79], Nuprl [Const86], Coq [CH85], and HOL <ref> [Gor88] </ref>, but provides more user control over the structure of the proof than highly automated systems such as Nqthm [BM79, BM88] and Otter [McC90].
Reference: [HI88] <author> Sharam Hekmatpour and Darrel Ince. </author> <title> Software Prototyping, Formal Methods, and VDM. </title> <booktitle> International Computer Science Series. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Woking-ham, England, </address> <year> 1988. </year>
Reference-contexts: We do expect to provide these in a later release, but using a different approach than EHDM. 7 Directly executable specification languages (e.g., <ref> [AJ90, HI88] </ref>) support validation of specifications by running conventional test cases.
Reference: [Hoo94] <author> Jozef Hooman. </author> <title> Correctness of real time systems by construction. </title> <editor> In Langmaack et al. </editor> <booktitle> [LdV94], </booktitle> <pages> pages 19-40. </pages>
Reference-contexts: Some of these applications of PVS are summarized in [ORSvH95], which also motivates and describes some of the design decisions underlying PVS. Applications of PVS undertaken independently of SRI include <ref> [Hoo94, But93, JMC94, MPJ94] </ref>. 1.3 Getting and Using PVS At the moment, PVS is readily available only for Sun SPARC workstations running SunOS 4.1.3, although versions of the system have been run on IBM Risc 6000 (under AIX) and DECSystem 5000 (under Ultrix).
Reference: [JMC94] <author> Steven D. Johnson, Paul S. Miner, and Albert Camlleri. </author> <title> Studies of the single-pulser in various reasoning systems. </title> <booktitle> In Kumar and Kropf [KK94], </booktitle> <pages> pages 126-145. </pages>
Reference-contexts: Some of these applications of PVS are summarized in [ORSvH95], which also motivates and describes some of the design decisions underlying PVS. Applications of PVS undertaken independently of SRI include <ref> [Hoo94, But93, JMC94, MPJ94] </ref>. 1.3 Getting and Using PVS At the moment, PVS is readily available only for Sun SPARC workstations running SunOS 4.1.3, although versions of the system have been run on IBM Risc 6000 (under AIX) and DECSystem 5000 (under Ultrix).
Reference: [KK94] <editor> Ramayya Kumar and Thomas Kropf, editors. </editor> <booktitle> Theorem Provers in Circuit Design (TPCD '94), volume 910 of Lecture Notes in Computer Science, </booktitle> <address> Bad Herrenalb, Germany, </address> <month> September </month> <year> 1994. </year> <note> Springer-Verlag. </note>
Reference: [KSK93] <author> R. Kumar, K. Schneider, and T. Kropf. </author> <title> Structuring and automating hardware proofs in a higher-order therem proving environment. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 2(2) </volume> <pages> 165-223, </pages> <year> 1993. </year>
Reference-contexts: The proof of the microprocessor property shown below follows a certain general pattern that works successfully for most hardware proofs. This general proof pattern, variants of which have been used in other verification exercises <ref> [KSK93, ALW93] </ref>, consists of the following sequence of general proof tasks. 81 Two Hardware Examples Using PVS Quantifier elimination: Since the decision procedures work on ground formulas, the user must eliminate the relevant universal quantifiers by skolemization or selecting variables on which to induct and existential quantifiers by suitable instantiation.
Reference: [LdV94] <editor> H. Langmaack, W.-P. de Roever, and J. Vytopil, editors. </editor> <booktitle> Formal Techniques in Real-Time and Fault-Tolerant Systems, volume 863 of Lecture Notes in Computer Science, Lubeck, </booktitle> <address> Germany, </address> <month> September </month> <year> 1994. </year> <note> Springer-Verlag. </note>
Reference: [LR93a] <author> Patrick Lincoln and John Rushby. </author> <title> Formal verification of an algorithm for interactive consistency under a hybrid fault model. </title> <booktitle> In Courcoubetis [Cou93], </booktitle> <pages> pages 292-304. </pages>
Reference-contexts: More substantial examples include the correctness of a real-time railroad crossing controller [Sha93b], an embedding of the Duration Calculus [SS94], the correctness of some transformations used in digital syntheses [Raj94], and the correctness of distributed agreement protocols for a hybrid fault model consisting of Byzantine, symmetric, and crash faults <ref> [LR93a, LR93b, LR94] </ref>. These harder examples can take from several days to several weeks. Industrial applications of PVS include verification of selected elements of a commercial avionics microprocessor whose implementation has 500,000 transistors [MS95].
Reference: [LR93b] <author> Patrick Lincoln and John Rushby. </author> <title> A formally verified algorithm for interactive consistency under a hybrid fault model. </title> <booktitle> In Fault Tolerant Computing Symposium 23, </booktitle> <pages> pages 402-411, </pages> <address> Toulouse, France, </address> <month> June </month> <year> 1993. </year> <journal> IEEE Computer Society. </journal> <volume> 110 References </volume>
Reference-contexts: More substantial examples include the correctness of a real-time railroad crossing controller [Sha93b], an embedding of the Duration Calculus [SS94], the correctness of some transformations used in digital syntheses [Raj94], and the correctness of distributed agreement protocols for a hybrid fault model consisting of Byzantine, symmetric, and crash faults <ref> [LR93a, LR93b, LR94] </ref>. These harder examples can take from several days to several weeks. Industrial applications of PVS include verification of selected elements of a commercial avionics microprocessor whose implementation has 500,000 transistors [MS95].
Reference: [LR94] <author> Patrick Lincoln and John Rushby. </author> <title> Formal verification of an interactive consistency algorithm for the Draper FTP architecture under a hybrid fault model. </title> <booktitle> In COMPASS '94 (Proceedings of the Ninth Annual Conference on Computer Assurance), </booktitle> <pages> pages 107-120, </pages> <address> Gaithersburg, MD, </address> <month> June </month> <year> 1994. </year> <institution> IEEE Washington Section. </institution>
Reference-contexts: More substantial examples include the correctness of a real-time railroad crossing controller [Sha93b], an embedding of the Duration Calculus [SS94], the correctness of some transformations used in digital syntheses [Raj94], and the correctness of distributed agreement protocols for a hybrid fault model consisting of Byzantine, symmetric, and crash faults <ref> [LR93a, LR93b, LR94] </ref>. These harder examples can take from several days to several weeks. Industrial applications of PVS include verification of selected elements of a commercial avionics microprocessor whose implementation has 500,000 transistors [MS95].
Reference: [McA89] <author> D. A. McAllester. ONTIC: </author> <title> A Knowledge Representation System for Mathematics. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: much else in PVS, the implementation philosophy of the proof checker has been guided by the 80-20 rule, namely that 80% of the functionality of a nearly perfect system can be built with 20% of the effort, and the remaining 20% of the functionality can take 40 The Ontic system <ref> [McA89] </ref> is a proof checker where decision procedures are ubiquitously used. Nqthm [BM79, BM88], Eves [PS89], and IMPS [FGT91] also rely heavily on the use of decision procedures. 58 Using PVS The PVS Proof Checker up the remaining 80% of the effort.
Reference: [McC90] <author> W. McCune. </author> <title> Otter 2.0 users guide. </title> <type> Technical Report ANL-90/9, </type> <institution> Argonne National Laboratory, </institution> <year> 1990. </year>
Reference-contexts: these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH [dB80], LCF [GMW79], Nuprl [Const86], Coq [CH85], and HOL [Gor88], but provides more user control over the structure of the proof than highly automated systems such as Nqthm [BM79, BM88] and Otter <ref> [McC90] </ref>. We feel that the low-level systems over-emphasize the formal correctness of proofs at the expense of their cogency, and the highly automated systems emphasize theorems at the expense of their proofs.
Reference: [MPJ94] <author> Paul S. Miner, Shyamsundar Pullela, and Steven D. Johnson. </author> <title> Interaction of formal design systems in the development of a fault-tolerant clock synchronization circuit. </title> <booktitle> In 13th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 128-137, </pages> <publisher> Dana Point, </publisher> <address> CA, </address> <month> October </month> <year> 1994. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: Some of these applications of PVS are summarized in [ORSvH95], which also motivates and describes some of the design decisions underlying PVS. Applications of PVS undertaken independently of SRI include <ref> [Hoo94, But93, JMC94, MPJ94] </ref>. 1.3 Getting and Using PVS At the moment, PVS is readily available only for Sun SPARC workstations running SunOS 4.1.3, although versions of the system have been run on IBM Risc 6000 (under AIX) and DECSystem 5000 (under Ultrix).
Reference: [MS95] <author> Steven P. Miller and Mandayam Srivas. </author> <title> Formal verification of the AAMP5 microprocessor: A case study in the industrial use of formal methods. </title> <booktitle> In WIFT '95: Workshop on Industrial-Strength Formal Specification Techniques, </booktitle> <pages> pages 2-16, </pages> <address> Boca Raton, FL, 1995. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: These harder examples can take from several days to several weeks. Industrial applications of PVS include verification of selected elements of a commercial avionics microprocessor whose implementation has 500,000 transistors <ref> [MS95] </ref>. Some of these applications of PVS are summarized in [ORSvH95], which also motivates and describes some of the design decisions underlying PVS.
Reference: [MSR85] <author> P. Michael Melliar-Smith and John Rushby. </author> <title> The Enhanced HDM system for specification and verification. </title> <booktitle> In Proc. VerkShop III, </booktitle> <pages> pages 41-43, </pages> <address> Watsonville, CA, </address> <month> February </month> <year> 1985. </year> <booktitle> Published as ACM Software Engineering Notes, </booktitle> <volume> Vol. 10, No. 4, </volume> <month> Aug. 85. </month>
Reference-contexts: PVS is the most recent in a line of specification languages, theorem provers, and verification systems developed at SRI, dating back over 20 years. That line includes the Jovial Verification System [EGMS79], the Hierarchical Development Methodology (HDM) [RL76, RLS79], STP [SSMS82], and EHDM <ref> [MSR85, RvHO91] </ref>. We call PVS a "Prototype Verification System," because it was built partly as a lightweight prototype to explore "next generation" technology for EHDM, our main, heavyweight, verification system.
Reference: [ORSvH95] <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: The design of PVS was shaped by our experience in doing or contemplating early-lifecycle applications of formal methods. Many of the larger examples we have done concern algorithms and architectures for fault-tolerance (see <ref> [ORSvH95] </ref> for an overview). We found that many of the published proofs that we attempted to check were in fact, incorrect, as was one of the important algorithms. We have also found that many of our own specifications are subtly flawed when first written. <p> These harder examples can take from several days to several weeks. Industrial applications of PVS include verification of selected elements of a commercial avionics microprocessor whose implementation has 500,000 transistors [MS95]. Some of these applications of PVS are summarized in <ref> [ORSvH95] </ref>, which also motivates and describes some of the design decisions underlying PVS.
Reference: [OSR93a] <author> S. Owre, N. Shankar, and J. M. Rushby. </author> <title> The PVS Specification Language. </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year> <note> A new edition for PVS Version 2 is expected in early 1995. </note>
Reference-contexts: More realistic examples are provided in Section 5. The PVS language, system, and theorem prover each have their own reference manuals <ref> [OSR93a, SOR93, OSR93b] </ref>, which you will need to study in order to make productive use of the system. A pocket reference card, summarizing all the features of the PVS language, system, and prover is also available. <p> In the following sections we will describe the language by means of a series of examples. These examples were chosen to exemplify various aspects of the language, and do not necessarily reflect the best style. The PVS language is described in detail in <ref> [OSR93a] </ref>. 3.1 A Simple Example: The Rational Numbers The rational numbers are built into PVS, but for the sake of illustration we attempt to develop a partial axiomatization. The examples in this section illustrate some simple syntactic and semantic aspects of PVS. <p> The development of the rational numbers is described in an appendix to the Language Reference <ref> [OSR93a] </ref>. It is important to note that the PVS proof checker has an underlying decision procedure that automatically proves many of the properties of the rational numbers.
Reference: [OSR93b] <author> S. Owre, N. Shankar, and J. M. Rushby. </author> <title> User Guide for the PVS Specification and Verification System. </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year> <note> A new edition for PVS Version 2 is expected in early 1995. </note>
Reference-contexts: More realistic examples are provided in Section 5. The PVS language, system, and theorem prover each have their own reference manuals <ref> [OSR93a, SOR93, OSR93b] </ref>, which you will need to study in order to make productive use of the system. A pocket reference card, summarizing all the features of the PVS language, system, and prover is also available.
Reference: [Pra92] <author> Sanjiva Prasad. </author> <title> Verification of numerical programs using Penelope/Ariel. </title> <booktitle> In COMPASS '92 (Proceedings of the Seventh Annual Conference on Computer Assurance), </booktitle> <pages> pages 11-24, </pages> <address> Gaithersburg, MD, </address> <month> June </month> <year> 1992. </year> <institution> IEEE Washington Section. </institution>
Reference-contexts: If this kind of program verification is your interest, then PVS is not for you. You will probably be better served by a verification system built around a programming language, such as Penelope <ref> [Pra92] </ref> (for Ada), or by some member of the Larch family [GHW85]. Similarly, if your interests are gate-level hardware designs, you will probably do best to consider model-checking and automatic procedures based on BDDs [BCM + 90].
Reference: [PS89] <author> W. Pase and M. Saaltink. </author> <title> Formal verification in m-EVES. </title> <editor> In G. Birtwistle and P. A. Subrahmanyam, editors, </editor> <booktitle> Current Trends in Hardware Verification and Theorem Proving, </booktitle> <pages> pages 268-302, </pages> <address> New York, NY, 1989. </address> <publisher> Springer-Verlag. </publisher> <address> 111 References </address>
Reference-contexts: Nqthm [BM79, BM88], Eves <ref> [PS89] </ref>, and IMPS [FGT91] also rely heavily on the use of decision procedures. 58 Using PVS The PVS Proof Checker up the remaining 80% of the effort. PVS attempts to provide much of the 80% of the functionality that is easily implemented.
Reference: [Raj94] <author> P. Sreeranga Rajan. </author> <title> Transformations in high-level synthesis: Formal specification and efficient mechanical verification. </title> <type> Technical Report SRI-CSL-94-10, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> October </month> <year> 1994. </year> <note> Revised version of Technical Report NL-TN 118/94, </note> <institution> Philips Research Laboratories, Eindhoven, </institution> <address> The Netherlands, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: Examples of this scale can typically be completed within a day. More substantial examples include the correctness of a real-time railroad crossing controller [Sha93b], an embedding of the Duration Calculus [SS94], the correctness of some transformations used in digital syntheses <ref> [Raj94] </ref>, and the correctness of distributed agreement protocols for a hybrid fault model consisting of Byzantine, symmetric, and crash faults [LR93a, LR93b, LR94]. These harder examples can take from several days to several weeks.
Reference: [RL76] <author> Lawrence Robinson and Karl N. Levitt. </author> <title> Proof techniques for hierarchically structured programs. </title> <journal> Communications of the ACM, </journal> <volume> 20(4) </volume> <pages> 271-283, </pages> <month> April </month> <year> 1976. </year>
Reference-contexts: PVS is the most recent in a line of specification languages, theorem provers, and verification systems developed at SRI, dating back over 20 years. That line includes the Jovial Verification System [EGMS79], the Hierarchical Development Methodology (HDM) <ref> [RL76, RLS79] </ref>, STP [SSMS82], and EHDM [MSR85, RvHO91]. We call PVS a "Prototype Verification System," because it was built partly as a lightweight prototype to explore "next generation" technology for EHDM, our main, heavyweight, verification system.
Reference: [RLS79] <author> L. Robinson, K. N. Levitt, and B. A. Silverberg. </author> <title> The HDM Handbook. </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> June </month> <year> 1979. </year> <title> Three Volumes. </title>
Reference-contexts: PVS is the most recent in a line of specification languages, theorem provers, and verification systems developed at SRI, dating back over 20 years. That line includes the Jovial Verification System [EGMS79], the Hierarchical Development Methodology (HDM) <ref> [RL76, RLS79] </ref>, STP [SSMS82], and EHDM [MSR85, RvHO91]. We call PVS a "Prototype Verification System," because it was built partly as a lightweight prototype to explore "next generation" technology for EHDM, our main, heavyweight, verification system.
Reference: [Rus95] <author> John Rushby. </author> <title> Proof Movie II: A proof with PVS. </title> <type> Technical report, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <year> 1995. </year> <month> Forthcoming. </month>
Reference-contexts: The smaller examples include the specification and verification of ordered binary tree insertion [Sha93a], a compiler for simple arithmetic expressions <ref> [Rus95] </ref>, and several small hardware examples including pipeline and microcode correctness [CRSS94]. Examples of this scale can typically be completed within a day.
Reference: [RvHO91] <author> John Rushby, Friedrich von Henke, and Sam Owre. </author> <title> An introduction to formal specification and verification using Ehdm. </title> <type> Technical Report SRI-CSL-91-2, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1991. </year>
Reference-contexts: PVS is the most recent in a line of specification languages, theorem provers, and verification systems developed at SRI, dating back over 20 years. That line includes the Jovial Verification System [EGMS79], the Hierarchical Development Methodology (HDM) [RL76, RLS79], STP [SSMS82], and EHDM <ref> [MSR85, RvHO91] </ref>. We call PVS a "Prototype Verification System," because it was built partly as a lightweight prototype to explore "next generation" technology for EHDM, our main, heavyweight, verification system.
Reference: [Sha93a] <author> N. Shankar. </author> <title> Abstract datatypes in PVS. </title> <type> Technical Report SRI-CSL-93-9, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: The smaller examples include the specification and verification of ordered binary tree insertion <ref> [Sha93a] </ref>, a compiler for simple arithmetic expressions [Rus95], and several small hardware examples including pipeline and microcode correctness [CRSS94]. Examples of this scale can typically be completed within a day.
Reference: [Sha93b] <author> Natarajan Shankar. </author> <title> Verification of real-time systems using PVS. </title> <booktitle> In Courcou-betis [Cou93], </booktitle> <pages> pages 280-291. </pages>
Reference-contexts: Examples of this scale can typically be completed within a day. More substantial examples include the correctness of a real-time railroad crossing controller <ref> [Sha93b] </ref>, an embedding of the Duration Calculus [SS94], the correctness of some transformations used in digital syntheses [Raj94], and the correctness of distributed agreement protocols for a hybrid fault model consisting of Byzantine, symmetric, and crash faults [LR93a, LR93b, LR94].
Reference: [SOR93] <author> N. Shankar, S. Owre, and J. M. Rushby. </author> <title> The PVS Proof Checker: A Reference Manual. </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year> <note> A new edition for PVS Version 2 is expected in early 1995. </note>
Reference-contexts: More realistic examples are provided in Section 5. The PVS language, system, and theorem prover each have their own reference manuals <ref> [OSR93a, SOR93, OSR93b] </ref>, which you will need to study in order to make productive use of the system. A pocket reference card, summarizing all the features of the PVS language, system, and prover is also available. <p> The commands needed to prove this theorem constitute only a very small subset of the commands available to the prover; more details can be found in the prover guide <ref> [SOR93] </ref>. First, notice the display (reproduced below), which consists of a single formula (labeled f1g) under a dashed line. This is a sequent; formulas above the dashed lines are called antecedents and those below are called succedents. <p> There is more discussion of this in the prover guide <ref> [SOR93] </ref>. 36 Using PVS A Brief Tour of PVS this yields 2 subgoals: closed_form.1 : |------- Rule? (postpone) Postponing closed_form.1. closed_form.2 : |------- f1g (FORALL (j: nat): sum (j) = (j * (j + 1)) / 2 IMPLIES sum (j + 1) = ((j + 1) * (j + 1 + <p> Section 4.2 provides the basic information needed to get started with the PVS proof checker. The remaining sections give a collection of typical examples of how the proof checker is used. The PVS Proof Checker Reference Manual <ref> [SOR93] </ref> contains detailed descriptions of the PVS proof commands. 4.2 Preliminaries Sequent Representation of Proof Goals. Each goal or subgoal in a PVS proof attempt is a sequent of the form ` , where is a sequence of antecedent formulas and is a sequence of consequent formulas. <p> Other Commands. We have described some typical commands, but have not mentioned many others. A partial account of some of those we've omitted is given below; a complete, annotated list of prover commands can be found in The PVS Prover Checker Reference Manual <ref> [SOR93] </ref>. The lemma command is used to bring in an instance of a lemma as an antecedent sequent formula. The extensionality proof command is similarly used to bring in the extensionality scheme given a suitable type expression, i.e., a function, record, or tuple type or an abstract datatype. <p> User-defined proof strategies , similar to the tactics and tacticals of LCF, can be employed by more advanced PVS users. A file containing definitions of basic strategies is distributed with PVS and provides a good introduction to this topic. The PVS Prover Checker Reference Manual <ref> [SOR93] </ref> can be consulted for additional information on user-defined proof strategies.
Reference: [SS94] <author> Jens U. Skakkebk and N. Shankar. </author> <title> Towards a Duration Calculus proof assistant in PVS. </title> <editor> In Langmaack et al. </editor> <booktitle> [LdV94], </booktitle> <pages> pages 660-679. </pages>
Reference-contexts: Examples of this scale can typically be completed within a day. More substantial examples include the correctness of a real-time railroad crossing controller [Sha93b], an embedding of the Duration Calculus <ref> [SS94] </ref>, the correctness of some transformations used in digital syntheses [Raj94], and the correctness of distributed agreement protocols for a hybrid fault model consisting of Byzantine, symmetric, and crash faults [LR93a, LR93b, LR94]. These harder examples can take from several days to several weeks.
Reference: [SSMS82] <author> R. E. Shostak, R. Schwartz, and P. M. Melliar-Smith. STP: </author> <title> A mechanized logic for specification and verification. </title> <editor> In D. Loveland, editor, </editor> <booktitle> 6th International Conference on Automated Deduction (CADE), </booktitle> <address> New York, NY, </address> <year> 1982. </year> <booktitle> Volume 138 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: PVS is the most recent in a line of specification languages, theorem provers, and verification systems developed at SRI, dating back over 20 years. That line includes the Jovial Verification System [EGMS79], the Hierarchical Development Methodology (HDM) [RL76, RLS79], STP <ref> [SSMS82] </ref>, and EHDM [MSR85, RvHO91]. We call PVS a "Prototype Verification System," because it was built partly as a lightweight prototype to explore "next generation" technology for EHDM, our main, heavyweight, verification system.
Reference: [SSR95] <author> Mandayam Srivas, Natarajan Shankar, and Sreeranga Rajan. </author> <title> Hardware verification using PVS: A tutorial. </title> <type> Technical report, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <year> 1995. </year> <month> Forthcoming. 112 </month>
Reference-contexts: Formal Specification PVS specifications consist of a number of files, each of which contains one or more theories. The microprocessor specification is organized into three theories, selected parts of which are shown in Figures 12 and 13. (The complete specification can be found in <ref> [SSR95] </ref>.) The theory pipe (Figure 12) contains a specification of the design and a statement of the correctness property to be proved. The theories signal and time, (Figure 13) imported by pipe, declares the types signal and time used in pipe. <p> An automatic way of performing this translation is discussed in <ref> [SSR95] </ref>, which illustrates more examples of hardware design verification using PVS. Returning to our example, the microprocessor specification in pipe consists of two parts. The first part declares all the signals used in the design|the inputs to the design and the internal wires that denote the outputs of components.
References-found: 49

