URL: http://www2.cs.cornell.edu/faculty/home/jgm/papers/fpca_gc.ps
Refering-URL: http://www2.cs.cornell.edu/faculty/home/jgm/home.html
Root-URL: 
Email: jgmorris@cs.cmu.edu matthias@cs.rice.edu rwh@cs.cmu.edu  
Title: Abstract Models of Memory Management  
Author: Greg Morrisett Matthias Felleisen Robert Harper 
Affiliation: Carnegie Mellon Rice University Carnegie Mellon  
Abstract: We develop a series of calculi that are just low-level enough that we can express allocation and garbage collection, yet are sufficiently abstract that we may formally prove the correctness of various memory management strategies. By making the heap of a program syntactically apparent, we can specify memory actions as rewriting rules that allocate values on the heap and automatically dereference pointers to such objects when needed. This formulation permits the specification of garbage collection as a relation that removes portions of the heap without affecting the outcome of the evaluation. Our high-level approach allows us to specify in a compact manner a wide variety of memory management techniques, including standard trace-based garbage collection (i.e., the family of copying and mark/sweep collection algorithms), generational collection, and type-based, tag-free collection. Furthermore, since the definition of garbage is based on the semantics of the underlying language instead of the conservative approximation of inaccessibility, we are able to specify and prove the idea that type inference can be used to collect some objects that are accessible but never used. fl This work was sponsored in part by the Advanced Research Projects Agency (ARPA), CSTO, under the title "The Fox Project: Advanced Development of Systems Software," ARPA Order No. 8313, issued by ESD/AVS under Contract No. F19628-91-C-0168, Wright Laboratory, Aeronautical Systems Center, Air Force Materiel Command, USAF, and ARPA grant No. F33615-93-1-1330. Views and conclusions contained in this document are those of the authors and should not be interpreted as necessarily representing official policies or endorsements, either expressed or implied, of Wright Laboratory or the United States Government. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Aditya and A. Caro. </author> <title> Compiler-directed type reconstruction for polymorphic languages. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 74-82, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: fx:t g; H t ; t i mono =) f ; 0 t i with appropriate 0 t and 0 2 Extending the mono-a collection algorithm to work for a language with explicit polymorphism, where types are passed to polymorphic routines at run time as suggested by various language implementors <ref> [21, 1, 27, 15] </ref>, is straightforward because enough information is preserved by evaluation to always reconstruct the type of a polymorphic object. <p> Aditya and Caro gave a type-recovery algorithm for an implementation of Id that uses a technique that appears to be equivalent to type passing <ref> [1] </ref> and Aditya, Flood, and Hicks extended this work to garbage collection for Id [2]. Over the past few years, a number of papers on inference-based collection in monomorphic [7, 29, 8] and polymorphic [3, 13, 14, 12] languages appeared in the literature.
Reference: [2] <author> S. Aditya, C. Flood, and J. Hicks. </author> <title> Garbage collection for strongly-typed languages using run-time type reconstruction. </title> <booktitle> In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 12-23, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: If types are determined at compile time and evaluation maintains enough information that the types of reachable objects can always be recovered, then there is no need to tag values. A number of researchers have made attempts to explore this alternative <ref> [7, 8, 3, 13, 27, 2] </ref>, but none of them presented concise characterizations of the underlying techniques with correctness proofs. In this section, we present the basic idea behind type-recovery based garbage collection. We then introduce gc-mono, an explicitly typed, monomorphic variant of gc. <p> Aditya and Caro gave a type-recovery algorithm for an implementation of Id that uses a technique that appears to be equivalent to type passing [1] and Aditya, Flood, and Hicks extended this work to garbage collection for Id <ref> [2] </ref>. Over the past few years, a number of papers on inference-based collection in monomorphic [7, 29, 8] and polymorphic [3, 13, 14, 12] languages appeared in the literature.
Reference: [3] <author> A. W. Appel. </author> <title> Runtime tags aren't necessary. </title> <journal> Journal of Lisp and Symbolic Computation, </journal> <volume> 2 </volume> <pages> 153-162, </pages> <year> 1989. </year>
Reference-contexts: In Section 5, we justify our semantic definition of garbage by showing that Milner-style type inference can be used to prove that an object is semantically garbage even though the object is still reachable. While previous authors have sketched this idea <ref> [3, 5, 14, 12] </ref>, we are the first to present a formal proof of this result. The proof is obtained by casting the well known interpretation of types as logical relations into our framework. Section 6 discusses related work and Section 7 closes with a summary. <p> If types are determined at compile time and evaluation maintains enough information that the types of reachable objects can always be recovered, then there is no need to tag values. A number of researchers have made attempts to explore this alternative <ref> [7, 8, 3, 13, 27, 2] </ref>, but none of them presented concise characterizations of the underlying techniques with correctness proofs. In this section, we present the basic idea behind type-recovery based garbage collection. We then introduce gc-mono, an explicitly typed, monomorphic variant of gc. <p> Over the past few years, a number of papers on inference-based collection in monomorphic [7, 29, 8] and polymorphic <ref> [3, 13, 14, 12] </ref> languages appeared in the literature. <p> Over the past few years, a number of papers on inference-based collection in monomorphic [7, 29, 8] and polymorphic [3, 13, 14, 12] languages appeared in the literature. Appel <ref> [3] </ref> argued informally that "tag-free" collection is possible for polymorphic languages such as SML by a combination of recording information statically and performing what amounts to type inference during the collection process, though the connections between inference and collection were not made clear.
Reference: [4] <author> Z. M. Ariola, M. Felleisen, J. Maraist, M. Odersky, and P. Wadler. </author> <title> A call-by-need lambda calculus. </title> <booktitle> In Conference Record of the 22nd Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Finally, Purushothaman and Seaman [23, 25] and Launchbury [17] have proposed "natural" semantics for call-by-need (lazy) languages where the semantic objects include an explicit heap. This allows sharing and memoization of computations to be expressed in the semantics. More recently, Ariola et al. <ref> [4] </ref> have presented a purely syntactic theory of the call-by-need -calculus that is largely compatible with our work. 7 Summary and Future Work Our paper provides a unifying framework for a variety of garbage collection ideas including standard copying and mark-sweep collection, generational collection, tag-free collection, and inference-based collection.
Reference: [5] <author> H. Baker. </author> <title> Unify and conquer (garbage, updating, aliasing ...) in functional languages. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 218-226, </pages> <address> Nice, France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: In Section 5, we justify our semantic definition of garbage by showing that Milner-style type inference can be used to prove that an object is semantically garbage even though the object is still reachable. While previous authors have sketched this idea <ref> [3, 5, 14, 12] </ref>, we are the first to present a formal proof of this result. The proof is obtained by casting the well known interpretation of types as logical relations into our framework. Section 6 discusses related work and Section 7 closes with a summary. <p> Appel [3] argued informally that "tag-free" collection is possible for polymorphic languages such as SML by a combination of recording information statically and performing what amounts to type inference during the collection process, though the connections between inference and collection were not made clear. Baker <ref> [5] </ref> recognized that Milner-style type inference can be used to prove that reachable objects can be safely collected, but did not give a formal account of this result.
Reference: [6] <author> E. Barendsen and S. Smetsers. </author> <title> Conventional and uniqueness typing in graph rewrite systems. </title> <booktitle> In Proceedings of the 13th Conference on the Foundations of Software Technology and Theoretical Computer Science 1993, </booktitle> <address> Bombay, New York, NY, </address> <year> 1993. </year> <note> Springer-Verlag. Extended abstract. </note>
Reference-contexts: Their low-level semantics specifies explicit memory management based on reference counting. Both Hudak and Chirimar et al. assume a weak approximation of garbage (reference counts). Barendsen and Smet-sers give a Curry-like type system for functional languages extended with uniqueness information that guarantees an object is only "locally acccessible" <ref> [6] </ref>. This provides a compiler enough information to determine when certain objects may be garbage collected or over-written.
Reference: [7] <author> P. Branquart and J. Lewi. </author> <title> A scheme for storage allocation and garbage collection for Algol-68. In Algol-68 Implementation. </title> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1970. </year>
Reference-contexts: We prove that the free-variable rule is correct and provide two "implementations" at the syntactic level: the first corresponds to a copying collector, the second to a generational one. In Section 4, we formalize so-called "tag-free" collection algorithms for explicitly-typed, monomorphic languages such as Pascal and Algol <ref> [7, 29, 8] </ref>. We show how to recover necessary shape information about values from types during garbage collection. We are able to prove the correctness of the garbage collection algorithm by using a well known type preservation argument. <p> If types are determined at compile time and evaluation maintains enough information that the types of reachable objects can always be recovered, then there is no need to tag values. A number of researchers have made attempts to explore this alternative <ref> [7, 8, 3, 13, 27, 2] </ref>, but none of them presented concise characterizations of the underlying techniques with correctness proofs. In this section, we present the basic idea behind type-recovery based garbage collection. We then introduce gc-mono, an explicitly typed, monomorphic variant of gc. <p> Over the past few years, a number of papers on inference-based collection in monomorphic <ref> [7, 29, 8] </ref> and polymorphic [3, 13, 14, 12] languages appeared in the literature.
Reference: [8] <author> D. E. Britton. </author> <title> Heap storage management for the programming language Pascal. </title> <type> Master's thesis, </type> <institution> University of Arizona, </institution> <year> 1975. </year>
Reference-contexts: We prove that the free-variable rule is correct and provide two "implementations" at the syntactic level: the first corresponds to a copying collector, the second to a generational one. In Section 4, we formalize so-called "tag-free" collection algorithms for explicitly-typed, monomorphic languages such as Pascal and Algol <ref> [7, 29, 8] </ref>. We show how to recover necessary shape information about values from types during garbage collection. We are able to prove the correctness of the garbage collection algorithm by using a well known type preservation argument. <p> If types are determined at compile time and evaluation maintains enough information that the types of reachable objects can always be recovered, then there is no need to tag values. A number of researchers have made attempts to explore this alternative <ref> [7, 8, 3, 13, 27, 2] </ref>, but none of them presented concise characterizations of the underlying techniques with correctness proofs. In this section, we present the basic idea behind type-recovery based garbage collection. We then introduce gc-mono, an explicitly typed, monomorphic variant of gc. <p> Over the past few years, a number of papers on inference-based collection in monomorphic <ref> [7, 29, 8] </ref> and polymorphic [3, 13, 14, 12] languages appeared in the literature.
Reference: [9] <author> J. Chirimar, C. A. Gunter, and J. G. Riecke. </author> <title> Proving memory management invariants for a language based on linear logic. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 139-150, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: He presents an abstraction of the model and gives an algorithm for computing approximations of reference counts statically. Chirimar, Gunter, and Riecke give a framework for proving invariants regarding memory management for a language with a linear type system <ref> [9] </ref>. Their low-level semantics specifies explicit memory management based on reference counting. Both Hudak and Chirimar et al. assume a weak approximation of garbage (reference counts). Barendsen and Smet-sers give a Curry-like type system for functional languages extended with uniqueness information that guarantees an object is only "locally acccessible" [6].
Reference: [10] <author> A. Demers, M. Weiser, B. Hayes, H. Boehm, D. Bobrow, and S. Shenker. </author> <title> Combining generational and conservative garbage collection: Framework and implementations. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 261-269, </pages> <address> San Francisco, CA, </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: Demers et al. <ref> [10] </ref> give a model of memory parameterized by an abstract notion of a "points-to" relation. As a result, they can characterize reachability-based algorithms including mark-sweep, copying, generational, "conservative," and other sophisticated forms of garbage collection.
Reference: [11] <author> M. Felleisen and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <type> Technical Report 89-100, </type> <institution> Rice University, </institution> <month> June </month> <year> 1989. </year> <note> Also appears in: Theoretical Computer Science, 102, </note> <year> 1992. </year>
Reference-contexts: Since garbage collectors work on the machine representations of abstract values, the very idea of providing a proof of memory safety sounds unrealistic given the lack of simple models of memory operations. The recently developed syntactic approaches to the specification of language semantics by Felleisen and Hieb <ref> [11] </ref> and Mason and Talcott [18, 19] are the first execution models that are intensional enough to permit the specification of memory management actions and yet are sufficiently abstract to permit compact proofs of important properties. <p> We use X n X 0 to denote fx 2 X j x 62 X 0 g. Semantics: The rewriting semantics for gc is an adaptation of the standard reduction function of the v -S calcu lus <ref> [11] </ref>. Roughly speaking, this kind of semantics describes an abstract machine whose states are programs and whose instructions are relations between programs. The desired final state of this abstract machine is an answer program (A) whose body is a pointer to some value, such as an integer, in the heap. <p> Put differently, the evaluation process defines a partial function from gc programs to irreducible programs <ref> [11, 30] </ref>. A Semantic Definition of Garbage Since the semantics of gc makes the allocation of values explicit, including the implicit pointer dereferencing in the language, we can also define what it means to garbage collect a value in the heap and then analyze some basic properties. <p> Most garbage collectors compute the reachable set of bindings in a program given the variables in use in the current instruction expression and control state. All reachable bindings are preserved; the others are eliminated. Following Felleisen and Hieb <ref> [11] </ref>, reachability in gc is formalized by considering free variables.
Reference: [12] <author> P. Fradet. </author> <title> Collecting more garbage. </title> <booktitle> In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 24-33, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: In Section 5, we justify our semantic definition of garbage by showing that Milner-style type inference can be used to prove that an object is semantically garbage even though the object is still reachable. While previous authors have sketched this idea <ref> [3, 5, 14, 12] </ref>, we are the first to present a formal proof of this result. The proof is obtained by casting the well known interpretation of types as logical relations into our framework. Section 6 discusses related work and Section 7 closes with a summary. <p> Over the past few years, a number of papers on inference-based collection in monomorphic [7, 29, 8] and polymorphic <ref> [3, 13, 14, 12] </ref> languages appeared in the literature. <p> They gave an informal argument based on traversal of stack frames to show that such values are semantically garbage. Fradet <ref> [12] </ref> gave another argument based on Reynolds's abstraction/parametricity theorem [24]. Fradet's formulation is closer to ours than Goldberg and Gloger's, since he represented the evaluation "stack" as a source-language term.
Reference: [13] <author> B. Goldberg. </author> <title> Tag-free garbage collection for strongly typed programming languages. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 165-176, </pages> <address> Toronto, Ontario, Canada, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: If types are determined at compile time and evaluation maintains enough information that the types of reachable objects can always be recovered, then there is no need to tag values. A number of researchers have made attempts to explore this alternative <ref> [7, 8, 3, 13, 27, 2] </ref>, but none of them presented concise characterizations of the underlying techniques with correctness proofs. In this section, we present the basic idea behind type-recovery based garbage collection. We then introduce gc-mono, an explicitly typed, monomorphic variant of gc. <p> Over the past few years, a number of papers on inference-based collection in monomorphic [7, 29, 8] and polymorphic <ref> [3, 13, 14, 12] </ref> languages appeared in the literature.
Reference: [14] <author> B. Goldberg and M. Gloger. </author> <title> Polymorphic type reconstruction for garbage collection without tags. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 53-65, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: In Section 5, we justify our semantic definition of garbage by showing that Milner-style type inference can be used to prove that an object is semantically garbage even though the object is still reachable. While previous authors have sketched this idea <ref> [3, 5, 14, 12] </ref>, we are the first to present a formal proof of this result. The proof is obtained by casting the well known interpretation of types as logical relations into our framework. Section 6 discusses related work and Section 7 closes with a summary. <p> Over the past few years, a number of papers on inference-based collection in monomorphic [7, 29, 8] and polymorphic <ref> [3, 13, 14, 12] </ref> languages appeared in the literature. <p> Baker [5] recognized that Milner-style type inference can be used to prove that reachable objects can be safely collected, but did not give a formal account of this result. Goldberg and Gloger <ref> [14] </ref> recognized that it is not possible to reconstruct the concrete types of all reachable values in an implementation of an ML-style language that does not pass types to polymorphic routines. They gave an informal argument based on traversal of stack frames to show that such values are semantically garbage.
Reference: [15] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Conference Record of the 22nd Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: fx:t g; H t ; t i mono =) f ; 0 t i with appropriate 0 t and 0 2 Extending the mono-a collection algorithm to work for a language with explicit polymorphism, where types are passed to polymorphic routines at run time as suggested by various language implementors <ref> [21, 1, 27, 15] </ref>, is straightforward because enough information is preserved by evaluation to always reconstruct the type of a polymorphic object.
Reference: [16] <author> P. Hudak. </author> <title> A semantic model of reference counting and its abstraction. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 351-363, </pages> <address> Cam-bridge, MA, </address> <year> 1986. </year>
Reference-contexts: Nettles [22] provides a concrete specification of a copying garbage collection algorithm using the Larch specification language. Our specification of the free-variable tracing algorithm is essentially a high-level, one-line description of his specification. Hudak gives a denotational model that tracks reference counts for a first-order language <ref> [16] </ref>. He presents an abstraction of the model and gives an algorithm for computing approximations of reference counts statically. Chirimar, Gunter, and Riecke give a framework for proving invariants regarding memory management for a language with a linear type system [9].
Reference: [17] <author> J. Launchbury. </author> <title> A natural semantics for lazy evaluation. </title> <booktitle> In Conference Record of the 20th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Charleston, SC, </address> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: However, none of these papers give a complete formulation of the underlying dynamic and static semantics of the language and thus the proofs of correctness are necessarily ad hoc. Finally, Purushothaman and Seaman [23, 25] and Launchbury <ref> [17] </ref> have proposed "natural" semantics for call-by-need (lazy) languages where the semantic objects include an explicit heap. This allows sharing and memoization of computations to be expressed in the semantics.
Reference: [18] <author> I. Mason and C. Talcott. </author> <title> Reasoning about programs with effects. </title> <booktitle> In Proceedings of Programming Language Implementation and Logic Programming, </booktitle> <publisher> LNCS 582. Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The recently developed syntactic approaches to the specification of language semantics by Felleisen and Hieb [11] and Mason and Talcott <ref> [18, 19] </ref> are the first execution models that are intensional enough to permit the specification of memory management actions and yet are sufficiently abstract to permit compact proofs of important properties.
Reference: [19] <author> I. Mason and C. Talcott. </author> <title> Equivalences in functional languages with effects. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(1), </volume> <year> 1991. </year>
Reference-contexts: The recently developed syntactic approaches to the specification of language semantics by Felleisen and Hieb [11] and Mason and Talcott <ref> [18, 19] </ref> are the first execution models that are intensional enough to permit the specification of memory management actions and yet are sufficiently abstract to permit compact proofs of important properties.
Reference: [20] <author> G. Morrisett, M. Felleisen, and R. Harper. </author> <title> Abstract models of memory management. </title> <type> Technical Report CMU-CS-95-110, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> Jan. </month> <year> 1995. </year> <note> Available as ftp://reports.adm.cs.cmu.edu/usr/anon/1995/CMU-CS95-110.ps. </note>
Reference-contexts: Section 6 discusses related work and Section 7 closes with a summary. Due to a lack of space, most of the proofs for lemmas are omitted in this paper. However, full details may be recovered from our companion technical report <ref> [20] </ref>. 2 Modeling Allocation: gc Syntax: The syntax of gc (see Figure 1) is that of a conventional, higher-order, applicative programming language based on the -calculus. Following the tradition of functional programming, a gc program (P ) consists of some mutually recursive definitions (H) and an expression (e). <p> In our technical report <ref> [20] </ref>, we show how this may be accomplished. 5 Collecting Reachable Garbage Using Type Inference Thus far, we have only considered specifications and algorithms for collecting unreachable bindings.
Reference: [21] <author> R. Morrison, A. Dearle, R. C. H. Connor, and A. L. Brown. </author> <title> An ad hoc approach to the implementation of polymorphism. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 13(3) </volume> <pages> 342-371, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: fx:t g; H t ; t i mono =) f ; 0 t i with appropriate 0 t and 0 2 Extending the mono-a collection algorithm to work for a language with explicit polymorphism, where types are passed to polymorphic routines at run time as suggested by various language implementors <ref> [21, 1, 27, 15] </ref>, is straightforward because enough information is preserved by evaluation to always reconstruct the type of a polymorphic object.
Reference: [22] <author> S. Nettles. </author> <title> A Larch specification of copying garbage collection. </title> <type> Technical Report CMU-CS-92-219, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: However, their model is intentionally divorced from the programming language and cannot take advantage of any semantic properties of evaluation, such as type preser-vation. Consequently, their framework cannot model the type-based collectors of Sections 4 and 5. Nettles <ref> [22] </ref> provides a concrete specification of a copying garbage collection algorithm using the Larch specification language. Our specification of the free-variable tracing algorithm is essentially a high-level, one-line description of his specification. Hudak gives a denotational model that tracks reference counts for a first-order language [16].
Reference: [23] <author> Purushothaman and J. Seaman. </author> <title> An adequate operational semantics of sharing in lazy evaluation. </title> <booktitle> In Proceedings of the 4th European Symposium on Programming, </booktitle> <publisher> LNCS 582. Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: However, none of these papers give a complete formulation of the underlying dynamic and static semantics of the language and thus the proofs of correctness are necessarily ad hoc. Finally, Purushothaman and Seaman <ref> [23, 25] </ref> and Launchbury [17] have proposed "natural" semantics for call-by-need (lazy) languages where the semantic objects include an explicit heap. This allows sharing and memoization of computations to be expressed in the semantics.
Reference: [24] <author> J. Reynolds. </author> <title> Types, abstraction, and parametric polymor-phism. </title> <booktitle> In Proceedings of Information Processing 83, </booktitle> <pages> pages 513-523, </pages> <year> 1983. </year>
Reference-contexts: They gave an informal argument based on traversal of stack frames to show that such values are semantically garbage. Fradet [12] gave another argument based on Reynolds's abstraction/parametricity theorem <ref> [24] </ref>. Fradet's formulation is closer to ours than Goldberg and Gloger's, since he represented the evaluation "stack" as a source-language term. However, none of these papers give a complete formulation of the underlying dynamic and static semantics of the language and thus the proofs of correctness are necessarily ad hoc.
Reference: [25] <author> J. M. Seaman. </author> <title> An Operational Semantics of Lazy Evaluation for Analysis. </title> <type> PhD thesis, </type> <institution> Pennsylvania State University, </institution> <year> 1993. </year>
Reference-contexts: However, none of these papers give a complete formulation of the underlying dynamic and static semantics of the language and thus the proofs of correctness are necessarily ad hoc. Finally, Purushothaman and Seaman <ref> [23, 25] </ref> and Launchbury [17] have proposed "natural" semantics for call-by-need (lazy) languages where the semantic objects include an explicit heap. This allows sharing and memoization of computations to be expressed in the semantics.
Reference: [26] <author> P. Steenkiste and J. Hennessey. </author> <title> Tags and type checking in LISP: Hardware and software approaches. </title> <booktitle> In Proceedings of the Second International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-II), </booktitle> <pages> pages 50-59, </pages> <address> Palo Alto, CA, </address> <month> Oct. </month> <year> 1987. </year>
Reference-contexts: This allows us to navigate through the memory unambiguously, but placing tags on heap values and stripping them off to perform a computation can impose a heavy overhead on the running time and space requirements of programs <ref> [26] </ref>. An alternative to tagging is the use of types to determine the shape of an object. If types are determined at compile time and evaluation maintains enough information that the types of reachable objects can always be recovered, then there is no need to tag values.
Reference: [27] <author> A. Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: If types are determined at compile time and evaluation maintains enough information that the types of reachable objects can always be recovered, then there is no need to tag values. A number of researchers have made attempts to explore this alternative <ref> [7, 8, 3, 13, 27, 2] </ref>, but none of them presented concise characterizations of the underlying techniques with correctness proofs. In this section, we present the basic idea behind type-recovery based garbage collection. We then introduce gc-mono, an explicitly typed, monomorphic variant of gc. <p> fx:t g; H t ; t i mono =) f ; 0 t i with appropriate 0 t and 0 2 Extending the mono-a collection algorithm to work for a language with explicit polymorphism, where types are passed to polymorphic routines at run time as suggested by various language implementors <ref> [21, 1, 27, 15] </ref>, is straightforward because enough information is preserved by evaluation to always reconstruct the type of a polymorphic object. <p> Barendsen and Smet-sers give a Curry-like type system for functional languages extended with uniqueness information that guarantees an object is only "locally acccessible" [6]. This provides a compiler enough information to determine when certain objects may be garbage collected or over-written. Tolmach <ref> [27] </ref> built a type-recovery collector for a variant of SML that passes type information to polymorphic routines during execution, effectively implementing a polymorphic version of our language and collector described in Section 4.
Reference: [28] <author> D. Ungar. </author> <title> Generational scavenging: A non-disruptive high performance storage management reclamation algorithm. </title> <booktitle> In ACM SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 15-167, </pages> <address> Pittsburgh, PA, </address> <month> Apr. </month> <year> 1984. </year>
Reference-contexts: The third reason generational collection is important is that empirical evidence shows that "objects tend to die young" <ref> [28] </ref>. That is, recently allocated bindings are more likely to become garbage in a small number of evaluation steps.
Reference: [29] <author> P. Wodon. </author> <title> Methods of garbage collection for Algol-68. In Algol-68 Implementation. </title> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1970. </year>
Reference-contexts: We prove that the free-variable rule is correct and provide two "implementations" at the syntactic level: the first corresponds to a copying collector, the second to a generational one. In Section 4, we formalize so-called "tag-free" collection algorithms for explicitly-typed, monomorphic languages such as Pascal and Algol <ref> [7, 29, 8] </ref>. We show how to recover necessary shape information about values from types during garbage collection. We are able to prove the correctness of the garbage collection algorithm by using a well known type preservation argument. <p> Over the past few years, a number of papers on inference-based collection in monomorphic <ref> [7, 29, 8] </ref> and polymorphic [3, 13, 14, 12] languages appeared in the literature.
Reference: [30] <author> A. Wright and M. Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report TR91-160, </type> <institution> Department of Computer Science, Rice University, </institution> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: Put differently, the evaluation process defines a partial function from gc programs to irreducible programs <ref> [11, 30] </ref>. A Semantic Definition of Garbage Since the semantics of gc makes the allocation of values explicit, including the implicit pointer dereferencing in the language, we can also define what it means to garbage collect a value in the heap and then analyze some basic properties. <p> The third judgement, . P , asserts the well-typing of a complete program. The calculus gc-mono is type sound in that evaluation of well formed programs cannot get stuck <ref> [30] </ref>. A key to the proof of soundness is a type preservation lemma: Lemma 4.2 (Type Preservation) If . P and P RM then . P 0 . Theorem 4.3 (Type Soundness) If .
References-found: 30

