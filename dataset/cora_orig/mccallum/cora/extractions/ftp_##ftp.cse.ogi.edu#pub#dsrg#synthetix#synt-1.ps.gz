URL: ftp://ftp.cse.ogi.edu/pub/dsrg/synthetix/synt-1.ps.gz
Refering-URL: http://www.cse.ogi.edu/~calton/publication.html
Root-URL: http://www.cse.ogi.edu
Title: The Synthesis Kernel  
Author: by Calton Pu, Henry Massalin, and John Ioannidis 
Address: New York, NY 10027  
Affiliation: Department of Computer Science Columbia University  
Abstract: The Synthesis distributed operating system combines efficient kernel calls with a high-level, orthogonal interface. The key idea is the use of a code synthesizer in the kernel to generate specialized (thus short and fast) kernel routines for specific situations. We have three methods to synthesize code: Factoring Invariants to bypass redundant computations; Collapsing Layers to eliminate unnecessary procedure calls and context switches; and Executable Data Structures to shorten data structure traversal time. Applying these methods, the kernel call synthesized to read /dev/mem takes about 15 microseconds on a 68020 machine. A simple model of computation called a synthetic machine supports parallel and distributed processing. The interface to synthetic machine consists of six operations on four kinds of objects. This combination of a high-level interface with the code synthesizer avoids the traditional trade-off in operating systems between powerful interfaces and efficient implementations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: a new kernel foundation for Unix development. </title> <booktitle> In Proceedings of the 1986 Usenix Conference, </booktitle> <pages> pages 93-112, </pages> <publisher> Usenix Association, </publisher> <year> 1986. </year> <month> 13 </month>
Reference-contexts: Systems with high-level interfaces and powerful features, like Argus [10] and Eden [2], require a lot of code for their implementation, and this added overhead makes the systems slow. Systems with simple kernel calls, like the V kernel [8], Amoeba [15], and Mach <ref> [1] </ref>, have little overhead and run fast. However, the application software then becomes more complex and slower because extra code is required to make up for the missing kernel functions. Our goal in developing the Synthesis distributed operating system is to escape from this trade-off. <p> Some examples are the virtual machine in VM/370 and the Unix process, which are similar to a synthetic machine with only one SCPU, or Mach tasks <ref> [1] </ref> and Distributed V teams [7], which are similar to multiple synthetic CPUs. <p> Synthetic machines and synthetic components are encapsulated resources, and users must ask them to perform the kernel calls defined in Table 1. Pioneer object-oriented systems such as Hydra [16], Eden [2], and Argus [10] have achieved performance adequate for a prototype, while Mach is comparable to BSD Unix <ref> [1] </ref>. We believe that synthesized code will take the performance of Synthesis one step ahead of current systems. <p> The V kernel [7] and Amoeba [15] are two examples of small distributed operating system kernels. They both encourage layers of software to be written on top of the kernel. Synthesis differs from both by the high-level synthetic machine interface, and the code synthesizer. Mach <ref> [1] </ref> offers an object-oriented interface that is isomorphic to a specialized synthetic machine. A Mach task corresponds to a synthetic machine; Mach thread, an SCPU; Mach port, the network SIO; Mach messages, network SIO read and write; and Mach virtual memory, an SMem.
Reference: [2] <author> G.T. Almes, A.P. Black, E.D. Lazowska, and J.D. Noe. </author> <title> The Eden system: a technical review. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(1):43-58, </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: 1 Introduction A trade-off between powerful features and efficient implementation exists in many operating systems. Systems with high-level interfaces and powerful features, like Argus [10] and Eden <ref> [2] </ref>, require a lot of code for their implementation, and this added overhead makes the systems slow. Systems with simple kernel calls, like the V kernel [8], Amoeba [15], and Mach [1], have little overhead and run fast. <p> The synthetic machine interface is object-oriented. Synthetic machines and synthetic components are encapsulated resources, and users must ask them to perform the kernel calls defined in Table 1. Pioneer object-oriented systems such as Hydra [16], Eden <ref> [2] </ref>, and Argus [10] have achieved performance adequate for a prototype, while Mach is comparable to BSD Unix [1]. We believe that synthesized code will take the performance of Synthesis one step ahead of current systems.
Reference: [3] <author> James Arleth. </author> <title> A 68010 Multiuser Development System. </title> <type> Master's thesis, </type> <institution> The Cooper Union for the Advancement of Science and Art, </institution> <address> New York City, </address> <year> 1984. </year>
Reference-contexts: The Synthesis prototype runs on an experimental machine based on a 68020 processor at 20 MHz with a 16-bit-wide bus <ref> [3] </ref>. For debugging and measurements, the prototype hardware provides single-step and real-time trace facilities. In addition, a ROM-based monitor contains an assembler, a disassembler, and a process manager, with a C-style interface [11]. Other commercially available machines are SUN-3, Macintosh II, and similar products.
Reference: [4] <author> J.R. Bell. </author> <title> Threaded code. </title> <journal> Communications of ACM, </journal> <volume> 16(6) </volume> <pages> 370-372, </pages> <month> June </month> <year> 1973. </year>
Reference-contexts: To solve this problem, F create generates either in-line code or subroutine calls using a mechanism similar to threaded code <ref> [4] </ref>. Frequently invoked functions are expanded in-line into the user's synthetic machine and executed there. Rarely executed functions are stored in a common area, shared by all synthetic machines running threaded code. The decision of when to expand in-line is made by the programmer writing F create . <p> A single example does not "prove" our approach, but it shows how far code synthesis can go. In C, the program is: #include &lt;sio/SIO.h&gt; struct SIO_if *myfile, *SIO_create (); char buf <ref> [4] </ref>; int i; myfile = SIO_create ( FILEACCESS, "/dev/mem", FA_RDONLY ); for (i=100000; i--; ) read ( myfile, buf, 1); SIO_terminate ( myfile ); A trace of the generated code running on the prototype is included in appendix A.
Reference: [5] <author> A. Black, N. Hutchinson, E. Jul, and H. Levy. </author> <title> Object structure in the Emerald system. </title> <booktitle> In Proceedings of the First Annual Conference on Object-Oriented Programming, Systems, Languages, and Applications, </booktitle> <pages> pages 78-86, </pages> <publisher> ACM, </publisher> <month> September </month> <year> 1986. </year>
Reference-contexts: The synthetic machine uses the same interface for all I/O activities, and child synthetic machines may be nested within a parent. As with other systems, Mach does not use a kernel code synthesizer. Emerald <ref> [5, 6] </ref> is an object-oriented, integrated language and system. Synthesis lacks the language support in Emerald, in particular the sophisticated typing system.
Reference: [6] <author> A. Black, N. Hutchinson, E. Jul, H. Levy, and L. Carter. </author> <title> Distribution and abstract types in Emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(12):65-76, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: The synthetic machine uses the same interface for all I/O activities, and child synthetic machines may be nested within a parent. As with other systems, Mach does not use a kernel code synthesizer. Emerald <ref> [5, 6] </ref> is an object-oriented, integrated language and system. Synthesis lacks the language support in Emerald, in particular the sophisticated typing system.
Reference: [7] <author> D. Cheriton. </author> <title> The V kernel: a software base for distributed systems. </title> <journal> IEEE Software, </journal> <volume> 1(2) </volume> <pages> 19-43, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: Some examples are the virtual machine in VM/370 and the Unix process, which are similar to a synthetic machine with only one SCPU, or Mach tasks [1] and Distributed V teams <ref> [7] </ref>, which are similar to multiple synthetic CPUs. <p> Although the interface remains approximately the same in the many different variants of Unix, the synthetic machine interface is more orthogonal. To the best of our knowledge, no Unix system uses a kernel code synthesizer. The V kernel <ref> [7] </ref> and Amoeba [15] are two examples of small distributed operating system kernels. They both encourage layers of software to be written on top of the kernel. Synthesis differs from both by the high-level synthetic machine interface, and the code synthesizer.
Reference: [8] <author> D. Cheriton and W. Zwaenepoel. </author> <title> The Distributed V kernel and its performance for diskless workstations. </title> <booktitle> In Proceedings of the Ninth Symposium on Operating Systems Principles, </booktitle> <pages> pages 129-140, </pages> <address> ACM/SIGOPS, </address> <month> October </month> <year> 1983. </year>
Reference-contexts: Systems with high-level interfaces and powerful features, like Argus [10] and Eden [2], require a lot of code for their implementation, and this added overhead makes the systems slow. Systems with simple kernel calls, like the V kernel <ref> [8] </ref>, Amoeba [15], and Mach [1], have little overhead and run fast. However, the application software then becomes more complex and slower because extra code is required to make up for the missing kernel functions. Our goal in developing the Synthesis distributed operating system is to escape from this trade-off.
Reference: [9] <author> Deitel H.M. </author> <title> An Introduction to Operating Systems. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> revised first edition, </address> <year> 1984. </year>
Reference-contexts: Each SIO provides input or output to the synthetic machine. Examples of SIO are ordinary files, devices, and network communications. An interesting example of a program running in a synthetic machine is a multiplexor supporting other synthetic machines to form a hierarchical structure similar to VM/370 <ref> [9] </ref>. Child synthetic machines are scheduled as any other SCPU, but they may "sub-schedule" their own SCPUs with different scheduling algorithms. Similarly, their SMEMs are allocated by the parent synthetic machine. The SIO system calls for the child synthetic machine are synthesized from the parent's SIO system calls.
Reference: [10] <author> B.H. Liskov and R.W. Scheifler. </author> <title> Guardians and Actions: linguistic support for robust, distributed programs. </title> <booktitle> In Proceedings of the Ninth Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 7-19, </pages> <month> January </month> <year> 1982. </year> <month> 14 </month>
Reference-contexts: 1 Introduction A trade-off between powerful features and efficient implementation exists in many operating systems. Systems with high-level interfaces and powerful features, like Argus <ref> [10] </ref> and Eden [2], require a lot of code for their implementation, and this added overhead makes the systems slow. Systems with simple kernel calls, like the V kernel [8], Amoeba [15], and Mach [1], have little overhead and run fast. <p> The synthetic machine interface is object-oriented. Synthetic machines and synthetic components are encapsulated resources, and users must ask them to perform the kernel calls defined in Table 1. Pioneer object-oriented systems such as Hydra [16], Eden [2], and Argus <ref> [10] </ref> have achieved performance adequate for a prototype, while Mach is comparable to BSD Unix [1]. We believe that synthesized code will take the performance of Synthesis one step ahead of current systems.
Reference: [11] <author> Henry Massalin. </author> <title> A 68010 Multitasking Development System. </title> <type> Master's thesis, </type> <institution> The Cooper Union for the Advancement of Science and Art, </institution> <address> New York City, </address> <year> 1984. </year>
Reference-contexts: For debugging and measurements, the prototype hardware provides single-step and real-time trace facilities. In addition, a ROM-based monitor contains an assembler, a disassembler, and a process manager, with a C-style interface <ref> [11] </ref>. Other commercially available machines are SUN-3, Macintosh II, and similar products. With multiple SCPUs in the same address space and SIOs to send/receive messages, Synthesis supports parallel machines of both shared-memory model and message-passing model. <p> Each implementation will emphasize performance, use the particular features of its own hardware, and maintain rigorous compatibility with the synthetic machine interface. 4.2 First Version of Software The first version of Synthesis kernel is being written incrementally on top of a small kernel <ref> [11] </ref>. At the moment, the Factoring Invariants method has been used in all input and output devices (SIO), including terminal I/O and a RAM-based file system. In the round-robin scheduler, the Executable Data Structures method provides fast context switch between synthetic machines and synthetic CPUs.
Reference: [12] <author> J.S. Quarterman, A. Silberschatz, and J.L. Peterson. </author> <title> 4.2BSD and 4.3BSD as examples of the Unix system. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 379-418, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: No other operating system offers a high-level interface and the potential to generate efficient code. Unix [13] has evolved into a large system with Fourth Berkeley Distribution <ref> [12] </ref> and AT&T System V. Although the interface remains approximately the same in the many different variants of Unix, the synthetic machine interface is more orthogonal. To the best of our knowledge, no Unix system uses a kernel code synthesizer.
Reference: [13] <author> D.M. Ritchie and K. Thompson. </author> <title> The Unix time-sharing system. </title> <journal> Communications of ACM, </journal> <volume> 7(7) </volume> <pages> 365-375, </pages> <month> July </month> <year> 1974. </year>
Reference-contexts: No other operating system offers a high-level interface and the potential to generate efficient code. Unix <ref> [13] </ref> has evolved into a large system with Fourth Berkeley Distribution [12] and AT&T System V. Although the interface remains approximately the same in the many different variants of Unix, the synthetic machine interface is more orthogonal.
Reference: [14] <author> J.E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> The MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: Let us consider a general function: F big (p1; p2; : : :; pn): By factoring out the parameter p1 through a process called currying <ref> [14] </ref>, we can obtain an equivalent composite function: [F create (p1)](p2; : : :; pn) F big (p1; p2; : : :; pn): 1 Unix is a trademark of AT&T Bell Laboratories. 2 F create is a second-order function.
Reference: [15] <author> A.S. Tanenbaum and S.J. Mullender. </author> <title> The Design of a Capability-Based Distributed Operating System. </title> <type> Technical Report IR-88, </type> <institution> Department of Mathematics and Computer Science, Vrije Univer-siteit Amsterdam, </institution> <month> November </month> <year> 1984. </year>
Reference-contexts: Systems with high-level interfaces and powerful features, like Argus [10] and Eden [2], require a lot of code for their implementation, and this added overhead makes the systems slow. Systems with simple kernel calls, like the V kernel [8], Amoeba <ref> [15] </ref>, and Mach [1], have little overhead and run fast. However, the application software then becomes more complex and slower because extra code is required to make up for the missing kernel functions. Our goal in developing the Synthesis distributed operating system is to escape from this trade-off. <p> Although the interface remains approximately the same in the many different variants of Unix, the synthetic machine interface is more orthogonal. To the best of our knowledge, no Unix system uses a kernel code synthesizer. The V kernel [7] and Amoeba <ref> [15] </ref> are two examples of small distributed operating system kernels. They both encourage layers of software to be written on top of the kernel. Synthesis differs from both by the high-level synthetic machine interface, and the code synthesizer.
Reference: [16] <author> W.A. Wulf, E. Cohen, W. Corwin, A. Jones, R. Levin, C. Pierson, and F. Pollack. Hydra: </author> <title> the kernel of a multiprocessing operating system. </title> <journal> Communications of ACM, </journal> <volume> 17(6) </volume> <pages> 337-345, </pages> <month> June </month> <year> 1974. </year>
Reference-contexts: Since the user program can only specify an index into this table, the synthesized routines are entered at the proper entry points. This protection mechanism is similar to C-lists to prevent the forgery of capabilities <ref> [16] </ref>. 5 Synthesized routines run in supervisor state. The transition from user to supervisor state is made via a trap instruction. Thus, synthesized code can perform privileged operations such as accessing protected buffer pages. <p> The synthetic machine interface is object-oriented. Synthetic machines and synthetic components are encapsulated resources, and users must ask them to perform the kernel calls defined in Table 1. Pioneer object-oriented systems such as Hydra <ref> [16] </ref>, Eden [2], and Argus [10] have achieved performance adequate for a prototype, while Mach is comparable to BSD Unix [1]. We believe that synthesized code will take the performance of Synthesis one step ahead of current systems.
References-found: 16

