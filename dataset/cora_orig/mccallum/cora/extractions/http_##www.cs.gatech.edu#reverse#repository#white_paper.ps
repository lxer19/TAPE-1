URL: http://www.cs.gatech.edu/reverse/repository/white_paper.ps
Refering-URL: http://www.cs.gatech.edu/reverse/repos.html
Root-URL: 
Title: WHITE PAPER ON REVERSE ENGINEERING C  
Author: Spencer Rugaber S 
Note: (404) 894-8450  
Date: March 9, 1994  
Address: Atlanta, Georgia 30332-0280  
Affiliation: ollege of Computing  oftware Engineering Research Center Georgia Institute of Technology  
Abstract-found: 0
Intro-found: 0
Reference: <institution> eferences </institution>
Reference: 1. <author> V. R. Basili and H. D. Mills, </author> <title> ``Understanding and Documenting Programs,'' </title> <journal> IEEE Transactions 2 on Software Engineering, </journal> <volume> vol. SE-8, no. 3, </volume> <pages> pp. 270-283, </pages> <month> May </month> <year> 1982. </year> . <editor> L. A. Belady and M. M. Lehman, </editor> <title> ``Programming System Dynamics or the Meta-Dynamics of r System in Maintenance and Growth,'' RC 3546, </title> <journal> International Business Machine Corp., </journal> <volume> Septembe 7, </volume> <year> 1971. </year>
Reference-contexts: They describe a nalysis procedure based on control flow analysis and formal documentation <ref> [1] </ref>. Hausler and his col leagues have described tools they are building to support this approach [13]. The top-down approach is championed by Ruven Brooks.
Reference: 3. <author> G. D. Bergland, </author> <title> ``A Guided Tour of Program Design Methodologies,'' </title> <journal> IEEE Computer, </journal> <note> October 4 . Ted J. </note> <author> Biggerstaff, </author> <title> ``Design Recovery for Maintenance and Reuse,'' </title> <booktitle> IEEE Computer, </booktitle> <month> July </month> <year> 1989. </year> <note> -5. </note> <author> Mark R. Blackburn, </author> <title> ``Toward a Theory of Software Reuse Based on Formal Methods,'' </title> <note> SPC-TR 88-010, Version 1.0, </note> <institution> Software Productivity Consortium, </institution> <month> April </month> <year> 1988. </year> . 
Reference-contexts: The proces hat creates the structuring is called design. A large variety of design methods and representation tech f niques have been developed to aid this process <ref> [3, 22] </ref>. Although programming languages have some eatures intended to facilitate abstraction and structuring, the higher-level design representations may i have been lost or allowed to become out-of-date by the time reverse engineering is required.
Reference: 6. <author> Barry W. Boehm, </author> <title> Software Engineering Economics, </title> <publisher> Prentice Hall, </publisher> <editor> 1981 . Ruven Brooks, </editor> <title> ``Towards a Theory of the Comprehension of Computer Programs,'' </title> <journal> International 8 Journal of Man-Machine Studies, </journal> <volume> vol. 18, </volume> <pages> pp. 543-554, </pages> <note> 1983. </note> . <author> Elliot J. Chikofsky and James H. </author> <title> Cross II, ``Reverse Engineering and Design Recovery: A Tax 9 onomy,'' </title> <journal> IEEE Software, </journal> <volume> vol. 7, no. 1, </volume> <month> January </month> <year> 1990. </year> . <editor> Derek Coleman and Robin M. Gallimore, </editor> <title> ``A Framework for Program Development,'' </title> <journal> Hewlett 1 Packard Journal, </journal> <volume> vol. 38, </volume> <pages> pp. 37-40, </pages> <month> October </month> <year> 1987. </year>
Reference: 0. <author> J. Conklin, </author> <title> ``Hypertext: An Introduction and Survey,'' </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 17-41, </pages> <month> September 1 </month>
Reference: 1. <author> Martin S. Feather, </author> <title> ``A Survey and Classification of some Program Transformation Approaches . and Techniques,'' in Program Specification and Transformation, </title> <editor> ed. L. G. L. T. </editor> <booktitle> Meertens, </booktitle> <pages> pp 65-195, </pages> <publisher> Elsevier North Holland, </publisher> <year> 1987. </year>
Reference-contexts: They describe a nalysis procedure based on control flow analysis and formal documentation <ref> [1] </ref>. Hausler and his col leagues have described tools they are building to support this approach [13]. The top-down approach is championed by Ruven Brooks.
Reference: 12. <author> R. K. Fjeldstad and W. T. Hamlen., </author> <title> ``Application Program Maintenance Study: Report to Our n Respondents,'' Proceedings GUIDE 48, </title> <address> Philadelphia, PA, </address> <year> 1979. </year> <title> Tutorial on Software Mainte ance, </title> <editor> G. Parikh and N. Zvegintozov, editors, </editor> <publisher> IEEE Computer Society, </publisher> <month> April </month> <year> 1983, </year> <note> IEEE Order 1 </note>
Reference: 3. <author> Philip A. Hausler, Mark G. Pleszkoch, Richard C. Linger, and Alan R. Hevner, </author> <title> ``Using Function 1 Abstraction to Understand Program Behavior,'' </title> <journal> IEEE Software, </journal> <volume> vol. 7, no. 1, </volume> <pages> pp. 55-63, </pages> <month> January 990. </month>
Reference-contexts: The proces hat creates the structuring is called design. A large variety of design methods and representation tech f niques have been developed to aid this process <ref> [3, 22] </ref>. Although programming languages have some eatures intended to facilitate abstraction and structuring, the higher-level design representations may i have been lost or allowed to become out-of-date by the time reverse engineering is required.
Reference: 14. <author> Stanley Letovsky, </author> <title> ``A Program Anti-Compiler,'' </title> <type> Draft Technical Report, </type> <institution> Department of Computer 1 Science, Yale University, </institution> <month> July 8, </month> <year> 1988. </year>
Reference-contexts: The plans ar rganized into subgoals and then goals. Experiments have been conducted that support this approach, and Letovsky has built an analysis tool that implements part of the analysis process <ref> [14] </ref>. Another bottom-up approach is that taken by the Programmer's Apprentice project.
Reference: 5. <author> H. Partsch and R. Steinbruggen, </author> <title> ``Program Transformation Systems,'' </title> <journal> ACM Computing Surveys, </journal> <volume> 1 vol. 15, no. 3, </volume> <pages> pp. 189-226, </pages> <month> September </month> <year> 1983. </year>
Reference-contexts: For a description of two approaches to the representation of this information, see <ref> [5] </ref> and [9]. Without such a mechanism, understanding cannot be communicated among maintainers, manage 2 ment cannot appreciate the extent and quality of the understanding, and tools cannot be integrated. .3. Tools Reverse engineering tools are currently limited in power.
Reference: 6. <author> Charles Rich and Linda M. Willis, </author> <title> ``Recognizing a Program's Design: A Graph-Parsing 1 Approach,'' </title> <journal> IEEE Software, </journal> <volume> vol. 7, no. 1, </volume> <month> January </month> <year> 1990. </year>
Reference: 7. <author> Spencer Rugaber and Kit Kamper, </author> <title> ``Design Decision Analysis Research Project,'' </title> <type> GIT-SERC . 90/01, </type> <institution> Software Engineering Research Center, Georgia Institute of Technology, </institution> <month> January 28, </month> <year> 1990 </year>
Reference-contexts: Because of this, totally automatic reverse engineering tools are - restricted to working with the formal program text. It is the job of the reverse engineer, then, to recon truct the mappings from the application domain to the program domain <ref> [7] </ref>. This of course requires o knowledge, not only of programming, but also of the application domain. It is no surprise, therefore, t nd that most automatic tools are restricted to analyzing the program text and do not address the appli 1 cation domain. <p> As the program is perused, the overall concept is refined into more lower - level details <ref> [7] </ref>. This synthesis process proceeds top-down. The difficulty is that both of these activi ies need to proceed at the same time, in a synchronized fashion [17]. 2. <p> The top-down approach is championed by Ruven Brooks. In his approach, the program under E stander attempts to recreate a series of mappings between the application domain and the program. xploration is driven by expectations derived from the application description <ref> [7] </ref>. An expectation is n confirmed by locating a beacon in the code. This is a stereotypical programming construct, similar i oncept to the plans mentioned above. There have been some human factors experiments that support 3 Brooks' ideas. .2.
Reference: 8. <author> Spencer Rugaber, Stephen B. Ornburn, and Richard J. LeBlanc, Jr., </author> <title> ``Recognizing Design Deci-1 sions in Programs,'' </title> <journal> IEEE Software, </journal> <volume> vol. 7, no. 1, </volume> <month> January </month> <year> 1990. </year>
Reference-contexts: 1.1. Definition The process of understanding a program involves reverse engineering the source code. Chikofsky s and Cross <ref> [8] </ref> give the following definition. "Reverse enginering is the process of analyzing a subject ystem to identify the system's components and their interrelationships and create representations of the u system in another form or at a higher level of abstraction." The purpose of reverse engineering is to nderstand a software system
Reference: 9. <author> Ben Shneiderman, </author> <title> Software Psychology: </title> <booktitle> Human Factors in Computer and Information Systems, </booktitle> <publisher> 2 Little Brown and Co., </publisher> <address> Boston, Massachusetts, </address> <year> 1980. </year>
Reference-contexts: For a description of two approaches to the representation of this information, see [5] and <ref> [9] </ref>. Without such a mechanism, understanding cannot be communicated among maintainers, manage 2 ment cannot appreciate the extent and quality of the understanding, and tools cannot be integrated. .3. Tools Reverse engineering tools are currently limited in power.
Reference: 0. <author> Eliot Soloway, Jeannine Pinto, Stan Letovsky, David Littman, and Robin Lampert, </author> <title> ``Designing . Documentation to Compensate for Delocalized Plans,'' </title> <journal> Communications of the ACM, </journal> <volume> vol. 31, no 1, </volume> <month> November </month> <year> 1988. </year> - <note> 10 - s21. </note> <author> E. Soloway and K. Ehrlich, </author> <title> ``Empirical Studies of Programming Knowledge,'' </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> vol. SE-10, no. 5, </volume> <month> September, </month> <year> 1984. </year> <note> ,22. </note> <author> Dallas E. Webster, </author> <title> ``Mapping the Design Representation Terrain: A Survey,'' </title> <institution> MCC STP-093-87 Microelectronics & Computer Technology Corporation, </institution> <month> July </month> <year> 1987. </year>
References-found: 15

