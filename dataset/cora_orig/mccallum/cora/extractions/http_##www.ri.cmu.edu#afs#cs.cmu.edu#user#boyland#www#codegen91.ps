URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/user/boyland/www/codegen91.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/user/boyland/www/codegen.html
Root-URL: 
Title: Attributed Transformational Code Generation for Dynamic Compilers  
Author: John Boyland Charles Farnum Susan L. Graham 
Address: Berkeley, CA 94720 USA  Dayton, OH 45435 USA  Berkeley, CA 94720 USA  
Affiliation: Computer Science Division, University of California, Berkeley  Department of Computer Science and Engineering, Wright State University  Computer Science Division, University of California, Berkeley  
Abstract: The design of dynamic compilers, that is, compilers that preserve execution state when newly compiled code is patched into an executing image, presents the compiler writer with a number of difficulties. First, all the complexity of a standard compiler is present. Second, enough intermediate information must be maintained to allow the compilation to proceed incrementally. Third, the incremental incorporation of newly compiled segments of code must disturb the existing execution state as little as possible. The last two factors are compounded when the desired level of granularity is small, such as at the level of statements or expressions. We describe our proposed method for automatically generating dynamic compilers and explain how the method will handle these issues.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Chase B B, Hood R T. </author> <title> Selective interpretation as a technique for debugging computationally intensive programs. </title> <booktitle> Proc ACM SIGPLAN 1987 Symp on Interpreters and Interpretive Techniques, ACM SIGPLAN Notices 1987; 22(7) </booktitle> <pages> 113-124 </pages>
Reference: 2. <author> Feiler P H. </author> <title> A language-oriented interactive programming environment based on compilation technology. </title> <type> PhD thesis, </type> <institution> CMU-CS-82-117, Carnegie-Mellon University, </institution> <year> 1982 </year>
Reference-contexts: Instead of modifying a current execution state in order to remove inconsistency, the run-time system could unroll computation back to the last consistent point and then restart computation. This capability was provided in the LOIPE system <ref> [2] </ref>, though side-effects were not unrolled|the execution environment popped procedure frames off the stack until no changed procedures were active. <p> Though several authors mention that dynamic compilation in their systems could theoretically be used for debugging purposes [2,24], in the same manner as interpreted Lisp, they do not pursue this capability seriously. For example, in Feiler's proposed system LOIPE <ref> [2] </ref>, the compiler would be able to partially replace a procedure with a new definition including a new statement (in our case, a debugging statement) right at the current execution point and then execution would be permitted to continue.
Reference: 3. <author> Ganzinger H, Giegerich R. </author> <title> Attribute coupled grammars. </title> <booktitle> 1984 Symp on Compiler Construction, ACM SIGPLAN Notices 1984; 19(6) </booktitle> <pages> 157-170 </pages>
Reference-contexts: We have been investigating limitations to the acceptable wrappers and composition rules that make possible efficient implementation via attribute couplings. 5.4 Attribute Couplings Attribute couplings were first formulated in the work of Ganzinger and Giegerich <ref> [3] </ref>. Work on attribute couplings has continued [4,5].
Reference: 4. <author> Ganzinger H, Giegerich R, Vach M. MARVIN: </author> <title> a tool for applicative and modular compiler specifications. </title> <type> Report 220, </type> <institution> University Dortmund, </institution> <year> 1986 </year>
Reference: 5. <author> Giegerich R. </author> <title> Composition and evaluation of attribute coupled grammars. </title> <journal> Acta Inform 1988; 25 </journal> <pages> 355-423 </pages>
Reference: 6. <author> Ballance R A, Graham S L, Van De Vanter M L. </author> <title> The Pan language-based editing system. </title> <journal> ACM Trans on Soft Eng and Meth 1992; 1(1) </journal> <pages> 95-127 </pages>
Reference-contexts: A form of fine-grained dynamic linking can then be used to update the executable image. 2 Research Context This research is an outgrowth of our work at Berkeley on the Pan system, which provides language-based support for interactive software development environments <ref> [6] </ref>. Much of the previous work on Pan has dealt with the interactive "front-end" that provides language-based editing and browsing of (static) language documents [7,8,9], using description-based components. It is natural to extend the Pan system to support execution services.
Reference: 7. <author> Ballance R A. </author> <title> Syntactic and semantic checking in language-based editing systems. </title> <type> PhD thesis, </type> <institution> UCB/CSD 89/548, University of California, Berkeley, </institution> <year> 1989 </year>
Reference: 8. <author> Black C. PPP: </author> <title> a pretty-printer for Pan. </title> <type> Master's report, </type> <institution> UCB/CSD 90/589, University of California, Berkeley, </institution> <year> 1990 </year>
Reference: 9. <author> Butcher J. LADLE. </author> <type> Master's report, </type> <institution> UCB/CSD 89/519, University of Cal-ifornia, Berkeley, </institution> <year> 1989 </year>
Reference: 10. <author> Bell J R. </author> <title> Threaded code. </title> <booktitle> Comm ACM 1973; 16(2) </booktitle> <pages> 370-372 </pages>
Reference: 11. <author> Kogge P M. </author> <title> An architectural trail to threaded code systems. </title> <booktitle> IEEE Computer 1982; 15 </booktitle> <pages> 22-33 </pages>
Reference: 12. <author> Alt M, Fecht C, Ferdinand C, Wilhelm R. </author> <title> The Trafola-H system. </title> <note> In The PROSPECTRA system (to appear) </note>
Reference: 13. <author> Ganzinger H, Giegerich R, Moncke U, Wilhelm R. </author> <title> A truly generative semantics directed compiler generator. </title> <booktitle> 1982 Symp on Compiler Construction, ACM SIGPLAN Notices 1982; 17(6) </booktitle> <pages> 172-184 </pages>
Reference: 14. <author> Lipps P, Moncke U, Wilhelm R. </author> <title> OPTRAN|A language/system for the specification of program transformations: system overview and experiences. In Compiler Compilers and High Speed Compilation, </title> <booktitle> 2nd CCHSC Workshop 1988; 52-65 </booktitle>
Reference: 15. <author> Pelegr i-Llopart E, Graham S L. </author> <title> Optimal code generation for expression trees: an application of BURS theory. </title> <booktitle> In 15th ACM Symp on Princ of Prog Lang 1988; 294-308 </booktitle>
Reference: 16. <author> Henry R R, Damron P C. </author> <title> Algorithms for table-driven code generators using tree-pattern matching. </title> <institution> 89-02-03, University of Washington, </institution> <address> Seattle, </address> <year> 1989 </year>
Reference: 17. <author> Farnum C. </author> <title> Pattern-based languages for prototyping compiler optimizers. </title> <type> PhD thesis, </type> <institution> UCB/CSD 90/608, University of California, Berkeley, </institution> <year> 1990 </year>
Reference-contexts: If the representations are tree-structured, the transformations can often be implemented by a sequence of smaller more local pattern-based rewrites of attributed trees, combined with an attribute-style analysis system for capturing global information [12,13,14]. Instruction selection can be described in this way [15,16], as can intraprocedural optimization <ref> [17] </ref>. In our system, a compiler will be written as a sequence of code attributes and transformations. Our attribution and transformation languages were originally developed in the context of Dora, an optimizing compiler workbench [17]. Dora is implemented in Lisp; consequently the pattern language syntax is also based on Lisp. <p> Instruction selection can be described in this way [15,16], as can intraprocedural optimization <ref> [17] </ref>. In our system, a compiler will be written as a sequence of code attributes and transformations. Our attribution and transformation languages were originally developed in the context of Dora, an optimizing compiler workbench [17]. Dora is implemented in Lisp; consequently the pattern language syntax is also based on Lisp. <p> These extended constructs can be handled without slowing down the pattern matcher; an automated reduction to the simple pattern matching language allows automaton-based solutions to be used for the enhanced language <ref> [17] </ref>. A horizontal iterator matches an indefinite number of subtrees at a particular position in the tree. Horizontal iterators are written by enclosing one or more subpatterns in an internal node within braces: -. A horizontal iterator denotes zero or more insertions of its subpatterns into the pattern.
Reference: 18. <author> Hoffman C M, O'Donnell M J. </author> <title> Pattern matching in trees. </title> <booktitle> J ACM 1982; 29(1) </booktitle> <pages> 68-95 </pages>
Reference-contexts: Efficient automaton-based pattern matchers can be constructed for such simple patterns <ref> [18] </ref>. We have made some useful extensions to the pattern language, while maintaining the ability to build an efficient matcher. 5.1.1 Trees Our trees are labeled and ordered. We write tree nodes by enclosing the label and (possibly empty) list of children in brackets: [ ].
Reference: 19. <author> Wall D W. </author> <title> Experience with a software-defined machine architecture. </title> <note> In ACM Trans on Prog Lang and Sys (to appear, </note> <year> 1992) </year>
Reference-contexts: It is expected, for example, that all implementations of dynamic compilers for the same machine will share the same "assembly" intermediate language for the particular machine 7 . More interestingly, it is possible that a 7 The recent work by David Wall on Mahler <ref> [19] </ref> demonstrates additional advantages of such sharing. few intermediate forms may be used in a wide variety of compilers for various languages and machines.
Reference: 20. <author> Strong J, Wegstein J, Tritter A, Olsztyn J, Mock O, Steel T. </author> <title> The problem of programming communications with changing machines: a proposed solution. </title> <booktitle> Comm ACM 1958; 1(8) </booktitle> <pages> 12-18 </pages>
Reference-contexts: As a result, later compilers can be described mainly using pieces from existing compilers. The benefit of sharing intermediate languages in compilers is, of course, well known <ref> [20] </ref>. 6.1.2 The Transformation Stages Each transformation stage consists of a transformation and the required attributes for this transformation. The compiler writer uses def-attribute and def-transformation for this purpose. Other macros are necessary for "glue" purposes.
Reference: 21. <author> Dybvig R K. </author> <title> The Scheme programming language. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> En-glewood Cliffs, New Jersey, </address> <year> 1987 </year>
Reference: 22. <author> Ho W W, Olsson R A. </author> <title> An approach to genuine dynamic linking. </title> <institution> University of California, Davis, CSE-90-25, </institution> <year> 1990 </year>
Reference-contexts: Such a system abandons partial consistency and thus is not suitable for debugging. 7.3 Foreign Code Foreign code | modules compiled by the standard system compiler, including standard library functions | are linked with the dynamically compiled code using traditional dynamic linking methods (such as dld <ref> [22] </ref>). Direct operating system entry points are linked with virtual functions in the run-time system so that, for example, input and output is appropriately redirected.
Reference: 23. <author> Deutsch P, Schiffman A M. </author> <title> Efficient implementation of the Smalltalk-80 system. </title> <booktitle> In 11th ACM Symp on Princ of Prog Lang 1984; 297-302 </booktitle>
Reference: 24. <author> Schwartz M D, Delisle N M, Begwani V S. </author> <title> Incremental compilation in Magpie. </title> <booktitle> 1984 Symp on Compiler Construction, ACM SIGPLAN Notices 1984; 19(6) </booktitle> <pages> 122-131 </pages>
Reference: 25. <author> Ross G. </author> <title> Integral C|A practical environment for C programming. </title> <note> In Proc ACM SIGSOFT/SIGPLAN Soft Eng Symp on Pract Soft Dev Env 1986; 42-48 </note>
Reference: 26. <author> Fritzson P. </author> <title> Preliminary experience from the DICE system: a distributed incremental compiling environment. </title> <booktitle> Proc ACM SIGSOFT/SIGPLAN Soft Eng Symp on Pract Soft Dev Env 1984; 19(5) </booktitle> <pages> 113-123 </pages>
Reference: 27. <author> Teitelman W. </author> <note> Interlisp reference manual. Xerox PARC, </note> <year> 1978 </year>
Reference: 28. <author> Teitelbaum T, Reps T. </author> <title> The Cornell program synthesizer: a syntax-directed programming environment. </title> <booktitle> Comm ACM 1981; 24 </booktitle> <pages> 563-573 </pages>
Reference: 29. <author> Standish T A, Taylor R N. Arcturus: </author> <title> a prototype advanced Ada programming environment. </title> <booktitle> Proc ACM SIGSOFT/SIGPLAN Soft Eng Symp on Pract Soft Dev Env 1984; 19(5) </booktitle> <pages> 57-64 </pages>
Reference: 30. <author> Saber Inc. Saber C. </author> <year> 1989 </year>
Reference-contexts: A number of integrated programming environments provide some sort of incremental or dynamic compilation to the programmer [2,23,24,25,26]. Some environments provide facilities similar to dynamic compilation using an interpreter <ref> [27,28,29, 30] </ref>. Typically, such systems provide incremental compilation at the procedure level and many allow a procedure definition or redefinition to be added to a program already in execution.
Reference: 31. <author> Delisle N M, Menicosy D E, Schwartz M D. </author> <title> Viewing a programming envi-ronment as a single tool. </title> <booktitle> Proc ACM SIGSOFT/SIGPLAN Soft Eng Symp on Pract Soft Dev Env 1984; 19(5) </booktitle> <pages> 49-56 </pages>
References-found: 31

