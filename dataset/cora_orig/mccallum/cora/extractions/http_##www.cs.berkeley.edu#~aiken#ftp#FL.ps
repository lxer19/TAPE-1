URL: http://www.cs.berkeley.edu/~aiken/ftp/FL.ps
Refering-URL: http://www.cs.berkeley.edu/~aiken/pubs.html
Root-URL: 
Email: email: aiken@cs.berkeley.edu  email: williams@almaden.ibm.com  email: wimmers@almaden.ibm.com  
Title: The FL Project: The Design of a Functional Language  
Author: Alexander Aiken John H. Williams Edward L. Wimmers 
Address: Berkeley, CA 94720-1776  650 Harry Rd. San Jose, CA 95120  650 Harry Rd. San Jose, CA 95120  
Affiliation: Computer Science Division University of California, Berkeley  IBM Almaden Research Center  IBM Almaden Research Center  
Abstract: FL is the result of an effort to design a practical functional programming language based on Backus' FP. This paper provides an introduction to and critique of the FL language. The language effort is analyzed from several points of view: language design, implementation, and user experiences. Emphasis is placed on the unusual aspects of FL, its strengths and weaknesses, and how FL compares with other functional programming languages.
Abstract-found: 1
Intro-found: 1
Reference: [App89] <author> A. Appel. </author> <title> Runtime tags aren't necessary. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2 </volume> <pages> 153-162, </pages> <year> 1989. </year>
Reference-contexts: All existing implementations of functional languages carry at least some run-time tags on data because existing garbage collection algorithms require them. There 31 is, however, an emerging technology of tagless garbage collection, where compile-time types are used at run-time by the garbage collector to reconstruct tags <ref> [App89] </ref>. If and when tagless garbage collection algorithms become practical, implementations of statically typed functional languages will be able to use them; this option cannot be exploited in an FL implementation.
Reference: [App93] <author> A. Appel. </author> <title> A critique of Standard ML. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(4), </volume> <year> 1993. </year> <note> to appear. </note>
Reference-contexts: This makes FL a secure language <ref> [App93] </ref>. An FL program never "dumps core" or otherwise terminates without returning a valid FL value. There is a special primitive signal such that signal : x = Exc (x) for any normal value x: This provides the programmer with a way to raise exceptions directly. <p> It also makes debugging Lisp programs much more difficult than necessary. Another point of comparison is ML, which incorporates exceptions in a way quite similar to FL. Both the motivation for and experience with exceptions in ML are similar to that of FL <ref> [App93] </ref>. The major difference is that exceptions are used uniformly in FL, while in ML certain errors are treated as static type errors and others as run-time exceptions. There are semantic and pragmatic arguments for not using exceptions.
Reference: [AW93] <author> A. Aiken and E. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: In this respect it functions as a traditional program analysis, which may be used at the discretion of the programmer or compiler, but is not required. This section very briefly describes the FL type system and presents two short examples. The interested reader is referred to <ref> [AW93, AWL94] </ref> for details. Functional languages such as ML and Haskell have type systems based on the well-known Hind- ley/Milner type system [DM82].
Reference: [AWL94] <author> A. Aiken, E. Wimmers, </author> <title> and T.K. Lakshman. Soft typing with conditional types. </title> <booktitle> In TwentyFirst Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year> <month> 38 </month>
Reference-contexts: In this respect it functions as a traditional program analysis, which may be used at the discretion of the programmer or compiler, but is not required. This section very briefly describes the FL type system and presents two short examples. The interested reader is referred to <ref> [AW93, AWL94] </ref> for details. Functional languages such as ML and Haskell have type systems based on the well-known Hind- ley/Milner type system [DM82]. <p> The notion of a minimal type is somewhat different from the notion of a principal type. Principal types are defined syntactically, whereas minimal types are defined semantically. Principal and minimal types coincide in the Hindley/Milner system; FLT has minimal types but not principal types <ref> [AWL94] </ref>. For brevity, a formal development of the FL type system is not presented here. Two examples should suffice to illustrate how the FL type system differs from the Hindley/Milner system. The first example is the program s1ffi [~1; ~2]: This program is a constant function that returns 1.
Reference: [AWW90] <author> A. Aiken, J. H. Williams, and E. L. Wimmers. </author> <title> Program transformation in the presence of errors. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 210-217, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The FL type system is able to prove at compile-time that most functions cannot produce exceptions. In addition, a robust theory of program transformation in the presence of exception producing functions has been developed and implemented in the FL compiler <ref> [AWW90] </ref>. Together, these two tools reduce the cost of FL's pervasive use of exceptions to a tolerable level. The semantic argument against exceptions is that adding exceptions forces too much to be specified about the order of evaluation.
Reference: [Bac78] <author> J. Backus. </author> <title> Can programming be liberated from the von Neumann style? A functional style and its algebra of programs. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 613-641, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: 1 Introduction In his Turing Award paper, John Backus introduced a simple notation for functional programming called FP <ref> [Bac78] </ref>. The initial design of FP underwent considerable evolution in subsequent years [Wil82b, Wil82a, Bac85, HWWW85, HWW86, BWW86, WW88, BWW90, HWW90], culminating in the definition of FL [BWW + 89]. <p> This paper is about the design of, implementation of, and experience with the FL language. The design of FL has been heavily influenced by FP and the philosophy set forth in <ref> [Bac78] </ref>. The core of this philosophy is expressed in the opening critique of conventional languages [Bac78]: Programming languages appear to be in trouble. <p> This paper is about the design of, implementation of, and experience with the FL language. The design of FL has been heavily influenced by FP and the philosophy set forth in <ref> [Bac78] </ref>. The core of this philosophy is expressed in the opening critique of conventional languages [Bac78]: Programming languages appear to be in trouble. <p> the function level by providing syntax for the function cons that parallels the syntax for sequences h: : :i; resulting in a shorter expression without "junk references." For a more complete discussion of the advantages of programming with a carefully selected collection of combining forms with rich algebraic properties, see <ref> [Bac78, Wil82b] </ref>. These advantages notwithstanding, FL syntax is peculiar, particularly to programmers who are familiar with other functional languages. Some of the peculiarity is superficial; people who use FL for the first time often are surprised at how easy it is to write FL programs.
Reference: [Bac85] <author> J. Backus. </author> <title> From function level semantics to program transformation and optimization. </title> <type> Technical Report RJ 4567 (49035), </type> <institution> IBM, </institution> <year> 1985. </year>
Reference-contexts: 1 Introduction In his Turing Award paper, John Backus introduced a simple notation for functional programming called FP [Bac78]. The initial design of FP underwent considerable evolution in subsequent years <ref> [Wil82b, Wil82a, Bac85, HWWW85, HWW86, BWW86, WW88, BWW90, HWW90] </ref>, culminating in the definition of FL [BWW + 89].
Reference: [BWW86] <author> J. Backus, J. H. Williams, and E. L. Wimmers. </author> <title> The FL language manual. </title> <type> Technical Report RJ 5339 (54809), </type> <institution> IBM, </institution> <year> 1986. </year>
Reference-contexts: 1 Introduction In his Turing Award paper, John Backus introduced a simple notation for functional programming called FP [Bac78]. The initial design of FP underwent considerable evolution in subsequent years <ref> [Wil82b, Wil82a, Bac85, HWWW85, HWW86, BWW86, WW88, BWW90, HWW90] </ref>, culminating in the definition of FL [BWW + 89].
Reference: [BWW + 89] <author> J. Backus, J. H. Williams, E. L. Wimmers, P. Lucas, and A. Aiken. </author> <title> The FL language manual parts 1 and 2. </title> <type> Technical Report RJ 7100 (67163), </type> <institution> IBM, </institution> <year> 1989. </year>
Reference-contexts: 1 Introduction In his Turing Award paper, John Backus introduced a simple notation for functional programming called FP [Bac78]. The initial design of FP underwent considerable evolution in subsequent years [Wil82b, Wil82a, Bac85, HWWW85, HWW86, BWW86, WW88, BWW90, HWW90], culminating in the definition of FL <ref> [BWW + 89] </ref>. Since the FL definition in 1989 a substantial implementation effort has been underway at the IBM Almaden Research Center to build an optimizing compiler for and to test the viability of programming in FL. <p> Section 3 presents the formal syntax and semantics of FL. Because FL is a small language, this section fairly presents almost everything there is to know about FL. For brevity, however, a few minor features are not discussed; the interested reader is referred to <ref> [BWW + 89] </ref>. The second topic is a critique of FL on the subjects of syntax, types, input/output, exceptions and order of evaluation. FL is very different in each of these respects from most other functional languages. <p> The omissions are three additional productions for more general forms of patterns, one environment operator, one additional form of function definition, a form of lambda abstraction, and approximately a dozen productions for defining assertions, a kind of formal comment <ref> [BWW + 89] </ref>. The more general forms of patterns are used in practice, but infrequently. The other omitted features are rarely used. To complete the definition of FL syntax it is necessary to describe its lexical structure as well as precedence rules for infix notation. <p> Originally, FL became strict because it was necessary to specify an order of evaluation to guarantee that the single-threaded history component for I/O is handled correctly. Exceptions were added to the language later <ref> [BWW + 89] </ref>. Today, much of the original motivation for strictness has been removed by the discovery of monadic I/O (see Section 4.3). FL's I/O system could be replaced by monadic I/O; I/O programming would become somewhat more inconvenient and the language semantics would be simplified.
Reference: [BWW90] <author> J. Backus, J. H. Williams, and E. L. Wimmers. </author> <title> An introduction to the programming language FL. </title> <editor> In D. Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, </booktitle> <pages> pages 219-247. </pages> <publisher> Addison-Wesley, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction In his Turing Award paper, John Backus introduced a simple notation for functional programming called FP [Bac78]. The initial design of FP underwent considerable evolution in subsequent years <ref> [Wil82b, Wil82a, Bac85, HWWW85, HWW86, BWW86, WW88, BWW90, HWW90] </ref>, culminating in the definition of FL [BWW + 89].
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principle type-schemes for functional programs. </title> <booktitle> In Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: This section very briefly describes the FL type system and presents two short examples. The interested reader is referred to [AW93, AWL94] for details. Functional languages such as ML and Haskell have type systems based on the well-known Hind- ley/Milner type system <ref> [DM82] </ref>.
Reference: [HMT89] <author> R. Harper, R. Milner, and M. Tofte. </author> <title> The definition of standard ML|version 3. </title> <type> Technical Report ECFS-LFCS-89-81, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <year> 1989. </year>
Reference-contexts: FL has exceptions because it was considered necessary to specify formally what happens in the event of a run-time error, such as division by zero. Most other functional languages do not provide run-time exceptions, choosing instead to leave the behavior of run-time errors unspecified and implementation-dependent. Standard ML <ref> [HMT89] </ref>, however, has an exception mechanism similar in spirit to FL's. Like ML, but unlike Haskell [HWA + 88], FL is a strict language. One desirable feature that is not a design goal of FL is efficiency of compiled code.
Reference: [HWA + 88] <author> P. Hudak, P. Wadler, Arvind, B. Boutel, J. Fairbairn, J. Fasel, J. Hughes, T. Johnsson, D. Kieburtz, S. P. Jones, R. Nikhil, M. Reeve, D. Wise, and J. Young. </author> <title> Report on the functional programming language Haskell. </title> <type> Technical Report DCS/RR-666, </type> <institution> Yale University, </institution> <month> December </month> <year> 1988. </year>
Reference-contexts: Most other functional languages do not provide run-time exceptions, choosing instead to leave the behavior of run-time errors unspecified and implementation-dependent. Standard ML [HMT89], however, has an exception mechanism similar in spirit to FL's. Like ML, but unlike Haskell <ref> [HWA + 88] </ref>, FL is a strict language. One desirable feature that is not a design goal of FL is efficiency of compiled code. Not surprisingly, as a result some features of FL are difficult to compile well. <p> Because of the lack of static typing as a default, programmers who chose not to have exceptions would be seriously handicapped in debugging FL programs. There is of course another alternative: drop exceptions and add static typing. This alternative is the design taken in Haskell <ref> [HWA + 88] </ref>. After much experience with writing functional programs in FL, another rationale has emerged for having a strict language. It is often necessary to rewrite a functional program to make it run faster; there are always things even an aggressive optimizing compiler cannot do.
Reference: [HWW86] <author> J. Halpern, J. Williams, and E. Wimmers. </author> <title> Good rewrite strategies for FP. </title> <booktitle> In Thirteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 149-162, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: 1 Introduction In his Turing Award paper, John Backus introduced a simple notation for functional programming called FP [Bac78]. The initial design of FP underwent considerable evolution in subsequent years <ref> [Wil82b, Wil82a, Bac85, HWWW85, HWW86, BWW86, WW88, BWW90, HWW90] </ref>, culminating in the definition of FL [BWW + 89]. <p> Allowing this kind of programming does not interact well with lazy evaluation; this is one of the reasons why lazy functional languages do not have built-in exceptions. At one time, this semantic argument carried significant weight for FL|the language that evolved into FL was lazy for many years <ref> [HWW86] </ref>. Originally, FL became strict because it was necessary to specify an order of evaluation to guarantee that the single-threaded history component for I/O is handled correctly. Exceptions were added to the language later [BWW + 89].
Reference: [HWW90] <author> J. Halpern, J. Williams, and E. Wimmers. </author> <title> Completeness of rewrite rules and rewrite strate-gies for FP. </title> <journal> Journal of the ACM, </journal> <volume> 37(1) </volume> <pages> 86-143, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: 1 Introduction In his Turing Award paper, John Backus introduced a simple notation for functional programming called FP [Bac78]. The initial design of FP underwent considerable evolution in subsequent years <ref> [Wil82b, Wil82a, Bac85, HWWW85, HWW86, BWW86, WW88, BWW90, HWW90] </ref>, culminating in the definition of FL [BWW + 89].
Reference: [HWWW85] <author> J. Halpern, J. Williams, E. Wimmers, and T. Winkler. </author> <title> Denotational semantics and rewrite rules for FP. </title> <booktitle> In Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 108-120, </pages> <month> January </month> <year> 1985. </year> <month> 39 </month>
Reference-contexts: 1 Introduction In his Turing Award paper, John Backus introduced a simple notation for functional programming called FP [Bac78]. The initial design of FP underwent considerable evolution in subsequent years <ref> [Wil82b, Wil82a, Bac85, HWWW85, HWW86, BWW86, WW88, BWW90, HWW90] </ref>, culminating in the definition of FL [BWW + 89].
Reference: [Lau93] <author> J. Launchbury. </author> <title> A natural semantics for lazy evaluation. </title> <booktitle> In Twentieth Annual ACM Sym-posium on Principles of Programming Languages, </booktitle> <pages> pages 144-154, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: It should be said that not much attention has been given to the problem of writing efficient lazy functional programs as yet, although it is becoming an active area of research <ref> [Lau93] </ref>. 5 Experience and Lessons Learned FL is designed to be a simple language to learn and to use. These desiderata are reflected both in the syntax and semantics of FL.
Reference: [PJW93] <author> S. L. Peyton Jones and P. Wadler. </author> <title> Imperative functional programming. </title> <booktitle> In Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 71-84, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Since the development of FL's I/O system another, more general, approach to I/O in functional languages has been discovered. This approach, known as monadic I/O, uses higher-order combinators to hide and control how the history component is threaded through a computation <ref> [Wad90, PJW93] </ref>. Monadic I/O uses a particular monad; variations on the same higher-order combinators can implement other language features such as exceptions and continuations as monads. Essentially, FL I/O is itself a particular monad built into the language's denotational semantics.
Reference: [Sto77] <author> J. E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1977. </year>
Reference-contexts: The proof that these equations have a solution is straightforward using standard techniques <ref> [Sto77] </ref>. Before presenting the domain equations a few definitions are required. The FL domain, denoted D FL , contains atoms, functions, sequences (written hx 1 ; : : : ; x n i), tagged pairs (written i; x where i is an integer tag), and exceptions (written Exc (x)).
Reference: [Wad90] <author> P. Wadler. </author> <title> Comprehending monads. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: Since the development of FL's I/O system another, more general, approach to I/O in functional languages has been discovered. This approach, known as monadic I/O, uses higher-order combinators to hide and control how the history component is threaded through a computation <ref> [Wad90, PJW93] </ref>. Monadic I/O uses a particular monad; variations on the same higher-order combinators can implement other language features such as exceptions and continuations as monads. Essentially, FL I/O is itself a particular monad built into the language's denotational semantics.
Reference: [Wil82a] <author> J. Williams. </author> <title> Notes on the FP style of functional programming. In Functional Programming and its Applications. </title> <publisher> Cambridge University Press, </publisher> <month> January </month> <year> 1982. </year>
Reference-contexts: 1 Introduction In his Turing Award paper, John Backus introduced a simple notation for functional programming called FP [Bac78]. The initial design of FP underwent considerable evolution in subsequent years <ref> [Wil82b, Wil82a, Bac85, HWWW85, HWW86, BWW86, WW88, BWW90, HWW90] </ref>, culminating in the definition of FL [BWW + 89].
Reference: [Wil82b] <author> J. Williams. </author> <title> On the development of the algebra of functional programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(4) </volume> <pages> 733-757, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: 1 Introduction In his Turing Award paper, John Backus introduced a simple notation for functional programming called FP [Bac78]. The initial design of FP underwent considerable evolution in subsequent years <ref> [Wil82b, Wil82a, Bac85, HWWW85, HWW86, BWW86, WW88, BWW90, HWW90] </ref>, culminating in the definition of FL [BWW + 89]. <p> the function level by providing syntax for the function cons that parallels the syntax for sequences h: : :i; resulting in a shorter expression without "junk references." For a more complete discussion of the advantages of programming with a carefully selected collection of combining forms with rich algebraic properties, see <ref> [Bac78, Wil82b] </ref>. These advantages notwithstanding, FL syntax is peculiar, particularly to programmers who are familiar with other functional languages. Some of the peculiarity is superficial; people who use FL for the first time often are surprised at how easy it is to write FL programs.
Reference: [WW88] <author> J. H. Williams and E. L. Wimmers. </author> <title> Sacrificing simplicity for convenience: </title> <booktitle> Where do you draw the line? In Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 169-179, </pages> <month> January </month> <year> 1988. </year> <month> 40 </month>
Reference-contexts: 1 Introduction In his Turing Award paper, John Backus introduced a simple notation for functional programming called FP [Bac78]. The initial design of FP underwent considerable evolution in subsequent years <ref> [Wil82b, Wil82a, Bac85, HWWW85, HWW86, BWW86, WW88, BWW90, HWW90] </ref>, culminating in the definition of FL [BWW + 89].
References-found: 23

