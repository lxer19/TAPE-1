URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-475.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/trlow.html
Root-URL: 
Title: Disconnected Actions: An Asynchronous Extension to a Nested Atomic Action System  
Author: by 
Address: Cambridge, Massachusetts 02139  
Affiliation: Massachusetts Institute of Technology Laboratory of Computer Science  
Note: c flMassachusetts Institute of Technology 1990 This research was supported in part by the Advanced Research Projects Agency of the Department of Defence, monitored by the Office of Naval Research under contract N00014-83-K-0125, and in part by the National Science Foundation under grant DCR-8503662.  
Date: January 1990  
Pubnum: Boaz Ben-Zvi  
Abstract-found: 0
Intro-found: 1
Reference: [Allchin & McKendry 1983] <author> J. E. Allchin and M. S. McKendry. </author> <title> Synchronization and Recovery of Actions. </title> <booktitle> In Proceedings of the Second Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Montreal, Canada, </address> <pages> pages 31-44, </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1983. </year>
Reference: [Aspnes, et al. 1988] <author> James Aspnes, Alan Fekete, Nancy Lynch, Michael Merritt, and William Weihl. </author> <title> A Theory of Timestamp-Based Concurrency Control for Nested Transactions. </title> <booktitle> In Proceedings of the 14th International Conference on Very Large Data Bases, </booktitle> <pages> pages 431-444, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: A small improvement to Reed's scheme is proposed in <ref> [Aspnes, et al. 1988] </ref>; it keeps all the read-timestamps, not only the maximal as does Reed, and subsequent aborts allow for a reduction in the value of the maximal read-timestamp. 96 We can have a different scheme for serial DAs, which is similar to Reed's.
Reference: [Bernstein & Goodman 1981] <author> Philip A. Bernstein and Nathan Goodman. </author> <title> Concurrency Control in Distributed Database Systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 13(2) </volume> <pages> 185-221, </pages> <month> June </month> <year> 1981. </year>
Reference-contexts: There are two basic techniques for serializing concurrent actions: timestamping ([Reed 1978, Aspnes, et al. 1988]) and two-phase locking ([Eswaran, et al. 1976]). Our technique of adding timestamps to the locking-based model can be considered as a hybrid serialization technique. Hybrid protocols are discussed in <ref> [Bernstein & Goodman 1981] </ref>; their protocols are general methods of synchronization that handle each of the read-write or write-write conflicts with separate two-phase locking or timestamp techniques. <p> Another hybrid technique is discussed in [Weihl 1984]; it proposes the use of (static) creation-order timestamps for read-only activities and (dynamic) commit-order timestamps for update activities. Our technique of explicit control of serialization (using constraint tables) relates to the 15 idea of conflict graphs, also discussed in <ref> [Bernstein & Goodman 1981] </ref>. However, the conflict graphs there are used only as a helping tool for a scheduler to improve performance of a certain timestamp technique. Our notion of similarity between deadlock detection and serializability of concurrent actions has also been noted in [Zhao & Ramamritham 1985].
Reference: [Bjork 1973] <author> L. A. Bjork. </author> <title> Recovery Scenario for a DB/DC System. </title> <booktitle> In Proceedings of the ACM Annual Conference, </booktitle> <pages> pages 142-146, </pages> <publisher> ACM, </publisher> <address> Atlanta, GA, </address> <year> 1973. </year>
Reference-contexts: finds such an archaic replica in its quorum, it has to do more work: it has to read 14 more records from an up-to-date replica and write those records to the archaic one. 1.2 Related work The idea of nested atomic actions was initially proposed, as spheres of control, in <ref> [Davies 1973, Bjork 1973] </ref>. The first detailed design for a model that uses nested atomic actions was developed by Reed ([Reed 1978]). Reed proposed a multi-version, timestamp-based algorithm to ensure serialization of concurrent actions. A locking-based model of a nested atomic action system was developed by Moss ([Moss 1981]).
Reference: [Boggs, et al. 1979] <author> David R. Boggs, John F. Shoch, Edward A. Taft, and Robert M. Metcalfe. Pup: </author> <title> An Internetwork Architecture. </title> <type> CSL 79-10, </type> <institution> Xerox Palo-Alto Research Center, </institution> <month> July </month> <year> 1979. </year>
Reference-contexts: Any component of the system may fail, but the likelihood of multiple simultaneous failures is small. Messages sent over the network may be lost, corrupted or duplicated. We assume that an underlying Datagram protocol (e.g., <ref> [Postel 1980, Boggs, et al. 1979] </ref>) ensures delivery of uncorrupted messages. When that Datagram protocol fails (i.e., network partition), the high-level system has to be notified. Nodes may fail, but we assume that they eventually recover.
Reference: [Davies 1973] <author> C. Davies. </author> <title> Recovery Semantics for a DB/DC System. </title> <booktitle> In Proceedings of the ACM National Conference 28, </booktitle> <pages> pages 136-141, </pages> <year> 1973. </year>
Reference-contexts: finds such an archaic replica in its quorum, it has to do more work: it has to read 14 more records from an up-to-date replica and write those records to the archaic one. 1.2 Related work The idea of nested atomic actions was initially proposed, as spheres of control, in <ref> [Davies 1973, Bjork 1973] </ref>. The first detailed design for a model that uses nested atomic actions was developed by Reed ([Reed 1978]). Reed proposed a multi-version, timestamp-based algorithm to ensure serialization of concurrent actions. A locking-based model of a nested atomic action system was developed by Moss ([Moss 1981]).
Reference: [Eswaran, et al. 1976] <author> K. P. Eswaran, J. N. Gray, R. A. Lorie, and I. L. Traiger. </author> <title> The notions of consistency and predicate locks in a database system. </title> <journal> Communications of the ACM, </journal> 19(11) 624-633, November 1976. Also published as IBM RJ1487, December, 1974. 
Reference: [Fredman & Tarjan 1984] <author> Michael L. Fredman and Robert Endre Tarjan. </author> <title> Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms. </title> <month> January </month> <year> 1984. </year> <note> Version of the paper that was used in MIT course 6.851. </note>
Reference: [Gifford & Donahue 1985] <author> D. K. Gifford and J. E. Donahue. </author> <title> Coordinating Independent Atomic Actions. </title> <booktitle> In Proc. of IEEE CompCon85, </booktitle> <pages> pages 92-95, </pages> <publisher> IEEE, </publisher> <month> February </month> <year> 1985. </year>
Reference-contexts: Other variations include non-blocking protocols ([Skeen 1981]) and three-phase protocols (like two-phase, but with an initial phase that tells the participant to "prepare for prepare"). Our work proposes a model that tries to commit the transaction in spite of failures. In <ref> [Gifford & Donahue 1985] </ref>, a different way is tried to avoid aborting a long-lived atomic transaction due to failures.
Reference: [Gifford 1979] <author> D. K. Gifford. </author> <title> Weighted Voting for Replicated Data. </title> <booktitle> In Proceedings of the Seventh Symposium on Operating Systems Principles, </booktitle> <pages> pages 150-162, </pages> <publisher> ACM SIGOPS, </publisher> <address> Pacific Grove, CA, </address> <month> De-cember </month> <year> 1979. </year>
Reference-contexts: Section 1.2 overviews some basic work in the field of nested atomic actions. The chapter concludes with an overview of the rest of the thesis. 1.1 Replicated File System an example Assume a replicated file system that employs a simple voting scheme (like those in <ref> [Thomas 1979, Gifford 1979] </ref>). There are N sites, each containing a replica of the file and a version number. A file is updated by assembling a write quorum of W sites, and read by a read quorum of R sites.
Reference: [Gray 1978] <author> Jim Gray. </author> <title> Notes on database operating systems. </title> <editor> In R. Bayer, R. M. Graham, and G. Seegmuller, editors, </editor> <booktitle> Operating Systems: An Advanced Course, chapter 3.F, </booktitle> <pages> pages 394-481, </pages> <publisher> Springer-Verlag, </publisher> <year> 1978. </year> <note> Also appears as IBM Research Report RJ 2188, </note> <month> Aug., </month> <year> 1987. </year>
Reference-contexts: Our notion of similarity between deadlock detection and serializability of concurrent actions has also been noted in [Zhao & Ramamritham 1985]. Much work has been done on the design of commit protocols for top-level actions. <ref> [Gray 1978] </ref> describes the classic two-phase commit protocol, and some variations like "nested two phase commit protocol", where the participants are ordered and every one communicates with the next one.
Reference: [Gray, et al. 1976] <author> J. N. Gray, R. A. Lori, G. F. Putzolu, and I. L. Traiger. </author> <title> Granularity of Locks and Degrees of Consistency in a Shared Data Base. </title> <editor> In G.M. Nijssen, editor, </editor> <booktitle> Modeling in Data Base Management Systems, </booktitle> <pages> pages 365-394, </pages> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1976. </year> <note> Also available as IBM Research Report RJ 1654/1706. </note>
Reference: [Gruber 1989] <author> Robert Edward Gruber. </author> <title> Optimistic Concurrency Control For Nested Distributed Transactions. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <month> June </month> <year> 1989. </year>
Reference-contexts: We believe that a distributed method, similar to some distributed deadlock detection protocol, can also be devised. 7.2.4 Optimistic Model Work can be done on using disconnected actions in a model that uses optimistic concurrency control, like the one in <ref> [Gruber 1989] </ref>. The optimistic approach allows atomic action to execute without synchronization (e.g., block when another action uses a needed object), and rely on commit-time validation to ensure serialization of the actions.
Reference: [Herlihy, et al. 1987] <author> M. Herlihy, N. Lynch, M. Merritt, and W. Weihl. </author> <title> On the cor-rectness of orphan elimination algorithms. </title> <booktitle> In Proceedings of the Seventeenth International Symposium on Fault-Tolerant Computing, IEEE, </booktitle> <address> Pittsburgh, </address> <month> July </month> <year> 1987. </year>
Reference: [Kolodner 89] <author> Elliot K. Kolodner. </author> <title> Design Bug in Argus Recovery System. DSG Note 158, Programming Methodology group, L.C.S, </title> <publisher> M.I.T, </publisher> <month> November 89. </month>
Reference-contexts: The decision to abort or commit the topaction will determine which version will prevail that top one or the base version. 4 Writing a version to stable storage includes also non-stable objects that are accessible from this version. See [Oki, Liskov & Scheifler 1985] and <ref> [Kolodner 89] </ref>. 78 BASE A A:2:3 A:2:3:D1:5 TOP TOPMOST REGULAR BOTTOM When DAs are used and the above modified Two Phase Commit protocol is obeyed, a more complex scheme has to be used to ensure that the topmost committed version of an atomic object will be available when and if the
Reference: [Lampson & Sturgis 1976] <author> Butler W. Lampson and Howard E. Sturgis. </author> <title> Crash Recovery in a Distributed Data Storage System. </title> <note> 1976. version of paper that was not published. </note>
Reference-contexts: We assume fail-stop processors ([Schlichting & Schneider 1983]) in the nodes; that is, a failed processor does not send random messages or write arbitrarily to its storage. 1 Some researchers make a distinction between non-volatile storage (e.g., single local disk) and stable storage (e.g., double-disk scheme ( <ref> [Lampson & Sturgis 1976] </ref> ), but in this thesis we shall treat the two as one. 17 2.2 The current model This section describes the model of computation that is used currently by the Argus system ([Liskov, et al. 1987b]), without any changes or optimizations (e.g., as suggested in [Perl 1987]).
Reference: [Liskov & Guttag 1986] <author> B. H. Liskov and J. V. Guttag. </author> <title> Abstraction and specification in program development. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference: [Liskov & Scheifler 1983] <author> Barbara Liskov and Robert Scheifler. </author> <title> Guardians and actions: linguistic support for robust, distributed programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 381-404, </pages> <month> July </month> <year> 1983. </year>
Reference: [Liskov & Shrira 1988] <author> B. Liskov and L. Shrira. </author> <title> Promises: Linguistic Support for Efficient Asynchronous Procedure Calls in Distributed Systems. </title> <booktitle> In Proc. of the ACM SIGPLAN '88 Conference on Programming Languages Design and Implementation, ACM, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: Therefore DAs can not return replies to their transaction like handler calls do. A linguistic support for asynchronous work was proposed in <ref> [Liskov & Shrira 1988] </ref> with the introduction of promises into the language. A promise is returned to the caller when an asynchronous activity begins, and can be used by the program to reclaim the results of that activity later.
Reference: [Liskov 1984] <author> Barbara Liskov. </author> <title> Overview of the Argus Language and System. Programming Methodology Group Memo 40, </title> <institution> MIT Laboratory for Computer Science, </institution> <month> February </month> <year> 1984. </year>
Reference: [Liskov, et al. 1987a] <author> B. Liskov, R. Scheifler, E. F. Walker, and W. Weihl. </author> <title> Orphan Detection (Extended Abstract). </title> <booktitle> In Proceedings of the 17th International Symposium on Fault-Tolerant Computing, IEEE, </booktitle> <month> July </month> <year> 1987. </year> <note> Also appears as Programming Mothodology Group memo 53, </note> <institution> M.I.T, L.C.S, </institution> <month> Feb. </month> <pages> 87. 110 </pages>
Reference-contexts: This protocol ensures that the transaction either commits everywhere or aborts everywhere. The participants in the protocol are the sites in the committing topaction's plist (see Section 2.2.3 above); the coordinator is the topaction's site 14 . 13 This process is not clearly defined in <ref> [Walker 1984, Liskov, et al. 1987a, Nguyen 1988] </ref>.
Reference: [Liskov, et al. 1987b] <author> Barbara Liskov, Dorothy Curtis, Paul Johnson, and Robert Scheifler. </author> <title> Implementation of Argus. </title> <booktitle> In Proc. of the 11th Symposium on Operating Systems Principles, ACM, </booktitle> <address> Austin, Tx, </address> <month> November </month> <year> 1987. </year>
Reference-contexts: A better approach is to quiesce the remaining active (disconnected) actions and catch up on the missing information while carrying out the Two Phase Commit protocol, taking advantage of the existing message flow. The current Two Phase Commit protocol <ref> [Liskov, et al. 1987b] </ref> has to be modified to take into consideration the (disconnected) actions that are still active and the fact that not all the participants are known when the protocol commences. 1 It would take several rounds of messages from the coordinator to the known participants until all the
Reference: [Menasce & Muntz 1979] <author> D. Menasce and R. Muntz. </author> <title> Locking and deadlock detection in distributed data bases. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5(3):195-202, </volume> <month> May </month> <year> 1979. </year>
Reference-contexts: Most deadlock detection methods for distributed systems build some variation of a wait-for graph in either a centralized or distributed manner. The centralized ones (including hierarchical methods, see <ref> [Menasce & Muntz 1979] </ref>) resemble our constraint table method; they use a distinguished node in which the wait-for graph is built. <p> The centralized ones (including hierarchical methods, see [Menasce & Muntz 1979]) resemble our constraint table method; they use a distinguished node in which the wait-for graph is built. The distributed protocols (e.g., <ref> [Menasce & Muntz 1979, Moss 1981, Obermarck 1982] </ref>) create the wait-for graph, whole or in part, at some node where a local transaction suspects that it is deadlocked.
Reference: [Moss 1981] <author> J. Elliot B. Moss. </author> <title> Nested transactions: an approach to reliable distributed computing. </title> <type> Ph.D. thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1981. </year> <note> Available as Technical Report MIT/LCS/TR-260. </note>
Reference-contexts: The centralized ones (including hierarchical methods, see [Menasce & Muntz 1979]) resemble our constraint table method; they use a distinguished node in which the wait-for graph is built. The distributed protocols (e.g., <ref> [Menasce & Muntz 1979, Moss 1981, Obermarck 1982] </ref>) create the wait-for graph, whole or in part, at some node where a local transaction suspects that it is deadlocked.
Reference: [Nguyen 1988] <author> Thu Duc Nguyen. </author> <title> Performance Measurements of Orphan Detection in the Argus System. </title> <type> Master's thesis, </type> <institution> M.I.T, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: This protocol ensures that the transaction either commits everywhere or aborts everywhere. The participants in the protocol are the sites in the committing topaction's plist (see Section 2.2.3 above); the coordinator is the topaction's site 14 . 13 This process is not clearly defined in <ref> [Walker 1984, Liskov, et al. 1987a, Nguyen 1988] </ref>. <p> The disadvantage of this solution is its performance cost. The maps that are sent with the OK reply may be large, and the Orphan Detection mechanism is expensive (see <ref> [Nguyen 1988] </ref>). Without Orphan Detection, our new dependency detection mechanism, which also has some cost, has to be implemented. 6.4 Summary In this chapter we presented the idea of completing the Two Phase Commit process successfully in spite of failures.
Reference: [Obermarck 1982] <author> R. Obermarck. </author> <title> Distributed deadlock detection algorithm. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(2) </volume> <pages> 187-208, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: The centralized ones (including hierarchical methods, see [Menasce & Muntz 1979]) resemble our constraint table method; they use a distinguished node in which the wait-for graph is built. The distributed protocols (e.g., <ref> [Menasce & Muntz 1979, Moss 1981, Obermarck 1982] </ref>) create the wait-for graph, whole or in part, at some node where a local transaction suspects that it is deadlocked.
Reference: [Oki, Liskov & Scheifler 1985] <author> Brian M. Oki, Barbara H. Liskov, and Robert W. Scheifler. </author> <title> Reliable Object Storage to Support Atomic Actions. </title> <journal> ACM SIGOPS Operating Systems Review, </journal> <volume> 19(5) </volume> <pages> 147-159, </pages> <month> December </month> <year> 1985. </year> <booktitle> Proceedings of the Tenth ACM Symposium on Operating Systems Principles, </booktitle> <month> 1-4 December </month> <year> 1985, </year> <institution> Orcas Island, Washing-ton, U.S.A. </institution> <note> Also appears as Programming Methodology Group memo 45, </note> <institution> M.I.T, L.C.S, </institution> <month> Sept. 85. </month>
Reference-contexts: The decision to abort or commit the topaction will determine which version will prevail that top one or the base version. 4 Writing a version to stable storage includes also non-stable objects that are accessible from this version. See <ref> [Oki, Liskov & Scheifler 1985] </ref> and [Kolodner 89]. 78 BASE A A:2:3 A:2:3:D1:5 TOP TOPMOST REGULAR BOTTOM When DAs are used and the above modified Two Phase Commit protocol is obeyed, a more complex scheme has to be used to ensure that the topmost committed version of an atomic object will
Reference: [Oppen & Dalal 1981] <author> D. C. Oppen and Y. K. Dalal. </author> <title> The Clearinghouse: a decentralized agent for locating named objects in a distributed environment. </title> <type> Technical Report OPD-T8103, </type> <institution> Xerox Office Products Division, </institution> <month> October </month> <year> 1981. </year> <month> 111 </month>
Reference: [Perl 1987] <author> Sharon E. </author> <title> Perl. Distributed commit protocols for nested ac-tions. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <month> October </month> <year> 1987. </year> <note> Available as MIT/LCS/TR-431, </note> <month> November </month> <year> 1988. </year>
Reference-contexts: Our work has some similarities to other works that enhanced the nested action model in some ways. In [Walker 1984], Walker proposed algorithms that piggybacked information on existing messages in order to detect orphaned computations. In <ref> [Perl 1987] </ref>, Perl also uses similar techniques to reduce the need for lock query messages by propagating commit and abort information with existing messages (she calls it eager diffusion). <p> ( [Lampson & Sturgis 1976] ), but in this thesis we shall treat the two as one. 17 2.2 The current model This section describes the model of computation that is used currently by the Argus system ([Liskov, et al. 1987b]), without any changes or optimizations (e.g., as suggested in <ref> [Perl 1987] </ref>). Some small modifications are introduced, however, both to the current implementation and the terminology to make it easier to extand the model to support our new algorithms and protocols.
Reference: [Postel 1980] <author> J. Postel. </author> <title> Internet User Datagram Protocol. Request For Comments 768, </title> <institution> University of Southern California / Information Sciences Institute, </institution> <month> August </month> <year> 1980. </year>
Reference-contexts: Any component of the system may fail, but the likelihood of multiple simultaneous failures is small. Messages sent over the network may be lost, corrupted or duplicated. We assume that an underlying Datagram protocol (e.g., <ref> [Postel 1980, Boggs, et al. 1979] </ref>) ensures delivery of uncorrupted messages. When that Datagram protocol fails (i.e., network partition), the high-level system has to be notified. Nodes may fail, but we assume that they eventually recover.
Reference: [Reed 1978] <author> D.P. Reed. </author> <title> Naming and synchronization in a decentralized computer system. </title> <type> Ph.D. thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1978. </year> <note> Available as Technical Report MIT/LCS/TR-205. </note>
Reference: [Reed 1983] <author> David P. Reed. </author> <title> Implementing Atomic Actions on Decentralized Data. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 1(1) </volume> <pages> 3-23, </pages> <month> Februar </month> <year> 1983. </year>
Reference: [Schlichting & Schneider 1983] <author> R. D. Schlichting and F. B. Schneider. </author> <title> Fail-Stop Processors: An Approach to Designing Fault-Tolerant Computing Systems. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 1(3) </volume> <pages> 222-238, </pages> <month> August </month> <year> 1983. </year>
Reference: [Schwarz 1984] <author> Peter M. Schwarz. </author> <title> Transactions on typed objects. </title> <type> Ph.D. thesis, CMU, </type> <month> December </month> <year> 1984. </year> <note> Available as Technical Report CMU-CS-84-166. </note>
Reference-contexts: Note that we introduce additional requirements into the current model: 7 For example, non-atomic objects are needed in order to build user-defined atomic types (see [Weihl 1984]). 8 Note that models exist where locking takes place on a higher level, like the type-specific locking in <ref> [Schwarz 1984] </ref>. 9 The current implementation of Argus keeps all locks together, which is a semantically confusing. 10 Note that a can not have lock reply implies that a query (explained below) has to be sent. 23 check locks for read = proc (Reader:ainfo, OBJ:object) returns (reply) % Called at a
Reference: [Skeen 1981] <author> D. Skeen. </author> <title> Nonblocking commit protocols. </title> <booktitle> In Proceedings of a Symposium on the Management of Data, </booktitle> <pages> pages 133-142, </pages> <booktitle> ACM SIGMOD, </booktitle> <year> 1981. </year>
Reference: [Spector, et al. 1987] <author> Alfred Z. Spector, Dean Thompson, Randy F. Pausch, Jeffery L. Eppinger, Dan Duchamp, Richard Draves, Dean S. Daniels, and Joshua J. Bloch. Camelot: </author> <title> A Distributed Transaction Facility for Mach and the Internet-An Interim Report. </title> <type> Technical Report CMU-CS-87-129, CMU, </type> <month> June </month> <year> 1987. </year> <month> 112 </month>
Reference: [Thomas 1979] <author> R. H. Thomas. </author> <title> A majority consensus approach to concurrency control for multiple copy databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(2) </volume> <pages> 180-209, </pages> <month> June </month> <year> 1979. </year>
Reference-contexts: Section 1.2 overviews some basic work in the field of nested atomic actions. The chapter concludes with an overview of the rest of the thesis. 1.1 Replicated File System an example Assume a replicated file system that employs a simple voting scheme (like those in <ref> [Thomas 1979, Gifford 1979] </ref>). There are N sites, each containing a replica of the file and a version number. A file is updated by assembling a write quorum of W sites, and read by a read quorum of R sites.
Reference: [Walker 1984] <author> Edward Franklin Walker. </author> <title> Orphan Detection in the Argus System. </title> <type> Technical Report 326, </type> <institution> MIT/LCS, </institution> <month> June </month> <year> 1984. </year>
Reference-contexts: Clouds also uses different levels of object locking, and leaves the choice of level to the programmer. Our work has some similarities to other works that enhanced the nested action model in some ways. In <ref> [Walker 1984] </ref>, Walker proposed algorithms that piggybacked information on existing messages in order to detect orphaned computations. In [Perl 1987], Perl also uses similar techniques to reduce the need for lock query messages by propagating commit and abort information with existing messages (she calls it eager diffusion). <p> This protocol ensures that the transaction either commits everywhere or aborts everywhere. The participants in the protocol are the sites in the committing topaction's plist (see Section 2.2.3 above); the coordinator is the topaction's site 14 . 13 This process is not clearly defined in <ref> [Walker 1984, Liskov, et al. 1987a, Nguyen 1988] </ref>.
Reference: [Weihl 1984] <author> William E. Weihl. </author> <title> Specification and implementation of atomic data types. </title> <type> Ph.D. thesis, </type> <institution> MIT, </institution> <month> March </month> <year> 1984. </year> <note> Available as MIT/LCS/TR-314. </note>
Reference-contexts: Hybrid protocols are discussed in [Bernstein & Goodman 1981]; their protocols are general methods of synchronization that handle each of the read-write or write-write conflicts with separate two-phase locking or timestamp techniques. Another hybrid technique is discussed in <ref> [Weihl 1984] </ref>; it proposes the use of (static) creation-order timestamps for read-only activities and (dynamic) commit-order timestamps for update activities. Our technique of explicit control of serialization (using constraint tables) relates to the 15 idea of conflict graphs, also discussed in [Bernstein & Goodman 1981]. <p> Note that we introduce additional requirements into the current model: 7 For example, non-atomic objects are needed in order to build user-defined atomic types (see <ref> [Weihl 1984] </ref>). 8 Note that models exist where locking takes place on a higher level, like the type-specific locking in [Schwarz 1984]. 9 The current implementation of Argus keeps all locks together, which is a semantically confusing. 10 Note that a can not have lock reply implies that a query (explained <p> One example is their use for quorum-sets, which is described in the thesis. Another potential "non-redundant" use of DAs can be achieved if the model is enhanced to provide programmers with explicit tools for implementing atomic types, as described in <ref> [Weihl 1984] </ref>.
Reference: [Xu & Liskov 1988] <author> Andrew Xu and Barbara Liskov. </author> <title> Stream Calls and Locking. DSG note 150, </title> <publisher> MIT, </publisher> <month> January </month> <year> 1988. </year>
Reference: [Zhao & Ramamritham 1985] <author> Wei Zhao and Krithivasan Ramamritham. </author> <title> Use of Transaction Structure for Improving Concurrency. </title> <type> COINS Technical Report 86-2, </type> <institution> University of Massachusetts, </institution> <month> March </month> <year> 1985. </year> <month> 113 </month>
Reference-contexts: However, the conflict graphs there are used only as a helping tool for a scheduler to improve performance of a certain timestamp technique. Our notion of similarity between deadlock detection and serializability of concurrent actions has also been noted in <ref> [Zhao & Ramamritham 1985] </ref>. Much work has been done on the design of commit protocols for top-level actions. [Gray 1978] describes the classic two-phase commit protocol, and some variations like "nested two phase commit protocol", where the participants are ordered and every one communicates with the next one.
References-found: 41

