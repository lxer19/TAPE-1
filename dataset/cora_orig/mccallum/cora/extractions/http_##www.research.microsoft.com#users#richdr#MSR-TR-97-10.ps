URL: http://www.research.microsoft.com/users/richdr/MSR-TR-97-10.ps
Refering-URL: http://www.research.microsoft.com/users/richdr/
Root-URL: http://www.research.microsoft.com
Title: Unifying the User and Kernel Environments  
Author: Richard P. Draves Scott M. Cutshall 
Address: One Microsoft Way Redmond, WA 98052  
Affiliation: Microsoft Research Microsoft Corporation  
Date: March 12, 1997  
Abstract: Technical Report MSR-TR-97-10 
Abstract-found: 1
Intro-found: 1
Reference: [Armand 91] <author> F. </author> <title> Armand. Give a Process to your Drivers! In Proceedings of the EurOpen Autumn 1991 Conference, </title> <address> Budapest, Hungary, </address> <month> September 16-20, </month> <year> 1991. </year>
Reference-contexts: Our contribution is to revive the idea and demonstrate that it is practical with modern hardware and software. The Chorus system <ref> [Armand 91, Rozier et al. 92] </ref> supports the concept of kernel collocation via supervisor tasks. Supervisor tasks execute in privileged mode; they share the kernels address space. Chorus can short-circuit IPC between supervisor tasks, although this is not transparent to the code involved.
Reference: [Baker 95] <author> A. Baker. </author> <title> The Windows NT Device Driver Book: A Guide for Programmers. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1995. </year>
Reference-contexts: That was the extent of the special-purpose device-driver support in our system, but industrial strength device driver interfaces like Microsofts Windows Driver Model (WDM) <ref> [Baker 95] </ref> supply important additional functionality that is available only in the kernel environment. The functionality is certainly important, but possibly it could be supplied in a more general fashion. As examples, we discuss several areas of WDM functionality and consider how they might be designed differently.
Reference: [Bala et al. 94] <author> K. Bala, M. F. Kaashoek, W. E. Weihl. </author> <title> Software Prefetching and Caching for Translation Lookaside Buffers. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 243253, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: The virtual memory system uses a virtual translation lookaside buffer (VTLB) that combines the pmap approach to portability [Rashid et al. 87] with a software TLB implementation <ref> [Huck & Hays 93, Bala et al. 94] </ref>. The implementation can replace any mapping in the VTLB, including kernel mappings, so the VTLB can use a small, fixed-size cache instead of page table pages. 6.1. Intel The Intel architecture presented two challenges for our implementation.
Reference: [Bershad et al. 95] <author> B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. E. Fiuczynski, D. Becker, C. Chambers, S. Eggers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 267284, </pages> <address> Copper Mountain Resort, Colorado, </address> <month> December 3-6, </month> <year> 1995. </year>
Reference-contexts: In contrast to these systems, our work allows trusted components to be transparently collocated in the kernel address space for improved performance. 3 Some extensible operating systems protect against misbehaving or malicious code that has been loaded into the kernel. For example, Spin <ref> [Bershad et al. 95] </ref> accomplishes this for kernel extensions written in a version of Modula-3. However, this approach increases the gap between the user and kernel programming environments. The extensions are typically small pieces of code that modify the kernels policies or mechanisms and not complete subsystems.
Reference: [Bolosky et al. 96] <author> W. J. Bolosky, J. S. Barrera III, R. P. Draves, R. P. Fitzgerald, G. A. Gibson, M. B. Jones, S. P. Levi, N. P. Myhrvold, R. F. Rashid. </author> <title> The Tiger Video Fileserver. </title> <booktitle> In Proceedings of the Sixth International Workshop on Network and Operating System Support for Digital Audio and Video, IEEE Computer Society, </booktitle> <address> Zushi, Japan, </address> <month> April, </month> <year> 1996. </year>
Reference-contexts: The set-top box used a PCI bus, a 75Mhz Pentium processor with no secondary cache, and 16MB of main memory. The STB also had three PCI cards, for ethernet, MPEG video, and graphics. The STB displayed 2Mb/s MPEG-I digitized video from the Tiger video file system <ref> [Bolosky et al. 96] </ref> on the head-end server. The head-end server also hosted many other ITV services, including the channel and program databases, financial transaction services, and a server for program binaries. Users interacted with the STB via a handheld infra-red remote controller. The test scenarios used three application programs.
Reference: [Brockschmidt 95] <author> K. Brockschmidt. </author> <title> Inside OLE, Second Edition. </title> <publisher> Microsoft Press, </publisher> <address> Redmond, WA, </address> <year> 1995. </year> <note> Table 7-5: Increase in MIPS TLB Misses MOD EPG MODEPG User/kernel 2.25% 2.74% 2.33% Kernel/kernel 0.32% 0.48% 0.45% Total 2.58% 3.22% 2.78% 16 </note>
Reference-contexts: The implementation segregates machinedependent code for portability; we have ports for Intel processors and for the MIPS R3000. Rialto uses single mechanism based on the Component Object Model (COM) <ref> [Brockschmidt 95] </ref> for both system calls and RPC. In this model, objects like processes or threads export one or more interfaces (C++-style arrays of method pointers). A standard QueryInterface method allows a client to bind dynamically to interfaces.
Reference: [Condict et al. 94] <author> M. Condict, D. Bolinger, D. Mitchell, E. McManus. </author> <title> Microkernel Modularity with Integrated Kernel Performance. </title> <booktitle> http://www.cs.utah.edu/~lepreau/osdi94/condict/abstract.html. Presented at the Mach-Chorus Workshop at the First Symposium on Operating Systems Design and Implementation, </booktitle> <address> Monterey, California, </address> <month> November 14-17, </month> <year> 1994. </year>
Reference-contexts: As a result, a program can be built to run as a supervisor task and communicate more efficiently with the kernel and other supervisor tasks. Supervisor tasks also have access to additional APIs for managing interrupts and low-level I/O. Some versions of Mach <ref> [Lepreau et al. 93, Condict et al. 94] </ref> also support kernel collocation to allow privileged subsystems like the Unix server to run in the Mach kernel. Our system builds upon the kernel collocation ideas from Chorus and Mach to unify user-level and kernel-level programming.
Reference: [Corbato et al. 72] <author> F. J. Corbato, J. H. Saltzer, and C. T. Clingen. </author> <title> MulticsThe First Seven Years. </title> <booktitle> In Proceedings of the American Federation of Information Processing Societies Spring Joint Computer Conference, </booktitle> <pages> pages 571583, </pages> <year> 1972. </year> <note> Reprinted in P. Freeman. Software Systems Principles. </note> <institution> Science Research Associates, Chicago, </institution> <year> 1975. </year>
Reference-contexts: It is worth reemphasizing that the only differentiation between Multics system programmers and user programmers is embodied in the access control mechanism which determines what online information can be referenced; therefore, what are apparently two groups of users can be discussed as one. <ref> [Corbato et al. 72] </ref> Although Multics achieved our software-engineering goal of a unified programming environment, it did so with a hardware base and software organization that is now thirty years old. Our contribution is to revive the idea and demonstrate that it is practical with modern hardware and software.
Reference: [Custer 92] <author> H. Custer. </author> <title> Inside Windows NT. </title> <publisher> Microsoft Press, </publisher> <address> Redmond, Washington, </address> <year> 1992. </year>
Reference-contexts: Coda was able to mitigate the performance impact by putting a small name and symbolic link cache in the inkernel VFS driver [Steere et al. 90]. In early versions of Windows NT <ref> [Custer 92] </ref>, Microsoft implemented the Win32 GUI subsystem as a user-level process. With version 4.0, Microsoft moved the GUI subsystem into the kernel address space to improve performance.
Reference: [Cutler 97] <author> D. Cutler, </author> <title> Windows NT Architect. </title> <type> Personal communication, </type> <month> March </month> <year> 1997. </year>
Reference-contexts: It took ten months to stabilize the resulting system, longer than any previous NT release, although many other factors (for example, switching to the Windows 95 user interface) also contributed to this delay <ref> [Cutler 97] </ref>. The Open Software Foundations DCE RPC runtime lives in each user process that uses RPC. The OSF source code uses conditional compilation to build a separate version for the OSF kernel.
Reference: [Draves et al. 91] <author> R. P. Draves, B. N. Bershad, R. F. Rashid, and R. W. Dean. </author> <title> Using Continuations to Implement Thread Management and Communication in Operating Systems. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 122136, </pages> <address> Pacific Grove, California, </address> <month> October 13-16, </month> <year> 1991. </year>
Reference-contexts: Page-fault processing must happen in a context that can tolerate blocking or preemption. For example, the page-fault handler may block when it tries to enter critical sections in the virtual memory system or when it waits for paging I/O to complete. Continuation techniques <ref> [Draves et al. 91] </ref> can eliminate the need for a stack in some blocking contexts, but in general the page-fault handler must run on a thread stack or the moral equivalent. To handle a kernel stack page fault, it suffices to perform initial page-fault processing on a small, fixed-size stack.
Reference: [Draves et al. 97] <author> R. P. Draves, G. Odinak, S. M. Cutshall. </author> <title> The Rialto Virtual Memory System. </title> <type> Technical Report MSR-TR-97-04, </type> <institution> Microsoft Research, </institution> <month> February 15, </month> <year> 1997. </year>
Reference-contexts: Our current implementation reclaims unused stack pages every ten seconds. 6. Implementation Our implementation of the Rialto kernel successfully unified the user and kernel environments. Rialto is a small, soft real-time system designed for disk-less consumer devices <ref> [Jones et al. 96, Draves et al. 97] </ref>. Rialto supports multiple address spaces and provides a strong separation between user mode and kernel mode operation, but it does not support demand paging or swapping.
Reference: [Druschel & Peterson 93] <author> P. Druschel and L. L. Peterson. Fbufs: </author> <title> A High-Bandwidth Cross-Domain Transfer Facility. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 189202, </pages> <address> Asheville, North Carolina, </address> <month> December 5-8, </month> <year> 1993. </year>
Reference-contexts: Two modules in a protocol stack may require an elaborate internal interface for efficient communication. There are two responses to this line of reasoning. First, it is possible to design interfaces that allow data movement across address space boundaries without copies (for example, <ref> [Druschel & Peterson 93] </ref>). In an ideal world we would design efficient interfaces that worked well both within an address space and across address space boundaries. Second, in the real world it is feasible to create separate internal and external interfaces, where the internal interface assumes collocated callers and callees.
Reference: [Engler et al. 95] <author> D. R. Engler, M. F. Kaashoek, and J. OToole Jr. Exokernel: </author> <title> An Operating System Architecture for Application-Level Resource Management. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 251266, </pages> <address> Copper Mountain Resort, Colorado, </address> <month> December 3-6, </month> <year> 1995. </year>
Reference-contexts: The small kernel operating system design has a long history; we only mention two recent examples. L4 [Liedtke 95] takes this approach, motivated by modularity, common interfaces, and flexibility. A device driver process maps I/O ports and the kernel converts device interrupts into IPC messages. The exo-kernel <ref> [Engler et al. 95] </ref> removes resource management policy and mechanism from the kernel, to the greatest extent possible. The kernel exposes hardware resources in a secure manner and vectors interrupts to user processes.
Reference: [Grunwald & Neves 96] <author> D. Grunwald and R. Neves. </author> <title> Whole-Program Optimization for Time and Space Efficient Threads. </title> <booktitle> In Proceedings of the Seventh International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 5059, </pages> <address> Cambridge, Massachusetts, </address> <month> October 1-5, </month> <year> 1996. </year>
Reference-contexts: One approach to lifting the size restriction on kernel-mode stacks would be to analyze call graphs in the kernel and at appropriate points insert code to grow the stack if necessary. This technique has been demonstrated with whole-program analysis of applications <ref> [Grunwald & Neves 96] </ref>. However, whole-program analysis is not feasible when the address space contains dynamically loaded modules or shared libraries with composite call graphs that can not be analyzed in advance.
Reference: [Huck & Hays 93] <author> J. Huck and J. Hays. </author> <title> Architectural Support for Translation Table Management in Large Address Space Machines. </title> <booktitle> In Proceedings of the 20 th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 3950, </pages> <address> San Diego, California, </address> <month> May 16-19, </month> <year> 1993. </year>
Reference-contexts: The virtual memory system uses a virtual translation lookaside buffer (VTLB) that combines the pmap approach to portability [Rashid et al. 87] with a software TLB implementation <ref> [Huck & Hays 93, Bala et al. 94] </ref>. The implementation can replace any mapping in the VTLB, including kernel mappings, so the VTLB can use a small, fixed-size cache instead of page table pages. 6.1. Intel The Intel architecture presented two challenges for our implementation.
Reference: [Husain & Parker 96] <author> K. Husain and T. Parker. </author> <title> Linux Unleashed, Second Edition. </title> <publisher> SAMS Publishing, </publisher> <address> Indianapolis, Indiana, </address> <year> 1996. </year>
Reference-contexts: Position-Independent Code Some implementations of shared libraries use position-independent code (PIC). PIC allows the shared library to run at a different virtual address in each address space, including the kernel. For example, the Linux <ref> [Husain & Parker 96] </ref> operating system uses PIC for shared libraries. PIC eliminates any problems with reserving address space regions in different processes or relocating code at runtime. However, PIC imposes a significant performance penalty on some processor architectures.
Reference: [Intel 95] <editor> Pentiumfi Processor Family Developers Manual, </editor> <volume> Volume 3. </volume> <publisher> Intel Corporation, </publisher> <address> Santa Clara, California, </address> <year> 1995. </year>
Reference-contexts: Privileged forms of the load and store instructions force the processor to use the user page-table base register. These instructions allow the kernel, running in supervisor mode, to access the current user processs address space. Segmented architectures like Intel <ref> [Intel 95] </ref> or Hewlett-Packards PARISC [Kane 96] also make it possible to create independent user and kernel address spaces. A trap into kernel mode changes the active segments and switches to the kernel address space.
Reference: [Jones et al. 96] <author> M. B. Jones, J. S. Barrera III, A. Forin, P. J. Leach, D. Rosu, M.-C. Rosu. </author> <title> An Overview of the Rialto Real-Time Architecture. </title> <booktitle> In Proceedings of the Seventh ACM SIGOPS European Workshop, </booktitle> <pages> pages 249256, </pages> <address> Connemara, Ireland, </address> <month> September, </month> <year> 1996. </year>
Reference-contexts: Our current implementation reclaims unused stack pages every ten seconds. 6. Implementation Our implementation of the Rialto kernel successfully unified the user and kernel environments. Rialto is a small, soft real-time system designed for disk-less consumer devices <ref> [Jones et al. 96, Draves et al. 97] </ref>. Rialto supports multiple address spaces and provides a strong separation between user mode and kernel mode operation, but it does not support demand paging or swapping.
Reference: [Kane 88] <author> G. Kane. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1988. </year>
Reference-contexts: With this approach shared libraries can be loaded at the same virtual address across all address spaces including the kernel. However, this approach makes it difficult for the kernel to access the current user address space. Different processor architectures support this technique to varying degrees. The MIPS architecture <ref> [Kane 88] </ref> restricts user processes to the low half of the address space and encourages the kernel to use the high half. On the other hand, the Motorola 88K architecture [Tucker & Coorpender 91] provides independent user and supervisor address spaces.
Reference: [Kane 96] <author> G Kane. </author> <title> PARISC 2.0 Architecture. </title> <publisher> Prentice-Hall PTR, </publisher> <address> Upper Saddle River, New Jersey, </address> <year> 1996. </year>
Reference-contexts: Privileged forms of the load and store instructions force the processor to use the user page-table base register. These instructions allow the kernel, running in supervisor mode, to access the current user processs address space. Segmented architectures like Intel [Intel 95] or Hewlett-Packards PARISC <ref> [Kane 96] </ref> also make it possible to create independent user and kernel address spaces. A trap into kernel mode changes the active segments and switches to the kernel address space. Inside the kernel hand-crafted assembly-language functions can set up a spare segment register to access the current user address space.
Reference: [Kazar 97] <author> M. Kazar. </author> <type> Personal communication, </type> <month> February 21, </month> <year> 1997. </year>
Reference-contexts: For instance, during the development of the Andrew File System (AFS), the Windows NT Win32 subsystem, and the DCE RPC runtime, a unified user/kernel environment would have yielded software-engineering improvements. There were several reasons for moving AFSs user-level cache manager into the kernel <ref> [Kazar 97] </ref>. They included improved performance, improved semantics (for example, by using internal kernel interfaces it was possible to check file versions in the read system call path and it was possible to fetch file chunks instead of performing whole-file transfer), and easier porting.
Reference: [Lepreau et al. 93] <author> J. Lepreau, M. Hibler, B. Ford, J. </author> <title> Law. InKernel Servers on Mach 3.0: Implementation and Performance. </title> <booktitle> In Proceedings of the USENIX Mach III Symposium, </booktitle> <pages> pages 3955, </pages> <address> Sante Fe, New Mexico, </address> <month> April 19-21, </month> <year> 1993. </year>
Reference-contexts: As a result, a program can be built to run as a supervisor task and communicate more efficiently with the kernel and other supervisor tasks. Supervisor tasks also have access to additional APIs for managing interrupts and low-level I/O. Some versions of Mach <ref> [Lepreau et al. 93, Condict et al. 94] </ref> also support kernel collocation to allow privileged subsystems like the Unix server to run in the Mach kernel. Our system builds upon the kernel collocation ideas from Chorus and Mach to unify user-level and kernel-level programming.
Reference: [Liedtke 95] <editor> J. Liedtke. </editor> <booktitle> 2Qfl .HUQHOfl&RQVWUXFWLRQfl,QflProceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 237250, </pages> <address> Copper Mountain Resort, Colorado, </address> <month> December 3-6, </month> <year> 1995. </year>
Reference-contexts: Device drivers, file systems, protocol stacks, subsystems, etc. are all implemented in user-level processes. The small kernel operating system design has a long history; we only mention two recent examples. L4 <ref> [Liedtke 95] </ref> takes this approach, motivated by modularity, common interfaces, and flexibility. A device driver process maps I/O ports and the kernel converts device interrupts into IPC messages. The exo-kernel [Engler et al. 95] removes resource management policy and mechanism from the kernel, to the greatest extent possible.
Reference: [Organick 72] <author> E. I. Organick. </author> <title> The Multics System: An Examination of Its Structure. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1972. </year>
Reference-contexts: The Chorus system and some versions of Mach support kernel collocation. Small kernel systems move all programming into user-mode, eliminating the kernel programming environment altogether. Some extensible kernels support the safe injection of code into the kernel address space. The Multics system <ref> [Organick 72] </ref> was designed to create a single environment for all programs, including device drivers. Multics ran on special-purpose hardware, the GE 645. Processes consisted of a collection of segments, and segments were normally shared between processes with per-segment access control.
Reference: [Rashid et al. 87] <author> R. Rashid, A. Tevanian, M. Young, D. Golub, R. Baron, D. Black, W. Bolosky, and J. Chew. </author> <title> Machine-Independent Virtual Memory Management for Paged Uniprocessor and Multiprocessor Architectures. </title> <booktitle> In Proceedings of the Second International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 3139, </pages> <address> Palo Alto, California, </address> <month> October 5-8, </month> <year> 1987. </year>
Reference-contexts: Without affecting the unified programming environment but with some increase in complexity, we could have provided user threads with their own kernel stacks. The virtual memory system uses a virtual translation lookaside buffer (VTLB) that combines the pmap approach to portability <ref> [Rashid et al. 87] </ref> with a software TLB implementation [Huck & Hays 93, Bala et al. 94]. The implementation can replace any mapping in the VTLB, including kernel mappings, so the VTLB can use a small, fixed-size cache instead of page table pages. 6.1.
Reference: [Ritchie & Thompson 78] <author> D. M. Ritchie and K. Thompson. </author> <title> The UNIX TimeSharing System. </title> <journal> The Bell System Technical Journal, </journal> <volume> 57(6): </volume> <pages> pages 19051930, </pages> <address> July-August, </address> <year> 1978. </year>
Reference-contexts: This section discusses whether it is feasible to unify the user-level and kernel-level systems programming interfaces in a general-purpose operating system. The kernel environment in the first versions of Unix <ref> [Ritchie & Thompson 78] </ref> was substantially simpler than one finds in commercial systems today. Binaries could be loaded into new processes but not into the kernel address space; device drivers were compiled into the kernel image.
Reference: [Salz 97] <author> R. Salz, </author> <title> Open Software Foundation. </title> <type> Personal communication, </type> <month> March </month> <year> 1997. </year>
Reference-contexts: The OSF source code uses conditional compilation to build a separate version for the OSF kernel. Because of differences in the kernel environment, the kernel implementation does not support TCP and it uses a separate helper program for authentication <ref> [Salz 97] </ref>. Developing, maintaining, and testing a separate kernel version adds software-engineering costs. Microsofts DCE RPC is also a user-mode shared library. The Microsoft implementation does not support the NT kernel environment.
Reference: [Steere et al. 90] <author> D. C. Steere, J. J. Kistler, M. Satyanarayanan. </author> <title> Efficient User-Level Cache Management on the Sun Vnode Interface. </title> <booktitle> In Proceedings of the Summer Usenix Technical Conference, </booktitle> <address> Anaheim, California, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: The Coda project, an AFS descendant, continued to use a user-level cache manager because of the ease of development and debugging. Coda was able to mitigate the performance impact by putting a small name and symbolic link cache in the inkernel VFS driver <ref> [Steere et al. 90] </ref>. In early versions of Windows NT [Custer 92], Microsoft implemented the Win32 GUI subsystem as a user-level process. With version 4.0, Microsoft moved the GUI subsystem into the kernel address space to improve performance.
Reference: [Tucker & Coorpender 91] <author> M. Tucker and B. Coorpender. </author> <title> Programming the Motorola 88000. Windcrest Books, Blue Ridge Summit, </title> <address> Pennsylvania, </address> <year> 1991. </year>
Reference-contexts: Different processor architectures support this technique to varying degrees. The MIPS architecture [Kane 88] restricts user processes to the low half of the address space and encourages the kernel to use the high half. On the other hand, the Motorola 88K architecture <ref> [Tucker & Coorpender 91] </ref> provides independent user and supervisor address spaces. The 88200 CMMU has two page-table base registers, for user mode and for supervisor mode. Privileged forms of the load and store instructions force the processor to use the user page-table base register.
References-found: 30

