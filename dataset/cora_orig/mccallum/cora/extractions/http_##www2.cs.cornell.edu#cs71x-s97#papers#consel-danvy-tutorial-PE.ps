URL: http://www2.cs.cornell.edu/cs71x-s97/papers/consel-danvy-tutorial-PE.ps
Refering-URL: http://www2.cs.cornell.edu/cs71x-s97/
Root-URL: http://www.cs.cornell.edu
Email: consel@cse.ogi.edu  Olivier.Danvy@cs.cmu.edu  
Title: Partial Evaluation: Principles and Perspectives  
Author: Charles Consel Olivier Danvy 
Affiliation: Pacific Software Research Center Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  School of Computer Science Carnegie Mellon University  
Abstract: The last years have witnessed a flurry of new results in the area of partial evaluation. These tutorial notes survey the field and present a critical assessment of the state of the art. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. D. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Unless imperative features are encapsulated in some language constructs and so side-effects are disciplined, it is difficult to reason about the flow of static data. Duplication of side-effects and aliasing are the main concerns <ref> [1] </ref>. 4 Termination Due to its basic strategy | unfolding calls and specializing functions, partial evaluation can loop in two ways: either by unfolding infinitely many function calls or by creating infinitely many specialized functions. <p> In [37], Consel, Pu and Walpole describe a research project aimed at using partial evaluation to derive automatically implementations of operating system components from generic specifications. They outline the necessary extensions to partial evaluation required for this derivation. 7 Related Work All optimizing compilers include constant propagation and folding <ref> [1] </ref>. The need for optimizing compilers to be efficient has motivated Wegman and Zadeck to study this subject on its own [107]. For another example, Deutsch's interactive program verifier, like many other theorem provers, includes a simplification phase performing static reductions [41].
Reference: [2] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: If the traversal goes from left to right and the text is static, the residual program is structured like a Weiner tree [108] (named a "position tree" by Aho, Hopcroft, and Ullman <ref> [2] </ref>). If the traversal goes from right to left and the string is static, the residual program mimics the effect of the Boyer & Moore string-matching algorithm.
Reference: [3] <author> L. O. Andersen. </author> <title> Self-applicable C program specialization. </title> <booktitle> In Consel [26], </booktitle> <pages> pages 54-61. </pages>
Reference-contexts: Partial evaluation has been studied in the context of a wide variety of programming languages. In the area of logic programming, partial deduction is the focus of much work [44, 47, 78, 77]. Partial evaluators for imperative languages like Pascal [84] and C <ref> [3] </ref> have been developed. In equational languages, partial evaluation has been used to optimize rewriting techniques [103], and more recently, it has been applied to Lafont's interaction nets [6]. <p> Nirkhe and Pugh [91] describe a partial evaluator for hard real-time problems where programs are constrained by the user to keep a tight control over the transformation process. Andersen reports a self-applicable partial evaluator for a subset of the C programming language <ref> [3] </ref>. Partial evaluation of imperative programs is difficult because of the lack of referential transparency. The program transformation phase must take into account the notion of state and thus is more complicated than in a functional setting [55].
Reference: [4] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cam-bridge University Press, </publisher> <year> 1992. </year> <month> 6 </month>
Reference-contexts: Mosses's compiler generator SIS includes a phase for compiler-generation time reductions and allows for compile-time reductions [87]. Appel's technique of "reopening closures" explicitly aims at specializing functions at compile time <ref> [4] </ref>. In fact, Lombardi and Raphael's main tool in their pioneer work on incremental computation was partial evaluation [81]. The investigations above have one point in common: they use program transformation as a phase in a larger system. Therefore this phase needs to be efficient.
Reference: [5] <author> W. Au and D. Weise. </author> <title> Automatic generation of compiler simulation through program specialization. </title> <booktitle> In IEEE Conference on Design Automation, </booktitle> <pages> pages 205-210, </pages> <year> 1991. </year>
Reference-contexts: control string. 1.2 Applications Because of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation [31, 34, 39, 59, 69, 71, 74], string and pattern matching [28, 40, 70, 94, 104], computer graphics [85], numerical computation [8], circuit simulation <ref> [5] </ref>, and hard real-time systems [91]. Partial evaluation has been studied in the context of a wide variety of programming languages. In the area of logic programming, partial deduction is the focus of much work [44, 47, 78, 77].
Reference: [6] <author> Denis Bechet. </author> <title> Partial evaluation of interaction nets. </title> <booktitle> In WSA'92 [111], </booktitle> <pages> pages 331-338. </pages>
Reference-contexts: Partial evaluators for imperative languages like Pascal [84] and C [3] have been developed. In equational languages, partial evaluation has been used to optimize rewriting techniques [103], and more recently, it has been applied to Lafont's interaction nets <ref> [6] </ref>. A broader discussion and more detailed references on contemporary work in the area of partial evaluation and on applications of partial evaluation can be found in Jones, Gomard, and Sestoft's new book [67]. Overview. This paper is organized as follows.
Reference: [7] <author> L. Beckman, A. Haraldsson, O. Oskarsson, and E. Sandewall. </author> <title> A partial evaluator, and its use as a programming tool. </title> <journal> Artificial Intelligence, </journal> <volume> 7(4) </volume> <pages> 319-357, </pages> <year> 1976. </year>
Reference-contexts: A polyvariant specializer can produce many specialized versions of a source function [18]. 2.3 Online vs. o*ine partial evaluation Contemporary partial evaluators are divided in two classes: online, monolithic partial evaluators and o*ine, staged partial evaluators. Before Jones's Mix system, all partial evaluators were online <ref> [7, 56, 81, 101] </ref>. Today, both online and o*ine partial-evaluation strategies are the subject of active research. An online partial-evaluator is a non-standard interpreter. The treatment of each expression is determined on the fly. Online partial-evaluators in general are very accurate but at the price of a considerable interpretive overhead.
Reference: [8] <author> A. </author> <title> Berlin. Partial evaluation applied to numerical computation. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 139-150, </pages> <year> 1990. </year>
Reference-contexts: interpretation of the control string. 1.2 Applications Because of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation [31, 34, 39, 59, 69, 71, 74], string and pattern matching [28, 40, 70, 94, 104], computer graphics [85], numerical computation <ref> [8] </ref>, circuit simulation [5], and hard real-time systems [91]. Partial evaluation has been studied in the context of a wide variety of programming languages. In the area of logic programming, partial deduction is the focus of much work [44, 47, 78, 77].
Reference: [9] <editor> D. Bjtrner, A. P. Ershov, and N. D. Jones, editors. </editor> <title> Partial Evaluation and Mixed Computation. </title> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference: [10] <author> C. Bohm. Subduing self-application. </author> <booktitle> In 16th International Colloquium on Automata, Languages and Programming, volume 372 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference: [11] <author> A. Bondorf. </author> <title> Towards a self-applicable partial evaluator for term rewriting systems. </title> <editor> In Bjtrner et al. </editor> <volume> [9]. </volume>
Reference-contexts: In an earlier work, we proposed to stage PE further by shifting the interpretation of binding times from PE to PE [24, 29]. This shift substantially simplifies the specializer. To get the best of both worlds, online and o*ine partial-evaluation can be combined as follows <ref> [11, 109] </ref>. Whenever the exact binding-time property of an expression can be determined, o*ine partial evaluation is used. Otherwise, the treatment for this expression is postponed until specialization time, when concrete values are available. <p> Whenever the exact binding-time property of an expression can be determined, o*ine partial evaluation is used. Otherwise, the treatment for this expression is postponed until specialization time, when concrete values are available. Bondorf's partial evaluator for term-rewriting sys tems uses this strategy <ref> [11] </ref>. 2.4 Formalizing partial evaluation Much effort is devoted to specifying and proving o*ine partial-evaluation. Gomard defines the denotational semantics of the specialization process for the -calculus and proves its correctness [53]. Launchbury formulates a binding-time analysis for a first-order applicative language with projections [63, 79].
Reference: [12] <author> A. Bondorf. </author> <title> Self-Applicable Partial Evaluation. </title> <type> PhD thesis, </type> <institution> University of Copenhagen, DIKU, Copenhagen, Denmark, </institution> <year> 1990. </year> <type> DIKU Report 90-17. </type>
Reference: [13] <author> A. Bondorf. </author> <title> Automatic autoprojection of higher-order recursive equations. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 17 </volume> <pages> 3-34, </pages> <year> 1991. </year>
Reference-contexts: This binding-time information is then used to guide the processing phase PE that performs the specialization proper. Binding-time analysis is necessarily approximate 1 and thus o*ine partial-evaluators are usually less accurate than online ones. Binding-time analysis has been intensively studied in the framework of abstract interpretation <ref> [13, 25, 32, 35, 89] </ref> as well as in the framework of type theory [52, 60, 92, 100, 105]. In o*ine, binding-time based partial-evaluators, accurate binding-time information is critical because it determines the degree of the actual specialization. Existing binding-time analyses handle higher-order functions and data structures. <p> The system handles recursive equations, customizable primitive operators and global side-effects. It also includes a binding-time debugger [88]. Since then, it has been extended to handle higher-order functions <ref> [13] </ref> and more recently partially-static values [15]. Today, the new version of Similix is based on Hen-glein's efficient type-inference for binding-time analysis [60]. Similix is freely available and is used as a black box in Harnett and Montenyohl's investigation of programming languages [59].
Reference: [14] <author> A. Bondorf. </author> <title> Similix manual, system version 3.0. </title> <type> Technical Report 91/9, </type> <institution> Computer Science Department, University of Copenhagen, </institution> <year> 1991. </year>
Reference-contexts: In addition, occurrences of some static data in the residual program signify that, in the source program, the static data are not processed independently of the dynamic data. This leads to strategies for restructuring source programs to "improve their binding times" <ref> [14, 15, 30] </ref>. Independently of the two points above, one is often surprised to find redundant tests in one's residual programs | usually a tell-tale of unexpected redundancies in the source programs.
Reference: [15] <author> A. Bondorf. </author> <title> Improving binding times without explicit CPS-conversion. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 1-10, </pages> <year> 1992. </year>
Reference-contexts: In addition, occurrences of some static data in the residual program signify that, in the source program, the static data are not processed independently of the dynamic data. This leads to strategies for restructuring source programs to "improve their binding times" <ref> [14, 15, 30] </ref>. Independently of the two points above, one is often surprised to find redundant tests in one's residual programs | usually a tell-tale of unexpected redundancies in the source programs. <p> The system handles recursive equations, customizable primitive operators and global side-effects. It also includes a binding-time debugger [88]. Since then, it has been extended to handle higher-order functions [13] and more recently partially-static values <ref> [15] </ref>. Today, the new version of Similix is based on Hen-glein's efficient type-inference for binding-time analysis [60]. Similix is freely available and is used as a black box in Harnett and Montenyohl's investigation of programming languages [59].
Reference: [16] <author> A. Bondorf and O. Danvy. </author> <title> Automatic autoprojec-tion of recursive equations with global variables and abstract data types. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 16 </volume> <pages> 151-195, </pages> <year> 1991. </year>
Reference-contexts: Bondorf's partial evaluator Similix is an o*ine poly-variant system and was explicitly designed to be self-applicable and mostly automatic, based on a fixed specialization strategy <ref> [16] </ref>. The system handles recursive equations, customizable primitive operators and global side-effects. It also includes a binding-time debugger [88]. Since then, it has been extended to handle higher-order functions [13] and more recently partially-static values [15]. <p> The strategy adopted in Similix, for example, is very simple and appears to be applicable in most situations in an automatic way: dynamic conditional-expressions (i.e., conditional expressions whose test do not evaluate to a static value) are selected as specialization points and all procedure calls are unfolded <ref> [16] </ref>. Schism offers a more flexible annotation strategy: filters, that can be used both in an online or in an o*ine strategy [23, 24, 27].
Reference: [17] <author> R. S. Boyer and J. S. Moore. </author> <title> A fast string searching algorithm. </title> <journal> Communications of the ACM, </journal> 20(10) 62-72, 1976. 
Reference-contexts: non-trivial programs are often instances of simpler ones [99, Chapter 5]. 6.1 Pattern Matching Let us consider the following string matching problem: does a string occur within a text? A variety of solutions have been proposed | for example, by Knuth, Morris, & Pratt [76] and by Boyer & Moore <ref> [17] </ref> | that essentially solve this problem in linear time with respect to the size of the string and of the text.
Reference: [18] <author> M. A. Bulyonkov. </author> <title> Polyvariant mixed computation for analyzer programs. </title> <journal> Acta Informatica, </journal> <volume> 21 </volume> <pages> 473-484, </pages> <year> 1984. </year>
Reference-contexts: A partial evaluator propagates constant values and folds constant expressions. It also inlines functions by unfolding calls, and produces specialized functions by residualizing calls. A monovariant specializer produces at most one specialized function for every source function. A polyvariant specializer can produce many specialized versions of a source function <ref> [18] </ref>. 2.3 Online vs. o*ine partial evaluation Contemporary partial evaluators are divided in two classes: online, monolithic partial evaluators and o*ine, staged partial evaluators. Before Jones's Mix system, all partial evaluators were online [7, 56, 81, 101]. Today, both online and o*ine partial-evaluation strategies are the subject of active research.
Reference: [19] <author> R. M. Burstall and J. Darlington. </author> <title> A transformational system for developing recursive programs. </title> <journal> Journal of ACM, </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <year> 1977. </year>
Reference-contexts: Therefore this phase needs to be efficient. Alternatively, transforming a program can be the main goal of a system, and then the emphasis is put first on understanding what is going on as a preliminary step to making the transformation efficient <ref> [19] </ref>. We also observe a new trend in using one of the main techniques of partial evaluation | polyvariance | in modern compilers [20, 38].
Reference: [20] <author> C. Chambers and D. Ungar. </author> <title> Customization: Optimizing compiler technology for SELF, a dynamically-typed object-oriented programming language. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, SIGPLAN Notices, </booktitle> <volume> Vol. 24, No 7, </volume> <pages> pages 146-160, </pages> <year> 1989. </year>
Reference-contexts: We also observe a new trend in using one of the main techniques of partial evaluation | polyvariance | in modern compilers <ref> [20, 38] </ref>. Acknowledgements We are grateful to Anindya Banerjee, Andrzej Filinski, John Hatcliff, Jim Hook, Neil Jones, Julia Lawall, Jurgen Koslowski, Karoline Malmkjr, Erik Ruf, Tim Sheard, and Anna Sosyura for commenting earlier versions of these notes on short notice.
Reference: [21] <editor> W. Clinger and J. Rees (editors). </editor> <title> Revised 4 report on the algorithmic language Scheme. LISP Pointers, </title> <address> IV(3):1-55, </address> <month> July-September </month> <year> 1991. </year>
Reference-contexts: Partial evaluation identifies and eliminates the compile-time constructs. 1.1 A complete example We consider a function producing formatted text. Such functions exist in most programming languages (e.g., format in Lisp and printf in C). Figure 1 displays a formatting function written in Scheme <ref> [21] </ref>. Given a channel, a control string, and a list of values, this function outputs text in the channel by interpreting the control string to determine how to format the list of values. For conciseness, this function handles only three formatting directives: ~N, ~S and ~%. <p> As such, a partial evaluator is a useful programming tool. 3 State of the Art We first review the state of the art of partial evaluators for call-by-value functional languages such as Scheme <ref> [21] </ref>, and then of partial evaluators for imperative languages. 3.1 Applicative languages Weise's partial evaluator Fuse is an online system and aims at applying partial evaluation to practical problems, such as circuit simulation [109].
Reference: [22] <author> C. Colby and P. Lee. </author> <title> An implementation of parameterized partial evaluation. </title> <booktitle> In WSA'91 [110], </booktitle> <pages> pages 82-89. </pages>
Reference-contexts: The generalization applies for both online and o*ine strategies. Parameterized partial-evaluation has been implemented at CMU <ref> [22] </ref> and at Yale [73] for a first-order subset of ML. Both systems handle partially-static data.
Reference: [23] <author> C. Consel. </author> <title> New insights into partial evaluation: the Schism experiment. </title> <booktitle> In ESOP'88, 2 nd Euro-pean Symposium on Programming, volume 300 of Lecture Notes in Computer Science, </booktitle> <pages> pages 236-246. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Schism offers a more flexible annotation strategy: filters, that can be used both in an online or in an o*ine strategy <ref> [23, 24, 27] </ref>. The user can equip each function with a filter, specifying under which conditions a call to this function should be unfolded and, if the call needs to be residualized, which parameters should be used for the specialization of this function.
Reference: [24] <author> C. Consel. </author> <title> Analyse de Programmes, Evaluation Partielle et Generation de Compilateurs. </title> <type> PhD thesis, </type> <institution> Universite de Paris VI, Paris, France, </institution> <month> June </month> <year> 1989. </year>
Reference-contexts: Newer ones are also polyvariant. The binding-time information determines whether an expression can be evaluated at partial-evaluation time or must be evaluated at runtime. In an earlier work, we proposed to stage PE further by shifting the interpretation of binding times from PE to PE <ref> [24, 29] </ref>. This shift substantially simplifies the specializer. To get the best of both worlds, online and o*ine partial-evaluation can be combined as follows [11, 109]. Whenever the exact binding-time property of an expression can be determined, o*ine partial evaluation is used. <p> Schism offers a more flexible annotation strategy: filters, that can be used both in an online or in an o*ine strategy <ref> [23, 24, 27] </ref>. The user can equip each function with a filter, specifying under which conditions a call to this function should be unfolded and, if the call needs to be residualized, which parameters should be used for the specialization of this function.
Reference: [25] <author> C. Consel. </author> <title> Binding time analysis for higher order untyped functional languages. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 264-272, </pages> <year> 1990. </year>
Reference-contexts: This binding-time information is then used to guide the processing phase PE that performs the specialization proper. Binding-time analysis is necessarily approximate 1 and thus o*ine partial-evaluators are usually less accurate than online ones. Binding-time analysis has been intensively studied in the framework of abstract interpretation <ref> [13, 25, 32, 35, 89] </ref> as well as in the framework of type theory [52, 60, 92, 100, 105]. In o*ine, binding-time based partial-evaluators, accurate binding-time information is critical because it determines the degree of the actual specialization. Existing binding-time analyses handle higher-order functions and data structures.
Reference: [26] <author> C. Consel, </author> <title> editor. ACM Workshop on Partial Evaluation and Semantics-Based Program Manipulation. </title> <type> Research Report 909, </type> <institution> Department of Computer Science, Yale University, </institution> <year> 1992. </year>
Reference: [27] <author> C. Consel. </author> <note> Report on Schism'92. Research report, </note> <institution> Pacific Software Research Center, Oregon Graduate Institute of Science and Technology, Beaverton, Oregon, USA, </institution> <year> 1992. </year>
Reference-contexts: Independently, Gengler and Rytz have extended the system with a polyvariant binding-time analysis and with partially static values [48, 98]. Consel's partial evaluator Schism is an o*ine poly-variant system with a flexible specialization strategy, higher-order functions, and partially-static values <ref> [27] </ref>. Both the binding-time analysis and the specialization are polyvariant. The system includes a binding-time based programming-environment [36]. Both source programs and specialized programs are expressed in Scheme, extended with ML-like datatypes. 3.2 Imperative languages Partial evaluation of imperative programs has received much attention recently. <p> Schism offers a more flexible annotation strategy: filters, that can be used both in an online or in an o*ine strategy <ref> [23, 24, 27] </ref>. The user can equip each function with a filter, specifying under which conditions a call to this function should be unfolded and, if the call needs to be residualized, which parameters should be used for the specialization of this function. <p> Lawall makes a considerable use of filters for her application of partial evaluation to theorem proving [80]. Filters can also be generated automatically, based on any strategy. For example, an analysis corresponding to the strategy of Similix is available in Schism <ref> [27] </ref>. As an online partial-evaluator, Fuse keeps a dynamic cache of program points [109, Section 3]. Specialization naturally terminates when all loops that are unrolled statically terminate or are broken by a cache hit. Otherwise, an arbitrary bound is needed.
Reference: [28] <author> C. Consel and O. Danvy. </author> <title> Partial evaluation of pattern matching in strings. </title> <journal> Information Processing Letters, </journal> <volume> 30(2) </volume> <pages> 79-86, </pages> <year> 1989. </year>
Reference-contexts: purpose of partial evaluation: eliminating interpretive overhead | here the interpretation of the control string. 1.2 Applications Because of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation [31, 34, 39, 59, 69, 71, 74], string and pattern matching <ref> [28, 40, 70, 94, 104] </ref>, computer graphics [85], numerical computation [8], circuit simulation [5], and hard real-time systems [91]. Partial evaluation has been studied in the context of a wide variety of programming languages. <p> This means that we can now match the pattern against a shifted copy of itself, rather than the input string; and the outcome of such a match can be decided at specialization time <ref> [28] </ref>. Rather than rewriting the source program to make it keep a static track of dynamic values, one can also obtain this residual program by generalizing the partial evaluator [46, 58, 104].
Reference: [29] <author> C. Consel and O. Danvy. </author> <title> From interpreting to compiling binding times. </title> <booktitle> In ESOP'90, 3 rd Euro-pean Symposium on Programming, volume 432 of Lecture Notes in Computer Science, </booktitle> <pages> pages 88-105. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Newer ones are also polyvariant. The binding-time information determines whether an expression can be evaluated at partial-evaluation time or must be evaluated at runtime. In an earlier work, we proposed to stage PE further by shifting the interpretation of binding times from PE to PE <ref> [24, 29] </ref>. This shift substantially simplifies the specializer. To get the best of both worlds, online and o*ine partial-evaluation can be combined as follows [11, 109]. Whenever the exact binding-time property of an expression can be determined, o*ine partial evaluation is used.
Reference: [30] <author> C. Consel and O. Danvy. </author> <title> For a better support of static data flow. </title> <booktitle> In Hughes [64], </booktitle> <pages> pages 496-519. </pages>
Reference-contexts: In addition, occurrences of some static data in the residual program signify that, in the source program, the static data are not processed independently of the dynamic data. This leads to strategies for restructuring source programs to "improve their binding times" <ref> [14, 15, 30] </ref>. Independently of the two points above, one is often surprised to find redundant tests in one's residual programs | usually a tell-tale of unexpected redundancies in the source programs.
Reference: [31] <author> C. Consel and O. Danvy. </author> <title> Static and dynamic semantics processing. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 14-23, </pages> <year> 1991. </year>
Reference-contexts: This example illustrates the essential purpose of partial evaluation: eliminating interpretive overhead | here the interpretation of the control string. 1.2 Applications Because of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation <ref> [31, 34, 39, 59, 69, 71, 74] </ref>, string and pattern matching [28, 40, 70, 94, 104], computer graphics [85], numerical computation [8], circuit simulation [5], and hard real-time systems [91]. Partial evaluation has been studied in the context of a wide variety of programming languages.
Reference: [32] <author> C. Consel and S. C. Khoo. </author> <title> Parameterized partial evaluation. </title> <type> Research Report 865, </type> <institution> Yale University, </institution> <address> New Haven, Connecticut, USA, </address> <year> 1991. </year> <note> To appear in Transactions on Programming Languages and Systems. Extended version of [33]. </note>
Reference-contexts: This binding-time information is then used to guide the processing phase PE that performs the specialization proper. Binding-time analysis is necessarily approximate 1 and thus o*ine partial-evaluators are usually less accurate than online ones. Binding-time analysis has been intensively studied in the framework of abstract interpretation <ref> [13, 25, 32, 35, 89] </ref> as well as in the framework of type theory [52, 60, 92, 100, 105]. In o*ine, binding-time based partial-evaluators, accurate binding-time information is critical because it determines the degree of the actual specialization. Existing binding-time analyses handle higher-order functions and data structures. <p> not bound at the same time is classified to have the latest binding time of its components. 3 In their parameterized partial-evaluation, Consel and Khoo allow a program to be specialized not only with actual values of its input, but also with respect to some abstract property of this input <ref> [32] </ref>. The generalization applies for both online and o*ine strategies. Parameterized partial-evaluation has been implemented at CMU [22] and at Yale [73] for a first-order subset of ML. Both systems handle partially-static data.
Reference: [33] <author> C. Consel and S. C. Khoo. </author> <title> Parameterized partial evaluation. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 92-106, </pages> <year> 1991. </year>
Reference: [34] <author> C. Consel and S. C. Khoo. </author> <title> Semantics-directed gen eration of a Prolog compiler. </title> <booktitle> In 3 rd International Symposium on Programming Language Implementation and Logic Programming, volume 528 of Lecture Notes in Computer Science, </booktitle> <pages> pages 135-146. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <month> 7 </month>
Reference-contexts: This example illustrates the essential purpose of partial evaluation: eliminating interpretive overhead | here the interpretation of the control string. 1.2 Applications Because of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation <ref> [31, 34, 39, 59, 69, 71, 74] </ref>, string and pattern matching [28, 40, 70, 94, 104], computer graphics [85], numerical computation [8], circuit simulation [5], and hard real-time systems [91]. Partial evaluation has been studied in the context of a wide variety of programming languages.
Reference: [35] <author> C. Consel and S.C. Khoo. </author> <title> On-line & off-line partial evaluation: Semantic specifications and correctness proofs. </title> <type> Research Report 896, </type> <institution> Yale University, </institution> <address> New Haven, Connecticut, USA, </address> <year> 1992. </year>
Reference-contexts: This binding-time information is then used to guide the processing phase PE that performs the specialization proper. Binding-time analysis is necessarily approximate 1 and thus o*ine partial-evaluators are usually less accurate than online ones. Binding-time analysis has been intensively studied in the framework of abstract interpretation <ref> [13, 25, 32, 35, 89] </ref> as well as in the framework of type theory [52, 60, 92, 100, 105]. In o*ine, binding-time based partial-evaluators, accurate binding-time information is critical because it determines the degree of the actual specialization. Existing binding-time analyses handle higher-order functions and data structures. <p> This line of work aims at proving the correctness of o*ine partial-evaluation with respect to the standard semantics of the source language. More generally, Consel and Khoo formally define online and o*ine partial-evaluation for a first-order applicative language <ref> [35] </ref>. They relate the standard semantics of the language to an online partial-evaluation semantics. Then they show that binding-time analysis is an abstraction of the online partial-evaluation semantics. Finally, they derive the specialization semantics from the binding-time analysis and the online partial evaluation semantics.
Reference: [36] <author> C. Consel and S. Pai. </author> <title> A programming environment for binding-time based partial evaluators. </title> <booktitle> In Consel [26], </booktitle> <pages> pages 62-66. </pages>
Reference-contexts: Consel's partial evaluator Schism is an o*ine poly-variant system with a flexible specialization strategy, higher-order functions, and partially-static values [27]. Both the binding-time analysis and the specialization are polyvariant. The system includes a binding-time based programming-environment <ref> [36] </ref>. Both source programs and specialized programs are expressed in Scheme, extended with ML-like datatypes. 3.2 Imperative languages Partial evaluation of imperative programs has received much attention recently. Gomard and Jones implemented the first self-applicable partial evaluator for imperative programs written in a simple flow-chart language [54, 55].
Reference: [37] <author> C. Consel, C. Pu, and J. Walpole. </author> <title> Incremental specialization: The key to high performance, modularity and portability in operating systems. </title> <type> Research report, </type> <institution> Pacific Software Research Center, Oregon Graduate Institute of Science and Technology, Beaverton, Oregon, USA, </institution> <year> 1992. </year>
Reference-contexts: Such a process is tedious and error-prone. Since microkernel-based operating systems can now be written in high-level programming languages there is no reason why partial evaluation cannot be used to perform the kind of specializations performed in the Synthesis kernel. In <ref> [37] </ref>, Consel, Pu and Walpole describe a research project aimed at using partial evaluation to derive automatically implementations of operating system components from generic specifications. They outline the necessary extensions to partial evaluation required for this derivation. 7 Related Work All optimizing compilers include constant propagation and folding [1].
Reference: [38] <author> K. D. Cooper, M. W. Hall, and K. Kennedy. </author> <title> Procedure cloning. </title> <booktitle> In Fourth IEEE International Conference on Computer Languages, </booktitle> <pages> pages 96-105, </pages> <year> 1992. </year>
Reference-contexts: We also observe a new trend in using one of the main techniques of partial evaluation | polyvariance | in modern compilers <ref> [20, 38] </ref>. Acknowledgements We are grateful to Anindya Banerjee, Andrzej Filinski, John Hatcliff, Jim Hook, Neil Jones, Julia Lawall, Jurgen Koslowski, Karoline Malmkjr, Erik Ruf, Tim Sheard, and Anna Sosyura for commenting earlier versions of these notes on short notice.
Reference: [39] <author> Pierre Cregut. </author> <title> Machines a environnement pour la reduction symbolique et l'evaluation partielle. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1991. </year>
Reference-contexts: This example illustrates the essential purpose of partial evaluation: eliminating interpretive overhead | here the interpretation of the control string. 1.2 Applications Because of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation <ref> [31, 34, 39, 59, 69, 71, 74] </ref>, string and pattern matching [28, 40, 70, 94, 104], computer graphics [85], numerical computation [8], circuit simulation [5], and hard real-time systems [91]. Partial evaluation has been studied in the context of a wide variety of programming languages.
Reference: [40] <author> O. Danvy. </author> <title> Semantics-directed compilation of nonlinear patterns. </title> <journal> Information Processing Letters, </journal> <volume> 37 </volume> <pages> 315-322, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: purpose of partial evaluation: eliminating interpretive overhead | here the interpretation of the control string. 1.2 Applications Because of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation [31, 34, 39, 59, 69, 71, 74], string and pattern matching <ref> [28, 40, 70, 94, 104] </ref>, computer graphics [85], numerical computation [8], circuit simulation [5], and hard real-time systems [91]. Partial evaluation has been studied in the context of a wide variety of programming languages. <p> d])) However, a strategy that keeps a static track of dynamic values across conditional expressions can do a better job and produce the following residual program. 5 (lambda (d) (case d [(1) 11] [else d])) This simple step is enough to produce residual programs that traverse the dynamic data linearly <ref> [40, 70] </ref>. Regarding string matching, any traversal of the string and the text leads to a specialized program that is linear over the dynamic string.
Reference: [41] <author> L. P. Deutsch. </author> <title> An interactive program verifier. </title> <type> Technical Report CSL-73-1, </type> <note> Xerox PARC, </note> <month> May </month> <year> 1973. </year>
Reference-contexts: The need for optimizing compilers to be efficient has motivated Wegman and Zadeck to study this subject on its own [107]. For another example, Deutsch's interactive program verifier, like many other theorem provers, includes a simplification phase performing static reductions <ref> [41] </ref>. Mosses's compiler generator SIS includes a phase for compiler-generation time reductions and allows for compile-time reductions [87]. Appel's technique of "reopening closures" explicitly aims at specializing functions at compile time [4]. In fact, Lombardi and Raphael's main tool in their pioneer work on incremental computation was partial evaluation [81].
Reference: [42] <author> A. P. Ershov, D. Bjtrner, Y. Futamura, K. Fu-rukawa, A. Haraldsson, and W. L. Scherlis, </author> <title> editors. Selected Papers from the Workshop on Partial Evaluation and Mixed Computation, volume 6 (2,3) of New Generation Computing. </title> <publisher> OHMSHA. LTD. and Springer-Verlag, </publisher> <year> 1988. </year>
Reference: [43] <author> D. P. Friedman, M. Wand, and C. T. Haynes. </author> <title> Essentials of Programming Languages. </title> <publisher> MIT Press and McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: In essence, partial evaluation removes layers of interpretation. In the most general sense, an interpreter can be defined as a program whose control flow is determined by its input data. As Abelson points out, <ref> [43, Foreword] </ref>, even programs that are not themselves interpreters have important interpreter-like pieces. These pieces contain both compile-time and run-time constructs. Partial evaluation identifies and eliminates the compile-time constructs. 1.1 A complete example We consider a function producing formatted text.
Reference: [44] <author> D. A. Fuller and S. Abramsky. </author> <title> Mixed computation of Prolog. </title> <editor> In Bjtrner et al. </editor> <volume> [9]. </volume>
Reference-contexts: Partial evaluation has been studied in the context of a wide variety of programming languages. In the area of logic programming, partial deduction is the focus of much work <ref> [44, 47, 78, 77] </ref>. Partial evaluators for imperative languages like Pascal [84] and C [3] have been developed. In equational languages, partial evaluation has been used to optimize rewriting techniques [103], and more recently, it has been applied to Lafont's interaction nets [6].
Reference: [45] <author> Y. Futamura. </author> <title> Partial evaluation of computation process an approach to a compiler-compiler. </title> <journal> Systems, Computers, </journal> <volume> Controls 2, 5, </volume> <pages> pages 45-50, </pages> <year> 1971. </year>
Reference: [46] <author> Y. Futamura and K. Nogi. </author> <title> Generalized partial computation. </title> <editor> In Bjtrner et al. </editor> <volume> [9]. </volume>
Reference-contexts: Rather than rewriting the source program to make it keep a static track of dynamic values, one can also obtain this residual program by generalizing the partial evaluator <ref> [46, 58, 104] </ref>.
Reference: [47] <author> J. Gallager and M. Codish. </author> <title> Specialisation of Prolog and FCP programs using abstract interpretation. </title> <editor> In Bjtrner et al. </editor> <volume> [9]. </volume>
Reference-contexts: Partial evaluation has been studied in the context of a wide variety of programming languages. In the area of logic programming, partial deduction is the focus of much work <ref> [44, 47, 78, 77] </ref>. Partial evaluators for imperative languages like Pascal [84] and C [3] have been developed. In equational languages, partial evaluation has been used to optimize rewriting techniques [103], and more recently, it has been applied to Lafont's interaction nets [6].
Reference: [48] <author> M. Gengler and B. Rytz. </author> <title> A polyvariant binding time analysis handling partially known values. </title> <booktitle> In WSA'92 [111], </booktitle> <pages> pages 322-330. </pages>
Reference-contexts: Similix is freely available and is used as a black box in Harnett and Montenyohl's investigation of programming languages [59]. Independently, Gengler and Rytz have extended the system with a polyvariant binding-time analysis and with partially static values <ref> [48, 98] </ref>. Consel's partial evaluator Schism is an o*ine poly-variant system with a flexible specialization strategy, higher-order functions, and partially-static values [27]. Both the binding-time analysis and the specialization are polyvariant. The system includes a binding-time based programming-environment [36].
Reference: [49] <author> R. Gluck. </author> <title> Towards multiple self-application. </title> <booktitle> In Hudak and Jones [62], </booktitle> <pages> pages 309-320. </pages>
Reference: [50] <author> D. Golub, R. Dean, A. Forin, and R. Rashid. </author> <title> Unix as an application program. </title> <booktitle> In Proceedings of the USENIX Summer Conference, </booktitle> <year> 1990. </year>
Reference-contexts: However, other insights are necessary to produce small programs quickly. 6.2 Partial evaluation applied to operating systems An important trend in operating system development is the restructuring of the traditional monolithic operating system kernel into independent servers running on top of a minimal/micro kernel <ref> [50] </ref>. This approach results in modular and flexible operating systems. Also operating systems can be written in high-level programming languages like Scheme [65]. However, these advantages come at a price: microkernel-based modular operating systems do not provide performance comparable to monolithic ones.
Reference: [51] <author> C. K. Gomard. </author> <title> Higher order partial evaluation HOPE for the lambda calculus. </title> <type> Master's thesis, </type> <institution> DIKU, University of Copenhagen, Copenhagen, Denmark, </institution> <year> 1989. </year>
Reference: [52] <author> C. K. Gomard. </author> <title> Partial type inference for untyped functional programs. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1990. </year>
Reference-contexts: Binding-time analysis is necessarily approximate 1 and thus o*ine partial-evaluators are usually less accurate than online ones. Binding-time analysis has been intensively studied in the framework of abstract interpretation [13, 25, 32, 35, 89] as well as in the framework of type theory <ref> [52, 60, 92, 100, 105] </ref>. In o*ine, binding-time based partial-evaluators, accurate binding-time information is critical because it determines the degree of the actual specialization. Existing binding-time analyses handle higher-order functions and data structures. Newer ones are also polyvariant.
Reference: [53] <author> C. K. Gomard. </author> <title> A self-applicable partial evaluator for the lambda-calculus: Correctness and pragmatics. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(2) </volume> <pages> 147-172, </pages> <year> 1992. </year>
Reference-contexts: Bondorf's partial evaluator for term-rewriting sys tems uses this strategy [11]. 2.4 Formalizing partial evaluation Much effort is devoted to specifying and proving o*ine partial-evaluation. Gomard defines the denotational semantics of the specialization process for the -calculus and proves its correctness <ref> [53] </ref>. Launchbury formulates a binding-time analysis for a first-order applicative language with projections [63, 79]. This line of work aims at proving the correctness of o*ine partial-evaluation with respect to the standard semantics of the source language.
Reference: [54] <author> C. K. Gomard and N. D. Jones. </author> <title> Compiler generation by partial evaluation. </title> <editor> In G. X. Ritter, editor, </editor> <booktitle> Information Processing '89. Proceedings of the IFIP 11th World Computer Congress, </booktitle> <pages> pages 1139-1144. </pages> <publisher> IFIP, North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: Both source programs and specialized programs are expressed in Scheme, extended with ML-like datatypes. 3.2 Imperative languages Partial evaluation of imperative programs has received much attention recently. Gomard and Jones implemented the first self-applicable partial evaluator for imperative programs written in a simple flow-chart language <ref> [54, 55] </ref>. They noticed how crucial it is to avoid specialization with respect to dead static variables. Meyer developed an online partial evaluator for a subset of Pascal [84].
Reference: [55] <author> C. K. Gomard and N. D. Jones. </author> <title> Compiler generation by partial evaluation: a case study. </title> <journal> Structured Programming, </journal> <volume> 12 </volume> <pages> 123-144, </pages> <year> 1991. </year>
Reference-contexts: Both source programs and specialized programs are expressed in Scheme, extended with ML-like datatypes. 3.2 Imperative languages Partial evaluation of imperative programs has received much attention recently. Gomard and Jones implemented the first self-applicable partial evaluator for imperative programs written in a simple flow-chart language <ref> [54, 55] </ref>. They noticed how crucial it is to avoid specialization with respect to dead static variables. Meyer developed an online partial evaluator for a subset of Pascal [84]. <p> Partial evaluation of imperative programs is difficult because of the lack of referential transparency. The program transformation phase must take into account the notion of state and thus is more complicated than in a functional setting <ref> [55] </ref>. Unless imperative features are encapsulated in some language constructs and so side-effects are disciplined, it is difficult to reason about the flow of static data.
Reference: [56] <author> M. A. Guzowski. </author> <title> Toward developing a reflexive partial evaluator for an interesting subset of Lisp. </title> <type> Master's thesis, </type> <institution> Department of Computer Engineering and Science, Case Western Reserve University, Cleveland, Ohio, </institution> <year> 1988. </year>
Reference-contexts: A polyvariant specializer can produce many specialized versions of a source function [18]. 2.3 Online vs. o*ine partial evaluation Contemporary partial evaluators are divided in two classes: online, monolithic partial evaluators and o*ine, staged partial evaluators. Before Jones's Mix system, all partial evaluators were online <ref> [7, 56, 81, 101] </ref>. Today, both online and o*ine partial-evaluation strategies are the subject of active research. An online partial-evaluator is a non-standard interpreter. The treatment of each expression is determined on the fly. Online partial-evaluators in general are very accurate but at the price of a considerable interpretive overhead.
Reference: [57] <author> T. A. Hansen. </author> <title> Transforming a naive pattern matcher into efficient pattern matchers. </title> <type> Technical report, DAIMI, </type> <year> 1991. </year>
Reference-contexts: Hansen has identified several variations around the Boyer & Moore string matching algorithm <ref> [57] </ref>. More recently, Queinnec and Geffroy have identified several other traversals of the static data corresponding to other well-known matching algorithms [94].
Reference: [58] <author> A. Haraldsson. </author> <title> A Program Manipulation System Based on Partial Evaluation. </title> <type> PhD thesis, </type> <institution> Linkoping University, Sweden, 1977. Linkoping Studies in Science and Technology Dissertations N o 14. </institution>
Reference-contexts: Rather than rewriting the source program to make it keep a static track of dynamic values, one can also obtain this residual program by generalizing the partial evaluator <ref> [46, 58, 104] </ref>.
Reference: [59] <author> S. Harnett and M. Montenyohl. </author> <title> Towards efficient compilation of a dynamic object-oriented language. </title> <booktitle> In Consel [26], </booktitle> <pages> pages 82-89. </pages>
Reference-contexts: This example illustrates the essential purpose of partial evaluation: eliminating interpretive overhead | here the interpretation of the control string. 1.2 Applications Because of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation <ref> [31, 34, 39, 59, 69, 71, 74] </ref>, string and pattern matching [28, 40, 70, 94, 104], computer graphics [85], numerical computation [8], circuit simulation [5], and hard real-time systems [91]. Partial evaluation has been studied in the context of a wide variety of programming languages. <p> Today, the new version of Similix is based on Hen-glein's efficient type-inference for binding-time analysis [60]. Similix is freely available and is used as a black box in Harnett and Montenyohl's investigation of programming languages <ref> [59] </ref>. Independently, Gengler and Rytz have extended the system with a polyvariant binding-time analysis and with partially static values [48, 98]. Consel's partial evaluator Schism is an o*ine poly-variant system with a flexible specialization strategy, higher-order functions, and partially-static values [27]. Both the binding-time analysis and the specialization are polyvariant.
Reference: [60] <author> F. Henglein. </author> <title> Efficient type inference for higher-order binding-time analysis. </title> <booktitle> In Hughes [64], </booktitle> <pages> pages 448-472. </pages>
Reference-contexts: Binding-time analysis is necessarily approximate 1 and thus o*ine partial-evaluators are usually less accurate than online ones. Binding-time analysis has been intensively studied in the framework of abstract interpretation [13, 25, 32, 35, 89] as well as in the framework of type theory <ref> [52, 60, 92, 100, 105] </ref>. In o*ine, binding-time based partial-evaluators, accurate binding-time information is critical because it determines the degree of the actual specialization. Existing binding-time analyses handle higher-order functions and data structures. Newer ones are also polyvariant. <p> It also includes a binding-time debugger [88]. Since then, it has been extended to handle higher-order functions [13] and more recently partially-static values [15]. Today, the new version of Similix is based on Hen-glein's efficient type-inference for binding-time analysis <ref> [60] </ref>. Similix is freely available and is used as a black box in Harnett and Montenyohl's investigation of programming languages [59]. Independently, Gengler and Rytz have extended the system with a polyvariant binding-time analysis and with partially static values [48, 98].
Reference: [61] <author> C. K. Holst. </author> <title> Language triplets: The AMIX approach. </title> <editor> In Bjtrner et al. </editor> <volume> [9], </volume> <pages> pages 167-185. </pages>
Reference-contexts: Therefore, a partial evaluator must include a compiler to construct the residual program. In the common case where the source and the target languages coincide this compiler essentially mimics the identity function. Otherwise, it is a simple translator <ref> [61] </ref>.
Reference: [62] <editor> P. Hudak and N. D. Jones, editors. </editor> <title> Partial Evaluation and Semantics based Program Manipulation. </title> <journal> Vol. </journal> <volume> 26, No 9. </volume> <booktitle> ACM SIGPLAN Notices, </booktitle> <year> 1991. </year>
Reference: [63] <author> J. Hughes. </author> <title> Backward analysis of functional programs. </title> <booktitle> In [42], </booktitle> <pages> pages 187-208, </pages> <year> 1988. </year>
Reference-contexts: Gomard defines the denotational semantics of the specialization process for the -calculus and proves its correctness [53]. Launchbury formulates a binding-time analysis for a first-order applicative language with projections <ref> [63, 79] </ref>. This line of work aims at proving the correctness of o*ine partial-evaluation with respect to the standard semantics of the source language. More generally, Consel and Khoo formally define online and o*ine partial-evaluation for a first-order applicative language [35].
Reference: [64] <editor> John Hughes, editor. FPCA'91, </editor> <booktitle> 5 th International Conference on Functional Programming Languages and Computer Architecture, number 523 in Lecture Notes in Computer Science, </booktitle> <year> 1991. </year>
Reference: [65] <author> S. Jagannathan and J. Philbin. </author> <title> A foundation for an efficient multi-threaded Scheme system. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 345-357, </pages> <year> 1992. </year> <month> 8 </month>
Reference-contexts: This approach results in modular and flexible operating systems. Also operating systems can be written in high-level programming languages like Scheme <ref> [65] </ref>. However, these advantages come at a price: microkernel-based modular operating systems do not provide performance comparable to monolithic ones. With the Synthesis kernel, Pu and his group have shown that microkernel-based operating systems can be optimized by generating specialized kernel routines [93].
Reference: [66] <author> N. D. Jones. </author> <title> Partial evaluation, self-application and types. </title> <booktitle> In 17th International Colloquium on Automata, Languages and Programming, volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 639-659. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference: [67] <author> N. D. Jones, C. K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: A broader discussion and more detailed references on contemporary work in the area of partial evaluation and on applications of partial evaluation can be found in Jones, Gomard, and Sestoft's new book <ref> [67] </ref>. Overview. This paper is organized as follows. Section 2 presents the principles and practice of partial evaluation. Section 3 briefly reviews the state of the art about partial evaluators for Scheme and imperative languages. Section 4 addresses the problem of termination.
Reference: [68] <author> N. D. Jones, P. Sestoft, and H. Stndergaard. </author> <title> An experiment in partial evaluation: the generation of a compiler generator. </title> <editor> In J.-P. Jouannaud, editor, </editor> <booktitle> Rewriting Techniques and Applications, Dijon, France, volume 202 of Lecture Notes in Computer Science, </booktitle> <pages> pages 124-140. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: In this section, we review the strategies used in Mix, Similix, Schism, and Fuse. In the Mix system, the problem was first treated by inserting annotations by hand in the source program, to indicate which call should be unfolded and which should be residualized <ref> [68] </ref>. Later on, static analyses were devised to annotate first-order programs automatically [102]. The use of binding-time analysis enables one to insert more accurate annotations.
Reference: [69] <author> N. D. Jones, P. Sestoft, and H. Stndergaard. </author> <title> Mix: a self-applicable partial evaluator for experiments in compiler generation. </title> <journal> LISP and Symbolic Computation, </journal> <volume> 2(1) </volume> <pages> 9-50, </pages> <year> 1989. </year>
Reference-contexts: This example illustrates the essential purpose of partial evaluation: eliminating interpretive overhead | here the interpretation of the control string. 1.2 Applications Because of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation <ref> [31, 34, 39, 59, 69, 71, 74] </ref>, string and pattern matching [28, 40, 70, 94, 104], computer graphics [85], numerical computation [8], circuit simulation [5], and hard real-time systems [91]. Partial evaluation has been studied in the context of a wide variety of programming languages. <p> Instead, their implementation is structured with a compiler and a runtime system. Implementing partial evaluation makes no exception, and o*ine partial evaluators are structured with a preprocessing phase PE and a processing phase PE . The preprocessing phase PE usually includes a binding-time analysis <ref> [69, 90] </ref>.
Reference: [70] <author> J. Jtrgensen. </author> <title> Generating a pattern matching compiler by partial evaluation. </title> <editor> In Simon L. Peyton Jones, Guy Hutton, and Carsten Kehler Holst, editors, </editor> <booktitle> Functional Programming, Glasgow 1990, </booktitle> <pages> pages 177-195. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: purpose of partial evaluation: eliminating interpretive overhead | here the interpretation of the control string. 1.2 Applications Because of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation [31, 34, 39, 59, 69, 71, 74], string and pattern matching <ref> [28, 40, 70, 94, 104] </ref>, computer graphics [85], numerical computation [8], circuit simulation [5], and hard real-time systems [91]. Partial evaluation has been studied in the context of a wide variety of programming languages. <p> d])) However, a strategy that keeps a static track of dynamic values across conditional expressions can do a better job and produce the following residual program. 5 (lambda (d) (case d [(1) 11] [else d])) This simple step is enough to produce residual programs that traverse the dynamic data linearly <ref> [40, 70] </ref>. Regarding string matching, any traversal of the string and the text leads to a specialized program that is linear over the dynamic string.
Reference: [71] <author> J. Jtrgensen. </author> <title> Generating a compiler for a lazy language by partial evaluation. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 258-268, </pages> <year> 1992. </year>
Reference-contexts: This example illustrates the essential purpose of partial evaluation: eliminating interpretive overhead | here the interpretation of the control string. 1.2 Applications Because of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation <ref> [31, 34, 39, 59, 69, 71, 74] </ref>, string and pattern matching [28, 40, 70, 94, 104], computer graphics [85], numerical computation [8], circuit simulation [5], and hard real-time systems [91]. Partial evaluation has been studied in the context of a wide variety of programming languages.
Reference: [72] <author> M. Katz and D. Weise. </author> <title> Towards a new perspective on partial evaluation. </title> <booktitle> In Consel [26], </booktitle> <pages> pages 29-37. </pages>
Reference-contexts: The design of Fuse is distinct from earlier online partial evaluators in that it uses graphs as an intermediate language and has a strategy for increasing sharing in residual programs <ref> [72, 96, 97] </ref>. Bondorf's partial evaluator Similix is an o*ine poly-variant system and was explicitly designed to be self-applicable and mostly automatic, based on a fixed specialization strategy [16]. The system handles recursive equations, customizable primitive operators and global side-effects. It also includes a binding-time debugger [88].
Reference: [73] <author> S. C. Khoo. </author> <title> Parameterized Partial Evaluation: Theory and Practice. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <year> 1992. </year> <month> Forthcoming. </month>
Reference-contexts: The generalization applies for both online and o*ine strategies. Parameterized partial-evaluation has been implemented at CMU [22] and at Yale <ref> [73] </ref> for a first-order subset of ML. Both systems handle partially-static data. The latter implementation includes both online and o*ine partial-evaluation phases. 2.6 The structure of a source program In general, partial evaluation forces one to be very conscious about the structure and properties of one's source programs.
Reference: [74] <author> S. C. Khoo and R. S. Sundaresh. </author> <title> Compiling inheritance using partial evaluation. </title> <booktitle> In Hudak and Jones [62], </booktitle> <pages> pages 211-222. </pages>
Reference-contexts: This example illustrates the essential purpose of partial evaluation: eliminating interpretive overhead | here the interpretation of the control string. 1.2 Applications Because of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation <ref> [31, 34, 39, 59, 69, 71, 74] </ref>, string and pattern matching [28, 40, 70, 94, 104], computer graphics [85], numerical computation [8], circuit simulation [5], and hard real-time systems [91]. Partial evaluation has been studied in the context of a wide variety of programming languages.
Reference: [75] <author> S. C. Kleene. </author> <title> Introduction to Metamathematics. </title> <publisher> Van Nostrand, </publisher> <year> 1952. </year>
Reference-contexts: In fact, S is Kleene's S m n -function <ref> [75] </ref>.
Reference: [76] <author> D. E. Knuth, J. H. Morris, and V. R. Pratt. </author> <title> Fast pattern matching in strings. </title> <journal> SIAM, </journal> <volume> 6(2) </volume> <pages> 323-350, </pages> <year> 1977. </year>
Reference-contexts: this method stresses the fact that non-trivial programs are often instances of simpler ones [99, Chapter 5]. 6.1 Pattern Matching Let us consider the following string matching problem: does a string occur within a text? A variety of solutions have been proposed | for example, by Knuth, Morris, & Pratt <ref> [76] </ref> and by Boyer & Moore [17] | that essentially solve this problem in linear time with respect to the size of the string and of the text.
Reference: [77] <author> H. J. Komorowski. </author> <title> Partial evaluation as a means for inferencing data structures in an applicative language: A theory and implementation in the case of Prolog. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1982. </year>
Reference-contexts: Partial evaluation has been studied in the context of a wide variety of programming languages. In the area of logic programming, partial deduction is the focus of much work <ref> [44, 47, 78, 77] </ref>. Partial evaluators for imperative languages like Pascal [84] and C [3] have been developed. In equational languages, partial evaluation has been used to optimize rewriting techniques [103], and more recently, it has been applied to Lafont's interaction nets [6].
Reference: [78] <author> A. Lakhotia and L. Sterling. ProMiX: </author> <title> A Prolog partial evaluation system. </title> <editor> In L. Sterling, editor, </editor> <booktitle> The Practice of Prolog, chapter 5, </booktitle> <pages> pages 137-179. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Partial evaluation has been studied in the context of a wide variety of programming languages. In the area of logic programming, partial deduction is the focus of much work <ref> [44, 47, 78, 77] </ref>. Partial evaluators for imperative languages like Pascal [84] and C [3] have been developed. In equational languages, partial evaluation has been used to optimize rewriting techniques [103], and more recently, it has been applied to Lafont's interaction nets [6].
Reference: [79] <author> J. Launchbury. </author> <title> Projection Factorisation in Partial Evaluation. </title> <type> PhD thesis, </type> <institution> Department of Computing Science, University of Glasgow, </institution> <address> Scotland, </address> <year> 1990. </year>
Reference-contexts: Gomard defines the denotational semantics of the specialization process for the -calculus and proves its correctness [53]. Launchbury formulates a binding-time analysis for a first-order applicative language with projections <ref> [63, 79] </ref>. This line of work aims at proving the correctness of o*ine partial-evaluation with respect to the standard semantics of the source language. More generally, Consel and Khoo formally define online and o*ine partial-evaluation for a first-order applicative language [35]. <p> This point of view has been progressively refined over the years. For example, Launchbury's partial evaluator is based on projections <ref> [79] </ref>.
Reference: [80] <author> J. L. Lawall. </author> <title> Proofs by structural induction and partial evaluation. </title> <editor> In D. A. Schmidt, editor, </editor> <booktitle> Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> Copenhagen, Den-mark, </address> <month> June </month> <year> 1993. </year> <journal> ACM SIGPLAN, </journal> <note> ACM Press. To appear. </note>
Reference-contexts: Writing filters provides the user with full control over specialization. Lawall makes a considerable use of filters for her application of partial evaluation to theorem proving <ref> [80] </ref>. Filters can also be generated automatically, based on any strategy. For example, an analysis corresponding to the strategy of Similix is available in Schism [27]. As an online partial-evaluator, Fuse keeps a dynamic cache of program points [109, Section 3].
Reference: [81] <author> L. A. Lombardi and B. Raphael. </author> <title> Lisp as the language for an incremental computer. </title> <editor> In E. C. Berkeley and D. G. Bobrow, editors, </editor> <booktitle> The Programming Language Lisp: Its Operation and Applications, </booktitle> <pages> pages 204-219. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1964. </year>
Reference-contexts: A polyvariant specializer can produce many specialized versions of a source function [18]. 2.3 Online vs. o*ine partial evaluation Contemporary partial evaluators are divided in two classes: online, monolithic partial evaluators and o*ine, staged partial evaluators. Before Jones's Mix system, all partial evaluators were online <ref> [7, 56, 81, 101] </ref>. Today, both online and o*ine partial-evaluation strategies are the subject of active research. An online partial-evaluator is a non-standard interpreter. The treatment of each expression is determined on the fly. Online partial-evaluators in general are very accurate but at the price of a considerable interpretive overhead. <p> Mosses's compiler generator SIS includes a phase for compiler-generation time reductions and allows for compile-time reductions [87]. Appel's technique of "reopening closures" explicitly aims at specializing functions at compile time [4]. In fact, Lombardi and Raphael's main tool in their pioneer work on incremental computation was partial evaluation <ref> [81] </ref>. The investigations above have one point in common: they use program transformation as a phase in a larger system. Therefore this phase needs to be efficient.
Reference: [82] <author> K. Malmkjr. </author> <title> On static properties of specialized programs. </title> <booktitle> In WSA'91 [110], </booktitle> <pages> pages 234-241. </pages>
Reference: [83] <author> K. Malmkjr. </author> <title> Predicting properties of residual programs. </title> <booktitle> In Consel [26], </booktitle> <pages> pages 8-13. </pages>
Reference: [84] <author> U. Meyer. </author> <title> Techniques for partial evaluation of imperative languages. </title> <booktitle> In Hudak and Jones [62], </booktitle> <pages> pages 94-105. </pages>
Reference-contexts: Partial evaluation has been studied in the context of a wide variety of programming languages. In the area of logic programming, partial deduction is the focus of much work [44, 47, 78, 77]. Partial evaluators for imperative languages like Pascal <ref> [84] </ref> and C [3] have been developed. In equational languages, partial evaluation has been used to optimize rewriting techniques [103], and more recently, it has been applied to Lafont's interaction nets [6]. <p> Gomard and Jones implemented the first self-applicable partial evaluator for imperative programs written in a simple flow-chart language [54, 55]. They noticed how crucial it is to avoid specialization with respect to dead static variables. Meyer developed an online partial evaluator for a subset of Pascal <ref> [84] </ref>. Nirkhe and Pugh [91] describe a partial evaluator for hard real-time problems where programs are constrained by the user to keep a tight control over the transformation process. Andersen reports a self-applicable partial evaluator for a subset of the C programming language [3].
Reference: [85] <author> T. Mogensen. </author> <title> The application of partial evaluation to ray-tracing. </title> <type> Master's thesis, </type> <institution> University of Copenhagen, DIKU, Copenhagen, Denmark, </institution> <year> 1986. </year>
Reference-contexts: | here the interpretation of the control string. 1.2 Applications Because of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation [31, 34, 39, 59, 69, 71, 74], string and pattern matching [28, 40, 70, 94, 104], computer graphics <ref> [85] </ref>, numerical computation [8], circuit simulation [5], and hard real-time systems [91]. Partial evaluation has been studied in the context of a wide variety of programming languages. In the area of logic programming, partial deduction is the focus of much work [44, 47, 78, 77].
Reference: [86] <author> T. Mogensen. </author> <title> Binding Time Aspects of Partial Evaluation. </title> <type> PhD thesis, </type> <institution> University of Copenhagen, DIKU, Copenhagen, Denmark, </institution> <year> 1989. </year>
Reference: [87] <author> P. Mosses. </author> <title> SIS Semantics Implementation System, reference manual and user guide. </title> <institution> University of Aarhus, Aarhus, Denmark, </institution> <year> 1979. </year> <note> Version 1.0. </note>
Reference-contexts: For another example, Deutsch's interactive program verifier, like many other theorem provers, includes a simplification phase performing static reductions [41]. Mosses's compiler generator SIS includes a phase for compiler-generation time reductions and allows for compile-time reductions <ref> [87] </ref>. Appel's technique of "reopening closures" explicitly aims at specializing functions at compile time [4]. In fact, Lombardi and Raphael's main tool in their pioneer work on incremental computation was partial evaluation [81].
Reference: [88] <author> C. Mossin. </author> <title> Similix binding time debugger manual. </title> <type> Technical report, </type> <institution> University of Copenhagen, Copenhagen, Denmark, </institution> <year> 1991. </year>
Reference-contexts: Bondorf's partial evaluator Similix is an o*ine poly-variant system and was explicitly designed to be self-applicable and mostly automatic, based on a fixed specialization strategy [16]. The system handles recursive equations, customizable primitive operators and global side-effects. It also includes a binding-time debugger <ref> [88] </ref>. Since then, it has been extended to handle higher-order functions [13] and more recently partially-static values [15]. Today, the new version of Similix is based on Hen-glein's efficient type-inference for binding-time analysis [60].
Reference: [89] <author> F. Nielson and H. R. Nielson. </author> <title> Two-Level Functional Languages. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: This binding-time information is then used to guide the processing phase PE that performs the specialization proper. Binding-time analysis is necessarily approximate 1 and thus o*ine partial-evaluators are usually less accurate than online ones. Binding-time analysis has been intensively studied in the framework of abstract interpretation <ref> [13, 25, 32, 35, 89] </ref> as well as in the framework of type theory [52, 60, 92, 100, 105]. In o*ine, binding-time based partial-evaluators, accurate binding-time information is critical because it determines the degree of the actual specialization. Existing binding-time analyses handle higher-order functions and data structures.
Reference: [90] <author> H. R. Nielson and F. Nielson. </author> <title> Automatic binding time analysis for a typed -calculus. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 98-106, </pages> <year> 1988. </year>
Reference-contexts: Instead, their implementation is structured with a compiler and a runtime system. Implementing partial evaluation makes no exception, and o*ine partial evaluators are structured with a preprocessing phase PE and a processing phase PE . The preprocessing phase PE usually includes a binding-time analysis <ref> [69, 90] </ref>.
Reference: [91] <author> V. Nirkhe and W. Pugh. </author> <title> Partial evaluation of high-level imperative program languages with applications in hard real-time systems. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 269-280, </pages> <year> 1992. </year>
Reference-contexts: of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation [31, 34, 39, 59, 69, 71, 74], string and pattern matching [28, 40, 70, 94, 104], computer graphics [85], numerical computation [8], circuit simulation [5], and hard real-time systems <ref> [91] </ref>. Partial evaluation has been studied in the context of a wide variety of programming languages. In the area of logic programming, partial deduction is the focus of much work [44, 47, 78, 77]. Partial evaluators for imperative languages like Pascal [84] and C [3] have been developed. <p> They noticed how crucial it is to avoid specialization with respect to dead static variables. Meyer developed an online partial evaluator for a subset of Pascal [84]. Nirkhe and Pugh <ref> [91] </ref> describe a partial evaluator for hard real-time problems where programs are constrained by the user to keep a tight control over the transformation process. Andersen reports a self-applicable partial evaluator for a subset of the C programming language [3].
Reference: [92] <author> J. Palsberg and M. I. Schwartzbach. </author> <title> Binding time analysis: Abstract interpretation versus type inference. </title> <type> Technical report, DAIMI, </type> <year> 1992. </year>
Reference-contexts: Binding-time analysis is necessarily approximate 1 and thus o*ine partial-evaluators are usually less accurate than online ones. Binding-time analysis has been intensively studied in the framework of abstract interpretation [13, 25, 32, 35, 89] as well as in the framework of type theory <ref> [52, 60, 92, 100, 105] </ref>. In o*ine, binding-time based partial-evaluators, accurate binding-time information is critical because it determines the degree of the actual specialization. Existing binding-time analyses handle higher-order functions and data structures. Newer ones are also polyvariant.
Reference: [93] <author> C. Pu, H. Massalin, and J. Ioannidis. </author> <title> The Synthesis kernel. </title> <journal> ACM Computing Systems, </journal> <volume> 1(1) </volume> <pages> 11-32, </pages> <year> 1988. </year>
Reference-contexts: However, these advantages come at a price: microkernel-based modular operating systems do not provide performance comparable to monolithic ones. With the Synthesis kernel, Pu and his group have shown that microkernel-based operating systems can be optimized by generating specialized kernel routines <ref> [93] </ref>. Their work demonstrated that efficiency can be obtained without compromise on modularity and flexibility.
Reference: [94] <author> C. Queinnec and J. M. Geffroy. </author> <title> Partial evaluation applied to pattern matching with intelligent backtracking. </title> <booktitle> In WSA'92 [111], </booktitle> <pages> pages 109-117. </pages>
Reference-contexts: purpose of partial evaluation: eliminating interpretive overhead | here the interpretation of the control string. 1.2 Applications Because of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation [31, 34, 39, 59, 69, 71, 74], string and pattern matching <ref> [28, 40, 70, 94, 104] </ref>, computer graphics [85], numerical computation [8], circuit simulation [5], and hard real-time systems [91]. Partial evaluation has been studied in the context of a wide variety of programming languages. <p> Hansen has identified several variations around the Boyer & Moore string matching algorithm [57]. More recently, Queinnec and Geffroy have identified several other traversals of the static data corresponding to other well-known matching algorithms <ref> [94] </ref>. But even though partial evaluation can be used to generate linear-time programs, there is no guarantee about the size of these programs, nor about the time taken by the partial evaluator to produce them.
Reference: [95] <author> E. Ruf. </author> <title> Topics in Online Partial Evaluation. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1993. </year> <note> (in preparation). 9 </note>
Reference: [96] <author> E. Ruf and D. Weise. </author> <title> Using types to avoid redun-dant specialization. </title> <booktitle> In Hudak and Jones [62], </booktitle> <pages> pages 321-333. </pages>
Reference-contexts: The design of Fuse is distinct from earlier online partial evaluators in that it uses graphs as an intermediate language and has a strategy for increasing sharing in residual programs <ref> [72, 96, 97] </ref>. Bondorf's partial evaluator Similix is an o*ine poly-variant system and was explicitly designed to be self-applicable and mostly automatic, based on a fixed specialization strategy [16]. The system handles recursive equations, customizable primitive operators and global side-effects. It also includes a binding-time debugger [88].
Reference: [97] <author> E. Ruf and D. Weise. </author> <title> Improving the accuracy of higher-order specialization using control flow analysis. </title> <booktitle> In Consel [26], </booktitle> <pages> pages 67-74. </pages>
Reference-contexts: The design of Fuse is distinct from earlier online partial evaluators in that it uses graphs as an intermediate language and has a strategy for increasing sharing in residual programs <ref> [72, 96, 97] </ref>. Bondorf's partial evaluator Similix is an o*ine poly-variant system and was explicitly designed to be self-applicable and mostly automatic, based on a fixed specialization strategy [16]. The system handles recursive equations, customizable primitive operators and global side-effects. It also includes a binding-time debugger [88].
Reference: [98] <author> B. Rytz and M. Gengler. </author> <title> A polyvariant binding time analysis. </title> <booktitle> In Consel [26], </booktitle> <pages> pages 21-28. </pages>
Reference-contexts: Similix is freely available and is used as a black box in Harnett and Montenyohl's investigation of programming languages [59]. Independently, Gengler and Rytz have extended the system with a polyvariant binding-time analysis and with partially static values <ref> [48, 98] </ref>. Consel's partial evaluator Schism is an o*ine poly-variant system with a flexible specialization strategy, higher-order functions, and partially-static values [27]. Both the binding-time analysis and the specialization are polyvariant. The system includes a binding-time based programming-environment [36].
Reference: [99] <author> W. L. Scherlis. </author> <title> Expression Procedures and Program Derivation. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1980. </year> <note> Report No. STAN-CS-80-818. </note>
Reference-contexts: In particular, this method stresses the fact that non-trivial programs are often instances of simpler ones <ref> [99, Chapter 5] </ref>. 6.1 Pattern Matching Let us consider the following string matching problem: does a string occur within a text? A variety of solutions have been proposed | for example, by Knuth, Morris, & Pratt [76] and by Boyer & Moore [17] | that essentially solve this problem in linear
Reference: [100] <author> D. A. Schmidt. </author> <title> Static properties of partial evaluation. </title> <editor> In Bjtrner et al. </editor> <volume> [9], </volume> <pages> pages 465-483. </pages>
Reference-contexts: Binding-time analysis is necessarily approximate 1 and thus o*ine partial-evaluators are usually less accurate than online ones. Binding-time analysis has been intensively studied in the framework of abstract interpretation [13, 25, 32, 35, 89] as well as in the framework of type theory <ref> [52, 60, 92, 100, 105] </ref>. In o*ine, binding-time based partial-evaluators, accurate binding-time information is critical because it determines the degree of the actual specialization. Existing binding-time analyses handle higher-order functions and data structures. Newer ones are also polyvariant.
Reference: [101] <author> R. Schooler. </author> <title> Partial evaluation as a means of language extensibility. </title> <type> Master's thesis, </type> <institution> M.I.T. (LCS), Massachusetts, U.S.A, </institution> <year> 1984. </year> <month> TR-324. </month>
Reference-contexts: A polyvariant specializer can produce many specialized versions of a source function [18]. 2.3 Online vs. o*ine partial evaluation Contemporary partial evaluators are divided in two classes: online, monolithic partial evaluators and o*ine, staged partial evaluators. Before Jones's Mix system, all partial evaluators were online <ref> [7, 56, 81, 101] </ref>. Today, both online and o*ine partial-evaluation strategies are the subject of active research. An online partial-evaluator is a non-standard interpreter. The treatment of each expression is determined on the fly. Online partial-evaluators in general are very accurate but at the price of a considerable interpretive overhead.
Reference: [102] <author> P. Sestoft. </author> <title> Automatic call unfolding in a partial evaluator. </title> <editor> In Bjtrner et al. </editor> <volume> [9]. </volume>
Reference-contexts: In the Mix system, the problem was first treated by inserting annotations by hand in the source program, to indicate which call should be unfolded and which should be residualized [68]. Later on, static analyses were devised to annotate first-order programs automatically <ref> [102] </ref>. The use of binding-time analysis enables one to insert more accurate annotations. <p> Care must also be taken when unfolding function calls to avoid duplicating computations. This can lead to the specialization of a linear program into an exponential one <ref> [102] </ref>.
Reference: [103] <author> D. Sherman, R. Strandh, and I. Durand. </author> <title> Optimization of equational programs using partial evaluation. </title> <booktitle> In Hudak and Jones [62], </booktitle> <pages> pages 72-82. </pages>
Reference-contexts: In the area of logic programming, partial deduction is the focus of much work [44, 47, 78, 77]. Partial evaluators for imperative languages like Pascal [84] and C [3] have been developed. In equational languages, partial evaluation has been used to optimize rewriting techniques <ref> [103] </ref>, and more recently, it has been applied to Lafont's interaction nets [6]. A broader discussion and more detailed references on contemporary work in the area of partial evaluation and on applications of partial evaluation can be found in Jones, Gomard, and Sestoft's new book [67]. Overview.
Reference: [104] <author> D. A. Smith. </author> <title> Partial evaluation of pattern matching in CLP domains. </title> <booktitle> In Hudak and Jones [62], </booktitle> <pages> pages 62-71. </pages>
Reference-contexts: purpose of partial evaluation: eliminating interpretive overhead | here the interpretation of the control string. 1.2 Applications Because of its conceptual simplicity, partial evaluation has been applied to a wide variety of areas that include compiling and compiler generation [31, 34, 39, 59, 69, 71, 74], string and pattern matching <ref> [28, 40, 70, 94, 104] </ref>, computer graphics [85], numerical computation [8], circuit simulation [5], and hard real-time systems [91]. Partial evaluation has been studied in the context of a wide variety of programming languages. <p> Rather than rewriting the source program to make it keep a static track of dynamic values, one can also obtain this residual program by generalizing the partial evaluator <ref> [46, 58, 104] </ref>.
Reference: [105] <author> K. L. Solberg, H. R. Nielson, and F. Nielson. </author> <title> Inference systems for binding time analysis. </title> <booktitle> In WSA'92 [111], </booktitle> <pages> pages 247-254. </pages>
Reference-contexts: Binding-time analysis is necessarily approximate 1 and thus o*ine partial-evaluators are usually less accurate than online ones. Binding-time analysis has been intensively studied in the framework of abstract interpretation [13, 25, 32, 35, 89] as well as in the framework of type theory <ref> [52, 60, 92, 100, 105] </ref>. In o*ine, binding-time based partial-evaluators, accurate binding-time information is critical because it determines the degree of the actual specialization. Existing binding-time analyses handle higher-order functions and data structures. Newer ones are also polyvariant.
Reference: [106] <author> R. S. Sundaresh and P. Hudak. </author> <title> Incremental computation via partial evaluation. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-13, </pages> <year> 1991. </year>
Reference: [107] <author> M. N. Wegman and F. K. Zadeck. </author> <title> Constant propagation with conditional branches. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(2) </volume> <pages> 181-210, </pages> <year> 1991. </year>
Reference-contexts: They outline the necessary extensions to partial evaluation required for this derivation. 7 Related Work All optimizing compilers include constant propagation and folding [1]. The need for optimizing compilers to be efficient has motivated Wegman and Zadeck to study this subject on its own <ref> [107] </ref>. For another example, Deutsch's interactive program verifier, like many other theorem provers, includes a simplification phase performing static reductions [41]. Mosses's compiler generator SIS includes a phase for compiler-generation time reductions and allows for compile-time reductions [87].
Reference: [108] <author> P. Weiner. </author> <title> Linear pattern matching algorithms. </title> <booktitle> In 14th Annual Symposium on Switching and Automata Theory, </booktitle> <pages> pages 1-11, </pages> <year> 1973. </year>
Reference-contexts: If the traversal goes from left to right and the text is static, the residual program is structured like a Weiner tree <ref> [108] </ref> (named a "position tree" by Aho, Hopcroft, and Ullman [2]). If the traversal goes from right to left and the string is static, the residual program mimics the effect of the Boyer & Moore string-matching algorithm.
Reference: [109] <author> D. Weise, R. Conybeare, E. Ruf, and S. Seligman. </author> <title> Automatic online partial evaluation. </title> <booktitle> In Hughes [64], </booktitle> <pages> pages 165-191. </pages>
Reference-contexts: In an earlier work, we proposed to stage PE further by shifting the interpretation of binding times from PE to PE [24, 29]. This shift substantially simplifies the specializer. To get the best of both worlds, online and o*ine partial-evaluation can be combined as follows <ref> [11, 109] </ref>. Whenever the exact binding-time property of an expression can be determined, o*ine partial evaluation is used. Otherwise, the treatment for this expression is postponed until specialization time, when concrete values are available. <p> first review the state of the art of partial evaluators for call-by-value functional languages such as Scheme [21], and then of partial evaluators for imperative languages. 3.1 Applicative languages Weise's partial evaluator Fuse is an online system and aims at applying partial evaluation to practical problems, such as circuit simulation <ref> [109] </ref>. The design of Fuse is distinct from earlier online partial evaluators in that it uses graphs as an intermediate language and has a strategy for increasing sharing in residual programs [72, 96, 97]. <p> Filters can also be generated automatically, based on any strategy. For example, an analysis corresponding to the strategy of Similix is available in Schism [27]. As an online partial-evaluator, Fuse keeps a dynamic cache of program points <ref> [109, Section 3] </ref>. Specialization naturally terminates when all loops that are unrolled statically terminate or are broken by a cache hit. Otherwise, an arbitrary bound is needed.
Reference: [110] <institution> Workshop on Static Analysis, </institution> <note> volume 74 of Bigre Journal. </note> <institution> IRISA, Rennes, France, </institution> <year> 1991. </year>
Reference: [111] <institution> Workshop on Static Analysis, volume 81-82 of Bigre Journal. IRISA, Rennes, France, </institution> <year> 1992. </year>
References-found: 111

