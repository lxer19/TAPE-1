URL: http://www.cs.bu.edu/techreports/96-023-pinwheel-bdisks.ps.Z
Refering-URL: http://cs-www.bu.edu/techreports/Home.html
Root-URL: 
Email: sanjoy@cs.uvm.edu  best@cs.bu.edu  
Title: Pinwheel Scheduling for Fault-tolerant Broadcast Disks in Real-time Database Systems  
Author: Sanjoy Baruah 
Keyword: Broadcast disks, information dispersal algorithm, pinwheel scheduling, real-time databases.  
Date: August 22, 1996  
Address: Vermont Azer Bestavros  Boston University  
Affiliation: Department of CS EE University of  CS Department  
Abstract: The design of programs for broadcast disks which incorporate real-time and fault-tolerance requirements is considered. A generalized model for real-time fault-tolerant broadcast disks is defined. It is shown that designing programs for broadcast disks specified in this model is closely related to the scheduling of pinwheel task systems. Some new results in pinwheel scheduling theory are derived, which facilitate the efficient generation of real-time fault-tolerant broadcast disk programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Acharya, R. Alonso, M. Franklin, and S. Zdonik. </author> <title> Broadcast disks: Data management for asymmetric communications environments. </title> <booktitle> In Proceedings of ACM SIGMOD conference, </booktitle> <address> San Jose, CA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: On the client side, this hierarchy gives rise to cache management and prefetching issues (e.g., cache replacement strategies to improve the hit ratio or reduce miss penalty). In [4], Acharya, Franklin and Zdonik discuss Bdisks organization issues, including client cache management <ref> [1] </ref>, client-initiated prefetching to improve the communication latency for database access systems [3], and techniques for disseminating updates [2].
Reference: [2] <author> S. Acharya, M. Franklin, and S. Zdonik. </author> <title> Disseminating updates on broadcast disks. </title> <booktitle> In Proceedings of VLDB'96: The 1996 International Conference on Very Large Databases, </booktitle> <address> India, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: In [4], Acharya, Franklin and Zdonik discuss Bdisks organization issues, including client cache management [1], client-initiated prefetching to improve the communication latency for database access systems [3], and techniques for disseminating updates <ref> [2] </ref>. <p> Therefore, bc (i; 2; [5; 6; 6]) ( pc (i; 2; 3). Observe that this is an optimal transformation, in that the density of this nice pinwheel condition is equal to the density lower bound of the broadcast condition. Example 6 bc (i; 1; <ref> [2; 3] </ref>) pc (i; 1; 2) ^ pc (i; 2; 3). By R2, pc (i; 2; 3) ) pc (i; 1; 2); therefore, pc (i; 2; 3), with a density of 0:6667, is an equivalent nice pinwheel condition. Applying TR2 directly to bc (i; 1; [2; 3]) would yield the nice <p> Example 6 bc (i; 1; <ref> [2; 3] </ref>) pc (i; 1; 2) ^ pc (i; 2; 3). By R2, pc (i; 2; 3) ) pc (i; 1; 2); therefore, pc (i; 2; 3), with a density of 0:6667, is an equivalent nice pinwheel condition. Applying TR2 directly to bc (i; 1; [2; 3]) would yield the nice conjunct of pinwheel conditions pc (i; 1; 2) ^ pc (i 0 ; 2; 3) ^ map (i; i 0 ), which has a density of 1=2 + 1=3 = 0:8333. 5 Conclusion With the advent of mobile computers and cellular communication, it is expected
Reference: [3] <author> S. Acharya, M. Franklin, and S. Zdonik. </author> <title> Prefetching from a broadcast disk. </title> <booktitle> In Proceedings of ICDE'96: The 1996 International Conference on Data Engineering, </booktitle> <address> New Orleans, Louisiana, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: In [4], Acharya, Franklin and Zdonik discuss Bdisks organization issues, including client cache management [1], client-initiated prefetching to improve the communication latency for database access systems <ref> [3] </ref>, and techniques for disseminating updates [2]. <p> Therefore, bc (i; 2; [5; 6; 6]) ( pc (i; 2; 3). Observe that this is an optimal transformation, in that the density of this nice pinwheel condition is equal to the density lower bound of the broadcast condition. Example 6 bc (i; 1; <ref> [2; 3] </ref>) pc (i; 1; 2) ^ pc (i; 2; 3). By R2, pc (i; 2; 3) ) pc (i; 1; 2); therefore, pc (i; 2; 3), with a density of 0:6667, is an equivalent nice pinwheel condition. Applying TR2 directly to bc (i; 1; [2; 3]) would yield the nice <p> Example 6 bc (i; 1; <ref> [2; 3] </ref>) pc (i; 1; 2) ^ pc (i; 2; 3). By R2, pc (i; 2; 3) ) pc (i; 1; 2); therefore, pc (i; 2; 3), with a density of 0:6667, is an equivalent nice pinwheel condition. Applying TR2 directly to bc (i; 1; [2; 3]) would yield the nice conjunct of pinwheel conditions pc (i; 1; 2) ^ pc (i 0 ; 2; 3) ^ map (i; i 0 ), which has a density of 1=2 + 1=3 = 0:8333. 5 Conclusion With the advent of mobile computers and cellular communication, it is expected
Reference: [4] <author> Swarup Acharya, Michael Franklin, and Stanley Zdonik. </author> <title> Dissemination-based data delivery using broadcast disks. </title> <journal> IEEE Personal Communications, </journal> <volume> 2(6), </volume> <month> December </month> <year> 1995. </year>
Reference-contexts: On the server side, this hierarchy gives rise to memory management issues (e.g., allocation of data to Bdisks based on priority/urgency). On the client side, this hierarchy gives rise to cache management and prefetching issues (e.g., cache replacement strategies to improve the hit ratio or reduce miss penalty). In <ref> [4] </ref>, Acharya, Franklin and Zdonik discuss Bdisks organization issues, including client cache management [1], client-initiated prefetching to improve the communication latency for database access systems [3], and techniques for disseminating updates [2].
Reference: [5] <author> S. Baruah, L. Rosier, and D. Varvel. </author> <title> Static and dynamic scheduling of sporadic tasks for single-processor systems. </title> <booktitle> In Proceedings of the Third Euromicro Workshop on Real-time Systems, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: For example, Han & Lin [16] have used pinwheel techniques to model distance-constrained tasks; Hsueh, Lin, and Fan [21] have extended this research to distributed systems. Baruah, Rosier, and Varvel <ref> [5] </ref> have used pinwheel scheduling to construct static schedules for sporadic task systems. Recently, Han & Shin [17, 18] have applied pinwheel techniques to real-time network scheduling. <p> f (m i + j)=d (j) i g is a lower bound on the density of any pinwheel condition (or nice conjunct of pinwheel conditions) that may imply bc (i; m i ; ~ d i ). (This bound may not be actually achievable | for example, bc (i; 2; <ref> [5; 7] </ref>) is not implied by any nice conjunct of pinwheel conditions of density 3=7). We refer to max j0 f (m i + j)=d (j) density lower bound of broadcast file condition bc (i; m i ; ~ d i ). <p> Example 5 When d (j) (j+1) i , rule R0 may be used to rid of one conjunct. Thus, bc (i; 2; <ref> [5; ; 6] </ref>) pc (i; 2; 5) ^ pc (i; 3; 6) ^ pc (i; 4; 6), which simplifies to pc (i; 2; 5) ^ pc (i; 4; 6). <p> By R1, pc (i; 2; 3) ) pc (i; 4; 6); by R0, pc (i; 2; 3) ) pc (i; 2; 5). Therefore, bc (i; 2; <ref> [5; 6; 6] </ref>) ( pc (i; 2; 3). Observe that this is an optimal transformation, in that the density of this nice pinwheel condition is equal to the density lower bound of the broadcast condition.
Reference: [6] <author> Azer Bestavros. </author> <title> IDA-based disk arrays. </title> <type> Technical Memorandum 45312-890707-01TM, </type> <institution> AT&T, Bell Laboratories, Department 45312, </institution> <address> Holmdel, NJ, </address> <month> July </month> <year> 1989. </year>
Reference-contexts: AIDA is an elaboration on the Information Dispersal Algorithm of Michael O. Rabin [30], which was previously shown to be a sound mechanism that considerably improves the performance of I/O systems, parallel/distributed storage devices <ref> [6, 10] </ref>, and routing in parallel architectures [28]. 2.1 Information Dispersal and Retrieval Let F represent the original data object (hereinafter referred to as the file) to be communicated (or retrieved). Furthermore, assume that file F is to be communicated by sending N independent transmissions. <p> Example 5 When d (j) (j+1) i , rule R0 may be used to rid of one conjunct. Thus, bc (i; 2; <ref> [5; ; 6] </ref>) pc (i; 2; 5) ^ pc (i; 3; 6) ^ pc (i; 4; 6), which simplifies to pc (i; 2; 5) ^ pc (i; 4; 6). <p> By R1, pc (i; 2; 3) ) pc (i; 4; 6); by R0, pc (i; 2; 3) ) pc (i; 2; 5). Therefore, bc (i; 2; <ref> [5; 6; 6] </ref>) ( pc (i; 2; 3). Observe that this is an optimal transformation, in that the density of this nice pinwheel condition is equal to the density lower bound of the broadcast condition.
Reference: [7] <author> Azer Bestavros. SETH: </author> <title> A VLSI chip for the real-time information dispersal and retrieval for security and fault-tolerance. </title> <booktitle> In Proceedings of ICPP'90, The 1990 International Conference on Parallel Processing, </booktitle> <address> Chicago, Illinois, </address> <month> August </month> <year> 1990. </year> <title> 5 The word best needs to be quantified based on the cost of dispersal and reconstruction. </title>
Reference-contexts: The process of processing F is called the dispersal of F , whereas the process of retrieving F by collecting m of its pieces is called the reconstruction of F . Both the dispersal and reconstruction operations can be performed in real-time. This was demonstrated in <ref> [7] </ref>, where an architecture and a CMOS implementation of a VLSI chip 1 that implements IDA was presented. <p> The performance of the chip was measured to be about 1 megabyte per second. By using proper pipelining and more elaborate designs, this figure can be boosted significantly. 2 For more details, we refer the reader to the papers by Rabin [30] and Bestavros <ref> [7] </ref> on IDA implementation. 3 Another alternative is to broadcast a directory (or index [24]) at the beginning of each broadcast period. <p> f (m i + j)=d (j) i g is a lower bound on the density of any pinwheel condition (or nice conjunct of pinwheel conditions) that may imply bc (i; m i ; ~ d i ). (This bound may not be actually achievable | for example, bc (i; 2; <ref> [5; 7] </ref>) is not implied by any nice conjunct of pinwheel conditions of density 3=7). We refer to max j0 f (m i + j)=d (j) density lower bound of broadcast file condition bc (i; m i ; ~ d i ).
Reference: [8] <author> Azer Bestavros. </author> <title> An adaptive information dispersal algorithm for time-critical reliable communication. </title> <editor> In Ivan Frisch, Manu Malek, and Shivendra Panwar, editors, </editor> <title> Network Management and Control, Volume II. </title> <publisher> Plenum Publishing Corporation, </publisher> <address> New York, New York, </address> <year> 1994. </year>
Reference-contexts: In [9], Bestavros showed how to allocate data items to Bdisks so as to mask (or otherwise minimize) the impact of intermittent failures in a real-time environment. In that respect, he proposed the use of the Adaptive Information Dispersal Algorithm (AIDA) <ref> [8] </ref>, which allows for a controllable and efficient tradeoff of bandwidth for reliability, and derived lower bounds on the bandwidth requirements for AIDA-based fault-tolerant real-time Bdisks. This research: The contributions of this paper are twofold. <p> The IDA approach is different in that redundancy is added uniformly; there is simply no distinction between data and parity. It is this feature that makes it possible to scale the amount of redundancy used in IDA. Indeed, this is the basis for the adaptive IDA (AIDA) <ref> [8] </ref>. Using AIDA, a bandwidth allocation operation is inserted after the dispersal operation but prior to transmission as shown in figure 4. This bandwidth allocation step allows the system to scale the amount of redundancy used in the transmission. <p> The examples below illustrate how rules R0-R3 and R5 may be sometimes used to simplify the conjunct of pinwheel conditions obtained by the application of transformation rules TR1 and TR2. Example 4 F i has m i = 4, and ~ d i = <ref> [8; 9] </ref>. This is represented by bc (i; 4; [8; 9]), and has a density lower bound of 0:5556. By Rule TR1, this is implied by pc (i; 1; 1), which has a density of 1:0. <p> Example 4 F i has m i = 4, and ~ d i = <ref> [8; 9] </ref>. This is represented by bc (i; 4; [8; 9]), and has a density lower bound of 0:5556. By Rule TR1, this is implied by pc (i; 1; 1), which has a density of 1:0.
Reference: [9] <author> Azer Bestavros. </author> <title> AIDA-based real-time fault-tolerant broadcast disks. </title> <booktitle> In Proceedings of RTAS'96: The 1996 IEEE Real-Time Technology and Applications Symposium, </booktitle> <address> Boston, Massachusetts, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: For non-real-time applications, such a mishap is tolerable and is translated to a longer-than-usual latency, and thus deserves little consideration. However, in a real-time environment, waiting for a complete retransmission may imply missing a critical deadline, and subjecting clients to possibly severe consequences. In <ref> [9] </ref>, Bestavros showed how to allocate data items to Bdisks so as to mask (or otherwise minimize) the impact of intermittent failures in a real-time environment. <p> First, we show that the problem of designing real-time Bdisk programs is intimately linked to the pinwheel scheduling problem [19], and make use of this link to (1) derive upper bounds on the bandwidth requirements for real-time fault-tolerant Bdisks (corresponding to the lower bounds in <ref> [9] </ref>), and (2) obtain efficient algorithms for designing fault-tolerant real-time Bdisk programs. Next, we present a more general model for real-time fault-tolerant Bdisks that subsumes the simple model presented in [9]. <p> link to (1) derive upper bounds on the bandwidth requirements for real-time fault-tolerant Bdisks (corresponding to the lower bounds in <ref> [9] </ref>), and (2) obtain efficient algorithms for designing fault-tolerant real-time Bdisk programs. Next, we present a more general model for real-time fault-tolerant Bdisks that subsumes the simple model presented in [9]. We derive a pinwheel algebra|some simple rules for manipulating pinwheel conditions|and demonstrate through examples how these rules may be used to efficiently construct broadcast programs for generalized fault-tolerant real-time Bdisks. The rest of this paper is organized as follows. <p> This broadcast period may be very long since the broadcast disk may include thousands of other blocks, which the server must transmit before getting back to the block in question. For real-time systems, such a delay may result in missing critical timing constraints. In <ref> [9] </ref>, Bestavros proposed the use of AIDA to mask (or otherwise minimize) the impact of such failures in a real-time environment. In this section we review the basic premise of AIDA-based Bdisks. <p> The examples below illustrate how rules R0-R3 and R5 may be sometimes used to simplify the conjunct of pinwheel conditions obtained by the application of transformation rules TR1 and TR2. Example 4 F i has m i = 4, and ~ d i = <ref> [8; 9] </ref>. This is represented by bc (i; 4; [8; 9]), and has a density lower bound of 0:5556. By Rule TR1, this is implied by pc (i; 1; 1), which has a density of 1:0. <p> Example 4 F i has m i = 4, and ~ d i = <ref> [8; 9] </ref>. This is represented by bc (i; 4; [8; 9]), and has a density lower bound of 0:5556. By Rule TR1, this is implied by pc (i; 1; 1), which has a density of 1:0.
Reference: [10] <author> Azer Bestavros, Danny Chen, and Wing Wong. </author> <title> The reliability and performance of parallel disks. </title> <type> Technical Memorandum 45312-891206-01TM, </type> <institution> AT&T, Bell Laboratories, Department 45312, </institution> <address> Holmdel, NJ, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: AIDA is an elaboration on the Information Dispersal Algorithm of Michael O. Rabin [30], which was previously shown to be a sound mechanism that considerably improves the performance of I/O systems, parallel/distributed storage devices <ref> [6, 10] </ref>, and routing in parallel architectures [28]. 2.1 Information Dispersal and Retrieval Let F represent the original data object (hereinafter referred to as the file) to be communicated (or retrieved). Furthermore, assume that file F is to be communicated by sending N independent transmissions.
Reference: [11] <author> Azer Bestavros and Sue Nagy. </author> <title> Value-cognizant admission control for rtdbs. </title> <booktitle> In Proceedings of RTSS'96: The 16 th IEEE Real-Time System Symposium, </booktitle> <address> Washington, DC, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: For example, the constraint would only be 6; 000 msecs for the data item recording the position of a tank with a velocity of 60 km/hour. Other reasons for imposing timing constraints on data retrieval from a Bdisk are due to the requirements of database protocols for admission control <ref> [11] </ref>, concurrency control, transaction scheduling [29], recovery [22], and bounded imprecision [32, 33]. The real-time constraints imposed on Bdisks protocols become even more pressing when issues of fault-tolerance are to be considered. Current Bdisks protocols assume that the broadcast infrastructure is not prone to failure.
Reference: [12] <author> M. Y. Chan and Francis Chin. </author> <title> Schedulers for the pinwheel problem based on double-integer reduction. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41(6) </volume> <pages> 755-768, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: When the number of tasks is not restricted, Holte et al [19] have a simple and elegant algorithm for scheduling any pinwheel task system with density at most one-half. Chan and Chin <ref> [13, 12] </ref> have significantly improved this result, designing a series of algorithms with successively better density bounds, culminating finally in one that can schedule any pinwheel system with a density at most 7=10 [12]. 3.2 Pinwheel Scheduling for Bdisks Suppose that a broadcast file F i is specified by a size <p> Chan and Chin [13, 12] have significantly improved this result, designing a series of algorithms with successively better density bounds, culminating finally in one that can schedule any pinwheel system with a density at most 7=10 <ref> [12] </ref>. 3.2 Pinwheel Scheduling for Bdisks Suppose that a broadcast file F i is specified by a size m i 2 N in blocks and a latency T i 2 N in seconds. <p> Since the algorithm of Chan and Chin <ref> [12] </ref> can schedule any pinwheel task system with density at most 7=10, n X m i 10 is sufficient for this purpose. <p> Furthermore, this upper bound is easily and efficiently realised | given this much bandwidth, the scheduling algorithm of Chan and Chin <ref> [12] </ref> can be used to determine the actual layout of blocks on the Bdisk. The fault-tolerance case when up to r faults must be tolerated is similarly handled. <p> F 2 ; : : : ; F n is equivalent to the following pinwheel scheduling problem: Determine a broadacst program that satisfies n ^ 0 ^ pc (i; m i + j; d i ) A (4) 4.2 Obtaining Broadcast Programs for Generalized Bdisks Recall that Chan and Chin <ref> [12] </ref> have designed an algorithm for scheduling any system of pinwheel tasks that has a density of at most 0:7. <p> this algorithm determines a P satisfying pc (1; a 1 ; b 1 ) ^ pc (2; a 2 ; b 2 ) ^ : : : ^ pc (n; a n ; b n ); provided ( P n An important observation about this algorithm of Chan and Chin <ref> [12] </ref> is that it can only schedule pinwheel task systems where each task is constrained by a single pinwheel condition. That is, we do not have any i such that both pc (i; a; b) and pc (i; a 0 ; b 0 ) must be satisfied. <p> That is, we are looking to convert a conjunct of pinwheel conditions on a single task into either a single pinwheel condition, or to a conjunct of pinwheel conditions on several tasks, such that these new conditions imply the original ones. Since the test of <ref> [12] </ref> is density-based, we would like to be able to perform such a conversion while causing the minimum possible increase in the density of the system.
Reference: [13] <author> M. Y. Chan and Francis Chin. </author> <title> Schedulers for larger classes of pinwheel instances. </title> <journal> Algo-rithmica, </journal> <volume> 9 </volume> <pages> 425-462, </pages> <year> 1993. </year>
Reference-contexts: When the number of tasks is not restricted, Holte et al [19] have a simple and elegant algorithm for scheduling any pinwheel task system with density at most one-half. Chan and Chin <ref> [13, 12] </ref> have significantly improved this result, designing a series of algorithms with successively better density bounds, culminating finally in one that can schedule any pinwheel system with a density at most 7=10 [12]. 3.2 Pinwheel Scheduling for Bdisks Suppose that a broadcast file F i is specified by a size
Reference: [14] <author> Garth Gibson, Lisa Hellerstein, Richard Karp, Randy Katz, and David Patterson. </author> <title> Coding techniques for handling failures in large disk arrays. </title> <type> Technical Report UCB/CSD 88/477, </type> <institution> Computer Science Division, University of California, </institution> <month> July </month> <year> 1988. </year>
Reference-contexts: In most of these protocols, redundancy is injected in the form of parity blocks, which are only used for error detection and/or correction purposes <ref> [14] </ref>. The IDA approach is different in that redundancy is added uniformly; there is simply no distinction between data and parity. It is this feature that makes it possible to scale the amount of redundancy used in IDA. Indeed, this is the basis for the adaptive IDA (AIDA) [8].
Reference: [15] <author> David Gifford. </author> <title> Ploychannel systems for mass digital communication. </title> <journal> Communications of the ACM, </journal> <volume> 33, </volume> <month> February </month> <year> 1990. </year>
Reference-contexts: by continuously and repeatedly broadcasting data to clients, thus in effect making the broadcast channel act as a set of disks (hence the term "Broadcast Disks") from which clients could fetch data "as it goes by." Work on Bdisks is different from previous work in both wired and wireless networks <ref> [15, 23] </ref> in that several sources of data are multiplexed and broadcast to clients, thus creating a hierarchy of Bdisks with different sizes and speeds. On the server side, this hierarchy gives rise to memory management issues (e.g., allocation of data to Bdisks based on priority/urgency).
Reference: [16] <author> C. C. Han and K. J. Lin. </author> <title> Scheduling distance-constrained real-time tasks. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1992. </year>
Reference-contexts: Since its introduction, this task model has been used to model the requirements of a wide variety of real-time systems. For example, Han & Lin <ref> [16] </ref> have used pinwheel techniques to model distance-constrained tasks; Hsueh, Lin, and Fan [21] have extended this research to distributed systems. Baruah, Rosier, and Varvel [5] have used pinwheel scheduling to construct static schedules for sporadic task systems.
Reference: [17] <author> C. C. Han and K. G. Shin. </author> <title> A polynomial time optimal synchronous bandwidth allocation scheme for the time-token MAC protocol. </title> <booktitle> In Proceedings of IEEE INFOCOMM'95, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: For example, Han & Lin [16] have used pinwheel techniques to model distance-constrained tasks; Hsueh, Lin, and Fan [21] have extended this research to distributed systems. Baruah, Rosier, and Varvel [5] have used pinwheel scheduling to construct static schedules for sporadic task systems. Recently, Han & Shin <ref> [17, 18] </ref> have applied pinwheel techniques to real-time network scheduling.
Reference: [18] <author> C. C. Han and K. G. Shin. </author> <title> Real-time communication in FieldBus multiaccess networks. </title> <booktitle> In Proceedings of the Real-Time Technology and Applications Symposium, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: For example, Han & Lin [16] have used pinwheel techniques to model distance-constrained tasks; Hsueh, Lin, and Fan [21] have extended this research to distributed systems. Baruah, Rosier, and Varvel [5] have used pinwheel scheduling to construct static schedules for sporadic task systems. Recently, Han & Shin <ref> [17, 18] </ref> have applied pinwheel techniques to real-time network scheduling.
Reference: [19] <author> R. Holte, A. Mok, L. Rosier, I. Tulchinsky, and D. Varvel. </author> <title> The pinwheel: A real-time scheduling problem. </title> <booktitle> In Proceedings of the 22nd Hawaii International Conference on System Science, </booktitle> <pages> pages 693-702, </pages> <address> Kailua-Kona, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: This research: The contributions of this paper are twofold. First, we show that the problem of designing real-time Bdisk programs is intimately linked to the pinwheel scheduling problem <ref> [19] </ref>, and make use of this link to (1) derive upper bounds on the bandwidth requirements for real-time fault-tolerant Bdisks (corresponding to the lower bounds in [9]), and (2) obtain efficient algorithms for designing fault-tolerant real-time Bdisk programs. <p> Generally speaking, the value of t depends on many parameters, including the granurality of the blocks, the length of the broadcast program, and the relative sizes of the files included in the broadcast program. 3 Pinwheel Task Systems Pinwheel task systems were introduced by Holte et al. <ref> [19] </ref>, in the context of o*ine scheduling for satellite-based communication. Since its introduction, this task model has been used to model the requirements of a wide variety of real-time systems. <p> When the number of tasks is not restricted, Holte et al <ref> [19] </ref> have a simple and elegant algorithm for scheduling any pinwheel task system with density at most one-half. <p> Given F 1 ; F 2 ; : : : ; F n , the problem of determining minimum bandwidth (in blocks/sec) reduces to determining the smallest B 2 N such that the system of pinwheel tasks <ref> [19] </ref> f (1; m 1 ; BT 1 ); (2; m 2 ; BT 2 ); : : : ; (n; m n ; BT n )g can be scheduled.
Reference: [20] <author> R. Holte, L. Rosier, I. Tulchinsky, and D. Varvel. </author> <title> Pinwheel scheduling with two distinct numbers. </title> <journal> Theoretical Computer Science, </journal> <volume> 100(1) </volume> <pages> 105-135, </pages> <year> 1992. </year>
Reference-contexts: The issue of designing efficient scheduling algorithms for pinwheel task systms has been the subject of much research. Holte et al <ref> [20] </ref> presented an algorithm which schedules any pinwheel task system of two tasks with density at most one.
Reference: [21] <author> C. W. Hsueh, K. J. Lin, and N. Fan. </author> <title> Distributed pinwheel scheduling with end-to-end timing constraints. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: Since its introduction, this task model has been used to model the requirements of a wide variety of real-time systems. For example, Han & Lin [16] have used pinwheel techniques to model distance-constrained tasks; Hsueh, Lin, and Fan <ref> [21] </ref> have extended this research to distributed systems. Baruah, Rosier, and Varvel [5] have used pinwheel scheduling to construct static schedules for sporadic task systems. Recently, Han & Shin [17, 18] have applied pinwheel techniques to real-time network scheduling.
Reference: [22] <author> Jing Huang and Le Gruenwald. </author> <title> An update-frequency-valid-interval partition checkpoint technique for real-time main memory databases. </title> <booktitle> In Proceedings of RTDB'96: The 1996 Workshop on Real-Time Databases, </booktitle> <pages> pages 135-143, </pages> <address> Newport Beach, California, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: Other reasons for imposing timing constraints on data retrieval from a Bdisk are due to the requirements of database protocols for admission control [11], concurrency control, transaction scheduling [29], recovery <ref> [22] </ref>, and bounded imprecision [32, 33]. The real-time constraints imposed on Bdisks protocols become even more pressing when issues of fault-tolerance are to be considered. Current Bdisks protocols assume that the broadcast infrastructure is not prone to failure.
Reference: [23] <author> T. Imielinski and B. Badrinath. </author> <title> Mobile wireless computing: Challenges in data management. </title> <journal> Communications of the ACM, </journal> <volume> 37, </volume> <month> October </month> <year> 1994. </year>
Reference-contexts: by continuously and repeatedly broadcasting data to clients, thus in effect making the broadcast channel act as a set of disks (hence the term "Broadcast Disks") from which clients could fetch data "as it goes by." Work on Bdisks is different from previous work in both wired and wireless networks <ref> [15, 23] </ref> in that several sources of data are multiplexed and broadcast to clients, thus creating a hierarchy of Bdisks with different sizes and speeds. On the server side, this hierarchy gives rise to memory management issues (e.g., allocation of data to Bdisks based on priority/urgency).
Reference: [24] <author> T. Imielinski, S. Viswanathan, and B. Badrinath. </author> <title> Energy efficient indexing on air. </title> <booktitle> In Proceedings of ACM SIGMOD Conference, </booktitle> <address> Minneapolis, MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: By using proper pipelining and more elaborate designs, this figure can be boosted significantly. 2 For more details, we refer the reader to the papers by Rabin [30] and Bestavros [7] on IDA implementation. 3 Another alternative is to broadcast a directory (or index <ref> [24] </ref>) at the beginning of each broadcast period. This approach is less desirable because it does not lend itself to a clean fault-tolerant organization. 2.2 Adaptive Information Dispersal and Retrieval Several fault-tolerant redundancy-injecting protocols have been suggested in the literature.
Reference: [25] <author> IVHS America. </author> <title> IVHS architecture development program: </title> <type> Interim status report, </type> <month> April </month> <year> 1994. </year>
Reference-contexts: IVHS systems allow for automated route guidance and automated rerouting around traffic incidents by allowing the mobile vehicle software to query and react to changes in IVHS databases <ref> [26, 25] </ref>. Other examples include wearable computers for soldiers in the battlefield and computerized cable boxes for future interactive TV networks and video-on-demand. Such systems are characterized by the significant discrepancy between the downstream communication capacity from servers (e.g.
Reference: [26] <author> R.K. Jurgen. </author> <title> Smart cars and highways go global. </title> <journal> IEEE Spectrum, </journal> <pages> pages 26-37, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: IVHS systems allow for automated route guidance and automated rerouting around traffic incidents by allowing the mobile vehicle software to query and react to changes in IVHS databases <ref> [26, 25] </ref>. Other examples include wearable computers for soldiers in the battlefield and computerized cable boxes for future interactive TV networks and video-on-demand. Such systems are characterized by the significant discrepancy between the downstream communication capacity from servers (e.g.
Reference: [27] <author> S. S. Lin and K. J. Lin. </author> <title> Pinwheel scheduling with three distinct numbers. </title> <booktitle> In Proceedings of the EuroMicro Workshop on Real-Time Systems, </booktitle> <address> Vaesteraas, Sweden, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The issue of designing efficient scheduling algorithms for pinwheel task systms has been the subject of much research. Holte et al [20] presented an algorithm which schedules any pinwheel task system of two tasks with density at most one. Lin & Lin <ref> [27] </ref> have designed an algorithm which schedules any pinwheel task system of three tasks with a density at most five-sixth's (this algorithm is optimal in the sense that, as the third example pinwheel task system in Example 1 shows, there are three-task systems with density 5=6 + * that are infeasible,
Reference: [28] <author> Yuh-Dauh Lyuu. </author> <title> Fast fault-tolerant parallel communication and on-line maintenance using information dispersal. </title> <type> Technical Report TR-19-1989, </type> <institution> Harvard University, Cambridge, Massachusetts, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: AIDA is an elaboration on the Information Dispersal Algorithm of Michael O. Rabin [30], which was previously shown to be a sound mechanism that considerably improves the performance of I/O systems, parallel/distributed storage devices [6, 10], and routing in parallel architectures <ref> [28] </ref>. 2.1 Information Dispersal and Retrieval Let F represent the original data object (hereinafter referred to as the file) to be communicated (or retrieved). Furthermore, assume that file F is to be communicated by sending N independent transmissions.
Reference: [29] <author> Ozgur Ulusoy and Alejandro Buchmann. </author> <title> Exploiting main memory dbms features to improve real-time concurrency protocols. </title> <journal> ACM SIGMOD Record, </journal> <volume> 25(1), </volume> <month> March </month> <year> 1996. </year>
Reference-contexts: Other reasons for imposing timing constraints on data retrieval from a Bdisk are due to the requirements of database protocols for admission control [11], concurrency control, transaction scheduling <ref> [29] </ref>, recovery [22], and bounded imprecision [32, 33]. The real-time constraints imposed on Bdisks protocols become even more pressing when issues of fault-tolerance are to be considered. Current Bdisks protocols assume that the broadcast infrastructure is not prone to failure.
Reference: [30] <author> Michael O. Rabin. </author> <title> Efficient dispersal of information for security, load balancing and fault tolerance. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 36(2) </volume> <pages> 335-348, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: AIDA is a novel technique for dynamic bandwidth allocation, which makes use of minimal, controlled redundancy to guarantee timeliness and fault-tolerance up to any degree of confidence. AIDA is an elaboration on the Information Dispersal Algorithm of Michael O. Rabin <ref> [30] </ref>, which was previously shown to be a sound mechanism that considerably improves the performance of I/O systems, parallel/distributed storage devices [6, 10], and routing in parallel architectures [28]. 2.1 Information Dispersal and Retrieval Let F represent the original data object (hereinafter referred to as the file) to be communicated (or <p> The performance of the chip was measured to be about 1 megabyte per second. By using proper pipelining and more elaborate designs, this figure can be boosted significantly. 2 For more details, we refer the reader to the papers by Rabin <ref> [30] </ref> and Bestavros [7] on IDA implementation. 3 Another alternative is to broadcast a directory (or index [24]) at the beginning of each broadcast period.
Reference: [31] <author> Krithi Ramamritham. </author> <title> Real-time databases. </title> <journal> International journal of Distributed and Parallel Databases, </journal> <volume> 1(2), </volume> <year> 1993. </year>
Reference-contexts: Rather, guaranteeing (either deterministically or probabilistically) that timing constraints imposed on data retrieval will be met becomes the overriding concern. There are many reasons for subjecting Bdisk data retrieval to timing constraints. Perhaps the most compelling is due to the absolute temporal consistency constraints <ref> [31] </ref> that may be imposed on data objects.
Reference: [32] <author> Wei-Kuan Shih, Jane Liu, and Jen-Yao Chung. </author> <title> Algorithms for scheduling imprecise computations with timing constraints. </title> <journal> SIAM journal of Computing, </journal> <month> July </month> <year> 1991. </year>
Reference-contexts: Other reasons for imposing timing constraints on data retrieval from a Bdisk are due to the requirements of database protocols for admission control [11], concurrency control, transaction scheduling [29], recovery [22], and bounded imprecision <ref> [32, 33] </ref>. The real-time constraints imposed on Bdisks protocols become even more pressing when issues of fault-tolerance are to be considered. Current Bdisks protocols assume that the broadcast infrastructure is not prone to failure.
Reference: [33] <author> V. Fay Wolfe, L. Cingiser DiPippo, and J. K. Black. </author> <title> Supporting concurrency, timing constraints and imprecision in objects. </title> <type> Technical Report TR94-230, </type> <institution> University of Rhode Island, Computer Science Department, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: Other reasons for imposing timing constraints on data retrieval from a Bdisk are due to the requirements of database protocols for admission control [11], concurrency control, transaction scheduling [29], recovery [22], and bounded imprecision <ref> [32, 33] </ref>. The real-time constraints imposed on Bdisks protocols become even more pressing when issues of fault-tolerance are to be considered. Current Bdisks protocols assume that the broadcast infrastructure is not prone to failure.
Reference: [34] <author> S. Zdonik, M. Franklin, R. Alonso, and S. Acharya. </author> <booktitle> Are `disks in the air' just pie in the sky? In Proceedings of the IEEE Workshop on Mobile Computing Systems and Applications, </booktitle> <address> Santa Cruz, CA, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: Broadcast Disks: The concept of Broadcast Disks (Bdisks) was introduced by Zdonik et al. <ref> [34] </ref> as a mechanism that uses communication bandwidth to emulate a storage device (or a memory hierarchy in general) for mobile clients of a database system.
References-found: 34

