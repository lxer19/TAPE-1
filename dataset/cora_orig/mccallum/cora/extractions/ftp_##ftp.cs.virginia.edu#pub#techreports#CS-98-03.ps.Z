URL: ftp://ftp.cs.virginia.edu/pub/techreports/CS-98-03.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Automated Delegation is a Viable Alternative to Multiple Inheritance in Class Based Languages  
Author: John Viega, Bill Tutt, Reimer Behrends 
Date: March 3, 1998 Last revised: March 12, 1998  
Pubnum: UVA Technical Report CS-98-03  
Abstract: Multiple inheritance is still a controversial feature in traditional objectoriented languages, as evidenced by its omission from such languages as Modula-3, Objective C and Java. Nonetheless, users of such languages often complain about having to work around the absence of multiple inheritance. Automating delegation, in combination with a multiple subtyping mechanism, provides many of the same benefits as multiple inheritance, yet sidesteps most of the associated problems. This simple feature could satisfy both the designers and the users of class based object oriented languages. In this paper, we discuss why automated delegation is desirable. We also present Jamie, a freeware preprocessor-based extension to Java that offers such an alternative. 
Abstract-found: 1
Intro-found: 1
Reference: [AFM97] <author> O. Agesen, S. Freund, J. Mitchell. </author> <title> Adding type parameterization to the Java language. </title> <booktitle> In OOPSLA 97 Conference Proceedings. ACM SIGPLAN Notices 32, </booktitle> <address> 10 (Oct. </address> <year> 1997). </year>
Reference-contexts: A hybrid model called object specialization is presented in [Sci89]. With object specialization, objects still have a class from which it receives variables and methods, but individual objects determine what they inherit. A method for using parametric polymorphism to support mixins is shown in <ref> [AFM97] </ref>, in the context of a Java language extension. However, this approach to mixins suffers from a few drawbacks. First, the syntax is nonintuitive, in that multiple mixins must be declared as nested template parameters, which forces an ordering, when, conceptually, there should not be one.
Reference: [AG96] <author> K. Arnold, J. Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Java supports this type of multiple inheritance, although in a limited manner, since a class may only inherit a single implementation. 4 Why interfaces are not sufficient The designers of Java chose to exclude multiple inheritance mainly due to the difficulties of implementing repeated inheritance <ref> [AG96] </ref>. However, they recognized the utility of the feature, and offered language support for interfaces, claiming that they offer all of the desirable features of multiple inheritance, without the drawbacks [GM95].
Reference: [BC90] <author> G. Bracha, W. Cook. </author> <title> Mixin-based inheritance. </title> <booktitle> In OOPSLA/ECOOP 90 Conference Proceedings. ACM SIGPLAN Notices 25, </booktitle> <address> 10 (Oct. </address> <year> 1990). </year>
Reference-contexts: As previously mentioned, C++ had a delegation mechanism for a short time before multiple inheritance was added [Str94], but it was error-prone as designed. Bracha and Cook added direct support for mixins to Modula-3, but they were a static concept, and both a subtyping and subclassing mechanism <ref> [BC90] </ref>. Cecils predicate classes are a variation on dynamic inheritance for a class-based language [Cha93]. Predicate classes offer dynamic subtyping as well as dynamic subclassing, as a single coupled mechanism.
Reference: [Boo94] <author> G. Booch. </author> <title> ObjectOriented Analysis and Design With Applications, 2 nd edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Also, sometimes having a base class explicitly duplicated is the right design decision [Str94]. Yet another problem with multiple inheritance is that it is often overused; i.e., some programmers use it in an unclear or undesirable manner <ref> [Boo94] </ref>.
Reference: [Bor81] <author> A. Borning. </author> <title> The programming language aspects of ThingLab, a constraint-oriented simulation laboratory. </title> <journal> ACM Transactions of Programming Languages And Systems 3, </journal> <month> 4 (Oct. </month> <year> 1981). </year>
Reference-contexts: Jamie addresses Stroustrups second problem directly by providing the forwarder keyword, allowing the delegate to refer back to the delegating object. 8 Related work Delegation is the foundation of a number of object-oriented languages without classes, such as ThingLab <ref> [Bor81] </ref>, Act-1 [Lie87], a Smalltalk without classes [LTP86], and, perhaps most notably, Self [US87]. Such languages were shown to be equally as powerful conceptually as inheritance by Lynn Stein [Ste87], although she notes that, in practice, either delegation or inheritance may be more desirable.
Reference: [Cha93] <author> C. Chambers. </author> <title> Predicate classes. </title> <booktitle> In ECOOP 93 Conference Proceedings. </booktitle>
Reference-contexts: Bracha and Cook added direct support for mixins to Modula-3, but they were a static concept, and both a subtyping and subclassing mechanism [BC90]. Cecils predicate classes are a variation on dynamic inheritance for a class-based language <ref> [Cha93] </ref>. Predicate classes offer dynamic subtyping as well as dynamic subclassing, as a single coupled mechanism. For future work, we plan to explore dynamic subtyping issues in Java by extending the interface mechanism, keeping it orthogonal from our delegation mechanism.
Reference: [CW85] <author> L. Cardelli, P. Wegner. </author> <title> On understanding types, data abstraction and polymorphism. </title> <journal> ACM Computing Surveys 17, </journal> <month> 4 (Dec. </month> <year> 1985). </year>
Reference-contexts: Otherwise, mixins are generally self contained. The main advantage of the mixin style of programming is that it encourages programmers to provide modular highly reusable components. 3. Multiple subtyping: One of the advantages of objectoriented languages is inclusion polymorphism, i.e., polymorphism through inheritance <ref> [CW85] </ref>. Multiple subtyping enhances this advantage, as only having a single inherited type is potentially limiting. 4. Pairing interfaces and implementations: Keeping interfaces and implementations (subtypes and subclasses) separate helps encourage reuse.
Reference: [GH+95] <author> E. Gamma, R. Helm, R. Johnson, J. Vlissides. </author> <title> Design Patterns. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: And while such a dynamic feature can provide the programmer with much expressive power, if abused, it can lead to code that is harder to read than static software <ref> [GH+95] </ref>. The forwarder keyword as implemented in Jamie has a potential drawback in that there is no way for the compiler to know the type of the forwarder, since arbitrary classes may delegate to arbitrary classes. Therefore, the programmer must pay the price of a run time cast.
Reference: [GJS96] <author> J. Gosling, B. Joy, G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: The rationale for this design is that having to declare these exceptions at every method that could possibly throw them would be an extraordinarily inconvenient burden to place on the programmer <ref> [GJS96] </ref>. Another way to solve this problem would be to only allow delegation to variables declared to be interface types. However, we felt this solution would be needlessly restrictive, and would be less useful than our proposed solution in practice.
Reference: [GM95] <author> J. Gosling, H. McGilton. </author> <title> The Java Language Environment. Sun Microsystems, </title> <year> 1995. </year>
Reference-contexts: However, they recognized the utility of the feature, and offered language support for interfaces, claiming that they offer all of the desirable features of multiple inheritance, without the drawbacks <ref> [GM95] </ref>. Java interfaces certainly avoid most problems generally associated with multiple inheritance, since those problems are, for the most part, the direct results of multiple subclassing, and not multiple subtyping.
Reference: [Knu88] <author> J. Knudsen. </author> <title> Name collision in multiple classification hierarchies. </title> <booktitle> In ECOOP 88 Conference Proceedings. </booktitle>
Reference-contexts: While most solutions to name conflicts that demand explicit resolution provide a straightforward and clear solution, none of them have completely avoided criticism. A comprehensive study of issues surrounding naming conflicts is presented in <ref> [Knu88] </ref>, which suggests that attributes should be disambiguated at class definition, so as to avoid limiting the utility of multiple inheritance. We believe that this solution not only maximizes flexibility but also is simple both for the programmer and the language designer.
Reference: [Lie86] <author> H. Lieberman. </author> <title> Using prototypical objects to implement shared behavior in object oriented systems. </title> <booktitle> In OOPSLA 86 Conference Proceedings. ACM SIGPLAN Notices 21, </booktitle> <address> 11 (Nov. </address> <year> 1986). </year>
Reference-contexts: In contrast, multiple inheritance generally (though not always) implies some degree of white-box reuse, which severely weakens encapsulation [Sny86]. Also, specializing a prototypical instance offers an alternative to the abstract, set-theoretic inheritance that better supports the way people tend to think about real objects <ref> [Lie86] </ref>, and promotes unanticipated sharing; i.e., reuse not anticipated by the author of the class [SLU88]. Also, delegation is a useful abstraction tool under circumstances that are not easily and cleanly handled by other language mechanisms, including inheritance.
Reference: [Lie87] <author> H. Lieberman. </author> <title> Concurrent Objectoriented programming in Act-1. </title> <editor> In A. Yonezawa, M. Tokoro (ed.), </editor> <booktitle> ObjectOriented Concurrent Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Jamie addresses Stroustrups second problem directly by providing the forwarder keyword, allowing the delegate to refer back to the delegating object. 8 Related work Delegation is the foundation of a number of object-oriented languages without classes, such as ThingLab [Bor81], Act-1 <ref> [Lie87] </ref>, a Smalltalk without classes [LTP86], and, perhaps most notably, Self [US87]. Such languages were shown to be equally as powerful conceptually as inheritance by Lynn Stein [Ste87], although she notes that, in practice, either delegation or inheritance may be more desirable.
Reference: [LP91] <author> W. LaLonde, J. Pugh. </author> <title> Subclassing subtyping is-a. </title> <journal> Journal of ObjectOriented Programming 3, </journal> <month> 5 (Jan. </month> <year> 1991). </year>
Reference-contexts: In fact, the conceptual specialization relationship IS-A is desirable, but separate from the notion of subclassing as a way of sharing code and data <ref> [LP91] </ref>. However, as we have previously discussed, a multiple subtyping mechanism in itself is not sufficient to replace multiple inheritance.
Reference: [LTP86] <author> W. LaLonde, D. Thomas, J. Pugh. </author> <title> An exemplar based Smalltalk. </title> <booktitle> In OOPSLA 86 Conference Proceedings. ACM SIGPLAN Notices 21, </booktitle> <address> 11 (Nov. </address> <year> 1986). </year>
Reference-contexts: Jamie addresses Stroustrups second problem directly by providing the forwarder keyword, allowing the delegate to refer back to the delegating object. 8 Related work Delegation is the foundation of a number of object-oriented languages without classes, such as ThingLab [Bor81], Act-1 [Lie87], a Smalltalk without classes <ref> [LTP86] </ref>, and, perhaps most notably, Self [US87]. Such languages were shown to be equally as powerful conceptually as inheritance by Lynn Stein [Ste87], although she notes that, in practice, either delegation or inheritance may be more desirable.
Reference: [Mac87] <author> B. MacLennan. </author> <booktitle> Principles of Programming Languages: Design, Evaluation, and Implementation, </booktitle> <address> 2 nd Edition. </address> <publisher> HBJ, </publisher> <year> 1987. </year>
Reference-contexts: However, delegation can also be viewed as an unsuitable coping strategy, since the user must tediously write one-line methods to dispatch to a delegate. In general, languages should automate such repetitive and error-prone tasks, if it is simple to do so <ref> [Mac87] </ref>. There is no universal consensus as to what are acceptable and desirable uses for multiple inheritance. However, researchers tend to enumerate them in similar-looking but not quite identical lists (e.g., [Str94], [Mey88] and [Sin95]).
Reference: [Mey88] <author> B. Meyer. </author> <title> ObjectOriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: He cites <ref> [Mey88] </ref>, who gave the example of a Fixed_Stack class inheriting from classes Stack and Array. His reasoning is that a fixed-size stack is conceptually a specialization of a stack only, and should therefore use the class Array only as a contained component. <p> In general, languages should automate such repetitive and error-prone tasks, if it is simple to do so [Mac87]. There is no universal consensus as to what are acceptable and desirable uses for multiple inheritance. However, researchers tend to enumerate them in similar-looking but not quite identical lists (e.g., [Str94], <ref> [Mey88] </ref> and [Sin95]). We consider the following uses of multiple inheritance to be desirable, all of which we have seen promoted in several sources: 1. Multiple specialization: An object is conceptually a specialization of two different objects.
Reference: [Mey97] <editor> B. Meyer. </editor> <booktitle> ObjectOriented Software Construction, </booktitle> <address> 2 nd edition. </address> <publisher> Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: Also, delegation is a useful abstraction tool under circumstances that are not easily and cleanly handled by other language mechanisms, including inheritance. Consider Meyer's defense of his use of multiple inheritance to handle a Fixed_Stack class which is presented in <ref> [Mey97] </ref>. In his example, Fixed_Stack inherits from both Stack and Array, where Stack as an abstract class provides the skeleton that is filled in by the methods from Array.
Reference: [PQ95] <author> T. Parr, R. Quong. </author> <title> ANTLR: A predicated-LL(k) parser generator. </title> <journal> Software Practice and Experience 25, </journal> <month> 7 (July </month> <year> 1995). </year>
Reference-contexts: We chose to add our extensions to Java because it already has a multiple subtyping mechanism (interfaces), and because it lacks multiple inheritance, and is unlikely to get it. Jamie is implemented as a preprocessor, using the Antlr LL (k) parser generator <ref> [PQ95] </ref> and its supplied Java 1.1 grammar, and Javas reflection mechanism. To use Jamie, the programmer writes his code in files with a .jam extension, which, when Jamie is run, get processed, and converted into a file with a .java extension.
Reference: [SCB+86] <author> C. Schaffert, T. Cooper, B. Bullis, M. Killian, C. Wilpot. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In OOPSLA 86 Conference Proceedings. ACM SIGPLAN Notices 21, </booktitle> <address> 11 (Nov. </address> <year> 1986). </year>
Reference-contexts: Should inheritance be virtual? That is, should there be only one shared copy of the class inherited multiple times, as in Trellis/Owl <ref> [SCB+86] </ref>? Should there always be one copy for each time a class is inherited, as in Python? Or should the programmer have control, as in C++? Virtual inheritance removes multiple copies of instance variables, which saves space and prevents the accidental modification of the wrong set of instance variables.
Reference: [Sci89] <author> E. Sciore. </author> <title> Object Specialization. </title> <journal> In ACM Transactions on Information Systems 7, </journal> <month> 2 (Apr. </month> <year> 1989). </year>
Reference-contexts: She even proposes a hybrid model that would allow for both delegation and inheritance in the same language. An excellent analysis of the similarities and differences in both sharing mechanisms is presented in [SLU88]. A hybrid model called object specialization is presented in <ref> [Sci89] </ref>. With object specialization, objects still have a class from which it receives variables and methods, but individual objects determine what they inherit. A method for using parametric polymorphism to support mixins is shown in [AFM97], in the context of a Java language extension.
Reference: [Sin95] <author> G. Singh. </author> <title> Single versus multiple inheritance in object oriented programming. </title> <booktitle> In OOPS Messenger 6, </booktitle> <month> 1 (Jan. </month> <year> 1995). </year>
Reference-contexts: There is no universal consensus as to what are acceptable and desirable uses for multiple inheritance. However, researchers tend to enumerate them in similar-looking but not quite identical lists (e.g., [Str94], [Mey88] and <ref> [Sin95] </ref>). We consider the following uses of multiple inheritance to be desirable, all of which we have seen promoted in several sources: 1. Multiple specialization: An object is conceptually a specialization of two different objects. For example, a class InputOutputStream is a specialization of both an InputStream and OutputStream. 2.
Reference: [SLU88] <author> L. Stein, H. Lieberman, D. Ungar. </author> <title> A shared view of sharing: the treaty of Orlando. </title> <editor> In W. Kim, F. Lochowsky (ed.), </editor> <booktitle> ObjectOriented Concepts, Applications and Databases. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Also, specializing a prototypical instance offers an alternative to the abstract, set-theoretic inheritance that better supports the way people tend to think about real objects [Lie86], and promotes unanticipated sharing; i.e., reuse not anticipated by the author of the class <ref> [SLU88] </ref>. Also, delegation is a useful abstraction tool under circumstances that are not easily and cleanly handled by other language mechanisms, including inheritance. Consider Meyer's defense of his use of multiple inheritance to handle a Fixed_Stack class which is presented in [Mey97]. <p> She even proposes a hybrid model that would allow for both delegation and inheritance in the same language. An excellent analysis of the similarities and differences in both sharing mechanisms is presented in <ref> [SLU88] </ref>. A hybrid model called object specialization is presented in [Sci89]. With object specialization, objects still have a class from which it receives variables and methods, but individual objects determine what they inherit.
Reference: [Sny86] <author> A. Snyder. </author> <title> Encapsulation and inheritance in objectoriented programming languages. </title> <booktitle> In OOPSLA 86 Conference Proceedings. ACM SIGPLAN Notices 21, </booktitle> <address> 11 (Nov. </address> <year> 1986). </year>
Reference-contexts: Linearization has an additional problem in that a classs real superclass may not reflect its superclass after the inheritance tree is linearized <ref> [Sny86] </ref>. This side effect is undesirable because a class may pass messages back to a different base class than the programmer intended. While explicit resolution places the burden of resolving names on the programmer, it does avoid unanticipated, undesirable resolutions. <p> However, unless programmers anticipate potential sharing of instance variables, unexpected side effects may occur. For example, when a class operation performs a depth-first traversal of the inheritance graph, the same class method may get called twice, unexpectedly <ref> [Sny86] </ref>. Also, sometimes having a base class explicitly duplicated is the right design decision [Str94]. Yet another problem with multiple inheritance is that it is often overused; i.e., some programmers use it in an unclear or undesirable manner [Boo94]. <p> Another benefit is that the mechanism only allows for black-box reuse: the delegating object has no special access to the implementation of the delegate. In contrast, multiple inheritance generally (though not always) implies some degree of white-box reuse, which severely weakens encapsulation <ref> [Sny86] </ref>. Also, specializing a prototypical instance offers an alternative to the abstract, set-theoretic inheritance that better supports the way people tend to think about real objects [Lie86], and promotes unanticipated sharing; i.e., reuse not anticipated by the author of the class [SLU88].
Reference: [Ste87] <author> L. Stein. </author> <title> Delegation Is Inheritance. </title> <booktitle> In OOPSLA 87 Conference Proceedings. ACM SIGPLAN Notices 22, </booktitle> <address> 12 (Oct. </address> <year> 1987). </year>
Reference-contexts: Such languages were shown to be equally as powerful conceptually as inheritance by Lynn Stein <ref> [Ste87] </ref>, although she notes that, in practice, either delegation or inheritance may be more desirable. She even proposes a hybrid model that would allow for both delegation and inheritance in the same language. An excellent analysis of the similarities and differences in both sharing mechanisms is presented in [SLU88].
Reference: [Str94] <author> B. Stroustrup. </author> <title> The Design and Evolution of C++. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: No resolution: naming conflicts are not allowed at all. Stroustrup notes that his practical experience shows that order dependencies in a language are generally a source of problems. He cites this problem as a reason for requiring explicit resolution <ref> [Str94] </ref>. Indeed, it is easy to see how it might be problematic if the semantics of a program change based on whether a class inherits A before B, or B before A. <p> However, a similar feature was considered for inclusion into C++, and later rejected, since such problems do not occur overly often, and such a language feature can lead to following a convoluted trail of chained aliases <ref> [Str94] </ref>. While most solutions to name conflicts that demand explicit resolution provide a straightforward and clear solution, none of them have completely avoided criticism. <p> For example, when a class operation performs a depth-first traversal of the inheritance graph, the same class method may get called twice, unexpectedly [Sny86]. Also, sometimes having a base class explicitly duplicated is the right design decision <ref> [Str94] </ref>. Yet another problem with multiple inheritance is that it is often overused; i.e., some programmers use it in an unclear or undesirable manner [Boo94]. <p> In general, languages should automate such repetitive and error-prone tasks, if it is simple to do so [Mac87]. There is no universal consensus as to what are acceptable and desirable uses for multiple inheritance. However, researchers tend to enumerate them in similar-looking but not quite identical lists (e.g., <ref> [Str94] </ref>, [Mey88] and [Sin95]). We consider the following uses of multiple inheritance to be desirable, all of which we have seen promoted in several sources: 1. Multiple specialization: An object is conceptually a specialization of two different objects. <p> If designing a language from scratch, however, we would almost certainly devise a suitable syntax to disallow forward referencing. Bjarne Stroustrup discusses other potential drawbacks to delegation in <ref> [Str94] </ref>. For a short time, C++ supported a simple delegation mechanism that automated the forwarding of messages to an object. The feature was removed from C++, as it was error prone and confusing [Str94]. Stroustrup believed the two sources of these problems to be: 1. <p> Bjarne Stroustrup discusses other potential drawbacks to delegation in <ref> [Str94] </ref>. For a short time, C++ supported a simple delegation mechanism that automated the forwarding of messages to an object. The feature was removed from C++, as it was error prone and confusing [Str94]. Stroustrup believed the two sources of these problems to be: 1. The delegate was an independent object, and thus the delegating object could not override its methods, which could be unexpected if such a method were called directly. 2. <p> As previously mentioned, C++ had a delegation mechanism for a short time before multiple inheritance was added <ref> [Str94] </ref>, but it was error-prone as designed. Bracha and Cook added direct support for mixins to Modula-3, but they were a static concept, and both a subtyping and subclassing mechanism [BC90]. Cecils predicate classes are a variation on dynamic inheritance for a class-based language [Cha93].
Reference: [Str98] <author> B. Stroustrup. </author> <type> Personal communication (Feb. </type> <year> 1998). </year>
Reference-contexts: The real problem was not the semantics, but that programmers could not remember the semantics; they would assume whatever was most convenient for the code they were writing <ref> [Str98] </ref>. This particular problem would go away if delegation were separated from type inheritance, as is the case with Jamie, or if assignment and casting only limited the interface of the delegating object, instead of essentially replacing the object with a delegate.
Reference: [Tai96] <author> A. Taivalsaari. </author> <title> On the notion of inheritance. </title> <booktitle> In ACM Computing Surveys 28, </booktitle> <address> 3 (Sept. </address> <year> 1996). </year>
Reference-contexts: Programmers often use multiple inheritance for containment, even though they are generally taught to only use it when the IS-A relationship is valid (We will discuss what is usually considered acceptable use in more detail in the next section). <ref> [Tai96] </ref> also notes that multiple inheritance is often used inappropriately, even in the literature. He cites [Mey88], who gave the example of a Fixed_Stack class inheriting from classes Stack and Array. <p> However, this strategy not only breaks encapsulation, it also fails to provide the Tank class with the methods it needs to implement the Armored interface, and makes it impossible for Tank to selectively override any of myArmors behavior. Another potential workaround is the copy and modify scheme <ref> [Tai96] </ref>, which has nothing but downsides in that it is highly error prone, breaks encapsulation, and defeats the notion of reuse encouraged by object oriented design methodologies. Yet another alternative is to modify the original base class, which is also undesirable. First, the source code must be available. <p> Second, editing the code can break something that works, which could even have an effect on other users and programs. Both copy and modify and editing the original class force the programmer to deal with the lower level implementation, and thus loses the benefit of abstraction <ref> [Tai96] </ref>. Delegation can be viewed as more useful than multiple inheritance, in that it is capable of dynamic changes that multiple inheritance generally does not support well. For example, users may dynamically change the implementation by reassigning to the delegate. <p> Such a design keeps all mode specific code together, instead of spreading it around via a conditional test in each relevant method, which can have a deleterious effect on code readability <ref> [Tai96] </ref>. <p> We wanted delegates to be clearly separated from their clients, and so we chose not to have the this keyword point back to the forwarder, as is done with the self-reference operator in many delegation-based languages <ref> [Tai96] </ref>. Our first mechanism was a caller keyword, which returned the object responsible for invoking the current method. We quickly found that such a mechanism did not support procedural decomposition. <p> As noted in section 2, this has been criticized as an inappropriate use of inheritance, as Fixed_Stack conceptually is not a specialization of Array <ref> [Tai96] </ref>. Still, if there are a number of similar container classes (e.g., stacks, queues, etc.) in need of an array-based implementation, a well-designed language should facilitate this task by allowing for a clean abstraction.
Reference: [US87] <author> D. Ungar, R. Smith. </author> <title> Self: the power of simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings. ACM SIGPLAN Notices 22, </booktitle> <address> 12 (Oct. </address> <year> 1987). </year>
Reference-contexts: Stroustrups second problem directly by providing the forwarder keyword, allowing the delegate to refer back to the delegating object. 8 Related work Delegation is the foundation of a number of object-oriented languages without classes, such as ThingLab [Bor81], Act-1 [Lie87], a Smalltalk without classes [LTP86], and, perhaps most notably, Self <ref> [US87] </ref>. Such languages were shown to be equally as powerful conceptually as inheritance by Lynn Stein [Ste87], although she notes that, in practice, either delegation or inheritance may be more desirable. She even proposes a hybrid model that would allow for both delegation and inheritance in the same language.
Reference: [VC+97] <author> E. Volanschi, C. Consel, G. Muller, C. Cowan. </author> <title> Declarative specialization of object-oriented programs. </title> <booktitle> In OOPSLA 97 Conference Proceedings. ACM SIGPLAN Notices 32, </booktitle> <address> 10 (Oct. </address> <year> 1997). </year>
Reference-contexts: For future work, we plan to explore dynamic subtyping issues in Java by extending the interface mechanism, keeping it orthogonal from our delegation mechanism. An extension to Java based on predicate classes is presented in <ref> [VC+97] </ref>, which is tailored towards the sole goal of specializing classes for efficiency purposes. 9 Conclusions In this paper we have presented automatic delegation for class based languages, which provides a second subclassing mechanism capable of multiple subclassing.
References-found: 30

