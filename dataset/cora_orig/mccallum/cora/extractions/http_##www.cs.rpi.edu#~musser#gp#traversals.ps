URL: http://www.cs.rpi.edu/~musser/gp/traversals.ps
Refering-URL: http://www.cs.rpi.edu/~musser/gp/index_2.html
Root-URL: http://www.cs.rpi.edu
Title: Complete Traversals and their Implementation Using the Standard Template Library 1  
Author: Eric Gamess David R. Musser and Arturo J. Sanchez-Ruiz Laboratorio de Construccion de Herramientas Automaticas (AuTooLab) 
Keyword: Generic Programming, Standard Template Library (STL), Iterators, Adaptors, Containers, Templates, C++.  
Note: for all 2 C  
Address: Apartado 47642, Caracas 1041-A Venezuela  Troy, NY 12180 USA  
Affiliation: Centro de Ingenieria de Software Sistemas (isys) Escuela de Computacion, Facultad de Ciencias Universidad Central de Venezuela  Computer Science Department Rensselaer Polytechnic Institute  
Email: E-mail: fegamess, asanchez g@anubis.ciens.ucv.ve  E-mail: musser@cs.rpi.edu  
Web: http://anubis.ciens.ucv.ve/asanchez /autoolab.html  http://www.cs.rpi.edu/musser  
Abstract: where F is a function that might possibly modify C by inserting new elements into it. We assume that the order in which the elements are treated is not relevant, as long as the iteration continues until F has been applied to all elements currently in C, including those F has inserted. Standard iteration mechanisms, such as the iterators provided in the C++ Standard Template Library (STL), do not directly support complete traversals. In this paper we present two approaches to complete traversals, both extending the STL framework, one by means of generic algorithms and the other by means of a container adaptor. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> ISO/IEC FDIS 14882. </author> <title> International Standard for the C++ Programming Language. </title> <institution> American National Standards Institute (ANSI), X3 Secretariat, </institution> <address> 1250 Eye Street NW, Suite 200, Washington, DC 20005, </address> <year> 1998. </year>
Reference-contexts: In this paper we describe two such approaches to complete traversals, both of which fit into the framework defined by the Standard Template Library, STL (part of the ANSI/ISO standard for C++ <ref> [1] </ref>). STL (see also [15, 11, 6]) provides a set of easily configurable software components of six major kinds: generic algorithms, containers, iterators, function objects, adaptors, and allocators.
Reference: [2] <author> A. Frick, W. Zimmer, and W. Zimmermann. Karla: </author> <title> An Extensible Library of Data Structures and Algorithms. Part I: Design Rationale. </title> <institution> Karlsruhe University, Faculty of Computer Science, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: Karla, which stands for the Karlsruhe Library of Data Structures and Algorithms, developed at the Faculty of Informatics (Karlsruhe University), also supports the concepts of containers and iterators <ref> [2, 4, 3] </ref>. This library was implemented by using Sather-K, which is "... a statically typed, type-safe variant of Sather." [2, 5]. <p> Karla, which stands for the Karlsruhe Library of Data Structures and Algorithms, developed at the Faculty of Informatics (Karlsruhe University), also supports the concepts of containers and iterators [2, 4, 3]. This library was implemented by using Sather-K, which is "... a statically typed, type-safe variant of Sather." <ref> [2, 5] </ref>.
Reference: [3] <author> A. Frick, W. Zimmer, and W. Zimmermann. </author> <booktitle> On the design of reliable libraries. In Tachnology of Object-Oriented Programming (TOOLS'17), </booktitle> <pages> pages 12-23. </pages> <publisher> Prentice-Hall, </publisher> <year> 1995. </year> <note> Available from http://i44www.info.uni-karlsruhe.de/ zimmer/karla/index.html. </note>
Reference-contexts: Karla, which stands for the Karlsruhe Library of Data Structures and Algorithms, developed at the Faculty of Informatics (Karlsruhe University), also supports the concepts of containers and iterators <ref> [2, 4, 3] </ref>. This library was implemented by using Sather-K, which is "... a statically typed, type-safe variant of Sather." [2, 5].
Reference: [4] <author> A. Frick and W. Zimmermann. Karla: </author> <title> An Extensible Library of Data Structures and Algorithms. Part II: Usage for Beginners. </title> <institution> Karlsruhe University, Faculty of Computer Science, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: Karla, which stands for the Karlsruhe Library of Data Structures and Algorithms, developed at the Faculty of Informatics (Karlsruhe University), also supports the concepts of containers and iterators <ref> [2, 4, 3] </ref>. This library was implemented by using Sather-K, which is "... a statically typed, type-safe variant of Sather." [2, 5].
Reference: [5] <author> G. Goos. Sather-k, </author> <title> the language. </title> <type> Technical report, </type> <institution> Karlsruhe University, </institution> <month> April </month> <year> 1996. </year>
Reference-contexts: Karla, which stands for the Karlsruhe Library of Data Structures and Algorithms, developed at the Faculty of Informatics (Karlsruhe University), also supports the concepts of containers and iterators [2, 4, 3]. This library was implemented by using Sather-K, which is "... a statically typed, type-safe variant of Sather." <ref> [2, 5] </ref>.
Reference: [6] <author> Silicon Graphics. </author> <title> Standard Template Library Programmer's Guide. </title> <note> URL http://www.sgi.com/Technology/STL, 1997. </note>
Reference-contexts: In this paper we describe two such approaches to complete traversals, both of which fit into the framework defined by the Standard Template Library, STL (part of the ANSI/ISO standard for C++ [1]). STL (see also <ref> [15, 11, 6] </ref>) provides a set of easily configurable software components of six major kinds: generic algorithms, containers, iterators, function objects, adaptors, and allocators. <p> Hashed associative containers are not part of the C++ standard but are now provided as an STL extension by at least one compiler vendor <ref> [6] </ref>. Another classification of associative containers is unique, in which objects in a container cannot have equivalent keys, versus multiple, in which they can. Still another classification is simple containers, in which only the keys are stored, versus pair containers, in which pairs of keys and associated values are kept.
Reference: [7] <author> G. Huet and D. Oppen. </author> <title> Equations and rewrite rules: a survey. </title> <editor> In R. Book, editor, </editor> <title> Formal Languages: Perspectives and Open Problems. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: Order Result h1; 4; 3i f1; 3; 4g h4; 1; 3; 2i f1; 2; 3; 4g Since we have cast the traversal successor relation as a rewriting relation, we can draw upon standard rewriting theory (e.g., <ref> [7, 12] </ref>) for deriving conditions for uniqueness of complete traversal results. Given an arbitrary rewriting relation !, the reflexive, transitive closure is denoted by ! * and is referred to as reduction. <p> This is called the "Diamond Lemma," because of the structure of its proof; see <ref> [7] </ref>. Applying this theory, we have: Theorem 2.2 If a traversal successor relation is uniformly terminating and locally confluent, then every complete traversal of a container C using a function F results in a unique final container. We say that the complete traversal computation is determinate.
Reference: [8] <author> B. Liskov and J. Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: &lt;< name &lt;< " "; name_association::const_iterator i = directory.find (name); if (i != directory.end () && (*i).second != string ("---")) c.insert ((*i).second); - typedef complete_container&lt;name_set&gt; cc_type; cc_type cc (invitees); name_function&lt;cc_type&gt; insert_boss (bosses); for (cc_type::iterator k = cc.begin (); k != cc.end (); ++k) insert_boss (*k, cc); 4 Related Work CLU <ref> [8] </ref> is one of the earliest contributions which offers language support for defining iterators as operations on programmer-defined container types. Since the programmer has total control over how iteration is defined, supporting complete traversal would be possible, perhaps by adapting one of the approaches discussed here. In [8], the authors mention <p> Related Work CLU <ref> [8] </ref> is one of the earliest contributions which offers language support for defining iterators as operations on programmer-defined container types. Since the programmer has total control over how iteration is defined, supporting complete traversal would be possible, perhaps by adapting one of the approaches discussed here. In [8], the authors mention the potential usefulness of such iterators but develop neither a formal definition nor any examples.
Reference: [9] <author> H. J. Messerschmidt. </author> <title> List iterators in C++. </title> <journal> Software|Practice and Experience, </journal> <volume> 26(11) </volume> <pages> 1197-1203, </pages> <year> 1996. </year>
Reference-contexts: In [8], the authors mention the potential usefulness of such iterators but develop neither a formal definition nor any examples. More recently, the work reported in <ref> [9] </ref> on list iterators in C++ covers issues associated with iterator integrity; i.e., problems which may arise when the object to which an iterator is pointing is deleted.
Reference: [10] <author> S. Murer, S. Omohundro, D. Stoutamire, and C. Szyperski. </author> <title> Iteration abstraction in sather. </title> <journal> ACM TOPLAS, </journal> <volume> 18(1) </volume> <pages> 1-15, </pages> <month> Jan. </month> <year> 1996. </year> <note> Available from http://www.icsi.berkeley.edu/ sather/. </note>
Reference-contexts: However, it does not appear that complete traversals are directly supported. The programming language Sather, which was designed and implemented at the International Computer Science Institute (UC-Berkeley), is object-oriented with "... parameterized classes, object-oriented dispatch (late binding), multiple inheritance, strong typing, and garbage collection" <ref> [10] </ref>, and supports containers and iterators. However they mention that their iterators "... will fail if the underlying data structure is modified." [10], which seems to imply that they do not tackle complete traversals automatically. <p> was designed and implemented at the International Computer Science Institute (UC-Berkeley), is object-oriented with "... parameterized classes, object-oriented dispatch (late binding), multiple inheritance, strong typing, and garbage collection" <ref> [10] </ref>, and supports containers and iterators. However they mention that their iterators "... will fail if the underlying data structure is modified." [10], which seems to imply that they do not tackle complete traversals automatically. Moreover, their suggestion to handle them is by trying to detect situations under which modifications to the container can happen while the iteration is in progress, which they mention could be problematic. <p> This library was implemented by using Sather-K, which is "... a statically typed, type-safe variant of Sather." [2, 5]. Sather-K iterators are called streams, which in <ref> [10] </ref> it is mentioned that are a generalization of Sather's iterators, however as far as we know this generalization does not address the issue of an iterator being able to handle modifications to their container (s) while the iteration is in progress. 5 Summary and Future Work We have defined the
Reference: [11] <author> D. R. Musser and A. Saini. </author> <title> STL Tutorial and Reference Guide. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: In this paper we describe two such approaches to complete traversals, both of which fit into the framework defined by the Standard Template Library, STL (part of the ANSI/ISO standard for C++ [1]). STL (see also <ref> [15, 11, 6] </ref>) provides a set of easily configurable software components of six major kinds: generic algorithms, containers, iterators, function objects, adaptors, and allocators.
Reference: [12] <author> David R. Musser. </author> <title> Automated theorem proving for analysis and synthesis of computations. </title> <editor> In G. Birtwistle and P. Subrahmanyam, editors, </editor> <title> Current Trends in Hardware Verification and Automated Theorem Proving. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Order Result h1; 4; 3i f1; 3; 4g h4; 1; 3; 2i f1; 2; 3; 4g Since we have cast the traversal successor relation as a rewriting relation, we can draw upon standard rewriting theory (e.g., <ref> [7, 12] </ref>) for deriving conditions for uniqueness of complete traversal results. Given an arbitrary rewriting relation !, the reflexive, transitive closure is denoted by ! * and is referred to as reduction.
Reference: [13] <author> ObjectSpace. </author> <title> Objectspace - JGL, the Generic Collection Library for Java. </title> <note> URL http://www.objectspace.com/jgl, 1997. </note>
Reference-contexts: Except for the case of such iterator invalidation, complete traversals of STL sequence containers can be trivially programmed. Another recent related work is the Java Generic Library (JGL) <ref> [13] </ref>, which is strongly based on the STL design. For instance, JGL supports the concept of containers and iterators. However, it does not appear that complete traversals are directly supported.
Reference: [14] <author> A. J. Sanchez-Ruiz. </author> <title> On Automatic Approaches to Multi-Language Programming via Code Reusability. </title> <type> Phd dissertation, </type> <institution> Computer Science Department, Rensselaer Polytechnic Institute, </institution> <address> Troy, NY, USA, </address> <year> 1995. </year>
Reference-contexts: The application problem and the definition of cts were taken from <ref> [14] </ref>. 6 3 Complete Traversals Implemented as STL Extensions In this section we present two different approaches to complete traversals, one using generic algorithms and the other a container adaptor.
Reference: [15] <author> A. A. Stepanov and M. Lee. </author> <title> The standard template library. </title> <type> Technical Report HP-94-93, </type> <institution> Hewlett-Packard, </institution> <year> 1995. </year> <month> 17 </month>
Reference-contexts: In this paper we describe two such approaches to complete traversals, both of which fit into the framework defined by the Standard Template Library, STL (part of the ANSI/ISO standard for C++ [1]). STL (see also <ref> [15, 11, 6] </ref>) provides a set of easily configurable software components of six major kinds: generic algorithms, containers, iterators, function objects, adaptors, and allocators.
References-found: 15

