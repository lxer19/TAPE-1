URL: ftp://mancos.cs.utah.edu/papers/reorder.ps.Z
Refering-URL: ftp://mancos.cs.utah.edu/papers/reorder.html
Root-URL: 
Title: DYNAMIC PROGRAM MONITORING AND TRANSFORMATION USING THE OMOS OBJECT SERVER  
Author: Douglas B. Orr, Robert W. Meck-lenburg, Peter J. Hoogenboom and Jay Lepreau 
Address: Salt Lake City, Utah 84112 USA  
Affiliation: Department of Computer Science University of Utah,  
Abstract: In traditional monolithic operating systems the constraints of working within the kernel have limited the sophistication of the schemes used to manage executable program images. By implementing an executable image loader as a persistent user-space program, we can extend system program loading capabilities. In this paper we present OMOS, an Object/Meta-Object Server which provides program loading facilities as a special case of generic object instantiation. We discuss the architecture of OMOS, the extensible nature of that architecture, and its transparent application to the problem of dynamic program monitoring and optimization, in particular, code reordering to improve locality of reference. We describe five reordering strategies, one using the static call graph and four based on analysis of the dynamic call graph. One large application was studied under varied amounts of available memory. The best dynamic strategy gave speed improvements ranging from 23 to 66%, while the static method gave speedups ranging from 19 to 52%. 1 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mike Accetta, Robert Baron, William Bolosky, David Golub, Richard Rashid, Avadis Tevanian, and Michael Young. </author> <title> Mach: A new kernel foundation for UNIX development. </title> <booktitle> In Proceedings of the Summer 1986 USENIX Conference, </booktitle> <pages> pages 93-112, </pages> <address> Atlanta, GA, June 9-13, 1986. </address> <publisher> Usenix Association. </publisher>
Reference-contexts: For example, given a meta-object for ls, OMOS can create an ls instance for a client. Instantiating an object subsumes linking and loading a program in a more traditional environment. OMOS is designed to support clients running on a variety of operating systems, including microkernels such as Mach <ref> [1] </ref> or Chorus [19], or traditional monolithic kernels that have remote mapping and IPC facilities. Meta-objects contain a specification, known as a blueprint, which includes the rules used to combine objects and other meta-objects to produce an instance of the meta-object.
Reference: [2] <editor> J.Y. Babonneau, M.S. Achard, G. Morisset, and M.B. Mounajjed. </editor> <title> Automatic and general solution to the adaptation of programs in a paging environment. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 109-116, </pages> <month> November </month> <year> 1971. </year>
Reference-contexts: Miller [4] uses the technique of binary wrapping to augment compiled procedure behavior, as OMOS does when generating monitored versions of programs. A variety of work has been done on the problem of automatically improving locality of reference within programs in overlay systems and early paging systems <ref> [5, 14, 10, 7, 2] </ref>. Some of this work concentrates on instruction reference locality; others concentrate on data reference locality. These systems tended to organise programs as a collection of segments, each of which occupied some fraction of a page. <p> These systems tended to organise programs as a collection of segments, each of which occupied some fraction of a page. Their work was based on reordering the segments to improve paging behavior. Hatfield [10] and Babonneau <ref> [2] </ref> used an adjacency matrix to record inter-sectional references. Inter-sectional references were signalled by page faults, whose frequency was thought to approximate that of inter-sectional references. The system developed by Babonneau, et. al. makes reordering and monitoring a standard part of the linking process.
Reference: [3] <author> Gilad Bracha and Gary Lindstrom. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proc. International Conference on Computer Languages, </booktitle> <pages> pages 282-290, </pages> <address> San Francisco, CA, </address> <month> April 20-23 </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal> <note> 22 Chapter 1 </note>
Reference-contexts: These rules map into a graph of construction operations, the m-graph, with each node representing one operation. Nodes in the m-graph define operations used to generate and modify objects. These operations consist of module operations as defined in Bracha and Lind-strom <ref> [3] </ref>. Conceptually, a module is a naming scope. Module operations operate on and modify the symbol bindings in modules; module operations take modules as input and generate modules as output.
Reference: [4] <author> J. Cargille and Miller B. P. </author> <title> Binary wrapping: A technique for instrumenting object code. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(6), </volume> <month> June </month> <year> 1992. </year>
Reference-contexts: Traditional techniques have often involved performing source to source translations, or modifying intermediate assembly code to insert the monitoring code. Laurus and Ball [13] use a technique of rewriting program executables and inserting monitoring code which is analogous to, but more ambitious than OMOS. Miller <ref> [4] </ref> uses the technique of binary wrapping to augment compiled procedure behavior, as OMOS does when generating monitored versions of programs.
Reference: [5] <author> L. W. Comeau. </author> <title> A study of the effect of user program optimization in a paging system. </title> <booktitle> In Proceedings of the ACM Symposium on Operating Systems Principles, </booktitle> <address> Gatlinburg, Tenn., </address> <month> October </month> <year> 1967. </year>
Reference-contexts: Miller [4] uses the technique of binary wrapping to augment compiled procedure behavior, as OMOS does when generating monitored versions of programs. A variety of work has been done on the problem of automatically improving locality of reference within programs in overlay systems and early paging systems <ref> [5, 14, 10, 7, 2] </ref>. Some of this work concentrates on instruction reference locality; others concentrate on data reference locality. These systems tended to organise programs as a collection of segments, each of which occupied some fraction of a page.
Reference: [6] <institution> Digital Equipment Corporation, Maynard, </institution> <address> MA. CHORD, CHORD2, </address> <year> 1993. </year>
Reference-contexts: By positioning segments to minimize the number of cases where an inter-segment reference would fall outside of the process working set, the number of page faults is reduced. More recent work focuses on the related problem of locality of reference within a cache <ref> [11, 6, 15] </ref>. McFarling [15] worked on reducing cache miss rates in direct-mapped caches. His algorithm allows a program to be restructured at the basic block level so that instructions that need to be in the cache at the same time are not mapped into the same cache line.
Reference: [7] <author> Domenico Ferrari. </author> <title> Improving locality by critical working sets. </title> <journal> Communications of the ACM, </journal> <volume> 17(1) </volume> <pages> 614-620, </pages> <month> November </month> <year> 1974. </year>
Reference-contexts: Clearly, these problems are not significant when using relatively small programs and small numbers of carefully designed libraries. The issue of locality of reference has been given attention in the past, when system memory sizes were small and penalties for non-local references were high <ref> [14, 10, 7] </ref>. Even though machine address space and main memory sizes have been growing, applications sizes have grown proportionally. <p> Miller [4] uses the technique of binary wrapping to augment compiled procedure behavior, as OMOS does when generating monitored versions of programs. A variety of work has been done on the problem of automatically improving locality of reference within programs in overlay systems and early paging systems <ref> [5, 14, 10, 7, 2] </ref>. Some of this work concentrates on instruction reference locality; others concentrate on data reference locality. These systems tended to organise programs as a collection of segments, each of which occupied some fraction of a page. <p> Hatfield [10] and Babonneau [2] used an adjacency matrix to record inter-sectional references. Inter-sectional references were signalled by page faults, whose frequency was thought to approximate that of inter-sectional references. The system developed by Babonneau, et. al. makes reordering and monitoring a standard part of the linking process. Ferrari <ref> [7] </ref> used critical working set analysis to obtain adjacency mappings. The intent of the critical working set analysis is to observe inter-segment fault patterns as functions of time, and not absolute values.
Reference: [8] <author> Susan L. Graham, Peter B. Kessler, and Marshall K. McKusick. </author> <title> An execution profiler for modular programs. </title> <journal> Software Practice and Experience, </journal> <volume> 13 </volume> <pages> 671-685, </pages> <year> 1983. </year>
Reference-contexts: This anomaly reinforces the need to investigate the use of code duplication for frequently used procedures. 8 RELATED WORK There is a large body of work related to monitoring program execution to derive optimization information <ref> [8, 12] </ref>. Traditional techniques have often involved performing source to source translations, or modifying intermediate assembly code to insert the monitoring code. Laurus and Ball [13] use a technique of rewriting program executables and inserting monitoring code which is analogous to, but more ambitious than OMOS.
Reference: [9] <author> S. J. </author> <title> Hartley. Compile-time program restructuring in multiprogrammed virtual memory systems. </title> <journal> IEEE Trans on Software Engineering, </journal> <volume> SE-14(11):1640-1644, </volume> <year> 1988. </year>
Reference-contexts: To solve this, we cluster a number of the most frequently referenced procedures in the program by selecting a percentage of the total number of procedures. These procedures would also be prime candidates for cloning <ref> [9] </ref>, which we intend to investigate as an enhancement in the future. The fourth dynamic strategy involves ordering the call chain by frequency of reference, rather than in a simple first-called, depth-first fashion. <p> McFarling studied a set of Program Monitoring Using OMOS 19 10 benchmark programs using a range of cache sizes from 128 to 16384 words. They determined that regardless of the cache size, their algorithm is as effective as tripling the cache size. Hartley <ref> [9] </ref> used procedure replication as a way to bound the locality of reference for a given point in the program.
Reference: [10] <author> D. J. Hatfield and J. Gerald. </author> <title> Program restructuring for virtual memory. </title> <journal> IBM Systems Journal, </journal> <volume> 10(3) </volume> <pages> 168-192, </pages> <year> 1971. </year>
Reference-contexts: Clearly, these problems are not significant when using relatively small programs and small numbers of carefully designed libraries. The issue of locality of reference has been given attention in the past, when system memory sizes were small and penalties for non-local references were high <ref> [14, 10, 7] </ref>. Even though machine address space and main memory sizes have been growing, applications sizes have grown proportionally. <p> Miller [4] uses the technique of binary wrapping to augment compiled procedure behavior, as OMOS does when generating monitored versions of programs. A variety of work has been done on the problem of automatically improving locality of reference within programs in overlay systems and early paging systems <ref> [5, 14, 10, 7, 2] </ref>. Some of this work concentrates on instruction reference locality; others concentrate on data reference locality. These systems tended to organise programs as a collection of segments, each of which occupied some fraction of a page. <p> Some of this work concentrates on instruction reference locality; others concentrate on data reference locality. These systems tended to organise programs as a collection of segments, each of which occupied some fraction of a page. Their work was based on reordering the segments to improve paging behavior. Hatfield <ref> [10] </ref> and Babonneau [2] used an adjacency matrix to record inter-sectional references. Inter-sectional references were signalled by page faults, whose frequency was thought to approximate that of inter-sectional references. The system developed by Babonneau, et. al. makes reordering and monitoring a standard part of the linking process.
Reference: [11] <author> J. L. Hennessy and Thomas R. Gross. </author> <title> Postpass code optimization of pipeline constraints. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3):342, </volume> <month> July </month> <year> 1983. </year>
Reference-contexts: By positioning segments to minimize the number of cases where an inter-segment reference would fall outside of the process working set, the number of page faults is reduced. More recent work focuses on the related problem of locality of reference within a cache <ref> [11, 6, 15] </ref>. McFarling [15] worked on reducing cache miss rates in direct-mapped caches. His algorithm allows a program to be restructured at the basic block level so that instructions that need to be in the cache at the same time are not mapped into the same cache line. <p> The extensible nature of OMOS, and its knowledge of everything from source file to execution traces, make it applicable to other kinds of optimizations requiring run-time data. OMOS could transparently implement the type of monitoring done by MIPS' pixie system, to optimize branch prediction <ref> [11] </ref>. Another direction is suggested by OMOS' natural connection with program development. OMOS could easily be used as the basis of a CASE tool, where its ability to feed back data from program execution, would be useful for both debugging and optimization.
Reference: [12] <author> Amir Kishon, Paul Hudak, and Charles Counsel. </author> <title> Monitoring semantics: A formal framework for specifying, implementing, and reasoning about execution monitors. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 338-352, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: This anomaly reinforces the need to investigate the use of code duplication for frequently used procedures. 8 RELATED WORK There is a large body of work related to monitoring program execution to derive optimization information <ref> [8, 12] </ref>. Traditional techniques have often involved performing source to source translations, or modifying intermediate assembly code to insert the monitoring code. Laurus and Ball [13] use a technique of rewriting program executables and inserting monitoring code which is analogous to, but more ambitious than OMOS.
Reference: [13] <author> James R. Laurus and Thomas Ball. </author> <title> Rewriting executable files to measure program behavior. </title> <type> Technical Report Technical Report 1083, </type> <institution> The University of Wisconsin, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Traditional techniques have often involved performing source to source translations, or modifying intermediate assembly code to insert the monitoring code. Laurus and Ball <ref> [13] </ref> use a technique of rewriting program executables and inserting monitoring code which is analogous to, but more ambitious than OMOS. Miller [4] uses the technique of binary wrapping to augment compiled procedure behavior, as OMOS does when generating monitored versions of programs.
Reference: [14] <author> T. C. Lowe. </author> <title> Automatic segmentation of cyclic program structures based on connectivity and processor timing. </title> <journal> Communications of the ACM, </journal> <volume> 13(1) </volume> <pages> 3-9, </pages> <month> January </month> <year> 1970. </year>
Reference-contexts: Clearly, these problems are not significant when using relatively small programs and small numbers of carefully designed libraries. The issue of locality of reference has been given attention in the past, when system memory sizes were small and penalties for non-local references were high <ref> [14, 10, 7] </ref>. Even though machine address space and main memory sizes have been growing, applications sizes have grown proportionally. <p> Miller [4] uses the technique of binary wrapping to augment compiled procedure behavior, as OMOS does when generating monitored versions of programs. A variety of work has been done on the problem of automatically improving locality of reference within programs in overlay systems and early paging systems <ref> [5, 14, 10, 7, 2] </ref>. Some of this work concentrates on instruction reference locality; others concentrate on data reference locality. These systems tended to organise programs as a collection of segments, each of which occupied some fraction of a page.
Reference: [15] <author> Scott McFarling. </author> <title> Program optimization for instruction caches. </title> <booktitle> In Third International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 183-191, </pages> <month> April </month> <year> 1989. </year> <title> Program Monitoring Using OMOS 23 </title>
Reference-contexts: By positioning segments to minimize the number of cases where an inter-segment reference would fall outside of the process working set, the number of page faults is reduced. More recent work focuses on the related problem of locality of reference within a cache <ref> [11, 6, 15] </ref>. McFarling [15] worked on reducing cache miss rates in direct-mapped caches. His algorithm allows a program to be restructured at the basic block level so that instructions that need to be in the cache at the same time are not mapped into the same cache line. <p> By positioning segments to minimize the number of cases where an inter-segment reference would fall outside of the process working set, the number of page faults is reduced. More recent work focuses on the related problem of locality of reference within a cache [11, 6, 15]. McFarling <ref> [15] </ref> worked on reducing cache miss rates in direct-mapped caches. His algorithm allows a program to be restructured at the basic block level so that instructions that need to be in the cache at the same time are not mapped into the same cache line.
Reference: [16] <author> D. Orr and R. Mecklenburg. </author> <title> OMOS | an object server for program execution. </title> <booktitle> In Proc. Second International Workshop on Object Orientation in Operating Systems, </booktitle> <address> Paris, France, </address> <month> September </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: Currently the specification language used by OMOS has a simple Lisp-like syntax. M-graphs are composed of nodes which are graph operators, meta-objects and fragments. The complete set of graph operators defined in OMOS is described in <ref> [16] </ref>. The graph operators important to this discussion include: 8 Chapter 1 Merge: binds the symbol definitions found in one operand to the references found in another. Multiple definitions of a symbol constitutes an error.
Reference: [17] <author> K. Pettis and R. C. Hansen. </author> <title> Profile guided code positioning. </title> <journal> SIGPLAN Notices, </journal> <volume> 25(6) </volume> <pages> 16-27, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: They determined that regardless of the cache size, their algorithm is as effective as tripling the cache size. Hartley [9] used procedure replication as a way to bound the locality of reference for a given point in the program. Pettis and Hansen <ref> [17] </ref> did work both to improve ordering of procedures and ordering of basic blocks; they concentrated more heavily on reordering basic blocks and used a single, straightforward algorithm for ordering procedures.
Reference: [18] <author> D. M. Ritchie and K. Thompson. </author> <title> The UNIX time-sharing system. </title> <journal> The Bell System Technical Journal, </journal> <volume> 57(6) </volume> <pages> 1905-1930, </pages> <month> July/August </month> <year> 1978. </year>
Reference-contexts: 1 INTRODUCTION Traditional program linking and loading facilities, like those found in Unix <ref> [18] </ref>, have simple semantics. They were developed in a time of small address spaces and small applications, often with the goal of minimizing linking time and use of kernel resources. These linkers and loaders tend to use simple external structures | executable files, libraries, etc. | to reduce kernel complexity.
Reference: [19] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> The Chorus distributed operating system. </title> <journal> Computing Systems, </journal> <volume> 1(4) </volume> <pages> 287-338, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Instantiating an object subsumes linking and loading a program in a more traditional environment. OMOS is designed to support clients running on a variety of operating systems, including microkernels such as Mach [1] or Chorus <ref> [19] </ref>, or traditional monolithic kernels that have remote mapping and IPC facilities. Meta-objects contain a specification, known as a blueprint, which includes the rules used to combine objects and other meta-objects to produce an instance of the meta-object.
References-found: 19

