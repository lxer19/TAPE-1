URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-94-6-1.ps.Z
Refering-URL: http://www.cs.man.ac.uk/cstechrep/Abstracts/UMCS-94-6-1.html
Root-URL: http://www.cs.man.ac.uk
Title: MathPIP: A Mathematica Interface for PIP User's Guide and Reference Manual  
Author: Zbigniew Chamski 
Date: 94-6-1  
Affiliation: Computer Science University of Manchester  
Pubnum: Technical Report  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Z. Chamski. </author> <title> Environnement logiciel de programmation d'un accelerateur de calcul parallele. </title> <type> PhD thesis, </type> <institution> Universite de Rennes I, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Applications of PIP include problems such as exact dependence testing and polyhedra scanning problems (taken in a broad sense: determination of accessed areas in arrays, generation of loop bounds etc.) The interested reader can consult <ref> [6, 7, 8, 9, 1, 5, 2, 3] </ref> for further information on the algorithm and its applications. The detailed description of the algorithm and the proofs of its properties can be found in [6] and [5]. <p> The detailed description of the algorithm and the proofs of its properties can be found in [6] and [5]. References [7] and [8] (in French) provide information on translating real-life problems into PIP input. Loop generation techniques based on PIP are discussed in <ref> [7, 1, 5, 2, 3] </ref>. In addition, [2] contains a performance comparison between MultiPIP 2 and an implementation of the Fourier-Motzkin pairwise elimination in the context of bound generation. 3 User's guide NB: in the following, we assume that the reader is familiar with Mathematica and PIP. <p> Function 'minToMaxPb' implements the conversion mechanism proposed in [8], returning a minimization problem. E.g., the conversion of the problem problem [1, 1, -1, True, --1,-4,1-,-1,2,-1-, --1,8,-1-,--1,2,1--, to the maximization form returns problem <ref> [1, 2, 4, True, ---1,-4,1,1-,--1,2,-1,1-, --1,0,-1-,--1,0,5--] </ref> corresponding to lexmin 1p 1 5 (big x 1 ) + p 1 8 0; (big x 1 ) p 1 2 0g); where big stands for the unconstrained "big parameter" of [8]. <p> This will start a default PIP server and bind its identification (a Mathematica LinkObject) to the symbol 'defaultPip'. If the binary can not be found, Mathematica will issue an error message of the form sh: mathpip: Permission denied LinkConnect::linkc: LinkObject <ref> [mathpip, 4, 1] </ref> is dead; attempt to connect failed. Test the operation of the interface on the examples from previous section. When correct, add "Pip.m" to your package hierarchy and add the line Needs ["Pip`"] to your $HOME/init.m file.
Reference: [2] <author> Z. Chamski. </author> <title> Fast and efficient generation of loop bounds. </title> <editor> In D. Trystram, editor, </editor> <address> ParCo '93, Grenoble, France, </address> <month> September </month> <year> 1993. </year> <institution> Elsevier Science Publishers (North Holland). </institution> <note> To appear. Available as Inria Research Report 2095, </note> <institution> Inria, Rocquencourt, France, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: Applications of PIP include problems such as exact dependence testing and polyhedra scanning problems (taken in a broad sense: determination of accessed areas in arrays, generation of loop bounds etc.) The interested reader can consult <ref> [6, 7, 8, 9, 1, 5, 2, 3] </ref> for further information on the algorithm and its applications. The detailed description of the algorithm and the proofs of its properties can be found in [6] and [5]. <p> The detailed description of the algorithm and the proofs of its properties can be found in [6] and [5]. References [7] and [8] (in French) provide information on translating real-life problems into PIP input. Loop generation techniques based on PIP are discussed in <ref> [7, 1, 5, 2, 3] </ref>. In addition, [2] contains a performance comparison between MultiPIP 2 and an implementation of the Fourier-Motzkin pairwise elimination in the context of bound generation. 3 User's guide NB: in the following, we assume that the reader is familiar with Mathematica and PIP. <p> References [7] and [8] (in French) provide information on translating real-life problems into PIP input. Loop generation techniques based on PIP are discussed in [7, 1, 5, 2, 3]. In addition, <ref> [2] </ref> contains a performance comparison between MultiPIP 2 and an implementation of the Fourier-Motzkin pairwise elimination in the context of bound generation. 3 User's guide NB: in the following, we assume that the reader is familiar with Mathematica and PIP. <p> Function 'minToMaxPb' implements the conversion mechanism proposed in [8], returning a minimization problem. E.g., the conversion of the problem problem [1, 1, -1, True, --1,-4,1-,-1,2,-1-, --1,8,-1-,--1,2,1--, to the maximization form returns problem <ref> [1, 2, 4, True, ---1,-4,1,1-,--1,2,-1,1-, --1,0,-1-,--1,0,5--] </ref> corresponding to lexmin 1p 1 5 (big x 1 ) + p 1 8 0; (big x 1 ) p 1 2 0g); where big stands for the unconstrained "big parameter" of [8].
Reference: [3] <author> Z. Chamski. </author> <title> Nested loop sequences: Towards efficient loop structures in automatic parallelization. </title> <booktitle> In 27 th Hawaii International Conference on System Sciences, volume II: Software Technology, </booktitle> <pages> pages 14-22, </pages> <year> 1994. </year> <month> 18 </month>
Reference-contexts: Applications of PIP include problems such as exact dependence testing and polyhedra scanning problems (taken in a broad sense: determination of accessed areas in arrays, generation of loop bounds etc.) The interested reader can consult <ref> [6, 7, 8, 9, 1, 5, 2, 3] </ref> for further information on the algorithm and its applications. The detailed description of the algorithm and the proofs of its properties can be found in [6] and [5]. <p> The detailed description of the algorithm and the proofs of its properties can be found in [6] and [5]. References [7] and [8] (in French) provide information on translating real-life problems into PIP input. Loop generation techniques based on PIP are discussed in <ref> [7, 1, 5, 2, 3] </ref>. In addition, [2] contains a performance comparison between MultiPIP 2 and an implementation of the Fourier-Motzkin pairwise elimination in the context of bound generation. 3 User's guide NB: in the following, we assume that the reader is familiar with Mathematica and PIP.
Reference: [4] <author> N.V. Chernikova. </author> <title> Algorithm for finding a general formula for the non-negative so-lutions of a system of linear equations. </title> <journal> USSR Computational Mathematics and Mathematical Physics, </journal> <volume> 4(4) </volume> <pages> 151-158, </pages> <year> 1964. </year>
Reference-contexts: Function 'minToMaxPb' implements the conversion mechanism proposed in [8], returning a minimization problem. E.g., the conversion of the problem problem [1, 1, -1, True, --1,-4,1-,-1,2,-1-, --1,8,-1-,--1,2,1--, to the maximization form returns problem <ref> [1, 2, 4, True, ---1,-4,1,1-,--1,2,-1,1-, --1,0,-1-,--1,0,5--] </ref> corresponding to lexmin 1p 1 5 (big x 1 ) + p 1 8 0; (big x 1 ) p 1 2 0g); where big stands for the unconstrained "big parameter" of [8]. <p> This will start a default PIP server and bind its identification (a Mathematica LinkObject) to the symbol 'defaultPip'. If the binary can not be found, Mathematica will issue an error message of the form sh: mathpip: Permission denied LinkConnect::linkc: LinkObject <ref> [mathpip, 4, 1] </ref> is dead; attempt to connect failed. Test the operation of the interface on the examples from previous section. When correct, add "Pip.m" to your package hierarchy and add the line Needs ["Pip`"] to your $HOME/init.m file.
Reference: [5] <author> J.-F. Collard, P. Feautrier, and T. Risset. </author> <title> Construction of DO loops from systems of affine constraints. </title> <type> Research Report 93-15, </type> <institution> Ecole Normale Superieure de Lyon, Lyon, France, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: Applications of PIP include problems such as exact dependence testing and polyhedra scanning problems (taken in a broad sense: determination of accessed areas in arrays, generation of loop bounds etc.) The interested reader can consult <ref> [6, 7, 8, 9, 1, 5, 2, 3] </ref> for further information on the algorithm and its applications. The detailed description of the algorithm and the proofs of its properties can be found in [6] and [5]. <p> The detailed description of the algorithm and the proofs of its properties can be found in [6] and <ref> [5] </ref>. References [7] and [8] (in French) provide information on translating real-life problems into PIP input. Loop generation techniques based on PIP are discussed in [7, 1, 5, 2, 3]. <p> The detailed description of the algorithm and the proofs of its properties can be found in [6] and [5]. References [7] and [8] (in French) provide information on translating real-life problems into PIP input. Loop generation techniques based on PIP are discussed in <ref> [7, 1, 5, 2, 3] </ref>. In addition, [2] contains a performance comparison between MultiPIP 2 and an implementation of the Fourier-Motzkin pairwise elimination in the context of bound generation. 3 User's guide NB: in the following, we assume that the reader is familiar with Mathematica and PIP.
Reference: [6] <author> P. Feautrier. </author> <title> Parametric integer programming. </title> <journal> Recherche Operationnelle / Operations Research, </journal> <volume> 22(3) </volume> <pages> 243-268, </pages> <year> 1988. </year>
Reference-contexts: Applications of PIP include problems such as exact dependence testing and polyhedra scanning problems (taken in a broad sense: determination of accessed areas in arrays, generation of loop bounds etc.) The interested reader can consult <ref> [6, 7, 8, 9, 1, 5, 2, 3] </ref> for further information on the algorithm and its applications. The detailed description of the algorithm and the proofs of its properties can be found in [6] and [5]. <p> The detailed description of the algorithm and the proofs of its properties can be found in <ref> [6] </ref> and [5]. References [7] and [8] (in French) provide information on translating real-life problems into PIP input. Loop generation techniques based on PIP are discussed in [7, 1, 5, 2, 3].
Reference: [7] <author> P. Feautrier. </author> <title> Semantical analysis and mathematical programming. Application to parallelization and vectorization. </title> <editor> In M. Cosnard et al., editors, </editor> <booktitle> Parallel and Distributed Algorithms, </booktitle> <pages> pages 309-320. </pages> <publisher> Elsevier Science Publishers B. V. (North-Holland), </publisher> <year> 1989. </year>
Reference-contexts: Applications of PIP include problems such as exact dependence testing and polyhedra scanning problems (taken in a broad sense: determination of accessed areas in arrays, generation of loop bounds etc.) The interested reader can consult <ref> [6, 7, 8, 9, 1, 5, 2, 3] </ref> for further information on the algorithm and its applications. The detailed description of the algorithm and the proofs of its properties can be found in [6] and [5]. <p> The detailed description of the algorithm and the proofs of its properties can be found in [6] and [5]. References <ref> [7] </ref> and [8] (in French) provide information on translating real-life problems into PIP input. Loop generation techniques based on PIP are discussed in [7, 1, 5, 2, 3]. <p> The detailed description of the algorithm and the proofs of its properties can be found in [6] and [5]. References [7] and [8] (in French) provide information on translating real-life problems into PIP input. Loop generation techniques based on PIP are discussed in <ref> [7, 1, 5, 2, 3] </ref>. In addition, [2] contains a performance comparison between MultiPIP 2 and an implementation of the Fourier-Motzkin pairwise elimination in the context of bound generation. 3 User's guide NB: in the following, we assume that the reader is familiar with Mathematica and PIP.
Reference: [8] <author> P. Feautrier and N. Tawbi. </author> <title> Resolution de systemes d'inequations lineaires ; mode d'emploi du logiciel PIP. </title> <type> Technical Report 90.2, </type> <institution> Laboratoire MASI, Univ. Pierre et Marie Curie, Paris, France, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: Applications of PIP include problems such as exact dependence testing and polyhedra scanning problems (taken in a broad sense: determination of accessed areas in arrays, generation of loop bounds etc.) The interested reader can consult <ref> [6, 7, 8, 9, 1, 5, 2, 3] </ref> for further information on the algorithm and its applications. The detailed description of the algorithm and the proofs of its properties can be found in [6] and [5]. <p> The detailed description of the algorithm and the proofs of its properties can be found in [6] and [5]. References [7] and <ref> [8] </ref> (in French) provide information on translating real-life problems into PIP input. Loop generation techniques based on PIP are discussed in [7, 1, 5, 2, 3]. <p> Function 'minToMaxPb' implements the conversion mechanism proposed in <ref> [8] </ref>, returning a minimization problem. <p> [1, 1, -1, True, --1,-4,1-,-1,2,-1-, --1,8,-1-,--1,2,1--, to the maximization form returns problem [1, 2, 4, True, ---1,-4,1,1-,--1,2,-1,1-, --1,0,-1-,--1,0,5--] corresponding to lexmin 1p 1 5 (big x 1 ) + p 1 8 0; (big x 1 ) p 1 2 0g); where big stands for the unconstrained "big parameter" of <ref> [8] </ref>.
Reference: [9] <author> P. Feautrier and M. R. Werth. </author> <title> Systematic construction of programs for distributed memory computers. </title> <type> Technical Report 91.36, </type> <institution> Laboratoire MASI, Univ. Pierre et Marie Curie, Paris, France, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: Applications of PIP include problems such as exact dependence testing and polyhedra scanning problems (taken in a broad sense: determination of accessed areas in arrays, generation of loop bounds etc.) The interested reader can consult <ref> [6, 7, 8, 9, 1, 5, 2, 3] </ref> for further information on the algorithm and its applications. The detailed description of the algorithm and the proofs of its properties can be found in [6] and [5].
Reference: [10] <author> T. Granlund. </author> <title> GNU MP: The GNU multiple precision arithmetic library. Reference manual, Free Software Foundation, </title> <publisher> Inc., </publisher> <month> December </month> <year> 1991. </year>
Reference: [11] <author> H. Le Verge. </author> <title> A note on Chernikova's algorithm. </title> <note> Publication interne 635, </note> <institution> Irisa, Rennes, France, </institution> <month> February </month> <year> 1992. </year>
Reference: [12] <author> Ch. Mauras. </author> <title> Alpha : un langage equationnel pour la conception et la programmation d'architectures paralleles synchrones. </title> <type> PhD thesis, </type> <institution> Univ. Rennes I, Rennes, France, </institution> <month> December </month> <year> 1989. </year>
Reference: [13] <author> Wolfram Research. </author> <title> MathLink reference guide. </title> <type> Technical Report 12/92, </type> <institution> Wolfram Research, Inc., </institution> <year> 1992. </year>
Reference: [14] <author> A. Schrijver. </author> <title> Theory of Linear and Integer Programming. Wiley Interscience Series in Discrete Mathematics. </title> <publisher> John Wiley and Sons, </publisher> <year> 1986. </year>
Reference-contexts: Example: In <ref> [14] </ref>:= send [pb4min] In [15]:= receive [] Out [15]= if [--1, 0, 0, 0, 3-, if [-0, -1, 0, 0, 3-, if [--400, 0, 0, 0, 1-, if [-0, -500, 0, 0, 1-, .... etc ....

References-found: 14

