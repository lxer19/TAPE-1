URL: http://www.pmg.lcs.mit.edu/papers/mobile-refs.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/areas/gc.html
Root-URL: 
Title: References to Remote Mobile Objects in Thor  
Author: Mark Day Barbara Liskov Umesh Maheshwari Andrew C. Myers 
Date: Abstract  
Address: Cambridge, MA 02139 USA  
Affiliation: Massachusetts Institute of Technology  
Abstract: Thor is a distributed object-oriented database where objects are stored persistently at highly-available servers called object repositories, or ORs. In a large Thor system, performance tuning and system reconfiguration dictate that objects must be able to migrate among ORs. The paper describes two schemes for object references that support object migration, one using location-independent names and the other, location-dependent names. The paper analyzes the performance of the two schemes and concludes that location-dependent names are the right choice for systems like Thor, where we want fast access to objects that have migrated. Categories and Subject Descriptors: H.2.4 [Database Management]: Systems: Distributed systems; C.2.4 [Computer-Communication networks]: Distributed Systems | Distributed databases; D.4.7 [Operating Systems]: Organization and Design | Distributed systems; E.2 [Data Storage Representations]: Linked representations; H.2.2 [Database Management]: Physical Design; General Terms: Design Additional Key Words and Phrases: addressing, distributed object management, distributed object-oriented database, location-dependent reference, location-independent reference, naming, object migration, object mobility, object reference, scalability. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Carey, M. J., DeWitt, D. J., and Naughton, J. F. </author> <title> The OO7 benchmark. </title> <booktitle> In Proceedings of the 1993 ACM SIGMOD (Washington, </booktitle> <address> DC, </address> <month> May </month> <year> 1993), </year> <pages> pp. 12-21. </pages>
Reference-contexts: Its state contains data such as integers, booleans, and characters and also references to other objects; we estimate that the average object is on the order of 70 bytes and contains 5 references to other objects (similar to <ref> [1, 13, 14] </ref>). The size of an object can vary over its lifetime. Although the Thor universe appears to clients as a single entity, it is distributed across servers called object repositories, or ORs, each of which stores some subset of the persistent objects.
Reference: [2] <author> Carson, S., and Setia, S. </author> <title> Optimal write batch size in log-structured file systems. </title> <booktitle> In Proceedings of the 1992 Usenix File Systems Workshop (1992), </booktitle> <pages> pp. 79-91. </pages>
Reference-contexts: Since we want to read the segment as a unit, it should not be too big; a size of about 64K bytes seems likely to use disk throughput effectively <ref> [2] </ref>. (The limit on segment size means that storing large objects requires another scheme, which is not discussed in this paper.) If objects average around 70 bytes, a segment can hold about 900 objects. The segment table is reasonably small.
Reference: [3] <author> Fowler, R. J. </author> <title> Decentralized object finding using forwarding addresses. </title> <type> Tech. Rep. </type> <institution> 85-12-1, Department of Computer Science, University of Washington, </institution> <month> December </month> <year> 1985. </year> <month> 10 </month>
Reference-contexts: Propagation of the new xref means that surrogates and location table entries are eventually unneeded. The garbage collector can recognize this and discard surrogates and table entries. Our use of forwarding addresses is similar to Fowler's work <ref> [3, 7] </ref>. Frequently-moved objects may generate chains of surrogates. In Fowler's scheme, clients perform path compression by sending updates to members of a chain of forwarding addresses. In Thor, path compression is performed by the ORs instead. 4.3.2 Xrefs vs.
Reference: [4] <author> Gray, J., and Reuter, A. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1993. </year>
Reference-contexts: For each client program, there is a front end, or FE, running on the client's machine. The FE provides an interface for the client to access Thor. To ensure consistency despite failures and concurrency, client calls take place within an atomic transaction <ref> [4] </ref>; the client program indicates when the current transaction should attempt to commit. Client programs never obtain direct pointers to objects; instead, an FE issues handles. Handles can be used to identify objects in subsequent clients calls but are local to that client session.
Reference: [5] <author> Hornick, M. F., and Zdonik, S. B. </author> <title> A shared, segmented memory system for an objectoriented database. </title> <journal> ACM Transactions on Office Information Systems 5, </journal> <month> 1 (January </month> <year> 1987), </year> <pages> 70-95. </pages>
Reference-contexts: They can then be prefetched and returned to the FE in the same message as the fetched object. An OR stores objects in segments. A segment is stored in a contiguous region of memory and is read and written to disk as a unit <ref> [5] </ref>. It contains a group of objects that are related to one another, i.e., objects are clustered in segments. An oref is structured so that an OR can efficiently find the corresponding object. The oref is divided into a segment id and an object number.
Reference: [6] <author> Hwang, D. J.-H. </author> <title> Constructing a highly-available location service for a distributed envi-ronment. </title> <type> Tech. Rep. </type> <institution> MIT/LCS/TR-410, MIT Laboratory for Computer Science, </institution> <month> January </month> <year> 1988. </year>
Reference-contexts: R* sites were not highly available, so the crash of a locator could make an migrated object unavailable even though the object's site was available. This problem does not exist in Thor because ORs are highly available. 3 Mechanisms for implementing such highly-available services are described in <ref> [6] </ref> and [9]. 6 unless the hint is usually accurate. This can be accomplished with the tracking mechanism described in Section 4.3.1. Using the birth site as the locator seems preferable to using the name service because it is simpler and has at least as good performance.
Reference: [7] <author> Jul, E., Levy, H., Hutchinson, N., and Black, A. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Transactions on Computer Systems 6, </journal> <month> 1 (February </month> <year> 1988), </year> <pages> 109-133. </pages>
Reference-contexts: Propagation of the new xref means that surrogates and location table entries are eventually unneeded. The garbage collector can recognize this and discard surrogates and table entries. Our use of forwarding addresses is similar to Fowler's work <ref> [3, 7] </ref>. Frequently-moved objects may generate chains of surrogates. In Fowler's scheme, clients perform path compression by sending updates to members of a chain of forwarding addresses. In Thor, path compression is performed by the ORs instead. 4.3.2 Xrefs vs.
Reference: [8] <author> Kaehler, T., and Krasner, G. </author> <title> LOOM Large object-oriented memory for Smalltalk80 systems. In Readings in Object-Oriented Database Systems, </title> <editor> S. B. Zdonik and D. Maier, Eds. </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1990, </year> <pages> pp. 298-307. </pages>
Reference-contexts: The object's previous storage at the old OR is turned into a surrogate that contains its new xref. (Surrogates are like forwarders in Mneme [13] and leaves in LOOM <ref> [8] </ref>.) Thus, instead of a predefined locator OR, the OR that last held an object has up-to-date information about its location. The information about the new xref for a moved object is propagated (in a manner discussed below) to objects that refer to it.
Reference: [9] <author> Ladin, R., Liskov, B., Shrira, L., and Ghemawat, S. </author> <title> Lazy replication: Exploiting the semantics of distributed services. </title> <type> Tech. Rep. </type> <institution> MIT/LCS/TR-484, MIT Laboratory for Computer Science, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: R* sites were not highly available, so the crash of a locator could make an migrated object unavailable even though the object's site was available. This problem does not exist in Thor because ORs are highly available. 3 Mechanisms for implementing such highly-available services are described in [6] and <ref> [9] </ref>. 6 unless the hint is usually accurate. This can be accomplished with the tracking mechanism described in Section 4.3.1. Using the birth site as the locator seems preferable to using the name service because it is simpler and has at least as good performance.
Reference: [10] <author> Lindsay, B. </author> <title> Object naming and catalog management for a distributed database manager. </title> <booktitle> In Proceedings of the 2nd International Conference on Distributed Computing Systems (Paris, </booktitle> <year> 1981), </year> <pages> pp. 31-40. </pages>
Reference: [11] <author> Liskov, B., Day, M., and Shrira, L. </author> <title> Distributed object management in Thor. In Distributed Object Management, </title> <editor> M. T. Ozsu, U. Dayal, and P. Valduriez, Eds. </editor> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1993. </year>
Reference-contexts: The schemes were de-veloped within the context of the Thor object-oriented database system <ref> [11] </ref>, but the results are applicable to other distributed object systems. We begin in Section 2 with a brief overview of the architecture of Thor. Section 3 discusses the requirements for object references. Section 4 describes the schemes for implementing object references.
Reference: [12] <author> Maheshwari, U. </author> <title> Distributed garbage collection in a client-server, transactional, persis-tent object system. </title> <type> Tech. Rep. </type> <institution> MIT/LCS/TR-574, Massachusetts Institute of Technology, </institution> <year> 1993. </year>
Reference-contexts: Thor provides a persistent root for the object universe. An object becomes persistent when it becomes reachable from the persistent root. If an object becomes unreachable from the root, its storage is reclaimed by a distributed garbage collector <ref> [12] </ref>. Client programs run at client workstations that are typically distinct from the servers that run ORs. For each client program, there is a front end, or FE, running on the client's machine. The FE provides an interface for the client to access Thor.
Reference: [13] <author> Moss, J. E. B. </author> <title> Design of the Mneme persistent object store. </title> <journal> ACM Transactions on Information Systems 8, </journal> <month> 2 (April </month> <year> 1990), </year> <pages> 103-139. </pages>
Reference-contexts: Its state contains data such as integers, booleans, and characters and also references to other objects; we estimate that the average object is on the order of 70 bytes and contains 5 references to other objects (similar to <ref> [1, 13, 14] </ref>). The size of an object can vary over its lifetime. Although the Thor universe appears to clients as a single entity, it is distributed across servers called object repositories, or ORs, each of which stores some subset of the persistent objects. <p> We begin by assuming that objects don't move and describe an efficient way of implementing references; our technique is somewhat like that in Mneme <ref> [13] </ref>. Then we discuss how to handle mobile objects. The two approaches differ in whether an object's name changes when it moves. 4.1 The Basic Scheme When an object becomes persistent, an OR is selected for it. <p> When an object moves, its new OR places it in a local segment that contains related objects and then gives it a new, local xref. The object's previous storage at the old OR is turned into a surrogate that contains its new xref. (Surrogates are like forwarders in Mneme <ref> [13] </ref> and leaves in LOOM [8].) Thus, instead of a predefined locator OR, the OR that last held an object has up-to-date information about its location. The information about the new xref for a moved object is propagated (in a manner discussed below) to objects that refer to it.
Reference: [14] <author> Stamos, J. W. </author> <title> A large object-oriented virtual memory: Grouping strategies, measure-ments, and performance. </title> <type> Tech. Rep. SCG-82-2, </type> <note> Xerox PARC, </note> <month> May </month> <year> 1982. </year> <month> 11 </month>
Reference-contexts: Its state contains data such as integers, booleans, and characters and also references to other objects; we estimate that the average object is on the order of 70 bytes and contains 5 references to other objects (similar to <ref> [1, 13, 14] </ref>). The size of an object can vary over its lifetime. Although the Thor universe appears to clients as a single entity, it is distributed across servers called object repositories, or ORs, each of which stores some subset of the persistent objects.
References-found: 14

