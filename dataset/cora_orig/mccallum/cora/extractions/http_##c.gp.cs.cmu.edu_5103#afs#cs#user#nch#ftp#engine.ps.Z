URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/nch/ftp/engine.ps.Z
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/nch/www/sba.html
Root-URL: http://www.cs.cmu.edu
Email: nch@cs.cmu.edu joxan@watson.ibm.com  
Title: An Engine for Logic Program Analysis  
Author: Nevin Heintze Joxan Jaffar 
Address: PO Box 740 Pittsburgh, PA 15213-3890 Yorktown Heights, NY 10598  
Affiliation: School of Computer Science IBM T.J. Watson Research Center Carnegie Mellon University  
Abstract: Most logic program analyzers employ a standard approach based on abstract interpretation. At the core of these is a generic algorithm or "engine" which is parameterized by an abstract domain. This standard engine is essentially a fixpoint computation over the abstract semantic equations of a program. This paper presents a new engine which is based on unfolding of semantic equations. A main advantage of the unfolding engine is a uniform treatment of structural information in a program. In particular, reasoning about partially instantiated structures, an area where traditional algorithms have been weak, is greatly enhanced. The main result of this paper shows that our engine is uniformly more accurate than the standard engine in the following sense: given an abstract domain, the output of our engine, for any program, is more accurate than that of the standard engine. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Bruynooghe and G. Janssens, </author> <title> "An Instance of Abstract Interpretation integrating Type and Mode Inference", </title> <booktitle> Proc. 5 th Int. Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <pages> pp 669-683, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Note that the i th column describes value [ ] after the i iterations of the main loop. 1: ?- eq (X, Y), p (f (Y, Z)). 3: q (f (S, V)) r (S). 5: eq (W, W). initial 1 2 3 4 value <ref> [1] </ref> false false false false x $ y value [2] false false false true true value [3] false false s s s value [4] false true true true true value [5] false true true true true We can similarly specify a standard engine for top-down analysis, but we defer the details <p> Amongst the many papers for which the stan dard engine applies are [10, 7] (bottom-up) and <ref> [1, 3, 9] </ref> (top-down). In order to compare the standard engine with the unfolding engine, we will now formulate the operation of the standard engine using our framework of group equations, clusters, composition etc.
Reference: [2] <author> A. Cortesi, G. File and W. Winsborough, </author> <title> "Equivalence of Abstract Domains for Groundness Analysis", </title> <type> Technical Report, </type> <institution> Dip. di Matematica Pure e Applicata, Universita di Padova, </institution> <year> 1991. </year>
Reference-contexts: i th column describes value [ ] after the i iterations of the main loop. 1: ?- eq (X, Y), p (f (Y, Z)). 3: q (f (S, V)) r (S). 5: eq (W, W). initial 1 2 3 4 value [1] false false false false x $ y value <ref> [2] </ref> false false false true true value [3] false false s s s value [4] false true true true true value [5] false true true true true We can similarly specify a standard engine for top-down analysis, but we defer the details to the appendix. <p> First, the issue of matching body and head atoms in set constraints is essentially the same as in the unfolding engine. Using our set constraint implementation 10 on reasonable example programs, this issue was not 9 By <ref> [2] </ref>, UNFOLD (D prop ) is uniformly more accurate than a number of other algorithms as well. 10 Approximately 3000 lines of Standard ML. prohibitive. Next consider the issue of unfolding efficiency.
Reference: [3] <author> S. Debray, </author> <title> "Global Optimization of Logic Programs", </title> <type> Ph.D. Thesis, </type> <institution> Department of Computer Science, SUNY at Stony Brook, </institution> <month> December </month> <year> 1986. </year>
Reference-contexts: To overcome this problem, domains have been developed in which information about the aliasing and sharing behavior of variables is maintained; see <ref> [3, 12, 7, 9, 11] </ref> for example. These dependency-based approaches improve the accuracy of the analysis and, for the first program, they infer that both X and Y are ground. They are, however, rather weak in reasoning about partially instantiated structures. <p> after the i iterations of the main loop. 1: ?- eq (X, Y), p (f (Y, Z)). 3: q (f (S, V)) r (S). 5: eq (W, W). initial 1 2 3 4 value [1] false false false false x $ y value [2] false false false true true value <ref> [3] </ref> false false s s s value [4] false true true true true value [5] false true true true true We can similarly specify a standard engine for top-down analysis, but we defer the details to the appendix. <p> Amongst the many papers for which the stan dard engine applies are [10, 7] (bottom-up) and <ref> [1, 3, 9] </ref> (top-down). In order to compare the standard engine with the unfolding engine, we will now formulate the operation of the standard engine using our framework of group equations, clusters, composition etc.
Reference: [4] <author> N. Heintze, </author> <title> "Set Based Program Analysis", </title> <type> forthcoming Ph.D. thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> May </month> <year> 1992 </year> <month> (expected). </month>
Reference-contexts: The first part of the proof establishes that the least model of these equations (denoted lm (E P )) corresponds to the collecting semantics at hand. This is tedious but fairly straightforward (see [5] and <ref> [4] </ref> for proofs of related results). We next prove that the algorithm constructs a conservative approximation to lm (E P ). Let E loop denote the equations obtained from E P after execution of the main repeat-until loop of the unfolding engine. <p> loop. 1: ?- eq (X, Y), p (f (Y, Z)). 3: q (f (S, V)) r (S). 5: eq (W, W). initial 1 2 3 4 value [1] false false false false x $ y value [2] false false false true true value [3] false false s s s value <ref> [4] </ref> false true true true true value [5] false true true true true We can similarly specify a standard engine for top-down analysis, but we defer the details to the appendix. <p> The second part concerns the unfolding step. Though the number of new groups produced by this step is linear in the size of the input clusters, the termination of the engine is based on an exhaustive application of this step. Experience with a prototype implementation of set constraints <ref> [4] </ref> provides some evidence that these two problems can be overcome. First, the issue of matching body and head atoms in set constraints is essentially the same as in the unfolding engine.
Reference: [5] <author> N. Heintze and J. Jaffar, </author> <title> "A Finite Presentation Theorem for Approximating Logic Programs", </title> <booktitle> Proc. 17 th ACM-POPL, </booktitle> <year> 1990, </year> <pages> pp. 197-209. </pages> <note> (A full version of this paper appears as IBM technical report RC 16089 (# 71415), </note> <month> August </month> <year> 1990, </year> <pages> 66 pp.) </pages>
Reference-contexts: They are, however, rather weak in reasoning about partially instantiated structures. For example, in the second program, the dependency-based approaches cannot infer that X is ground since this requires reasoning about the structure of the terms to which U can be bound. A different approach, that of set constraints <ref> [5] </ref>, has been shown to be useful for reasoning about structural information. The basic idea here is to reason about the program variables as sets of possible values, as opposed to one set of substitutions. <p> Proof outline: Let E P denote the semantic equations obtained from the input program P . The first part of the proof establishes that the least model of these equations (denoted lm (E P )) corresponds to the collecting semantics at hand. This is tedious but fairly straightforward (see <ref> [5] </ref> and [4] for proofs of related results). We next prove that the algorithm constructs a conservative approximation to lm (E P ). Let E loop denote the equations obtained from E P after execution of the main repeat-until loop of the unfolding engine. <p> (f (Y, Z)). 3: q (f (S, V)) r (S). 5: eq (W, W). initial 1 2 3 4 value [1] false false false false x $ y value [2] false false false true true value [3] false false s s s value [4] false true true true true value <ref> [5] </ref> false true true true true We can similarly specify a standard engine for top-down analysis, but we defer the details to the appendix. Amongst the many papers for which the stan dard engine applies are [10, 7] (bottom-up) and [1, 3, 9] (top-down).
Reference: [6] <author> N. Heintze and J. Jaffar, </author> <title> "A Decision Procedure for a Class of Herbrand Set Constraints", </title> <booktitle> Proc. 5 th IEEE-LICS, </booktitle> <month> June </month> <year> 1990, </year> <pages> pp 42 - 51. </pages> <note> (A full version of this paper appears as Carnegie Mellon University technical report CMU-CS-91-110, </note> <month> February </month> <year> 1991, </year> <pages> 42 pp.) </pages>
Reference-contexts: In fact, they represent an undecidable set of equations in general. Perhaps the best general technique for extracting information from these residual groups is to approximate them by interpreting them as set constraints, and then employing an intersection algorithm for set expressions (see <ref> [6] </ref> for example). It is important to note that the engine as stated already has much of the analytical power of the set constraint approach to analysis. Indeed the third program in section 1 shows that it is sometimes strictly more accurate.
Reference: [7] <author> D. Jacobs and A. Langen, </author> <title> "Accurate and Efficient Approximation of Variable Aliasing in Logic Programs", </title> <booktitle> Proc. North American Conf. on Logic Programming, </booktitle> <year> 1989, </year> <pages> pp 154-165. </pages>
Reference-contexts: To overcome this problem, domains have been developed in which information about the aliasing and sharing behavior of variables is maintained; see <ref> [3, 12, 7, 9, 11] </ref> for example. These dependency-based approaches improve the accuracy of the analysis and, for the first program, they infer that both X and Y are ground. They are, however, rather weak in reasoning about partially instantiated structures. <p> Amongst the many papers for which the stan dard engine applies are <ref> [10, 7] </ref> (bottom-up) and [1, 3, 9] (top-down). In order to compare the standard engine with the unfolding engine, we will now formulate the operation of the standard engine using our framework of group equations, clusters, composition etc. <p> We conclude this section with the realization of some analysis algorithms using our engine. Let unfold (D) denote the algorithm obtained by using the unfolding engine and the abstract domain D; sim-ilarly for standard (D). Let D sharing denote the domain described in <ref> [7] </ref>. Corollary 1 For groundness analysis, unfold (D prop ) is uniformly more accurate than [11] 9 . Corollary 2 For sharing analysis, unfold (D sharing ) is uniformly more accurate than [7]. (The second example program in section 1 shows that unfold (D sharing ) is strictly more accurate.) 7 <p> Let D sharing denote the domain described in <ref> [7] </ref>. Corollary 1 For groundness analysis, unfold (D prop ) is uniformly more accurate than [11] 9 . Corollary 2 For sharing analysis, unfold (D sharing ) is uniformly more accurate than [7]. (The second example program in section 1 shows that unfold (D sharing ) is strictly more accurate.) 7 Conclusion A new engine for analysis of logic program is presented. Its starting point is a specific formulation of semantic equations of a program.
Reference: [8] <author> N. Jones and H. Stndergaard, </author> <title> "A Semantics-based Framework for the Abstract Interpretation of PRO-LOG", in Abstract Interpretation of Declarative Languages, </title> <editor> (S. Abramsky and C. Hankin, Eds), </editor> <publisher> Ellis Horwood, </publisher> <year> 1987, </year> <pages> pp 123-142. </pages>
Reference-contexts: Consider approximating the new groups constructed during the substitution step. Each such group is terminal and hence defines a fixed set of substitutions. Hence any traditional means for approximating substitution sets can be employed (see, for example, <ref> [8] </ref>). We present one formalization as follows.
Reference: [9] <author> K. Muthukumar and M. Hermenegildo, </author> <title> "Determination of Variable Dependence Information Through Abstract Interpretation", </title> <booktitle> Proc. North American Conf. on Logic Programming, </booktitle> <year> 1989, </year> <pages> pp 166-186. </pages>
Reference-contexts: To overcome this problem, domains have been developed in which information about the aliasing and sharing behavior of variables is maintained; see <ref> [3, 12, 7, 9, 11] </ref> for example. These dependency-based approaches improve the accuracy of the analysis and, for the first program, they infer that both X and Y are ground. They are, however, rather weak in reasoning about partially instantiated structures. <p> Amongst the many papers for which the stan dard engine applies are [10, 7] (bottom-up) and <ref> [1, 3, 9] </ref> (top-down). In order to compare the standard engine with the unfolding engine, we will now formulate the operation of the standard engine using our framework of group equations, clusters, composition etc.
Reference: [10] <author> K. Marriott and H. Stndergaard, </author> <title> "Bottom-Up Abstract Interpretation of Logic Programs" Proc. </title> <booktitle> Fifth International Conf. and Symp. on Logic Programming, </booktitle> <year> 1988, </year> <pages> pp 733-748. </pages>
Reference-contexts: Amongst the many papers for which the stan dard engine applies are <ref> [10, 7] </ref> (bottom-up) and [1, 3, 9] (top-down). In order to compare the standard engine with the unfolding engine, we will now formulate the operation of the standard engine using our framework of group equations, clusters, composition etc.
Reference: [11] <author> K. Marriott and H. Stndergaard and N.D. Jones, </author> <title> "Abstract Interpretation of Logic Programs: The Denotational Approach", ACM-TOPLAS, to appear. (Also, </title> <booktitle> Proc. Fifth Italian Conf. Logic Programming, </booktitle> <year> 1990, </year> <pages> pp 399-425.) </pages>
Reference-contexts: To overcome this problem, domains have been developed in which information about the aliasing and sharing behavior of variables is maintained; see <ref> [3, 12, 7, 9, 11] </ref> for example. These dependency-based approaches improve the accuracy of the analysis and, for the first program, they infer that both X and Y are ground. They are, however, rather weak in reasoning about partially instantiated structures. <p> Example 1 <ref> [11] </ref> Let D prop consist of all propositional formulas over certain variables, whose purpose is to describe propositional relationships between groundness of variables. Let abs and conc be described informally as follows. <p> Let unfold (D) denote the algorithm obtained by using the unfolding engine and the abstract domain D; sim-ilarly for standard (D). Let D sharing denote the domain described in [7]. Corollary 1 For groundness analysis, unfold (D prop ) is uniformly more accurate than <ref> [11] </ref> 9 . Corollary 2 For sharing analysis, unfold (D sharing ) is uniformly more accurate than [7]. (The second example program in section 1 shows that unfold (D sharing ) is strictly more accurate.) 7 Conclusion A new engine for analysis of logic program is presented.
Reference: [12] <author> H. Stndergaard, </author> <title> "An Application of Abstract Interpretation of Logic Programs: Occur Check Reduction", </title> <booktitle> in Proc. ESOP '86, Saarbrucken, </booktitle> <month> March 86. </month>
Reference-contexts: To overcome this problem, domains have been developed in which information about the aliasing and sharing behavior of variables is maintained; see <ref> [3, 12, 7, 9, 11] </ref> for example. These dependency-based approaches improve the accuracy of the analysis and, for the first program, they infer that both X and Y are ground. They are, however, rather weak in reasoning about partially instantiated structures.
References-found: 12

