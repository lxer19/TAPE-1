URL: http://www.cs.wisc.edu/wpis/papers/acta96.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Title: On the Sequential Nature of Interprocedural Program-Analysis Problems Obtaining meet-over-all-valid-paths solutions to interprocedural versions of
Author: Thomas Reps P. 
Note: analysis problems is P-hard.  
Address: Wisconsin 1  
Affiliation: University of  
Abstract: In this paper, we study two interprocedural program-analysis problemsinterprocedural slicing and inter-procedural dataow analysisand present the following results: These results provide evidence that there do not exist fast (NC-class) parallel algorithms for interprocedural slicing and precise interprocedural dataow analysis (unless P = NC). That is, it is unlikely that there are algorithms for interpro-cedural slicing and precise interprocedural dataow analysis for which the number of processors is bounded by a polynomial in the size of the input, and whose running time is bounded by a polynomial in the logarithm of the size of the input. This suggests that there are limitations on the ability to use parallelism to overcome compiler bottlenecks due to expensive interprocedural-analysis computations. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Badger, L. and Weiser, M., </author> <title> Minimizing communication for synchronizing parallel dataow programs, </title> <booktitle> in Proceedings of the 1988 International Conference on Parallel Processing, </booktitle> <address> (St. Charles, IL, </address> <month> Aug. </month> <pages> 15-19, </pages> <year> 1988), </year> <institution> Pennsylvania State University Press, University Park, </institution> <address> PA (1988). </address>
Reference: 2. <author> Callahan, D., </author> <title> The program summary graph and ow-sensitive interprocedural data ow analysis, </title> <booktitle> Proceedings of the ACM SIG-PLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIGPLAN Notices 23(7) pp. </journal> <month> 47-56 (July </month> <year> 1988). </year>
Reference: 3. <author> Deransart, P., Jourdan, M., and Lorho, B., </author> <title> Attribute Grammars: Definitions, Systems and Bibliography, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 323, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1988). </address>
Reference-contexts: Theorem 3.5. The problem of deciding whether an edge occurs in the IO graph of a nonterminal of an attribute grammar is log-space complete for P. Proof. The IO graphs of an attribute grammar's nonterminals can be computed in polynomial time (by means of a bottom-up iterative algorithm) <ref> [3, pp. 16] </ref>. The proof that the problem is P-hard is again by reduction from the monotone circuit value problem.
Reference: 4. <author> Dwork, C., Kanellakis, P.C., and Mitchell, </author> <title> J.C., On the sequential nature of unification, </title> <journal> Journal of Logic Programming 1 pp. </journal> <month> 35-50 </month> <year> (1984). </year>
Reference-contexts: In terms of the impact on the programming-languages area, our results can be viewed as being complementary to the results of Dwork, Kanellakis, and Mitchell, who showed that there are limitations on the ability to use parallelism to speed up unification <ref> [4] </ref>. The Dwork-Kanellakis-Mitchell result demonstrates that there are limitations on the use of parallelism to speed up the execution of programs (specifically, programs written in languages such as Prolog that use unification for parameter passing). <p> Robinson's comments on the Dwork-Kanellakis-Mitchell result [30].) The gadgets used in the constructions in Sections 3 and 4 have some similarities to the ones used in the proofs that the unification problem <ref> [4] </ref> and the left-linear semi-unification problem [7] are log-space complete for P.
Reference: 5. <author> Ferrante, J., Ottenstein, K., and Warren, J., </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 9(3) pp. </pages> <month> 319-349 (July </month> <year> 1987). </year>
Reference: 6. <author> Goldschlager, L., </author> <title> The monotone and planar circuit value problems are log-space complete for P, </title> <journal> ACM SIGACT News 9(2) pp. </journal> <month> 25-29 </month> <year> (1977). </year>
Reference-contexts: The proof that interprocedural slicing is log-space complete for P is by a log-space reduction from a known P-complete problem, the monotone circuit value problem <ref> [6] </ref>, which is defined as follows: Definition 3.3.
Reference: 7. <author> Henglein, F., </author> <title> Fast left-linear semi-unification, pp. </title> <booktitle> 82-91 in Proceedings of the International Conference on Computing and Information, </booktitle> <month> (May </month> <year> 1990), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 468, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1990). </address>
Reference-contexts: Robinson's comments on the Dwork-Kanellakis-Mitchell result [30].) The gadgets used in the constructions in Sections 3 and 4 have some similarities to the ones used in the proofs that the unification problem [4] and the left-linear semi-unification problem <ref> [7] </ref> are log-space complete for P.
Reference: 8. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 11(3) pp. </pages> <month> 345-387 (July </month> <year> 1989). </year> <title> 8 Some program-analysis problems are undecidable even in their intraprocedural version [20,26]. </title> - <type> 15 </type> - 
Reference-contexts: This concept, originally discussed by Mark Weiser in [34], allows one to isolate individual computation threads within a program. Slicing can be used for such diverse activities as helping a programmer understand complicated code, aiding debugging [21], automatically parallelizing programs [33,1], and automatically combining program variants <ref> [8] </ref>. In Weiser's terminology, a slicing criterion is a pair &lt; p, V &gt;, where p is a program point and V is a subset of the program's variables.
Reference: 9. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 12(1) pp. </pages> <month> 26-60 (January </month> <year> 1990). </year>
Reference-contexts: The problem of interprocedural slicing concerns how to generate a slice of a multi-procedure program, where the slice can cross the boundaries of procedure calls. One algorithm for interprocedural slicing was presented by Weiser [34]. However, as pointed out independently by Horwitz, Reps, and Binkley <ref> [9] </ref> and Hwang, Du, and Chou [10], Weiser's algorithm is imprecise in the sense that it can report effects that are transmitted (only) through paths in a graph representation of the program that do not represent feasible (valid) execution paths. <p> Valid Paths and System Dependence Graphs The notion of a valid path is most easily understood in terms of the concept of a system dependence graph, a graph used to represent multi-procedure programs (systems) <ref> [9] </ref>. The system dependence graph is similar to other dependence-graph representations of programs (e.g., [16,5]), but represents collections of procedures rather than just monolithic programs. <p> An example program and its system dependence graph 3 It has been shown that running time of the Horwitz-Reps-Binkley algorithm is polynomial in the size of the program <ref> [9] </ref>. An improved version of the algorithm (one with an asymptotically better running time) is given in [27]. The Hwang-Du-Chou algorithm, on the other hand, takes exponential time in the worst case [27]. <p> Due to space limitations we will not give a detailed definition here; however, the important ideas should be clear from Figure 1 and the summary provided below. (For a detailed description of SDGs, see <ref> [9] </ref>.) The vertices of a procedure's PDG represent the individual statements and predicates of the procedure. A call statement is represented by several vertices: a call vertex and a collection of actual-in and actual-out vertices. <p> These are shown as dashed lines in Figure 1. A key fact about SDGs is that the SDG for a program can be constructed in time polynomial in the size of the program <ref> [9] </ref>. The notion of a valid path captures the idea that not every path through a system dependence graph represents a potentially valid execution path: Definition 3.1. Let each call site in program P be given a unique index in the range [1 . . <p> (backward) slicing problem is that of finding, given a program P and a program point w in P, all program points v such that there is a valid path in P's SDG from the vertex that corresponds to v to the vertex that corresponds to w. 4 As defined in <ref> [9] </ref>, procedure dependence graphs include four kinds of dependence edges: control, loop-independent ow, loop-carried ow, and def-order. Howev er, for slicing the distinction between loop-independent and loop-carried ow edges is irrelevant, and def-order edges are not used. <p> P-Complete Attribute-Grammar Analysis Problems Horwitz, Reps, and Binkley pointed out a correspondence between the call structure of a program and a context-free grammar, and between the intraprocedural transitive dependences among a PDG's parameter vertices and the dependences among attributes in an attribute grammar <ref> [9] </ref>. Because of this correspondence, Theorem 3.4 also has consequences for the computation of IO graphs of attribute grammars [13,3,22] and other similar approximations to the characteristic graphs of an attribute grammar's nontermi-nals that can be computed in polynomial time, such as TDS graphs of ordered attribute grammars [12].
Reference: 10. <author> Hwang, J.C., Du, M.W., and Chou, C.R., </author> <title> Finding program slices for recursive procedures, </title> <booktitle> in Proceedings of IEEE COMPSAC 88, </booktitle> <address> (Chicago, IL, </address> <month> Oct. </month> <pages> 3-7, </pages> <address> 1988), </address> <publisher> IEEE Computer Society, </publisher> <address> Washington, DC (1988). </address>
Reference-contexts: One algorithm for interprocedural slicing was presented by Weiser [34]. However, as pointed out independently by Horwitz, Reps, and Binkley [9] and Hwang, Du, and Chou <ref> [10] </ref>, Weiser's algorithm is imprecise in the sense that it can report effects that are transmitted (only) through paths in a graph representation of the program that do not represent feasible (valid) execution paths.
Reference: 11. <author> Jones, N.D. and Laaser, W.T., </author> <title> Complete problems for deterministic polynomial time, </title> <note> Theoretical Computer Science 3 pp. </note> <month> 105-117 </month> <year> (1977). </year>
Reference-contexts: A language that is log-space complete for P has the property that if it is recognizable in space log k ( . ), then every language in P (a.k.a. PTIME) is also recognizable in space log k ( . ) <ref> [11] </ref>.
Reference: 12. <author> Kastens, U., </author> <title> Ordered attribute grammars, </title> <note> Acta Informatica 13(3) pp. </note> <month> 229-256 </month> <year> (1980). </year>
Reference-contexts: Because of this correspondence, Theorem 3.4 also has consequences for the computation of IO graphs of attribute grammars [13,3,22] and other similar approximations to the characteristic graphs of an attribute grammar's nontermi-nals that can be computed in polynomial time, such as TDS graphs of ordered attribute grammars <ref> [12] </ref>. Theorem 3.5. The problem of deciding whether an edge occurs in the IO graph of a nonterminal of an attribute grammar is log-space complete for P. Proof.
Reference: 13. <author> Kennedy, K. and Warren, </author> <title> S.K., Automatic generation of efficient evaluators for attribute grammars, pp. </title> <booktitle> 32-49 in Conference Record of the Third ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Atlanta, GA, </address> <month> Jan. </month> <pages> 19-21, </pages> <address> 1976), </address> <publisher> ACM, </publisher> <address> New York, NY (1976). </address>
Reference: 14. <author> Kildall, G., </author> <title> A unified approach to global program optimization, pp. </title> <booktitle> 194-206 in Conference Record of the First ACM Symposium on Principles of Programming Languages, ACM, </booktitle> <address> New York, NY (1973). </address>
Reference-contexts: The concept of valid paths arises in both the interprocedural-slicing problem [9,10,27] and in ow-sensitive inter-procedural dataow-analysis problems [32,23,2,17,15,18,19,28,29,31]. For example, Sharir and Pnueli generalized Kildall's concept of the meet-over-all-paths solution of an intraprocedural dataow-analysis problem <ref> [14] </ref> to the meet-over-all-valid-paths solution of an interprocedural dataow-analysis problem [32]. Interprocedural analysis is generally expensive, and can be the bottleneck in compilers that employ it. This raises the question of whether it might be possible to devise fast parallel algorithms for interprocedural analysis problems. <p> The problems considered are those amenable to Sharir and Pnueli's functional approach to interprocedural dataow analysis. 7 This generalizes Kildall's concept of the meet-over-all-paths solution of an intrapro-cedural dataow-analysis problem <ref> [14] </ref> to the meet-over-all-valid-paths solution of an interprocedural dataow-analysis problem [32]. This framework for interprocedural dataow analysis is reviewed below.
Reference: 15. <author> Knoop, J. and Steffen, B., </author> <title> The interprocedural coincidence theorem, pp. </title> <booktitle> 125-140 in Proceedings of the Fourth International Conference on Compiler Construction, (Paderborn, </booktitle> <address> FRG, </address> <month> October 5-7, </month> <year> 1992), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 641, </volume> <editor> ed. U. Kastens and P. Pfahler, </editor> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1992). </address>
Reference: 16. <author> Kuck, D.J., Kuhn, R.H., Leasure, B., Padua, D.A., and Wolfe, M., </author> <title> Dependence graphs and compiler optimizations, pp. </title> <booktitle> 207-218 in Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Williamsburg, VA, </address> <month> January 26-28, </month> <year> 1981), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1981). </address>
Reference: 17. <author> Landi, W. and Ryder, B.G., </author> <title> Pointer-induced aliasing: A problem classification, pp. </title> <booktitle> 93-103 in Conference Record of the Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Orlando, FL, </address> <month> January </month> <year> 1991), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1991). </address>
Reference-contexts: problems there does exist a fast (NC-class) parallel algorithm. (Compare, for example, Theorem 4.3 and Corollary 4.4 against Theorem 4.5.) 2 See also the discussion in Section 5 relating the work reported in this paper with Landi and Ryder's work on other aspects of interpro-cedural analysis and inherent computational limitations <ref> [17] </ref>. - 3 - 3. Interprocedural Slicing The slice of a program with respect to program point p and variable x consists of all statements and predicates of the program that might affect the value of x at point p. <p> Landi and Ryder have also investigated the computational complexity of interprocedural dataow analysis under the assumption that only valid paths are to be considered <ref> [17] </ref>. (Valid paths are called realizable paths in [17].) Their work shows that when the program-analysis problem to be solved involves certain kinds of constructs (e.g., single or multiple levels of pointers, reference parameters, etc.) one faces certain kinds of computational limitations (e.g., NP-hardness, undecidability, etc.). 8 This paper demonstrates that, <p> Landi and Ryder have also investigated the computational complexity of interprocedural dataow analysis under the assumption that only valid paths are to be considered <ref> [17] </ref>. (Valid paths are called realizable paths in [17].) Their work shows that when the program-analysis problem to be solved involves certain kinds of constructs (e.g., single or multiple levels of pointers, reference parameters, etc.) one faces certain kinds of computational limitations (e.g., NP-hardness, undecidability, etc.). 8 This paper demonstrates that, by itself, the aspect of considering only valid
Reference: 18. <author> Landi, W. and Ryder, B.G., </author> <title> A safe approximate algorithm for interprocedural pointer aliasing, </title> <booktitle> Proceedings of the ACM SIG-PLAN 92 Conference on Programming Language Design and Implementation, </booktitle> <address> (San Francisco, CA, </address> <month> June 17-19, </month> <year> 1992), </year> <journal> ACM SIG-PLAN Notices 27(7) pp. </journal> <month> 235-248 (July </month> <year> 1992). </year>
Reference: 19. <author> Landi, W., Ryder, B.G., and Zhang, S., </author> <title> Interprocedural modification side effect analysis with pointer aliasing, pp. </title> <booktitle> 56-67 in Proceedings of the ACM SIGPLAN 93 Conference on Programming Language Design and Implementation, </booktitle> <address> (Albuquerque, NM, June 23-25, 1993), </address> <publisher> ACM, </publisher> <address> New York, NY (June 1993). </address>
Reference: 20. <author> Landi, W., </author> <title> Undecidability of static analysis, </title> <journal> ACM Letters on Pro gramming Languages and Systems 1(4) p. </journal> <month> December </month> <year> 1993 </year> (). 
Reference: 21. <author> Lyle, J. and Weiser, M., </author> <title> Experiments on slicing-based debugging tools, </title> <booktitle> in Proceedings of the First Conference on Empirical Studies of Programming, </booktitle> <address> (June 1986), </address> <publisher> Ablex Publishing Co. </publisher> <year> (1986). </year>
Reference-contexts: This concept, originally discussed by Mark Weiser in [34], allows one to isolate individual computation threads within a program. Slicing can be used for such diverse activities as helping a programmer understand complicated code, aiding debugging <ref> [21] </ref>, automatically parallelizing programs [33,1], and automatically combining program variants [8]. In Weiser's terminology, a slicing criterion is a pair &lt; p, V &gt;, where p is a program point and V is a subset of the program's variables.
Reference: 22. <author> Mo ncke, U. and Wilhelm, R., </author> <title> Grammar ow analysis, pp. 151-186 in Attribute Grammars, </title> <booktitle> Applications and Systems, (International Summer School SAGA, </booktitle> <address> Prague, Czechoslovakia, </address> <month> June </month> <year> 1991), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 545, </volume> <editor> ed. H. Alblas and B. Melichar, </editor> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1991). </address>
Reference: 23. <author> Myers, E., </author> <title> A precise inter-procedural data ow algorithm, pp. </title> <booktitle> 219-230 in Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Williamsburg, VA, </address> <month> January 26-28, </month> <year> 1981), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1981). </address>
Reference: 24. <author> Ottenstein, K.J. and Ottenstein, L.M., </author> <title> The program dependence graph in a software development environment, </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> Apr. </month> <pages> 23-25, </pages> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 177-184 (May </month> <year> 1984). </year>
Reference-contexts: In intraprocedural slicingthe problem of slicing a program that consists of just a single monolithic procedurea slice can be determined from the closure of the directly-affects relation. Ottenstein and Ottenstein pointed out how well-suited program dependence graphs are for intraprocedu-ral slicing <ref> [24] </ref>. Once a program is represented by its program dependence graph, the slicing problem is simply a reachability problem.
Reference: 25. <author> Papadimitriou, C.H., </author> <title> Computational Complexity, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1994). </address>
Reference-contexts: PTIME) is also recognizable in space log k ( . ) [11]. If any language that is log-space complete for P is decidable by an NC parallel algorithm, then every language in P has an NC parallel algorithm. (See, for example, <ref> [25, pp. 377] </ref>.) That is, the problems that are log-space complete for P do not have NC parallel algorithms unless P = NC. At the present time it is unknown whether P = NC, but it is considered to be unlikely. <p> Proof. Reps, Horwitz, and Sagiv hav e shown how all intraprocedural finite, distributive, subset problems can be converted to graph-reachability problems (where the size of the graph is polynomial in the size of the program) [29]. Reachability is known to be in NC. (See, for example, <ref> [25, pp. 362] </ref>.) - 13 - Output gate output ( p a ) global x proc Main () x : = 0 call P a () return And gate p b = p c p d proc P b () call P c () call P d () return Or gate
Reference: 26. <author> Ramalingam, G., </author> <title> The undecidability of aliasing, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 16(5) pp. </pages> <month> 1476-1471 (September </month> <year> 1994). </year>
Reference: 27. <author> Reps, T., Horwitz, S., Sagiv, M., and Rosay, G., </author> <title> Speeding up slicing, </title> <booktitle> SIGSOFT 94: Proceedings of the Second ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <address> (New Orleans, LA, </address> <month> December 7-9, </month> <year> 1994), </year> <booktitle> ACM SIGSOFT Software Engineering Notes 19(5) pp. </booktitle> <month> 11-20 (December </month> <year> 1994). </year>
Reference-contexts: An example program and its system dependence graph 3 It has been shown that running time of the Horwitz-Reps-Binkley algorithm is polynomial in the size of the program [9]. An improved version of the algorithm (one with an asymptotically better running time) is given in <ref> [27] </ref>. The Hwang-Du-Chou algorithm, on the other hand, takes exponential time in the worst case [27]. That is, there is a family of examples on which the Hwang-Du-Chou algorithm uses time exponential in the size of the program being sliced. - 4 - are shown in Figure 1. <p> An improved version of the algorithm (one with an asymptotically better running time) is given in <ref> [27] </ref>. The Hwang-Du-Chou algorithm, on the other hand, takes exponential time in the worst case [27]. That is, there is a family of examples on which the Hwang-Du-Chou algorithm uses time exponential in the size of the program being sliced. - 4 - are shown in Figure 1. <p> in the program, E is the maximum number of control and ow edges in any procedure's PDG, TotalSites is the total number of call sites in the program, Params is the largest number of formal parameters in any procedure, and Globals is the number of global variables in the program <ref> [27] </ref>.
Reference: 28. <author> Reps, T., </author> <title> Demand interprocedural program analysis using logic databases, </title> <note> pp. 163-196 in Applications of Logic Databases, </note> <editor> ed. R. Ramakrishnan, </editor> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, MA (1994). </address>
Reference: 29. <author> Reps, T., Horwitz, S., and Sagiv, M., </author> <title> Precise interprocedural dataow analysis via graph reachability, pp. </title> <booktitle> 49-61 in Conference Record of the Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Francisco, CA, </address> <month> Jan. </month> <pages> 23-25, </pages> <address> 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address>
Reference-contexts: n) pf q for each n N * y n = F n ( ) for each n N * 7 In order to handle programs in which recursive procedures have local variables and parameters, we actually use a slightly generalized version of the Sharir-Pnueli framework that was introduced in <ref> [29] </ref>. - 12 - Theorem 4.3. The interprocedural dataow-analysis problems are P-hard under log-space reductions. Proof. Suppose problem X is any interprocedural dataow-analysis problem that meets the conditions of the dataow framework. <p> all of the so-called interprocedural, finite, distributive, subset problems (or IFDS problems, for short)distributive dataow-analysis problems in which the domain of dataow values for a program being analyzed consists of all subsets of a finite set D, where the size of D is polynomial in the size of the program <ref> [29] </ref>. <p> Every gen/kill or IFDS problem for which there is a dataow value that can be generated in the main procedure and killed in other procedures of the program is log-space complete for P. Proof. Reps, Horwitz, and Sagiv hav e given a polynomial-time algorithm for the IFDS problems <ref> [29] </ref>. The (finite-subset) gen/kill problems are a subclass of the IFDS problems and hence are also solvable in polynomial time. P-completeness follows from Theorem 4.3. <p> Every intraprocedural, finite, distributive, subset problem is solvable by an NC-class parallel algorithm. Proof. Reps, Horwitz, and Sagiv hav e shown how all intraprocedural finite, distributive, subset problems can be converted to graph-reachability problems (where the size of the graph is polynomial in the size of the program) <ref> [29] </ref>.
Reference: 30. <author> Robinson, </author> <title> J.A., </title> <journal> Logic and logic programming, Commun. of the ACM 35(3) pp. </journal> <month> 40-65 (March </month> <year> 1992). </year>
Reference-contexts: Robinson's comments on the Dwork-Kanellakis-Mitchell result <ref> [30] </ref>.) The gadgets used in the constructions in Sections 3 and 4 have some similarities to the ones used in the proofs that the unification problem [4] and the left-linear semi-unification problem [7] are log-space complete for P.
Reference: 31. <author> Sagiv, M., Reps, T., and Horwitz, S., </author> <title> Precise interprocedural dataow analysis with applications to constant propagation, pp. </title> <booktitle> 651-665 in Proceedings of FASE 95: Colloquium on Formal Approaches in Software Engineering, </booktitle> <address> (Aarhus, Denmark, </address> <month> May 22-26, </month> <year> 1995), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 915, </volume> <editor> ed. P.D. Mosses, M. Nielsen, and M.I. Schwartzbach, </editor> <publisher> Springer Verlag, </publisher> <address> New York, NY (1995). </address>
Reference: 32. <author> Sharir, M. and Pnueli, A., </author> <title> Two approaches to interprocedural data ow analysis, pp. 189-233 in Program Flow Analysis: The ory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones, </editor> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: The concept of valid paths arises in both the interprocedural-slicing problem [9,10,27] and in ow-sensitive inter-procedural dataow-analysis problems [32,23,2,17,15,18,19,28,29,31]. For example, Sharir and Pnueli generalized Kildall's concept of the meet-over-all-paths solution of an intraprocedural dataow-analysis problem [14] to the meet-over-all-valid-paths solution of an interprocedural dataow-analysis problem <ref> [32] </ref>. Interprocedural analysis is generally expensive, and can be the bottleneck in compilers that employ it. This raises the question of whether it might be possible to devise fast parallel algorithms for interprocedural analysis problems. <p> The problems considered are those amenable to Sharir and Pnueli's functional approach to interprocedural dataow analysis. 7 This generalizes Kildall's concept of the meet-over-all-paths solution of an intrapro-cedural dataow-analysis problem [14] to the meet-over-all-valid-paths solution of an interprocedural dataow-analysis problem <ref> [32] </ref>. This framework for interprocedural dataow analysis is reviewed below.
Reference: 33. <author> Weiser, M., </author> <title> Reconstructing sequential behavior from parallel behavior projections, </title> <note> Information Processing Letters 17 pp. </note> <month> 129-135 (October </month> <year> 1983). </year>
Reference: 34. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year>
Reference-contexts: Interprocedural Slicing The slice of a program with respect to program point p and variable x consists of all statements and predicates of the program that might affect the value of x at point p. This concept, originally discussed by Mark Weiser in <ref> [34] </ref>, allows one to isolate individual computation threads within a program. Slicing can be used for such diverse activities as helping a programmer understand complicated code, aiding debugging [21], automatically parallelizing programs [33,1], and automatically combining program variants [8]. <p> The problem of interprocedural slicing concerns how to generate a slice of a multi-procedure program, where the slice can cross the boundaries of procedure calls. One algorithm for interprocedural slicing was presented by Weiser <ref> [34] </ref>.
References-found: 34

