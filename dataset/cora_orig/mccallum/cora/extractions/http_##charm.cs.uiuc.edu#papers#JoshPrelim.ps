URL: http://charm.cs.uiuc.edu/papers/JoshPrelim.ps
Refering-URL: http://charm.cs.uiuc.edu/papers/JoshPrelim.html
Root-URL: http://www.cs.uiuc.edu
Email: jyelon@cs.uiuc.edu  
Title: Agents: an Abstraction Mechanism that Labels and Taxonomizes the Objects it Encapsulates  
Author: J. Yelon 
Date: March 3, 1997  
Address: Urbana Illinois 61801,  
Affiliation: Dept. of Computer Science, University of Illinois,  
Abstract: In object-oriented languages, an abstraction often involves a group of objects acting as a single entity. The programmer often has a mental vocabulary by which to label the objects: for example, in a particular LR(0) automaton, one object might represent the state "P :== R . S". In a particular instance of a binary-tree, one object might represent the data item "15". In general, each object in an abstraction can be mentally labeled, by the programmer, according to some statement of its purpose. The programmer's vocabulary to taxonomize and label the objects constituting an abstraction may be quite sophisticated and detailed. However, that vocabulary is only in the programmer's mind, it does not exist at the language level. The runtime system has no means to tell two instances of class binary-tree-node apart | it can't even distinguish the nodes of one tree from the nodes of another without sophisticated analysis. Though object-oriented languages make it possible to construct data structures with many different parts, they do not create a language-level vocabulary by which to refer to the different parts of the data structure. There are several problems in the field of object-oriented parallel processing that have hampered programmers for years, and for which solutions have been elusive. We argue that the lack of solutions to these problems stems from the absence of a vocabulary with which to express those solutions. In particular, the inability to refer to objects by name, and the lack of a vocabulary to distinguish objects from each other, makes it difficult to even describe what is desired from a complex algorithm. When the runtime system can't identify which object is which, it becomes becomes impossible to express such ideas as locality, or interconnectivity, or grouping. Clearly, this is a serious problem for parallel programmers. We have designed a new encapsulation mechanism for parallel processing, the agent declaration. This mechanism makes it possible to create an abstraction whose subcomponents are labeled and taxonomized. Having done so, we straightforwardly address some of the difficulties that have been facing object-oriented parallel programmers for years. The purpose of this research is to explore the consequences of having a vocabulary by which to distinguish objects, and to experiment with powerful language-level constructs that were previously inexpressible. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Robert D. Blumfoe, Christopher F. Joerg, Bradley C. Kuszmaul, Charles E. Leiserson, Keith H. Randall, and Yuli Zhou. Cilk: </author> <title> An efficient multithreaded runtime system. </title> <booktitle> In 5th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <address> Santa Barbara, California, </address> <month> July </month> <year> 1995. </year>
Reference: [2] <author> K. Mani Chandy and Carl Kesselman. </author> <title> Compositional C++: Compositional parallel programming. </title> <type> Technical Report Caltech-CS-TR-92-13, </type> <institution> Department of Computer Science, California Institute of Technology, </institution> <year> 1992. </year>
Reference: [3] <author> A. Chien and W. J. Dally. </author> <title> Concurrent aggregates. </title> <booktitle> In Proceedings of the Second ACM Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 187-196, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Known Problem | Using an ordinary sequential object as the header to a parallel structure creates a bottleneck. This doesn't eliminate all concurrency, but limits it severely. This was quickly recognized as a problem by researchers in the field, and was explicitly commented upon by Chien in <ref> [3] </ref>. The first solution was the branchoffice, which was part of the Chare Kernel [12] parallel programming system (later renamed Charm). BranchOffices are essentially distributed arrays of objects. <p> This is not usually difficult. Currently, the only language that we are aware of that uses this approach is concurrent aggregates <ref> [3] </ref>. In CA, aggregates were specifically designed to support the same interface as an ordinary object | method invocation. The type system also allows the substitution of an aggregate for a single object. <p> One can conceptually relay each matrix element into the consumer as soon as it is computed, without 8 waiting for the other matrix elements to be computed. Consider how a matrix-multiply routine would be implemented in a parallel language like Concurrent Aggregates <ref> [3] </ref> (CA for short). CA computations are embodied by aggregates, which are much like BranchOffices: they are arrays of objects, with the ability to invoke methods on the array as a whole.
Reference: [4] <author> I. Foster and K. M. Chandy. </author> <title> Fortran m: A language for modular parallel programming. </title> <journal> In Journal of Parallel and Distributed Computing, </journal> <year> 1994. </year>
Reference-contexts: Agents, by labeling objects according to their caller/callee relationships, makes the statement "send to parent" meaningful. Thus, it supports true data-driven output. Though other models cannot provide data-driven output, many do provide single-demand-driven output, which is at least an approximation to data-driven. For example, in Fortran-M <ref> [4] </ref>, after delivering one "channel endpoint" (much like a Unix pipe) to a thread, the thread can then write values into the channel. Similarly, in Id, one can pass a global pointer to an I-variable into a producer. The producer can then gradually fill the I-variable with a linked list.
Reference: [5] <author> David Gelernter, Nicholas Carriero, S. Chandran, , and Silva Chang. </author> <title> Parallel programming in Linda. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <pages> pages 255-263, </pages> <month> Aug </month> <year> 1985. </year>
Reference-contexts: Such names make it possible to express a wide variety of ideas that cannot be stated otherwise. The need for a vocabulary by which to identify data, and the related need to taxonomize those data, have also been recognized in languages like Linda <ref> [5] </ref> and D-Memo [15]. In such languages, each item of data is represented by a key (or by tag fields) which can be semantically meaningful. This simplifies the expression of programs. Linda's wildcards taxonomize the tuples into groups, those groups are useful for expressing such concepts as wildcard receives.
Reference: [6] <author> A. S. Grimshaw and J. W. Liu. </author> <title> Mentat: An object-oriented data-flow system. </title> <booktitle> Proceedings of the 1987 Object-Oriented Programming Systems, Languages and Applications Conference, </booktitle> <pages> pages 35-47, </pages> <month> October </month> <year> 1987. </year> <month> 28 </month>
Reference: [7] <author> Attila Gursoy and L. V. Kale. Dagger: </author> <title> Combining benefits of synchronous and asynchronous communication styles. </title> <editor> In H. G. Siegel, editor, </editor> <booktitle> Proc. 8th International Parallel Processing, </booktitle> <pages> pages 590-596, </pages> <month> April </month> <year> 1994. </year>
Reference: [8] <author> M. Haines, D. Cronk, and P. Mehrotra. </author> <title> On the design of Chant: A talking threads package. </title> <booktitle> In Proceedings of Supercomputing 1994, </booktitle> <address> Washington D.C., </address> <month> Nov </month> <year> 1994. </year>
Reference-contexts: This makes it difficult to compose the modules. Encapsulation Principle | All encapsulation mechanisms in a language should have plug-compatible interfaces to allow maximum compositionality, at least insofar as possible. An example of this problem occurs in Chant <ref> [8] </ref>, which contains two major constructs: threads, and ropes (groups of threads). Both kinds of entities interact with the world by sending and receiving messages. Thus, they are potentially plug-compatible. <p> The simplest way to avoid this problem is to minimize the size of the language, providing one general construct instead of many specialized constructs. This approach is being used less and less often, as composite languages like CC++[2], Charm++[13], Chant <ref> [8] </ref>, HPC++ and many others are being invented with a large number of features. 7 The other approach is to provide compatible interfaces despite having multiple constructs. This is not usually difficult. Currently, the only language that we are aware of that uses this approach is concurrent aggregates [3]. <p> Note that there is no question of interface inconsistency in agents. This agent, like all other agents, produces its output as a stream of messages, and expects inputs as a stream of messages. By way of comparison, a similar object in Chant <ref> [8] </ref> would need to decide whether to produce output by sending it to a thread, or by sending it to a rope element | an impossible decision to make without contextual information. Now we move on to the summation-tree proper.
Reference: [9] <author> L. V. Kale and Attila Gursoy. </author> <title> Modularity, reuse and efficiency with message-driven libraries. </title> <booktitle> In Proc. 27th Conference on Parallel Processing for Scientific Computing, </booktitle> <pages> pages 738-743, </pages> <month> February </month> <year> 1995. </year>
Reference: [10] <author> L. V. Kale, B. Ramkumar, A. B. Sinha, and A. Gursoy. </author> <title> The CHARM Parallel Programming Language and System: Part I Description of Language Features. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <year> 1994. </year>
Reference: [11] <author> L. V. Kale, B. Ramkumar, A. B. Sinha, and V. A. Saletore. </author> <title> The CHARM Parallel Programming Language and System: Part II The Runtime system. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <year> 1994. </year>
Reference: [12] <author> L.V. Kale. </author> <title> The Chare Kernel parallel programming language and system. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: This doesn't eliminate all concurrency, but limits it severely. This was quickly recognized as a problem by researchers in the field, and was explicitly commented upon by Chien in [3]. The first solution was the branchoffice, which was part of the Chare Kernel <ref> [12] </ref> parallel programming system (later renamed Charm). BranchOffices are essentially distributed arrays of objects. They support an operation branchcall which causes the entire array to appear as a single object on which one may perform method invocations. <p> The adaptation of the object-oriented model to the parallel arena was a first step in this direction, and clearly represented an intention to achieve modularity within a parallel context. Among the first languages incorporating the object-oriented model was the Chare Kernel <ref> [12] </ref>. Almost immediately, it was clear that the object-oriented model contained bottlenecks, and this bottleneck was addressed by the addition of the branchoffice to the Chare Kernel, making it possible to create abstractions of distributed modules.
Reference: [13] <author> L.V. Kale and S. Krishnan. </author> <title> Charm++ : A portable concurrent object oriented system based on C++. </title> <booktitle> In Proceedings of the Conference on Object Oriented Programming Systems, Languages and Applications, </booktitle> <month> September </month> <year> 1993. </year>
Reference: [14] <author> Rishiyur S. Nikhil. </author> <booktitle> Parallel Symbolic Computing in Cid. In Parallel Symbolic Languages and Systems, </booktitle> <year> 1995. </year>
Reference-contexts: For example, many parallel libraries now provide the reduction tree, and Charm recently added a primitive for building multidimensional arrays. We feel that this approach is limited, but useful. Many researchers have asserted that continuation-passing style may not be desirable for general programming. For example, the Cid description <ref> [14] </ref> comments that "continuation-based programming seems quite tricky for humans. We believe that this is because it is difficult to modularize continuation-passing style, causing it to pervade the whole program." Agents makes a concerted effort to avoid the need for continuation-passing style.
Reference: [15] <author> W. O'Connell, G. Thiruvathukal, and T. Christopher. </author> <title> Distributed Memo: A heterogenously distributed parallel software development environment. </title> <booktitle> In Proceedings of the 23rd International Conference on Parallel Processing, </booktitle> <month> Aug </month> <year> 1994. </year>
Reference-contexts: Such names make it possible to express a wide variety of ideas that cannot be stated otherwise. The need for a vocabulary by which to identify data, and the related need to taxonomize those data, have also been recognized in languages like Linda [5] and D-Memo <ref> [15] </ref>. In such languages, each item of data is represented by a key (or by tag fields) which can be semantically meaningful. This simplifies the expression of programs. Linda's wildcards taxonomize the tuples into groups, those groups are useful for expressing such concepts as wildcard receives.
Reference: [16] <author> Paul A. Suhler, Jit Biswas, and Kim M. Korner. TDFL: </author> <title> A task-level data flow language. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 9(2), </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: Insofar as we are aware, the problem of efficient and elegant graph construction has not been addressed in a general manner in other models. The visual petri net languages like TDFL <ref> [16] </ref> strongly seem to suggest that easier graph construction was a primary design objective.
Reference: [17] <author> J. Yelon and L. V. Kale. </author> <title> Agents : An undistorted representation of problem structure. </title> <booktitle> In Proceedings of the Conference on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 551-565, </pages> <month> August </month> <year> 1995. </year> <month> 29 </month>
References-found: 17

