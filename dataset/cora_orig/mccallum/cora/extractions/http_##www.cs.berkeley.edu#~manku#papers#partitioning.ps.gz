URL: http://www.cs.berkeley.edu/~manku/papers/partitioning.ps.gz
Refering-URL: http://www.cs.berkeley.edu/~manku/papers-abstracts.html
Root-URL: 
Title: Circuit Partitioning with Partial Order for Mixed Simulation Emulation Environment  
Author: Gurmeet Singh Manku Anshul Kumar Shashi Kumar 
Address: New Delhi 110016, India  
Affiliation: Dept. of Computer Science and Engineering Indian Institute of Technology, Delhi  
Abstract: blends the ideas of hardware emulation with conventional software simulation. A crucial preparatory step is to partition a given circuit into as few parts as possible. The parts are then downloaded onto the RS one by one and emulated in stand alone mode or in conjunction with software simulator. The hybrid simulation environment poses some unique requirements on the partitioner. This paper presents an efficient partitioning algorithm for this purpose. A study of performance of the algorithm on 32 benchmark circuits for various I/O and size constraints of FPGAs has been carried out and good results have been obtained. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Blank Tom, </author> <title> A Survey of Hardware Accelerators used in CAD, </title> <booktitle> IEEE Design and Test of Computers, </booktitle> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: In software simulation, the circuit is completely modelled by software, which on execu tion gives the circuit behavior. In the hardware accelerated simulation approach, backend processors and special purpose computing engines are used for speeding up simulation <ref> [1] </ref>. A hardware emulator consists of a reconfigurable system ( RS ) on which a circuit can be mapped. The simulation in such a system can be carried out by giving a set of stimulii and looking at the outputs.
Reference: [2] <author> Stephen Walters, </author> <title> Computer Aided Prototyping for ASIC Based Systems, </title> <booktitle> IEEE Design and Test of Computers, </booktitle> <month> June </month> <year> 1991. </year>
Reference: [3] <author> E. David et. al., AnyBoard: </author> <title> A FPGA Based Reconfigurable System, </title> <booktitle> IEEE Design and Test of Computers, </booktitle> <month> Sep. </month> <year> 1992. </year>
Reference: [4] <author> K. Yamada et. al., </author> <title> High Speed Emulation of Communication Circuits on a Multiple-FPGA System, </title> <booktitle> 2nd ACM/SIGDA Workshop on FPGAs, </booktitle> <address> Berke-ley, </address> <month> Feb. </month> <year> 1994. </year>
Reference: [5] <author> S. Hauck et. al., Springbok: </author> <title> A Rapid Proto-typing System for Board Level Designs, </title> <booktitle> 2nd ACM/SIGDA Workshop on FPGAs, </booktitle> <address> Berkeley, </address> <month> Feb. </month> <year> 1994. </year>
Reference: [6] <author> Puneet Sharma and Rahul Garg, </author> <title> Flash: FPGA Based Logic Simulation System with Hardware Emulation, B.Tech. </title> <type> Thesis, </type> <institution> Dept. of Comp. Sc. and Engg., </institution> <address> IIT Delhi, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: On the other hand, software simulators are too slow for large circuits. At I.I.T. Delhi, a low cost, high performance hybrid logic simulator is under development which combines a software simulator with hardware emulation <ref> [6] </ref>, [7]. The hardware emulation is carried out on an RS built with a small number of static RAM based FPGAs. A low cost RS will have a limited capacity in terms of Configurable Logic Blocks ( CLBs ) and I/O pins. <p> The Controller generates the required signals for the RS to communicate with the interface. Initially, an RS was built using a single XILINX 3064 FPGA <ref> [6] </ref>, [7]. We are in the process of implementing a larger RS consisting of six XILINX 3064 FPGA's. The overall simulation approach is shown in Fig. 2. The circuit description is generated by a Synthesis and Mapping module which produces the required map file for the target FPGA.
Reference: [7] <author> Sumeer Bhola and R. Rajesh, </author> <title> Logic Simulation System for Large Circuits with FPGA Based Hardware Emulator, B.Tech. </title> <type> Thesis, </type> <institution> Dept. of Comp. Sc. and Engg., </institution> <address> IIT Delhi, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: On the other hand, software simulators are too slow for large circuits. At I.I.T. Delhi, a low cost, high performance hybrid logic simulator is under development which combines a software simulator with hardware emulation [6], <ref> [7] </ref>. The hardware emulation is carried out on an RS built with a small number of static RAM based FPGAs. A low cost RS will have a limited capacity in terms of Configurable Logic Blocks ( CLBs ) and I/O pins. <p> The Controller generates the required signals for the RS to communicate with the interface. Initially, an RS was built using a single XILINX 3064 FPGA [6], <ref> [7] </ref>. We are in the process of implementing a larger RS consisting of six XILINX 3064 FPGA's. The overall simulation approach is shown in Fig. 2. The circuit description is generated by a Synthesis and Mapping module which produces the required map file for the target FPGA.
Reference: [8] <author> T H Cormen, C E Leiserson and R L Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> New York : MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: This is a hard problem and we present an efficient polynomial-time heuristic algorithm. 4.1 The Basic Idea It can be shown that if the hypergraph G is partitioned into Strongly Connected Components <ref> [8] </ref> SCC 1 ; SCC 2 ; :::SCC s , then there will be no cyclic dependency between the components. For obtaining the required partition, we consider the directed acyclic graph G S formed by collapsing the nodes in each SCC into one. G S is necessarily acyclic. <p> However, this step must be heuristic-based, because there could be an exponential number of topological orderings of hypergraph G S , in general. Step 2, however, can be solved optimally in polynomial time using dynamic programming techniques <ref> [8] </ref>. We now discuss these two steps individually. 4.2 Cut Placement Step The function parts (i) returns the least number of parts into which ht 0 : : : t i i, can be partitioned.
Reference: [9] <author> D E Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol II, </volume> <year> 1968. </year>
Reference-contexts: The algorithm for partitioning is based on the idea that we could first topologically sort <ref> [9] </ref> the nodes in G S and then place cuts in the sequence thus obtained. The motivation for this approach is that for any partitioning that ensures acyclicity of parts, there exists a total order on the nodes, such that all nodes in any part are contiguous in that ordering.
References-found: 9

