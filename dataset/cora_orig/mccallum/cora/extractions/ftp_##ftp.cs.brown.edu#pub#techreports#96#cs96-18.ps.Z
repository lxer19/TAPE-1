URL: ftp://ftp.cs.brown.edu/pub/techreports/96/cs96-18.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-96-18.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [Gad] <author> Frank Gadegast. </author> <title> MPEG FAQ. </title> <journal> PHADE SOFTWARE. </journal>
Reference-contexts: MPEG is a compression standard devised by ISO, used to compress digital video <ref> [Gad] </ref>. The MT MPEG Viewer essentially decodes an MPEG version of a movie clip and then displays it to screen. The MT MPEG Viewer is built on top of a C++ class framework for concurrently decoding and displaying MPEG movies.
Reference: [HJT + 93] <author> Carl Hauser, Christian Jacobi, Marvin Theimer, Brent Welch, and Mark Weiser. </author> <title> Using threads in interactive systems: A case study. </title> <booktitle> Operating Systems Review, </booktitle> <pages> pages 94-105, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: To stop an errant RT thread the system must be rebooted. This is unacceptable. The approach taken by this package is to use two additional threads to monitor whether the system has locked up and if so terminate the program. <ref> [HJT + 93] </ref> The two threads are objects with type names DeadManThread and DeadManSwitch. The DeadManThread is a normal thread. Upon creation it sets a bit, and then goes to sleep for a period of time wakes up and sets the bit again. The DeadManSwitch is a real-time thread.
Reference: [Jr] <author> Thomas W. Doeppner Jr. </author> <title> The Brown C++ Threads Package. </title> <institution> Brown University. </institution>
Reference-contexts: Finally, the RTTP provides a level of abstraction allowing application programmers to develop on a OS independent layer of code. RTTP extends the Brown Thread Package (BTP), a C++ framework that treats threads and thread synchronization primitives as C++ types. <ref> [Jr] </ref> The BTP thread, for example, is an object whose methods provide the same facilities that Solaris and POSIX C-functions provide for manipulating vanilla threads.
Reference: [Suna] <author> SunSoft. man Pages(1): </author> <title> User Commands. </title>
Reference-contexts: The load plot points were obtained using the top UNIX utility and the frame rates were obtained from the MPEG viewer itself. top is a UNIX utility that display the load of top 15 processes on a machine and the current load and average loads of the machine <ref> [Suna] </ref>. The experiments were run on a SPARC 10 with 2 processors and 80MB. The MT MPEG Viewer was run twice once using RT threads and once using TS threads. The load was increased using a simple program that started four bound threads that spun in a loop.
Reference: [Sunb] <author> SunSoft. man Pages(2): </author> <title> User Commands. </title>
Reference-contexts: To 6 change a process's scheduling class to RT the process making the change must be root. Our original approach was to use the Solaris user command priocntl and execute it with an effective user ID of root to change the scheduling class of a process to real-time. <ref> [Sunb] </ref> Unfortunately priocntl changes its effective ID to real user ID before it calls the priocntl system call. As a result we modified the user command priocntl. The modified version rtpriocntl differs from the original version in two ways.
Reference: [Sunc] <author> SunSoft. </author> <title> Multithreaded Programming Guide. </title>
Reference-contexts: Binding the time-shared thread (TST) to the LWP, ties them together such that whenever the LWP runs, the TST runs, and no other TST may be scheduled to run on that LWP. It was then possible to use the underlying LWP to have the thread scheduled by the kernel. <ref> [Sunc] </ref> The RTTP RTThread had to use the Solaris thread types because there is no other convenient way to create user-level threads. 5 Although the BTP is a portable C++ framework, the internals of the BTP Thread class had to be modified (Figure 1) to get real-time threads to work.
Reference: [Sund] <author> SunSoft. </author> <title> System Services Guide. </title> <type> 44 </type>
Reference-contexts: As a side effect to changing the process's scheduling class the scheduling parameters of all the LWPs of the target process were set to the parameters passed to rtpriocntl and, therefore, had to be changed back to their original values. <ref> [Sund] </ref> The exact procedure detailed in Figure 2 was used to make real-time threads using rtpriocntl. First some thread creates a thread object and then calls Thread::make runnable to start the underlying Solaris thread. Thread::make runnable then calls RTThread:: InitThread that in turn calls RTManager::AddThread. <p> Memory locking is extremely important because a real-time thread must be able to guarantee continuous memory residence to prevent paging and swapping <ref> [Sund] </ref>. If the memory of a thread is not in memory, the thread will be blocked and descheduled in spite of its scheduling parameters. Unfortunately a process can only lock its own pages and to do so must be root.
References-found: 7

