URL: file://ftp.cs.wisc.edu/tech-reports/reports/92/tr1093.ps.Z
Refering-URL: http://www.cs.wisc.edu/shore/shore.papers.html
Root-URL: 
Email: -white,dewitt-@cs.wisc.edu  
Title: A Performance Study of Alternative Object Faulting and Pointer Swizzling Strategies  
Author: Seth J. White David J. Dewitt 
Address: Madison, WI 53706  
Affiliation: Computer Sciences Department University of Wisconsin  
Abstract: This paper presents a portable, efficient method for accessing memory resident persistent objects in virtual memory in the context of the E programming language. Under the approach, objects are copied from the buffer pool of the underlying object manager into virtual memory on demand, as they are accessed by an E program. The cumulative effects of updates to a persistent object are then propagated back to the object manager via a single write operation at the end of each transaction. The method incorporates a comprehensive pointer swizzling mechanism to enhance performance. Swizzling is done a pointer-at-a-time and software checks are used to detect the use of swizzled pointers. The paper also presents the results of a performance study comparing the method presented here with several alternative software architectures including ObjectStore V1.2, a commercially available OODBMS. The results highlight the tradeoffs between providing software vs. memory-mapped support for pointer swizzling and quantify the effects of pointer swizzling on overall performance. In addition, the significant performance impact of pointer swizzling on the generation of recovery information is examined. The experimental results show that in many situations a software approach can outperform the memory-mapped approach. 
Abstract-found: 1
Intro-found: 1
Reference: [Atkin83] <author> M. Atkinson, K. Chisholm, and P. Cockshott, </author> <title> "Algorithms for a Persistent Heap," </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 13, No. 3, </volume> <pages> pp. 259-272, </pages> <month> March </month> <year> 1983 </year>
Reference-contexts: Some early work on software implementations of pointer swizzling was done as part of an implementation of PS-Algol <ref> [Atkin83, Cock84] </ref>.
Reference: [Catte91] <author> R. Cattell, </author> <title> "An Engineering Database Benchmark," in The Benchmark Handbook For Database and Transaction Processing Systems, </title> <editor> Jim Gray ed., Morgan-Kaufman, </editor> <year> 1991. </year>
Reference-contexts: To help evaluate the effectiveness of the design of EPVM 2.0 this paper presents the results of a number of performance experiments that were conducted using the OO1 benchmark <ref> [Catte91] </ref>. The experiments compare EPVM 2.0 with three alternative software architectures. The first of these is ObjectStore V1.2 [Objec90], a commercially available object-oriented DBMS. ObjectStore uses a memory-mapped approach to support pointer swizzling and fault objects into main memory. <p> Note that all of the pointers between objects that have been visited by the program are swizzled, and that further traversals of the collection will dereference only swiz-zled pointers. 4. Performance Experiments The performance experiments were done using the traversal portion of the OO1 Benchmark <ref> [Catte91] </ref>. The traversal portion involves repeatedly traversing a collection of part objects, beginning at a randomly selected part, in a depth-first fashion to a depth of 7 levels. Each of the individual traversals is referred to as an iteration of the benchmark. <p> Both approaches have important implications for systems that do redo/undo logging. The experiments also compare the different software versions using a small database that fits into main memory and a large database that represents a working set size that is bigger than main memory <ref> [Catte91] </ref>. 4.1. Software Versions The first architecture, which is shown in Figure 5, results when a conventional non-persistent programming language, i.e. C++, is used to call ESM directly. This approach accesses objects in the client buffer pool of ESM using a procedural interface. <p> We used 5 megabyte client and server buffer pools for all of the experiments. This architecture will be referred to as OS. 4.2. Benchmark Database For ESM, the small benchmark database <ref> [Catte91] </ref> consumed a total of 489 8K-byte disk pages (3.8 Mg) and consisted of a collection of 20,000 part objects (each object is an average of 176 bytes in size). <p> The large database occupied 3,057 disk pages with an index whose size was 1.9 megabytes when using ESM. For ObjectStore the large database required 2,559 pages. 125,000 objects were used for the large database instead of 200,000 as specified in <ref> [Catte91] </ref> due to limitations in the amount of available swap space. Using 125,000 objects eliminated this problem while still providing a database that would not fit into the real memory of the workstations that were used. 4.3.
Reference: [Carey89a] <author> M. Carey et al., </author> <title> "The EXODUS Extensible DBMS Project: An Overview," in Readings in Object-Oriented Databases, </title> <editor> S. Zdonik and D. Maier, eds., Morgan-Kaufman, </editor> <year> 1989. </year>
Reference-contexts: The current implementation of E (E 2.0) uses an interpreter, the E Persistent Virtual Machine (EPVM 1.0), to coordinate access to persistent data [Schuh90] that is stored using the EXODUS Storage Manager <ref> [Carey89a, Carey89b] </ref>. Under the approach taken by EPVM 1.0, memory resident persistent objects are cached in the buffer pool of the EXODUS Storage Manager (ESM) and persistent objects are accessed in-place. In addition, EPVM 1.0 provides support for a limited form of pointer swizzling. <p> Next, the interface function returns a data structure to the application, known as a user descriptor <ref> [Carey89a] </ref>, that contains a pointer to the object. The application can then read values in the object any number of times by following the pointer contained in the user descriptor.
Reference: [Carey89b] <author> M. Carey et al., </author> <title> "Storage Management for Objects in EXODUS," in Object-Oriented Concepts, Databases, and Applications, </title> <editor> W. Kim and F. Lochovsky, eds., </editor> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The current implementation of E (E 2.0) uses an interpreter, the E Persistent Virtual Machine (EPVM 1.0), to coordinate access to persistent data [Schuh90] that is stored using the EXODUS Storage Manager <ref> [Carey89a, Carey89b] </ref>. Under the approach taken by EPVM 1.0, memory resident persistent objects are cached in the buffer pool of the EXODUS Storage Manager (ESM) and persistent objects are accessed in-place. In addition, EPVM 1.0 provides support for a limited form of pointer swizzling.
Reference: [Cock84] <author> P. Cockshott et al., </author> <title> "Persistent Object Management System," </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 14, </volume> <pages> pp. 49-71, </pages> <year> 1984 </year>
Reference-contexts: Some early work on software implementations of pointer swizzling was done as part of an implementation of PS-Algol <ref> [Atkin83, Cock84] </ref>.
Reference: [Exodu92] <institution> Using the EXODUS Storage Manager V2.0.2, technical documentation, Department of Computer Sciences, University of Wisconsin-Madison, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: All of the systems included in the study are based on a client/server architecture and feature full support for transactions, concurrency control, and recovery. The client/server version of ESM <ref> [Frank92, Exodu92] </ref> was used to store persistent data for the experiments based on EPVM 2.0, EPVM 1.0, and C++. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh This research was funded by the Defense Advanced Research Projects Agency under contract DAAB07-92-C-Q508. The remainder of the paper is organized as follows.
Reference: [Frank92] <author> M. Franklin et al., </author> <title> "Crash Recovery in Client-Server EXODUS", </title> <booktitle> Proc. ACM SIGMOD Int'l Conf. on Management of Data, </booktitle> <address> San Diego, California, </address> <year> 1992. </year>
Reference-contexts: All of the systems included in the study are based on a client/server architecture and feature full support for transactions, concurrency control, and recovery. The client/server version of ESM <ref> [Frank92, Exodu92] </ref> was used to store persistent data for the experiments based on EPVM 2.0, EPVM 1.0, and C++. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh This research was funded by the Defense Advanced Research Projects Agency under contract DAAB07-92-C-Q508. The remainder of the paper is organized as follows. <p> However, the client must communicate with the server to reacquire locks for cached pages that are accessed in succeeding transactions. Transaction commit involves shipping dirty data pages and log pages back to the server, writing log pages to disk, and releasing locks <ref> [Frank92] </ref>. In the future, ESM will support "callbacks" from the server to the client. This will allow inter-transaction caching of locks at the client and eliminate the need to ship dirty data pages back to the server during transaction commit. No pointer swizzling is done in this architecture.
Reference: [Lamb91] <author> C. Lamb, G. Landis, J. Orenstein, D. Weinreb, </author> <title> "The ObjectStore Database System", </title> <journal> CACM, </journal> <volume> Vol. 34, No. 10, </volume> <month> October </month> <year> 1991 </year>
Reference-contexts: This ensures that there are no dangling references to objects that are no longer resident in memory. A pointer swizzling scheme based on virtual memory techniques is described in [Wilso90]. A similar approach is used in Object Design's ObjectStore <ref> [Objec90, Lamb91] </ref>. The basic idea presented in [Wilso90] is to allocate virtual memory addresses for pages containing persistent data one step ahead of a program's actual usage of the pages. When a program first attempts to access a page, a virtual memory page fault occurs. <p> Again, a 5 megabyte server buffer pool was used for all of the experiments. The version referred to as PC1M does pointer swizzling, while the version labeled PC1M-NO does not. The fourth architecture examined was that of ObjectStore V1.2 1 <ref> [Lamb91] </ref>. Like ESM, ObjectStore uses a client/server architecture in which both the client and server processes buffer recently accessed pages of objects. All interaction between the client and server in ObjectStore was set to take place at the granularity of individual pages, just as in ESM. <p> ObjectStore features basically the same transaction facilities as ESM, i.e. recovery for updates in the event of client or server failure, page level locking, and transaction rollback. ObjectStore also supports inter-transaction caching of persistent data in the client's main memory <ref> [Lamb91] </ref>. Callback messages are sent by the server to clients in order to maintain the coherence of cached data. This allows the ObjectStore client to cache locks between transactions as well as data pages.
Reference: [Moss90] <author> J. Eliot B. Moss, </author> <title> Working with Persistent Objects: To Swizzle or Not to Swizzle, </title> <type> COINS Object-Oriented Systems Laboratory Technical Report 90-38, </type> <institution> University of Massachusetts at Amherst, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: Some early work on software implementations of pointer swizzling was done as part of an implementation of PS-Algol [Atkin83, Cock84]. This approach also used pointer dereferences to trigger the transfer of objects from secondary storage into main memory. <ref> [Moss90] </ref> presents a more recent study of software swizzling techniques, and also examines the issue of storing persistent objects in the buffer pool of the object manager versus copying them into virtual memory. [Moss90] takes an object-at-a-time approach to swizzling in which objects that are in memory are classified as either <p> approach also used pointer dereferences to trigger the transfer of objects from secondary storage into main memory. <ref> [Moss90] </ref> presents a more recent study of software swizzling techniques, and also examines the issue of storing persistent objects in the buffer pool of the object manager versus copying them into virtual memory. [Moss90] takes an object-at-a-time approach to swizzling in which objects that are in memory are classified as either swizzled or unswizzled. Under this approach, all pointers in an unswizzled object are swizzled immediately upon the first use of the object. <p> Software checks are used to distinguish swizzled and unswizzled pointers. This seems reasonable since the price of such checks should be a very small part of overall program execution time; a fact that has been independently confirmed in <ref> [Moss90] </ref>. Furthermore, it is possible to do standard kinds of compiler optimizations to eliminate checks from a program (though the E compiler currently does not do this). The software approach combines efficiency with portability, and provides a flexible environment for conducting further research. <p> The software approach combines efficiency with portability, and provides a flexible environment for conducting further research. The swizzling scheme used in EPVM 2.0 is further characterized by the fact that it swizzles pointers one-at-a-time, as opposed to the approach described in [Wilso90] which swizzles a page-at-a-time, and <ref> [Moss90] </ref> which swizzles Page Hash TableOID Hash Table Large Object List 0 0 0 0 Large Object Page 1 Small Object Large Object Page 2 Small Object 0 pointers at the granularity of objects. <p> The type of swizzling scheme used by EPVM 2.0 is referred to as an 'edge marking' scheme in <ref> [Moss90] </ref>. Implementation Strategy Since pointers are swizzled dynamically during program execution, the key decision that must be made is when during execution to actually do the swizzling. One possibility is to swizzle pointers when they are dereferenced.
Reference: [Objec90] <institution> Object Design, Inc., </institution> <note> ObjectStore User Guide, Release 1.0, </note> <month> October </month> <year> 1990. </year>
Reference-contexts: To help evaluate the effectiveness of the design of EPVM 2.0 this paper presents the results of a number of performance experiments that were conducted using the OO1 benchmark [Catte91]. The experiments compare EPVM 2.0 with three alternative software architectures. The first of these is ObjectStore V1.2 <ref> [Objec90] </ref>, a commercially available object-oriented DBMS. ObjectStore uses a memory-mapped approach to support pointer swizzling and fault objects into main memory. The second architecture is represented by EPVM 1.0 which supports only a limited form of pointer swiz-zling. <p> This ensures that there are no dangling references to objects that are no longer resident in memory. A pointer swizzling scheme based on virtual memory techniques is described in [Wilso90]. A similar approach is used in Object Design's ObjectStore <ref> [Objec90, Lamb91] </ref>. The basic idea presented in [Wilso90] is to allocate virtual memory addresses for pages containing persistent data one step ahead of a program's actual usage of the pages. When a program first attempts to access a page, a virtual memory page fault occurs. <p> This is because swizzling and unswizzling are done at the granularity of individual pages, and it is unlikely that most programs will use all of the pointers located on each page. <ref> [Objec90] </ref> describes an extension of the basic technique that can avoid this problem by eliminating the need to swizzle and unswiz-zle pointers in many cases. In effect, pointers are always stored in their swizzled format in [Objec90]. 3. EPVM 2.0 Design Concepts 3.1. <p> unlikely that most programs will use all of the pointers located on each page. <ref> [Objec90] </ref> describes an extension of the basic technique that can avoid this problem by eliminating the need to swizzle and unswiz-zle pointers in many cases. In effect, pointers are always stored in their swizzled format in [Objec90]. 3. EPVM 2.0 Design Concepts 3.1. Object Caching As mentioned in Section 1, ESM is used to provide disk storage for the persistent objects that are accessible to an E program. EPVM 2.0 copies objects from the ESM client buffer pool into virtual memory as they are accessed.
Reference: [Orens92] <author> J. </author> <title> Orenstein, </title> <type> personal communication, </type> <month> May </month> <year> 1992. </year>
Reference-contexts: Callback messages are sent by the server to clients in order to maintain the coherence of cached data. This allows the ObjectStore client to cache locks between transactions as well as data pages. To efficiently support callbacks, the ObjectStore client is divided into two processes <ref> [Orens92] </ref>: a callback process, and an application process. When only a single client is connected with the server, the two-process architecture does not have a noticeable effect on performance since the application process communicates directly with the server to obtain data pages and locks on those pages. <p> OS is surprisingly 12% slower than EPVM1 in the warm iteration. As with the cold iteration, this is likely due to data mapping costs <ref> [Orens92] </ref>. In Table 6 OC1M has the worst performance in the cold iteration because it performs more I/O operations. PC1M is a little slower than OC5M due to the overhead of copying full pages. Swizzling makes no difference for PC1M in the cold iteration.
Reference: [Rich89] <author> J. Richardson, M. Carey, and D. Schuh, </author> <title> The Design of the E Programming Language, </title> <type> Technical Report No. 824, </type> <institution> Computer Sciences Dept., University of Wisconsin, </institution> <month> Feb. </month> <year> 1989. </year>
Reference-contexts: 1. Introduction E is a persistent programming language <ref> [Rich89, Rich90] </ref> that was originally designed to ease the implementation of data-intensive software applications, such as database management systems, that require access to huge amounts of persistent data.
Reference: [Rich90] <author> J. Richardson, </author> <title> "Compiled Item Faulting," </title> <booktitle> Proc. of the 4th Int'l. Workshop on Persistent Object Systems, </booktitle> <address> Martha's Vineyard, MA, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: 1. Introduction E is a persistent programming language <ref> [Rich89, Rich90] </ref> that was originally designed to ease the implementation of data-intensive software applications, such as database management systems, that require access to huge amounts of persistent data.
Reference: [Schuh90] <author> D. Schuh, M. Carey, and D. Dewitt, </author> <title> Persistence in E Revisited---Implementation Experiences, in Implementing Persistent Object Bases Principles and Practice, </title> <booktitle> The Fourth International Workshop on Persistent Object Systems. </booktitle>
Reference-contexts: The current implementation of E (E 2.0) uses an interpreter, the E Persistent Virtual Machine (EPVM 1.0), to coordinate access to persistent data <ref> [Schuh90] </ref> that is stored using the EXODUS Storage Manager [Carey89a, Carey89b]. Under the approach taken by EPVM 1.0, memory resident persistent objects are cached in the buffer pool of the EXODUS Storage Manager (ESM) and persistent objects are accessed in-place. <p> In particular, unswizzled objects, while they are memory resident, have by definition not been referenced. A restricted form of pointer swizzling is supported by EPVM 1.0 <ref> [Schuh90] </ref>. Since it maintains memory resident objects in the ESM buffer pool, swizzling inter-object pointer references is difficult to implement efficiently. Hence, only local program variables that are pointers to persistent objects are swizzled. <p> No pointer swizzling is done in this architecture. A single software version based on this architecture was used (referred to as CESM). The size of the ESM client and server buffer pools was 5 megabytes. The second architecture represents the approach taken by EPVM 1.0 <ref> [Schuh90] </ref>. Figure 6 shows the client portion of this architecture (The server portion is identical to the server shown in Figure 5). EPVM 1.0 avoids calls to the storage manager by maintaining a cache of worthy objects in the ESM client buffer pool. Objects are accessed in the following way.
Reference: [Wilso90] <author> Paul R. Wilson, </author> <title> Pointer Swizzling at Page Fault Time: Efficiently Supporting Huge Address Spaces on Standard Hardware, </title> <type> Technical Report UIC-EECS-90-6, </type> <institution> University of Illi-nois at Chicago, </institution> <month> December </month> <year> 1990. </year> <title> Acknowledgements We wish to thank Jack Orenstein, Dan Weinreb, and Benson Mar-gulies of Object Design, Inc. for their many helpful comments and feedback concerning the results presented in the paper. Special thanks should be given to Dan Schuh who implemented EPVM 1.0 and the E compiler. Mike Zwilling and Mike Franklin implemented the ARIES based recovery algorithm used in the EXODUS storage manager. Nancy Hall implemented inter-transaction caching. </title>
Reference-contexts: This causes the objects that the pointers reference to be faulted into memory and marked as unswizzled. Finally, the initial object is marked as swizzled. One advantage of this approach over that of <ref> [Wilso90] </ref> (see below) is that it should generally perform less unnecessary swizzling and unswizzling work. A disadvantage, however, is that objects that are not accessed by a program can be faulted into memory by the swizzling mechanism, resulting in unnecessary I/O operations. <p> This ensures that there are no dangling references to objects that are no longer resident in memory. A pointer swizzling scheme based on virtual memory techniques is described in <ref> [Wilso90] </ref>. A similar approach is used in Object Design's ObjectStore [Objec90, Lamb91]. The basic idea presented in [Wilso90] is to allocate virtual memory addresses for pages containing persistent data one step ahead of a program's actual usage of the pages. <p> This ensures that there are no dangling references to objects that are no longer resident in memory. A pointer swizzling scheme based on virtual memory techniques is described in <ref> [Wilso90] </ref>. A similar approach is used in Object Design's ObjectStore [Objec90, Lamb91]. The basic idea presented in [Wilso90] is to allocate virtual memory addresses for pages containing persistent data one step ahead of a program's actual usage of the pages. When a program first attempts to access a page, a virtual memory page fault occurs. <p> Objects that span multiple pages in virtual memory can be handled transparently as long as sufficient contiguous virtual memory address space can be reserved for the entire object. A disadvantage of the basic approach described in <ref> [Wilso90] </ref> is that programs may incur unnecessary swizzling and unswizzling overhead. <p> The software approach combines efficiency with portability, and provides a flexible environment for conducting further research. The swizzling scheme used in EPVM 2.0 is further characterized by the fact that it swizzles pointers one-at-a-time, as opposed to the approach described in <ref> [Wilso90] </ref> which swizzles a page-at-a-time, and [Moss90] which swizzles Page Hash TableOID Hash Table Large Object List 0 0 0 0 Large Object Page 1 Small Object Large Object Page 2 Small Object 0 pointers at the granularity of objects.
References-found: 15

