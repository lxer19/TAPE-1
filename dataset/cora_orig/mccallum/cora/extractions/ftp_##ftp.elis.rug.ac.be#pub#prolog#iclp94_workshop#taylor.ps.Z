URL: ftp://ftp.elis.rug.ac.be/pub/prolog/iclp94_workshop/taylor.ps.Z
Refering-URL: http://www.informatik.uni-trier.de/~ley/db/conf/iclp/iclp94-w1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: e-mail: hamish@cee.hw.ac.uk  
Title: Design of a Resolution Multiprocessor for the Parallel Virtual Machine  
Author: Hamish Taylor 
Keyword: Prolog, PVM, X Window, evolutionary, message passing, process based  
Address: Edinburgh EH14 4AS, Britain  
Affiliation: Department of Computing and Electrical Engineering Heriot-Watt University,  
Abstract: PAN is a process based Prolog system running in a distributed manner on the nodes of a virtual multiprocessor. It was designed to be a general purpose parallel logic programming system that would be resilient to software and hardware evolution. Programs can explicitly control parallelism through passing general terms synchronously or asynchronously among PAN's Prolog engines. Alternatively several forms of parallelism can be implicitly extracted by compilation techniques and runtime scheduling on top of this architecture. The computational platform or Parallel Virtual Machine is a meshed set of daemons on a network of heterogeneous workstations offering common message passing, configuration and job control services. PAN is presented to users under X Window as a multi-headed extension of single processor Prolog systems. An interface to each Prolog engine is displayed in a separate X widget together with a console window to the PVM, and window based methods are supported for simultaneously invoking all engines together.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K.A.M. Ali and R. Karlsson. </author> <title> Full prolog and scheduling or-parallelism in muse. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 19(6) </volume> <pages> 445-475, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Implicitly parallel Prologs extract various opportunities for parallel execution transparently at the resolution processing level in a data or demand driven manner. For example or-parallelism is exploited implicitly by Muse <ref> [1] </ref>, independent and-parallelism by &-Prolog [10] and stream and-parallelism by Parallel NU Prolog [12]. Combinations of forms of parallelism are also being exploited such as or-parallelism and deterministic and-parallelism by Andorra I [5]. However, such capabilities usually require major alterations to conventional sequential Prolog engine technology particularly to manage memory.
Reference: [2] <author> K. De Bosschere and J-M. Jacquet. Multi-prolog: </author> <title> Definition, operational semantics and implementation. </title> <editor> In D.S. Warren, editor, </editor> <booktitle> Proceedings of 10th International Conference on Logic Programming, </booktitle> <pages> pages 299-313. </pages> <publisher> MIT Press, </publisher> <address> Budapest, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction Interest in process based logic programming systems featuring explicit communication and distributed execution has recently revived <ref> [2] </ref>, [15], although research has been continuing in this area over the years [6], [8]. This type of approach to developing parallel logic programming systems is not as promising for exploiting parallelism as more specialised approaches such as [11]. <p> Blackboard based logic programming systems usually follow the LINDA model [3]. A shared tuple space serves as the message exchange zone and Linda operations on the tuple space coordinate and organise the multiple threads of execution. Representative examples of blackboard based logic programming systems include Multi-Prolog <ref> [2] </ref> and Prolog-D-Linda [13]. Such systems provide appealingly expressive ways for explicitly controlling multiple threads of resolution. However, the reliance such systems place in communicating via a shared store builds in a contention bottleneck that is a threat to their scalability.
Reference: [3] <author> N. Carriero and D. Gelernter. </author> <title> Linda in context. </title> <journal> Communications of the ACM, </journal> <volume> 32(4) </volume> <pages> 444-459, </pages> <year> 1989. </year>
Reference-contexts: Communication among process based Prologs tends either to be * blackboard * message based depending upon whether it is done through a shared store or by explicit message passing. Blackboard based logic programming systems usually follow the LINDA model <ref> [3] </ref>. A shared tuple space serves as the message exchange zone and Linda operations on the tuple space coordinate and organise the multiple threads of execution. Representative examples of blackboard based logic programming systems include Multi-Prolog [2] and Prolog-D-Linda [13].
Reference: [4] <author> D. Chu and K. Clark. </author> <title> I.C. Prolog II: a Multi-threaded Prolog System. </title> <institution> Department of Computing, Imperial College, </institution> <address> London, </address> <month> 31 May </month> <year> 1993. </year>
Reference-contexts: However, Prolog is more 2 expressive, generally familiar, and suitable for the most relevant class of applications, knowledge based systems, than languages like KL1, FCP or PARLOG. Mixing the two different styles of resolution engines would also have been an attractive possibility to enhance functionality [14] <ref> [4] </ref>, but would have created significant extra complexities in mediating interactions among the different styles of resolution.
Reference: [5] <author> V. Santos Costa, D.H.D. Warren, and R. Yang. </author> <title> The andorra-i engine: A parallel implementation of the basic andorra model. </title> <booktitle> In Proceedings of 8th International Conference on Logic Programming, </booktitle> <pages> pages 825-839. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: For example or-parallelism is exploited implicitly by Muse [1], independent and-parallelism by &-Prolog [10] and stream and-parallelism by Parallel NU Prolog [12]. Combinations of forms of parallelism are also being exploited such as or-parallelism and deterministic and-parallelism by Andorra I <ref> [5] </ref>. However, such capabilities usually require major alterations to conventional sequential Prolog engine technology particularly to manage memory. Thus while impressive speedup results can be obtained, such systems are not robust to evolution in their enabling technologies and require substantial maintenance effort to remain state of the art.
Reference: [6] <author> J.C. Cunha, P.D. Medeiros, M.B. Carvalhosa, and L.M. Pereira. </author> <title> Delta prolog: A distributed logic programming language and its implementation on distributed memory multiprocessors. </title> <editor> In P. Kacsuk and M.J. Wise, editors, </editor> <booktitle> Implementations of Distributed Prolog, </booktitle> <pages> pages 335-356. </pages> <publisher> John Wiley, </publisher> <address> Chichester, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Interest in process based logic programming systems featuring explicit communication and distributed execution has recently revived [2], [15], although research has been continuing in this area over the years <ref> [6] </ref>, [8]. This type of approach to developing parallel logic programming systems is not as promising for exploiting parallelism as more specialised approaches such as [11].
Reference: [7] <author> S.K. Debray, N-W. Lin, and M. Hermenegildo. </author> <title> Task granularity analysis in logic programs. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Programming Language Design and Implementation. </booktitle> <publisher> ACM Press, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Since the grain of parallelism is not readily flexible at a reasonable cost, efficient multiprocessing dictates exploiting parallelism in only a coarse grained manner. Granularity analysis of logic programs at compile time would be an important aid to doing this most effectively <ref> [7] </ref>. The choice of existing message passing Prologs to support only a synchronous style of message reception is also curious.
Reference: [8] <author> S. Ferenczi and I. Futo. CS-prolog: </author> <title> A communicating sequential prolog. </title> <editor> In P. Kacsuk and M.J. Wise, editors, </editor> <booktitle> Implementations of Distributed Prolog, </booktitle> <pages> pages 357-378. </pages> <publisher> John Wiley, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Interest in process based logic programming systems featuring explicit communication and distributed execution has recently revived [2], [15], although research has been continuing in this area over the years [6], <ref> [8] </ref>. This type of approach to developing parallel logic programming systems is not as promising for exploiting parallelism as more specialised approaches such as [11]. <p> They also avoid the inefficiency of making all interprocess communication indirect. They are not quite as expressive, because they force users to address all messages or consign them to 3 named channels, but in practice this drawback can be finessed. Representative examples include CS-Prolog <ref> [8] </ref> and PMS-Prolog [15]. A common design choice of such Prologs has been to support dynamic process creation and to adopt a purely synchronous style of message reception. Dynamic process creation provides flexibility and expressiveness but has rather high overheads, since it is normally realised by forking and overlaying processes.
Reference: [9] <author> A. Geist, A. Beguelin, J. Dongarra, W. Jiang, R. Manchek, and Vaidy Sunderam. </author> <title> PVM 3.0 User's Guide and Reference Manual. </title> <institution> Oak Ridge Nat. Lab., Tennessee, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Expressiveness and functionality can be maintained by supporting asynchronous communication as well. However, PAN needs further support if it is also to be resilient to platform evolution. 2.3 Virtual Multiprocessor The Parallel Virtual Machine or PVM <ref> [9] </ref> is a widely used virtual multiprocessor that runs on many different kinds of platforms. It allows a heterogeneous network of parallel and serial computers to appear as a single concurrent computational resource.
Reference: [10] <author> M.V. Hermenegildo and K.J. Greene. </author> <title> &-prolog and its performance: Exploiting independent and-parallelism. </title> <booktitle> In Proceedings of the 7th International Conference on Logic Programming, </booktitle> <pages> pages 253-268. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Implicitly parallel Prologs extract various opportunities for parallel execution transparently at the resolution processing level in a data or demand driven manner. For example or-parallelism is exploited implicitly by Muse [1], independent and-parallelism by &-Prolog <ref> [10] </ref> and stream and-parallelism by Parallel NU Prolog [12]. Combinations of forms of parallelism are also being exploited such as or-parallelism and deterministic and-parallelism by Andorra I [5]. However, such capabilities usually require major alterations to conventional sequential Prolog engine technology particularly to manage memory.
Reference: [11] <author> P. Kacsuk. </author> <title> Execution Models of Prolog for Parallel Computers. </title> <publisher> Pitman, </publisher> <address> London, </address> <year> 1990. </year>
Reference-contexts: This type of approach to developing parallel logic programming systems is not as promising for exploiting parallelism as more specialised approaches such as <ref> [11] </ref>. However, it substantially reduces the effort required to build such systems, and avoids making the systems architecture so special that evolution in enabling technologies will soon render it out of date.
Reference: [12] <editor> L. Naish. Parallelizing nu-prolog. In R.A. Kowalski and K.A. Bowen, editors, </editor> <booktitle> Proceedings of the 5th International Conference/Symposium on Logic Programming, </booktitle> <pages> pages 1546-1564. </pages> <publisher> MIT Press, </publisher> <address> Seattle, Washington, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: Implicitly parallel Prologs extract various opportunities for parallel execution transparently at the resolution processing level in a data or demand driven manner. For example or-parallelism is exploited implicitly by Muse [1], independent and-parallelism by &-Prolog [10] and stream and-parallelism by Parallel NU Prolog <ref> [12] </ref>. Combinations of forms of parallelism are also being exploited such as or-parallelism and deterministic and-parallelism by Andorra I [5]. However, such capabilities usually require major alterations to conventional sequential Prolog engine technology particularly to manage memory.
Reference: [13] <author> G. Sutcliffe. </author> <title> Prolog-d-linda v2 : A new embedding of linda in SICStus prolog. </title> <editor> In K. De Bosschere, J-M. Jacquet, and P. Tarau, editors, </editor> <booktitle> Proceedings of ICLP'93 Conference Workshop on Blackboard Based Logic Programming, </booktitle> <pages> pages 105-117. </pages> <address> ICLP'93, Budapest, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Blackboard based logic programming systems usually follow the LINDA model [3]. A shared tuple space serves as the message exchange zone and Linda operations on the tuple space coordinate and organise the multiple threads of execution. Representative examples of blackboard based logic programming systems include Multi-Prolog [2] and Prolog-D-Linda <ref> [13] </ref>. Such systems provide appealingly expressive ways for explicitly controlling multiple threads of resolution. However, the reliance such systems place in communicating via a shared store builds in a contention bottleneck that is a threat to their scalability.
Reference: [14] <author> H. Taylor. </author> <title> Coupling committed and trial binding resolution engines. </title> <journal> In Data and Knowledge Engineering, </journal> <volume> volume 6, </volume> <pages> pages 159-178. </pages> <publisher> North-Holland, </publisher> <year> 1991. </year>
Reference-contexts: However, Prolog is more 2 expressive, generally familiar, and suitable for the most relevant class of applications, knowledge based systems, than languages like KL1, FCP or PARLOG. Mixing the two different styles of resolution engines would also have been an attractive possibility to enhance functionality <ref> [14] </ref> [4], but would have created significant extra complexities in mediating interactions among the different styles of resolution.
Reference: [15] <author> M.J. Wise, D.G. Jones, and T. Hintz. PMS-prolog: </author> <title> A distributed, coarse-grain-parallel prolog with processes, modules and streams. </title> <editor> In P. Kacsuk and M.J. Wise, editors, </editor> <booktitle> Implementations of Distributed Prolog, </booktitle> <pages> pages 379-404. </pages> <publisher> John Wiley, </publisher> <address> Chichester, </address> <year> 1992. </year> <month> 10 </month>
Reference-contexts: 1 Introduction Interest in process based logic programming systems featuring explicit communication and distributed execution has recently revived [2], <ref> [15] </ref>, although research has been continuing in this area over the years [6], [8]. This type of approach to developing parallel logic programming systems is not as promising for exploiting parallelism as more specialised approaches such as [11]. <p> They also avoid the inefficiency of making all interprocess communication indirect. They are not quite as expressive, because they force users to address all messages or consign them to 3 named channels, but in practice this drawback can be finessed. Representative examples include CS-Prolog [8] and PMS-Prolog <ref> [15] </ref>. A common design choice of such Prologs has been to support dynamic process creation and to adopt a purely synchronous style of message reception. Dynamic process creation provides flexibility and expressiveness but has rather high overheads, since it is normally realised by forking and overlaying processes. <p> Unbound variables in communicated terms are allowed but get freshly renamed on reception to ensure all variables have purely local scope. PAN follows PMS-Prolog's reasons <ref> [15] </ref> in not supporting any form of backtracking on communication.
References-found: 15

