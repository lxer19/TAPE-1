URL: http://www-ccs.cs.umass.edu/db/publications/UM-CS-1995-090.ps
Refering-URL: http://www-ccs.cs.umass.edu/db/lang.html
Root-URL: 
Email: fcris,krithig@cs.umass.edu  
Title: Delegation: Efficiently Rewriting History  
Author: Cris Pedregal Martin and Krithi Ramamritham 
Keyword: Extended Transaction Models, Transaction Management, Recovery.  
Note: Supported in part by grants from Sun Microsystems and the National Science Foundation.  
Address: Amherst, Mass. 01003-4610  
Affiliation: Department of Computer Science University of Massachusetts  
Abstract: Technical Report 1995-090 October 26, 1995 Abstract The notion of transaction delegation, as introduced in ACTA, allows a transaction to transfer responsibility for the operations that it has performed on an object to another transaction. Delegation can be used to broaden the visibility of the delegatee, and to tailor the recovery properties of a transaction model. Delegation has been shown to be useful in synthesizing Extended Transaction Models. With an efficient implementation of delegation it becomes practicable to realize various Extended Transaction Models whose requirements are specified at a high level language instead of the current expensive practice of building them from scratch. In this paper we identify the issues in efficiently supporting delegation and hence extended transaction models, and illustrate our solution in ARIES, an industrial-quality system that uses undo/redo recovery. Since delegation is tantamount to rewriting history, a nave implementation entails frequent and costly log accesses, and complicates recovery protocols. Our algorithm achieves the effect of rewriting history without rewriting the history, i.e., the log, resulting in implementations that realize the semantics of delegation at minimal additional overhead and incur no overhead when delegation is not used. Besides showing its efficient application to ARIES, we also show the correctness of the implementation of delegation. Our work indicates that it is feasible to build efficient and robust, general-purpose machinery for Extended Transaction Models. It also leads toward making recovery a first-class concept within Extended Transaction Models. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Roger S. Barga and Calton Pu. </author> <title> A Practical and Modular Implementation of Extended Transaction Models. </title> <booktitle> In Proceedings of the 21st International Conference on Very Large Data Bases, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: This may allow for initial gains in performance, but we believe that the use of language primitives is a richer and more flexible approach. The recent work of Barga and Pu <ref> [1] </ref>, also inspired in part by ACTA, explores another modular approach, based on the ideas of metaobject protocols [13], and incorporates some elements of the TSME approach and some of our language-based approach. 24 Also related is the work on the ConTract model [20].
Reference: [2] <author> Philip A. Bernstein, Vassos Hadzilacos, and Nathan Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mass. </address> <year> 1987. </year>
Reference-contexts: To that end, we augment Transaction List and each transaction's Object List found in conventional DBSs. We also add a delegate type log record. Tr List. We use the standard Transaction List T r List <ref> [2, 12, 14] </ref> that contains, for each Trans-ID, the LSN for the most recent record written on behalf of that transaction, and, during recovery, whether a transaction is a winner or a loser (see 3.3).
Reference: [3] <author> Philip A. Bernstein, Per O. Gyllstrom, and Tom Wimberg. </author> <title> STDL A Portable Language for Transaction Processing. </title> <booktitle> In Proceedings of the 19th International Conference on Very Large Databases, </booktitle> <pages> pages 218-229, </pages> <address> Dublin, </address> <year> 1993. </year>
Reference-contexts: But ConTract scripts introduce their own control flow syntax, while ASSET introduces a small set of transaction management primitives that can be embedded in a host language. Other related work also includes Structured Transaction Definition Language <ref> [3] </ref>, a persistent programming language geared to portability and the integration of legacy applications. Its emphasis, however, is in Application Programming Interfaces conforming to existing conventional transactional technology.
Reference: [4] <author> A. Biliris, E. Panagos. </author> <title> EOS User's Guide. </title> <institution> AT&T Bell Labs Report, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: Specifically, to further the goal of providing general purpose machinery to support the specification and implementation of arbitrary Extended Transaction Models, we propose here an efficient implementation of delegation based on ARIES [14].(Also, we briefly suggest how to implement delegation on EOS <ref> [4] </ref>.) Our additions allow the "efficient Rewriting of History." We hence call our implementation ARIES/RH. By providing delegation, we add substantial semantic power to a conventional Transaction Management System, allowing it to capture various Extended Transaction Models. <p> The set of scopes Cluster is searched by invoking transaction, gains scopes to the left and loses scopes to the right. A binary tree keyed on transaction ids is a reasonable implementation. 3.7 Implementing delegation in EOS Rewriting History can be applied to other recovery algorithms, for instance, EOS <ref> [4] </ref>, which uses a no-undo/redo protocol. Next, we give an overview of EOS and then discuss briefly how to apply RH to implement delegation. To avoid having to undo changes in the database, EOS avoids applying those changes until the transaction that made them is ready to commit.
Reference: [5] <author> A. Biliris, S. Dar, N. Gehani, H. V. Jagadish, K. Ramamritham. </author> <title> ASSET: A System for Supporting Extended Transactions. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data , Minneapolis, Minn., </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: A first step was ACTA [6], that identified, in a formal framework, the essential components of Extended Transaction Models. In more operational terms, ASSET <ref> [5] </ref> provided a set of new language primitives that enable the realization of various Extended Transaction Models in an object-oriented database setting. <p> Examples of Extended Transaction Models that can be synthesized using delegate are Joint Transactions, Nested Transactions, Split Transactions, and Open Nested Transactions [6, 11]. Biliris et al. <ref> [5] </ref> gave a high-level description of how to realize the three new ASSET primitives. Briefly, permit is done by suitably adding the permittee transaction to the object's access descriptor. Form-dependency is done by adding edges to the dependency graph, after checking for certain cycles. <p> With delegation (and the other two ASSET primitives, permit and form-dependency <ref> [5] </ref>) we believe we can offer the flexibility to synthesize a wide range of ETMs at a performance comparable to that of tailor-made implementations. Delegation, by allowing changes in the visibility and recovery properties of transactions, is a very useful primitive for synthesizing Extended Transaction Models. <p> Delegation, by allowing changes in the visibility and recovery properties of transactions, is a very useful primitive for synthesizing Extended Transaction Models. Our work builds on the formal foundation provided by ACTA [6, 7, 8], and the primitives introduced in ASSET <ref> [5] </ref>. The main contribution of this paper is the concept of rewriting history (RH), designed to achieve the semantics of delegation in an efficient and robust manner.
Reference: [6] <author> P. K. Chrysantis and Krithi Ramamritham. </author> <title> Synthesis of Extended Transaction Models using ACTA. </title> <journal> ACM Trans. on Database Systems, </journal> <month> September </month> <year> 1994. </year>
Reference-contexts: Our strategy has been to work from first principles, first identifying the basic elements that give rise to different models and showing how to realize various Extended Transaction Models using these elements, and then proposing mechanisms for implementing these elements. A first step was ACTA <ref> [6] </ref>, that identified, in a formal framework, the essential components of Extended Transaction Models. In more operational terms, ASSET [5] provided a set of new language primitives that enable the realization of various Extended Transaction Models in an object-oriented database setting. <p> Examples of Extended Transaction Models that can be synthesized using delegate are Joint Transactions, Nested Transactions, Split Transactions, and Open Nested Transactions <ref> [6, 11] </ref>. Biliris et al. [5] gave a high-level description of how to realize the three new ASSET primitives. Briefly, permit is done by suitably adding the permittee transaction to the object's access descriptor. Form-dependency is done by adding edges to the dependency graph, after checking for certain cycles. <p> Delegation, by allowing changes in the visibility and recovery properties of transactions, is a very useful primitive for synthesizing Extended Transaction Models. Our work builds on the formal foundation provided by ACTA <ref> [6, 7, 8] </ref>, and the primitives introduced in ASSET [5]. The main contribution of this paper is the concept of rewriting history (RH), designed to achieve the semantics of delegation in an efficient and robust manner.
Reference: [7] <author> P. K. Chrysanthis. </author> <title> ACTA, A Framework for Modeling and Reasoning about Extended Transactions. </title> <type> Computer Science TR 91-90. PhD thesis, </type> <institution> Department of Computer and Information Science, University of Massachusetts, </institution> <address> Amherst, Mass., </address> <month> September </month> <year> 1991. </year>
Reference-contexts: In the remainder of this section we show the code for split and nested transactions, synthesized using delegation and the other ASSET primitives. Other transaction models using delegation include Reporting Transactions and Co-Transactions described in <ref> [7, 8] </ref>. The former periodically reports to other transactions by delegating its current results. <p> Delegation, by allowing changes in the visibility and recovery properties of transactions, is a very useful primitive for synthesizing Extended Transaction Models. Our work builds on the formal foundation provided by ACTA <ref> [6, 7, 8] </ref>, and the primitives introduced in ASSET [5]. The main contribution of this paper is the concept of rewriting history (RH), designed to achieve the semantics of delegation in an efficient and robust manner.
Reference: [8] <author> P. K. Chrysantis, and Krithi Ramamritham. </author> <title> Delegation in ACTA as a Means to Control Sharing in Extended Transactions. </title> <journal> IEEE Data Engineering, </journal> <volume> 16(2): </volume> <pages> 16-19, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: In the remainder of this section we show the code for split and nested transactions, synthesized using delegation and the other ASSET primitives. Other transaction models using delegation include Reporting Transactions and Co-Transactions described in <ref> [7, 8] </ref>. The former periodically reports to other transactions by delegating its current results. <p> Delegation, by allowing changes in the visibility and recovery properties of transactions, is a very useful primitive for synthesizing Extended Transaction Models. Our work builds on the formal foundation provided by ACTA <ref> [6, 7, 8] </ref>, and the primitives introduced in ASSET [5]. The main contribution of this paper is the concept of rewriting history (RH), designed to achieve the semantics of delegation in an efficient and robust manner.
Reference: [9] <author> D. Georgakopoulos, M. Hornick, P. Krychniak, and F. Manola. </author> <title> Specification and Management of Extended Transactions in a Programmable Transaction Environment. </title> <booktitle> In Proceedings of 10th International Conference on Data Engineering, </booktitle> <address> Houston, Tex., </address> <month> February </month> <year> 1994. </year>
Reference-contexts: In summary, the ARIES/RH algorithm adds only minimal overhead to support delegation. 5 Related Work We have benefited from insights gained in an effort with goals closer to ours: the work at GTE Labs on Transaction Specification and Management Environment (TSME, <ref> [9] </ref>). The architecture of TSME consists of a Transaction Specification Facility that understands TSME's transaction specification language, and drives the Transaction Management Mechanism which configures the run-time system to support a specific Extended Transaction Model.
Reference: [10] <editor> A. K. Elmagarmid, editor, </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan Kaufman, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction The transaction model adopted in traditional database systems has proven inadequate for novel applications of growing importance, such as those that involve reactive (endless), open-ended (long-lived), and collaborative (interactive) activities. Various Extended Transaction Models (ETMs) have been proposed <ref> [10] </ref>, each custom built for the application it addresses; alas, no one extension is of universal applicability. To address this problem, we have been investigating how to create general-purpose and robust support for the specification and implementation of diverse Extended Transaction Models.
Reference: [11] <author> Narain Gehani, Krithi Ramamritham, Oded Shmueli. </author> <title> Accessing Extra Database Information: Concurrency Control and Correctness. </title> <institution> Computer Science TR 93-081, University of Massachusetts, Amherst, </institution> <year> 1993. </year> <month> 26 </month>
Reference-contexts: Examples of Extended Transaction Models that can be synthesized using delegate are Joint Transactions, Nested Transactions, Split Transactions, and Open Nested Transactions <ref> [6, 11] </ref>. Biliris et al. [5] gave a high-level description of how to realize the three new ASSET primitives. Briefly, permit is done by suitably adding the permittee transaction to the object's access descriptor. Form-dependency is done by adding edges to the dependency graph, after checking for certain cycles. <p> It is possible to solve the correctness problem by ensuring that each BC switch 2 Extra data: information accessed by transactions that is not part of the database schema; for example, the log, the system clock, wait-for graph. Gehani et al. <ref> [11] </ref> discuss the issues of correctness with extra data. 9 is done atomically. 3 The performance, however, is inherently hostage to the way the log is accessed. Recall that in general the log does not fit into volatile storage.
Reference: [12] <author> Jim Gray and Andreas Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufman, </publisher> <address> San Jose, Calif. </address> <year> 1993. </year>
Reference-contexts: To that end, we augment Transaction List and each transaction's Object List found in conventional DBSs. We also add a delegate type log record. Tr List. We use the standard Transaction List T r List <ref> [2, 12, 14] </ref> that contains, for each Trans-ID, the LSN for the most recent record written on behalf of that transaction, and, during recovery, whether a transaction is a winner or a loser (see 3.3). <p> Write log abort record to the log. 3. flush log. Flush log up to abort record. The other transactional events are processed as usual <ref> [12, 14] </ref>. 3.6 Recovery After a crash, the transaction system must do some recovery processing to return to a consistent state. This entails restoring the state from a checkpoint (retrieved from stable storage), and using the log (also from stable storage) to reproduce the events after the checkpoint was taken.
Reference: [13] <author> Gregor Kiczales, Jim des Rivieres, Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: This may allow for initial gains in performance, but we believe that the use of language primitives is a richer and more flexible approach. The recent work of Barga and Pu [1], also inspired in part by ACTA, explores another modular approach, based on the ideas of metaobject protocols <ref> [13] </ref>, and incorporates some elements of the TSME approach and some of our language-based approach. 24 Also related is the work on the ConTract model [20]. In ConTract, a set of steps define individual transactions; a script is provided to control the execution of these transactions.
Reference: [14] <author> C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh, P. Schwartz. </author> <title> ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging. </title> <journal> In ACM TODS, </journal> <volume> 17(1) </volume> <pages> 94-162, </pages> <year> 1992. </year>
Reference-contexts: To that end, we augment Transaction List and each transaction's Object List found in conventional DBSs. We also add a delegate type log record. Tr List. We use the standard Transaction List T r List <ref> [2, 12, 14] </ref> that contains, for each Trans-ID, the LSN for the most recent record written on behalf of that transaction, and, during recovery, whether a transaction is a winner or a loser (see 3.3). <p> Write log abort record to the log. 3. flush log. Flush log up to abort record. The other transactional events are processed as usual <ref> [12, 14] </ref>. 3.6 Recovery After a crash, the transaction system must do some recovery processing to return to a consistent state. This entails restoring the state from a checkpoint (retrieved from stable storage), and using the log (also from stable storage) to reproduce the events after the checkpoint was taken. <p> Its emphasis, however, is in Application Programming Interfaces conforming to existing conventional transactional technology. Finally, the idea of rewriting history is a natural extension of the repeating history paradigm of ARIES <ref> [14] </ref> and is a generalization of ARIES/NT [19], an extension to ARIES for nested transactions [15]. 6 Conclusions Recent work has produced many Extended Transaction Models (ETMs), but each has its own tailor-made implementation.
Reference: [15] <author> J. Eliot B. Moss. </author> <title> Nested Transactions: An approach to reliable distributed computing. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, Mass., </address> <month> April </month> <year> 1981. </year>
Reference-contexts: Inheritance in Nested Transactions <ref> [15] </ref> is an instance of delegation. Delegation from a child transaction t c to its parent t p occurs when t c commits. This is achieved through the delegation of all the changes done by t c to t p when t c commits. <p> 5 t2 = initiate (f); delegate (self (), t2, ob_set); // self returns t1 begin (t2); t 2 can join t 1 by executing: wait (t2); delegate (t2,t1); // t2 delegates *all* objects 2.2.2 Nested Transactions Nested transactions are among the first extended transaction models; they are discussed by Moss <ref> [15] </ref>. A nested transaction consists of a root (or parent) transaction and nested component transactions, called subtransactions. The subtransactions can themselves be nested transactions. Subtransactions execute atomically with respect to their siblings, and are failure atomic with respect to their parent. <p> Its emphasis, however, is in Application Programming Interfaces conforming to existing conventional transactional technology. Finally, the idea of rewriting history is a natural extension of the repeating history paradigm of ARIES [14] and is a generalization of ARIES/NT [19], an extension to ARIES for nested transactions <ref> [15] </ref>. 6 Conclusions Recent work has produced many Extended Transaction Models (ETMs), but each has its own tailor-made implementation.
Reference: [16] <author> C. Pu, G. Kaiser, G., and N. Hutchinson. </author> <title> Split-Transactions for Open-Ended Activities. </title> <booktitle> In Proceedings of the 14th International Conference on Very Large Data Bases, </booktitle> <pages> pages 26-37, </pages> <address> Los Angeles, CA, </address> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: That is, all the changes that a child transaction is responsible for are delegated to its parent when the child commits. A transaction can delegate at any point during its execution, not just when it aborts or commits. For instance, in Split Transactions <ref> [16] </ref>, a transaction may split into two transactions, a splitting and a split transaction, at any point during its execution. A splitting transaction t 1 may delegate to the split transaction t 2 some of its operations at the time of the split. <p> The former periodically reports to other transactions by delegating its current results. In the latter, control is passed from one transaction to the other transaction at the time of delegation. 2.2.1 Split Transactions In the split transaction model <ref> [16] </ref> a transaction t 1 can split into two transactions, t 1 and t 2 . Operations invoked by t 1 on objects in a set ob set are delegated to t 2 . t 1 and t 2 can now commit or abort independently.
Reference: [17] <author> Cris Pedregal Martin and Krithi Ramamritham. ARIES/RH: </author> <title> Robust Support for Delegation by Rewriting History. </title> <institution> TR 95-51 Computer Science Dept., University of Massachusetts, Amherst, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: The performance penalty is due to the random nature of the accesses (as opposed to the usual append-only to logs), and the fact that a single delegation will generate many accesses, in principle sweeping the whole log <ref> [17] </ref>. Ensuring recovery correctness is hard because we manipulate the log outside the usual append-only mode, complicating the model with extra data, 2 whose integrity in the face of crashes is not guaranteed by the standard recovery algorithm and must be ensured ad-hoc. <p> This re-establishes the state of the database at failure time, including uncommitted updates. Because some ARIES 3 It is easier to tolerate unusual log manipulations during recovery than during normal processing. 4 The problems of this approach are discussed in detail in <ref> [17] </ref>. 10 variants merge the analysis and redo passes in a single forward pass, ARIES/RH relies on a single forward pass to add delegation. The Undo pass rolls back all the updates by loser transactions in reverse chronological order starting with the last record of the log.
Reference: [18] <author> Cris Pedregal Martin and Krithi Ramamritham. </author> <title> Delegation: Efficiently Rewriting History. </title> <institution> TR 95-90 Computer Science Dept., University of Massachusetts, Amherst, </institution> <month> October </month> <year> 1995. </year>
Reference: [19] <author> Rothermel, K., and C. Mohan. ARIES/NT: </author> <title> A Recovery Method Based on Write-Ahead Logging for Nested Transactions. </title> <booktitle> In Proceedings of the 15th International Conference on Very Large Databases, </booktitle> <pages> pages 337-346, </pages> <address> Amsterdam, </address> <year> 1989. </year>
Reference-contexts: Its emphasis, however, is in Application Programming Interfaces conforming to existing conventional transactional technology. Finally, the idea of rewriting history is a natural extension of the repeating history paradigm of ARIES [14] and is a generalization of ARIES/NT <ref> [19] </ref>, an extension to ARIES for nested transactions [15]. 6 Conclusions Recent work has produced many Extended Transaction Models (ETMs), but each has its own tailor-made implementation.
Reference: [20] <author> H. Wachter and A. Reuter. </author> <title> The ConTract Model. </title> <booktitle> In [10]. </booktitle>
Reference-contexts: The recent work of Barga and Pu [1], also inspired in part by ACTA, explores another modular approach, based on the ideas of metaobject protocols [13], and incorporates some elements of the TSME approach and some of our language-based approach. 24 Also related is the work on the ConTract model <ref> [20] </ref>. In ConTract, a set of steps define individual transactions; a script is provided to control the execution of these transactions. But ConTract scripts introduce their own control flow syntax, while ASSET introduces a small set of transaction management primitives that can be embedded in a host language.
Reference: [21] <author> Gerhard Weikum, Christof Hasse, Peter Broessler, Peter Muth. </author> <title> Multi-Level Recovery. </title> <booktitle> In ACM International Symposium on Principles of Database Systems, </booktitle> <pages> pages 109-123, </pages> <address> Nashville, </address> <year> 1990. </year> <month> 27 </month>
References-found: 21

