URL: http://www.cs.wisc.edu/~richards/Pubs/iclp.ps
Refering-URL: http://www.cs.wisc.edu/~richards/richards.html
Root-URL: 
Title: On Warren's Method for Functional Programming in Logic  
Author: M.H.M. Cheng M.H. van Emden and B.E. Richards 
Date: October 3, 1989  
Address: Victoria  
Affiliation: University of  
Abstract: Although Warren's method for the evaluation in Prolog of expressions with higher-order functions appears to have been neglected, it is of great value. Warren's paper needs to be supplemented in two respects. He showed examples of a translation from expressions to clauses, but did not present a general method. Here we present a general translation program and prove it correct with respect to the axioms of equality and those of the -calculus. Warren's paper only argues in general terms that a structure-sharing Prolog implementation can be expected to efficiently evaluate the result of his translation. We show a comparison of timings between lisp and a structure-copying implementation of Prolog. The result suggests that Warren's method is about as efficient as the Lisp method for the evaluation of expressions involving higher-order functions.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M.H.M. Cheng. </author> <title> Lambda-equational Logic Programming. </title> <type> PhD thesis, </type> <institution> University of Waterloo, </institution> <year> 1987. </year> <month> 19 </month>
Reference-contexts: More information on the relation between expressions and equations can be found in <ref> [1] </ref>. As an example, let us show how to eliminate the 's from the definition of the "twice" function t = f: x: f : (f : x). The constant on the left-hand side is appropriate, as the right-hand side has no free variables.
Reference: [2] <author> P. Landin. </author> <title> The next 700 programming languages. </title> <journal> Comm. ACM, </journal> <volume> 9 </volume> <pages> 157-164, </pages> <year> 1966. </year>
Reference-contexts: Most agree (including hard-bitten opponents of "mere syntactic sugar") that this is unbearable; hence the alternative X is 1+2+3. What we propose is to allow the second argument of is to include ISWIM <ref> [2] </ref> expressions, which are widely known to have a simple translation to expressions. The remainder of this paper is devoted to a method of translating expressions to clauses that gives the same result as Warren's on the example in his paper. <p> As it stands, its second argument must be an arithmetic expression. A natural generalization, one that leaves the rest of Prolog unaffected, is to allow this second argument to be any expression, preferably in modified syntactic form such as ISWIM <ref> [2] </ref>. Results of computations that are functions present problems in existing languages for functional programming. Lisp arbitrarily disallows the usual notation in such cases, forcing the user to explicitly construct "closures" with system functions especially provided for this purpose. Scheme is an improvement in that it accepts notation.
Reference: [3] <author> J. McCarthy. </author> <title> Recursive functions of symbolic expressions and their computation by machine. </title> <journal> Comm. ACM, </journal> <volume> 3 </volume> <pages> 184-195, </pages> <year> 1960. </year>
Reference-contexts: The problems McCarthy had with recursive definitions (see <ref> [3] </ref>) support our belief that he must have been committed to -calculus. The prevailing view of the subsequent developers and users of Lisp is quite different.
Reference: [4] <author> Hartley Rogers, Jr. </author> <title> Theory of Recursive Functions and Effective Computability. </title> <publisher> McGraw-Hill, </publisher> <year> 1967. </year>
Reference-contexts: We present our conclusions in section 6. 2 Recursion equations Our earliest source for equations as a computational formalism is S.C. Kleene's 1936 paper "General recursive functions of natural numbers" quoted in <ref> [4] </ref>. On page 16 this reference gives the following example of a system of recursion equations: f (0) = 0 f (x + 1) = g (x) + 1 with the comment that f is the main symbol 1 and that g is an auxiliary one. <p> The reason is that the terms denote the values of the functions being defined rather than the functions themselves. Another possibility is the applicative style where the functions themselves are denoted by terms. In this style, the above example becomes f : 0 = 0 1 <ref> [4] </ref> says that it can easily be verified that the equations determine the function x: 2 fl x. 4 f : s (x) = s (g : x) The first argument of the application operator : is a term denoting a function.
Reference: [5] <author> M.H. van Emden. </author> <title> Conditional answers for polymorphic type inference. In K.A. </title> <editor> Bowen and R.A. Kowalski, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <pages> pages 590-603. </pages> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: : Y = Z apply (X; Y; Z) apply (F; X; Z 2 ); F : Z 2 = Z X : Y = Z apply (X; Y; Z) apply (F; X; Z 2 ); apply (F; Z 2 ; Z): The derivation is incomplete; it yields a "conditional answer" <ref> [8, 5] </ref> which is a clause where the initial goal with the cumulative substitution applied to it is the head and the final goal statement as body. The derivation proves that this conditional answer is logically implied by the input clauses of the SLD-derivation.
Reference: [6] <author> M.H. van Emden and T.S.E. Maibaum. </author> <title> Equations compared with clauses for specification of abstract data types. </title> <booktitle> In Advances in Database Theory, </booktitle> <pages> pages 159-194. </pages> <publisher> Plenum Press, </publisher> <year> 1981. </year>
Reference-contexts: The derivation proves that this conditional answer is logically implied by the input clauses of the SLD-derivation. As far as we know the first logic program to translate equations to relationalized form was in <ref> [6] </ref>. In this program it is not clear why the resulting clause is justified by the equation and the axioms. The authors invented the program by having it duplicate the known manual operations.
Reference: [7] <author> M.H. van Emden and K. Yukawa. </author> <title> Logic programming with equations. </title> <journal> The Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 265-288, </pages> <year> 1987. </year>
Reference-contexts: By this we mean that the Prolog derivation mechanism can be made to apply the equality axioms in such a way that they reduce an expression to canonical form. This approach is discussed in detail in <ref> [7] </ref>. Although the presence of equality axioms guarantees that SLD derivations exist that mimic equational rewriting, Prolog control will not find such derivations when the equality axioms are in their usual form. However, [7] shows that it is possible to specify an alternative of the usual equality axioms for which essentially <p> This approach is discussed in detail in <ref> [7] </ref>. Although the presence of equality axioms guarantees that SLD derivations exist that mimic equational rewriting, Prolog control will not find such derivations when the equality axioms are in their usual form. However, [7] shows that it is possible to specify an alternative of the usual equality axioms for which essentially one SLD-derivation exists, so that SLD-resolution can be used to mimic equational rewriting.
Reference: [8] <author> P. Vasey. </author> <title> Qualified answers and their application to transformation. </title> <booktitle> In Proceedings of the Third International Logic Programming Conference, </booktitle> <pages> pages 425-432, </pages> <year> 1986. </year>
Reference-contexts: : Y = Z apply (X; Y; Z) apply (F; X; Z 2 ); F : Z 2 = Z X : Y = Z apply (X; Y; Z) apply (F; X; Z 2 ); apply (F; Z 2 ; Z): The derivation is incomplete; it yields a "conditional answer" <ref> [8, 5] </ref> which is a clause where the initial goal with the cumulative substitution applied to it is the head and the final goal statement as body. The derivation proves that this conditional answer is logically implied by the input clauses of the SLD-derivation.
Reference: [9] <author> D.H.D. Warren. </author> <title> Higher-order extensions to prolog: are they needed? In J.E. </title> <editor> Hayes, Donald Michie, and Y-H. Pao, editors, </editor> <booktitle> Machine Intelligence 10, </booktitle> <pages> pages 441-454. </pages> <publisher> Ellis Horwood with John Willey and Sons, </publisher> <year> 1982. </year> <note> Lecture Notes in Mathematics 125. </note>
Reference-contexts: 1 Introduction In <ref> [9] </ref> Warren discussed whether higher-order features are needed in Prolog. We are concerned with the first half of the paper, which considers functions and relations that are higher-order in the sense of Lisp and other languages for functional programming.
Reference: [10] <author> Robert Wilensky. LISPcraft. W.W. Norton, </author> <year> 1984. </year>
References-found: 10

