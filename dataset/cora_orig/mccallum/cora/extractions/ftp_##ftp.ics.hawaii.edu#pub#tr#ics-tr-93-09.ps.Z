URL: ftp://ftp.ics.hawaii.edu/pub/tr/ics-tr-93-09.ps.Z
Refering-URL: ftp://ftp.ics.hawaii.edu/pub/tr/INDEX.html
Root-URL: 
Title: A Practical Technique for Bounding the Time Between Events in Concurrent Real-Time Systems  
Author: James C. Corbett George S. Avrunin 
Note: This is a revised version of a paper that appeared in the Proceedings of the 1993 International Symposium on Software Testing and Analysis (ISSTA), June 1993, pages 110-116.  
Address: Honolulu, HI 96822  Amherst, MA 01003  
Affiliation: Information and Computer Science Department University of Hawaii at Manoa  Department of Mathematics and Statistics University of Massachusetts at Amherst  
Abstract: Showing that concurrent systems satisfy timing constraints on their behavior is difficult, but may be essential for critical applications. Most methods are based on some form of reachability analysis and require construction of a state space of size that is, in general, exponential in the number of components in the concurrent system. In an earlier paper with L. K. Dillon and J. C. Wileden, we described a technique for finding bounds on the time between events without enumerating the state space, but the technique applies chiefly to the case of logically concurrent systems executing on a uniprocessor, in which events do not overlap in time. In this paper, we extend that technique to obtain upper bounds on the time between events in maximally parallel concurrent systems. Our method does not require construction of the state space and the results of preliminary experiments show that, for at least some systems with large state spaces, it is quite tractable. We also briefly describe the application of our method to the case in which there are multiple processors, but several processes run on each processor. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. S. Avrunin. </author> <title> Sharpening bounds on the time between events in maximally 14 parallel systems. </title> <type> Technical Report 92-69, </type> <institution> Department of Computer Science, University of Massachusetts at Amherst, </institution> <year> 1992. </year> <note> Available for anonymous ftp on ext.math.umass.edu. </note>
Reference-contexts: In the remainder of this section, we outline a method for achieving this when the automata representing the tasks are acyclic. Complete details of the method can be found in <ref> [1] </ref>. Suppose that Task 2 enters state 3 at time s 3 and leaves it at time t 3 . Then it is waiting in state 3 during the interval from s 3 to t 3 . Let s 1 and t 1 be the corresponding times for state 1. <p> We can then use these variables to enforce the appropriate synchronization conditions. Full details of this method, and the extensions needed to bound the time between two given events, rather than the duration of a complete execution, are given in <ref> [1] </ref>. 5 Experiments We have demonstrated the feasibility of our approach by conducting experiments on several concurrent systems. The constrained expression toolset has been modified to implement our new techniques.
Reference: [2] <author> G. S. Avrunin, U. A. Buy, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: It is an extension of the constrained expression analysis technique for concurrent software <ref> [2] </ref> which uses essentially the same necessary conditions to overcome, at least in some cases, the state explosion problem inherent in reachability-based analysis techniques. 3 Extension to the Multiprocessor Setting The chief difficulty in extending the above technique to the multiprocessor setting is calculating the parallel execution time of a set <p> The constrained expression toolset has been modified to implement our new techniques. We first report on the application of the technique described in Section 3 to two example systems with very large state spaces. The constrained expression toolset, described fully in <ref> [2] </ref>, takes as input the specification of a concurrent system in an Ada-like specification language as well as a query that describes the property to be verified and other information needed for the analysis (e.g., the durations of atomic events).
Reference: [3] <author> G. S. Avrunin, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automated derivation of time bounds in uniprocessor concurrent systems. </title> <note> Submitted for publication. Available for anonymous ftp on ext.math.umass.edu, </note> <year> 1993. </year>
Reference-contexts: Since the size of this state space is, in general, exponential in the number of processes in the system, these techniques are computationally infeasible except in certain special cases. In an earlier paper with Laura K. Dillon and Jack C. Wileden <ref> [3] </ref>, we described a technique for finding upper and lower bounds on the time between events in the execution of a concurrent system. <p> Similarly, we force the flow to stop after the ending event in the task (s) containing that event, and allow the flow to stop anywhere in a task if it contains no ending events. 3 This approach is described in detail in <ref> [3] </ref>. <p> Since we are bounding the time of the whole execution rather than an interval between events, we can omit the start variables for all tasks (as described in <ref> [3] </ref>) and simply add an implicit flow in of one for the starting states of the tasks. <p> As shown in [4], this technique can easily be generalized to find an upper bound on the time between two specific events by generating an execution part of the inequality system that finds segments of an execution beginning and ending with specific events, as described in <ref> [3] </ref>. Additional b i and e i variables would allow the path found by the critical path part to begin anywhere a task could be after the starting event and end anywhere a task could be after the ending event. <p> Refinements to the method that partially address the first two problems are described in <ref> [3] </ref>. In the next section, we show how the third problem can be eliminated if the DFAs are acyclic. 4 Enforcing the maximal parallelism assumption This failure to enforce the maximal parallelism assumption can be seen in the example of Figure 3.
Reference: [4] <author> J. C. Corbett. </author> <title> Automated Formal Analysis Methods for Concurrent and Real-Time Software. </title> <type> PhD thesis, </type> <institution> University of Massachusetts at Amherst, </institution> <year> 1992. </year> <note> Available as Technical Report 92-48, </note> <institution> Department of Computer Science, University of Massachusetts at Amherst. </institution>
Reference-contexts: The number of traversals will usually be bounded by the execution part. Due to space limitations, we omit a formal description and simply illustrate the 6 technique with the example shown in Figure 2. (A complete description of the tech-nique can be found in <ref> [4] </ref>.) Two tasks representing customers each choose whether to rendezvous with a common task that represents a resource. The resource task would most naturally be modeled with a loop, but the resulting cycle in the task's automaton degrades the bound derived by our technique. <p> If event a takes 10 units and the other events take only one, then the bound will be 10, produced by a solution in which task 1 does not use the resource. As shown in <ref> [4] </ref>, this technique can easily be generalized to find an upper bound on the time between two specific events by generating an execution part of the inequality system that finds segments of an execution beginning and ending with specific events, as described in [3].
Reference: [5] <author> C. Courcoubetis and M. Yannakakis. </author> <title> Minimum and maximum delay problems in real-time systems. </title> <editor> In K. G. Larsen and A. Skou, editors, </editor> <booktitle> Computer Aided Verification, 3rd International Workshop Proceedings, volume 575 of Lecture Notes in Computer Science, </booktitle> <pages> pages 399-409, </pages> <address> Aalborg, Denmark, July 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Most have relied on either proving theorems in some logical setting (e.g., [7]) or some form of reachability analysis (e.g., <ref> [5] </ref>, [6]). The theorem-proving techniques have been hard to automate and the reachability-based techniques require construction of the state space of the concurrent system.
Reference: [6] <author> R. Gerber and I. Lee. </author> <title> A layered approach to automating the verification of real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 18(9) </volume> <pages> 768-784, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: Most have relied on either proving theorems in some logical setting (e.g., [7]) or some form of reachability analysis (e.g., [5], <ref> [6] </ref>). The theorem-proving techniques have been hard to automate and the reachability-based techniques require construction of the state space of the concurrent system.
Reference: [7] <author> F. Jahanian and A. K.-L. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 12(5) </volume> <pages> 890-904, </pages> <year> 1986. </year> <month> 15 </month>
Reference-contexts: Most have relied on either proving theorems in some logical setting (e.g., <ref> [7] </ref>) or some form of reachability analysis (e.g., [5], [6]). The theorem-proving techniques have been hard to automate and the reachability-based techniques require construction of the state space of the concurrent system.
References-found: 7

