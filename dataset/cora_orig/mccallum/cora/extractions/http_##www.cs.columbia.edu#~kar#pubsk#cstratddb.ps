URL: http://www.cs.columbia.edu/~kar/pubsk/cstratddb.ps
Refering-URL: http://www.cs.columbia.edu/~kar/pubsk/pubsk.html
Root-URL: http://www.cs.columbia.edu
Email: kar@cs.columbia.edu  
Title: Constraint Stratification in Deductive Databases  
Author: Kenneth A. Ross 
Affiliation: Columbia University  
Abstract: We propose a syntactic condition on deductive database programs that ensures a two-valued well-founded model. This condition, called constraint stratification, is significantly more general than previous syntactic conditions such as stratification and local stratification. Modular stratification has been proposed as a semantic (i.e., nonsyntactic) condition for ensuring a two-valued well-founded model. While not every modularly stratified program is constraint stratified, all of the well-known practical examples of modularly stratified programs are constraint stratified under appropriate natural constraints. In addition, there exist constraint stratified programs that are not modularly stratified. We also show how the magic sets optimization technique can be applied for constraint stratified programs.
Abstract-found: 1
Intro-found: 1
Reference: [BMSU86] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proceedings of the Fifth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1986. </year>
Reference-contexts: Theorem 3.2: Every locally stratified program is constraint stratified with respect to any set of constraints. Proof : Since this fact holds for the empty set of constraints. 4 Optimization The fundamental optimization technique for deductive databases is magic sets <ref> [BR91, BMSU86] </ref>. Magic sets speeds up bottom-up evaluation by passing binding information from the query into the rule evaluation so that only information relevant to the query is accessed.
Reference: [BR91] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of magic. </title> <journal> Journal of Logic Programming, </journal> <volume> 10 </volume> <pages> 255-300, </pages> <year> 1991. </year> <note> Preliminary version appeared in the 6th ACM Symposium on Principles of Database Systems, </note> <year> 1987. </year>
Reference-contexts: Theorem 3.2: Every locally stratified program is constraint stratified with respect to any set of constraints. Proof : Since this fact holds for the empty set of constraints. 4 Optimization The fundamental optimization technique for deductive databases is magic sets <ref> [BR91, BMSU86] </ref>. Magic sets speeds up bottom-up evaluation by passing binding information from the query into the rule evaluation so that only information relevant to the query is accessed.
Reference: [BS89] <author> A. Brodsky and Y. Sagiv. </author> <title> Inference of monotonicity constraints in Datalog programs. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1989. </year>
Reference-contexts: The constraints we allow are monotonicity constraints <ref> [BS89] </ref>. Monotonicity constraints specify that one argument of a predicate is less than another according to some partial order. Our approach can be outlined as follows: * Specify a set of monotonicity constraints on the EDB predicates. <p> Thus we would like to phrase the question as whether a program has a two-valued well-founded model for all EDB relations that satisfy some acyclicity constraints. In this section we present the notion of monotonicity constraints from <ref> [BS89] </ref> in order to be able to phrase such constraints. We shall also look at the problem of inferring constraints on IDB predicates given constraints on the EDB predicates, extending some results from [BS89]. <p> In this section we present the notion of monotonicity constraints from <ref> [BS89] </ref> in order to be able to phrase such constraints. We shall also look at the problem of inferring constraints on IDB predicates given constraints on the EDB predicates, extending some results from [BS89]. Definition 2.5: (Monotonicity Constraint) A monotonicity constraint is a statement of the form p : i mc j where p is a predicate name, and i and j are either column positions of p, or constants in the language (i.e., elements of U). <p> Our context is more general than that of <ref> [BS89] </ref> since we allow negative subgoals. 1 While Brodsky and Sagiv's method is sound and complete for datalog programs, it may fail to detect monotonicity constraints for programs like p (X; Y ) q (X; Y ); :q (X; Y ): Even though there are no constraints on relation q, the <p> The envelope of P is p (X; Y ) p (X; Z); f (Z; Y ) from which p : 2 mc 1 is derivable using the techniques of <ref> [BS89] </ref>. Thus, p : 2 mc 1 also holds for P . 2 Definition 2.6: Let P be a program, E a constraint set on the EDB predicates of P , and I a constraint set on the IDB predicates of P .
Reference: [GL88] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming, </booktitle> <year> 1988. </year>
Reference-contexts: A stratified program is one in which, effectively, there is no predicate that depends negatively on itself. Recent work has shown that there are interesting logic programs that are not stratifiable but for which a natural, unambiguous semantics exists. The well-founded semantics [VGRS91] and the stable model semantics <ref> [GL88] </ref> are two (closely related) proposals for defining the semantics of logic programs, whether stratified or not. For stratified programs they both coincide with the perfect model semantics. The well-founded semantics is a three-valued semantics. Literals may be true, false or undefined.
Reference: [Kol91] <author> P. G. Kolaitis. </author> <title> The expressive power of stratified programs. </title> <journal> Information and Computation, </journal> <volume> 90 </volume> <pages> 50-66, </pages> <year> 1991. </year>
Reference-contexts: Note that none of these examples is locally stratified. Example 2.1: Consider the program P consisting of the rule w (X ) m (X; Y ); :w (Y ) together with some facts about m. P is a game-playing program <ref> [Kol91] </ref> in which a position X is "winning" [w (X )] if there is a move from X to a position Y [m (X; Y )] and Y is a losing position [:w (Y )].
Reference: [KSS92] <author> D. Kemp, P. Stuckey, and D. Srivastava. </author> <title> Query restricted bottom-up evaluation of normal logic programs. </title> <booktitle> In Proc. Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 288-302, </pages> <year> 1992. </year>
Reference-contexts: Various authors have looked at the problem of extending the magic sets techniques to larger classes of programs with negation, be it stratified, modularly stratified, or general negation <ref> [Ros90, RSS92, Mor93, KSS92] </ref>. In general, the larger the class of programs allowed, the fewer options there are for optimization, and so we look for the most specific optimization technique that applies.
Reference: [Llo87] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> New York, 2nd edition, </address> <year> 1987. </year>
Reference-contexts: We also outline how magic sets techniques for modularly stratified programs can be applied to a version of constraint stratification that ensures freedom from recursive loops through negation using a left-to-right binding passing strategy. 2 Terminology We consider normal logic programs with function symbols and negation <ref> [Llo87] </ref>. Definition 2.1: A term is either a variable, a constant symbol, or a function symbol applied to terms. If p is an n-ary predicate symbol and t 1 ; ; t n are terms then p (t 1 ; ; t n ) is an atom.
Reference: [Mor93] <author> S. Morishita. </author> <title> An alternating fixpoint tailored to magic programs. </title> <booktitle> In Proceedings of the Twelfth ACM Conference on Principles of Database Systems, 1993. Preliminary version appeared in the 1992 Proceedings of the Workshop on Deductive Databases, Joint International Conference and Symposium on Logic Programming. </booktitle>
Reference-contexts: Various authors have looked at the problem of extending the magic sets techniques to larger classes of programs with negation, be it stratified, modularly stratified, or general negation <ref> [Ros90, RSS92, Mor93, KSS92] </ref>. In general, the larger the class of programs allowed, the fewer options there are for optimization, and so we look for the most specific optimization technique that applies.
Reference: [PP90] <author> H. Przymusinska and T. C. Przymusinski. </author> <title> Weakly stratified logic programs. </title> <journal> Fundamenta Informaticae, </journal> <volume> 13 </volume> <pages> 51-65, </pages> <year> 1990. </year> <note> Preliminary version appeared in Proc. Fifth International Conference and Symposium on Logic Programming, </note> <year> 1988. </year>
Reference-contexts: Unfortunately, the definition of modular stratification is semantic rather than syntactic. Whether a program is modularly stratified depends, in general, on the semantics assigned to its predicates. This contrasts with stratification and local stratification, which are syntactically definable conditions. Other conditions such as weak stratification <ref> [PP90] </ref> are also semantic in this sense. In the context of deductive databases, where the rules and schema-level information is small compared to the data, it would be undesirable to make the stratification condition depend on the data.
Reference: [Prz88] <author> T. C. Przymusinski. </author> <title> On the declarative semantics of deductive databases and logic programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216, </pages> <address> Los Altos, CA, 1988. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: 1 Introduction Much recent work has concerned defining the semantics of negation in deductive databases. The "perfect model semantics" <ref> [Prz88] </ref> has been generally accepted as natural, and is the basis for several experimental deductive database systems. Unfortunately, the perfect model semantics applies only to programs that are stratified (or locally stratified). A stratified program is one in which, effectively, there is no predicate that depends negatively on itself. <p> To see how the well-founded model of a program may be composed from those of its components, recall that a locally stratified program has a unique perfect model <ref> [Prz88] </ref> and hence a total well-founded model that coincides with the perfect model. The "lowest" components must be locally stratified; compute their perfect model M .
Reference: [Ros90] <author> K. A. Ross. </author> <title> Modular stratification and magic sets for Datalog programs with negation. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1990. </year> <note> Full version to appear in J.ACM. </note>
Reference-contexts: In many cases, two truth values suffice to model the situation under consideration. So we desire a condition on the program, more general than stratification, that ensures that the well-founded semantics is two-valued. In <ref> [Ros90] </ref> the present author proposed such a class, which was termed the class of modularly stratified programs. For modularly stratified programs the well-founded semantics is total (i.e., makes every ground literal either true or false). <p> Modularly stratified programs also allow subgoal-at-a-time evaluation <ref> [Ros90] </ref>. A program is modularly stratified if and only if its mutually recursive components are locally stratified once all instantiated rules with a false subgoal that is defined in a "lower" component are removed. Unfortunately, the definition of modular stratification is semantic rather than syntactic. <p> We prove that it is sound with respect to the well-founded semantics of P . Not every modularly stratified program is constraint stratified. However, we find, perhaps surprisingly, that all of the common examples of modularly stratified programs, including all of the examples from <ref> [Ros90] </ref>, are constraint stratified. Further, there are some constraint stratified programs that are not modularly stratified. We prove that constraint stratified programs have a two-valued well-founded semantics. <p> Definition 2.2: The envelope of a program P is P with all negative subgoals removed. 2 2.1 Modular Stratification We now present the concept of modular stratification, originally defined in <ref> [Ros90] </ref>. Definition 2.3: (Reduction of a component) Let F be a program component, and let S be the set of predicates used by F . Let M be a two-valued interpretation over the universe U for the predicates in S. <p> We can proceed in this way up the dependency relation between components until we have the well-founded model for the whole program. 2.2 Examples We present a number of examples from <ref> [Ros90] </ref> of modularly stratified programs. Note that none of these examples is locally stratified. Example 2.1: Consider the program P consisting of the rule w (X ) m (X; Y ); :w (Y ) together with some facts about m. <p> checks could be performed incrementally, and so have (incremental) cost significantly smaller than proportional to the size of the database. 3 Constraint Stratification: A Syntactic Condition In this section we provide a syntactic stratification condition that is general enough to include all of the examples from Section 2.2 originally from <ref> [Ros90] </ref>, while also including some programs that are not modularly stratified. Definition 3.1: Let &lt; be a fixed antisymmetric partial order with no infinite descending chains. Let P be a program, and let C be a sound constraint set for (P; &lt;). <p> Various authors have looked at the problem of extending the magic sets techniques to larger classes of programs with negation, be it stratified, modularly stratified, or general negation <ref> [Ros90, RSS92, Mor93, KSS92] </ref>. In general, the larger the class of programs allowed, the fewer options there are for optimization, and so we look for the most specific optimization technique that applies. <p> Thus we seek an efficient optimization strategy for constraint stratified programs that is potentially better than those that apply to larger classes of programs. One doesn't have to look very far. It turns out that we can use techniques developed for modularly stratified programs <ref> [Ros90] </ref> if the program satisfies a slightly stronger condition about the way it passes its bindings from left to right in each rule. Definition 4.1: Let &lt; be a fixed antisymmetric partial order with no infinite descending chains. <p> We say that P is constraint stratified from left to right for (C; &lt;) if and only if pref (P; C; &lt;) is locally stratified. 2 The definition of constraint stratification from left to right is analogous to the notion of modular stratification from left to right <ref> [Ros90] </ref>. The idea is to make sure that no recursive loops occur through the initial subgoals of a rule, even if the later subgoals would make the loop unsatisfiable. <p> Hence the constraint stratification of the original program implies the constraint stratification from left to right of the transformed program. While space restrictions prevent a full description of the magic sets techniques here, one can show that the techniques of <ref> [Ros90] </ref> (and, we conjecture, the techniques of [RSS92]) are correct for function-free programs that are constraint stratified from left to right. This result does not follow from results in [Ros90] since there exist constraint stratified programs that are not modularly stratified. 5 Conclusions We have presented a syntactic condition for a <p> While space restrictions prevent a full description of the magic sets techniques here, one can show that the techniques of <ref> [Ros90] </ref> (and, we conjecture, the techniques of [RSS92]) are correct for function-free programs that are constraint stratified from left to right. This result does not follow from results in [Ros90] since there exist constraint stratified programs that are not modularly stratified. 5 Conclusions We have presented a syntactic condition for a deductive database to have a two-valued well-founded model. <p> Previous conditions were either too weak to naturally express some programs, or were semantic in nature, depending on the values of certain relations in the database. Our condition, called constraint stratification, is shown to be general enough to express all of the examples from <ref> [Ros90] </ref> of interesting modularly stratified programs. In addition, we demonstrate that there are some constraint stratified programs that are not modularly stratified. We can also show that magic sets optimization techniques developed for modularly stratified programs [Ros90] also apply to programs that are constraint stratified. <p> stratification, is shown to be general enough to express all of the examples from <ref> [Ros90] </ref> of interesting modularly stratified programs. In addition, we demonstrate that there are some constraint stratified programs that are not modularly stratified. We can also show that magic sets optimization techniques developed for modularly stratified programs [Ros90] also apply to programs that are constraint stratified. There are several directions for future work. The first problem is that of having to check all instances of all rules in order to determine constraint stratification. For programs with function symbols the instantiated program is infinite.
Reference: [Ros94] <author> K. A. Ross. </author> <title> Stratification conditions using constraints. </title> <note> Submitted for publication, </note> <month> March </month> <year> 1994. </year>
Reference-contexts: For programs with function symbols the instantiated program is infinite. Even for function-free programs, checking all rule instances is likely to be a prohibitively expensive task. In a forthcoming paper <ref> [Ros94] </ref>, we show that checking all rule instances is not necessary in general for function-free programs. One can manage just by looking at the original rules themselves in addition to the constraints. The second problem is that this paper assumes that the partial order &lt; is given in advance. <p> For example, we know engine &lt; torque-generator only when the relation representing the hierarchy expresses that an engine is a direct or indirect subpart of a torque-generator. It is conceivable that in a different hierarchy, a torque-generator is a subpart of an engine. In the same forthcoming paper <ref> [Ros94] </ref>, we address this issue by quantifying over all partial orders that are consistent with the constraints, and requiring constraint stratification with respect to every such partial order. Another direction for future work is on defining other sound (but still syntactic) constraint inference methods. <p> Brodsky and Sagiv's method can potentially be extended to programs with negation and programs with function symbols to derive more constraints. Unfortunately, completeness is impossible since the monotonicity constraint implication problem for datalog programs with negation is undecidable <ref> [Ros94] </ref>.
Reference: [RSS92] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Controlling the search in bottom-up evaluation. </title> <booktitle> In Proc. Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 273-287, </pages> <year> 1992. </year>
Reference-contexts: Various authors have looked at the problem of extending the magic sets techniques to larger classes of programs with negation, be it stratified, modularly stratified, or general negation <ref> [Ros90, RSS92, Mor93, KSS92] </ref>. In general, the larger the class of programs allowed, the fewer options there are for optimization, and so we look for the most specific optimization technique that applies. <p> Hence the constraint stratification of the original program implies the constraint stratification from left to right of the transformed program. While space restrictions prevent a full description of the magic sets techniques here, one can show that the techniques of [Ros90] (and, we conjecture, the techniques of <ref> [RSS92] </ref>) are correct for function-free programs that are constraint stratified from left to right.
Reference: [Ull89] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge Base Systems. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year> <title> (Two volumes). </title>
Reference-contexts: Every predicate has a unique minimal complete component to which it belongs. A program may be broken up into complete components according to the equivalence classes (called strongly connected components in <ref> [Ull89] </ref>) induced on the predicates.
Reference: [VGRS91] <author> A. Van Gelder, K. A. Ross, and J. S. Schlipf. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <journal> JACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: A stratified program is one in which, effectively, there is no predicate that depends negatively on itself. Recent work has shown that there are interesting logic programs that are not stratifiable but for which a natural, unambiguous semantics exists. The well-founded semantics <ref> [VGRS91] </ref> and the stable model semantics [GL88] are two (closely related) proposals for defining the semantics of logic programs, whether stratified or not. For stratified programs they both coincide with the perfect model semantics. The well-founded semantics is a three-valued semantics. Literals may be true, false or undefined. <p> Theorem 2.2: Let P be a program and let P 0 be its envelope. Then the least model of P 0 contains all atoms that are either true or undefined in the well-founded model of P . Proof : (This proof assumes some familiarity with the notation of <ref> [VGRS91] </ref>.) Since P 0 is negation-free, its well-founded model is two-valued and equal to its least model by results of [VGRS91]. <p> Proof : (This proof assumes some familiarity with the notation of <ref> [VGRS91] </ref>.) Since P 0 is negation-free, its well-founded model is two-valued and equal to its least model by results of [VGRS91]. The negation-freeness of P 0 also means that the set of false atoms in the well-founded model for P 0 is U P 0 (;), where U Q (I) is the greatest unfounded set of program Q with respect to interpretation I.
References-found: 15

