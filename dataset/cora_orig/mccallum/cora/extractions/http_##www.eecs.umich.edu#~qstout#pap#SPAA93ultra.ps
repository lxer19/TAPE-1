URL: http://www.eecs.umich.edu/~qstout/pap/SPAA93ultra.ps
Refering-URL: http://www.eecs.umich.edu/~qstout/papers.html
Root-URL: http://www.cs.umich.edu
Title: Optimal Parallel Construction of Hamiltonian Cycles and Spanning Trees in Random Graphs (Preliminary Version)  
Author: Philip D. MacKenzie Quentin F. Stout 
Address: Ann Arbor, MI 48109-2122  
Affiliation: Advanced Computer Architecture Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Note: In Proc. 5th ACM Symp. on Parallel Algorithms and Architectures (1993), pp. 224-229.  
Abstract: We give tight bounds on the parallel complexity of some problems involving random graphs. Specifically, we show that a Hamiltonian cycle, a breadth first spanning tree, and a maximal matching can all be constructed in fi(log fl n) expected time using n= log fl n processors on the CRCW PRAM. This is a substantial improvement over the best previous algorithms, which required fi((log log n) 2 ) time and n log 2 n processors. We then introduce a technique which allows us to prove that constructing an edge cover of a random graph from its adjacency matrix requires (log fl n) expected time on a CRCW PRAM with O(n) processors. Constructing an edge cover is implicit in constructing a spanning tree, a Hamiltonian cycle, and a maximal matching, so this lower bound holds for all these problems, showing that our algorithms are optimal. This new lower bound technique is one of the very few lower bound techniques known which apply to randomized CRCW PRAM algorithms, and it provides the first nontrivial parallel lower bounds for these problems. 
Abstract-found: 1
Intro-found: 1
Reference: [AV79] <author> D. Angluin and L. G. Valiant. </author> <title> Fast probabilistic algorithms for hamiltonian circuits and matchings. </title> <journal> J. Comput. System Sci., </journal> <volume> 18 </volume> <pages> 155-193, </pages> <year> 1979. </year>
Reference-contexts: For a binomial random varible Z ~ B (n; p), where Z is the sum of n independent Bernoulli trials with 9 probability of success p, Angluin and Valiant <ref> [AV79] </ref> show that for 0 &lt; fi &lt; 1, one can obtain the bounds P (Z (1 + fi)np) e fi 2 np=3 ; P (Z (1 fi)np) e fi 2 np=2 : From this we obtain the bound P (Z 2np) 2 4np=9 : Also, for k 6 we obtain
Reference: [Ber73] <author> C. Berge. </author> <title> Graphs and Hypergraphs. </title> <publisher> North Holland, </publisher> <year> 1973. </year>
Reference-contexts: If we let v = n=2k and e = n m nm 2 , then by Turan's theorem <ref> [Ber73] </ref>, we can find an independent set of these vertices (targets) of size at least v 2 =(v + 2e) = n=2k (4km 2 + 1). Each target has at least a (1 p) 2km independent chance of not being hit in this step.
Reference: [BFF87] <author> B. Bollobas, T. I. Fenner, and A. M. Frieze. </author> <title> An algorithm for finding hamilton paths and cycles in random graphs. </title> <journal> Combinatorica, </journal> <volume> 7(4) </volume> <pages> 327-341, </pages> <year> 1987. </year>
Reference-contexts: Because this is a very important problem with many practical applications, researchers have studied under what conditions this problem becomes tractable. Some of the most successful results of this type are for the class of random graphs. Bol-lobas, Fenner and Frieze <ref> [BFF87] </ref> give an algorithm which constructs a Hamiltonian cycle in G n;p if one exists. This algorithm runs in polynomial expected time for p 1 2 .
Reference: [Che52] <author> H. Chernoff. </author> <title> A measure of asymptotic efficiency for tests of a hypothesis based on the sum of observations. </title> <journal> The Annals of Mathematical Statistics, </journal> <volume> 23 </volume> <pages> 493-507, </pages> <year> 1952. </year>
Reference-contexts: Thus by theorem 6.1, the stated lower bound holds. 2 A Probabilistic Tools One technique we use is the Chernoff bound <ref> [Che52] </ref>. This can be used when we wish to bound the distribution of a random variable Z which is the sum of n independent random variables.
Reference: [Fri87] <author> A. M. Frieze. </author> <title> Parallel algorithms for finding hamilton cycles in random graphs. </title> <journal> Inform. Process. Lett., </journal> <volume> 25 </volume> <pages> 111-117, </pages> <year> 1987. </year>
Reference-contexts: Gurevich and Shelah [GS87] and Thomason [Tho89] independently improve on this result, giving algorithms which run in linear expected time for any constant p. These algorithms are optimal, since linear time is needed just to write the output. Frieze <ref> [Fri87] </ref> gives a parallel algorithm which constructs a Hamiltonian cycle 1 Supported by an AT&T Fellowship and by NSF/DARPA grant CCR-9004727. <p> The next three subsections describe Stages 1, 2, and 3 respectively. We will need to use the following lemma. Lemma 3.1 (Frieze <ref> [Fri87] </ref>) The probability that a Hamiltonian cycle does not exist in a random graph G n;p is at most n 2 (1 p) n1 . 3.1 Hamiltonian cycle through p n vertices We attempt to find a Hamiltonian cycle through the first p n vertices using n processors using the following
Reference: [GMV91] <author> J. Gil, Y. Matias, and U. Vishkin. </author> <title> Towards a theory of nearly constant time parallel algorithms. </title> <booktitle> In Proc. 32nd Symp. on Found. of Comp. Sci., </booktitle> <pages> pages 698-710, </pages> <year> 1991. </year>
Reference-contexts: Thus exactly one cycle is formed through all the vertices. 2 3.2 Log-star paradigm Let m = n n. Here we show how to use the log-star pardigm of Gil, Matias, and Vishkin <ref> [GMV91] </ref> to perform Stage 2 of our algorithm, connecting the vertices of a random graph G m;p into a small number of simple disjoint paths. Gil, Matias, and Vishkin [GMV91] consider the following abstract problem. 4 Problem 3.1 Given an array of m active items and a constant 0 &lt; p <p> Here we show how to use the log-star pardigm of Gil, Matias, and Vishkin <ref> [GMV91] </ref> to perform Stage 2 of our algorithm, connecting the vertices of a random graph G m;p into a small number of simple disjoint paths. Gil, Matias, and Vishkin [GMV91] consider the following abstract problem. 4 Problem 3.1 Given an array of m active items and a constant 0 &lt; p &lt; 1, assume that in a single round, a processor can be assigned to try to deactivate an active item, and if q processors are trying to deactivate an <p> We can then use the red edges in the parallel algorithm using the probability p=2, and the blue edges in the serial algorithm using probability p=4. 3.5 Reducing the number of processors We can use the general technique for optimizing asynchronous geometric decaying algorithms in Gil, Matias and Vishkin <ref> [GMV91] </ref> to reduce the number of processors to n= log fl n. We have thus proven the following theorem. <p> This shows that the deactivation step succeeds with high probability. If the log-star paradigm fails, then we can simply perform a fi (n 2 ) time serial breadth-first spanning forest algorithm We can use the general technique for optimizing asynchronous geometric decaying algorithms in Gil, Matias and Vishkin <ref> [GMV91] </ref> to reduce the number of processors to n= log fl n. We have thus proven the following theorem.
Reference: [GS87] <author> Y. Gurevich and S. Shelah. </author> <title> Expected computation time for hamiltonian path problem. </title> <journal> SIAM J. Comput., </journal> <volume> 16(3) </volume> <pages> 486-502, </pages> <year> 1987. </year>
Reference-contexts: Bol-lobas, Fenner and Frieze [BFF87] give an algorithm which constructs a Hamiltonian cycle in G n;p if one exists. This algorithm runs in polynomial expected time for p 1 2 . Gurevich and Shelah <ref> [GS87] </ref> and Thomason [Tho89] independently improve on this result, giving algorithms which run in linear expected time for any constant p. These algorithms are optimal, since linear time is needed just to write the output. <p> If it does not succeed, we will simply revert to the linear expected time algorithm of Gurevich and Shelah <ref> [GS87] </ref>. We will explain later how we guarantee that failure in the parallel algorithm does not increase the expected time of the serial algorithm. Our algorithm runs in three stages as follows: Stage 1 Remove p n vertices, and find a Hamiltonian cycle through them in constant time. <p> If it does fail, we revert to the O (n) expected time serial algorithm of Gurevich and Shelah <ref> [GS87] </ref>. Since the probability of failure will be less than 1=n, this will not add anything to the expected time of the algorithm. Unfortunately, failure in our algorithm might imply failure in the linear expected time algorithm. To solve this problem, we use a nice technique from Gurevich and Shelah.
Reference: [Law76] <author> E. L. Lawler. </author> <title> Combinatorial Optimization: Networks and Matroids. </title> <publisher> Holt, Rinehart and Winston, </publisher> <address> New York, </address> <year> 1976. </year>
Reference-contexts: If we are unable to find a Hamiltonian cycle in fi (log fl n) time, then we revert to the polynomial time algorithm in Lawler <ref> [Law76] </ref> to find a maximal matching. Similar modifications can be made to find depth-first spanning forests, and to decide if a graph is connected, giving the following theorem.
Reference: [Mac92] <author> P. D. MacKenzie. </author> <title> Load balancing requires (log fl n) expected time. </title> <booktitle> In 3rd ACM-SIAM Symp. on Disc. Alg., </booktitle> <pages> pages 94-99, </pages> <year> 1992. </year> <note> submitted to SIAM Journal on Computing. </note>
Reference-contexts: When z is omitted we assume base 2. It is well known that log fl n is an extremely slow growing function of n, and in fact log fl n 5 for n 2 65536 . We can convert between bases using the following lemma. Lemma 2.1 (MacKenzie <ref> [Mac92] </ref>) For z 4, log fl n log fl z n + log fl z. 3 Hamiltonian Cycle We present here a parallel algorithm for finding a Hamiltonian cycle in G n;p which will succeed with high probability.
Reference: [MV91] <author> Y. Matias and U. Vishkin. </author> <title> Converting high probability into nearly-constant time with applications to parallel hashing. </title> <booktitle> In Proc. 23rd ACM Symp. on Theory of Computing, </booktitle> <pages> pages 307-316, </pages> <year> 1991. </year>
Reference-contexts: The allocation succeeds for all but 1 i+1 active items with high probability. Only allocated items participate in the deacti vation step. Deactivation Deactivate each participating item. The deactivation succeeds for all but 1 2 m=q c participating items with high probability. Matias and Vishkin <ref> [MV91] </ref> provide the allocation step, and thus only the deactivation step needs to be implemented for any specific problem. In our specific problem, an active element will be the highest numbered endpoint of a simple disjoint path, or the single endpoint of a path of length 0. <p> We try to deactivate v 1 by hooking its path P to a vertex in H i;j+1 which is in the interior of a path. We allocate q i processors to v 1 using the allocation routine of Matias and Vishkin <ref> [MV91] </ref>. Each of these processors will randomly choose k vertices in H i;j+1 . A processor checks to see if any chosen vertex v 0 both has not been chosen by another processor, and has a successor in its path.
Reference: [Tho89] <author> A. Thomason. </author> <title> A simple linear expected time algorithm for the hamilton cycle problem. </title> <journal> Discrete Math., </journal> <volume> 75 </volume> <pages> 373-379, </pages> <year> 1989. </year> <month> 10 </month>
Reference-contexts: Bol-lobas, Fenner and Frieze [BFF87] give an algorithm which constructs a Hamiltonian cycle in G n;p if one exists. This algorithm runs in polynomial expected time for p 1 2 . Gurevich and Shelah [GS87] and Thomason <ref> [Tho89] </ref> independently improve on this result, giving algorithms which run in linear expected time for any constant p. These algorithms are optimal, since linear time is needed just to write the output.
References-found: 11

