URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/95-37.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Email: govin-k@cs.buffalo.edu  bharat@cs.buffalo.edu  mantha@wrc.xerox.com  
Title: Optimization and Relaxation in Constraint Logic Languages  
Author: Kannan Govindarajan Bharat Jayaraman Surya Mantha 
Address: Buffalo, NY 14260  Buffalo, NY 14260  Webster, NY 14580  
Affiliation: Dept. of Computer Science SUNY at Buffalo  Dept. of Computer Science SUNY at Buffalo  Corporate Research Technology Xerox Corporation  
Abstract: Optimization and relaxation are two important operations that naturally arise in many applications involving constraints, e.g., engineering design, scheduling, decision support, etc. In optimization, we are interested in finding the optimal (i.e., best) solutions to a set of constraints with respect to an objective function. In many applications, optimal solutions may be difficult or impossible to obtain, and hence we are interested in finding suboptimal solutions, by either relaxing the constraints or relaxing the objective function. The contribution of this paper lies in providing a logical framework for performing optimization and relaxation in a constraint logic programming language. Our proposed framework is called preference logic programming (PLP), and its use for optimization was discussed in [8]. Essentially, in PLP we can designate certain predicates as optimization predicates, and we can specify the objective function by stating preference criteria for determining the optimal solutions to these predicates. This paper extends the PLP paradigm with facilities to formulate relaxation problems in a natural manner. We introduce the concept of a relaxation goal, and discuss its use for preference relaxation. Our model-theoretic semantics of relaxation is based on simple concepts from modal logic: Essentially, each world in the possible-worlds semantics for a preference logic program is a model for the constraints of the program, and an ordering over these worlds is determined by the objective function. Optimization can then be expressed as truth in strongly optimal worlds, while relaxation becomes truth in suitably-defined suboptimal worlds. We also present an operational semantics for relaxation as well as correctness results. Our conclusion is that the concept of preference provides a unifying framework for formulating optimization as well as relaxation problems. To appear in the Proceedings of the 23rd ACM SIGPLAN-SIGACT Symposium on the Principles of Programming Languages. January 1996. Also available as Department of Computer Science SUNY at Buffalo, Technical Report TR 95-37. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Brown, S. Mantha, and T. Wakayama. </author> <title> Logical Reconstruction of Constraint Relaxation Hierarchies in Logic Programming. </title> <booktitle> In Proc. of 7th Intl. Symp. on Methodologies for Intelligent Systems, </booktitle> <publisher> LNAI 689, </publisher> <address> Trondheim Norway, </address> <year> 1993. </year>
Reference: [2] <author> A. Brown, S. Mantha, and T. Wakayama. </author> <title> Preference Logics: Towards a Unified Approach to Non-Monotonicity in Deductive Reasoning. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <volume> 10 </volume> <pages> 233-280, </pages> <year> 1994. </year>
Reference-contexts: In the above approach, the worlds constructed at different levels are different. This enables us to obtain the optimal solutions at one level without regard to the orderings enforced by arbiter clauses at higher levels. If we maintained one set of worlds for all levels as in <ref> [2] </ref>, the orderings enforced by arbiter clauses at one level might conflict with those at a lower level, thereby disallowing optimal solutions to O-predicates at the lower level.
Reference: [3] <author> F. Fages. </author> <title> On the Semantics of Optimization Predicates in CLP Languages. </title> <booktitle> In Proc. 13th Conf. on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <year> 1993. </year>
Reference: [4] <author> F. Fages, J. Fowler, and T. Sola. </author> <title> Handling Preferences in Constraint Logic Programming with Relational Optimization. </title> <booktitle> In Proc. 6th Intl. Symposium PLILP '94, LNCS 844, </booktitle> <year> 1994. </year>
Reference: [5] <author> S. Ganguly, S. Greco, and C. Zaniolo. </author> <title> Minimum and Maximum Predicates in Logic Programming. </title> <booktitle> In Proc. 10th ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 154-163, </pages> <year> 1991. </year>
Reference: [6] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Proc. 5th Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1081-1086, </pages> <year> 1988. </year>
Reference: [7] <author> K. Govindarajan, B. Jayaraman, and S. Mantha. </author> <title> Preference Logic Grammars. </title> <type> Technical Report 94-27, </type> <institution> Dept. of Computer Science, SUNY at Buffalo, </institution> <year> 1994. </year>
Reference: [8] <author> K. Govindarajan, B. Jayaraman, and S. Mantha. </author> <title> Preference Logic Programming. </title> <booktitle> In Proc. 12th Intl. Conf. on Logic Programming, </booktitle> <pages> pages 731-745, </pages> <year> 1995. </year>
Reference-contexts: The intended preference model at level k + 1 contains all those worlds that model the clauses defining the O-predicates at level k + 1. The ordering among the worlds is enforced by the arbiter clauses for the O-predicates at level k + 1. The reader is referred to <ref> [8] </ref> for examples and a more detailed description of the model theory. Given a preference logic program P with n levels of O-predicates, the intended preference model of P is the intended preference model at level n. <p> Theorem 1 Given a preference logic program P and a relaxation query G, the relaxed intended preference model exists and is unique. Proof Sketch: For any preference logic program P , its intended preference model is unique <ref> [8] </ref>. The relaxed intended preference model is constructed from the intended preference model. Since the C-predicate in the relaxation goal is interpreted uniformly across the worlds, the set of worlds in the relaxed intended preference model is well defined. <p> Theorem 2 For any preference logic program P with relax-able goals in the body, the relaxed intended preference model exists and is unique. The proof is similar to the case for preference logic programs without relaxation goals <ref> [17, 8] </ref>. 5 Operational Semantics After briefly reviewing the operational semantics of preference logic programs without relaxation goals [8], we present an extension of the operational semantics for programs with relaxation goals in the bodies of clauses. 5.1 Operational Semantics of Optimization We now briefly review a derivation scheme called PTSLD-derivation, <p> The proof is similar to the case for preference logic programs without relaxation goals [17, 8]. 5 Operational Semantics After briefly reviewing the operational semantics of preference logic programs without relaxation goals <ref> [8] </ref>, we present an extension of the operational semantics for programs with relaxation goals in the bodies of clauses. 5.1 Operational Semantics of Optimization We now briefly review a derivation scheme called PTSLD-derivation, which stands for Pruned Tree SLD-derivation, for efficiently computing the optimal valuations to queries presented in [8]. <p> goals <ref> [8] </ref>, we present an extension of the operational semantics for programs with relaxation goals in the bodies of clauses. 5.1 Operational Semantics of Optimization We now briefly review a derivation scheme called PTSLD-derivation, which stands for Pruned Tree SLD-derivation, for efficiently computing the optimal valuations to queries presented in [8]. <p> Proof Sketch: The proof is by induction on the levels of the O-predicates in the program. It makes use of the lemma above. 6 Conclusions The concept of preference provides a unifying approach to formulating problems requiring optimization and relaxation. In earlier work <ref> [8] </ref>, we showed how optimization problems can be specified declaratively in the paradigm of preference logic programming. This paper extends our previous work in showing how the paradigm can also capture the notion of relaxation. Motivated by practical considerations, we introduced the notion of preference relaxation in this paper.
Reference: [9] <author> K. Govindarajan, B. Jayaraman, and S. Mantha. </author> <title> Relaxation in Constraint Logic Languages. </title> <type> Technical Report 95-22, </type> <institution> Dept. of Computer Science, SUNY at Buffalo, </institution> <year> 1995. </year>
Reference-contexts: The key difference between our presentation here and the presentation in <ref> [9] </ref> is the following. Since we now allow relaxation goals to occur in the bodies of clauses, the relaxed version of the O-predicate gets a very specific name depending on the exact arguments with which it is invoked. [9] did not allow relaxation goals to occur in the bodies of clauses <p> The key difference between our presentation here and the presentation in <ref> [9] </ref> is the following. Since we now allow relaxation goals to occur in the bodies of clauses, the relaxed version of the O-predicate gets a very specific name depending on the exact arguments with which it is invoked. [9] did not allow relaxation goals to occur in the bodies of clauses and therefore the operational semantics described there did not require the name of the relaxed version of an O-predicate to be so specialized.
Reference: [10] <author> J. Jaffar and J. L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. 14th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119, </pages> <year> 1987. </year>
Reference-contexts: Below we assume that the program consists of definite and optimization clauses without constraints in the sense of <ref> [10, 11] </ref>; we subsequently describe how this scheme can be extended to the case where the program contains constraints as goals in bodies of clauses. 5.1.1 PTSLD-Derivations Let P be a definite clause program and G a positive goal.
Reference: [11] <author> J. Jaffar and M. J. Maher. </author> <title> Constraint Logic Programming: A Survey. </title> <journal> Journal of Logic Programming, </journal> <year> 1994. </year>
Reference-contexts: Below we assume that the program consists of definite and optimization clauses without constraints in the sense of <ref> [10, 11] </ref>; we subsequently describe how this scheme can be extended to the case where the program contains constraints as goals in bodies of clauses. 5.1.1 PTSLD-Derivations Let P be a definite clause program and G a positive goal.
Reference: [12] <author> P. C. Kannelakis, G. M. Kuper, and P. Z. Revesz. </author> <title> Constraint Query Languages. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 299-313, </pages> <year> 1990. </year>
Reference-contexts: All the predicates in a cycle get assigned the same ordinal. 4 In the presence of constraints, this refers to the generalized Her-brand Base <ref> [12] </ref>. In the above approach, the worlds constructed at different levels are different. This enables us to obtain the optimal solutions at one level without regard to the orderings enforced by arbiter clauses at higher levels.
Reference: [13] <author> D. B. Kemp and P. J. Stuckey. </author> <title> Semantics of Logic Programs with Aggregates. </title> <booktitle> In Proc. International Logic Programming Symposium, </booktitle> <year> 1991. </year>
Reference: [14] <author> E. L. Lawler, J. K. Lenstra, A. H. G. Rinnooy Kan, and D. B. </author> <title> Shmoys (eds.). The Traveling Salesman Problem: a Guided Tour of Combinatorial Optimization. </title> <publisher> Wiley and Sons, </publisher> <address> Chichester, United Kingdom, </address> <year> 1985. </year>
Reference: [15] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <month> 12 </month>
Reference-contexts: Proof Sketch: By induction on the levels of the PTLSD search tree and the soundness and completeness of SLD-derivations for definite clauses <ref> [15] </ref>. All the solutions to O-predicates are considered as the ! clauses are interpreted exactly as the clauses by the operational semantics. Since O-predicates have to be sufficiently uninstantiated when invoked, we can show that the pruning is sound.
Reference: [16] <author> M. J. Maher and P. J. Stuckey. </author> <title> Expanding Query Power in Constraint Logic Programming Languages. </title> <editor> In E. L. Lusk and R. A. Overbeek, editors, </editor> <booktitle> Proc. North American Conference on Logic Programming, </booktitle> <pages> pages 20-36, </pages> <year> 1989. </year>
Reference: [17] <author> S. Mantha. </author> <title> First-Order Preference Theories and their Applications. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> Novem-ber </month> <year> 1991. </year>
Reference-contexts: introduction to the modal logic of preference <ref> [17] </ref>. The syntax of this logic extends the syntax of first-order logic by adding a new modal operator P f with the associated rule of formation: If F is a formula then so is P f F . <p> definite preference clause p ( t) p (u) L 1 ; : : : ; L n in a preference logic program as a formula p ( t) ! P f (p (u) ^ L 1 ^ : : : ^ L n ) In the tradition of modal logic, <ref> [17] </ref> provides a possible worlds semantics for this logic. A preference frame F is an ordered pair of the form hW; i, where W is a non-empty set of possible worlds and is a binary relation over W. <p> Theorem 2 For any preference logic program P with relax-able goals in the body, the relaxed intended preference model exists and is unique. The proof is similar to the case for preference logic programs without relaxation goals <ref> [17, 8] </ref>. 5 Operational Semantics After briefly reviewing the operational semantics of preference logic programs without relaxation goals [8], we present an extension of the operational semantics for programs with relaxation goals in the bodies of clauses. 5.1 Operational Semantics of Optimization We now briefly review a derivation scheme called PTSLD-derivation,
Reference: [18] <author> K. Marriott and P. J. Stuckey. </author> <title> Semantics of Constraint Logic Programs with Optimization. </title> <journal> Letters on Programming Languages and Systems, </journal> <volume> 2(1-4):181-196, </volume> <year> 1993. </year>
Reference: [19] <author> F. C. N. Pereira and D. H. D. Warren. </author> <title> Definite Clause Grammars for Language Analysis A Survey of the Formalism and a Comparison with Augmented Transition Networks. </title> <journal> Artificial Intelligence, </journal> <volume> 13 </volume> <pages> 231-278, </pages> <year> 1980. </year>
Reference: [20] <author> K. A. Ross and Y. Sagiv. </author> <title> Monotonic Aggregation in Deductive Databases. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 114-126, </pages> <year> 1992. </year>
Reference: [21] <author> S. Sudarshan and R. Ramakrishnan. </author> <title> Aggregation and Relevance in Deductive Databases. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1991. </year>
Reference: [22] <author> S. Sudarshan, D. Srivastava, R. Ramakrishnan, and C. Beeri. </author> <title> Extending the Well-Founded and Valid Semantics for Aggregation. </title> <booktitle> In Proc. International Logic Programming Symposium, </booktitle> <pages> pages 590-608, </pages> <year> 1993. </year>
Reference: [23] <author> A. van Gelder, K. Ross, and J.S. Schlipf. </author> <title> Unfounded Sets and Well-Founded Semantics for General Logic Programs. </title> <journal> JACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference: [24] <author> M. Wilson and A. Borning. </author> <title> Hierarchical Constraint Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 16 </volume> <pages> 277-318, </pages> <year> 1993. </year>
References-found: 24

