URL: ftp://ftp.cs.man.ac.uk/pub/hardware-verification/AHV-PROJECT/charme97-paper.ps.gz
Refering-URL: http://www.cs.man.ac.uk/fmethods/projects/AHV-PROJECT/node16.html
Root-URL: http://www.cs.man.ac.uk
Email: email: fvisserw,howard,donal,graham,alanwg@cs.man.ac.uk  
Phone: phone: +44 (0) 161-275-6248 fax: +44 (0) 161-275-6211  
Title: Efficient CTL Model Checking for Analysis of Rainbow Designs  
Author: W. Visser, H. Barringer, D. Fellows, G. Gough, A. Williams 
Address: Manchester, Manchester M13 9PL, UK  
Affiliation: Department of Computer Science University of  
Abstract: We describe an efficient implementation of a CTL fl model-checking algorithm based on alternating automata. We use this to check properties of an asynchronous mi-cropipeline design described in the Rainbow framework, which operates at the mi-cropipeline level and leads to compact models of the hardware. We also use alternating automata to characterise the expressive power and model-checking complexity for sub-logics of CTL fl . Keywords: CTL fl model-checking, alternating automata, asynchronous hardware micropipeline design.
Abstract-found: 1
Intro-found: 1
Reference: <editor> Asy (1997), </editor> <booktitle> Third International Symposium on Advanced Research in Asynchronous Circuits and Systems, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <address> Eindhoven, The Netherlands. </address>
Reference: <author> Barringer, H., Fellows, D., Gough, G., Jinks, P., Marsden, B. & Williams, A. </author> <year> (1996), </year> <title> Design and simulation in rainbow: A framework for asynchronous micropipeline circuits., </title> <editor> in A. Bruzzone & U. Kerckhoffs, eds, </editor> <booktitle> `Proceedings of the European Simulation Symposium (ESS'96)', </booktitle> <volume> Vol. 2, </volume> <booktitle> Society for Computer Simulation International, </booktitle> <address> Genoa, Italy, </address> <note> References pp. 567571. See also the Rainbow Project web pages, URL: http://www.cs.man. ac.uk/fmethods/projects/AHV-PROJECT/ahv-project.html. </note>
Reference-contexts: However, designers are hampered by the current lack of suitable specialised design representations for asynchronous systems, and support or analysis tools for checking properties such as equivalence or deadlock-freedom, the latter being of particular concern to the asynchronous design community. We have developed the Rainbow asynchronous design framework <ref> (Barringer et al. 1996, Barringer et al. 1997) </ref> as a means of giving compact abstract descriptions of micropipeline designs. From these, we can generate state-based models for analysis using automated model-checking tools. Of course, model-checking suffers in general c flIFIP 1997.
Reference: <author> Barringer, H., Fellows, D., Gough, G. & Williams, A. </author> <year> (1997), </year> <title> Abstract Modelling of Asynchronous Micropipeline Systems using Rainbow, </title> <note> in Kloos & Cerny (1997). </note>
Reference: <author> Bernholtz, O. </author> <year> (1995), </year> <title> Model Checking for Branching Time Temporal Logics, </title> <type> PhD thesis, </type> <institution> The Technion, Haifa, Israel. </institution>
Reference-contexts: Recently it has been shown that alternating tree automata are the automata-theoretic counterpart for branching time logics <ref> (Bernholtz 1995, Vardi 1995, Bernholtz et al. 1994) </ref>. Not only does the translation into alternating tree automata allow matching of the linear time complexity of CTL model checking, but also of the space efficiency of CTL model checking. <p> An infinite path in the run of a WAA will therefore get trapped within some S i ; if this S i is accepting then the path satisfies the acceptance condition. WAA can be used to define linear time algorithms for model checking CTL <ref> (Bernholtz 1995) </ref>. Bernholtz et al. (1994) defined bounded alternation WAA, that allows also space efficient CTL model checking. In fact, it was shown that CTL model checking is in NLOGSPACE in the size of the Kripke structure. <p> If the language accepted by A K;j is nonempty then j holds for K. Thus, a non-emptiness check for HAA is required to check CTL/CTL fl properties in K. The general non-emptiness check for HAA cannot be done efficiently <ref> (Bernholtz 1995) </ref>. Fortunately, taking the product with the Kripke structure K, results in a 1-letter HAA over words (i.e. a HAA with jSj = 1 and D = f1g), for which a non-emptiness check can be done in linear time (Bernholtz 1995). Let us now define this product automaton. <p> The general non-emptiness check for HAA cannot be done efficiently <ref> (Bernholtz 1995) </ref>. Fortunately, taking the product with the Kripke structure K, results in a 1-letter HAA over words (i.e. a HAA with jSj = 1 and D = f1g), for which a non-emptiness check can be done in linear time (Bernholtz 1995). Let us now define this product automaton. <p> we do not translate the linear time formula into an alternating Buchi word automaton, even though this translation is known to be linear (see section 3.4); this is because the reduction to a 1-letter non-emptiness problem is impossible for alternating Buchi word automata, but valid for nondeterministic Buchi word automata <ref> (Bernholtz 1995) </ref>. Example 3: Consider the CTL fl formula j = AF Gp. Since it is of the form Ay we need to negate and complement the HAA for EGF:p.
Reference: <author> Bernholtz, O. & Grumberg, O. </author> <year> (1994), </year> <title> Buy One, </title> <booktitle> Get One Free !!!, in `ICTL '94 : 1st International Conference on Temporal Logic', Vol. 827 of Lecture Notes in Artificial Intelligence. </booktitle>
Reference-contexts: show that CTL 2 can be checked by a CTL model checker: all the translations given in Bernholtz & Grumberg (1994) were shown to hold by simply generating the alternating automata for the CTL fl formula and translating these automata back to CTL, thus avoiding the cumbersome proofs required in <ref> (Bernholtz & Grumberg 1994) </ref> to show the translations to be valid. The only formula (AFGp) for which the translation back to CTL did not work (since it cannot be expressed by CTL) is shown to have an efficient model checking algorithm of linear complexity (Bernholtz & Grumberg 1994). <p> avoiding the cumbersome proofs required in <ref> (Bernholtz & Grumberg 1994) </ref> to show the translations to be valid. The only formula (AFGp) for which the translation back to CTL did not work (since it cannot be expressed by CTL) is shown to have an efficient model checking algorithm of linear complexity (Bernholtz & Grumberg 1994). Future work in this area will be concerned with finding even more expressive logics with efficient model checking algorithms, by exploiting the theory of alternating automata.
Reference: <author> Bernholtz, O. & Vardi, M. </author> <year> (1995), </year> <title> On the Complexity of Branching Modular Model Checking, </title> <booktitle> in `CONCUR '95: 6th International Conference on Concurrency Theory', Vol. 962 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: Recently it has been shown that alternating tree automata are the automata-theoretic counterpart for branching time logics <ref> (Bernholtz 1995, Vardi 1995, Bernholtz et al. 1994) </ref>. Not only does the translation into alternating tree automata allow matching of the linear time complexity of CTL model checking, but also of the space efficiency of CTL model checking. <p> An infinite path in the run of a WAA will therefore get trapped within some S i ; if this S i is accepting then the path satisfies the acceptance condition. WAA can be used to define linear time algorithms for model checking CTL <ref> (Bernholtz 1995) </ref>. Bernholtz et al. (1994) defined bounded alternation WAA, that allows also space efficient CTL model checking. In fact, it was shown that CTL model checking is in NLOGSPACE in the size of the Kripke structure. <p> If the language accepted by A K;j is nonempty then j holds for K. Thus, a non-emptiness check for HAA is required to check CTL/CTL fl properties in K. The general non-emptiness check for HAA cannot be done efficiently <ref> (Bernholtz 1995) </ref>. Fortunately, taking the product with the Kripke structure K, results in a 1-letter HAA over words (i.e. a HAA with jSj = 1 and D = f1g), for which a non-emptiness check can be done in linear time (Bernholtz 1995). Let us now define this product automaton. <p> The general non-emptiness check for HAA cannot be done efficiently <ref> (Bernholtz 1995) </ref>. Fortunately, taking the product with the Kripke structure K, results in a 1-letter HAA over words (i.e. a HAA with jSj = 1 and D = f1g), for which a non-emptiness check can be done in linear time (Bernholtz 1995). Let us now define this product automaton. <p> we do not translate the linear time formula into an alternating Buchi word automaton, even though this translation is known to be linear (see section 3.4); this is because the reduction to a 1-letter non-emptiness problem is impossible for alternating Buchi word automata, but valid for nondeterministic Buchi word automata <ref> (Bernholtz 1995) </ref>. Example 3: Consider the CTL fl formula j = AF Gp. Since it is of the form Ay we need to negate and complement the HAA for EGF:p.
Reference: <author> Bernholtz, O., Vardi, M. & Wolper, P. </author> <year> (1994), </year> <title> An Automata-Theoretic Approach to Branching-Time Model Checking, </title> <booktitle> in `CAV '94 : 6th International Conference on Computer Aided Verification', Vol. 818 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: show that CTL 2 can be checked by a CTL model checker: all the translations given in Bernholtz & Grumberg (1994) were shown to hold by simply generating the alternating automata for the CTL fl formula and translating these automata back to CTL, thus avoiding the cumbersome proofs required in <ref> (Bernholtz & Grumberg 1994) </ref> to show the translations to be valid. The only formula (AFGp) for which the translation back to CTL did not work (since it cannot be expressed by CTL) is shown to have an efficient model checking algorithm of linear complexity (Bernholtz & Grumberg 1994). <p> avoiding the cumbersome proofs required in <ref> (Bernholtz & Grumberg 1994) </ref> to show the translations to be valid. The only formula (AFGp) for which the translation back to CTL did not work (since it cannot be expressed by CTL) is shown to have an efficient model checking algorithm of linear complexity (Bernholtz & Grumberg 1994). Future work in this area will be concerned with finding even more expressive logics with efficient model checking algorithms, by exploiting the theory of alternating automata.
Reference: <author> Birtwistle, G. & Davis, A., </author> <title> eds (1995), Asynchronous Digital Circuit Design, </title> <publisher> Springer. </publisher>
Reference-contexts: 1 INTRODUCTION There is renewed interest in asynchronous hardware design, in particular at the VLSI chip level <ref> (Birtwistle & Davis 1995, Asy 1997) </ref>, as an alternative to the (globally clocked) synchronous approach which has dominated the recent past.
Reference: <author> Burns, A. </author> <year> (1988), </year> <title> Programming in Occam 2, </title> <publisher> Addison-Wesley. </publisher>
Reference-contexts: The Rainbow asynchronous design framework offers a suite of unified design and modelling languages for giving mixed-view hierarchical descriptions of asynchronous micropipeline systems. Rainbow includes a control-flow sequential language, called Yellow, that is similar to occam <ref> (Burns 1988) </ref>, but uses an Ada-like rendezvous. A (static) dataflow-style language called Green uses micropipeline communication as Rainbow Designs primitive, thus hiding lower-level handshaking control components we will concentrate on the latter here.
Reference: <author> Clarke, E., Emerson, E. & Sistla, A. </author> <year> (1986), </year> <title> `Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications', </title> <journal> ACM Transactions on Programming Languages and Systems 8(2), </journal> <volume> 244263. </volume>
Reference-contexts: Although this may be acceptable in the linear case, where model checking for the propositional linear time temporal logic (LTL) is known to be PSPACE-complete (Sistla & Clarke 1985), it is not for branching time where the well-known logic CTL has a linear time model checking algorithm <ref> (Clarke et al. 1986) </ref>. Recently it has been shown that alternating automata on infinite trees, first introduced in Muller et al. (1986), is a solution for efficient translation of branching time temporal logics to automata (Vardi 1995, Bernholtz et al. 1994, Bernholtz 1995, Bernholtz & Vardi 1995). <p> and the results are compared with those obtained from Promela/SPIN (Holzmann 1991). 2 SYNTAX AND SEMANTICS OF CTL fl Since CTL fl can express both linear and branching time properties, it is more expressive than the linear time logic LTL (Lichtenstein & Pnueli 1985) and the branching time logic CTL <ref> (Clarke et al. 1986) </ref>. In fact, both these logics are sub-logics of CTL fl . Here, only positive CTL fl formulas will be used, i.e. formulas with negations only applied to atomic propositions. <p> For branching time logics, a translation to automata over infinite trees is required. Here, however, the exponential blowup in size of the resulting nondeterministic automata (Vardi & Wolper 1986a) is unacceptable, since it is known that for some branching time logics a linear model checking algorithm exist <ref> (Clarke et al. 1986) </ref>. Recently it has been shown that alternating tree automata are the automata-theoretic counterpart for branching time logics (Bernholtz 1995, Vardi 1995, Bernholtz et al. 1994).
Reference: <author> Courcoubetis, C., Vardi, M., Wolper, P. & Yannakakis, M. </author> <year> (1992), </year> <title> `Memory-Efficient Algorithms for the Verification of Temporal Properties', Formal Methods in System Design 1, </title> <type> 275288. </type>
Reference: <author> Furber, S. </author> <year> (1995), </year> <title> Computing Without Clocks: Micropipelining the ARM Processor, </title> <booktitle> in Birtwistle & Davis (1995), </booktitle> <pages> pp. 211262. </pages>
Reference-contexts: This new interest has coincided with the emergence of new asynchronous design methodologies, in particular Sutherland's (1989) Micropipeline technique. This has been used successfully to develop significant designs, including asynchronous versions of the ARM microprocessor <ref> (Furber 1995, Furber et al. 1997) </ref> developed by the AMULET Group at the University of Manchester.
Reference: <author> Furber, S., Garside, J., Temple, S. & Liu, J. </author> <year> (1997), </year> <title> AMULET2e: An Asynchronous Embedded Controller, </title> <booktitle> in Asy (1997). </booktitle>
Reference: <author> Gerth, R., Peled, D., Vardi, M. & Wolper, P. </author> <year> (1995), </year> <title> Simple on-the-fly automatic verification of linear temporal logic, in `Protocol Specification Testing and Verification', </title> <publisher> Chapman & Hall, </publisher> <address> Warsaw, Poland, </address> <pages> pp. 318. </pages>
Reference-contexts: With each LTL formula a nondeterministic finite automaton over infinite words, B uchi automaton, is associated that accepts exactly all the computations that satisfy the formula <ref> (Gerth et al. 1995) </ref>. This translation is exponential in the size of the formula, but this matches the PSPACE complexity of LTL model checking. For branching time logics, a translation to automata over infinite trees is required.
Reference: <author> Holzmann, G. </author> <year> (1991), </year> <title> Design and Validation of Computer Protocols, </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, New Jersey. </address>
Reference-contexts: Syntax and Semantics of CTL fl its underlying semantics. The alternating automata model checker is used to analyse the address interface design in section 4.2, and the results are compared with those obtained from Promela/SPIN <ref> (Holzmann 1991) </ref>. 2 SYNTAX AND SEMANTICS OF CTL fl Since CTL fl can express both linear and branching time properties, it is more expressive than the linear time logic LTL (Lichtenstein & Pnueli 1985) and the branching time logic CTL (Clarke et al. 1986). <p> Our algorithm is goal directed, that is to say, only the part of the state space required to satisfy (or invalidate) the formula is visited. Also, the state space is generated on-the-fly and in a depth-first manner, similar to the LTL model checker SPIN <ref> (Holzmann 1991) </ref>. A stack is kept for all the states in the current path and a hash table for all the states that are no longer on the current path, but have been visited before.
Reference: <author> Holzmann, G., Peled, D. & Yannakakis, M. </author> <year> (1996), </year> <title> On Nested Depth First Search, </title> <booktitle> in J.-C. </booktitle>
Reference-contexts: We adopted the algorithm proposed in Courcoubetis et al. (1992) and implemented in SPIN <ref> (Holzmann et al. 1996) </ref>, where a second depth-first search is started whenever a state in a universal (existential) set and in B (G) is backtracked, to see if this state is reachable from itself.
Reference: <author> Gregoire, G. J. Holzmann & D. </author> <title> Peled, </title> <editor> eds, </editor> <booktitle> `Proceedings of the Second Workshop in the SPIN Verification System', </booktitle> <publisher> American Mathematical Society, DIMACS/39. </publisher>
Reference: <author> Kloos, C. D. & Cerny, E., </author> <title> eds (1997), Hardware Description Languages and their Applications (CHDL'97), </title> <publisher> Chapman and Hall, </publisher> <address> Toledo, Spain. </address>
Reference: <author> Lamport, L. </author> <year> (1980), </year> <title> `Sometimes is sometimes not never on the Temporal Logic of Programs', </title> <booktitle> Proceedings 7th ACM Symposium on Principles of Programming Languages pp. </booktitle> <pages> 174185. </pages>
Reference-contexts: Temporal logics are popular property-description languages since they can describe event orderings without having to introduce time explicitly. There are two main kinds of temporal logics: linear and branching <ref> (Lamport 1980) </ref>. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time has several possible futures. We adopt as our property language the branching time temporal logic CTL fl that can express both linear and branching time properties.
Reference: <author> Lichtenstein, O. & Pnueli, A. </author> <year> (1985), </year> <title> `Checking That Finite State Concurrent Programs Satisfy Their Linear Specification', </title> <booktitle> Proceedings 12th ACM Symposium on Principles of Programming Languages pp. </booktitle> <pages> 97107. </pages>
Reference-contexts: used to analyse the address interface design in section 4.2, and the results are compared with those obtained from Promela/SPIN (Holzmann 1991). 2 SYNTAX AND SEMANTICS OF CTL fl Since CTL fl can express both linear and branching time properties, it is more expressive than the linear time logic LTL <ref> (Lichtenstein & Pnueli 1985) </ref> and the branching time logic CTL (Clarke et al. 1986). In fact, both these logics are sub-logics of CTL fl . Here, only positive CTL fl formulas will be used, i.e. formulas with negations only applied to atomic propositions.
Reference: <author> Liu, Y. </author> <year> (1995), </year> <title> AMULET1: Specification and Verification in CCS, </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Calgary. </institution>
Reference: <author> Milner, R. </author> <year> (1989), </year> <title> Communication and Concurrency, </title> <publisher> Prentice Hall, </publisher> <address> Hemel Hempstead, Herts, England. </address>
Reference-contexts: In Rainbow, the micropipeline communication is atomic, both at the user-language level only a single (data) channel and the data transfer activity on the channel is seen by the designer and at the semantics level. In other description methods, such as CCS <ref> (Milner 1989) </ref>, occam or Promela, then the full handshake must be explicitly encoded, by the user and in the semantics, because the communication primitive is simply a synchronisation.
Reference: <author> Muller, D., Saoudi, A. & Schupp, P. </author> <year> (1986), </year> <title> Alternating Automata, the Weak Monadic Therory Efficient CTL fl Model Checking of the Tree and its Complexity, </title> <booktitle> in `13th International Colloquium on Automata, Languages and Programming', Vol. 226 of Lecture Notes in Computer Science. </booktitle>
Reference: <author> Muller, D., Saoudi, A. & Schupp, P. </author> <year> (1988), </year> <title> Weak Alternating Automata give a simple Explanation of why Temporal and Dynamic Logics are Decidable in Exponential Time, </title> <booktitle> in `Third Symposium on Logic in Computer Science', </booktitle> <pages> pp. 422427. </pages>
Reference: <author> Paver, N. </author> <year> (1994), </year> <title> The Design and Implementation of an Asynchronous Microprocessor, </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Manchester. </institution>
Reference-contexts: Firstly, the abstract design representation using Rainbow reduces the size of the design model, and secondly we define sub-logics of CTL fl for which linear sized alternating automata exist that also allow for efficient model checking. This will be illustrated using a simplified version of the AMULET1 address interface <ref> (Paver 1994) </ref>; we show this to be deadlock-free, whereas an earlier version of the design contains a deadlock. The rest of the paper is structured as follows. First we give the syntax and semantics of CTL fl and review the theory of alternating automata.
Reference: <author> Schneider, K. </author> <year> (1997), </year> <note> CTL and Equivalent Sublanguages of CTL fl , in Kloos & Cerny (1997). </note>
Reference-contexts: One of the advantages of using alternating automata is that we do not need syntax-directed translations between sub-logics in CTL fl and CTL formulas, as used in <ref> (Schneider 1997, Bernholtz & Grumberg 1994) </ref>, to show that efficient model checking algorithms exist for these sub-logics, but rather we simply translate them into alternating automata and check these to see if they conform to the requirements for efficient CTL model checking.
Reference: <author> Sistla, A. & Clarke, E. </author> <year> (1985), </year> <title> `The Complexity of Propositional Linear Temporal Logics', </title> <journal> Journal of the ACM 32(3), </journal> <volume> 733749. </volume>
Reference-contexts: However, for both branching and linear time temporal logics, there is an exponential increase when going from formulas to nondeterministic automata. Although this may be acceptable in the linear case, where model checking for the propositional linear time temporal logic (LTL) is known to be PSPACE-complete <ref> (Sistla & Clarke 1985) </ref>, it is not for branching time where the well-known logic CTL has a linear time model checking algorithm (Clarke et al. 1986).
Reference: <author> Sutherland, I. </author> <year> (1989), </year> <note> `Micropipelines', Communications of the ACM 32(6). </note>
Reference: <author> Thomas, W. </author> <year> (1990), </year> <title> `Automata on Infinite Objects', </title> <booktitle> Handbook of Theoretical Computer Science pp. </booktitle> <pages> 165191. </pages>
Reference: <author> Vardi, M. </author> <year> (1995), </year> <title> Alternating Automata and Program Verification, </title> <booktitle> in `Computer Science Today. Recent Trends and Developments.', Vol. 1000 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: Recently it has been shown that alternating tree automata are the automata-theoretic counterpart for branching time logics <ref> (Bernholtz 1995, Vardi 1995, Bernholtz et al. 1994) </ref>. Not only does the translation into alternating tree automata allow matching of the linear time complexity of CTL model checking, but also of the space efficiency of CTL model checking. <p> The construction of this logic is based on the observation that nondeterministic Buchi word automata can only express existential choice, whereas alternating Buchi word automata can express both universal and existential choice. Let us first consider the translation of LTL formula into alternating Buchi word automata <ref> (Vardi 1995) </ref>. Given an LTL formula j, an alternating Buchi word automaton A j = (2 Props ; S; s 0 ; d; F ) can be constructed such that the language it accepts is exactly the set of infinite words satisfying j.
Reference: <author> Vardi, M. & Wolper, P. </author> <year> (1986a), </year> <title> An Automata Theoretic Approach to Automatic Program Verification, </title> <booktitle> in `First Symposium on Logic in Computer Science', </booktitle> <pages> pp. 322331. </pages>
Reference-contexts: In the rest of the paper the following two abbreviations will also be used: Fj = true U j and Gj = f alse V j. 3 AUTOMATA-THEORETIC BRANCHING TIME MODEL CHECKING Automata over infinite words have long been used as the basis for model checking LTL formulas <ref> (Vardi & Wolper 1986a, Vardi & Wolper 1994) </ref>. With each LTL formula a nondeterministic finite automaton over infinite words, B uchi automaton, is associated that accepts exactly all the computations that satisfy the formula (Gerth et al. 1995). <p> This translation is exponential in the size of the formula, but this matches the PSPACE complexity of LTL model checking. For branching time logics, a translation to automata over infinite trees is required. Here, however, the exponential blowup in size of the resulting nondeterministic automata <ref> (Vardi & Wolper 1986a) </ref> is unacceptable, since it is known that for some branching time logics a linear model checking algorithm exist (Clarke et al. 1986).
Reference: <author> Vardi, M. & Wolper, P. </author> <year> (1986b), </year> <title> `Automata-theoretic Techniques for Modal Logics of Programs', </title> <journal> Journal of Computer and System Science 32(5). </journal>
Reference-contexts: We adopt as our property language the branching time temporal logic CTL fl that can express both linear and branching time properties. Nondeterministic automata have traditionally been the automata of choice when translating temporal formulas to automata <ref> (Vardi & Wolper 1986b, Vardi & Wolper 1994) </ref>. However, for both branching and linear time temporal logics, there is an exponential increase when going from formulas to nondeterministic automata.
Reference: <author> Vardi, M. & Wolper, P. </author> <year> (1994), </year> <title> `Reasoning about Infinite Computations', </title> <booktitle> Information and Computation 115(1). </booktitle>
Reference-contexts: A simple translation exists from this automaton to the HAA for Ey (see Bernholtz (1995)). Unfortunately, the Buchi word automaton is exponential in the size of the y <ref> (Vardi & Wolper 1994, Gerth et al. 1995) </ref>. This results in the complete translation from a CTL fl formula into a HAA being exponential.
References-found: 33

