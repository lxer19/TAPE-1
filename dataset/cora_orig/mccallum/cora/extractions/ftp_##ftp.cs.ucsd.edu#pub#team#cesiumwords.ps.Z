URL: ftp://ftp.cs.ucsd.edu/pub/team/cesiumwords.ps.Z
Refering-URL: http://www.cs.ucsd.edu/users/flaviu/publications.html
Root-URL: http://www.cs.ucsd.edu
Title: Cesium: Testing Hard Real-time and Dependability Properties of Distributed Protocols  
Author: Guillermo A. Alvarez Flaviu Cristian 
Web: http://www-cse.ucsd.edu/users/fgalvarez,flaviug  
Address: La Jolla, CA 920930114, USA  
Affiliation: Department of Computer Science and Engineering University of California, San Diego  
Abstract: Cesium is an object-oriented environment for testing that implementations of real-time, fault-tolerant protocols satisfy the safety and timeliness properties prescribed by their specifications. Protocol implementations are tested under configurable workloads and failure scenarios. A centralized simulator executes all tasks in a single address space while providing the appearance of truly distributed execution. Experiments can be exactly reproduced any number of times; Cesium provides an unprecedented degree of monitoring and control over them. It is not necessary to instrument (or even to have access to) the source code of the protocols under test. The observed behaviors correspond exactly to executions in the real system being simulated, as Cesium does not change the time of occurrence of any event. Besides from providing a testing and performance evaluation environment superior to real distributed systems, Cesium can test properties of existing protocols that can not be tested in any distributed environment. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Alvarez and F. Cristian. </author> <title> Centralized failure injection for distributed, fault-tolerant protocol testing. </title> <booktitle> In Proceedings of the 17th International Conference on Distributed Computing Systems, </booktitle> <address> Baltimore, Maryland, </address> <month> May </month> <year> 1997. </year> <note> Available at ftp:// cs.ucsd.edu/ pub/ galvarez/ papers/ failsim.ps.Z. </note>
Reference-contexts: Our approach provides repeatability, i.e. the ability of exactly reproducing experiments any number of times. Even though the simulation process can entail the additional tasks of checking properties, monitoring the execution, and optionally logging relevant events, we proved in <ref> [1] </ref> that the executions observed in Cesium correspond exactly to the ones feasible in the real system. Therefore, the simulation process achieves zero intrusiveness and does not suffer from the probe effect [15], where the addition of testing code may cause relevant monitored effects to disappear. <p> As a consequence of these features, Cesium provides a much better testing platform than the target distributed system. Moreover, this superiority extends to the set of testable properties <ref> [1] </ref>. The specifications of existing, widely-used protocols contain properties that are provably impossible to test in a distributed environment; but Cesium can test them exactly, since it has instantaneous access to the global state of the system. <p> Since processes depend on the values returned by the clock-reading primitive to check the passage of time, this masking is transparent from their point of view. We proved formally in <ref> [1] </ref> that events occur at exactly the same global time in R and in Cesium, and therefore there is no intrusiveness caused by the simulation process. <p> Several results are mentioned without proof; the interested reader is referred to <ref> [1] </ref> for the details. We assume that every task T executes deterministically as a function of the messages received, the crashes and restarts suffered by T , the moments at which these events occur, and the values read from T 's local clock during the execution.
Reference: [2] <author> G. Alvarez, F. Cristian, and S. Mishra. </author> <title> On-demand asynchronous atomic broadcast. </title> <booktitle> In Proceedings of the 5th IFIP Working Conference on Dependable Computing for Critical Applications, </booktitle> <address> Urbana, IL, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Highly available group services allow a set of processors to cooperate on a common task despite the occurrence of component failures in distributed systems. Examples of these services include group membership [9], atomic broadcast <ref> [2] </ref>, and clock synchronization [11]. To use these services as building blocks for the development of dependable applications, they must exhibit a well-defined behavior when failures occur [10]. Furthermore, real-time services must deliver the correct results within bounded time intervals. <p> A protocol stack is a particular case of hierarchy. Cesium can test protocols at any level of the hierarchy. Consider the example in which an asynchronous atomic broadcast service <ref> [2] </ref> must be tested, that depends upon a group membership and a datagram communication services. Figure 3 (a) shows the hierarchy of tasks in R, including the clients that broadcast and receive updates at each participating node.
Reference: [3] <author> J. Arlat, A. Costes, Y. Crouzet, J.-C. Laprie, and D. Powell. </author> <title> Fault injection and dependability evaluation of fault-tolerant systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 42(8) </volume> <pages> 913-23, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: In general, timeliness properties are exactly testable along the same lines. We proved formally this intuitive argument as in the case of safety properties: timeliness properties can be tested in Cesium without missing real violations, and without reporting inexistent ones. 7 Related Work Existing environments like Messaline <ref> [3] </ref>, Fiat [18], Depend [16], and Doctor [17] either inject or simulate the occurrence of faults at the hardware level.
Reference: [4] <institution> Asymetrix Corp. </institution> <note> SuperCede Release Notes, May 1996. Available at http:// www.asymetrix.com/ nettools/ vm. </note>
Reference-contexts: By substituting the standard java.net class names by Cesium's simulated versions in the bytecode files, the s-servers can be run in the simulator without problems. On-the-fly compilation techniques can execute Java code at speeds comparable to compiled C++ <ref> [4] </ref>. 4 Failure Simulation The failures that can be injected by the driver during the execution belong to three classes. UCTs can crash and restart any node by invoking Cesium primitives that simulate a total amnesia crash, and re-execute the initializations of every task on the restart ing node.
Reference: [5] <author> E. Brewer, C. Dellarocas, A. Colbrook, and W. Weihl. Proteus: </author> <title> A high-performance parallel-architecture simulator. </title> <booktitle> In Proceedings of the 1992 ACM SIGMETRICS, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: Direct execution results in very small simulation overhead <ref> [5] </ref>. As depicted in Figure 2, intertask communication is simulated by using event queues. Each task T has a queue that contains descriptors for the events that will occur at T in the future, ordered by increasing time of occurrence. <p> It is not necessary to have a node of the real system available for testing: the tester can optionally specify a constant k for the relative execution speeds of the real nodes and Cesium's host machine. Previous research in the simulation field <ref> [5] </ref> shows that a single constant gives a good approximation to the real system's execution times, since the inaccuracies tend to cancel out when amortized over many instructions. 3 Modular Structure The distributed system being simulated is structured as a hierarchy of services, where each service is above the services upon <p> We proved formally in [1] that events occur at exactly the same global time in R and in Cesium, and therefore there is no intrusiveness caused by the simulation process. Other approaches like <ref> [5, 12] </ref> add counting instructions to the code under test, thus changing its timing behavior (e.g. a deadline that would never be missed in R might be missed in the simulation). <p> Since it runs on a distributed platform, it suffers from the limitations discussed in Section 6 for coordination and property testing. Another difference is that Orchestra will, in general, interfere with the execution by introducing additional overhead. Proteus <ref> [5] </ref> and Tango [12] are centralized simulators of MIMD parallel architectures. They are well suited for debugging and performance evaluation, but they support neither failure simulation, nor timely testing of properties.
Reference: [6] <author> S. Budkowski. </author> <title> Estelle development toolset (EDT). </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 25(1) </volume> <pages> 63-82, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Another difference is that Orchestra will, in general, interfere with the execution by introducing additional overhead. Proteus [5] and Tango [12] are centralized simulators of MIMD parallel architectures. They are well suited for debugging and performance evaluation, but they support neither failure simulation, nor timely testing of properties. EDT <ref> [6] </ref> simulates the execution of specifications written in the Estelle language; the tester has access to the global state, and safety properties can be tested. This is a rather interesting approach, but it does not support accurate testing of timeliness properties as relevant events can be arbitrarily late.
Reference: [7] <author> R. Covington, S. Madala, V. Mehta, J. Jump, and J. Sinclair. </author> <title> The Rice parallel processing testbed. </title> <booktitle> In Proceedings of the 1988 ACM SIGMETRICS, </booktitle> <month> May </month> <year> 1988. </year>
Reference-contexts: Cesium allows the human tester to perform experiments during which the implementations under test are subject to requests for service from simulated clients, and to the failure scenarios they are designed to tolerate. It is based on an execution-driven simulator <ref> [7] </ref> that multiplexes in a single ad This work was partially supported by the Air Force Office of Scientific Research. dress space all the processes of the distributed system being simulated. Cesium allows the tester to monitor experiments closely, and to drive the system into any desired state. <p> The upper bound should be chosen so that messages arrive in less time with a high probability; delays beyond ffi u are simulated as communication performance failures. This concludes our description of R. Cesium is based on a centralized, execution-driven <ref> [7] </ref> simulator. It multiplexes all the tasks of R in a single address space.
Reference: [8] <author> F. Cristian. </author> <title> A rigorous approach to fault-tolerant programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(1):23-31, </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: Cesium can also simulate failures by queue manipulations. In our view, every service has two kinds of operations; standard operations, provided by the service to its clients, and failure operations that can be triggered by the "adverse environment" to simulate failures among those specified for the service <ref> [8] </ref>. For the atomic broadcast example, the datagram service provides a standard operation that transports a data-gram between two nodes within the admissible delays. Sample failure operations for the same service include dropping and delaying a datagram.
Reference: [9] <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4 </volume> <pages> 175-187, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Highly available group services allow a set of processors to cooperate on a common task despite the occurrence of component failures in distributed systems. Examples of these services include group membership <ref> [9] </ref>, atomic broadcast [2], and clock synchronization [11]. To use these services as building blocks for the development of dependable applications, they must exhibit a well-defined behavior when failures occur [10]. Furthermore, real-time services must deliver the correct results within bounded time intervals. <p> Even for properties formulated in terms of purely local times, there are several problems to overcome. Consider this example: the "bounded join detection delay J " for the synchronous group membership protocol described in <ref> [9] </ref>: (M-bj) 9J : 8T; t : Start T t ^ Corr (T; t; t + J ) ) 9t 0 : t 0 t + J ^ (8T 0 ; T 00 : Corr (T 0 ; t; t + J ) ^ Corr (T 00 ; t; t+ J
Reference: [10] <author> F. Cristian. </author> <title> Understanding fault-tolerant distributed systems. </title> <journal> Communications of ACM, </journal> <volume> 34(2) </volume> <pages> 56-78, </pages> <month> Feb </month> <year> 1991. </year>
Reference-contexts: Examples of these services include group membership [9], atomic broadcast [2], and clock synchronization [11]. To use these services as building blocks for the development of dependable applications, they must exhibit a well-defined behavior when failures occur <ref> [10] </ref>. Furthermore, real-time services must deliver the correct results within bounded time intervals. We present a centralized environment for testing that implementations of real-time, fault-tolerant protocols satisfy the safety and timeliness properties of their specifications. <p> single constant gives a good approximation to the real system's execution times, since the inaccuracies tend to cancel out when amortized over many instructions. 3 Modular Structure The distributed system being simulated is structured as a hierarchy of services, where each service is above the services upon which it depends <ref> [10] </ref>. A protocol stack is a particular case of hierarchy. Cesium can test protocols at any level of the hierarchy. Consider the example in which an asynchronous atomic broadcast service [2] must be tested, that depends upon a group membership and a datagram communication services.
Reference: [11] <author> F. Cristian and C. </author> <title> Fetzer. Fault-tolerant external clock synchronization. </title> <booktitle> In Proceedings of the 15th International Conference on Distributed Systems, </booktitle> <address> Vancouver, Canada, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Highly available group services allow a set of processors to cooperate on a common task despite the occurrence of component failures in distributed systems. Examples of these services include group membership [9], atomic broadcast [2], and clock synchronization <ref> [11] </ref>. To use these services as building blocks for the development of dependable applications, they must exhibit a well-defined behavior when failures occur [10]. Furthermore, real-time services must deliver the correct results within bounded time intervals. <p> UCTs can crash and restart any node by invoking Cesium primitives that simulate a total amnesia crash, and re-execute the initializations of every task on the restart ing node. Many existing services such as clock synchronization <ref> [11] </ref> can tolerate local clock failures. Typical failure semantics include an excessive drift from real time, stuck bits and clock crashes. Cesium provides two ways of implementing clock failures. First, the driver can change the local clocks when needed by invoking primitive functions. <p> For instance, consider the "bounded maximum internal deviation" safety property of an external clock synchronization protocol <ref> [11] </ref>. Let C T (t) denote the value of task T 's local clock at real time t, and ffi denote the maximum allowable deviation between any two correct local clocks.
Reference: [12] <author> H. Davis, S. Goldschmidt, and J. Hennessy. </author> <title> Tango: A multiprocessor simulation and tracing system. </title> <booktitle> In Proceedings of the 1991 Int'l. Conf. on Parallel Processing, </booktitle> <month> August </month> <year> 1991. </year>
Reference-contexts: We proved formally in [1] that events occur at exactly the same global time in R and in Cesium, and therefore there is no intrusiveness caused by the simulation process. Other approaches like <ref> [5, 12] </ref> add counting instructions to the code under test, thus changing its timing behavior (e.g. a deadline that would never be missed in R might be missed in the simulation). <p> Since it runs on a distributed platform, it suffers from the limitations discussed in Section 6 for coordination and property testing. Another difference is that Orchestra will, in general, interfere with the execution by introducing additional overhead. Proteus [5] and Tango <ref> [12] </ref> are centralized simulators of MIMD parallel architectures. They are well suited for debugging and performance evaluation, but they support neither failure simulation, nor timely testing of properties.
Reference: [13] <author> S. Dawson, F. Jahanian, T. Mitton, and T. Tung. </author> <title> Testing of fault-tolerant and real-time distributed systems via protocol fault injection. </title> <booktitle> In Proceedings of the 26th International Symposium on Fault-Tolerant Computing, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: Other approaches like [5, 12] add counting instructions to the code under test, thus changing its timing behavior (e.g. a deadline that would never be missed in R might be missed in the simulation). Some platform-specific solutions aim at reducing the intrusiveness without eliminating it, like scheduler reservations <ref> [13] </ref> or additional, redundant testing hardware [17]. Since these approaches execute in the target distributed system, the testing environments compete with the application under test for the use of CPU, access to the communication net work, and other resources. <p> The SockPFI/Orchestra tool <ref> [13] </ref> is closest to our approach; we proceed to discuss the main differences. Orchestra does not address the problem of coordinating the separate injection agents to coerce the execution into hard-to-reach states, and provides no mechanism for property testing.
Reference: [14] <author> D. Dolev, J. Halpern, and R. </author> <title> Strong. On the possibility and impossibility of achieving clock synchronization. </title> <journal> Journal of Computer and System Science, </journal> <volume> 32(2) </volume> <pages> 230-250, </pages> <year> 1986. </year>
Reference-contexts: To do so, every task T would have to take a snapshot of its local clock at the same real time t, to compare the values against each other later. This exact synchronization among actions in different processors is impossible to achieve in the presence of communication delay uncertainty <ref> [14] </ref>. Safety properties are tested in Cesium by declaring a set of boolean functions that are invoked after the global initialization and after each task activation during the simulation.
Reference: [15] <author> J. Gait. </author> <title> A probe effect in concurrent programs. </title> <journal> Software-Practice and Experience, </journal> <volume> 16(3) </volume> <pages> 225-33, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: Therefore, the simulation process achieves zero intrusiveness and does not suffer from the probe effect <ref> [15] </ref>, where the addition of testing code may cause relevant monitored effects to disappear. As a consequence of these features, Cesium provides a much better testing platform than the target distributed system. Moreover, this superiority extends to the set of testable properties [1].
Reference: [16] <author> K. Goswami and R. Iyer. </author> <title> Simulation of software behavior under hardware faults. </title> <booktitle> In Proceedings of the 23rd International Symposium on Fault-Tolerant Computing, </booktitle> <address> Toulouse, France, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: We proved formally this intuitive argument as in the case of safety properties: timeliness properties can be tested in Cesium without missing real violations, and without reporting inexistent ones. 7 Related Work Existing environments like Messaline [3], Fiat [18], Depend <ref> [16] </ref>, and Doctor [17] either inject or simulate the occurrence of faults at the hardware level.
Reference: [17] <author> S. Han, K. Shin, and H. Rosenberg. Doctor: </author> <title> An integrated software fault injection environment for distributed real-time systems. </title> <booktitle> In Proceedings of the International Computer Performance and Dependability Symposium, </booktitle> <publisher> Erlangen, </publisher> <address> Germany, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: Some platform-specific solutions aim at reducing the intrusiveness without eliminating it, like scheduler reservations [13] or additional, redundant testing hardware <ref> [17] </ref>. Since these approaches execute in the target distributed system, the testing environments compete with the application under test for the use of CPU, access to the communication net work, and other resources. We avoid this problem completely, by presenting its own version of time to the application. <p> We proved formally this intuitive argument as in the case of safety properties: timeliness properties can be tested in Cesium without missing real violations, and without reporting inexistent ones. 7 Related Work Existing environments like Messaline [3], Fiat [18], Depend [16], and Doctor <ref> [17] </ref> either inject or simulate the occurrence of faults at the hardware level.
Reference: [18] <author> Z. Segall, D. Vrsalovic, D. Siewiorek, D. Yaskin, J. Kownacki, J. Barton, R. Dancey, A. Robinson, and T. Lin. FIAT: </author> <title> Fault-injection based automated testing environment. </title> <booktitle> In Proceedings of the 18th International Symposium on Fault-Tolerant Computing, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: In general, timeliness properties are exactly testable along the same lines. We proved formally this intuitive argument as in the case of safety properties: timeliness properties can be tested in Cesium without missing real violations, and without reporting inexistent ones. 7 Related Work Existing environments like Messaline [3], Fiat <ref> [18] </ref>, Depend [16], and Doctor [17] either inject or simulate the occurrence of faults at the hardware level.
Reference: [19] <author> Sun Microsystems, Inc. </author> <title> The Java Language Specification, V1.0 Beta, </title> <month> August </month> <year> 1996. </year> <note> Available at http:// java.sun.com/ doc/ language specification.html. </note>
Reference-contexts: It is possible to evaluate statistical dependability measures such as availability by performing a large number of experiments, and to evaluate the protocol's performance by supplying Cesium with realistic communication and processing delay parameters. An object-oriented version of Cesium has been implemented in the Java programming language <ref> [19] </ref>, and currently provides an interface to test protocols written in Java as well. It is portable without modification to a variety of platforms 1 . Thus, the target distributed system can be simulated in a variety of machines, even if it is unavailable for testing and performance evaluation purposes.
References-found: 19

