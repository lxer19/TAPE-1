URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-96-2-1.ps.Z
Refering-URL: http://www.cs.man.ac.uk/cstechrep/Abstracts/UMCS-96-2-1.html
Root-URL: http://www.cs.man.ac.uk
Title: A Theory of Classes: Proofs and Models  
Author: Barnaby P. Hilken and David E. Rydeheard 
Affiliation: Computer Science University of Manchester  
Pubnum: ISSN 1361 6161  
Abstract: Department of Computer Science University of Manchester Technical Report Series UMCS-96-2-1 
Abstract-found: 1
Intro-found: 1
Reference: [Bailey 1996] <author> A. Bailey. </author> <title> LEGO with implicit coercions. </title> <type> Draft Report, </type> <institution> Dept. of Computer Science, University of Manchester, Manchester, U.K. </institution> <year> (1996). </year>
Reference-contexts: Other related work includes [Curien, Ghelli 1990] which examines coherence for languages with explicit subtyping; <ref> [Bailey 1996] </ref> which introduces implicit type conversions into the type system LEGO and [Nipkow, Snelting 1990] which deals with the overloading mechanism in type classes using order-sorted algebra. 7 Conclusions This has been a fairly lengthly exercise in understanding a feature of programming languages from a logical viewpoint.
Reference: [Barendregt 1989] <author> H. Barendregt, </author> <title> Introduction to Generalised Type Systems. </title> <booktitle> Proc. Third Ital-ian Conference on Theoretical Computer Science, </booktitle> <editor> Ed. U. Moscati. Montova, </editor> <month> November, </month> <title> 1989. </title> <publisher> World Scientific Publishing, Singapore. </publisher>
Reference: [Curien 1990] <author> P.-L. Curien, </author> <title> Substitution up to Isomorphism. </title> <type> Report LIENS-90-9, </type> <institution> Laboratoire d'Informatique de l'Ecole Normale Superieure, </institution> <address> 45 Rue d'Ulm, 75230 Paris, </address> <year> 1990. </year>
Reference-contexts: Results of this form are called `coherence' results and have been extensively studied in category theory (see [Mac Lane 1982] for example) and in proof theory (see <ref> [Curien 1990] </ref> and [Curien, Ghelli 1990] for example). The appropriate equality (Figure 5) arises as a description of equivalence of proofs under `inversion principles' [Prawitz 1965]. <p> The link between decision procedures and `coherence' results is well-known (see for example [Curien, Ghelli 1990], <ref> [Curien 1990] </ref>) and will be illustrated later in the paper (Section 4). The decision procedure operates by converting expressions to a `canonical form', such that expressions are equal in C Der iff their canonical forms are syntactically identical.
Reference: [Curien, Ghelli 1990] <author> P.-L. Curien and G. Ghelli, </author> <title> Coherence of Subsumption. </title> <institution> Research Report LIENS-90-10, Laboratoire d'Informatique de l'Ecole Normale Superieure, </institution> <address> 45 Rue d'Ulm, 75230 Paris, </address> <year> 1990. </year>
Reference-contexts: Results of this form are called `coherence' results and have been extensively studied in category theory (see [Mac Lane 1982] for example) and in proof theory (see [Curien 1990] and <ref> [Curien, Ghelli 1990] </ref> for example). The appropriate equality (Figure 5) arises as a description of equivalence of proofs under `inversion principles' [Prawitz 1965]. It includes both the usual fi-rules, where an introduction is followed by an elimination, and also j-rules, where an elimination is followed by an introduction. <p> The link between decision procedures and `coherence' results is well-known (see for example <ref> [Curien, Ghelli 1990] </ref>, [Curien 1990]) and will be illustrated later in the paper (Section 4). The decision procedure operates by converting expressions to a `canonical form', such that expressions are equal in C Der iff their canonical forms are syntactically identical. <p> The analysis is, in overall structure, that of the relationship between C Env and C Der in this paper, although details differ. [Jones 1992] is somewhat more general, especially in the treatment of parametric polymorphism, but lacks the underlying logical systems of this paper. Other related work includes <ref> [Curien, Ghelli 1990] </ref> which examines coherence for languages with explicit subtyping; [Bailey 1996] which introduces implicit type conversions into the type system LEGO and [Nipkow, Snelting 1990] which deals with the overloading mechanism in type classes using order-sorted algebra. 7 Conclusions This has been a fairly lengthly exercise in understanding a
Reference: [Ehrhard 1989] <author> Th. Ehrhard, </author> <title> A categorical semantics of constructions. </title> <booktitle> In Proc. Logic in Computer Science I.E.E.E. </booktitle> <publisher> publ. Computer Society Press, </publisher> <address> Washington, </address> <year> 1989. </year>
Reference: [Fitch 1952] <author> F. </author> <title> Fitch Symbolic Logic, </title> <address> New York, </address> <year> 1952. </year>
Reference-contexts: We describe comprehension schemata later in the paper and use this link to categories to provide models for the formal systems of classes. There is a superficial resemblance between the formal systems presented in this paper and set theories, especially those in Natural Deduction form as in <ref> [Fitch 1952] </ref>, [Prawitz 1965] and [Hallnas 1988].
Reference: [Girard et al. 1989] <author> J.-Y. Girard, Y. Lafont and P. Taylor, </author> <title> Proofs and Types, </title> <booktitle> Cambridge Tracts in Theoretical Computer Science, </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: The present paper attempts a reconstruction of a language of type classes as a language of proofs of a simple logic. In this way, we extend the propositions-as-types correspondence (see, for example, <ref> [Girard et al. 1989] </ref>) to cover type classes. However, in doing so we deviate from standard methods of presenting logics and the formulation here is closer to a programming language in that it includes `environments' as well as contexts.
Reference: [Hallnas 1988] <author> L. Hallnas, </author> <title> On normalisation of proofs in set theory. </title> <publisher> Dissertationes Mathemati-cae, Polska Akademia Nauk, </publisher> <address> Instytut Matematyczny, Warszawa, </address> <year> 1988. </year>
Reference-contexts: There is a superficial resemblance between the formal systems presented in this paper and set theories, especially those in Natural Deduction form as in [Fitch 1952], [Prawitz 1965] and <ref> [Hallnas 1988] </ref>. <p> This would extend the present notion of type classes in programming and, when we come to consider models, necessitate a further level of indexing of categories. Logical systems which include parameterised comprehension forms have been investigated by Hallnas <ref> [Hallnas 1988] </ref> amongst others. The additional formula context in the second elimination rule makes weakening admissible in the system. Example 2.1. Here is a simple example of derivations in C.
Reference: [Hilken, Rydeheard 1992] <author> B.P. Hilken and D.E. Rydeheard, </author> <title> Towards a categorical semantics of type classes. </title> <journal> Fundamenta Informaticae, </journal> <volume> 16, 2. </volume> <year> 1992. </year>
Reference-contexts: The reader need not know of type classes to understand this paper, but should be aware that the theory we present is a reformulation of (and extension of) the theory of type classes described in <ref> [Hilken, Rydeheard 1992] </ref>. There we described a primitive functional language with type classes and gave a semantics in category-theoretic terms. A major part of the work lay in showing that this semantics was properly defined, needing a so-called coherence result. <p> Any such attempt requires formalising a language of type classes and a coherence result to show that the semantics is properly defined. In <ref> [Hilken, Rydeheard 1992] </ref>, we defined a semantics directly, starting with a language with unusual features which were difficult to justify except by comparison with 30 existing languages. The coherence was established through rewriting categorical expressions. Whilst coherence results are often treated categorically, in this case the proof looked opaque. <p> correspondence to make sense, we consider systems with a distinguished class (to be thought of as the class of all types) and a bijective rule between judgements ` t : and judgements ` t : prop, or, indeed, drop judgements of the form ` OE : prop altogether as in <ref> [Hilken, Rydeheard 1992] </ref>. This follows the standard treatment of programming languages as first order systems and so called "hyperdoctrine models" (see [Pitts 1987], for example).
Reference: [Hudak, Wadler 1990] <author> P. Hudak and P. </author> <title> Wadler (editors) Report on the Programming Language, Haskell, A Non-strict Purely Functional Language (Version 1.0). </title> <institution> Yale University, Department of Computer Science, </institution> <month> April </month> <year> 1990. </year> <note> Technical Report No. YALEU/DCS/RR777. </note>
Reference-contexts: One source is the notion of type classes in programming languages. Type classes were introduced in [Wadler, Blott 89] and provide a systematic treatment of implicit conversion between structures using operator overloading. Type classes have been incorporated in functional languages such as Haskell <ref> [Hudak, Wadler 1990] </ref> and Gofer [Jones 1992]. The reader need not know of type classes to understand this paper, but should be aware that the theory we present is a reformulation of (and extension of) the theory of type classes described in [Hilken, Rydeheard 1992]. <p> This follows the standard treatment of programming languages as first order systems and so called "hyperdoctrine models" (see [Pitts 1987], for example). Following this interpretation, C Env is a language of type classes with the same basic type structure as introduced in [Wadler, Blott 1989] and implemented in Haskell <ref> [Hudak, Wadler 1990] </ref> and Gofer [Jones 1992]. To illustrate this, we revisit the running example of the paper (Example 2.1) and give a corresponding fragment of Haskell.
Reference: [Hyland, Pitts 1987] <author> J.M.E. Hyland and A.M. Pitts, </author> <title> Theory of constructions: categorical semantics and topos-theoretic models. </title> <editor> In J.W. Gray and A. Scedrov (editors), </editor> <booktitle> Proc. A.M.S. Conference on Categories in Computer Science and Logic, </booktitle> <address> Boulder, Colorado (1987). </address> <publisher> American Mathematical Society, </publisher> <year> 1989. </year>
Reference: [Huet 1976] <author> G. Huet, </author> <note> Resolutions d'equations dans des langages d'ordre 1; 2; : : : ; !. These d'Etat, </note> <institution> Universite de Paris VII, </institution> <year> 1976. </year>
Reference-contexts: A more delicate notion of canonical form is necessary in which the class of a term has a role as well as the form of the term itself. The definition of canonical form that we give is an adaptation of the `long fij' normal forms of -calculus (see <ref> [Huet 1976] </ref> and [Jay 1991]). We first define the appropriate notion of canonical form and then describe a procedure for converting judgements into this form. For judgements ` t : K canonical forms are j-expanded versions of t according to the form of class K.
Reference: [Jacobs 1990] <author> B. Jacobs, </author> <title> Comprehension Categories and The Semantics of Type Dependency. </title> <type> Preprint, </type> <institution> Dept. Comp. Sci., Toernooiveld, 6525 ED Nijmegen, </institution> <address> Holland, </address> <year> 1990. </year>
Reference-contexts: There is a standard interpretation of first order logics in indexed categories and fibrations (see, for example, [Pitts 1987] or <ref> [Jacobs 1990] </ref>), where terms denote arrows in the base category and proofs (or entailment relations) denote arrows in the fibres. We extend this to include class comprehension using comprehension schemata in indexed categories. <p> It is possible to remove the strictness requirement so that the indexed category is functorial only up to isomorphism (as in [Lawvere 1970]), or consider comprehension schemata in fibrations as in <ref> [Jacobs 1990] </ref>, [Jacobs 1991]. The language C Der may be interpreted in these models, some of the equations being interpreted as isomorphisms. 5.1 Indexed categories and comprehension A strict indexed category is a functor p : C op ! Cat.
Reference: [Jacobs 1991] <author> B. Jacobs, </author> <title> Categorical Type Theory. </title> <type> PhD Thesis, </type> <institution> Catholic University of Ni-jmegen, </institution> <address> The Netherlands. </address> <year> 1991. </year>
Reference-contexts: It is possible to remove the strictness requirement so that the indexed category is functorial only up to isomorphism (as in [Lawvere 1970]), or consider comprehension schemata in fibrations as in [Jacobs 1990], <ref> [Jacobs 1991] </ref>. The language C Der may be interpreted in these models, some of the equations being interpreted as isomorphisms. 5.1 Indexed categories and comprehension A strict indexed category is a functor p : C op ! Cat.
Reference: [Jacobs et al. 1991] <author> B. Jacobs, E. Moggi and T. </author> <title> Streicher (1991) Relating Models of Impred-icative Type Theories, </title> <booktitle> Proc. Conference on Category Theory and Computer Science, </booktitle> <address> Paris, </address> <month> September </month> <year> 1991. </year> <note> Springer LNCS 530. 33 </note>
Reference: [Jay 1991] <author> C.B. Jay, </author> <title> Long fij Normal Forms in Confluent Categories. </title> <type> Preprint: </type> <institution> LFCS, Depart--ment of Computer Science, University of Edinburgh, The King's Buildings, Mayfield Road, Edinburgh, </institution> <year> 1991. </year>
Reference-contexts: The definition of canonical form that we give is an adaptation of the `long fij' normal forms of -calculus (see [Huet 1976] and <ref> [Jay 1991] </ref>). We first define the appropriate notion of canonical form and then describe a procedure for converting judgements into this form. For judgements ` t : K canonical forms are j-expanded versions of t according to the form of class K.
Reference: [Jones 1992] <author> M.P. Jones, </author> <title> Qualified Types: Theory and Practice. </title> <type> PhD thesis, </type> <institution> Oxford University Computing Laboratory, Programming Research Group. </institution> <month> July </month> <year> 1992. </year> <note> Technical Monograph, PRG-106. </note>
Reference-contexts: One source is the notion of type classes in programming languages. Type classes were introduced in [Wadler, Blott 89] and provide a systematic treatment of implicit conversion between structures using operator overloading. Type classes have been incorporated in functional languages such as Haskell [Hudak, Wadler 1990] and Gofer <ref> [Jones 1992] </ref>. The reader need not know of type classes to understand this paper, but should be aware that the theory we present is a reformulation of (and extension of) the theory of type classes described in [Hilken, Rydeheard 1992]. <p> Following this interpretation, C Env is a language of type classes with the same basic type structure as introduced in [Wadler, Blott 1989] and implemented in Haskell [Hudak, Wadler 1990] and Gofer <ref> [Jones 1992] </ref>. To illustrate this, we revisit the running example of the paper (Example 2.1) and give a corresponding fragment of Haskell. <p> The instance declaration in the program shows how any type z of class C2 may be considered to be of class C by defining the operator o in in terms of o1. This correspond to the above judgement in C Env . In <ref> [Jones 1992] </ref>, there is a detailed analysis of functional languages with type classes. A proof is given of the correctness of a compiler a translation from a language with implicit `evidence' to one with explicit `evidence'. <p> A coherence result is required and, to this end, an equational theory of judgements is introduced with both fi- and j-rules. The analysis is, in overall structure, that of the relationship between C Env and C Der in this paper, although details differ. <ref> [Jones 1992] </ref> is somewhat more general, especially in the treatment of parametric polymorphism, but lacks the underlying logical systems of this paper. <p> It has neither function abstraction nor recursion (but see Section 3.3). Although it has type variables, it lacks ML-style polymorphism and 8 type quantification. To introduce this polymorphism requires a modified definition of the well-formedness of proof environments as described in <ref> [Jones 1992] </ref>. Other extensions include adding classifications of type constructors, as in [Jones 1996]. This involves a lambda calculus of types: in the categorical treatment, a cartesian closed base category.
Reference: [Jones 1996] <author> M.P. Jones, </author> <title> A system with constructor classes: Overloading and implicit higher order polymorphism. </title> <journal> J. Functional Programming. </journal> <note> To appear. </note>
Reference-contexts: Although it has type variables, it lacks ML-style polymorphism and 8 type quantification. To introduce this polymorphism requires a modified definition of the well-formedness of proof environments as described in [Jones 1992]. Other extensions include adding classifications of type constructors, as in <ref> [Jones 1996] </ref>. This involves a lambda calculus of types: in the categorical treatment, a cartesian closed base category. Other interesting avenues to explore include linear versions of classes, and, more speculatively, languages of records and variants, and features of object-oriented languages, viewed from this proof-theoretic perspective.
Reference: [Lambek, Scott 1986] <author> J. Lambek and P. Scott, </author> <title> Introduction to higher order categorical logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference: [Lawvere 1970] <author> F.W. Lawvere, </author> <title> Equality in Hyperdoctrines and the Comprehension Schema as an Adjoint Functor. </title> <booktitle> In Proc. Symp. in Pure Math., XVII: Applications of Categorical Algebra, </booktitle> <address> Am. </address> <publisher> Math. Soc. </publisher> <pages> pp. 1-14, </pages> <year> 1970. </year>
Reference-contexts: The other source for this theory of classes is the notion of a comprehension schema introduced into category theory in <ref> [Lawvere 1970] </ref>. Lawvere formulates a comprehension schema as an adjoint in an indexed category and shows how such schemata capture the `extent' of a predicate. We describe comprehension schemata later in the paper and use this link to categories to provide models for the formal systems of classes. <p> These results rely on the decision procedure for equality in C Der . As an application, we consider a model theory for the systems. For the first order system C Der , models in strict indexed categories with comprehension schemata are formalised (based upon <ref> [Lawvere 1970] </ref>), a semantics of judgements in such models is given, and a soundness theorem is proved (completeness holds as well). This provides a basis for a semantics of C Env , given straightforwardly using the coherence result. <p> Implication introduces a -calculus of proofs v : OE:ff. We may also consider adding recursion to this system. Of course, we will need to modify the notion of model to cope with these additional constructs. For oe, _, ? and quantification, the relevant categorical structure is well-known (see <ref> [Lawvere 1970] </ref>, for example). 4 A calculus of proofs (II) We now present an alternative language, which we call C Env , of derivations in the system of classes C. <p> We present here a simple form of the semantics using strict indexed categories (i.e. functors p : C op ! Cat). It is possible to remove the strictness requirement so that the indexed category is functorial only up to isomorphism (as in <ref> [Lawvere 1970] </ref>), or consider comprehension schemata in fibrations as in [Jacobs 1990], [Jacobs 1991]. The language C Der may be interpreted in these models, some of the equations being interpreted as isomorphisms. 5.1 Indexed categories and comprehension A strict indexed category is a functor p : C op ! Cat. <p> Comprehension schemata in an indexed category are unique to within an isomorphism. For examples and properties of comprehension schemata see <ref> [Lawvere 1970] </ref>. An arrow ff : &gt; K ! s fl ( ) in the fibre p (K), where s : K ! L, induces, under the bijection, an arrow K ! fL j g, which we denote by (s; ff), so that (s; ff); fl L; = s.
Reference: [Mac Lane 1982] <author> S. Mac Lane, </author> <title> Why commutative diagrams coincide with equivalent proofs (presented in honour of Nathan Jacobson). </title> <booktitle> In Contemporary Mathematics 13, </booktitle> <publisher> American Mathematical Society. </publisher> <pages> pp 387-401, </pages> <year> 1982. </year>
Reference-contexts: Results of this form are called `coherence' results and have been extensively studied in category theory (see <ref> [Mac Lane 1982] </ref> for example) and in proof theory (see [Curien 1990] and [Curien, Ghelli 1990] for example). The appropriate equality (Figure 5) arises as a description of equivalence of proofs under `inversion principles' [Prawitz 1965]. <p> They differ because the predicate symbols on the right of the turnstile are derived from different occurrences in the context. To capture this, we follow standard treatment of such coherence results (see <ref> [Mac Lane 1982] </ref>) and introduce an appropriate notion of a graph which links occurrences of symbols. For simplicity, we begin with a much reduced form of system C.
Reference: [Mac Lane, Pare 1985] <author> S. Mac Lane and R. Pare, </author> <title> Coherence for Bicategories and Indexed Categories. </title> <journal> J. Pure and Applied Algebra, </journal> <volume> 37. </volume> <pages> pp 59-80, </pages> <year> 1985. </year>
Reference: [Moggi 1991] <author> E. Moggi, </author> <title> A category-theoretic account of program modules. </title> <journal> Math. Structures in Comp. Sci. </journal> <volume> 1.1. </volume> <pages> pp 103-139, </pages> <year> 1991. </year>
Reference: [Nipkow, Snelting 1990] <author> T. Nipkow and G. Snelting, </author> <title> Type Classes and Overloading Resolution via Order-Sorted Unification. </title> <type> Technical Report No. 200, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <address> Cambridge, U.K, </address> <year> 1990. </year>
Reference-contexts: Other related work includes [Curien, Ghelli 1990] which examines coherence for languages with explicit subtyping; [Bailey 1996] which introduces implicit type conversions into the type system LEGO and <ref> [Nipkow, Snelting 1990] </ref> which deals with the overloading mechanism in type classes using order-sorted algebra. 7 Conclusions This has been a fairly lengthly exercise in understanding a feature of programming languages from a logical viewpoint.
Reference: [Peyton Jones, Wadler 1990] <author> S.L. Peyton Jones and P. Wadler, </author> <title> A static semantics for Haskell. </title> <type> Preprint, </type> <institution> Dept Computer Science, University of Glasgow, U.K, </institution> <year> 1990. </year>
Reference: [Pitts 1987] <author> A.M. Pitts, </author> <title> Polymorphism is Set Theoretic, </title> <booktitle> Constructively. Proc. Summer Conference on Category Theory and Computer Science, </booktitle> <address> Edinburgh 1987, </address> <publisher> Springer LNCS 283, </publisher> <year> 1987. </year>
Reference-contexts: There is a standard interpretation of first order logics in indexed categories and fibrations (see, for example, <ref> [Pitts 1987] </ref> or [Jacobs 1990]), where terms denote arrows in the base category and proofs (or entailment relations) denote arrows in the fibres. We extend this to include class comprehension using comprehension schemata in indexed categories. <p> This follows the standard treatment of programming languages as first order systems and so called "hyperdoctrine models" (see <ref> [Pitts 1987] </ref>, for example). Following this interpretation, C Env is a language of type classes with the same basic type structure as introduced in [Wadler, Blott 1989] and implemented in Haskell [Hudak, Wadler 1990] and Gofer [Jones 1992].
Reference: [Prawitz 1965] <author> Dag Prawitz, </author> <title> Natural Deduction, A Proof-Theoretical Study, Stockholm Studies in Philosophy 3. </title> <publisher> Almqvist and Wiksell, </publisher> <year> 1965. </year>
Reference-contexts: We describe comprehension schemata later in the paper and use this link to categories to provide models for the formal systems of classes. There is a superficial resemblance between the formal systems presented in this paper and set theories, especially those in Natural Deduction form as in [Fitch 1952], <ref> [Prawitz 1965] </ref> and [Hallnas 1988]. <p> Finally, we show how this relates to type classes in programming languages. 2 A formal system of classes We begin by describing a first order system C which incorporates a notion of comprehension. The system is presented as a sequent calculus in a Natural Deduction style <ref> [Prawitz 1965] </ref>. It consists of terms t which are classified by what we call classes K, and we write t : K. Properties of terms are described by propositional formulae OE which may have free variables for which terms may be substituted. <p> The appropriate equality (Figure 5) arises as a description of equivalence of proofs under `inversion principles' <ref> [Prawitz 1965] </ref>. It includes both the usual fi-rules, where an introduction is followed by an elimination, and also j-rules, where an elimination is followed by an introduction. Equality is at the level of judgements rather than at the level of constituents of judgements (such as terms).
Reference: [Rydeheard, Burstall 1986] <author> D.E. Rydeheard and R.M. Burstall, </author> <title> Computational Category Theory. </title> <booktitle> Prentice-Hall International Series in Computer Science (ed. C.A.R. Hoare), </booktitle> <year> 1986. </year>
Reference: [Seely 1984] <author> R.A.G. Seely, </author> <title> Locally Cartesian Closed Categories and Type Theory. </title> <journal> Math. Proc. Camb. Phil. Soc., </journal> <volume> 95, </volume> <pages> pp. 33-48, </pages> <year> 1984. </year>
Reference: [Seely 1987] <author> R.A.G. Seely, </author> <title> Categorical semantics for higher order polymorphic lambda calculus. </title> <journal> J. Symbolic Logic, </journal> <volume> 52, </volume> <pages> pp 969-989, </pages> <year> 1987. </year>
Reference: [Wadler, Blott 1989] <author> P. Wadler and S. Blott, </author> <title> How to make ad hoc polymorphism less ad hoc. </title> <booktitle> In Proceedings of 16th ACM Symposium on Principles of Programming Languages, A.C.M., </booktitle> <year> 1989. </year>
Reference-contexts: This follows the standard treatment of programming languages as first order systems and so called "hyperdoctrine models" (see [Pitts 1987], for example). Following this interpretation, C Env is a language of type classes with the same basic type structure as introduced in <ref> [Wadler, Blott 1989] </ref> and implemented in Haskell [Hudak, Wadler 1990] and Gofer [Jones 1992]. To illustrate this, we revisit the running example of the paper (Example 2.1) and give a corresponding fragment of Haskell.
References-found: 31

