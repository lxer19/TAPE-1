URL: http://www.cs.washington.edu/homes/beame/branch.ps
Refering-URL: http://www.cs.washington.edu/homes/beame/papers.html
Root-URL: http://www.cs.washington.edu
Email: beame@cs.washington.edu  saks@math.rutgers.edu  jayram@cs.washington.edu  
Title: Time-Space Tradeoffs for Branching Programs  
Author: Paul Beame Michael Saks Jayram S. Thathachar 
Date: 21 February 1999  
Address: Seattle, WA  New Brunswick, NJ  Seattle, WA  
Affiliation: Dept. of Computer Science and Engineering University of Washington  Dept. of Mathematics Rutgers University  Dept. of Computer Science and Engineering University of Washington  
Abstract: We obtain the first non-trivial time-space tradeoff lower bound for functions f : f0; 1g n ! f0; 1g on general branching programs by exhibiting a Boolean function f that requires exponential size to be computed by any branching program of length (1 + *)n, for some constant * &gt; 0. We also give the first separation result between the syntactic and semantic read-k models [BRS93] for k &gt; 1 by showing that polynomial-size semantic read-twice branching programs can compute functions that require exponential size on any syntactic read-k branching program. We also show a time-space tradeoff result on the more general R-way branching program model [BRS93]: for any k, we give a function that requires exponential size to be computed by length kn q-way branching programs, for some q = q(k). 
Abstract-found: 1
Intro-found: 1
Reference: [Abr90] <author> Karl R. Abrahamson. </author> <title> A time-space tradeoff for Boolean matrix multiplication. </title> <booktitle> In Proceedings 31st Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 412-419, </pages> <address> St. Louis, MO, </address> <month> October </month> <year> 1990. </year> <note> IEEE. </note>
Reference-contexts: results on two distinct problems for branching programs, which we summarize in the next two subsections. 1.1 Lower bounds for single-output functions There has been a great deal of success in proving time-space tradeoff lower bounds for multi-output functions in FP such as sorting, pattern matching, matrix-vector product, and hashing <ref> [BC82, Bea91, Abr90, Abr91, MNT93] </ref>. However, for single-output functions (those whose output is one bit), prior to the work in this paper, there were apparently no lower bounds known better than n + C (for constant C) for any explicit n variable function.
Reference: [Abr91] <author> Karl R. Abrahamson. </author> <title> Time-space tradeoffs for algebraic problems on general sequential models. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43(2) </volume> <pages> 269-289, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: results on two distinct problems for branching programs, which we summarize in the next two subsections. 1.1 Lower bounds for single-output functions There has been a great deal of success in proving time-space tradeoff lower bounds for multi-output functions in FP such as sorting, pattern matching, matrix-vector product, and hashing <ref> [BC82, Bea91, Abr90, Abr91, MNT93] </ref>. However, for single-output functions (those whose output is one bit), prior to the work in this paper, there were apparently no lower bounds known better than n + C (for constant C) for any explicit n variable function.
Reference: [AM88] <author> Noga Alon and Wolfgang Maass. </author> <title> Meanders and their applications in lower bounds arguments. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 37 </volume> <pages> 118-129, </pages> <year> 1988. </year>
Reference-contexts: For oblivious branching programs, linear length and read-k for some constant k are essentially the same and several size-length tradeoff lower bounds for oblivious branching programs have been shown using this connection <ref> [AM88, BNS92] </ref>.
Reference: [AS92] <author> Noga Alon and Joel H. Spencer. </author> <title> The Probabilistic Method. </title> <publisher> John Wiley & Sons, </publisher> <year> 1992. </year> <month> 28 </month>
Reference-contexts: variance of Z is given by var [Z] = x X cov (Z x ; Z y );(2) where cov (Z x ; Z y ) = E [Z x Z y ] E [Z x ]E [Z y ] denotes the covariance of Z x and Z y (see <ref> [AS92] </ref> for an elementary proof of this equality). Consider the first term in the right hand side of Equation 2.
Reference: [BC82] <author> Allan Borodin and Stephen A. Cook. </author> <title> A time-space tradeoff for sorting on a general sequential model of computation. </title> <journal> SIAM Journal on Computing, </journal> <volume> 11(2) </volume> <pages> 287-297, </pages> <month> May </month> <year> 1982. </year>
Reference-contexts: results on two distinct problems for branching programs, which we summarize in the next two subsections. 1.1 Lower bounds for single-output functions There has been a great deal of success in proving time-space tradeoff lower bounds for multi-output functions in FP such as sorting, pattern matching, matrix-vector product, and hashing <ref> [BC82, Bea91, Abr90, Abr91, MNT93] </ref>. However, for single-output functions (those whose output is one bit), prior to the work in this paper, there were apparently no lower bounds known better than n + C (for constant C) for any explicit n variable function.
Reference: [BCL + 94] <author> J.R. Burch, E.M. Clarke, D.E. Long, K.L. MacMillan, and D.L. Dill. </author> <title> Symbolic model checking for sequential circuit verification. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, </journal> <volume> 13(4) </volume> <pages> 401-424, </pages> <month> April </month> <year> 1994. </year>
Reference: [Bea91] <author> Paul W. Beame. </author> <title> A general time-space tradeoff for finding unique elements. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(2) </volume> <pages> 270-277, </pages> <year> 1991. </year>
Reference-contexts: results on two distinct problems for branching programs, which we summarize in the next two subsections. 1.1 Lower bounds for single-output functions There has been a great deal of success in proving time-space tradeoff lower bounds for multi-output functions in FP such as sorting, pattern matching, matrix-vector product, and hashing <ref> [BC82, Bea91, Abr90, Abr91, MNT93] </ref>. However, for single-output functions (those whose output is one bit), prior to the work in this paper, there were apparently no lower bounds known better than n + C (for constant C) for any explicit n variable function.
Reference: [BF92] <author> Laszlo Babai and Peter Frankl. </author> <note> Linear Algebra Methods in Combinatorics with Applications to Geometry and Computer Science (Preliminary Version 2). </note> <institution> University of Chicago, </institution> <year> 1992. </year>
Reference-contexts: If jA 0 " B 1 j and jA 0 " B 2 j are both odd and jB 1 " B 2 j is even then the sum of entries in M J;J is +1. We will also need the so-called "Eventown-Oddtown" theorems (see <ref> [BF92] </ref>), stated as a proposition below. We sketch the proof for the sake of completeness. Proposition 31. Let F be a family of sets.
Reference: [BFMadH + 87] <author> Allan Borodin, Faith E. Fich, Friedhelm Meyer auf der Heide, Eli Upfal, and Avi Wigderson. </author> <title> A time-space tradeoff for element distinctness. </title> <journal> SIAM Journal on Computing, </journal> <volume> 16(1) </volume> <pages> 97-99, </pages> <month> February </month> <year> 1987. </year>
Reference-contexts: For example, it is not known how to relate the apparently very similar problems of sorting and element distinctness, although time-space tradeoffs for element distinctness on the structured comparison branching program have been shown <ref> [BFMadH + 87, Yao88] </ref>. The branching program model allows the domain of the variables to be any finite set. For variables taking values in a q element set, the nodes in the program have out-degree q, corresponding to the possible values.
Reference: [BNS92] <author> Laszlo Babai, Noam Nisan, and Mario Szegedy. </author> <title> Multiparty protocols, pseudorandom generators for logspace, and time-space trade-offs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 45(2) </volume> <pages> 204-232, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: For oblivious branching programs, linear length and read-k for some constant k are essentially the same and several size-length tradeoff lower bounds for oblivious branching programs have been shown using this connection <ref> [AM88, BNS92] </ref>.
Reference: [BRS93] <author> Allan Borodin, A. A. Razborov, and Roman Smolensky. </author> <title> On lower bounds for read-k times branching programs. </title> <journal> Computational Complexity, </journal> <volume> 3 </volume> <pages> 1-18, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: While this is only just barely non-trivial, it is the first such result in which the length divided by the number of variables is bounded away from one. 1 The proofs introduce some techniques, some of which extend past techniques of <ref> [BRS93, Tha98] </ref>. <p> f in the form W V j where each function T i j is a decision tree of "small" height, and where the number of terms in the expression is not too large. (This generalizes a similar construction for the special cases of syntactic read-k and oblivious branching programs, in <ref> [BRS93] </ref>). So proving a size lower bound trade-off for branching programs for f reduces to showing that no such representation exists. <p> The analysis that such pseudo-rectangles do not work well at approximating the explicit functions we define are generalizations and improvements of arguments in <ref> [BRS93, Tha98] </ref>. The key to showing the result for the Boolean domain is to prove a tighter form of this decomposition. The proof of this tighter form employs an interesting entropy argument. <p> [Bry86, 1 Since the publication of a preliminary version of our results, Ajtai, using related techniques, has exhibited an explicit family of boolean functions for which any linear size branching program must have exponential size. 3 BCL + 94] and so have generated significant independent interest.) Borodin, Razborov, and Smolensky <ref> [BRS93] </ref> observed that read-k branching programs come in two flavors, syntactic read-k in which all paths in the branching program must satisfy the read-k restriction and the more general semantic read-k in which only the paths consistent with some input must satisfy the restriction. <p> We view B as a boolean function from D n by defining B (oe) = 1 if and only if B accepts oe. Two measures associated with B are size which equals the number of nodes, and length which is the length of the longest path. (In <ref> [BRS93] </ref>, a non-deterministic branching program also contains free arcs, namely arcs which are consistent with any input. <p> We now describe families of explicit functions for which the lower bounds of Corollaries 3 and 4 yield exponential size lower bounds on branching programs with certain length upper bounds. The functions are based on quadratic forms. (Similar functions based on bilinear forms were considered in <ref> [BRS93] </ref>.) Let M = M n be an n fi n matrix over GF (q). <p> The conclusions of Theorems 7 and 8 hold, more generally, whenever N is a Generalized Fourier Transform (GFT) matrix (see <ref> [BRS93] </ref>). <p> Provided that q is relatively prime to jGj (see, e.g., <ref> [BRS93] </ref>), it is known that there are jGj distinct characters and that they are linearly independent when viewed as a vector space over GF (q). <p> Finally, note that, in the deterministic case, each input follows a unique path, and so is accepted by at most one of the decision programs. The oblivious version of this lemma was implicit in <ref> [BRS93] </ref> which gave a similar oblivious decomposition in the case of syntactic read-k branching programs. (For the definition of syntactic read-k, see section 9.) 6 Tradeoffs over Large Domains and for Oblivious Branching Programs In this section we prove the decomposition given by Theorem 1. <p> In the same way that Theorem 1 was used to deduce Corollary 3, we can use Theorem 14 to deduce the following lower bound result for oblivious branching programs. (Again, something similar is implicit in <ref> [BRS93] </ref>). 14 Corollary 15. Let n; k 2 N with n k (k + 1) 2 2 2 (k+4) . Let f be a boolean function on D n for some finite set D. <p> Lemma 27 below, which is a slight generalization of results in <ref> [BRS93, Tha98] </ref>, implies the required bound on jj. Lemma 27. Let N be a t fi t matrix over GF (q). <p> This completes the proof of Lemma 25. We now turn to the proof of Lemma 26. This lemma is an immediate consequence of the following lemma, which says, roughly, that every large minor of a GFT matrix has large rank. The lemma both simplifies and improves a bound in <ref> [BRS93] </ref> which showed that every u fi t minor of such a matrix has rank at least ut=(j (n; u; t) n), where j (n; u; t) is a function that is typically logarithmic in n. (This new bound also improves the lower bound on the size of read-k branching programs <p> There is a simple semantic read-twice branching program of linear size computing f k . On the other hand, any non-deterministic syntactic read-k branching program for f k requires exponential size. The proof of Theorem 35 relies heavily on machinery developed in <ref> [BRS93, Tha98] </ref>. We call a function R (X) a planar pseudo-rectangle of order m if there exist disjoint sets A; B X such that 1. R (X) can be expressed as R 0 (XnB) ^ R 00 (XnA), for some functions R 0 and R 00 . 26 2.
Reference: [Bry86] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference: [For97] <author> Lance Fortnow. </author> <title> Nondeterministic polynomial time versus nondeterministic logarithmic space: Time-space tradeoffs for satisfiability. </title> <booktitle> In Proceedings, Twelfth Annual IEEE Conference on Computational Complexity, </booktitle> <pages> pages 52-60, </pages> <address> Ulm, Germany, 24-27 June 1997. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: This work was done while on sabbatical at University of Washington. 1 bounds? Despite significant progress given by Fortnow's recent time-space tradeoff lower bounds for SAT <ref> [For97] </ref>, this question remains unsolved. One natural model for studying this question is that of Boolean branching programs, which simultaneously capture time and space in a clean combinatorial manner.
Reference: [HLP52] <author> G. H. Hardy, J. E. Littlewood, and G. Polya. </author> <title> Inequalities. </title> <publisher> Cambridge University Press, </publisher> <year> 1952. </year>
Reference-contexts: This proves Lemma 10. To prove Lemma 11, we use two forms of Chebyschev's inequality the usual well-known form, and a second, less standard, but equivalent, form that is also known as Chebyschev's inequality (see for example <ref> [HLP52, Theorem 43, page 43] </ref>). 12 Proposition 12. Let E [Z x ] denote the mean and var [Z x ] denote the variance of a random variable Z x .
Reference: [MNT93] <author> Y. Mansour, N. Nisan, and P. Tiwari. </author> <title> The computational complexity of universal hashing. </title> <journal> Theoretical Computer Science, </journal> <volume> 107 </volume> <pages> 121-133, </pages> <year> 1993. </year>
Reference-contexts: results on two distinct problems for branching programs, which we summarize in the next two subsections. 1.1 Lower bounds for single-output functions There has been a great deal of success in proving time-space tradeoff lower bounds for multi-output functions in FP such as sorting, pattern matching, matrix-vector product, and hashing <ref> [BC82, Bea91, Abr90, Abr91, MNT93] </ref>. However, for single-output functions (those whose output is one bit), prior to the work in this paper, there were apparently no lower bounds known better than n + C (for constant C) for any explicit n variable function.
Reference: [Pip79] <author> Nicholas J. Pippenger. </author> <title> On simultaneous resource bounds. </title> <booktitle> In 20th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 307-311, </pages> <address> San Juan, Puerto Rico, </address> <month> October </month> <year> 1979. </year> <journal> IEEE. </journal> <volume> 29 </volume>
Reference-contexts: It is well known <ref> [Pip79] </ref> that every branching program P of size s and length d, can be converted into a leveled branching program P 0 of length d that has at most s nodes in each of its levels and computes the same function as P (and is deterministic if P is).
Reference: [Raz91] <author> A. A. Razborov. </author> <title> Lower bounds for deterministic and nondeterministic branch-ing programs. </title> <editor> In Lothar Budach, editor, </editor> <booktitle> Fundamentals of Computation Theory: 8th International Conference, FCT '91, volume 529 of Lecture Notes in Computer Science, </booktitle> <pages> pages 47-60, </pages> <address> Gosen, Germany, </address> <month> September </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: This led to the definition of read-k branching programs [Weg87] in which each input can be read at most k times. Many lower bounds have been shown for several functions on read-once branching programs (for example, see <ref> [Raz91, SS93] </ref>). (Another branching program restriction that has also been considered is that of oblivious branching programs which test the same variable at each time-step along any path.
Reference: [SS93] <author> Janos Simon and Mario Szegedy. </author> <title> A new lower bound theorem for read only once branching programs and its applications. </title> <booktitle> In Advances in Computational Complexity (J. Cai, editor), volume 13 of DIMACS Series in Discrete Mathematics, </booktitle> <pages> pages 183-193. </pages> <publisher> AMS, </publisher> <year> 1993. </year>
Reference-contexts: This led to the definition of read-k branching programs [Weg87] in which each input can be read at most k times. Many lower bounds have been shown for several functions on read-once branching programs (for example, see <ref> [Raz91, SS93] </ref>). (Another branching program restriction that has also been considered is that of oblivious branching programs which test the same variable at each time-step along any path.
Reference: [Tha98] <author> J. S. Thathachar. </author> <title> On separating the read-k-times branching program hierarchy. </title> <booktitle> In Proceedings of the Thirtieth Annual ACM Symposium on Theory of Computing, </booktitle> <address> Dallas, TX, </address> <month> May </month> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: While this is only just barely non-trivial, it is the first such result in which the length divided by the number of variables is bounded away from one. 1 The proofs introduce some techniques, some of which extend past techniques of <ref> [BRS93, Tha98] </ref>. <p> The analysis that such pseudo-rectangles do not work well at approximating the explicit functions we define are generalizations and improvements of arguments in <ref> [BRS93, Tha98] </ref>. The key to showing the result for the Boolean domain is to prove a tighter form of this decomposition. The proof of this tighter form employs an interesting entropy argument. <p> The functions we construct are based on a class of functions that were by introduced by Thathachar <ref> [Tha98] </ref> to separate the power of read-k and read-(k+1) in the syntactic model. These functions are exponentially hard for syntactic read-k, and seem to be hard for semantic read-k. <p> This lemma is a generalization of a lemma from <ref> [Tha98] </ref>. 6.1 A combinatorial lemma Lemma 10. Let k; p; n be integers with p = (k + 1)2 k+4 and let n kp 2 . Let fi = 1=2 k+1 and r = kp. <p> In <ref> [Tha98] </ref>, a weaker lemma was proved that required each x to appear in at most mjF j=n sets. Using Lemma 11, we prove Lemma 10 as follows. <p> Let a 1 ; : : : a N is a non-decreasing sequence and b 1 ; : : : b N be a non-increasing sequence of non-negative numbers. Then, P P P Proof of Lemma 11. The proof uses some of the ideas in <ref> [Tha98] </ref>; we give the complete proof to make it self-contained. Color each set Y 2 F red or blue uniformly and independently. Define S (respectively, T ) to be the set of elements x such that every set that contains x is colored red (respectively, blue). <p> Lemma 27 below, which is a slight generalization of results in <ref> [BRS93, Tha98] </ref>, implies the required bound on jj. Lemma 27. Let N be a t fi t matrix over GF (q). <p> There is a simple semantic read-twice branching program of linear size computing f k . On the other hand, any non-deterministic syntactic read-k branching program for f k requires exponential size. The proof of Theorem 35 relies heavily on machinery developed in <ref> [BRS93, Tha98] </ref>. We call a function R (X) a planar pseudo-rectangle of order m if there exist disjoint sets A; B X such that 1. R (X) can be expressed as R 0 (XnB) ^ R 00 (XnA), for some functions R 0 and R 00 . 26 2. <p> It is not too hard to show that there is a setting of the z i 's such that P i u i z i + b = 0 (mod 3). (See <ref> [Tha98] </ref> for details.) Repeating this for all d's gives a satisfying assignment for g k (X; Y ). Proof of Claim 40.
Reference: [Weg87] <author> Ingo Wegener. </author> <title> The Complexity of Boolean Functions. </title> <publisher> B.G. Teubner, </publisher> <address> Stuttgart, 1 edition, </address> <year> 1987. </year>
Reference-contexts: This led to the definition of read-k branching programs <ref> [Weg87] </ref> in which each input can be read at most k times.
Reference: [Yao88] <author> A. C. Yao. </author> <title> Near-optimal time-space tradeoff for element distinctness. </title> <booktitle> In 29th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 91-97, </pages> <address> White Plains, NY, </address> <month> October </month> <year> 1988. </year> <journal> IEEE. </journal> <volume> 30 </volume>
Reference-contexts: For example, it is not known how to relate the apparently very similar problems of sorting and element distinctness, although time-space tradeoffs for element distinctness on the structured comparison branching program have been shown <ref> [BFMadH + 87, Yao88] </ref>. The branching program model allows the domain of the variables to be any finite set. For variables taking values in a q element set, the nodes in the program have out-degree q, corresponding to the possible values.
References-found: 21

