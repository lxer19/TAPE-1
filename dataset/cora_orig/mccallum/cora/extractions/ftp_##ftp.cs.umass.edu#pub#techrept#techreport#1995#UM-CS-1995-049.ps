URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1995/UM-CS-1995-049.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/95-049.html
Root-URL: 
Email: chamilla@cs.umass.edu  
Title: Improving Static Analysis Accuracy on Concurrent Ada Programs:  
Address: Amherst, MA 01003  
Affiliation: Department of Computer Science University of Massachusetts, Amherst  
Note: email:  
Abstract: Complexity Results and Empirical Findings CMPSCI Technical Report 95-49 June 1, 1995 Abstract This paper presents several techniques for improving the accuracy of static analysis of concurrent Ada programs. We determine the cost of building the program representations used to perform the analysis and examine the complexity of performing analysis on those representations. Inaccuracies in the static analysis are reflected in spurious results, which can be generated if the analysis considers paths through the program that are infeasible, or if the effects of aliasing lead to consideration of task communications that can not actually occur. We present three techniques to counter the effects of infeasible path consideration and aliasing and determine the cost of using these techniques. We present empirical results that demonstrate the improvements in accuracy and, in some cases, the reduction in the search space that result from application of our techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [ABC + 91] <author> George S. Avrunin, Ugo A. Buy, James C. Corbett, Laura K. Dillon, and Jack C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Transactions on Software Engineering , 17(11) </journal> <pages> 1204-1222, </pages> <month> November </month> <year> 1991. </year>
Reference: [BCM+90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking : 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science , pages 428-439, </booktitle> <year> 1990. </year>
Reference-contexts: The accuracy-improving techniques in the following sections are presented in the context of reachability analysis based on a Petri net representation of the programs to be analyzed. Symbolic model checking techniques <ref> [BCM+90] </ref> represent the program state space symbolically rather than explicitly. A formula for the property of interest is specified, the program to be analyzed is modeled using Binary Decision Diagrams (BDDs), and a fixed point algorithm is used to determine whether the property formula is valid in the program model. <p> Because checking Boolean satisfiability is NP-complete, determining the validity of the formula in the program model can require exponential time in the worst case; the BDD representations can require exponential space in the worst case. Because the BDDs developed in <ref> [BCM+90] </ref> contain a large amount of information about the program state, including variable values, techniques for improving the accuracy of this approach are not yet prevalent in the literature. The Constrained Expression approach [ABC+91] avoids representing the state space of the program altogether.
Reference: [BDF92] <author> Gianfranco Balbo, Susanna Donatelli, and Giuliana Franceschinis. </author> <title> Understanding parallel program behavior through petri net models. </title> <journal> Journal of Parallel and Distributed Computing , 15(3) </journal> <pages> 171-187, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Theoretical results [Tay83b] imply that, in general, the time and space requirements for this technique are exponential. Methods proposed for improving accuracy of reachability analysis include combining reachability analysis with symbolic execution [YT88] and using program variable value information in the analysis <ref> [BDF92] </ref>. The accuracy-improving techniques in the following sections are presented in the context of reachability analysis based on a Petri net representation of the programs to be analyzed. Symbolic model checking techniques [BCM+90] represent the program state space symbolically rather than explicitly. <p> The variable subnet for a Boolean variable would thus have a "True" place, a "False" place, and an "Unknown" place. Balbo et al. <ref> [BDF92] </ref> suggest an alternate approach in which each variable has a single place, with the variable's value represented by the number of tokens in the place; we choose not to use this approach because it yields an unsafe net.
Reference: [Cor93] <author> James C. Corbett. </author> <title> Identical tasks and counter variables in an integer programming based approach to verification. </title> <editor> In Martin Feather and Axel van Lamsweerd, editors, </editor> <booktitle> Proceedings of the Seventh International Workshop on Software Specification and Design , pages 100-109, </booktitle> <address> Los Alamitos, California, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: In the worst case, solving the system of inequalities can require exponential time, and the system of inequalities can require exponential space. Including information about certain program variable values in the set of inequalities has been proposed <ref> [Cor93] </ref> as one way to improve the accuracy of this technique. Another approach is to use data flow techniques for analysis of concurrent programs.
Reference: [CK93] <author> S.C. Cheung and J. Kramer. </author> <title> Tractable flow analysis for anomaly detection in distributed programs. </title> <booktitle> In Proceedings of the Software Engineering Conference , 1993. </booktitle>
Reference-contexts: Including information about certain program variable values in the set of inequalities has been proposed [Cor93] as one way to improve the accuracy of this technique. Another approach is to use data flow techniques for analysis of concurrent programs. Exploration of this approach <ref> [TO80, RS90, MR91, CK93, DC94] </ref> shows that polynomial-time algorithms can be used in data flow analysis to prove a wide range of program properties.
Reference: [CLR92] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms . The MIT Press, </title> <year> 1992. </year>
Reference-contexts: For a given function g (n), O (g (n)) can be defined as -f (n) : there exist positive constants c and n 0 such that 0 f (n) cg (n) for all n n 0 - <ref> [CLR92] </ref>. O (g (n)) represents a set of functions; when we show an algorithm has cost O (g (n)), we demonstrate membership in that set of functions. In general, Onotation does not specify how tight the upper bound is on the algorithm in question. <p> Because it is difficult to predict the distribution of numbers that will represent markings, we have also implemented a universal hashing scheme, which uses randomly selected multipliers in the hash function to avoid consistent worst case performance. Our universal hashing algorithm is from <ref> [CLR92] </ref>; Theorem 12.3 in [CLR92] proves that, if we use a hash function selected from the universal hashing functions and we are hashing fewer keys than slots in the hash table, then the expected number of collisions for a given key is less than 1. <p> Because it is difficult to predict the distribution of numbers that will represent markings, we have also implemented a universal hashing scheme, which uses randomly selected multipliers in the hash function to avoid consistent worst case performance. Our universal hashing algorithm is from <ref> [CLR92] </ref>; Theorem 12.3 in [CLR92] proves that, if we use a hash function selected from the universal hashing functions and we are hashing fewer keys than slots in the hash table, then the expected number of collisions for a given key is less than 1.
Reference: [CR81] <author> Lori A. Clarke and Debra J. Richardson. </author> <title> Symbolic evaluation methods implementations and applications. </title> <editor> In Chandrasekaran and Radicchi, editors, </editor> <title> Computer Program Testing , pages 65-102. </title> <publisher> North-Holland Publishing Company, </publisher> <year> 1981. </year>
Reference-contexts: For simple programs, the impossible pairs and regions re-enabling them are easily recognized; in more complicated programs, automated techniques such as symbolic evaluation <ref> [CR81] </ref> can be used. We assume that some technique has been used to recognize the impossible pairs and the regions re-enabling them, so our discussion below focuses on including information about these impossible pairs in our TPN.
Reference: [Dav73] <author> Martin Davis. </author> <title> Hilbert's tenth problem is unsolvable. </title> <journal> The American Mathematical Monthly , 80(3) </journal> <pages> 233-269, </pages> <month> March </month> <year> 1973. </year> <month> 42 </month>
Reference-contexts: This is proved using a reduction of Hilbert's Tenth Problem to the Petri net equality problem; Hilbert's Tenth Problem has been shown to be unsolvable <ref> [Dav73] </ref>. Grabowski goes on to prove that the problem becomes decidable if the Petri nets in question have no unbounded places; we note that safe Petri nets have no unbounded places.
Reference: [DC94] <author> Matthew B. Dwyer and Lori A. Clarke. </author> <title> Data flow analysis for verifying properties of concurrent programs. </title> <booktitle> Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering (to appear). </booktitle>
Reference-contexts: Including information about certain program variable values in the set of inequalities has been proposed [Cor93] as one way to improve the accuracy of this technique. Another approach is to use data flow techniques for analysis of concurrent programs. Exploration of this approach <ref> [TO80, RS90, MR91, CK93, DC94] </ref> shows that polynomial-time algorithms can be used in data flow analysis to prove a wide range of program properties. <p> Methods proposed for improving accuracy include identifying program statements that can not 3 execute concurrently [MR93] and including selected information about program paths and program variable values in the analysis <ref> [DC94] </ref>. 3 Program Representations Because Ada is one of the few commonly used languages supporting concurrency, and because our current tools are written for analysis of Ada programs, we use Ada examples to explain our analysis techniques. <p> Though we have chosen to apply these techniques to generating reachability graphs from TPNs, the ideas can be generalized for use in other static analysis techniques. For instance, an idea similar to variable subnets, called variable automata, is discussed in <ref> [DC94] </ref>. In general, additional information about a program's execution state could be included in the flow graph used in a data flow problem; this should yield accuracy improvements similar to those observed here.
Reference: [DCN94] <author> Matthew B. Dwyer, Lori A. Clarke, and Kari A. Nies. </author> <title> A compact petri net representation for concurrent programs. </title> <type> Technical Report TR 94-46, </type> <institution> University of Massachusetts, Amherst, </institution> <year> 1994. </year>
Reference-contexts: The set of reachable program states can be estimated using a variety of program representations, including flow graphs [Tay83a, YTL+92] and Petri nets <ref> [Pet77, SC88, DCN94] </ref>. Theoretical results [Tay83b] imply that, in general, the time and space requirements for this technique are exponential. Methods proposed for improving accuracy of reachability analysis include combining reachability analysis with symbolic execution [YT88] and using program variable value information in the analysis [BDF92]. <p> Petri net modeling appears to be a valuable tool for modeling concurrent software [SC88]. A Petri net can be generated directly from the control flow graphs of a given program. We can also build a Petri net from the TIGs of a program <ref> [DCN94] </ref>, with the resulting Petri net called a TIG-based Petri Net (TPN). To generate the TPN, we build a place for each node in the set of TIGs of a program. <p> We thus have the same algorithmic complexity whether we build the net directly from CFGs or generate TIGs first, though we note that the net built from TIGs is generally smaller than that built directly from the CFGs <ref> [DCN94] </ref>. <p> In the worst case, checking for deadlock in a reachability graph node consists of examining all possible communication choices within the TIG regions represented by the program state of the node. As pointed out in <ref> [DCN94] </ref>, this can be exponential in the number of tasks in the program, though in practice it appears to be much less. Checking for critical data races is also examined in [DCN94]; the cost for each node in the reachability graph is found to be O (number of program tasks * <p> As pointed out in <ref> [DCN94] </ref>, this can be exponential in the number of tasks in the program, though in practice it appears to be much less. Checking for critical data races is also examined in [DCN94]; the cost for each node in the reachability graph is found to be O (number of program tasks * number of shared variables) for the algorithm given.
Reference: [GMO76] <author> Harold N. Gabow, Shachindra N. Maheshwari, and Leon J. Osterweil. </author> <title> On two problems in the generation of program test paths. </title> <journal> IEEE Transactions on Software Engineering , SE-2(3):227-231, </journal> <month> September </month> <year> 1976. </year>
Reference-contexts: Impossible pairs are pairs of program statements that can not both execute in the same execution of the program; in other words, both statements can not be on the same execution path. As noted in <ref> [GMO76] </ref>, determining whether or not there exists an executable path in the program, constrained by 2 Aliasing can also cause a variety of other problems for static analysis techniques. 16 impossible pairs of statements, is NP-complete (by reduction of 3SAT). In fact, as also shown in [GMO76], the problem remains NP-complete <p> As noted in <ref> [GMO76] </ref>, determining whether or not there exists an executable path in the program, constrained by 2 Aliasing can also cause a variety of other problems for static analysis techniques. 16 impossible pairs of statements, is NP-complete (by reduction of 3SAT). In fact, as also shown in [GMO76], the problem remains NP-complete even if the control flow graph is acyclic, and the in-degree and out-degree of all nodes is limited to two. <p> The key differences between our meaning and that in <ref> [GMO76] </ref> is that our pair is only impossible in one direction (first member to second member, not second member to first member) and we will let both statements execute in an execution of the program (given certain conditions described below).
Reference: [Gra79] <author> Jan Grabowski. </author> <title> The unsolvability of some petri net language problems. </title> <journal> Information Processing Letters , 9(2) </journal> <pages> 60-63, </pages> <month> August </month> <year> 1979. </year>
Reference-contexts: Analyzing Representations We now move from examining the cost of generating our program representations to determining the cost of performing analyses on those representations. The complexity of answering various questions about Petri nets has been widely studied in the literature <ref> [Gra79, Jan87, JLL77, May84, MM81] </ref>; it turns out that the complexities of answering these questions extend over a wide range. <p> The first two results below do not directly relate to our analyses, since it is doubtful we will need to check whether two TPNs have the same set of reachable markings; however, we include them here to more completely demonstrate the range of Petri net problem complexities. Both Grabowski <ref> [Gra79] </ref> and Jantzen [Jan87] have shown that determining whether the reachable markings for two arbitrary Petri nets are identical, called the Petri net equality problem, is undecidable.
Reference: [Hec77] <author> Matthew S. Hecht. </author> <title> Flow Analysis of Computer Programs . North-Holland, </title> <year> 1977. </year>
Reference-contexts: Each of these representations is described more fully below. Control Flow Graphs One way to represent the behavior of a program is with a control flow graph <ref> [Hec77] </ref>. A control flow graph (CFG) is similar to a flow chart, in that it represents all paths through a procedure or task.
Reference: [Hol88] <author> Gerard J. Holzmann. </author> <title> An improved protocol reachability analysis technique. </title> <journal> Software Practice and Experience , 18(2) </journal> <pages> 137-161, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Holzmann <ref> [Hol88] </ref> suggests hashing the marking as an index into a hash table of the visited nodes; using this approach yields a constant time check for a visited node on average.
Reference: [Hwa93] <author> Kai Hwang. </author> <title> Advanced Computer Architecture: Parallelism, Scalability, </title> <publisher> Programmability . McGraw-Hill, Inc., </publisher> <year> 1993. </year>
Reference-contexts: The approach is generally applicable whenever valid array element interactions can be statically determined. This includes arrays of tasks representing processors connected using any static interconnection network (a network of non-reconfigurable links between processors), including rings, trees, meshes, and hypercubes <ref> [Hwa93] </ref>. 6 Empirical Results We have run experiments on a small set of programs for two purposes.
Reference: [Jan87] <author> Matthias Jantzen. </author> <title> Complexity of place/transition nets. </title> <editor> In W. Brauer, W. Reisig, and G. Rozenberg, editors, </editor> <title> Petri Nets : Central Models and Their Properties , pages 413-434. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Analyzing Representations We now move from examining the cost of generating our program representations to determining the cost of performing analyses on those representations. The complexity of answering various questions about Petri nets has been widely studied in the literature <ref> [Gra79, Jan87, JLL77, May84, MM81] </ref>; it turns out that the complexities of answering these questions extend over a wide range. <p> Both Grabowski [Gra79] and Jantzen <ref> [Jan87] </ref> have shown that determining whether the reachable markings for two arbitrary Petri nets are identical, called the Petri net equality problem, is undecidable. This is proved using a reduction of Hilbert's Tenth Problem to the Petri net equality problem; Hilbert's Tenth Problem has been shown to be unsolvable [Dav73]. <p> Next, they note that Petri nets can be used to compute polynomial functions with nonnegative integer coefficients; the result is called a Weak Petri Net Computer (WPNC). Jantzen <ref> [Jan87] </ref> shows that any function computed by a WPNC is primitive recursive. Using slightly modified WPNCs for functions p and q, Mayr and Meyer perform a poly-time reduction of BPI to the Finite Equality Problem. Finally, they conclude that FEP is decidable, but not primitive recursive.
Reference: [JLL77] <author> Neil D. Jones, Lawrence H. Landweber, and Y. Edmund Lien. </author> <title> Complexity of some problems in petri nets. </title> <booktitle> Theoretical Computer Science , 4(3) </booktitle> <pages> 277-299, </pages> <month> June </month> <year> 1977. </year>
Reference-contexts: Analyzing Representations We now move from examining the cost of generating our program representations to determining the cost of performing analyses on those representations. The complexity of answering various questions about Petri nets has been widely studied in the literature <ref> [Gra79, Jan87, JLL77, May84, MM81] </ref>; it turns out that the complexities of answering these questions extend over a wide range. <p> Finally, they conclude that FEP is decidable, but not primitive recursive. This result is of theoretical interest, since FEP seems to be one of a small set of uncontrived decidable problems that are not primitive recursive. Jones et al. <ref> [JLL77] </ref> examine the complexities of a variety of problems on Petri nets. While many of their results are for arbitrary Petri nets, there is one result for safe Petri nets that is of interest to us.
Reference: [LC89] <author> Douglas L. Long and Lori A. Clarke. </author> <title> Task interaction graphs for concurrency analysis. </title> <booktitle> In Proceedings of the 11th International Conference on Software Engineering , pages 44-52, </booktitle> <address> Pittsburgh PA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Long and Clarke <ref> [LC89] </ref> suggest using Task Interaction Graphs (TIGs) to reduce the size of the program representation while retaining interaction information. The TIG, like the CFG, consists of a finite set of nodes, N = -n i -, and a finite set of directed edges, E = -e i -.
Reference: [May84] <author> Ernst W. Mayr. </author> <title> An algorithm for the general petri net reachability problem. </title> <journal> SIAM Journal on Computing , 13(3) </journal> <pages> 441-460, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: It would thus be helpful to be able to check properties of reachable 13 program states without actually generating the reachability graph. The reachability problem tries to determine whether a Petri net started with a given marking can reach a specified marking. Mayr <ref> [May84] </ref> presents an algorithm for solving the reachability problem using an iterative approach rather than generating the entire reachability graph and inspecting it for the marking of interest. While the idea of avoiding generation of the entire reachable state space is intriguing, there are several problems with this approach. <p> More importantly, we are usually interested in checking whether markings with a certain property are reachable, rather than whether a specific marking is reachable. It is therefore not clear that the approach described in <ref> [May84] </ref> is applicable to our analysis. Analyzing Representations We now move from examining the cost of generating our program representations to determining the cost of performing analyses on those representations. <p> Analyzing Representations We now move from examining the cost of generating our program representations to determining the cost of performing analyses on those representations. The complexity of answering various questions about Petri nets has been widely studied in the literature <ref> [Gra79, Jan87, JLL77, May84, MM81] </ref>; it turns out that the complexities of answering these questions extend over a wide range.
Reference: [MM81] <author> Ernst W. Mayr and Albert R. Meyer. </author> <title> The complexity of the finite containment problem for petri nets. </title> <journal> Journal of the ACM , 28(3) </journal> <pages> 561-576, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: Analyzing Representations We now move from examining the cost of generating our program representations to determining the cost of performing analyses on those representations. The complexity of answering various questions about Petri nets has been widely studied in the literature <ref> [Gra79, Jan87, JLL77, May84, MM81] </ref>; it turns out that the complexities of answering these questions extend over a wide range. <p> Grabowski goes on to prove that the problem becomes decidable if the Petri nets in question have no unbounded places; we note that safe Petri nets have no unbounded places. Mayr and Meyer prove in <ref> [MM81] </ref> that, if the reachability sets of two Petri nets are finite (which is true of safe Petri nets), determining equality of the sets (called the Finite Equality Problem, or FEP) is decidable; the problem is not, however, primitive recursive.
Reference: [MR91] <author> Stephen P. Masticola and Barbara G. Ryder. </author> <title> A model of ada programs for static deadlock detection in polynomial time. </title> <booktitle> In Proceedings of the Workshop on Parallel and Distributed Debugging , pages 97-107, </booktitle> <month> May </month> <year> 1991. </year> <month> 43 </month>
Reference-contexts: Including information about certain program variable values in the set of inequalities has been proposed [Cor93] as one way to improve the accuracy of this technique. Another approach is to use data flow techniques for analysis of concurrent programs. Exploration of this approach <ref> [TO80, RS90, MR91, CK93, DC94] </ref> shows that polynomial-time algorithms can be used in data flow analysis to prove a wide range of program properties.
Reference: [MR93] <author> Stephen P. Masticola and Barbara G. Ryder. </author> <title> Non-concurrency analysis. </title> <booktitle> In Proceedings of the ACM Symposium on Principles and Practices of Parallel Programming (PPOPP) , 1993. </booktitle>
Reference-contexts: Exploration of this approach [TO80, RS90, MR91, CK93, DC94] shows that polynomial-time algorithms can be used in data flow analysis to prove a wide range of program properties. Methods proposed for improving accuracy include identifying program statements that can not 3 execute concurrently <ref> [MR93] </ref> and including selected information about program paths and program variable values in the analysis [DC94]. 3 Program Representations Because Ada is one of the few commonly used languages supporting concurrency, and because our current tools are written for analysis of Ada programs, we use Ada examples to explain our analysis <p> We observe that statements in an impossible pair are conceptually different from statements that Can't Happen Together (CHT) <ref> [MR93] </ref>; impossible pairs identification is concerned with identifying invalid sequences of statements, and CHT analysis is concerned with identifying statements that can not execute concurrently.
Reference: [Pet77] <author> James L. Peterson. </author> <title> Petri nets. </title> <journal> Computing Surveys , 9(3) </journal> <pages> 223-252, </pages> <month> September </month> <year> 1977. </year>
Reference-contexts: The set of reachable program states can be estimated using a variety of program representations, including flow graphs [Tay83a, YTL+92] and Petri nets <ref> [Pet77, SC88, DCN94] </ref>. Theoretical results [Tay83b] imply that, in general, the time and space requirements for this technique are exponential. Methods proposed for improving accuracy of reachability analysis include combining reachability analysis with symbolic execution [YT88] and using program variable value information in the analysis [BDF92]. <p> The set of task statements forming the sequential region of a TIG node are stored as part of the node to support later analysis activities. 6 Petri Nets Petri nets have been proposed as a natural and powerful model of information flow in a system <ref> [Pet77] </ref>. A Petri net can be represented as a 5-tuple (P, T, I, O, M0). P is the set of places in the Petri net; a place can hold zero or more tokens. If a place holds one or more tokens, the place is said to be marked .
Reference: [Pet81] <author> James L. Peterson. </author> <title> Petri Net Theory and the Modeling of Systems . Prentice-Hall, </title> <year> 1981. </year>
Reference-contexts: To make the resulting subnet safe, we modify the TPN to ensure the operation places can never contain more than one token; the modifications described below are based on a transformation described by Peterson <ref> [Pet81] </ref>. For every operation place for the variable, we add an operation prime place, yielding two places for each possible operation on the variable. For each transition with an operation place as an output, we add the corresponding operation prime place as an input.
Reference: [RS90] <author> John H. Reif and Scott A. Smolka. </author> <title> Data flow analysis of distributed communicating processes. </title> <booktitle> International Journal of Parallel Programming , 19(1) </booktitle> <pages> 1-30, </pages> <year> 1990. </year>
Reference-contexts: Including information about certain program variable values in the set of inequalities has been proposed [Cor93] as one way to improve the accuracy of this technique. Another approach is to use data flow techniques for analysis of concurrent programs. Exploration of this approach <ref> [TO80, RS90, MR91, CK93, DC94] </ref> shows that polynomial-time algorithms can be used in data flow analysis to prove a wide range of program properties.
Reference: [SC88] <author> S.M. Shatz and W.K. Cheng. </author> <title> A petri net framework for automated static analysis of ada tasking behavior. </title> <journal> The Journal of Systems and Software , 8(5) </journal> <pages> 343-359, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: The set of reachable program states can be estimated using a variety of program representations, including flow graphs [Tay83a, YTL+92] and Petri nets <ref> [Pet77, SC88, DCN94] </ref>. Theoretical results [Tay83b] imply that, in general, the time and space requirements for this technique are exponential. Methods proposed for improving accuracy of reachability analysis include combining reachability analysis with symbolic execution [YT88] and using program variable value information in the analysis [BDF92]. <p> M0 is a list of all the places in the net that are initially marked. Petri net modeling appears to be a valuable tool for modeling concurrent software <ref> [SC88] </ref>. A Petri net can be generated directly from the control flow graphs of a given program. We can also build a Petri net from the TIGs of a program [DCN94], with the resulting Petri net called a TIG-based Petri Net (TPN).
Reference: [Tay83a] <author> Richard N. Taylor. </author> <title> A general-purpose algorithm for analyzing concurrent programs. </title> <journal> Communications of the ACM , 26(5) </journal> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: One analysis approach is to check the property of interest by considering all reachable states of the program being analyzed; this approach is commonly called reachability analysis. The set of reachable program states can be estimated using a variety of program representations, including flow graphs <ref> [Tay83a, YTL+92] </ref> and Petri nets [Pet77, SC88, DCN94]. Theoretical results [Tay83b] imply that, in general, the time and space requirements for this technique are exponential.
Reference: [Tay83b] <author> Richard N. Taylor. </author> <title> Complexity of analyzing the synchronization structure of concurrent programs. </title> <journal> Acta Informatica , 19 </journal> <pages> 57-84, </pages> <year> 1983. </year>
Reference-contexts: The set of reachable program states can be estimated using a variety of program representations, including flow graphs [Tay83a, YTL+92] and Petri nets [Pet77, SC88, DCN94]. Theoretical results <ref> [Tay83b] </ref> imply that, in general, the time and space requirements for this technique are exponential. Methods proposed for improving accuracy of reachability analysis include combining reachability analysis with symbolic execution [YT88] and using program variable value information in the analysis [BDF92]. <p> We next consider some general complexity results for reachability analysis of concurrent programs. Taylor examines several important problems in reachability analysis <ref> [Tay83b] </ref> and we review some of his results below. In many cases, he demonstrates NP-completeness by a reduction of 3SAT to the problem in question. <p> It is clear that a variety of important questions in static analysis of concurrent programs are intractable; indeed, Taylor points out that "Only when enough restrictions are applied to make a system fully deterministic do the problems become tractable" <ref> [Tay83b] </ref>. Taylor's results indicate the complexity of using reachability analysis to answer certain questions in general; we now examine the cost of answering questions about specific properties using our representations (a reachability graph generated from a TPN).
Reference: [TO80] <author> Richard N. Taylor and Leon J. Osterweil. </author> <title> Anomaly detection in concurrent software by static data flow analysis. </title> <journal> IEEE Transaction on Software Engineering , SE-6(3):265-277, </journal> <month> May </month> <year> 1980. </year>
Reference-contexts: Including information about certain program variable values in the set of inequalities has been proposed [Cor93] as one way to improve the accuracy of this technique. Another approach is to use data flow techniques for analysis of concurrent programs. Exploration of this approach <ref> [TO80, RS90, MR91, CK93, DC94] </ref> shows that polynomial-time algorithms can be used in data flow analysis to prove a wide range of program properties.
Reference: [YT88] <author> Michal Young and Richard N. Taylor. </author> <title> Combining static concurrency analysis with symbolic execution. </title> <journal> IEEE Transactions on Software Engineering , 14(10) </journal> <pages> 1499-1511, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Theoretical results [Tay83b] imply that, in general, the time and space requirements for this technique are exponential. Methods proposed for improving accuracy of reachability analysis include combining reachability analysis with symbolic execution <ref> [YT88] </ref> and using program variable value information in the analysis [BDF92]. The accuracy-improving techniques in the following sections are presented in the context of reachability analysis based on a Petri net representation of the programs to be analyzed.
Reference: [YTL+92] <author> Michal Young, Richard N. Taylor, David L. Levine, Kari Forester, and Debra Brodbeck. </author> <title> A concurrency analysis tool suite: Rationale, design, and preliminary experience. </title> <type> SERC Technical Report TR-128-P, </type> <institution> Purdue University, West Lafayette, Indiana, </institution> <month> October </month> <year> 1992. </year> <month> 44 </month>
Reference-contexts: One analysis approach is to check the property of interest by considering all reachable states of the program being analyzed; this approach is commonly called reachability analysis. The set of reachable program states can be estimated using a variety of program representations, including flow graphs <ref> [Tay83a, YTL+92] </ref> and Petri nets [Pet77, SC88, DCN94]. Theoretical results [Tay83b] imply that, in general, the time and space requirements for this technique are exponential. <p> In many cases our reachability graphs are cyclic; because the number of paths in a cyclic graph is infinite, these questions are difficult to answer using reachability graphs. General model checking can be used to check path properties on a reachability graph <ref> [YTL+92] </ref>; we could also use the reachability graph in a data flow problem to answer questions about path properties. 5 Improving Accuracy Because we perform static analysis on models that overestimate the behavior of the system being analyzed, we may often answer questions about properties of the system with spurious results.
References-found: 31

