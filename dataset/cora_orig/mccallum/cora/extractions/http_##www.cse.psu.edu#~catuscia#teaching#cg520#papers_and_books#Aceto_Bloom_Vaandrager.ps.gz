URL: http://www.cse.psu.edu/~catuscia/teaching/cg520/papers_and_books/Aceto_Bloom_Vaandrager.ps.gz
Refering-URL: http://www.cse.psu.edu/~catuscia/teaching/cg520/98Fall/assignments/Projects.html
Root-URL: http://www.cse.psu.edu
Email: luca@cogs.sussex.ac.uk  bard@cs.cornell.edu  fritsv@cwi.nl  
Title: Turning SOS Rules into Equations  
Author: Luca Aceto COGS, Bard Bloom Frits Vaandrager 
Address: Brighton, United Kingdom;  Ithaca, New York, USA;  P.O. Box 4079, 1009 AB Amsterdam, The Netherlands;  Kruislaan 403, 1098 SJ Amsterdam, The Netherlands;  
Affiliation: University of Sussex,  Dept. of Computer Science, Cornell University,  Department of Software Technology, CWI  Programming Research Group, University of Amsterdam,  
Abstract: Many process algebras are defined by structural operational semantics (SOS). Indeed, most such definitions are nicely structured and fit the GSOS format of [19]. We give a procedure for converting any GSOS language definition to a finite complete equational axiom system (possibly with one infinitary induction principle) which precisely characterizes strong bisimulation of processes. 1991 Mathematics Subject Classification: 68Q05, 68Q55. 1991 CR Categories: D.1.3, D.3.1, F.1.1, F.3.1, F.3.2, F.3.3. Key Words and phrases: Structural Operational Semantics (SOS), GSOS format, bisimulation equivalence, process algebra, equational logic, complete axiomatizations, approximation induction principle. Note: The research of the second author was supported by NSF grant (CCR-9003441). Most of the work on this paper was done while the first author was employed by Hewlett-Packard Laboratories, Pisa Science Center, and the third author was employed by the Ecole des Mines, CMA, at Sophia Antipolis, France. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Aceto. </author> <title> Deriving complete inference systems for a class of GSOS languages generating regular behaviours. </title> <type> Report IR 93-2009, </type> <institution> Institute for Electronic Systems, Department of Mathematics and Computer Science, Aalborg University, Aalborg, </institution> <month> November </month> <year> 1993. </year> <month> 41 </month>
Reference-contexts: The same trick applies to all constants. There are doubtless any number of other clever tricks axiomatizing other kinds of operations. (See, e.g., <ref> [18, 1] </ref> for a discussion of alternative axiomatizations of operators specified by rules without negative antecedents). The issue of improving the equations, and in particular reducing the number of auxiliary operations in equational characterizations of process equivalences, is of more than purely theoretical interest.
Reference: [2] <author> L. Aceto, B. Bloom, and F.W. Vaandrager. </author> <title> Turning SOS rules into equations. </title> <type> Report CS-R9218, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: We will now show that, for an interesting subclass of GSOS systems, there exists a rather natural, effective constraint on the rules of GSOS systems that ensures semantic well-foundedness. (The following definitions and results are slight generalizations of those presented in the report version of this paper <ref> [2] </ref>).
Reference: [3] <author> P. America, J.W. de Bakker, J.N. Kok, and J.J.M.M. Rutten. </author> <title> Operational semantics of a parallel object-oriented language. </title> <booktitle> In Conference Record of the 13 th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg, Florida, </address> <pages> pages 194-208, </pages> <year> 1986. </year>
Reference-contexts: In such a semantics, the behavior of a composite process is given in terms of the behaviors of its components. Some examples of languages specified by SOSses include <ref> [43, 44, 3, 4, 36, 15] </ref>. In SOS semantics, induction on terms and on the proofs of transitions are viable proof methods. SOSses are thus a fruitful area for proving properties of programming languages as a whole [52], compilation techniques [51], hardware implementations [15], and logics of programming [46].
Reference: [4] <author> E. Astesiano, A. Giovini, F. Mazzanti, G. Reggio, and E. Zucca. </author> <title> The Ada challenge for new formal semantic techniques. </title> <editor> In P.L. Wallis, editor, </editor> <booktitle> Ada: Managing the Transition - Proceedings of the 1986 Ada-Europe International Conference, </booktitle> <address> Cambridge, U.K., 1986. </address> <publisher> Cambridge University Press. </publisher>
Reference-contexts: In such a semantics, the behavior of a composite process is given in terms of the behaviors of its components. Some examples of languages specified by SOSses include <ref> [43, 44, 3, 4, 36, 15] </ref>. In SOS semantics, induction on terms and on the proofs of transitions are viable proof methods. SOSses are thus a fruitful area for proving properties of programming languages as a whole [52], compilation techniques [51], hardware implementations [15], and logics of programming [46].
Reference: [5] <editor> D. Austry and G. Boudol. Algebre de processus et synchronisations. </editor> <booktitle> Theoretical Computer Science, </booktitle> <volume> 30(1) </volume> <pages> 91-131, </pages> <year> 1984. </year>
Reference-contexts: We present the algorithm for strong bisimulation, the finest useful notion of process equivalence in this setting. We work in the setting of process algebras, languages such as CCS [35], CSP [31], ACP, and Meije <ref> [5] </ref>. A process P is an entity capable of repeatedly performing uninterpreted atomic actions a. The basic operational notion in such languages is P a ! P 0 , indicating that P is capable of performing the action a and thereafter behaving like P 0 . <p> Consequently our methods can not be applied directly to the full versions of calculi like CCS [35] and Meije <ref> [5] </ref>, since these calculi postulate an infinite action set. If the action set is infinite it is natural to use, both in the inference rules and in the equations, variables ranging over actions instead of just actions.
Reference: [6] <author> J.C.M. Baeten and J.A. Bergstra. </author> <title> A survey of axiom systems for process algebras. </title> <type> Report P9111, </type> <institution> University of Amsterdam, </institution> <address> Amsterdam, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: As a typical example of the way in which the above completeness result is used, consider the GSOS system G y , which extends FINTREE with a family of operations yB (called @ 1 B in <ref> [6] </ref>), where B is a finite set of actions, with rules x ! y a a 62 B The process P y B behaves like P , except that it cannot do any actions from B in its first move.
Reference: [7] <author> J.C.M. Baeten, J.A. Bergstra, and J.W. Klop. </author> <title> Syntax and defining equations for an interrupt mechanism in process algebra. </title> <note> Fundamenta Informaticae, IX(2):127-168, </note> <year> 1986. </year>
Reference-contexts: If there are no positive antecedents about x j , then x j can be copied. (1), (2), and (8) are smooth rules. An excellent example of a non-smooth operation is the priority operation of Baeten, Bergstra and Klop <ref> [7] </ref>. Fix a partial ordering relation &gt; on Act. <p> y4z (39) ax4y = a:(x) if a is maximal (40) ax4 (y y fb 2 Actjb &gt; ag) = a:(x) if a is not maximal (41) 04x = 0 (42) The axiomatization of the priority operation obtained by applying our general strategy compares rather well with the one given in <ref> [7] </ref>. The axiomatization given there also relies on the introduction of an auxiliary operation, the unless operation &lt; .
Reference: [8] <editor> J.C.M. Baeten and J.W. Klop, editors. </editor> <booktitle> Proceedings CONCUR 90, Amsterdam, volume 458 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference: [9] <author> J.C.M. Baeten and F.W. Vaandrager. </author> <title> An algebra for process creation. </title> <journal> Acta Informatica, </journal> <volume> 29(4) </volume> <pages> 303-334, </pages> <year> 1992. </year>
Reference-contexts: Besides the law (30) it consists of: (x + y); 1 z = x; 1 z + y; 1 z x; 2 (y + z) = x; 2 y + x; 2 z (ax + y); 2 z = 0 This is somewhat inferior to the axiomatization of <ref> [9] </ref>, which does not require auxiliary operations. However, finding the latter axiomatization required a lot of thinking whereas the one presented here is produced automatically. 4.2 General GSOS Operations In this subsection we show how to axiomatize non-smooth operations.
Reference: [10] <author> J.C.M. Baeten and W.P. Weijland. </author> <title> Process Algebra. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science 18. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: One then verifies the program by showing that it is equivalent to (or a suitable approximation of) the specification. Indeed, one of the major schools of theoretical concurrency, that of ACP <ref> [10, 13] </ref>, takes the notion of process equivalence as primary, and defines operational semantics to fit their algebraic laws. A logic of programs is complete (relative to a programming language) if all true formulas of the language are provable in the logic. <p> In the more general setting (e.g., GSOS languages with recursive process definition), head normalization does not imply general normalization and indeed no finite, purely equational axiom system can be complete; however, the Approximation Induction Principle of <ref> [14, 10] </ref> is sound in our setting, can be expressed in GSOS terms, and makes the equations of Sections 4.1 and 4.2 complete. Of course, variations are possible on our method to obtain complete axiom systems for GSOS languages. <p> In Section 6, we study one such variation, which uses fewer auxiliary operations. Finally, in Section 7, we discuss some topics for future research. 2 Preliminaries We assume familiarity with the basic notation of process algebra and structural operational semantics; see e.g. <ref> [31, 29, 35, 10, 27, 19, 16] </ref> for more details. We start from a countably infinite set Var of process variables with typical elements x; y. <p> Proof: Straightforward from Lemma 4.10 and Theorem 4.9. 4 + 4.1.6 Examples We demonstrate our method on the parallel composition operation k of ACP <ref> [13, 10] </ref>. Fix a partial, commutative and associative function fl : Act fi Act * Act, which describes the synchronization between actions. <p> However, it is possible to extend our results to the whole class of GSOS systems in a rather standard way. Bisimulation equivalence over finitely branching labelled transition systems supports a powerful induction principle, known as the Approximation Induction Principle (AIP), see <ref> [14, 10] </ref>. By Lemma 2.8, all GSOS processes are finitely branching, so the AIP applies. <p> By Lemma 2.8, all GSOS processes are finitely branching, so the AIP applies. We introduce a family of unary operations n (), n 2 N, with rules (one for each a 2 Act): x ! y a These operations are known as projection operations in the literature on ACP <ref> [10] </ref>. Intuitively, n (P ) allows P to perform n moves freely, and then stops it. Since the n () operations are smooth and distinctive, we may thus apply the strategy presented in Section 4.1 (or consult [10]) to automatically derive the following equations for them: n (x + y) = <p> a These operations are known as projection operations in the literature on ACP <ref> [10] </ref>. Intuitively, n (P ) allows P to perform n moves freely, and then stops it. Since the n () operations are smooth and distinctive, we may thus apply the strategy presented in Section 4.1 (or consult [10]) to automatically derive the following equations for them: n (x + y) = n (x) + n (y) n (0) = 0 The Approximation Induction Principle is the following infinitary conditional equation: n (x) = n (y) (for all n) Intuitively, AIP states a "continuity" property of bisimulation, namely that <p> Proposition 5.9 BISIM i FINTREE = j Proof: Standard. The proof closely follows the proof of Theorem 2.5.8 in <ref> [10] </ref>, and essentially uses the result of Lemma 2.8 that all GSOS processes are finitely branching, i.e. boundedly non-deterministic in the terminology of [10]. 4 + Theorem 4.14 shows that the equational rules presented so far suffice to give the one-step behaviour of all closed terms, and hence their n-step behaviour <p> Proposition 5.9 BISIM i FINTREE = j Proof: Standard. The proof closely follows the proof of Theorem 2.5.8 in <ref> [10] </ref>, and essentially uses the result of Lemma 2.8 that all GSOS processes are finitely branching, i.e. boundedly non-deterministic in the terminology of [10]. 4 + Theorem 4.14 shows that the equational rules presented so far suffice to give the one-step behaviour of all closed terms, and hence their n-step behaviour for all n 2 N. <p> AIP is not valid though for most of the so-called `weak' process equivalences, which declare a special internal action o to be invisible. A weaker rule AIP holds in several of these cases (see <ref> [23, 10] </ref>) but unless additional proof principles like Koomen's Fair Abstraction Rule [10] are added, one will often lose completeness in the case of non-well-founded operations. <p> AIP is not valid though for most of the so-called `weak' process equivalences, which declare a special internal action o to be invisible. A weaker rule AIP holds in several of these cases (see [23, 10]) but unless additional proof principles like Koomen's Fair Abstraction Rule <ref> [10] </ref> are added, one will often lose completeness in the case of non-well-founded operations.
Reference: [11] <author> J.A. Bergstra. </author> <title> Put and get, primitives for synchronous unreliable message passing. Logic Group Preprint Series Nr. </title> <type> 3, </type> <institution> CIF, State University of Utrecht, </institution> <year> 1985. </year>
Reference-contexts: Ignoring termination issues, this operation may be specified by the following rules (one for each a): x ! x 0 ; y 9 (for all b &gt; a) a which are quite similar to (38). Bergstra <ref> [11] </ref> gives a finite axiomatization of without auxiliary operations.
Reference: [12] <author> J.A. Bergstra and J.W. Klop. </author> <title> Fixed point semantics in process algebras. </title> <type> Report IW 206, </type> <institution> Mathematisch Centrum, </institution> <address> Amsterdam, </address> <year> 1982. </year>
Reference-contexts: It is somewhat harder to see how to describe it equationally. Some equations are clear enough it is commutative and associative, and the stopped process is the identity but the first finite equational description did not appear until <ref> [12] </ref>. This equational characterization required an additional operation, "left merge" . 1 Intuitively, P Q is like P kQ except that the first move must be taken by P .
Reference: [13] <author> J.A. Bergstra and J.W. Klop. </author> <title> Process algebra for synchronous communication. </title> <journal> Information and Computation, </journal> 60(1/3):109-137, 1984. 
Reference-contexts: One then verifies the program by showing that it is equivalent to (or a suitable approximation of) the specification. Indeed, one of the major schools of theoretical concurrency, that of ACP <ref> [10, 13] </ref>, takes the notion of process equivalence as primary, and defines operational semantics to fit their algebraic laws. A logic of programs is complete (relative to a programming language) if all true formulas of the language are provable in the logic. <p> Proof: Straightforward from Lemma 4.10 and Theorem 4.9. 4 + 4.1.6 Examples We demonstrate our method on the parallel composition operation k of ACP <ref> [13, 10] </ref>. Fix a partial, commutative and associative function fl : Act fi Act * Act, which describes the synchronization between actions.
Reference: [14] <author> J.A. Bergstra and J.W. Klop. </author> <title> Verification of an alternating bit protocol by means of process algebra. </title> <editor> In W. Bibel and K.P. Jantke, editors, </editor> <title> Math. Methods of Spec. and Synthesis of Software Systems '85, </title> <journal> Math. Research 31, </journal> <pages> pages 9-23, </pages> <address> Berlin, </address> <year> 1986. </year> <note> Akademie-Verlag. First appeared as: Report CS-R8404, </note> <institution> CWI, </institution> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: In the more general setting (e.g., GSOS languages with recursive process definition), head normalization does not imply general normalization and indeed no finite, purely equational axiom system can be complete; however, the Approximation Induction Principle of <ref> [14, 10] </ref> is sound in our setting, can be expressed in GSOS terms, and makes the equations of Sections 4.1 and 4.2 complete. Of course, variations are possible on our method to obtain complete axiom systems for GSOS languages. <p> However, it is possible to extend our results to the whole class of GSOS systems in a rather standard way. Bisimulation equivalence over finitely branching labelled transition systems supports a powerful induction principle, known as the Approximation Induction Principle (AIP), see <ref> [14, 10] </ref>. By Lemma 2.8, all GSOS processes are finitely branching, so the AIP applies.
Reference: [15] <author> G. Berry. </author> <title> A hardware implementation of Pure Esterel. </title> <institution> Rapport de Recherche 06/91, Ecole des Mines, CMA, Sophia-Antipolis, France, </institution> <year> 1991. </year> <month> 42 </month>
Reference-contexts: In such a semantics, the behavior of a composite process is given in terms of the behaviors of its components. Some examples of languages specified by SOSses include <ref> [43, 44, 3, 4, 36, 15] </ref>. In SOS semantics, induction on terms and on the proofs of transitions are viable proof methods. SOSses are thus a fruitful area for proving properties of programming languages as a whole [52], compilation techniques [51], hardware implementations [15], and logics of programming [46]. <p> In SOS semantics, induction on terms and on the proofs of transitions are viable proof methods. SOSses are thus a fruitful area for proving properties of programming languages as a whole [52], compilation techniques [51], hardware implementations <ref> [15] </ref>, and logics of programming [46]. However, it is often necessary to prove properties of individual programs. While it is in principle possible to work directly with the semantics of the language to verify a program, this can be quite difficult.
Reference: [16] <author> B. Bloom. </author> <title> Ready Simulation, Bisimulation, and the Semantics of CCS-like Languages. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: In Section 6, we study one such variation, which uses fewer auxiliary operations. Finally, in Section 7, we discuss some topics for future research. 2 Preliminaries We assume familiarity with the basic notation of process algebra and structural operational semantics; see e.g. <ref> [31, 29, 35, 10, 27, 19, 16] </ref> for more details. We start from a countably infinite set Var of process variables with typical elements x; y. <p> The GSOS discipline is advocated in <ref> [16, 19] </ref>. Briefly, GSOS rules seem to be a maximal class of rules such that: 1. <p> It seems impossible to extend the format of the rules in any systematic way which preserves the basic sanity properties. Unlike 1, this is informal; <ref> [16] </ref> gives a series of examples showing that the most natural extensions violate the basic sanity properties of 1. There are other consistent rule formats, such as the tyft/tyxt format of [27] and the ntyft/ntyxt format of [20].
Reference: [17] <author> B. Bloom. </author> <title> Ready, set, go: Structural operational semantics for linear-time process algebras. </title> <type> Technical Report TR 93-1372, </type> <institution> Cornell, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: By now it is quite well understood which equivalences are congruences for which GSOS systems (see <ref> [19, 27, 50, 17, 18] </ref>), but some work remains to be done to extend these results to the new formats presented in this paper. In [19], ready simulation is introduced as an equivalence that is a congruence for all operations defined via GSOS rules. <p> In addition a GSOS language is presented for which ready simulation is in fact fully abstract (relative to completed trace equivalence). It is not too hard to define a language that uses only the smooth GSOS rules introduced in this paper such that ready simulation is fully abstract. <ref> [17] </ref> gives subclasses of GSOS languages which respect ready equivalence [ready trace equivalence], and for which our equational construction stays within the scope of the class.
Reference: [18] <author> B. Bloom. </author> <title> Structural operational semantics for weak bisimulations. </title> <type> Technical Report TR 93-1373, </type> <institution> Cornell, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: By now it is quite well understood which equivalences are congruences for which GSOS systems (see <ref> [19, 27, 50, 17, 18] </ref>), but some work remains to be done to extend these results to the new formats presented in this paper. In [19], ready simulation is introduced as an equivalence that is a congruence for all operations defined via GSOS rules. <p> The problem is analyzed in [25], where also a solution is proposed: the use of module logic instead of the standard (conditional) equational logic. Reference <ref> [18] </ref> gives a subclass of GSOS languages which respect various weak bisimulations; there it is shown how the methods of this paper apply to rooted branching bisimulation, and to a large extent to rooted weak bisimulation (Milner's "observational congruence" [35]). 7.2 Other Formats In this paper we assume that the set <p> The same trick applies to all constants. There are doubtless any number of other clever tricks axiomatizing other kinds of operations. (See, e.g., <ref> [18, 1] </ref> for a discussion of alternative axiomatizations of operators specified by rules without negative antecedents). The issue of improving the equations, and in particular reducing the number of auxiliary operations in equational characterizations of process equivalences, is of more than purely theoretical interest.
Reference: [19] <author> B. Bloom, S. Istrail, and A.R. Meyer. </author> <title> Bisimulation can't be traced: preliminary report. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 229-239, </pages> <year> 1988. </year> <note> Full version available as Technical Report 90-1150, </note> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <month> August </month> <year> 1990. </year> <note> To appear in the Journal of the ACM. </note>
Reference-contexts: In Section 6, we study one such variation, which uses fewer auxiliary operations. Finally, in Section 7, we discuss some topics for future research. 2 Preliminaries We assume familiarity with the basic notation of process algebra and structural operational semantics; see e.g. <ref> [31, 29, 35, 10, 27, 19, 16] </ref> for more details. We start from a countably infinite set Var of process variables with typical elements x; y. <p> The GSOS discipline is advocated in <ref> [16, 19] </ref>. Briefly, GSOS rules seem to be a maximal class of rules such that: 1. <p> Moreover, every operation in a GSOS system respects many of the stronger notions of process equivalence, in particular bisimulation [41, 34] and ready simulation <ref> [19] </ref>. 2. It seems impossible to extend the format of the rules in any systematic way which preserves the basic sanity properties. Unlike 1, this is informal; [16] gives a series of examples showing that the most natural extensions violate the basic sanity properties of 1. <p> By now it is quite well understood which equivalences are congruences for which GSOS systems (see <ref> [19, 27, 50, 17, 18] </ref>), but some work remains to be done to extend these results to the new formats presented in this paper. In [19], ready simulation is introduced as an equivalence that is a congruence for all operations defined via GSOS rules. <p> By now it is quite well understood which equivalences are congruences for which GSOS systems (see [19, 27, 50, 17, 18]), but some work remains to be done to extend these results to the new formats presented in this paper. In <ref> [19] </ref>, ready simulation is introduced as an equivalence that is a congruence for all operations defined via GSOS rules. In addition a GSOS language is presented for which ready simulation is in fact fully abstract (relative to completed trace equivalence).
Reference: [20] <author> R.N. Bol and J.F. Groote. </author> <title> The meaning of negative premises in transition system specifications (extended abstract). </title> <editor> In J. Leach Albert, B. Monien, and M. Rodriguez, editors, </editor> <booktitle> Proceedings 18 th ICALP, Madrid, volume 510 of Lecture Notes in Computer Science, </booktitle> <pages> pages 481-494. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> Full version available as Report CS-R9054, </note> <institution> CWI, </institution> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: Unlike 1, this is informal; [16] gives a series of examples showing that the most natural extensions violate the basic sanity properties of 1. There are other consistent rule formats, such as the tyft/tyxt format of [27] and the ntyft/ntyxt format of <ref> [20] </ref>. These two formats respect strong bisimulation, but induce transition systems that are in general neither computable nor finitely branching. We will now formally define the transition relation induced by a GSOS system, and state precisely some of the basic sanity properties of the format. <p> operational semantics of P + Q is defined by the rules (for each a) x ! x 0 a y ! y 0 a 4 Our notion of disjoint extension is more restrictive than the semantic one of "conservative extension" studied by Groote and Vaandrager [27], and Bol and Groote <ref> [20] </ref>. The restriction is essential in the technical development of the paper; it is needed for instance for Lemma 4.12. 8 The intent of these rules is that, whenever a transition is known to be possible for P or Q, that transition is possible for P + Q. <p> It is not clear to us how to handle more general rule formats with lookahead and function symbols in the antecedents, as the tyft/tyxt format of [27] and the ntyft/ntyxt format of <ref> [20] </ref>. 7.3 The Other Direction Now that we have shown that it is possible to generate complete axiom systems for arbitrary SOS specifications in GSOS format, a natural question to ask is whether it is possible to go 38 in the other direction as well, that is, to generate an SOS-style
Reference: [21] <author> D.J.B. Bosscher. </author> <title> Term rewriting properties of SOS axiomatizations, </title> <note> 1993. To appear as CWI technical report. An extended abstract will appear in the Proceedings of TACS '94. </note>
Reference-contexts: However, it may be argued that the new strategy of Figure 4 improves upon this algorithm as it does not use the y operations. Also, preliminary results of <ref> [21] </ref> indicate that the axiomatizations produced by the alternative strategy have better term rewriting properties. 36 Step 1. Add to G a disjoint copy of FINTREE, if it is not the case that FINTREE v G. Step 2.
Reference: [22] <author> R. De Nicola and R. Segala. </author> <title> A process algebraic view of input/output automata. </title> <institution> Rap-porto di Ricerca SI-92/07, Dipartimento di Scienze dell'Informazione, Universita degli Studi di Roma "La Sapienza", </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: successor and zero as zero is clearly not correct for arbitrary terms - e.g., succ + zero looks both positive and zero but it works for our coding of the naturals. 33 Another example is the complete equational axiomatization for an I/O automata calculus due to De Nicola and Segala <ref> [22] </ref>. An interesting open problem is to find a class of non-well-founded GSOS languages for which finite complete equational axiomatizations exist. 6 An Alternative Strategy Of course, several variations are possible on our method to obtain complete axiom systems for GSOS languages.
Reference: [23] <author> R.J. van Glabbeek. </author> <title> Bounded nondeterminism and the approximation induction principle in process algebra. </title> <editor> In F.J. Brandenburg, G. Vidal-Naquet, and M. Wirsing, editors, </editor> <booktitle> Proceedings STACS 87, volume 247 of Lecture Notes in Computer Science, </booktitle> <pages> pages 336-347. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: AIP is not valid though for most of the so-called `weak' process equivalences, which declare a special internal action o to be invisible. A weaker rule AIP holds in several of these cases (see <ref> [23, 10] </ref>) but unless additional proof principles like Koomen's Fair Abstraction Rule [10] are added, one will often lose completeness in the case of non-well-founded operations.
Reference: [24] <author> R.J. van Glabbeek. </author> <title> The linear time branching time spectrum. </title> <booktitle> In Baeten and Klop [8], </booktitle> <pages> pages 278-297. </pages>
Reference-contexts: This proof rule does hold for most `strong' equivalences on finitely branching labelled transition systems occurring in the literature, in particular for the 11 equivalences on this domain that are discussed in <ref> [24] </ref>. AIP is not valid though for most of the so-called `weak' process equivalences, which declare a special internal action o to be invisible.
Reference: [25] <author> R.J. van Glabbeek and F.W. Vaandrager. </author> <title> Modular specification of process algebras. </title> <journal> Theoretical Computer Science, </journal> <volume> 113(2) </volume> <pages> 293-348, </pages> <year> 1993. </year>
Reference-contexts: For instance, weak failure equivalence is a congruence for all the operations of the CSP language, but not for the auxiliary operations +, , and j generated by our method. The problem is analyzed in <ref> [25] </ref>, where also a solution is proposed: the use of module logic instead of the standard (conditional) equational logic.
Reference: [26] <author> J.F. Groote. </author> <title> A new strategy for proving !-completeness with applications in process algebra. </title> <booktitle> In Baeten and Klop [8], </booktitle> <pages> pages 314-331. </pages>
Reference: [27] <author> J.F. Groote and F.W. Vaandrager. </author> <title> Structured operational semantics and bisimulation as a congruence. </title> <journal> Information and Computation, </journal> <volume> 100(2) </volume> <pages> 202-260, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In Section 6, we study one such variation, which uses fewer auxiliary operations. Finally, in Section 7, we discuss some topics for future research. 2 Preliminaries We assume familiarity with the basic notation of process algebra and structural operational semantics; see e.g. <ref> [31, 29, 35, 10, 27, 19, 16] </ref> for more details. We start from a countably infinite set Var of process variables with typical elements x; y. <p> Unlike 1, this is informal; [16] gives a series of examples showing that the most natural extensions violate the basic sanity properties of 1. There are other consistent rule formats, such as the tyft/tyxt format of <ref> [27] </ref> and the ntyft/ntyxt format of [20]. These two formats respect strong bisimulation, but induce transition systems that are in general neither computable nor finitely branching. <p> The operational semantics of P + Q is defined by the rules (for each a) x ! x 0 a y ! y 0 a 4 Our notion of disjoint extension is more restrictive than the semantic one of "conservative extension" studied by Groote and Vaandrager <ref> [27] </ref>, and Bol and Groote [20]. <p> We will not motivate smoothness in this paper; it is a technical condition chosen to get proofs to work. The name "smooth" comes from the lack of "barbs"; that is, positive and negative tests on the same term. The format of smooth rules generalizes the format of De Simone <ref> [47, 27] </ref> since it allows restricted forms of negative hypotheses and copying. If there is a positive hypothesis x i a i then y i may be copied; however, x i must not appear at all , even if y i is completely destroyed. <p> By now it is quite well understood which equivalences are congruences for which GSOS systems (see <ref> [19, 27, 50, 17, 18] </ref>), but some work remains to be done to extend these results to the new formats presented in this paper. In [19], ready simulation is introduced as an equivalence that is a congruence for all operations defined via GSOS rules. <p> It is not clear to us how to handle more general rule formats with lookahead and function symbols in the antecedents, as the tyft/tyxt format of <ref> [27] </ref> and the ntyft/ntyxt format of [20]. 7.3 The Other Direction Now that we have shown that it is possible to generate complete axiom systems for arbitrary SOS specifications in GSOS format, a natural question to ask is whether it is possible to go 38 in the other direction as well,
Reference: [28] <author> M. Hennessy. </author> <title> A term model for synchronous processes. </title> <journal> Information and Control, </journal> <volume> 51(1) </volume> <pages> 58-75, </pages> <year> 1981. </year>
Reference-contexts: An example is the delay operation ffi of SCCS [34], which is defined by the rules ffix 1 ! ffix x ! y ffix a Hennessy <ref> [28] </ref> axiomatized this operation relative to a kind of bisimulation preorder.
Reference: [29] <author> M. Hennessy. </author> <title> Algebraic Theory of Processes. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: In Section 6, we study one such variation, which uses fewer auxiliary operations. Finally, in Section 7, we discuss some topics for future research. 2 Preliminaries We assume familiarity with the basic notation of process algebra and structural operational semantics; see e.g. <ref> [31, 29, 35, 10, 27, 19, 16] </ref> for more details. We start from a countably infinite set Var of process variables with typical elements x; y.
Reference: [30] <author> M. Hennessy and R. Milner. </author> <title> On observing nondeterminism and concurrency. </title> <editor> In J.W. de Bakker and J. van Leeuwen, editors, </editor> <booktitle> Proceedings 7 th ICALP, Noorwijkerhout, volume 85 of Lecture Notes in Computer Science, </booktitle> <pages> pages 299-309. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1980. </year> <title> This is a preliminary version of: Algebraic laws for nondeterminism and concurrency. </title> <journal> JACM, </journal> <volume> 32(1) </volume> <pages> 137-161, </pages> <year> 1985. </year>
Reference-contexts: For example, we have a (b + c) a b c , where we write a for a0 in process terms. The following completeness result is well-known <ref> [30, 35] </ref>: Lemma 3.1 Let T FINTREE be the theory consisting of the equations x + y = y + x (9) x + x = x (11) Then T FINTREE is complete for equality in Bisim (FINTREE). We will use the standard process algebra conventions for the FINTREE language.
Reference: [31] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <address> En-glewood Cliffs, </address> <year> 1985. </year>
Reference-contexts: We present the algorithm for strong bisimulation, the finest useful notion of process equivalence in this setting. We work in the setting of process algebras, languages such as CCS [35], CSP <ref> [31] </ref>, ACP, and Meije [5]. A process P is an entity capable of repeatedly performing uninterpreted atomic actions a. The basic operational notion in such languages is P a ! P 0 , indicating that P is capable of performing the action a and thereafter behaving like P 0 . <p> A typical operation found in many such languages (e.g., <ref> [31] </ref>) is interleaving parallel 2 composition without communication, which is defined by the rules (one pair of rules for every action a): x ! x 0 a y ! y 0 a This is an intuitively reasonable definition of simple parallel composition, and the operational rule is easy to explain. <p> In Section 6, we study one such variation, which uses fewer auxiliary operations. Finally, in Section 7, we discuss some topics for future research. 2 Preliminaries We assume familiarity with the basic notation of process algebra and structural operational semantics; see e.g. <ref> [31, 29, 35, 10, 27, 19, 16] </ref> for more details. We start from a countably infinite set Var of process variables with typical elements x; y.
Reference: [32] <author> He Jifeng and C.A.R. Hoare. </author> <title> From algebra to operational semantics. </title> <journal> Information Processing Letters, </journal> <volume> 45(2) </volume> <pages> 75-80, </pages> <year> 1993. </year>
Reference-contexts: In these cases it is, almost without exception, easy to find an SOS semantics. In particular this is always possible in the case of the axiomatizations generated by our method, since the original rules can be retrieved from the action laws. He Jifeng and Hoare <ref> [32] </ref> derive the standard SOS semantics of a large subset of CSP and a notational variant of Dijkstra's language from the algebraic semantics of these languages.
Reference: [33] <author> Huimin Lin. PAM: </author> <title> A Process Algebra Manipulator (Version 1.0). </title> <institution> Computer Science Report 4/93, University of Sussex, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: The issue of improving the equations, and in particular reducing the number of auxiliary operations in equational characterizations of process equivalences, is of more than purely theoretical interest. General tools which support algebraic style proofs of process equalities have recently been developed, e.g., Huimin Lin's PAM <ref> [33] </ref>. We envisage that suitably optimized versions of our methods might be the theoretical foundations for the development of front-ends to these tools, which, when fed with a GSOS system, would generate tractable equational axiomatizations of bisimulation equivalence.
Reference: [34] <author> R. Milner. </author> <title> Calculi for synchrony and asynchrony. </title> <journal> Theoretical Computer Science, </journal> <volume> 25 </volume> <pages> 267-310, </pages> <year> 1983. </year>
Reference-contexts: Moreover, every operation in a GSOS system respects many of the stronger notions of process equivalence, in particular bisimulation <ref> [41, 34] </ref> and ready simulation [19]. 2. It seems impossible to extend the format of the rules in any systematic way which preserves the basic sanity properties. <p> Even though an induction principle like AIP is needed to deal with general non-well founded GSOS systems, there are several examples in the literature of non-well-founded GSOS systems for which finite equational axiomatizations exist. An example is the delay operation ffi of SCCS <ref> [34] </ref>, which is defined by the rules ffix 1 ! ffix x ! y ffix a Hennessy [28] axiomatized this operation relative to a kind of bisimulation preorder.
Reference: [35] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, </address> <year> 1989. </year>
Reference-contexts: We present the algorithm for strong bisimulation, the finest useful notion of process equivalence in this setting. We work in the setting of process algebras, languages such as CCS <ref> [35] </ref>, CSP [31], ACP, and Meije [5]. A process P is an entity capable of repeatedly performing uninterpreted atomic actions a. <p> In Section 6, we study one such variation, which uses fewer auxiliary operations. Finally, in Section 7, we discuss some topics for future research. 2 Preliminaries We assume familiarity with the basic notation of process algebra and structural operational semantics; see e.g. <ref> [31, 29, 35, 10, 27, 19, 16] </ref> for more details. We start from a countably infinite set Var of process variables with typical elements x; y. <p> For example, we have a (b + c) a b c , where we write a for a0 in process terms. The following completeness result is well-known <ref> [30, 35] </ref>: Lemma 3.1 Let T FINTREE be the theory consisting of the equations x + y = y + x (9) x + x = x (11) Then T FINTREE is complete for equality in Bisim (FINTREE). We will use the standard process algebra conventions for the FINTREE language. <p> Reference [18] gives a subclass of GSOS languages which respect various weak bisimulations; there it is shown how the methods of this paper apply to rooted branching bisimulation, and to a large extent to rooted weak bisimulation (Milner's "observational congruence" <ref> [35] </ref>). 7.2 Other Formats In this paper we assume that the set Act of actions is finite. Consequently our methods can not be applied directly to the full versions of calculi like CCS [35] and Meije [5], since these calculi postulate an infinite action set. <p> apply to rooted branching bisimulation, and to a large extent to rooted weak bisimulation (Milner's "observational congruence" <ref> [35] </ref>). 7.2 Other Formats In this paper we assume that the set Act of actions is finite. Consequently our methods can not be applied directly to the full versions of calculi like CCS [35] and Meije [5], since these calculi postulate an infinite action set. If the action set is infinite it is natural to use, both in the inference rules and in the equations, variables ranging over actions instead of just actions.
Reference: [36] <author> R. Milner. </author> <title> Functions as processes. </title> <booktitle> In Paterson [42], </booktitle> <pages> pages 167-180. </pages>
Reference-contexts: In such a semantics, the behavior of a composite process is given in terms of the behaviors of its components. Some examples of languages specified by SOSses include <ref> [43, 44, 3, 4, 36, 15] </ref>. In SOS semantics, induction on terms and on the proofs of transitions are viable proof methods. SOSses are thus a fruitful area for proving properties of programming languages as a whole [52], compilation techniques [51], hardware implementations [15], and logics of programming [46].
Reference: [37] <author> F. Moller. </author> <title> Axioms for concurrency. </title> <type> PhD thesis, Report CST-59-89, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <year> 1989. </year>
Reference-contexts: Consider a constant defined by ! a: ! b:: (60) 10 Because in ACP one writes y x instead of x y, the algebra A is not a model of the basic ACP axioms for k. However, it follows from an example in <ref> [37] </ref> that also the ACP axioms are not complete for open terms. 40 is not distinctive; indeed, a constant is distinctive iff it has exactly one rule.
Reference: [38] <author> F. Moller. </author> <title> The importance of the left merge operator in process algebras. </title> <booktitle> In Paterson [42], </booktitle> <pages> pages 752-764. </pages>
Reference-contexts: Some operations char acterized in Section 4.1 as "smooth and distinctive" can be completely axiomatized by distributive laws like (3), action laws like (4), and inaction laws like (5). 1 <ref> [38] </ref> showed that additional operations, such as , are indeed required. 3 Properties of f Equations Smooth + distinctive Distributive, action, and inaction equations. <p> That is, we want to find a finite (conditional) equational theory T such that for all closed terms P; Q 2 T ( G ), T ` P = Q , Bisim (G) j= P = Q: Moller <ref> [38] </ref> has shown that bisimulation congruence over a subset of the usual CCS algebra with the interleaving operation k cannot be completely characterized by any finite set of equational axioms over that language. Thus, our program requires the addition of auxiliary operations to G.
Reference: [39] <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs. </title> <journal> Acta Informatica, </journal> <volume> 6(4) </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: For example, to verify a concurrent program directly, one might have to calculate its entire transition graph. It is thus helpful to have some more abstract reasoning principles. There are several methods of specifying processes, e.g. modal formulas [49] and variants of Hoare logic <ref> [39, 48] </ref>. One fairly successful verification technique is to give the specification as a (not necessarily implementable) process in the process algebra that the program is written in. One then verifies the program by showing that it is equivalent to (or a suitable approximation of) the specification.
Reference: [40] <author> C.H. Papadimitriou and K. Steiglitz. </author> <title> Combinatorial Optimization Algorithms and Complexity. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, </address> <year> 1982. </year>
Reference-contexts: But this problem is equivalent to the problem of finding an integer solution to f 0 h 0 f + g 0 3f + g h 1 The general problem of deciding whether a linear system of diophantine equations has a solution is known to be NP-complete <ref> [40] </ref>. (In this case, i = 0, f = g = 1, and h = 5 works.) 4 The import of the above proposition is that in some cases one can check whether a linear GSOS system is well-founded by proving its syntactic well-foundedness. <p> Generating equations tuned to au tomatic proof | e.g., with fewer auxiliary constants | will thus be of value in verifying programs. 8 Acknowledgements We would like to thank Ilaria Castellani and Sam Weber for comments on this paper, Robert de Simone and Loic Pottier for telling us about <ref> [40] </ref>, and the participants to the Process Algebra Meetings at CWI for the reference to [45]. The anonymous referees provided useful comments that led to improvements in the paper. In particular, one of them suggested the slightly more general versions of Definitions 5.5 and 5.6 that appear in this paper.
Reference: [41] <author> D.M.R. Park. </author> <title> Concurrency and automata on infinite sequences. </title> <editor> In P. Deussen, editor, </editor> <booktitle> 5 th GI Conference, volume 104 of Lecture Notes in Computer Science, </booktitle> <pages> pages 167-183. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Moreover, every operation in a GSOS system respects many of the stronger notions of process equivalence, in particular bisimulation <ref> [41, 34] </ref> and ready simulation [19]. 2. It seems impossible to extend the format of the rules in any systematic way which preserves the basic sanity properties.
Reference: [42] <editor> M. Paterson, editor. </editor> <booktitle> Proceedings 17 th ICALP, Warwick, volume 443 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1990. </year>
Reference: [43] <author> G.D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1981. </year> <month> 44 </month>
Reference-contexts: In such a semantics, the behavior of a composite process is given in terms of the behaviors of its components. Some examples of languages specified by SOSses include <ref> [43, 44, 3, 4, 36, 15] </ref>. In SOS semantics, induction on terms and on the proofs of transitions are viable proof methods. SOSses are thus a fruitful area for proving properties of programming languages as a whole [52], compilation techniques [51], hardware implementations [15], and logics of programming [46].
Reference: [44] <author> G.D. Plotkin. </author> <title> An operational semantics for CSP. </title> <editor> In D. Bjorner, editor, </editor> <booktitle> Proceedings IFIP TC2 Working Conference on Formal Description of Programming Concepts - II, Garmisch, </booktitle> <pages> pages 199-225, </pages> <address> Amsterdam, 1983. </address> <publisher> North-Holland. </publisher>
Reference-contexts: In such a semantics, the behavior of a composite process is given in terms of the behaviors of its components. Some examples of languages specified by SOSses include <ref> [43, 44, 3, 4, 36, 15] </ref>. In SOS semantics, induction on terms and on the proofs of transitions are viable proof methods. SOSses are thus a fruitful area for proving properties of programming languages as a whole [52], compilation techniques [51], hardware implementations [15], and logics of programming [46].
Reference: [45] <author> Sade. </author> <title> Smooth operator. In Diamond Life. Epic Records, </title> <year> 1984. </year>
Reference-contexts: Fix a partial ordering relation &gt; on Act. For each a the operation has a rule x ! x 0 ; x 9 (for all b &gt; a) a (18) 5 We use the term in an utterly different setting than <ref> [45] </ref>, and no confusion should arise. 11 For nontrivial &gt;, is non-smooth since it tests its argument with both positive and negative antecedents. <p> will thus be of value in verifying programs. 8 Acknowledgements We would like to thank Ilaria Castellani and Sam Weber for comments on this paper, Robert de Simone and Loic Pottier for telling us about [40], and the participants to the Process Algebra Meetings at CWI for the reference to <ref> [45] </ref>. The anonymous referees provided useful comments that led to improvements in the paper. In particular, one of them suggested the slightly more general versions of Definitions 5.5 and 5.6 that appear in this paper.
Reference: [46] <author> F.B. Schneider, B. Bloom, and K. Marzullo. </author> <title> Putting time into proof outlines. </title> <booktitle> In Proceedings REX Workshop "Real-Time: Theory in Practice", Mook, </booktitle> <address> The Netherlands, </address> <month> June </month> <year> 1991, </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <pages> pages 618-639. </pages> <note> Springer-Verlag, to appear. </note>
Reference-contexts: In SOS semantics, induction on terms and on the proofs of transitions are viable proof methods. SOSses are thus a fruitful area for proving properties of programming languages as a whole [52], compilation techniques [51], hardware implementations [15], and logics of programming <ref> [46] </ref>. However, it is often necessary to prove properties of individual programs. While it is in principle possible to work directly with the semantics of the language to verify a program, this can be quite difficult.
Reference: [47] <author> R. de Simone. </author> <title> Higher-level synchronising devices in meije-SCCS. </title> <journal> Theoretical Computer Science, </journal> <volume> 37 </volume> <pages> 245-267, </pages> <year> 1985. </year>
Reference-contexts: from with arity l, and C [~x; ~y] is a -context with variables including at most the x i 's and y ij 's. (It need not contain all these variables.) Note that the a ij , b ik , and c are actions, and not, as for instance in <ref> [47] </ref>, variables ranging over actions. It is useful to name components of rules. The operation symbol f is the principal operation of the rule, and the term f (~x) is the source. <p> We will not motivate smoothness in this paper; it is a technical condition chosen to get proofs to work. The name "smooth" comes from the lack of "barbs"; that is, positive and negative tests on the same term. The format of smooth rules generalizes the format of De Simone <ref> [47, 27] </ref> since it allows restricted forms of negative hypotheses and copying. If there is a positive hypothesis x i a i then y i may be copied; however, x i must not appear at all , even if y i is completely destroyed. <p> The question arises whether there exists a general, systematic way of finding more powerful axiomatiza-tions. In <ref> [47] </ref>, De Simone introduced the notion of FH-bisimulation as a viable, though not complete, proof technique for open equations. <p> Using FH-bisimulations it is not too hard to come up with an algorithm that can at least check the validity of the above commutativity and associativity laws, as well as many other important open equations. FH-bisimulations are defined in <ref> [47] </ref> for a format of linear, smooth rules with positive antecedents only, but we think that it will be possible to generalize this to general GSOS rules. 7.5 Improved Equations The equations generated by these methods are by no means optimal for all operations.
Reference: [48] <author> C. Stirling. </author> <title> A generalization of Owicki-Gries's Hoare logic for a concurrent while-language. </title> <journal> Theoretical Computer Science, </journal> <volume> 58 </volume> <pages> 34-359, </pages> <year> 1988. </year>
Reference-contexts: For example, to verify a concurrent program directly, one might have to calculate its entire transition graph. It is thus helpful to have some more abstract reasoning principles. There are several methods of specifying processes, e.g. modal formulas [49] and variants of Hoare logic <ref> [39, 48] </ref>. One fairly successful verification technique is to give the specification as a (not necessarily implementable) process in the process algebra that the program is written in. One then verifies the program by showing that it is equivalent to (or a suitable approximation of) the specification.
Reference: [49] <author> C. Stirling. </author> <title> Modal and temporal logics. </title> <editor> In S. Abramsky, D. Gabbay, and T.Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, Vol I. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1990. </year> <note> To appear. </note>
Reference-contexts: For example, to verify a concurrent program directly, one might have to calculate its entire transition graph. It is thus helpful to have some more abstract reasoning principles. There are several methods of specifying processes, e.g. modal formulas <ref> [49] </ref> and variants of Hoare logic [39, 48]. One fairly successful verification technique is to give the specification as a (not necessarily implementable) process in the process algebra that the program is written in.
Reference: [50] <author> F.W. Vaandrager. </author> <title> On the relationship between process algebra and input/output automata (extended abstract). </title> <booktitle> In Proceedings 6 th Annual Symposium on Logic in Computer Science, Amsterdam, </booktitle> <pages> pages 387-398. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: By now it is quite well understood which equivalences are congruences for which GSOS systems (see <ref> [19, 27, 50, 17, 18] </ref>), but some work remains to be done to extend these results to the new formats presented in this paper. In [19], ready simulation is introduced as an equivalence that is a congruence for all operations defined via GSOS rules.
Reference: [51] <author> S. Weber, B. Bloom, and G. Brown. </author> <title> Compiling Joy to silicon: A verified silicon compilation scheme. </title> <booktitle> In Proceedings of the Advanced Research in VLSI and VLSI and Parallel Systems Conference, </booktitle> <address> Providence, RI, </address> <year> 1992. </year>
Reference-contexts: Some examples of languages specified by SOSses include [43, 44, 3, 4, 36, 15]. In SOS semantics, induction on terms and on the proofs of transitions are viable proof methods. SOSses are thus a fruitful area for proving properties of programming languages as a whole [52], compilation techniques <ref> [51] </ref>, hardware implementations [15], and logics of programming [46]. However, it is often necessary to prove properties of individual programs. While it is in principle possible to work directly with the semantics of the language to verify a program, this can be quite difficult.
Reference: [52] <author> Andrew K. Wright and Matthias Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report TR91-160, </type> <institution> Rice University, </institution> <year> 1991. </year> <month> 45 </month>
Reference-contexts: Some examples of languages specified by SOSses include [43, 44, 3, 4, 36, 15]. In SOS semantics, induction on terms and on the proofs of transitions are viable proof methods. SOSses are thus a fruitful area for proving properties of programming languages as a whole <ref> [52] </ref>, compilation techniques [51], hardware implementations [15], and logics of programming [46]. However, it is often necessary to prove properties of individual programs. While it is in principle possible to work directly with the semantics of the language to verify a program, this can be quite difficult.
References-found: 52

