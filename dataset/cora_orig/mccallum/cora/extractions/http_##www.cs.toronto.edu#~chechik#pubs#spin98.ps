URL: http://www.cs.toronto.edu/~chechik/pubs/spin98.ps
Refering-URL: http://www.cs.toronto.edu/~chechik/projects.html
Root-URL: http://www.cs.toronto.edu
Title: Production Cell Revisited  
Author: Dimitrie O. Paun Marsha Chechik Bernd Biechele 
Date: June 18, 1998  
Abstract: This paper presents an analysis of the Production Cell system. We were able to model the system and verify most of its properties in Promela/SPIN. Our model is very close to the implementation level, and deriving code from it is trivial. In order to verify properties with SPIN's partial order reduction algorithms, we needed to ensure that all of our properties are closed under stuttering. We introduce the notion of logic edges and use them to show that properties of interest to us are closed under stuttering. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bernd Biechele and Dimitrie O. Paun. </author> <title> "A Case Study Production Cell with PROMELA/SPIN". </title> <editor> In M. Chechik, editor, </editor> <title> Automated Verification: A Collection of Reports. </title> <institution> University of Toronto, </institution> <type> Technical Report CSRG-374, </type> <year> 1998. </year>
Reference-contexts: In this section, we list several representative properties and describe the variables which appear in them. We present a complete list of properties in the Appendix. For more information about those and a description of all the system variables, please see <ref> [1] </ref>. <p> arm is positioned inside it. is formalized as 2 (press closed ) ((arm1 retracted ^ arm2 retracted)_ (robot pos = POS ARM1 TABLE ^ arm2 retracted)_ (robot pos = POS ARM2 BELT ^ arm1 retracted))); where arm1 retracted = robot ext [0] = EXT RETRACTED arm2 retracted = robot ext <ref> [1] </ref> = EXT RETRACTED This formula describes a slightly stronger property: the press may close only when both arms are retracted or one of them is pointing away from the press and the other one is retracted. 4.3 Verification Results The Promela code in our model consists of about 300 lines. <p> Our formulae are quite stylized: the "next" operator is used to identify events | that is, changes in the values of variables, e.g. 2 ((robot mgn <ref> [1] </ref> ^ ffi :robot mgn [1]) ) ffi (:new on deposit U (:deposit sen ^ ffi deposit sen))) (1) This formula says that when the robot drops an object on the deposit belt (there is a falling edge in robot mgn [1]), a new one should not be deposited (deposit sen <p> Our formulae are quite stylized: the "next" operator is used to identify events | that is, changes in the values of variables, e.g. 2 ((robot mgn <ref> [1] </ref> ^ ffi :robot mgn [1]) ) ffi (:new on deposit U (:deposit sen ^ ffi deposit sen))) (1) This formula says that when the robot drops an object on the deposit belt (there is a falling edge in robot mgn [1]), a new one should not be deposited (deposit sen should remain false) until the <p> in the values of variables, e.g. 2 ((robot mgn <ref> [1] </ref> ^ ffi :robot mgn [1]) ) ffi (:new on deposit U (:deposit sen ^ ffi deposit sen))) (1) This formula says that when the robot drops an object on the deposit belt (there is a falling edge in robot mgn [1]), a new one should not be deposited (deposit sen should remain false) until the previous object has been cleared (there is a rising edge in deposit sen). <p> Thus, F can refer to either of these states and not change the interpretation of the resulting formula under stuttering. Property 1 described above is represented as 2 (# robot mgn <ref> [1] </ref> ) ffi (:new on deposit U " deposit sen)) Equation 11 implies that :new on deposit U "deposit sen , and thus the whole property is c.u.s via Equation 10.
Reference: [2] <author> Thierry Cattel. </author> <title> "Process Control Design Using SPIN". </title> <booktitle> In Proceedings of SPIN Workshop, </booktitle> <address> Montreal, Canada, </address> <year> 1995. </year>
Reference-contexts: Here, we only want to convince ourselves (i.e., not a customer) that our system is correct. In our project, we worked with the Production Cell system [9]. This system has been specified in Promela/SPIN before by Thierry Cattel <ref> [2] </ref>. He described an approach to fl Contact address: Department of Computer Science, University of Toronto, Toronto, ON M5S 3G4, Canada. Email: fdimi,chechikg@cs.toronto.edu. y Contact address: Fakultat fur Informatik, Universitat Ulm, 89069 Ulm, Germany.
Reference: [3] <author> M. Chechik and Dimitrie O. Paun. </author> <title> "Linear-Time Properties for Event-Based and State-Based Formalisms". </title> <note> (in preparation), </note> <month> June </month> <year> 1998. </year>
Reference-contexts: We observed that stuttering cannot add or remove edges in propositional formulae which led us to develop a simple language and well-formedness criteria that allow us to easily identify a class of c.u.s formulae. This work is described in detail in <ref> [3] </ref>. We present some basic notions of this theory here. Definition 5.1 For a propositional formula a, " a = :a ^ ffi a, # a = a ^ ffi :a.
Reference: [4] <author> Rance Cleaveland, Joachim Parrow, and Bernhard Steffen. </author> <title> "The Concurrency Workbench: A Semantics Based Tool for the Verification of Concurrent Systems". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 36-72, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Email: bernd@bach.informatik.uni-ulm.de. 1 specification by building models on different levels of abstraction from a very abstract to more detailed ones through a sequence of refinement steps. Since SPIN cannot check equivalence between the levels of abstraction, Cattel used Concurrency Workbench <ref> [4] </ref> for this task. The goals of our work were quite different. We chose the Production Cell example to see if we can model non-trivial systems at a prescribed level of abstraction and check their properties without resorting to further abstraction.
Reference: [5] <author> G. J. Holzmann and O. Kupferman. </author> <title> "Not Checking for Closure under Stuttering". </title> <booktitle> In Proceedings of SPIN Workshop, </booktitle> <year> 1996. </year>
Reference-contexts: Despite the nice mathematical properties of the resulting language, it is not expressive enough even for fairly simple properties, as we found out in our study. An algorithm which can identify a larger class of c.u.s formulae has been proposed in <ref> [5] </ref> but not yet implemented in SPIN. A complete procedure for recognizing c.u.s formulae, based on the !-automata tableau-building algorithm, has also been developed and shown to be PSPACE-complete [12]. <p> A complete procedure for recognizing c.u.s formulae, based on the !-automata tableau-building algorithm, has also been developed and shown to be PSPACE-complete [12]. Unable to find the appropriate "next"-free LTL formalization for the desired properties and not having access to the automated procedures described in <ref> [5] </ref> and [12], we resorted to showing that these properties are c.u.s by hand.
Reference: [6] <author> Gerard Holzmann. </author> <title> Keynote address: "Designing Executable Abstractions". </title> <booktitle> In Proceedings of 2nd Workshop on Formal Methods in Software Practice, </booktitle> <month> March </month> <year> 1998. </year>
Reference-contexts: 1 Introduction In recent years model-checking has become a verification tool of choice for many projects. However, limitations of model-checking are well known systems have to be finite, and abstractions have to be used to combat the state-space explosion. Although abstractions are essential in reasoning about complicated algorithms <ref> [6] </ref>, they are not always natural or even feasible. Consider the following scenario: a customer specifies the environment at a certain level of abstraction. This might include timing, frequency of input sampling, etc.
Reference: [7] <author> G.J. Holzmann. </author> <title> "The Model Checker SPIN". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 23(5) </volume> <pages> 279-295, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: In our work, we specified and verified a model of the Production Cell system in Promela/SPIN <ref> [7] </ref>. Below we provide a brief description of the specification of the system. The production cell (see Figure 1) processes metal blanks which are conveyed to a press 2 by a feed belt. A robot takes each blank from the feed belt and places it into the press.
Reference: [8] <author> Leslie Lamport. </author> <title> "The Temporal Logic of Actions". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16 </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: In Section 4, we discuss formalizing and proving safety and liveness properties about the system. In order to use SPIN's powerful partial order reduction algorithms, we needed to convince ourselves that the properties under analysis are closed under stuttering <ref> [8] </ref>. We describe our approach to proving closure under stuttering in Section 5. <p> 66 56 Transitions (M) 1.4 0.4 0.3 0.3 0.5 0.4 0.4 0.3 1.3 0.6 0.5 0.7 0.6 0.4 Table 1: Resource requirements. 5 Closure Under Stuttering To reduce the size of the state-space, SPIN uses a partial-order reduction technique which is applicable only to formulae that are closed under stuttering <ref> [8] </ref>. A formula is closed under stuttering (c.u.s) if its interpretation does not change when we repeat (stutter) some states. For example, 2a is c.u.s, whereas ffia is not. Currently, one can easily ensure that a formula is c.u.s by avoiding the "next" operator [8]. <p> formulae that are closed under stuttering <ref> [8] </ref>. A formula is closed under stuttering (c.u.s) if its interpretation does not change when we repeat (stutter) some states. For example, 2a is c.u.s, whereas ffia is not. Currently, one can easily ensure that a formula is c.u.s by avoiding the "next" operator [8]. Despite the nice mathematical properties of the resulting language, it is not expressive enough even for fairly simple properties, as we found out in our study. An algorithm which can identify a larger class of c.u.s formulae has been proposed in [5] but not yet implemented in SPIN. <p> The edges are related: " :a =# a (2) # :a =" a (3) If a formula F is c.u.s, we write it as F . So, if F does not contain a "next" operator, then F <ref> [8] </ref>.
Reference: [9] <author> Claus Lewerentz and Thomas Lindner, </author> <title> editors. Formal Development of Reactive Systems. Case Study Production Cell. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference-contexts: Here, we only want to convince ourselves (i.e., not a customer) that our system is correct. In our project, we worked with the Production Cell system <ref> [9] </ref>. This system has been specified in Promela/SPIN before by Thierry Cattel [2]. He described an approach to fl Contact address: Department of Computer Science, University of Toronto, Toronto, ON M5S 3G4, Canada. Email: fdimi,chechikg@cs.toronto.edu. y Contact address: Fakultat fur Informatik, Universitat Ulm, 89069 Ulm, Germany. <p> We chose the Production Cell example to see if we can model non-trivial systems at a prescribed level of abstraction and check their properties without resorting to further abstraction. We were able to express in LTL and verify most of the properties described for the system in <ref> [9] </ref>. The rest of this paper is organized our as follows: Section 2 briefly describes the Production Cell case study. Section 3 describes the choices we made in modeling the system and suggests some modifications to SPIN. <p> We describe our approach to proving closure under stuttering in Section 5. Section 6 summarizes our experience with the project. 2 The Production Cell System The Production Cell System <ref> [9] </ref> is a case study initiated at the Forschungszentrum Infor-matik (FZI) to show the usefulness of formal methods for critical software systems and to show their applicability to real-world examples. In our work, we specified and verified a model of the Production Cell system in Promela/SPIN [7]. <p> In order to model the system, we had to abstract from its reactive components and keep track of the state of hardware using global variables. We discuss these techniques below. 1 In a "real" system, we would want to forge "new" blanks. However, the system specified in <ref> [9] </ref> has a closed production cycle to simulate a continuous stream of blanks. <p> this reduction automatically, reducing the burden of the model designer. 2 These checks are performed by simply searching the source code for the name of the variable; it should appear only in the macro definition and in the never claims. 5 4 Proving Properties The original description of the system <ref> [9] </ref> contained a large number of properties concerning all aspects of its behaviour. We were able to translate many of these properties into LTL and verify them using the SPIN model-checker. <p> In Table 1, we list the properties we were able to check, together with their verification time, memory used, and the number of computed transitions. Property numbers refer to the original description of the system <ref> [9] </ref>. We adopted the same numbering convention when listing the properties in the Appendix. The time measurements are approximate and are reported in seconds; the memory requirements reflect the real memory used, rounded to the nearest megabyte; the number of transitions is given in millions.
Reference: [10] <author> Z. Manna and A. Pnueli. </author> <title> "Tools and Rules for the Practicing Verifier". </title> <type> Technical Report STAN-CS-90-1321, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1990. </year>
Reference-contexts: These included a number of safety and one liveness property. In order to translate the properties into linear-time logic (LTL) <ref> [10] </ref>, we had to introduce a number of variables representing the state of hardware, as described in Section 3.2. In this section, we list several representative properties and describe the variables which appear in them. We present a complete list of properties in the Appendix.
Reference: [11] <author> J. Ostroff. </author> <title> "A Visual Toolset for the Design of Real-Time Discrete Event Systems". </title> <journal> IEEE Transactions on Control Systems Technology, </journal> <month> May </month> <year> 1997. </year> <month> 11 </month>
Reference-contexts: Instead, we assumed that other verification methods could be used to ensure that the reactive components are implemented correctly. Since SPIN does not support direct verification of properties involving time, a different tool would have to be chosen to specify and verify these, e.g. <ref> [11] </ref>. 4.2 Other Properties The majority of the properties in the original description did not involve time. These included a number of safety and one liveness property.
Reference: [12] <author> Doron Peled, Thomas Wilke, and Pierre Wolper. </author> <title> "An Algorithmic Approach for Checking Closure Properties of !-Regular Languages". </title> <booktitle> In Proceedings of CONCUR '96: 7th International Conference on Concurrency Theory, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: An algorithm which can identify a larger class of c.u.s formulae has been proposed in [5] but not yet implemented in SPIN. A complete procedure for recognizing c.u.s formulae, based on the !-automata tableau-building algorithm, has also been developed and shown to be PSPACE-complete <ref> [12] </ref>. Unable to find the appropriate "next"-free LTL formalization for the desired properties and not having access to the automated procedures described in [5] and [12], we resorted to showing that these properties are c.u.s by hand. <p> A complete procedure for recognizing c.u.s formulae, based on the !-automata tableau-building algorithm, has also been developed and shown to be PSPACE-complete <ref> [12] </ref>. Unable to find the appropriate "next"-free LTL formalization for the desired properties and not having access to the automated procedures described in [5] and [12], we resorted to showing that these properties are c.u.s by hand.
References-found: 12

