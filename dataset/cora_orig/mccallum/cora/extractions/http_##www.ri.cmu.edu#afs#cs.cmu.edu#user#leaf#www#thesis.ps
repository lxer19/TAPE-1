URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/user/leaf/www/thesis.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/user/leaf/www/index.html
Root-URL: 
Title: A Module System for LOOM  
Author: by Leaf Eames Petersen WILLIAMS 
Degree: A Thesis Submitted in partial fulfillment of of the requirements for the Degree of Bachelor of Arts with Honors in Computer Science  
Date: October 3, 1996  
Affiliation: COLLEGE Williamstown, Massachusetts  
Abstract-found: 0
Intro-found: 1
Reference: [AC95] <author> Martin Abadi and Luca Cardelli. </author> <title> On subtyping and matching. </title> <booktitle> In Proceedings ECOOP '95, </booktitle> <pages> pages 145-167, </pages> <year> 1995. </year>
Reference: [Ala89] <author> Suad Alagic. </author> <title> Object-Oriented Database Programming. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag New York Inc., </publisher> <year> 1989. </year>
Reference-contexts: This kind of construct is used frequently in object-oriented database programming, where it is common to want different objects to have different views of each other <ref> [Ala89] </ref>. Modula-3 supports a number of interesting features in this regard. To begin with, Modula-3 allows modules to implement multiple interfaces in a very straightforward way - modules simply specify more than one interface name in their export list.
Reference: [BCC + 96] <author> Kim B. Bruce, Luca Cardelli, Giuseppe Castagna, The Hopkins Objects Group, Gary T. Leavens, and Benjamin Pierce. </author> <title> On binary methods. </title> <booktitle> Theory and Practice of Object-Oriented Systems, </booktitle> <year> 1996. </year> <note> to appear. </note>
Reference-contexts: implementation type of the object. 7.1.2 Friends This conflict between the need for access to structural details and the need for abstraction that we see in in the set example is very common in object-oriented programming, making up a significant part of what is known as the binary method problem <ref> [BCC + 96] </ref>.
Reference: [BCD + 93] <author> K. Bruce, J. Crabtree, A. Dimock, R. Muller, T. Murtagh, and R. van Gent. </author> <title> Safe and decidable type checking in an object-oriented language. </title> <booktitle> In Proc. ACM Symp. on Object-Oriented Programming: Systems, Languages, and Applications, </booktitle> <pages> pages 29-46, </pages> <year> 1993. </year>
Reference: [BCK94] <author> K. Bruce, J. Crabtree, and G. Kanapathy. </author> <title> An operational semantics for TOOPLE: A statically-typed object-oriented programming language. </title> <editor> In S. Brookes, M. Main, A. Melton, M. Mislove, and D. Schmidt, editors, </editor> <booktitle> Mathematical Foundations of Programming Semantics, </booktitle> <pages> pages 603-626. </pages> <publisher> LNCS 802, Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: PolyTOIL is a statically typed object-oriented language that was designed to be completely type safe while still providing significantly more flexibility than existing object-oriented languages, such as C++ [ES90], or Object Pascal [Tes85]. It is itself an outgrowth of two other languages - TOOPLE <ref> [Bru94, BCK94] </ref> and TOIL [vG93, BvG93]. TOIL Typed Object-Oriented Imperative Language provides the type safety and flexibility of the functional language TOOPLE in an imperative language. PolyTOIL extends the basic object-oriented functionality of TOIL with parametric polymorphism, allowing even greater flexibility in the type system.
Reference: [Bru93] <author> K. Bruce. </author> <title> Safe type checking in a statically typed object-oriented programming language. </title> <booktitle> In Proc. ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 285-298, </pages> <year> 1993. </year>
Reference-contexts: PolyTOIL extends the basic object-oriented functionality of TOIL with parametric polymorphism, allowing even greater flexibility in the type system. One part of the parametric polymorphism of PolyTOIL is a form of bounded quantification based on an idea called matching <ref> [Bru93, Bru94, BSvG95] </ref>. 2.1 Introduction to PolyTOIL and matching Matching is a relation between types very similar to subtyping, loosely based on the inheritance hierarchy of objects.
Reference: [Bru94] <author> K. Bruce. </author> <title> A paradigmatic object-oriented programming language: design, static typing and semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 127-206, </pages> <year> 1994. </year> <note> An earlier version of this paper appeared in the 1993 POPL Proceedings. </note>
Reference-contexts: PolyTOIL is a statically typed object-oriented language that was designed to be completely type safe while still providing significantly more flexibility than existing object-oriented languages, such as C++ [ES90], or Object Pascal [Tes85]. It is itself an outgrowth of two other languages - TOOPLE <ref> [Bru94, BCK94] </ref> and TOIL [vG93, BvG93]. TOIL Typed Object-Oriented Imperative Language provides the type safety and flexibility of the functional language TOOPLE in an imperative language. PolyTOIL extends the basic object-oriented functionality of TOIL with parametric polymorphism, allowing even greater flexibility in the type system. <p> PolyTOIL extends the basic object-oriented functionality of TOIL with parametric polymorphism, allowing even greater flexibility in the type system. One part of the parametric polymorphism of PolyTOIL is a form of bounded quantification based on an idea called matching <ref> [Bru93, Bru94, BSvG95] </ref>. 2.1 Introduction to PolyTOIL and matching Matching is a relation between types very similar to subtyping, loosely based on the inheritance hierarchy of objects.
Reference: [BSvG95] <author> Kim B. Bruce, Angela Schuett, and Robert van Gent. PolyTOIL: </author> <title> A type-safe polymorphic object-oriented language, extended abstract. </title> <booktitle> In ECOOP '95, </booktitle> <pages> pages 27-51. </pages> <publisher> LNCS 952, Springer-Verlag, </publisher> <year> 1995. </year> <note> A complete version of this paper with full proofs is available via http://www.cs.williams.edu/~kim/. 75 BIBLIOGRAPHY 76 </note>
Reference-contexts: In Chapter 7 we evaluate the successes and failures of the LOOM module system, and present ideas for future work. Chapter 8 summarizes the results, and draws conclusions from the work. Chapter 2 Overview of LOOM The programming language LOOM is a descendant of an earlier language called PolyTOIL <ref> [BSvG95] </ref>. PolyTOIL is a statically typed object-oriented language that was designed to be completely type safe while still providing significantly more flexibility than existing object-oriented languages, such as C++ [ES90], or Object Pascal [Tes85]. <p> PolyTOIL extends the basic object-oriented functionality of TOIL with parametric polymorphism, allowing even greater flexibility in the type system. One part of the parametric polymorphism of PolyTOIL is a form of bounded quantification based on an idea called matching <ref> [Bru93, Bru94, BSvG95] </ref>. 2.1 Introduction to PolyTOIL and matching Matching is a relation between types very similar to subtyping, loosely based on the inheritance hierarchy of objects. <p> The complete set of rules along with definitions for symbols used in them appear in appendix B. An in depth look at the origin and meaning of the original PolyTOIL type checking rules, of which these are a direct descendant, can be found in <ref> [BSvG95] </ref>. <p> Recall from the type checking rules for PolyTOIL <ref> [BSvG95] </ref> that we define two sets of relations, C and E to maintain information used during type checking. C and E are used for determining the context of a type. The following is a formal definition of C, the type constraint system. <p> Chapter 6 The Interpreter 6.1 Implementation issues A prototype type checker and interpreter for the language LOOM has been implemented in SML, using the sml-yacc/sml-lex tools. The code for the base language is modified from the code for the PolyTOIL <ref> [BSvG95] </ref> interpreter originally implemented by Robert van Gent [vG93] and Angela Schuett [Sch94], and subsequently worked on by Jasper Rosenberg and myself. Interestingly, almost all of the modifications for handling the hash types occur only in the type checking phase, with the interpreter remaining relatively unchanged.
Reference: [BvG93] <author> Kim B. Bruce and Robert van Gent. </author> <title> TOIL: A new type-safe object-oriented imperative language. </title> <type> Technical report, </type> <institution> Williams College, </institution> <year> 1993. </year>
Reference-contexts: PolyTOIL is a statically typed object-oriented language that was designed to be completely type safe while still providing significantly more flexibility than existing object-oriented languages, such as C++ [ES90], or Object Pascal [Tes85]. It is itself an outgrowth of two other languages - TOOPLE [Bru94, BCK94] and TOIL <ref> [vG93, BvG93] </ref>. TOIL Typed Object-Oriented Imperative Language provides the type safety and flexibility of the functional language TOOPLE in an imperative language. PolyTOIL extends the basic object-oriented functionality of TOIL with parametric polymorphism, allowing even greater flexibility in the type system.
Reference: [Car89] <author> L. Cardelli. </author> <title> Typeful programming. </title> <type> Technical Report 45, </type> <institution> DEC Systems Research Center, </institution> <year> 1989. </year> <booktitle> Presented at IFIP Advanced Seminar on Formal Descriptions of Programming Concepts. </booktitle>
Reference: [CL94] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and modules for multi-methods. </title> <booktitle> In OOPSLA Proceedings, </booktitle> <year> 1994. </year> <note> to appear. </note>
Reference-contexts: Eiffel also provides a similar functionality by allowing the programmer to specify which features should CHAPTER 7. EVALUATION OF THE LANGUAGE 67 be exported to which classes [Mey92]. Other approaches to this problem include a concept called multi-methods <ref> [CL94] </ref> which allows dynamic message dispatch based on the dynamic type of the parameter to the method, and something called friendly functions [PT93] which provides similar functionality to C++'s friends in a type safe manner.
Reference: [CW85] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <year> 1985. </year>
Reference: [DGLM95] <author> Mark Day, Robert Gruber, Barbara Liskov, and Andrew C. Meyers. </author> <title> Subtypes vs. where clauses: Constraining parametric polymorphism. </title> <booktitle> In Proc. ACM Symp. on Object-Oriented Programming: Systems, Languages, and Applications, </booktitle> <pages> pages 156-168, </pages> <year> 1995. </year>
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrop. </author> <title> The annotated C ++ reference manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: It is not clear though that object-oriented facilities alone are sufficient to fully address all of the issues that come up in building large systems. Languages like C++ <ref> [ES90] </ref> and Eiffel [Mey92] that attempt to support programming-in-the-large through object systems alone are seeming more and more inadequate to the task. C++ in particular provides immensely complicated functionality in an attempt to provide programmers with sufficient flexibility to organize and write their code in a rational way. <p> Chapter 2 Overview of LOOM The programming language LOOM is a descendant of an earlier language called PolyTOIL [BSvG95]. PolyTOIL is a statically typed object-oriented language that was designed to be completely type safe while still providing significantly more flexibility than existing object-oriented languages, such as C++ <ref> [ES90] </ref>, or Object Pascal [Tes85]. It is itself an outgrowth of two other languages - TOOPLE [Bru94, BCK94] and TOIL [vG93, BvG93]. TOIL Typed Object-Oriented Imperative Language provides the type safety and flexibility of the functional language TOOPLE in an imperative language. <p> In C++, this is made even worse by the fact that classes are aggregates, not pointers, and hence must have information about their size hardwired into any client code (recall that in C++ classes serve as types for objects, and must specify the makeup of the object in complete detail) <ref> [ES90] </ref>. Client code must therefore either be written entirely using pointers, or else suffer from forced recompilation every time the size of a class changes. <p> A C++ class may optionally include a list of functions and other classes that are to be allowed access to the class's private features. This allows the example above to be written relatively straightforwardly, since classes are defined to be friends with themselves <ref> [ES90] </ref>. Eiffel also provides a similar functionality by allowing the programmer to specify which features should CHAPTER 7. EVALUATION OF THE LANGUAGE 67 be exported to which classes [Mey92].
Reference: [Har92] <author> Samuel P. Harbison. </author> <title> Modula-3. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> New Jersey, </address> <year> 1992. </year>
Reference-contexts: Another approach to supporting programming-in-the-large is to use the idea of modules. Languages such as Ada 95,[Joi95] Modula-3 <ref> [Har92, Nel91] </ref> and SML [Mac85, HMM86] have provided very different and interesting module systems, frequently in addition to object-oriented facilities. This approach is interesting because it allows different functionalities to be assigned to different language features, making the semantics easier to understand and less likely to interact in surprising ways. <p> MOTIVATIONS FOR MODULES 39 that modules which import other modules only need access to the interfaces of the imported modules. (The modules themselves can then be compiled in any order.) Moreover, changes in a module cannot force recompilation of other modules unless changes were made in the interface as well <ref> [Har92, Nel91] </ref>. Even more interesting from a language design standpoint are the facilities provided by Modula-3 for type abstraction. <p> As a result, SML can allow multiple structures to implement a single signature, allowing parameterization over modules in a more powerful and syntactically elegant manner. Modula-3 supports similar functionality through generic modules parameterized over interfaces, but the result is a fairly cumbersome mechanism <ref> [Har92] </ref>. On the other hand, restricting modular access to interfaces makes it much easier to compose modules into programs without relying on specific implementations, since the name of the implementation of an interface need never appear anywhere else in the program. <p> The module blocks are guaranteed to execute such that no module is initialized before any of its imports. (Since this refers only to implementation modules, the ordering is guaranteed to be acyclic) <ref> [Har92, Nel91] </ref>. Similarly, many languages also permit modules to contain runtime variables as members. In general, we could not come up with any sufficiently convincing arguments for allowing variables or executable sections in modules that could not be easily addressed with objects. <p> Generics are instantiated by binding actual interfaces to the formal interfaces. The semantics of this behavior is essentially equivalent to adding a list of imports renaming the actuals as the formals <ref> [Har92] </ref>. Parameterization over modules is a subject that needs to be evaluated very carefully. It seems in some senses to be a very powerful tool, but it is not clear that it is necessarily a useful or needed tool.
Reference: [HMM86] <author> R. Harper, D.B. MacQueen, and R. Milner. </author> <title> Standard ML. </title> <type> Technical Report ECS-LFCS-86-2, </type> <institution> Lab. for Foundations of Computer Science, University of Ed-inburgh, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: Another approach to supporting programming-in-the-large is to use the idea of modules. Languages such as Ada 95,[Joi95] Modula-3 [Har92, Nel91] and SML <ref> [Mac85, HMM86] </ref> have provided very different and interesting module systems, frequently in addition to object-oriented facilities. This approach is interesting because it allows different functionalities to be assigned to different language features, making the semantics easier to understand and less likely to interact in surprising ways.
Reference: [Joi95] <institution> Joint Technical Committee ISO/IEC JTC 1. </institution> <note> Ada 95 Reference Manual. </note> <institution> Inter-metrics, Inc., </institution> <year> 1995. </year>
Reference-contexts: CHAPTER 2. OVERVIEW OF LOOM 7 similar in functionality to Ada's idea of tagged records <ref> [Joi95] </ref>. Essentially the idea is that if e has type t and t &lt;# , then e also has type #. We refer to types of the form #t as "hash" types, in reference to the constructor.
Reference: [Jon96] <author> Mark P. Jones. </author> <title> Using parameterized signatures to express modular structure. </title> <booktitle> In 23rd ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 68-78, </pages> <year> 1996. </year>
Reference-contexts: Standard ML provides a small typed language on top of the core language explicitly for handling modular structures. All of these mechanisms are attempts to provide support in some way for programming in the large. Jones <ref> [Jon96] </ref> identifies three major issues that a module system needs to address: 1. The need to provide a way of organizing code into distinct units in a coherent way to facilitate code and namespace management. 2.
Reference: [KLM94] <author> Dinesh Katiyar, David Luckham, and John Mitchell. </author> <title> A type system for proto-typing languages. </title> <booktitle> In 21st ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 138-150, </pages> <year> 1994. </year>
Reference-contexts: This problem is fairly common in object-oriented programming languages. Name-space management is an especially crucial issue when it comes to types in PolyTOIL. Separate types must be provided for both a class and the objects it generates. Despite the use of a Rapide <ref> [KLM94] </ref> style type inclusion mechanism, type sections in PolyTOIL programs tend to be large and unwieldy even for small problems. The name-space difficulties this causes are not at all insignificant.
Reference: [KM89] <author> P.C. Kanellakis and J.C. Mitchell. </author> <title> Polymorphic unification and ML typing. </title> <booktitle> In 16th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 105-115, </pages> <year> 1989. </year>
Reference-contexts: Note too that this problem is not unique to LOOM. Type checking in SML is also in principle potentially exponential, but is in practice quite manageable. <ref> [KM89] </ref> Chapter 4 Motivations for Modules 4.1 Programming in the Large One thing that we have avoided dealing with up until this point is the issue of programming in the large.
Reference: [Ler94] <author> Xavier Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In Proc. 21st ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 109-122, </pages> <year> 1994. </year> <note> BIBLIOGRAPHY 77 </note>
Reference-contexts: This allows the type information to be propagated without violating the integrity of the module abstraction. This kind of abstraction is is referred to as a manifest type specification, and has been advanced as a possible solution to the SML separate compilation problem <ref> [Ler94] </ref>. Modula-3 takes this approach to exporting complete type information from modules. An interface may contain declarations of the form TYPE T = INTEGER, TYPE S = ..., etc. Any type importing the module in which the declarations appear may use all of the information given by the type declaration.
Reference: [Ler95] <author> Xavier Leroy. </author> <title> Applicative functors and fully transparent higher-order modules. </title> <booktitle> In Proc. 22nd ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1995. </year>
Reference: [Lis88] <author> Barbara Liskov. </author> <title> Data abstraction and hierarchy. </title> <booktitle> In OOPSLA '87 Addendum to the Proceedings, </booktitle> <pages> pages 17-34. </pages> <booktitle> ACM SIGPLAN Notices,23(5), </booktitle> <month> May </month> <year> 1988. </year>
Reference: [LSAS77] <author> B. Liskov, A. Snyder, R. Atkinson, and C. Schaffert. </author> <title> Abstraction mechanisms in clu. </title> <journal> Comm. ACM, </journal> <volume> 20 </volume> <pages> 564-576, </pages> <year> 1977. </year>
Reference: [Mac85] <author> D.B. MacQueen. </author> <title> Modules for Standard ML. </title> <journal> Polymorphism, </journal> <volume> 2(2), </volume> <year> 1985. </year> <pages> 35 pages. </pages> <note> An earlier version appeared in Proc. 1984 ACM Symp. on Lisp and Functional Programming. </note>
Reference-contexts: Another approach to supporting programming-in-the-large is to use the idea of modules. Languages such as Ada 95,[Joi95] Modula-3 [Har92, Nel91] and SML <ref> [Mac85, HMM86] </ref> have provided very different and interesting module systems, frequently in addition to object-oriented facilities. This approach is interesting because it allows different functionalities to be assigned to different language features, making the semantics easier to understand and less likely to interact in surprising ways.
Reference: [Mey92] <author> B. Meyer. </author> <title> Eiffel: the language. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: It is not clear though that object-oriented facilities alone are sufficient to fully address all of the issues that come up in building large systems. Languages like C++ [ES90] and Eiffel <ref> [Mey92] </ref> that attempt to support programming-in-the-large through object systems alone are seeming more and more inadequate to the task. C++ in particular provides immensely complicated functionality in an attempt to provide programmers with sufficient flexibility to organize and write their code in a rational way. <p> In the case of Eiffel, the usefulness of separate compilation is further compromised by the need (as yet unimplemented) for global link time checks to insure system validity, meaning that there is no guarantee that previously compiled code cannot later produce type errors <ref> [Mey92] </ref>. In general, the support for modular programming provided by these two languages does not sufficiently address the issues of programming in the large. Neither language provides any means of using modules to support type abstraction in any advanced sense. <p> This allows the example above to be written relatively straightforwardly, since classes are defined to be friends with themselves [ES90]. Eiffel also provides a similar functionality by allowing the programmer to specify which features should CHAPTER 7. EVALUATION OF THE LANGUAGE 67 be exported to which classes <ref> [Mey92] </ref>. Other approaches to this problem include a concept called multi-methods [CL94] which allows dynamic message dispatch based on the dynamic type of the parameter to the method, and something called friendly functions [PT93] which provides similar functionality to C++'s friends in a type safe manner.
Reference: [Nel91] <author> Greg Nelson, </author> <title> editor. Systems Programming in Modula-3. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> New Jersey, </address> <year> 1991. </year>
Reference-contexts: Another approach to supporting programming-in-the-large is to use the idea of modules. Languages such as Ada 95,[Joi95] Modula-3 <ref> [Har92, Nel91] </ref> and SML [Mac85, HMM86] have provided very different and interesting module systems, frequently in addition to object-oriented facilities. This approach is interesting because it allows different functionalities to be assigned to different language features, making the semantics easier to understand and less likely to interact in surprising ways. <p> MOTIVATIONS FOR MODULES 39 that modules which import other modules only need access to the interfaces of the imported modules. (The modules themselves can then be compiled in any order.) Moreover, changes in a module cannot force recompilation of other modules unless changes were made in the interface as well <ref> [Har92, Nel91] </ref>. Even more interesting from a language design standpoint are the facilities provided by Modula-3 for type abstraction. <p> In general there be any number of these partial revelations, with the restriction that all of the revealed supertypes be linearly ordered by the &lt;: relation, and that for all such Ws, V &lt;: W must hold <ref> [Nel91] </ref>. 5.2 Designing the LOOM Modules The process of designing programming language features involves a good deal of feedback between syntactic issues and semantic issues. <p> The module blocks are guaranteed to execute such that no module is initialized before any of its imports. (Since this refers only to implementation modules, the ordering is guaranteed to be acyclic) <ref> [Har92, Nel91] </ref>. Similarly, many languages also permit modules to contain runtime variables as members. In general, we could not come up with any sufficiently convincing arguments for allowing variables or executable sections in modules that could not be easily addressed with objects.
Reference: [Pie92] <author> Benjamin C. Pierce. </author> <title> Bounded quantification is undecidable. </title> <booktitle> In Proc 19th ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 305-315, </pages> <year> 1992. </year>
Reference-contexts: In particular, we show that type checking is decidable and give a lower bound for the complexity of the procedure. This is particularly important in light of the fact that in general, subtyping for bounded quantification is undecidable. <ref> [Pie92] </ref>. In section 3.1 we present a proof of the complexity of the equivalence and matching algorithms for LOOM. In section 3.2 we present a proof of the decidability of the type checking algorithm.
Reference: [PT93] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Statically typed friendly functions via partially abstract types. </title> <type> Technical Report ECS-LFCS-93-256, </type> <institution> University of Edinburgh, </institution> <year> 1993. </year>
Reference-contexts: EVALUATION OF THE LANGUAGE 67 be exported to which classes [Mey92]. Other approaches to this problem include a concept called multi-methods [CL94] which allows dynamic message dispatch based on the dynamic type of the parameter to the method, and something called friendly functions <ref> [PT93] </ref> which provides similar functionality to C++'s friends in a type safe manner. In LOOM, we provide the essence of the friends idea without tampering with the semantics of classes, and class abstraction.
Reference: [Sch94] <author> Angela Schuett. </author> <title> Parametric Polymorphism in a type-safe, object-oriented programming language. </title> <type> Williams College Senior Honors Thesis, </type> <year> 1994. </year>
Reference-contexts: The code for the base language is modified from the code for the PolyTOIL [BSvG95] interpreter originally implemented by Robert van Gent [vG93] and Angela Schuett <ref> [Sch94] </ref>, and subsequently worked on by Jasper Rosenberg and myself. Interestingly, almost all of the modifications for handling the hash types occur only in the type checking phase, with the interpreter remaining relatively unchanged.
Reference: [Tes85] <author> L. Tesler. </author> <title> Object Pascal report. </title> <type> Technical Report 1, </type> <institution> Apple Computer, </institution> <year> 1985. </year>
Reference-contexts: PolyTOIL is a statically typed object-oriented language that was designed to be completely type safe while still providing significantly more flexibility than existing object-oriented languages, such as C++ [ES90], or Object Pascal <ref> [Tes85] </ref>. It is itself an outgrowth of two other languages - TOOPLE [Bru94, BCK94] and TOIL [vG93, BvG93]. TOIL Typed Object-Oriented Imperative Language provides the type safety and flexibility of the functional language TOOPLE in an imperative language.
Reference: [vG93] <author> Robert van Gent. </author> <title> TOIL: An imperative type-safe object-oriented language. </title> <type> Williams College Senior Honors Thesis, </type> <year> 1993. </year>
Reference-contexts: PolyTOIL is a statically typed object-oriented language that was designed to be completely type safe while still providing significantly more flexibility than existing object-oriented languages, such as C++ [ES90], or Object Pascal [Tes85]. It is itself an outgrowth of two other languages - TOOPLE [Bru94, BCK94] and TOIL <ref> [vG93, BvG93] </ref>. TOIL Typed Object-Oriented Imperative Language provides the type safety and flexibility of the functional language TOOPLE in an imperative language. PolyTOIL extends the basic object-oriented functionality of TOIL with parametric polymorphism, allowing even greater flexibility in the type system. <p> Chapter 6 The Interpreter 6.1 Implementation issues A prototype type checker and interpreter for the language LOOM has been implemented in SML, using the sml-yacc/sml-lex tools. The code for the base language is modified from the code for the PolyTOIL [BSvG95] interpreter originally implemented by Robert van Gent <ref> [vG93] </ref> and Angela Schuett [Sch94], and subsequently worked on by Jasper Rosenberg and myself. Interestingly, almost all of the modifications for handling the hash types occur only in the type checking phase, with the interpreter remaining relatively unchanged.
References-found: 32

