URL: http://http.cs.berkeley.edu/~vahdat/publications/oopsla93/oopsla93.ps
Refering-URL: http://http.cs.berkeley.edu/~vahdat/publications/work.html
Root-URL: 
Title: Tools for the Development of Application-Specific Virtual Memory Management  
Author: Keith Krueger, David Loftesness, Amin Vahdat, and Thomas Anderson 
Address: Berkeley, CA 94720  
Affiliation: Computer Science Division University of California  
Abstract: While many applications incur few page faults, some scientific and database applications perform poorly when running on top of a traditional virtual memory implementation. To help address this problem, several systems have been built to allow each program the flexibility to use its own application-specific page replacement policy, in place of the generic policy provided by the operating system. This has the potential to improve performance for the class of applications limited by virtual memory behavior; however, to realize this performance gain, application developers must re-implement much of the virtual memory system, a non-trivial programming task. Our goal is to make it easy for programmers to develop new application-specific page replacement policies. To do this, we have implemented (i) an extensible object-oriented user-level virtual memory system and (ii) a graphical performance monitor for virtual memory behavior. Together, these help the user to identify problems with an application's existing paging policy and to quickly modify the system to fix these problems. We have used our tools for tuning the virtual memory performance of several applications; we present one case study illustrating the benefits and the limitations of our tools. This work was supported in part by the National Science Foundation (CDA-8722788), the Digital Equipment Corporation, the Xerox Corporation, and the AT&T Foundation. Anderson was also supported by a National Science Foundation Young Investigator Award. The authors' e-mail addresses are keithk/dloft/vahdat/tea@cs.berkeley.edu. 
Abstract-found: 1
Intro-found: 1
Reference: [Ald 1992] <institution> Aldus Corporation, Seattle, WA. Page maker Additions Developer Toolkit, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: Other examples include thread scheduling [Anderson et al. 1992], interprocess communication [Bershad et al. 1991], compiler optimizations [Steele Jr. 1990], database access routines [DeWitt & Carey 1984, Stonebraker 1987], and desktop publishing <ref> [Ald 1992, Clark 1992, Dyson 1992] </ref>. In all of these cases, an application-specific structure offers the potential for more flexibility and better performance, in part because it is difficult to design a complex system to be optimal for all users of the system.
Reference: [Alonso & Appel 1990] <author> Alonso, R. and Appel, A. </author> <title> An Advisor for Flexible Working Sets. </title> <booktitle> In Proceedings of the 1990 ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pp. 153-159, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: A garbage collector is another application that accesses memory in a way unsuitable for LRU <ref> [Alonso & Appel 1990] </ref>. Once a page has been garbage collected, it is not needed until the heap swings around again, yet LRU will keep it in memory because the page has been recently touched.
Reference: [Anderson et al. 1992] <author> Anderson, T., Bershad, B., La zowska, E., and Levy, H. </author> <title> Scheduler Activations: Effective Kernel Support for the User-Level Management of Parallelism. </title> <journal> In ACM Transactions on Computer Systems, </journal> <pages> pp. 53-79, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: Use VMprof to determine whether it performs well using LRU or still requires a custom policy. 7 Discussion Application-specific virtual memory is an instance of a larger trend towards structuring system software to allow application control over policy decisions. Other examples include thread scheduling <ref> [Anderson et al. 1992] </ref>, interprocess communication [Bershad et al. 1991], compiler optimizations [Steele Jr. 1990], database access routines [DeWitt & Carey 1984, Stonebraker 1987], and desktop publishing [Ald 1992, Clark 1992, Dyson 1992].
Reference: [Appel & Li 1991] <author> Appel, A. W. and Li, K. </author> <title> Virtual Memory Primitives for User Programs. </title> <booktitle> In Proceedings of the 4th ACM Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 96-107, </pages> <address> Santa Clara, California, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: For instance, this capability can be used to collect more detailed page usage information [Levy & Lipman 1982] or to provide other features such as distributed virtual memory, transactional memory, or automatic checkpointing <ref> [Appel & Li 1991] </ref>. Moreover, there is not a one-to-one mapping between applications and paging policies. The same default user-level pager can be used by the majority of applications that perform acceptably well with an LRU paging policy.
Reference: [Bershad et al. 1988] <author> Bershad, B., Lazowska, E., and Levy, H. </author> <title> PRESTO: A System for Object-Oriented Parallel Programming. </title> <journal> Software| Practice and Experience, </journal> <volume> 18(8) </volume> <pages> 713-732, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Apertos [Yokote 1992] is designed to be entirely reflective to allow every part of the operating system to be under application control. Perhaps most analogous to our work, Presto <ref> [Bershad et al. 1988] </ref> is a user-level thread system linked into parallel applications as a run-time library.
Reference: [Bershad et al. 1991] <author> Bershad, B., Anderson, T., La zowska, E., and Levy, H. </author> <title> User-Level Inter-process Communication for Shared-Memory Multiprocessors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2) </volume> <pages> 175-198, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Other examples include thread scheduling [Anderson et al. 1992], interprocess communication <ref> [Bershad et al. 1991] </ref>, compiler optimizations [Steele Jr. 1990], database access routines [DeWitt & Carey 1984, Stonebraker 1987], and desktop publishing [Ald 1992, Clark 1992, Dyson 1992].
Reference: [Cheriton et al. 1991] <author> Cheriton, D. R., Goosen, H. A., and Machanick, P. </author> <title> Restructuring a Parallel Simulation to Improve Shared Memory Multiprocessor Cache Behavior: A First Experience. </title> <booktitle> In Shared Memory Multiprocessor Symposium, </booktitle> <address> Tokyo, Japan, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Finally, if applications know the number of physical pages currently available to them, they can modify their runtime behavior to make optimal use of available resources <ref> [Harty & Cheriton 1992, Cheriton et al. 1991] </ref>. For example, certain Monte Carlo simulations generate a final result by averaging the results of a number of runs. Fewer runs of the simulation can be made to produce the same results if there is a larger sample size.
Reference: [Clark 1992] <author> Clark, J. </author> <title> Window Programmer' Guide To OLE/DDE. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: Other examples include thread scheduling [Anderson et al. 1992], interprocess communication [Bershad et al. 1991], compiler optimizations [Steele Jr. 1990], database access routines [DeWitt & Carey 1984, Stonebraker 1987], and desktop publishing <ref> [Ald 1992, Clark 1992, Dyson 1992] </ref>. In all of these cases, an application-specific structure offers the potential for more flexibility and better performance, in part because it is difficult to design a complex system to be optimal for all users of the system.
Reference: [Denning 1980] <author> Denning, P. </author> <title> Working Sets, Past and Present. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 6(1) </volume> <pages> 64-84, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: On current hardware, a single disk read can take the equivalent of about one million machine instructions to service, and this gap is likely to increase in the future. Operating systems have traditionally used virtual memory to help hide the gap between CPU speed and disk access time <ref> [Denning 1980] </ref>. Virtual memory provides the illusion of a large, fast address space for each application, by managing physical memory as a cache for disk.
Reference: [DeWitt & Carey 1984] <author> DeWitt, D. and Carey, M. </author> <title> Ex tensible Database Systems. </title> <booktitle> In Proc. 1st International Workshop on Expert Data Bases, </booktitle> <month> October </month> <year> 1984. </year>
Reference-contexts: Other examples include thread scheduling [Anderson et al. 1992], interprocess communication [Bershad et al. 1991], compiler optimizations [Steele Jr. 1990], database access routines <ref> [DeWitt & Carey 1984, Stonebraker 1987] </ref>, and desktop publishing [Ald 1992, Clark 1992, Dyson 1992].
Reference: [Dyson 1992] <author> Dyson, P. </author> <title> Xtensions for Xpress: Modular Software for Custom Systems. Seybold Report on Desktop Publishing, </title> <booktitle> 6(10) </booktitle> <pages> 1-21, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Other examples include thread scheduling [Anderson et al. 1992], interprocess communication [Bershad et al. 1991], compiler optimizations [Steele Jr. 1990], database access routines [DeWitt & Carey 1984, Stonebraker 1987], and desktop publishing <ref> [Ald 1992, Clark 1992, Dyson 1992] </ref>. In all of these cases, an application-specific structure offers the potential for more flexibility and better performance, in part because it is difficult to design a complex system to be optimal for all users of the system.
Reference: [Graham et al. 1982] <author> Graham, S., Kessler, P., and McKusick, M. </author> <title> gprof: A Call Graph Execution Profiler. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pp. 120-126, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: The user-extensible virtual memory manager and VMprof complement each other by decreasing the time needed to tune virtual memory performance. VMprof supplements other program performance analysis tools such as UNIX gprof <ref> [Graham et al. 1982] </ref> and MemSpy [Martonosi et al. 1992]. Given a trace of page faults, VMprof allows the user to analyze both spatial and temporal aspects of virtual memory management. VMprof's graphs may be used to identify regions of the address space with high page fault rates.
Reference: [Hagmann 1992] <author> Hagmann, R. </author> <title> Medium Term Virtual Memory Replacement. </title> <booktitle> In Proceeding of the Third Workshop on Workstation Operating Systems, </booktitle> <pages> pp. 142-147, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Worse, this problem will not improve with time: the performance of these applications will continue to deteriorate as the relative performance of disks continues to get slower. One possible solution would be to try to develop a "hero" virtual memory system that performs well for these programs (see <ref> [Hagmann 1992] </ref> for an attempt). The difficulty in developing such a system is that the operating system page replacement policy must balance the needs of all applications. <p> While this may appear attractive because memory is increasingly inexpensive, application programmers often would like to scale to even larger data set sizes. So, irrespective of the amount of physical memory, there will always be problems which require more memory than the hardware can support <ref> [Hagmann 1992] </ref>. * Bypass the operating system's virtual mem ory system by pinning a pool of the appli-cation's pages into physical memory [Stone-braker 1981]. User code explicitly manages the buffer pool as a cache for disk by deciding which disk pages get swapped into main memory.
Reference: [Harty & Cheriton 1992] <author> Harty, K. and Cheriton, D. R. </author> <title> Application-Controlled Physical Memory Using External Page-Cache Management. </title> <booktitle> In Proceedings of the 5th ACM Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 187-197, </pages> <year> 1992. </year>
Reference-contexts: Any program which performs well with LRU can use the system's default policy; other applications can use a policy tuned to their specific needs. Mach [Young et al. 1987, Rashid et al. 1988], V++ <ref> [Harty & Cheriton 1992] </ref>, and Aper-tos [Yokote 1992] are all systems that implement this approach. 1 While these systems have the potential for large improvements in application performance, it can be difficult for an ordinary application programmer to realize the potential performance gain. <p> Finally, if applications know the number of physical pages currently available to them, they can modify their runtime behavior to make optimal use of available resources <ref> [Harty & Cheriton 1992, Cheriton et al. 1991] </ref>. For example, certain Monte Carlo simulations generate a final result by averaging the results of a number of runs. Fewer runs of the simulation can be made to produce the same results if there is a larger sample size.
Reference: [Harty & Cheriton 1993] <author> Harty, K. and Cheriton, D. </author> <note> R. </note>
Reference-contexts: This can require large changes to application code since accesses to data structures must now indirect through the buffer pool manager, and it is inflexible in a multi-programmed environment <ref> [Harty & Cheriton 1993] </ref>. Worse, this essentially requires each application programmer to re-implement the virtual memory system. <p> A system call is added to inform the kernel that the application needs more/fewer pages of physical memory <ref> [Harty & Cheriton 1993] </ref>. * The user-level pager can request that the ker nel unmap a page but not remove it from memory, causing the application to trap on read or write references to selected pages. <p> Also, it should be possible to see how multiple programs interact when sharing the same physical memory resources, for those programs that adjust their memory usage based on run-time conditions. For instance, <ref> [Harty & Cheriton 1993] </ref> suggest that programs "bid" for physical memory; the kernel can then use a market approach to system memory allocation.
References-found: 15

