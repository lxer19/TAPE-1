URL: ftp://ftp.cs.sunysb.edu/pub/TechReports/kifer/tpc.ps.Z
Refering-URL: http://www.cs.sunysb.edu/~kifer/papers.html
Root-URL: http://www.cs.sunysb.edu
Email: kifer@cs.sunysb.edu  wujwo@cs.sunysb.edu  
Title: A First-Order Theory of Types and Polymorphism in Logic Programming  
Author: Michael Kifer James Wu 
Note: Work supported in part by the NSF grant IRI-8903507  
Address: NY 11794  NY 11794  
Affiliation: Department of Computer Science SUNY at Stony Brook Stony Brook,  Department of Computer Science SUNY at Stony Brook Stony Brook,  
Abstract: Technical Report #90/23 July 1990 Department of Computer Science SUNY at Stony Brook Abstract We describe a new logic called typed predicate calculus (T PC) that gives declarative meaning to logic programs with type declarations and type inference. T PC supports all popular types of polymorphism, such as parametric, inclusion, and ad hoc polymorphism. The proper interaction between parametric and inclusion varieties of polymorphism is achieved through a new construct, called type dependency, which is reminiscent of implication types of [PR89] but yields more natural and succinct specifications. Unlike other proposals where typing has extra-logical status, in T PC the notion of type-correctness has precise model-theoretic meaning that is independent of any specific type-checking or type-inference procedure. Moreover, many different approaches to typing that were proposed in the past can be studied and compared within the framework of our logic. As an illustration, we apply T PC to interpret and compare the results reported in [MO84, Smo88, HT90, Mis84, XW88]. Another novel feature of T PC is its reflexivity with respect to type declarations; namely, in T PC these declarations can be queried the same way as any other data. This should be contrasted with other proposals where typing is part of meta-specifications about the program, inaccessible from within the program. Type reflexivity is useful for browsing knowledge bases and, potentially, for debugging logic programs. 
Abstract-found: 1
Intro-found: 1
Reference: [AV88] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural and declarative database update languages. </title> <booktitle> In Proceedings of the ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 240-250, </pages> <year> 1988. </year>
Reference-contexts: With negative literals in rule-bodies, there is a number of different competing semantics <ref> [GRS88, GL88, Van89, AV88, KP88] </ref>, each of which can easily be adapted to T PC. All of these semantics have in common that the logical entailment is defined with respect to some subset of models, called canonic models (which may be different for different proposals).
Reference: [Azz88] <author> H. Azzoune. </author> <title> Type inference in Prolog. </title> <booktitle> In Proceedings of International Conference on Automated Deduction, </booktitle> <pages> pages 258-277, </pages> <year> 1988. </year>
Reference-contexts: Mishra [Mis84] was the first one to show that the idea of type inference that is widely used in functional languages is applicable to logic programs as well. This work was then followed by <ref> [MR85, KH85, Zob87, Azz88, Fru88, PR89] </ref>, where various inference-based approaches were studied. The idea of type inference is to let the compiler infer the types of predicates automatically, with little or no declarations supplied by the user. <p> The inferred type declarations are represented as regular trees and satisfy the well-typing principle according to which the inferred typing must cover all atoms that can be successfully derived from the program. This principle is widely accepted in the logic programming community, and several other researchers <ref> [Zob87, Azz88, PR89] </ref> further extended Mishra's work by proposing different type inference algorithms. In this subsection we explain how T PC captures the notion of Mishra's regular trees and show that his well-typing principle is consistent with the notion of type-correctness in T PC. <p> In this subsection we explain how T PC captures the notion of Mishra's regular trees and show that his well-typing principle is consistent with the notion of type-correctness in T PC. In particular, this means that the type-inference algorithms developed in <ref> [Mis84, Zob87, Azz88, PR89] </ref> can be used in T PC, provided that the type-base is restricted to regular trees. 21 Example 9.1 Consider the standard Prolog program for append: append (nil; K; K) append (cons (X; L); M; cons (X; N)) append (L; M; N ): The typing computed by Mishra's
Reference: [BB79] <author> C. Beeri and P.A. Bernstein. </author> <title> Computational problems related to the design of normal form relational schemes. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(1) </volume> <pages> 30-59, </pages> <month> March </month> <year> 1979. </year>
Reference-contexts: The question of whether or not ` T D fl, can be decided in linear time in the sizes of and fl <ref> [BB79] </ref>. Proposition 4.1 The inference rules for TDs are sound and complete, that is, j= T D fl if and only if ` T D fl.
Reference: [Bru82] <author> M. Bruynooghe. </author> <title> Adding redundancy to obtain more reliable and more readable Prolog programs. </title> <booktitle> In Proceedings of the First International Logic Programming Conference, </booktitle> <pages> pages 129-133, </pages> <address> Marseille, France, </address> <year> 1982. </year>
Reference-contexts: Several researchers have addressed this problem by attempting to enrich logic programming with various typing disciplines. These efforts can be classified into declaration-based and inference-based (also known as reconstruction-based or descriptive) approaches. Bruynooghe <ref> [Bru82] </ref> proposed a declaration-based type system, that requires the user to augment logic programs with type information, thereby enabling the system to detect type errors at compile time. Mycroft and O'Keefe [MO84] extended [Bru82] to support parametric polymorphism. <p> Bruynooghe <ref> [Bru82] </ref> proposed a declaration-based type system, that requires the user to augment logic programs with type information, thereby enabling the system to detect type errors at compile time. Mycroft and O'Keefe [MO84] extended [Bru82] to support parametric polymorphism. Recently, Dietrich and Hagl [DH88] and Jacobs [Jac90] further extended [MO84] to handle inclusion polymorphism. Another approach to polymorphic type checking, based on HiLog [CKW89a, CKW89b], is discussed in [Fru89, YFS90].
Reference: [CKW89a] <author> W. Chen, M. Kifer, and D.S. Warren. HiLog: </author> <title> A first-order semantics for higher-order logic programming constructs. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming, </booktitle> <month> October </month> <year> 1989. </year>
Reference-contexts: Mycroft and O'Keefe [MO84] extended [Bru82] to support parametric polymorphism. Recently, Dietrich and Hagl [DH88] and Jacobs [Jac90] further extended [MO84] to handle inclusion polymorphism. Another approach to polymorphic type checking, based on HiLog <ref> [CKW89a, CKW89b] </ref>, is discussed in [Fru89, YFS90]. Other researchers argued that declaration-based typing may severely impact the simplicity and flexibility of logic programming, since it requires every predicate symbol to be annotated with a type. <p> As an illustration, we showed how the formalisms of [MO84, Smo88, HT90, Mis84, XW88, Xu89] can be accounted for in our framework. Finally, we note that all results in this paper can be easily extended to typing HiLog <ref> [CKW89a, CKW89b] </ref>|a recently proposed higher-order logic programming language. Acknowledgements: We thank Catriel Beeri, Thom Fruehwirth, Dean Jacobs, Prateek Mishra, Uday Reddy, David Warren and Jiyang Xu for their valuable suggestions and illuminating discussions.
Reference: [CKW89b] <author> W. Chen, M. Kifer, and D.S. Warren. </author> <title> HiLog as a platform for database programming languages (or why predicate calculus is not enough). </title> <editor> In R. Hull, R. Morrison, and D. Stemple, editors, </editor> <booktitle> Database Programming Languages, </booktitle> <pages> pages 315-329. </pages> <publisher> Morgan-Kaufmann, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Mycroft and O'Keefe [MO84] extended [Bru82] to support parametric polymorphism. Recently, Dietrich and Hagl [DH88] and Jacobs [Jac90] further extended [MO84] to handle inclusion polymorphism. Another approach to polymorphic type checking, based on HiLog <ref> [CKW89a, CKW89b] </ref>, is discussed in [Fru89, YFS90]. Other researchers argued that declaration-based typing may severely impact the simplicity and flexibility of logic programming, since it requires every predicate symbol to be annotated with a type. <p> As an illustration, we showed how the formalisms of [MO84, Smo88, HT90, Mis84, XW88, Xu89] can be accounted for in our framework. Finally, we note that all results in this paper can be easily extended to typing HiLog <ref> [CKW89a, CKW89b] </ref>|a recently proposed higher-order logic programming language. Acknowledgements: We thank Catriel Beeri, Thom Fruehwirth, Dean Jacobs, Prateek Mishra, Uday Reddy, David Warren and Jiyang Xu for their valuable suggestions and illuminating discussions.
Reference: [DH88] <author> R. Dietrich and F. Hagl. </author> <title> A polymorphic type system with subtypes for Prolog. </title> <booktitle> In Proceedings of the 2-nd European Symp. on Programming, Lecture Notes in Computer Science 300, </booktitle> <pages> pages 79-93. </pages> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Bruynooghe [Bru82] proposed a declaration-based type system, that requires the user to augment logic programs with type information, thereby enabling the system to detect type errors at compile time. Mycroft and O'Keefe [MO84] extended [Bru82] to support parametric polymorphism. Recently, Dietrich and Hagl <ref> [DH88] </ref> and Jacobs [Jac90] further extended [MO84] to handle inclusion polymorphism. Another approach to polymorphic type checking, based on HiLog [CKW89a, CKW89b], is discussed in [Fru89, YFS90]. <p> We shall see shortly that TDs behave similarly to functional dependencies of the database theory (although, by themselves, they do not enforce any functional dependency on predicates). Type dependencies generalize modes in Prolog literature <ref> [War77, DW86, DH88] </ref>. Intuitively, TDs represent the flow of control between predicate arguments. Section 5.2 (see after Example 5.5) shows that, in the presence of inclusion polymorphism, mode declarations alone are incapable of capturing certain subtleties of interaction between the types assigned to predicate arguments. <p> Observe that, in contrast to our approach, predicate modes for append <ref> [DH88] </ref> can express only what amounts to a single TD f1; 2g ! f3g, and therefore the anomaly exhibited above is inevitable. <p> Syntactic approaches, usually found in the works on type checking (e.g., <ref> [MO84, DH88, Smo88, Fru89, YFS90, Jac90, HT90] </ref>), see the notion of type-correctness as a syntactic concept. Their notion of well-typing is defined by a set of "well-formedness rules" that are imposed directly on the syntactic structure of logic programs. <p> Similarly, SLDNF-resolution can be defined and the corresponding classical results carry over to T PC programs. 9 Case Study 9.1 Syntactic Approaches to Type Checking Majority of the approaches to type checking in logic programming (e.g., <ref> [MO84, DH88, Smo88, Fru89, YFS90, Jac90, HT90] </ref>) can be classified as syntactic. The notion of type-correctness is established via a set of well-typing rules, defined inductively on the syntactic structure of formulae. Consider first Mycroft-O'Keefe's type checking system [MO84]. <p> What this effectively means is that an innocent query that asks for the intersection of two heterogeneous sets (like p and q above) is illegitimate according to [MO84]. Dietrich and Hagl <ref> [DH88] </ref> and Jacobs [Jac90] have a similar problem if p is typed as phall=; ! ;i. Hence, the well-typing 20 conditions in [MO84, DH88, Jac90] are too restrictive. It is easy to see that in T PC the above program is well-typed. <p> Dietrich and Hagl [DH88] and Jacobs [Jac90] have a similar problem if p is typed as phall=; ! ;i. Hence, the well-typing 20 conditions in <ref> [MO84, DH88, Jac90] </ref> are too restrictive. It is easy to see that in T PC the above program is well-typed. Furthermore, the original approach in [MO84] has no model-theoretic semantics. As a result, some confusion may arise if the typed logic programs are interpreted naively.
Reference: [DW86] <author> S.K. Debray and D.S. Warren. </author> <title> Automatic mode inference for Prolog programs. </title> <booktitle> In IEEE Symposium on Logic Programming, </booktitle> <year> 1986. </year>
Reference-contexts: We shall see shortly that TDs behave similarly to functional dependencies of the database theory (although, by themselves, they do not enforce any functional dependency on predicates). Type dependencies generalize modes in Prolog literature <ref> [War77, DW86, DH88] </ref>. Intuitively, TDs represent the flow of control between predicate arguments. Section 5.2 (see after Example 5.5) shows that, in the presence of inclusion polymorphism, mode declarations alone are incapable of capturing certain subtleties of interaction between the types assigned to predicate arguments.
Reference: [End72] <author> H.B. Enderton. </author> <title> A Mathematical Introduction to Logic. </title> <publisher> Academic Press, </publisher> <year> 1972. </year>
Reference-contexts: There is a standard procedure to convert sorted programs into the one-sorted form (see <ref> [End72, page 279] </ref>). The following theorem establishes a correspondence between the well-typed programs of [MO84] (in Reddy's reconstruction) and those of T PC. Theorem 9.1 Let P be a well-typed program with respect to a type assignment in the sense of Mycroft-O'Keefe-Reddy.
Reference: [Fru88] <author> T. Fruehwirth. </author> <title> Type inference by program transformation and partial evaluation. </title> <booktitle> In IEEE Intl. Conf. on Computer Languages, </booktitle> <pages> pages 347-355, </pages> <address> Miami Beach, FL, </address> <year> 1988. </year>
Reference-contexts: Mishra [Mis84] was the first one to show that the idea of type inference that is widely used in functional languages is applicable to logic programs as well. This work was then followed by <ref> [MR85, KH85, Zob87, Azz88, Fru88, PR89] </ref>, where various inference-based approaches were studied. The idea of type inference is to let the compiler infer the types of predicates automatically, with little or no declarations supplied by the user.
Reference: [Fru89] <author> T. Fruehwirth. </author> <title> Polymorphic type checking for Prolog in HiLog. </title> <booktitle> In 6th Israel Conference on Artificial Intelligence and Computer Vision, </booktitle> <address> Tel Aviv, Israel, </address> <year> 1989. </year> <month> 25 </month>
Reference-contexts: Mycroft and O'Keefe [MO84] extended [Bru82] to support parametric polymorphism. Recently, Dietrich and Hagl [DH88] and Jacobs [Jac90] further extended [MO84] to handle inclusion polymorphism. Another approach to polymorphic type checking, based on HiLog [CKW89a, CKW89b], is discussed in <ref> [Fru89, YFS90] </ref>. Other researchers argued that declaration-based typing may severely impact the simplicity and flexibility of logic programming, since it requires every predicate symbol to be annotated with a type. <p> Syntactic approaches, usually found in the works on type checking (e.g., <ref> [MO84, DH88, Smo88, Fru89, YFS90, Jac90, HT90] </ref>), see the notion of type-correctness as a syntactic concept. Their notion of well-typing is defined by a set of "well-formedness rules" that are imposed directly on the syntactic structure of logic programs. <p> Similarly, SLDNF-resolution can be defined and the corresponding classical results carry over to T PC programs. 9 Case Study 9.1 Syntactic Approaches to Type Checking Majority of the approaches to type checking in logic programming (e.g., <ref> [MO84, DH88, Smo88, Fru89, YFS90, Jac90, HT90] </ref>) can be classified as syntactic. The notion of type-correctness is established via a set of well-typing rules, defined inductively on the syntactic structure of formulae. Consider first Mycroft-O'Keefe's type checking system [MO84].
Reference: [GL88] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Logic Programming: Proceedings of the Fifth Conference and Symposium, </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: With negative literals in rule-bodies, there is a number of different competing semantics <ref> [GRS88, GL88, Van89, AV88, KP88] </ref>, each of which can easily be adapted to T PC. All of these semantics have in common that the logical entailment is defined with respect to some subset of models, called canonic models (which may be different for different proposals). <p> Since all our examples employ definite Horn clauses only, the reader can handily think that canonic models coincide with t min -minimal models defined in Section 5.1. Precise definitions of canonic models in T PC according to the prefect [Prz88], well-founded [GRS88, Van89], or stable model semantics <ref> [GL88] </ref> can be given along the lines of the corresponding developments in PC and are beyond the scope of this paper.
Reference: [GRS88] <author> A. Van Gelder, K.A. Ross, and J.S. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <booktitle> In Proceedings of the ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 221-230, </pages> <year> 1988. </year>
Reference-contexts: With negative literals in rule-bodies, there is a number of different competing semantics <ref> [GRS88, GL88, Van89, AV88, KP88] </ref>, each of which can easily be adapted to T PC. All of these semantics have in common that the logical entailment is defined with respect to some subset of models, called canonic models (which may be different for different proposals). <p> Since all our examples employ definite Horn clauses only, the reader can handily think that canonic models coincide with t min -minimal models defined in Section 5.1. Precise definitions of canonic models in T PC according to the prefect [Prz88], well-founded <ref> [GRS88, Van89] </ref>, or stable model semantics [GL88] can be given along the lines of the corresponding developments in PC and are beyond the scope of this paper.
Reference: [GTW78] <author> J.A. Goguen, J.W. Thatcher, and E.W. Wagner. </author> <title> An initial algebra approach to the specification, correctness and implementation of abstract data types. In R.T. Yeh, editor, </title> <booktitle> Current Trends in Programming Methodology, </booktitle> <pages> pages 80-149. </pages> <publisher> Prentice-Hall, </publisher> <year> 1978. </year>
Reference-contexts: The recent work by Reddy [Red91] rectifies the problem by reconstructing Mycroft-O'Keefe's approach on the basis of the many-sorted algebra <ref> [GTW78] </ref>. In particular, predicate p in (7) would have the sort int and so will the variable X.
Reference: [HT90] <author> P. Hill and R. Topor. </author> <title> A semantics for typed logic programs. </title> <type> manuscript, </type> <year> 1990. </year>
Reference-contexts: Unfortunately, this approach does not work well in the presence of inclusion polymorphism, as discussed in Section 9.3. In this paper, we propose a framework that unifies many of the above works. Section 9 presents a case-study of several representative approaches <ref> [MO84, Smo88, HT90, Mis84, XW88, XW90] </ref>. Our results shed new light on these works, and allow to compare them in a single framework. <p> It should be noted that, despite its name, T PC is not a typed language. Instead, the type of a predicate is declared via logical formulas, called signatures, and types are enforced by semantic, model-theoretic means (as opposed to the syntactic means, such as many-sorted algebras <ref> [Smo88, HT90] </ref>). Thus, unlike other approaches, type declarations in T PC are formulae in the object language of the logic, rather than syntactic expressions in a meta-language. <p> Syntactic approaches, usually found in the works on type checking (e.g., <ref> [MO84, DH88, Smo88, Fru89, YFS90, Jac90, HT90] </ref>), see the notion of type-correctness as a syntactic concept. Their notion of well-typing is defined by a set of "well-formedness rules" that are imposed directly on the syntactic structure of logic programs. <p> Similarly, SLDNF-resolution can be defined and the corresponding classical results carry over to T PC programs. 9 Case Study 9.1 Syntactic Approaches to Type Checking Majority of the approaches to type checking in logic programming (e.g., <ref> [MO84, DH88, Smo88, Fru89, YFS90, Jac90, HT90] </ref>) can be classified as syntactic. The notion of type-correctness is established via a set of well-typing rules, defined inductively on the syntactic structure of formulae. Consider first Mycroft-O'Keefe's type checking system [MO84]. <p> Mycroft-O'Keefe's type system can be extended to support inclusion polymorphism using the idea of parametric order-sorted logic. Such extensions are described in [Smo88] and <ref> [HT90] </ref>. Results similar to Theorem 9.1 also hold about the relationship of these extensions to T PC. 9.2 Mishra's Type Inference System Mishra [Mis84] proposed an inference-based type system for Prolog, based on the idea of automatic type inference in ML. <p> Most importantly, we gave precise model-theoretic meaning to the notion of type-correctness, independent of any specific type-checking or type-inference procedure. This enables us to accommodate many different type-checking and type-inference algorithms that suit in different situations. As an illustration, we showed how the formalisms of <ref> [MO84, Smo88, HT90, Mis84, XW88, Xu89] </ref> can be accounted for in our framework. Finally, we note that all results in this paper can be easily extended to typing HiLog [CKW89a, CKW89b]|a recently proposed higher-order logic programming language.
Reference: [Jac90] <author> D. Jacobs. </author> <title> Type declarations as subtype constraints in logic programming. </title> <booktitle> In Proceedings of the ACM SIGPLAN-90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 165-173, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Bruynooghe [Bru82] proposed a declaration-based type system, that requires the user to augment logic programs with type information, thereby enabling the system to detect type errors at compile time. Mycroft and O'Keefe [MO84] extended [Bru82] to support parametric polymorphism. Recently, Dietrich and Hagl [DH88] and Jacobs <ref> [Jac90] </ref> further extended [MO84] to handle inclusion polymorphism. Another approach to polymorphic type checking, based on HiLog [CKW89a, CKW89b], is discussed in [Fru89, YFS90]. <p> Polymorphic types are treated as first-class citizens and are represented as ordinary 1 terms. 1 The relationship among types and their instances is defined by the user, via logic formulae that correspond to type declarations of <ref> [MO84, YS87, XW88, Jac90] </ref>, but are more general. It should be noted that, despite its name, T PC is not a typed language. <p> Atomic formulae of classical predicate calculus are called data atoms in T PC, in order to distinguish them from is-a and signature atoms introduced below. 1 Jacobs <ref> [Jac90] </ref> uses a similar (but less general) term-based representation of types. His overall approach is not semantic, though, and the notion of type-correctness is algorithm-dependent. <p> Syntactic approaches, usually found in the works on type checking (e.g., <ref> [MO84, DH88, Smo88, Fru89, YFS90, Jac90, HT90] </ref>), see the notion of type-correctness as a syntactic concept. Their notion of well-typing is defined by a set of "well-formedness rules" that are imposed directly on the syntactic structure of logic programs. <p> Similarly, SLDNF-resolution can be defined and the corresponding classical results carry over to T PC programs. 9 Case Study 9.1 Syntactic Approaches to Type Checking Majority of the approaches to type checking in logic programming (e.g., <ref> [MO84, DH88, Smo88, Fru89, YFS90, Jac90, HT90] </ref>) can be classified as syntactic. The notion of type-correctness is established via a set of well-typing rules, defined inductively on the syntactic structure of formulae. Consider first Mycroft-O'Keefe's type checking system [MO84]. <p> What this effectively means is that an innocent query that asks for the intersection of two heterogeneous sets (like p and q above) is illegitimate according to [MO84]. Dietrich and Hagl [DH88] and Jacobs <ref> [Jac90] </ref> have a similar problem if p is typed as phall=; ! ;i. Hence, the well-typing 20 conditions in [MO84, DH88, Jac90] are too restrictive. It is easy to see that in T PC the above program is well-typed. Furthermore, the original approach in [MO84] has no model-theoretic semantics. <p> Dietrich and Hagl [DH88] and Jacobs [Jac90] have a similar problem if p is typed as phall=; ! ;i. Hence, the well-typing 20 conditions in <ref> [MO84, DH88, Jac90] </ref> are too restrictive. It is easy to see that in T PC the above program is well-typed. Furthermore, the original approach in [MO84] has no model-theoretic semantics. As a result, some confusion may arise if the typed logic programs are interpreted naively. <p> The logic naturally supports inclusion, parametric, and ad hoc polymorphism. Type declarations in T PC are more expressive than in <ref> [MO84, Xu89, Jac90] </ref> and other works, since multiple signatures and functional-style type-enforcement patterns, can be used to capture polymorphic types. 24 We combined the benefits of declaration-based and inference-based approaches, and showed how type inference under partial type declarations fits in our framework.
Reference: [KH85] <author> T. Kanamori and K. Horiuchi. </author> <title> Type inference in Prolog and its application. </title> <booktitle> In Intl. Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 704-707, </pages> <year> 1985. </year>
Reference-contexts: Mishra [Mis84] was the first one to show that the idea of type inference that is widely used in functional languages is applicable to logic programs as well. This work was then followed by <ref> [MR85, KH85, Zob87, Azz88, Fru88, PR89] </ref>, where various inference-based approaches were studied. The idea of type inference is to let the compiler infer the types of predicates automatically, with little or no declarations supplied by the user.
Reference: [KL89] <author> M. Kifer and G. Lausen. F-logic: </author> <title> A higher-order language for reasoning about objects, inheritance and schema. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 134-146, </pages> <year> 1989. </year>
Reference-contexts: His overall approach is not semantic, though, and the notion of type-correctness is algorithm-dependent. In a different context, term-based representation of types also appears in <ref> [KL89] </ref>. 2 The view of types as classes comes from object-oriented logics [KL89, KLW90]. 2 To enable modeling the inclusion polymorphism, T PC lets one organize terms in an is-a hierarchy via a new kind of atomic formulae, called is-a atoms. <p> His overall approach is not semantic, though, and the notion of type-correctness is algorithm-dependent. In a different context, term-based representation of types also appears in [KL89]. 2 The view of types as classes comes from object-oriented logics <ref> [KL89, KLW90] </ref>. 2 To enable modeling the inclusion polymorphism, T PC lets one organize terms in an is-a hierarchy via a new kind of atomic formulae, called is-a atoms.
Reference: [KLW90] <author> M. Kifer, G. Lausen, and J. Wu. </author> <title> Logical foundations of object-oriented and frame-based languages. </title> <type> Technical Report 90/14, </type> <institution> Department of Computer Science, SUNY at Stony Brook, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: His overall approach is not semantic, though, and the notion of type-correctness is algorithm-dependent. In a different context, term-based representation of types also appears in [KL89]. 2 The view of types as classes comes from object-oriented logics <ref> [KL89, KLW90] </ref>. 2 To enable modeling the inclusion polymorphism, T PC lets one organize terms in an is-a hierarchy via a new kind of atomic formulae, called is-a atoms. <p> However, this seems to be a common practice so far in the works on types in logic programming and we do not intend to break the tradition in this paper. We note that object-oriented logic languages <ref> [KLW90] </ref> may require additional flexibility of being able to define classes that contain all objects with certain typing or internal state. In such a case, the above three components might not be independent. The following subsections discuss the aforesaid program components separately. <p> Notice that in (2) the result depends on the available object-level data as well as type declarations. We envision that queries against type declarations of T PC logic programs will be quite useful for debugging. In <ref> [KLW90] </ref> such queries are shown to be useful for browsing knowledge bases. 5.4 The Semantics of Well-Typedness We now pull together the various pieces discussed so far and define a semantics for T PC programs.
Reference: [KP88] <author> P.G. Kolaitis and C.H. Papadimitriou. </author> <title> Why not negation by fixpoint. </title> <booktitle> In Proceedings of the ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 231-239, </pages> <year> 1988. </year>
Reference-contexts: With negative literals in rule-bodies, there is a number of different competing semantics <ref> [GRS88, GL88, Van89, AV88, KP88] </ref>, each of which can easily be adapted to T PC. All of these semantics have in common that the logical entailment is defined with respect to some subset of models, called canonic models (which may be different for different proposals).
Reference: [Llo87] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming (Second Edition). </title> <publisher> Springer Verlag, </publisher> <year> 1987. </year>
Reference-contexts: For type-correct programs it can be shown that a T PC analogue of the SLD-resolution <ref> [Llo87] </ref> is sound and complete for Horn programs.
Reference: [Man74] <author> Z. Manna. </author> <title> Mathematical Theory of Computation. </title> <publisher> McGraw-Hill Book Co., </publisher> <year> 1974. </year>
Reference-contexts: Query emptiness is a problem of whether the set of solutions to a logical query ? q (:::) defined by a program P is empty. The class of all empty queries is known to be nonrecursively enumerable. (For instance, in the proof of Theorem 2-6, Manna <ref> [Man74, pages 105-106] </ref> shows that for every Post system S there is a Horn program P and a query ? p (Z; Z) such that this query has no answers if and only if S has no solution.) The reduction from query emptiness to type-correctness is carried out as follows.
Reference: [Mil78] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17(3) </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: In contrast, the notion of well-typedness in T PC given earlier does not capture the above intuition and is too weak to classify P as ill-typed. There are deficiencies in syntactic approaches, too. Many such approaches insist that well-typed programs should not "go wrong" <ref> [Mil78, MO84] </ref>. Although this requirement causes problems even without subtyping, the latter makes it unavoidable to think of better criteria for syntactic well-typedness. For instance, the not-going-wrong requirement makes it illegal to ask for the intersection of a pair of predicates that define heterogeneous sets. <p> The notion of type-correctness is established via a set of well-typing rules, defined inductively on the syntactic structure of formulae. Consider first Mycroft-O'Keefe's type checking system [MO84]. Their well-typing rules are derived from the slogan that "well-typed programs do not go wrong", coined in by Milner <ref> [Mil78] </ref>. By "not going wrong" in [MO84] is meant that subgoals are not called with bindings that disagree with the declared typing of the corresponding predicates.
Reference: [Mis84] <author> P. Mishra. </author> <title> Towards a theory of types in Prolog. </title> <booktitle> In IEEE Symposium on Logic Programming, </booktitle> <pages> pages 289-298, </pages> <year> 1984. </year>
Reference-contexts: Another approach to polymorphic type checking, based on HiLog [CKW89a, CKW89b], is discussed in [Fru89, YFS90]. Other researchers argued that declaration-based typing may severely impact the simplicity and flexibility of logic programming, since it requires every predicate symbol to be annotated with a type. Mishra <ref> [Mis84] </ref> was the first one to show that the idea of type inference that is widely used in functional languages is applicable to logic programs as well. This work was then followed by [MR85, KH85, Zob87, Azz88, Fru88, PR89], where various inference-based approaches were studied. <p> Unfortunately, this approach does not work well in the presence of inclusion polymorphism, as discussed in Section 9.3. In this paper, we propose a framework that unifies many of the above works. Section 9 presents a case-study of several representative approaches <ref> [MO84, Smo88, HT90, Mis84, XW88, XW90] </ref>. Our results shed new light on these works, and allow to compare them in a single framework. <p> Then list (nat) is the type of all lists of natural numbers, containing elements such as nil, cons (zero; nil), cons (zero; cons (succ (zero); nil)), and so on. 2 10 Observe that we do not require types to be tuple-distributive in the sense of <ref> [Mis84] </ref>. However, usually they will come out that way, if the semantic of a specific type calls for this feature (cf. list (T ) above). Likewise, in T PC, type constructors do not have to be monotonic. <p> Their notion of well-typing is defined by a set of "well-formedness rules" that are imposed directly on the syntactic structure of logic programs. In contrast, semantic approaches, where T PC and most of the works on type inference (e.g., <ref> [Mis84, YS87, Xu89] </ref>) belong, define the concept of type-correctness in model-theoretic or set-theoretic terms. For instance, in T PC, a program is regarded as well-typed if and only if the intended model of the program satisfies the well-typing conditions of Section 2.2. <p> In extreme cases, the system can assume all TDs to be trivial (e.g., ; ! ;, ! ! ;) or, alternatively, the strongest ones (i.e., ; ! !). For instance, Mishra <ref> [Mis84] </ref> and Xu and Warren [XW88, Xu89, XW90] implicitly assume all type dependencies to be trivial. User-supplied TDs may improve the accuracy of type inference algorithms, for in case of trivial TDs too many signatures may be inferred, leading to information glut. <p> Mycroft-O'Keefe's type system can be extended to support inclusion polymorphism using the idea of parametric order-sorted logic. Such extensions are described in [Smo88] and [HT90]. Results similar to Theorem 9.1 also hold about the relationship of these extensions to T PC. 9.2 Mishra's Type Inference System Mishra <ref> [Mis84] </ref> proposed an inference-based type system for Prolog, based on the idea of automatic type inference in ML. This type system is able to infer typings for all predicates in any logic program without explicit type declarations. <p> In this subsection we explain how T PC captures the notion of Mishra's regular trees and show that his well-typing principle is consistent with the notion of type-correctness in T PC. In particular, this means that the type-inference algorithms developed in <ref> [Mis84, Zob87, Azz88, PR89] </ref> can be used in T PC, provided that the type-base is restricted to regular trees. 21 Example 9.1 Consider the standard Prolog program for append: append (nil; K; K) append (cons (X; L); M; cons (X; N)) append (L; M; N ): The typing computed by Mishra's <p> Most importantly, we gave precise model-theoretic meaning to the notion of type-correctness, independent of any specific type-checking or type-inference procedure. This enables us to accommodate many different type-checking and type-inference algorithms that suit in different situations. As an illustration, we showed how the formalisms of <ref> [MO84, Smo88, HT90, Mis84, XW88, Xu89] </ref> can be accounted for in our framework. Finally, we note that all results in this paper can be easily extended to typing HiLog [CKW89a, CKW89b]|a recently proposed higher-order logic programming language.
Reference: [MO84] <author> A. Mycroft and R.A. O'Keefe. </author> <title> A polymorphic type system for Prolog. </title> <journal> Artificial Intelligence, </journal> <volume> 23 </volume> <pages> 295-307, </pages> <year> 1984. </year>
Reference-contexts: These efforts can be classified into declaration-based and inference-based (also known as reconstruction-based or descriptive) approaches. Bruynooghe [Bru82] proposed a declaration-based type system, that requires the user to augment logic programs with type information, thereby enabling the system to detect type errors at compile time. Mycroft and O'Keefe <ref> [MO84] </ref> extended [Bru82] to support parametric polymorphism. Recently, Dietrich and Hagl [DH88] and Jacobs [Jac90] further extended [MO84] to handle inclusion polymorphism. Another approach to polymorphic type checking, based on HiLog [CKW89a, CKW89b], is discussed in [Fru89, YFS90]. <p> Bruynooghe [Bru82] proposed a declaration-based type system, that requires the user to augment logic programs with type information, thereby enabling the system to detect type errors at compile time. Mycroft and O'Keefe <ref> [MO84] </ref> extended [Bru82] to support parametric polymorphism. Recently, Dietrich and Hagl [DH88] and Jacobs [Jac90] further extended [MO84] to handle inclusion polymorphism. Another approach to polymorphic type checking, based on HiLog [CKW89a, CKW89b], is discussed in [Fru89, YFS90]. Other researchers argued that declaration-based typing may severely impact the simplicity and flexibility of logic programming, since it requires every predicate symbol to be annotated with a type. <p> Unfortunately, this approach does not work well in the presence of inclusion polymorphism, as discussed in Section 9.3. In this paper, we propose a framework that unifies many of the above works. Section 9 presents a case-study of several representative approaches <ref> [MO84, Smo88, HT90, Mis84, XW88, XW90] </ref>. Our results shed new light on these works, and allow to compare them in a single framework. <p> Polymorphic types are treated as first-class citizens and are represented as ordinary 1 terms. 1 The relationship among types and their instances is defined by the user, via logic formulae that correspond to type declarations of <ref> [MO84, YS87, XW88, Jac90] </ref>, but are more general. It should be noted that, despite its name, T PC is not a typed language. <p> Syntactic approaches, usually found in the works on type checking (e.g., <ref> [MO84, DH88, Smo88, Fru89, YFS90, Jac90, HT90] </ref>), see the notion of type-correctness as a syntactic concept. Their notion of well-typing is defined by a set of "well-formedness rules" that are imposed directly on the syntactic structure of logic programs. <p> As a rule, the criteria for well-typedness in syntactic approaches are stricter than in semantic approaches. For instance, a program may be ill-typed according to Mycroft and O'Keefe <ref> [MO84] </ref> but not in T PC. <p> This program is well-typed in T PC, for p (a) is never derived. In Mycroft-O'Keefe's type system <ref> [MO84] </ref> this program is clearly ill-typed because p (a) is ill-formed regardless of whether it can be derived or not. One advantage of syntactic approaches is that the type-checking problem is (usually) decidable, since only finitely many program components need be examined. <p> Then any type assignment for X makes either p (X) or q (X) ill-typed because string and int do not share common subtype or instances. As a consequence, P would be regarded as ill-typed by syntactic approaches, such as Mycroft-O'Keefe's <ref> [MO84] </ref>. In contrast, the notion of well-typedness in T PC given earlier does not capture the above intuition and is too weak to classify P as ill-typed. There are deficiencies in syntactic approaches, too. Many such approaches insist that well-typed programs should not "go wrong" [Mil78, MO84]. <p> In contrast, the notion of well-typedness in T PC given earlier does not capture the above intuition and is too weak to classify P as ill-typed. There are deficiencies in syntactic approaches, too. Many such approaches insist that well-typed programs should not "go wrong" <ref> [Mil78, MO84] </ref>. Although this requirement causes problems even without subtyping, the latter makes it unavoidable to think of better criteria for syntactic well-typedness. For instance, the not-going-wrong requirement makes it illegal to ask for the intersection of a pair of predicates that define heterogeneous sets. <p> Similarly, SLDNF-resolution can be defined and the corresponding classical results carry over to T PC programs. 9 Case Study 9.1 Syntactic Approaches to Type Checking Majority of the approaches to type checking in logic programming (e.g., <ref> [MO84, DH88, Smo88, Fru89, YFS90, Jac90, HT90] </ref>) can be classified as syntactic. The notion of type-correctness is established via a set of well-typing rules, defined inductively on the syntactic structure of formulae. Consider first Mycroft-O'Keefe's type checking system [MO84]. <p> The notion of type-correctness is established via a set of well-typing rules, defined inductively on the syntactic structure of formulae. Consider first Mycroft-O'Keefe's type checking system <ref> [MO84] </ref>. Their well-typing rules are derived from the slogan that "well-typed programs do not go wrong", coined in by Milner [Mil78]. By "not going wrong" in [MO84] is meant that subgoals are not called with bindings that disagree with the declared typing of the corresponding predicates. <p> Consider first Mycroft-O'Keefe's type checking system <ref> [MO84] </ref>. Their well-typing rules are derived from the slogan that "well-typed programs do not go wrong", coined in by Milner [Mil78]. By "not going wrong" in [MO84] is meant that subgoals are not called with bindings that disagree with the declared typing of the corresponding predicates. Although this principle may be appropriate in functional programming, it cannot be fully applied to logic programs since, in fact, logic programs never go wrong in the logical sense. <p> What this effectively means is that an innocent query that asks for the intersection of two heterogeneous sets (like p and q above) is illegitimate according to <ref> [MO84] </ref>. Dietrich and Hagl [DH88] and Jacobs [Jac90] have a similar problem if p is typed as phall=; ! ;i. Hence, the well-typing 20 conditions in [MO84, DH88, Jac90] are too restrictive. It is easy to see that in T PC the above program is well-typed. <p> Dietrich and Hagl [DH88] and Jacobs [Jac90] have a similar problem if p is typed as phall=; ! ;i. Hence, the well-typing 20 conditions in <ref> [MO84, DH88, Jac90] </ref> are too restrictive. It is easy to see that in T PC the above program is well-typed. Furthermore, the original approach in [MO84] has no model-theoretic semantics. As a result, some confusion may arise if the typed logic programs are interpreted naively. <p> Hence, the well-typing 20 conditions in [MO84, DH88, Jac90] are too restrictive. It is easy to see that in T PC the above program is well-typed. Furthermore, the original approach in <ref> [MO84] </ref> has no model-theoretic semantics. As a result, some confusion may arise if the typed logic programs are interpreted naively. For instance, the program phint=; ! ;i p (X) is well-typed according to [MO84] because for any well-typed query, its top-down evaluation generates only well-typed subgoals. <p> Furthermore, the original approach in <ref> [MO84] </ref> has no model-theoretic semantics. As a result, some confusion may arise if the typed logic programs are interpreted naively. For instance, the program phint=; ! ;i p (X) is well-typed according to [MO84] because for any well-typed query, its top-down evaluation generates only well-typed subgoals. However, this program logically entails ill-typed atoms, such as p ("abc") (assuming "abc" occurs somewhere else in the program), which suggests that (7) is going to misbehave under bottom-up evaluation. <p> There is a standard procedure to convert sorted programs into the one-sorted form (see [End72, page 279]). The following theorem establishes a correspondence between the well-typed programs of <ref> [MO84] </ref> (in Reddy's reconstruction) and those of T PC. Theorem 9.1 Let P be a well-typed program with respect to a type assignment in the sense of Mycroft-O'Keefe-Reddy. Let P fl be the one-sorted version of P . <p> The logic naturally supports inclusion, parametric, and ad hoc polymorphism. Type declarations in T PC are more expressive than in <ref> [MO84, Xu89, Jac90] </ref> and other works, since multiple signatures and functional-style type-enforcement patterns, can be used to capture polymorphic types. 24 We combined the benefits of declaration-based and inference-based approaches, and showed how type inference under partial type declarations fits in our framework. <p> Most importantly, we gave precise model-theoretic meaning to the notion of type-correctness, independent of any specific type-checking or type-inference procedure. This enables us to accommodate many different type-checking and type-inference algorithms that suit in different situations. As an illustration, we showed how the formalisms of <ref> [MO84, Smo88, HT90, Mis84, XW88, Xu89] </ref> can be accounted for in our framework. Finally, we note that all results in this paper can be easily extended to typing HiLog [CKW89a, CKW89b]|a recently proposed higher-order logic programming language.
Reference: [MR85] <author> P. Mishra and U.S. Reddy. </author> <title> Declaration-free type checking. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 7-21, </pages> <year> 1985. </year>
Reference-contexts: Mishra [Mis84] was the first one to show that the idea of type inference that is widely used in functional languages is applicable to logic programs as well. This work was then followed by <ref> [MR85, KH85, Zob87, Azz88, Fru88, PR89] </ref>, where various inference-based approaches were studied. The idea of type inference is to let the compiler infer the types of predicates automatically, with little or no declarations supplied by the user.
Reference: [PR89] <author> C. Pyo and U.S. Reddy. </author> <title> Inference of polymorphic types for logic programs. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming, </booktitle> <pages> pages 1115-1132, </pages> <year> 1989. </year> <month> 26 </month>
Reference-contexts: Mishra [Mis84] was the first one to show that the idea of type inference that is widely used in functional languages is applicable to logic programs as well. This work was then followed by <ref> [MR85, KH85, Zob87, Azz88, Fru88, PR89] </ref>, where various inference-based approaches were studied. The idea of type inference is to let the compiler infer the types of predicates automatically, with little or no declarations supplied by the user. <p> The inferred type declarations are represented as regular trees and satisfy the well-typing principle according to which the inferred typing must cover all atoms that can be successfully derived from the program. This principle is widely accepted in the logic programming community, and several other researchers <ref> [Zob87, Azz88, PR89] </ref> further extended Mishra's work by proposing different type inference algorithms. In this subsection we explain how T PC captures the notion of Mishra's regular trees and show that his well-typing principle is consistent with the notion of type-correctness in T PC. <p> In this subsection we explain how T PC captures the notion of Mishra's regular trees and show that his well-typing principle is consistent with the notion of type-correctness in T PC. In particular, this means that the type-inference algorithms developed in <ref> [Mis84, Zob87, Azz88, PR89] </ref> can be used in T PC, provided that the type-base is restricted to regular trees. 21 Example 9.1 Consider the standard Prolog program for append: append (nil; K; K) append (cons (X; L); M; cons (X; N)) append (L; M; N ): The typing computed by Mishra's
Reference: [Prz88] <author> T.C. Przymusinski. </author> <title> On the declarative semantics of deductive databases and logic pro-grams. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: Since all our examples employ definite Horn clauses only, the reader can handily think that canonic models coincide with t min -minimal models defined in Section 5.1. Precise definitions of canonic models in T PC according to the prefect <ref> [Prz88] </ref>, well-founded [GRS88, Van89], or stable model semantics [GL88] can be given along the lines of the corresponding developments in PC and are beyond the scope of this paper.
Reference: [Red88] <author> U.S. Reddy. </author> <title> Notions of polymorphism for predicate logic programs. </title> <booktitle> In Intl. Conference on Logic Programming, pages (addendum, distributed at conference) 17-34. </booktitle> <publisher> MIT Press, </publisher> <month> August </month> <year> 1988. </year> <note> also to appear in J. Logic Programming. </note>
Reference-contexts: Section 5.2 (see after Example 5.5) shows that, in the presence of inclusion polymorphism, mode declarations alone are incapable of capturing certain subtleties of interaction between the types assigned to predicate arguments. TDs are also related to implicational types of <ref> [Red88] </ref>, which serve similar purpose. Informally, a signature such as phu; v; w=f1; 2g ! f3g; f3g ! f1gi states that for every data atom p (a; b; c), if a and b are of the types u and v, respectively, then c must be of the type w.
Reference: [Red91] <author> U. Reddy. </author> <title> A perspective on types for logic programs. </title> <editor> In F. Pfenning, editor, </editor> <booktitle> Types in Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year> <note> to appear. </note>
Reference-contexts: However, this program logically entails ill-typed atoms, such as p ("abc") (assuming "abc" occurs somewhere else in the program), which suggests that (7) is going to misbehave under bottom-up evaluation. The recent work by Reddy <ref> [Red91] </ref> rectifies the problem by reconstructing Mycroft-O'Keefe's approach on the basis of the many-sorted algebra [GTW78]. In particular, predicate p in (7) would have the sort int and so will the variable X.
Reference: [Smo88] <author> G. Smolka. </author> <title> Logic programming with polymorphically order-sorted types. </title> <type> Technical Report ILOG Report 55, </type> <institution> IBM Deutchland GmbH, </institution> <year> 1988. </year>
Reference-contexts: Unfortunately, this approach does not work well in the presence of inclusion polymorphism, as discussed in Section 9.3. In this paper, we propose a framework that unifies many of the above works. Section 9 presents a case-study of several representative approaches <ref> [MO84, Smo88, HT90, Mis84, XW88, XW90] </ref>. Our results shed new light on these works, and allow to compare them in a single framework. <p> It should be noted that, despite its name, T PC is not a typed language. Instead, the type of a predicate is declared via logical formulas, called signatures, and types are enforced by semantic, model-theoretic means (as opposed to the syntactic means, such as many-sorted algebras <ref> [Smo88, HT90] </ref>). Thus, unlike other approaches, type declarations in T PC are formulae in the object language of the logic, rather than syntactic expressions in a meta-language. <p> Syntactic approaches, usually found in the works on type checking (e.g., <ref> [MO84, DH88, Smo88, Fru89, YFS90, Jac90, HT90] </ref>), see the notion of type-correctness as a syntactic concept. Their notion of well-typing is defined by a set of "well-formedness rules" that are imposed directly on the syntactic structure of logic programs. <p> Similarly, SLDNF-resolution can be defined and the corresponding classical results carry over to T PC programs. 9 Case Study 9.1 Syntactic Approaches to Type Checking Majority of the approaches to type checking in logic programming (e.g., <ref> [MO84, DH88, Smo88, Fru89, YFS90, Jac90, HT90] </ref>) can be classified as syntactic. The notion of type-correctness is established via a set of well-typing rules, defined inductively on the syntactic structure of formulae. Consider first Mycroft-O'Keefe's type checking system [MO84]. <p> Mycroft-O'Keefe's type system can be extended to support inclusion polymorphism using the idea of parametric order-sorted logic. Such extensions are described in <ref> [Smo88] </ref> and [HT90]. Results similar to Theorem 9.1 also hold about the relationship of these extensions to T PC. 9.2 Mishra's Type Inference System Mishra [Mis84] proposed an inference-based type system for Prolog, based on the idea of automatic type inference in ML. <p> Most importantly, we gave precise model-theoretic meaning to the notion of type-correctness, independent of any specific type-checking or type-inference procedure. This enables us to accommodate many different type-checking and type-inference algorithms that suit in different situations. As an illustration, we showed how the formalisms of <ref> [MO84, Smo88, HT90, Mis84, XW88, Xu89] </ref> can be accounted for in our framework. Finally, we note that all results in this paper can be easily extended to typing HiLog [CKW89a, CKW89b]|a recently proposed higher-order logic programming language.
Reference: [Ull88] <author> J.F. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> Volume 1. </volume> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: To account for the derivations of this kind, we need to characterize the logical implication among sets of TDs. The following inference rules are sound and complete for TDs. Incidentally, these rules coincide with the well-known Armstrong's axioms for functional dependencies <ref> [Ull88] </ref>. Let be a set of TDs for n-ary predicates, and let ! n = f1; :::; ng. Reflexivity : If fi ff ! n , then ` T D ff ! fi. <p> Proposition 4.1 The inference rules for TDs are sound and complete, that is, j= T D fl if and only if ` T D fl. Proof: Similar to the corresponding proof for functional dependencies <ref> [Ull88] </ref>. 2 It follows from the above rules for TDs that ; ! ;, ! ! ; and, in fact, any TD ff ! fi, where fi ff, is a tautology.
Reference: [Van89] <author> A. Van Gelder. </author> <title> The alternating fixpoint of logic programs with negation. </title> <booktitle> In Proceedings of the ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-10, </pages> <year> 1989. </year>
Reference-contexts: With negative literals in rule-bodies, there is a number of different competing semantics <ref> [GRS88, GL88, Van89, AV88, KP88] </ref>, each of which can easily be adapted to T PC. All of these semantics have in common that the logical entailment is defined with respect to some subset of models, called canonic models (which may be different for different proposals). <p> Since all our examples employ definite Horn clauses only, the reader can handily think that canonic models coincide with t min -minimal models defined in Section 5.1. Precise definitions of canonic models in T PC according to the prefect [Prz88], well-founded <ref> [GRS88, Van89] </ref>, or stable model semantics [GL88] can be given along the lines of the corresponding developments in PC and are beyond the scope of this paper.
Reference: [War77] <author> D.H.D. Warren. </author> <title> Implementing Prolog Compiling predicate logic programs. </title> <type> Technical Report 39 and 40, </type> <institution> Dept. of Artificial Intelligence, University of Edinburgh, </institution> <year> 1977. </year>
Reference-contexts: We shall see shortly that TDs behave similarly to functional dependencies of the database theory (although, by themselves, they do not enforce any functional dependency on predicates). Type dependencies generalize modes in Prolog literature <ref> [War77, DW86, DH88] </ref>. Intuitively, TDs represent the flow of control between predicate arguments. Section 5.2 (see after Example 5.5) shows that, in the presence of inclusion polymorphism, mode declarations alone are incapable of capturing certain subtleties of interaction between the types assigned to predicate arguments.
Reference: [Xu89] <author> J. Xu. </author> <title> A Theory of Types and Type Inference in Logic Programming Languages. </title> <type> PhD thesis, </type> <institution> SUNY at Stony Brook, </institution> <year> 1989. </year>
Reference-contexts: Furthermore, correctness of type checking or inference algorithms cannot be independently verified and thus many of these studies bear a significant ad hoc component. In an attempt to close the semantic gap between programs and types, Xu and Warren <ref> [XW88, Xu89, XW90] </ref> developed a model theory for type-inference based on the notion of partial interpretations. They convincingly argued that in practice both paradigms, declaration-based and inference-based, are useful. They proposed an algorithm that takes into account user-supplied type declarations and then infers types for the rest of the predicates. <p> Likewise, the semantics of inferred types is independent of the inference algorithm. Therefore, various such algorithms can be formally studied and compared in our framework. Last but not least, as in <ref> [Xu89, XW90] </ref>, type inference under partial type declarations has a natural semantics in T PC. 2 Typed Predicate Calculus In this section, we introduce our new logic, Typed Predicate Calculus, that extends classical first-order predicate calculus both syntactically and semantically. 2.1 Syntax The alphabet of a language L of T PC <p> Their notion of well-typing is defined by a set of "well-formedness rules" that are imposed directly on the syntactic structure of logic programs. In contrast, semantic approaches, where T PC and most of the works on type inference (e.g., <ref> [Mis84, YS87, Xu89] </ref>) belong, define the concept of type-correctness in model-theoretic or set-theoretic terms. For instance, in T PC, a program is regarded as well-typed if and only if the intended model of the program satisfies the well-typing conditions of Section 2.2. <p> In extreme cases, the system can assume all TDs to be trivial (e.g., ; ! ;, ! ! ;) or, alternatively, the strongest ones (i.e., ; ! !). For instance, Mishra [Mis84] and Xu and Warren <ref> [XW88, Xu89, XW90] </ref> implicitly assume all type dependencies to be trivial. User-supplied TDs may improve the accuracy of type inference algorithms, for in case of trivial TDs too many signatures may be inferred, leading to information glut. <p> For instance, for append , the typing appendhlist (all); list (all); list (all)=; ! ;i is stronger than (9). 9.3 Xu-Warren's Type Inference <ref> [XW88, Xu89] </ref> In [XW88], the typing of a program is defined via typed interpretations. Given a type base , a typed interpretation A under is a semantic structure where terms are interpreted by the types of , and predicates are interpreted as relations over . <p> The logic naturally supports inclusion, parametric, and ad hoc polymorphism. Type declarations in T PC are more expressive than in <ref> [MO84, Xu89, Jac90] </ref> and other works, since multiple signatures and functional-style type-enforcement patterns, can be used to capture polymorphic types. 24 We combined the benefits of declaration-based and inference-based approaches, and showed how type inference under partial type declarations fits in our framework. <p> Most importantly, we gave precise model-theoretic meaning to the notion of type-correctness, independent of any specific type-checking or type-inference procedure. This enables us to accommodate many different type-checking and type-inference algorithms that suit in different situations. As an illustration, we showed how the formalisms of <ref> [MO84, Smo88, HT90, Mis84, XW88, Xu89] </ref> can be accounted for in our framework. Finally, we note that all results in this paper can be easily extended to typing HiLog [CKW89a, CKW89b]|a recently proposed higher-order logic programming language.
Reference: [XW88] <author> J. Xu and D.S. Warren. </author> <title> A type inference system for Prolog. </title> <booktitle> In Intl. Conference on Logic Programming, </booktitle> <pages> pages 604-619, </pages> <year> 1988. </year>
Reference-contexts: Furthermore, correctness of type checking or inference algorithms cannot be independently verified and thus many of these studies bear a significant ad hoc component. In an attempt to close the semantic gap between programs and types, Xu and Warren <ref> [XW88, Xu89, XW90] </ref> developed a model theory for type-inference based on the notion of partial interpretations. They convincingly argued that in practice both paradigms, declaration-based and inference-based, are useful. They proposed an algorithm that takes into account user-supplied type declarations and then infers types for the rest of the predicates. <p> Unfortunately, this approach does not work well in the presence of inclusion polymorphism, as discussed in Section 9.3. In this paper, we propose a framework that unifies many of the above works. Section 9 presents a case-study of several representative approaches <ref> [MO84, Smo88, HT90, Mis84, XW88, XW90] </ref>. Our results shed new light on these works, and allow to compare them in a single framework. <p> Polymorphic types are treated as first-class citizens and are represented as ordinary 1 terms. 1 The relationship among types and their instances is defined by the user, via logic formulae that correspond to type declarations of <ref> [MO84, YS87, XW88, Jac90] </ref>, but are more general. It should be noted that, despite its name, T PC is not a typed language. <p> In extreme cases, the system can assume all TDs to be trivial (e.g., ; ! ;, ! ! ;) or, alternatively, the strongest ones (i.e., ; ! !). For instance, Mishra [Mis84] and Xu and Warren <ref> [XW88, Xu89, XW90] </ref> implicitly assume all type dependencies to be trivial. User-supplied TDs may improve the accuracy of type inference algorithms, for in case of trivial TDs too many signatures may be inferred, leading to information glut. <p> Return V as the inferred type declaration. Unfortunately, this algorithm may not stop if W is infinite. However, we can approximate W using a particular group of type bases with finite domains. For instance, for the type bases n in <ref> [XW88] </ref> that contain terms up to a certain depth, the termination of the algorithm is guaranteed. We will discuss the type bases n and the type inference algorithm of [XW88] in Section 9.3. <p> For instance, for the type bases n in <ref> [XW88] </ref> that contain terms up to a certain depth, the termination of the algorithm is guaranteed. We will discuss the type bases n and the type inference algorithm of [XW88] in Section 9.3. The above type inference can be combined with partial type declarations, which works like this: The user declares signatures for some of the predicates (possibly none, if "pure" type inference is desired). <p> For instance, for append , the typing appendhlist (all); list (all); list (all)=; ! ;i is stronger than (9). 9.3 Xu-Warren's Type Inference <ref> [XW88, Xu89] </ref> In [XW88], the typing of a program is defined via typed interpretations. Given a type base , a typed interpretation A under is a semantic structure where terms are interpreted by the types of , and predicates are interpreted as relations over . <p> For instance, for append , the typing appendhlist (all); list (all); list (all)=; ! ;i is stronger than (9). 9.3 Xu-Warren's Type Inference [XW88, Xu89] In <ref> [XW88] </ref>, the typing of a program is defined via typed interpretations. Given a type base , a typed interpretation A under is a semantic structure where terms are interpreted by the types of , and predicates are interpreted as relations over . <p> Given a Horn clause program P , the typing of P is defined as the minimum typed model of P under . The type-inference algorithm of <ref> [XW88] </ref> correctly (relatively to their semantics) finds the minimum typed model of any Horn clause program. Unfortunately, no such algorithm can terminate in all cases. As a practical solution, Xu and Warren consider a particular group of type bases, n , for which their type inference algorithm always terminates. <p> It is shown in <ref> [XW88] </ref> that their type inference algorithm terminates for every type base n . As an example, consider the following program P that subtracts 1 from its first argument: sub1 (succ (zero); zero) sub1 (succ (X); succ (Y )) sub1 (X; Y ): Let the type base be 1 . <p> As an example, consider the following program P that subtracts 1 from its first argument: sub1 (succ (zero); zero) sub1 (succ (X); succ (Y )) sub1 (X; Y ): Let the type base be 1 . The type declaration inferred by the algorithm in <ref> [XW88] </ref> (represented in the T PC-notation) is: sub1hsucc (zero); zero=; ! ;i sub1hsucc (succ (all)); succ (succ (all))=; ! ;i; where "all" is the class of all things defined in (1). For each truncated term t of [XW88], its T PC counterpart is obtained from t by replacing each occurrence of <p> The type declaration inferred by the algorithm in <ref> [XW88] </ref> (represented in the T PC-notation) is: sub1hsucc (zero); zero=; ! ;i sub1hsucc (succ (all)); succ (succ (all))=; ! ;i; where "all" is the class of all things defined in (1). For each truncated term t of [XW88], its T PC counterpart is obtained from t by replacing each occurrence of "fl" by all. <p> The type-dependency declaration corresponding to the formalism of <ref> [XW88] </ref> is the simplest possible one: every signature is tagged with a trivial TD. Theorem 9.3 Let P be a program and Type be the type declaration for P generated by Xu-Warren's type inference algorithm. Let Isa be the class-hierarchy declaration obtained from n as explained above. <p> Let Isa be the class-hierarchy declaration obtained from n as explained above. Then Isa [ Type [ P is a well-typed T PC-program. In [XW90], Xu and Warren extended the framework of <ref> [XW88] </ref> and introduced type declarations, making it possible to do type checking together with type inference, as in Section 6. <p> This contradicts the declaration of p as a set of men (assuming mary is not a man). It is not clear whether an adequate solution to the problem of type declarations can be found within the framework of partial interpretations developed in <ref> [XW88, XW90] </ref>. 10 Conclusion We presented a new logic, typed predicate calculus (T PC), that provides a natural framework for representing logic programs with type declaration and for reasoning about type-correctness of these programs. The logic naturally supports inclusion, parametric, and ad hoc polymorphism. <p> Most importantly, we gave precise model-theoretic meaning to the notion of type-correctness, independent of any specific type-checking or type-inference procedure. This enables us to accommodate many different type-checking and type-inference algorithms that suit in different situations. As an illustration, we showed how the formalisms of <ref> [MO84, Smo88, HT90, Mis84, XW88, Xu89] </ref> can be accounted for in our framework. Finally, we note that all results in this paper can be easily extended to typing HiLog [CKW89a, CKW89b]|a recently proposed higher-order logic programming language.
Reference: [XW90] <author> J. Xu and D.S. Warren. </author> <title> Semantics of types in logic programming. </title> <type> manuscript, </type> <year> 1990. </year>
Reference-contexts: Furthermore, correctness of type checking or inference algorithms cannot be independently verified and thus many of these studies bear a significant ad hoc component. In an attempt to close the semantic gap between programs and types, Xu and Warren <ref> [XW88, Xu89, XW90] </ref> developed a model theory for type-inference based on the notion of partial interpretations. They convincingly argued that in practice both paradigms, declaration-based and inference-based, are useful. They proposed an algorithm that takes into account user-supplied type declarations and then infers types for the rest of the predicates. <p> Unfortunately, this approach does not work well in the presence of inclusion polymorphism, as discussed in Section 9.3. In this paper, we propose a framework that unifies many of the above works. Section 9 presents a case-study of several representative approaches <ref> [MO84, Smo88, HT90, Mis84, XW88, XW90] </ref>. Our results shed new light on these works, and allow to compare them in a single framework. <p> Likewise, the semantics of inferred types is independent of the inference algorithm. Therefore, various such algorithms can be formally studied and compared in our framework. Last but not least, as in <ref> [Xu89, XW90] </ref>, type inference under partial type declarations has a natural semantics in T PC. 2 Typed Predicate Calculus In this section, we introduce our new logic, Typed Predicate Calculus, that extends classical first-order predicate calculus both syntactically and semantically. 2.1 Syntax The alphabet of a language L of T PC <p> In extreme cases, the system can assume all TDs to be trivial (e.g., ; ! ;, ! ! ;) or, alternatively, the strongest ones (i.e., ; ! !). For instance, Mishra [Mis84] and Xu and Warren <ref> [XW88, Xu89, XW90] </ref> implicitly assume all type dependencies to be trivial. User-supplied TDs may improve the accuracy of type inference algorithms, for in case of trivial TDs too many signatures may be inferred, leading to information glut. <p> Theorem 9.3 Let P be a program and Type be the type declaration for P generated by Xu-Warren's type inference algorithm. Let Isa be the class-hierarchy declaration obtained from n as explained above. Then Isa [ Type [ P is a well-typed T PC-program. In <ref> [XW90] </ref>, Xu and Warren extended the framework of [XW88] and introduced type declarations, making it possible to do type checking together with type inference, as in Section 6. <p> This contradicts the declaration of p as a set of men (assuming mary is not a man). It is not clear whether an adequate solution to the problem of type declarations can be found within the framework of partial interpretations developed in <ref> [XW88, XW90] </ref>. 10 Conclusion We presented a new logic, typed predicate calculus (T PC), that provides a natural framework for representing logic programs with type declaration and for reasoning about type-correctness of these programs. The logic naturally supports inclusion, parametric, and ad hoc polymorphism.
Reference: [YFS90] <author> E. Yardeni, T. Fruehwirth, and E. Shapiro. </author> <title> Polymorphically typed logic programs. </title> <type> manuscript, </type> <year> 1990. </year>
Reference-contexts: Mycroft and O'Keefe [MO84] extended [Bru82] to support parametric polymorphism. Recently, Dietrich and Hagl [DH88] and Jacobs [Jac90] further extended [MO84] to handle inclusion polymorphism. Another approach to polymorphic type checking, based on HiLog [CKW89a, CKW89b], is discussed in <ref> [Fru89, YFS90] </ref>. Other researchers argued that declaration-based typing may severely impact the simplicity and flexibility of logic programming, since it requires every predicate symbol to be annotated with a type. <p> Syntactic approaches, usually found in the works on type checking (e.g., <ref> [MO84, DH88, Smo88, Fru89, YFS90, Jac90, HT90] </ref>), see the notion of type-correctness as a syntactic concept. Their notion of well-typing is defined by a set of "well-formedness rules" that are imposed directly on the syntactic structure of logic programs. <p> Similarly, SLDNF-resolution can be defined and the corresponding classical results carry over to T PC programs. 9 Case Study 9.1 Syntactic Approaches to Type Checking Majority of the approaches to type checking in logic programming (e.g., <ref> [MO84, DH88, Smo88, Fru89, YFS90, Jac90, HT90] </ref>) can be classified as syntactic. The notion of type-correctness is established via a set of well-typing rules, defined inductively on the syntactic structure of formulae. Consider first Mycroft-O'Keefe's type checking system [MO84].
Reference: [YS87] <author> E. Yardeni and E. Shapiro. </author> <title> A type system for logic programs. </title> <editor> In E. Shapiro, editor, </editor> <booktitle> Concurrent Prolog, </booktitle> <volume> volume 2. </volume> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Polymorphic types are treated as first-class citizens and are represented as ordinary 1 terms. 1 The relationship among types and their instances is defined by the user, via logic formulae that correspond to type declarations of <ref> [MO84, YS87, XW88, Jac90] </ref>, but are more general. It should be noted that, despite its name, T PC is not a typed language. <p> Their notion of well-typing is defined by a set of "well-formedness rules" that are imposed directly on the syntactic structure of logic programs. In contrast, semantic approaches, where T PC and most of the works on type inference (e.g., <ref> [Mis84, YS87, Xu89] </ref>) belong, define the concept of type-correctness in model-theoretic or set-theoretic terms. For instance, in T PC, a program is regarded as well-typed if and only if the intended model of the program satisfies the well-typing conditions of Section 2.2. <p> The importance of capturing type inconsistency in rule bodies lies in the fact that this leads to the notion of useless clauses <ref> [YS87] </ref>, i.e., clauses that do not affect the meaning of a program. Let the program P be: rhstring= i r (X) p (X) & q (X): phstring= i qhint= i (4) Suppose int and string have no common subtypes and elements.
Reference: [Zob87] <author> J. Zobel. </author> <title> Derivation of polymorphic types for Prolog programs. </title> <booktitle> In Proceedings of the Fourth International Logic Programming Conference, </booktitle> <address> Australia, </address> <year> 1987. </year> <month> 27 </month>
Reference-contexts: Mishra [Mis84] was the first one to show that the idea of type inference that is widely used in functional languages is applicable to logic programs as well. This work was then followed by <ref> [MR85, KH85, Zob87, Azz88, Fru88, PR89] </ref>, where various inference-based approaches were studied. The idea of type inference is to let the compiler infer the types of predicates automatically, with little or no declarations supplied by the user. <p> The inferred type declarations are represented as regular trees and satisfy the well-typing principle according to which the inferred typing must cover all atoms that can be successfully derived from the program. This principle is widely accepted in the logic programming community, and several other researchers <ref> [Zob87, Azz88, PR89] </ref> further extended Mishra's work by proposing different type inference algorithms. In this subsection we explain how T PC captures the notion of Mishra's regular trees and show that his well-typing principle is consistent with the notion of type-correctness in T PC. <p> In this subsection we explain how T PC captures the notion of Mishra's regular trees and show that his well-typing principle is consistent with the notion of type-correctness in T PC. In particular, this means that the type-inference algorithms developed in <ref> [Mis84, Zob87, Azz88, PR89] </ref> can be used in T PC, provided that the type-base is restricted to regular trees. 21 Example 9.1 Consider the standard Prolog program for append: append (nil; K; K) append (cons (X; L); M; cons (X; N)) append (L; M; N ): The typing computed by Mishra's
References-found: 40

