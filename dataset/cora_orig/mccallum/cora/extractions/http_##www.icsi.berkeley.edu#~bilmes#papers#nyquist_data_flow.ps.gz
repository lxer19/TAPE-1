URL: http://www.icsi.berkeley.edu/~bilmes/papers/nyquist_data_flow.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/~bilmes/papers/
Root-URL: http://www.icsi.berkeley.edu
Title: Nyquist and Data-Flow: An Overview and Comparison  
Author: Jeff A. Bilmes 
Date: December 10, 1993  
Note: Final Paper for Advanced Topics in Signal Processing EE290T  
Address: U.C. Berkeley  
Affiliation: Computer Science Division Department of Electrical Engineering and Computer Science  
Abstract: I describe the sound synthesis and musical event language Nyquist and how it relates to data-flow. Three styles of data-flow are discussed. Then, Nyquist features are considered individually in relation to each of the three styles. Finally, we summarize the above results and discuss how the notion of behavioral abstraction in Nyquist naturally leads us to a concept that perhaps could be called object-oriented data-flow.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> David P. Anderson and Jeff A. Bilmes. </author> <title> Concurrent real-time music in C++. </title> <booktitle> In USENIX C++ Conference Proceedings, </booktitle> <address> Washington D.C., </address> <year> 1991. </year>
Reference-contexts: Previous music systems <ref> [1] </ref> have utilized both a real-time event scheduler and a select mechanism to perform this sort of scheduling with reasonable success. 4.2 sim The sim function simultaneously performs the note expressions that are given as arguments.
Reference: [2] <author> David Michael Betz. XLISP: </author> <title> An Object-Oriented Lisp: </title> <note> Version 2.0, </note> <month> February </month> <year> 1988. </year>
Reference-contexts: Nyquist is a language primarily used for musical signal generation. Its main goal is to provide an easy and flexible way for musicians to generate and compose music using a computer. Nyquist is based on a dialect of lisp called XLISP <ref> [2] </ref>. Unlike many other music sequencers or sound generation languages, Nyquist provides methods that make it easy for the composer to define algorithms for generating music. In most music languages, the score is the data, usually in the form of a note list. <p> Nyquist is a language that operates in much the same way but on musical notes represented by digital signals. Canon and Nyquist are based on XLISP <ref> [2] </ref>, so code resembles lisp syntax. For example, (note c4) represents middle C. note is a lisp function that constructs note objects. There are several optional parameters for constructing notes.
Reference: [3] <author> Jeff A. Bilmes. </author> <title> Timing is of the essence: Perceptual and computational techniques for representing, learning, and reproducing expressive timing in percussive rhythm. </title> <type> Master's thesis, </type> <institution> The MIT Media Lab, Massachusetts Institute of Technology, </institution> <year> 1993. </year>
Reference-contexts: The above describes implementation techniques for time-varying transformations that themselves do not affect the timing of the performance. Another form of time-varying transformation, however, is performance variation, a crucial topic in modern computer music systems. There are basically two types of performance variation, tempo warping [14] and deviations <ref> [3] </ref>. Tempo warping is currently implemented in Nyquist using the warp function. The following is an example: (warp (warp-env (0 1) (1 1) (3 2) (4 1)) (seq n0 n1 n2 n3 n4)) This specifies a mapping from intervals specified in score time to intervals in performance real-time. <p> Here, we schedule the events to occur at the times given by the above integral. Another important music expression representation is time deviations <ref> [3] </ref>. A deviation is a small time-shift applied to a musical event. This is different than tempo variation, however, because different performers in an ensemble or even the same performer might have different deviations for different but "simultaneous" voices.
Reference: [4] <author> Joseph T. Buck and Edward A. Lee. </author> <title> Scheduling dynamic dataflow graphs with bounded memory using the token flow model. </title> <type> Technical report, </type> <institution> Dept. of EECS, University of California, Berkeley, </institution> <year> 1993. </year>
Reference-contexts: With DFR, there must be a global synchronized clock that all nodes use to determine the current time. DFU is probably most flexible scheme in terms of scheduling. It does not have any real-time demands and is closest to what most people consider dynamic data-flow <ref> [4] </ref>. It is also somewhat akin to the way in which Nyquist is currently implemented (everything is computed ahead of time, events are sorted, and then a sound file is generated). DFO is in some ways similar to Lustre [13] and Signal [12].
Reference: [5] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: In a naive implementation, emitting is an O (1) operation where reading is an O (N ) operation (or O (lg (N )) if using a heap implementation <ref> [5] </ref>). More sophisticated implementations could use a bit-bucket idea and reduce both operating costs to O (1). The at function shifts in time the events provided as arguments. For example: (at N (note c4)) will perform a middle C shifted by N time units.
Reference: [6] <author> Roger B. Dannenberg. </author> <title> The canon score language. </title> <journal> CMJ, </journal> <volume> 13(1), </volume> <year> 1989. </year>
Reference-contexts: 1 Introduction In this paper, I discuss the sound synthesis language Nyquist <ref> [8, 11, 10, 6, 7, 9] </ref>. Nyquist is a language primarily used for musical signal generation. Its main goal is to provide an easy and flexible way for musicians to generate and compose music using a computer. Nyquist is based on a dialect of lisp called XLISP [2]. <p> Nevertheless, as we will see, most of Nyquist's features can be represented in a data-flow style. Nyquist is a descendent of the earlier music processing languages Canon <ref> [6] </ref> and Fugue [7]. Nyquist is different from Fugue only in implementation: i.e., they have the same language features and semantics. Therefore, their differences will not be discussed. Canon is primarily an event based language and Nyquist provides sound synthesis abilities.
Reference: [7] <author> Roger B. Dannenberg. </author> <title> A Functional Language for Sound Synthesis with Behavioral Abstraction and Lazy Evaluation, </title> <address> pages 25-40. </address> <publisher> IEEE Computer Society Press, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction In this paper, I discuss the sound synthesis language Nyquist <ref> [8, 11, 10, 6, 7, 9] </ref>. Nyquist is a language primarily used for musical signal generation. Its main goal is to provide an easy and flexible way for musicians to generate and compose music using a computer. Nyquist is based on a dialect of lisp called XLISP [2]. <p> Nevertheless, as we will see, most of Nyquist's features can be represented in a data-flow style. Nyquist is a descendent of the earlier music processing languages Canon [6] and Fugue <ref> [7] </ref>. Nyquist is different from Fugue only in implementation: i.e., they have the same language features and semantics. Therefore, their differences will not be discussed. Canon is primarily an event based language and Nyquist provides sound synthesis abilities. <p> If, however, the DFR system is operating slightly ahead of real-time (at least as ahead as the greatest transformed deviation in the program), then we will be able to schedule the event. 5 Sound Signal Generation Basics Nyquist is very similar to the earlier language Fugue <ref> [7] </ref>, except that the implementation of Nyquist is more space efficient. In Fugue, sound memory allocation was done all at once, whereas in Nyquist, it is done in a lazy manner: "blocks" of sound are allocated and computed on a by-need basis.
Reference: [8] <author> Roger B. Dannenberg. </author> <title> The implementation of nyquist, a sound synthesis language. </title> <booktitle> In Proc. of ICMC, </booktitle> <year> 1993. </year>
Reference-contexts: 1 Introduction In this paper, I discuss the sound synthesis language Nyquist <ref> [8, 11, 10, 6, 7, 9] </ref>. Nyquist is a language primarily used for musical signal generation. Its main goal is to provide an easy and flexible way for musicians to generate and compose music using a computer. Nyquist is based on a dialect of lisp called XLISP [2].
Reference: [9] <author> Roger B. Dannenberg. </author> <title> Nyquist Reference Manual: </title> <note> Version 1.0, </note> <month> October </month> <year> 1993. </year>
Reference-contexts: 1 Introduction In this paper, I discuss the sound synthesis language Nyquist <ref> [8, 11, 10, 6, 7, 9] </ref>. Nyquist is a language primarily used for musical signal generation. Its main goal is to provide an easy and flexible way for musicians to generate and compose music using a computer. Nyquist is based on a dialect of lisp called XLISP [2]. <p> Currently, this does not work in Nyquist since an at command may not have a negative value <ref> [9] </ref>. In the DFU case, we may add the appropriate deviation to each token. In the DFO case, we also may add a deviation to current token. <p> The resulting signals may further be manipulated by filtering, multiplying by amplitude or temporal envelopes, etc. The full set of operations may be found in <ref> [9] </ref>. Nyquist also supports multiple sample rates.
Reference: [10] <author> Roger B. Dannenberg and Clifford W. Mercer. </author> <title> Real-time software synthesis on superscalar architectures. </title> <booktitle> In Proc. of ICMC, </booktitle> <year> 1992. </year>
Reference-contexts: 1 Introduction In this paper, I discuss the sound synthesis language Nyquist <ref> [8, 11, 10, 6, 7, 9] </ref>. Nyquist is a language primarily used for musical signal generation. Its main goal is to provide an easy and flexible way for musicians to generate and compose music using a computer. Nyquist is based on a dialect of lisp called XLISP [2].
Reference: [11] <author> Roger B. Dannenberg, Dean Rubine, and Tom Neuendorffer. </author> <title> The resource-instance model of music representation. </title> <booktitle> In Proc. of ICMC, </booktitle> <year> 1991. </year>
Reference-contexts: 1 Introduction In this paper, I discuss the sound synthesis language Nyquist <ref> [8, 11, 10, 6, 7, 9] </ref>. Nyquist is a language primarily used for musical signal generation. Its main goal is to provide an easy and flexible way for musicians to generate and compose music using a computer. Nyquist is based on a dialect of lisp called XLISP [2].
Reference: [12] <author> Paul Le Guernic, Thierry Gautier, Michel Le Borgne, and Claude Le Maire. </author> <title> Programming real-time applications with SIGNAL. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9), </volume> <month> September </month> <year> 1991. </year>
Reference-contexts: It is also somewhat akin to the way in which Nyquist is currently implemented (everything is computed ahead of time, events are sorted, and then a sound file is generated). DFO is in some ways similar to Lustre [13] and Signal <ref> [12] </ref>. Similar to those languages, there is an ordering on the tokens that flow through an arc. Unlike those languages, however, there is no notion of a global order, i.e., two tokens on different arcs do not have an ordering relationship between them.
Reference: [13] <author> Nicholas Halbwachs, Paul Caspi, Pascal Raymond, and Daniel Pilaud. </author> <title> The synthronous data flow programming language LUSTRE. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9), </volume> <month> September </month> <year> 1991. </year>
Reference-contexts: It is also somewhat akin to the way in which Nyquist is currently implemented (everything is computed ahead of time, events are sorted, and then a sound file is generated). DFO is in some ways similar to Lustre <ref> [13] </ref> and Signal [12]. Similar to those languages, there is an ordering on the tokens that flow through an arc. Unlike those languages, however, there is no notion of a global order, i.e., two tokens on different arcs do not have an ordering relationship between them.
Reference: [14] <author> David Jaffe. </author> <title> Ensemble timing in computer music. </title> <journal> CMJ, </journal> <volume> 9(4) </volume> <pages> 38-48, </pages> <year> 1985. </year> <month> 15 </month>
Reference-contexts: The above describes implementation techniques for time-varying transformations that themselves do not affect the timing of the performance. Another form of time-varying transformation, however, is performance variation, a crucial topic in modern computer music systems. There are basically two types of performance variation, tempo warping <ref> [14] </ref> and deviations [3]. Tempo warping is currently implemented in Nyquist using the warp function.
References-found: 14

