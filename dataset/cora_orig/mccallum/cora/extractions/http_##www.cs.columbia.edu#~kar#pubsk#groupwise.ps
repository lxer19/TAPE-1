URL: http://www.cs.columbia.edu/~kar/pubsk/groupwise.ps
Refering-URL: http://www.cs.columbia.edu/~kar/pubsk/pubsk.html
Root-URL: http://www.cs.columbia.edu
Email: damianos,kar@cs.columbia.edu  
Title: Groupwise Processing of Relational Queries  
Author: Damianos Chatziantoniou Kenneth A. Ross 
Note: Proceedings of the 23rd VLDB Conference Athens, Greece, 1997  
Affiliation: Department of Computer Science, Columbia University  
Abstract: In this paper, we define and examine a particular class of queries called group queries. Group queries are natural queries in many decision-support applications. The main characteristic of a group query is that it can be executed in a group-by-group fashion. In other words, the underlying relation(s) can be partitioned (based on some set of attributes) into disjoint groups, and each group can be processed separately. We give a syntactic criterion to identify these queries and prove its sufficiency. We also prove the strong result that every group query has an equivalent formulation that satisfies our syntactic criterion. We describe a general evaluation technique for group queries, and demonstrate how an optimizer can determine this plan. We then consider more complex queries whose components are group queries with potentially different partitioning attributes. We give two methods to identify group query components within such a query. We also give some performance results for group queries expressed in standard SQL, comparing a commercial database system with our optimized plan on top of the same commercial system. These results indicate that there are significant potential performance improvements. fl This research was supported by a grant from the AT&T Foundation, by a David and Lucile Packard Foundation Fellowship in Science and Engineering, by a Sloan Foundation Fellowship, by NSF CISE grant CDA-9625374, and by an NSF Young Investigator award. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the VLDB copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Very Large Data Base Endowment. To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment. 
Abstract-found: 1
Intro-found: 1
Reference: [AGS97] <author> Rakesh Agrawal, Ashish Gupta, and Sunita Sarawagi. </author> <title> Modeling multidimensional databases. </title> <booktitle> In IEEE International Conf. on Data Engineering, </booktitle> <year> 1997. </year>
Reference-contexts: This idea is implicit in papers that model multi-dimensional databases <ref> [LW96, AGS97] </ref>. In our framework this characteristic results in a query graph with several, possibly overlapping, component group queries. Having a complex decision support query, it is important to identify its group query components for a number of reasons. Firstly, each component can be optimized locally. <p> Our techniques apply to all relational queries, including those expressed in a special syntax. Decision support. Very recently, a number of papers appeared on data models for decision support queries <ref> [AGS97, LW96] </ref>. In these papers databases are treated as multidimensional constructs and operators such as push (similar to grouping with aggregation) and join are proposed.
Reference: [Cha97] <author> Damianos Chatziantoniou. </author> <title> Optimization of Complex Aggregate Queries in Relational Databases. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Columbia University, </institution> <year> 1997. </year>
Reference-contexts: We join V1 and V2 in order to get the result in single tuples. The actual SQL formulation is omitted due to lack of space and appears in <ref> [Cha97] </ref>. Once again, FYI LOG can be partitioned on id attribute and a simpler query can be posed separately on each partition. We shall discuss Query Q4 in Section 2.4. 2 Theoretical Framework In this section, we introduce our terminology and define what we mean by a group query. <p> Note that we do not allow constant relations in queries, nor do we allow attribute renaming. (In <ref> [Cha97] </ref> we describe the extensions needed to handle the renaming operator.) Definition 2.1: (Query Graph) Suppose that we are given a query Q. The nodes of the query graph for Q are the relational operations (as defined above) used in Q and its subviews. <p> The following theorem demonstrates the sufficiency of Criterion 2.1. Theorem 2.1: Every query graph that satisfies Criterion 2.1 defines a group query. Proof : See <ref> [Cha97] </ref> where a more general result is proved. The proof of Theorem 2.1 is constructive: it shows how to construct a Q 0 that operates on partitions of R given Q. Essentially, Q 0 is Q with join nodes modified by removing the equality conditions between partitioning attributes. <p> Theorem 2.2: For every group query Q there exists a query Q fl such that (i) Q = Q fl , and (ii) The query graph of Q fl satisfies Criterion 2.1. Proof : This is a special case of a more general result shown in <ref> [Cha97] </ref>. 2.4 Multiple Base Relations In this section we extend our formalism to handle queries over multiple relations. Example 2.2: Consider Query Q4 from Section 1. Its SQL version appears in [Cha97]. <p> Proof : This is a special case of a more general result shown in <ref> [Cha97] </ref>. 2.4 Multiple Base Relations In this section we extend our formalism to handle queries over multiple relations. Example 2.2: Consider Query Q4 from Section 1. Its SQL version appears in [Cha97]. The query graph for this query is given in Figure 2. 2 Multiple views on both FYI LOG and FYI BILL are defined and joined together. However, the key idea is still present. <p> The idea is that we simultaneously partition the base relations on attributes with common domains. Queries can operate on multiple relations, so that query graphs can have multiple sinks. The definition, criterion, and theorems can be appropriately extended. The details appear in <ref> [Cha97] </ref>. <p> In general, before our method is applied, its estimated cost should be compared with the estimated cost of other methods, since it is not always better than conventional techniques. See <ref> [Cha97] </ref> for a discussion of cost formulas for our techniques. Furthermore, the presence of indices should be considered since with sorting or hash-partitioning, indices may become useless for later computations. <p> For optimization purposes it is better to partition as large a subquery as possible in order to simplify the processing of that subquery. Below, we briefly discuss two algorithms to identify group query components (for a detailed discussion, see <ref> [Cha97] </ref>). The idea of maximal group query components is fundamental in both. The first algorithm has running time O (mn), where m is the number of aggregate and join nodes in the query graph and n the total number of nodes.
Reference: [Syb94] <author> Sybase Corporation. </author> <title> Sybase SQL Server, Reference manual, Vol. </title> <type> 1. </type> <institution> Sybase, Inc, </institution> <year> 1994. </year>
Reference-contexts: Therefore, a differential form of the partial query ppq (Q) can be applied only to that group, where Q is the query defining the materialized view. Extended syntaxes. A number of papers and systems propose extensions of standard SQL in order to more easily express and optimize complex queries <ref> [CR96, KS95, RBVG96, Syb94] </ref>. Each of these proposals makes the argument that with an extended syntax, complex queries are easier to write and easier to optimize.
Reference: [CR96] <author> Damianos Chatziantoniou and Kenneth Ross. </author> <title> Querying multiple features of groups in relational databases. </title> <booktitle> In 22nd VLDB Conference, </booktitle> <pages> pages 295-306, </pages> <year> 1996. </year>
Reference-contexts: Firstly, each component can be optimized locally. As a result, simpler and more efficient plans can be identified. For example, the group query component on the section attribute of query Q5 constitutes a multi-feature query (discussed in <ref> [CR96] </ref>). Secondly, depending on the structure and the interrelation of these components, special cases with efficient plans can be identified. Results of one component can be pipelined to another, or components can be evaluated in parallel. <p> Therefore, a differential form of the partial query ppq (Q) can be applied only to that group, where Q is the query defining the materialized view. Extended syntaxes. A number of papers and systems propose extensions of standard SQL in order to more easily express and optimize complex queries <ref> [CR96, KS95, RBVG96, Syb94] </ref>. Each of these proposals makes the argument that with an extended syntax, complex queries are easier to write and easier to optimize.
Reference: [CS94] <author> Surajit Chaudhuri and Kyuseok Shim. </author> <title> Including group-by in query optimization. </title> <booktitle> In VLDB Conference, </booktitle> <pages> pages 354-366, </pages> <year> 1994. </year>
Reference-contexts: A large body of work exists on query optimization in databases. Graefe surveys various principles and techniques [Gra93]. The issues of aggregation and join have been studied separately until quite recently, when a number of papers on optimization of both aggregation and join have appeared <ref> [YL94, YL95, CS94, CS96, GHQ95] </ref>. Yan and Larson in [YL94, YL95] describe a class of transformations that allow the query optimizer to push a group-by past a join (eager aggregation) or pull a group-by above a join (lazy aggregation). <p> Yan and Larson in [YL94, YL95] describe a class of transformations that allow the query optimizer to push a group-by past a join (eager aggregation) or pull a group-by above a join (lazy aggregation). In a similar direction, Chaudhuri and Shim in <ref> [CS94, CS96] </ref> present a similar class of pull-up and push-down transformations. Furthermore, they incorporate these transformations in optimizers and propose a cost-based optimization algorithm to pick a plan. In [GHQ95], Gupta, Harinarayan and Quass try to unify these transformations, viewing aggregation as an extension of duplicate-eliminating projection.
Reference: [CS96] <author> Surajit Chaudhuri and Kyuseok Shim. </author> <title> Optimizing queries with aggregate views. </title> <booktitle> In Extending Database Technology, </booktitle> <pages> pages 167-182, </pages> <year> 1996. </year>
Reference-contexts: A large body of work exists on query optimization in databases. Graefe surveys various principles and techniques [Gra93]. The issues of aggregation and join have been studied separately until quite recently, when a number of papers on optimization of both aggregation and join have appeared <ref> [YL94, YL95, CS94, CS96, GHQ95] </ref>. Yan and Larson in [YL94, YL95] describe a class of transformations that allow the query optimizer to push a group-by past a join (eager aggregation) or pull a group-by above a join (lazy aggregation). <p> Yan and Larson in [YL94, YL95] describe a class of transformations that allow the query optimizer to push a group-by past a join (eager aggregation) or pull a group-by above a join (lazy aggregation). In a similar direction, Chaudhuri and Shim in <ref> [CS94, CS96] </ref> present a similar class of pull-up and push-down transformations. Furthermore, they incorporate these transformations in optimizers and propose a cost-based optimization algorithm to pick a plan. In [GHQ95], Gupta, Harinarayan and Quass try to unify these transformations, viewing aggregation as an extension of duplicate-eliminating projection.
Reference: [Day83] <author> Umeshwar Dayal. </author> <title> Processing queries over generalization hierarchies in a multidatabase system. </title> <booktitle> In Proceedings of the 9th VLDB Conference, </booktitle> <pages> pages 342-353, </pages> <year> 1983. </year>
Reference-contexts: Our approach is quite different from these in that we try to optimize a query by partitioning the query (or components of a query) rather than by changing the order of operations. Similarities exist in the context of distributed query processing and horizontally partitioned relations <ref> [SA80, ESW78, Day83] </ref>. In these papers, one of the key ideas for query optimization is that selection, projection and join distribute over union, a key idea also in our work.
Reference: [Day87] <author> Umeshwar Dayal. </author> <title> Of nests and trees: A unified approach to processing queries that contain nested sub-queries, aggregates, and quantifiers. </title> <booktitle> In Proceedings of the 13th VLDB Conference, </booktitle> <pages> pages 197-208, </pages> <year> 1987. </year>
Reference-contexts: This is a valid assumption since there are many ways to rewrite a subquery as a join of two (or more) views <ref> [Kim82, Day87, SPL96] </ref>. <p> Similarities exist in the context of distributed query processing and horizontally partitioned relations [SA80, ESW78, Day83]. In these papers, one of the key ideas for query optimization is that selection, projection and join distribute over union, a key idea also in our work. Kim in [Kim82], Dayal in <ref> [Day87] </ref>, Seshadri in [SPL96] propose decorrelation techniques, where an SQL correlated query is transformed to a query that is a join of base tables and one or more aggregate views. When rewritten using views, the attributes used for equality correlations tend to become partitioning attributes in our sense.
Reference: [DG92] <author> David DeWitt and Jim Gray. </author> <title> Parallel database systems: The future of high performance database systems. </title> <journal> Communications of the ACM, </journal> <volume> 35(6) </volume> <pages> 85-98, </pages> <year> 1992. </year>
Reference-contexts: Although our method is presented in the context of a single-processor database system, parallelism can be exploited by partitioning the base relations on the partitioning attributes and then applying the partition partial query on each partition simultaneously. This is similar to intraoperator parallelism <ref> [Gra93, DG92] </ref>. However it is different in the sense that an entire complex query may be executed in parallel, rather than a single operation. <p> This is similar to intraoperator parallelism [Gra93, DG92]. However it is different in the sense that an entire complex query may be executed in parallel, rather than a single operation. While it has always been clear that multiple operators could be parallelized together <ref> [DG92] </ref>, our work is novel in two important respects: Firstly, we have given a criterion (Criterion 2.1) that allows the expression of every group query on a given set of partitioning attributes.
Reference: [DiP69] <author> R. A. DiPaola. </author> <title> The recursive unsolvability of the decision problem for a class of definitite formulas. </title> <journal> Journal of ACM, </journal> <volume> 16(2) </volume> <pages> 324-327, </pages> <year> 1969. </year>
Reference-contexts: It is relatively straightforward to construct a query Q fl from a query Q such that Q fl is a group query if and only if Q is empty for all databases. However, deciding whether a query returns the empty set as an answer is an undecidable problem <ref> [DiP69] </ref>. Nevertheless, Theorem 2.2 shows that every group query can be expressed using a query graph satisfying Criterion 2.1. In other words, by restricting attention to queries satisfying Criterion 2.1 we can still express all group queries.
Reference: [ESW78] <author> Robert Epstein, Michael Stonebraker, and Eu-gene Wong. </author> <title> Distributed query processing in a relational data base system. </title> <booktitle> In ACM SIGMOD, Conference on Management of Data, </booktitle> <pages> pages 169-178, </pages> <year> 1978. </year>
Reference-contexts: Our approach is quite different from these in that we try to optimize a query by partitioning the query (or components of a query) rather than by changing the order of operations. Similarities exist in the context of distributed query processing and horizontally partitioned relations <ref> [SA80, ESW78, Day83] </ref>. In these papers, one of the key ideas for query optimization is that selection, projection and join distribute over union, a key idea also in our work.
Reference: [GHQ95] <author> Ashish Gupta, Venky Harinarayan, and Dallan Quass. </author> <title> Aggregate-query processing in data warehousing environments. </title> <booktitle> In VLDB Conf., </booktitle> <pages> pages 358-369, </pages> <year> 1995. </year>
Reference-contexts: A large body of work exists on query optimization in databases. Graefe surveys various principles and techniques [Gra93]. The issues of aggregation and join have been studied separately until quite recently, when a number of papers on optimization of both aggregation and join have appeared <ref> [YL94, YL95, CS94, CS96, GHQ95] </ref>. Yan and Larson in [YL94, YL95] describe a class of transformations that allow the query optimizer to push a group-by past a join (eager aggregation) or pull a group-by above a join (lazy aggregation). <p> In a similar direction, Chaudhuri and Shim in [CS94, CS96] present a similar class of pull-up and push-down transformations. Furthermore, they incorporate these transformations in optimizers and propose a cost-based optimization algorithm to pick a plan. In <ref> [GHQ95] </ref>, Gupta, Harinarayan and Quass try to unify these transformations, viewing aggregation as an extension of duplicate-eliminating projection. Our approach is quite different from these in that we try to optimize a query by partitioning the query (or components of a query) rather than by changing the order of operations.
Reference: [Gra93] <author> Goetz Graefe. </author> <title> Query evaluation techniques for large databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(2) </volume> <pages> 73-170, </pages> <year> 1993. </year>
Reference-contexts: A large body of work exists on query optimization in databases. Graefe surveys various principles and techniques <ref> [Gra93] </ref>. The issues of aggregation and join have been studied separately until quite recently, when a number of papers on optimization of both aggregation and join have appeared [YL94, YL95, CS94, CS96, GHQ95]. <p> Although our method is presented in the context of a single-processor database system, parallelism can be exploited by partitioning the base relations on the partitioning attributes and then applying the partition partial query on each partition simultaneously. This is similar to intraoperator parallelism <ref> [Gra93, DG92] </ref>. However it is different in the sense that an entire complex query may be executed in parallel, rather than a single operation.
Reference: [Kim82] <author> Won Kim. </author> <title> On optimizing an SQL-like nested query. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(3) </volume> <pages> 443-469, </pages> <year> 1982. </year>
Reference-contexts: This is a valid assumption since there are many ways to rewrite a subquery as a join of two (or more) views <ref> [Kim82, Day87, SPL96] </ref>. <p> Similarities exist in the context of distributed query processing and horizontally partitioned relations [SA80, ESW78, Day83]. In these papers, one of the key ideas for query optimization is that selection, projection and join distribute over union, a key idea also in our work. Kim in <ref> [Kim82] </ref>, Dayal in [Day87], Seshadri in [SPL96] propose decorrelation techniques, where an SQL correlated query is transformed to a query that is a join of base tables and one or more aggregate views.
Reference: [KS95] <author> Ralph Kimball and Kevin Strehlo. </author> <title> Why decision support fails and how to fix it. </title> <booktitle> SIGMOD RECORD, </booktitle> <volume> 24(3) </volume> <pages> 92-97, </pages> <year> 1995. </year>
Reference-contexts: Therefore, a differential form of the partial query ppq (Q) can be applied only to that group, where Q is the query defining the materialized view. Extended syntaxes. A number of papers and systems propose extensions of standard SQL in order to more easily express and optimize complex queries <ref> [CR96, KS95, RBVG96, Syb94] </ref>. Each of these proposals makes the argument that with an extended syntax, complex queries are easier to write and easier to optimize.
Reference: [LW96] <author> Chang Li and Sean W. Wang. </author> <title> A data model for supporting on-line analytical processing. </title> <booktitle> In to appear in International Conference on Information and Knowledge Management, </booktitle> <pages> pages 81-88, </pages> <year> 1996. </year>
Reference-contexts: This idea is implicit in papers that model multi-dimensional databases <ref> [LW96, AGS97] </ref>. In our framework this characteristic results in a query graph with several, possibly overlapping, component group queries. Having a complex decision support query, it is important to identify its group query components for a number of reasons. Firstly, each component can be optimized locally. <p> Our techniques apply to all relational queries, including those expressed in a special syntax. Decision support. Very recently, a number of papers appeared on data models for decision support queries <ref> [AGS97, LW96] </ref>. In these papers databases are treated as multidimensional constructs and operators such as push (similar to grouping with aggregation) and join are proposed.
Reference: [RBVG96] <author> Sudhir Rao, Antonio Badia, and Dirk Van Gucht. </author> <title> Providing better support for a class of decision support queries. </title> <booktitle> In ACM SIGMOD, Conference on Management of Data, </booktitle> <pages> pages 217-227, </pages> <year> 1996. </year>
Reference-contexts: Therefore, a differential form of the partial query ppq (Q) can be applied only to that group, where Q is the query defining the materialized view. Extended syntaxes. A number of papers and systems propose extensions of standard SQL in order to more easily express and optimize complex queries <ref> [CR96, KS95, RBVG96, Syb94] </ref>. Each of these proposals makes the argument that with an extended syntax, complex queries are easier to write and easier to optimize.
Reference: [SA80] <author> Patricia Selinger and Michel Adiba. </author> <title> Access path selection in distributed database management systems. </title> <booktitle> In International Conference on Databases, </booktitle> <pages> pages 204-215, </pages> <year> 1980. </year>
Reference-contexts: Our approach is quite different from these in that we try to optimize a query by partitioning the query (or components of a query) rather than by changing the order of operations. Similarities exist in the context of distributed query processing and horizontally partitioned relations <ref> [SA80, ESW78, Day83] </ref>. In these papers, one of the key ideas for query optimization is that selection, projection and join distribute over union, a key idea also in our work.
Reference: [Sel88] <author> Timos Sellis. </author> <title> Multiple-query optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(1) </volume> <pages> 23-52, </pages> <year> 1988. </year>
Reference-contexts: Results of one component can be pipelined to another, or components can be evaluated in parallel. Finally, one of the key ideas in multiple-query optimization is to allow queries to be decomposed into smaller subqueries that now become the unit of execution <ref> [Sel88] </ref>. The idea of group query components is very similar: Group queries become now the unit of execution. In fact, our framework can be used for multiple-query optimization in the case of aggregate queries.
Reference: [SN95] <author> Ambuj Shatdal and Jeffrey F. Naughton. </author> <title> Adaptive parallel aggregation algorithms. </title> <booktitle> In ACM SIGMOD, Conference on Management of Data, </booktitle> <pages> pages 104-114, </pages> <year> 1995. </year>
Reference-contexts: This strategy can improve query performance by more than a linear factor, whether one uses a parallel database system or a single-processor system. Shatdal and Naughton have described a performance comparison of various algorithms for performing aggregation in the presence of data partitioning <ref> [SN95] </ref>. While we have not considered data partitioning here, our partitioned queries would obviously benefit in a parallel system if the data were partitioned to CPUs according to the partitioning attributes.
Reference: [SPL96] <author> Praveen Seshadri, Hamid Pirahesh, and T.Y. Cliff Leung. </author> <title> Complex query decorrelation. </title> <booktitle> In International Conference of Data Engineering, </booktitle> <pages> pages 450-458, </pages> <year> 1996. </year>
Reference-contexts: This is a valid assumption since there are many ways to rewrite a subquery as a join of two (or more) views <ref> [Kim82, Day87, SPL96] </ref>. <p> In these papers, one of the key ideas for query optimization is that selection, projection and join distribute over union, a key idea also in our work. Kim in [Kim82], Dayal in [Day87], Seshadri in <ref> [SPL96] </ref> propose decorrelation techniques, where an SQL correlated query is transformed to a query that is a join of base tables and one or more aggregate views. When rewritten using views, the attributes used for equality correlations tend to become partitioning attributes in our sense.
Reference: [YL94] <author> Weipeng P. Yan and Per-Ake Larson. </author> <title> Performing Group-By before Join. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 89-100, </pages> <year> 1994. </year>
Reference-contexts: A large body of work exists on query optimization in databases. Graefe surveys various principles and techniques [Gra93]. The issues of aggregation and join have been studied separately until quite recently, when a number of papers on optimization of both aggregation and join have appeared <ref> [YL94, YL95, CS94, CS96, GHQ95] </ref>. Yan and Larson in [YL94, YL95] describe a class of transformations that allow the query optimizer to push a group-by past a join (eager aggregation) or pull a group-by above a join (lazy aggregation). <p> Graefe surveys various principles and techniques [Gra93]. The issues of aggregation and join have been studied separately until quite recently, when a number of papers on optimization of both aggregation and join have appeared [YL94, YL95, CS94, CS96, GHQ95]. Yan and Larson in <ref> [YL94, YL95] </ref> describe a class of transformations that allow the query optimizer to push a group-by past a join (eager aggregation) or pull a group-by above a join (lazy aggregation). In a similar direction, Chaudhuri and Shim in [CS94, CS96] present a similar class of pull-up and push-down transformations.
Reference: [YL95] <author> Weipeng P. Yan and Per-Ake Larson. </author> <title> Eager aggregation and lazy aggregation. </title> <booktitle> In VLDB Conference, </booktitle> <pages> pages 345-357, </pages> <year> 1995. </year>
Reference-contexts: A large body of work exists on query optimization in databases. Graefe surveys various principles and techniques [Gra93]. The issues of aggregation and join have been studied separately until quite recently, when a number of papers on optimization of both aggregation and join have appeared <ref> [YL94, YL95, CS94, CS96, GHQ95] </ref>. Yan and Larson in [YL94, YL95] describe a class of transformations that allow the query optimizer to push a group-by past a join (eager aggregation) or pull a group-by above a join (lazy aggregation). <p> Graefe surveys various principles and techniques [Gra93]. The issues of aggregation and join have been studied separately until quite recently, when a number of papers on optimization of both aggregation and join have appeared [YL94, YL95, CS94, CS96, GHQ95]. Yan and Larson in <ref> [YL94, YL95] </ref> describe a class of transformations that allow the query optimizer to push a group-by past a join (eager aggregation) or pull a group-by above a join (lazy aggregation). In a similar direction, Chaudhuri and Shim in [CS94, CS96] present a similar class of pull-up and push-down transformations.
References-found: 23

