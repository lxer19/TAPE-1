URL: ftp://ftp.cs.cmu.edu/project/mach/doc/published/dos-fs.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/project/mach/public/www/doc/publications.html
Root-URL: 
Title: An MS-DOS File System for UNIX  
Author: Alessandro Forin Gerald R. Malan 
Note: A shorter version of this document will appear in the Proceedings of the 1994 Winter USENIX Conference  
Address: Pittsburgh, Pennsylvania 15213  Francisco, CA.  
Affiliation: School of Computer Science Carnegie Mellon University  San  
Date: September 1993  January 17-21, 1994  
Pubnum: CMU-CS-93-196  
Abstract: This research was sponsored by the Advanced Research Projects Agency (DOD), under contract number DABT63-93-C-0054. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the Defense Advanced Research Projects Agency or the US Government.- 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ray Duncan. </author> <title> Advanced MSDOS Programming. </title> <publisher> Microsoft Press, </publisher> <year> 1986. </year>
Reference-contexts: The MS-DOS File System Structure Starting from the first sector of a disk, the MS-DOS file system layout is as follows; further details can be found in <ref> [1] </ref>. The initial section of the disk contains the primary (1 sector) and the secondary bootstraps (a variable number of sectors). This is followed by one or more copies of the File Allocation Table (FAT), which is followed by the root directory entries. <p> If we encounter a power failure the status of the disk will be as of the last sync (2) call, and dosfsck takes care of rewriting the alternate FATs. Our disk block allocation algorithm is extremely simple and similar to the one used by MS-DOS <ref> [1] </ref>. When extending a file we scan forward in the FAT starting from the last block of the file. If we do not find a free block, then we scan backward from the last block of the file. <p> The only cost is a more cumbersome and slow implementation of hard file links. In the implementation of DosFs we have used a new block allocation algorithm, derived from MS-DOS <ref> [1] </ref>. The algorithm obtains both contiguous allocation of disk blocks and compact disk utilization. DosFs is both faster than 4.3 BSD FFS and more efficient in disk space. The performance gains are equivalent to Extent Based allocation, but without the high fragmentation costs.
Reference: [2] <author> David Golub, Randall Dean, Alessandro Forin, Richard Rashid. </author> <title> Unix as an Application Program. </title> <booktitle> In Proceedings of the USENIX Summer Conference, </booktitle> <pages> pages 87-95. </pages> <publisher> USENIX, </publisher> <address> Anaheim, CA, </address> <month> June, </month> <year> 1990. </year>
Reference-contexts: 1. Introduction Today's micro-kernel architectures make it possible to run multiple operating system environments simultaneously. For example, a notebook computer running Mach 3.0 <ref> [2] </ref> can have both UNIX and MS-DOS disk partitions. In fact, an MS-DOS emulator [12] can be started from within the UNIX environment so that Windows applications can run in parallel with UNIX applications.
Reference: [3] <author> David Golub and Richard Draves. </author> <title> Moving the Default Memory Manager Out of the Mach Kernel. </title> <booktitle> In Proceedings of the USENIX Mach Symposium, </booktitle> <pages> pages 177-188. </pages> <publisher> USENIX, </publisher> <address> Monterey, CA, </address> <month> November, </month> <year> 1991. </year>
Reference-contexts: Other extensions When we first tried to use DosFs as a root file system on a DEC Alpha workstation we discovered a small number of other problems. To begin with, we had to modify both the boot programs and the Mach default pager <ref> [3] </ref> to understand the MS-DOS file system structures. The first must be able to find, read in, and transfer control to the boot image. The second has similar needs with respect to the UNIX server image. In addition, it might have to use a DosFs file system for paging purposes.
Reference: [4] <author> Howard, J. et al. </author> <title> Scale and Performance in a Distributed File System. </title> <journal> ACM Transactions on Computer Systems 6(1), </journal> <month> February, </month> <year> 1988. </year>
Reference-contexts: This is also repeated at least 100 times. Most of the well-known macro-benchmarks are UNIX-specific and do not have an identical implementation and meaning under MS-DOS and UNIX. This is true for the Andrew benchmark <ref> [4] </ref>, for which we do not have a native MS-DOS version. Similarly for the unpacking of the tar file described in Section 6; we can only compare the times to do the unpacking between FFS and DosFs. The Iostone test is a synthetic benchmark that models a timesharing load.
Reference: [5] <author> ISO 9660 : 1988 (E). </author> <title> Information processing - Volume and file structure of CD-ROM for information interchange. International Organization for Standardization, </title> <year> 1988. </year>
Reference-contexts: On the practical side, we wanted to extend our UNIX system to support more disk formats, including MS-DOS and the ISO 9660 <ref> [5] </ref> disk formats. Some of our users expressed a desire to have the UNIX backup and restore utilities work on their MS-DOS data. Finally, a UNIX local file system should be usable as the root file system for a multi-user UNIX system.
Reference: [6] <author> Kleiman, S. R. Vnodes: </author> <title> An Architecture for Multiple File System Types in Sun UNIX. </title> <booktitle> In Proceedings of the Summer 1986 USENIX Conference, </booktitle> <pages> pages 238-247. </pages> <month> June, </month> <year> 1986. </year>
Reference-contexts: It strives to minimize resource utilization, both in memory and on disk. But it lacks features present in UNIX file systems, such as file links. DosFs is implemented as a layer of code below the virtual file system (Vnode) layer <ref> [6] </ref>. The Vnode layer has a well defined interface, which must be fully implemented to cover all aspects of UNIX file system functionality. This presented us with various design issues, which we will describe in the rest of the section.
Reference: [7] <author> Margo Seltzer, Keith Bostic, Kirk McKusick, Carl Staelin. </author> <title> An Implementation of a Log-Structured File System for Unix. </title> <booktitle> In Proceedings of the USENIX Winter Conference, </booktitle> <pages> pages 201-220. </pages> <publisher> USENIX, </publisher> <address> San Diego, CA, </address> <month> January, </month> <year> 1993. </year>
Reference-contexts: The remainder of the paper is structured as follows. Section 2 describes the organization of the MS-DOS file system and permanent disk data. We assume the reader has some knowledge of the BSD FFS data structures, descriptions can be found in <ref> [8, 7] </ref>. Section 3 details the main design and implementation problems. Section 4 illustrates the programs we wrote for file system maintainance. In Section 5 we look at the performance optimizations from the following viewpoint. We use native, uncached MS-DOS as the base for each test. <p> Using fresh file systems would lead to a more repeatable experiment, but using old file systems shows what happens to the performance numbers when the file systems age. The discrepancy between our results and the results presented in <ref> [7] </ref> seems to indicate that DosFs has a better degradation than FFS. <p> Extra data copies make DosFs slower than MS-DOS. But the most remarkable result here is the five fold speedup of DosFs over FFS. This result can be explained in the same way as in <ref> [7] </ref>: DosFs performs I/Os on a file that is contiguous, whereas FFS allows for presumed rotational delays and interleaves blocks on the disk. Every track is only 1/4 utilized by FFS, losing most of the benefits of the track-level caching done by the disk. <p> These can support more than just protection information; they can be used for presentation purposes for instance. Extensions by the same name are defined in the ISO 9660 standard, and serve similar purposes. Our optimizations for uncached accesses are similar, but unrelated to the optimizations described in <ref> [9, 7] </ref> for Extent Based File Systems. DosFs adds to McVoy's work the ability to specify the extent size at mount time. The 20 implementation of large operations is similar to the BSD 4.4 cluster idea, the bmap () changes are almost identical.
Reference: [8] <author> Kirk McKusick, William Joy, Sam Leffler, R. </author> <note> Fabry. </note>
Reference-contexts: We found that the MS-DOS file was contiguously allocated and was being accessed with four times larger block sizes (e.g. 16 KB at a time) just like our user program was requesting. The FFS file was allocated in an interleaved fashion to cope with rotational delays <ref> [8] </ref>, and was being accessed at the file system block size, 4 KB. The extra seek times accounted for the remaining discrepancies. <p> The remainder of the paper is structured as follows. Section 2 describes the organization of the MS-DOS file system and permanent disk data. We assume the reader has some knowledge of the BSD FFS data structures, descriptions can be found in <ref> [8, 7] </ref>. Section 3 details the main design and implementation problems. Section 4 illustrates the programs we wrote for file system maintainance. In Section 5 we look at the performance optimizations from the following viewpoint. We use native, uncached MS-DOS as the base for each test. <p> One last optimization we adopted from MS-DOS: we do not force the users to discover optimizations on their own, unless they are really obvious. This is in sharp contrast with the FFS philosophy. In <ref> [8] </ref> it was advocated that users would know the characteristics of all disks and even the speed of their processors relative to the disks they used. Users would otherwise perform experiments to define the correct values for the file system parameters, and 12 use tunefs (1) to optimize them. <p> An important factor in the DosFs performance profile is the effect of seek times, or more precisely the time spent by the disk to service a given I/O request. Today's disks use a variety of multi-track caching strategies that make the old FFS model <ref> [8] </ref> unrealistic. Unfortunately, the service time has become very difficult to model. In our SCSI analyzer traces we observed large variations in service times, anywhere from 3 milliseconds to 45 milliseconds, on the same disk, and not at all a simple function of the distance between disk blocks.
References-found: 8

