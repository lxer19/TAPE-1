URL: http://www.cs.kuleuven.ac.be/~herman/PAPERS/euromicro93.ps
Refering-URL: http://www.cs.kuleuven.ac.be/~henk/DPS/publications.html
Root-URL: 
Email: herman@cs.kuleuven.ac.be  
Title: Object Invocation in the COMET Open Distributed System the Dialogue Model communication side, dialogues support
Author: Herman Moons, Pierre Verbaeten 
Note: On the  
Address: Leuven, Belgium  
Affiliation: Dept. of Computer Science Katholieke Universiteit Leuven  
Abstract: This paper presents COMET, a Common Object Management EnvironmenT, that investigates basic problems associated with distributed computing in an internet environment with mobile objects. COMET offers a uniform invocation model, based on dialogues, that integrates both communication and execution aspects. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Birrell and B. Nelson, </author> <title> ``Implementing Remote Procedure Calls'' ACM Transactions on Computer Systems, </title> <type> Vol.2 (1) , pp. </type> <month> 39-59 (February, </month> <year> 1984). </year>
Reference-contexts: Developing distributed applications for such an environment is a hard problem. An integrated approach is needed to relieve the programmer of the burden of communication details, presentation management issues, locating partners, etc. Remote procedure calls were introduced to ease the programming of distributed applications <ref> [1] </ref>. However, RPC's are not well suited for an internet environment. A first problem is the synchronous nature of RPC, which unduly restricts the amount of parallelism that can be obtained in a distributed system.
Reference: [2] <author> A.P. Black and Y. Artsy, </author> <title> ``Implementing Location Independent Invocation'' IEEE Transactions on Parallel and Distributed Systems, </title> <type> Vol.1 (1) , pp. </type> <month> 107-119 (January </month> <year> 1990). </year>
Reference-contexts: The COMET kernels on different logical nodes cooperate to implement the notion of a global object space. Within this object space, COMET objects can interact with each other regardless of their physical location, using location-independent invocation <ref> [2, 10] </ref>. 3. Type Model and Object Model Distributed applications in the COMET system are constructed from sets of interacting objects. For objects to cooperate, they must know the operations supported by the objects they invoke. This knowledge is captured by an object's type.
Reference: [3] <author> D.K. Gifford and N. Glasser, </author> <title> ``Remote Pipes and Procedures for Efficient Distributed Communication'' ACM Transactions on Computer Systems, </title> <note> Vol.6 (3) , pp. </note> <month> 258-283 (August, </month> <year> 1988). </year>
Reference-contexts: Related Work Gifford was one of the first to introduce primitives for asynchronous request handling, in order to overcome the shortcomings of RPC <ref> [3] </ref>. He introduced remote pipes, which allow for the asynchronous transfer of bulk data. Remote procedures and pipes can be combined in channel groups to enforce the ordering property. A more integrated approach is taken by Liskov, who introduced promises to express asynchrony [7].
Reference: [4] <author> Ulf Hollberg, Herbert Eberle, Kurt Geihs, Reinhard Heite, and Herman Schmutz, </author> <title> An Object Oriented View of Distribution, </title> <type> Technical Report No. </type> <institution> 43.9004, IBM European Networking Center, </institution> <address> Heidelberg, Germany (1990). </address>
Reference-contexts: Supporting additional languages is however straightforward, and requires the addition of some simple modules to the kernel (e.g. data conversion routines for presentation management). In COMET, classes and types are independent entities. A similar approach is used in Guide [5], OVID <ref> [4] </ref> and Portlandish [13]. This strict separation is essential in an open environment. It allows us to provide multiple implementations, e.g. for different machine architectures, or written in different programming languages. A type and its classes are brought together in a template.
Reference: [5] <author> S. Krakowiak, M. Meysembourg, H. Nguyen Van, M. Riveill, C. Roisin, and X. Rousset de Pina, </author> <title> ``Design and Implementation of an Object-Oriented, </title> <booktitle> Strongly Typed Language for Distributed Applications'' Journal on Object-Oriented Programming, </booktitle> <pages> pp. </pages> <month> 11-22 (September/October </month> <year> 1990). </year>
Reference-contexts: Supporting additional languages is however straightforward, and requires the addition of some simple modules to the kernel (e.g. data conversion routines for presentation management). In COMET, classes and types are independent entities. A similar approach is used in Guide <ref> [5] </ref>, OVID [4] and Portlandish [13]. This strict separation is essential in an open environment. It allows us to provide multiple implementations, e.g. for different machine architectures, or written in different programming languages. A type and its classes are brought together in a template.
Reference: [6] <author> B. Liskov, </author> <title> ``Data Abstraction and Hierarchy'' pp. </title> <booktitle> 17-34 in OOPSLA '87 Addendum to the Proceedings, </booktitle> <address> Orlando, Florida (October 4-8, </address> <year> 1987). </year>
Reference-contexts: No details are revealed about the representation of objects that conform to the type. This is in accordance with the abstract data type approach, which states that knowledge about the representation of a type is immaterial (and even harmful) to its users <ref> [6] </ref>. Implementation details are captured by an object's class. The class provides the methods implementing the operations of the type, and the state variables manipulated by these methods. The actual implementation of the class methods is expressed in a programming language supported by the COMET system (currently C and C++).
Reference: [7] <author> B. Liskov and L. Shrira, </author> <title> ``Promises: Linguistic Support for Efficient Asynchronous Procedure Calls in Distributed Systems'' pp. </title> <booktitle> 260-267 in Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation (June, </booktitle> <year> 1988). </year>
Reference-contexts: He introduced remote pipes, which allow for the asynchronous transfer of bulk data. Remote procedures and pipes can be combined in channel groups to enforce the ordering property. A more integrated approach is taken by Liskov, who introduced promises to express asynchrony <ref> [7] </ref>. Promises serve as placeholders for values that will exist in the future (when the actual result of an invocation arrives). They ensure ordered handling of requests. Batching is used to increase throughput.
Reference: [8] <author> Peter W. Madany, Nayeem Islam, Panos Kougiouris, and Roy H. Campbell, </author> <title> Reification and Reflection in C++: An Operating Systems Perspective, </title> <type> Technical Report, </type> <institution> University of Illinois at Urbana-Champaign, Dept. of Computer Science. </institution>
Reference-contexts: When a dialogue is opened, the actual flavor of the partner object is unknown. It is therefore not possible to directly instantiate a dialogue of the correct type. The BaseDlg RegularDlg ReplicatedDlgPersistentDlg AtomicDlg solution adopted in COMET is to use a reflective technique <ref> [8, 12] </ref>. When opening a dialogue, a Meta-Dialogue is created that controls a BaseDialogue. The Meta-Dialogue is responsible for determining the partner's flavor. This information is obtained from name servers in the COMET system.
Reference: [9] <author> Herman Moons, Pierre Verbaeten, and Ulf Hollberg, </author> <booktitle> ``Distributed Computing in Heterogeneous Environments'' EUUG Spring '90 Conference, </booktitle> <pages> pp. 15-26 (April 23-27, </pages> <year> 1990). </year>
Reference-contexts: It offers primitives for object creation/destruction, object migration and location-independent object invocation. The presence of Generic and Transport kernels makes it easy to support multiple platforms <ref> [9] </ref>. They effectively insulate higher level software from the idiosyncrasies of the underlying guest system. The COMET kernels on different logical nodes cooperate to implement the notion of a global object space.
Reference: [10] <author> Herman Moons and Pierre Verbaeten, </author> <title> Naming and Locating Mobile Objects in Open Distributed Systems, </title> <type> Report CW 151, </type> <institution> Dept. of Computer Science, Katholieke Universiteit Leuven (March, </institution> <year> 1992). </year>
Reference-contexts: The COMET kernels on different logical nodes cooperate to implement the notion of a global object space. Within this object space, COMET objects can interact with each other regardless of their physical location, using location-independent invocation <ref> [2, 10] </ref>. 3. Type Model and Object Model Distributed applications in the COMET system are constructed from sets of interacting objects. For objects to cooperate, they must know the operations supported by the objects they invoke. This knowledge is captured by an object's type.
Reference: [11] <author> Herman Moons, </author> <title> The Comet Type and Object Model, </title> <type> Report CW 150, </type> <institution> Dept. of Computer Science, Katholieke Universiteit Leuven (June, </institution> <year> 1992). </year>
Reference-contexts: COMET therefore provides a language-independent type system for expressing object interfaces. Object types are defined by means of a Type Definition Language (TDL), that rigorously specifies the set of available operations, with their arguments, results and exceptions <ref> [11] </ref>. Although the semantics of these operations are not required by the COMET kernel, they are best provided in the form of comments to document the meaning of the operations. A sample TDL description of a simple terminal type is shown in figure 2.
Reference: [12] <author> Maes Patty, </author> <title> ``Concepts and Experiments in Computational Reflection'' OOPSLA 87, </title> <booktitle> Conference Proceedings, </booktitle> <pages> pp. 147-155, </pages> <note> ACM (1987). </note>
Reference-contexts: When a dialogue is opened, the actual flavor of the partner object is unknown. It is therefore not possible to directly instantiate a dialogue of the correct type. The BaseDlg RegularDlg ReplicatedDlgPersistentDlg AtomicDlg solution adopted in COMET is to use a reflective technique <ref> [8, 12] </ref>. When opening a dialogue, a Meta-Dialogue is created that controls a BaseDialogue. The Meta-Dialogue is responsible for determining the partner's flavor. This information is obtained from name servers in the COMET system.
Reference: [13] <author> Harry H. Porter, </author> <title> ``Separating the subtype hierarchy from the inheritance of implementation'' Journal of Object-Oriented Programming, </title> <type> Vol.4 (9) , pp. </type> <month> 20-29 (February, </month> <year> 1992). </year>
Reference-contexts: Supporting additional languages is however straightforward, and requires the addition of some simple modules to the kernel (e.g. data conversion routines for presentation management). In COMET, classes and types are independent entities. A similar approach is used in Guide [5], OVID [4] and Portlandish <ref> [13] </ref>. This strict separation is essential in an open environment. It allows us to provide multiple implementations, e.g. for different machine architectures, or written in different programming languages. A type and its classes are brought together in a template. A template thus contains all classes implementing a specific type.
Reference: [14] <author> Edward F. Walker, Richard Floyd, and Paul Neves, </author> <title> ``Asynchronous Remote Operation Execution in Distributed Systems'' pp. </title> <booktitle> 253-259 in Proceedings 10th International Conference on Distributed Computing Systems, </booktitle> <address> Paris, France (May 28 - June 1, </address> <year> 1990). </year>
Reference-contexts: They ensure ordered handling of requests. Batching is used to increase throughput. A similar approach is taken with the futures in the Cronus system, except that no guarantee is made concerning delivery order <ref> [14] </ref>. Like promises, COMET's ticket mechanism ensures ordered handling of requests. The dialogue model is however more powerful, since it also supports increased parallelism with out-of-band requests. Furthermore, the programmer has full control over the batching aspect of dialogues, thus permitting him to weigh increased throughput against reduced latency.
References-found: 14

