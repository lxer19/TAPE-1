URL: http://www.cs.umr.edu/techreports/94-18.ps
Refering-URL: http://www.cs.umr.edu/techreports/
Root-URL: 
Title: Using Temporal Subsumption to Generate Efficient Error-Detecting Distributed Algorithms  
Author: Dr. George Zobrist Dr. Matt Insall Dr. Paul Stigall 
Degree: by Martina F. Schollmeyer, 1964 A DISSERTATION Presented to the Faculty of the Graduate School of the UNIVERSITY OF MISSOURI-ROLLA In Partial Fulfillment of the Requirements for the Degree DOCTOR OF PHILOSOPHY in COMPUTER SCIENCE 1994 Dr. Bruce McMillin, Advisor Dr. Arlan DeKock  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> D.M. Andrews. </author> <title> Using executable assertions for testing and fault tolerance. </title> <booktitle> Proceedings of the 9th FTCS, </booktitle> <pages> pages 102-105, </pages> <year> 1979. </year>
Reference-contexts: F. A SPECIFIC EXAMPLE OF AN ERROR-DETECTING ALGORITHM Error-detecting algorithms work by checking, at run time, for hardware, communication [26], and software errors [38]. These algorithms can be generated by using executable assertions for error detection [34], <ref> [1] </ref>. Assertions can, for example, be obtained from program verification. A properly chosen set of assertions guarantees that, when operationally 138 evaluated, such as in Changeling [34], the program meets its specifications or an error will be flagged.
Reference: [2] <author> G.R. Andrews. </author> <title> Concurrent Programming Principles and Practice. </title> <publisher> Benjamin Cum-mings Publishing Company, Inc., </publisher> <year> 1991. </year>
Reference-contexts: These assertions would then allow us to determine whether Q e ! P and thus whether fQg (partially) subsumes fP g. We will now describe how to obtain the weakest pre-condition for each of the program statements in the language CSP, based on discussions in [10] and <ref> [2] </ref>. <p> We therefore need to define a different rule for generating the weakest pre-condition. We will refer to the discussion in <ref> [2] </ref> for generating the weakest pre-condition for the looping construct. We assume that I denotes the loop invariant and the variable b is an integer expression whose value is non-negative. <p> B. PROPOSED WORK The work performed in this dissertation deals with assertions describing the expected behavior of a program in the subsumption model. In general, one would expect these assertions to be predicate logic assertions <ref> [2] </ref>, and that is exactly how the subsumption tool was developed. There exist several natural extensions to both the theory of temporal subsumption developed here and the tools that were developed to go with it.
Reference: [3] <author> R. Apt and W. Roever. </author> <title> A proof system for communicating sequential processes. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(3) </volume> <pages> 359-385, </pages> <year> 1981. </year>
Reference-contexts: The first approach divides the correctness proof into two parts. Part one consists of the sequential proofs of each individual process that makes assumptions about the effects of the communication commands. The second part is to ensure that the assumptions are "legitimate." 1 This first approach is taken in <ref> [3] </ref> and [29]. The second approach allows us to prove properties of the individual processes using the axioms and rules of inference applicable to the statements in the individual processes.
Reference: [4] <author> B. Arrowsmith and B. McMillin. </author> <title> CCSP a formal system for distributed program debugging. </title> <booktitle> Proc. of the 2nd Int. Conf. on Software for Multiprocessors and Supercomputers: Theory, Practice, Experience, </booktitle> <year> 1994. </year>
Reference-contexts: There is, to our knowledge, no CSP compiler available that does exactly what we want it to do, and so the CCSP system <ref> [4] </ref> was used for the run-time experiments. 80 The CCSP system consists of a CSP parser written using C and the compiling tools lex and yacc.
Reference: [5] <author> R.S. Boyer and J.S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: And it is very easy to make little mistakes which may lead to not being able to show that the program meets its specifications. Because of the tedious nature of manual proofs, there have been many efforts in trying to mechanize program verification <ref> [5] </ref>, [13], [14]. Unfortunately, it has been shown that it is impossible in principle to design a decision procedure which decides automatically the truth or falsehood of an arbitrary (mathematical) statement [41]. However, the non-existence of a general decision procedure only shows that one cannot prove everything automatically.
Reference: [6] <author> R. Chadha. </author> <title> Application of unskolemization. </title> <type> Ph.D Thesis, </type> <institution> Computer Science Department, University of North Carolina at Chapel Hill, </institution> <year> 1991. </year> <title> Chapter III: Mechanical Generation of Loop Invariants for Program Verification. </title>
Reference-contexts: Even if no complete invariants can be generated, partial information may be sufficient to detect inconsistencies in the assertions during the subsumption process. The complete automation of generating weakest pre-conditions for branching and looping constructs can be considered a separate research area <ref> [6] </ref>. We will therefore focus mostly on the automatic generation of pre-assertions for the non-branching code segments and simplify the process for the branching and looping constructs.
Reference: [7] <author> M. Clint. </author> <title> Program proving: </title> <journal> coroutines,. Acta Informatica, </journal> <volume> 2 </volume> <pages> 50-63, </pages> <year> 1973. </year>
Reference-contexts: This is done with the use of "dummy" or auxiliary variables that relate program variables of one process to program variables of another. The need for such variables has been independently recognized by many. The first reference that shows the usefulness of auxiliary variables is found in <ref> [7] </ref>. If we now want to prove the correctness of a sequential program that communicates with another program, we can use these auxiliary variables to do just that. 1. Overall Proof Approach. As discussed before, a CSP program is made up of component sequential processes executing in parallel.
Reference: [8] <author> F. Cristian, H. Aghili, and R. </author> <title> Strong. Atomic broadcast: From simple message diffusion to byzantine agreement. </title> <booktitle> Proceedings of the 15th FTCS, </booktitle> <pages> pages 200-206, </pages> <year> 1985. </year>
Reference-contexts: must satisfy the following relation: For i 2 f1; 2; Qg; fi fi fi a i;i 4 j6=i (K) 3 (k) fi fi fi ! To verify the post assertion, each process will send its last computed value of u (K) other members of its CE using message diffusion 2 <ref> [8] </ref>. By checking the different versions that arrive on these paths [34], each processor in the CE must receive identical versions of a sent message or will detect an error if inconsistencies 1 Axiomatic semantics provide formal statements about the effect of executing a program.
Reference: [9] <author> W. Dally and C. Seitz. </author> <title> The torus routing chip. </title> <journal> Journal of Distributed Computing, </journal> <volume> 1(3) </volume> <pages> 187-196, </pages> <year> 1986. </year>
Reference-contexts: Frequently, algorithms restrict interprocessor communication to adjacent processors to improve efficiency. However, new routing technologies, such as wormhole routing, make the delivery of messages to processors that are a distance of more than one away almost as efficient as direct communication <ref> [9] </ref>. We allow for both types of interactions in the communication environment. Definition VIII.1 The communication environment (CE) of a processor P i is the set of processors from which P i will receive information during the execution of a program. This set includes P i as well.
Reference: [10] <author> E. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1976. </year>
Reference-contexts: With only one process running, communication commands deadlock. Thus, for a single process, any predicate Q may be assumed to be true as the post-condition of a communication command because termination never occurs. The "Law of the Excluded Miracle" <ref> [10] </ref> states that the statement false should never be derived. This is a requirement to ensure a sound logic. <p> In those cases, since the static rules require a complete proof, we will need to reconstruct the lacking assertions. In the following section we will discuss how we can use Dijkstra's weakest pre-condition rules <ref> [10] </ref> to generate intermediate assertions that are not provided with a given program to be subjected to the subsumption process. 59 B. DEALING WITH INCOMPLETE PROOF OUTLINES Often, the person designing and proving the correctness of a program is not interested in the complete semantics of the program. <p> These assertions would then allow us to determine whether Q e ! P and thus whether fQg (partially) subsumes fP g. We will now describe how to obtain the weakest pre-condition for each of the program statements in the language CSP, based on discussions in <ref> [10] </ref> and [2]. <p> By requiring that the above condition holds, we simply require that wherever P is true, wp (S; Q) is also true, which means that P is a sufficient pre-condition (although not the weakest). 60 Dijkstra <ref> [10] </ref> lists several properties of the weakest pre-condition generation that may become useful for generating simpler pre-conditions. * wp (S; false) = false (Law of the Excluded Miracle) * if Q ! R then wp (S; Q) ! wp (S; R) * (wp (S; Q) ^ wp (S; R)) = wp <p> Again, combining the cases described above, we can now derive the weakest pre-condition for the iterative statement as follows: wp (DO; Q) = (9k : 0 k : H k (Q)) The weakest pre-condition for the iterative statement, as described above and discussed in detail in <ref> [10] </ref>, does not connect the usual inference rules for the generation of assertions 64 with the pre-condition generated since it completely ignores the loop-invariant.
Reference: [11] <author> J. Fortes and C. Raghavendra. </author> <title> Graceful degradable processor arrays. </title> <journal> IEEE Trans. On Computers, </journal> <volume> C-34:1033-1044, </volume> <month> November </month> <year> 1985. </year>
Reference-contexts: Section F provides an example of how this form of assessment can be used in an error-detecting matrix relaxation algorithm. B. TERMINOLOGY FOR MPS TOPOLOGIES In this chapter we examine fixed-topology multiprocessor systems as discussed in <ref> [11] </ref>, [17], [28], [46].
Reference: [12] <author> M. Garey and Johnson D. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. W.H. </title> <publisher> Freeman, </publisher> <address> San Francisco, </address> <year> 1979. </year>
Reference-contexts: in NP. fl Lemma VIII.2 A variant of the 0,1 integer programming problem in which all components of ~y are required to be in 0,1, called 0,1-integer programming, which is NP-complete, even if all components of each ~x, b and all components of ~c are required to be in 0,1 <ref> [12] </ref>, can be reduced to the FTD problem in polynomial time. The proof for Lemma VIII.2 is given in [48].
Reference: [13] <author> D.I. </author> <title> Good. Mechanical proofs about computer programs. In C.A.R. Hoare and J.C. </title> <editor> Shepherdson, editors, </editor> <booktitle> Mathematical Logic and Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: And it is very easy to make little mistakes which may lead to not being able to show that the program meets its specifications. Because of the tedious nature of manual proofs, there have been many efforts in trying to mechanize program verification [5], <ref> [13] </ref>, [14]. Unfortunately, it has been shown that it is impossible in principle to design a decision procedure which decides automatically the truth or falsehood of an arbitrary (mathematical) statement [41]. However, the non-existence of a general decision procedure only shows that one cannot prove everything automatically.
Reference: [14] <author> M.J.C. Gordon. </author> <title> Programming Language Theory and its Implementation. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1988. </year>
Reference-contexts: And it is very easy to make little mistakes which may lead to not being able to show that the program meets its specifications. Because of the tedious nature of manual proofs, there have been many efforts in trying to mechanize program verification [5], [13], <ref> [14] </ref>. Unfortunately, it has been shown that it is impossible in principle to design a decision procedure which decides automatically the truth or falsehood of an arbitrary (mathematical) statement [41]. However, the non-existence of a general decision procedure only shows that one cannot prove everything automatically.
Reference: [15] <author> D. Gu, D.J. Rosenkrantz, and S.S. Ravi. </author> <title> Determining performance measures of algorithm-based fault-tolerant systems. </title> <journal> J. of Parallel and Distributed Comp., </journal> <volume> 18(1) </volume> <pages> 56-70, </pages> <year> 1993. </year> <month> 151 </month>
Reference-contexts: Section F provides an example of how this form of assessment can be used in an error-detecting matrix relaxation algorithm. B. TERMINOLOGY FOR MPS TOPOLOGIES In this chapter we examine fixed-topology multiprocessor systems as discussed in [11], [17], [28], [46]. In contrast to <ref> [15] </ref> we do not examine whether an algorithm can detect all combinations of up to k faults, where k is a specified bound, but we assume that the algorithm has been designed with a certain local fault tolerance t l , for each communication 124 environment [37]. The analysis in [15] <p> <ref> [15] </ref> we do not examine whether an algorithm can detect all combinations of up to k faults, where k is a specified bound, but we assume that the algorithm has been designed with a certain local fault tolerance t l , for each communication 124 environment [37]. The analysis in [15] can determine whether every combination of up to t l faults can be detected, and it provides the minimum number of simultaneous faults for which this condition does not hold any more.
Reference: [16] <author> R.W. </author> <title> Hamming. Error detecting and error correcting codes. </title> <journal> Bell Syst. Tech. J., </journal> <volume> 29 </volume> <pages> 147-160, </pages> <month> April </month> <year> 1950. </year>
Reference-contexts: Specifically, for d = 3, B (n; 3) = 2 m n + 1 according to <ref> [16] </ref>. This provides an upper bound for the maximal fault index. An example for a 3-cube where a set of two faulty nodes which do not interfere with each others' computations and communications are marked is given in Figure 26 (left).
Reference: [17] <author> J. Hayes. </author> <title> A graph model for fault-tolerant computing systems. </title> <journal> IEEE Trans. On Computers, </journal> <volume> C-25:875-883, </volume> <month> September </month> <year> 1976. </year>
Reference-contexts: Section F provides an example of how this form of assessment can be used in an error-detecting matrix relaxation algorithm. B. TERMINOLOGY FOR MPS TOPOLOGIES In this chapter we examine fixed-topology multiprocessor systems as discussed in [11], <ref> [17] </ref>, [28], [46].
Reference: [18] <author> N. Heintze, J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> The CLP(R) Programmer's Manual, </title> <type> Version 1.2. </type> <institution> IBM Thomas J. Watson Research Center, </institution> <year> 1992. </year>
Reference-contexts: Thus, the result file will contain only the program listing itself and all non-subsumable assertions. 5. CLP (R). CLP (R) is a simple theorem prover, using PROLOG-like syntax. It is implemented in C and available for UNIX systems <ref> [18] </ref>. Since the platform we use for the execution of our CSP programs allows only for assertions in propositional calculus rather than predicate calculus, we also restrict the use of CLP (R) to the use of propositional expressions. <p> Because of that, it was decided to help with the generation of assertions for these two types of constructs by using the CLP (R) prover <ref> [18] </ref>. As discussed before, certain format requirements have to be met when the assertions are transformed into CLP (R) input format. As an input file, CLP (R) takes the assertions which are necessary for the generation of the preconditions, generally post-assertions immediately following the branching/looping conditions.
Reference: [19] <author> D. Heydtmann. </author> <title> Subsumption in modal logic. M.S. </title> <type> Thesis, </type> <institution> Computer Science Department, University of Missouri-Rolla, </institution> <year> 1993. </year>
Reference-contexts: We will then discuss the model that can be used to generate efficient error-detecting algorithms, the model of temporal subsumption. This will be introduced first as a theoretical model, and later tailored towards the actual language used. Concurrently with the work described here, <ref> [19] </ref> provided a summary for subsumption in modal logic, which is closely related to the subsumption model introduced here. Details of this work are discussed in the chapter of this dissertation which introduces our subsumption model. <p> TEMPORAL SUBSUMPTION In this chapter we first give a brief overview about other work done in this area and how it relates to the results presented here. The work in subsumption that is described in <ref> [19] </ref>, and which appears to be the only other work in this area, is a very general model which is not directly applicable to program verification and the methods described here. <p> Subsumption has long been known as a technique to detect redundant clauses in the search space of automated deduction systems for classical first order logics. Because of the need to develop similar techniques for non-classical modal logics, <ref> [19] </ref> examined how subsumption can be made to work in the context of these modal logic deduction systems. Modal logics, such as temporal logic, reason about possible worlds, i.e. not every statement made will be true all the time but only in certain specific worlds. <p> Paths can lead from one world to the next, and, depending on the path selected, different truths can be shown. Thus, it is easy to see that whatever needs to be proven depends on a specific path, and a logic called World Path Logic (WPL) is introduced in <ref> [19] </ref> as a possible target language in which a proof can be done. In his paper, [19] then continues to develop a subsumption model which will work in this environment. For more details, the reader is asked to refer directly to the material presented in [19]. <p> Thus, it is easy to see that whatever needs to be proven depends on a specific path, and a logic called World Path Logic (WPL) is introduced in <ref> [19] </ref> as a possible target language in which a proof can be done. In his paper, [19] then continues to develop a subsumption model which will work in this environment. For more details, the reader is asked to refer directly to the material presented in [19]. <p> Logic (WPL) is introduced in <ref> [19] </ref> as a possible target language in which a proof can be done. In his paper, [19] then continues to develop a subsumption model which will work in this environment. For more details, the reader is asked to refer directly to the material presented in [19]. It can easily be seen how this concept of sequences of worlds and paths connecting them could be related to programs and the program statements which are also connected by "paths" through the program. The approach by [19], although more abstract since it deals only with modal logics as such, <p> the reader is asked to refer directly to the material presented in <ref> [19] </ref>. It can easily be seen how this concept of sequences of worlds and paths connecting them could be related to programs and the program statements which are also connected by "paths" through the program. The approach by [19], although more abstract since it deals only with modal logics as such, was developed concurrently at UMR with the approach 24 presented in this dissertation. In contrast to the work by [19], the model presented in this work deals specifically with distributed programs and describes a very different approach for <p> The approach by <ref> [19] </ref>, although more abstract since it deals only with modal logics as such, was developed concurrently at UMR with the approach 24 presented in this dissertation. In contrast to the work by [19], the model presented in this work deals specifically with distributed programs and describes a very different approach for generating subsumption rules as they are very closely linked to the application, distributed programs. B.
Reference: [20] <author> C. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <year> 1969. </year>
Reference-contexts: These assertions characterize properties of program variables and relationships between them at various stages of the program execution. Program verification requires proofs of theorems of the following type: fP gSfQg where P is said to be the pre-condition and Q the post-condition of the statement S <ref> [20] </ref>. The details about the axiomatic approach are contained in Section B. Using this approach we can generate assertions for each program statement, based on a pre-condition for the program. <p> P is said to be the pre-condition and Q the post-condition of S <ref> [20] </ref>. A sequence of statements, S, is partially correct with respect to the pre-condition P and a post-condition Q, if, whenever P is true prior to the execution of S, and if S terminates, then Q is true after S terminates. <p> In addition, we have statement-independent inference rules which describe the interaction between processes or make statements about sequences of statements. The following rules and axioms are common to all the axiomatic systems and apply to reasoning about sequential programs based on <ref> [20] </ref>. 1 This means that they take into account the actions taken by some other process. 12 A proof outline for the composition of two statements can be derived from proofs for each of its components. fP gS 1 fQg; fQgS 2 fRg fP gS 1 ; S 2 fRg When <p> For more detail on how assertions can be determined from a program using axiomatic semantics see <ref> [20] </ref> and [29]). To reduce the number of assertions that need to be examined as candidates for (V; S)- subsumption, we want to divide the program into parts that can be examined independently.
Reference: [21] <author> C. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <year> 1978. </year>
Reference-contexts: A simple approach is to take a sequential language and add the appropriate communication commands. We can thus create a programming language that allows for executing programs in a distributed environment. Hoare's model of concurrent programming, Communicating Sequential Processes (CSP) <ref> [21] </ref>, is such a language. It is examined and explained in Section A. For the remainder of this work, we will continue to use CSP as the main language to write our distributed programs. <p> Using this approach we can generate assertions for each program statement, based on a pre-condition for the program. The sequential execution of the individual programs, and the interactions with other programs, will hopefully lead to the desired post-condition A. CSP Communicating Sequential Processes (CSP) <ref> [21] </ref>, is a model reflecting properties that should be present in all concurrent programming languages. It was not intended to be used as a programming language per se, but it does reflect Hoare's concerns for proving the 8 correctness of programs. <p> However, CSP has provided a medium of discussion of synchronous systems and has inspired a great deal of development. CSP was proposed as a preliminary solution to the problem of defining a synchronous message-based language. Hoare suggested in <ref> [21] </ref>, that there are three properties that every concurrent language should have: the ability to express parallelism, communication primitives and non-determinism. This section provides an informal brief description of the syntax and meaning of CSP commands. Full details of CSP are contained in [21]. <p> Hoare suggested in <ref> [21] </ref>, that there are three properties that every concurrent language should have: the ability to express parallelism, communication primitives and non-determinism. This section provides an informal brief description of the syntax and meaning of CSP commands. Full details of CSP are contained in [21]. A CSP program consists of a static collection of processes. The basic command of CSP is [ 1 k:::k n ], expressing concurrent execution of the sequential processes 1 ; :::; n . Each individual process i has a distinct address space and consists of statements S i .
Reference: [22] <author> K Huang and J. Abraham. </author> <title> Fault-tolerant algorithms and their applications to solving laplace equations. </title> <booktitle> Proceedings of the 1984 International Conference on Parallel Processing, </booktitle> <pages> pages 117-122, </pages> <month> August, </month> <year> 1984. </year>
Reference-contexts: Recovery and reconfiguration are different issues which are not discussed here. 18 Work in concurrent detection methods includes self-checking software [53] and recovery blocks [45], which instrument the software with assertions on the program's state, watchdog processor [36], which monitors intermediate data of a computation, and algorithm-based fault tolerance <ref> [22] </ref> which imposes an additional structure on the data to detect errors. These methods define the structure for fault tolerance, but do not, generally, give a methodology for instantiating this structure.
Reference: [23] <author> R. Hummel and S. Zucker. </author> <title> On the foundations of relaxation labeling processes. </title> <journal> PAMI, </journal> <volume> PAMI-5(3):267-287, </volume> <month> May </month> <year> 1984. </year>
Reference-contexts: Iterative Relaxation. Iterative relaxation is one of the fundamental computation methods. Relaxation can be used in such diverse problem ranging from relaxation labeling <ref> [23] </ref> in distributed scene analysis to computational partial differential equation solvers [38].
Reference: [24] <author> M. Insall and K. Ngo. </author> <title> Probabilistic logic and software assurance. </title> <note> 1994. unpublished manuskript. </note>
Reference-contexts: are weakened? How much fault detection latency will be introduced because of this? How much deviation from the mathematically expected solution is acceptable? How probable is it that a program whose assertions are weakened will actually produce the correct solution? Some initial work in this area has been described in <ref> [24] </ref>. These issues deal directly with the operational environment and should be addressed for the next generation of algorithms that use assertions for error detection. 148 APPENDIX JUSTIFICATION OF THE GENERAL SUBSUMPTION RULE In Definitions III.9 and III.10 we introduce two different notations for subsumption.
Reference: [25] <author> J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> The CLP(R) language and system. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(3) </volume> <pages> 339-395, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: The individual parts of the tool are as follows: * a scanner * a program flow graph generator * the graph traversal algorithm * the actual subsumption rules for the different program statements 70 * CLP (R), an automated theorem prover <ref> [25] </ref>. We will now discuss the individual roles of the different parts in the overall approach, as well as the design specifications. 1. Scanner. The scanner used for the subsumption tool is written using the UNIX programming tool lex [30].
Reference: [26] <author> J. Jou and J. Abraham. </author> <title> Fault-tolerant matrix arithmetic and signal processing on highly parallel computing structures. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 74(5) </volume> <pages> 732-741, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: Only when the actual computation is compared with the expected results are we able to determine that an error occurred in the computation process. As described in <ref> [26] </ref> and [38], we can use assertions to detect hardware, communication and software errors at run-time. <p> A fault-tolerant mapping of the nodes onto a smaller set of processors is given in Figure 26 (right). F. A SPECIFIC EXAMPLE OF AN ERROR-DETECTING ALGORITHM Error-detecting algorithms work by checking, at run time, for hardware, communication <ref> [26] </ref>, and software errors [38]. These algorithms can be generated by using executable assertions for error detection [34], [1]. Assertions can, for example, be obtained from program verification.
Reference: [27] <author> J. Laprie and B. Littlewood. </author> <title> Probabilistic assessment of safety-critical software: </title> <journal> Why and how? Communications of the ACM, </journal> <volume> 35(2) </volume> <pages> 13-21, </pages> <year> 1992. </year>
Reference-contexts: Thus, in addition to error detection, we need to preserve the original timeliness properties of the system and thus generate a method that performs program checks efficiently. C. ALGORITHMS FOR SAFETY-CRITICAL SYSTEMS It is important for safety-critical distributed systems to meet their specification at run time <ref> [27] </ref>. Large, complex, distributed systems, are subject to individual component failures which can cause system failures. Since safety-critical systems generally govern very complex tasks that cannot be completely controlled by humans alone, they generally fall into this category. <p> This is the non-interference property of [42]. C. OPERATIONAL EVALUATION It is important for both life-critical, and non-life-critical distributed systems, to meet their specification at run time <ref> [27] </ref>. Large, complex, distributed systems are subject to individual component failures which can cause system failures. Fault tolerance is an important technique to improve system reliability. The fault detection aspect identifies individual faulty components (processors) before they can negatively affect overall system reliability.
Reference: [28] <author> T. Leighton and C. Leierson. </author> <title> Wafer-scale integration of systolic arrays. </title> <journal> IEEE Trans. On Computers, </journal> <volume> C-34:448-461, </volume> <month> May </month> <year> 1985. </year>
Reference-contexts: Section F provides an example of how this form of assessment can be used in an error-detecting matrix relaxation algorithm. B. TERMINOLOGY FOR MPS TOPOLOGIES In this chapter we examine fixed-topology multiprocessor systems as discussed in [11], [17], <ref> [28] </ref>, [46].
Reference: [29] <author> G.M. Levin and D. Gries. </author> <title> A proof technique for communicating sequential processes. </title> <journal> Acta Informatica, </journal> <volume> 15 </volume> <pages> 281-302, </pages> <year> 1981. </year>
Reference-contexts: Part one consists of the sequential proofs of each individual process that makes assumptions about the effects of the communication commands. The second part is to ensure that the assumptions are "legitimate." 1 This first approach is taken in [3] and <ref> [29] </ref>. The second approach allows us to prove properties of the individual processes using the axioms and rules of inference applicable to the statements in the individual processes. <p> However, there are very different approaches to the verification of a program and their applicability in a practical environment. The proof system presented in <ref> [29] </ref> was selected and will be used extensively in this paper for its relative ease of use. 2. Axioms and Inference Rules Used For Sequential Reasoning. In addition to the axioms and inference rules of predicate logic, there exists one axiom or inference rule for each type of statement. <p> Otherwise, unrestricted use of auxiliary variables would destroy the soundness of the proof system. Hence, auxiliary variables are not necessary to the computation, but they are necessary for verification. The proof system in <ref> [29] </ref> allows for auxiliary variables to be global i.e. variables that can be shared between distinct processes. Global auxiliary variables (GAVs) are used to record part of the history of the communication sequence. Shared reference to auxiliary 17 variables allows for assertions relating the different communication sequences. <p> For more detail on how assertions can be determined from a program using axiomatic semantics see [20] and <ref> [29] </ref>). To reduce the number of assertions that need to be examined as candidates for (V; S)- subsumption, we want to divide the program into parts that can be examined independently. In general, we want these sections to be enclosed by a forward and a backward concurrency 31 point.
Reference: [30] <author> J.R. Levine, T. Mason, and D. Brown. </author> <title> lex & yacc. </title> <publisher> O'Reilly & Associates, Inc., </publisher> <address> 2nd edition, </address> <year> 1992. </year>
Reference-contexts: We will now discuss the individual roles of the different parts in the overall approach, as well as the design specifications. 1. Scanner. The scanner used for the subsumption tool is written using the UNIX programming tool lex <ref> [30] </ref>. As input, it takes a program listing written in CSP and provides as an output the list of program statements, the assertions, and the line numbers for all statements.
Reference: [31] <author> D.W. Loveland. </author> <title> Automated Theorem Proving, </title> <booktitle> chapter 4. Number 6 in Fundamental Studies in Computer Science. </booktitle> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1978. </year> <month> 152 </month>
Reference-contexts: In the (automated reasoning) literature, subsumption is defined as follows <ref> [31] </ref>: Definition III.9 A clause C subsumes a clause D if and only if 8C ! 8D is valid, and 8C is the notation for the universal closure of the clause C.
Reference: [32] <author> H. Lutfiyya. </author> <title> Fault tolerance in concurrent systems through formal methods. </title> <type> Ph.D Thesis, </type> <institution> Computer Science Department, University of Missouri-Rolla, </institution> <year> 1992. </year>
Reference-contexts: A detailed survey of techniques for providing hardware as well as software implemented fault tolerance in distributed systems has been given in <ref> [32] </ref>. B. ERROR-DETECTING ALGORITHMS The first step in determining that an algorithm is not providing the results that are expected due to an error, is the verification of the computation at run-time.
Reference: [33] <author> H. Lutfiyya and B. McMillin. </author> <title> Comparison of three axiomatic proof systems. </title> <institution> UMR Department of Computer Science Technical Report CSC 91-13, </institution> <year> 1991. </year>
Reference-contexts: The properties of the sequential program are then used to prove properties of the entire program. This is the approach of [49]. The work given in <ref> [33] </ref> shows that it is irrelevant which axiomatic proof system for program verification is chosen. This is due to the axiomatic systems being equivalent in the sense that they allow us to prove the same properties and that no system is more powerful than the other.
Reference: [34] <author> H. Lutfiyya, M. Schollmeyer, and B. McMillin. </author> <title> Fault-tolerant distributed sort generated from a verification proof outline. </title> <booktitle> 2nd Responsive Systems Symposium, 1992. </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: A properly chosen set of assertions, such as those generated from program verification, guarantees that, when operationally evaluated, the program meets its specification <ref> [34] </ref>. This set of assertions can then be transformed into executable assertions which are embedded into the program code and executed at run-time together with the actual program. <p> F. A SPECIFIC EXAMPLE OF AN ERROR-DETECTING ALGORITHM Error-detecting algorithms work by checking, at run time, for hardware, communication [26], and software errors [38]. These algorithms can be generated by using executable assertions for error detection <ref> [34] </ref>, [1]. Assertions can, for example, be obtained from program verification. A properly chosen set of assertions guarantees that, when operationally 138 evaluated, such as in Changeling [34], the program meets its specifications or an error will be flagged. <p> These algorithms can be generated by using executable assertions for error detection <ref> [34] </ref>, [1]. Assertions can, for example, be obtained from program verification. A properly chosen set of assertions guarantees that, when operationally 138 evaluated, such as in Changeling [34], the program meets its specifications or an error will be flagged. In general, we add executable assertions after each statement, which then verify that the previous statement was executed correctly. In case of an error, the assertions can force the program to halt execution to indicate the faulty condition. <p> The desired topology of the interconnection network for this computation is a two-dimensional mesh. The data exchange pattern for this algorithm corresponds to a 139 communication with all adjacent processors in the mesh, which we described in Section b as the star pattern. 2. Error-Detecting Matrix Relaxation. Using Changeling <ref> [34] </ref>, a program verification proof outline based on axiomatic semantics 1 is used to construct an error-detecting matrix relaxation. <p> By checking the different versions that arrive on these paths <ref> [34] </ref>, each processor in the CE must receive identical versions of a sent message or will detect an error if inconsistencies 1 Axiomatic semantics provide formal statements about the effect of executing a program.
Reference: [35] <author> H. Lutfiyya, M. Schollmeyer, and B. McMillin. </author> <title> Formal generation of executable assertions for application-oriented fault tolerance. </title> <type> Technical Report CSC 92-15, </type> <institution> UMR Department of Computer Science, </institution> <year> 1992. </year>
Reference-contexts: Thus, GAVs are treated as local variables in each process and become known to other processes only when they are communicated instead of being communicated and known instantaneously. This is possible due to the non-interference of the sequential proofs <ref> [35] </ref>. Since this delay of the communication of the 'global' knowledge contained in the GAVs retains the soundness and (relative) completeness of the proof system used for the verification proof, we can use the same boundaries here for the (V; S)-subsumption. <p> This lemma follows directly from the reasoning above and <ref> [35] </ref>. During program execution, and thus in a proof outline, only few variable values or relationships change from program step to program step. <p> From this substitution, immediately the above theorem follows. fl We again introduce concurrency points as subsumption boundaries. This is based on efficiency reasons as well as error-detecting ability and the soundness and completeness of the proof system used <ref> [35] </ref>. We want to verify the correct execution of each statement, and we also want to ensure that data that was obtained from other processes meets its specifications and that the current states are permitted states.
Reference: [36] <author> A. Mahmood, E. McCluskey, and D. Lu. </author> <title> Concurrent fault detection using a watchdog processor and assertions. </title> <booktitle> IEEE 1983 International Test Conference, </booktitle> <pages> pages 622-628, </pages> <year> 1983. </year>
Reference-contexts: Recovery and reconfiguration are different issues which are not discussed here. 18 Work in concurrent detection methods includes self-checking software [53] and recovery blocks [45], which instrument the software with assertions on the program's state, watchdog processor <ref> [36] </ref>, which monitors intermediate data of a computation, and algorithm-based fault tolerance [22] which imposes an additional structure on the data to detect errors. These methods define the structure for fault tolerance, but do not, generally, give a methodology for instantiating this structure.
Reference: [37] <author> B. McMillin. </author> <title> Reliable parallel processing: The application-oriented paradigm. </title> <type> Ph.D Thesis, </type> <institution> Computer Science Department, Michigan State University, </institution> <year> 1988. </year>
Reference-contexts: In contrast to [15] we do not examine whether an algorithm can detect all combinations of up to k faults, where k is a specified bound, but we assume that the algorithm has been designed with a certain local fault tolerance t l , for each communication 124 environment <ref> [37] </ref>. The analysis in [15] can determine whether every combination of up to t l faults can be detected, and it provides the minimum number of simultaneous faults for which this condition does not hold any more.
Reference: [38] <author> B. McMillin and L. Ni. </author> <title> Executable assertion development for the distributed parallel environment. </title> <booktitle> Proceedings of the 12th International COMPSAC, </booktitle> <pages> pages 284-291, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Only when the actual computation is compared with the expected results are we able to determine that an error occurred in the computation process. As described in [26] and <ref> [38] </ref>, we can use assertions to detect hardware, communication and software errors at run-time. Definition I.1 An assertion is a logical expression which is constructed from boolean expressions using boolean connectives and quantifiers (8; 9) over some variables that appear in the expressions, and which forms a well-formed formula. <p> A fault-tolerant mapping of the nodes onto a smaller set of processors is given in Figure 26 (right). F. A SPECIFIC EXAMPLE OF AN ERROR-DETECTING ALGORITHM Error-detecting algorithms work by checking, at run time, for hardware, communication [26], and software errors <ref> [38] </ref>. These algorithms can be generated by using executable assertions for error detection [34], [1]. Assertions can, for example, be obtained from program verification. <p> Iterative Relaxation. Iterative relaxation is one of the fundamental computation methods. Relaxation can be used in such diverse problem ranging from relaxation labeling [23] in distributed scene analysis to computational partial differential equation solvers <ref> [38] </ref>.
Reference: [39] <author> B. McMillin and L. Ni. </author> <title> Reliable distributed sorting through the application-oriented fault tolerance paradigm. </title> <journal> IEEE Trans. of Parallel and Distributed Computing, </journal> <volume> 3(4) </volume> <pages> 411-420, </pages> <year> 1992. </year>
Reference-contexts: These methods define the structure for fault tolerance, but do not, generally, give a methodology for instantiating this structure. Application-oriented fault tolerance <ref> [39] </ref>, by contrast, provides a heuristic approach, based on the "Natural Constraints," to choosing executable assertions from the software specification. These executable assertions [53] are inserted in the form of source language statements into a program for monitoring the run-time execution behavior of the program. <p> For simplification, we will focus only on processor failures, since a processor failure can be described by the failure of all its links, and a link failure can be described by indicating a processor failure <ref> [39] </ref>. We assume the worst-case fault model of Byzantine (malicious) behavior where a faulty process can lose or modify messages. We can check for lost messages as well as inconsistency of the data by sending multiple copies of the same message through node-disjoint paths.
Reference: [40] <author> A. Mili. </author> <title> Self-checking programs: An axiomatisation of program validation by executable assertions. </title> <booktitle> Proceedings of the 11th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 118-120, </pages> <year> 1981. </year>
Reference-contexts: This set of assertions can then be transformed into executable assertions which are embedded into the program code and executed at run-time together with the actual program. Mili <ref> [40] </ref> was the first to notice the relationship between program verification and fault tolerance of a program through software specified executable assertions. However, his approach was designed for the sequential verification environment. The development of executable assertions for a program in the distributed environment is more complex.
Reference: [41] <author> E. Nagel and J.R. Newman. </author> <title> Godel's Proof. </title> <publisher> Routledge & Kegan Paul, </publisher> <address> London, </address> <year> 1959. </year>
Reference-contexts: Unfortunately, it has been shown that it is impossible in principle to design a decision procedure which decides automatically the truth or falsehood of an arbitrary (mathematical) statement <ref> [41] </ref>. However, the non-existence of a general decision procedure only shows that one cannot prove everything automatically. Many of the simpler tasks encountered in program verification can be relatively easily automated. <p> Thus, proofs of theorems tend to be long, difficult to read, and at times even impossible to provide. Thus, using a theorem prover for proving a program correct may not be the best approach, and in light of <ref> [41] </ref>, it may actually be impossible. In contrast to the theorem prover, a proof checker examines the proof given to it, using the rules indicated and determines whether the proof can be obtained using this particular method.
Reference: [42] <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: This necessitates a Proof of Non-interference which consists of showing that for each assertion P in process i , it must be shown that P is invariant over any parallel execution. This is the non-interference property of <ref> [42] </ref>. C. OPERATIONAL EVALUATION It is important for both life-critical, and non-life-critical distributed systems, to meet their specification at run time [27]. Large, complex, distributed systems are subject to individual component failures which can cause system failures. Fault tolerance is an important technique to improve system reliability.
Reference: [43] <author> S. Owre, J.M. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification syten. </title> <editor> In Deepak Kapur, editor, </editor> <booktitle> 11th International Conference on Automated Deduction (CADE), volume 607 of Lecture Notes in Computer Science, </booktitle> <pages> pages 748-752. </pages> <publisher> Springer Verlag, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Since the proof checker works under the guidance of the human rather than completely independently, different approaches can be suggested about the proof at hand, thus making the proving process interactive. One recent proof checker, PVS, was developed at SRI International for the explicit purpose of proving programs correct <ref> [43] </ref>. It provides reasoning about Hoare-triples using pre- and post-assertions with a matching program statement. B. SUBSUMPTION AND COMPLETE PROOFS Temporal subsumption on a program removes redundant assertions from the proof outline so that information that has been verified previously does not have to be verified again.
Reference: [44] <author> P. Ramanathan and S. Chalasani. </author> <title> Resource placement in k-ary n-cubes. </title> <booktitle> Proc. Intern. Conf. on Parallel Processing, </booktitle> <address> II:133-140, </address> <year> 1992. </year>
Reference-contexts: For P faulty and t l = 1, none of these processors must be faulty. In the ideal case we obtain a distribution of faulty processors that is identical to the perfect 1-adjacency placement of resources, where each non-resource node is adjacent to exactly one resource <ref> [44] </ref>, which in our case is a faulty component. [44] show that the number of resource nodes in a k-ary n-cube for perfect 1-adjacency is X = k n =(2n + 1); k &gt; 2 which must be an integer. <p> In the ideal case we obtain a distribution of faulty processors that is identical to the perfect 1-adjacency placement of resources, where each non-resource node is adjacent to exactly one resource <ref> [44] </ref>, which in our case is a faulty component. [44] show that the number of resource nodes in a k-ary n-cube for perfect 1-adjacency is X = k n =(2n + 1); k &gt; 2 which must be an integer.
Reference: [45] <author> B. Randall. </author> <title> System structure for software fault tolerance. </title> <journal> IEEE Transactions of Software Engineering, </journal> <volume> SE-1(2):220-232, </volume> <year> 1975. </year> <month> 153 </month>
Reference-contexts: This paper focuses only on the most difficult part of the process, the detection of the occurrence of errors. Recovery and reconfiguration are different issues which are not discussed here. 18 Work in concurrent detection methods includes self-checking software [53] and recovery blocks <ref> [45] </ref>, which instrument the software with assertions on the program's state, watchdog processor [36], which monitors intermediate data of a computation, and algorithm-based fault tolerance [22] which imposes an additional structure on the data to detect errors.
Reference: [46] <author> A. Rosenberg. </author> <title> The diogenes approach to testable fault-tolerant arrays of processors. </title> <journal> IEEE Trans. On Computers, </journal> <volume> C-32:902-910, </volume> <month> October </month> <year> 1983. </year>
Reference-contexts: Section F provides an example of how this form of assessment can be used in an error-detecting matrix relaxation algorithm. B. TERMINOLOGY FOR MPS TOPOLOGIES In this chapter we examine fixed-topology multiprocessor systems as discussed in [11], [17], [28], <ref> [46] </ref>.
Reference: [47] <author> M. Schollmeyer, H. Lutfiyya, and B. McMillin. </author> <title> An algorithm for generating executable assertions for fault tolerance. </title> <institution> UMR Department of Computer Science Technical Report CSC 92-01, </institution> <year> 1992. </year>
Reference-contexts: Global variables are declared in all processes that are participating in the communication, and any changes made to a global variable in a single process have to be distributed to all other processes. CCSP allows for the use of global auxiliary variables based on the HAA system <ref> [47] </ref>, where the communication of the GAVs is piggy-backed on top of regular communication between processes. Of course, it is easy to see that the communication of GAVs can add baggage to the run-time of a CSP program.
Reference: [48] <author> M. Schollmeyer and B. McMillin. </author> <title> A general method for maximizing the error-detecting ability of distributed algorithms. </title> <institution> UMR Department of Computer Science Technical Report CS-93-16, </institution> <year> 1993. </year>
Reference-contexts: The proof for Lemma VIII.2 is given in <ref> [48] </ref>.
Reference: [49] <author> N. Soundararahan. </author> <title> Axiomatic semantics of communicating sequential processes. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(6) </volume> <pages> 647-662, </pages> <year> 1984. </year>
Reference-contexts: The properties of the sequential program are then used to prove properties of the entire program. This is the approach of <ref> [49] </ref>. The work given in [33] shows that it is irrelevant which axiomatic proof system for program verification is chosen.
Reference: [50] <author> S. Tsai. </author> <title> Providing assurance for responsive computing systems. </title> <type> Ph.D Thesis, </type> <institution> Computer Science Department, University of Missouri-Rolla, </institution> <year> 1994. </year>
Reference-contexts: It would thus be a straight forward goal to extend the subsumption model developed here to deal with temporal logic, and specifically with temporal logic describing expected program behavior, such as interval temporal logic <ref> [50] </ref>. Again, the goal would be to generate efficient error-detecting distributed algorithms for run-time assurance. However, subsumption of redundant assertions in this case might be able to guarantee the timeliness of response when error-detecting features are added to an existing responsive system.
Reference: [51] <author> J.G.G. van de Vorst. </author> <title> The formal development of a parallel program performing LU-decomposition. </title> <journal> Acta Informatica, </journal> <volume> 26(1-2):1-17, </volume> <month> Oct </month> <year> 1988. </year>
Reference-contexts: The programs listings provided are written in CSP. b. LU-Decomposition. As an example for a program that can become more computa-tionally expensive, we have included a program that performs the LU-decomposition of a matrix <ref> [51] </ref>. However, to keep the program simple, and since we do not want to use quantifiers, the example given limits itself to a 3x3 matrix. Again, the program is written in CSP, and the listing is given in Figure 12.
Reference: [52] <author> R. Yanney and J. Hayes. </author> <title> Distributed recovery in fault tolerance multiprocessor networks. </title> <booktitle> 4th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 514-525, </pages> <year> 1984. </year>
Reference-contexts: Early attempts at improving system reliability used fault-masking methods; these methods make the hardware tolerant of faults through the multiplicity of processing resources. In contrast, concurrent fault detection methods attempt to locate component errors which can lead to system failure. Once the faults are identified, reconfiguration and recovery <ref> [52] </ref> are used to deal with the fault. This paper focuses only on the most difficult part of the process, the detection of the occurrence of errors.

References-found: 52

