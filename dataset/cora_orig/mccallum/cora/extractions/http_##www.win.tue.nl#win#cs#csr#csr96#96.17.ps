URL: http://www.win.tue.nl/win/cs/csr/csr96/96.17.ps
Refering-URL: http://www.win.tue.nl/win/cs/csr/csr96.html
Root-URL: http://www.win.tue.nl
Title: Nested collections and polytypism  
Author: Eerke Boiten and Paul Hoogendijk 
Date: November 1996  
Abstract: A point-free calculus of so-called "collection types" is presented, similar to the monadic calculus of Tannen, Buneman and Wong. We observe that our calculus is parametrised by a monad thus making the calculus "polytypic". A novel contribution of the paper is to discuss situations in which a single application involves more than one collection type. In particular, we outline the contribution to database research that may be obtained by exploiting current developments in polytypic programming. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C.J. Aarts, R.C. Backhouse, P. Hoogendijk, T.S. Voermans, and J. van der Woude. </author> <title> A relational theory of datatypes. </title> <note> Available via anonymous ftp from ftp.win.tue.nl in directory pub/math.prog.construction, </note> <month> September </month> <year> 1992. </year>
Reference-contexts: nest L is an injective function, but unnest L is not its left inverse: 7 unnest L :nest L :[(a ; 5 ) ; (b ; 1 ) ; (a ; 7 )] = f definition nest L g unnest L :[(a ; [5 ; 7 ]) ; (b ; <ref> [1 ] </ref>) ; (a ; [5 ; 7 ])] = f definition unnest L g [(a ; 5) ; (a ; 7) ; (b ; 1) ; (a ; 5) ; (a ; 7)] One could argue that either the nest operation on lists should discard the duplicates (making it no <p> Thus, a set up of functors over partial functions with associated natural transformations was chosen. Large portions of equational (point-free) calculi for category theory, for (total) functions [19, 5], and for binary relations <ref> [1] </ref> are directly applicable to our calculus. Much of these will translate directly to well-known or possibly even new optimisations of (nested) relational database queries. The calculus instantiated to a single monad appears to be complete and well understood, cf. [7].
Reference: [2] <author> S. Abiteboul, C. Beeri, M. Gyssens, and D. van Gucht. </author> <title> An introduction to the completeness of languages for complex objects and nested relations. In Nested Relations and Complex Objects in Databases, </title> <booktitle> volume 361 of Lecture Notes in Computer Science, </booktitle> <pages> pages 117-138. </pages> <publisher> Springer Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Box 513, 5600 MB Eindhoven, The Netherlands, email:paulh@win.tue.nl. 1 (the so-called First Normal Form). Various "nested" relational calculi 1 (i.e. calculi pro-viding for set-valued attributes) have been proposed <ref> [20, 2, 9] </ref>.
Reference: [3] <author> R.C. Backhouse, H. Doornbos, and P. Hoogendijk. </author> <title> A class of commuting relators. </title> <booktitle> In Lecture Notes of the STOP 1992 Summer School on Constructive Algorithmics, Ame-land. STOP, </booktitle> <year> 1992. </year> <note> Available via anonymous ftp from ftp.win.tue.nl in directory pub/math.prog.construction. </note>
Reference-contexts: The importance of these differences has to do with the emerging interest in the area of so-called polytypic programs, the current focus of research in the BMF <ref> [3, 4, 11, 15, 12] </ref>. Such programs are parametrised by type constructors (as opposed to polymorphic programs which are parametrised by types). <p> A completely different class of useful operations for interfacing several data types is formed by operations that commute functors, i.e. that convert FG-structures into GF-structures. Our group has studied such operations <ref> [3] </ref>, and called them "zips", after the well known operator that turns a pair of lists of equal length into a list of pairs. The special case where G is the powerset functor P has been studied by de Moor [10] under the name of "cross operators". <p> Altogether, it seems that more research is needed into zips and other data type transformations before a more conclusive form of a query language with multiple collection types can be established. We expect that research done in formal program development on zips <ref> [3] </ref>, the Boom hierarchy [19, 14] of datatypes, and polytypic programming in general [4, 11, 15] will provide a basis for this further research. 6 Concluding remarks We have presented a monadic calculus for querying nested collections, inspired by (and in some sense equivalent to) the ones defined by Tannen, Buneman
Reference: [4] <author> Richard Bird, Oege de Moor, and Paul Hoogendijk. </author> <title> Generic functional programming with types and relations. </title> <journal> J. of Functional Programming, </journal> <volume> 6(1) </volume> <pages> 1-28, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: The importance of these differences has to do with the emerging interest in the area of so-called polytypic programs, the current focus of research in the BMF <ref> [3, 4, 11, 15, 12] </ref>. Such programs are parametrised by type constructors (as opposed to polymorphic programs which are parametrised by types). <p> comprehension, it is str P :(S ; x ) = f (y ; x ) j y 2 S g In general the strength of a functor F is a natural transformation from (FA) fi B to F (A fi B), which has interesting links with the concept of membership <ref> [4] </ref>. <p> This implies that for each such type F a polymorphic function (i.e., a natural transformation) setify F : PA FA exists. We could impose the existence of setify as an additional requirement on collection types - <ref> [4] </ref> gives a definition of setify F in terms of the membership relation of F, which is strongly related to the strength of F. So, within the current context, this may not be a severe restriction. <p> We expect that research done in formal program development on zips [3], the Boom hierarchy [19, 14] of datatypes, and polytypic programming in general <ref> [4, 11, 15] </ref> will provide a basis for this further research. 6 Concluding remarks We have presented a monadic calculus for querying nested collections, inspired by (and in some sense equivalent to) the ones defined by Tannen, Buneman and Wong [6, 7] and Trinder [23]. <p> Our partial answer to this question showed that this strongly relates to several issues currently studied in the area of formal program development, most importantly to polytypism <ref> [4] </ref>.
Reference: [5] <author> R.S. Bird. </author> <title> An introduction to the theory of lists. </title> <editor> In M. Broy, editor, </editor> <booktitle> Logic of Programming and Calculi of Discrete Design. NATO ASI Series Vol. F36, </booktitle> <pages> pages 5-42. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: The most important aspect of this so-called Boom hierarchy is that a calculus of higher order functions (like map, reduce and filter) can be defined on all its types. This calculus is commonly known as the Bird-Meertens Formalism (BMF) <ref> [19, 5] </ref>, and it is widely used for the development and description of functional and parallel [21] programs. <p> Our presentation was designed to connect theories from formal program development with the state of the art in database query languages. Thus, a set up of functors over partial functions with associated natural transformations was chosen. Large portions of equational (point-free) calculi for category theory, for (total) functions <ref> [19, 5] </ref>, and for binary relations [1] are directly applicable to our calculus. Much of these will translate directly to well-known or possibly even new optimisations of (nested) relational database queries. The calculus instantiated to a single monad appears to be complete and well understood, cf. [7].
Reference: [6] <author> V. Breazu-Tannen, P. Buneman, and L. Wong. </author> <title> Naturally embedded query languages. </title> <booktitle> In Proceedings of International Conference on Database Theory, volume 646 of Lecture Notes in Computer Science, </booktitle> <pages> pages 140-154, </pages> <address> Berlin, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Box 513, 5600 MB Eindhoven, The Netherlands, email:paulh@win.tue.nl. 1 (the so-called First Normal Form). Various "nested" relational calculi 1 (i.e. calculi pro-viding for set-valued attributes) have been proposed [20, 2, 9]. The most general of these is the "monadic" calculus described by Tannen, Buneman and Wong <ref> [6, 22] </ref>. (The observation that collection types "are" monads with additional properties ("ringads") can be attributed to Wadler [24] and Trinder [23].) They prove that their calculus (using the set monad) is equivalent to "the" nested relational calculus [9]. <p> This equals the calculus M [ (= ; cond) of Tannen et al <ref> [6, 7] </ref>, whose expressive power equals that of the nested relational algebra with equality test [20], see [6, 7] for a proof. An important property of this calculus is that the complexity of a query is exponential in the size of its input. <p> This equals the calculus M [ (= ; cond) of Tannen et al <ref> [6, 7] </ref>, whose expressive power equals that of the nested relational algebra with equality test [20], see [6, 7] for a proof. An important property of this calculus is that the complexity of a query is exponential in the size of its input. <p> Thus, a monadic calculus of this form can be defined for any strong ringad. Important examples of these are lists and bags with their obvious (certainly for Boom hierarchy adepts) operations. For this reason, Trinder [23] and Tannen et al <ref> [6, 22] </ref> have argued that strong ringads describe the essence of so-called bulk- or collection types in databases. As an aside, not all operations defined above generalise from sets to other collection types all that well. Consider for example nesting/unnesting on lists, where L is the list functor. <p> hierarchy [19, 14] of datatypes, and polytypic programming in general [4, 11, 15] will provide a basis for this further research. 6 Concluding remarks We have presented a monadic calculus for querying nested collections, inspired by (and in some sense equivalent to) the ones defined by Tannen, Buneman and Wong <ref> [6, 7] </ref> and Trinder [23]. Our presentation was designed to connect theories from formal program development with the state of the art in database query languages. Thus, a set up of functors over partial functions with associated natural transformations was chosen.
Reference: [7] <author> P. Buneman, S. Naqvi, V. Tannen, and L. Wong. </author> <title> Principles of programming with complex objects and collection types. </title> <note> Theoretical Computer Science. To appear. </note>
Reference-contexts: This equals the calculus M <ref> [ (= ; cond) of Tannen et al [6, 7] </ref>, whose expressive power equals that of the nested relational algebra with equality test [20], see [6, 7] for a proof. <p> This equals the calculus M [ (= ; cond) of Tannen et al <ref> [6, 7] </ref>, whose expressive power equals that of the nested relational algebra with equality test [20], see [6, 7] for a proof. An important property of this calculus is that the complexity of a query is exponential in the size of its input. <p> This equals the calculus M [ (= ; cond) of Tannen et al <ref> [6, 7] </ref>, whose expressive power equals that of the nested relational algebra with equality test [20], see [6, 7] for a proof. An important property of this calculus is that the complexity of a query is exponential in the size of its input. <p> nest P = id : For lists nest L is an injective function, but unnest L is not its left inverse: 7 unnest L :nest L :[(a ; 5 ) ; (b ; 1 ) ; (a ; 7 )] = f definition nest L g unnest L :[(a ; <ref> [5 ; 7 ] </ref>) ; (b ; [1 ]) ; (a ; [5 ; 7 ])] = f definition unnest L g [(a ; 5) ; (a ; 7) ; (b ; 1) ; (a ; 5) ; (a ; 7)] One could argue that either the nest operation on lists <p> function, but unnest L is not its left inverse: 7 unnest L :nest L :[(a ; 5 ) ; (b ; 1 ) ; (a ; 7 )] = f definition nest L g unnest L :[(a ; <ref> [5 ; 7 ] </ref>) ; (b ; [1 ]) ; (a ; [5 ; 7 ])] = f definition unnest L g [(a ; 5) ; (a ; 7) ; (b ; 1) ; (a ; 5) ; (a ; 7)] One could argue that either the nest operation on lists should discard the duplicates (making it no longer injective since order information <p> hierarchy [19, 14] of datatypes, and polytypic programming in general [4, 11, 15] will provide a basis for this further research. 6 Concluding remarks We have presented a monadic calculus for querying nested collections, inspired by (and in some sense equivalent to) the ones defined by Tannen, Buneman and Wong <ref> [6, 7] </ref> and Trinder [23]. Our presentation was designed to connect theories from formal program development with the state of the art in database query languages. Thus, a set up of functors over partial functions with associated natural transformations was chosen. <p> Much of these will translate directly to well-known or possibly even new optimisations of (nested) relational database queries. The calculus instantiated to a single monad appears to be complete and well understood, cf. <ref> [7] </ref>. However, having the monad (functor) as an explicit parameter induces the question of how these calculi could be combined for several monads, leading to a query language for databases involving multiple collection types.
Reference: [8] <author> E.F. Codd. </author> <title> A relational model for large shared databank. </title> <journal> Communications of the ACM, </journal> <volume> 13(6) </volume> <pages> 377-387, </pages> <year> 1970. </year>
Reference-contexts: This provided a new syntax and calculus for comprehensions on these types. In the area of databases, the interest in these types arises from the quest for query languages for databases containing structured data. The traditional "flat" relational database model <ref> [8] </ref> only describes sets of tuples, whose attributes are assumed to be of atomic type fl Now at Computing Laboratory, University of Kent, Canterbury Kent CT2 7NF, UK, email: E.A.Boiten@ukc.ac.uk; research was carried out at Eindhoven University of Technology. y Department of Mathematics and Computing Science, Eindhoven University of Technology, P.O.
Reference: [9] <author> L.S. Colby. </author> <title> A recursive algebra for nested relations. </title> <journal> Information Systems, </journal> <volume> 15(5) </volume> <pages> 567-582, </pages> <year> 1990. </year>
Reference-contexts: Box 513, 5600 MB Eindhoven, The Netherlands, email:paulh@win.tue.nl. 1 (the so-called First Normal Form). Various "nested" relational calculi 1 (i.e. calculi pro-viding for set-valued attributes) have been proposed <ref> [20, 2, 9] </ref>. <p> of these is the "monadic" calculus described by Tannen, Buneman and Wong [6, 22]. (The observation that collection types "are" monads with additional properties ("ringads") can be attributed to Wadler [24] and Trinder [23].) They prove that their calculus (using the set monad) is equivalent to "the" nested relational calculus <ref> [9] </ref>. The calculus we present here is inspired by (and can be instantiated to) that "monadic calculus". Thus, this paper does not claim to directly advance research in database query languages.
Reference: [10] <author> O. de Moor. </author> <title> Categories, Relations and Dynamic Programming. </title> <type> PhD thesis, </type> <institution> Oxford University Laboratory, Programming Research Group, </institution> <month> April </month> <year> 1992. </year> <month> 10 </month>
Reference-contexts: Our group has studied such operations [3], and called them "zips", after the well known operator that turns a pair of lists of equal length into a list of pairs. The special case where G is the powerset functor P has been studied by de Moor <ref> [10] </ref> under the name of "cross operators".
Reference: [11] <author> Oege de Moor. </author> <title> A generic program for sequential decision processes. </title> <editor> In Manuel Hermenegildo and S. Doaitse Swierstra, editors, </editor> <booktitle> Programming Languages: Implementations, Logics and Programs. 7th International Symposium, </booktitle> <address> PLIPS '95 Utrecht, The Netherlands, </address> <month> September </month> <year> 1995, </year> <booktitle> volume 982 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-23. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The importance of these differences has to do with the emerging interest in the area of so-called polytypic programs, the current focus of research in the BMF <ref> [3, 4, 11, 15, 12] </ref>. Such programs are parametrised by type constructors (as opposed to polymorphic programs which are parametrised by types). <p> We expect that research done in formal program development on zips [3], the Boom hierarchy [19, 14] of datatypes, and polytypic programming in general <ref> [4, 11, 15] </ref> will provide a basis for this further research. 6 Concluding remarks We have presented a monadic calculus for querying nested collections, inspired by (and in some sense equivalent to) the ones defined by Tannen, Buneman and Wong [6, 7] and Trinder [23].
Reference: [12] <author> H. Doornbos. </author> <title> Reductivity arguments and program construction. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology, Department of Mathematics and Computing Science, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: The importance of these differences has to do with the emerging interest in the area of so-called polytypic programs, the current focus of research in the BMF <ref> [3, 4, 11, 15, 12] </ref>. Such programs are parametrised by type constructors (as opposed to polymorphic programs which are parametrised by types).
Reference: [13] <author> P.J. Freyd and A. Scedrov. </author> <title> Categories, </title> <publisher> Allegories. North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: This will be defined using the 2 Actually, Tot P is also a functor, viz. from the base category into the corresponding Kleisli category. Tot F can for any F be expressed without applications and case distinctions if the base category is a boolean division allegory <ref> [13] </ref>. 4 function that pairs all elements of a set with one particular value, also known as the strength of the powerset functor.
Reference: [14] <author> P.F. Hoogendijk and R.C. Backhouse. </author> <title> Relational programming laws in the tree, list, bag, set hierarchy. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 22 </volume> <pages> 67-105, </pages> <year> 1994. </year>
Reference-contexts: This calculus is commonly known as the Bird-Meertens Formalism (BMF) [19, 5], and it is widely used for the development and description of functional and parallel [21] programs. A generalisation of this calculus was found in the category theoretic [18] and relational <ref> [14] </ref> approaches to abstract data types, and it was observed that the Boom hierarchy types form an instance of another popular category theoretic concept, the monad . This provided a new syntax and calculus for comprehensions on these types. <p> Altogether, it seems that more research is needed into zips and other data type transformations before a more conclusive form of a query language with multiple collection types can be established. We expect that research done in formal program development on zips [3], the Boom hierarchy <ref> [19, 14] </ref> of datatypes, and polytypic programming in general [4, 11, 15] will provide a basis for this further research. 6 Concluding remarks We have presented a monadic calculus for querying nested collections, inspired by (and in some sense equivalent to) the ones defined by Tannen, Buneman and Wong [6, 7]
Reference: [15] <author> J. Jeuring. </author> <title> Polytypic pattern matching. </title> <editor> In S. Peyton Jones, editor, </editor> <booktitle> Proceedings Functional Programming Languages and Computer Architecture, FPCA '95, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: The importance of these differences has to do with the emerging interest in the area of so-called polytypic programs, the current focus of research in the BMF <ref> [3, 4, 11, 15, 12] </ref>. Such programs are parametrised by type constructors (as opposed to polymorphic programs which are parametrised by types). <p> We expect that research done in formal program development on zips [3], the Boom hierarchy [19, 14] of datatypes, and polytypic programming in general <ref> [4, 11, 15] </ref> will provide a basis for this further research. 6 Concluding remarks We have presented a monadic calculus for querying nested collections, inspired by (and in some sense equivalent to) the ones defined by Tannen, Buneman and Wong [6, 7] and Trinder [23].
Reference: [16] <author> L. Libkin. </author> <title> Normalizing incomplete databases. </title> <booktitle> In PODS-95, </booktitle> <year> 1995. </year>
Reference-contexts: ; L turns a list of m lists of length n into a list of n lists of length m in the obvious way. 6 A final example of the use of zips is in the approach to query languages for databases with partial information advocated by Libkin and Wong <ref> [17, 16] </ref>. They combine a collection type (sets or bags) with a version of sets that has a non-standard interpretation (but is otherwise identical), the so-called or-sets. An or-set conceptually represents one of the values in it.
Reference: [17] <author> L. Libkin and L. Wong. </author> <title> Semantic representations and query languages for or-sets. </title> <booktitle> In PODS-93, </booktitle> <pages> pages 155-166, </pages> <year> 1993. </year>
Reference-contexts: ; L turns a list of m lists of length n into a list of n lists of length m in the obvious way. 6 A final example of the use of zips is in the approach to query languages for databases with partial information advocated by Libkin and Wong <ref> [17, 16] </ref>. They combine a collection type (sets or bags) with a version of sets that has a non-standard interpretation (but is otherwise identical), the so-called or-sets. An or-set conceptually represents one of the values in it.
Reference: [18] <author> G.R. Malcolm. </author> <title> Data structures and program transformation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 14 </volume> <pages> 255-279, </pages> <year> 1990. </year>
Reference-contexts: This calculus is commonly known as the Bird-Meertens Formalism (BMF) [19, 5], and it is widely used for the development and description of functional and parallel [21] programs. A generalisation of this calculus was found in the category theoretic <ref> [18] </ref> and relational [14] approaches to abstract data types, and it was observed that the Boom hierarchy types form an instance of another popular category theoretic concept, the monad . This provided a new syntax and calculus for comprehensions on these types. <p> Such programs are parametrised by type constructors (as opposed to polymorphic programs which are parametrised by types). Beginning with the work of Malcolm <ref> [18] </ref> it has been observed that several programming concepts and building blocks can be profitably formulated in polytypic terms thus enhancing their (re)usability.
Reference: [19] <author> L.G.L.T. Meertens. </author> <title> Algorithmics | towards programming as a mathematical activity. </title> <editor> In J.W. de Bakker, M. Hazewinkel, and J.K. Lenstra, editors, </editor> <booktitle> Proc. CWI Symposium on Mathematics and Computer Science, volume 1 of CWI Monographs, </booktitle> <pages> pages 289-334, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction and overview "Collection types" such as trees, lists, and bags have been studied extensively in computing science. In particular, in the research area of formal program development, the observation (attributed by L.Meertens <ref> [19] </ref> to H.Boom) that these types form a hierarchy has proved fruitful. The most important aspect of this so-called Boom hierarchy is that a calculus of higher order functions (like map, reduce and filter) can be defined on all its types. <p> The most important aspect of this so-called Boom hierarchy is that a calculus of higher order functions (like map, reduce and filter) can be defined on all its types. This calculus is commonly known as the Bird-Meertens Formalism (BMF) <ref> [19, 5] </ref>, and it is widely used for the development and description of functional and parallel [21] programs. <p> Altogether, it seems that more research is needed into zips and other data type transformations before a more conclusive form of a query language with multiple collection types can be established. We expect that research done in formal program development on zips [3], the Boom hierarchy <ref> [19, 14] </ref> of datatypes, and polytypic programming in general [4, 11, 15] will provide a basis for this further research. 6 Concluding remarks We have presented a monadic calculus for querying nested collections, inspired by (and in some sense equivalent to) the ones defined by Tannen, Buneman and Wong [6, 7] <p> Our presentation was designed to connect theories from formal program development with the state of the art in database query languages. Thus, a set up of functors over partial functions with associated natural transformations was chosen. Large portions of equational (point-free) calculi for category theory, for (total) functions <ref> [19, 5] </ref>, and for binary relations [1] are directly applicable to our calculus. Much of these will translate directly to well-known or possibly even new optimisations of (nested) relational database queries. The calculus instantiated to a single monad appears to be complete and well understood, cf. [7].
Reference: [20] <author> H.-J. Schek and M.H. Scholl. </author> <title> The relational model with relation-valued attributes. </title> <journal> Information systems, </journal> <volume> 11(2) </volume> <pages> 137-147, </pages> <year> 1986. </year>
Reference-contexts: Box 513, 5600 MB Eindhoven, The Netherlands, email:paulh@win.tue.nl. 1 (the so-called First Normal Form). Various "nested" relational calculi 1 (i.e. calculi pro-viding for set-valued attributes) have been proposed <ref> [20, 2, 9] </ref>. <p> This equals the calculus M [ (= ; cond) of Tannen et al [6, 7], whose expressive power equals that of the nested relational algebra with equality test <ref> [20] </ref>, see [6, 7] for a proof. An important property of this calculus is that the complexity of a query is exponential in the size of its input.
Reference: [21] <author> D. B. Skillicorn. </author> <title> The Bird-Meertens formalism as a parallel model. </title> <editor> In J.S. Kowalik and L. Grandinetti, editors, </editor> <booktitle> NATO ARW "Software for Parallel Computation", volume 106 of Series F. NATO ASI Workshop on Software for Parallel Computation, </booktitle> <address> Cetraro, Italy, June 1992, </address> <publisher> Springer-Verlag NATO ASI, </publisher> <year> 1993. </year>
Reference-contexts: This calculus is commonly known as the Bird-Meertens Formalism (BMF) [19, 5], and it is widely used for the development and description of functional and parallel <ref> [21] </ref> programs. A generalisation of this calculus was found in the category theoretic [18] and relational [14] approaches to abstract data types, and it was observed that the Boom hierarchy types form an instance of another popular category theoretic concept, the monad .
Reference: [22] <author> V. Tannen. </author> <title> Tutorial: Languages for collection types. Slides for the 13th ACM Conference on Principles of Database Systems. </title> <note> Available via anonymous ftp from ftp.cis.upenn.edu, file pub/papers/db_research/pods94t_slide.ps.Z, </note> <year> 1994. </year>
Reference-contexts: Box 513, 5600 MB Eindhoven, The Netherlands, email:paulh@win.tue.nl. 1 (the so-called First Normal Form). Various "nested" relational calculi 1 (i.e. calculi pro-viding for set-valued attributes) have been proposed [20, 2, 9]. The most general of these is the "monadic" calculus described by Tannen, Buneman and Wong <ref> [6, 22] </ref>. (The observation that collection types "are" monads with additional properties ("ringads") can be attributed to Wadler [24] and Trinder [23].) They prove that their calculus (using the set monad) is equivalent to "the" nested relational calculus [9]. <p> y ) j 9 (S : (x ; S ) 2 T : y 2 S )g In our calculus they are the beauty: unnest P ; A ; B = flatten P ; A fiB ffi map P :stl P ; A ; B and the beast (translated from <ref> [22] </ref>): nest P;A;B = map P :( o A;P (AfiB) 4 f ) ffi str P;A;P (AfiB) ffi ( A;B 4 id P (AfiB) ) where f = 0 A fi A ; B ffi lift P :(equal A fi id B ) ffi stl P;A;AfiB Note that this nested algebra <p> Thus, a monadic calculus of this form can be defined for any strong ringad. Important examples of these are lists and bags with their obvious (certainly for Boom hierarchy adepts) operations. For this reason, Trinder [23] and Tannen et al <ref> [6, 22] </ref> have argued that strong ringads describe the essence of so-called bulk- or collection types in databases. As an aside, not all operations defined above generalise from sets to other collection types all that well. Consider for example nesting/unnesting on lists, where L is the list functor.
Reference: [23] <author> P.W. Trinder. </author> <title> Comprehensions a query notation for DBPLs. </title> <booktitle> In Proceedings of the 1990 Glasgow Database Workshop, </booktitle> <pages> pages 95-102, </pages> <address> Glasgow, Scotland, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: The most general of these is the "monadic" calculus described by Tannen, Buneman and Wong [6, 22]. (The observation that collection types "are" monads with additional properties ("ringads") can be attributed to Wadler [24] and Trinder <ref> [23] </ref>.) They prove that their calculus (using the set monad) is equivalent to "the" nested relational calculus [9]. The calculus we present here is inspired by (and can be instantiated to) that "monadic calculus". Thus, this paper does not claim to directly advance research in database query languages. <p> Thus, a monadic calculus of this form can be defined for any strong ringad. Important examples of these are lists and bags with their obvious (certainly for Boom hierarchy adepts) operations. For this reason, Trinder <ref> [23] </ref> and Tannen et al [6, 22] have argued that strong ringads describe the essence of so-called bulk- or collection types in databases. As an aside, not all operations defined above generalise from sets to other collection types all that well. <p> datatypes, and polytypic programming in general [4, 11, 15] will provide a basis for this further research. 6 Concluding remarks We have presented a monadic calculus for querying nested collections, inspired by (and in some sense equivalent to) the ones defined by Tannen, Buneman and Wong [6, 7] and Trinder <ref> [23] </ref>. Our presentation was designed to connect theories from formal program development with the state of the art in database query languages. Thus, a set up of functors over partial functions with associated natural transformations was chosen.
Reference: [24] <author> P. Wadler. </author> <note> Notes on monads and ringads. Unpublished note, 1990. 11 </note>
Reference-contexts: The most general of these is the "monadic" calculus described by Tannen, Buneman and Wong [6, 22]. (The observation that collection types "are" monads with additional properties ("ringads") can be attributed to Wadler <ref> [24] </ref> and Trinder [23].) They prove that their calculus (using the set monad) is equivalent to "the" nested relational calculus [9]. The calculus we present here is inspired by (and can be instantiated to) that "monadic calculus". <p> zero P = zero P flatten P ffi map P :zero P = zero P flatten P ffi map P :f ffi union P = union P ffi ((flatten P ffi map P :f ) fi (flatten P ffi map P :f )) making the entire structure a strong ringad <ref> [24] </ref>. This equals the calculus M [ (= ; cond) of Tannen et al [6, 7], whose expressive power equals that of the nested relational algebra with equality test [20], see [6, 7] for a proof.
References-found: 24

