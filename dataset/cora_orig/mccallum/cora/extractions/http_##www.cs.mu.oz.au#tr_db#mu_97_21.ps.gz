URL: http://www.cs.mu.oz.au/tr_db/mu_97_21.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: A Parallel Implementation of the Andorra Kernel Language  
Author: Douglas Frank Palmer 
Degree: Submitted in total fulfilment of the requirements of the degree of Doctor of Philosophy  
Address: Parkville, Victoria Australia  
Affiliation: Department of Computer Science University of Melbourne  
Date: June, 1997  
Pubnum: TR 97/21  
Abstract-found: 0
Intro-found: 1
Reference: [AK90] <author> Khayri A. M. Ali and Roland Karlsson. </author> <title> The Muse Or-Parallel Prolog model and its performance. </title> <editor> In Saumya Debray and Manuel Hermenegildo, editors, </editor> <booktitle> Proceedings of the 1990 North American Conference on Logic Programming, </booktitle> <pages> pages 757-776, </pages> <address> Austin, 1990. </address> <publisher> ALP, MIT Press. </publisher>
Reference-contexts: Following the new path may be expensive. 2.1.4 The Copying Model The copying model was proposed by Ali <ref> [AK90] </ref> for the Muse or-parallel Prolog system. The copying model, rather than trying to maintain shared bindings for the same variable uses copying of the entire worker's workspace to allow multiple bindings.
Reference: [AK91a] <author> Hassan A it-Kaci. </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Elements from the WAM design can be seen in most abstract machines for logic programming languages. A complete description of the WAM can be found in [War83]. A more approachable description can be found in <ref> [AK91a] </ref>. The basic WAM architecture consists of three main data areas, a set of registers and an instruction set. These elements are summarised in table 5.1.
Reference: [AK91b] <author> Khayri A. M. Ali and Roland Karlsson. </author> <title> Scheduling Or-parallelism in Muse. </title> <editor> In Koichi Furukawa, editor, </editor> <booktitle> Proceedings of the Eighth International Conference on Logic Programming, </booktitle> <pages> pages 807-821, </pages> <address> Paris, France, 1991. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Performance results suggest that the copying method is often superior to the binding array method <ref> [AK91b] </ref>. 2.2 Independent And-Parallelism Independent and-parallelism (IAP) attempts to transparently exploit the parallelism which appears when two goals in a conjunction have no common variables. If the goals share no variables, then the two goals can be evaluated in parallel without the need for any synchronisation between processes.
Reference: [Ali86] <author> Khayri A. M. Ali. </author> <title> Or-parallel execution of prolog on a mutli-sequential machine. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 15(3) </volume> <pages> 189-214, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Binding arrays, however, provide the advantages of constant access time to bindings. Intuitively, binding arrays should be superior to hash windows in cases where there are few workers, leading to fewer large context changes. 2.1.3 The Multi-Sequential Machine Model The multi-sequential machine model was proposed separately by Ali <ref> [Ali86] </ref> as the multi-sequential machine and Clocksin (further refined by Alshawi) as Delphi [AM88], Both models are designed to allow or-parallelism with a minimal amount of communication between processes. Clever ini-tialisation of workers allow workers to distribute or-branches between themselves with little communication.
Reference: [AM88] <author> H. Alshawi and D. B. Moran. </author> <title> The delphi model and some preliminary experiments. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Proceedings of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1578-1589, </pages> <address> Seatle, 1988. </address> <publisher> ALP, IEEE, The MIT Press. </publisher>
Reference-contexts: Intuitively, binding arrays should be superior to hash windows in cases where there are few workers, leading to fewer large context changes. 2.1.3 The Multi-Sequential Machine Model The multi-sequential machine model was proposed separately by Ali [Ali86] as the multi-sequential machine and Clocksin (further refined by Alshawi) as Delphi <ref> [AM88] </ref>, Both models are designed to allow or-parallelism with a minimal amount of communication between processes. Clever ini-tialisation of workers allow workers to distribute or-branches between themselves with little communication. The multi-sequential machine model starts a number of workers executing the same program.
Reference: [Bah91] <author> Reem Bahgat. Pandora: </author> <title> Non-Deterministic Parallel Logic Programming. </title> <type> PhD thesis, </type> <institution> Imperial College, </institution> <year> 1991. </year>
Reference-contexts: Moolenaar and Demoen have found that an intelligent search rule can improve search performance by 2-3 times [MD94]. Another approach would be to provide a programmable search system, similar to Pandora <ref> [Bah91] </ref>. When a choice-box is selected for copying, a duplicate of the parent and-box and all child-boxes is created and added to the parent choice box. The and-box selected for promotion is moved to the choice-box and made active. <p> The ParAKL system [MD93] uses hash tables to maintain multiple binding environments. The Andorra-I system [SCWY91a] is intended for use with the basic Andorra model and therefore does not need the complications of multiple binding environments. Similarly, Pandora <ref> [Bah91] </ref> is based on Parlog and the JAM and does not need to consider such complications. 84 CHAPTER 5. THE DAM Chapter 6 An AKL Compiler This chapter covers the compiler for the DAM.
Reference: [BDL + 88] <author> Ralph Butler, Terry Disz, Ewing Lusk, Robert Olson, Ross Overbeek, and Rick Stevens. </author> <title> Scheduling OR-Parallelism: An Argonne perspective. </title> <editor> In Robert A. Kowal-ski and Kenneth A. Bowen, editors, </editor> <booktitle> Proceedings of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1590-1605, </pages> <address> Seatle, 1988. </address> <publisher> ALP, IEEE, The MIT Press. </publisher>
Reference-contexts: The essential problem in or-parallelism is how to resolve the multiple binding problem. 2.1.1 The Hash Window Binding Model The hash window binding model was developed by Borgwardt [Bor84] and is used in the Argonne National Laboratory's parallel Prolog <ref> [BDL + 88] </ref> and the PEPSys system [WR87]. Each alternative or-branch maintains a hash table, called a hash window, for storing conditional bindings. When a process makes a binding to a variable that other processes may be able to bind to, the binding is stored in a hash window. <p> By itself the hash window system is very inefficient, as every dereference to a possibly shared variable needs to work through the ascending chain of hash windows. The shallow binding <ref> [BDL + 88, WR87] </ref> optimisation reduces the need for entries in hash windows. Once a workers starts on a branch of the tree, any variables that it creates and then binds need not be entered into the hash window, as the variable is only visible to the creating worker.
Reference: [Bel77] <author> N. D. Belnap. </author> <title> A useful four-valued logic. </title> <editor> In J. Michael Dunn and G. Epstein, editors, </editor> <booktitle> Modern Uses of Multiple-Valued Logic, </booktitle> <pages> pages 8-37. </pages> <publisher> Reidel, </publisher> <year> 1977. </year>
Reference-contexts: v, such that: 1. each of and v gives B the structure of a complete lattice. 2. the lub and glb operations for each partial ordering are monotone with respect to the other partial ordering. 4.2.2 A Logic Based on FOUR The AKL, needs the simplest form of bilattice, FOUR <ref> [Bel77] </ref>. The Hasse diagram for FOUR is shown in figure 4.1. For the purposes of the AKL, &gt; is interpreted as meaning "both succeeds and fails" and ? has a meaning of undefined, which can be interpreted as either "still being computed," "infinite loop" or "deadlocked," depending on context.
Reference: [BG89] <author> R. Bahgat and S. Gregory. Pandora: </author> <title> Non-deterministic parallel logic programming. </title> <editor> In Giorgio Levi and Maurizio Martelli, editors, </editor> <booktitle> Proceedings of the Sixth International Conference on Logic Programming, </booktitle> <pages> pages 471-486, </pages> <address> Lisbon, 1989. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Andorra-I includes a sophisticated pre-processor that allows Andorra-I programs to act exactly like a Prolog program. Andorra Prolog [HB88] is an initial attempt to apply the Andorra model to Prolog. Pandora <ref> [BG89] </ref> uses the Andorra model in conjunction with Parlog. NUA-Prolog [PN91] is a basic application of the BAM to Prolog, using negations instead of cuts. 3.2 Andorra Prolog Andorra Prolog [HB88] is an instance of the BAM.
Reference: [BJ88] <author> Maurice Bruynooghe and Gerda Janssens. </author> <title> An instance of abstract interpretation integrating type and mode inferencing. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Proceedings of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 669-683, </pages> <address> Seatle, 1988. </address> <publisher> ALP, IEEE, The MIT Press. </publisher>
Reference-contexts: In most logic programming languages, abstract interpretations can be built to model either top-down or bottom-up execution (eg. SLD-resolution and the T P fixpoint semantics respectively in the case of Prolog). An example of top-down abstract interpretations is the general framework described by Bruynooghe et al. <ref> [BJ88] </ref>, Another example is multiple specialisation [JLW90], which allows the creation of multiple, specialised versions of a predicate, selected by run-time tests.
Reference: [Bor84] <author> P. Borgwardt. </author> <title> Parallel Prolog using stack segments on shared-memory multiprocessors. </title> <booktitle> In Proc. International Symposium on Logic Programming, </booktitle> <pages> pages 2-11, </pages> <address> Atlantic City, 1984. </address> <publisher> IEEE, Computer Society Press. </publisher> <address> 115 116 BIBLIOGRAPHY </address>
Reference-contexts: When clauses are evaluated in parallel, multiple bindings may be made to a single variable. The essential problem in or-parallelism is how to resolve the multiple binding problem. 2.1.1 The Hash Window Binding Model The hash window binding model was developed by Borgwardt <ref> [Bor84] </ref> and is used in the Argonne National Laboratory's parallel Prolog [BDL + 88] and the PEPSys system [WR87]. Each alternative or-branch maintains a hash table, called a hash window, for storing conditional bindings.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Conference Record of the Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, California, </address> <month> January </month> <year> 1977. </year>
Reference-contexts: AN AKL COMPILER 6.1. ABSTRACT INTERPRETATION 87 requirements from the future stages of the meta-interpretation. 6.1 Abstract Interpretation Abstract interpretation was introduced by Cousot and Cousot <ref> [CC77] </ref> as a method of formally deriving program properties. Using an abstract interpretation involves an approximate execution of the program, which is guaranteed both to halt and work with a superset of the possible values of the actual program.
Reference: [CG86] <author> Keith L. Clark and Steve Gregory. </author> <title> Parlog: parallel programming in logic. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(1) </volume> <pages> 1-49, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: The computation then commits to the remaining solution. This process of commitment gives the class of languages that support this feature the name of Committed Choice Languages (CCLs). The various committed choice languages: Concurrent Prolog [Sha83], Parlog <ref> [CG86] </ref>, GHC [Ued86] and KL1 [UC90] all share similar features. Over time, these languages have devolved as features that are difficult to implement and do not seem to be needed by programmers are stripped from them. An entertaining review of the CCLs and their devolution can be found in [Tic95].
Reference: [Cha85] <author> Jung-Heng Chang. </author> <title> High performance execution of logic programs based on a static data dependency analysis. </title> <type> Technical Report UCB/CSD 86/263, </type> <institution> Univerity of Califor-nia at Berkeley, </institution> <year> 1985. </year>
Reference-contexts: An alternative to expensive run-time checks is to perform a static analysis of the data-flow dependencies of the program for some top-level goal and generate a single call-graph for the goal. The method used in <ref> [Cha85] </ref> is to use a static analysis where variables are classified into sets of ground variables, independent variables and groups of variables that may be dependent on each other.
Reference: [Cod91] <author> Michael Codish. </author> <title> Abstract Interpretation of Sequential and Concurrent Logic Programs. </title> <type> PhD thesis, </type> <institution> Weizmann Institute of Science, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: Bottom-up abstract interpretations therefore, are also implicitly parallel. Top-down execution models, especially committed-choice languages, may be sensitive to deadlock and race conditions. As a result, the abstract interpretation must take account of these possibilities. An example of a top-down abstract interpretation that handles parallelism is Codish's suspension analysis <ref> [Cod91] </ref>. The main existing form of abstract interpretation for the AKL is that of Sjoland and Sahlin [SS95] which uses top down interpretation to derive a set of pre- and post- call domain equations which can be solved.
Reference: [Con83] <author> John S. Conery. </author> <title> The AND/OR process model for parallel interpretation of logic programs. </title> <type> Ph.D. thesis, </type> <institution> Department of Information and Computer Science, University of California, Irvine, </institution> <month> June </month> <year> 1983. </year>
Reference-contexts: In turn, and-parallelism can take two subsidiary forms: Independent and-parallelism evaluates conjunctions that are independent of each other (ie. no shared variables). Dependent and-parallelism evaluates conjunctions that share information. Most models of parallelism in logic programming languages view the computation as an and-or tree <ref> [Con83] </ref>. The computation tree consists of alternating layers of and- and or-nodes. Conjunctions of goals running in parallel are viewed as and-nodes. <p> These solutions need to be combined via some sort of cross-product operation: ff X/a g; f X/b gg ff Y/c g; f Y/d gg = 2.3. DEPENDENT AND-PARALLELISM 13 p (0, []). sum ([], S, S). ?-p (5, L), sum (L, 0, S). The And/Or process model <ref> [Con83] </ref>, and its practical realisation in OPAL [Con92] uses a tree of and- and or-processes to collect solutions. Or-processes collect incremental copies of non-ground terms. The PEPSys system [WR87] uses hash windows (section 2.1.1) to maintain or-parallelism. Creating a cross-product essentially means creating a cross-product of the candidate hash windows. <p> The instruction set and unification primitives are almost identical to the WAM and will not be discussed unless some significant difference occurs. See section 5.1.1 for a discussion of the WAM. The JAM, like Parlog, is similar to Conery's And/Or process model <ref> [Con83] </ref>. Each conjunction of goals is represented by an And-process. Each uncommitted predicate call is represented by an Or-Process. A tree of And- and Or-processes is used to represent the computation. Most of these processes will not actually be running at a given time.
Reference: [Con92] <author> John S. Conery. </author> <title> The opal machine. </title> <editor> In Peter Kacsuk and Michael J. Wise, editors, </editor> <booktitle> Implementations of Distributed Prolog, </booktitle> <pages> pages 159-185. </pages> <publisher> Wiley, </publisher> <year> 1992. </year>
Reference-contexts: DEPENDENT AND-PARALLELISM 13 p (0, []). sum ([], S, S). ?-p (5, L), sum (L, 0, S). The And/Or process model [Con83], and its practical realisation in OPAL <ref> [Con92] </ref> uses a tree of and- and or-processes to collect solutions. Or-processes collect incremental copies of non-ground terms. The PEPSys system [WR87] uses hash windows (section 2.1.1) to maintain or-parallelism. Creating a cross-product essentially means creating a cross-product of the candidate hash windows.
Reference: [Cra88] <author> Jim Crammond. </author> <title> Implementation of Committed Choice Languages on Shared Memory Multiprocessors. </title> <type> PhD thesis, </type> <institution> Department of Computing, Imperial College of Science and Technology, </institution> <address> London, England, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: The main motivation for introducing flat languages is the difficulty of implementing deep guards. A full implementation of deep guards requires separate binding environments for each guard computation, making it as least a hard a problem as or-parallelism. Crammond's JAM <ref> [Cra88] </ref> for Parlog only allows one deep guard to be evaluated at a time, allowing deep guards, but eliminating a source of parallelism. Modes CCLs also need to provide some mechanism for specifying which subgoals are producers of bindings and which are consumers | modes. <p> A complete description of the JAM can be found in <ref> [Cra88] </ref>. The JAM shares several common points with the WAM, but has been designed to accommodate the attributes of Parlog: parallelism, suspension and guard computations. The instruction set and unification primitives are almost identical to the WAM and will not be discussed unless some significant difference occurs. <p> An alternative is to directly use a native atomic update instruction. Use of such hardware specifics, however, tends to destroy the portability of the system. The approach taken here, and used in <ref> [Cra88] </ref>, is to use a limited number of hardware/software locks, in conjunction with hashing. Each structure that needs to be locked has an associated status bit assigned to it.
Reference: [CRR92] <author> Ta Chen, I. V. Ramakrishnan, and R. Ramesh. </author> <title> Multistage indexing algorithms for speeding Prolog execution. </title> <editor> In Krzysztof Apt, editor, </editor> <booktitle> Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 639-653, </pages> <address> Wash-ington, USA, 1992. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: A simpler solution is to restrict the clause set to 32 bits and have the clause set 5.4. ABSTRACT ARCHITECTURE 77 DAM Code WAM Code ChoiceBox 2 Try 1,1,&L1 Try 3,0,&L3 Defer try 2,L1 retry L2 trust L3 contained in the register <ref> [Han92, CRR92] </ref>. Since the CS register is limited to 32 bits it can only handle up to 32 clauses. Most predicates are less than 32 clauses in size so this is rarely a problem.
Reference: [CS89] <author> A. Calderwood and P. </author> <title> Szeredi. Scheduling or-parallelism in Aurora: The Manchester scheduler. </title> <editor> In Giorgio Levi and Maurizio Martelli, editors, </editor> <booktitle> Proceedings of the Sixth International Conference on Logic Programming, </booktitle> <pages> pages 419-435, </pages> <address> Lisbon, 1989. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: OR-PARALLELISM 7 8 CHAPTER 2. AN OVERVIEW OF PARALLEL LOGIC PROGRAMMING 2.1. OR-PARALLELISM 9 tree, to avoid the copying overhead of a large move. The Manchester scheduler <ref> [CS89] </ref> keeps two global arrays, indexed by worker number. The first array contains the tasks that each worker has available for sharing, along with information on how far the task is from the root of the computation tree.
Reference: [DeG84] <author> Doug DeGroot. </author> <title> Restricted and-parallelism. </title> <booktitle> In Proceedings of the 1984 International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 471-478, </pages> <address> Tokyo, Japan, </address> <month> November </month> <year> 1984. </year>
Reference-contexts: The second literal can now be safely evaluated. 2.2.2 Static Detection of Independent And-Parallelism Dynamic detection of IAP is expensive, especially the tests for groundness and variable independence, although groundness tests can be cached <ref> [DeG84] </ref>. An alternative to expensive run-time checks is to perform a static analysis of the data-flow dependencies of the program for some top-level goal and generate a single call-graph for the goal. <p> The most pessimistic assumptions are made about variable aliasing, ensuring safe parallel execution. 2.2.3 Conditional Graph Expressions The purely dynamic models of IAP tend to produce excess run-time testing. Static analysis restricts the amount of parallelism available. Hybrid methods, such as program graph expressions <ref> [DeG84] </ref> and conditional graph expressions (CGEs) [Her86a, Her86b] attempt to tread a path between the two extremes. 12 CHAPTER 2. <p> If the term is later tested for groundness and found to be ground, then the groundness bit can be set, eliminating the need to re-test for groundness. This approach is similar to that used by DeGroot for restricted and-parallelism <ref> [DeG84] </ref>. Variables have a lower tag value of 1. It is no longer possible to represent a variable as a reference to itself, as the variable may have a number of dependent localised variables and delayed boxes attached to it.
Reference: [DLH90] <author> Saumya K Debray, Nai-Wei Lin, and Manuel Hermenegildo. </author> <title> Task granularity analysis in logic programs. </title> <booktitle> In Proceedings of SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 174-188, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: An example of this approach would be an expression that limits parallel calls on the Fibonacci benchmark to those with input arguments of (eg.) 4 or more, preventing work fragmentation <ref> [DLH90] </ref>. 103 104 CHAPTER 7. CONCLUSIONS * The copying approach to nondeterminism seems to be the simplest approach to implementing the AKL.
Reference: [FBR93] <author> Steve Frank, Henry Burkhadt, and James Rothric. </author> <title> The KSR1: Bridging the gap between shared memory and mpps. </title> <booktitle> In Proceedings of COMPCON, </booktitle> <pages> pages 285-294, </pages> <month> Spring </month> <year> 1993. </year>
Reference-contexts: An example is the Parallel Inference Machine [Got87], where small clusters of processors share local memory but messages are exchanged between clusters. The KSR1 <ref> [FBR93] </ref> maintains a logically unfragmented address space, with each processor maintaining a cache and no processor "owning" an address. The Data Diffusion Machine (DDM) [WH88] allows shared memory access to a system with local memory by providing a hierarchy of data directories.
Reference: [FF92] <author> Sz. Ferenczi and I. Futo. CS-Prolog: </author> <title> A communicating sequential prolog. </title> <editor> In Peter Kacsuk and Michael J. Wise, editors, </editor> <booktitle> Implementations of Distributed Prolog, </booktitle> <pages> pages 357-378. </pages> <publisher> Wiley, </publisher> <year> 1992. </year>
Reference-contexts: Both or- and independent and- parallelism attempt to transparently extract parallelism from Prolog-like programs. Dependent and-parallelism, despite the use of CCLs, still attempts to supply an implied model of parallelism. Process-oriented logic programming languages, such as Delta-Prolog [PN84] or CS-Prolog <ref> [FF92] </ref> use explicit message passing operators to transmit and receive messages between essentially unconnected Prolog processes. Data-flow models, such as Kacsuk's 3DPAM [Kac92] or Zhang's DIALOG [ZT91], model the and-or tree by means of tokens passing between the nodes of the tree.
Reference: [Fit91] <author> Melvin Fitting. </author> <title> Bilattices and the semantics of logic programming. </title> <journal> The Journal of Logic Programming, </journal> <volume> 11(1 </volume> & 2):91-116, July 1991. 
Reference-contexts: This chapter covers the logical structure of the AKL, and introduces a fixpoint semantics for the language that can be used as the concrete semantics for abstract interpretation (see chapter 6). This chapter builds upon the work of Fitting <ref> [Fit91] </ref> on applying bilattices to logic programming and applies the bilattice model to committed-choice languages in general and the AKL in particular. 4.1 Logical Aspects of the AKL Before considering the logical aspects of the AKL, it is necessary to provide an intended interpretation of an AKL program. <p> THE AKL AND LOGIC H H H H H H H H - &gt; ? false true 4.2.1 Bilattices Bilattices were introduced to logic programming by Fitting <ref> [Fit91] </ref> with the intention of modelling uncertain and unknown information. The characterisation of bilattices given here is taken from [Fit91], with some changes in notation 1 . <p> THE AKL AND LOGIC H H H H H H H H - &gt; ? false true 4.2.1 Bilattices Bilattices were introduced to logic programming by Fitting <ref> [Fit91] </ref> with the intention of modelling uncertain and unknown information. The characterisation of bilattices given here is taken from [Fit91], with some changes in notation 1 . <p> Negation is a reflection about the v axis and indecisive 1 In this thesis, is used instead of the t in <ref> [Fit91] </ref>. Similarly, v is used in place of k , u in place of and t in place of . 2 These names derive from the idea that indecisive-or can't make up its mind about true t false; the initial motivation for introducing a multi-valued logic. In [Fit91] indecisive-not is called <p> the t in <ref> [Fit91] </ref>. Similarly, v is used in place of k , u in place of and t in place of . 2 These names derive from the idea that indecisive-or can't make up its mind about true t false; the initial motivation for introducing a multi-valued logic. In [Fit91] indecisive-not is called confluence. 4.2. <p> The combination of FOUR and the operations defined above form an extended Boolean algebra, satisfying the normal identities of a Boolean algebra. These identities are summarised in table 4.2; most are consequences of the properties of interlaced bilattices (see <ref> [Fit91] </ref>). 4.2.3 Commit Predicates Armed with the bilattice described above, it is now possible to describe a logical interpretation of a commit-guarded predicate. <p> The treatment here follows that of <ref> [Fit91] </ref>. Definition 4.3.1 An interpretation is a mapping v from a subset of ground atomic formulae to FOUR. The interpretation is in the constraint theory T C provided that for each constraint , if T C j= then v = true and if T C 6j= then v = false.
Reference: [Fly66] <author> M. J. Flynn. </author> <title> Very high speed computing systems. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 54(12) </volume> <pages> 1901-1909, </pages> <month> December </month> <year> 1966. </year> <note> BIBLIOGRAPHY 117 </note>
Reference-contexts: All of these four factors affect each other, so some combinations are more likely than others. All parallel systems necessarily involve a set of processors executing instructions semi-independently. Parallel machines are usually categorised by the Flynn taxonomy <ref> [Fly66] </ref>. The first rough division between parallel machines is between single instruction, multiple data (SIMD) machines and multiple instruction, multiple data (MIMD) machines. The processors of SIMD machines all execute a single program in lock-step.
Reference: [Foo94] <author> Wai-Keong Foong. </author> <title> A directory-based scheme of implementing distributed shared memory for multi-transputer systems. </title> <booktitle> In Australasian Workshop on Parallel and Real-Time Systems, </booktitle> <pages> pages 135-149. </pages> <institution> Victoria University of Technology, </institution> <year> 1994. </year>
Reference-contexts: A strictly distributed structure would require copies of terms to be made when a non-local processor needs to refer to those terms. A variety of incremental copying schemes have been designed for use with distributed architectures <ref> [Nak92, Foo94] </ref>. The existence of the DDM suggests that shared memory could be used for reading terms, leaving the actual location of the term to the underlying system [RDC92]. The issue of using shared memory with locks or message passing for updating shared structures is more problematic.
Reference: [Fra94] <author> Torkel Franzen. </author> <title> Some formal aspects of AKL. </title> <institution> Research Report R94:10, Swedish Institute of Computer Science, Kista, Sweden, </institution> <year> 1994. </year>
Reference-contexts: The AKL execution model should be sound in the sense that any answer computed should be a logical consequence of P , and complete in the sense that all possible logical consequences of P are computed. The basic logical structure of AKL program is given in <ref> [Fra94] </ref>. A constraint theory, T C, is assumed, with a constraint, , holding if T C j= . <p> A query such as merge ([1], [2], [1, 2]) may succeed or fail, depending on the exact path of the computation. Similarly, merge ([1], [2], X), not merge ([1], [2], X) may succeed, breaking the identity A ^ :A false. Franzen <ref> [Fra94] </ref> avoids the difficulties with commit by examining only those predicates with authoritative guards: Definition 4.1.2 An AKL program, P , is authoritative if for every clause of the form H (x) :- G (x; y) | B (x; y; z): T C [ P j= G (x; y) ! (H <p> Terminal configurations that are not end configurations are deadlock configurations. A logical mapping for AKL configurations is also necessary. Following the model of sections 4.1 and 4.2.3 each box can be mapped onto a logical interpretation in a manner similar to that of <ref> [Fra94] </ref>, but adjusted to the new definition for commit. Definition 4.4.1 The logical interpretation of a configuration C, written as C fl , is defined recursively as: 1. fail fl = false. 2. A fl = A, where A is an atom or primitive constraint. <p> ? then 9G is either true or false and therefore, from the Hasse diagram of FOUR P [ T C j= G $ B fl . 2 The above theorem also shows the relationship between the logical semantics derived by the fixpoint construction given here and the semantics given in <ref> [Fra94] </ref>. Provided a program is authoritative, indifferent and guard stratified, no goal has a truth-value of &gt; and (with the exception of undefined goals | those having a truth value of ?) the true and false truth values must match.
Reference: [FW91] <author> Ian Foster and Will Winsborough. </author> <title> Copy avoidance through compile-time analysis and local reuse. </title> <editor> In Vijay Saraswat and Kazunori Ueda, editors, </editor> <booktitle> Logic Programming, Proceedings of the 1991 International Symposium, </booktitle> <pages> pages 455-469, </pages> <address> San Diego, USA, 1991. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: This technique has the advantage that it side-steps the inherent complexities of explicitly modelling parallelism, while producing the same results in some areas. An example of this technique is the abstract interpretation developed by Foster and Winsborough for Strand <ref> [FW91] </ref>, used to avoid copying of modified data structures. The compiler described here uses abstract interpretation to provide more accurate indexing of clauses throughout the program, and to provide accurate mode information for determining call orders and call delaying.
Reference: [GH91] <author> Gopal Gupta and M. Hermenegildo. </author> <title> Ace: And/or-parallel copying-based execution of logic programs. </title> <editor> In Anthony Beaumont and Gopal Gupta, editors, </editor> <booktitle> Proceedings of the ICLP91 Pre-Conference Workshop on Parallel Execution of Logic Programs, </booktitle> <address> Paris, France, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Creating a cross-product essentially means creating a cross-product of the candidate hash windows. IAP ensures that there will be no conflicting variable bindings in the hash windows created by different and-branches. Join cells are used to link hash windows for each possible element of the cross-product. The ACE system <ref> [GH91] </ref> is a combination of conditional graph expressions and the copying model for or-parallelism. A group of workers executing a set of IAP subgoals makes a single area, which can be copied in total.
Reference: [GJ79] <author> Michael R. Garey and David S. Johnson. </author> <title> Computers and Intractibility. W.H. </title> <publisher> Freeman, </publisher> <address> San Francisco, </address> <year> 1979. </year>
Reference-contexts: An example of a predicate that generates an exponential decision tree is p/6: p (0, 1, 0, , , no). p (1, 0, , 0, , no). p ( , , , , , yes). p/6 is a disguised form of the 3-satisfiability problem <ref> [GJ79] </ref> for the formula F = (x 1 _ :x 2 _ x 3 ) ^ (x 1 _ :x 4 _ x 5 ) ^ (:x 1 _ x 2 _ x 4 ) ^ (:x 2 _ x 3 _ x 5 ).
Reference: [GJ89] <author> G. Gupta and B. Jayaraman. </author> <title> Combined And-Or Parallism on Shared Memory Multiprocessors. </title> <editor> In Ewing L. Lusk and Ross A. Overbeek, editors, </editor> <booktitle> Proceedings of the North American Conference on Logic Programming, </booktitle> <pages> pages 332-349, </pages> <address> Cleveland, Ohio, USA, </address> <year> 1989. </year>
Reference-contexts: The Reduce-OR model [Kal87] maintains sets of variable bindings, called tuples, for each branch of an and-parallel computation. These tuples are lazily combined where the execution graph joins to make a cross product. The AO-WAM <ref> [GJ89] </ref> builds a tree of and- and or-nodes, extended by crossproduct- and sequential-nodes. The crossproduct-nodes combine solutions in a similar manner to the Reduce-OR model. 2.3 Dependent And-Parallelism Dependent and-parallelism (DAP) or stream and-parallelism takes a view of parallelism similar to Hoare's communicating sequential processes [Hoa78].
Reference: [GL88] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Proceedings of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1081-1086, </pages> <address> Seatle, 1988. </address> <publisher> ALP, IEEE, The MIT Press. </publisher>
Reference-contexts: choice and (; X1 = s (0)) ? true; and (o (X2); X1 = s (s (X2))) fX2g ? true; ! ! ? true; 1 1 fXg 4.6 Related Work The FOUR based logic used above has a strong relationship to the stable model semantics developed by Gelfond and Lifschitz <ref> [GL88] </ref>. The stable model semantics uses two sets: one for successes (S) and one for failures (F ).
Reference: [GL92] <author> Maurizio Gabbrielli and Giorgio Levi. </author> <title> Unfolding and fixpoint semantics of concurrent constraint logic programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 105(1) </volume> <pages> 85-128, </pages> <year> 1992. </year>
Reference-contexts: Naish [Nai89] uses four different sets to represent potential success and failure in committed choice programs, splitting success sets into definite and potential success sets and failure into definite and potential failure sets. Gabbrielli and Levi <ref> [GL92] </ref> use an unfolding mechanism to derive a fixpoint semantics for committed choice programs. The unfolding mechanism is careful to retain the reactive behaviour of the program, ensuring that spurious successes are not possible and that deadlocks are correctly modelled.
Reference: [GMS96] <author> Laura Giordano, Alberto Martelli, and Maria Luisa Sapino. </author> <title> Extending negation as failure by abduction: A three valued stable model semantics. </title> <journal> The Journal of Logic Programming, </journal> <volume> 26(1) </volume> <pages> 31-68, </pages> <year> 1996. </year>
Reference-contexts: The relationship between FOUR and the stable model semantics has been examined by Gior-dano et al <ref> [GMS96] </ref>: G $ ? if G 62 S [ F , G $ &gt; if G 2 S " F , G $ true if G 2 S F and G $ false if G 2 F S.
Reference: [Got87] <author> A. Goto. </author> <title> Parallel inference machine research in FGCS project. </title> <booktitle> In Proceedings of the US-Japan AI Symposium 87, </booktitle> <pages> pages 21-36, </pages> <year> 1987. </year>
Reference-contexts: Fragmented memories tend to enforce a message passing communication system. Some hybrid systems impose a hierarchy of organisation to support the efficiency of shared-memory communication between small groups of processors while retaining the massive parallelism possible through local memory and message passing. An example is the Parallel Inference Machine <ref> [Got87] </ref>, where small clusters of processors share local memory but messages are exchanged between clusters. The KSR1 [FBR93] maintains a logically unfragmented address space, with each processor maintaining a cache and no processor "owning" an address.
Reference: [Han92] <author> Werner Hans. </author> <title> A complete indexing scheme for WAM-based abstract machines. </title> <type> Technical Report TR92-11, </type> <institution> RWTH Aachen, Lehrstuhl fur Informatik II, </institution> <year> 1992. </year>
Reference-contexts: A simpler solution is to restrict the clause set to 32 bits and have the clause set 5.4. ABSTRACT ARCHITECTURE 77 DAM Code WAM Code ChoiceBox 2 Try 1,1,&L1 Try 3,0,&L3 Defer try 2,L1 retry L2 trust L3 contained in the register <ref> [Han92, CRR92] </ref>. Since the CS register is limited to 32 bits it can only handle up to 32 clauses. Most predicates are less than 32 clauses in size so this is rarely a problem.
Reference: [HB88] <author> Seif Haridi and Per Brand. </author> <title> Andorra Prolog | an integration of Prolog and committed choice languages. </title> <booktitle> In Proceedings of the 1988 International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 745-754, </pages> <address> Tokyo, Japan, </address> <month> December </month> <year> 1988. </year>
Reference-contexts: There are a number of applications of the BAM: Andorra-I [SCWY91b] is a parallel version of the BAM which executes Prolog programs. Andorra-I includes a sophisticated pre-processor that allows Andorra-I programs to act exactly like a Prolog program. Andorra Prolog <ref> [HB88] </ref> is an initial attempt to apply the Andorra model to Prolog. Pandora [BG89] uses the Andorra model in conjunction with Parlog. NUA-Prolog [PN91] is a basic application of the BAM to Prolog, using negations instead of cuts. 3.2 Andorra Prolog Andorra Prolog [HB88] is an instance of the BAM. <p> Andorra Prolog <ref> [HB88] </ref> is an initial attempt to apply the Andorra model to Prolog. Pandora [BG89] uses the Andorra model in conjunction with Parlog. NUA-Prolog [PN91] is a basic application of the BAM to Prolog, using negations instead of cuts. 3.2 Andorra Prolog Andorra Prolog [HB88] is an instance of the BAM. Andorra Prolog provides semantics for cut and commit operators, missing from the BAM, and formalises the execution model in terms of a series of configurations. <p> In particular, the configuration-based approach forms a natural bridge between Andorra Prolog and the AKL. 3.2.1 Execution Model The execution model presented here is based on that of Haridi and Brand <ref> [HB88] </ref>. The implicit node-tree built in [HB88] has been made explicit; the explicit node-tree makes the relationship between Andorra Prolog and the AKL (section 3.4) more apparent. <p> In particular, the configuration-based approach forms a natural bridge between Andorra Prolog and the AKL. 3.2.1 Execution Model The execution model presented here is based on that of Haridi and Brand <ref> [HB88] </ref>. The implicit node-tree built in [HB88] has been made explicit; the explicit node-tree makes the relationship between Andorra Prolog and the AKL (section 3.4) more apparent. Programs in Andorra Prolog consist of a set of definite clauses in the form: H :- G; B The head, H, is a single atom.
Reference: [Her86a] <author> Manuel V. Hermenegildo. </author> <title> An abstract machine for restricted AND-parallel execution of logic programs. </title> <editor> In Ehud Shapiro, editor, </editor> <booktitle> Proceedings of the Third International Conference on Logic Programming, Lecture Notes in Computer Science, </booktitle> <pages> pages 25-39, </pages> <address> London, 1986. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Static analysis restricts the amount of parallelism available. Hybrid methods, such as program graph expressions [DeG84] and conditional graph expressions (CGEs) <ref> [Her86a, Her86b] </ref> attempt to tread a path between the two extremes. 12 CHAPTER 2.
Reference: [Her86b] <author> Manuel V. Hermenegildo. </author> <title> Efficient management of backtracking in AND-Parallelism. </title> <editor> In Ehud Shapiro, editor, </editor> <booktitle> Proceedings of the Third International Conference on Logic Programming, Lecture Notes in Computer Science, </booktitle> <pages> pages 40-54, </pages> <address> London, 1986. </address> <publisher> Springer-Verlag. 118 BIBLIOGRAPHY </publisher>
Reference-contexts: Static analysis restricts the amount of parallelism available. Hybrid methods, such as program graph expressions [DeG84] and conditional graph expressions (CGEs) <ref> [Her86a, Her86b] </ref> attempt to tread a path between the two extremes. 12 CHAPTER 2.
Reference: [HG91] <author> Arie Harsat and Ran Ginosar. CARMEL-4: </author> <title> The unify-spawn machine for FCP. </title> <editor> In Koichi Furukawa, editor, </editor> <booktitle> Proceedings of the Eighth International Conference on Logic Programming, </booktitle> <pages> pages 840-854, </pages> <address> Paris, France, 1991. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: The original WAM specification drew a distinction between the set of temporary registers, X1, X2, ..., and the set of argument registers, 1 Or an actual physical machine, if such a thing is achievable. An example is the CARMEL series of processors for FCP <ref> [HG91] </ref>. 48 CHAPTER 5.
Reference: [HJ90] <author> Seif Haridi and Sverker Janson. </author> <title> Kernel Andorra Prolog and its computation model. </title> <editor> In David H. D. Warren and Peter Szeredi, editors, </editor> <booktitle> Proceedings of the Seventh International Conference on Logic Programming, </booktitle> <pages> pages 31-46, </pages> <address> Jerusalem, 1990. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: The model for AKL presented here is a combination of the original Kernel Andorra Prolog (KAP) described by Haridi and Janson <ref> [HJ90] </ref> and the later Andorra Kernel Language [JH91]. The model retains the constraint-based description of the original KAP, but includes such elements as the bagof/3 predicate introduced by the AKL.
Reference: [Hoa78] <author> C.A.R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <year> 1978. </year>
Reference-contexts: The AO-WAM [GJ89] builds a tree of and- and or-nodes, extended by crossproduct- and sequential-nodes. The crossproduct-nodes combine solutions in a similar manner to the Reduce-OR model. 2.3 Dependent And-Parallelism Dependent and-parallelism (DAP) or stream and-parallelism takes a view of parallelism similar to Hoare's communicating sequential processes <ref> [Hoa78] </ref>. Subgoals within a clause are executed as individual processes, with shared variables acting as conduits of information between the processes. An example program capable of DAP is shown in figure 2.7.
Reference: [Jan94] <author> Sverker Janson. AKL: </author> <title> A Multiparadigm Programming Language. </title> <type> PhD thesis, </type> <institution> Uppsala University, </institution> <year> 1994. </year>
Reference-contexts: If both parts are run in parallel, then some means of synchronising the two parts must be found. A huge variety of attempts to solve the various problems of parallelism in logic programming have been made over the years. The Andorra/Agents Kernel Language (AKL) <ref> [Jan94] </ref> is an attempt to unify many of these attempts, as well as provide a general formal structure for handling logic programming. <p> However, use of localised variables in the DAM means that there are no readily available hash windows for maintaining multiple bindings. The DAM copies box-trees in a manner similar to copying garbage collection. This approach is also used in the AGENTS abstract machine <ref> [Jan94] </ref> and the Penny system [MA96]. Each object that is part of the structure being copied is allocated a new block of memory and copied across. As each structure is copied its first word is replaced by a relocation term, giving the address of the copied object. <p> For purposes of comparison, the benchmarks were run on the following implementations: NU-Prolog [ZT86] An example of a sequential Prolog system built around the WAM. Version 1.6.5 was used. AGENTS <ref> [Jan94] </ref> The SICS sequential AGENTS abstract machine, version 1.0. Penny [MA96] The experimental SICS parallel AKL abstract machine. DAM Doug's Abstract Machine. <p> Thy middle ground between NU-Prolog and the DAM can be expected to be occupied by AGENTS and Penny. 5.6 Related Work The closest relation to the DAM is the Penny parallel machine and its sequential predecessor, the AGENTs abstract machine <ref> [MA96, Jan94] </ref>. Both these machines use a system of configuration-stacks to control the computation, rather than the box-based approach of the DAM.
Reference: [JH91] <author> Sverker Janson and Seif Haridi. </author> <title> Programming paradigms of the Andorra Kernel Language. </title> <editor> In Vijay Saraswat and Kazunori Ueda, editors, </editor> <booktitle> Logic Programming, Proceedings of the 1991 International Symposium, </booktitle> <pages> pages 167-186, </pages> <address> San Diego, USA, 1991. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: The model for AKL presented here is a combination of the original Kernel Andorra Prolog (KAP) described by Haridi and Janson [HJ90] and the later Andorra Kernel Language <ref> [JH91] </ref>. The model retains the constraint-based description of the original KAP, but includes such elements as the bagof/3 predicate introduced by the AKL. <p> Enforcing the quietness condition ensures that the configuration produced from p (X) is nondeterministically promoted, and the solution X = a is computed. 3.4.4 Using the AKL This section describes some of the uses the AKL can be put to. The examples in this section are largely derived from <ref> [JH91] </ref>. Dependent And-Parallelism The determinate promotion rule can be used to provide dependent and-parallelism. Figure 3.6 shows the execution path of a simple dependent and-parallel program. In the figure, parts of execution that can be performed in parallel, are.
Reference: [JL87] <author> Joxan Jaffar and Jean-Louis Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the Fourteenth Conference on the Princliples of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: Substitutions and unification allow an answer to be computed. However, logic programming can be extended to cover a wider range of interpretations. Constraint Logic Programming <ref> [JL87] </ref> extends logic programming to handle a variety of constraint systems, where constraints can be arbitrary closed formulae built from primitive predicates. A constraint theory is an interpretation of the constraint domain. A constraint is satisfiable in a constraint theory C if C j= .
Reference: [JLW90] <author> Dean Jacobs, Anno Langen, and Will Winsborough. </author> <title> Multiple specialization of logic programs with run-time test. </title> <editor> In David H. D. Warren and Peter Szeredi, editors, </editor> <booktitle> Proceedings of the Seventh International Conference on Logic Programming, </booktitle> <pages> pages 717-731, </pages> <address> Jerusalem, 1990. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: SLD-resolution and the T P fixpoint semantics respectively in the case of Prolog). An example of top-down abstract interpretations is the general framework described by Bruynooghe et al. [BJ88], Another example is multiple specialisation <ref> [JLW90] </ref>, which allows the creation of multiple, specialised versions of a predicate, selected by run-time tests. Most specific logic programs [MNL88] can be used to generate more efficient versions of programs; an example of bottom up abstract interpretation is the generation of most specific programs [MS92].
Reference: [Kac92] <author> Peter Kacsuk. </author> <title> Distributed data driven Prolog abstract machine. </title> <editor> In Peter Kacsuk and Michael J. Wise, editors, </editor> <booktitle> Implementations of Distributed Prolog, </booktitle> <pages> pages 89-118. </pages> <publisher> Wiley, </publisher> <year> 1992. </year>
Reference-contexts: Dependent and-parallelism, despite the use of CCLs, still attempts to supply an implied model of parallelism. Process-oriented logic programming languages, such as Delta-Prolog [PN84] or CS-Prolog [FF92] use explicit message passing operators to transmit and receive messages between essentially unconnected Prolog processes. Data-flow models, such as Kacsuk's 3DPAM <ref> [Kac92] </ref> or Zhang's DIALOG [ZT91], model the and-or tree by means of tokens passing between the nodes of the tree.
Reference: [Kal87] <author> L. V. Kale. </author> <title> The REDUCE-OR process model for parallel evaluation of logic programs. </title> <editor> In Jean-Louis Lassez, editor, </editor> <booktitle> Proceedings of the Fourth International Conference on Logic Pro gramming, MIT Press Series in Logic Programming, </booktitle> <pages> pages 616-632, </pages> <address> Mel-bourne, 1987. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: The ACE system [GH91] is a combination of conditional graph expressions and the copying model for or-parallelism. A group of workers executing a set of IAP subgoals makes a single area, which can be copied in total. The Reduce-OR model <ref> [Kal87] </ref> maintains sets of variable bindings, called tuples, for each branch of an and-parallel computation. These tuples are lazily combined where the execution graph joins to make a cross product. The AO-WAM [GJ89] builds a tree of and- and or-nodes, extended by crossproduct- and sequential-nodes.
Reference: [Kow74] <author> R. Kowalski. </author> <title> Predicate logic as programming language. </title> <editor> In Jack L. Rosenfeld, editor, </editor> <booktitle> Proceedings of the Sixth IFIP Congress (Information Processing 74), </booktitle> <pages> pages 569-574, </pages> <address> Stockholm, Sweden, </address> <month> August </month> <year> 1974. </year>
Reference-contexts: Introduction Logic Programming <ref> [Kow74] </ref> and its practical realisation in Prolog [Rou75] introduced a new paradigm to computer science. Logic programming has a declarative model, where programs are represented by relationships between entities, rather than by instructions on how to solve problems (the imperative model).
Reference: [KS88] <author> Shmuel Kliger and Ehud Shapiro. </author> <title> A decision tree compilation algorithm for FCP (j, </title> :, ?). <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Proceedings of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1315-1336, </pages> <address> Seatle, 1988. </address> <publisher> ALP, IEEE, The MIT Press. </publisher>
Reference-contexts: There are several ways of avoiding exponential decision trees. If the expected input modes are known (e.g. from a moded logic programming language such as Concurrent Prolog or Pandora) then the decision tree can be generated directly <ref> [KS88, KT91] </ref>. Alternately, partial indexing is possible, abandoning the indexing when the decision tree becomes too complex and simply trying clauses [SCWY91b]. The approach taken in the DAM is to use the clause set approach developed for NUA-Prolog [PN91].
Reference: [KT91] <author> M. Korsloot and E. Tick. </author> <title> Compilation techniques for nondeterminate flat concurrent logic programming languages. </title> <editor> In Koichi Furukawa, editor, </editor> <booktitle> Proceedings of the Eighth International Conference on Logic Programming, </booktitle> <pages> pages 457-471, </pages> <address> Paris, France, 1991. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: There are several ways of avoiding exponential decision trees. If the expected input modes are known (e.g. from a moded logic programming language such as Concurrent Prolog or Pandora) then the decision tree can be generated directly <ref> [KS88, KT91] </ref>. Alternately, partial indexing is possible, abandoning the indexing when the decision tree becomes too complex and simply trying clauses [SCWY91b]. The approach taken in the DAM is to use the clause set approach developed for NUA-Prolog [PN91].
Reference: [LBD + 90] <author> Ewing Lusk, Ralph Butler, Terrence Disz, Robert Olson, Ross Overbeek, Rick Stevens, D.H.D. Warren, Alan Calderwood, Peter Szeridi, Seif Haridi, Per Brand, Mats Carlsson, Andrzej Ciepielewski, and Bogumil Hausman. </author> <title> The Aurora or-parallel Prolog system. </title> <journal> New Generation Computing, </journal> <volume> 7(2, 3):243-271, 1990. BIBLIOGRAPHY 119 </volume>
Reference-contexts: This computation has two workers, which are currently exploring alternate branches in the or-tree. 2.1.2 The Binding Array Model The binding array model has been used in both one version of the SRI-Model [War87] and the Aurora system <ref> [LBD + 90] </ref>. Each worker maintains an array of bindings, with shared variables having the same index into the array across workers.
Reference: [LK88] <author> Y. J. Lin and V. Kumar. </author> <title> And-parallel execution of logic programs on a shared memory multiprocessor: A summary of results. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Proceedings of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1123-1141, </pages> <address> Seatle, 1988. </address> <publisher> ALP, IEEE, The MIT Press. </publisher>
Reference-contexts: An example of the run-time approach is Lin and Kumar's bit-vector model <ref> [LK88] </ref>. The bit vector model essentially associates a token with each variable in a clause. The tokens are passed from literal to literal, with a literal becoming available for execution when it holds the tokens for all the shared variables that it uses.
Reference: [Llo84] <author> John W. Lloyd. </author> <booktitle> Foundations of Logic Programming. Springer series in symbolic computation. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: Most of this terminology is derived from Lloyd <ref> [Llo84] </ref>. 1.2.1 First Order Logic Most logic programming has first order logic as a foundation. This section provides an informal guide to the terminology of first order logic. 1.2. SOME PRELIMINARIES 3 First order theories are built from variables, constants and function and predicate symbols. <p> The constraint theory of Herbrand equality interprets the equality predicate as equality on Herbrand terms. 1.2.4 Lattices Lattices are a generalisation of ordered sets and are useful in describing the logical semantics of logic programming. This characterisation of lattices is taken from <ref> [Llo84] </ref>. A relation R on a set S is a partial order if xRx, xRy ^ yRx ! x = y and xRy ^ yRz ! xRz for all x; y; z 2 S. A poset is a set with some partial ordering. <p> Further suppose that there exists an interpretation, p, which is in T C, and has a domain covering all guards in P i = Q. Then Q p is continuous. Proof The proof is a suitable variation of that in <ref> [Llo84] </ref>. Q p is continuous if lub ( Q p X) = Q p lub (X) for all directed sets X. <p> See <ref> [Llo84] </ref>. Theorem 4.3.1 (Fixpoint characterisation of the AKL) Suppose P is an indifferent, guard stratified program, partitioned into sub-programs fP 1 ; : : : ; P m g. Further suppose that p is a model in T C for P 1 [ [ P i1 . <p> Further suppose that p is a model in T C for P 1 [ [ P i1 . Then P i p " ! is a model for T C [ P 1 [ [ P i . Proof This proof is, again, a variation on <ref> [Llo84] </ref>. To start with, v is a model for P i if P i p v v v since v is a model for P i if, for each H $ 2 P i , v H = v . <p> An and-box is stable if the box is suspended and quiet. 58 CHAPTER 5. THE DAM 5.3.1 Constraints The constraint system used in the DAM is the familiar constraint system of equality over Herbrand terms <ref> [Llo84] </ref>. Terms are built from constants, function symbols with a fixed number of arguments, and variables. Variable Localisation The AKL computation model allows a hierarchy of constraints, with both variables and constraints being local to a specific and-box.
Reference: [LM92] <author> Thomas LeBlanc and Evangelos Markatos. </author> <title> Shared memory vs. message passing in shared memory multiprocessors. </title> <type> Technical report, </type> <institution> University of Rochester, Rochester, </institution> <address> NY 14627, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: An initial design did take the message passing approach, with disappointing results. LeBlanc and Markatos report that the advantages to message passing are often outweighed by the effects of load imbalance <ref> [LM92] </ref>. The assumed target architecture for the abstract machine can therefore be summarised as: * Multiple Instruction, Multiple Data. Each processor can execute a separate thread of the computation. * Modestly Parallel. Only a few (possibly less than 10) processors.
Reference: [MA96] <author> Johan Montelius and Khari A. M. Ali. </author> <title> An and/or-parallel implementation of AKL. </title> <journal> New Generation Computing, </journal> <volume> 14(1) </volume> <pages> 31-52, </pages> <year> 1996. </year>
Reference-contexts: This approach has been taken by Moolenaar and Demoen for the ParAKL system [MD93]. Another approach is taken by Montelius and Ali in the Penny parallel abstract machine, where each variable that is constrained further down the and-box hierarchy maintains a list of suspensions <ref> [MA96] </ref>. Both these approaches have a non-constant access time for determining bindings. The approach taken by the DAM is to treat each variable as a parent variable and a hierarchy of localised copies. <p> Figure 5.6 shows an example of two workers adding variables. An alternative to maintaining a list of local variables is to mark a promoted and-box as promoted and to allow the locality checks to follow the chain of promoted and-boxes up to the actual and-box <ref> [MA96] </ref>. This method is superior to the method in the DAM, as it both saves on the memory used by the list and the time taken to promote the variables. The cost of following the and-box chain 60 CHAPTER 5. THE DAM 5.3. <p> Copying is also used in Montelius and Ali's implementation of Penny <ref> [MA96] </ref>. When an and-box becomes stable, the tree below the and-box is searched for a choice-box which has as its first and-box an and-box which has completed its guard and is waiting for commitment. This choice-box can then be used as the basis for a single nondeterminate promotion. <p> However, use of localised variables in the DAM means that there are no readily available hash windows for maintaining multiple bindings. The DAM copies box-trees in a manner similar to copying garbage collection. This approach is also used in the AGENTS abstract machine [Jan94] and the Penny system <ref> [MA96] </ref>. Each object that is part of the structure being copied is allocated a new block of memory and copied across. As each structure is copied its first word is replaced by a relocation term, giving the address of the copied object. <p> For purposes of comparison, the benchmarks were run on the following implementations: NU-Prolog [ZT86] An example of a sequential Prolog system built around the WAM. Version 1.6.5 was used. AGENTS [Jan94] The SICS sequential AGENTS abstract machine, version 1.0. Penny <ref> [MA96] </ref> The experimental SICS parallel AKL abstract machine. DAM Doug's Abstract Machine. <p> Thy middle ground between NU-Prolog and the DAM can be expected to be occupied by AGENTS and Penny. 5.6 Related Work The closest relation to the DAM is the Penny parallel machine and its sequential predecessor, the AGENTs abstract machine <ref> [MA96, Jan94] </ref>. Both these machines use a system of configuration-stacks to control the computation, rather than the box-based approach of the DAM.
Reference: [MD93] <author> Remco Moolenaar and Bart Demoen. </author> <title> A parallel implementation for AKL. </title> <booktitle> In Programming Language Implementation and Logic Programming: PLILP'93, </booktitle> <pages> pages 246-261, </pages> <year> 1993. </year>
Reference-contexts: One solution to this problem is to use hash-tables to record the local constraints on a variable. This approach has been taken by Moolenaar and Demoen for the ParAKL system <ref> [MD93] </ref>. Another approach is taken by Montelius and Ali in the Penny parallel abstract machine, where each variable that is constrained further down the and-box hierarchy maintains a list of suspensions [MA96]. Both these approaches have a non-constant access time for determining bindings. <p> Table 5.12: Benchmarks and worker re-synchronisation appears to be potentially expensive. The hash window model (see section 2.1.1) has been used successfully in the ParAKL machine <ref> [MD93] </ref>. However, use of localised variables in the DAM means that there are no readily available hash windows for maintaining multiple bindings. The DAM copies box-trees in a manner similar to copying garbage collection. This approach is also used in the AGENTS abstract machine [Jan94] and the Penny system [MA96]. <p> The tendency of the DAM to perform breadth-first search, and the granularity problems that it experiences suggests that the DAM should use a stacking-based scheduler for at least some of its work. The ParAKL system <ref> [MD93] </ref> uses hash tables to maintain multiple binding environments. The Andorra-I system [SCWY91a] is intended for use with the basic Andorra model and therefore does not need the complications of multiple binding environments.
Reference: [MD94] <author> Remco Moolenaar and Bart Demoen. </author> <title> Hybrid tree search in the Andorra model. </title> <editor> In Pascal Van Hentenryck, editor, </editor> <booktitle> Proceedings of the Eleventh International Conference on Logic Programming, </booktitle> <pages> pages 110-123. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: A more intelligent search rule would examine other alternatives and choose those with the minimum number of alternatives and the minimum number of constraints. Moolenaar and Demoen have found that an intelligent search rule can improve search performance by 2-3 times <ref> [MD94] </ref>. Another approach would be to provide a programmable search system, similar to Pandora [Bah91]. When a choice-box is selected for copying, a duplicate of the parent and-box and all child-boxes is created and added to the parent choice box.
Reference: [MH90] <author> K. Muthukumar and M. V. Hermenegildo. </author> <title> The DCG, UDG, and MEL methods for automatic compile-time parallelization of logic programs for independent and-parallelism. </title> <editor> In David H. D. Warren and Peter Szeredi, editors, </editor> <booktitle> Proceedings of the Seventh International Conference on Logic Programming, </booktitle> <pages> pages 221-236, </pages> <address> Jerusalem, 1990. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Conditional graph expressions are well suited to optimisation by compile-time analysis, as the expressions can be grouped and manipulated by various forms of static analysis <ref> [MH90, XG88] </ref>. Conditional graph expressions also provide a means for handling nondeterministic and-parallelism. A failure while executing sequentially can be handled in the normal backtracking manner.
Reference: [MH92] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Compile-time derivation of variable dependency using abstract interpretation. </title> <journal> The Journal of Logic Programming, </journal> <volume> 13(1, 2, 3 and </volume> 4):315-347, 1992. 
Reference-contexts: The simple semantics of logic programming languages make them ideal for abstract interpretation, and abstract interpretation models have been used for several purposes, such as variable dependence tests for independent and-parallelism <ref> [MH92] </ref>, specialising versions of predicates [Win92] and compile-time garbage collection [MWB90]. An abstract interpretation involves two posets, a concrete domain, denoted by &lt; E; &gt;, that is an accurate representation of the computation and an abstract domain &lt; D; v&gt; that represents some useful abstraction of the concrete domain.
Reference: [Mil91] <author> H-akan Millroth. </author> <title> Reforming compilation of logic programs. </title> <editor> In Vijay Saraswat and Kazunori Ueda, editors, </editor> <booktitle> Logic Programming, Proceedings of the 1991 International Symposium, </booktitle> <pages> pages 485-502, </pages> <address> San Diego, USA, 1991. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Data-flow models, such as Kacsuk's 3DPAM [Kac92] or Zhang's DIALOG [ZT91], model the and-or tree by means of tokens passing between the nodes of the tree. Reform parallelism <ref> [Mil91] </ref> is a form of vector parallelism where recursively defined predicates are flattened into iterative loops and constructed so as to allow execution on a vector parallel processor. 18 CHAPTER 2.
Reference: [MJT91] <author> L. Matyska, A. Jergova, and D. Toman. </author> <title> Register allocation in WAM. </title> <editor> In Koichi Furukawa, editor, </editor> <booktitle> Proceedings of the Eighth International Conference on Logic Programming, </booktitle> <pages> pages 142-156, </pages> <address> Paris, France, 1991. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: The DAM uses a register passing convention for passing arguments to calls; an ideal register allocation would ensure that terms which are used as arguments to calls are always pre-placed. Generating an optimal register allocation is known to be an NP-hard problem <ref> [MJT91] </ref>. However register allocation for the DAM essentially needs to satisfy only two criteria: a term remains in a register while it is in use and a term is placed in a calling register if it is to be used in the next call. <p> When a term stops being requested by the future, the term can be discarded from the set of register allocations, allowing the register to be re-allocated. The two stream approach combines both optimal register placement and liveness analysis. Following Matyska et al. <ref> [MJT91] </ref>, we use the following terminology. An inline call is a call to a primitive inline predicate, eg. unification or arithmetic operations. An out of line call is a call to any other predicate.
Reference: [MNL88] <author> K. Marriott, L. Naish, and J.-L. Lassez. </author> <title> Most specific logic programs. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Proceedings of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 909-923, </pages> <address> Seatle, 1988. </address> <publisher> ALP, IEEE, The MIT Press. </publisher>
Reference-contexts: An example of top-down abstract interpretations is the general framework described by Bruynooghe et al. [BJ88], Another example is multiple specialisation [JLW90], which allows the creation of multiple, specialised versions of a predicate, selected by run-time tests. Most specific logic programs <ref> [MNL88] </ref> can be used to generate more efficient versions of programs; an example of bottom up abstract interpretation is the generation of most specific programs [MS92]. Abstract interpretations may also be based on a parallel or sequential model of interpretation.
Reference: [Mon97] <author> Johan Montelius. </author> <title> Exploiting Fine-grain Parallelism in Concurrent Constraint Languages. </title> <type> PhD thesis, </type> <institution> Uppsala University, Uppsala, Sweden, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: Creating a localised variable also requires a variable to be allocated to each level as opposed to a single hash-window cell in ParAKL or suspension in Penny. In practise, AKL programs tend to have a fairly shallow nesting of and-boxes <ref> [Mon97] </ref>, reducing the cost of long chains of localised variables. Adding Local Variables As local variables are created, they need to be added to the list of local variables maintained by the and-box that owns them.
Reference: [MS92] <author> Kim Marriott and Harald Stndergaard. </author> <title> Bottom-up dataflow analysis of normal logic programs. </title> <journal> The Journal of Logic Programming, </journal> <volume> 13(1, 2, 3 and </volume> 4):181-204, 1992. 
Reference-contexts: Each operation s in the concrete domain, is mapped onto an abstract operation s 0 in the abstract domain. To be a safe abstract interpretation, the domains must be adjoined <ref> [MS92] </ref>. Definition 6.1.1 Let D and E be complete lattices. The monotonic functions fl : D ! E and ff : E ! D are adjoined iff 8d 2 D; d = ff (fl (d)) and 8e 2 E; e fl (ff (e)). <p> Most specific logic programs [MNL88] can be used to generate more efficient versions of programs; an example of bottom up abstract interpretation is the generation of most specific programs <ref> [MS92] </ref>. Abstract interpretations may also be based on a parallel or sequential model of interpretation. Bottom-up execution is implicitly parallel, as each new fact can be computed independently of all other possible facts. Bottom-up abstract interpretations therefore, are also implicitly parallel.
Reference: [MS93] <author> Maged Michael and Michael Scott. </author> <title> Fast mutual exclusion, even with contention. </title> <type> Technical report, </type> <institution> University of Rochester, Rochester, </institution> <address> NY 14627, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: The costs of ensuring cache coherence seems to be a likely explanation. An alternative to using hardware locks is to use a software locking scheme such as that of Michael and Scott <ref> [MS93] </ref>. Software locks can show significant performance improvement over hardware locks. However special requirements, such as speed bounds, makes implementation of software locks unattractive.
Reference: [MWB90] <author> Anne Mulkers, William Winsborough, and Maurice Bruynooghe. </author> <title> Analysis of shared data structures for compile-time garbage. </title> <editor> In David H. D. Warren and Peter Szeredi, editors, </editor> <booktitle> Proceedings of the Seventh International Conference on Logic Programming, </booktitle> <pages> pages 747-762, </pages> <address> Jerusalem, 1990. </address> <publisher> The MIT Press. 120 BIBLIOGRAPHY </publisher>
Reference-contexts: The simple semantics of logic programming languages make them ideal for abstract interpretation, and abstract interpretation models have been used for several purposes, such as variable dependence tests for independent and-parallelism [MH92], specialising versions of predicates [Win92] and compile-time garbage collection <ref> [MWB90] </ref>. An abstract interpretation involves two posets, a concrete domain, denoted by &lt; E; &gt;, that is an accurate representation of the computation and an abstract domain &lt; D; v&gt; that represents some useful abstraction of the concrete domain.
Reference: [Nai86] <author> Lee Naish. </author> <title> Negation and control in Prolog. </title> <booktitle> Number 238 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: As a result, dependent and-parallel languages tend to be committed choice languages | Concurrent Prolog, Parlog, GHC | which enforce determinism. The roots of the Andorra model can be found in Naish's thesis <ref> [Nai86] </ref>. Naish proposed that a desirable computation rule would choose atoms in the following order: tests that were likely to fail, deterministic calls, non-deterministic calls with a finite number of solutions, non-deterministic calls likely to cause loops and uninstantiated system predicates (eg. negation).
Reference: [Nai88] <author> Lee Naish. </author> <title> Parallelizing NU-Prolog. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Proceedings of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1546-1564, </pages> <address> Seatle, 1988. </address> <publisher> ALP, IEEE, The MIT Press. </publisher>
Reference-contexts: CP [Sar87] is a formal unification of the various features of don't know and don't care non-determinism, and the various synchronisation features that different CCLs supply. The Andorra model, discussed in the next chapter, and Parallel NU-Prolog <ref> [Nai88] </ref> have similar behaviour to CCLs, but allow restricted nondeterminism. <p> Early versions of the Andorra model for dependent and-parallelism go back to Yang's P-Prolog [YA87], where sets of alternate clauses were chosen by means of explicitly grouping them together. Naish's parallel NU-Prolog <ref> [Nai88] </ref> is also implicitly organised about the Andorra model; goals delay until sufficient information becomes available to commit to a single clause. 3.1 The Basic Andorra Model The Andorra model was first named by D.H.D.
Reference: [Nai89] <author> Lee Naish. </author> <title> Proving properties of committed choice logic programs. </title> <journal> The Journal of Logic Programming, </journal> <volume> 7(1) </volume> <pages> 63-84, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Naish <ref> [Nai89] </ref> uses four different sets to represent potential success and failure in committed choice programs, splitting success sets into definite and potential success sets and failure into definite and potential failure sets. Gabbrielli and Levi [GL92] use an unfolding mechanism to derive a fixpoint semantics for committed choice programs.
Reference: [Nai93] <author> Lee Naish. </author> <title> Applying the Andorra principle. </title> <journal> Australian Computer Science Communications, </journal> <volume> 15(1) </volume> <pages> 191-201, </pages> <year> 1993. </year>
Reference-contexts: The Andorra model collapses this list into a simple distinction between deterministic calls and non-deterministic calls. This distinction can be made by simple run-time tests, making the Andorra model an efficient computation rule <ref> [Nai93] </ref>. Early versions of the Andorra model for dependent and-parallelism go back to Yang's P-Prolog [YA87], where sets of alternate clauses were chosen by means of explicitly grouping them together.
Reference: [Nak92] <author> K. Nakajima. </author> <title> Distributed implementation of kl1 on the multi-psi. </title> <editor> In Peter Kacsuk and Michael J. Wise, editors, </editor> <booktitle> Implementations of Distributed Prolog, </booktitle> <pages> pages 89-118. </pages> <publisher> Wiley, </publisher> <year> 1992. </year>
Reference-contexts: A strictly distributed structure would require copies of terms to be made when a non-local processor needs to refer to those terms. A variety of incremental copying schemes have been designed for use with distributed architectures <ref> [Nak92, Foo94] </ref>. The existence of the DDM suggests that shared memory could be used for reading terms, leaving the actual location of the term to the underlying system [RDC92]. The issue of using shared memory with locks or message passing for updating shared structures is more problematic.
Reference: [PN84] <author> Luis Pereira and Roger Nasr. </author> <title> Delta Prolog: A distributed logic programming language. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 283-291, </pages> <address> Tokyo, Japan, </address> <month> November </month> <year> 1984. </year>
Reference-contexts: Both or- and independent and- parallelism attempt to transparently extract parallelism from Prolog-like programs. Dependent and-parallelism, despite the use of CCLs, still attempts to supply an implied model of parallelism. Process-oriented logic programming languages, such as Delta-Prolog <ref> [PN84] </ref> or CS-Prolog [FF92] use explicit message passing operators to transmit and receive messages between essentially unconnected Prolog processes. Data-flow models, such as Kacsuk's 3DPAM [Kac92] or Zhang's DIALOG [ZT91], model the and-or tree by means of tokens passing between the nodes of the tree.
Reference: [PN91] <author> Doug Palmer and Lee Naish. NUA-Prolog: </author> <title> An extension to the WAM for parallel An-dorra. </title> <editor> In Koichi Furukawa, editor, </editor> <booktitle> Proceedings of the Eighth International Conference on Logic Programming, </booktitle> <pages> pages 429-442, </pages> <address> Paris, France, 1991. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Andorra-I includes a sophisticated pre-processor that allows Andorra-I programs to act exactly like a Prolog program. Andorra Prolog [HB88] is an initial attempt to apply the Andorra model to Prolog. Pandora [BG89] uses the Andorra model in conjunction with Parlog. NUA-Prolog <ref> [PN91] </ref> is a basic application of the BAM to Prolog, using negations instead of cuts. 3.2 Andorra Prolog Andorra Prolog [HB88] is an instance of the BAM. <p> Naively, it should be simple to generate a decision tree covering all possible combinations of bound and unbound arguments. However, the size of the decision tree rapidly grows and, in general, creating a decision tree is NP-Hard <ref> [PN91] </ref>. <p> Alternately, partial indexing is possible, abandoning the indexing when the decision tree becomes too complex and simply trying clauses [SCWY91b]. The approach taken in the DAM is to use the clause set approach developed for NUA-Prolog <ref> [PN91] </ref>. The set of possible clauses is represented by a bit-vector, with each set bit representing a candidate clause. Arguments can then be examined and the set of candidate clauses intersected with the current clause set. <p> The DAM uses a choice-box to perform the same function as a WAM choice-point. However a choice-box can be created remotely, so the creation operation is separated from the try and retry operations. 5.4.5 Indexing and Modes The implementation of NUA-Prolog <ref> [PN91] </ref> constructed clause sets on the heap. The clause sets could be of any size, and could therefore be adapted to any predicate, no matter how large. This generality carried a considerable cost, both in memory usage and the time taken to search for a singleton bit.
Reference: [RDC92] <author> S Raina, Warren D. H. D., and J. Cownie. </author> <title> Parallel prolog on a scalable multiprocessor. </title> <editor> In Peter Kacsuk and Michael J. Wise, editors, </editor> <booktitle> Implementations of Distributed Prolog, </booktitle> <pages> pages 27-44. </pages> <publisher> Wiley, </publisher> <year> 1992. </year>
Reference-contexts: A variety of incremental copying schemes have been designed for use with distributed architectures [Nak92, Foo94]. The existence of the DDM suggests that shared memory could be used for reading terms, leaving the actual location of the term to the underlying system <ref> [RDC92] </ref>. The issue of using shared memory with locks or message passing for updating shared structures is more problematic. In an implementation of AKL, most data structures will be updated by a single processor most of the time.
Reference: [Rou75] <author> P. Roussel. </author> <title> Prolog: Manuel de reference et d'utilisation. </title> <type> Technical report, </type> <institution> Universite d'Aix-Marseille, Groupe d'Intelligence Artificielle, </institution> <year> 1975. </year>
Reference-contexts: Introduction Logic Programming [Kow74] and its practical realisation in Prolog <ref> [Rou75] </ref> introduced a new paradigm to computer science. Logic programming has a declarative model, where programs are represented by relationships between entities, rather than by instructions on how to solve problems (the imperative model).
Reference: [Sar87] <author> Vijay A. Saraswat. </author> <title> The concurrent logic programming language CP: definition and operational semantics. </title> <booktitle> In Conference Record of the Fourteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-62, </pages> <address> Munich, West Germany, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: Over time, these languages have devolved as features that are difficult to implement and do not seem to be needed by programmers are stripped from them. An entertaining review of the CCLs and their devolution can be found in [Tic95]. CP <ref> [Sar87] </ref> is a formal unification of the various features of don't know and don't care non-determinism, and the various synchronisation features that different CCLs supply. The Andorra model, discussed in the next chapter, and Parallel NU-Prolog [Nai88] have similar behaviour to CCLs, but allow restricted nondeterminism.
Reference: [SC93] <author> V itor Santos Costa. </author> <title> Compile-Time Analysis for the Parallel Execution of Logic Programs in Andorra-I. </title> <type> PhD thesis, </type> <institution> University of Bristol, Bristol, UK, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: Warren at a Gigalips meeting in 1987, who pointed out that determinism could be made the basis of transparently exploiting dependent and-parallelism. This model is the Basic Andorra Model or BAM. A description of the BAM can be found in Santos Costa's thesis <ref> [SC93] </ref>. <p> The BAM also prevents nondeterministic independent and-parallelism, as a single goal is chosen for forking. The Extended Andorra Model (EAM) was designed by Warren to allow the detection of most parallelism within a logic program. A Description of the EAM can be found in Santos Costa's thesis <ref> [SC93] </ref>. EAM computations are formally defined in terms a set of rewrite rules on trees of boxes:.
Reference: [Sch95] <author> Erik Schon. </author> <title> On the computation of fixpoints in static program analysis with an application of analysis of AKL. </title> <type> Technical Report R95:06, </type> <institution> Swedish Institute of Computer Science, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: The main existing form of abstract interpretation for the AKL is that of Sjoland and Sahlin [SS95] which uses top down interpretation to derive a set of pre- and post- call domain equations which can be solved. A variety of methods for solving the equations are examined by Schon <ref> [Sch95] </ref>. An alternative to directly using top-down abstract interpretation for top-down, parallel execution models is to build an equivalent bottom-up execution model and use that model to derive the abstract interpretation.
Reference: [SCWY91a] <author> Vtor Santos Costa, David H. D. Warren, and Rong Yang. </author> <title> The Andorra-I engine: A parallel implementation of the basic Andorra model. </title> <editor> In Koichi Furukawa, editor, </editor> <booktitle> Proceedings of the Eighth International Conference on Logic Programming, </booktitle> <pages> pages 825-839, </pages> <address> Paris, France, 1991. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: The tendency of the DAM to perform breadth-first search, and the granularity problems that it experiences suggests that the DAM should use a stacking-based scheduler for at least some of its work. The ParAKL system [MD93] uses hash tables to maintain multiple binding environments. The Andorra-I system <ref> [SCWY91a] </ref> is intended for use with the basic Andorra model and therefore does not need the complications of multiple binding environments. Similarly, Pandora [Bah91] is based on Parlog and the JAM and does not need to consider such complications. 84 CHAPTER 5.
Reference: [SCWY91b] <author> Vtor Santos Costa, David H. D. Warren, and Rong Yang. </author> <title> The Andorra-I preprocessor: Supporting full Prolog on the basic Andorra model. </title> <editor> In Koichi Furukawa, editor, </editor> <booktitle> Proceedings of the Eighth International Conference on Logic Programming, </booktitle> <pages> pages 443-456, </pages> <address> Paris, France, 1991. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: The BAM is an idealised description of the Andorra model. To become a practical system, an instance of the BAM needs to supply such details as how determinism is detected and how extra-logical features (eg. cut) are handled. There are a number of applications of the BAM: Andorra-I <ref> [SCWY91b] </ref> is a parallel version of the BAM which executes Prolog programs. Andorra-I includes a sophisticated pre-processor that allows Andorra-I programs to act exactly like a Prolog program. Andorra Prolog [HB88] is an initial attempt to apply the Andorra model to Prolog. <p> The solution suggested in Haridi and Brand's description of Andorra Prolog is to have a relaxed form of cut, one which acts as a normal cut during or-extension, but relaxes and acts in a similar manner to a commit during and-reduction. The implementation of Andorra-I <ref> [SCWY91b] </ref> provides a mechanism that enforces the semantics of the Prolog cut. A preprocessor identifies red cuts, and inserts a sequencing operator (written as :: ) into the code. All goals to the left of the sequencing operator must complete before any goals to the right are executed. <p> If the expected input modes are known (e.g. from a moded logic programming language such as Concurrent Prolog or Pandora) then the decision tree can be generated directly [KS88, KT91]. Alternately, partial indexing is possible, abandoning the indexing when the decision tree becomes too complex and simply trying clauses <ref> [SCWY91b] </ref>. The approach taken in the DAM is to use the clause set approach developed for NUA-Prolog [PN91]. The set of possible clauses is represented by a bit-vector, with each set bit representing a candidate clause.
Reference: [Sha83] <author> Ehud Y. Shapiro. </author> <title> A subset of Concurrent Prolog and its interpreter. </title> <type> Technical Report ICOT TR-003, </type> <institution> Institute for New Generation Computer Technology, </institution> <address> Tokyo, Japan, </address> <year> 1983. </year> <note> BIBLIOGRAPHY 121 </note>
Reference-contexts: The computation then commits to the remaining solution. This process of commitment gives the class of languages that support this feature the name of Committed Choice Languages (CCLs). The various committed choice languages: Concurrent Prolog <ref> [Sha83] </ref>, Parlog [CG86], GHC [Ued86] and KL1 [UC90] all share similar features. Over time, these languages have devolved as features that are difficult to implement and do not seem to be needed by programmers are stripped from them.
Reference: [Sha86] <author> E. Shapiro. </author> <title> Concurrent Prolog: A progress report. </title> <booktitle> In Fundamentals of Artificial Intelligence, number lncs 232, </booktitle> <pages> pages 277-313. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: In this example, the object is represented by the stream on Io. The two writers produce streams of messages which are merged and forwarded to the Io stream. Incomplete Messages Incomplete messages <ref> [Sha86] </ref> extend the object-oriented model described above by providing a mechanism for back communication. If an uninstantiated variable is included in the arguments of a message, that variable may be bound by the predicate which is handling the object's messages.
Reference: [She92] <author> Kish Shen. </author> <title> Exploiting dependent and-parallelism in Prolog. The dynamic dependent and-parallel scheme (DDAS). </title> <editor> In Krzysztof Apt, editor, </editor> <booktitle> Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 717-731, </pages> <address> Wash-ington, USA, 1992. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Ptah allows the reactive programming of section 2.3.2. However, the amount of mode information needed to identify producers and consumers can make for a quite onerous task, removing the attractive conciseness of logic programming. Shen's Dynamic Dependent And-Parallel Scheme (DDAS) <ref> [She92, She93] </ref> provides transparent exploitation of and-parallelism. Conceptually, the scheme is a token-passing system similar to the IAP model discussed in section 2.2.1. Each variable has a producer token which is initially given to the left-most and-node that refers to the variable.
Reference: [She93] <author> Kish Shen. </author> <title> Implementing dynamic dependent and-parallelism. </title> <editor> In David S. Warren, editor, </editor> <booktitle> Proceedings of the Tenth International Conference on Logic Programming, </booktitle> <pages> pages 167-183. </pages> <publisher> MIT Press, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: Ptah allows the reactive programming of section 2.3.2. However, the amount of mode information needed to identify producers and consumers can make for a quite onerous task, removing the attractive conciseness of logic programming. Shen's Dynamic Dependent And-Parallel Scheme (DDAS) <ref> [She92, She93] </ref> provides transparent exploitation of and-parallelism. Conceptually, the scheme is a token-passing system similar to the IAP model discussed in section 2.2.1. Each variable has a producer token which is initially given to the left-most and-node that refers to the variable.
Reference: [SIC88] <author> SICS. </author> <title> Sicstus Prolog user's manual. </title> <type> Technical Report R88007B, </type> <institution> Swedish Institute of Computer Science, </institution> <year> 1988. </year>
Reference-contexts: Although standard Prolog always evaluates parts of a body in strict left to right order, more advanced versions of Prolog, such as NU-Prolog [ZT86] or SICStus Prolog <ref> [SIC88] </ref> allow a user-defined order of evaluation. Rather than order independence, parts of goals can be evaluated in parallel, giving Prolog an inherently parallel character.
Reference: [Som87] <author> Z. Somogyi. </author> <title> A system of precise models for logic programs. </title> <editor> In Jean-Louis Lassez, editor, </editor> <booktitle> Proceedings of the Fourth International Conference on Logic Pro gramming, MIT Press Series in Logic Programming, </booktitle> <pages> pages 769-787, </pages> <address> Melbourne, 1987. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Other approaches combine don't know nondeterminism and DAP. Ptah <ref> [Som87, SRV88, Som89] </ref> uses strict mode declarations to identify the producers and consumers of variable bindings. The strict mode declarations allow a data-flow graph to be built for the computation. If a part of the computation fails, the source of the original binding that caused 2.4.
Reference: [Som89] <author> Zoltan Somogyi. </author> <title> A parallel logic programming system based on strong and precise modes. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Mel-bourne, Australia, </address> <month> January </month> <year> 1989. </year> <type> Technical Report 89/4. </type>
Reference-contexts: Other approaches combine don't know nondeterminism and DAP. Ptah <ref> [Som87, SRV88, Som89] </ref> uses strict mode declarations to identify the producers and consumers of variable bindings. The strict mode declarations allow a data-flow graph to be built for the computation. If a part of the computation fails, the source of the original binding that caused 2.4.
Reference: [SRV88] <author> Zoltan Somogyi, Kotagiri Ramamohanarao, and Jayen Vaghani. </author> <title> A stream and-parallel execution algorithm with backtracking. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Proceedings of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1142-1159, </pages> <address> Seatle, 1988. </address> <publisher> ALP, IEEE, The MIT Press. </publisher>
Reference-contexts: Other approaches combine don't know nondeterminism and DAP. Ptah <ref> [Som87, SRV88, Som89] </ref> uses strict mode declarations to identify the producers and consumers of variable bindings. The strict mode declarations allow a data-flow graph to be built for the computation. If a part of the computation fails, the source of the original binding that caused 2.4.
Reference: [SS95] <author> Thomas Sjoland and Dan Sahlin. </author> <title> Fixpoint analysis of type and alias in AKL programs. </title> <type> Technical Report R94:13b, </type> <institution> Swedish Institute of Computer Science, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: As a result, the abstract interpretation must take account of these possibilities. An example of a top-down abstract interpretation that handles parallelism is Codish's suspension analysis [Cod91]. The main existing form of abstract interpretation for the AKL is that of Sjoland and Sahlin <ref> [SS95] </ref> which uses top down interpretation to derive a set of pre- and post- call domain equations which can be solved. A variety of methods for solving the equations are examined by Schon [Sch95].
Reference: [Sta80] <author> T. A. Standish. </author> <title> Data Structure Techniques. </title> <publisher> Addison-Wesley, </publisher> <year> 1980. </year>
Reference-contexts: The results are summarised in table 5.3. Using locking results in a massive overhead on what should be a simple operation. Each processor therefore should be given a private heap to manipulate. Heap allocation follows a "fast fit" allocation strategy <ref> [Sta80] </ref>. The heap consists of a top of heap pointer and a set of free lists, grouped into blocks of size ranging from 1 word to 64 words (the maximum structure size).
Reference: [Tic95] <author> Evan Tick. </author> <title> The deevolution of concurrent logic programming languages. </title> <journal> JLP, </journal> <volume> 23(1, 2, </volume> 3):89-124, 1995. 
Reference-contexts: Over time, these languages have devolved as features that are difficult to implement and do not seem to be needed by programmers are stripped from them. An entertaining review of the CCLs and their devolution can be found in <ref> [Tic95] </ref>. CP [Sar87] is a formal unification of the various features of don't know and don't care non-determinism, and the various synchronisation features that different CCLs supply. The Andorra model, discussed in the next chapter, and Parallel NU-Prolog [Nai88] have similar behaviour to CCLs, but allow restricted nondeterminism.
Reference: [UC90] <author> K. Ueda and T. Chikayama. </author> <title> Design of the kernel language for the parallel inference machine. </title> <journal> The Computer Journal, </journal> <volume> 33(6) </volume> <pages> 494-500, </pages> <year> 1990. </year>
Reference-contexts: The computation then commits to the remaining solution. This process of commitment gives the class of languages that support this feature the name of Committed Choice Languages (CCLs). The various committed choice languages: Concurrent Prolog [Sha83], Parlog [CG86], GHC [Ued86] and KL1 <ref> [UC90] </ref> all share similar features. Over time, these languages have devolved as features that are difficult to implement and do not seem to be needed by programmers are stripped from them. An entertaining review of the CCLs and their devolution can be found in [Tic95].
Reference: [Ued86] <author> Kazunori Ueda. </author> <title> Guarded Horn Clauses. </title> <type> PhD thesis, </type> <institution> University of Tokyo, </institution> <address> Tokyo, Japan, </address> <month> March </month> <year> 1986. </year>
Reference-contexts: The computation then commits to the remaining solution. This process of commitment gives the class of languages that support this feature the name of Committed Choice Languages (CCLs). The various committed choice languages: Concurrent Prolog [Sha83], Parlog [CG86], GHC <ref> [Ued86] </ref> and KL1 [UC90] all share similar features. Over time, these languages have devolved as features that are difficult to implement and do not seem to be needed by programmers are stripped from them. An entertaining review of the CCLs and their devolution can be found in [Tic95].
Reference: [UF88] <author> K. Ueda and K Furukawa. </author> <title> Transformation rules for ghc programs. </title> <editor> In ICOT, editor, </editor> <booktitle> Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 582-591, </pages> <publisher> ICOT, </publisher> <address> Japan, </address> <month> December </month> <year> 1988. </year>
Reference-contexts: Flat CCLs restrict guard atoms to being primitive operations, such as unification and arithmetic comparison, as opposed to deep guards, where the guards may be arbitrary literals. Examples of flat CCLs are FCP [YKS90] and Flat GHC <ref> [UF88] </ref>. The main motivation for introducing flat languages is the difficulty of implementing deep guards. A full implementation of deep guards requires separate binding environments for each guard computation, making it as least a hard a problem as or-parallelism.
Reference: [War80] <author> David H. D. Warren. </author> <title> Logic programming and compiler writing. </title> <journal> Software Practise and Experience, </journal> <volume> 10(2) </volume> <pages> 97-125, </pages> <year> 1980. </year>
Reference-contexts: Sorting the goals gives the sequence r (X), p (X, Y), q (Y, X). 98 CHAPTER 6. AN AKL COMPILER 6.2 Compilation on Partial Information The advantages of logic programming languages for compilers have been recognised since <ref> [War80] </ref>. Most compilation can be viewed as a meta-interpretation of the source code, evaluating it to the point that it can be transformed into another target language.
Reference: [War83] <author> David H.D. Warren. </author> <title> An abstract Prolog instruction set. </title> <type> Technical Note 309, </type> <institution> SRI International, </institution> <address> Menlo Park, California, </address> <month> October </month> <year> 1983. </year>
Reference-contexts: Elements from the WAM design can be seen in most abstract machines for logic programming languages. A complete description of the WAM can be found in <ref> [War83] </ref>. A more approachable description can be found in [AK91a]. The basic WAM architecture consists of three main data areas, a set of registers and an instruction set. These elements are summarised in table 5.1.
Reference: [War87] <author> D.H.D. Warren. </author> <title> The SRI model for or-parallel execution of Prolog: Abstract design and implementation. </title> <booktitle> In Proceedings of the 1987 Symposium on Logic Programming, </booktitle> <pages> pages 92-102, </pages> <address> San Francisco, </address> <month> August - September </month> <year> 1987. </year> <title> IEEE, </title> <publisher> Computer Society Press. 122 BIBLIOGRAPHY </publisher>
Reference-contexts: A computation for the example from figure 2.1 using hash windows is shown in figure 2.2. This computation has two workers, which are currently exploring alternate branches in the or-tree. 2.1.2 The Binding Array Model The binding array model has been used in both one version of the SRI-Model <ref> [War87] </ref> and the Aurora system [LBD + 90]. Each worker maintains an array of bindings, with shared variables having the same index into the array across workers.
Reference: [WH88] <author> David H. D. Warren and Seif Haridi. </author> <title> The data diffusion machine: A scalable shared virtual memory multiprocessor. </title> <editor> In ICOT, editor, </editor> <booktitle> Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 943-952, </pages> <publisher> ICOT, </publisher> <address> Japan, </address> <month> December </month> <year> 1988. </year>
Reference-contexts: An example is the Parallel Inference Machine [Got87], where small clusters of processors share local memory but messages are exchanged between clusters. The KSR1 [FBR93] maintains a logically unfragmented address space, with each processor maintaining a cache and no processor "owning" an address. The Data Diffusion Machine (DDM) <ref> [WH88] </ref> allows shared memory access to a system with local memory by providing a hierarchy of data directories.
Reference: [Win92] <author> Will Winsborough. </author> <title> Multiple specialization using minimal-function graph semantics. </title> <journal> The Journal of Logic Programming, </journal> <volume> 13(1, 2, 3 and </volume> 4):259-290, 1992. 
Reference-contexts: The simple semantics of logic programming languages make them ideal for abstract interpretation, and abstract interpretation models have been used for several purposes, such as variable dependence tests for independent and-parallelism [MH92], specialising versions of predicates <ref> [Win92] </ref> and compile-time garbage collection [MWB90]. An abstract interpretation involves two posets, a concrete domain, denoted by &lt; E; &gt;, that is an accurate representation of the computation and an abstract domain &lt; D; v&gt; that represents some useful abstraction of the concrete domain.
Reference: [WR87] <author> H. Westphal and P. Robert. </author> <title> The PEPSys model: Combining backtracking, AND- and OR- parallelism. </title> <booktitle> In Proceedings of the 1987 Symposium on Logic Programming, </booktitle> <pages> pages 436-448, </pages> <address> San Francisco, </address> <month> August - September </month> <year> 1987. </year> <title> IEEE, </title> <publisher> Computer Society Press. </publisher>
Reference-contexts: The essential problem in or-parallelism is how to resolve the multiple binding problem. 2.1.1 The Hash Window Binding Model The hash window binding model was developed by Borgwardt [Bor84] and is used in the Argonne National Laboratory's parallel Prolog [BDL + 88] and the PEPSys system <ref> [WR87] </ref>. Each alternative or-branch maintains a hash table, called a hash window, for storing conditional bindings. When a process makes a binding to a variable that other processes may be able to bind to, the binding is stored in a hash window. <p> By itself the hash window system is very inefficient, as every dereference to a possibly shared variable needs to work through the ascending chain of hash windows. The shallow binding <ref> [BDL + 88, WR87] </ref> optimisation reduces the need for entries in hash windows. Once a workers starts on a branch of the tree, any variables that it creates and then binds need not be entered into the hash window, as the variable is only visible to the creating worker. <p> DEPENDENT AND-PARALLELISM 13 p (0, []). sum ([], S, S). ?-p (5, L), sum (L, 0, S). The And/Or process model [Con83], and its practical realisation in OPAL [Con92] uses a tree of and- and or-processes to collect solutions. Or-processes collect incremental copies of non-ground terms. The PEPSys system <ref> [WR87] </ref> uses hash windows (section 2.1.1) to maintain or-parallelism. Creating a cross-product essentially means creating a cross-product of the candidate hash windows. IAP ensures that there will be no conflicting variable bindings in the hash windows created by different and-branches.
Reference: [XG88] <author> H. Xia and W.K. Giloi. </author> <title> A hybrid scheme for detecting and-parallelism in Prolog programs. </title> <booktitle> In International Conference on Supercomputing, </booktitle> <pages> pages 539-559. </pages> <publisher> ACM Press, </publisher> <month> July </month> <year> 1988. </year>
Reference-contexts: Conditional graph expressions are well suited to optimisation by compile-time analysis, as the expressions can be grouped and manipulated by various forms of static analysis <ref> [MH90, XG88] </ref>. Conditional graph expressions also provide a means for handling nondeterministic and-parallelism. A failure while executing sequentially can be handled in the normal backtracking manner.
Reference: [YA87] <author> Rong Yang and Hideo Aiso. P-Prolog: </author> <title> a parallel logic language based on exclusive relation. </title> <journal> New Generation Computing, </journal> <volume> 5(1) </volume> <pages> 79-95, </pages> <year> 1987. </year>
Reference-contexts: The Andorra model collapses this list into a simple distinction between deterministic calls and non-deterministic calls. This distinction can be made by simple run-time tests, making the Andorra model an efficient computation rule [Nai93]. Early versions of the Andorra model for dependent and-parallelism go back to Yang's P-Prolog <ref> [YA87] </ref>, where sets of alternate clauses were chosen by means of explicitly grouping them together.
Reference: [YKS90] <author> E. Yardeni, S. Kliger, and E. Shapiro. </author> <title> The languages FCP(:,?) </title> <journal> and FCP(:). New Generation Computing, </journal> <volume> 7(2, </volume> 3):89-107, 1990. 
Reference-contexts: Flat CCLs restrict guard atoms to being primitive operations, such as unification and arithmetic comparison, as opposed to deep guards, where the guards may be arbitrary literals. Examples of flat CCLs are FCP <ref> [YKS90] </ref> and Flat GHC [UF88]. The main motivation for introducing flat languages is the difficulty of implementing deep guards. A full implementation of deep guards requires separate binding environments for each guard computation, making it as least a hard a problem as or-parallelism.
Reference: [Zob90] <author> Justin Zobel. </author> <title> Types in Logic Programming. </title> <type> PhD thesis, </type> <institution> University of Melbourne, </institution> <year> 1990. </year>
Reference-contexts: Broad types are both less flexible and less precise than the regular types used by (for example) Zobel <ref> [Zob90] </ref>. It is not possible to represent a general recursive type, such as list = f []; :(&gt;; list)g using broad types. It is also not possible to separate arguments in broad types, e.g. ff (fa; bg); g (fc; dg)g.
Reference: [ZT86] <author> Justin Zobel and James Thom. </author> <title> NU-Prolog reference manual, version 1.0. </title> <type> Technical Report 86/10, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <year> 1986. </year>
Reference-contexts: Although standard Prolog always evaluates parts of a body in strict left to right order, more advanced versions of Prolog, such as NU-Prolog <ref> [ZT86] </ref> or SICStus Prolog [SIC88] allow a user-defined order of evaluation. Rather than order independence, parts of goals can be evaluated in parallel, giving Prolog an inherently parallel character. <p> As a result, the DAM takes almost as long to compute 1 solution to the SEND + MORE = MONEY problem as it takes to compute all solutions. For purposes of comparison, the benchmarks were run on the following implementations: NU-Prolog <ref> [ZT86] </ref> An example of a sequential Prolog system built around the WAM. Version 1.6.5 was used. AGENTS [Jan94] The SICS sequential AGENTS abstract machine, version 1.0. Penny [MA96] The experimental SICS parallel AKL abstract machine. DAM Doug's Abstract Machine.

References-found: 107

