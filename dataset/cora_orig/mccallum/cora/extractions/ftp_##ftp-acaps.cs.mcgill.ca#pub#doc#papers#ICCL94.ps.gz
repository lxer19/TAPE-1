URL: ftp://ftp-acaps.cs.mcgill.ca/pub/doc/papers/ICCL94.ps.gz
Refering-URL: http://www.cs.mcgill.ca/resrchpages/pub94.html
Root-URL: http://www.cs.mcgill.ca
Email: ferosa,hendreng@cs.mcgill.ca  
Title: Taming Control Flow: A Structured Approach to Eliminating Goto Statements  
Author: Ana M. Erosa and Laurie J. Hendren 
Address: Montreal, Quebec H3A 2A7  
Affiliation: School of Computer Science McGill University  
Note: In the Proceedings of the 1994 International Conference on Computer Languages (ICCL'94), pp. 229-240, Toulouse, France, May 16-19, 1994. c fl1994 IEEE. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.  
Abstract: In this paper we present a straight-forward algorithm to structure C programs by eliminating all goto statements. The method works directly on a high-level abstract syntax tree (AST) representation of the program and could easily be integrated into any compiler that uses an AST-based intermediate representation. The actual algorithm proceeds by eliminating each goto by first applying a sequence of goto-movement transformations followed by the appropriate goto-elimination transformation. We have implemented the method in the Mc-CAT (McGill Compiler Architecture Testbed) optimizing/parallelizing C compiler and we present experimental results that demonstrate that the method is both efficient and effective. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers| Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley Pub. Co., </publisher> <address> corrected edition, </address> <year> 1988. </year>
Reference-contexts: One important consequence is that C programs without gotos are compositional, structured analyses techniques can be used to compute data flow information. For example, one can use the efficient techniques available for structured data flow graphs <ref> [1] </ref>, or simple abstract interpretation techniques that need not consider continuation-based semantics. From the program transformation standpoint, compositional programs also lend themselves to simpler and often more efficient algorithms.
Reference: [2] <author> J. R. Allen, Ken Kennedy, Carrie Porterfield, and Joe Warren. </author> <title> Conversion of control dependence to data dependence. </title> <booktitle> In Conf. Rec. of the POPL-10, </booktitle> <pages> pages 177-189, </pages> <address> Austin, Texas, </address> <month> Jan. </month> <year> 1983. </year>
Reference-contexts: This work is similar in spirit to Baker's problem in that she only structures the parts of the program that correspond naturally to structured control constructs. More relevant to our work are the structuring methods proposed by Allen et al for vectorizing compilers <ref> [2] </ref>, and the work by Ammarguellat for parallelizing compilers [3]. Allen et al present the IF conversion method that converts control dependences into data dependences by eliminating goto statements and introducing logical variables to control the execution of the statements.
Reference: [3] <author> Zahira Ammarguellat. </author> <title> A control-flow normalization algorithm and its complexity. </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> 18(3) </volume> <pages> 237-250, </pages> <year> 1992. </year>
Reference-contexts: More relevant to our work are the structuring methods proposed by Allen et al for vectorizing compilers [2], and the work by Ammarguellat for parallelizing compilers <ref> [3] </ref>. Allen et al present the IF conversion method that converts control dependences into data dependences by eliminating goto statements and introducing logical variables to control the execution of the statements. The goal of this work is to vectorize statements in loops which contain conditional transfers in Fortran programs.
Reference: [4] <author> B. Baker. </author> <title> An algorithm for structuring flowgraphs. </title> <journal> Journal of the ACM, </journal> <volume> 24(1) </volume> <pages> 98-120, </pages> <year> 1977. </year>
Reference-contexts: However, there have also been approaches suggested that are used to restructure programs in order to expose the natural structure of the program, leaving some gotos unstructured. The first such method was given by Baker as a method for restructuring Fortran programs <ref> [4] </ref> in order to make them more understandable. Since her goal was understandable Fortran programs, she only restructures in situations where there is a clear use of a structured construct and leaves some gotos in the program.
Reference: [5] <author> Robert A. Balance and Arthur B. Maccabe. </author> <title> Program dependence graphs for the rest of us. </title> <type> Technical report, </type> <institution> The University of New Mexico, </institution> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: This discussion has led to the relatively infrequent use of gotos in typical C programs <ref> [5] </ref>. However, in languages like C, there are still special occasions where programmers like to use gotos. <p> Consider, for example, the efficient creation of the Static Single Assignment (SSA) form for structured programs consisting of straight-line code, if statements, and while statements [8], the structured transformations to the ALPHA dependence representation [12], and the efficient construction of Program Dependence Graphs for structured programs <ref> [5] </ref>. Finally, compositional programs are naturally represented as trees, and intermediate representations based on compositional representations can be manipulated and transformed using a wide variety of strategies including the use of attribute grammars. <p> This means that we apply 1 or 2 movement transformations per goto. Also, we see that we introduce about 3 statements per goto (giving a net increase of 2 statements per goto). These results are consistent with the results of a study done by Bal-lance and Maccabe <ref> [5] </ref>, that indicated that only 2.9% of 119,000 functions examined use gotos. Of those gotos, 68% can be characterized as simple gotos: one target label per function, with one or more associated gotos, where the goto and label are siblings or the goto is an exit from a control structure.
Reference: [6] <author> C. Bohm and G. Jacopini. </author> <title> Flow diagrams, Turing machines and languages with only two formation rules. </title> <journal> Comm. of the ACM, </journal> <volume> 9(5) </volume> <pages> 366-371, </pages> <month> May </month> <year> 1966. </year>
Reference-contexts: Thus, for the vast majority of programs, we can exploit structured representations for designing compilers while paying only a minimal penalty due to restructuring. 5 Related Work One of the first approaches to restructuring was given by Bohm and Jacopini <ref> [6] </ref>. Their restructuring method was done in the context of normalizing flow graphs (where the flow graph represented mappings of a set onto itself).
Reference: [7] <author> C. Cifuentes. </author> <title> A structuring algorithm for decompi-lation. </title> <booktitle> In XIX Conferencia Latinoamericana de In-formatica, </booktitle> <pages> pages 267-276, </pages> <address> Buenos Aires, Argentina, </address> <month> 2-6 August </month> <year> 1993. </year> <institution> Centro Latinoamericano de Estu-dios en Informatica. </institution>
Reference-contexts: This is of historical interest, but since she leaves some gotos in the program, her method is not applicable to the complete restructuring of programs for the purposes of compilation. More recently, Cifuentes has presented an algorithm for restructuring in the context of decom-pilation <ref> [7] </ref>. This work is similar in spirit to Baker's problem in that she only structures the parts of the program that correspond naturally to structured control constructs.
Reference: [8] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: From the program transformation standpoint, compositional programs also lend themselves to simpler and often more efficient algorithms. Consider, for example, the efficient creation of the Static Single Assignment (SSA) form for structured programs consisting of straight-line code, if statements, and while statements <ref> [8] </ref>, the structured transformations to the ALPHA dependence representation [12], and the efficient construction of Program Dependence Graphs for structured programs [5].
Reference: [9] <author> E. W. Dijkstra. </author> <title> Go to statement considered harmful. </title> <journal> Communications of the ACM, </journal> <volume> 11 </volume> <pages> 147-148, </pages> <month> March </month> <year> 1968. </year>
Reference-contexts: 1 Introduction and Motivation Over the years there has been substantial discussion about the use of explicit gotos in high-level programs and there have been many arguments against the frequent use gotos from a software engineering or program understandability point of view <ref> [9, 13, 15] </ref>. This discussion has led to the relatively infrequent use of gotos in typical C programs [5]. However, in languages like C, there are still special occasions where programmers like to use gotos.
Reference: [10] <author> E.Ashcroft and Z. Manna. </author> <title> Translating programs schemas to while-shemas. </title> <journal> SIAM J. Comput, </journal> <volume> 4(2) </volume> <pages> 125-146, </pages> <year> 1975. </year>
Reference-contexts: Ashcroft and Manna tackled the problem of restructuring by presenting two algorithms for converting program schemas into while schemas. Rather than using node-splitting they use extra logical variables to achieve these transformations <ref> [10] </ref>. All of the previous methods were intended to restructure all flow charts. However, there have also been approaches suggested that are used to restructure programs in order to expose the natural structure of the program, leaving some gotos unstructured.
Reference: [11] <author> L. Hendren, C. Donawa, M. Emami, G. Gao, Justiani, and B. Sridharan. </author> <title> Designing the McCAT compiler based on a family of structured intermediate representations. </title> <booktitle> In Conf. Rec. of the 5th Work. on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 261-275, </pages> <address> New Haven, Conn., </address> <month> Aug. </month> <year> 1992. </year> <institution> Dept. of Comp. Sci., Yale U. </institution> <note> Also available as ACAPS 46, </note> <institution> Sch. of Comp. Sci., , Montreal, Que. </institution>
Reference-contexts: We have implemented this method in our McCAT (McGill Compiler Architecture Testbed) parallelizing/optimizing compiler, and thus our compiler can assume fully structured programs for all intermediate forms, analyses and transformations <ref> [11] </ref>. From the pragmatic point of view there are many reasons why programs without gotos are simpler to handle in such compilers. One important consequence is that C programs without gotos are compositional, structured analyses techniques can be used to compute data flow information. <p> we give some experimental results using our implementation of the algorithm presented in this paper. 4.1 McCAT Compiler As shown in Figure 16, the McCAT compiler is based on a family of three intermediate representa tions that range from a high-level abstract representa tion, FIRST, to a low-level representation, LAST <ref> [11] </ref>.
Reference: [12] <author> L. J. Hendren, G. R. Gao, and V. C. Sreed-har. </author> <title> ALPHA: A dependence-based intermediate representation for an optimizing/parallelizing C compiler. </title> <type> ACAPS Tech. Memo 49, </type> <institution> Sch. of Comp. Sci., McGill U., Montreal, Que., </institution> <month> Nov </month> <year> 1992. </year>
Reference-contexts: Consider, for example, the efficient creation of the Static Single Assignment (SSA) form for structured programs consisting of straight-line code, if statements, and while statements [8], the structured transformations to the ALPHA dependence representation <ref> [12] </ref>, and the efficient construction of Program Dependence Graphs for structured programs [5]. Finally, compositional programs are naturally represented as trees, and intermediate representations based on compositional representations can be manipulated and transformed using a wide variety of strategies including the use of attribute grammars.
Reference: [13] <author> D. E. Knuth. </author> <title> Structured programming with go to statements. </title> <journal> Computing Surveys, </journal> <pages> pages 261-302, </pages> <month> Dec </month> <year> 1974. </year>
Reference-contexts: 1 Introduction and Motivation Over the years there has been substantial discussion about the use of explicit gotos in high-level programs and there have been many arguments against the frequent use gotos from a software engineering or program understandability point of view <ref> [9, 13, 15] </ref>. This discussion has led to the relatively infrequent use of gotos in typical C programs [5]. However, in languages like C, there are still special occasions where programmers like to use gotos.
Reference: [14] <author> W.W. Peterson, T. Kasami, and N. Tokura. </author> <title> On the capabilities of while, repeat and exit statements. </title> <journal> Comm. of the ACM, </journal> <volume> 16(8) </volume> <pages> 503-512, </pages> <year> 1973. </year>
Reference-contexts: There have been several approaches to restructuring program flowgraphs. Peterson et al. present a proof that every flowgraph can be transformed into an equivalent well-formed flowchart (loops and conditionals are properly nested and can only entered at the beginning) <ref> [14] </ref>. They present a graph algorithm to do such a transformation using a technique of node-splitting and they proved the transformation was correct.
Reference: [15] <author> P. Wegner. </author> <title> Programming languages the first 25 years. </title> <journal> IEEE Transactions on Computers, </journal> <pages> pages 1207-1225, </pages> <month> Dec </month> <year> 1976. </year>
Reference-contexts: 1 Introduction and Motivation Over the years there has been substantial discussion about the use of explicit gotos in high-level programs and there have been many arguments against the frequent use gotos from a software engineering or program understandability point of view <ref> [9, 13, 15] </ref>. This discussion has led to the relatively infrequent use of gotos in typical C programs [5]. However, in languages like C, there are still special occasions where programmers like to use gotos.
Reference: [16] <author> M.H. Williams. </author> <title> Generating structured flow diagrams: </title> <journal> The nature of unstructuredness. Comput. J, </journal> <volume> 20(1) </volume> <pages> 45-50, </pages> <year> 1977. </year>
Reference-contexts: William and Osher also use node-splitting, but they present the problem as recognizing five basic unstructured sub-graphs, and show how to replace these sub-graphs with equivalent structured forms <ref> [17, 16] </ref>. Ashcroft and Manna tackled the problem of restructuring by presenting two algorithms for converting program schemas into while schemas. Rather than using node-splitting they use extra logical variables to achieve these transformations [10]. All of the previous methods were intended to restructure all flow charts.
Reference: [17] <author> M.H. Williams and H.L. Ossher. </author> <title> Conversion of unstructured flow diagrams to structured. </title> <journal> Comput. J, </journal> <volume> 21(2) </volume> <pages> 161-167, </pages> <year> 1978. </year>
Reference-contexts: William and Osher also use node-splitting, but they present the problem as recognizing five basic unstructured sub-graphs, and show how to replace these sub-graphs with equivalent structured forms <ref> [17, 16] </ref>. Ashcroft and Manna tackled the problem of restructuring by presenting two algorithms for converting program schemas into while schemas. Rather than using node-splitting they use extra logical variables to achieve these transformations [10]. All of the previous methods were intended to restructure all flow charts.
References-found: 17

