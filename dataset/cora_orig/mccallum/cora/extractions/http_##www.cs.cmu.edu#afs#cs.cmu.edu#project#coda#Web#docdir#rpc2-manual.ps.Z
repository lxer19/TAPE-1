URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/coda/Web/docdir/rpc2-manual.ps.Z
Refering-URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/coda/Web/docs-coda.html
Root-URL: 
Title: RPC2 User Guide and Reference Manual  
Author: M. Satyanarayanan (Editor) Richard Draves, James Kistler, Anders Klemets, Qi Lu, Lily Mummert, David Nichols, Larry Raper, Gowthami Rajendran, Jonathan Rosenberg, Ellen Siegel 
Note: Copyright 1985-91 M. Satyanarayanan et al  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: 14 July 1995  
Abstract: This manual describes the programming interface and internal design of RPC2, a highly portable and extensible remote procedure call package for Unix. RPC2 runs on top of the IP/UDP protocol, and provides support for streaming file transfer, parallel RPC calls, and IP-level multicast. The manual also describes two other packages used by RPC2: RP2Gen, a stub generator, and LWP, a coroutine-based lightweight process package. All the software described in this manual runs at user-level on the Unix 4.3BSD interface; no kernel modifications are necessary. The software has been ported to a variety of machine architectures (such as IBM-RT, MIPS, Sun2, Sun3, Sparc, and i386) and to variants of the Unix operating system (such as Mach, SunOS and AIX). This work has been supported by the Defense Advanced Research Projects Agency (Avionics Lab, Wright Research and Development Center, Aeronautical Systems Division (AFSC), U.S. Air Force, Wright-Patterson AFB, Ohio, 45433-6543 under Contract F33615-90-C-1465, ARPA Order No. 7597), the National Science Foundation (CCR-8657907), and the IBM Corporation (Andrew Project, Faculty Development Grant, Research Initiation Grant), and Digital Equipment Corporation (External Research Project). The views and conclusion expressed in this paper are those of the authors, and should not be interpreted as those of DARPA, NSF, IBM, DEC or Carnegie Mellon University. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Satyanarayanan, M. and Okasaki, </author> <title> M.E. (Editors). </title>
Reference-contexts: &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;netinet/in.h&gt; #include &lt;assert.h&gt; #include "lwp.h" #include "rpc2.h" #include "rtime.h" main (argc, argv) int argc; char *argv []; - RPC2 Handle cid; RPC2 Integer tv_sec, tv_usec; int rc ; char msg [200]; if (argc != 2) error_report ("usage: rtime &lt;machine name&gt;"); Init_RPC (); cid = connect_to_machine (argv <ref> [1] </ref>); client makes a remote procedure call to get the time on the server machine rc = GetRTime (cid, &tv_sec, &tv_usec) ; 1-4 if (rc != RPC2 SUCCESS) - sprintf (msg, "%s"nGet remote time on machine %s failed", RPC2 ErrorMsg (rc),argv [1]); error_report (msg); - else - printf ("The remote time <p> rtime &lt;machine name&gt;"); Init_RPC (); cid = connect_to_machine (argv <ref> [1] </ref>); client makes a remote procedure call to get the time on the server machine rc = GetRTime (cid, &tv_sec, &tv_usec) ; 1-4 if (rc != RPC2 SUCCESS) - sprintf (msg, "%s"nGet remote time on machine %s failed", RPC2 ErrorMsg (rc),argv [1]); error_report (msg); - else - printf ("The remote time on machine %s is"n", argv [1]); printf ("tv_sec = %d and tv_usec = %d"n", tv_sec, tv_usec); -; rc = RPC2 Unbind (cid) ; if (rc != RPC2 SUCCESS) error_report ("%s"nCant' close the connection!", RPC2 ErrorMsg (rc)); - ; error_report (message) char <p> call to get the time on the server machine rc = GetRTime (cid, &tv_sec, &tv_usec) ; 1-4 if (rc != RPC2 SUCCESS) - sprintf (msg, "%s"nGet remote time on machine %s failed", RPC2 ErrorMsg (rc),argv <ref> [1] </ref>); error_report (msg); - else - printf ("The remote time on machine %s is"n", argv [1]); printf ("tv_sec = %d and tv_usec = %d"n", tv_sec, tv_usec); -; rc = RPC2 Unbind (cid) ; if (rc != RPC2 SUCCESS) error_report ("%s"nCant' close the connection!", RPC2 ErrorMsg (rc)); - ; error_report (message) char *message; - fprintf (stderr, message); fprintf (stderr, ""n"); exit (1); - Init_RPC () - PROCESS <p> *p; assert (RPC2 GetPrivatePointer (cid, &p) == RPC2 SUCCESS); return (time (0) - p-&gt;Creation); - iopen () is a system call created at the ITC; put a dummy here for other sites iopen ()-- RPC Initialization and Error handling InitRPC () - int mylpid = -1; RPC2 PortalIdent portalid, *portallist <ref> [1] </ref>; RPC2 SubsysIdent subsysid; long rc; assert (LWP Init (LWP VERSION, LWP NORMAL_PRIORITY, &mylpid) == LWP SUCCESS); portalid.Tag = RPC2 PORTALBYINETNUMBER; portalid.Value.InetPortNumber = htons (AUTHPORTAL); portallist [0] = &portalid; rc = RPC2 Init (RPC2 VERSION, 0, portallist, 1, -1, NULL); if (rc != RPC2 SUCCESS) - fprintf (stderr, "RPC2 Init: failed <p> When a packet is sent out on a connection, it acquires this color. Colors have no implicit significance to RPC2. But they can be used by other packages such as the Coda failure emulator package <ref> [1] </ref> to selectively induce failures. For example, in debugging an implementation of a two-phase commit protocol, one needs to test the situation where a failure occurs between the two phases. This situation can be detected by the failure emulator by using packets of different colors for the different phases. <p> "rcat.h" main (argc, argv) int argc; char *argv []; - RPC2 Handle the_connection; char error_msg [100]; char local_cmd [100]; int return_code; char *remotefilename, *servername, localfilename [30]; SE Descriptor sed; get a unique temporary file name if (argc != 3) error_report ("usage: rcat &lt;server name&gt; <remote file name>"); servername = argv <ref> [1] </ref>; remotefilename = argv [2]; sprintf (localfilename, "/tmp/rcat.%d", getpid ()) ; Init_RPC (); the_connection = make_connection (servername); sed.Tag = SMARTFTP; sed.Value.SmartFTPD.Tag = FILEBYNAME; sed.Value.SmartFTPD.FileInfo.ByName.ProtectionBits = 0644; sed.Value.SmartFTPD.TransmissionDirection = SERVERTOCLIENT; sed.Value.SmartFTPD.ByteQuota = -1; strcpy (sed.Value.SmartFTPD.FileInfo.ByName.LocalFileName, localfilename); set the side effect descriptor to store the fetched file in filename return_code = Fetch_Remote_File (the_connection, <p> FILEBYNAME; sed.Value.SmartFTPD.FileInfo.ByName.ProtectionBits = 0644; sed.Value.SmartFTPD.TransmissionDirection = SERVERTOCLIENT; sed.Value.SmartFTPD.ByteQuota = -1; strcpy (sed.Value.SmartFTPD.FileInfo.ByName.LocalFileName, localfilename); set the side effect descriptor to store the fetched file in filename return_code = Fetch_Remote_File (the_connection, remotefilename, &sed); if (return_code == RCAT_FAILED) - sprintf (error_msg, "Failed to get the file %s on machine %s"n", argv [2], argv <ref> [1] </ref>); error_report (error_msg); - else - sprintf (local_cmd, "cat %s", localfilename); system (local_cmd); display the fetched file to the standard output sprintf (local_cmd, "rm -f %s", localfilename); system (local_cmd); remove the temporary tile -; return_code = RPC2 Unbind (the_connection); if (return_code != RPC2 SUCCESS) - sprintf (error_msg, "%s"nCant' close the connection!",
References-found: 1

