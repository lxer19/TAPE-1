URL: http://www.isi.edu:80/people/johnh/PAPERS/Heidemann95c.ps.gz
Refering-URL: http://www.isi.edu:80/people/johnh/PAPERS/Heidemann95c.html
Root-URL: http://www.isi.edu
Title: Performance of Cache Coherence in Stackable Filing  
Author: John Heidemann Gerald Popek 
Address: Los Angeles  
Affiliation: University of California,  
Date: December, 1995.  
Note: To appear, ACM Symposium on Operating Systems Principles,  
Abstract: Individual layers of such a system often need to cache data to improve performance or provide desired functionality. When access to different layers is allowed, cache incoherencies can occur. Without a cache coherence solution, layer designers must either restrict layer access and flexibility or compromise the layered structure to avoid potential data corruption. The value of modular designs such as stacking can be questioned without a suitable solution to this problem. This paper presents a general cache coherence architecture for stackable filing, including a standard approach to data identification as a key component to layered coherence protocols. We also present a detailed performance analysis of one implementation of stack cache-coherence, which suggests that very low overheads can be achieved in practice. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. S. Batory, J. R. Barnett, J. F. Garza, K. P. Smith, K. Tsukuda, B. C. Twichell, and T. E. Wise. </author> <title> GENESIS: An extensible database management system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(11) </volume> <pages> 1711-1730, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: Most data in these systems is transient, and so they do not address cache coherence problems 7 . Databases and file systems have both persistent data and a need for caching. The Genesis work in databases <ref> [1] </ref>, and file system stacking work from UCLA [7, 8], Rosenthal and Skinner at Sun-Soft [22, 25] and the Spring project at Sun Laboratories [12] approach cache coherence in different ways. The Genesis work focuses on modularity and stacking for databases.
Reference: [2] <author> Jeff Bonwick. </author> <title> The slab allocator: An object-caching kernel memory allocator. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 87-98. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: This overhead represents the cost of setting up and maintaining cache coherence data structures. We expect that some of this cost can be avoided by internally preserving partially built data structures <ref> [2] </ref>. Careful tuning and examination of fast-path opportunities could also likely improve our prototype system; we project that a production quality service is quite feasible. The cost of this overhead must also be weighed against the benefits of cache coherence.
Reference: [3] <author> John B. Carter, John K. Bennett, and Willy Zwaenepoel. </author> <title> Implementation and performance of Munin. </title> <booktitle> In Proceedings of the Thirteenth Symposium on Operating Systems Principles, </booktitle> <pages> pages 152-164. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: In distributed shared memory systems software plays a larger role in coherence. Li proposes strong consistency with both centralized and distributed algorithms [15]. Recent work has focused on employing application-specific knowledge to relax the consistency model and obtain better performance <ref> [5, 3] </ref>. 6.3 Stackable layering Early work in joining layers with a symmetric interface developed in several contexts: the Unix shell [19], the Streams I/O system [21], and x-kernel network protocols [10]. Most data in these systems is transient, and so they do not address cache coherence problems 7 .
Reference: [4] <author> Rick Floyd. </author> <title> Short-term file reference patterns in a UNIX environment. </title> <type> Technical Report TR-177, </type> <institution> University of Rochester, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: As in this example, we expect that the majority of such access will be sequential. Floyd's studies of Unix applications in an academic environment suggest that 70-90% of opened files are read sequentially <ref> [4] </ref>. For these cases, the sequential-update benchmark is representative. Sequential-update performance shows some system-time performance cost, but no noticeable elapsed-time performance penalty. The remaining random access case is exemplified by database ap plications. Recall, however, that the random-update benchmark is a stream of randomly located updates to random layers.
Reference: [5] <author> Kourosh Gharachorloo, Daniel Lenoski, James Laudon, Phil-lip Gibbons, Anoop Gupta, and John Hennessy. </author> <title> Memory consistency and event ordering in scalable shared-memory multiprocessors. </title> <booktitle> In Proceedings of the 17th International Symposium on Computer Architecture, </booktitle> <pages> pages 15-26. </pages> <publisher> IEEE, </publisher> <month> May </month> <year> 1990. </year>
Reference-contexts: In distributed shared memory systems software plays a larger role in coherence. Li proposes strong consistency with both centralized and distributed algorithms [15]. Recent work has focused on employing application-specific knowledge to relax the consistency model and obtain better performance <ref> [5, 3] </ref>. 6.3 Stackable layering Early work in joining layers with a symmetric interface developed in several contexts: the Unix shell [19], the Streams I/O system [21], and x-kernel network protocols [10]. Most data in these systems is transient, and so they do not address cache coherence problems 7 .
Reference: [6] <author> Cary Gray and David Cheriton. Leases: </author> <title> An efficient fault-tolerant mechanism for distributed file cache consistency. </title> <booktitle> In Proceedings of the Twelfth Symposium on Operating Systems Principles, </booktitle> <pages> pages 202-210. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1989. </year>
Reference-contexts: Later systems provide variations on the token algorithm: AFS's callbacks are essentially centrally-managed tokens [11]; Gray's leases are tokens that can time-out to simplify error recovery <ref> [6] </ref>. Cache coherence in stacking borrows the basic coherence approach used in these systems.
Reference: [7] <author> Richard G. Guy, John S. Heidemann, Wai Mak, Thomas W. Page, Jr., Gerald J. Popek, and Dieter Rothmeier. </author> <title> Implementation of the Ficus replicated file system. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 63-71. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Today's filing interfaces vary from system to system, and even between point releases of a single operating system. These differences imply that third parties cannot adapt filing interfaces to suit their own needs, nor can they expect their software to function as the base system evolves. Stackable filing <ref> [7, 22, 8] </ref> presents a new approach to the construction of filing services to address these problems. Inspired by fl This work was sponsored by the Advanced Research Projects Agency under contract N00174-91-C-0107. Gerald Popek is also affiliated with Locus Computing Corporation. <p> One could imagine adding compression to the top of this stack as another layer. At UCLA we have constructed a number of services with stackable layers including replicated filing, user-id mapping, a persistent, object-oriented storage service, and prototypes of compression and encryption <ref> [7, 8] </ref>. All of these have been integrated into a full function filing service (SunOS 4.1.1). In UCLA stacking, each layer provides a potentially different view of the underlying data; a user can select different views by accessing a file through different layers. <p> Finally, we describe in Section 5.4 how internal access to different layers occurs in sophisticated filing services. Stacking has been adopted in BSD 4.4 and the Spring operating system [12], and it has been employed extensively at UCLA to develop distributed filing services <ref> [7] </ref>. However, we argue below that suitable incorporation of multi-level cache management is essential to the success of modular systems. <p> Related work and directions for this paper: Our work builds upon two areas of prior research. First, we draw cache coherence algorithms from research in the areas of hardware multiprocessing, distributed filing, and distributed shared memory. Second, we build upon stacking work done at Sun Microsystems [22] and UCLA <ref> [7, 8] </ref>, and cache-coherent stacking work also done at Sun [12]. A complete discussion of related work follows in Section 6. This paper contributes to the architecture of cache coherence in a stacking system. <p> Most data in these systems is transient, and so they do not address cache coherence problems 7 . Databases and file systems have both persistent data and a need for caching. The Genesis work in databases [1], and file system stacking work from UCLA <ref> [7, 8] </ref>, Rosenthal and Skinner at Sun-Soft [22, 25] and the Spring project at Sun Laboratories [12] approach cache coherence in different ways. The Genesis work focuses on modularity and stacking for databases. Cache coherence problems are avoided by not allowing multi-layer access.
Reference: [8] <author> John S. Heidemann and Gerald J. Popek. </author> <title> File-system development with stackable layers. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12(1) </volume> <pages> 58-89, </pages> <year> 1994. </year> <note> Preliminary version available as UCLA technical report CSD-930019. </note>
Reference-contexts: Today's filing interfaces vary from system to system, and even between point releases of a single operating system. These differences imply that third parties cannot adapt filing interfaces to suit their own needs, nor can they expect their software to function as the base system evolves. Stackable filing <ref> [7, 22, 8] </ref> presents a new approach to the construction of filing services to address these problems. Inspired by fl This work was sponsored by the Advanced Research Projects Agency under contract N00174-91-C-0107. Gerald Popek is also affiliated with Locus Computing Corporation. <p> One could imagine adding compression to the top of this stack as another layer. At UCLA we have constructed a number of services with stackable layers including replicated filing, user-id mapping, a persistent, object-oriented storage service, and prototypes of compression and encryption <ref> [7, 8] </ref>. All of these have been integrated into a full function filing service (SunOS 4.1.1). In UCLA stacking, each layer provides a potentially different view of the underlying data; a user can select different views by accessing a file through different layers. <p> Related work and directions for this paper: Our work builds upon two areas of prior research. First, we draw cache coherence algorithms from research in the areas of hardware multiprocessing, distributed filing, and distributed shared memory. Second, we build upon stacking work done at Sun Microsystems [22] and UCLA <ref> [7, 8] </ref>, and cache-coherent stacking work also done at Sun [12]. A complete discussion of related work follows in Section 6. This paper contributes to the architecture of cache coherence in a stacking system. <p> the extent that caching is important at multiple levels of such systems, cache coherence also will be important, and the techniques employed in this paper may also be relevant. 2 Overview of UCLA Stacking Our work on cache coherence takes place in the context of the UCLA stackable filing environment <ref> [8] </ref>. This system has been developed at UCLA since 1990, and portions of it have more recently been incorporated into 4.4BSD Unix. The research environment at the UCLA Ficus project has been hosted under a replicated file system built with stacking since 1991. <p> To provide a uniform vocabulary for the remainder of the paper, we now briefly summarize the original vnode interface and the UCLA stackable filing framework. (Detailed descriptions of the vnode interface [14] and UCLA stacking <ref> [8, 9] </ref> are available elsewhere.) The vnode interface: The vnode interface separates the upper-level kernel from different file system implementations in an object-oriented manner. The upper-level kernel treats files as nearly opaque while each collection of joined triangles represents a file. objects, vnodes. <p> The upper-level kernel treats files as nearly opaque while each collection of joined triangles represents a file. objects, vnodes. Actions on files are invoked via vnode operations which match the desired action with the a particular implementation at run-time. At UCLA <ref> [8] </ref> and Sun [22, 25, 12] the vnode interface has been extended to support file system stacking, extensibility, and distributed filing. We next discuss each component of stackable filing at UCLA, drawing on Figure 2 for illustration. Layer configuration: Each filing service is provided as a layer. <p> Our test machine runs a modified version of SunOS 4.1.1. All data is stored in a stack-enabled version of the standard SunOS 4.1.1 file-system (UFS), a version of Berkeley's Fast Filesystem [16]. For multi-layer tests we add one or more null layers <ref> [8] </ref>. <p> Most data in these systems is transient, and so they do not address cache coherence problems 7 . Databases and file systems have both persistent data and a need for caching. The Genesis work in databases [1], and file system stacking work from UCLA <ref> [7, 8] </ref>, Rosenthal and Skinner at Sun-Soft [22, 25] and the Spring project at Sun Laboratories [12] approach cache coherence in different ways. The Genesis work focuses on modularity and stacking for databases. Cache coherence problems are avoided by not allowing multi-layer access.
Reference: [9] <author> John Shelby Heidemann. </author> <title> Stackable Design of File Systems. </title> <type> Ph.D. dissertation, </type> <institution> University of California, </institution> <address> Los Angeles, </address> <year> 1995. </year>
Reference-contexts: To provide a uniform vocabulary for the remainder of the paper, we now briefly summarize the original vnode interface and the UCLA stackable filing framework. (Detailed descriptions of the vnode interface [14] and UCLA stacking <ref> [8, 9] </ref> are available elsewhere.) The vnode interface: The vnode interface separates the upper-level kernel from different file system implementations in an object-oriented manner. The upper-level kernel treats files as nearly opaque while each collection of joined triangles represents a file. objects, vnodes.
Reference: [10] <author> Norman C. Hutchinson, Larry L. Peterson, Mark B. Ab-bott, and Sean O'Malley. </author> <title> RPC in the x-Kernel: Evaluating new design techniques. </title> <booktitle> In Proceedings of the Twelfth Symposium on Operating Systems Principles, </booktitle> <pages> pages 91-101. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1989. </year>
Reference-contexts: Recent work has focused on employing application-specific knowledge to relax the consistency model and obtain better performance [5, 3]. 6.3 Stackable layering Early work in joining layers with a symmetric interface developed in several contexts: the Unix shell [19], the Streams I/O system [21], and x-kernel network protocols <ref> [10] </ref>. Most data in these systems is transient, and so they do not address cache coherence problems 7 . Databases and file systems have both persistent data and a need for caching.
Reference: [11] <author> Michael Leon Kazar. </author> <title> Synchronization and caching issues in the Andrew File System. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 31-43. </pages> <publisher> USENIX, </publisher> <month> February </month> <year> 1988. </year>
Reference-contexts: Locus provides strong coherence with a distributed token passing algorithm [20], while Sprite detects concurrent update at a central site and disables caching for coherence [17]. Later systems provide variations on the token algorithm: AFS's callbacks are essentially centrally-managed tokens <ref> [11] </ref>; Gray's leases are tokens that can time-out to simplify error recovery [6]. Cache coherence in stacking borrows the basic coherence approach used in these systems.
Reference: [12] <author> Yousef A. Khalidi and Michael N. Nelson. </author> <title> Extensible file systems in Spring. </title> <booktitle> In Proceedings of the 14th Symposium on Operating Systems Principles. ACM, </booktitle> <month> Dec </month> <year> 1993. </year>
Reference-contexts: The unified view would be most often used, but the underlying directories would be required for new software installation. Finally, we describe in Section 5.4 how internal access to different layers occurs in sophisticated filing services. Stacking has been adopted in BSD 4.4 and the Spring operating system <ref> [12] </ref>, and it has been employed extensively at UCLA to develop distributed filing services [7]. However, we argue below that suitable incorporation of multi-level cache management is essential to the success of modular systems. <p> First, we draw cache coherence algorithms from research in the areas of hardware multiprocessing, distributed filing, and distributed shared memory. Second, we build upon stacking work done at Sun Microsystems [22] and UCLA [7, 8], and cache-coherent stacking work also done at Sun <ref> [12] </ref>. A complete discussion of related work follows in Section 6. This paper contributes to the architecture of cache coherence in a stacking system. We refine the notion of separation of the manager and the provider of cached objects introduced in Spring [12]. <p> and cache-coherent stacking work also done at Sun <ref> [12] </ref>. A complete discussion of related work follows in Section 6. This paper contributes to the architecture of cache coherence in a stacking system. We refine the notion of separation of the manager and the provider of cached objects introduced in Spring [12]. We show that consistent identification of cached objects is an important component of a coherence solution and can simplify the burden cache coherence places on layers. <p> The upper-level kernel treats files as nearly opaque while each collection of joined triangles represents a file. objects, vnodes. Actions on files are invoked via vnode operations which match the desired action with the a particular implementation at run-time. At UCLA [8] and Sun <ref> [22, 25, 12] </ref> the vnode interface has been extended to support file system stacking, extensibility, and distributed filing. We next discuss each component of stackable filing at UCLA, drawing on Figure 2 for illustration. Layer configuration: Each filing service is provided as a layer. <p> In a monolithic system such as the UFS, the same layer performs both of these operations. As first noted by the Spring project <ref> [12] </ref>, successful layered caching benefits from a separation of these functions. In Spring terms, one object will serve as the pager, performing actual data I/O, while another object (the cacher) may be actively caching data. <p> Databases and file systems have both persistent data and a need for caching. The Genesis work in databases [1], and file system stacking work from UCLA [7, 8], Rosenthal and Skinner at Sun-Soft [22, 25] and the Spring project at Sun Laboratories <ref> [12] </ref> approach cache coherence in different ways. The Genesis work focuses on modularity and stacking for databases. Cache coherence problems are avoided by not allowing multi-layer access. Rosenthal identifies the problem of cache coherence in stackable filing [22]. <p> These approaches do not generalize to filing environments where cached data is considered authoritative and employed without verification. composition layers is not discussed. Spring is an operating system that closely ties the virtual memory and file systems to provide distributed shared memory <ref> [12] </ref>. Cache coherent file system stacking is a natural result of this architecture, and with it come two important results. First, they recognize that separation of the data provider and the data manager is necessary for efficient, layered caching.
Reference: [13] <author> Yousef A. Khalidi and Michael N. Nelson. </author> <title> The Spring virtual memory system. </title> <type> Technical Report SMLI TR-93-09, </type> <institution> Sun Mi-crosystems, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Page sharing: Allowing multiple layers to concurrently share the same physical page representation is a desirable optimization to avoid page thrashing and page duplication when two active layers have identical page contents. This optimization requires support from the VM system, like that provided by Spring <ref> [13] </ref>. Unfortunately, the SunOS 4.x VM system serving as our test-bed associates each page with a single vnode, and so we were unable to explore this optimization. Read-only and read/write pages: Another possible optimization is to coordinate page access with reader/writer tokens instead of simple tokens.
Reference: [14] <author> S. R. Kleiman. Vnodes: </author> <title> An architecture for multiple file system types in Sun Unix. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 238-247. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: To provide a uniform vocabulary for the remainder of the paper, we now briefly summarize the original vnode interface and the UCLA stackable filing framework. (Detailed descriptions of the vnode interface <ref> [14] </ref> and UCLA stacking [8, 9] are available elsewhere.) The vnode interface: The vnode interface separates the upper-level kernel from different file system implementations in an object-oriented manner. The upper-level kernel treats files as nearly opaque while each collection of joined triangles represents a file. objects, vnodes.
Reference: [15] <author> Kai Li and Paul Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <booktitle> In Proceedings of the Fifth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 229-239. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1986. </year>
Reference-contexts: More sophisticated systems broadcast and multicast coherence information to some or all processors. The constraints of a hardware implementation limit the scale of these approaches. In distributed shared memory systems software plays a larger role in coherence. Li proposes strong consistency with both centralized and distributed algorithms <ref> [15] </ref>. Recent work has focused on employing application-specific knowledge to relax the consistency model and obtain better performance [5, 3]. 6.3 Stackable layering Early work in joining layers with a symmetric interface developed in several contexts: the Unix shell [19], the Streams I/O system [21], and x-kernel network protocols [10].
Reference: [16] <author> Marshall McKusick, William Joy, Samuel Leffler, and R. Fabry. </author> <title> A fast file system for UNIX. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 181-197, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Our test machine runs a modified version of SunOS 4.1.1. All data is stored in a stack-enabled version of the standard SunOS 4.1.1 file-system (UFS), a version of Berkeley's Fast Filesystem <ref> [16] </ref>. For multi-layer tests we add one or more null layers [8].
Reference: [17] <author> Michael N. Nelson, Brent B. Welch, and John K. Ousterhout. </author> <title> Caching in the Sprite network file system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 134-154, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Locus provides strong coherence with a distributed token passing algorithm [20], while Sprite detects concurrent update at a central site and disables caching for coherence <ref> [17] </ref>. Later systems provide variations on the token algorithm: AFS's callbacks are essentially centrally-managed tokens [11]; Gray's leases are tokens that can time-out to simplify error recovery [6]. Cache coherence in stacking borrows the basic coherence approach used in these systems.
Reference: [18] <author> John K. Ousterhout. </author> <title> Why aren't operating systems getting faster as fast as hardware? In USENIX Conference Proceedings, </title> <booktitle> pages 247-256. USENIX, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: We selected this set because they intensively exercise the file system in different ways. Find accesses a large number of files without generating much caching. Copy accesses files and their data. The second class of benchmarks is represented by the Modified Andrew Benchmark <ref> [18] </ref>. The Modified Andrew Benchmark consists of five phases: four brief file system operations and a large-program build. In our environment we found the first four phases too short to allow good statistical comparisons, and all were dominated by the compile phase.
Reference: [19] <author> Rob Pike and Brian Kernighan. </author> <title> Program design in the UNIX environment. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1595-1605, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: Li proposes strong consistency with both centralized and distributed algorithms [15]. Recent work has focused on employing application-specific knowledge to relax the consistency model and obtain better performance [5, 3]. 6.3 Stackable layering Early work in joining layers with a symmetric interface developed in several contexts: the Unix shell <ref> [19] </ref>, the Streams I/O system [21], and x-kernel network protocols [10]. Most data in these systems is transient, and so they do not address cache coherence problems 7 . Databases and file systems have both persistent data and a need for caching.
Reference: [20] <author> Gerald J. Popek and Bruce J. Walker. </author> <title> The Locus Distributed System Architecture. </title> <publisher> The MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Locus provides strong coherence with a distributed token passing algorithm <ref> [20] </ref>, while Sprite detects concurrent update at a central site and disables caching for coherence [17]. Later systems provide variations on the token algorithm: AFS's callbacks are essentially centrally-managed tokens [11]; Gray's leases are tokens that can time-out to simplify error recovery [6].
Reference: [21] <author> Dennis M. Ritchie. </author> <title> A stream input-output system. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1897-1910, </pages> <month> Octo-ber </month> <year> 1984. </year>
Reference-contexts: Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request Permissions from Publications Dept, ACM Inc., Fax +1 (212) 869-0481, or hpermissions@acm.orgi. is connected by a standard interface. Streams <ref> [21] </ref>, stackable filing is based on two key ideas. <p> Recent work has focused on employing application-specific knowledge to relax the consistency model and obtain better performance [5, 3]. 6.3 Stackable layering Early work in joining layers with a symmetric interface developed in several contexts: the Unix shell [19], the Streams I/O system <ref> [21] </ref>, and x-kernel network protocols [10]. Most data in these systems is transient, and so they do not address cache coherence problems 7 . Databases and file systems have both persistent data and a need for caching.
Reference: [22] <author> David S. H. Rosenthal. </author> <title> Evolving the vnode interface. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 107-118. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Today's filing interfaces vary from system to system, and even between point releases of a single operating system. These differences imply that third parties cannot adapt filing interfaces to suit their own needs, nor can they expect their software to function as the base system evolves. Stackable filing <ref> [7, 22, 8] </ref> presents a new approach to the construction of filing services to address these problems. Inspired by fl This work was sponsored by the Advanced Research Projects Agency under contract N00174-91-C-0107. Gerald Popek is also affiliated with Locus Computing Corporation. <p> Related work and directions for this paper: Our work builds upon two areas of prior research. First, we draw cache coherence algorithms from research in the areas of hardware multiprocessing, distributed filing, and distributed shared memory. Second, we build upon stacking work done at Sun Microsystems <ref> [22] </ref> and UCLA [7, 8], and cache-coherent stacking work also done at Sun [12]. A complete discussion of related work follows in Section 6. This paper contributes to the architecture of cache coherence in a stacking system. <p> The upper-level kernel treats files as nearly opaque while each collection of joined triangles represents a file. objects, vnodes. Actions on files are invoked via vnode operations which match the desired action with the a particular implementation at run-time. At UCLA [8] and Sun <ref> [22, 25, 12] </ref> the vnode interface has been extended to support file system stacking, extensibility, and distributed filing. We next discuss each component of stackable filing at UCLA, drawing on Figure 2 for illustration. Layer configuration: Each filing service is provided as a layer. <p> Databases and file systems have both persistent data and a need for caching. The Genesis work in databases [1], and file system stacking work from UCLA [7, 8], Rosenthal and Skinner at Sun-Soft <ref> [22, 25] </ref> and the Spring project at Sun Laboratories [12] approach cache coherence in different ways. The Genesis work focuses on modularity and stacking for databases. Cache coherence problems are avoided by not allowing multi-layer access. Rosenthal identifies the problem of cache coherence in stackable filing [22]. <p> The Genesis work focuses on modularity and stacking for databases. Cache coherence problems are avoided by not allowing multi-layer access. Rosenthal identifies the problem of cache coherence in stackable filing <ref> [22] </ref>. His early system restricts access and caching to the top stack layer, avoiding coherence problems at the cost of prohibiting multi-layer access. Skinner's later work provides two kinds of stacking termed interposition and composition [25].
Reference: [23] <author> Russel Sandberg, David Goldberg, Steve Kleiman, Dan Walsh, and Bob Lyon. </author> <title> Design and implementation of the Sun Network File System. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 119-130. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1985. </year>
Reference-contexts: We examine different applications from this perspective, categorizing how this information is stored and collected. 6.1 Distributed filing Early distributed file systems such as Cedar and NFS avoid the problem of cache coherence by disallowing file mutation [24] and not providing strong coherence <ref> [23] </ref>. Locus provides strong coherence with a distributed token passing algorithm [20], while Sprite detects concurrent update at a central site and disables caching for coherence [17].
Reference: [24] <author> Michael D. Schroeder, David K. Gifford, and Roger M. Need-ham. </author> <title> A caching file system for a programmer's workstation. </title> <booktitle> In Proceedings of the Tenth Symposium on Operating Systems Principles, </booktitle> <pages> pages 25-34. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1985. </year>
Reference-contexts: We examine different applications from this perspective, categorizing how this information is stored and collected. 6.1 Distributed filing Early distributed file systems such as Cedar and NFS avoid the problem of cache coherence by disallowing file mutation <ref> [24] </ref> and not providing strong coherence [23]. Locus provides strong coherence with a distributed token passing algorithm [20], while Sprite detects concurrent update at a central site and disables caching for coherence [17].
Reference: [25] <author> Glenn C. Skinner and Thomas K. Wong. </author> <title> Stacking vnodes: A progress report. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 161-174. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: The upper-level kernel treats files as nearly opaque while each collection of joined triangles represents a file. objects, vnodes. Actions on files are invoked via vnode operations which match the desired action with the a particular implementation at run-time. At UCLA [8] and Sun <ref> [22, 25, 12] </ref> the vnode interface has been extended to support file system stacking, extensibility, and distributed filing. We next discuss each component of stackable filing at UCLA, drawing on Figure 2 for illustration. Layer configuration: Each filing service is provided as a layer. <p> Databases and file systems have both persistent data and a need for caching. The Genesis work in databases [1], and file system stacking work from UCLA [7, 8], Rosenthal and Skinner at Sun-Soft <ref> [22, 25] </ref> and the Spring project at Sun Laboratories [12] approach cache coherence in different ways. The Genesis work focuses on modularity and stacking for databases. Cache coherence problems are avoided by not allowing multi-layer access. Rosenthal identifies the problem of cache coherence in stackable filing [22]. <p> Rosenthal identifies the problem of cache coherence in stackable filing [22]. His early system restricts access and caching to the top stack layer, avoiding coherence problems at the cost of prohibiting multi-layer access. Skinner's later work provides two kinds of stacking termed interposition and composition <ref> [25] </ref>. Access to multiple stack layers created with composition is allowed, but with interposition is not. Issues of cache coherence are mentioned but not addressed in Skinner's paper.
Reference: [26] <author> Alan J. Smith. </author> <title> Cache memories. </title> <journal> ACM Computing Surveys, </journal> <volume> 14(3) </volume> <pages> 473-530, </pages> <month> September </month> <year> 1982. </year>
Reference-contexts: Unlike these systems, stacking faces the unique problem of data identification across different data representations. 6.2 Multiprocessors and distributed shared memory As with distributed filing, early approaches to shared memory multiprocessing avoid multiple caches or do not provide strong coherence (Smith surveys such systems <ref> [26] </ref>). More sophisticated systems broadcast and multicast coherence information to some or all processors. The constraints of a hardware implementation limit the scale of these approaches. In distributed shared memory systems software plays a larger role in coherence. Li proposes strong consistency with both centralized and distributed algorithms [15].
Reference: [27] <author> Mark Wittle. LADDIS: </author> <title> The next generation in NFS file server benchmarking. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 111-128. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: When examining the performance of a cache coherence framework, particular care must be taken to separate the overhead of the framework from the benefits of caching. (The LADDIS NFS server benchmark, for example, carefully exercises NFS to gain useful measurements <ref> [27] </ref>.) The next sections examine components of our coherence approach that impact performance, the benchmarks we use to examine that performance, and finally the performance of our system from several perspectives. 5.1 Performance components A cache coherent, layered file system is composed of a number of cooperating components.
References-found: 27

