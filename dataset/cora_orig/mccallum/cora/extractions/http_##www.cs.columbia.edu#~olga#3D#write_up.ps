URL: http://www.cs.columbia.edu/~olga/3D/write_up.ps
Refering-URL: http://www.cs.columbia.edu/~olga/research.html
Root-URL: http://www.cs.columbia.edu
Title: Registration of two object views  
Author: Olga Merport 
Date: May 25, 1998  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> C. Dorai and J. Weng, </author> <title> "Optimal Registration of Object Views Using Range Data", </title> <journal> IEEE Transactions on pattern analysis and machine Intelligence, </journal> <volume> vol. 19, no. 10, </volume> <month> Oct </month> <year> 1997 </year>
Reference-contexts: Automatic construction of 3D models includes 3 basic steps: 1. scanning images from different view points, 2. registration of views, 3. integration of views. The goal of the term project was to implement an optimal view registration algorithm proposed by Dorai <ref> [1] </ref>. I was to incorporate my implementation with software package Zipper by Turk and Levoy [2]. <p> In <ref> [1] </ref> Dorai and Weng showed how the noise in z values affects the estimation of the tangential plane parameters (A; B; C; D) T which, in their turn, affect the distance d which is being minimized to estimate T . <p> Dorai and Weng proposed a method to optimize Chen and Medioni registration algorithm by minimizing the following error function: e k = i=1 2 d 2 T k p i ; S k where 2 d is the estimated variance of the distance d. In their paper <ref> [1] </ref> they showed how to estimate 2 d . Dorai and Weng used a classical eigenvector method to estimate tangen tial plane parameters. <p> T A = 2 diag (P 1 ; P 2 ; :::; P n ); (16) where P i is 4 fi 4 submatrix: P i = 6 6 0 0 0 0 0 0 1 0 3 7 5 Detailed explanation of the above formulas can be obtained in <ref> [1] </ref>. 3 Implementation of the optimal algorithm In our implementation we use the following notational conventions: Q is the "target" mesh, and P is the mesh which is to be aligned with mesh Q. 3.1 Data preprocessing We start our implementation with the preproccesing of the given data. <p> I resolved the problem by limiting the distance between matched points. Finally, in some parts of the algorithm, I used a transposed transformation T T , rather than just using T . The reason for this mistake was inconsistency between the definition of T given in the paper <ref> [1] </ref>, and the one used by Zipper. Since, my implementation was incorporated into Zipper, I had to follow Zipper's conventions.
Reference: [2] <author> G. Turk and M. Levoy, </author> <title> "Zippered Polygon Meshes from Range Images", </title> <booktitle> Proc. SIGGRAPH '94, </booktitle> <pages> pp. 311-318, </pages> <year> 1994 </year>
Reference-contexts: The goal of the term project was to implement an optimal view registration algorithm proposed by Dorai [1]. I was to incorporate my implementation with software package Zipper by Turk and Levoy <ref> [2] </ref>.
Reference: [3] <author> Y.Chen and G.Medioni, </author> <title> "Object Modelling by Registration of Multiple Range Images", </title> <journal> Image and Vision Computing, </journal> <volume> vol. 10, </volume> <pages> pp 145-155, </pages> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: The goal of the term project was to implement an optimal view registration algorithm proposed by Dorai [1]. I was to incorporate my implementation with software package Zipper by Turk and Levoy [2]. The algorithm is an improvement upon the approach of Chen and Medioni <ref> [3] </ref>. 2 Views Registration 2.1 Non-Optimal Registration algorithm by Chen and Medioni View P is said to be registered with view Q if any pair of points (p; q) representing the same surface point can be related to each other by one rigid spatial transformation T: In other words, 8p 2
Reference: [4] <editor> Numerical Recipies in C: </editor> <booktitle> The art of Scientific Computing; William H.Press, </booktitle> <address> et al; 10 </address>
Reference-contexts: We assume the approximate initial registration, and suppose that the initial transformation corresponds to ff = fi = fl = 0; t x = t y = t z = 0; According to Newton's method for systems of nonlinear equations in <ref> [4] </ref>, we have: ~x n+1 = ~x n J 1 (~x n ) ~ F (~x n ) (22) where the superscript n denotes values obtained on the nth iteration and n+1 indicates values to be found on the (n+1)st iteration, ~ F is a nonlinear vector-funciton, and J 1 stands <p> Routine computeAllP ointsJ acobian () computes contributions to Jacobian matrix from each matched pair and sums them together to form J. Routine computeJ acobInverse () inverts matrix J with the help of LU decomposition method ("Numerical Recipes", <ref> [4] </ref>). Finally, function newtonM ethod () performs Newton's iterations, until convergence is reached (within the given threshold). If convergence is reached before the prescribed number of iterations is performed (I use 20 as a maximum number), then the process stops, and new transformation is reported.
References-found: 4

