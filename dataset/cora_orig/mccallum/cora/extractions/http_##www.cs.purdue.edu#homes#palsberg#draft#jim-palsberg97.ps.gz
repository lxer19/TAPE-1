URL: http://www.cs.purdue.edu/homes/palsberg/draft/jim-palsberg97.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Title: Type inference in systems of recursive types with subtyping  
Author: Trevor Jim Jens Palsberg 
Date: July 24, 1997  
Abstract: We present general methods for performing type inference and deciding sub-typing in languages with recursive types. Our type inference algorithm generalizes a common idea of previous work: type inference is reduced to a constraint satisfaction problem, whose satisfiability can be decided by a process of closure and consistency checking. We prove a general correctness theorem for this style of type inference. We define subtyping co-inductively, and we prove by co-induction that a closed and consistent constraint set has a solution. Our theorem makes it easier to find new type inference algorithms. For example, we provide definitions of closure and consistency for recursive types with a greatest type, but not a least type; we show that the definitions satisfy the conditions of our theorem; and the theorem immediately provides a type inference algorithm, thereby solving an open problem.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Luca Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: In theoretical studies and experimental languages, one more often finds subtyping by structure without subtype declarations, and full-fledged recursive types which can be unfolded, e.g., <ref> [1, 3] </ref>. Some languages rely on explicit type annotations and static type checking, e.g., Java [15] and C ++ [12]. Others do not require type annotations and rely on dynamic type checking, e.g., Smalltalk [14] and Self [40]. <p> Well-known languages with &gt; but not ? include F &lt;: [6] and O-1 <ref> [1] </ref>. Cardone and Coppo [7, 8] have studied the system with ? but not &gt;, and claim type inference is solved, but their method is flawed, as we will explain. Our algorithm uses well-known ideas, starting with the equivalence between type inference and finding solutions to sets of constraints. <p> Other well-known calculi with &gt; but not ? include F &lt;: [6] and O-1 <ref> [1] </ref>. * The system fl 3 , where 3 = Tv [ f?; !; natg, was studied by Cardone and Coppo [7, 8].
Reference: [2] <author> Alexander Aiken and Edward Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proc. Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <year> 1993. </year>
Reference-contexts: A "consistency" test then determines whether R (and therefore, R M ) has a solution. Again, this is a standard technique. However, known methods for constructing solutions, or showing that solutions exist, are complicated. For example, Aiken and Wimmers <ref> [2] </ref> show that their constraints have solutions by transforming them to contractive equations, a class that MacQueen et al. [21] demonstrated to be solvable by Banach's Fixed Point Theorem. Tiuryn and Wand [37] reduce solvability to the emptiness problem for Buchi automata. <p> Constrained types without cycles in the constraint set were studied by Kaes [18] and Smith [32]. Type inference for constrained types extended with let-polymorphism was studied for functional languages by Aiken and Wimmers <ref> [2] </ref>, and later for object-oriented languages by Eifrig, Smith, and Trifonov [11, 10]. An algorithm for deciding a subtyping relation for constrained types, including type quantifiers, was presented by Trifonov and Smith [39].
Reference: [3] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: In theoretical studies and experimental languages, one more often finds subtyping by structure without subtype declarations, and full-fledged recursive types which can be unfolded, e.g., <ref> [1, 3] </ref>. Some languages rely on explicit type annotations and static type checking, e.g., Java [15] and C ++ [12]. Others do not require type annotations and rely on dynamic type checking, e.g., Smalltalk [14] and Self [40]. <p> Example 6 * The system fl 1 , where 1 = Tv [ f?; &gt;; !; natg, is the system of recursive types studied by Amadio and Cardelli <ref> [3] </ref>. 6 * The system fl 2 , where 2 = Tv [f&gt;; !; natg, is sometimes called the system of partial types, after the work of Thatte [33, 34, 35], who studied a nonrecursive version. <p> Kozen, Palsberg, and Schwartzbach [19, 20] improved on O'Keefe and Wand's algorithm, and extended it to recursive types: these problems are P-complete. Palsberg, Wand, and O'Keefe [29] gave an O (n 3 ) time algorithm for simple types plus &gt; and ?. Amadio and 16 Cardelli <ref> [3] </ref> gave the first subtyping algorithm for the system of recursive types with &gt;, ?, and discretely-ordered base types. Later, Kozen, Palsberg, and Schwartzbach showed that the subtype ordering can be decided in O (n 2 ) time [20].
Reference: [4] <author> Marcin Benke. </author> <title> Efficient type reconstruction in the presence of inheritance. </title> <type> Manuscript, </type> <year> 1994. </year>
Reference-contexts: Mitchell [24, 25] gave the first inference algorithm for atomic subtyping, without recursive types. With no further assumptions about the partial order, this problem is PSPACE-complete [36, 16, 13], and if the partial order is a disjoint union of lattices or trees, then type inference is in polynomial time <ref> [36, 4] </ref>. Tiuryn and Wand [37] gave the first inference algorithm for atomic subtyping with recursive types: this problem is in EXPTIME. Thatte [35] introduced the problem of type inference with partial types (simple types plus &gt;), and showed that it was semi-decidable.
Reference: [5] <author> Michael Brandt and Fritz Henglein. </author> <title> Coinductive axiomatization of recursive type equality and subtyping. </title> <booktitle> In TLCA 3 [38]. </booktitle>
Reference-contexts: This leads to a very simple algorithm for deciding subtyping, based on co-induction. Co-induction is also used to prove the correctness of our method of finding solutions to constraints. Brandt and Henglein also use co-inductive techniques to decide subtyping for recursive types <ref> [5] </ref>. They use notation, so their definition applies only to regular types. We show that it applies as well to nonregular types. Pierce and Sangiorgi [31] used simulations to define a subtyping relation, however, they did not base their subtyping algorithm on co-induction. <p> The first use of simulations to define a subtyping relation that we are aware of is Pierce and Sangiorgi [31], who used it for a process calculus. Later, Brandt and Henglein <ref> [5] </ref> used co-inductive methods to obtain complete axiomatizations of type equality and subtyping, and to obtain an easy proof of the O (n 2 ) algorithm for deciding the subtyping relation. A Proof of the main theorems Recall that Type Sym;R (g) is not always a type.
Reference: [6] <author> Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. </author> <title> An extension of system F with subtyping. </title> <journal> Information and Computation, </journal> 109(1/2):4-56, <volume> 15 </volume> February/March 1994. 
Reference-contexts: In particular, we will see that having &gt; and ? actually makes type inference easier, and we give the first algorithms for the system with &gt; but not ?, and the system with ? but not &gt;. Well-known languages with &gt; but not ? include F &lt;: <ref> [6] </ref> and O-1 [1]. Cardone and Coppo [7, 8] have studied the system with ? but not &gt;, and claim type inference is solved, but their method is flawed, as we will explain. <p> Other well-known calculi with &gt; but not ? include F &lt;: <ref> [6] </ref> and O-1 [1]. * The system fl 3 , where 3 = Tv [ f?; !; natg, was studied by Cardone and Coppo [7, 8].
Reference: [7] <author> Felice Cardone and Mario Coppo. </author> <title> Two extensions of Curry's type inference system. </title> <editor> In Piergiorgio Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, volume 31 of APIC Studies in Data Processing, </booktitle> <pages> pages 19-75. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: Well-known languages with &gt; but not ? include F &lt;: [6] and O-1 [1]. Cardone and Coppo <ref> [7, 8] </ref> have studied the system with ? but not &gt;, and claim type inference is solved, but their method is flawed, as we will explain. Our algorithm uses well-known ideas, starting with the equivalence between type inference and finding solutions to sets of constraints. <p> Other well-known calculi with &gt; but not ? include F &lt;: [6] and O-1 [1]. * The system fl 3 , where 3 = Tv [ f?; !; natg, was studied by Cardone and Coppo <ref> [7, 8] </ref>. <p> The problems arising in constructing a structure for 3 are dual to those encountered for 2 , so we will not bother to give the appropriate structure here. However, a historical note is in order. Cardone and Coppo <ref> [7, 8] </ref> have claimed that a type inference algorithm for fl 3 can be based on Huet's unification algorithm [17] (see p. 56 of [8]), and they refer to Courcelle [9] in support. However, Huet's algorithm does not apply to types with ?, and Courcelle does not make that claim.
Reference: [8] <author> Felice Cardone and Mario Coppo. </author> <title> Type inference with recursive types: Syntax and semantics. </title> <journal> Information and Computation, </journal> <volume> 92(1) </volume> <pages> 48-80, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Well-known languages with &gt; but not ? include F &lt;: [6] and O-1 [1]. Cardone and Coppo <ref> [7, 8] </ref> have studied the system with ? but not &gt;, and claim type inference is solved, but their method is flawed, as we will explain. Our algorithm uses well-known ideas, starting with the equivalence between type inference and finding solutions to sets of constraints. <p> Other well-known calculi with &gt; but not ? include F &lt;: [6] and O-1 [1]. * The system fl 3 , where 3 = Tv [ f?; !; natg, was studied by Cardone and Coppo <ref> [7, 8] </ref>. <p> The problems arising in constructing a structure for 3 are dual to those encountered for 2 , so we will not bother to give the appropriate structure here. However, a historical note is in order. Cardone and Coppo <ref> [7, 8] </ref> have claimed that a type inference algorithm for fl 3 can be based on Huet's unification algorithm [17] (see p. 56 of [8]), and they refer to Courcelle [9] in support. However, Huet's algorithm does not apply to types with ?, and Courcelle does not make that claim. <p> However, a historical note is in order. Cardone and Coppo [7, 8] have claimed that a type inference algorithm for fl 3 can be based on Huet's unification algorithm [17] (see p. 56 of <ref> [8] </ref>), and they refer to Courcelle [9] in support. However, Huet's algorithm does not apply to types with ?, and Courcelle does not make that claim. Moreover, Courcelle's ordering on types is not the same as the ordering of Cardone and Coppo.
Reference: [9] <author> Bruno Courcelle. </author> <title> Fundamental properties of infinite trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 25 </volume> <pages> 95-169, </pages> <year> 1983. </year>
Reference-contexts: However, a historical note is in order. Cardone and Coppo [7, 8] have claimed that a type inference algorithm for fl 3 can be based on Huet's unification algorithm [17] (see p. 56 of [8]), and they refer to Courcelle <ref> [9] </ref> in support. However, Huet's algorithm does not apply to types with ?, and Courcelle does not make that claim. Moreover, Courcelle's ordering on types is not the same as the ordering of Cardone and Coppo. <p> Moreover, Courcelle's ordering on types is not the same as the ordering of Cardone and Coppo. Courcelle's ordering is the the Bohm ordering on infinite trees, with a least type called instead of ? (see p. 110 of <ref> [9] </ref>). In the Bohm order, occurrences of are always treated covariantly, so, for example, ! is less than nat ! nat in the Bohm order. Cardone and Coppo order function types contravariantly in the argument type, as do we.
Reference: [10] <author> Jonathan Eifrig, Scott Smith, and Valery Trifonov. </author> <title> Sound polymorphic type inference for objects. </title> <booktitle> In Proc. OOPSLA'95, ACM SIGPLAN Tenth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 169-184, </pages> <year> 1995. </year>
Reference-contexts: Constrained types without cycles in the constraint set were studied by Kaes [18] and Smith [32]. Type inference for constrained types extended with let-polymorphism was studied for functional languages by Aiken and Wimmers [2], and later for object-oriented languages by Eifrig, Smith, and Trifonov <ref> [11, 10] </ref>. An algorithm for deciding a subtyping relation for constrained types, including type quantifiers, was presented by Trifonov and Smith [39]. The first use of simulations to define a subtyping relation that we are aware of is Pierce and Sangiorgi [31], who used it for a process calculus.
Reference: [11] <author> Jonathan Eifrig, Scott Smith, and Valery Trifonov. </author> <title> Type inference for recursively constrained types and it application to OOP. </title> <booktitle> In Proc. Mathematical Foundations of Programming Semantics, </booktitle> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: Constrained types without cycles in the constraint set were studied by Kaes [18] and Smith [32]. Type inference for constrained types extended with let-polymorphism was studied for functional languages by Aiken and Wimmers [2], and later for object-oriented languages by Eifrig, Smith, and Trifonov <ref> [11, 10] </ref>. An algorithm for deciding a subtyping relation for constrained types, including type quantifiers, was presented by Trifonov and Smith [39]. The first use of simulations to define a subtyping relation that we are aware of is Pierce and Sangiorgi [31], who used it for a process calculus.
Reference: [12] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: In theoretical studies and experimental languages, one more often finds subtyping by structure without subtype declarations, and full-fledged recursive types which can be unfolded, e.g., [1, 3]. Some languages rely on explicit type annotations and static type checking, e.g., Java [15] and C ++ <ref> [12] </ref>. Others do not require type annotations and rely on dynamic type checking, e.g., Smalltalk [14] and Self [40]. What is not common is type inference for real languages with subtyping and recursive types.
Reference: [13] <author> Alexandre Frey. </author> <title> Satisfying systems of subtype inequalities in polynomial space. </title> <booktitle> In Proc. SAS'97, International Static Analysis Symposium. </booktitle> <publisher> Springer-Verlag (LNCS ), 1997. </publisher>
Reference-contexts: Mitchell [24, 25] gave the first inference algorithm for atomic subtyping, without recursive types. With no further assumptions about the partial order, this problem is PSPACE-complete <ref> [36, 16, 13] </ref>, and if the partial order is a disjoint union of lattices or trees, then type inference is in polynomial time [36, 4]. Tiuryn and Wand [37] gave the first inference algorithm for atomic subtyping with recursive types: this problem is in EXPTIME.
Reference: [14] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80|The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Some languages rely on explicit type annotations and static type checking, e.g., Java [15] and C ++ [12]. Others do not require type annotations and rely on dynamic type checking, e.g., Smalltalk <ref> [14] </ref> and Self [40]. What is not common is type inference for real languages with subtyping and recursive types. Although type inference is known for some systems combining both features, these systems tend to lack many features of full-fledged languages.
Reference: [15] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Subtyping and recursive types are common in modern programming languages. For example, Java <ref> [15] </ref> has a notion of subtyping by name based on explicit subtype declarations, and it allows interfaces to be mutually recursive, although there is no unfolding rule. <p> In theoretical studies and experimental languages, one more often finds subtyping by structure without subtype declarations, and full-fledged recursive types which can be unfolded, e.g., [1, 3]. Some languages rely on explicit type annotations and static type checking, e.g., Java <ref> [15] </ref> and C ++ [12]. Others do not require type annotations and rely on dynamic type checking, e.g., Smalltalk [14] and Self [40]. What is not common is type inference for real languages with subtyping and recursive types.
Reference: [16] <author> My Hoang and John Mitchell. </author> <title> Lower bounds on type inference with subtypes. </title> <booktitle> In Conference Record of POPL '95: 22 nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 176-185, </pages> <year> 1995. </year> <month> 21 </month>
Reference-contexts: Mitchell [24, 25] gave the first inference algorithm for atomic subtyping, without recursive types. With no further assumptions about the partial order, this problem is PSPACE-complete <ref> [36, 16, 13] </ref>, and if the partial order is a disjoint union of lattices or trees, then type inference is in polynomial time [36, 4]. Tiuryn and Wand [37] gave the first inference algorithm for atomic subtyping with recursive types: this problem is in EXPTIME.
Reference: [17] <author> G. Huet. </author> <title> Resolution d'equations dans les langages d'ordre 1, </title> <type> 2, </type> . . . , !. <institution> These de Doctorat d'Etat, Universite de Paris VII, </institution> <year> 1976. </year>
Reference-contexts: However, a historical note is in order. Cardone and Coppo [7, 8] have claimed that a type inference algorithm for fl 3 can be based on Huet's unification algorithm <ref> [17] </ref> (see p. 56 of [8]), and they refer to Courcelle [9] in support. However, Huet's algorithm does not apply to types with ?, and Courcelle does not make that claim. Moreover, Courcelle's ordering on types is not the same as the ordering of Cardone and Coppo. <p> Cardone and Coppo order function types contravariantly in the argument type, as do we. Hence, we believe we have the first type inference algorithm for this system. 6 Related work Huet <ref> [17] </ref> gave the first unification algorithm for recursive types. Mitchell [24, 25] gave the first inference algorithm for atomic subtyping, without recursive types.
Reference: [18] <author> Stefan Kaes. </author> <title> Typing in the presence of overloading, subtyping, and recursive types. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 193-204, </pages> <year> 1992. </year>
Reference-contexts: Constrained types without cycles in the constraint set were studied by Kaes <ref> [18] </ref> and Smith [32]. Type inference for constrained types extended with let-polymorphism was studied for functional languages by Aiken and Wimmers [2], and later for object-oriented languages by Eifrig, Smith, and Trifonov [11, 10].
Reference: [19] <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient inference of partial types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 49(2) </volume> <pages> 306-324, </pages> <year> 1994. </year>
Reference-contexts: For example, Aiken and Wimmers [2] show that their constraints have solutions by transforming them to contractive equations, a class that MacQueen et al. [21] demonstrated to be solvable by Banach's Fixed Point Theorem. Tiuryn and Wand [37] reduce solvability to the emptiness problem for Buchi automata. Other work <ref> [19, 29] </ref> transforms R into a language of graphs, and then to a nondeterministic automaton whose language represents the solution. Our method of constructing a solution is much simpler. <p> When recursive types and the base type nat are omitted, we have the system of partial types introduced by Thatte [35]. Thatte gave a semi-decision procedure for type inference in his system. O'Keefe and Wand [26] gave the first type inference algorithm for Thatte's system. Kozen, Palsberg, and Schwartzbach <ref> [19, 20] </ref> improved on O'Keefe and Wand's algorithm, and extended it to recursive types. The addition of the base type nat to the type system makes type inference more difficult. <p> Then 1 must be a lower bound of S ( 1 ) and S (t 1 ). The existence of such a lower bound was not implied in 1 . This is exactly where nat causes difficulties. The type inference algorithm in <ref> [19] </ref> for the system without nat constructs a closed solution, that is, a solution containing no type variables. The possible types in the solution are thus generated by the signature f!; &gt;g. This class of types has a special property: every nonempty set of such types has a lower bound. <p> Thatte [35] introduced the problem of type inference with partial types (simple types plus &gt;), and showed that it was semi-decidable. O'Keefe and Wand [26] gave the first type inference algorithm for Thatte's system. Kozen, Palsberg, and Schwartzbach <ref> [19, 20] </ref> improved on O'Keefe and Wand's algorithm, and extended it to recursive types: these problems are P-complete. Palsberg, Wand, and O'Keefe [29] gave an O (n 3 ) time algorithm for simple types plus &gt; and ?.
Reference: [20] <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient recursive subtyping. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 5(1) </volume> <pages> 113-125, </pages> <year> 1995. </year>
Reference-contexts: When recursive types and the base type nat are omitted, we have the system of partial types introduced by Thatte [35]. Thatte gave a semi-decision procedure for type inference in his system. O'Keefe and Wand [26] gave the first type inference algorithm for Thatte's system. Kozen, Palsberg, and Schwartzbach <ref> [19, 20] </ref> improved on O'Keefe and Wand's algorithm, and extended it to recursive types. The addition of the base type nat to the type system makes type inference more difficult. <p> Thatte [35] introduced the problem of type inference with partial types (simple types plus &gt;), and showed that it was semi-decidable. O'Keefe and Wand [26] gave the first type inference algorithm for Thatte's system. Kozen, Palsberg, and Schwartzbach <ref> [19, 20] </ref> improved on O'Keefe and Wand's algorithm, and extended it to recursive types: these problems are P-complete. Palsberg, Wand, and O'Keefe [29] gave an O (n 3 ) time algorithm for simple types plus &gt; and ?. <p> Amadio and 16 Cardelli [3] gave the first subtyping algorithm for the system of recursive types with &gt;, ?, and discretely-ordered base types. Later, Kozen, Palsberg, and Schwartzbach showed that the subtype ordering can be decided in O (n 2 ) time <ref> [20] </ref>. Palsberg and O'Keefe [27] gave a type inference algorithm for the Amadio-Cardelli system: this problem is in O (n 3 ) time. The type system with recursive types and &gt; and ? is equivalent in expressive power to a type system with constrained types [28].
Reference: [21] <author> David MacQueen, Gordon Plotkin, and Ravi Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> 71(1/2):95-130, Octo-ber/November 1986. 
Reference-contexts: Again, this is a standard technique. However, known methods for constructing solutions, or showing that solutions exist, are complicated. For example, Aiken and Wimmers [2] show that their constraints have solutions by transforming them to contractive equations, a class that MacQueen et al. <ref> [21] </ref> demonstrated to be solvable by Banach's Fixed Point Theorem. Tiuryn and Wand [37] reduce solvability to the emptiness problem for Buchi automata. Other work [19, 29] transforms R into a language of graphs, and then to a nondeterministic automaton whose language represents the solution.
Reference: [22] <author> R. Milner. </author> <title> A calculus of communicating systems. </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: Our definition of the subtyping relation is based on simulations, an idea from concurrency theory <ref> [22, 30] </ref>. This leads to a very simple algorithm for deciding subtyping, based on co-induction. Co-induction is also used to prove the correctness of our method of finding solutions to constraints. Brandt and Henglein also use co-inductive techniques to decide subtyping for recursive types [5].
Reference: [23] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Lemma 2 t if and only if * (*) t (*); and * if = 0 ! 1 and t = t 0 ! t 1 , then t 0 0 and 1 t 1 . This result is standard in concurrency theory, and has an easy proof, cf. <ref> [23] </ref>. Similarly, it is easy to show that is a preorder, and that all simulations are antisym metric. Therefore we have the following result.
Reference: [24] <author> John Mitchell. </author> <title> Coercion and type inference. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 175-185, </pages> <year> 1984. </year>
Reference-contexts: Cardone and Coppo order function types contravariantly in the argument type, as do we. Hence, we believe we have the first type inference algorithm for this system. 6 Related work Huet [17] gave the first unification algorithm for recursive types. Mitchell <ref> [24, 25] </ref> gave the first inference algorithm for atomic subtyping, without recursive types. With no further assumptions about the partial order, this problem is PSPACE-complete [36, 16, 13], and if the partial order is a disjoint union of lattices or trees, then type inference is in polynomial time [36, 4].
Reference: [25] <author> John Mitchell. </author> <title> Type inference with simple subtypes. </title> <journal> J. Functional Programming, </journal> <volume> 1(3) </volume> <pages> 245-285, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Cardone and Coppo order function types contravariantly in the argument type, as do we. Hence, we believe we have the first type inference algorithm for this system. 6 Related work Huet [17] gave the first unification algorithm for recursive types. Mitchell <ref> [24, 25] </ref> gave the first inference algorithm for atomic subtyping, without recursive types. With no further assumptions about the partial order, this problem is PSPACE-complete [36, 16, 13], and if the partial order is a disjoint union of lattices or trees, then type inference is in polynomial time [36, 4].
Reference: [26] <author> Patrick M. O'Keefe and Mitchell Wand. </author> <title> Type inference for partial types is decidable. </title> <editor> In B. Krieg-Bruckner, editor, </editor> <booktitle> 4 th European Symposium on Programming, volume 582 of Lecture Notes in Computer Science, </booktitle> <pages> pages 408-417. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1992. </year>
Reference-contexts: Type inference has not previously been solved for 13 2 . When recursive types and the base type nat are omitted, we have the system of partial types introduced by Thatte [35]. Thatte gave a semi-decision procedure for type inference in his system. O'Keefe and Wand <ref> [26] </ref> gave the first type inference algorithm for Thatte's system. Kozen, Palsberg, and Schwartzbach [19, 20] improved on O'Keefe and Wand's algorithm, and extended it to recursive types. The addition of the base type nat to the type system makes type inference more difficult. <p> Tiuryn and Wand [37] gave the first inference algorithm for atomic subtyping with recursive types: this problem is in EXPTIME. Thatte [35] introduced the problem of type inference with partial types (simple types plus &gt;), and showed that it was semi-decidable. O'Keefe and Wand <ref> [26] </ref> gave the first type inference algorithm for Thatte's system. Kozen, Palsberg, and Schwartzbach [19, 20] improved on O'Keefe and Wand's algorithm, and extended it to recursive types: these problems are P-complete.
Reference: [27] <author> Jens Palsberg and Patrick O'Keefe. </author> <title> A type system equivalent to flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(4) </volume> <pages> 576-599, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: A type inference algorithm for the regular subset of fl 1 was first given by Palsberg and O'Keefe <ref> [27] </ref>. We will need the following notation: if R is a relation on types, then R = is defined to be the relation R [ f (; ) j is a typeg. <p> Amadio and 16 Cardelli [3] gave the first subtyping algorithm for the system of recursive types with &gt;, ?, and discretely-ordered base types. Later, Kozen, Palsberg, and Schwartzbach showed that the subtype ordering can be decided in O (n 2 ) time [20]. Palsberg and O'Keefe <ref> [27] </ref> gave a type inference algorithm for the Amadio-Cardelli system: this problem is in O (n 3 ) time. The type system with recursive types and &gt; and ? is equivalent in expressive power to a type system with constrained types [28].
Reference: [28] <author> Jens Palsberg and Scott F. Smith. </author> <title> Constrained types and their expressiveness. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 18(5) </volume> <pages> 519-527, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: Palsberg and O'Keefe [27] gave a type inference algorithm for the Amadio-Cardelli system: this problem is in O (n 3 ) time. The type system with recursive types and &gt; and ? is equivalent in expressive power to a type system with constrained types <ref> [28] </ref>. A constrained type is a combination of a type and a constraint set.
Reference: [29] <author> Jens Palsberg, Mitchell Wand, and Patrick O'Keefe. </author> <title> Type inference with nonstructural subtyping. </title> <journal> Formal Aspects of Computing, </journal> <volume> 9 </volume> <pages> 49-67, </pages> <year> 1997. </year> <month> 22 </month>
Reference-contexts: For example, Aiken and Wimmers [2] show that their constraints have solutions by transforming them to contractive equations, a class that MacQueen et al. [21] demonstrated to be solvable by Banach's Fixed Point Theorem. Tiuryn and Wand [37] reduce solvability to the emptiness problem for Buchi automata. Other work <ref> [19, 29] </ref> transforms R into a language of graphs, and then to a nondeterministic automaton whose language represents the solution. Our method of constructing a solution is much simpler. <p> O'Keefe and Wand [26] gave the first type inference algorithm for Thatte's system. Kozen, Palsberg, and Schwartzbach [19, 20] improved on O'Keefe and Wand's algorithm, and extended it to recursive types: these problems are P-complete. Palsberg, Wand, and O'Keefe <ref> [29] </ref> gave an O (n 3 ) time algorithm for simple types plus &gt; and ?. Amadio and 16 Cardelli [3] gave the first subtyping algorithm for the system of recursive types with &gt;, ?, and discretely-ordered base types.
Reference: [30] <author> D.M.R. Park. </author> <title> Concurrency and automata on infinite sequences. </title> <booktitle> In Proceedings of the 5th GI Conference, volume 104 of Lecture Notes in Computer Science, </booktitle> <pages> pages 15-32. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Our definition of the subtyping relation is based on simulations, an idea from concurrency theory <ref> [22, 30] </ref>. This leads to a very simple algorithm for deciding subtyping, based on co-induction. Co-induction is also used to prove the correctness of our method of finding solutions to constraints. Brandt and Henglein also use co-inductive techniques to decide subtyping for recursive types [5].
Reference: [31] <author> Benjamin Pierce and Davide Sangiorgi. </author> <title> Typing and subtyping for mobile processes. </title> <booktitle> In Proceedings, Eighth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 376-385, </pages> <address> Montreal, Canada, 19-23 June 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Brandt and Henglein also use co-inductive techniques to decide subtyping for recursive types [5]. They use notation, so their definition applies only to regular types. We show that it applies as well to nonregular types. Pierce and Sangiorgi <ref> [31] </ref> used simulations to define a subtyping relation, however, they did not base their subtyping algorithm on co-induction. Simulations have been used to compare elements of recursive domains, for example, to compare infinite lists, where the domain of lists is recursively defined. Overview. <p> An algorithm for deciding a subtyping relation for constrained types, including type quantifiers, was presented by Trifonov and Smith [39]. The first use of simulations to define a subtyping relation that we are aware of is Pierce and Sangiorgi <ref> [31] </ref>, who used it for a process calculus. Later, Brandt and Henglein [5] used co-inductive methods to obtain complete axiomatizations of type equality and subtyping, and to obtain an easy proof of the O (n 2 ) algorithm for deciding the subtyping relation.
Reference: [32] <author> Geoffrey S. Smith. </author> <title> Principal type schemes for functional programs with overloading and subtyping. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 23 </volume> <pages> 197-226, </pages> <year> 1994. </year>
Reference-contexts: Constrained types without cycles in the constraint set were studied by Kaes [18] and Smith <ref> [32] </ref>. Type inference for constrained types extended with let-polymorphism was studied for functional languages by Aiken and Wimmers [2], and later for object-oriented languages by Eifrig, Smith, and Trifonov [11, 10].
Reference: [33] <author> Satish Thatte. </author> <title> Type inference with partial types. </title> <booktitle> In Automata, Languages and Programming: 15 th International Colloquium, volume 317 of Lecture Notes in Computer Science, </booktitle> <pages> pages 615-629. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: 1 , where 1 = Tv [ f?; &gt;; !; natg, is the system of recursive types studied by Amadio and Cardelli [3]. 6 * The system fl 2 , where 2 = Tv [f&gt;; !; natg, is sometimes called the system of partial types, after the work of Thatte <ref> [33, 34, 35] </ref>, who studied a nonrecursive version. Other well-known calculi with &gt; but not ? include F &lt;: [6] and O-1 [1]. * The system fl 3 , where 3 = Tv [ f?; !; natg, was studied by Cardone and Coppo [7, 8].
Reference: [34] <author> Satish R. Thatte. </author> <title> Quasi-static typing. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 367-381, </pages> <year> 1990. </year>
Reference-contexts: 1 , where 1 = Tv [ f?; &gt;; !; natg, is the system of recursive types studied by Amadio and Cardelli [3]. 6 * The system fl 2 , where 2 = Tv [f&gt;; !; natg, is sometimes called the system of partial types, after the work of Thatte <ref> [33, 34, 35] </ref>, who studied a nonrecursive version. Other well-known calculi with &gt; but not ? include F &lt;: [6] and O-1 [1]. * The system fl 3 , where 3 = Tv [ f?; !; natg, was studied by Cardone and Coppo [7, 8].
Reference: [35] <author> Satish R. Thatte. </author> <title> Type inference with partial types. </title> <journal> Theoretical Computer Science, </journal> <volume> 124 </volume> <pages> 127-148, </pages> <year> 1994. </year>
Reference-contexts: 1 , where 1 = Tv [ f?; &gt;; !; natg, is the system of recursive types studied by Amadio and Cardelli [3]. 6 * The system fl 2 , where 2 = Tv [f&gt;; !; natg, is sometimes called the system of partial types, after the work of Thatte <ref> [33, 34, 35] </ref>, who studied a nonrecursive version. Other well-known calculi with &gt; but not ? include F &lt;: [6] and O-1 [1]. * The system fl 3 , where 3 = Tv [ f?; !; natg, was studied by Cardone and Coppo [7, 8]. <p> This signature is interesting both historically and technically. Type inference has not previously been solved for 13 2 . When recursive types and the base type nat are omitted, we have the system of partial types introduced by Thatte <ref> [35] </ref>. Thatte gave a semi-decision procedure for type inference in his system. O'Keefe and Wand [26] gave the first type inference algorithm for Thatte's system. Kozen, Palsberg, and Schwartzbach [19, 20] improved on O'Keefe and Wand's algorithm, and extended it to recursive types. <p> Tiuryn and Wand [37] gave the first inference algorithm for atomic subtyping with recursive types: this problem is in EXPTIME. Thatte <ref> [35] </ref> introduced the problem of type inference with partial types (simple types plus &gt;), and showed that it was semi-decidable. O'Keefe and Wand [26] gave the first type inference algorithm for Thatte's system.
Reference: [36] <author> Jerzy Tiuryn. </author> <title> Subtype inequalities. </title> <booktitle> In Proceedings, Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 308-315, </pages> <address> Santa Cruz, California, 22-25 June 1992. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Mitchell [24, 25] gave the first inference algorithm for atomic subtyping, without recursive types. With no further assumptions about the partial order, this problem is PSPACE-complete <ref> [36, 16, 13] </ref>, and if the partial order is a disjoint union of lattices or trees, then type inference is in polynomial time [36, 4]. Tiuryn and Wand [37] gave the first inference algorithm for atomic subtyping with recursive types: this problem is in EXPTIME. <p> Mitchell [24, 25] gave the first inference algorithm for atomic subtyping, without recursive types. With no further assumptions about the partial order, this problem is PSPACE-complete [36, 16, 13], and if the partial order is a disjoint union of lattices or trees, then type inference is in polynomial time <ref> [36, 4] </ref>. Tiuryn and Wand [37] gave the first inference algorithm for atomic subtyping with recursive types: this problem is in EXPTIME. Thatte [35] introduced the problem of type inference with partial types (simple types plus &gt;), and showed that it was semi-decidable.
Reference: [37] <author> Jerzy Tiuryn and Mitchell Wand. </author> <title> Type reconstruction with recursive types and atomic subtyping. </title> <booktitle> In CAAP '93: 18th Colloquium on Trees in Algebra and Programming, Lecture Notes in Computer Science, </booktitle> <pages> pages 686-701. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1993. </year>
Reference-contexts: For example, Aiken and Wimmers [2] show that their constraints have solutions by transforming them to contractive equations, a class that MacQueen et al. [21] demonstrated to be solvable by Banach's Fixed Point Theorem. Tiuryn and Wand <ref> [37] </ref> reduce solvability to the emptiness problem for Buchi automata. Other work [19, 29] transforms R into a language of graphs, and then to a nondeterministic automaton whose language represents the solution. Our method of constructing a solution is much simpler. <p> With no further assumptions about the partial order, this problem is PSPACE-complete [36, 16, 13], and if the partial order is a disjoint union of lattices or trees, then type inference is in polynomial time [36, 4]. Tiuryn and Wand <ref> [37] </ref> gave the first inference algorithm for atomic subtyping with recursive types: this problem is in EXPTIME. Thatte [35] introduced the problem of type inference with partial types (simple types plus &gt;), and showed that it was semi-decidable.
Reference: [38] <editor> Proceedings, </editor> <booktitle> 3 rd International Conference on Typed Lambda Calculi and Applications, </booktitle> <month> 2-4 April </month> <year> 1997. </year>
Reference: [39] <author> Valery Trifonov and Scott Smith. </author> <title> Subtyping constrained types. </title> <booktitle> In Proc. SAS'96, International Static Analysis Symposium. </booktitle> <publisher> Springer-Verlag (LNCS 1145), </publisher> <month> September </month> <year> 1996. </year>
Reference-contexts: Type inference for constrained types extended with let-polymorphism was studied for functional languages by Aiken and Wimmers [2], and later for object-oriented languages by Eifrig, Smith, and Trifonov [11, 10]. An algorithm for deciding a subtyping relation for constrained types, including type quantifiers, was presented by Trifonov and Smith <ref> [39] </ref>. The first use of simulations to define a subtyping relation that we are aware of is Pierce and Sangiorgi [31], who used it for a process calculus.
Reference: [40] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The power of simplicity. </title> <booktitle> In Proc. OOPSLA '87, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 227-241, </pages> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Acadamic Publishers, </publisher> <month> June </month> <year> 1991. </year> <month> 23 </month>
Reference-contexts: Some languages rely on explicit type annotations and static type checking, e.g., Java [15] and C ++ [12]. Others do not require type annotations and rely on dynamic type checking, e.g., Smalltalk [14] and Self <ref> [40] </ref>. What is not common is type inference for real languages with subtyping and recursive types. Although type inference is known for some systems combining both features, these systems tend to lack many features of full-fledged languages.
References-found: 40

