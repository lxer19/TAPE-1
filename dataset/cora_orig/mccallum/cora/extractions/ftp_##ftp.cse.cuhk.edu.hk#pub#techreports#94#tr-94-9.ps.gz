URL: ftp://ftp.cse.cuhk.edu.hk/pub/techreports/94/tr-94-9.ps.gz
Refering-URL: ftp://ftp.cs.cuhk.hk/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Computing Performance Bounds for Fork-Join Queueing Models  
Author: John C.S. Lui Richard R. Muntz Don Towsley 
Note: 1 The work of this author was supported in part by the Croucher Foundation and the Direct Research Grant from CUHK. 2 The work of this author was supported in part by the National Science Foundation under grant CCR-9215064. 3 The work of this author was supported in part by the National Science Foundation under grant NCR-9116183.  
Affiliation: Computer Science Department The Chinese University of Hong Kong  UCLA Computer Science Department  University of Massachusetts Computer Science Department  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> F. Baccelli and A.M. Makowski. </author> <title> Simple computable bounds for the fork-join queue. </title> <booktitle> Proceeding 19 th Annual Conference of Information Sciences and Systems. </booktitle> <publisher> The John Hopkins University, </publisher> <address> Baltimore, MD, </address> <pages> pp. </pages> <month> 436-441,March </month> <year> 1985. </year>
Reference-contexts: Nelson and Tantawi [24] also proposed a scaling approximation technique for K 2 homogeneous exponential servers. Recently, an extension to this approximation approach was developed by Makowski and Verma [22]. A more general model is considered in <ref> [1, 2, 3] </ref> where arrival and service processes are general. An upper bound is obtained by assuming K mutually independent GI=G=1 parallel queuing systems while the lower bound assumes D=G=1 parallel queueing systems. The tightness of these bounds is not investigated. <p> p 1 ]; :::; [N i ; p i + 1]; :::; [N K ; p K ]) ([a; b]; [N 1 ; p 1 ]; :::; [N i ; p i ]; :::; [N K ; p K ]) ! ([a; b]; [N 1 ; p 1 ]; :::; <ref> [N i 1; 1] </ref>; :::; [N K ; p K ]) ([a; b]; [N 1 ; p 1 ]; :::; [N i ; p i ]; :::; [N K ; p K ]) ! ([a; b]; [N 1 ; p 1 ]; :::; [0; 0]; :::; [N K ; p K <p> 5); (5; 4; 3); (5; 4; 4); (5; 4; 5); (5; 5; 3); (5; 5; 4); (5; 5; 5)g Example 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; <ref> [1; 1] </ref>; [3; 1]); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; <p> 4; 3); (5; 4; 4); (5; 4; 5); (5; 5; 3); (5; 5; 4); (5; 5; 5)g Example 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; <ref> [3; 1] </ref>); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; <p> 4; 4); (5; 4; 5); (5; 5; 3); (5; 5; 4); (5; 5; 5)g Example 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; <ref> [1; 1] </ref>; [3; 1]); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; <p> (5; 5; 3); (5; 5; 4); (5; 5; 5)g Example 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; [3; 2]); (2; <ref> [1; 2] </ref>; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; <p> 3); (5; 5; 4); (5; 5; 5)g Example 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; <ref> [3; 1] </ref>); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; <p> 4); (5; 5; 5)g Example 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; [3; 2]); (2; <ref> [1; 2] </ref>; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; <p> 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; <ref> [2; 1] </ref>; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; <p> the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; <ref> [3; 1] </ref>); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; <p> process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; <ref> [2; 1] </ref>; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; <p> times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; <ref> [2; 1] </ref>; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; <p> two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; <ref> [3; 1] </ref>); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; <p> = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; <ref> [2; 1] </ref>; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; <p> C = (3; 3), then S tt = f (1; [1; 1]; <ref> [3; 1] </ref>); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; <p> (3; 3), then S tt = f (1; <ref> [1; 1] </ref>; [3; 1]); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; <p> S tt = f (1; [1; 1]; <ref> [3; 1] </ref>); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; <p> = f (1; [1; 1]; [3; 1]); (1; [1; 1]; [3; 2]); (2; <ref> [1; 2] </ref>; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; <p> [1; 1]; <ref> [3; 1] </ref>); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 <p> [3; 1]); (1; <ref> [1; 1] </ref>; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B <p> [1; 1]; [3; 2]); (2; [1; 2]; <ref> [3; 1] </ref>); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality <p> [3; 2]); (2; <ref> [1; 2] </ref>; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the <p> [1; 2]; <ref> [3; 1] </ref>); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger <p> <ref> [3; 1] </ref>); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S <p> [1; 2]; [3; 2]); (1; [2; 1]; <ref> [3; 1] </ref>); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or <p> [2; 1]; <ref> [3; 1] </ref>); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> <ref> [3; 1] </ref>); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> [2; 1]; [3; 2]); (2; [2; 1]; <ref> [3; 1] </ref>); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> [3; 1]); (2; <ref> [2; 1] </ref>; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; <ref> [2; 1] </ref>); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. Definition 6 Let S tt (i) be the i th element in S tt , where 0 i B 1. <p> Using example 1 listed above, we have: B = 19; S tt (0) = (3; 3; 5); : : : ; S tt (18) = (5; 5; 5) Using example 2 listed above, we have: B = 40; S tt (0) = (1; <ref> [1; 1] </ref>; [3; 1]); : : : ; S tt (39) = (2; [3; 2]; [3; 2]) Definition 7 Let S u i;j , i 0; 0 j B i 1, be the set of states for the upper bound model M u such that (1) system is in the i <p> Using example 1 listed above, we have: B = 19; S tt (0) = (3; 3; 5); : : : ; S tt (18) = (5; 5; 5) Using example 2 listed above, we have: B = 40; S tt (0) = (1; [1; 1]; <ref> [3; 1] </ref>); : : : ; S tt (39) = (2; [3; 2]; [3; 2]) Definition 7 Let S u i;j , i 0; 0 j B i 1, be the set of states for the upper bound model M u such that (1) system is in the i th (where
Reference: [2] <author> F. Baccelli, A.M. Makowski and A. Shwartz. </author> <title> Simple computable bounds and approximations for fork-join queue. </title> <booktitle> Intern. Workshop on Computer Performance Evaluation, </booktitle> <address> Tokyo, </address> <month> September </month> <year> 1985, </year> <month> pp.437-450. </month>
Reference-contexts: Nelson and Tantawi [24] also proposed a scaling approximation technique for K 2 homogeneous exponential servers. Recently, an extension to this approximation approach was developed by Makowski and Verma [22]. A more general model is considered in <ref> [1, 2, 3] </ref> where arrival and service processes are general. An upper bound is obtained by assuming K mutually independent GI=G=1 parallel queuing systems while the lower bound assumes D=G=1 parallel queueing systems. The tightness of these bounds is not investigated. <p> (5; 4; 5); (5; 5; 3); (5; 5; 4); (5; 5; 5)g Example 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; <ref> [3; 2] </ref>); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; <p> (5; 5; 3); (5; 5; 4); (5; 5; 5)g Example 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; [3; 2]); (2; <ref> [1; 2] </ref>; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; <p> 4); (5; 5; 5)g Example 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; [3; 2]); (2; <ref> [1; 2] </ref>; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; <p> 5; 5)g Example 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; <ref> [3; 2] </ref>); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; <p> 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; <ref> [2; 1] </ref>; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; <p> process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; <ref> [2; 1] </ref>; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; <p> the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; <ref> [3; 2] </ref>); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; <p> times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; <ref> [2; 1] </ref>; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; <p> = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; <ref> [2; 1] </ref>; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; <p> d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; <ref> [3; 2] </ref>); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; <p> = f (1; [1; 1]; [3; 1]); (1; [1; 1]; [3; 2]); (2; <ref> [1; 2] </ref>; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; <p> [3; 2]); (2; <ref> [1; 2] </ref>; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the <p> <ref> [3; 2] </ref>); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = <p> <ref> [3; 2] </ref>); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> [2; 1]; [3; 1]); (2; [2; 1]; <ref> [3; 2] </ref>); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> [3; 1]); (2; <ref> [2; 1] </ref>; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> [2; 1]; <ref> [3; 2] </ref>); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; <ref> [2; 2] </ref>); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; <ref> [3; 2] </ref>); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; <ref> [2; 1] </ref>); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. Definition 6 Let S tt (i) be the i th element in S tt , where 0 i B 1. <p> [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; <ref> [3; 2] </ref>); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. Definition 6 Let S tt (i) be the i th element in S tt , where 0 i B 1. <p> [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; <ref> [2; 2] </ref>); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. Definition 6 Let S tt (i) be the i th element in S tt , where 0 i B 1. <p> have: B = 19; S tt (0) = (3; 3; 5); : : : ; S tt (18) = (5; 5; 5) Using example 2 listed above, we have: B = 40; S tt (0) = (1; [1; 1]; [3; 1]); : : : ; S tt (39) = (2; <ref> [3; 2] </ref>; [3; 2]) Definition 7 Let S u i;j , i 0; 0 j B i 1, be the set of states for the upper bound model M u such that (1) system is in the i th (where i &gt; 0) nested level of busy cycles, 11 (2) the <p> = 19; S tt (0) = (3; 3; 5); : : : ; S tt (18) = (5; 5; 5) Using example 2 listed above, we have: B = 40; S tt (0) = (1; [1; 1]; [3; 1]); : : : ; S tt (39) = (2; <ref> [3; 2] </ref>; [3; 2]) Definition 7 Let S u i;j , i 0; 0 j B i 1, be the set of states for the upper bound model M u such that (1) system is in the i th (where i &gt; 0) nested level of busy cycles, 11 (2) the difference in
Reference: [3] <author> F. Baccelli, A.M. Makowski and A. Shwartz. </author> <title> The Fork-Join Queue and Related Systems with Synchronization constraints: Stochastic Ordering and Computable Bounds. </title> <journal> Adv. Applied Probability, </journal> <volume> Vol 21, </volume> <pages> pp. 629-660, </pages> <year> 1989. </year>
Reference-contexts: Nelson and Tantawi [24] also proposed a scaling approximation technique for K 2 homogeneous exponential servers. Recently, an extension to this approximation approach was developed by Makowski and Verma [22]. A more general model is considered in <ref> [1, 2, 3] </ref> where arrival and service processes are general. An upper bound is obtained by assuming K mutually independent GI=G=1 parallel queuing systems while the lower bound assumes D=G=1 parallel queueing systems. The tightness of these bounds is not investigated. <p> 4; 3); (5; 4; 4); (5; 4; 5); (5; 5; 3); (5; 5; 4); (5; 5; 5)g Example 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; <ref> [3; 1] </ref>); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; <p> (5; 4; 5); (5; 5; 3); (5; 5; 4); (5; 5; 5)g Example 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; <ref> [3; 2] </ref>); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; <p> 3); (5; 5; 4); (5; 5; 5)g Example 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; <ref> [3; 1] </ref>); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; <p> 5; 5)g Example 2: If the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; <ref> [3; 2] </ref>); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; <p> the job arrival process and the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; <ref> [3; 1] </ref>); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; <p> the task service times are two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; <ref> [3; 2] </ref>); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; <p> two-stage Erlang, K = 2, d = 2, C = (3; 3), then S tt = f (1; [1; 1]; <ref> [3; 1] </ref>); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; <p> d = 2, C = (3; 3), then S tt = f (1; [1; 1]; [3; 1]); (1; [1; 1]; <ref> [3; 2] </ref>); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; <p> C = (3; 3), then S tt = f (1; [1; 1]; <ref> [3; 1] </ref>); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; <p> S tt = f (1; [1; 1]; <ref> [3; 1] </ref>); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; <p> [1; 1]; <ref> [3; 1] </ref>); (1; [1; 1]; [3; 2]); (2; [1; 2]; [3; 1]); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 <p> [1; 1]; [3; 2]); (2; [1; 2]; <ref> [3; 1] </ref>); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality <p> [1; 2]; <ref> [3; 1] </ref>); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger <p> <ref> [3; 1] </ref>); (2; [1; 2]; [3; 2]); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S <p> [1; 2]; [3; 2]); (1; [2; 1]; <ref> [3; 1] </ref>); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or <p> <ref> [3; 2] </ref>); (1; [2; 1]; [3; 1]); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = <p> [2; 1]; <ref> [3; 1] </ref>); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> <ref> [3; 1] </ref>); (1; [2; 1]; [3; 2]); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> [2; 1]; [3; 2]); (2; [2; 1]; <ref> [3; 1] </ref>); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> <ref> [3; 2] </ref>); (2; [2; 1]; [3; 1]); (2; [2; 1]; [3; 2]); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> [2; 1]; [3; 1]); (2; [2; 1]; <ref> [3; 2] </ref>); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> [2; 1]; <ref> [3; 2] </ref>); (1; [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; [3; 2]); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> [3; 1]; [1; 1]); (1; [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; <ref> [3; 2] </ref>); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. <p> [3; 1]; [1; 2]); (2; [3; 1]; [1; 1]); (2; [3; 1]; [1; 2]); (1; [3; 1]; [3; 1]); (1; [3; 1]; <ref> [3; 2] </ref>); (2; [3; 1]; [3; 1]); (2; [3; 1]; [3; 2]); (1; [3; 2]; [2; 1]); (1; [3; 2]; [2; 2]); (2; [3; 2]; [2; 1]); (2; [3; 2]; [2; 2]); Definition 5 Let B be the cardinality of the set of trigger states S tt , or B = jS tt j. Definition 6 Let S tt (i) be the i th element in S tt , where 0 i B 1. <p> Using example 1 listed above, we have: B = 19; S tt (0) = (3; 3; 5); : : : ; S tt (18) = (5; 5; 5) Using example 2 listed above, we have: B = 40; S tt (0) = (1; [1; 1]; <ref> [3; 1] </ref>); : : : ; S tt (39) = (2; [3; 2]; [3; 2]) Definition 7 Let S u i;j , i 0; 0 j B i 1, be the set of states for the upper bound model M u such that (1) system is in the i th (where <p> have: B = 19; S tt (0) = (3; 3; 5); : : : ; S tt (18) = (5; 5; 5) Using example 2 listed above, we have: B = 40; S tt (0) = (1; [1; 1]; [3; 1]); : : : ; S tt (39) = (2; <ref> [3; 2] </ref>; [3; 2]) Definition 7 Let S u i;j , i 0; 0 j B i 1, be the set of states for the upper bound model M u such that (1) system is in the i th (where i &gt; 0) nested level of busy cycles, 11 (2) the <p> = 19; S tt (0) = (3; 3; 5); : : : ; S tt (18) = (5; 5; 5) Using example 2 listed above, we have: B = 40; S tt (0) = (1; [1; 1]; [3; 1]); : : : ; S tt (39) = (2; <ref> [3; 2] </ref>; [3; 2]) Definition 7 Let S u i;j , i 0; 0 j B i 1, be the set of states for the upper bound model M u such that (1) system is in the i th (where i &gt; 0) nested level of busy cycles, 11 (2) the difference in
Reference: [4] <author> F. Baccelli, W.A. Massey and D. Towsley. </author> <title> Acyclic Fork-Join Queueing Networks. </title> <journal> Journal of ACM, Vol.36, </journal> <volume> No. 3, </volume> <pages> pp. 615-642, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Stability conditions for fork-join queueing networks were investigated by Konstantopoulos and Walrand [17] while the mean job response time was studied in <ref> [4] </ref> but the tightness of the bounds was not investigated. In [6], bounds on job response time were derived based on two-server models. Lastly, models have been investigated for programs exhibiting parallel fork-join structures that are executed on multiple servers sharing a single queue [18, 25, 30].
Reference: [5] <author> A. Beguelin, J.J. Dongarra, A. Geist, R. Manchek, V.Sunderam. </author> <title> PVM and HeNCE: Tools for Heterogeneous Network Computing. </title> <booktitle> Advances in Parallel Computing: Environments and Tools for Parallel Scientific Computing, </booktitle> <publisher> Elsevier Science Publishers, </publisher> <pages> pp. 139-153, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction With the advent of multiprocessing technology, parallel programming languages [14, 26] and parallel programming environments <ref> [5, 11] </ref>, there is an increasing interest in understanding and modeling the performance of parallel programs. In this paper, we propose a methodology to evaluate the performance of parallel programs which have a fork-join control structure on a parallel machine. We model this kind of parallel program as follows.
Reference: [6] <author> S. Chen and D. Towsley. </author> <title> Design and Modeling Policies for Two Server Fork/Join Queueing Systems. University of Mass. </title> <type> COINS Technical Report 91-39, </type> <year> 1991. </year>
Reference-contexts: Stability conditions for fork-join queueing networks were investigated by Konstantopoulos and Walrand [17] while the mean job response time was studied in [4] but the tightness of the bounds was not investigated. In <ref> [6] </ref>, bounds on job response time were derived based on two-server models. Lastly, models have been investigated for programs exhibiting parallel fork-join structures that are executed on multiple servers sharing a single queue [18, 25, 30].
Reference: [7] <author> P. J. Courtois. </author> <title> Decomposability | queueing and computer system applications. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1977. </year>
Reference-contexts: Further, transitions from S u i+1;k to S u i;j can only go to one state in S u i;j . This unique transition structure, as we will show later, allows us to efficiently solve the model via exact aggregation <ref> [7] </ref>. After we aggregate each set of states, S u i;j , into a single state s u i;j , the aggregated model has a tree structure, which implies the aggregated process is time reversible [15] and the steady state probability solution to this aggregated process can be derived easily. <p> This implies we only need to solve two models, ^ Q S u 0;0 ;S u 1;0 ;S u to obtain all the conditional state probabilities. Once we obtain the conditional state probabilities for partition S u i;j , we can aggregate each partition <ref> [7] </ref> into a single state, which we denote as s u i;j .
Reference: [8] <author> P. J. Courtois, P. Semal. </author> <title> Computable Bounds for Conditional Steady-State Probabilities in Large Markov Chains and Queueing Models. </title> <journal> IEEE JSAC, </journal> <volume> Vol 4, number 6, </volume> <month> September, </month> <year> 1986. </year>
Reference-contexts: In order to justify the procedure for computing the conditional steady state probabil ities for states in S u i;j given that the system is in set S u i;j , we need the follow lemma from <ref> [8, 23, 20] </ref>: Lemma 2 Given an irreducible Markov process with state space S = A [B and transition rate matrix: " Q A;A Q A;B # where Q i;j is the transition rate sub-matrix from partition i to partition j.
Reference: [9] <author> L. Fatto and S. Hahn. </author> <title> Two parallel queues created by arrivals with two demands I, </title> <journal> SIAM J. Appl. Math., </journal> <volume> Vol. 44, pp.1041-1053, </volume> <month> Oct, </month> <year> 1984. </year>
Reference-contexts: First, exact analysis is possible when the system is significantly simplified, for example, if we assume the job arrival process is Poisson with tasks having exponential service time distribution and the number of servers is equal to two. The 1 exact analysis for this system can be found in <ref> [9, 10, 24] </ref>. Nelson and Tantawi [24] also proposed a scaling approximation technique for K 2 homogeneous exponential servers. Recently, an extension to this approximation approach was developed by Makowski and Verma [22]. A more general model is considered in [1, 2, 3] where arrival and service processes are general.
Reference: [10] <author> L. Fatto. </author> <title> Two parallel queues created by arrivals with two demands II, </title> <journal> SIAM J. Appl. Math., </journal> <volume> Vol. 45, pp.861-878, </volume> <month> Oct, </month> <year> 1985. </year>
Reference-contexts: First, exact analysis is possible when the system is significantly simplified, for example, if we assume the job arrival process is Poisson with tasks having exponential service time distribution and the number of servers is equal to two. The 1 exact analysis for this system can be found in <ref> [9, 10, 24] </ref>. Nelson and Tantawi [24] also proposed a scaling approximation technique for K 2 homogeneous exponential servers. Recently, an extension to this approximation approach was developed by Makowski and Verma [22]. A more general model is considered in [1, 2, 3] where arrival and service processes are general.
Reference: [11] <author> G.A. Geist, </author> <title> V.S. Sunderam. The PVM System: Supercomputing Level Concurrent Computations on Heterogeneous Network of Workstations. </title> <booktitle> The Sixth Distributed memory Computing Conference Proceedings, </booktitle> <pages> pp. 258-261, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: 1 Introduction With the advent of multiprocessing technology, parallel programming languages [14, 26] and parallel programming environments <ref> [5, 11] </ref>, there is an increasing interest in understanding and modeling the performance of parallel programs. In this paper, we propose a methodology to evaluate the performance of parallel programs which have a fork-join control structure on a parallel machine. We model this kind of parallel program as follows.
Reference: [12] <author> P. </author> <title> Heidelberger and K.S. Trivedi. Queueing Network models for parallel processing with asynchronous tasks. </title> <journal> IEEE Trans. Computer, </journal> <volume> Vol. C-31, pp.1099-1109, </volume> <month> Nov, </month> <year> 1982. </year>
Reference-contexts: An upper bound is obtained by assuming K mutually independent GI=G=1 parallel queuing systems while the lower bound assumes D=G=1 parallel queueing systems. The tightness of these bounds is not investigated. Heidelberger and Trivedi <ref> [12] </ref> developed an approximate solution with bounds for a queueing network with jobs having computation graphs with a fork phase only (i.e., no synchronization of the completion of the tasks).
Reference: [13] <author> P. </author> <title> Heidelberger and K.S. Trivedi. Analytic queueing models for programs with inter-nal concurrency. </title> <journal> IEEE Trans. Computer, </journal> <volume> Vol. C-32, pp.73-82, </volume> <month> Nov, </month> <year> 1983. </year>
Reference-contexts: The tightness of these bounds is not investigated. Heidelberger and Trivedi [12] developed an approximate solution with bounds for a queueing network with jobs having computation graphs with a fork phase only (i.e., no synchronization of the completion of the tasks). In <ref> [13] </ref>, the model is extended to contain a fork and join node and two approximation techniques are presented: one is based on a decomposition approach and other is based on an iterative solution method.
Reference: [14] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <address> London, </address> <year> 1985. </year>
Reference-contexts: 1 Introduction With the advent of multiprocessing technology, parallel programming languages <ref> [14, 26] </ref> and parallel programming environments [5, 11], there is an increasing interest in understanding and modeling the performance of parallel programs. In this paper, we propose a methodology to evaluate the performance of parallel programs which have a fork-join control structure on a parallel machine.
Reference: [15] <author> F.P. Kelly. </author> <title> Reversibility and Stochastic Networks. </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: After we aggregate each set of states, S u i;j , into a single state s u i;j , the aggregated model has a tree structure, which implies the aggregated process is time reversible <ref> [15] </ref> and the steady state probability solution to this aggregated process can be derived easily. We are now in a position to describe the computational procedure to obtain the expected response time for the upper bound model M u .
Reference: [16] <author> L. Kleinrock. </author> <title> Queueing Systems Volume I: Theory. </title> <publisher> Wiley International, </publisher> <year> 1975. </year>
Reference-contexts: The parallel program is modeled as an external job with interarrival distribution being a series-parallel phase type distribution where each phase is exponentially distributed <ref> [16] </ref>. The mean arrival rate of external jobs is denoted by . Upon arrival, a job forks into K tasks, namely t i ; 1 i K. <p> Let fl (i; j) be the steady state probability for the aggregate state s u i;j . For this aggregated process, we can write the local balance equations <ref> [16] </ref>: fl (1; i) = fl (0; 0) i 0 i B 1 ufl (jmodB) -u Normalizing all local balance equations, we have: fl (0; 0) 4 1+ -u i=0 i + 1 2 B1 X B1 X u 0 j + 1 3 B1 X B1 X B1 X u
Reference: [17] <author> P. Konstantopoulos and J. Walrand. </author> <title> Stationary and Stability of Fork-Join Networks. </title> <journal> Journal of Applied Probability, Vol.26, </journal> <volume> pp.604-614, </volume> <year> 1989. </year>
Reference-contexts: In [13], the model is extended to contain a fork and join node and two approximation techniques are presented: one is based on a decomposition approach and other is based on an iterative solution method. Stability conditions for fork-join queueing networks were investigated by Konstantopoulos and Walrand <ref> [17] </ref> while the mean job response time was studied in [4] but the tightness of the bounds was not investigated. In [6], bounds on job response time were derived based on two-server models.
Reference: [18] <author> C.P. Kruskal and A. Weiss. </author> <title> Allocating independent substasks on parallel processors. </title> <journal> IEEE Trans. Software Eng. </journal> <volume> SE-11, </volume> <pages> pp. 1001-1016, </pages> <month> October. </month> <year> 1985 </year>
Reference-contexts: In [6], bounds on job response time were derived based on two-server models. Lastly, models have been investigated for programs exhibiting parallel fork-join structures that are executed on multiple servers sharing a single queue <ref> [18, 25, 30] </ref>. Rather than complete modification of the arrival and service distributions to obtain bounds on the mean job response time as reported in previous literature, we show that by modifying the arrival and service distributions at some imbedded points in time, we can obtain better performance bounds.
Reference: [19] <author> John C.S. Lui, R.R. Muntz and D. Towsley. </author> <title> Bounding the Response Time of a Minimum Expected Delay Routing System: </title> <note> An Algorithmic Approach Submitted for publication in IEEE Trans. on Computers. </note>
Reference-contexts: The approach is to show that M u gives an upper bound on the number of tasks in the system at any given point in time using sample path analysis <ref> [19] </ref>. In the case that the model exhibits stationary behavior, we apply Equation (4) to obtain the expected job response time. To establish the upper bound, let us define the notion of sub-task.
Reference: [20] <author> John C.S. Lui, R.R. Muntz. </author> <title> Computing Bounds on Steady State Availability of Repairable Computer Systems. </title> <journal> Journal of ACM, </journal> <volume> Vol 41, No. 4, </volume> <pages> pp. 676-707, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: In order to justify the procedure for computing the conditional steady state probabil ities for states in S u i;j given that the system is in set S u i;j , we need the follow lemma from <ref> [8, 23, 20] </ref>: Lemma 2 Given an irreducible Markov process with state space S = A [B and transition rate matrix: " Q A;A Q A;B # where Q i;j is the transition rate sub-matrix from partition i to partition j.
Reference: [21] <author> Marshall and Olkin. </author> <title> Inequalities: Theory of Majorization and Applications, </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: We will use the concept of majorization <ref> [21] </ref> in the proof so we first review some basic facts about majorization. <p> The proof follows in a straightforward manner from the definition of " w ". The reader is referred to <ref> [21] </ref> for a detailed proof. In the following definition, we introduce the concept of a Schur-convex function, which will be useful in applying stochastic comparison based on majorization. <p> the sense of Schur-convex order (written X scx Y ) iff (X) st (Y ); 8Schur-convex : If the class of functions is restricted to be increasing Schur-convex, then we say that X is smaller than Y in the sense of increasing Schur-convex order (X iscx Y ). 22 From <ref> [21] </ref>, we have a property of these orderings as expressed in the following lemma.
Reference: [22] <author> A. Makowski and S. Verma. </author> <title> Interpolation Approximations for Symmetric Fork-Join Queues. Performance '93. </title>
Reference-contexts: The 1 exact analysis for this system can be found in [9, 10, 24]. Nelson and Tantawi [24] also proposed a scaling approximation technique for K 2 homogeneous exponential servers. Recently, an extension to this approximation approach was developed by Makowski and Verma <ref> [22] </ref>. A more general model is considered in [1, 2, 3] where arrival and service processes are general. An upper bound is obtained by assuming K mutually independent GI=G=1 parallel queuing systems while the lower bound assumes D=G=1 parallel queueing systems. The tightness of these bounds is not investigated. <p> Each processor is modeled as a single server with infinite queueing capacity and FCFS scheduling discipline. The system model is depicted in Figure 1. The stability condition for this kind of queueing system is <ref> [22] </ref>: &lt; (1) which is the local stability condition for each server in the system. A job leaves the system as soon as all its tasks are completed. For a partially completed job, the completed tasks are forced to wait in the synchronization area.
Reference: [23] <author> R.R. Muntz, E. De Souza E Silva and A. Goyal. </author> <title> Bounding Availability of Repairable Computer Systems. </title> <booktitle> In Proceedings of 1989 ACM SIGMETRICS and PERFORMANCE '89, also in special issue of IEEE Trans. Computers, </booktitle> <month> Dec. </month> <year> 1989, </year> <pages> pp. 19-30. </pages>
Reference-contexts: In order to justify the procedure for computing the conditional steady state probabil ities for states in S u i;j given that the system is in set S u i;j , we need the follow lemma from <ref> [8, 23, 20] </ref>: Lemma 2 Given an irreducible Markov process with state space S = A [B and transition rate matrix: " Q A;A Q A;B # where Q i;j is the transition rate sub-matrix from partition i to partition j.
Reference: [24] <author> R. </author> <title> Nelson and A.N. Tantawi. Approximate Analysis of Fork/Join Synchronization in Parallel Queues. </title> <journal> IEEE Transaction of Computers, </journal> <volume> Vol. 37, No. 6, </volume> <month> June, </month> <year> 1988. </year>
Reference-contexts: First, exact analysis is possible when the system is significantly simplified, for example, if we assume the job arrival process is Poisson with tasks having exponential service time distribution and the number of servers is equal to two. The 1 exact analysis for this system can be found in <ref> [9, 10, 24] </ref>. Nelson and Tantawi [24] also proposed a scaling approximation technique for K 2 homogeneous exponential servers. Recently, an extension to this approximation approach was developed by Makowski and Verma [22]. A more general model is considered in [1, 2, 3] where arrival and service processes are general. <p> The 1 exact analysis for this system can be found in [9, 10, 24]. Nelson and Tantawi <ref> [24] </ref> also proposed a scaling approximation technique for K 2 homogeneous exponential servers. Recently, an extension to this approximation approach was developed by Makowski and Verma [22]. A more general model is considered in [1, 2, 3] where arrival and service processes are general.
Reference: [25] <author> R. Nelson, D. </author> <title> Towsley and A.N. Tantawi. Performance Analysis of Parallel Processing Systems. </title> <journal> IEEE Transaction of Software Engineering, </journal> <volume> 14, pp.532-540, </volume> <month> April </month> <year> 1988. </year>
Reference-contexts: In [6], bounds on job response time were derived based on two-server models. Lastly, models have been investigated for programs exhibiting parallel fork-join structures that are executed on multiple servers sharing a single queue <ref> [18, 25, 30] </ref>. Rather than complete modification of the arrival and service distributions to obtain bounds on the mean job response time as reported in previous literature, we show that by modifying the arrival and service distributions at some imbedded points in time, we can obtain better performance bounds.
Reference: [26] <author> I.C. Pyle. </author> <booktitle> The Ada Programming Language. Prentice-Hall International, </booktitle> <address> London, </address> <year> 1981. </year>
Reference-contexts: 1 Introduction With the advent of multiprocessing technology, parallel programming languages <ref> [14, 26] </ref> and parallel programming environments [5, 11], there is an increasing interest in understanding and modeling the performance of parallel programs. In this paper, we propose a methodology to evaluate the performance of parallel programs which have a fork-join control structure on a parallel machine.
Reference: [27] <author> A. Giest, A. Beguelin, J. Dongarra, W. Jiang, R. Manchek, V. Sunderam. </author> <title> PVM 3:0 User's Guide and Reference Manual. </title> <institution> Oak Ridge National Laboratory, </institution> <year> 1993. </year>
Reference-contexts: l -l lfl + KC-l 2 (31) 5 Applications and Numerical Examples In this section, we present two examples in order to illustrate the applicability of the bounding algorithm. 30 Let us consider a computer vision system implemented in a homogeneous workstation cluster under the Parallel Virtual Machines (PVM) environment <ref> [27] </ref>. An image will arrive to the computer vision control manager, which will then assign a portion of the image to each workstation for computation.
Reference: [28] <author> S.M. Ross. </author> <title> Introduction to Probability Models. </title> <publisher> Academic Press, </publisher> <year> 1970. </year> <month> 35 </month>
Reference-contexts: The interarrival time random variable t , can be expressed as t = j=1 Because st relationship is preserved under linear combination <ref> [28] </ref>. Therefore: t max = j=1 R X ff j ^t 1j = t (12) Let Z be a random variable that takes on value 0 or 1. Define ^t max = t Prob (Z = 0) t max Prob (Z = 1) Corollary 2 ^t max st t . <p> We want to show that n G (t) st n F (t) for t 0 In preparation for this proof, we need the following lemma about coupling between random variables <ref> [28] </ref>: Lemma 1 If F and G are probability distributions such that F (a) G (a) for all a, then there exist random variables X and Y having distributions F and G respectively such that P fY Xg = 1 Theorem 3 fn G (t); t 0g st fn F (t);
Reference: [29] <author> M. R. Stonebraker. </author> <title> The Case for Shared-Nothing. </title> <booktitle> Proceeding of the 1986 Data Engineering Conference. IEEE, </booktitle> <year> 1986. </year>
Reference-contexts: The job is considered complete (and it departs from the system) when all its tasks have completed their service. This kind of parallel program paradigm arises in many application areas. For example, in a parallel database machine with a shared-nothing architecture <ref> [29] </ref>, a complex query is partitioned so that there is a local query on each processing nodes. Another example is a computer vision system where an image is fed to a multiprocessor system, each processor does ray-tracing calculations for a portion of the rays.
Reference: [30] <author> D. Towsley, J.A. Rommel and J.A. Stankovic. </author> <title> The Performance of Processor Sharing Scheduling Fork-Join in Multiprocessors. High-Performance Computer Systems. </title> <editor> E. Gelenbe. ed. </editor> <publisher> North-Holland, Amsterdam, </publisher> <pages> pp. 146-156, </pages> <year> 1988. </year> <month> 36 </month>
Reference-contexts: In [6], bounds on job response time were derived based on two-server models. Lastly, models have been investigated for programs exhibiting parallel fork-join structures that are executed on multiple servers sharing a single queue <ref> [18, 25, 30] </ref>. Rather than complete modification of the arrival and service distributions to obtain bounds on the mean job response time as reported in previous literature, we show that by modifying the arrival and service distributions at some imbedded points in time, we can obtain better performance bounds.
References-found: 30

