URL: http://emr.cs.uiuc.edu/~reingold/chips.ps
Refering-URL: http://calcutta.cs.uiuc.edu:1024/cs491.html
Root-URL: http://www.cs.uiuc.edu
Title: The Chip Problem  
Author: Laurent Alonso Philippe Chassaing Edward M. Reingold Rene Schott 
Keyword: Key words. Fault diagnosis, algorithm analysis, chip problem, majority problem, probabilistic algorithms.  
Address: LORIA, Universite Henri Poincare-Nancy I, BP 239, 54506 Vandoeuvre-les-Nancy, France.  Elie Cartan, Universite Henri Poincare-Nancy I, BP 239, 54506 Vanduvre-les-Nancy, France.  1304 W. Springfield Avenue, Urbana, Illinois 61801, USA.  Rehovot, Israel.  LORIA, Universite Henri Poincare-Nancy I, BP 239, 54506 Vanduvre-les-Nancy, France.  
Affiliation: INRIA-Lorraine and  Institut  Department of Computer Science, University of Illinois at Urbana-Champaign,  Weizmann Institute of Science,  -Institut Elie Cartan and  
Note: AMS(MOS) subject classifications.  Supported in part by NSF grants CCR-93-20577 and CCR-95-30297 and by a Meyerhoff Visiting Professorship at the  
Email: Email: Laurent.Alonso@loria.fr  Email: Philippe.Chassaing@antares.iecn.u-nancy.fr  Email: reingold@cs.uiuc.edu  Email: Rene.Schott@loria.fr  
Date: December 3, 1998  
Web: 68Q25, 68P10, 68Q20, 68R05, 05A10, 11A63  
Abstract: The "chip problem" is a fault diagnosis problem in which we must determine which components (chips) in a system are defective, assuming the majority of them are good. Chips are tested as follows: Take two chips, say x and y, and have x report whether y is good or bad. If x is good, the answer is correct, but if x is bad, the answer is unreliable and can be either wrong with probability ff or right with probability 1 ff. We show that the chip problem is closely related to a modified majority problem in the worst case and use this fact to obtain upper and lower bounds on algorithms for the chip problem. We show the limits of this relationship by showing that algorithms for the chip problem can violate lower bounds on average performance for the modified majority problem and we give an algorithm for the "biased chip" problem (in which p is the probability that a chip is bad) whose average performance is better than the average cost of the best algorithm for the biased majority problem. fl A preliminary version of these results was presented at the DIMACS Workshop on Average-Case Analysis of Algorithms, July 20-24, 1998, Princeton, NJ. This research was supported in part by INRIA and the NSF, through grant numbers NSF INT 90-16958 and 95-07248. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alonso, L., E. M. Reingold, and R. Schott, </author> <title> "Determining the majority," Info. </title> <booktitle> Proc. Let. 47 (1993), </booktitle> <pages> 253-255. </pages>
Reference-contexts: We consider both the worst and average case for this problem, using results of the "majority problem" as starting point of our investigations. Other algorithmic questions are discussed in the conclusions. 2 Majority Problems The majority problem of <ref> [1] </ref>, [2], and [9] is to determine the majority color in a set of n elements fx 1 ; x 2 ; : : : ; x n g, each element of which is colored either blue 2 S R H A O J G E C chip to another labeled <p> In the worst case, exactly n -(n) questions are necessary and sufficient for the majority problem, where, following [6], -(n) is the number of 1-bits in the binary representation of n. This result was first proved by Saks and Werman [9]; <ref> [1] </ref> gave a short, elementary proof. [2] proved that any algorithm that correctly determines the majority must on the average use at least 2n 8n + fi (1) color comparisons, assuming all 2 n distinct colorings of the n elements are equally probable.
Reference: [2] <author> Alonso, L., E. M. Reingold, and R. Schott, </author> <title> "The average-case complexity of determining the majority," </title> <journal> SIAM J. Comput. </journal> <month> 26 </month> <year> (1997) </year> <month> 1-14. </month>
Reference-contexts: We consider both the worst and average case for this problem, using results of the "majority problem" as starting point of our investigations. Other algorithmic questions are discussed in the conclusions. 2 Majority Problems The majority problem of [1], <ref> [2] </ref>, and [9] is to determine the majority color in a set of n elements fx 1 ; x 2 ; : : : ; x n g, each element of which is colored either blue 2 S R H A O J G E C chip to another labeled by <p> In the worst case, exactly n -(n) questions are necessary and sufficient for the majority problem, where, following [6], -(n) is the number of 1-bits in the binary representation of n. This result was first proved by Saks and Werman [9]; [1] gave a short, elementary proof. <ref> [2] </ref> proved that any algorithm that correctly determines the majority must on the average use at least 2n 8n + fi (1) color comparisons, assuming all 2 n distinct colorings of the n elements are equally probable. Furthermore, [2] describes an algorithm that uses an aver age of 3 r 9 <p> proved by Saks and Werman [9]; [1] gave a short, elementary proof. <ref> [2] </ref> proved that any algorithm that correctly determines the majority must on the average use at least 2n 8n + fi (1) color comparisons, assuming all 2 n distinct colorings of the n elements are equally probable. Furthermore, [2] describes an algorithm that uses an aver age of 3 r 9 color comparisons. Together these bounds imply that 2n 8n + O (log n) such comparisons are necessary and sufficient in the average case to solve the original majority problem. <p> In fact, these two problems are equivalent in the worst case. Suppose there is an algorithm that determines the majority color in the modified majority problem, the same algorithm can be used to solve the chip problem. To prove this, we recall from <ref> [2] </ref> that any algorithm for the (modified) majority problem corresponds to a decision tree in which the state of affairs at any node in decision tree for an algorithm solving the majority problem can be described with a nonincreasing sequence of positive integers 1 2 m &gt; 0; each i is <p> P n sets of n chips having a strict majority of good chips occurs with probability 1= P n Since the modified majority problem is identical to the original majority problem for odd n, the tree in Figure 5 (which is derived from the algorithm described in the conclusions of <ref> [2] </ref>), is optimal for the modified majority problem with n = 5, having cost 2.25. <p> Third, if we choose all n chips as the sample, algorithm A n (; 1; *) is precisely the majority algorithm from <ref> [2] </ref> which is optimal in the worst case and within O (log n) of being optimal in the average case. The analysis of A n (; ff; *) rests on two results.
Reference: [3] <author> Bollobas, B., </author> <title> Random Graphs, </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1985. </year>
Reference-contexts: Now Chernoff's inequality <ref> [3, top of page 12] </ref> states that, if N is a binomially distributed random variable with parameters n and p, then Pr (jN pnj h) 2e 2h 2 =n ; so that Pr (N pn h) 2e 2h 2 =n (11) because Pr (jN pnj h) = Pr (N pn h)
Reference: [4] <author> Chassaing, P., </author> <title> "Determining the majority: the biased case," </title> <journal> Ann. Appl. Prob. </journal> <volume> 7 (1997), </volume> <pages> 523-544. </pages>
Reference-contexts: Together these bounds imply that 2n 8n + O (log n) such comparisons are necessary and sufficient in the average case to solve the original majority problem. The biased case of the majority problem has been investigated by Chassaing <ref> [4] </ref>. Let p be the probability that an element is blue and q = 1p the probability that it is red. Let = q=p. <p> These algorithms are based on Chassaing's algorithm <ref> [4, Section 9] </ref>. The algorithm A n (; ff; *) works by choosing a sample of size m &lt; n from the chips and combining the m chips into larger and larger happy binomial trees. <p> When ff = 1 the choice m n (; 1; *) = 2p for some *, 0 &lt; * &lt; 1=2, results from basic considerations about the binomial distribution (see <ref> [4, Section 9] </ref>), while when ff &lt; 1 the choice of a value m n (; ff; *) meeting these requirements is more subtle.
Reference: [5] <author> Cormen, T. H., C. E. Leiserson, and R. L. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: For convenience of language we refer to "chips" rather than "units" or "components" <ref> [5, exercise 4-7, page 75] </ref>. An algorithm can determine whether a bad (faulty) chip exists if and only if a strict majority of the chips are fault-free [8]. <p> The tree structures we use are binomial trees [12] (see also <ref> [5, Chapter 20] </ref>). For convenience, we summarize the necessary details here. A binomial tree of chips B k is an (unordered) tree defined recursively as shown in Figure 3.
Reference: [6] <author> Greene, D. H. and D. E. Knuth, </author> <title> Mathematics for the Analysis of Algorithms, </title> <publisher> 3rd ed., Birkhauser, </publisher> <address> Boston, </address> <year> 1990. </year>
Reference-contexts: When n is even, we must report that there is no majority if there are equal numbers of each color. In the worst case, exactly n -(n) questions are necessary and sufficient for the majority problem, where, following <ref> [6] </ref>, -(n) is the number of 1-bits in the binary representation of n.
Reference: [7] <author> Hakimi, S. L. and E. F. Schmeichel, </author> <title> "An adaptive algorithm for system level diagnosis," </title> <journal> J. </journal> <note> Algorithms 5 (1984) 526-530. </note>
Reference-contexts: binomial trees that diagnose R as good in the final stage fi fi : If there are no happy binomial trees left at the end of the stages of tests, or if the consequences of R being bad are not sufficient to reach a contradiction, we use the algorithm of <ref> [7] </ref> to identify a good chip. That algorithm uses n tests, but it will rarely need to be invoked. <p> With the proper choice of m, the number of tests used is small and the probability that the algorithm of <ref> [7] </ref> must be invoked is exponentially small. When bad chips always lie (ff = 1), this algorithm solves the majority problem, provided that X m &gt; n=2, since R belongs to the majority. <p> Finally, we prove (10). By (9), the likelihood of needing to apply the fi (n) algorithm of <ref> [7] </ref> is exponentially small, so we ignore it in our estimates of T m . Let m i = 0 if i &gt; lg m.
Reference: [8] <author> Preparata, F., G. Metze, and R. T. Chien, </author> <title> "On the connection assignment problem for diagnosable systems," </title> <journal> IEEE Trans. Comput. </journal> <month> 16 </month> <year> (1967) </year> <month> 848-854. </month>
Reference-contexts: For convenience of language we refer to "chips" rather than "units" or "components" [5, exercise 4-7, page 75]. An algorithm can determine whether a bad (faulty) chip exists if and only if a strict majority of the chips are fault-free <ref> [8] </ref>. The basic problem is to determine that some chip is good (fault-free) so we can rely on its diagnosis of other chips; the difficulty is that a faulty chip can behave exactly like a fault-free one.
Reference: [9] <author> Saks, M. E. and M. Werman, </author> <title> "On computing majority by comparisons," </title> <note> Combinatorica 11 (1991) 383-387. </note>
Reference-contexts: We consider both the worst and average case for this problem, using results of the "majority problem" as starting point of our investigations. Other algorithmic questions are discussed in the conclusions. 2 Majority Problems The majority problem of [1], [2], and <ref> [9] </ref> is to determine the majority color in a set of n elements fx 1 ; x 2 ; : : : ; x n g, each element of which is colored either blue 2 S R H A O J G E C chip to another labeled by a smiling <p> In the worst case, exactly n -(n) questions are necessary and sufficient for the majority problem, where, following [6], -(n) is the number of 1-bits in the binary representation of n. This result was first proved by Saks and Werman <ref> [9] </ref>; [1] gave a short, elementary proof. [2] proved that any algorithm that correctly determines the majority must on the average use at least 2n 8n + fi (1) color comparisons, assuming all 2 n distinct colorings of the n elements are equally probable.
Reference: [10] <author> Schmeichel, E. F., S. L. Hakimi, M. Otsuka, and G. </author> <title> Sullivan "A parallel fault identification algorithm," </title> <journal> J. </journal> <note> Algorithms 11 (1990) 231-241. 27 </note>
Reference-contexts: 1 Introduction In system diagnosis, according to <ref> [10] </ref>, . . . in a set U of n units (processors, modules, etc.) at most t are faulty, and an external observer wishes to identify the faulty units.
Reference: [11] <author> Smullyan, R., </author> <title> What Is the Name of This Book?|The Riddle of Dracula and Other Logical Puzzles, </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1978. </year>
Reference-contexts: In such cases, as we will see, the difference between the two sizes constitutes a bound on the plurality between good chips and bad chips in the trees. 3.1 Faulty Chips Always Lie Suppose faulty chips always give wrong answers. This problem is reminiscent of the Smullyan's puzzles <ref> [11] </ref> in which one lands on an island of truth-tellers and liars and must get correct information by asking questions to people of unknown type. The problem of determining a good chip under such conditions is equivalent to the modified majority problem described above.
Reference: [12] <author> Vuillemin, J., </author> <title> "A data structure for manipulating priority queues," </title> <booktitle> Comm. ACM 21 (1978), </booktitle> <pages> 309-315. 28 </pages>
Reference-contexts: The tree structures we use are binomial trees <ref> [12] </ref> (see also [5, Chapter 20]). For convenience, we summarize the necessary details here. A binomial tree of chips B k is an (unordered) tree defined recursively as shown in Figure 3.
References-found: 12

