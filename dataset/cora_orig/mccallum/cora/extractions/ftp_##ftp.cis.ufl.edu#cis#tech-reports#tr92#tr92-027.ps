URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr92/tr92-027.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr92-abstracts.html
Root-URL: http://www.cis.ufl.edu
Title: Analysis of Optimistic Concurrency Control Revisited  
Author: Theodore Johnson 
Date: September 3, 1992  
Abstract: Ryu and Thomasian have analyzed several varieties of optimistic concurrency control under two assumptions: that the characteristics of a transaction remain constant throughout its execution, and that the proportion of committing transactions is fixed (in order to avoid an unrealistic biasing of the transaction mixture). We show how both of these assumptions can be relaxed. First, we allow an aborted transaction to resample its execution time from the distribution that describes the transaction class execution times. Second, we allow transactions to change their class if they are aborted. These assumptions are more appropriate for analyzing special applications of optimistic concurrency control, such as nonblocking data structures and real-time optimistic transaction processing. We use our analyses to show that OCC performance has different characteristics in the new transaction models, and to analyze a simple nonblocking queue algorithm.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K.E. Atkinson. </author> <title> An Introduction to Numerical Analysis. </title> <publisher> John Wiley and Sons, </publisher> <year> 1978. </year>
Reference-contexts: In the VF model, it is possible for the utilization to be greater than 1, so the root finder must use one of the standard nonlinear equation solution methods <ref> [1] </ref>. 2.1.2 Solving The VV Model In the VV transaction model, when a transaction aborts, it leaves the system and a new transaction enters.
Reference: [2] <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Many types of database concurrency control have been proposed, including static locking, two-phase locking, certification, multiversion concurrency control, and optimistic concurrency control <ref> [2] </ref>. In this paper, we analyze optimistic concurrency control (OCC) [14]. Optimistic concurrency control is so named because it makes the optimistic assumption that data conflicts are rare. A transaction accesses data without regard to possible conflicts. If a data conflict does occur, the transaction is aborted and restarted.
Reference: [3] <author> H.A. David. </author> <title> Order Statistics. </title> <publisher> John Wiley, </publisher> <year> 1981. </year>
Reference-contexts: The distributions of the execution times of the successful and unsuccessful operations is given by taking order statistics <ref> [3] </ref>: b s b f where K s and K f are normalizing constants computed by K s = 0 1 Z 1 (1 e fl c t )b c (t)dt 7 If b s c are the expected values of b s c (t) and b f c (t), respectively,
Reference: [4] <author> A. Gottlieb, B. D. Lubachevsky, and L. Rudolph. </author> <title> Coordinating large numbers of processors. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing. IEEE, </booktitle> <year> 1981. </year>
Reference: [5] <author> T. </author> <title> Harder. Observations on optimistic concurrency control schemes. </title> <journal> Inform. Systems, </journal> <volume> 9(2) </volume> <pages> 111-120, </pages> <year> 1984. </year>
Reference-contexts: We also distinguish between silent and broadcast concurrency control. The pseudo-code in Figure 1 is silent optimistic concurrency control: 2 an operation doesn't advertise its commit, and transactions that will abort continue to execute. Alter--natively, a transaction can broadcast its commit, so that conflicting transactions can restart immediately <ref> [22, 5] </ref>. We model the transaction processing system as a closed system in which V transactions each execute one of C transaction types. When a new transaction enters the system, it is a class c transaction with probability f c , P C f c = 1.
Reference: [6] <author> J. Haritsa. </author> <title> Transaction scheduling in firm real-time database systems. </title> <type> Technical Report TR1036, </type> <institution> University of Wisconson-Madison, Dept. of CS, </institution> <year> 1991. </year>
Reference-contexts: We developed these OCC models as a tool for analyzing the performance of non-blocking data structure algorithms [20, 21, 29, 30], and they also have applications in analyzing real time optimistic transaction processing schemes <ref> [6, 9] </ref>. 2 Model Description Data access conflicts in OCC are detected by the use of timestamps. Each data granule, g, (the smallest unit of concurrency control) has an associated timestamp, t (g), which contains the last time that the data granule was written to.
Reference: [7] <author> M. Herlihy. </author> <title> A methodology for implementing highly concurrent data structures. </title> <booktitle> In Proceeding of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 197-206. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Nonblocking data structures avoid the use of locks, and also guarantee that no operation blocks the execution of any other operation for more than a finite number of steps <ref> [7] </ref>. Nonblocking data structures are tolerant of 15 SS SB 5 3.456 4.157 4.019 5.000 15 6.237 9.672 8.049 15.000 25 7.636 13.817 10.140 25.000 Table 4: Comparison of OCC performance, exponential distribution.
Reference: [8] <author> M. Herlihy and J. Wing. </author> <title> Axioms for concurrent objects. </title> <booktitle> In Fourteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 13-26, </pages> <year> 1987. </year>
Reference-contexts: The first transaction class models the fast processors. Its execution time is chosen uniformly randomly in [:8; 1:2], and f 1 = :9. The execution time of the second transaction class, which represents the slow processors, is chosen uniformly randomly in <ref> [8; 12] </ref>, and f 2 = :1.
Reference: [9] <author> J. Huang, J. Stankovic, K. Ramamritham, and D. Towsley. </author> <title> Experimental evaluation of real-time optimistic concurrency control schemes. </title> <booktitle> In Proc. 17th VLDB, </booktitle> <year> 1991. </year>
Reference-contexts: We developed these OCC models as a tool for analyzing the performance of non-blocking data structure algorithms [20, 21, 29, 30], and they also have applications in analyzing real time optimistic transaction processing schemes <ref> [6, 9] </ref>. 2 Model Description Data access conflicts in OCC are detected by the use of timestamps. Each data granule, g, (the smallest unit of concurrency control) has an associated timestamp, t (g), which contains the last time that the data granule was written to.
Reference: [10] <author> T. Johnson. </author> <title> The Performance of Concurrent Data Structure Algorithms. </title> <type> PhD thesis, </type> <institution> NYU Dept. of Computer Science, </institution> <year> 1990. </year> <month> 18 </month>
Reference-contexts: A class c transaction is assumed to have an execution time of fi (V )b c (x), where fi (V ) is the increase in execution time due to resource contention. Factoring out fi (V ) is an example of a resource contention decomposition approximation <ref> [26, 24, 10] </ref>, which lets us focus on the concurrency control mechanism, and which allows the analysis to be applied to different computer models. We will assume that fi (V ) = 1 in the analysis. <p> A nonblocking data structure avoids the use of locks by using optimistic concurrency control instead (relying on the use of the compare-and-swap instruction). As a result, the performance of nonblocking data structures can't be analyzed by using the analytical tools developed for locking data structures <ref> [10, 11, 12] </ref>. This work was motivated by the desire to develop tools for analyzing nonblocking data structures. We developed a simple nonblocking queue that permits an enqueue to occur in parallel with a dequeue operation [20].
Reference: [11] <author> T. Johnson and D. Shasha. </author> <title> A framework for the performance analysis of concurrent B-tree algo-rithms. </title> <booktitle> In ACM SIGACT/SIGMOD/SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 273-287, </pages> <year> 1990. </year>
Reference-contexts: A nonblocking data structure avoids the use of locks by using optimistic concurrency control instead (relying on the use of the compare-and-swap instruction). As a result, the performance of nonblocking data structures can't be analyzed by using the analytical tools developed for locking data structures <ref> [10, 11, 12] </ref>. This work was motivated by the desire to develop tools for analyzing nonblocking data structures. We developed a simple nonblocking queue that permits an enqueue to occur in parallel with a dequeue operation [20].
Reference: [12] <author> T. Johnson and D. Shasha. </author> <title> The performance of concurrent data structure algorithms. </title> <journal> Transactions on Database Systems, </journal> <note> 1992. to appear. </note>
Reference-contexts: A nonblocking data structure avoids the use of locks by using optimistic concurrency control instead (relying on the use of the compare-and-swap instruction). As a result, the performance of nonblocking data structures can't be analyzed by using the analytical tools developed for locking data structures <ref> [10, 11, 12] </ref>. This work was motivated by the desire to develop tools for analyzing nonblocking data structures. We developed a simple nonblocking queue that permits an enqueue to occur in parallel with a dequeue operation [20]. <p> The first transaction class models the fast processors. Its execution time is chosen uniformly randomly in [:8; 1:2], and f 1 = :9. The execution time of the second transaction class, which represents the slow processors, is chosen uniformly randomly in <ref> [8; 12] </ref>, and f 2 = :1.
Reference: [13] <author> L. Kleinrock. </author> <title> Queueing Systems, volume 1. </title> <publisher> John Wiley, </publisher> <address> New York, </address> <year> 1975. </year>
Reference-contexts: mean residence time of te fl c t , and class c transactions have a running time of R c (V ) = 0 te fl c t b c (t)dt = B 1 where B 1 c is the first derivative of the Laplace transform of b c (t) <ref> [13] </ref>.
Reference: [14] <author> H.T. Kung and J.T. Robinson. </author> <title> On optimistic methods for concurrency control. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(2) </volume> <pages> 213-226, </pages> <year> 1981. </year>
Reference-contexts: 1 Introduction Many types of database concurrency control have been proposed, including static locking, two-phase locking, certification, multiversion concurrency control, and optimistic concurrency control [2]. In this paper, we analyze optimistic concurrency control (OCC) <ref> [14] </ref>. Optimistic concurrency control is so named because it makes the optimistic assumption that data conflicts are rare. A transaction accesses data without regard to possible conflicts. If a data conflict does occur, the transaction is aborted and restarted.
Reference: [15] <author> L. Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 190-222, </pages> <year> 1983. </year>
Reference: [16] <author> V. Lanin and D. Shasha. </author> <title> Concurrent set manipulation without locking. </title> <booktitle> In Proceedings of the Seventh ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 211-220, </pages> <year> 1988. </year>
Reference: [17] <author> D. Menasce and T. Nakanishi. </author> <title> Optimistic vs. pessimistic concurrency control mechanisms in database management systems. </title> <journal> Information Systems, </journal> <volume> 7(1) </volume> <pages> 13-27, </pages> <year> 1982. </year>
Reference-contexts: Optimistic concurrency control is so named because it makes the optimistic assumption that data conflicts are rare. A transaction accesses data without regard to possible conflicts. If a data conflict does occur, the transaction is aborted and restarted. Menasce and Nakanishi <ref> [17] </ref> present a Markov chain model of OCC in which aborted transactions leave, then reenter the transaction processing system as new transactions. Morris and Wong [18, 19] note that generating new transactions to replace aborted ones biases the transaction processing system towards executing short fast transactions. <p> We modify the transaction model to examine the bias towards fast transactions that OCC introduces (taking the transaction execution model to that in <ref> [17] </ref>).
Reference: [18] <author> R. Morris and W. Wong. </author> <title> Performance of concurrency control algorithms with non-exclusive access. </title> <booktitle> In Performance '84, </booktitle> <pages> pages 87-101, </pages> <year> 1984. </year>
Reference-contexts: A transaction accesses data without regard to possible conflicts. If a data conflict does occur, the transaction is aborted and restarted. Menasce and Nakanishi [17] present a Markov chain model of OCC in which aborted transactions leave, then reenter the transaction processing system as new transactions. Morris and Wong <ref> [18, 19] </ref> note that generating new transactions to replace aborted ones biases the transaction processing system towards executing short fast transactions. These authors provide an alternative solution method that avoids the bias by requiring that the transaction that replaces the aborted transaction be identical to the aborted transaction.
Reference: [19] <author> R. Morris and W. Wong. </author> <title> Performance analysis of locking and optimistic concurrency control algorithms. Performance Evaluation, </title> <booktitle> 5 </booktitle> <pages> 105-118, </pages> <year> 1985. </year>
Reference-contexts: A transaction accesses data without regard to possible conflicts. If a data conflict does occur, the transaction is aborted and restarted. Menasce and Nakanishi [17] present a Markov chain model of OCC in which aborted transactions leave, then reenter the transaction processing system as new transactions. Morris and Wong <ref> [18, 19] </ref> note that generating new transactions to replace aborted ones biases the transaction processing system towards executing short fast transactions. These authors provide an alternative solution method that avoids the bias by requiring that the transaction that replaces the aborted transaction be identical to the aborted transaction.
Reference: [20] <author> S. Prakash, Y.H. Lee, and T. Johnson. </author> <title> A non-blocking algorithm for shared queues using compare-and-swap. </title> <booktitle> In Proc. Int'l Conf. on Parallel Processing, </booktitle> <pages> pages II68-II75, </pages> <year> 1991. </year>
Reference-contexts: We modify the transaction model to examine the bias towards fast transactions that OCC introduces (taking the transaction execution model to that in [17]). We developed these OCC models as a tool for analyzing the performance of non-blocking data structure algorithms <ref> [20, 21, 29, 30] </ref>, and they also have applications in analyzing real time optimistic transaction processing schemes [6, 9]. 2 Model Description Data access conflicts in OCC are detected by the use of timestamps. <p> This work was motivated by the desire to develop tools for analyzing nonblocking data structures. We developed a simple nonblocking queue that permits an enqueue to occur in parallel with a dequeue operation <ref> [20] </ref>. We wrote a detailed simulation to compare the performance of the nonblocking queue to a locking queue. We modeled the processors in the parallel computer as being either constant speed or varying speed. In the constant speed model, the processors are divided into fast and slow processors.
Reference: [21] <author> S. Prakash, Y.H. Lee, and T. Johnson. </author> <title> Non-blocking algorithms for concurrent data structures. </title> <type> Technical report, </type> <institution> University of Florida Dept. of CIS, </institution> <year> 1991. </year> <note> Available at cis.ufl.edu:cis/tech-reports/tr91/tr91.002.ps.Z. </note>
Reference-contexts: We modify the transaction model to examine the bias towards fast transactions that OCC introduces (taking the transaction execution model to that in [17]). We developed these OCC models as a tool for analyzing the performance of non-blocking data structure algorithms <ref> [20, 21, 29, 30] </ref>, and they also have applications in analyzing real time optimistic transaction processing schemes [6, 9]. 2 Model Description Data access conflicts in OCC are detected by the use of timestamps. <p> Our simulation results showed the surprising result that nonblocking queue has worse performance than the blocking queue in the constant speed model, but better performance in the varying speed model <ref> [21] </ref>. In order to examine this phenomenon more closely, we analyze the queue using the V/F and the V/V models. <p> These running times are shown in figure 3. The throughput of the variable speed model increases with increasing V , and is considerably greater than that of the locking queue. These model predictions are in agreement with our simulation results <ref> [21] </ref>. 6 Conclusion In this paper, we have extended the OCC performance model due to Ryu and Thomasian (which we call the FF model) to handle transactions that resample their execution time if they abort (VF transaction model), and also to handle transactions that change their transaction class (VV transaction model).
Reference: [22] <author> J.T. Robinson. </author> <title> Experiments with transaction processing on a multiprocessor. </title> <type> Technical Report RC9725, </type> <institution> IBM, Yorktown Heights, </institution> <year> 1982. </year> <month> 19 </month>
Reference-contexts: We also distinguish between silent and broadcast concurrency control. The pseudo-code in Figure 1 is silent optimistic concurrency control: 2 an operation doesn't advertise its commit, and transactions that will abort continue to execute. Alter--natively, a transaction can broadcast its commit, so that conflicting transactions can restart immediately <ref> [22, 5] </ref>. We model the transaction processing system as a closed system in which V transactions each execute one of C transaction types. When a new transaction enters the system, it is a class c transaction with probability f c , P C f c = 1.
Reference: [23] <author> S.M. Ross. </author> <title> Stochastic Processes. </title> <publisher> John Wiley, </publisher> <year> 1983. </year>
Reference-contexts: Thus, the observation period would take P C i=1 M f i b i seconds, during which a class k transaction would be executed for M f k b k seconds. By the theory of alternating renewal processes <ref> [23] </ref>, we have S k = f k b k = i=1 If process is executing a class k transaction, it will finish at rate 1=b k .
Reference: [24] <author> I.K. Ryu and A. Thomasian. </author> <title> Performance analysis of centralized database with optimistic concur-rency control. Performance Evaluation, </title> <booktitle> 7 </booktitle> <pages> 195-211, </pages> <year> 1987. </year>
Reference-contexts: These authors provide an alternative solution method that avoids the bias by requiring that the transaction that replaces the aborted transaction be identical to the aborted transaction. Ryu and Thomasian <ref> [24] </ref> extend this model of OCC to permit a wide variety of execution time distributions and a variety of OCC execution models. <p> T 's local workspace access time (g)=Global time validate (T) for each g 2 R (T ) if access time (g)&lt;t (g) abort (T) for every g 2 W (T ) t (g)=Global time commit (T) In this paper, we extend the simple but flexible model of Ryu and Thomasian <ref> [24] </ref> to handle additional transaction processing models. We modify the transaction model to examine the bias towards fast transactions that OCC introduces (taking the transaction execution model to that in [17]). <p> A class c transaction is assumed to have an execution time of fi (V )b c (x), where fi (V ) is the increase in execution time due to resource contention. Factoring out fi (V ) is an example of a resource contention decomposition approximation <ref> [26, 24, 10] </ref>, which lets us focus on the concurrency control mechanism, and which allows the analysis to be applied to different computer models. We will assume that fi (V ) = 1 in the analysis. <p> We denote by (k; c) the probability that a committing class k transaction conflicts with an executing class c transaction. We model the stochastic process in which committing transactions conflict with an executing transaction as a Poisson process. Ryu and Thomasian <ref> [24] </ref> show that this assumption, which makes the analysis tractable, leads to accurate model predictions under a wide variety of conditions. We differentiate between three models depending on the actions that occur when a transaction aborts. In [24], a transaction samples its execution time when it first enters the system. <p> Ryu and Thomasian <ref> [24] </ref> show that this assumption, which makes the analysis tractable, leads to accurate model predictions under a wide variety of conditions. We differentiate between three models depending on the actions that occur when a transaction aborts. In [24], a transaction samples its execution time when it first enters the system. If the transaction is aborted, it is executed again with the same execution time as the first execution time. We call this transaction model the fixed time/fixed class model, or the FF model 1 . <p> There are some situations in which an aborted transaction simply exits the system and is not re-executed (for example, the transactions might be sensor data reports in a real time data monitoring 1 Most of the results that we present for the FF model have been taken from <ref> [24] </ref>. 3 system). <p> In the silent/static scheme, transactions access their entire data sets when they start their executions, and detect conflicts when they attempt to commit. 3.1.1 Fixed Time/Fixed Class In <ref> [24] </ref>, if a transaction executes for t seconds, then aborts, it will execute for t seconds when it restarts. If an operation requires t seconds, the probability that it will be commit is e flt , since we assume that conflicts form a Poisson process.
Reference: [25] <author> J. Stone. </author> <title> A simple and correct shared-queue algorithm using compare-and-swap. </title> <type> Technical Report RC 15675, </type> <institution> IBM TJ Watson Research Center, </institution> <year> 1990. </year>
Reference: [26] <author> Y.C. Tay, R. Suri, and N. Goodman. </author> <title> Locking performance in centralized databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 10(4) </volume> <pages> 415-462, </pages> <year> 1985. </year>
Reference-contexts: A class c transaction is assumed to have an execution time of fi (V )b c (x), where fi (V ) is the increase in execution time due to resource contention. Factoring out fi (V ) is an example of a resource contention decomposition approximation <ref> [26, 24, 10] </ref>, which lets us focus on the concurrency control mechanism, and which allows the analysis to be applied to different computer models. We will assume that fi (V ) = 1 in the analysis.
Reference: [27] <author> R. Treiber. </author> <title> Systems programming: Coping with parallelism. </title> <type> Technical Report RJ 5118, </type> <institution> IBM Almaden Research Center, </institution> <year> 1986. </year>
Reference: [28] <author> J. Turek. </author> <title> Resilient Computation in the Presence of Slowdowns. </title> <type> PhD thesis, </type> <institution> NYU Dept. of Computer Science, </institution> <year> 1991. </year>
Reference: [29] <author> J.D. Valois. </author> <title> Analysis of a lock-free queue. </title> <note> Submitted for publication, </note> <year> 1992. </year>
Reference-contexts: We modify the transaction model to examine the bias towards fast transactions that OCC introduces (taking the transaction execution model to that in [17]). We developed these OCC models as a tool for analyzing the performance of non-blocking data structure algorithms <ref> [20, 21, 29, 30] </ref>, and they also have applications in analyzing real time optimistic transaction processing schemes [6, 9]. 2 Model Description Data access conflicts in OCC are detected by the use of timestamps.
Reference: [30] <author> J.D. Valois. </author> <title> Concurrent dictionaries without locks. </title> <note> Submitted for publication, </note> <year> 1992. </year>
Reference-contexts: We modify the transaction model to examine the bias towards fast transactions that OCC introduces (taking the transaction execution model to that in [17]). We developed these OCC models as a tool for analyzing the performance of non-blocking data structure algorithms <ref> [20, 21, 29, 30] </ref>, and they also have applications in analyzing real time optimistic transaction processing schemes [6, 9]. 2 Model Description Data access conflicts in OCC are detected by the use of timestamps.
Reference: [31] <author> P.S. Yu, D.M. Dias, and S.S. Lavenberg. </author> <title> On modeling database concurrency control. </title> <type> Technical Report RC 15368, </type> <institution> IBM Research Division, </institution> <year> 1990. </year>
Reference-contexts: Ryu and Thomasian [24] extend this model of OCC to permit a wide variety of execution time distributions and a variety of OCC execution models. Yu et al. <ref> [32, 31] </ref> develop approximate models of OCC and locking concurrency control to evaluate their performance in transaction processing systems. 1 read (g,Ta) read g into T 's local workspace access time (g)=Global time validate (T) for each g 2 R (T ) if access time (g)&lt;t (g) abort (T) for every
Reference: [32] <author> P.S. Yu, H.U Heiss, </author> <title> and D.M Dias. Modeling and analysis of a time-stamp history based certification protocol for concurrency control. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 3(4) </volume> <pages> 525-537, </pages> <year> 1991. </year> <title> varying speed model 21 </title>
Reference-contexts: Ryu and Thomasian [24] extend this model of OCC to permit a wide variety of execution time distributions and a variety of OCC execution models. Yu et al. <ref> [32, 31] </ref> develop approximate models of OCC and locking concurrency control to evaluate their performance in transaction processing systems. 1 read (g,Ta) read g into T 's local workspace access time (g)=Global time validate (T) for each g 2 R (T ) if access time (g)&lt;t (g) abort (T) for every
References-found: 32

