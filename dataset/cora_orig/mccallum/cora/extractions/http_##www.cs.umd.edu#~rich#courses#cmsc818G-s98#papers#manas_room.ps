URL: http://www.cs.umd.edu/~rich/courses/cmsc818G-s98/papers/manas_room.ps
Refering-URL: http://www.cs.umd.edu/~rich/courses/cmsc818G-s98/resources.html
Root-URL: 
Title: Guidelines for Automated Implementation of Executable Object Oriented Models for Real-Time Embedded Control Systems  
Author: M. Saksena P. Freedman P. Rodziewicz 
Date: December 1997 1  
Note: Appeared in Proceedings, IEEE Real-Time Systems Symposium,  
Abstract: In this paper we present our experiences in applying real-time scheduling theory to embedded control systems designed using ROOM (Real-time Object Oriented Modeling) methodology. ROOM has originated from the telecommunications community, and has been successfully applied to many commercial systems through the supporting case tool ObjecTime. It is particularly suitable for modeling reactive real-time behavior. Furthermore, it provides many other advantages through the use of object-orientation, and the use of executable models from which code may be generated quickly and efficiently. Since many real-time embedded control systems have significant reactive, event-driven, behavior, it is attractive to use ROOM methodology to develop such systems. However, the ROOM methodology does not provide tools to specify and analyze the temporal behavior as is required for the hard real-time components of embedded systems, and for which the real-time scheduling theory provides an analytical basis. In this paper, we show how real-time scheduling theory may be applied to ROOM models using a cruise control example to illustrate. The biggest challenge comes from minimizing the adverse effects of priority inversions. Our results are very encouraging, and we show that not only is it possible to apply real-time scheduling theory, but that it can be done very efficiently provided certain guidelines are followed in the design and implementation of the ROOM model. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Objectime microRTS system description. ObjecTime, Kanata, Canada. </institution>
Reference-contexts: The ObjecTime toolset (http://www.objectime.com) is a CASE tool that provides a fully integrated development environment to support the ROOM methodology, with features such as graphical and textual editing for actor construction and C++ code generation from the model [20]. The ObjecTime toolset includes a micro run-time system microRTS <ref> [1] </ref>, which is linked with the application code to provide a standalone executable that may be run on either a workstation (emulation) environment, or on a target environment with an underlying real-time operating system such as VxWorks, QNX, pSOS, and VRTX.
Reference: [2] <institution> Qnx microkernel product information. </institution> <note> Available at http://www.qnx.com. </note>
Reference-contexts: However, recent performance numbers suggest that such system calls can be executed very cheaply, with execution times as low as a 10 microseconds or less <ref> [16, 2] </ref>. 4.2. Blocking due to Message Passing The second source of blocking comes from priority inversions arising from access to shared data structures. In the case of ROOM models, actors communicate via message passing and there is no provision for sharing data structures.
Reference: [3] <author> M. Awad, J. kuusela, and J. Ziegler. </author> <title> Object-Oriented Technology for Real-Time Systems: A Practical Approach using OMT and Fusion. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: Indeed, we observe that the telecommunications community has widely embraced such new generation CASE tool support e.g., ROOM [20], OCTOPUS <ref> [3] </ref>. We believe that such acceptance is due, in part, to the sheer size/complexity of new products (e.g. digital switches), and due to the fundamentally reactive or event-driven nature of such computerized products 1 . In contrast, the embedded control systems community continues to be much more conservative. <p> Automobile Cruise Control: An Example Real-Time System We use a variant of an automobile cruise control system, presented in [8], to illustrate the concepts developed in this paper. Automobile cruise control is a well studied example to illustrate real-time design methods, including Octopus <ref> [3] </ref>, ADARTS and CODARTS [10]. In order to keep the example manageable, we have selected only a subset of the functionality.
Reference: [4] <author> H. Ben-Abdallah and S. Leue. </author> <title> Expressing and analyzing timing constraints in message sequence chart specifications. </title> <type> Technical Report TR-97-04, </type> <institution> University of Waterloo, Dept. of Electrical and Computer Engineering, </institution> <year> 1997. </year>
Reference-contexts: Transactions and Timing Constraints ROOM provides the notion of scenarios to describe system behavior. A scenario may be pictorially depicted using message sequence charts [13], and additional annotations may be used to indicate timing constraints <ref> [4] </ref>. However, ROOM itself does not provide any mechanisms to specify and enforce timing constraints. As scenarios correspond to broad system descriptions, they are not particularly appropriate for specifying timing constraints.
Reference: [5] <author> M. </author> <title> Boasson. </title> <journal> Control systems software. IEEE Transactions on Automatic Control, </journal> <volume> 38(7) </volume> <pages> 1094-1106, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: The increasingly complexity and the sophisticated demands of such systems in terms of safety, reliability, and performance <ref> [5] </ref> requires the use of rigorous development methodologies and CASE tools for reliable software development, and analytical techniques to analyze and predict temporal (real-time) behavior [14].
Reference: [6] <author> A. Burns and A. Wellings. </author> <title> Real-time Systems: Specification, Verification and Analysis, chapter Advanced Fixed Priority Scheduling, </title> <address> pages 32-65. </address> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: Priority Inheritance and Priority Ceiling protocols [22] can be used to bound the blocking time associated with such priority inversion. We propose the use of a simpler Immediate Priority Ceiling Inheritance protocol <ref> [6] </ref>, and show that using this protocol, such blocking may be greatly reduced and even totally eliminated. The protocol works as follows: let the ceiling priority of a message queue be the priority of the maximum priority task that can access it. <p> Schedulability analysis In this section, we present our approach to schedulability analysis of ROOM models. Once blocking times have been analyzed, calculating the response time for transactions can be done according to real-time scheduling theory. We use the strategy shown in <ref> [24, 6] </ref>, based on the following basic equation to calculate the response time of a task: R i = t j 2hp (i) R i e fl C j ) + C i + B i where, R i , C i , and B i are the response time, execution <p> The response time analysis becomes more complicated when there are multiple tasks in a transaction (as is the case for us), or when deadlines exceed activation period. The reader is referred to <ref> [6, 24] </ref> for more details. 5.1. Cruise Control Example: Revisited We now return to the schedulability analysis for cruise control example presented earlier.
Reference: [7] <author> B. Douglass and G. Cernosek. </author> <title> Unified modeling language for real-time systems design. </title>
Reference-contexts: While our work is done in the context of a specific methodolgy (i.e., ROOM), we believe that the results and the observations are more generally applicable. In particular, the results developed here are equally applicable to Unified Modeling Language (UML) <ref> [7] </ref>, an object-oriented modeling language being developed by using concepts from several object-oriented development methodologies (OMT, Booch, and OOSE), with statecharts at its heart. The remainder of the paper is organized as follows. In Section 2 we present the key aspects of the ROOM modeling technique.
Reference: [8] <author> D. Gaudreau and P. Freedman. </author> <title> Temporal analysis and object-oriented real-time software development: a case study with room/objectime. </title> <booktitle> In Proceedings, IEEE Real-Time Technology and Applications Symposium, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: Such transactions would then have the same activation period, but may have different deadlines. 3. Automobile Cruise Control: An Example Real-Time System We use a variant of an automobile cruise control system, presented in <ref> [8] </ref>, to illustrate the concepts developed in this paper. Automobile cruise control is a well studied example to illustrate real-time design methods, including Octopus [3], ADARTS and CODARTS [10]. In order to keep the example manageable, we have selected only a subset of the functionality.
Reference: [9] <author> R. Gerber, S. Hong, D. Kang, and M. Saksena. </author> <title> End-to-End Design of Real-Time Systems, chapter 10. </title> <publisher> John Wiley & Sons, </publisher> <year> 1996. </year> <title> In Formal Methods in Real-Time Computing, </title> <editor> edited by D. Mandrioli and C. </editor> <publisher> Heitmeyer. </publisher>
Reference-contexts: In this paper, we focused on relatively simple timing constraints, although, we believe that the analysis can be easily extended to include more sophisticated timing requirements. We also feel that the recent results on integration of real-time scheduling with design of such control systems <ref> [9, 18] </ref> can also be used and applied. Also, we restricted attention to a single processor system. The applicability of ROOM to distributed systems would require that message passing in ROOM be implemented using a real-time network. We found that the biggest difficulty lies in assigning appropriate message/event priorities.
Reference: [10] <author> H. Gomaa. </author> <title> Software Design Methods for Concurrent and Real-Time Systems. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: Automobile Cruise Control: An Example Real-Time System We use a variant of an automobile cruise control system, presented in [8], to illustrate the concepts developed in this paper. Automobile cruise control is a well studied example to illustrate real-time design methods, including Octopus [3], ADARTS and CODARTS <ref> [10] </ref>. In order to keep the example manageable, we have selected only a subset of the functionality.
Reference: [11] <author> D. Harel. Statecharts: </author> <title> A visual approach to complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1987. </year>
Reference-contexts: A message is a tuple consisting of a signal name, a message body (i.e., data associated with the message), and an associated message priority. The behavior of an actor is represented by an extended state machine called a ROOMchart, based on the statechart formalism <ref> [11] </ref>. Each actor remains dormant until an event occurs, i.e., when a message is received by an actor. Incoming messages trigger transitions associated with the actor's finite state machine. Actions may be associated with transitions, as well as entry and exit points of a state.
Reference: [12] <author> D. Harel and E. Gery. </author> <title> Executable object modelling with stat-echarts. </title> <booktitle> In Proceedings of the ACM/IEEE 18th International Conference on Software Engineering, </booktitle> <year> 1996. </year>
Reference-contexts: It is not surprising then that there is increasing interest in new generation methodologies and tools which makes possible the modeling and analysis of computing systems in terms of executable models <ref> [12] </ref>. One such product is the modeling language ROOM (Real-Time Object Oriented Modeling) [20] and its CASE tool, ObjecTime (Ob-jecTime Ltd., Kanata, Ontario, Canada) which grew out of more than ten years of internal development at Bell-Northern Research.
Reference: [13] <author> ITU-T. </author> <title> Message sequence charts standard (z.120) reference. International Telecommunication Union (ITU-T), </title> <year> 1994. </year>
Reference-contexts: However, a thread may be preempted by other threads depending on thread priorities and the scheduling of threads by the underlying operating system. 2.2. Transactions and Timing Constraints ROOM provides the notion of scenarios to describe system behavior. A scenario may be pictorially depicted using message sequence charts <ref> [13] </ref>, and additional annotations may be used to indicate timing constraints [4]. However, ROOM itself does not provide any mechanisms to specify and enforce timing constraints. As scenarios correspond to broad system descriptions, they are not particularly appropriate for specifying timing constraints.
Reference: [14] <author> D. Johnson. </author> <title> The system engineer and the software crisis. </title> <booktitle> ACM Sigsoft, </booktitle> <volume> 21(7), </volume> <month> March </month> <year> 1996. </year>
Reference-contexts: The increasingly complexity and the sophisticated demands of such systems in terms of safety, reliability, and performance [5] requires the use of rigorous development methodologies and CASE tools for reliable software development, and analytical techniques to analyze and predict temporal (real-time) behavior <ref> [14] </ref>. It is not surprising then that there is increasing interest in new generation methodologies and tools which makes possible the modeling and analysis of computing systems in terms of executable models [12].
Reference: [15] <author> M. H. Klein, T. Ralya, B. Pollak, R. Obenza, and M. G. Harbour. </author> <title> A Practitioner's Handbook for Real-Time Analysis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: In contrast, the embedded control systems community continues to be much more conservative. Once again, this is due, in part, to the smaller size/complexity of new products and to the emphasis on time-driven behavior. And in this time-driven context, techniques such as Real-time scheduling theory <ref> [15] </ref> have evolved to provide guidance, at design time, about time-driven behavior of real-time systems, such as that exhibited by periodic computations associated 1 In a recent article entitled The Challenges of Real-Time Software Design [21], Selic and Ward use the words event-driven and time-driven to describe two basic `styles' of <p> And in RTAS96, we described how ROOM models could be subjected to Generalized Rate Monotonic Analysis (GRMA) <ref> [15] </ref>, using a simplified cruise control example [23]. The intent here was to promote GRMA to provide guidance, at design time, to the software development team.
Reference: [16] <author> L. McVoy and C. Staelin. lmbench: </author> <title> Portable tools for performance analysis. </title> <booktitle> In Proceedings, Winter 1996 Usenix, </booktitle> <month> jan </month> <year> 1996. </year>
Reference-contexts: However, recent performance numbers suggest that such system calls can be executed very cheaply, with execution times as low as a 10 microseconds or less <ref> [16, 2] </ref>. 4.2. Blocking due to Message Passing The second source of blocking comes from priority inversions arising from access to shared data structures. In the case of ROOM models, actors communicate via message passing and there is no provision for sharing data structures.
Reference: [17] <author> C. Puchol and A. K. Mok. </author> <title> The integration of control and dataflow structures in distributed hard real-time systems. </title> <booktitle> In Proceedings, International Workshop on Parallel and Distributed Real-Time Systems, </booktitle> <year> 1994. </year>
Reference-contexts: However, the integration of control structure associated with the reactive behavior and the dataflow structure associated with the time-driven behavior has not received much attention <ref> [17] </ref>. With this observation in mind, work began at CRIM in 1995-96 to investigate the suitability of ROOM/ObjecTime and its software development automation for the development of embedded control systems, in cooperation with Bombardier's Transportation Equipment Group, one of North America's leading mass transit companies.
Reference: [18] <author> M. Saksena and S. Hong. </author> <title> Resource conscious design of distributed real-time systems: An end-to-end approach. </title> <booktitle> In Proceedings, IEEE International Conference on Engineering of Complex Computer Systems, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: In this paper, we focused on relatively simple timing constraints, although, we believe that the analysis can be easily extended to include more sophisticated timing requirements. We also feel that the recent results on integration of real-time scheduling with design of such control systems <ref> [9, 18] </ref> can also be used and applied. Also, we restricted attention to a single processor system. The applicability of ROOM to distributed systems would require that message passing in ROOM be implemented using a real-time network. We found that the biggest difficulty lies in assigning appropriate message/event priorities.
Reference: [19] <author> B. Selic. </author> <title> Periodic tasks in ROOM. </title> <booktitle> In Proceedings, Workshop on Object-Oriented Real-Time Systems, ACM OOPSLA, </booktitle> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: The communications service provides the services to establish and manage connections between ROOM actors. The timing service may be used to set and cancel timers, both one-shot and periodic <ref> [19] </ref>. The ROOM virtual machine is also responsible for interfacing to other external (non-ROOM) environments such as specialized hardware or other software components and systems. 2.1. <p> In particular, we will use the timing service provided by the ROOM virtual machine to trigger periodic activities <ref> [19] </ref>. Also, we will assume that the ROOM virtual machine will handle device interrupts and send them as messages to the hardware wrappers. ture The behavior of most of the actors is relatively simple. The brake, accelerator, and the lever actors have only a single state.
Reference: [20] <author> B. Selic, G. Gullekson, and P. T. Ward. </author> <title> Real-Time Object-Oriented Modeling. </title> <publisher> John Wiley and Sons, </publisher> <year> 1994. </year>
Reference-contexts: It is not surprising then that there is increasing interest in new generation methodologies and tools which makes possible the modeling and analysis of computing systems in terms of executable models [12]. One such product is the modeling language ROOM (Real-Time Object Oriented Modeling) <ref> [20] </ref> and its CASE tool, ObjecTime (Ob-jecTime Ltd., Kanata, Ontario, Canada) which grew out of more than ten years of internal development at Bell-Northern Research. <p> Indeed, we observe that the telecommunications community has widely embraced such new generation CASE tool support e.g., ROOM <ref> [20] </ref>, OCTOPUS [3]. We believe that such acceptance is due, in part, to the sheer size/complexity of new products (e.g. digital switches), and due to the fundamentally reactive or event-driven nature of such computerized products 1 . In contrast, the embedded control systems community continues to be much more conservative. <p> The ObjecTime toolset (http://www.objectime.com) is a CASE tool that provides a fully integrated development environment to support the ROOM methodology, with features such as graphical and textual editing for actor construction and C++ code generation from the model <ref> [20] </ref>.
Reference: [21] <author> B. Selic and P. Ward. </author> <title> The challenges of real-time software design. </title> <booktitle> Embedded Systems Programming, </booktitle> <pages> pages 66-82, </pages> <month> Oc-tober </month> <year> 1996. </year>
Reference-contexts: And in this time-driven context, techniques such as Real-time scheduling theory [15] have evolved to provide guidance, at design time, about time-driven behavior of real-time systems, such as that exhibited by periodic computations associated 1 In a recent article entitled The Challenges of Real-Time Software Design <ref> [21] </ref>, Selic and Ward use the words event-driven and time-driven to describe two basic `styles' of real-time software.
Reference: [22] <author> L. Sha, R. Rajkumar, and J. Lehoczky. </author> <title> Priority inheritance protocols: An approach to real-time synchronization. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39 </volume> <pages> 1175-1185, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: However, the message passing itself requires the sharing of message queues, and therefore, the processing due to sending and receiving messages can incur blocking. Priority Inheritance and Priority Ceiling protocols <ref> [22] </ref> can be used to bound the blocking time associated with such priority inversion. We propose the use of a simpler Immediate Priority Ceiling Inheritance protocol [6], and show that using this protocol, such blocking may be greatly reduced and even totally eliminated.
Reference: [23] <author> M. Shaw. </author> <title> Comparing architectural design styles. </title> <journal> IEEE Software, </journal> <pages> pages 27-41, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: And in RTAS96, we described how ROOM models could be subjected to Generalized Rate Monotonic Analysis (GRMA) [15], using a simplified cruise control example <ref> [23] </ref>. The intent here was to promote GRMA to provide guidance, at design time, to the software development team. At the same time, a sister project began in 1996, jointly funded by Bombardier and the Canadian government to include the University of Sherbrooke and Concor-dia University.
Reference: [24] <author> K. Tindell, A. Burns, and A. Wellings. </author> <title> An extendible approach for analysing fixed priority hard real-time tasks. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 6(2) </volume> <pages> 133-152, </pages> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: Schedulability analysis In this section, we present our approach to schedulability analysis of ROOM models. Once blocking times have been analyzed, calculating the response time for transactions can be done according to real-time scheduling theory. We use the strategy shown in <ref> [24, 6] </ref>, based on the following basic equation to calculate the response time of a task: R i = t j 2hp (i) R i e fl C j ) + C i + B i where, R i , C i , and B i are the response time, execution <p> The response time analysis becomes more complicated when there are multiple tasks in a transaction (as is the case for us), or when deadlines exceed activation period. The reader is referred to <ref> [6, 24] </ref> for more details. 5.1. Cruise Control Example: Revisited We now return to the schedulability analysis for cruise control example presented earlier.
References-found: 24

