URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3415/3415.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Title: PARALLEL I/O USING A DISTRIBUTED DISK CLUSTER: AN EXERCISE IN TAILORED PROTOTYPING  
Author: Charles Falkenberg James M. Purtilo 
Keyword: INDEX TERMS: Software prototyping, parallel file systems, software risk analysis, distributed systems, database management systems, I/O bottleneck.  
Note: With oversight by Office of Naval Research, this research was supported by ARPA in conjunction with the Prototech project.  
Address: College Park, MD 20742  
Affiliation: Computer Science Department and Institute for Advanced Computer Studies University of Maryland  
Abstract: Tailored prototyping refers to an emerging process for prototyping software applications, emphasizing a disciplined experimental approach in order for developers to obtain an understanding of system characteristics before committing to costly design decisions. In our approach, the design of software constituting prototype apparatus is driven by experimental hypotheses concerning risk, rather than an application's functional requirements. This paper describes the principles behind tailored prototyping, then illustrates them in concrete terms by describing their application in a pilot project. The pilot used in our illustration is a parallel I/O service | a mechanism designed to deliver pages, in parallel, from a cluster of distributed disks. The performance results show that this parallel I/O system can, in certain circumstances, deliver higher page throughput from multiple remote disks, than with a single local disk. The pilot project exemplifies our prototyping method which is applicable to a wide variety software prototyping activities. 
Abstract-found: 1
Intro-found: 1
Reference: [CPP94] <author> C. Chen, A. Porter, and J. Purtilo. </author> <title> "Tool support for tailored software prototyping". </title> <booktitle> In Third Symposium on Assessment of Quality Software Development Tools, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Many scenarios do indeed have much in common for certain of the steps, and hence we have found some tools useful for assisting the developer <ref> [CPP94] </ref>; and because of the extent of planning, and also potential for leveraging prior experiences once captured, it is easy to anticipate how in the future emerging decision 3 support systems may support broad classes of applications employing our process.
Reference: [FHK93] <author> C. Falkenberg, P. Hagger, and S. Kelley. </author> <title> "A server of distributed disk pages using a configurable software bus". </title> <type> Technical Report UMIACS-TR-93-47, </type> <institution> Institute for Advanced Computer Studies at the University of Maryland, College Park, MD, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: The API included the standard operations on UNIX files and a call to initiate the communication with the cluster of servers as well as a call to terminate the system. The manual for the complete API is provided in <ref> [FHK93] </ref>. The local and remote interfaces were modeled after the Pagefile API which resulted in corresponding accessor in the remote and local interfaces for each accessor in the API. the PFEI, links to the client side of the prototype.
Reference: [LSHZ93] <author> H. Lichter, M. Schneider-Hufschmidt, and H. Zullighoven. </author> <title> "Prototyping in industrial software projects -Bridging the gap between theory and practice-". </title> <booktitle> In IEEE Proceedings of the International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1993. </year>
Reference: [PLC91] <author> J. Purtilo, A Larson, and J Clark. </author> <title> "A methodology for prototyping-in-the-large". </title> <booktitle> In IEEE Proceedings of the International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1991. </year>
Reference: [Pur94] <author> J. Purtilo. </author> <title> "The Polylith software bus". </title> <journal> ACM Transaction on Programming Languages, </journal> <volume> 16(1) </volume> <pages> 151-174, </pages> <month> January </month> <year> 1994. </year> <month> 22 </month>
Reference: [RES93] <author> N. Roussopoulos, N. Economou, and A. Stamenas. "ADMS: </author> <title> A testbed for incremental access methods". </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5(5) </volume> <pages> 762-774, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: The larger design effort was the development of the ADMS database management system at the University of Maryland. The design and development of ADMS is a long term research project to build a comprehensive database management system based on the the concept of incremental updates <ref> [RES93] </ref>. Like any data intensive application, the developers of ADMS seek to minimize the I/O bottleneck. The critical decision was whether or not to develop a parallel file server to deliver pages to an ADMS client. <p> A proposed enhancement to ADMS to implement parallel I/O, provided an opportunity to apply the tailored methodology, explore the value of prototyping, and assist in refining the design of the target system. 3 DATABASE RESEARCH USING ADMS ADMS is a database management system (DBMS), developed at the University of Maryland <ref> [RES93] </ref>. As a research tool, ADMS was designed to explore incremental access methods for caching query results and updating indexes. In addition, ADMS has been used to research database issues relevant to spatial data management and query execution probability.
Reference: [Rou92] <author> N. Roussopoulos. </author> <title> The tower of pizzas. Internal Memo, </title> <year> 1992. </year>
Reference-contexts: To achieve this, the disk servers are to be in the main enclosure of a workstation. This includes the CPU, memory and operating system but no keyboard or monitor. A stack of these enclosures will make up the cluster of disk servers <ref> [Rou92] </ref>. The prototype needed to provide a programming interface which could be used by an application program. The interface to a Pagefile closely resembles the UNIX file interface with a few distinct differences. First the granularity of an I/O request is pages, not bytes.

References-found: 7

