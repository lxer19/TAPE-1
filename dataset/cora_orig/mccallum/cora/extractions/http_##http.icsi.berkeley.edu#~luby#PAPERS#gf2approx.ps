URL: http://http.icsi.berkeley.edu/~luby/PAPERS/gf2approx.ps
Refering-URL: http://http.icsi.berkeley.edu/~luby/monte.html
Root-URL: http://http.icsi.berkeley.edu
Title: Approximating the Number of Zeroes of a GF[2] Polynomial  
Author: Marek Karpinski Michael Luby 
Abstract: We develop a probabilistic polynomial time algorithm which on input a polynomial g(x 1 ; : : : ; x n ) over GF[2], * and ffi, outputs an approximation to the number of zeroes of g with relative error at most * with probability at least 1 ffi. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Adleman, L.M., Huang, M.A., </author> <title> "Computing the Number of Rational Points on the Jacobian of a Curve", </title> <type> manuscript, </type> <year> 1987. </year>
Reference-contexts: some special cases of counting the number of points on an algebraic variety, like counting the order of an elliptic curve over finite fields or the number of rational points on the Jacobian of a curve of genus two over finite fields, there are known polynomial time algorithms ([14, Schoof], <ref> [1, Adleman, Huang] </ref>, [2, Adleman, Huang]). However, in most cases there are no known efficient algorithms for counting exactly the number of points. Furthermore, for some cases the exact counting problem is known to be #P-complete.
Reference: [2] <author> Adleman, L.M., Huang, M.A., </author> <title> "Recognizing Primes in Random Polynomial Time", </title> <booktitle> Proc. 19 th ACM STOC (1987), </booktitle> <pages> pp. 462-469. </pages>
Reference-contexts: of counting the number of points on an algebraic variety, like counting the order of an elliptic curve over finite fields or the number of rational points on the Jacobian of a curve of genus two over finite fields, there are known polynomial time algorithms ([14, Schoof], [1, Adleman, Huang], <ref> [2, Adleman, Huang] </ref>). However, in most cases there are no known efficient algorithms for counting exactly the number of points. Furthermore, for some cases the exact counting problem is known to be #P-complete. <p> counting is hard, the question arises: Is it possible to produce a reasonable estimate of the number of solutions to a general algebraic circuit over GF [q] in polynomial time? In this paper, we consider the special case of this problem when the input is a multivariate equation over GF <ref> [2] </ref>. Let g (x 1 ; : : : ; x n ) be a polynomial in variables x 1 ; : : :; x n over GF [2] of the form t 1 (x 1 ; : : : ; x n ) t 2 (x 1 ; : : <p> polynomial time? In this paper, we consider the special case of this problem when the input is a multivariate equation over GF <ref> [2] </ref>. Let g (x 1 ; : : : ; x n ) be a polynomial in variables x 1 ; : : :; x n over GF [2] of the form t 1 (x 1 ; : : : ; x n ) t 2 (x 1 ; : : : ; x n ) t m (x 1 ; : : : ; x n ); fl Department of Computer Science, University of Bonn, and International Computer <p> be the set of assignments to x 1 ; : : : ; x n that are zeroes of g. 2 The problem is to compute jGj given a description of g. [5, Ehrenfeucht, Karpinski] show that computing jGj exactly is #P-complete, even when restricted to cubic polynomials over GF <ref> [2] </ref>. Degree three is the sharp bound for the intractability of exact counting for polynomials; [5, Ehrenfeucht, Karpinski] describe an O (n 3 ) time algorithm for exact counting for degree two polynomials over GF [2]. <p> show that computing jGj exactly is #P-complete, even when restricted to cubic polynomials over GF <ref> [2] </ref>. Degree three is the sharp bound for the intractability of exact counting for polynomials; [5, Ehrenfeucht, Karpinski] describe an O (n 3 ) time algorithm for exact counting for degree two polynomials over GF [2]. We describe a polynomial time Monte Carlo (*; ffi) approximation algorithm (cf.[6, Karp, Luby], [7, Karp, Luby, Madras]) for estimating jGj. <p> The DNF algorithm of [6, Karp, Luby] provides a way of choosing an assignment randomly from G 1 . From this and Theorem 1, the algorithm for estimating jG odd j is straightforward. Besides the basic algebraic interest in the GF <ref> [2] </ref> problem, it is also interesting from the viewpoint of circuit complexity. The polynomial g can be viewed as a depth two circuit over the basis (; ^). Although we provide a randomized polynomial time approximation algorithm for the GF [2] problem, there are no known subexponential deterministic 1 Without loss <p> Besides the basic algebraic interest in the GF <ref> [2] </ref> problem, it is also interesting from the viewpoint of circuit complexity. The polynomial g can be viewed as a depth two circuit over the basis (; ^). Although we provide a randomized polynomial time approximation algorithm for the GF [2] problem, there are no known subexponential deterministic 1 Without loss of generality, we assume for all i 6= j, t i 6= t j , i.e. there are no duplicate terms in the polynomial. 2 For brevity, hereafter the arguments x 1 ; : : : ; x n to <p> x n to the polynomial and to the terms of the polynomial are suppressed. 3 The term 1 corresponds to the product of the empty set of variables, and is satisfied by all assignments to x 1 ; : : : ; x n . algorithms for approximating the GF <ref> [2] </ref> problem. <p> A preliminary version of this paper appears in [9, Luby, Karpinski]. 2 The Approximation Algorithms We first review a simple and standard "dart throwing" algorithm that at a very high level provides the general outline for the GF <ref> [2] </ref> algorithms and highlights the design obstacles that must be overcome. We have a finite (but large) universe U of known size jU j, and our goal is to estimate the size of some set G ae U of unknown size. <p> A standard analysis using an inequality due to Bernstein [13, Renyi] shows that for * &lt; 1, Pr [jGj (1 *) Y jGj (1 + *)] 1 ffi: (See for example [7, Karp, Luby, Madras] for a proof.) The key criteria in the design of the GF <ref> [2] </ref> algorithm are: (a) The universe U should be defined in such a way that jU j is easy to compute. (b) Steps (1) and (2) above can be performed efficiently. (c) jGj is known a priori to be a significant fraction of jU j, i.e. b is polynomially bounded. <p> Thus, the total running time of A 1 is O (nm 3 ln (2=ffi)=* 2 ). 3 The Main Theorem Theorem 1 Let g be a multivariate polynomial over GF <ref> [2] </ref> with no duplicate terms and m terms in total. Let G 1 be the set of assignments to the variables that satisfy at least one term, and let G odd be the set of assignments that satisfy an odd number of terms. Then, jG 1 j=jG odd j m. <p> By the way term t 1 is chosen, t 1 is the only term t i that satisfies t i " X = X, and thus q (X) = 1. We can view p () and q () as column vectors of length 2 k with entries from GF <ref> [2] </ref>, where the first entry corresponds to X 0 = ; and the last entry corresponds to X 0 = X. Then, it can be verified that there is a 2 k fi 2 k lower triangular matrix M over GF [2] with main diagonal 1 such that M q () <p> vectors of length 2 k with entries from GF <ref> [2] </ref>, where the first entry corresponds to X 0 = ; and the last entry corresponds to X 0 = X. Then, it can be verified that there is a 2 k fi 2 k lower triangular matrix M over GF [2] with main diagonal 1 such that M q () = p (). <p> Note that Theorem 1 holds even in the case when g contains the constant term 1. This fact is used in the proof of the following corollary. Corollary 1 Let g be a multivariate polynomial over GF <ref> [2] </ref> with no duplicate terms, no occurence of the constant term 1 and m terms in total. Let U be the set of all assignments to the variables, and let G even be the set of assignments that satisfy an even number of terms. <p> The bound given in Theorem 1 is optimal. To see this, let m be a power of two and let g = i=1;:::;log m (1 x i ) j=log m;:::;n x j . When g is viewed as a polynomial over GF <ref> [2] </ref> and expanded out the number of terms is m. When viewed over GF [2], g = 1 has a unique solution, whereas when viewed as a DNF formula, g has m satisfying assignments. 6 The bound given in Corollary 1 is also optimal. <p> To see this, let m be a power of two and let g = i=1;:::;log m (1 x i ) j=log m;:::;n x j . When g is viewed as a polynomial over GF <ref> [2] </ref> and expanded out the number of terms is m. When viewed over GF [2], g = 1 has a unique solution, whereas when viewed as a DNF formula, g has m satisfying assignments. 6 The bound given in Corollary 1 is also optimal. To see this, consider g = 1 Q i=1;:::;n (1 x i ). <p> To see this, consider g = 1 Q i=1;:::;n (1 x i ). When g is viewed as a polynomial over GF <ref> [2] </ref> and expanded out the 1 term is cancelled and the total number of terms is m = 2 n 1. When viewed over GF [2], g = 0 has a unique solution, and thus jU j=jG even j = 2 n = m + 1. 4 Open Problems The success <p> To see this, consider g = 1 Q i=1;:::;n (1 x i ). When g is viewed as a polynomial over GF <ref> [2] </ref> and expanded out the 1 term is cancelled and the total number of terms is m = 2 n 1. When viewed over GF [2], g = 0 has a unique solution, and thus jU j=jG even j = 2 n = m + 1. 4 Open Problems The success of our method depends on a special property of the GF [2] field, and its connection to the DNF counting problem. <p> When viewed over GF <ref> [2] </ref>, g = 0 has a unique solution, and thus jU j=jG even j = 2 n = m + 1. 4 Open Problems The success of our method depends on a special property of the GF [2] field, and its connection to the DNF counting problem. <p> This problem is of paramount importance in algebra and algebraic geometry. Another important question is whether it is possible to design a polynomial time deterministic approximation algorithm for the GF <ref> [2] </ref> (or more optimistically, for the GF [q] problem) that always produces an estimate with relative error at most *.
Reference: [3] <author> Ajtai, M., Wigderson, A., </author> <title> "Deterministic Simulation of Probabilistic constant depth circuits", </title> <booktitle> FOCS 1985. </booktitle>
Reference-contexts: On the other hand, for the related DNF problem when the basis is (_; ^; :), in addition to the randomized polynomial time algorithm developed in [6, Karp, Luby], there are known deterministic approximation algorithms with running time substantially less than 2 n <ref> [3, Ajtai, Wigderson] </ref>, [12, Nisan, Wigderson], [10, Luby, Velickovic]. Furthermore, the results in [3, Ajtai Wigderson] and the better results in [12, Nisan, Wigderson] extend to the much more general case of a constant depth circuit over basis (_; ^; :). <p> Furthermore, the results in <ref> [3, Ajtai Wigderson] </ref> and the better results in [12, Nisan, Wigderson] extend to the much more general case of a constant depth circuit over basis (_; ^; :).
Reference: [4] <author> Berlekamp, </author> <title> E.R., Algebraic Coding Theory, </title> <publisher> McGraw-Hill, </publisher> <year> 1968. </year>
Reference-contexts: Among other things, this problem has direct applications in information and coding theory for computing weights of codes and channel-error probabilities (cf. <ref> [4, Berlekamp] </ref>, [8, Kasami, Tokura], [11, McWilliams, Sloan]).
Reference: [5] <author> Ehrenfeucht, A., Karpinski, M., </author> <title> "The Computational Complexity of (XOR, AND)- Counting Problems", </title> <type> preprint, </type> <year> 1989. </year> <month> 7 </month>
Reference-contexts: a subset of the variables x 1 ; : : : ; x n . 1 Let G be the set of assignments to x 1 ; : : : ; x n that are zeroes of g. 2 The problem is to compute jGj given a description of g. <ref> [5, Ehrenfeucht, Karpinski] </ref> show that computing jGj exactly is #P-complete, even when restricted to cubic polynomials over GF [2]. Degree three is the sharp bound for the intractability of exact counting for polynomials; [5, Ehrenfeucht, Karpinski] describe an O (n 3 ) time algorithm for exact counting for degree two polynomials <p> that are zeroes of g. 2 The problem is to compute jGj given a description of g. <ref> [5, Ehrenfeucht, Karpinski] </ref> show that computing jGj exactly is #P-complete, even when restricted to cubic polynomials over GF [2]. Degree three is the sharp bound for the intractability of exact counting for polynomials; [5, Ehrenfeucht, Karpinski] describe an O (n 3 ) time algorithm for exact counting for degree two polynomials over GF [2]. We describe a polynomial time Monte Carlo (*; ffi) approximation algorithm (cf.[6, Karp, Luby], [7, Karp, Luby, Madras]) for estimating jGj.
Reference: [6] <author> Karp, R., Luby, M., </author> <title> "Monte-Carlo Algorithms for Enumeration and Reliability Prob--lems," </title> <booktitle> 24 th FOCS, </booktitle> <month> November 7-9, </month> <year> 1983, </year> <pages> pp. 54-63. </pages>
Reference-contexts: The first step of algorithm A 1 is to consider the equivalent problem of estimating jG odd j for the polynomial g resulting from discarding the 1 term from the input polynomial. The DNF algorithm of <ref> [6, Karp, Luby] </ref> provides a way of choosing an assignment randomly from G 1 . From this and Theorem 1, the algorithm for estimating jG odd j is straightforward. Besides the basic algebraic interest in the GF [2] problem, it is also interesting from the viewpoint of circuit complexity. <p> On the other hand, for the related DNF problem when the basis is (_; ^; :), in addition to the randomized polynomial time algorithm developed in <ref> [6, Karp, Luby] </ref>, there are known deterministic approximation algorithms with running time substantially less than 2 n [3, Ajtai, Wigderson], [12, Nisan, Wigderson], [10, Luby, Velickovic]. <p> Thus, the total running time of A 0 is O (nm 2 ln (2=ffi)=* 2 ). We now describe algorithm A 1 . The outline of the algorithm is borrowed from the DNF approximation algorithm of <ref> [6, Karp, Luby] </ref>; we provide a self-contained description of the algorithm. Let g be the input polynomial with the constant term 1 discarded. Thus, the problem is to approximate the number of assignments that satisfy an odd number of terms of g. <p> The final portion of the analysis is to show that there is an easily computable value b such that b is an upper bound on jU j=jG odd j and such that b is polynomial in n and m. As shown in <ref> [6, Karp, Luby] </ref>, it is not hard to verify that jU j=jG 1 j m; this is simply because jG 1 j max i=1;:::;m jT i j which implies that jU j=jG 1 j i=1;:::;m i=1;:::;m 4 Theorem 1 in the next section shows that jG 1 j=jG odd j m.
Reference: [7] <author> Karp, R., Luby, M., Madras, N., </author> <title> "Monte-Carlo Approximation Algorithms for Enumeration Problems," </title> <journal> J. of Algorithms, </journal> <volume> Vol. 10, No. 3, </volume> <month> Sept. </month> <year> 1989, </year> <pages> pp. 429-448. </pages>
Reference-contexts: Degree three is the sharp bound for the intractability of exact counting for polynomials; [5, Ehrenfeucht, Karpinski] describe an O (n 3 ) time algorithm for exact counting for degree two polynomials over GF [2]. We describe a polynomial time Monte Carlo (*; ffi) approximation algorithm (cf.[6, Karp, Luby], <ref> [7, Karp, Luby, Madras] </ref>) for estimating jGj. We design two different algorithms A 0 and A 1 ; A 0 is used in the case when g does not contain the constant term 1 3 and A 1 is used in the case when g contains the term 1. <p> A standard analysis using an inequality due to Bernstein [13, Renyi] shows that for * &lt; 1, Pr [jGj (1 *) Y jGj (1 + *)] 1 ffi: (See for example <ref> [7, Karp, Luby, Madras] </ref> for a proof.) The key criteria in the design of the GF [2] algorithm are: (a) The universe U should be defined in such a way that jU j is easy to compute. (b) Steps (1) and (2) above can be performed efficiently. (c) jGj is known
Reference: [8] <author> Kasami, T., Tokura, N., </author> <title> "On the Weight Structure of Reed-Muller Codes", </title> <journal> IEEE Trans. Inform. Theory IT-16(1970), </journal> <pages> pp. 752-759. </pages>
Reference-contexts: Among other things, this problem has direct applications in information and coding theory for computing weights of codes and channel-error probabilities (cf. [4, Berlekamp], <ref> [8, Kasami, Tokura] </ref>, [11, McWilliams, Sloan]).
Reference: [9] <author> Luby, M., Karpinski, M., </author> <title> "Approximating the Number of Zeroes of a GF[2] Polynomial", </title> <booktitle> proceedings of the 2 nd Annual Symposium on Discrete Algorithms, </booktitle> <year> 1991, </year> <pages> pp. 300-303. </pages>
Reference-contexts: Furthermore, the results in [3, Ajtai Wigderson] and the better results in [12, Nisan, Wigderson] extend to the much more general case of a constant depth circuit over basis (_; ^; :). A preliminary version of this paper appears in <ref> [9, Luby, Karpinski] </ref>. 2 The Approximation Algorithms We first review a simple and standard "dart throwing" algorithm that at a very high level provides the general outline for the GF [2] algorithms and highlights the design obstacles that must be overcome.
Reference: [10] <author> Luby, M., Velickovic, B., </author> <title> "On Deterministic Approximation of DNF", </title> <note> to appear in the proceedings of STOC 1991. </note>
Reference-contexts: On the other hand, for the related DNF problem when the basis is (_; ^; :), in addition to the randomized polynomial time algorithm developed in [6, Karp, Luby], there are known deterministic approximation algorithms with running time substantially less than 2 n [3, Ajtai, Wigderson], [12, Nisan, Wigderson], <ref> [10, Luby, Velickovic] </ref>. Furthermore, the results in [3, Ajtai Wigderson] and the better results in [12, Nisan, Wigderson] extend to the much more general case of a constant depth circuit over basis (_; ^; :).
Reference: [11] <author> MacWilliams, F.J., Sloan, N.J.A., </author> <title> The Theory of Error Correcting Codes, </title> <publisher> North-Holland, </publisher> <year> 1981. </year>
Reference-contexts: Among other things, this problem has direct applications in information and coding theory for computing weights of codes and channel-error probabilities (cf. [4, Berlekamp], [8, Kasami, Tokura], <ref> [11, McWilliams, Sloan] </ref>).
Reference: [12] <author> Nisan, N., Wigderson, A., </author> <title> "Hardness vs. Randomness", </title> <booktitle> 29 th FOCS (1988), </booktitle> <pages> pp. 2-11. </pages>
Reference-contexts: On the other hand, for the related DNF problem when the basis is (_; ^; :), in addition to the randomized polynomial time algorithm developed in [6, Karp, Luby], there are known deterministic approximation algorithms with running time substantially less than 2 n [3, Ajtai, Wigderson], <ref> [12, Nisan, Wigderson] </ref>, [10, Luby, Velickovic]. Furthermore, the results in [3, Ajtai Wigderson] and the better results in [12, Nisan, Wigderson] extend to the much more general case of a constant depth circuit over basis (_; ^; :). <p> ^; :), in addition to the randomized polynomial time algorithm developed in [6, Karp, Luby], there are known deterministic approximation algorithms with running time substantially less than 2 n [3, Ajtai, Wigderson], <ref> [12, Nisan, Wigderson] </ref>, [10, Luby, Velickovic]. Furthermore, the results in [3, Ajtai Wigderson] and the better results in [12, Nisan, Wigderson] extend to the much more general case of a constant depth circuit over basis (_; ^; :).
Reference: [13] <author> Renyi, A., </author> <year> (1970), </year> <title> Probability Theory, </title> <publisher> North-Holland, Amsterdam. </publisher>
Reference-contexts: The algorithm performs N = 4b ln (2=ffi)=* 2 independent trials, and the output Y is the fraction of these N trials where an element of G is chosen, multiplied by jU j. A standard analysis using an inequality due to Bernstein <ref> [13, Renyi] </ref> shows that for * &lt; 1, Pr [jGj (1 *) Y jGj (1 + *)] 1 ffi: (See for example [7, Karp, Luby, Madras] for a proof.) The key criteria in the design of the GF [2] algorithm are: (a) The universe U should be defined in such a
Reference: [14] <author> Schoof, </author> <title> R.J., "Elliptic Curves Over Finite Fields and the Computation of square Roots Mod p", </title> <journal> Math. </journal> <volume> Computation 44(1985), </volume> <pages> 483-494. 8 </pages>
References-found: 14

