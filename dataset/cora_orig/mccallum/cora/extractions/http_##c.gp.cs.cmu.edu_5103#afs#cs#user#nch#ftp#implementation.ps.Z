URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/nch/ftp/implementation.ps.Z
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/nch/www/sba.html
Root-URL: http://www.cs.cmu.edu
Email: (nch@cs.cmu.edu)  
Title: Practical Aspects of Set Based Analysis  Summary  
Author: Nevin Heintze 
Date: March, 1992  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: The set based approach to compile time analysis of logic programs has numerous advantages over other approaches, including a simple, intuitive definition, and a very accurate and uniform treatment of term structure. However the algorithms for set based analysis that have been presented to date have focussed on establishing decidability results, and do not provide a practical basis for program analysis. This paper demonstrates that very substantial progress can be made towards a practical system by redesigning the algorithms according to implementation criteria, designing appropriate representations techniques, and exploiting the redundancy which is typically present. An implementation is described and experimental evidence is presented which suggests that set based analysis can be made practical for comprehensive and accurate analysis of logic programs.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken and B. Murphy, </author> <title> "Implementing Regular Trees", </title> <booktitle> Proceedings 4 th ACM Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pp 2 - 16, </pages> <year> 1991. </year>
Reference-contexts: Implementations have been reported in [11] and [14], but the former does not focus on practical issues, and the latter is not directly comparable to our work since it deals with type checking rather than type inference. The most closely related work to ours is <ref> [1] </ref>, which describes an implementation of type inference for the functional language FL. In very general terms their observations about the complexity of the intersection operation are similar to ours. However the two algorithms are completely different in nature.
Reference: [2] <author> F. Gecseg and M. Steinby, </author> <title> "Tree Automata", </title> <publisher> Akademiai Kiado, </publisher> <address> Budapest, </address> <year> 1984. </year>
Reference-contexts: Moreover, [4] shows that least models are always describable by regular term grammars because the set defined for each set variable is definable using a regular term grammar or equivalently a frontier-to-root tree automaton (see <ref> [2] </ref>). Computing the least model of a collection of set constraints involves constructing an explicit representation of the least model using regular tree grammars. This representation is explicit in the sense that its structure is evident and questions about membership and emptiness can be readily answered.
Reference: [3] <author> N. Heintze and J. Jaffar, </author> <title> "A Finite Presentation Theorem for Approximating Logic Programs", </title> <booktitle> Proceedings 17 th ACM-POPL, </booktitle> <year> 1990, </year> <pages> pp. 197-209. </pages>
Reference-contexts: 1 Introduction The set based approach to program analysis <ref> [3, 4, 5] </ref> has its origins in the use of constraints to perform type analysis of programs [12, 8, 10]. <p> While set based analysis has substantial advantages in terms of accuracy, it also has substantial disadvantages in terms of computational cost. To address the question of whether the cost is prohibitive, this paper develops and evaluates an implementation of set constraints. Although straightforward implementation of the algorithms described in <ref> [3, 4] </ref> is unworkable, substantial progress has been made towards a practical system by developing an algorithm specifically for implementation purposes, designing appropriate representations techniques and exploiting the redundancy which is typically present. <p> Section 6 contains some experimental results, with particular focus on justifying the design decisions outlined in the paper. 2 Background: Set Constraints and Program Analysis We briefly outline how set constraints may be used to obtain safe approximations of program execution (see <ref> [3, 4, 9] </ref> for more details). Specifically, for each point in the program, we wish to obtain a safe description of the possible substitutions that are encountered at that point during program execution. <p> The construction of set constraints corresponding to a program has only been informally outlined here. Further details and correctness proofs can be found in <ref> [3, 6, 5, 9] </ref>. The key point is that, given a notion of program execution (such as topdown left-to-right, topdown parallel) we can give a schema for generating appropriate constraints from a program. <p> The key point is that, given a notion of program execution (such as topdown left-to-right, topdown parallel) we can give a schema for generating appropriate constraints from a program. We note that the constraints used in this paper are simpler and slightly less accurate than those used in <ref> [3] </ref>. However the differences are only minor, and it is easy to adapt the correctness proofs in [3] to the constraints considered here. Most importantly, the constraints used here provide a similar uniform treatment of structures, and in some sense represent the core part of the more complex constraints. <p> We note that the constraints used in this paper are simpler and slightly less accurate than those used in <ref> [3] </ref>. However the differences are only minor, and it is easy to adapt the correctness proofs in [3] to the constraints considered here. Most importantly, the constraints used here provide a similar uniform treatment of structures, and in some sense represent the core part of the more complex constraints. <p> This algorithm is closely related to the algorithm in [4] (see also <ref> [3] </ref>); we shall discuss the differnces at the end of this section. For convenence of presentation, we 4 shall ignore the symbol &gt;. The details of the transformations to deal with &gt; are straightforward and can be found in [4].
Reference: [4] <author> N. Heintze and J. Jaffar, </author> <title> "A Decision Procedure for a Class of Herbrand Set Constraints", </title> <booktitle> Proceedings 5 th IEEE-LICS, </booktitle> <month> June </month> <year> 1990, </year> <pages> pp 42 - 51. </pages>
Reference-contexts: 1 Introduction The set based approach to program analysis <ref> [3, 4, 5] </ref> has its origins in the use of constraints to perform type analysis of programs [12, 8, 10]. <p> While set based analysis has substantial advantages in terms of accuracy, it also has substantial disadvantages in terms of computational cost. To address the question of whether the cost is prohibitive, this paper develops and evaluates an implementation of set constraints. Although straightforward implementation of the algorithms described in <ref> [3, 4] </ref> is unworkable, substantial progress has been made towards a practical system by developing an algorithm specifically for implementation purposes, designing appropriate representations techniques and exploiting the redundancy which is typically present. <p> Section 6 contains some experimental results, with particular focus on justifying the design decisions outlined in the paper. 2 Background: Set Constraints and Program Analysis We briefly outline how set constraints may be used to obtain safe approximations of program execution (see <ref> [3, 4, 9] </ref> for more details). Specifically, for each point in the program, we wish to obtain a safe description of the possible substitutions that are encountered at that point during program execution. <p> For the purposes of set based analysis, we shall only be interested in the least models of set constraints, and these always exist for the constraints considered here. Moreover, <ref> [4] </ref> shows that least models are always describable by regular term grammars because the set defined for each set variable is definable using a regular term grammar or equivalently a frontier-to-root tree automaton (see [2]). <p> This algorithm is closely related to the algorithm in <ref> [4] </ref> (see also [3]); we shall discuss the differnces at the end of this section. For convenence of presentation, we 4 shall ignore the symbol &gt;. The details of the transformations to deal with &gt; are straightforward and can be found in [4]. <p> algorithm is closely related to the algorithm in <ref> [4] </ref> (see also [3]); we shall discuss the differnces at the end of this section. For convenence of presentation, we 4 shall ignore the symbol &gt;. The details of the transformations to deal with &gt; are straightforward and can be found in [4]. The first step of the algorithm is a preprocessing stage which puts the constraints in a standard form, and this essentially involves removing nested occurrences of union, intersection and projection symbols. <p> Three replacement steps lead to the equations X = W 1 " W 2 ; W 2 = p 1 W 3 = p 1 The details of this are straightforward and can be adapted from <ref> [4] </ref>. Importantly the resulting equations are equivalent to the original equations in the sense that the least model of the former, when restricted to the variables in the original equations, is the least model of the latter. <p> The main difference is that the projector and intersector transformations also contain part of the previous substitution transformation. In essence, the variable transformation is all that remains of the original substitution transformation. A minor difference is that <ref> [4] </ref> used an extended version of regular grammars, whereas we deal directly with set equations. We now briefly outline the proof of correctness of this formulation of the algorithm, with particular emphasis on the parts of the proof that differ from that in [4]. <p> A minor difference is that <ref> [4] </ref> used an extended version of regular grammars, whereas we deal directly with set equations. We now briefly outline the proof of correctness of this formulation of the algorithm, with particular emphasis on the parts of the proof that differ from that in [4]. Theorem 1 If constraints C in are input to the algorithm then the algorithm terminates and output constraints C out in explicit form.
Reference: [5] <author> N. Heintze and J. Jaffar, </author> <title> "Set Based Program Analysis", </title> <type> draft manuscript, </type> <month> January </month> <year> 1991. </year>
Reference-contexts: 1 Introduction The set based approach to program analysis <ref> [3, 4, 5] </ref> has its origins in the use of constraints to perform type analysis of programs [12, 8, 10]. <p> The construction of set constraints corresponding to a program has only been informally outlined here. Further details and correctness proofs can be found in <ref> [3, 6, 5, 9] </ref>. The key point is that, given a notion of program execution (such as topdown left-to-right, topdown parallel) we can give a schema for generating appropriate constraints from a program.
Reference: [6] <author> N. Heintze and J. Jaffar, </author> <title> "Semantic Types for Logic Programs" in Types in Logic Programming, </title> <editor> F. Pfenning (Ed.), </editor> <publisher> MIT Press Series in Logic Programming, </publisher> <year> 1992, </year> <month> forthcoming. </month>
Reference-contexts: The construction of set constraints corresponding to a program has only been informally outlined here. Further details and correctness proofs can be found in <ref> [3, 6, 5, 9] </ref>. The key point is that, given a notion of program execution (such as topdown left-to-right, topdown parallel) we can give a schema for generating appropriate constraints from a program.
Reference: [7] <author> N. Heintze and J. Jaffar, </author> <title> "An Engine for Logic Program Analysis", </title> <journal> Proceedings 7 th IEEE-LICS, </journal> <note> to appear. </note>
Reference-contexts: Although this extension has been incorporated into the implementation with very little additional overhead, it is somewhat restricted because interdependencies between variables are ignored, and such dependencies can be important for mode analysis. An algorithm in <ref> [7] </ref> may provide a basis for more accurately dealing with modes whilst retaining the important advantages of structural accuracy. We conclude with a discussion of related work.
Reference: [8] <editor> N.D. Jones and S.S. Muchnick, </editor> <title> "Flow Analysis and Optimization of LISP-like Structures", </title> <booktitle> Proceedings 6 th ACM-POPL, </booktitle> <year> 1979, </year> <pages> pp 244 - 256. </pages>
Reference-contexts: 1 Introduction The set based approach to program analysis [3, 4, 5] has its origins in the use of constraints to perform type analysis of programs <ref> [12, 8, 10] </ref>. In essence set based analysis involves first writing set constraints (a calculus for expressing relationships between sets of program values) to describe the runtime behaviour of a program, and then solving these constraints to find their least model.
Reference: [9] <author> N. Heintze, </author> <title> "Set Based Program Analysis", </title> <type> forthcoming Ph.D. thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> June </month> <year> 1992 </year> <month> (expected). </month>
Reference-contexts: Section 6 contains some experimental results, with particular focus on justifying the design decisions outlined in the paper. 2 Background: Set Constraints and Program Analysis We briefly outline how set constraints may be used to obtain safe approximations of program execution (see <ref> [3, 4, 9] </ref> for more details). Specifically, for each point in the program, we wish to obtain a safe description of the possible substitutions that are encountered at that point during program execution. <p> The construction of set constraints corresponding to a program has only been informally outlined here. Further details and correctness proofs can be found in <ref> [3, 6, 5, 9] </ref>. The key point is that, given a notion of program execution (such as topdown left-to-right, topdown parallel) we can give a schema for generating appropriate constraints from a program.
Reference: [10] <author> P. Mishra, </author> <title> "Toward a Theory of Types in PROLOG", </title> <booktitle> Proceedings 1 st IEEE Symposium on Logic Programming, </booktitle> <pages> pp 289 - 298, </pages> <year> 1984. </year>
Reference-contexts: 1 Introduction The set based approach to program analysis [3, 4, 5] has its origins in the use of constraints to perform type analysis of programs <ref> [12, 8, 10] </ref>. In essence set based analysis involves first writing set constraints (a calculus for expressing relationships between sets of program values) to describe the runtime behaviour of a program, and then solving these constraints to find their least model.
Reference: [11] <author> C. Pyo and U.S. Reddy, </author> <title> "Inference of Polymorphic Types for Logic Programs" Logic Programming, </title> <booktitle> Proceedings of the North American Conference, 1989, </booktitle> <publisher> MIT Press, </publisher> <pages> pp 1115 - 1134, </pages> <month> October, </month> <year> 1989. </year>
Reference-contexts: Our work is more closely connected to work on types for logic programs in which types are defined by ignoring inter-variable or inter-argument dependencies. Implementations have been reported in <ref> [11] </ref> and [14], but the former does not focus on practical issues, and the latter is not directly comparable to our work since it deals with type checking rather than type inference.
Reference: [12] <author> J.C. Reynolds, </author> <title> "Automatic Computation of Data Set Definitions", </title> <booktitle> Information Processing 68, </booktitle> <publisher> North-Holland, </publisher> <year> 1969, </year> <pages> pp 456 - 461. </pages>
Reference-contexts: 1 Introduction The set based approach to program analysis [3, 4, 5] has its origins in the use of constraints to perform type analysis of programs <ref> [12, 8, 10] </ref>. In essence set based analysis involves first writing set constraints (a calculus for expressing relationships between sets of program values) to describe the runtime behaviour of a program, and then solving these constraints to find their least model.
Reference: [13] <author> T. Fruhwirth, E. Shapiro, M.Y. Vardi, E. Yardeni, </author> <title> "Logic Programs as Types for Logic Programs", </title> <booktitle> Proceedings 6 th IEEE Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: are operations of set projection, intersection and union, and it is clear that solving such constraints can be expensive in the worst case. (This is mainly due to the exponential behaviour of the intersection operation.) Exponential upper and lower bounds for one case of set constraint analysis are established in <ref> [13] </ref>. However it is not clear what these observations have to say about the practicality of set based analysis. Typical programs rarely exhibit the extremes of behaviour which are exploited to obtain worst case behaviour.
Reference: [14] <author> E. Yardeni and E.Y. Shapiro, </author> <title> "A Type System for Logic Programs", </title> <journal> Journal of Logic Programming, </journal> <volume> Vol. 10, </volume> <pages> pp 125 - 153, </pages> <year> 1991. </year> <month> 16 </month>
Reference-contexts: Our work is more closely connected to work on types for logic programs in which types are defined by ignoring inter-variable or inter-argument dependencies. Implementations have been reported in [11] and <ref> [14] </ref>, but the former does not focus on practical issues, and the latter is not directly comparable to our work since it deals with type checking rather than type inference.
References-found: 14

