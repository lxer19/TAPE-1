URL: http://www.cs.nmsu.edu/lldap/download/jicslp/prestwich.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/jicslp/prest.html
Root-URL: http://www.cs.nmsu.edu
Email: Email steven@nortel.co.uk  
Phone: Tel. +44 1279 40 2719  
Title: Three Implementations of Branch-and-Bound in CLP  
Author: Steven Prestwich 
Date: September 9, 1996  
Address: London Road, Harlow, Essex, CM17 9NA, England  
Affiliation: Nortel technology,  
Abstract: Constraint logic programming systems are becoming increasingly popular for solving real-life combinatorial optimization problems. An important component of such systems is therefore an optimization function, and one or more implementations of the branch-and-bound method are typically provided. However, there seems to be no available methodology for choosing an implementation, and making the wrong choice can cause disastrous performance problems. This paper examines the robustness of three known implementations by testing their performance under extreme conditions. One implementation performs badly when constraint propagation is poor and also interacts poorly with parallelization in three distinct ways. Another performs badly on certain cost functions. The third is not always the fastest but it emerges as more robust than the other two. We therefore recommend that only the third or something like it be provided, thus relieving the programmer of a difficult but critical decision. Keywords: constraint logic programming, or-parallelism, branch-and-bound 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aggoun and N. Beldiceanu. </author> <title> Extending CHIP in order to solve complex scheduling and placement problems. </title> <booktitle> In Proc. of JFPL'92, </booktitle> <year> 1992. </year>
Reference-contexts: Most CLP systems provide functions for optimization based on the branch-and-bound method. The first two implementations were in CHIP [5]. Various implementations are also provided by commercial versions of CHIP <ref> [1] </ref> and related constraint solving tools, such as ECL i PS e [6], CHARME [11] and DECISIONPOWER [4]; and by ILOG SOLVER [7], a constraint solver based on C++ instead of Prolog.
Reference: [2] <author> Y. Caseau and F. Laburthe. </author> <title> Improved CLP scheduling with task intervals. </title> <booktitle> In Proc. of 11th Int. Conf. on Logic Programming, </booktitle> <pages> pages 369-383. </pages> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: 1. Introduction Constraint Logic Programming (CLP) has been successfully applied to combinatorial optimization problems in Operations Research and Artificial Intelligence [3, 20, 21], some implementations approaching the efficiency of specialized, hand-coded algorithms <ref> [2] </ref>. The main advantage of the CLP approach is its ease of programming and its flexibility. For well-studied problems Operations Research techniques are the best, but for new problems with complex and non-standard constraints, the flexibility of CLP makes it the tool of choice.
Reference: [3] <author> D. Clark, C. Rawlings, J. Shirazi, L.-L. Li, M. Reeve, K. Schuermann, and A. Veron. </author> <title> Solving large combinatorial problems in molecular biology using the ElipSys parallel constraint logic programming system. </title> <journal> Computer Journal, </journal> <volume> 36(4), </volume> <year> 1993. </year>
Reference-contexts: 1. Introduction Constraint Logic Programming (CLP) has been successfully applied to combinatorial optimization problems in Operations Research and Artificial Intelligence <ref> [3, 20, 21] </ref>, some implementations approaching the efficiency of specialized, hand-coded algorithms [2]. The main advantage of the CLP approach is its ease of programming and its flexibility.
Reference: [4] <author> J.-Y. Cras. </author> <title> A review of industrial constraint solving tools. Survey, </title> <booktitle> AI Perspectives, 1994. 1996 Compulog Net Meeting on Parallelism and Implementation Technology 11 </booktitle>
Reference-contexts: Most CLP systems provide functions for optimization based on the branch-and-bound method. The first two implementations were in CHIP [5]. Various implementations are also provided by commercial versions of CHIP [1] and related constraint solving tools, such as ECL i PS e [6], CHARME [11] and DECISIONPOWER <ref> [4] </ref>; and by ILOG SOLVER [7], a constraint solver based on C++ instead of Prolog. Users of such systems, when programming a new problem, must try all the available implementations to see which works best.
Reference: [5] <author> M. Dincbas et al. </author> <title> The constraint logic programming language CHIP. </title> <booktitle> In Proc. of the Int. Conf. on 5th Generation Computer Systems (FGCS'88), </booktitle> <pages> pages 693-702. </pages> <publisher> ICOT, </publisher> <year> 1988. </year>
Reference-contexts: For well-studied problems Operations Research techniques are the best, but for new problems with complex and non-standard constraints, the flexibility of CLP makes it the tool of choice. Most CLP systems provide functions for optimization based on the branch-and-bound method. The first two implementations were in CHIP <ref> [5] </ref>. Various implementations are also provided by commercial versions of CHIP [1] and related constraint solving tools, such as ECL i PS e [6], CHARME [11] and DECISIONPOWER [4]; and by ILOG SOLVER [7], a constraint solver based on C++ instead of Prolog.
Reference: [6] <institution> European Computer-Industry Research Centre, Munich, Germany. ECLiPSe 3.5.2 User Manual, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: Most CLP systems provide functions for optimization based on the branch-and-bound method. The first two implementations were in CHIP [5]. Various implementations are also provided by commercial versions of CHIP [1] and related constraint solving tools, such as ECL i PS e <ref> [6] </ref>, CHARME [11] and DECISIONPOWER [4]; and by ILOG SOLVER [7], a constraint solver based on C++ instead of Prolog. Users of such systems, when programming a new problem, must try all the available implementations to see which works best. <p> This combination of or-parallelism and CLP was first suggested in [17]. The first real system to combine finite domain constraints with or-parallelism was Elipsys [19]. Or-parallelism has now been added to ECL i PS e <ref> [6] </ref> on which the results in this paper have been obtained. Or-parallelism works as follows. At certain nodes of the search tree each branch is tried in parallel on different processors instead of in sequence by backtracking. <p> The ../2 operator defines a closed integer interval in a domain. So for example [X,Y]::0..3, Z#=X sets the domains of the variables X, Y and Z to f0; 1; 2; 3g. The syntax is fully defined in the ECL i PS e manual <ref> [6] </ref>. We also allow sub- and superscripts to facilitate the description of parameterized families of programs. A call to a branch-and-bound implementation s with goal Goal and cost function Cost will be denoted by bb s (Goal, Cost). <p> They are rather artificial in nature, but the fact that we can construct such examples means that they may occur in real programs. Moreover, we have observed at least some of these effects in real applications. All timings were obtained on ECL i PS e version 3.5.2 <ref> [6] </ref>. Examples which are purely sequential were executed on a Sun SparcStation 5 while parallel examples were executed on a 4-processor ICL DRS6000. Timings are elapsed times (not CPU times) and are given in seconds. 3.1.
Reference: [7] <author> ILOG. </author> <title> ILOG SOLVER reference manual version 3.0. </title> <type> Technical report, </type> <year> 1995. </year>
Reference-contexts: The first two implementations were in CHIP [5]. Various implementations are also provided by commercial versions of CHIP [1] and related constraint solving tools, such as ECL i PS e [6], CHARME [11] and DECISIONPOWER [4]; and by ILOG SOLVER <ref> [7] </ref>, a constraint solver based on C++ instead of Prolog. Users of such systems, when programming a new problem, must try all the available implementations to see which works best.
Reference: [8] <author> J. M. Jansen and F. W. Sijstermans. </author> <title> Parallel branch-and-bound algorithms. </title> <journal> Future Generation Computer Systems, </journal> <volume> 4 </volume> <pages> 271-279, 1988-89. </pages>
Reference-contexts: A number of researchers have worked on exploiting or-parallelism within branch-and-bound algorithms, both inside and outside the logic programming framework <ref> [8, 9, 10, 15, 16] </ref>. In particular, Szeredi [16] investigated the use of or-parallel Prolog for such problems and had some encouraging preliminary performance figures using Aurora [12]. 1.2.
Reference: [9] <author> V. Kumar and V. N. Rao. </author> <title> Parallel depth first search | Part I. Implementation. </title> <journal> Int. Journal of Parallel Programming, </journal> <volume> 16(6), </volume> <year> 1987. </year>
Reference-contexts: A number of researchers have worked on exploiting or-parallelism within branch-and-bound algorithms, both inside and outside the logic programming framework <ref> [8, 9, 10, 15, 16] </ref>. In particular, Szeredi [16] investigated the use of or-parallel Prolog for such problems and had some encouraging preliminary performance figures using Aurora [12]. 1.2.
Reference: [10] <author> V. Kumar and V. N. Rao. </author> <title> Parallel depth first search | Part II. Analysis. </title> <journal> Int. Journal of Parallel Programming, </journal> <volume> 16(6), </volume> <year> 1987. </year>
Reference-contexts: A number of researchers have worked on exploiting or-parallelism within branch-and-bound algorithms, both inside and outside the logic programming framework <ref> [8, 9, 10, 15, 16] </ref>. In particular, Szeredi [16] investigated the use of or-parallel Prolog for such problems and had some encouraging preliminary performance figures using Aurora [12]. 1.2.
Reference: [11] <author> M. Leconte. </author> <type> Personal communication, </type> <month> March </month> <year> 1996. </year>
Reference-contexts: Most CLP systems provide functions for optimization based on the branch-and-bound method. The first two implementations were in CHIP [5]. Various implementations are also provided by commercial versions of CHIP [1] and related constraint solving tools, such as ECL i PS e [6], CHARME <ref> [11] </ref> and DECISIONPOWER [4]; and by ILOG SOLVER [7], a constraint solver based on C++ instead of Prolog. Users of such systems, when programming a new problem, must try all the available implementations to see which works best. <p> At a node with many branches, if the new constraint fails at some branch then bb 3 should not try the remaining branches (though it currently does in CHARME <ref> [11] </ref>). 2.4. Discussion There are other possibilities than the three implementations described here. For example when a new upper cost bound is found, intelligent backtracking can be used to jump back to an appropriate place in the search tree [18].
Reference: [12] <author> E. Lusk, R. Butler, T. Disz, R. Olson, R. Overbeek, R. Stevens, D. H. D. Warren, A. Calderwood, P. Szerdi, S. Haridi, P. Brand, M. Carlsson, A. Ciepielewski, and B. Hausman. </author> <title> The Aurora Or-Parallel Prolog system. </title> <booktitle> In Proc. of the Int. Conf. on 5th Generation Computer Systems (FGCS'88). </booktitle> <publisher> ICOT, </publisher> <year> 1988. </year>
Reference-contexts: A number of researchers have worked on exploiting or-parallelism within branch-and-bound algorithms, both inside and outside the logic programming framework [8, 9, 10, 15, 16]. In particular, Szeredi [16] investigated the use of or-parallel Prolog for such problems and had some encouraging preliminary performance figures using Aurora <ref> [12] </ref>. 1.2. Terminology We use the standard Prolog syntax whereby predicates and constants are denoted by lower-case and variables by upper-case characters, plus some constraint operators. The =/2 operator (that is the = operator with arity 2) denotes unification while #=/2 makes the value of two domain variables equal.
Reference: [13] <author> S. D. Prestwich. </author> <title> On parallelization strategies for logic programs. </title> <booktitle> In Proc. of the Int. Conf. on Parallel Processing, number 854 in LNCS, </booktitle> <pages> pages 289-300. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: If heuristics such as dynamic value-ordering are successfully employed then solutions occur to the left of the space, and parallelism yields little benefit. 3.5. Unusual cost distributions A logic program may be slower when executed in parallel than sequentially even if the parallelism overhead is negligible <ref> [13] </ref>. This is possible if what is computed depends upon the history of the parallel computation, as in branch-and-bound programs. We construct a family of programs with a parameter s in Figure 5.
Reference: [14] <author> S. D. Prestwich and S. Mudambi. </author> <title> Improved branch and bound in constraint logic programming. </title> <booktitle> In Proc. of the 1st Int. Conf. on Principles and Practice of Constraint Programming, </booktitle> <pages> pages 533-548, </pages> <year> 1995. </year>
Reference-contexts: The idea behind bb 2 is to avoid the restarting overhead of bb 1 . 2.3. Implementation bb 3 This implementation is provided by ILOG SOLVER (IlcMinim), CHARME (minimize) and was proposed for ECL i PS e in <ref> [14] </ref> (where it was called min). <p> For large portions of the search, bb 2 is using an out-of-date cost bound, which makes it extremely inefficient for this example. This behaviour has been observed in more realistic problems. In <ref> [14] </ref> it was noted that a set of job-shop scheduling problems behaved well under bb 1;3 but was orders of magnitude slower under bb 2 . For these reasons (we believe that) bb 2 is used less often than bb 1 . 3.3.
Reference: [15] <author> T. J. Reynold and P. Kefalas. </author> <title> Or-parallel prolog and search problems in AI applications. </title> <booktitle> In Logic Programming: Proc. of the 7th Int Conf., </booktitle> <pages> pages 340-354. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: A number of researchers have worked on exploiting or-parallelism within branch-and-bound algorithms, both inside and outside the logic programming framework <ref> [8, 9, 10, 15, 16] </ref>. In particular, Szeredi [16] investigated the use of or-parallel Prolog for such problems and had some encouraging preliminary performance figures using Aurora [12]. 1.2.
Reference: [16] <author> P. </author> <title> Szeredi. Exploiting or-parallelism in optimisation problems. </title> <booktitle> In Proc. of the JIC-SLP'92, </booktitle> <pages> pages 703-716. </pages> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: A number of researchers have worked on exploiting or-parallelism within branch-and-bound algorithms, both inside and outside the logic programming framework <ref> [8, 9, 10, 15, 16] </ref>. In particular, Szeredi [16] investigated the use of or-parallel Prolog for such problems and had some encouraging preliminary performance figures using Aurora [12]. 1.2. <p> A number of researchers have worked on exploiting or-parallelism within branch-and-bound algorithms, both inside and outside the logic programming framework [8, 9, 10, 15, 16]. In particular, Szeredi <ref> [16] </ref> investigated the use of or-parallel Prolog for such problems and had some encouraging preliminary performance figures using Aurora [12]. 1.2. Terminology We use the standard Prolog syntax whereby predicates and constants are denoted by lower-case and variables by upper-case characters, plus some constraint operators.
Reference: [17] <author> P. van Hentenryck. </author> <title> Parallel constraint satisfaction in logic programming: Preliminary results of chip within PEPSys. </title> <editor> In Giorgio Levi and Maurizio Martelli, editors, </editor> <booktitle> Proc. of the 6th Int. Conf. on Logic Programming, </booktitle> <pages> pages 165-180, </pages> <address> Lisbon, 1989. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Since even after the constrain phase the remaining search space can be quite large, or-parallel CLP systems attempt to explore the remaining search space in parallel. This combination of or-parallelism and CLP was first suggested in <ref> [17] </ref>. The first real system to combine finite domain constraints with or-parallelism was Elipsys [19]. Or-parallelism has now been added to ECL i PS e [6] on which the results in this paper have been obtained. Or-parallelism works as follows.
Reference: [18] <author> P. van Hentenryck. </author> <type> Personal communication, </type> <month> January </month> <year> 1995. </year> <booktitle> 12 1996 Compulog Net Meeting on Parallelism and Implementation Technology </booktitle>
Reference-contexts: Discussion There are other possibilities than the three implementations described here. For example when a new upper cost bound is found, intelligent backtracking can be used to jump back to an appropriate place in the search tree <ref> [18] </ref>. However, in this paper we only consider the three implementations bb 1;2;3 currently available in ECL i PS e . They each have pros and cons which we discuss here before testing them on examples.
Reference: [19] <author> A. Veron, K. Schuerman, M. Reeve, and L. Li. </author> <title> Why and how in the ElipSys Or-Parallel CLP system. </title> <booktitle> In PARLE'93: Parallel Architectures and Languages Europe, </booktitle> <pages> pages 291-302. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: This combination of or-parallelism and CLP was first suggested in [17]. The first real system to combine finite domain constraints with or-parallelism was Elipsys <ref> [19] </ref>. Or-parallelism has now been added to ECL i PS e [6] on which the results in this paper have been obtained. Or-parallelism works as follows. At certain nodes of the search tree each branch is tried in parallel on different processors instead of in sequence by backtracking.
Reference: [20] <author> A. Veron, K. Schuerman, M. Reeve, and L.-L. Li. APPLAUSE: </author> <title> Applications using the ElipSys parallel CLP system. </title> <booktitle> In Proc. of the 10th Int. Conf. on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: 1. Introduction Constraint Logic Programming (CLP) has been successfully applied to combinatorial optimization problems in Operations Research and Artificial Intelligence <ref> [3, 20, 21] </ref>, some implementations approaching the efficiency of specialized, hand-coded algorithms [2]. The main advantage of the CLP approach is its ease of programming and its flexibility.
Reference: [21] <author> M. Wallace. </author> <title> Constraints in planning, scheduling and placement problems. In Constraint Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: 1. Introduction Constraint Logic Programming (CLP) has been successfully applied to combinatorial optimization problems in Operations Research and Artificial Intelligence <ref> [3, 20, 21] </ref>, some implementations approaching the efficiency of specialized, hand-coded algorithms [2]. The main advantage of the CLP approach is its ease of programming and its flexibility.
References-found: 21

