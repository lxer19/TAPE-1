URL: ftp://flint.cs.yale.edu/pub/flint/publications/lift.ps.gz
Refering-URL: http://daffy.cs.yale.edu/users/shao-zhong/papers.html
Root-URL: http://www.cs.yale.edu
Email: fsaha,shaog@cs.yale.edu  
Title: Optimal Type Lifting  
Author: Bratin Saha and Zhong Shao 
Address: New Haven, CT 06520-8285  
Affiliation: Dept. of Computer Science Yale University  
Abstract: Modern compilers for ML-like polymorphic languages have used explicit run-time type passing to support advanced optimizations such as intensional type analysis, representation analysis and tagless garbage collection. Unfortunately, maintaining type information at run time can incur a large overhead to the time and space usage of a program. In this paper, we present an optimal type-lifting algorithm that lifts all type applications in a program to the top level. Our algorithm eliminates all run-time type constructions within any core-language functions. In fact, it guarantees that the number of types built at run time is strictly a static constant. We present our algorithm as a type-preserving source-to-source transformation and show how to extend it to handle the entire SML'97 with higher-order modules.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Executing the function doit results in three type applications arising from the Array.sub function, pair, and f. In each iteration, sub and pair are applied to types ff fl ff and ff respectively. A clever compiler may do a loop-invariant removal <ref> [1] </ref> to avoid the repeated type construction (e.g., ff fl ff) and application (e.g., pair [ff]). But optimizing type applications such as f [sfls] is less obvious; f is nested inside pair, and its repeated type applications are not apparent in the doit function. <p> Peyton Jones [25, 23, 24] also described a number of optimizations which are similar in spirit but have totally different aims. Appel [2] describes let hoisting in the context of ML. In general, using correctness preserving transformations as a compiler optimization <ref> [1, 2] </ref> is a well established technique and has received quite a bit of attention in the functional programming area. We have proposed a method for minimizing the cost of runtime type passing.
Reference: 2. <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: The terms are an explicitly typed -calculus (but in A-normal form) with explicit constructor abstraction and application. (kinds) ::= j 1 ! 2 (cons) ::= t j Int j 1 ! 2 j t :: : j 1 <ref> [ 2 ] </ref> (types) ::= T () j 1 ! 2 j 8t :: : (terms) e ::= i j x j let x = e 1 in e 2 j @x 1 x 2 j c x : T ():e j m x : :e (values) e v ::= i <p> Johnsson [10] describes different forms of lambda lifting and the pros and cons of each. Peyton Jones [25, 23, 24] also described a number of optimizations which are similar in spirit but have totally different aims. Appel <ref> [2] </ref> describes let hoisting in the context of ML. In general, using correctness preserving transformations as a compiler optimization [1, 2] is a well established technique and has received quite a bit of attention in the functional programming area. <p> Peyton Jones [25, 23, 24] also described a number of optimizations which are similar in spirit but have totally different aims. Appel [2] describes let hoisting in the context of ML. In general, using correctness preserving transformations as a compiler optimization <ref> [1, 2] </ref> is a well established technique and has received quite a bit of attention in the functional programming area. We have proposed a method for minimizing the cost of runtime type passing.
Reference: 3. <author> N. de Bruijn. </author> <title> A survey of the project AUTOMATH. In To H. </title> <editor> B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 579-606. </pages> <note> Edited by J. </note> <editor> P. Seldin and J. R. Hindley, </editor> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference: 4. <author> C. Flanagan, A. Sabry, B. F. Duba, and M. Felleisen. </author> <title> The essence of compiling with continuations. </title> <booktitle> In Proc. ACM SIGPLAN '93 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 237-247, </pages> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Throughout the paper we take a few liberties with the syntax: we allow ourselves infix operators, multiple definitions in a single let expression to abbreviate a sequence of nested let expressions, and term applications that are at times not in A-Normal form <ref> [4] </ref>. We also use indentation to indicate the nesting. 2.2 Informal description Before we move on to the formal description of the algorithm, we will present the basic ideas informally. Define the depth of a term in a program as the number of (value) abstractions within which it is nested. <p> The details of the translation are given in [29]. FLINT is based upon a predicative variant of the Girard-Reynolds polymorphic - calculus [5, 26], with the term language written in A-normal form <ref> [4] </ref>. It contains the following four syntactic classes: kinds (), constructors (), types () and terms (e), as shown in Figure 3. Here, kinds classify constructors, and types classify terms. Constructors of kind name monotypes. The monotypes are generated from variables, from Int, and through the ! constructor.
Reference: 5. <author> J. Y. Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieur. </title> <type> PhD thesis, </type> <institution> University of Paris VII, </institution> <year> 1972. </year>
Reference-contexts: 1 Introduction Modern compilers for ML-like polymorphic languages [16, 17] usually use variants of the Girard-Reynolds polymorphic -calculus <ref> [5, 26] </ref> as their intermediate language (IL). Implementation of these ILs often involves passing types explicitly as parameters [32, 31, 28] at runtime: each polymorphic type variable gets instantiated to the actual type through run-time type application. <p> The details of the translation are given in [29]. FLINT is based upon a predicative variant of the Girard-Reynolds polymorphic - calculus <ref> [5, 26] </ref>, with the term language written in A-normal form [4]. It contains the following four syntactic classes: kinds (), constructors (), types () and terms (e), as shown in Figure 3. Here, kinds classify constructors, and types classify terms. Constructors of kind name monotypes.
Reference: 6. <author> R. Harper and J. C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: We provide the implementation results at the end of this paper. 2 The Lifting Algorithm For Core-ML This section presents our optimal type lifting algorithm. We use an explicitly typed variant of the Core-ML calculus <ref> [6] </ref> (Figure 1) as the source and target languages. The type lifting algorithm (Figure. 2) is expressed as a type-directed program transformation that lifts all type applications to the top-level. 2.1 The language We use an explicitly typed variant of the Core-ML calculus [6] as our source and target languages. <p> explicitly typed variant of the Core-ML calculus <ref> [6] </ref> (Figure 1) as the source and target languages. The type lifting algorithm (Figure. 2) is expressed as a type-directed program transformation that lifts all type applications to the top-level. 2.1 The language We use an explicitly typed variant of the Core-ML calculus [6] as our source and target languages. The syntax is shown in Figure 1. The static and dynamic semantics are standard, and are given in the Appendix (Section 7). Here, terms e consist of identifiers (x), integer constants (i), function abstractions, function applications, and let expressions. <p> The speedups obtained in our method are comparable to the ones reported in his paper. Mark P. Jones [11] has worked on the related problem of optimising dictionary passing in the implementation of type classes. In their study of the type theory of Standard ML, Harper and Mitchell <ref> [6] </ref> argued that an explicitly typed interpretation of ML polymorphism has better semantic properties and scales more easily to cover the full language. The idea of passing types to polymorphic functions is exploited by Morrison et al. [19] in the implementation of Napier.
Reference: 7. <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 130-141, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Maintaining type information in this manner helps to ensure the correctness of a compiler. More importantly, it also enables many interesting optimizations and applications. For example, both pretty-printing and debugging on polymorphic values require complete type information at runtime. Intensional type analysis <ref> [7, 31, 27] </ref>, which is used by some compilers [31, 28] to support efficient data representation, also requires the propagation of type information into the target code. <p> The work of Ohori on compiling record operations [21] is similarly based on a type passing interpretation of polymor-phism. Jones [12] has proposed evidence passing|a general framework for passing data derived from types to "qualified" polymorphic operations. Harper and Morisett <ref> [7] </ref> proposed an alternative approach for compiling polymorphism where types are passed as arguments to polymorphic routines in order to determine the representation of an object.
Reference: 8. <author> P. Hudak, S. P. Jones, and P. W. et al. </author> <title> Report on the programming language Haskell, a non-strict, purely functional language version 1.2. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: Jones [11] has also worked on a similar problem related to dictionary passing in Haskell and Gofer. Type classes in these languages are implemented by passing dictionaries at runtime. Dictionaries are tuples of functions that implement the methods defined in a type class. Consider the following Haskell <ref> [8] </ref> example f :: Eq a =&gt; a -&gt; a -&gt; Bool f x y = ([x] == [y]) && ([y] == [x]) The actual type of f is Eq [a] ) a ! a ! Bool. Context reduction leads to the type specified in the example.
Reference: 9. <author> R. Hughes. </author> <title> The design and implementation of programming languages. </title> <type> PhD thesis, </type> <institution> Programming Research Group, Oxford University, Oxford, UK, </institution> <year> 1983. </year>
Reference-contexts: The lifting of type applications is similar in spirit to the hoisting of loop invariant expressions outside a loop. It could be considered as a special case of a fully lazy transformation <ref> [9, 24] </ref> with the maximal free subexpressions restricted to be type applications. However, the fully-lazy transformation as described in Peyton Jones [24] will not lift all type applications to the top level. <p> Many modern compilers like the FLINT/ML compiler [28], TIL [31] and the Glasgow Haskell compiler [22] use an explicitly typed language as the intermediate language for the compilation. Lambda lifting and full laziness are part of the folklore of functional programming. Hughes <ref> [9] </ref> showed that by doing lambda lifting in a particular way, full laziness can be preserved. Johnsson [10] describes different forms of lambda lifting and the pros and cons of each.
Reference: 10. <author> T. Johnsson. </author> <title> Lambda Lifting: Transforming Programs to Recursive Equations. </title> <booktitle> In The Second International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 190-203, </pages> <address> New York, </address> <month> September </month> <year> 1985. </year> <note> Springer-Verlag. </note>
Reference-contexts: One is the lifting of type applications and the other is the lifting of polymorphic function definitions. At first glance, the lifting of function definitions may seem similar to lambda lifting <ref> [10] </ref>. However the lifting in the two cases is different. Lambda lifting converts a program with local function definitions into a program with global function definitions whereas the lifting shown here preserves the nesting structure of the program. <p> Lambda lifting and full laziness are part of the folklore of functional programming. Hughes [9] showed that by doing lambda lifting in a particular way, full laziness can be preserved. Johnsson <ref> [10] </ref> describes different forms of lambda lifting and the pros and cons of each. Peyton Jones [25, 23, 24] also described a number of optimizations which are similar in spirit but have totally different aims. Appel [2] describes let hoisting in the context of ML.
Reference: 11. <author> M. P. Jones. </author> <title> Qualified Types: Theory and Practice. </title> <type> PhD thesis, </type> <institution> Oxford University Computing Laboratory, Oxford, </institution> <month> july </month> <year> 1992. </year> <note> Technical Monograph PRG-106. </note>
Reference-contexts: Our algorithm on the other hand is a source-to-source transformation. Moreover, Minamide's algorithm deals only with the Core-ML calculus whereas we have implemented our algorithm on the entire SML'97 language with higher-order modules. Jones <ref> [11] </ref> has also worked on a similar problem related to dictionary passing in Haskell and Gofer. Type classes in these languages are implemented by passing dictionaries at runtime. Dictionaries are tuples of functions that implement the methods defined in a type class. <p> This is repeated for all overloaded functions so that all dictionaries are constructed statically. But this approach does not work with separately compiled modules since f's type in other modules does not specify the dictionaries that are constructed inside it. In Gofer <ref> [11] </ref>, instance declarations are not used to simplify the context. Therefore the type of f in the above example would be Eq [a] ) a ! a ! Bool. Jones' optimisation of dictionary passing can now be performed in the presence of separately compiled modules. <p> He used the method in the implementation of the tag-free garbage collector. Minamide [18] proposes a refinement of Tolmach's method to eliminate runtime construction of type parameters. The speedups obtained in our method are comparable to the ones reported in his paper. Mark P. Jones <ref> [11] </ref> has worked on the related problem of optimising dictionary passing in the implementation of type classes.
Reference: 12. <author> M. P. Jones. </author> <title> A theory of qualified types. </title> <booktitle> In The 4th European Symposium on Programming, </booktitle> <pages> pages 287-306, </pages> <address> Berlin, </address> <month> February </month> <year> 1992. </year> <pages> Spinger-Verlag. </pages>
Reference-contexts: The transformation also does not rely on the value restriction for polymorphic definitions. However, he requires a more sophisticated type system to type-check his transformation; he uses a type system based on the qualified type system of Jones <ref> [12] </ref> and the implementation calculus for the compilation of polymorphic records of Ohori [21]. Our algorithm on the other hand is a source-to-source transformation. Moreover, Minamide's algorithm deals only with the Core-ML calculus whereas we have implemented our algorithm on the entire SML'97 language with higher-order modules. <p> The idea of passing types to polymorphic functions is exploited by Morrison et al. [19] in the implementation of Napier. The work of Ohori on compiling record operations [21] is similarly based on a type passing interpretation of polymor-phism. Jones <ref> [12] </ref> has proposed evidence passing|a general framework for passing data derived from types to "qualified" polymorphic operations. Harper and Morisett [7] proposed an alternative approach for compiling polymorphism where types are passed as arguments to polymorphic routines in order to determine the representation of an object.
Reference: 13. <author> M. P. Jones. </author> <title> Dictionary-free overloading by partial evaluation. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 107-117. </pages> <institution> University of Melbourne TR 94/9, </institution> <month> June </month> <year> 1994. </year>
Reference: 14. <author> X. Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 177-188, </pages> <address> New York, </address> <month> Jan </month> <year> 1992. </year> <note> ACM Press. Longer version available as INRIA Tech Report. </note>
Reference-contexts: The boxing interpretation of polymorphism which applies the appropriate coercions based on the type of an object was studied by Leroy <ref> [14] </ref> and Shao [27]. Many modern compilers like the FLINT/ML compiler [28], TIL [31] and the Glasgow Haskell compiler [22] use an explicitly typed language as the intermediate language for the compilation. Lambda lifting and full laziness are part of the folklore of functional programming.
Reference: 15. <author> X. Leroy and M. Mauny. </author> <title> Dynamics in ML. </title> <booktitle> In The Fifth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 406-426, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: Intensional type analysis [7, 31, 27], which is used by some compilers [31, 28] to support efficient data representation, also requires the propagation of type information into the target code. Run-time type information is also crucial to the implementation of tag-less garbage collection [32], pickling, and type dynamic <ref> [15] </ref>. ? This research was sponsored in part by the DARPA ITO under the title "Software Evolution using HOT Language Technology", DARPA Order No. D888, issued under Contract No. F30602-96-2-0232, and in part by an NSF CAREER Award CCR-9501624, and NSF Grant CCR-9633390.
Reference: 16. <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Modern compilers for ML-like polymorphic languages <ref> [16, 17] </ref> usually use variants of the Girard-Reynolds polymorphic -calculus [5, 26] as their intermediate language (IL). Implementation of these ILs often involves passing types explicitly as parameters [32, 31, 28] at runtime: each polymorphic type variable gets instantiated to the actual type through run-time type application. <p> Finally, following SML <ref> [17, 16] </ref>, polymorphic functions are not recursive. 2 This restriction is crucial to proving that all type applications can be lifted to the top level.
Reference: 17. <author> R. Milner, M. Tofte, R. Harper, and D. MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: 1 Introduction Modern compilers for ML-like polymorphic languages <ref> [16, 17] </ref> usually use variants of the Girard-Reynolds polymorphic -calculus [5, 26] as their intermediate language (IL). Implementation of these ILs often involves passing types explicitly as parameters [32, 31, 28] at runtime: each polymorphic type variable gets instantiated to the actual type through run-time type application. <p> Finally, following SML <ref> [17, 16] </ref>, polymorphic functions are not recursive. 2 This restriction is crucial to proving that all type applications can be lifted to the top level.
Reference: 18. <author> Y. Minamide. </author> <title> Full lifting of type parameters. </title> <type> Technical report, </type> <institution> RIMS, Kyoto University, </institution> <year> 1997. </year>
Reference-contexts: For example, Tolmach [32] implemented a tag-free garbage collector via explicit type passing; he reported that the memory allocated for type information sometimes exceeded the memory saved by the tag-free approach. Clearly, it is desirable to optimize the run-time type passing in polymorphic code <ref> [18] </ref>. In fact, a better goal would be to guarantee that explicit type passing never blows up the execution cost of a program. Consider the sample code below we took some liberties with the syntax by using an explicitly typed variant of the Core-ML. <p> However, the fully-lazy transformation as described in Peyton Jones [24] will not lift all type applications to the top level. Specifically, type applications of a polymorphic function that is defined inside other functions will not be lifted to the top level. Minamide <ref> [18] </ref> uses a different approach to solve this problem. He lifts the construction of type parameters from within a polymorphic function to the call sites of the function. This lifting is recursively propagated to the call sites at the top level. <p> He used the method in the implementation of the tag-free garbage collector. Minamide <ref> [18] </ref> proposes a refinement of Tolmach's method to eliminate runtime construction of type parameters. The speedups obtained in our method are comparable to the ones reported in his paper. Mark P. Jones [11] has worked on the related problem of optimising dictionary passing in the implementation of type classes.
Reference: 19. <author> R. Morrison, A. Dearle, R. C. H. Connor, and A. L. Brown. </author> <title> An ad hoc approach to the implementation of polymorphism. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 13(3), </volume> <month> July </month> <year> 1991. </year>
Reference-contexts: The idea of passing types to polymorphic functions is exploited by Morrison et al. <ref> [19] </ref> in the implementation of Napier. The work of Ohori on compiling record operations [21] is similarly based on a type passing interpretation of polymor-phism. Jones [12] has proposed evidence passing|a general framework for passing data derived from types to "qualified" polymorphic operations.
Reference: 20. <author> G. Nadathur. </author> <title> A notation for lambda terms II: Refinements and applications. </title> <type> Technical Report CS-1994-01, </type> <institution> Duke University, Durham, NC, </institution> <month> January </month> <year> 1994. </year>
Reference: 21. <author> A. Ohori. </author> <title> A compilation method for ML-style polymorphic record calculi. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <address> New York, Jan 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: However, he requires a more sophisticated type system to type-check his transformation; he uses a type system based on the qualified type system of Jones [12] and the implementation calculus for the compilation of polymorphic records of Ohori <ref> [21] </ref>. Our algorithm on the other hand is a source-to-source transformation. Moreover, Minamide's algorithm deals only with the Core-ML calculus whereas we have implemented our algorithm on the entire SML'97 language with higher-order modules. <p> The idea of passing types to polymorphic functions is exploited by Morrison et al. [19] in the implementation of Napier. The work of Ohori on compiling record operations <ref> [21] </ref> is similarly based on a type passing interpretation of polymor-phism. Jones [12] has proposed evidence passing|a general framework for passing data derived from types to "qualified" polymorphic operations.
Reference: 22. <author> S. Peyton Jones. </author> <title> Implementing lazy functional languages on stock hardware: </title> <journal> the Spineless Tagless G-machine. Journal of Functional Programming, </journal> <volume> 2(2) </volume> <pages> 127-202, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: The boxing interpretation of polymorphism which applies the appropriate coercions based on the type of an object was studied by Leroy [14] and Shao [27]. Many modern compilers like the FLINT/ML compiler [28], TIL [31] and the Glasgow Haskell compiler <ref> [22] </ref> use an explicitly typed language as the intermediate language for the compilation. Lambda lifting and full laziness are part of the folklore of functional programming. Hughes [9] showed that by doing lambda lifting in a particular way, full laziness can be preserved.
Reference: 23. <author> S. Peyton Jones. </author> <title> Compiling haskell by program transformation: a report from trenches. </title> <booktitle> In Proceedings of the European Symposium on Programming, </booktitle> <address> Linkoping, </address> <month> April </month> <year> 1996. </year>
Reference-contexts: Lambda lifting and full laziness are part of the folklore of functional programming. Hughes [9] showed that by doing lambda lifting in a particular way, full laziness can be preserved. Johnsson [10] describes different forms of lambda lifting and the pros and cons of each. Peyton Jones <ref> [25, 23, 24] </ref> also described a number of optimizations which are similar in spirit but have totally different aims. Appel [2] describes let hoisting in the context of ML.
Reference: 24. <author> S. Peyton Jones and D. Lester. </author> <title> A modular fully-lazy lambda lifter in haskell. </title> <journal> Software Practice and Experience, </journal> <volume> 21 </volume> <pages> 479-506, </pages> <year> 1991. </year>
Reference-contexts: The lifting of type applications is similar in spirit to the hoisting of loop invariant expressions outside a loop. It could be considered as a special case of a fully lazy transformation <ref> [9, 24] </ref> with the maximal free subexpressions restricted to be type applications. However, the fully-lazy transformation as described in Peyton Jones [24] will not lift all type applications to the top level. <p> It could be considered as a special case of a fully lazy transformation [9, 24] with the maximal free subexpressions restricted to be type applications. However, the fully-lazy transformation as described in Peyton Jones <ref> [24] </ref> will not lift all type applications to the top level. Specifically, type applications of a polymorphic function that is defined inside other functions will not be lifted to the top level. Minamide [18] uses a different approach to solve this problem. <p> Lambda lifting and full laziness are part of the folklore of functional programming. Hughes [9] showed that by doing lambda lifting in a particular way, full laziness can be preserved. Johnsson [10] describes different forms of lambda lifting and the pros and cons of each. Peyton Jones <ref> [25, 23, 24] </ref> also described a number of optimizations which are similar in spirit but have totally different aims. Appel [2] describes let hoisting in the context of ML.
Reference: 25. <author> S. Peyton Jones, W. Partain, and A. Santos. Let-floating: </author> <title> moving bindings to give faster programs. </title> <booktitle> In Proc. International Conference on Functional Programming (ICFP'96), </booktitle> <address> New York, June 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Lambda lifting and full laziness are part of the folklore of functional programming. Hughes [9] showed that by doing lambda lifting in a particular way, full laziness can be preserved. Johnsson [10] describes different forms of lambda lifting and the pros and cons of each. Peyton Jones <ref> [25, 23, 24] </ref> also described a number of optimizations which are similar in spirit but have totally different aims. Appel [2] describes let hoisting in the context of ML.
Reference: 26. <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proceedings, Colloque sur la Programmation, Lecture Notes in Computer Science, </booktitle> <volume> volume 19, </volume> <pages> pages 408-425. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1974. </year>
Reference-contexts: 1 Introduction Modern compilers for ML-like polymorphic languages [16, 17] usually use variants of the Girard-Reynolds polymorphic -calculus <ref> [5, 26] </ref> as their intermediate language (IL). Implementation of these ILs often involves passing types explicitly as parameters [32, 31, 28] at runtime: each polymorphic type variable gets instantiated to the actual type through run-time type application. <p> The details of the translation are given in [29]. FLINT is based upon a predicative variant of the Girard-Reynolds polymorphic - calculus <ref> [5, 26] </ref>, with the term language written in A-normal form [4]. It contains the following four syntactic classes: kinds (), constructors (), types () and terms (e), as shown in Figure 3. Here, kinds classify constructors, and types classify terms. Constructors of kind name monotypes.
Reference: 27. <author> Z. Shao. </author> <title> Flexible representation analysis. </title> <booktitle> In Proc. 1997 ACM SIGPLAN International Conference on Functional Programming (ICFP'97), </booktitle> <pages> pages 85-98. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: Maintaining type information in this manner helps to ensure the correctness of a compiler. More importantly, it also enables many interesting optimizations and applications. For example, both pretty-printing and debugging on polymorphic values require complete type information at runtime. Intensional type analysis <ref> [7, 31, 27] </ref>, which is used by some compilers [31, 28] to support efficient data representation, also requires the propagation of type information into the target code. <p> The boxing interpretation of polymorphism which applies the appropriate coercions based on the type of an object was studied by Leroy [14] and Shao <ref> [27] </ref>. Many modern compilers like the FLINT/ML compiler [28], TIL [31] and the Glasgow Haskell compiler [22] use an explicitly typed language as the intermediate language for the compilation. Lambda lifting and full laziness are part of the folklore of functional programming.
Reference: 28. <author> Z. Shao. </author> <title> An overview of the FLINT/ML compiler. </title> <booktitle> In Proc. 1997 ACM SIGPLAN Workshop on Types in Compilation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: 1 Introduction Modern compilers for ML-like polymorphic languages [16, 17] usually use variants of the Girard-Reynolds polymorphic -calculus [5, 26] as their intermediate language (IL). Implementation of these ILs often involves passing types explicitly as parameters <ref> [32, 31, 28] </ref> at runtime: each polymorphic type variable gets instantiated to the actual type through run-time type application. Maintaining type information in this manner helps to ensure the correctness of a compiler. More importantly, it also enables many interesting optimizations and applications. <p> More importantly, it also enables many interesting optimizations and applications. For example, both pretty-printing and debugging on polymorphic values require complete type information at runtime. Intensional type analysis [7, 31, 27], which is used by some compilers <ref> [31, 28] </ref> to support efficient data representation, also requires the propagation of type information into the target code. <p> This in turn will allow us to use a more sophisticated runtime type representation and make greater use of type information at runtime. We describe the algorithm in later sections and also prove that it is both type-preserving and semantically sound. We have implemented it in the FLINT/ML compiler <ref> [28] </ref> and tested it on a few benchmarks. We provide the implementation results at the end of this paper. 2 The Lifting Algorithm For Core-ML This section presents our optimal type lifting algorithm. <p> The boxing interpretation of polymorphism which applies the appropriate coercions based on the type of an object was studied by Leroy [14] and Shao [27]. Many modern compilers like the FLINT/ML compiler <ref> [28] </ref>, TIL [31] and the Glasgow Haskell compiler [22] use an explicitly typed language as the intermediate language for the compilation. Lambda lifting and full laziness are part of the folklore of functional programming.
Reference: 29. <author> Z. Shao. </author> <title> Typed cross-module compilation. </title> <type> Technical Report YALEU/DCS/RR-1126, </type> <institution> Dept. of Computer Science, Yale University, </institution> <address> New Haven, CT, </address> <month> November </month> <year> 1997. </year>
Reference-contexts: But what happens when we take into account the module language as well? To handle the Full-ML langauge, we compile the source code into the FLINT intermediate language. The details of the translation are given in <ref> [29] </ref>. FLINT is based upon a predicative variant of the Girard-Reynolds polymorphic - calculus [5, 26], with the term language written in A-normal form [4]. It contains the following four syntactic classes: kinds (), constructors (), types () and terms (e), as shown in Figure 3. <p> Syntax of the Core-FLINT calculus In ML, structures are the basic module unit and functors abstract over structures. Polymorphic functions may now escape as part of structures and get initialized later at a functor application site. In the FLINT translation <ref> [29] </ref>, func-tors are represented as a polymorphic definition combined with a polymorphic abstraction (fct = flt i :: k i : m x : :e). The variable x in the functor definition is polymorphic since the parameterised structure may contain polymorphic components.
Reference: 30. <author> Z. Shao and A. W. Appel. </author> <title> A type-based compiler for Standard ML. </title> <booktitle> In Proc. ACM SIGPLAN '95 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 116-129. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference: 31. <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In Proc. ACM SIGPLAN '96 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 181-192. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Modern compilers for ML-like polymorphic languages [16, 17] usually use variants of the Girard-Reynolds polymorphic -calculus [5, 26] as their intermediate language (IL). Implementation of these ILs often involves passing types explicitly as parameters <ref> [32, 31, 28] </ref> at runtime: each polymorphic type variable gets instantiated to the actual type through run-time type application. Maintaining type information in this manner helps to ensure the correctness of a compiler. More importantly, it also enables many interesting optimizations and applications. <p> Maintaining type information in this manner helps to ensure the correctness of a compiler. More importantly, it also enables many interesting optimizations and applications. For example, both pretty-printing and debugging on polymorphic values require complete type information at runtime. Intensional type analysis <ref> [7, 31, 27] </ref>, which is used by some compilers [31, 28] to support efficient data representation, also requires the propagation of type information into the target code. <p> More importantly, it also enables many interesting optimizations and applications. For example, both pretty-printing and debugging on polymorphic values require complete type information at runtime. Intensional type analysis [7, 31, 27], which is used by some compilers <ref> [31, 28] </ref> to support efficient data representation, also requires the propagation of type information into the target code. <p> The boxing interpretation of polymorphism which applies the appropriate coercions based on the type of an object was studied by Leroy [14] and Shao [27]. Many modern compilers like the FLINT/ML compiler [28], TIL <ref> [31] </ref> and the Glasgow Haskell compiler [22] use an explicitly typed language as the intermediate language for the compilation. Lambda lifting and full laziness are part of the folklore of functional programming. Hughes [9] showed that by doing lambda lifting in a particular way, full laziness can be preserved.
Reference: 32. <author> A. Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proc. 1994 ACM Conf. on Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <address> New York, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction Modern compilers for ML-like polymorphic languages [16, 17] usually use variants of the Girard-Reynolds polymorphic -calculus [5, 26] as their intermediate language (IL). Implementation of these ILs often involves passing types explicitly as parameters <ref> [32, 31, 28] </ref> at runtime: each polymorphic type variable gets instantiated to the actual type through run-time type application. Maintaining type information in this manner helps to ensure the correctness of a compiler. More importantly, it also enables many interesting optimizations and applications. <p> Intensional type analysis [7, 31, 27], which is used by some compilers [31, 28] to support efficient data representation, also requires the propagation of type information into the target code. Run-time type information is also crucial to the implementation of tag-less garbage collection <ref> [32] </ref>, pickling, and type dynamic [15]. ? This research was sponsored in part by the DARPA ITO under the title "Software Evolution using HOT Language Technology", DARPA Order No. D888, issued under Contract No. F30602-96-2-0232, and in part by an NSF CAREER Award CCR-9501624, and NSF Grant CCR-9633390. <p> Government. However, the advantages of runtime type passing do not come for free. De--pending on the sophistication of the type representation, run-time type passing can add a significant overhead to the time and space usage of a program. For example, Tolmach <ref> [32] </ref> implemented a tag-free garbage collector via explicit type passing; he reported that the memory allocated for type information sometimes exceeded the memory saved by the tag-free approach. Clearly, it is desirable to optimize the run-time type passing in polymorphic code [18]. <p> abstracted variables have to be adjusted.) The implementation also optimises the number of variables abstracted while lifting a definition it remembers the depth at which a variable is defined so that variables that will still remain in scope after the lifting are not abstracted. 5 Related Work and Conclusions Tolmach <ref> [32] </ref> has worked on a similar problem and proposed a method based on the lazy substitution on types. He used the method in the implementation of the tag-free garbage collector. Minamide [18] proposes a refinement of Tolmach's method to eliminate runtime construction of type parameters.

References-found: 32

