URL: http://arthur.cs.uni-bonn.de/praktika_help/rules.ps
Refering-URL: http://arthur.cs.uni-bonn.de/praktika_help/programmierung.html
Root-URL: http://cs.uni-bonn.de
Phone: 125 25  Tel: int 46 8 727 30 00  
Author: M Uen FN/Erik Nyquist Mats Henricson FN/Mats Henricson and Erik Nyquist 
Degree: Author  Approved by  
Address: Box 1505  Sweden  
Affiliation: Ellemtel Telecommunication Systems Laboratories  lvsj  
Note: 1(88) Document Name DESCRIPTION Page Date Rev. C Document No.  Title Programming in C++, Rules and Recommendations Belongs to Programming in C++ Rules and Recommendations Copyright (C) 1990-1992 by  Permission is granted to any individual or institution to use, copy, modify, and distribute this document, provided that this complete copyright and permission notice is maintained intact in all copies. Ellemtel Telecommunication Systems Laboratories makes no representations about the suitability of this document or the examples described herein for any purpose. It is provided as is without any expressed or implied warranty. Original translation from Swedish by Joseph Supanich  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> The Annotated C++ Reference Manual Bjarne Stroustrup/Margareth Ellis[ARM] Addison Wesley 1990, </author> <title> ISBN 0-201-51459-1 This book forms the basis of the work in the ANSI-C++ committee. </title>
Reference-contexts: See, for example, page 25 in ref. <ref> [1] </ref>: The Annotated C++ Reference Manual Bjarne Stroustrup/Margareth Ellis [ARM]. 31 (88) Document Name DESCRIPTION Page Date Rev. C Document No. <p> C Document No. M 90 0118 Uen Example 54 For more efficient execution, remove const-ness when storing intermediate results // This is code is NOT recommended #include &lt;math.h&gt; class Vector - public: Vector (int, const int []); // Constructor double length () const; // length = sqrt (array <ref> [1] </ref>*array [1] + ... ) void set (int x, int value); // ... private: int size; int* array; double lengthCache; // to cache calculated length int hasChanged; // is it necessary to re-calculate length ? -; double Vector::length () const - if (hasChanged) // Do we need to re-calculate length - ((Vector*)this)-&gt;hasChanged=0; <p> M 90 0118 Uen Example 55 Alternative to removing const-ness for more efficient execution // This is code is safer than Example 54 but could be inefficient #include &lt;math.h&gt; class Vector - public: Vector (int, const int []); // Constructor double length () const; // length = sqrt (array <ref> [1] </ref>*array [1] + ... ) void set (int x, int value); // ... private: int size; int* array; double* lengthCache; // to cache length in int* hasChanged; // is it necessary to re-calculate length ? -; Vector::Vector (int sizeA, const int arrayA []) : size (sizeA), array ( new int [sizeA] ),
Reference: [2] <editor> C++ Primer, Second Edition Stanley B. Lippman Addison Wesley 1991, </editor> <title> ISBN 0-201-54848-8 Very good for learning the basics of C++. </title>
Reference-contexts: inline Buffer::Buffer ( char* cp ) - strncpy ( buffer , cp , sizeof ( buffer ) ); - main () - const Buffer cfoo = "peter"; // This is a constant buffer Buffer foo = "mary"; // This buffer can change foo <ref> [2] </ref>=c; // calls char& Buffer::operator [](unsigned) cfoo [2] = c // ERROR: cfoo [2] is not an lvalue. // cfoo [2] means that Buffer::operator [](unsigned) const is called. cout &lt;< cfoo [2] << ":" << foo [2] << endl; // OK! Only rvalues are needed foo.get () = cfoo.get (); cfoo.get () = foo.get (); // ERROR: cfoo.get <p> - strncpy ( buffer , cp , sizeof ( buffer ) ); - main () - const Buffer cfoo = "peter"; // This is a constant buffer Buffer foo = "mary"; // This buffer can change foo <ref> [2] </ref>=c; // calls char& Buffer::operator [](unsigned) cfoo [2] = c // ERROR: cfoo [2] is not an lvalue. // cfoo [2] means that Buffer::operator [](unsigned) const is called. cout &lt;< cfoo [2] << ":" << foo [2] << endl; // OK! Only rvalues are needed foo.get () = cfoo.get (); cfoo.get () = foo.get (); // ERROR: cfoo.get () is not an lvalue - <p> sizeof ( buffer ) ); - main () - const Buffer cfoo = "peter"; // This is a constant buffer Buffer foo = "mary"; // This buffer can change foo <ref> [2] </ref>=c; // calls char& Buffer::operator [](unsigned) cfoo [2] = c // ERROR: cfoo [2] is not an lvalue. // cfoo [2] means that Buffer::operator [](unsigned) const is called. cout &lt;< cfoo [2] << ":" << foo [2] << endl; // OK! Only rvalues are needed foo.get () = cfoo.get (); cfoo.get () = foo.get (); // ERROR: cfoo.get () is not an lvalue - 32 (88) Document Name DESCRIPTION Page Date <p> cfoo = "peter"; // This is a constant buffer Buffer foo = "mary"; // This buffer can change foo <ref> [2] </ref>=c; // calls char& Buffer::operator [](unsigned) cfoo [2] = c // ERROR: cfoo [2] is not an lvalue. // cfoo [2] means that Buffer::operator [](unsigned) const is called. cout &lt;< cfoo [2] << ":" << foo [2] << endl; // OK! Only rvalues are needed foo.get () = cfoo.get (); cfoo.get () = foo.get (); // ERROR: cfoo.get () is not an lvalue - 32 (88) Document Name DESCRIPTION Page Date Rev. C Document No. <p> is a constant buffer Buffer foo = "mary"; // This buffer can change foo <ref> [2] </ref>=c; // calls char& Buffer::operator [](unsigned) cfoo [2] = c // ERROR: cfoo [2] is not an lvalue. // cfoo [2] means that Buffer::operator [](unsigned) const is called. cout &lt;< cfoo [2] << ":" << foo [2] << endl; // OK! Only rvalues are needed foo.get () = cfoo.get (); cfoo.get () = foo.get (); // ERROR: cfoo.get () is not an lvalue - 32 (88) Document Name DESCRIPTION Page Date Rev. C Document No.
Reference: [3] <institution> The C++ Programming Language, </institution> <note> Second Edition Bjarne Stroustrup Addison Wesley 1991, ISBN 0-201-53992-6 This second edition has been completely updated with the current (and future) language definition. It will most certainly become a standard reference book. </note>
Reference-contexts: This example is, in part, taken from <ref> [3] </ref>: The C++ Programming Language, Second Edition Bjarne Stroustrup. 56 (88) Document Name DESCRIPTION Page Date Rev. C Document No.
Reference: [4] <author> Advanced C++ Programming Styles and Idioms James O. </author> <title> Coplien Addison Wesley 1992, ISBN 0-210-54855-0 Possibly the most advanced book on how to use C++. Contains many tricks and tips. </title>
Reference: [5] <author> Object-oriented Software Construction Bertrand Meyer Prentice Hall 1988, </author> <title> ISBN 0-13-629049-3 or 0-13-629031-0 PBK Somewhat of a classic work. Examples are written in Eiffel. </title>
Reference: [6] <editor> Data Abstraction and Object-Oriented Programming in C++ Keith E. Gorlen, Sanford M. Orlow, Perry S. Plexico John Wiley & Sons 1990, </editor> <title> ISBN 0 471 92346 X pbk or 0 471 92751 1 The book that describes the class library NIH. Includes many good examples. </title>
Reference: [7] <author> Object-Oriented Design with Applications Grady Booch Benjamin/Cummings 1991, </author> <title> ISBN 0-8053-0091-0 Treats the design and implementation of software in various object-oriented languages. 82(88) Document Name DESCRIPTION Page Date Rev. C Document No. </title> <address> M 90 0118 Uen </address>
Reference: [8] <institution> Recommended C Style and Coding Standards Bell Labs, Zoology Computer Systems University of Toronto, CS University of Washington, </institution> <month> November 18, </month> <year> 1989. </year> <title> A collection of rules for programming in C. Contains a good section on portability. </title>
Reference: [9] <editor> A Guide to Natural Naming Daniel Keller ETH, Projekt-Zentrum IDA, CH-8092 Zurich, </editor> <title> Switzerland A guide on how to choose good names for functions and variables. Not adapted to object-oriented programming. </title>
Reference: [10] <author> Advanced C++ Jonathan E. </author> <note> Shopiro Binder with material from course held in Lund (Sweden) from June 4 to June 7, 1991. Filled with warnings and tips. </note>
Reference-contexts: inside next case - case B: - // Do something else break; // Now we leave the switch-statement - default: - // If no match in above cases, this is executed exit ( 1 ); - Example 59 Good and bad ways of setting limits for loop variables int a <ref> [10] </ref>; int nine = 9; // Good way to do it: for ( int i = 0; i &lt; ten; i++ ) // Loop runs 10-0=10 times - - for ( int j = 0; j &lt;= nine; j++ ) // Loop runs 10 times, but 9-0=9 !!! - - 68 <p> Example 64 Right and wrong ways to invoke delete for arrays with destructors int n = 7; T* myT = new T [n]; // T is a type with defined constructors and destructors // ... delete myT; // No! Destructor only called for first object in array a delete <ref> [10] </ref> myT; // No! Destructor called on memory out of bounds in array a delete [] myT; // OK, and always safe! Example 65 Dangerous memory management String myFunc ( const char* myArgument ) - String* temp = new String ( myArgument ); return *temp; // temp is never deallocated and
Reference: [11] <institution> Objektorienterad programmering och biblioteksuppbyggnad i C++ Martin Carrol Material from course held in Stockholm (Sweden) on April 18, </institution> <year> 1991. </year> <title> Presents useful viewpoints on problems which may arise when designing a class library. </title>
Reference: [12] <editor> Automatic Detection of C++ Programming Errors: </editor> <title> Initial Thoughts on a lint++ Scott Myers/Moises Lejter Usenix C++ Conference Proceedings, Spring 91 Article which describes some programming rules for C++. </title>

References-found: 12

