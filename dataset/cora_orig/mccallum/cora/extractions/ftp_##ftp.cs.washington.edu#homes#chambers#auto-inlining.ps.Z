URL: ftp://ftp.cs.washington.edu/homes/chambers/auto-inlining.ps.Z
Refering-URL: http://www.cs.washington.edu/research/projects/cecil/www/Papers/auto-inlining.html
Root-URL: 
Title: Towards Better Inlining Decisions Using Inlining Trials prohibitively. Inlining should only be applied where the
Author: Jeffrey Dean and Craig Chambers 
Affiliation: Department of Computer Science and Engineering University of Washington  
Date: June, 1994.  
Note: To appear in 1994 ACM Conference on LISP and Functional Programming, Orlando, FL,  without any hardwired operations or  
Abstract: In many systems, the profitability of inlining a particular routine is hardwired into the compiler . For example, the Smalltalk-80 compiler hard-wires the definition and optimized implementation of several basic functions from its standard library , and the Haskell standard prelude is fixed so that compilers can implement the functions in the standard library more efficiently [Hudak et al. 90]. A drawback of the hard-wiring approach is that built-in routines usually run much faster than user defined routines, discouraging programmers from defining and using their own abstractions. Other systems, including C++, Modula- 3, T Scheme, SchemeXerox, Common Lisp, Similix, and Schism [Stroustrup 91, Nelson 91, Slade 87, Adams et al. 93, Steele 90], allow programmers to indicate explicitly which routines are profitable to inline. While granting programmers fine control over the compilation process, this approach requires programmers to have a fair understanding of the languages implementation issues (an assumption becoming less likely as implementations become more sophisticated) and can be tedious if inlining must be applied heavily to get good performance. Additionally, most explicit declaration-based mechanisms do not allow programmers to specify that inlining is profitable only in certain contexts, or that inlining should only take place at particular high-frequency calls of some routine. Our research investigates techniques for automatically deciding when inlining is profitable. Making good inlining decisions depends crucially on accurately assessing the costs and benefits of inlining. Previous automatic decision makers used simple techniques for estimating costs based on an examination of the tar get routine s source code (or unoptimized intermediate code), and consequently they failed to take into account the ef fect of post-inlining optimization of the target routine. Our work corrects this deficiency, leading to more accurate cost and benefit estimates and therefore better inlining decisions. Our system assesses the costs and benefits of inlining by first experimentally inlining the tar get routine, in the process measuring the actual costs and benefits of that particular inline-expansion, and then amortizing the cost of the experiment (called an inlining trial) across future calls to that routine by storing the results of the trial in a persistent database. Because the indirect costs and benefits of inlining can depend greatly on the amount of the static information available at the call site (e.g., the static value or class of an argument), our system performs type group analysis to determine the amount of available callsite-specific static information that was exploited during optimization. Each database entry is guarded with type group information, restricting reuse of the information derived from an inlining trial to those call sites that would generate substantially the same compiled code. We implemented and measured this approach in the context of an optimizing compiler for S ELF [Ungar & Smith 87, Chambers & Ungar 91], a pure objectoriented language similar to Smalltalk but Inlining trials are a general mechanism for making better automatic decisions about whether a routine is profitable to inline. Unlike standard source-level inlining heuristics, an inlining trial captures the effects of optimizations applied to the body of the inlined routine when calculating the costs and benefits of inlining. The results of inlining trials are stored in a persistent database to be reused when making future inlining decisions at similar call sites. T ype group analysis can determine the amount of available static information exploited during compilation, and the results of analyzing the compilation of an inlined routine help decide when a future call site would lead to substantially the same generated code as a given inlining trial. W e have implemented inlining trials and type group analysis in an optimizing compiler for S ELF, and by making wiser inlining decisions we were able to cut compilation time and compiled code space with virtually no loss of execution speed. We believe that inlining trials and type group analysis could be applied effectively to many high-level languages where procedural or functional abstraction is used heavily. 
Abstract-found: 1
Intro-found: 1
Reference: [Adams et al. 93] <author> Norman Adams, Pavel Curtis, and Mike Spreitzer. </author> <title> First-Class Data-Type Representations in SchemeXerox. </title> <booktitle> In Proceedings of the SIGPLAN 93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 139-146, </pages> <address> Albuquerque, NM, </address> <month> June, </month> <year> 1993. </year> <note> Published as SIGPLAN Notices 28(6), </note> <month> June, </month> <year> 1993. </year>
Reference-contexts: Functional languages such as Scheme and ML [Rees & Clinger 86, Milneret al. 90], pure objectoriented languages such as Smalltalk and Eif fel [Goldberg & Robson 83, Meyer 92], and reective systems such as CLOS and SchemeXerox <ref> [Bobrow et al. 88, Adams et al. 93] </ref> encourage programmers to write general, reusable routines and solve problems by composing existing functionality , leading to programs with very high call frequencies.
Reference: [Allen & Johnson 88] <author> Randy Allen and Steve Johnson. </author> <title> Compiling C for Vectorization, Parallelization, and Inline Expansion. </title> <booktitle> In Proceedings of the SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 241-249, </pages> <address> Atlanta, GA, </address> <month> June, </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(7), </note> <month> July, </month> <year> 1988. </year>
Reference-contexts: programs in succession (1275) is only half of the sum of the number of entries generated by compiling each program separately (2612). 6 Related Work Previous work on automatic inlining has focused primarily on attempting to maximize the direct benefits of inlining without too much increase in compiled code space <ref> [Scheier 77, Allen & Johnson 88, Chang et al. 92] </ref>. In the context of this related work, indirect benefits of inlining tend to be relatively unimportant.
Reference: [Bobrow et al. 88] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. E. Keene, G. Kiczales, D. A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <journal> In SIGPLAN Notices 23(Special Issue), </journal> <month> September, </month> <year> 1988. </year>
Reference-contexts: Functional languages such as Scheme and ML [Rees & Clinger 86, Milneret al. 90], pure objectoriented languages such as Smalltalk and Eif fel [Goldberg & Robson 83, Meyer 92], and reective systems such as CLOS and SchemeXerox <ref> [Bobrow et al. 88, Adams et al. 93] </ref> encourage programmers to write general, reusable routines and solve problems by composing existing functionality , leading to programs with very high call frequencies.
Reference: [Bondorf 91] <author> Anders Bondorf. </author> <title> Similix Manual, System Version 4.0. </title> <type> Technical report, </type> <institution> DIKU, University of Copenhagen, Copenhagen, Denmark, </institution> <year> 1991. </year>
Reference-contexts: Compilers and partial evaluators, such as Similix and Schism <ref> [Bondorf 91, Consel 90] </ref>, can exploit inlining to reduce the cost of these abstraction mechanisms and thereby foster better programming styles.
Reference: [Chambers & Ungar 90] <author> Craig Chambers and David Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <booktitle> In Proceedings of the SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 150-164, </pages> <address> White Plains, NY, </address> <month> June, </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(6), </note> <month> June, </month> <year> 1990. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference: [Chambers & Ungar 91] <author> Craig Chambers and David Ungar. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(10), </note> <month> October, </month> <year> 1991. </year>
Reference: [Chambers 92] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <type> technical report STAN-CS-92-1420, </type> <month> March, </month> <year> 1992. </year>
Reference-contexts: For example, the original S ELF compiler counts the number of message sends in the candidate routine and inlines the routine if this number is below some threshold <ref> [Chambers 92] </ref>. The GNU gcc C compiler inlines a routine only if the number of instructions in its RTL (register transfer language) representation is less than some threshold [Stallman 90].
Reference: [Chambers et al. 93] <author> Craig Chambers, Jeffrey Dean, Dave Grove, and Charlie Garrett. </author> <title> Analysis and Optimization of Object-Oriented Languages. </title> <type> Unpublished manuscript, </type> <month> October, </month> <year> 1993. </year>
Reference: [Chang et al. 92] <author> Pohua P. Chang, Scott A. Mahlke, William Y. Chen, and Wen-Mei W. Hwu. </author> <title> Profile-Guided Automatic Inline Expansion for C Programs. </title> <booktitle> In SoftwarePractice and Experience 22(5), </booktitle> <pages> pp. 349-369, </pages> <month> May, </month> <year> 1992. </year>
Reference-contexts: By assessing costs and benefits of inlining on the routine after optimization, inlining trials are much less sensitive to superficial details of the source code and can adapt as the source code evolves. The Impact C compiler uses profile information to help guide the inlining process <ref> [Chang et al. 92] </ref>. The profile information is used to weight arcs in the program s call graph, allowing the cost/benefit estimates to be weighted by the expected execution frequency , and leading to better inlining decisions. <p> programs in succession (1275) is only half of the sum of the number of entries generated by compiling each program separately (2612). 6 Related Work Previous work on automatic inlining has focused primarily on attempting to maximize the direct benefits of inlining without too much increase in compiled code space <ref> [Scheier 77, Allen & Johnson 88, Chang et al. 92] </ref>. In the context of this related work, indirect benefits of inlining tend to be relatively unimportant.
Reference: [Chien et al. 93] <author> Andrew A. Chien, Vijay Karamcheti, John Plevyak. </author> <title> The Concert System: Compiler and Runtime Support for Efficient, Fine-Grained Concurrent Object-Oriented Programs. </title> <type> Technical report R-93-1815, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <year> 1993. </year>
Reference-contexts: For these programs, the current SELF compiler is unable to statically bind many messages because of a lack of static type information. Future compilers for S ELF and other objectoriented languages <ref> [Chien et al. 93, Hlzle & Ungar 93, Chamberset al. 93] </ref> are expected to incorporate interprocedural type analysis and extract type information from execution profiles, leading to many more messages being statically bound and thus eligible for inlining.
Reference: [Consel 90] <author> Charles Consel. </author> <title> The Schism Manual, </title> <type> Version 1.0. </type> <institution> Yale University, </institution> <address> New Haven, CT, </address> <month> December, </month> <year> 1990. </year>
Reference-contexts: Compilers and partial evaluators, such as Similix and Schism <ref> [Bondorf 91, Consel 90] </ref>, can exploit inlining to reduce the cost of these abstraction mechanisms and thereby foster better programming styles.
Reference: [Cooper et al. 92] <author> Keith D. Cooper, Mary W. Hall, and Ken Kennedy. </author> <title> Procedure Cloning. </title> <booktitle> In Proceeding of the 1992 IEEE International Conference on Computer Languages, </booktitle> <pages> pp. 96-105, </pages> <address> Oakland, CA, </address> <month> April, </month> <year> 1992. </year>
Reference-contexts: Our type group analysis computes similar summary information about argument types, although the details of the two analyses differ. Cooper, Hall, and Kennedy present a technique for identifying when creating multiple, specialized copies of a procedure can enable optimizations <ref> [Cooper et al. 92] </ref>. They apply this algorithm to the interprocedural constant propagation problem. To reduce the number of specialized copies of a procedure, their system evaluates when merging two specialized versions of a procedure would not sacrifice an important optimization.
Reference: [Dean & Chambers 93] <author> Jeffrey Dean and Craig Chambers. </author> <title> Training Compilers to Make Better Inlining Decisions. </title> <type> Technical report 93-05-05. </type> <institution> Department of Computer Science & Engineering, University of Washington, </institution> <address> Seattle, WA, </address> <month> May, </month> <year> 1993. </year>
Reference-contexts: This calculation is mostly straightforward, using standard compiler static estimates for execution frequency . (Due to space constraints, some of the subtleties involved with this calculation are relegated to a separate technical report <ref> [Dean & Chambers 93] </ref>.) To determine the execution time saved as a result of inlining, the compiler monitors each optimization performed on the body of the inlined routine and estimates the number of dynamic machine instructions skipped as a result of the optimization, weighted by expected execution frequency. <p> Further details of type group analysis and its implementation in the S ELF compiler can be found in a separate technical report <ref> [Dean & Chambers 93] </ref>. 4.3 An Example We will use the following inlining candidate to illustrate how type analysis and type group analysis interact: method growable_sequence::fetch (index) - if index &lt; 0 or index &gt; self.max_index then error (index out of bounds) endif return self.elems [index + self.base_index] - ... seq.fetch
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: Inlining has long been applied to languages like C and Fortran, but it may be even more beneficial in the context of higher level languages. Functional languages such as Scheme and ML [Rees & Clinger 86, Milneret al. 90], pure objectoriented languages such as Smalltalk and Eif fel <ref> [Goldberg & Robson 83, Meyer 92] </ref>, and reective systems such as CLOS and SchemeXerox [Bobrow et al. 88, Adams et al. 93] encourage programmers to write general, reusable routines and solve problems by composing existing functionality , leading to programs with very high call frequencies.
Reference: [Hall & Kennedy 92] <author> Mary W. Hall and Ken Kennedy. </author> <title> Efficient Call Graph Analysis. </title> <booktitle> In ACM Letters on Programming Languages and Systems 1(3), </booktitle> <pages> pp. 227-242, </pages> <month> September, </month> <year> 1992. </year>
Reference: [Hlzle & Ungar 93] <author> Urs Hlzle and David Ungar. </author> <title> Optimizing Dynamically-Dispatched Calls with Run-Time Type Feedback. </title> <type> Unpublished manuscript, </type> <year> 1993. </year>
Reference-contexts: For these programs, the current SELF compiler is unable to statically bind many messages because of a lack of static type information. Future compilers for S ELF and other objectoriented languages <ref> [Chien et al. 93, Hlzle & Ungar 93, Chamberset al. 93] </ref> are expected to incorporate interprocedural type analysis and extract type information from execution profiles, leading to many more messages being statically bound and thus eligible for inlining.
Reference: [Hudak et al. 92] <author> Paul Hudak, Simon Peyton Jones, Philip Wadler, Brian Boutel, Jon Fairbairn, Joseph Fasel, Mara M. Guzmn, Kevin Hammond, John Hughes, Thomas Johnsson, Dick Kieburtz, Rishiyur Nikhil, Will Partain, and John Peterson. </author> <title> Report on the Programming Language Haskell, Version 1.2. </title> <booktitle> In SIGPLAN Notices 27(5), </booktitle> <month> May, </month> <year> 1992. </year>
Reference: [Meyer 92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <address> New York, NY,1992. </address>
Reference-contexts: Inlining has long been applied to languages like C and Fortran, but it may be even more beneficial in the context of higher level languages. Functional languages such as Scheme and ML [Rees & Clinger 86, Milneret al. 90], pure objectoriented languages such as Smalltalk and Eif fel <ref> [Goldberg & Robson 83, Meyer 92] </ref>, and reective systems such as CLOS and SchemeXerox [Bobrow et al. 88, Adams et al. 93] encourage programmers to write general, reusable routines and solve problems by composing existing functionality , leading to programs with very high call frequencies.
Reference: [Milner et al. 90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference: [Nelson 91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference: [Palsberg & Schwartzbach 91] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-Oriented Type Inference. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 146-161, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(10), </note> <month> October, </month> <year> 1991. </year>
Reference: [Rees & Clinger 86] <editor> Jonathan Rees and William Clinger, editors. </editor> <title> Revised 3 Report on the Algorithmic Language Scheme. </title> <note> Published as SIGPLAN Notices 21(12), </note> <month> December, </month> <year> 1986. </year>
Reference-contexts: Inlining has long been applied to languages like C and Fortran, but it may be even more beneficial in the context of higher level languages. Functional languages such as Scheme and ML <ref> [Rees & Clinger 86, Milneret al. 90] </ref>, pure objectoriented languages such as Smalltalk and Eif fel [Goldberg & Robson 83, Meyer 92], and reective systems such as CLOS and SchemeXerox [Bobrow et al. 88, Adams et al. 93] encourage programmers to write general, reusable routines and solve problems by composing existing
Reference: [Ruf & Weise 91] <author> Erik Ruf and Daniel Weise. </author> <title> Using Types to Avoid Redundant Specialization. </title> <booktitle> In Proceedings of the PEPM 91 Symposium on Partial Evaluation and Semantics-Based Program Manipulations, </booktitle> <pages> pp. 321-333, </pages> <address> New Haven, CT, </address> <month> June, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(9), </note> <month> September, </month> <year> 1991. </year>
Reference-contexts: Additionally, in the context of higher-level languages, the indirect benefits of inlining often are more important in determining profitability than the simple direct costs. Ruf and W eise describe a technique for avoiding redundant specialization in a partial evaluator for Scheme <ref> [Ruf & Weise 91, Ruf & Weise 92] </ref>. When specializing a called routine using the static information available at a call site, their technique computes a generalization of the actual types that still leads to the same specialized version of the called routine.
Reference: [Ruf & Weise 92] <author> Erik Ruf and Daniel Weise. </author> <title> Avoiding Redundant Specialization During Partial Evaluation. </title> <type> Technical Report 92-518. </type> <institution> Department of Computer Science, Stanford University, Stanford, </institution> <address> CA, </address> <year> 1992. </year>
Reference-contexts: Additionally, in the context of higher-level languages, the indirect benefits of inlining often are more important in determining profitability than the simple direct costs. Ruf and W eise describe a technique for avoiding redundant specialization in a partial evaluator for Scheme <ref> [Ruf & Weise 91, Ruf & Weise 92] </ref>. When specializing a called routine using the static information available at a call site, their technique computes a generalization of the actual types that still leads to the same specialized version of the called routine.
Reference: [Scheier 77] <author> Robert W. Scheier. </author> <title> An Analysis of Inline Substitution for a Structured Programming Language. </title> <booktitle> In Communications of the ACM 20(9), </booktitle> <pages> pp. 647-654, </pages> <month> September, </month> <year> 1977. </year>
Reference-contexts: programs in succession (1275) is only half of the sum of the number of entries generated by compiling each program separately (2612). 6 Related Work Previous work on automatic inlining has focused primarily on attempting to maximize the direct benefits of inlining without too much increase in compiled code space <ref> [Scheier 77, Allen & Johnson 88, Chang et al. 92] </ref>. In the context of this related work, indirect benefits of inlining tend to be relatively unimportant.
Reference: [Shivers 88] <author> Olin Shivers. </author> <title> Control Flow Analysis in Scheme. </title> <booktitle> In Proceedings of the SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 164-174, </pages> <address> Atlanta, GA, </address> <month> June, </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(7), </note> <month> July, </month> <year> 1988. </year>
Reference: [Slade 87] <author> Stephen Slade. </author> <title> The T Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1987. </year>
Reference: [Stallman 90] <author> Richard M. Stallman. </author> <title> Using and Porting GNU gcc Version 2.0. Free Software Foundation, </title> <month> November, </month> <year> 1990. </year>
Reference-contexts: The GNU gcc C compiler inlines a routine only if the number of instructions in its RTL (register transfer language) representation is less than some threshold <ref> [Stallman 90] </ref>. Source-level heuristics suf fer from the problem that they do not consider the effect of optimizations applied to the body of the called routine after inlining, in particular those optimizations derived from static information available at the call site.
Reference: [Steele 90] <author> Guy L. Steele, Jr. </author> <title> Common Lisp: The Language, second edition. </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1990. </year>
Reference: [Stroustrup 91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language, second edition. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1991. </year>
Reference: [Ungar & Smith 87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 227-241, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991 </year> <month> 10 </month>
References-found: 31

