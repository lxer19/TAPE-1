URL: http://ftp.cs.indiana.edu/pub/stoller/FTRTFT98.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/stoller.html
Root-URL: http://www.cs.indiana.edu
Email: stoller@cs.indiana.edu  fbs@cs.cornell.edu  
Phone: 2  
Title: Automated Stream-Based Analysis of Fault-Tolerance  
Author: Scott D. Stoller and Fred B. Schneider 
Address: Bloomington, IN 47405, USA  Ithaca, NY 14853, USA  
Affiliation: 1 Computer Science Dept., Indiana University,  Dept. of Computer Science, Cornell University,  
Abstract: A rigorous, automated approach to analyzing fault-tolerance of distributed systems is presented. The method is based on a stream model of computation that incorporates approximation mechanisms. One application is described: a protocol for fault-tolerant moving agents. 
Abstract-found: 1
Intro-found: 1
Reference: [AH87] <editor> S. Abramsky and C. Hankin, editors. </editor> <title> Abstract Interpretation of Declarative Languages. </title> <publisher> Ellis-Horwood, </publisher> <year> 1987. </year>
Reference-contexts: This paper discusses a specialized approach to analysis of fault-tolerance properties for distributed systems. It is a novel hybrid of ideas from stream-processing (or data-flow) models of networks of processes [Kah74,Bro87] and abstract interpretation of programs <ref> [AH87] </ref>. An important feature of our approach is its emphasis on communication (rather than state), consistent with the thesis that distributed systems have natural descriptions in terms of communication. In stream-processing models, each component of a system is represented by an input-output function describing its input/output behavior. <p> An exact computation of all possible sequences of messages that might be sent is generally infeasible. To help make automated analysis feasible, our framework supports flexible and powerful approximations, or abstractions, as they are called in the literature on abstract interpretation <ref> [AH87] </ref>. Traditionally, stream-processing models have not incorporated approximations. The approximations in our framework enable compact representation of the highly non-deterministic behavior characteristic of severe failures and also support abstraction from irrelevant aspects of a system's failure-free behavior.
Reference: [Bro87] <author> M. Broy. </author> <title> Semantics of finite and infinite networks of concurrent communicating agents. </title> <journal> Distributed Computing, </journal> <volume> 2(1) </volume> <pages> 13-31, </pages> <year> 1987. </year>
Reference: [CdR93] <author> A. Cau and W.-P. de Roever. </author> <title> Using relative refinement for fault tolerance. </title> <booktitle> In Proc. 1st Intl. Symposium of Formal Methods Europe, </booktitle> <pages> pages 19-41, </pages> <year> 1993. </year>
Reference: [CGL94] <author> E. M. Clarke, O. Grumberg, and D. E. </author> <title> Long. Model checking and abstraction. </title> <journal> ACM Trans. on Prog. Lang. and Sys., </journal> <volume> 16(5) </volume> <pages> 1512-1542, </pages> <year> 1994. </year>
Reference: [CS96] <author> R. Cleaveland and S. Sims. </author> <title> The NCSU Concurrency Workbench. </title> <booktitle> In Proc. CAV '96, volume 1102 of LNCS, </booktitle> <pages> pages 394-397. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference: [Hol91] <author> G. J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference: [JJ96] <author> T. Janowski and M. Joseph. </author> <title> Dynamic scheduling in the presence of faults: Specification and verification. </title> <booktitle> In Proc. FTRTFT '96, volume 1135 of LNCS, </booktitle> <pages> pages 279-297. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference: [Kah74] <author> G. Kahn. </author> <title> The semantics of a simple language for parallel programming. </title> <editor> In J. L. Rosenfeld, editor, </editor> <booktitle> Information Processing 74: Proc. IFIP Congress 74, </booktitle> <pages> pages 471-475. </pages> <publisher> North-Holland, </publisher> <year> 1974. </year>
Reference: [Kur94] <author> R. P. Kurshan. </author> <title> Computer-aided verification of coordinating processes: the automata-theoretic approach. </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference: [LM94] <author> L. Lamport and S. Merz. </author> <title> Specifying and verifying fault-tolerant systems. </title> <booktitle> In Proc. Formal Techniques in Real-Time and Fault-Tolerant Systems, volume 863 of LNCS, </booktitle> <pages> pages 41-76. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: [LSP82] <author> L. Lamport, R. Shostak, and M. Pease. </author> <title> The Byzantine generals problem. </title> <journal> ACM Trans. on Prog. Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Message orderings are approximated using partial (instead of total) orders. Our analysis method is implemented in a prototype tool called CRAFT [Sto97]. We have used CRAFT to analyze a protocol for fault-tolerant moving agents and the Oral Messages algorithm for Byzantine Agreement <ref> [LSP82] </ref>. A formal presentation of our analysis method, including a semantics and a proof of soundness with respect to that semantics, appears in [Sto97].
Reference: [MvRSS96] <author> Y. Minsky, R. van Renesse, F. B. Schneider, and S. D. Stoller. </author> <title> Crypto graphic support for fault-tolerant distributed computing. </title> <booktitle> In Proc. Seventh ACM SIGOPS European Workshop, </booktitle> <pages> pages 109-114. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference: [ORSvH95] <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference: [PJ94] <author> D. Peled and M. Joseph. </author> <title> A compositional framework for fault-tolerance by specification transformation. </title> <journal> Theoretical Computer Science, </journal> <volume> 128(1-2):99 125, </volume> <year> 1994. </year>
Reference: [Sch96] <author> H. Schepers. </author> <title> Real-time systems and fault-tolerance. </title> <editor> In M. Joseph, editor, </editor> <booktitle> Mathematics of Dependable Systems, chapter 7. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1996. </year>
Reference: [SS97] <author> S. D. Stoller and F. B. Schneider. </author> <title> Automated analysis of fault-tolerance in distributed systems. </title> <booktitle> In Proc. First ACM SIGPLAN Workshop on Automated Analysis of Software, </booktitle> <pages> pages 33-44, </pages> <year> 1997. </year> <note> Available via http://www.cs.indiana.edu/~stoller/ </note> . 
Reference-contexts: Thus, we define Mul = Set (SVal fi AMul) n f;g; where the set AMul AVal of abstract multiplicities contains abstract values whose meanings are subsets of the natural numbers, excluding ; and f0g. The symbolic values in multiplicities are useful for efficient analysis of systems with crash failures <ref> [SS97] </ref>. Abstract multiplicities are analogous to superscripts in regular expressions. To promote the resemblance, we assume AVal contains the following: 1, denoting f1g; ?, denoting f0; 1g; +, denoting the set of positive natural numbers; and fl, denoting the set of natural numbers.
Reference: [Sto97] <author> S. D. Stoller. </author> <title> A Method and Tool for Analyzing Fault-Tolerance in Systems. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> May </month> <year> 1997. </year> <note> Available via http://www.cs.indiana.edu/~stoller/ </note> . 
Reference-contexts: Values and multiplicities are approximated using a form of abstract interpretation and a form of symbolic computation. Message orderings are approximated using partial (instead of total) orders. Our analysis method is implemented in a prototype tool called CRAFT <ref> [Sto97] </ref>. We have used CRAFT to analyze a protocol for fault-tolerant moving agents and the Oral Messages algorithm for Byzantine Agreement [LSP82]. A formal presentation of our analysis method, including a semantics and a proof of soundness with respect to that semantics, appears in [Sto97]. <p> in a prototype tool called CRAFT <ref> [Sto97] </ref>. We have used CRAFT to analyze a protocol for fault-tolerant moving agents and the Oral Messages algorithm for Byzantine Agreement [LSP82]. A formal presentation of our analysis method, including a semantics and a proof of soundness with respect to that semantics, appears in [Sto97]. A discussion of related and future work, including comparisons with the abstraction methods of [CGL94,Kur94], can also be found there. 2 Analysis Method We start by describing how data is approximated in our framework and then how sets and sequences of messages are approximated. <p> Each variable is local to a single component, whose outputs in a given execution determine the value represented by that variable. Making each variable local to a single component enables independent verification that each input-output function faithfully represents the behavior of the corresponding process (as described in <ref> [Sto97] </ref>). We also include in SVal a special wildcard symbol " ", which is used when a value is not known to have any interesting relationships to other values. Different occurrences of the wildcard in a MFG do not necessarily represent the same concrete value. <p> The behavior of a system nf in failure scenario fs is represented by the MFG lfp (step nf ;fs ), if it exists, where lfp indicates the least fixed-point, and the partial ordering on MFG, defined in <ref> [Sto97] </ref>, corresponds informally to the prefix ordering on sequences. This fixed-point might not exist; one reason, roughly, is that MFGs do not have canonical forms [Sto97]. <p> by the MFG lfp (step nf ;fs ), if it exists, where lfp indicates the least fixed-point, and the partial ordering on MFG, defined in <ref> [Sto97] </ref>, corresponds informally to the prefix ordering on sequences. This fixed-point might not exist; one reason, roughly, is that MFGs do not have canonical forms [Sto97]. The tool searches for a fixed-point by starting with the "empty" MFG (x : Name : y : Name: h;; ;i) and repeatedly applying step nf ;fs . If the fixed-point does not exist, this procedure diverges. 2 Fault-Tolerance Requirements. <p> its three input messages in its output, so the value in its outputs is a set of three possibilities; specifically, the value is (ms j fifMsgg) 2 Val , where ms j = fm2 1;j ; m2 2;j ; m2 3;j g: Detailed input-output functions for this protocol appear in <ref> [Sto97] </ref>. 3.1 Analysis Results To determine whether the above protocol satisfies MA-FTR, an MFG representing the protocol's behavior is computed for each failure scenario in which a 4 The only remaining differences between a server and a consolidator are: (1) a consolidator does not perform application-specific computation, i.e., does not apply
References-found: 17

