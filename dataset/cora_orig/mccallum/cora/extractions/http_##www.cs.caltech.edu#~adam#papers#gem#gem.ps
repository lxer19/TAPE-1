URL: http://www.cs.caltech.edu/~adam/papers/gem/gem.ps
Refering-URL: http://www.cs.caltech.edu/~adam/papers.html
Root-URL: http://www.cs.caltech.edu
Email: adam@cs.caltech.edu  
Title: Using a Global Event Model in Developing Distributed Control Systems  
Author: Adam Rifkin 
Keyword: Java infrastructure.  
Date: December 16, 1997  
Address: 256-80, Pasadena, CA 91125  
Affiliation: Caltech Department of Computer Science  
Abstract: We specify an abstract model for distributed control systems in which the component objects do not have access to the state of the entire system, new objects can enter and leave the system dynamically, and each object makes its own local decisions (though collectively these local decisions maintain some system-wide constraints). We present several applications of such control systems, and then focus on distributed resource management. In exploring solutions that are compositional (and hence scale), we observe that a general Java framework for constructing distributed resource management algorithms benefits both from exploiting the multicast facilities of Java and from building global events into the 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Aldrich, J. Dooley, S. Mandelsohn, and A. Rifkin, </author> <title> `Providing Easier Access to Remote Objects in Client-Server Systems', </title> <booktitle> Proceedings of the Thirty-first Hawaii International Conference on System Sciences, Hawaii, </booktitle> <month> January </month> <year> 1998. </year>
Reference-contexts: Remote Method Calls. Remote method calls allow an object in one virtual machine to call methods on an object in another virtual machine. Introspection can be used to implement remote calls instead of Java's Remote Method Interface (RMI) when dynamic reconfigurability is a concern <ref> [1] </ref>. Infospheres 2.0 provides three flavors of calls: regular calls, future calls in which the caller is not blocked after making the call and during which the caller can check whether a value has been returned at any point; and, oneway calls. Messages. <p> Status of Java Implementation. The object persistence and communication Java packages of Info-spheres 1.0 have been available since August 1997 [6], and we are presently working on wrapping these services in Java Beans. We have also implemented a prototype package for dynamic remote method calling using Infospheres 1.0 <ref> [1] </ref>. We have implemented a framework for constructing distributed resource managers using Infospheres 1.0, and used the framework to develop the collaborating consumer pull and competing consumer pull algorithms [18].
Reference: [2] <author> A. D. Alexandrov, M. Ibel, K. E. Schauser, and C. J. Scheiman, `SuperWeb: </author> <title> Research Issues in Java-Based Global Computing', </title> <journal> Concurrency: Practice and Experience, </journal> <month> June </month> <year> 1997. </year>
Reference-contexts: SuperWeb has explored the technological and economic tradeoffs of using a Java-based infrastructure to harness global resources, making them available to anyone on the Internet through intermediate brokers that match client computations with suitable hosts <ref> [2] </ref>. SuperWeb's broker architecture is well-suited to the middlemen compositional structure in section 3.3 for the distributed management of computing resources, and SuperWeb's prototype implementation, Javelin [5], demonstrates that a Java infrastructure can obtain reasonable speedups in parallel computations as well.
Reference: [3] <author> E. Amir, S. McCanne, and R. Katz, </author> <title> `Receiver-driven Bandwidth Adaptation for Light-weight Sessions', </title> <booktitle> Proceedings of ACM Multimedia, </booktitle> <address> Seattle, Washington, </address> <month> November </month> <year> 1997. </year>
Reference-contexts: A collaboration with more than one sender and several receivers has to partition bandwidth during a session within each multicast channel among the contending senders; this can be done adaptively, as with the Scalable ConsensUs-based Bandwidth Allocation (SCUBA) <ref> [3] </ref>. <p> An example application using soft state is SCUBA <ref> [3] </ref>, for controlling bandwidth allocation in synchronous collaborations. The amount of bandwidth taken by a sender depends on the relative interest expressed by multiple listeners. <p> Such fluctuating requests need not be satisfied completely before new requests are made; rather, requests are fulfilled adaptively as resources become available, as occurs with SCUBA <ref> [3] </ref>. In such situations, each resource | for example, a divisible bandwidth pipe or a fleet of cars | is represented as an adjustable slidebar representing the utilization of that resource. Consumers request fractions of the resource capacity under allocation constraints (such as duration of intended use).
Reference: [4] <author> K. P. Birman and R. van Renesse, </author> <title> Reliable Distributed Computing with the Isis Toolkit, </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> California, </address> <year> 1994. </year>
Reference-contexts: Furthermore, unlike the group communication in virtual synchrony <ref> [4] </ref>, it is not necessary for the event sources to know at any point who the event observers will be; they simply generate the events and let the event listeners handle the distribution of those events to the appropriate targets. <p> Since providers collaborate to satisfy each consumer's request, the listening providers can ante up additional resources (or keep from doing so) based on previous information announced by providers and consumers. Although multicast is not virtual synchrony <ref> [4] </ref> | and hence group communications are not guaranteed to be reliable, as shown in figure 4 | messages being in different orders at different objects is not a problem. <p> Furthermore, the messaging layer in Infospheres 2.0 allows for arbitrarily nestable protocol stacks built on-the-fly, such as those provided by Horus [22]. However, we have not yet incorporated support in our packages for the virtually synchronous execution model for group membership and communication introduced by the Isis Toolkit <ref> [4] </ref>. With Isis' group membership primitives, participants in a distributed activity know the identities of the other group members at all times.
Reference: [5] <author> B. O. Christiansen, P. Cappello, M. F. Ionescu, M. O. Neary, K. E. Schauser, and D. Wu, `Javelin: </author> <title> Internet-Based Parallel Computing Using Java', </title> <booktitle> 1997 ACM Workshop on Java for Science and Engineering Computation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: SuperWeb's broker architecture is well-suited to the middlemen compositional structure in section 3.3 for the distributed management of computing resources, and SuperWeb's prototype implementation, Javelin <ref> [5] </ref>, demonstrates that a Java infrastructure can obtain reasonable speedups in parallel computations as well. High-performance facilities are critical to several other metacomputing frameworks, including Globus, NPAC, and Legion. Globus provides the infrastructure to create networked virtual supercomputers for running applications on machines distributed globally [12].
Reference: [6] <author> K. M. Chandy, </author> <title> `Software Infrastructure for VECS', </title> <booktitle> AFOSR/Caltech Workshop on Theoretical Foundations of Virtual Engineering and Complex Systems, </booktitle> <address> Pasadena, California, </address> <month> December </month> <year> 1997. </year> <month> 13 </month>
Reference-contexts: Event Model that extends the local events of Java Beans to be distributable | with an implementation using the Infospheres 2.0 packages planned. 1.1 Distributed Control Systems A distributed control system consists of interacting component objects, each of which have persistent local state and one or more threads of control <ref> [6] </ref>. As illustrated in figure 1, input messages called feedback may come from other objects; other input messages may come in an uncontrolled fashion from the system's environment. Output messages called observations can be routed as feedback to other objects. <p> Nonetheless, the algorithms are compelling, and they can be implemented in Java using the Infospheres Infrastructure. Status of Java Implementation. The object persistence and communication Java packages of Info-spheres 1.0 have been available since August 1997 <ref> [6] </ref>, and we are presently working on wrapping these services in Java Beans. We have also implemented a prototype package for dynamic remote method calling using Infospheres 1.0 [1].
Reference: [7] <author> K. M. Chandy, J. Kiniry, A. Rifkin, and D. Zimmerman, </author> <title> `Webs of Archived Distributed Computations for Asynchronous Collaboration', </title> <journal> Journal of Supercomputing, </journal> <volume> Volume 11, Number 2, </volume> <pages> Pages 101-118, </pages> <month> August </month> <year> 1997. </year>
Reference-contexts: Later, we refine this model for the specific case of distributed resource management systems, discuss different kinds of resource management problems, and discuss a strategy for implementing a distributed resource management system using the Java middleware layer called Infospheres <ref> [7, 10] </ref>. <p> Rather, we provide general mechanisms for programmers to use in developing distributed system components and in composing them dynamically, both to work synchronously on a task in short-lived sessions [9], and to coordinate work asynchronously on an archivable activity in longer, discontinuous collaborations <ref> [7] </ref>. Furthermore, the messaging layer in Infospheres 2.0 allows for arbitrarily nestable protocol stacks built on-the-fly, such as those provided by Horus [22]. However, we have not yet incorporated support in our packages for the virtually synchronous execution model for group membership and communication introduced by the Isis Toolkit [4].
Reference: [8] <author> K. M. Chandy and J. Misra, </author> <title> `How Processes Learn', </title> <journal> Journal of Distributed Computing, </journal> <volume> Volume 1, Number 1, </volume> <pages> Pages 40-52, </pages> <year> 1986. </year>
Reference-contexts: In this case, if x in object A has value 1, then object A knows that y in object B has value at least 1, and this knowledge is hard <ref> [8] </ref>. Some distributed control problems allow for the use of soft states exclusively, and algorithms based on soft state usually scale better and are more resilient in the presence of faults [21].
Reference: [9] <author> K. M. Chandy and A. Rifkin, </author> <title> `Systematic Composition of Objects in Distributed Internet Applications: Processes and Sessions', Computer Journal, </title> <publisher> Oxford University Press, </publisher> <month> October </month> <year> 1997. </year>
Reference-contexts: Rather, we provide general mechanisms for programmers to use in developing distributed system components and in composing them dynamically, both to work synchronously on a task in short-lived sessions <ref> [9] </ref>, and to coordinate work asynchronously on an archivable activity in longer, discontinuous collaborations [7]. Furthermore, the messaging layer in Infospheres 2.0 allows for arbitrarily nestable protocol stacks built on-the-fly, such as those provided by Horus [22].
Reference: [10] <author> K. M. Chandy, A. Rifkin, P. A. G. Sivilotti, J. Mandelson, M. Richardson, W. Tanaka, and L. Weisman, </author> <title> `A World-Wide Distributed Sytem Using Java and the Internet', </title> <booktitle> Proceedings of the Fifth IEEE International Symposium on High Performance Distributed Computing, </booktitle> <pages> Pages 11-18, </pages> <address> Syracuse, New York, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: Later, we refine this model for the specific case of distributed resource management systems, discuss different kinds of resource management problems, and discuss a strategy for implementing a distributed resource management system using the Java middleware layer called Infospheres <ref> [7, 10] </ref>.
Reference: [11] <author> K. M. Chandy and E. M. Schooler, </author> <title> `Designing Directories in Distributed Systems: A Systematic Framework', </title> <booktitle> Proceedings of the Fifth IEEE International Symposium on High Performance Distributed Computing, </booktitle> <pages> Pages 318-328, </pages> <address> Syracuse, New York, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: time (t + t 0 ), object A gets a message from B, timestamped t, stating that B is listening, then A has the "soft" information that B is listening at time (t + t 0 ); and the softness of the state can be quantified in terms of probability <ref> [11] </ref>. An example application using soft state is SCUBA [3], for controlling bandwidth allocation in synchronous collaborations. The amount of bandwidth taken by a sender depends on the relative interest expressed by multiple listeners. <p> A probabilistic model for estimating current state based on old information announcements and elapsed time may be sufficient for a distributed control system's information needs, yet efficient for such a system to scale well <ref> [11] </ref>.
Reference: [12] <author> I. Foster and C. Kesselman, `Globus: </author> <title> A Metacomputing Infrastructure Toolkit', </title> <booktitle> Proceedings of the Workshop on Environments and Tools for Parallel Scientific Computing, </booktitle> <publisher> SIAM, </publisher> <address> Lyon, France, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: In a scalable system, each producer will not have complete and up-to-date information about every requestor or other producers. Yet, the grid has to collectively deliver resources to requestors in a manner that satisfies given constraints and optimizes the given objective, as is done with the Globus <ref> [12] </ref> and Legion [15] resource management systems. Applications outside Metacomputing. Note that such a system has applications outside the domain of metacomputing. For example, consider the general distributed resource management problem with finite resources, providers of resources, and requestors of resources. <p> High-performance facilities are critical to several other metacomputing frameworks, including Globus, NPAC, and Legion. Globus provides the infrastructure to create networked virtual supercomputers for running applications on machines distributed globally <ref> [12] </ref>. NPAC seeks to perform High Performance Computing and Communications (HPCC) activities using a Web-enabled concurrent virtual machine [13]. And, Legion 12 provides an architecture and object model for giving the illusion of a single virtual machine to users for wide--area parallel processing [15].
Reference: [13] <author> G. Fox and W. Furmanski, </author> <title> `Towards Web/Java based High Performance Distributed Computing An Evolving Virtual Machine', </title> <booktitle> Proceedings of the Fifth IEEE International Symposium on High Performance Distributed Computing, </booktitle> <pages> Pages 308-317, </pages> <address> Syracuse, New York, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: High-performance facilities are critical to several other metacomputing frameworks, including Globus, NPAC, and Legion. Globus provides the infrastructure to create networked virtual supercomputers for running applications on machines distributed globally [12]. NPAC seeks to perform High Performance Computing and Communications (HPCC) activities using a Web-enabled concurrent virtual machine <ref> [13] </ref>. And, Legion 12 provides an architecture and object model for giving the illusion of a single virtual machine to users for wide--area parallel processing [15].
Reference: [14] <author> J. Gray and A. Reuter, </author> <title> Transaction Processing: Concepts and Techniques, </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: Some listening providers will hear each consumer's request, and each consumer will hear some collection of tokens available and respond according to its needs using a two-phase commit of reserving and then locking <ref> [14, 18] </ref>. This algorithm could present a problem if middlemen are used, because deadlock can occur if no consumer gets all of the resources it needs. <p> Again, consumers using multicast is not a problem, because some listening providers will hear each consumer's request, and each consumer will hear some collection of tokens available and respond according to its needs using a two-phase commit of reserving and then locking <ref> [14, 18] </ref>. 5.5 Competitive Providers, Using Middlemen As in section 5.2, each consumer uses global events to announce its requests for resources to a list of middlemen specific to that consumer; each list is updated by its consumer dynamically both by asking other consumers about appropriate middlemen and by middlemen advertising
Reference: [15] <author> A. S. Grimshaw, W. A. Wulf, </author> <title> and the Legion team, `The Legion Vision of a Worldwide Virtual Computer', </title> <journal> Communications of the ACM, </journal> <volume> Volume 40, Number 1, </volume> <pages> Pages 39-45, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: Yet, the grid has to collectively deliver resources to requestors in a manner that satisfies given constraints and optimizes the given objective, as is done with the Globus [12] and Legion <ref> [15] </ref> resource management systems. Applications outside Metacomputing. Note that such a system has applications outside the domain of metacomputing. For example, consider the general distributed resource management problem with finite resources, providers of resources, and requestors of resources. <p> NPAC seeks to perform High Performance Computing and Communications (HPCC) activities using a Web-enabled concurrent virtual machine [13]. And, Legion 12 provides an architecture and object model for giving the illusion of a single virtual machine to users for wide--area parallel processing <ref> [15] </ref>. Unlike these efforts, Infospheres 2.0 uses only pure Java standards; that is, the packages are just a collection of Java classes, without native method calls or source-to-source compilers. Also, the emphasis of our work is the exploration of event models and multicast with Java.
Reference: [16] <author> S. Maffeis, </author> <title> `Adding Group Communication and Fault-Tolerance to CORBA', </title> <booktitle> Proceedings of the 1995 USENIX Conference on Object-Oriented Technologies, </booktitle> <address> Monterey, California, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: investigating the construction of a virtual synchrony layer using Infospheres 2.0, because the fault-tolerance tools afforded by virtual synchrony | such as for load-balanced request execution, for security, and for coherently replicated data | have proven useful for many applications, as demonstrated by the CORBA-compliant interface to Horus called Electra <ref> [16] </ref> and by the Java middleware package iBus [17]. Summary. Infospheres 2.0 provides a suitable infrastructure for investigating algorithms for distributed control.
Reference: [17] <author> S. Maffeis, `iBus: </author> <title> The Java Intranet Software Bus', </title> <note> available at http://www.olsen.ch/export/ftp/users/maffeis/ibus/ibus_overview.ps.gz, Olsen and Associates, </note> <institution> Zurich, </institution> <year> 1997. </year>
Reference-contexts: using Infospheres 2.0, because the fault-tolerance tools afforded by virtual synchrony | such as for load-balanced request execution, for security, and for coherently replicated data | have proven useful for many applications, as demonstrated by the CORBA-compliant interface to Horus called Electra [16] and by the Java middleware package iBus <ref> [17] </ref>. Summary. Infospheres 2.0 provides a suitable infrastructure for investigating algorithms for distributed control.
Reference: [18] <author> R. Ramamoorthi, A. Rifkin, B. Dimitrov, and K. M. Chandy, </author> <title> `A General Resource Reservation Framework for Scientific Computing', </title> <booktitle> Proceedings of the First International Scientific Computing in Object-Oriented Parallel Environments (ISCOPE) Conference, Volume 1343 of Springer-Verlag's Lecture Notes in Computer Science, </booktitle> <pages> Pages 283-290, </pages> <institution> Marina del Rey, California, </institution> <month> December </month> <year> 1997. </year>
Reference-contexts: Tokens intrinsically permit mutual exclusion, because only the current holder of a token may use its respective resource. We can associate a token color for each respective "type" of resource, and the number of tokens of each color corresponds to the number of resources of that type available <ref> [18] </ref>. For instance, yellow tokens are used for supercomputers, red for visualization tools, blue for printers, and so on. <p> Some listening providers will hear each consumer's request, and each consumer will hear some collection of tokens available and respond according to its needs using a two-phase commit of reserving and then locking <ref> [14, 18] </ref>. This algorithm could present a problem if middlemen are used, because deadlock can occur if no consumer gets all of the resources it needs. <p> Providers make announcements when the tokens they hold change significantly, and on a periodic basis [21]. A consumer may choose to execute a low-priority task just because the resources it needs happen to be available <ref> [18] </ref>. 5.4 Competitive Providers, Consumer Push As in section 5.1, consumers use global events to announce their requests for resources, and the resource providers are global event listeners implemented using GEM. <p> Again, consumers using multicast is not a problem, because some listening providers will hear each consumer's request, and each consumer will hear some collection of tokens available and respond according to its needs using a two-phase commit of reserving and then locking <ref> [14, 18] </ref>. 5.5 Competitive Providers, Using Middlemen As in section 5.2, each consumer uses global events to announce its requests for resources to a list of middlemen specific to that consumer; each list is updated by its consumer dynamically both by asking other consumers about appropriate middlemen and by middlemen advertising <p> Since providers are competing, providers avoid announcing (as much as possible) things that competing providers can hear; rather, they use remote method calls or messages to talk with consumers directly, allowing the consumers themselves to piece together a distributed package of tokens fulfilling its needs <ref> [18] </ref>. 6 Related and Future Work The algorithms described in section 5 have several advantages in using global events and multicast. The announce-listen paradigm is fault-resilient [21]; that is, if a resource provider goes away, the system adapts dynamically to continue to meet the requests of the consumers. <p> We have also implemented a prototype package for dynamic remote method calling using Infospheres 1.0 [1]. We have implemented a framework for constructing distributed resource managers using Infospheres 1.0, and used the framework to develop the collaborating consumer pull and competing consumer pull algorithms <ref> [18] </ref>. We plan to collect simulation and performance results of the Infospheres 2.0 (using GEM) implementation of the algorithm for collaborative providers, consumer push given in section 5.1.
Reference: [19] <author> A. Rifkin, </author> <title> `GEM: A Global Event Model for Using Events in Distributed Systems', Caltech Infospheres Group Internal Report, </title> <institution> California Institute of Technology, </institution> <year> 1998. </year>
Reference-contexts: Event Model (GEM) on which Infosphere 2.0's global events are based expands the rich Java local event model with mechanisms for distributing the components of an event system, for composing (distributed) event notifiers, and for filtering (using predicates) and providing security (using access control lists) at the event notifier level <ref> [19] </ref>.
Reference: [20] <author> D. S. Rosenblum and A. L. Wolf, </author> <title> `A Design Framework for Internet-Scale Event Observation and Notification', </title> <booktitle> Proceedings of the Fifth ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> Pages 344-360, </pages> <address> Zurich, Switzerland, </address> <year> 1997. </year>
Reference-contexts: An Internet-scale event generation, observation, and notification facility provides a common (event-based) 6 architectural style for distributed, loosely-coupled, heterogeneous software system development <ref> [20] </ref>.
Reference: [21] <author> E. M. Schooler, </author> <title> `A Multicast User Directory Service for Synchronous Rendezvous', </title> <type> Technical Report CS-TR-96-18, </type> <institution> Department of Computer Science, California Institute of Technology, Pasadena, California, </institution> <year> 1996. </year>
Reference-contexts: In a collaborative environment, providers and requestors can use an announce-listen communication strategy: each object knows that all the other objects within the scope of the announcement will get the announcement <ref> [21] </ref>. The overall system state can be propagated, with delays, throughout the system, providing that scalability is not a problem. <p> Some distributed control problems allow for the use of soft states exclusively, and algorithms based on soft state usually scale better and are more resilient in the presence of faults <ref> [21] </ref>. Whether soft states can be used depends on the nature of the problem, the duration of message delays, and the fuzziness of constraints and objective. <p> For example, if you are in Caltech and providers in Pasadena can provide the resources then no further requests are necessary; otherwise, the request is announced with larger scope (all of Los Angeles county), and so on <ref> [21] </ref>. Hybrid Solutions with Online Middlemen. In hybrid systems, the requestor asks a middleman to get the resources. The middleman may use global events or remote methods. The middleman may have a directory of resource providers, and thus the middleman determines the communication mechanism to use. <p> The use of multicast to post events requires limiting the scope of the multicast announcements accordingly. For efficiency, middlemen can refrain from announcing events except when resources available change dramatically; if available resources change a lot, the middlemen can announce these changes periodically <ref> [21] </ref>. 5.3 Collaborative Providers, Consumer Pull Providers use global events to announce their available resources; consumers are global event listeners implemented using GEM. The use of multicast to post events requires limiting the scope, so that only consumers within the proper scope listen to provider resource announcements. <p> The use of multicast to post events requires limiting the scope, so that only consumers within the proper scope listen to provider resource announcements. Providers make announcements when the tokens they hold change significantly, and on a periodic basis <ref> [21] </ref>. <p> The use of multicast to post events requires limiting the scope of the multicast announcements accordingly. For efficiency, middlemen can refrain from announcing events except when resources available change dramatically; if available resources change a lot, the middlemen can announce these changes periodically <ref> [21] </ref>. 5.6 Competitive Providers, Consumer Pull As in section 5.3, providers use global events to announce their available resources; consumers are global event listeners implemented using GEM. <p> The announce-listen paradigm is fault-resilient <ref> [21] </ref>; that is, if a resource provider goes away, the system adapts dynamically to continue to meet the requests of the consumers. Furthermore, systems constructed using global events and multicast are compositional and scale; providers and consumers can add or remove themselves at any point dynamically. <p> With Isis' group membership primitives, participants in a distributed activity know the identities of the other group members at all times. For the dynamic distributed control systems described in this paper, allowing the component objects to have imperfect knowledge of other participants garners the scaling benefits of soft state <ref> [21] </ref>. A probabilistic model for estimating current state based on old information announcements and elapsed time may be sufficient for a distributed control system's information needs, yet efficient for such a system to scale well [11].
Reference: [22] <author> R. van Renesse, K. P. Birman, and S. Maffeis, `Horus: </author> <title> a Flexible Group Communication System', </title> <journal> Communications of the ACM, </journal> <volume> Volume 39, Number 4, </volume> <month> April </month> <year> 1996. </year> <month> 14 </month>
Reference-contexts: The package allows a message to create the appropriate receiver protocol stack on-the-fly (for example, piecing together protocols such as compression or encryption as needed, like the Horus <ref> [22] </ref> system) when the message is received. Communication protocols supported include Java's TCP, UDP, and multicast facilities; developers can employ any of these depending on their quality-of-service requirements. <p> Furthermore, the messaging layer in Infospheres 2.0 allows for arbitrarily nestable protocol stacks built on-the-fly, such as those provided by Horus <ref> [22] </ref>. However, we have not yet incorporated support in our packages for the virtually synchronous execution model for group membership and communication introduced by the Isis Toolkit [4]. With Isis' group membership primitives, participants in a distributed activity know the identities of the other group members at all times.
References-found: 22

