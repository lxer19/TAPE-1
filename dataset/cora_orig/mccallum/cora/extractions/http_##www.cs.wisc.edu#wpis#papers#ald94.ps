URL: http://www.cs.wisc.edu/wpis/papers/ald94.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Email: reps@cs.wisc.edu  
Title: DEMAND INTERPROCEDURAL PROGRAM ANALYSIS USING LOGIC DATABASES  
Author: Thomas W. Reps 
Address: 1210 W. Dayton Street, Madison, WI 53706 USA  
Affiliation: Computer Sciences Department, University of Wisconsin-Madison  
Abstract: This paper describes how algorithms for demand versions of inerprocedural program-analysis problems can be obtained from their exhaustive counterparts essentially for free, by applying the so-called magic-sets transformation that was developed in the logic-programming and deductive-database communities. Applications to interproce-dural dataflow analysis and interprocedural program slicing are described. 1 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F.E. Allen. </author> <title> Interprocedural data flow analysis. In Information Processing Demand Interprocedural Program Analysis 31 74: </title> <booktitle> Proceedings of the IFIP Congress 74, </booktitle> <pages> pages 398-408, </pages> <year> 1974. </year>
Reference-contexts: For example, in interprocedural dataflow analysis, analysis is carried out on a structure that consists of a control-flow graph for each procedure, plus some additional procedure-linkage information <ref> [1, 7, 36, 11] </ref>. In interprocedural analysis problems, not all of the paths in the graphs that represent the program correspond to possible execution paths.
Reference: [2] <author> U. Assmann. </author> <title> On edge addition rewrite systems and their relevance to program analysis. </title> <type> Unpublished report, </type> <institution> GMD Forschungsstelle Karlsruhe, Karlsruhe, Germany, </institution> <year> 1993. </year>
Reference-contexts: For instance, one of the Demand Interprocedural Program Analysis 29 examples in Ullman's book shows how a logic database can be used to solve the intraprocedural reaching-definitions problem [38, pp. 984-987]. U. Assmann has examined a variety of other intraprocedural program-analysis problems <ref> [2] </ref>.
Reference: [3] <author> W.A. Babich and M. Jazayeri. </author> <title> The method of attributes for data flow analysis: Part II. Demand analysis. </title> <journal> Acta Informatica, </journal> <volume> 10(3) </volume> <pages> 265-272, </pages> <month> October </month> <year> 1978. </year>
Reference-contexts: way to obtain implementations of demand algorithms for the in-terprocedural dataflow-analysis and interprocedural-slicing problems would be to use the programs from Sections 3 and 4 in conjunction with the SUNY-Stony Brook XSB system [40]. 6.1 Dataflow Analysis Previous work on demand-driven dataflow analysis has dealt only with the in-traprocedural case <ref> [3, 43] </ref>. The work that has been reported in the present paper 28 Chapter 1 complements previous work on the intraprocedural case in the sense that our approach to obtaining algorithms for demand-driven dataflow analysis problems applies equally well to intraprocedural dataflow analysis.
Reference: [4] <author> L. Badger and M. Weiser. </author> <title> Minimizing communication for synchronizing parallel dataflow programs. </title> <booktitle> In Proceedings of the 1988 International Conference on Parallel Processing, </booktitle> <address> St. Charles, IL, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: This concept, originally discussed by Mark Weiser in [42], allows one to isolate individual computation threads within a program. Slicing can be used for such 16 Chapter 1 diverse activities as helping a programmer understand complicated code, aiding debugging [24], automatically parallelizing programs <ref> [41, 4] </ref>, and automatically combining program variants [14]. (See [37] for an extensive survey of work on program slicing.) The problem of interprocedural slicing concerns how to determine a slice of an entire program, where the slice crosses the boundaries of procedure calls.
Reference: [5] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proceedings of the Fifth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1986. </year>
Reference-contexts: With the approach presented in this paper, this capability is obtained for free, as a by-product of the way the composition of two computations is treated by the magic-sets transformation <ref> [35, 5, 8] </ref>. Sidestepping incremental-updating problems. An optimizing transforma tion performed at one point in the program can invalidate previously computed dataflow information at other points in the program.
Reference: [6] <author> J.P. Banning. </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> In Conference Record of the Sixth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 29-41, </pages> <address> San Antonio, TX, </address> <month> January </month> <year> 1979. </year>
Reference-contexts: For example, the interprocedural MayMod and MayUse problems are to determine, for each call site c, which variables may have their values modified by c's execution and which variables may have their values used by c's execution, respectively <ref> [6, 11] </ref>. The flow-insensitive versions of these side-effect-analysis problems can be decomposed into two subsidiary phases: computing alias information and computing side effects due to reference formal parameters [6, 12, 11]. <p> The flow-insensitive versions of these side-effect-analysis problems can be decomposed into two subsidiary phases: computing alias information and computing side effects due to reference formal parameters <ref> [6, 12, 11] </ref>.
Reference: [7] <author> J.M. Barth. </author> <title> A practical interprocedural data flow analysis algorithm. </title> <journal> Com-mun. of the ACM, </journal> <volume> 21(9) </volume> <pages> 724-736, </pages> <month> September </month> <year> 1978. </year>
Reference-contexts: For example, in interprocedural dataflow analysis, analysis is carried out on a structure that consists of a control-flow graph for each procedure, plus some additional procedure-linkage information <ref> [1, 7, 36, 11] </ref>. In interprocedural analysis problems, not all of the paths in the graphs that represent the program correspond to possible execution paths.
Reference: [8] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of magic. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 269-293, </pages> <address> San Diego, CA, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: With the approach presented in this paper, this capability is obtained for free, as a by-product of the way the composition of two computations is treated by the magic-sets transformation <ref> [35, 5, 8] </ref>. Sidestepping incremental-updating problems. An optimizing transforma tion performed at one point in the program can invalidate previously computed dataflow information at other points in the program.
Reference: [9] <author> D. Callahan. </author> <title> The program summary graph and flow-sensitive interproce-dural data flow analysis. </title> <booktitle> In Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 47-56, </pages> <address> Atlanta, GA, </address> <month> June </month> <year> 1988. </year> <note> Appeared in SIGPLAN Notices 23, </note> <month> 7 (July </month> <year> 1988). </year>
Reference-contexts: Such paths fail to account correctly for the calling context (e.g., c 1 in Main) of a called procedure (e.g., P ). Thus, in many interprocedural analysis problems an important issue is to carry out the analysis so that only interprocedurally valid paths are considered <ref> [36, 26, 9, 16, 22] </ref> (see Definitions 3.3 and 4.5). With the approach taken in this paper, if the exhaustive algorithm considers only interprocedurally valid paths, then the demand algorithm obtained will also consider only interprocedurally valid paths.
Reference: [10] <author> D. Callahan, A. Carle, M.W. Hall, and K. Kennedy. </author> <title> Constructing the procedure call multigraph. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-16(4):483-487, </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: Rosay and the author have been able to develop a method for constructing call multigraphs in the presence of procedure-valued variables that is compatible with the dataflow-analysis method described in the paper; this work combines 6 Chapter 1 and extends the methods described by Lakhotia [21] and Callahan et al. <ref> [10] </ref>. Simplifications (iii) and (iv) prevent the Sharir-Pnueli framework for interpro-cedural dataflow analysis from being able to handle local variables and formal parameters of procedures in the presence of recursion; however, Knoop and Steffen have presented a generalization of the Sharir-Pnueli framework that lifts this restriction [20].
Reference: [11] <author> K.D. Cooper and K. Kennedy. </author> <title> Interprocedural side-effect analysis in linear time. </title> <booktitle> In Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 57-66, </pages> <address> Atlanta, GA, </address> <month> June </month> <year> 1988. </year> <note> Appeared in SIGPLAN Notices 23, 7 (July 1988). 32 Chapter 1 </note>
Reference-contexts: For example, the interprocedural MayMod and MayUse problems are to determine, for each call site c, which variables may have their values modified by c's execution and which variables may have their values used by c's execution, respectively <ref> [6, 11] </ref>. The flow-insensitive versions of these side-effect-analysis problems can be decomposed into two subsidiary phases: computing alias information and computing side effects due to reference formal parameters [6, 12, 11]. <p> The flow-insensitive versions of these side-effect-analysis problems can be decomposed into two subsidiary phases: computing alias information and computing side effects due to reference formal parameters <ref> [6, 12, 11] </ref>. <p> For example, in interprocedural dataflow analysis, analysis is carried out on a structure that consists of a control-flow graph for each procedure, plus some additional procedure-linkage information <ref> [1, 7, 36, 11] </ref>. In interprocedural analysis problems, not all of the paths in the graphs that represent the program correspond to possible execution paths.
Reference: [12] <author> K.D. Cooper and K. Kennedy. </author> <title> Fast interprocedural alias analysis. </title> <booktitle> In Conference Record of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-59, </pages> <address> Austin, TX, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: The flow-insensitive versions of these side-effect-analysis problems can be decomposed into two subsidiary phases: computing alias information and computing side effects due to reference formal parameters <ref> [6, 12, 11] </ref>.
Reference: [13] <author> E. Duesterwald, R. Gupta, </author> <title> and M.L. Soffa. Demand-driven program analysis. </title> <type> Technical Report TR-93-15, </type> <institution> Department of Computer Science, University of Pittsburgh, </institution> <address> Pittsburgh, PA, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: A recent paper by Duesterwald, Gupta, and Soffa discusses a very different approach to obtaining demand versions of (intraprocedural) dataflow analysis algorithms <ref> [13] </ref>. For each query of the form "Is fact f in the solution set at vertex v?", a set of dataflow equations are set up on the flow graph (but as if all edges were reversed).
Reference: [14] <author> S. Horwitz, J. Prins, and T. Reps. </author> <title> Integrating non-interfering versions of programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(3) </volume> <pages> 345-387, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Slicing can be used for such 16 Chapter 1 diverse activities as helping a programmer understand complicated code, aiding debugging [24], automatically parallelizing programs [41, 4], and automatically combining program variants <ref> [14] </ref>. (See [37] for an extensive survey of work on program slicing.) The problem of interprocedural slicing concerns how to determine a slice of an entire program, where the slice crosses the boundaries of procedure calls. One algorithm for interprocedural slicing was presented by Weiser [42].
Reference: [15] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <booktitle> In Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 35-46, </pages> <address> Atlanta, GA, </address> <month> June </month> <year> 1988. </year> <note> Appeared in SIGPLAN Notices 23, </note> <month> 7 (July </month> <year> 1988). </year>
Reference-contexts: x:(x kill n ) [ gen n is the dataflow function associated with program point n, gen n represents dataflow facts "created" at n and kill n represents dataflow facts "stopped" by n.) The paper also makes use of the approach to obtain a demand algorithm for the interprocedural-slicing problem <ref> [42, 15, 18, 34, 33] </ref>. The remainder of the paper is organized as follows: Section 2 discusses background and assumptions. Section 3 shows how to obtain a demand algorithm for the interprocedural gen-kill problems. Section 4 discusses how to obtain a demand algorithm for the interprocedural-slicing problem. <p> One algorithm for interprocedural slicing was presented by Weiser [42]. However, as pointed out independently by Horwitz, Reps, and Binkley <ref> [15] </ref> and Hwang, Du, and Chou [18], Weiser's algorithm is imprecise in the sense that it can report "effects" that are transmitted (only) through paths in a graph representation of the program that do not represent "feasible execution paths".
Reference: [16] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Such paths fail to account correctly for the calling context (e.g., c 1 in Main) of a called procedure (e.g., P ). Thus, in many interprocedural analysis problems an important issue is to carry out the analysis so that only interprocedurally valid paths are considered <ref> [36, 26, 9, 16, 22] </ref> (see Definitions 3.3 and 4.5). With the approach taken in this paper, if the exhaustive algorithm considers only interprocedurally valid paths, then the demand algorithm obtained will also consider only interprocedurally valid paths. <p> To streamline the presentation, the analysis problems discussed in Sections 3 and 4 have been simplified in certain ways. In particular, following Sharir and Pnueli [36] and Horwitz, Reps, and Binkley <ref> [16] </ref> we assume that (i) the programs being analyzed do not contain aliasing and (ii) the programs being analyzed do not use procedure-valued variables. We also make some simplifying assumptions about global variables. <p> is possible to generalize the approach described in Section 3 to implement the more general Knoop-Steffen framework. (v) In programs that use value-result parameter passing, global variables can be converted into additional parameters to each procedure. (vi) Extensions needed to slice programs that use call-by-reference parameter passing are discussed in <ref> [16] </ref>. In the logic programs given in the paper, we follow the standard naming convention used in Prolog: identifiers that begin with lower-case letters denote ground atoms; those that begin with upper-case letters denote variables. <p> The algorithm of Hwang, Du, and Chou can, in the worst case, take exponential time [33]. As shown in <ref> [16] </ref>, the algorithm of Horwitz, Reps, and Binkley is a polynomial-time algorithm; however, even though the slicing problem asks "What statements and predicates might affect the value of x at p?", which is a demand query, the Horwitz-Reps-Binkley algorithm has a phase in which certain auxiliary information is computed by a <p> In contrast, using the approach described in the paper we have explored a number of true demand algorithms for the interprocedural-slicing problem. For example, although the version of the Horwitz-Reps-Binkley algorithm reported in <ref> [16] </ref> is not a true demand algorithm, by using the approach described in the paper|encoding the problem as a logic program and applying the magic-sets transformation|we were able to obtain a true demand version of it.
Reference: [17] <author> S. Horwitz and T. Teitelbaum. </author> <title> Generating editing environments based on relations and attributes. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(4) </volume> <pages> 577-608, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: It is desirable to have program development tools in which the user can ask questions interactively about various aspects of the program <ref> [25, 42, 23, 17] </ref>. Such tools are particularly useful when debugging, when trying to understand complicated code, or when trying to transform a program to execute efficiently on a parallel machine.
Reference: [18] <author> J.C. Hwang, M.W. Du, and C.R. Chou. </author> <title> Finding program slices for recursive procedures. </title> <booktitle> In Proceedings of IEEE COMPSAC 88, </booktitle> <address> Chicago, IL, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: x:(x kill n ) [ gen n is the dataflow function associated with program point n, gen n represents dataflow facts "created" at n and kill n represents dataflow facts "stopped" by n.) The paper also makes use of the approach to obtain a demand algorithm for the interprocedural-slicing problem <ref> [42, 15, 18, 34, 33] </ref>. The remainder of the paper is organized as follows: Section 2 discusses background and assumptions. Section 3 shows how to obtain a demand algorithm for the interprocedural gen-kill problems. Section 4 discusses how to obtain a demand algorithm for the interprocedural-slicing problem. <p> One algorithm for interprocedural slicing was presented by Weiser [42]. However, as pointed out independently by Horwitz, Reps, and Binkley [15] and Hwang, Du, and Chou <ref> [18] </ref>, Weiser's algorithm is imprecise in the sense that it can report "effects" that are transmitted (only) through paths in a graph representation of the program that do not represent "feasible execution paths".
Reference: [19] <author> B. Kernighan and P. Plauger. </author> <title> Software Tools in Pascal. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1981. </year>
Reference-contexts: been tested only on examples of trivial size, the two demand algorithms for the interprocedural-slicing problem (the valid-paths algorithm and the Horwitz-Reps-Binkley algorithm) have been tested on several programs of modest size, the largest being a 757-line program for text formatting taken from Kernighan and Plauger's book on software tools <ref> [19] </ref>. The following table shows how the execution times of the Coral-obtained demand versions of the two interprocedural-slicing algorithms vary depending on the size of the answer: Performance of Demand Algorithms for Interprocedural Slicing (Coral) Number Valid-Paths Alg.
Reference: [20] <author> J. Knoop and B. Steffen. </author> <title> The interprocedural coincidence theorem. </title> <booktitle> In Proceedings of the Fourth International Conference on Compiler Construction, </booktitle> <pages> pages 125-140, </pages> <address> Paderborn, FRG, </address> <month> October </month> <year> 1992. </year> <note> Appeared as Lecture Notes in Computer Science, Vol. 641, </note> <editor> U. Kastens and P. Pfahler (eds.), </editor> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference-contexts: Simplifications (iii) and (iv) prevent the Sharir-Pnueli framework for interpro-cedural dataflow analysis from being able to handle local variables and formal parameters of procedures in the presence of recursion; however, Knoop and Steffen have presented a generalization of the Sharir-Pnueli framework that lifts this restriction <ref> [20] </ref>. <p> It is not clear from the extensions they outline for interprocedural dataflow analysis whether the algorithm obtained will properly account for valid paths. Previous work on inter procedural dataflow analysis has dealt only with the exhaustive case <ref> [36, 20] </ref>. This paper has described how to obtain algorithms for solving demand versions of interprocedural gen-kill dataflow-analysis problems from their exhaustive counterparts. There has been some previous work in which intraprocedural dataflow-analysis problems have been expressed using Horn clauses.
Reference: [21] <author> A. Lakhotia. </author> <title> Constructing call multigraphs using dependence graphs. </title> <booktitle> In Conference Record of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 273-284, </pages> <address> Charleston, SC, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: Rosay and the author have been able to develop a method for constructing call multigraphs in the presence of procedure-valued variables that is compatible with the dataflow-analysis method described in the paper; this work combines 6 Chapter 1 and extends the methods described by Lakhotia <ref> [21] </ref> and Callahan et al. [10].
Reference: [22] <author> W. Landi and B.G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Conference Record of the Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <address> Orlando, FL, </address> <month> January </month> <year> 1991. </year> <title> Demand Interprocedural Program Analysis 33 </title>
Reference-contexts: Such paths fail to account correctly for the calling context (e.g., c 1 in Main) of a called procedure (e.g., P ). Thus, in many interprocedural analysis problems an important issue is to carry out the analysis so that only interprocedurally valid paths are considered <ref> [36, 26, 9, 16, 22] </ref> (see Definitions 3.3 and 4.5). With the approach taken in this paper, if the exhaustive algorithm considers only interprocedurally valid paths, then the demand algorithm obtained will also consider only interprocedurally valid paths.
Reference: [23] <author> M.A. Linton. </author> <title> Implementing relational views of programs. </title> <booktitle> In Proc. ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 132-140, </pages> <address> Pittsburgh, Pennsylva-nia, </address> <month> April </month> <year> 1984. </year> <note> Appeared in SIGPLAN Notices 19, </note> <month> 5 (May </month> <year> 1984). </year>
Reference-contexts: It is desirable to have program development tools in which the user can ask questions interactively about various aspects of the program <ref> [25, 42, 23, 17] </ref>. Such tools are particularly useful when debugging, when trying to understand complicated code, or when trying to transform a program to execute efficiently on a parallel machine.
Reference: [24] <author> J. Lyle and M. Weiser. </author> <title> Experiments on slicing-based debugging tools. </title> <booktitle> In Proceedings of the First Conference on Empirical Studies of Programming, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: This concept, originally discussed by Mark Weiser in [42], allows one to isolate individual computation threads within a program. Slicing can be used for such 16 Chapter 1 diverse activities as helping a programmer understand complicated code, aiding debugging <ref> [24] </ref>, automatically parallelizing programs [41, 4], and automatically combining program variants [14]. (See [37] for an extensive survey of work on program slicing.) The problem of interprocedural slicing concerns how to determine a slice of an entire program, where the slice crosses the boundaries of procedure calls.
Reference: [25] <author> L.M. Masinter. </author> <title> Global program analysis in an interactive environment. </title> <type> Technical Report SSL-80-1, </type> <institution> Xerox Palo Alto Research Center, </institution> <address> Palo Alto, CA, </address> <month> January </month> <year> 1980. </year>
Reference-contexts: It is desirable to have program development tools in which the user can ask questions interactively about various aspects of the program <ref> [25, 42, 23, 17] </ref>. Such tools are particularly useful when debugging, when trying to understand complicated code, or when trying to transform a program to execute efficiently on a parallel machine.
Reference: [26] <author> E. Myers. </author> <title> A precise inter-procedural data flow algorithm. </title> <booktitle> In Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 219-230, </pages> <address> Williamsburg, VA, </address> <month> January </month> <year> 1981. </year>
Reference-contexts: Such paths fail to account correctly for the calling context (e.g., c 1 in Main) of a called procedure (e.g., P ). Thus, in many interprocedural analysis problems an important issue is to carry out the analysis so that only interprocedurally valid paths are considered <ref> [36, 26, 9, 16, 22] </ref> (see Definitions 3.3 and 4.5). With the approach taken in this paper, if the exhaustive algorithm considers only interprocedurally valid paths, then the demand algorithm obtained will also consider only interprocedurally valid paths.
Reference: [27] <author> K.J. Ottenstein and L.M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <address> Pittsburgh, PA, </address> <month> April </month> <year> 1984. </year> <note> Appeared in SIGPLAN Notices 19, </note> <month> 5 (May </month> <year> 1984). </year>
Reference-contexts: In intraprocedural slicing|the problem of slicing a program that consists of just a single monolithic procedure|a slice can be determined from the closure of the directly-affects relation. Ottenstein and Ottenstein pointed out how well-suited program dependence graphs are for this kind of slicing <ref> [27] </ref>.
Reference: [28] <author> R. Ramakrishnan, P. Seshadri, D. Srivastava, and S. Sudarshan. </author> <note> Coral pre-Release 1.0 Software System. Available via ftp from ftp.cs.wisc.edu, </note> <year> 1993. </year>
Reference-contexts: In principle, the second step is completely automatic. In practice|at least with the Coral system <ref> [29, 28, 30] </ref>|to obtain the most efficient program, the user may need to rewrite certain recursive rules and reorder literals in some rules. <p> a query "?valid path (r,z,P,U)" (by bottom-up evaluation of the transformed program) valid path tuples are computed only for the vertices on valid paths to z. 5 PRELIMINARY EXPERIMENTAL RESULTS This section reports some performance results obtained on a Sun 10 with pre-Release 1.0 of the Coral deductive database system <ref> [28] </ref>.
Reference: [29] <author> R. Ramakrishnan, P. Seshadri, D. Srivastava, and S. Sudarshan. </author> <title> The Coral user manual: A tutorial introduction to Coral. </title> <type> Unpublished report, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI, </institution> <year> 1993. </year>
Reference-contexts: In principle, the second step is completely automatic. In practice|at least with the Coral system <ref> [29, 28, 30] </ref>|to obtain the most efficient program, the user may need to rewrite certain recursive rules and reorder literals in some rules.
Reference: [30] <author> R. Ramakrishnan, P. Seshadri, D. Srivastava, and S. Sudarshan. </author> <title> Implementation of the Coral deductive database system. </title> <booktitle> In Proceedings of the ACM SIGMOD 93 Conference, </booktitle> <pages> pages 167-176, </pages> <year> 1993. </year>
Reference-contexts: In principle, the second step is completely automatic. In practice|at least with the Coral system <ref> [29, 28, 30] </ref>|to obtain the most efficient program, the user may need to rewrite certain recursive rules and reorder literals in some rules.
Reference: [31] <author> T. Reps. </author> <title> The Wisconsin program-integration system reference manual: Release 2.0. </title> <type> Unpublished report, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: We already had a C implementation of the Horwitz-Reps-Binkley algorithm that ran on a Sun 10 <ref> [31] </ref>. As mentioned in Section 4, the Horwitz-Reps-Binkley algorithm has a phase in which certain auxiliary information is computed by a preliminary exhaustive algorithm.
Reference: [32] <author> T. Reps. </author> <title> Solving demand versions of interprocedural analysis problems. </title> <booktitle> In Proceedings of the Fifth International Conference on Compiler Construction, </booktitle> <pages> pages 389-403, </pages> <address> Edinburgh, Scotland, </address> <month> April </month> <year> 1994. </year> <note> Appeared as Lecture Notes in Computer Science, Vol. 786, </note> <editor> P. Fritzson (ed.), </editor> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1994. </year> <note> 34 Chapter 1 </note>
Reference-contexts: the summary information at one program point typically depends on summary information from other points, an important issue is to minimize the number of other points 1 An abbreviated version of this paper, discussing only interprocedural dataflow analysis, appeared in the Proceedings of the Fifth International Conference on Compiler Construction <ref> [32] </ref>. 2 Chapter 1 for which (transient) summary information is computed and/or the amount of information computed at those points. There are several reasons why it is desirable to solve the demand versions of interprocedural analysis problems: Narrowing the focus to specific points of interest.
Reference: [33] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reachability. </title> <type> Technical Report TOPPS D-216, </type> <institution> Datalogisk Institut, University of Copenhagen, Copenhagen, Denmark, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: x:(x kill n ) [ gen n is the dataflow function associated with program point n, gen n represents dataflow facts "created" at n and kill n represents dataflow facts "stopped" by n.) The paper also makes use of the approach to obtain a demand algorithm for the interprocedural-slicing problem <ref> [42, 15, 18, 34, 33] </ref>. The remainder of the paper is organized as follows: Section 2 discusses background and assumptions. Section 3 shows how to obtain a demand algorithm for the interprocedural gen-kill problems. Section 4 discusses how to obtain a demand algorithm for the interprocedural-slicing problem. <p> Previous work on interprocedural slicing has the following drawbacks: The interprocedural slicing algorithm of Weiser [42] is imprecise in the sense that it considers paths that are not interprocedurally valid paths. The algorithm of Hwang, Du, and Chou can, in the worst case, take exponential time <ref> [33] </ref>. <p> this formalism is equivalent to Datalog. 6.2 Interprocedural Slicing Hwang, Du, and Chou did not give an analysis of the running time of their interprocedural-slicing algorithm; however, I was able to show that the Hwang-Du-Chou algorithm could, in the worst case, use time exponential in the size of the program <ref> [33] </ref>. After discovering this, I began to consider strategies that could be used to overcome this drawback, which led to the approach followed in this paper. <p> Sagiv, S. Horwitz, and the author have shown a new connection between the interprocedural-slicing problem and a large class of interprocedu-ral dataflow-analysis problems <ref> [34, 33] </ref>. In particular, they have shown that all of these problems can be reduced to the valid-path-reachability problem.
Reference: [34] <author> T. Reps, M. Sagiv, and S. Horwitz. </author> <title> Interprocedural dataflow analysis via graph reachability. </title> <type> Technical Report TR 94-14, </type> <institution> Datalogisk Institut, University of Copenhagen, Copenhagen, Denmark, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: x:(x kill n ) [ gen n is the dataflow function associated with program point n, gen n represents dataflow facts "created" at n and kill n represents dataflow facts "stopped" by n.) The paper also makes use of the approach to obtain a demand algorithm for the interprocedural-slicing problem <ref> [42, 15, 18, 34, 33] </ref>. The remainder of the paper is organized as follows: Section 2 discusses background and assumptions. Section 3 shows how to obtain a demand algorithm for the interprocedural gen-kill problems. Section 4 discusses how to obtain a demand algorithm for the interprocedural-slicing problem. <p> Sagiv, S. Horwitz, and the author have shown a new connection between the interprocedural-slicing problem and a large class of interprocedu-ral dataflow-analysis problems <ref> [34, 33] </ref>. In particular, they have shown that all of these problems can be reduced to the valid-path-reachability problem.
Reference: [35] <author> R. Rohmer, R. Lescoeur, and J.-M. Kersit. </author> <title> The Alexander method, a technique for the processing of recursive axioms in deductive databases. </title> <journal> New Generation Computing, </journal> <volume> 4(3) </volume> <pages> 273-285, </pages> <year> 1986. </year>
Reference-contexts: With the approach presented in this paper, this capability is obtained for free, as a by-product of the way the composition of two computations is treated by the magic-sets transformation <ref> [35, 5, 8] </ref>. Sidestepping incremental-updating problems. An optimizing transforma tion performed at one point in the program can invalidate previously computed dataflow information at other points in the program.
Reference: [36] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. In Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 189-233. </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: For example, in interprocedural dataflow analysis, analysis is carried out on a structure that consists of a control-flow graph for each procedure, plus some additional procedure-linkage information <ref> [1, 7, 36, 11] </ref>. In interprocedural analysis problems, not all of the paths in the graphs that represent the program correspond to possible execution paths. <p> Such paths fail to account correctly for the calling context (e.g., c 1 in Main) of a called procedure (e.g., P ). Thus, in many interprocedural analysis problems an important issue is to carry out the analysis so that only interprocedurally valid paths are considered <ref> [36, 26, 9, 16, 22] </ref> (see Definitions 3.3 and 4.5). With the approach taken in this paper, if the exhaustive algorithm considers only interprocedurally valid paths, then the demand algorithm obtained will also consider only interprocedurally valid paths. <p> To streamline the presentation, the analysis problems discussed in Sections 3 and 4 have been simplified in certain ways. In particular, following Sharir and Pnueli <ref> [36] </ref> and Horwitz, Reps, and Binkley [16] we assume that (i) the programs being analyzed do not contain aliasing and (ii) the programs being analyzed do not use procedure-valued variables. We also make some simplifying assumptions about global variables. <p> The basis for the exhaustive algorithm is Sharir and Pnueli's "functional approach" to interprocedural dataflow analysis, which, for distributive dataflow functions, yields the meet-over-all-valid-paths solution to certain classes of flow-sensitive interprocedural dataflow analysis problems <ref> [36] </ref>. We assume that (L; u) is a meet semilattice of dataflow facts with a smallest element ? and a largest element &gt;. We also assume that dataflow functions are members of a space of monotonic (or distributive) functions F L ! L and that F contains the identity function. <p> Sharir and Pnueli make use of two different graph representations of programs, which are defined below. Demand Interprocedural Program Analysis 7 Definition 3.1 (Sharir and Pnueli <ref> [36] </ref>) Let G 0 ; G 1 ; :::; G k be a collection of flow graphs, where each G p is a directed graph corresponding to a procedure of the program, and G p = (N p ; E p ; s p ; e p ). <p> The second graph representation, in which the flow graphs of the different procedures are connected together, is used to define the notion of interprocedurally valid paths. Definition 3.2 (Sharir and Pnueli <ref> [36] </ref>) Define G fl = (N fl ; E fl ; s main ), where N fl = p N p and E fl = E 0 [ E 2 , where E 0 = S p is the collection of all ordinary control-flow edges, and an edge (m; n) 2 <p> edge (e q ; n) correspond to each other if p = q and (m; n) 2 E 1 s for some procedure s. 2 The notion of interprocedurally valid paths captures the idea that not all paths through G fl represent potential execution paths: Definition 3.3 (Sharir and Pnueli <ref> [36] </ref>) For each n 2 N , we define IVP (s main ; n) as the set of all interprocedurally valid paths in G fl that lead from s main to n. <p> return edge, then q 2 is proper if i &gt; 1 and q 2 (i 1) is a call edge corresponding to the return edge q 2 (i), and after deleting those two components from q 2 , the remaining sequence is also proper. 2 Definition 3.4 (Sharir and Pnueli <ref> [36] </ref>) If q is a path in G fl , let pf q denote the (path) function obtained by composing the functions associated with q's edges (in the order that they appear in path q). <p> p ) for each procedure p and n 2 (N p fs p g) Sharir and Pnueli showed that if the edge functions are distributive, the greatest solution to the above set of equations is equal to the meet-over-all-valid-paths solution (i.e., for all n, x n = y n ) <ref> [36] </ref>. 3.1 Representing an Interprocedural Dataflow Analysis Problem To make use of the Sharir-Pnueli formulation for our purposes, it is necessary to find an appropriate way to use Horn clauses to express (i) the dataflow functions on the edges of the control-flow graph, (ii) the application of a function to an <p> It is not clear from the extensions they outline for interprocedural dataflow analysis whether the algorithm obtained will properly account for valid paths. Previous work on inter procedural dataflow analysis has dealt only with the exhaustive case <ref> [36, 20] </ref>. This paper has described how to obtain algorithms for solving demand versions of interprocedural gen-kill dataflow-analysis problems from their exhaustive counterparts. There has been some previous work in which intraprocedural dataflow-analysis problems have been expressed using Horn clauses.
Reference: [37] <author> F. </author> <title> Tip. A survey of program slicing techniques. </title> <type> Technical Report CS-R9438, </type> <institution> Centrum voor Wiskunde en Informatica (CWI), </institution> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: Slicing can be used for such 16 Chapter 1 diverse activities as helping a programmer understand complicated code, aiding debugging [24], automatically parallelizing programs [41, 4], and automatically combining program variants [14]. (See <ref> [37] </ref> for an extensive survey of work on program slicing.) The problem of interprocedural slicing concerns how to determine a slice of an entire program, where the slice crosses the boundaries of procedure calls. One algorithm for interprocedural slicing was presented by Weiser [42].
Reference: [38] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, Volume II: The New Technologies. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year>
Reference-contexts: There has been some previous work in which intraprocedural dataflow-analysis problems have been expressed using Horn clauses. For instance, one of the Demand Interprocedural Program Analysis 29 examples in Ullman's book shows how a logic database can be used to solve the intraprocedural reaching-definitions problem <ref> [38, pp. 984-987] </ref>. U. Assmann has examined a variety of other intraprocedural program-analysis problems [2].
Reference: [39] <author> D.S. Warren. </author> <title> Memoing for logic programs. </title> <journal> Commun. of the ACM, </journal> <volume> 35(3) </volume> <pages> 93-111, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Warren and others concerning the use of tabulation techniques in top-down evaluation of logic programs <ref> [39] </ref> was brought to my attention. These techniques provide an alternative method for obtaining demand algorithms for program-analysis problems.
Reference: [40] <author> D.S. Warren. </author> <title> XSB Logic Programming System. </title> <note> Available via ftp from sbcs.sunysb.edu, </note> <year> 1993. </year>
Reference-contexts: Thus, another way to obtain implementations of demand algorithms for the in-terprocedural dataflow-analysis and interprocedural-slicing problems would be to use the programs from Sections 3 and 4 in conjunction with the SUNY-Stony Brook XSB system <ref> [40] </ref>. 6.1 Dataflow Analysis Previous work on demand-driven dataflow analysis has dealt only with the in-traprocedural case [3, 43].
Reference: [41] <author> M. Weiser. </author> <title> Reconstructing sequential behavior from parallel behavior projections. </title> <journal> Information Processing Letters, </journal> <volume> 17 </volume> <pages> 129-135, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: This concept, originally discussed by Mark Weiser in [42], allows one to isolate individual computation threads within a program. Slicing can be used for such 16 Chapter 1 diverse activities as helping a programmer understand complicated code, aiding debugging [24], automatically parallelizing programs <ref> [41, 4] </ref>, and automatically combining program variants [14]. (See [37] for an extensive survey of work on program slicing.) The problem of interprocedural slicing concerns how to determine a slice of an entire program, where the slice crosses the boundaries of procedure calls.
Reference: [42] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: It is desirable to have program development tools in which the user can ask questions interactively about various aspects of the program <ref> [25, 42, 23, 17] </ref>. Such tools are particularly useful when debugging, when trying to understand complicated code, or when trying to transform a program to execute efficiently on a parallel machine. <p> x:(x kill n ) [ gen n is the dataflow function associated with program point n, gen n represents dataflow facts "created" at n and kill n represents dataflow facts "stopped" by n.) The paper also makes use of the approach to obtain a demand algorithm for the interprocedural-slicing problem <ref> [42, 15, 18, 34, 33] </ref>. The remainder of the paper is organized as follows: Section 2 discusses background and assumptions. Section 3 shows how to obtain a demand algorithm for the interprocedural gen-kill problems. Section 4 discusses how to obtain a demand algorithm for the interprocedural-slicing problem. <p> The slice of a program with respect to program point p and variable x consists of all statements and predicates of the program that might affect the value of x at point p. This concept, originally discussed by Mark Weiser in <ref> [42] </ref>, allows one to isolate individual computation threads within a program. <p> One algorithm for interprocedural slicing was presented by Weiser <ref> [42] </ref>. However, as pointed out independently by Horwitz, Reps, and Binkley [15] and Hwang, Du, and Chou [18], Weiser's algorithm is imprecise in the sense that it can report "effects" that are transmitted (only) through paths in a graph representation of the program that do not represent "feasible execution paths". <p> The algorithms of Horwitz, Reps, and Binkley and Hwang, Du, and Chou improve on Weiser's algorithm by only considering effects transmitted along interprocedurally valid paths. Previous work on interprocedural slicing has the following drawbacks: The interprocedural slicing algorithm of Weiser <ref> [42] </ref> is imprecise in the sense that it considers paths that are not interprocedurally valid paths. The algorithm of Hwang, Du, and Chou can, in the worst case, take exponential time [33]. <p> This is explained in Section 4.2. 4.2 The Calling-Context Problem and Valid Paths Weiser describes his method for interprocedural slicing as follows <ref> [42] </ref>: For each criterion C for a procedure P , there is a set of criteria UP 0 (C) which are those needed to slice callers of P , and a set of 18 Chapter 1 criteria DOWN 0 (C) which are those needed to slice procedures called by P .
Reference: [43] <author> F.K. Zadeck. </author> <title> Incremental data flow analysis in a structured program editor. </title> <booktitle> In Proceedings of the SIGPLAN 84 Symposium on Compiler Construction, </booktitle> <pages> pages 132-143, </pages> <address> Montreal, Can., </address> <month> June </month> <year> 1984. </year> <note> Appeared in SIGPLAN Notices 19, </note> <month> 6 (June </month> <year> 1984). </year>
Reference-contexts: way to obtain implementations of demand algorithms for the in-terprocedural dataflow-analysis and interprocedural-slicing problems would be to use the programs from Sections 3 and 4 in conjunction with the SUNY-Stony Brook XSB system [40]. 6.1 Dataflow Analysis Previous work on demand-driven dataflow analysis has dealt only with the in-traprocedural case <ref> [3, 43] </ref>. The work that has been reported in the present paper 28 Chapter 1 complements previous work on the intraprocedural case in the sense that our approach to obtaining algorithms for demand-driven dataflow analysis problems applies equally well to intraprocedural dataflow analysis.
References-found: 43

