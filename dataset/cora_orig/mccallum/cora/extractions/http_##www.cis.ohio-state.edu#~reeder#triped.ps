URL: http://www.cis.ohio-state.edu/~reeder/triped.ps
Refering-URL: http://www.cis.ohio-state.edu/~reeder/reeder_29Aug97.html
Root-URL: 
Title: THREE-LEGGED ROBOTS: GAIT, KINEMATICS, DYNAMICS SIMULATION  
Author: By P. Douglas Reeder, B.A. Dr. Kenneth J. Waldron 
Degree: A Thesis Presented in Partial Fulfillment of the Requirements for the Degree Master of Science in the  Master's Examination Committee: Dr. Hooshang Hemami, Advisor  Approved by Advisor  
Date: 1996  
Affiliation: Graduate School of The Ohio State University  The Ohio State University  Department of Electrical Engineering  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> anonymous, </author> <booktitle> Encylopedia Brittanica 15th Edition, </booktitle> <volume> vol. 3, </volume> <editor> p. </editor> <volume> 148. </volume> <publisher> Chicago: Encylopedia Brittanica, Inc., </publisher> <year> 1994. </year>
Reference-contexts: Locomotion is intimately connected with animals' biological niche | herbivores must travel continually to forage, and must be able hide or run away from predators. Predators, likewise, must be able to hunt down prey. Cheetahs can sprint at up to 100 km/hr across the savanna <ref> [1] </ref>, much faster than any wheeled or tracked vehicle can travel off-road. How animals locomote, and locomote efficiently, is a significant question of natural science. Legged robots provide an important type of testing and validation for theories of animal locomotion. <p> ) + sin ( 6 ) 2 sin ( 5 ) d4 116 &gt; beta4 := evalm (R4B &* vector ([0, 0, 1])); &gt; &gt; beta5 := evalm (crossprod (p5B,gamma5)); &gt; &gt; beta6 := evalm (crossprod (p6B,gamma6)); &gt; &gt; # &gt; J := matrix (6,6): &gt; J [1,1] := gamma1 <ref> [1] </ref>: &gt; J [2,1] := gamma1 [2]: &gt; J [3,1] := gamma1 [3]: &gt; J [4,1] := beta1 [1]: &gt; J [5,1] := beta1 [2]: &gt; J [6,1] := beta1 [3]: &gt; J [1,2] := gamma2 [1]: &gt; J [2,2] := gamma2 [2]: &gt; J [3,2] := gamma2 [3]: &gt; J <p> &* vector ([0, 0, 1])); &gt; &gt; beta5 := evalm (crossprod (p5B,gamma5)); &gt; &gt; beta6 := evalm (crossprod (p6B,gamma6)); &gt; &gt; # &gt; J := matrix (6,6): &gt; J [1,1] := gamma1 <ref> [1] </ref>: &gt; J [2,1] := gamma1 [2]: &gt; J [3,1] := gamma1 [3]: &gt; J [4,1] := beta1 [1]: &gt; J [5,1] := beta1 [2]: &gt; J [6,1] := beta1 [3]: &gt; J [1,2] := gamma2 [1]: &gt; J [2,2] := gamma2 [2]: &gt; J [3,2] := gamma2 [3]: &gt; J [4,2] := beta2 [1]: &gt; J [5,2] := beta2 [2]: &gt; J [6,2] := beta2 [3]: &gt; J <p> (p6B,gamma6)); &gt; &gt; # &gt; J := matrix (6,6): &gt; J [1,1] := gamma1 <ref> [1] </ref>: &gt; J [2,1] := gamma1 [2]: &gt; J [3,1] := gamma1 [3]: &gt; J [4,1] := beta1 [1]: &gt; J [5,1] := beta1 [2]: &gt; J [6,1] := beta1 [3]: &gt; J [1,2] := gamma2 [1]: &gt; J [2,2] := gamma2 [2]: &gt; J [3,2] := gamma2 [3]: &gt; J [4,2] := beta2 [1]: &gt; J [5,2] := beta2 [2]: &gt; J [6,2] := beta2 [3]: &gt; J [1,3] := gamma3 [1]: &gt; J [2,3] := gamma3 [2]: &gt; J [3,3] := gamma3 [3]: &gt; J <p> := gamma1 [2]: &gt; J [3,1] := gamma1 [3]: &gt; J [4,1] := beta1 <ref> [1] </ref>: &gt; J [5,1] := beta1 [2]: &gt; J [6,1] := beta1 [3]: &gt; J [1,2] := gamma2 [1]: &gt; J [2,2] := gamma2 [2]: &gt; J [3,2] := gamma2 [3]: &gt; J [4,2] := beta2 [1]: &gt; J [5,2] := beta2 [2]: &gt; J [6,2] := beta2 [3]: &gt; J [1,3] := gamma3 [1]: &gt; J [2,3] := gamma3 [2]: &gt; J [3,3] := gamma3 [3]: &gt; J [4,3] := beta3 [1]: &gt; J [5,3] := beta3 [2]: &gt; J [6,3] := simplify (beta3 [3]): &gt; <p> := beta1 [2]: &gt; J [6,1] := beta1 [3]: &gt; J [1,2] := gamma2 <ref> [1] </ref>: &gt; J [2,2] := gamma2 [2]: &gt; J [3,2] := gamma2 [3]: &gt; J [4,2] := beta2 [1]: &gt; J [5,2] := beta2 [2]: &gt; J [6,2] := beta2 [3]: &gt; J [1,3] := gamma3 [1]: &gt; J [2,3] := gamma3 [2]: &gt; J [3,3] := gamma3 [3]: &gt; J [4,3] := beta3 [1]: &gt; J [5,3] := beta3 [2]: &gt; J [6,3] := simplify (beta3 [3]): &gt; J [1,4] := gamma4 [1]: &gt; J [2,4] := gamma4 [2]: &gt; J [3,4] := gamma4 [3]: &gt; <p> := gamma2 [2]: &gt; J [3,2] := gamma2 [3]: &gt; J [4,2] := beta2 <ref> [1] </ref>: &gt; J [5,2] := beta2 [2]: &gt; J [6,2] := beta2 [3]: &gt; J [1,3] := gamma3 [1]: &gt; J [2,3] := gamma3 [2]: &gt; J [3,3] := gamma3 [3]: &gt; J [4,3] := beta3 [1]: &gt; J [5,3] := beta3 [2]: &gt; J [6,3] := simplify (beta3 [3]): &gt; J [1,4] := gamma4 [1]: &gt; J [2,4] := gamma4 [2]: &gt; J [3,4] := gamma4 [3]: &gt; J [4,4] := beta4 [1]: &gt; J [5,4] := beta4 [2]: &gt; J [6,4] := beta4 [3]: &gt; <p> beta2 [2]: &gt; J [6,2] := beta2 [3]: &gt; J [1,3] := gamma3 <ref> [1] </ref>: &gt; J [2,3] := gamma3 [2]: &gt; J [3,3] := gamma3 [3]: &gt; J [4,3] := beta3 [1]: &gt; J [5,3] := beta3 [2]: &gt; J [6,3] := simplify (beta3 [3]): &gt; J [1,4] := gamma4 [1]: &gt; J [2,4] := gamma4 [2]: &gt; J [3,4] := gamma4 [3]: &gt; J [4,4] := beta4 [1]: &gt; J [5,4] := beta4 [2]: &gt; J [6,4] := beta4 [3]: &gt; J [1,5] := gamma5 [1]: &gt; J [2,5] := gamma5 [2]: &gt; J [3,5] := gamma5 [3]: &gt; J <p> gamma3 [2]: &gt; J [3,3] := gamma3 [3]: &gt; J [4,3] := beta3 <ref> [1] </ref>: &gt; J [5,3] := beta3 [2]: &gt; J [6,3] := simplify (beta3 [3]): &gt; J [1,4] := gamma4 [1]: &gt; J [2,4] := gamma4 [2]: &gt; J [3,4] := gamma4 [3]: &gt; J [4,4] := beta4 [1]: &gt; J [5,4] := beta4 [2]: &gt; J [6,4] := beta4 [3]: &gt; J [1,5] := gamma5 [1]: &gt; J [2,5] := gamma5 [2]: &gt; J [3,5] := gamma5 [3]: &gt; J [4,5] := beta5 [1]: &gt; J [5,5] := beta5 [2]: &gt; J [6,5] := beta5 [3]: &gt; J <p> beta3 [2]: &gt; J [6,3] := simplify (beta3 [3]): &gt; J [1,4] := gamma4 <ref> [1] </ref>: &gt; J [2,4] := gamma4 [2]: &gt; J [3,4] := gamma4 [3]: &gt; J [4,4] := beta4 [1]: &gt; J [5,4] := beta4 [2]: &gt; J [6,4] := beta4 [3]: &gt; J [1,5] := gamma5 [1]: &gt; J [2,5] := gamma5 [2]: &gt; J [3,5] := gamma5 [3]: &gt; J [4,5] := beta5 [1]: &gt; J [5,5] := beta5 [2]: &gt; J [6,5] := beta5 [3]: &gt; J [1,6] := gamma6 [1]: &gt; J [2,6] := gamma6 [2]: &gt; J [3,6] := gamma6 [3]: &gt; J <p> := gamma4 [2]: &gt; J [3,4] := gamma4 [3]: &gt; J [4,4] := beta4 <ref> [1] </ref>: &gt; J [5,4] := beta4 [2]: &gt; J [6,4] := beta4 [3]: &gt; J [1,5] := gamma5 [1]: &gt; J [2,5] := gamma5 [2]: &gt; J [3,5] := gamma5 [3]: &gt; J [4,5] := beta5 [1]: &gt; J [5,5] := beta5 [2]: &gt; J [6,5] := beta5 [3]: &gt; J [1,6] := gamma6 [1]: &gt; J [2,6] := gamma6 [2]: &gt; J [3,6] := gamma6 [3]: &gt; J [4,6] := beta6 [1]: 117 &gt; J [5,6] := beta6 [2]: &gt; J [6,6] := beta6 [3]: &gt; <p> := beta4 [2]: &gt; J [6,4] := beta4 [3]: &gt; J [1,5] := gamma5 <ref> [1] </ref>: &gt; J [2,5] := gamma5 [2]: &gt; J [3,5] := gamma5 [3]: &gt; J [4,5] := beta5 [1]: &gt; J [5,5] := beta5 [2]: &gt; J [6,5] := beta5 [3]: &gt; J [1,6] := gamma6 [1]: &gt; J [2,6] := gamma6 [2]: &gt; J [3,6] := gamma6 [3]: &gt; J [4,6] := beta6 [1]: 117 &gt; J [5,6] := beta6 [2]: &gt; J [6,6] := beta6 [3]: &gt; J := evalm (J); &gt; [ %1 ; %2 ; sin ( 6 ) ; 0 ; sin <p> := gamma5 [2]: &gt; J [3,5] := gamma5 [3]: &gt; J [4,5] := beta5 <ref> [1] </ref>: &gt; J [5,5] := beta5 [2]: &gt; J [6,5] := beta5 [3]: &gt; J [1,6] := gamma6 [1]: &gt; J [2,6] := gamma6 [2]: &gt; J [3,6] := gamma6 [3]: &gt; J [4,6] := beta6 [1]: 117 &gt; J [5,6] := beta6 [2]: &gt; J [6,6] := beta6 [3]: &gt; J := evalm (J); &gt; [ %1 ; %2 ; sin ( 6 ) ; 0 ; sin ( 6 ) ; 0 ] [ %5 sin ( 2 ) ; %6 ; 0 ; 0 <p> const double altitude = 1.75; const double turntime = 1.4; //const double turntime = timelimit; cout &lt;< "------------------------- time = " &lt;< el_time &lt;< endl; /* // stand still desired_pos.assign (6,0.0); desired_pos [0] = M_PI/2.0; desired_pos [2] = M_PI/2.0; for (int i=0; i&lt;num_legs; ++i) desired_pos [i+3] = body_start [i]; //desired_pos <ref> [1] </ref> = tilt; desired_vel.assign (6,0.0); desired_accel.assign (6,0.0); */ if (el_time&lt;turntime) - // walk forward desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos [1] = -M_PI_4; desired_pos [2] = M_PI_2; desired_pos [3] = body_start [0]+desired_speed*M_SQRT1_2*el_time; desired_pos [4] = body_start [1]-desired_speed*M_SQRT1_2*el_time; desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< <p> &lt;< el_time &lt;< endl; /* // stand still desired_pos.assign (6,0.0); desired_pos [0] = M_PI/2.0; desired_pos [2] = M_PI/2.0; for (int i=0; i&lt;num_legs; ++i) desired_pos [i+3] = body_start [i]; //desired_pos <ref> [1] </ref> = tilt; desired_vel.assign (6,0.0); desired_accel.assign (6,0.0); */ if (el_time&lt;turntime) - // walk forward desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos [1] = -M_PI_4; desired_pos [2] = M_PI_2; desired_pos [3] = body_start [0]+desired_speed*M_SQRT1_2*el_time; desired_pos [4] = body_start [1]-desired_speed*M_SQRT1_2*el_time; desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; 123 desired_vel.assign (6,0.0); desired_vel [3] = desired_speed*M_SQRT1_2; desired_vel [4] = -desired_speed*M_SQRT1_2; desired_accel.assign (6,0.0); - if (el_time&gt;=turntime) - // circular turn <p> //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; 123 desired_vel.assign (6,0.0); desired_vel [3] = desired_speed*M_SQRT1_2; desired_vel [4] = -desired_speed*M_SQRT1_2; desired_accel.assign (6,0.0); - if (el_time&gt;=turntime) - // circular turn to left const double radius = 5; double rho = (el_time-turntime)*desired_speed/radius - M_PI_4; desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos <ref> [1] </ref> = rho; // euler angle beta desired_pos [2] = M_PI_2; desired_pos [3] = body_start [0] + turntime*desired_speed*M_SQRT1_2 + radius*(sin (rho)+M_SQRT1_2); desired_pos [4] = body_start [1] - turntime*desired_speed*M_SQRT1_2 - radius*(cos (rho) - M_SQRT1_2); desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; desired_vel.assign (6,0.0); desired_vel [2] <p> (el_time&gt;=turntime) - // circular turn to left const double radius = 5; double rho = (el_time-turntime)*desired_speed/radius - M_PI_4; desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos <ref> [1] </ref> = rho; // euler angle beta desired_pos [2] = M_PI_2; desired_pos [3] = body_start [0] + turntime*desired_speed*M_SQRT1_2 + radius*(sin (rho)+M_SQRT1_2); desired_pos [4] = body_start [1] - turntime*desired_speed*M_SQRT1_2 - radius*(cos (rho) - M_SQRT1_2); desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; desired_vel.assign (6,0.0); desired_vel [2] = desired_speed/radius; // rotate about z axis desired_vel [3] = desired_speed*cos (rho); desired_vel [4] = desired_speed*sin (rho); //cout &lt;< desired_vel &lt;< " = desired velocity" <p> - // for (leg=0..3) // calculate body angles double alpha, beta; //cout &lt;< RBG &lt;< " = rotation of body in ground frame" &lt;< endl; // Euler X-Y-Z (or fixed Z-Y-X) double cbeta = sqrt (RBG.elem <ref> [1] </ref>[2]*RBG.elem [1][2]+ RBG.elem [2][2]*RBG.elem [2][2]); if (cbeta != 0.0) - 125 beta = body_pos [1] = atan2 (RBG.elem [0][2],cbeta); alpha = body_pos [0] = atan2 (-RBG.elem [1][2]/cbeta,RBG.elem [2][2]/cbeta); body_pos [2] = atan2 (-RBG.elem [0][1]/cbeta,RBG.elem [0][0]/cbeta); else-// degenerate beta = body_pos [1] = M_PI/2.0; alpha = body_pos [0] = 0; body_pos [2] = atan2 (RBG.elem [2][1],RBG.elem [1][1]); - //cout &lt;< body_pos &lt;< " = angles using <p> Euler X-Y-Z (or fixed Z-Y-X) double cbeta = sqrt (RBG.elem <ref> [1] </ref>[2]*RBG.elem [1][2]+ RBG.elem [2][2]*RBG.elem [2][2]); if (cbeta != 0.0) - 125 beta = body_pos [1] = atan2 (RBG.elem [0][2],cbeta); alpha = body_pos [0] = atan2 (-RBG.elem [1][2]/cbeta,RBG.elem [2][2]/cbeta); body_pos [2] = atan2 (-RBG.elem [0][1]/cbeta,RBG.elem [0][0]/cbeta); else-// degenerate beta = body_pos [1] = M_PI/2.0; alpha = body_pos [0] = 0; body_pos [2] = atan2 (RBG.elem [2][1],RBG.elem [1][1]); - //cout &lt;< body_pos &lt;< " = angles using fixed Z-Y-X" &lt;< endl; for (int i=0; i&lt;3; ++i) - body_pos [3+i] = pBG [i]; - //cout &lt;< body_pos &lt;< " = body position" &lt;< endl; <p> machine if appropriate switch (state) - case inner_fwd: if (joint_ang [0]<ref> [1] </ref> &lt; M_PI*.54) - state = inner_only; t_touchdown = el_time+air_time; // what will eventually happen is forces will be applied to // lift the feet, and the plant model will set the foot sensors // But for now, cheat! foot_up [1] = foot_up [2] = true; ref_leg = 0; cout &lt;< "OUTER LEGS LIFTED" &lt;< endl; - break; case inner_only: if (el_time &gt; t_touchdown) - // touchdown! state = outer_fwd; /* foot_up [1] = foot_up [2] = false; double theta2p = joint_ang [0][1]; //joint_ang [1][0] = body_pos [2] - M_PI/2; //joint_ang <p> lift the feet, and the plant model will set the foot sensors // But for now, cheat! foot_up <ref> [1] </ref> = foot_up [2] = true; ref_leg = 0; cout &lt;< "OUTER LEGS LIFTED" &lt;< endl; - break; case inner_only: if (el_time &gt; t_touchdown) - // touchdown! state = outer_fwd; /* foot_up [1] = foot_up [2] = false; double theta2p = joint_ang [0][1]; //joint_ang [1][0] = body_pos [2] - M_PI/2; //joint_ang [2][0] = body_pos [2] - M_PI/2; joint_ang [1][0] = joint_ang [0][0]; joint_ang [2][0] = joint_ang [0][0]; joint_ang [1][1] = 2*M_PI/3; // theta2 = 2/3 pi joint_ang [2][1] = 2*M_PI/3-.01; // slight offset <p> M_PI/2; 129 joint_ang <ref> [1] </ref>[4] = M_PI/2; joint_ang [2][4] = M_PI/2; double d41 = joint_ang [0][3]*sin (theta2p)/.8660; double d42 = joint_ang [0][3]*sin (theta2p)/.8661; joint_ang [1][3] = d41; joint_ang [2][3] = d42; // calculate values for leg 1 calc_body_matricies (1, junk, offset); foot_lin_pos [1].subtract (pBG,offset); foot_linear_vel [1].assign (3, 0.0); cout &lt;< foot_lin_pos [1] &lt;< " = position of foot 1" &lt;< endl; // calculate values for leg 2 calc_body_matricies (2, junk, offset); foot_lin_pos [2].subtract (pBG,offset); foot_linear_vel [2].assign (3, 0.0); cout &lt;< foot_lin_pos [2] &lt;< " = position of foot 2" &lt;< endl; */ place_foot (1,0); place_foot (2,0); cout &lt;< "OUTER LEGS TOUCHED DOWN" <p> cheat! foot_up [0] = true; ref_leg = 1; cout &lt;< "INNER LEG LIFTED" &lt;< endl; - break; case outer_only: if (el_time &gt; t_touchdown) - // touchdown! 130 state = inner_fwd; /* foot_up [0] = false; double theta2p = joint_ang <ref> [1] </ref>[1]; // joint_ang [0][0] = joint_ang [2][0]; joint_ang [0][0] = body_pos [1] - desired_vel [2]/3; // heuristic joint_ang [0][0] = body_pos [1]; joint_ang [0][1] = M_PI*5/8; // theta2 = 5/8 pi joint_ang [0][2] = M_PI_2; joint_ang [0][3] = joint_ang [1][3]* sin (theta2p)/sin (M_PI-joint_ang [0][1]); joint_ang [0][4] = M_PI_2; joint_ang [0][5] = -joint_ang [0][1]+joint_ang [1][5]+theta2p; //offset_x [0] = offset_x [1] + joint_ang [1][3]*cos <p> "INNER LEG LIFTED" &lt;< endl; - break; case outer_only: if (el_time &gt; t_touchdown) - // touchdown! 130 state = inner_fwd; /* foot_up [0] = false; double theta2p = joint_ang <ref> [1] </ref>[1]; // joint_ang [0][0] = joint_ang [2][0]; joint_ang [0][0] = body_pos [1] - desired_vel [2]/3; // heuristic joint_ang [0][0] = body_pos [1]; joint_ang [0][1] = M_PI*5/8; // theta2 = 5/8 pi joint_ang [0][2] = M_PI_2; joint_ang [0][3] = joint_ang [1][3]* sin (theta2p)/sin (M_PI-joint_ang [0][1]); joint_ang [0][4] = M_PI_2; joint_ang [0][5] = -joint_ang [0][1]+joint_ang [1][5]+theta2p; //offset_x [0] = offset_x [1] + joint_ang [1][3]*cos (theta2p) + d4/2; //offset_z [0] = offset_z [1]; // calculate <p> [0][0] = body_pos <ref> [1] </ref> - desired_vel [2]/3; // heuristic joint_ang [0][0] = body_pos [1]; joint_ang [0][1] = M_PI*5/8; // theta2 = 5/8 pi joint_ang [0][2] = M_PI_2; joint_ang [0][3] = joint_ang [1][3]* sin (theta2p)/sin (M_PI-joint_ang [0][1]); joint_ang [0][4] = M_PI_2; joint_ang [0][5] = -joint_ang [0][1]+joint_ang [1][5]+theta2p; //offset_x [0] = offset_x [1] + joint_ang [1][3]*cos (theta2p) + d4/2; //offset_z [0] = offset_z [1]; // calculate values for leg 0 calc_body_matricies (0, junk, offset); foot_lin_pos [0].subtract (pBG,offset); foot_linear_vel [0].assign (3, 0.0); cout &lt;< foot_lin_pos [0] &lt;< " = position of foot 0" &lt;< endl; */ place_foot (0,1); cout &lt;< "INNER LEG TOUCHDOWN" &lt;< <p> = body_pos <ref> [1] </ref>; joint_ang [0][1] = M_PI*5/8; // theta2 = 5/8 pi joint_ang [0][2] = M_PI_2; joint_ang [0][3] = joint_ang [1][3]* sin (theta2p)/sin (M_PI-joint_ang [0][1]); joint_ang [0][4] = M_PI_2; joint_ang [0][5] = -joint_ang [0][1]+joint_ang [1][5]+theta2p; //offset_x [0] = offset_x [1] + joint_ang [1][3]*cos (theta2p) + d4/2; //offset_z [0] = offset_z [1]; // calculate values for leg 0 calc_body_matricies (0, junk, offset); foot_lin_pos [0].subtract (pBG,offset); foot_linear_vel [0].assign (3, 0.0); cout &lt;< foot_lin_pos [0] &lt;< " = position of foot 0" &lt;< endl; */ place_foot (0,1); cout &lt;< "INNER LEG TOUCHDOWN" &lt;< endl; - break; -; ////////////////////////////////////////////////////////////////////// // place_foot // inputs: foot to <p> inputs: foot to be placed, reference leg // outputs: none // globals: joint_ang [leg][], foot_lin_pos [leg], foot_linear_vel [leg] ////////////////////////////////////////////////////////////////////// void place_foot (int leg, int rleg) - Matrix junk; Column_vector offset (3); 131 foot_up [leg] = false; double theta2r = joint_ang [rleg]<ref> [1] </ref>; const double place_angle = M_PI*5/8; joint_ang [leg][0] = body_pos [1]; joint_ang [leg][1] = place_angle; joint_ang [leg][2] = M_PI_2; joint_ang [leg][3] = joint_ang [rleg][3] *sin (theta2r)/sin (M_PI-place_angle); joint_ang [leg][4] = M_PI_2; joint_ang [leg][5] = -place_angle+joint_ang [rleg][5]+theta2r; calc_body_matricies (leg, junk, offset); foot_lin_pos [leg].subtract (pBG,offset); cout &lt;< foot_lin_pos [leg] &lt;< " = position of foot " &lt;< leg &lt;< endl; foot_linear_vel [leg].assign (3, <p> (int i=0; i&lt;6; ++i) Kbd.elem [i][j] = KbdT.elem [j][i] = Jinv <ref> [1] </ref>.elem [j+3][i]; Kbd.elem [i][j+3] = KbdT.elem [j+3][i] = Jinv [2].elem [j+3][i]; - Kbd.elem [6][1] = KbdT.elem [1][6] = .5; Kbd.elem [6][4] = KbdT.elem [4][6] = -.5; for (int i=0; i&lt;6; ++i) augmented_wrench [i] = des_wrench [i]; //cout &lt;< Jinv [1] &lt;< " = Jinv [1]" &lt;< endl; //cout &lt;< Kbd &lt;< " = Kbd" &lt;< endl &lt;< KbdT &lt;< " = transpose (Kbd)" &lt;< endl; Column_vector torque456; least_squares (Kbd,KbdT,augmented_wrench,torque456); //torques [0].assign (3,0.0); //torques [1].assign (3,999.9); 133 //torques [2].assign (3,888.8); for (int i = 0; i&lt;3; ++i) - torques [1][i] = <p> [i][j] = KbdT.elem [j][i] = Jinv <ref> [1] </ref>.elem [j+3][i]; Kbd.elem [i][j+3] = KbdT.elem [j+3][i] = Jinv [2].elem [j+3][i]; - Kbd.elem [6][1] = KbdT.elem [1][6] = .5; Kbd.elem [6][4] = KbdT.elem [4][6] = -.5; for (int i=0; i&lt;6; ++i) augmented_wrench [i] = des_wrench [i]; //cout &lt;< Jinv [1] &lt;< " = Jinv [1]" &lt;< endl; //cout &lt;< Kbd &lt;< " = Kbd" &lt;< endl &lt;< KbdT &lt;< " = transpose (Kbd)" &lt;< endl; Column_vector torque456; least_squares (Kbd,KbdT,augmented_wrench,torque456); //torques [0].assign (3,0.0); //torques [1].assign (3,999.9); 133 //torques [2].assign (3,888.8); for (int i = 0; i&lt;3; ++i) - torques [1][i] = torque456 [i]; torques [2][i] = <p> &lt;< endl; 136 -; // calc_frame0_Jacobian // inputs: theta [vector of angles] & d6 [hip offset] // output: J0 [frame 0 Jacobian] ///////////////////////////////////////////////////////////////////////// void calc_frame0_Jacobian (Column_vector & theta, double d6, Matrix & J0) - double s1,c1,s2,c2,s3,c3,d4,s5,c5,s6,c6; s1 = sin (theta [0]); c1 = cos (theta [0]); s2 = sin (theta <ref> [1] </ref>); c2 = cos (theta [1]); s3 = sin (theta [2]); c3 = cos (theta [2]); d4 = theta [3]; s5 = sin (theta [4]); c5 = cos (theta [4]); s6 = sin (theta [5]); c6 = cos (theta [5]); // calculate body-frame (frame 6) Jacobian, row by row Matrix J6 <p> calc_frame0_Jacobian // inputs: theta [vector of angles] & d6 [hip offset] // output: J0 [frame 0 Jacobian] ///////////////////////////////////////////////////////////////////////// void calc_frame0_Jacobian (Column_vector & theta, double d6, Matrix & J0) - double s1,c1,s2,c2,s3,c3,d4,s5,c5,s6,c6; s1 = sin (theta [0]); c1 = cos (theta [0]); s2 = sin (theta <ref> [1] </ref>); c2 = cos (theta [1]); s3 = sin (theta [2]); c3 = cos (theta [2]); d4 = theta [3]; s5 = sin (theta [4]); c5 = cos (theta [4]); s6 = sin (theta [5]); c6 = cos (theta [5]); // calculate body-frame (frame 6) Jacobian, row by row Matrix J6 (6,6); // temp. variables double <p> s1*s2*c6; RB0.elem <ref> [1] </ref>[2] = s5*s1*c2*c3 - s5*c1*s3 - c5*s1*c2*s3 - c5*c1*c3; RB0.elem [2][0] = c6*s2*c3*c5 + c6*s2*s3*s5 + c2*s6; RB0.elem [2][1] = -s6*s2*c3*c5 - s6*s2*s3*s5 + c2*c6; RB0.elem [2][2] = s2*c3*s5 - s2*s3*c5; pB0.assign (3, 0.0); pB0 [0] = (c1*c2*s3-s1*c3)*d4 - (-c6*c5*c1*c2*c3 - c6*c5*s1*s3 - c6*s5*c1*c2*s3 + c6*s5*s1*c3 + pB0 [1] = (s1*c2*s3+c1*c3)*d4 - (c6*c5*s1*c2*c3 - c6*c5*c1*s3 + c6*s5*s1*c2*s3 + c6*s5*c1*c3 - pB0 [2] = (s2*s3)*d4 - s2*(-c3*s5+s3*c5)*d6 + - // init_state -- initialize the state of the system // inputs: [none] // outputs: [none] // globals: sets el_time,joint_ang [leg angles], body linear vel., // body ang. vel //////////////////////////////////////////////////////////////////////// void init_state <p> &lt;< endl; // assign and calculate values for leg 1 joint_ang <ref> [1] </ref>.assign (6,999.9); joint_ang [1][0] = -M_PI_4; joint_ang [1][1] = M_PI*3/8; joint_ang [1][2] = M_PI_2; joint_ang [1][3] = 1.6236; joint_ang [1][4] = M_PI_2 + roll; joint_ang [1][5] = M_PI/8 tilt; calc_body_matricies (1, junk, offset); foot_lin_pos [1].subtract (body_start,offset); //cout &lt;< foot_lin_pos [1] &lt;< " = position of foot 1" &lt;< endl; // assign and calculate values for leg 2 joint_ang [2].assign (6,999.9); 141 joint_ang [2][0] = -M_PI_4; joint_ang [2][1] = M_PI*3/8 -.0001; joint_ang [2][2] = M_PI_2; joint_ang [2][3] = 1.62361; // slightly different joint_ang [2][4] = M_PI_2 + roll; joint_ang [2][5] = <p> &lt;< " = position of foot 2" &lt;< endl; //cout &lt;< joint_ang [0] &lt;< endl; // joint velocities are used only to integrate joint angles /* joint_vel [0].assign (6, 0.0); joint_vel <ref> [1] </ref>.assign (6, 0.0); joint_vel [2].assign (6, 0.0); */ body_ang_vel.assign (3, 0.0); body_linear_vel.assign (3, 0.0); body_linear_vel [0] = desired_speed*M_SQRT1_2; body_linear_vel [1] = -desired_speed*M_SQRT1_2; for (int i=0; i&lt;num_legs; ++i) - body_vel [i] = body_ang_vel [i]; body_vel [i+3] = body_linear_vel [i]; - state = inner_fwd; foot_up [0] = foot_up [1] = foot_up [2] = false; foot_slipping [0] = foot_slipping [1] = foot_slipping [2] = false; foot_linear_vel [0].assign (3, 0.0); foot_linear_vel [1].assign (3, 0.0); <p> [0].assign (6, 0.0); joint_vel <ref> [1] </ref>.assign (6, 0.0); joint_vel [2].assign (6, 0.0); */ body_ang_vel.assign (3, 0.0); body_linear_vel.assign (3, 0.0); body_linear_vel [0] = desired_speed*M_SQRT1_2; body_linear_vel [1] = -desired_speed*M_SQRT1_2; for (int i=0; i&lt;num_legs; ++i) - body_vel [i] = body_ang_vel [i]; body_vel [i+3] = body_linear_vel [i]; - state = inner_fwd; foot_up [0] = foot_up [1] = foot_up [2] = false; foot_slipping [0] = foot_slipping [1] = foot_slipping [2] = false; foot_linear_vel [0].assign (3, 0.0); foot_linear_vel [1].assign (3, 0.0); foot_linear_vel [2].assign (3, 0.0); - 142 APPENDIX D Dynamic Simulation Code This is the C++ code that simulates the dynamics of the triped robot. //----------------------------------------------------------- // plant.H <p> 0.0); */ body_ang_vel.assign (3, 0.0); body_linear_vel.assign (3, 0.0); body_linear_vel [0] = desired_speed*M_SQRT1_2; body_linear_vel <ref> [1] </ref> = -desired_speed*M_SQRT1_2; for (int i=0; i&lt;num_legs; ++i) - body_vel [i] = body_ang_vel [i]; body_vel [i+3] = body_linear_vel [i]; - state = inner_fwd; foot_up [0] = foot_up [1] = foot_up [2] = false; foot_slipping [0] = foot_slipping [1] = foot_slipping [2] = false; foot_linear_vel [0].assign (3, 0.0); foot_linear_vel [1].assign (3, 0.0); foot_linear_vel [2].assign (3, 0.0); - 142 APPENDIX D Dynamic Simulation Code This is the C++ code that simulates the dynamics of the triped robot. //----------------------------------------------------------- // plant.H mechanical simulation of triped // by P. <p> do one iteration of plant simulation // input: actuator torques: each vector contains the torqes for joints 4,5,&6 ///////////////////////////////////////////////////////////////////////// void iterate_plant (Column_vector actuator_torques [3]) - body_wrench.assign (6, 0.0); for (int leg=0; leg&lt;num_legs; ++leg) - 145 Column_vector joint_torques (6); // copy joint torqes, and apply torque limits joint_torques [0] = joint_torques <ref> [1] </ref> = joint_torques [2] = 0.0; joint_torques [3] = min (actuator_torques [leg][0],actuator4max); joint_torques [3] = max (joint_torques [3], -actuator4max); joint_torques [4] = min (actuator_torques [leg][1],actuator5max); joint_torques [4] = max (joint_torques [4], -actuator5max); joint_torques [5] = min (actuator_torques [leg][2],actuator6max); joint_torques [5] = max (joint_torques [5], -actuator6max); for (int actuator=3; actuator&lt;6; ++actuator) if
Reference: [2] <author> M. Raibert, </author> <title> Legged Robots that Balance. </title> <address> Cambridge, Mass.: </address> <publisher> MIT Press, </publisher> <editor> first ed., </editor> <year> 1986. </year>
Reference-contexts: Even normal humans will need powered exoskeletons to explore heavy-gravity planets or augment their power to lift and manipulate 2 heavy equipment. Only about half of the Earth's land area is accessible to wheeled vehicles <ref> [2, page 1] </ref>, but almost all of it is accessible to legged creatures. We would like to avoid paving everything, and there are many places such as arctic tundra where cutting a road or driving a wheeled vehicle causes increased erosion or other ecological damage. <p> Legged locomotion is an area of robotics where it is reasonably clear what is a workable approach and what is not. Furthermore, legged locomotion poses interesting challenges for the engineer in applied dynamics and control. Currently, robots with one <ref> [2, chapters 2-3] </ref>, two [5], four [6], six [7] and eight [8] legs are studied.[9] They divide naturally into two groups | one and two legged robots that dynamically balance, and robots with four or more legs that are basically statically stable, though they may use gaits that are dynamically stable. <p> Sutherland [20] introduced the notion of a virtual leg, two or more legs that move together, and can thus be analyzed as if they are a single leg. Raibert, Hodgins, and others at MIT made seminal studies <ref> [2] </ref> of dynamically balancing one legged robots, in two and three dimensions. They were able to decompose control into sagittal and frontal planes. Vertical height was controlled as a limit cycle, as the robots had to hop to balance. <p> Dynamic control frees robots from the constraints on leg posi 15 tion imposed by static control. Legs have much more freedom to use widely sepa-rated or erratically placed footholds <ref> [2, page5] </ref>. Inertial pseudo-forces and pseudo-torques become significant if the robot moves faster than a slow crawl. These also require the use of a dynamic control system. Dynamic control has been perceived as being too difficult to implement in the past. <p> Biped running thus involves periods of ballistic flight. Bipeds are usually analyzed using dynamics rather than gaits. Raibert defines <ref> [2, page 84] </ref> a class of gaits called single foot gaits wherein 1. One leg provides support at a time. 2. Support phases and flight phases proceed in strict alternation. These gaits allow Raibert's algorithm to control robots with one, two, or more 17 legs. <p> In order to control robot yaw, these legs must all be firmly planted on the ground for a significant fraction of the leg cycle. Monopods thus cannot exert a yaw torque without a powered ankle. Raibert's hoppers <ref> [2, page 66] </ref> could not control their yaw. <p> If bounding gaits are allowed, the optimum number is two. If active ankles and bounding gaits are allowed, the number drops to one. If the yaw of the body need not be controlled, the optimum number is one. Raibert's hoppers <ref> [2, chapters 2-3] </ref> fall into this category. If the yaw must be controlled, but only when crawling, the number is two. Another factor is important here: the duty cycle of the legs, fi. <p> Tripeds can hop on all three legs together. This is a one-foot gait, as defined by Raibert <ref> [2] </ref>. The analysis and control that Raibert used for quadrupeds hopping on all four feet together [2] should also work 37 length of thigh 1 m length of shank 1 m minimum leg length 1 m maximum leg length 2 m body c.m. to center hip distance .25 m hip to <p> Tripeds can hop on all three legs together. This is a one-foot gait, as defined by Raibert <ref> [2] </ref>. The analysis and control that Raibert used for quadrupeds hopping on all four feet together [2] should also work 37 length of thigh 1 m length of shank 1 m minimum leg length 1 m maximum leg length 2 m body c.m. to center hip distance .25 m hip to hip spacing .5 m track width 1 m body width 1.2 m body length 1.2 m <p> 2 sin ( 5 ) d4 116 &gt; beta4 := evalm (R4B &* vector ([0, 0, 1])); &gt; &gt; beta5 := evalm (crossprod (p5B,gamma5)); &gt; &gt; beta6 := evalm (crossprod (p6B,gamma6)); &gt; &gt; # &gt; J := matrix (6,6): &gt; J [1,1] := gamma1 [1]: &gt; J [2,1] := gamma1 <ref> [2] </ref>: &gt; J [3,1] := gamma1 [3]: &gt; J [4,1] := beta1 [1]: &gt; J [5,1] := beta1 [2]: &gt; J [6,1] := beta1 [3]: &gt; J [1,2] := gamma2 [1]: &gt; J [2,2] := gamma2 [2]: &gt; J [3,2] := gamma2 [3]: &gt; J [4,2] := beta2 [1]: &gt; J <p> &gt; beta5 := evalm (crossprod (p5B,gamma5)); &gt; &gt; beta6 := evalm (crossprod (p6B,gamma6)); &gt; &gt; # &gt; J := matrix (6,6): &gt; J [1,1] := gamma1 [1]: &gt; J [2,1] := gamma1 <ref> [2] </ref>: &gt; J [3,1] := gamma1 [3]: &gt; J [4,1] := beta1 [1]: &gt; J [5,1] := beta1 [2]: &gt; J [6,1] := beta1 [3]: &gt; J [1,2] := gamma2 [1]: &gt; J [2,2] := gamma2 [2]: &gt; J [3,2] := gamma2 [3]: &gt; J [4,2] := beta2 [1]: &gt; J [5,2] := beta2 [2]: &gt; J [6,2] := beta2 [3]: &gt; J [1,3] := gamma3 [1]: &gt; J <p> := matrix (6,6): &gt; J [1,1] := gamma1 [1]: &gt; J [2,1] := gamma1 <ref> [2] </ref>: &gt; J [3,1] := gamma1 [3]: &gt; J [4,1] := beta1 [1]: &gt; J [5,1] := beta1 [2]: &gt; J [6,1] := beta1 [3]: &gt; J [1,2] := gamma2 [1]: &gt; J [2,2] := gamma2 [2]: &gt; J [3,2] := gamma2 [3]: &gt; J [4,2] := beta2 [1]: &gt; J [5,2] := beta2 [2]: &gt; J [6,2] := beta2 [3]: &gt; J [1,3] := gamma3 [1]: &gt; J [2,3] := gamma3 [2]: &gt; J [3,3] := gamma3 [3]: &gt; J [4,3] := beta3 [1]: &gt; J <p> := gamma1 [3]: &gt; J [4,1] := beta1 [1]: &gt; J [5,1] := beta1 <ref> [2] </ref>: &gt; J [6,1] := beta1 [3]: &gt; J [1,2] := gamma2 [1]: &gt; J [2,2] := gamma2 [2]: &gt; J [3,2] := gamma2 [3]: &gt; J [4,2] := beta2 [1]: &gt; J [5,2] := beta2 [2]: &gt; J [6,2] := beta2 [3]: &gt; J [1,3] := gamma3 [1]: &gt; J [2,3] := gamma3 [2]: &gt; J [3,3] := gamma3 [3]: &gt; J [4,3] := beta3 [1]: &gt; J [5,3] := beta3 [2]: &gt; J [6,3] := simplify (beta3 [3]): &gt; J [1,4] := gamma4 [1]: &gt; <p> := beta1 [3]: &gt; J [1,2] := gamma2 [1]: &gt; J [2,2] := gamma2 <ref> [2] </ref>: &gt; J [3,2] := gamma2 [3]: &gt; J [4,2] := beta2 [1]: &gt; J [5,2] := beta2 [2]: &gt; J [6,2] := beta2 [3]: &gt; J [1,3] := gamma3 [1]: &gt; J [2,3] := gamma3 [2]: &gt; J [3,3] := gamma3 [3]: &gt; J [4,3] := beta3 [1]: &gt; J [5,3] := beta3 [2]: &gt; J [6,3] := simplify (beta3 [3]): &gt; J [1,4] := gamma4 [1]: &gt; J [2,4] := gamma4 [2]: &gt; J [3,4] := gamma4 [3]: &gt; J [4,4] := beta4 [1]: &gt; <p> := gamma2 [3]: &gt; J [4,2] := beta2 [1]: &gt; J [5,2] := beta2 <ref> [2] </ref>: &gt; J [6,2] := beta2 [3]: &gt; J [1,3] := gamma3 [1]: &gt; J [2,3] := gamma3 [2]: &gt; J [3,3] := gamma3 [3]: &gt; J [4,3] := beta3 [1]: &gt; J [5,3] := beta3 [2]: &gt; J [6,3] := simplify (beta3 [3]): &gt; J [1,4] := gamma4 [1]: &gt; J [2,4] := gamma4 [2]: &gt; J [3,4] := gamma4 [3]: &gt; J [4,4] := beta4 [1]: &gt; J [5,4] := beta4 [2]: &gt; J [6,4] := beta4 [3]: &gt; J [1,5] := gamma5 [1]: &gt; <p> beta2 [3]: &gt; J [1,3] := gamma3 [1]: &gt; J [2,3] := gamma3 <ref> [2] </ref>: &gt; J [3,3] := gamma3 [3]: &gt; J [4,3] := beta3 [1]: &gt; J [5,3] := beta3 [2]: &gt; J [6,3] := simplify (beta3 [3]): &gt; J [1,4] := gamma4 [1]: &gt; J [2,4] := gamma4 [2]: &gt; J [3,4] := gamma4 [3]: &gt; J [4,4] := beta4 [1]: &gt; J [5,4] := beta4 [2]: &gt; J [6,4] := beta4 [3]: &gt; J [1,5] := gamma5 [1]: &gt; J [2,5] := gamma5 [2]: &gt; J [3,5] := gamma5 [3]: &gt; J [4,5] := beta5 [1]: &gt; J <p> gamma3 [3]: &gt; J [4,3] := beta3 [1]: &gt; J [5,3] := beta3 <ref> [2] </ref>: &gt; J [6,3] := simplify (beta3 [3]): &gt; J [1,4] := gamma4 [1]: &gt; J [2,4] := gamma4 [2]: &gt; J [3,4] := gamma4 [3]: &gt; J [4,4] := beta4 [1]: &gt; J [5,4] := beta4 [2]: &gt; J [6,4] := beta4 [3]: &gt; J [1,5] := gamma5 [1]: &gt; J [2,5] := gamma5 [2]: &gt; J [3,5] := gamma5 [3]: &gt; J [4,5] := beta5 [1]: &gt; J [5,5] := beta5 [2]: &gt; J [6,5] := beta5 [3]: &gt; J [1,6] := gamma6 [1]: &gt; J <p> simplify (beta3 [3]): &gt; J [1,4] := gamma4 [1]: &gt; J [2,4] := gamma4 <ref> [2] </ref>: &gt; J [3,4] := gamma4 [3]: &gt; J [4,4] := beta4 [1]: &gt; J [5,4] := beta4 [2]: &gt; J [6,4] := beta4 [3]: &gt; J [1,5] := gamma5 [1]: &gt; J [2,5] := gamma5 [2]: &gt; J [3,5] := gamma5 [3]: &gt; J [4,5] := beta5 [1]: &gt; J [5,5] := beta5 [2]: &gt; J [6,5] := beta5 [3]: &gt; J [1,6] := gamma6 [1]: &gt; J [2,6] := gamma6 [2]: &gt; J [3,6] := gamma6 [3]: &gt; J [4,6] := beta6 [1]: 117 &gt; <p> := gamma4 [3]: &gt; J [4,4] := beta4 [1]: &gt; J [5,4] := beta4 <ref> [2] </ref>: &gt; J [6,4] := beta4 [3]: &gt; J [1,5] := gamma5 [1]: &gt; J [2,5] := gamma5 [2]: &gt; J [3,5] := gamma5 [3]: &gt; J [4,5] := beta5 [1]: &gt; J [5,5] := beta5 [2]: &gt; J [6,5] := beta5 [3]: &gt; J [1,6] := gamma6 [1]: &gt; J [2,6] := gamma6 [2]: &gt; J [3,6] := gamma6 [3]: &gt; J [4,6] := beta6 [1]: 117 &gt; J [5,6] := beta6 [2]: &gt; J [6,6] := beta6 [3]: &gt; J := evalm (J); &gt; [ <p> := beta4 [3]: &gt; J [1,5] := gamma5 [1]: &gt; J [2,5] := gamma5 <ref> [2] </ref>: &gt; J [3,5] := gamma5 [3]: &gt; J [4,5] := beta5 [1]: &gt; J [5,5] := beta5 [2]: &gt; J [6,5] := beta5 [3]: &gt; J [1,6] := gamma6 [1]: &gt; J [2,6] := gamma6 [2]: &gt; J [3,6] := gamma6 [3]: &gt; J [4,6] := beta6 [1]: 117 &gt; J [5,6] := beta6 [2]: &gt; J [6,6] := beta6 [3]: &gt; J := evalm (J); &gt; [ %1 ; %2 ; sin ( 6 ) ; 0 ; sin ( 6 ) ; 0 ] <p> gamma5 [3]: &gt; J [4,5] := beta5 [1]: &gt; J [5,5] := beta5 <ref> [2] </ref>: &gt; J [6,5] := beta5 [3]: &gt; J [1,6] := gamma6 [1]: &gt; J [2,6] := gamma6 [2]: &gt; J [3,6] := gamma6 [3]: &gt; J [4,6] := beta6 [1]: 117 &gt; J [5,6] := beta6 [2]: &gt; J [6,6] := beta6 [3]: &gt; J := evalm (J); &gt; [ %1 ; %2 ; sin ( 6 ) ; 0 ; sin ( 6 ) ; 0 ] [ %5 sin ( 2 ) ; %6 ; 0 ; 0 ; 0 ; 1 ] sin ( <p> effects: increments el_time, // when sequence completes, reinitializes sim. //////////////////////////////////////////////////////////////////////// void sequencer (void) - const double altitude = 1.75; const double turntime = 1.4; //const double turntime = timelimit; cout &lt;< "------------------------- time = " &lt;< el_time &lt;< endl; /* // stand still desired_pos.assign (6,0.0); desired_pos [0] = M_PI/2.0; desired_pos <ref> [2] </ref> = M_PI/2.0; for (int i=0; i&lt;num_legs; ++i) desired_pos [i+3] = body_start [i]; //desired_pos [1] = tilt; desired_vel.assign (6,0.0); desired_accel.assign (6,0.0); */ if (el_time&lt;turntime) - // walk forward desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos [1] = -M_PI_4; desired_pos [2] = M_PI_2; desired_pos [3] = body_start [0]+desired_speed*M_SQRT1_2*el_time; desired_pos [4] = body_start <p> /* // stand still desired_pos.assign (6,0.0); desired_pos [0] = M_PI/2.0; desired_pos <ref> [2] </ref> = M_PI/2.0; for (int i=0; i&lt;num_legs; ++i) desired_pos [i+3] = body_start [i]; //desired_pos [1] = tilt; desired_vel.assign (6,0.0); desired_accel.assign (6,0.0); */ if (el_time&lt;turntime) - // walk forward desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos [1] = -M_PI_4; desired_pos [2] = M_PI_2; desired_pos [3] = body_start [0]+desired_speed*M_SQRT1_2*el_time; desired_pos [4] = body_start [1]-desired_speed*M_SQRT1_2*el_time; desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; 123 desired_vel.assign (6,0.0); desired_vel [3] = desired_speed*M_SQRT1_2; desired_vel [4] = -desired_speed*M_SQRT1_2; desired_accel.assign (6,0.0); - if (el_time&gt;=turntime) - // circular turn to left const double <p> &lt;< endl; 123 desired_vel.assign (6,0.0); desired_vel [3] = desired_speed*M_SQRT1_2; desired_vel [4] = -desired_speed*M_SQRT1_2; desired_accel.assign (6,0.0); - if (el_time&gt;=turntime) - // circular turn to left const double radius = 5; double rho = (el_time-turntime)*desired_speed/radius - M_PI_4; desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos [1] = rho; // euler angle beta desired_pos <ref> [2] </ref> = M_PI_2; desired_pos [3] = body_start [0] + turntime*desired_speed*M_SQRT1_2 + radius*(sin (rho)+M_SQRT1_2); desired_pos [4] = body_start [1] - turntime*desired_speed*M_SQRT1_2 - radius*(cos (rho) - M_SQRT1_2); desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; desired_vel.assign (6,0.0); desired_vel [2] = desired_speed/radius; // rotate about z axis desired_vel <p> [1] = rho; // euler angle beta desired_pos <ref> [2] </ref> = M_PI_2; desired_pos [3] = body_start [0] + turntime*desired_speed*M_SQRT1_2 + radius*(sin (rho)+M_SQRT1_2); desired_pos [4] = body_start [1] - turntime*desired_speed*M_SQRT1_2 - radius*(cos (rho) - M_SQRT1_2); desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; desired_vel.assign (6,0.0); desired_vel [2] = desired_speed/radius; // rotate about z axis desired_vel [3] = desired_speed*cos (rho); desired_vel [4] = desired_speed*sin (rho); //cout &lt;< desired_vel &lt;< " = desired velocity" &lt;< endl; desired_accel.assign (6,0.0); desired_accel [3] = -desired_speed*sin (rho); desired_accel [4] = desired_speed*cos (rho); //cout &lt;< desired_accel &lt;< " = desired acceleration" &lt;< endl; - <p> " = rotation of body in ground frame" &lt;< endl; // Euler X-Y-Z (or fixed Z-Y-X) double cbeta = sqrt (RBG.elem [1]<ref> [2] </ref>*RBG.elem [1][2]+ RBG.elem [2][2]*RBG.elem [2][2]); if (cbeta != 0.0) - 125 beta = body_pos [1] = atan2 (RBG.elem [0][2],cbeta); alpha = body_pos [0] = atan2 (-RBG.elem [1][2]/cbeta,RBG.elem [2][2]/cbeta); body_pos [2] = atan2 (-RBG.elem [0][1]/cbeta,RBG.elem [0][0]/cbeta); else-// degenerate beta = body_pos [1] = M_PI/2.0; alpha = body_pos [0] = 0; body_pos [2] = atan2 (RBG.elem [2][1],RBG.elem [1][1]); - //cout &lt;< body_pos &lt;< " = angles using fixed Z-Y-X" &lt;< endl; for (int i=0; i&lt;3; ++i) - body_pos [3+i] = pBG [i]; <p> [1]<ref> [2] </ref>*RBG.elem [1][2]+ RBG.elem [2][2]*RBG.elem [2][2]); if (cbeta != 0.0) - 125 beta = body_pos [1] = atan2 (RBG.elem [0][2],cbeta); alpha = body_pos [0] = atan2 (-RBG.elem [1][2]/cbeta,RBG.elem [2][2]/cbeta); body_pos [2] = atan2 (-RBG.elem [0][1]/cbeta,RBG.elem [0][0]/cbeta); else-// degenerate beta = body_pos [1] = M_PI/2.0; alpha = body_pos [0] = 0; body_pos [2] = atan2 (RBG.elem [2][1],RBG.elem [1][1]); - //cout &lt;< body_pos &lt;< " = angles using fixed Z-Y-X" &lt;< endl; for (int i=0; i&lt;3; ++i) - body_pos [3+i] = pBG [i]; - //cout &lt;< body_pos &lt;< " = body position" &lt;< endl; //-------------------------------------------------------- // calculate desired wrench Column_vector desired_lin_accel (3, 0.0); Column_vector <p> discard them Column_vector temp (3),temp2 (3); //cout &lt;< body_ang_vel &lt;< " = body angular velocity" &lt;< endl; temp.multiply (body_inertia,body_ang_vel); //cout &lt;< temp &lt;< " = inertia * body angular velocity" &lt;< endl; temp2.crossprod (body_ang_vel,temp); //cout &lt;< temp2 &lt;< " = centrifugal and coriolis correction torques" &lt;< endl; desired_torque.add (desired_torque,temp2); desired_force <ref> [2] </ref> += body_weight; 127 // combine for (int i=0; i&lt;3; ++i) - desired_wrench [i] = desired_torque [i]; desired_wrench [i+3] = desired_force [i]; - cout &lt;< desired_wrench &lt;< " = desired wrench" &lt;< endl; //-------------------------------------------------------- // find best approximate joint torques switch (state) - case inner_fwd: fwd_on_all (desired_wrench,torques); break; case inner_only: fwd_on_inner <p> = desired wrench" &lt;< endl; //-------------------------------------------------------- // find best approximate joint torques switch (state) - case inner_fwd: fwd_on_all (desired_wrench,torques); break; case inner_only: fwd_on_inner (desired_wrench,torques); break; case outer_fwd: fwd_on_all (desired_wrench,torques); break; case outer_only: fwd_on_outer (desired_wrench,torques); break; - calc_body_matricies (ref_leg, RBG, pBG); pBG.add (foot_lin_pos [ref_leg],pBG); //cout &lt;< "body z position:" &lt;< pBG <ref> [2] </ref> &lt;< endl; - // do_state_machine () // inputs: none // outputs: none // globals: state, joint_ang, ... 128 /////////////////////////////////////////////////////////////////////////// void do_state_machine (void) - static double t_touchdown; // Matrix junk; // Column_vector offset (3); // advance state machine if appropriate switch (state) - case inner_fwd: if (joint_ang [0][1] &lt; M_PI*.54) - <p> switch (state) - case inner_fwd: if (joint_ang [0][1] &lt; M_PI*.54) - state = inner_only; t_touchdown = el_time+air_time; // what will eventually happen is forces will be applied to // lift the feet, and the plant model will set the foot sensors // But for now, cheat! foot_up [1] = foot_up <ref> [2] </ref> = true; ref_leg = 0; cout &lt;< "OUTER LEGS LIFTED" &lt;< endl; - break; case inner_only: if (el_time &gt; t_touchdown) - // touchdown! state = outer_fwd; /* foot_up [1] = foot_up [2] = false; double theta2p = joint_ang [0][1]; //joint_ang [1][0] = body_pos [2] - M_PI/2; //joint_ang [2][0] = body_pos <p> and the plant model will set the foot sensors // But for now, cheat! foot_up [1] = foot_up <ref> [2] </ref> = true; ref_leg = 0; cout &lt;< "OUTER LEGS LIFTED" &lt;< endl; - break; case inner_only: if (el_time &gt; t_touchdown) - // touchdown! state = outer_fwd; /* foot_up [1] = foot_up [2] = false; double theta2p = joint_ang [0][1]; //joint_ang [1][0] = body_pos [2] - M_PI/2; //joint_ang [2][0] = body_pos [2] - M_PI/2; joint_ang [1][0] = joint_ang [0][0]; joint_ang [2][0] = joint_ang [0][0]; joint_ang [1][1] = 2*M_PI/3; // theta2 = 2/3 pi joint_ang [2][1] = 2*M_PI/3-.01; // slight offset to avoid divide <p> now, cheat! foot_up [1] = foot_up <ref> [2] </ref> = true; ref_leg = 0; cout &lt;< "OUTER LEGS LIFTED" &lt;< endl; - break; case inner_only: if (el_time &gt; t_touchdown) - // touchdown! state = outer_fwd; /* foot_up [1] = foot_up [2] = false; double theta2p = joint_ang [0][1]; //joint_ang [1][0] = body_pos [2] - M_PI/2; //joint_ang [2][0] = body_pos [2] - M_PI/2; joint_ang [1][0] = joint_ang [0][0]; joint_ang [2][0] = joint_ang [0][0]; joint_ang [1][1] = 2*M_PI/3; // theta2 = 2/3 pi joint_ang [2][1] = 2*M_PI/3-.01; // slight offset to avoid divide by 0 joint_ang [1][5] = theta2p+joint_ang [0][5]-2*M_PI/3; joint_ang [2][5] = theta2p+joint_ang [0][5]-2*M_PI/3+.01; <p> = true; ref_leg = 0; cout &lt;< "OUTER LEGS LIFTED" &lt;< endl; - break; case inner_only: if (el_time &gt; t_touchdown) - // touchdown! state = outer_fwd; /* foot_up [1] = foot_up <ref> [2] </ref> = false; double theta2p = joint_ang [0][1]; //joint_ang [1][0] = body_pos [2] - M_PI/2; //joint_ang [2][0] = body_pos [2] - M_PI/2; joint_ang [1][0] = joint_ang [0][0]; joint_ang [2][0] = joint_ang [0][0]; joint_ang [1][1] = 2*M_PI/3; // theta2 = 2/3 pi joint_ang [2][1] = 2*M_PI/3-.01; // slight offset to avoid divide by 0 joint_ang [1][5] = theta2p+joint_ang [0][5]-2*M_PI/3; joint_ang [2][5] = theta2p+joint_ang [0][5]-2*M_PI/3+.01; joint_ang [1][2] = M_PI/2; joint_ang [2][2] = <p> // calculate values for leg 1 calc_body_matricies (1, junk, offset); foot_lin_pos [1].subtract (pBG,offset); foot_linear_vel [1].assign (3, 0.0); cout &lt;< foot_lin_pos [1] &lt;< " = position of foot 1" &lt;< endl; // calculate values for leg 2 calc_body_matricies (2, junk, offset); foot_lin_pos <ref> [2] </ref>.subtract (pBG,offset); foot_linear_vel [2].assign (3, 0.0); cout &lt;< foot_lin_pos [2] &lt;< " = position of foot 2" &lt;< endl; */ place_foot (1,0); place_foot (2,0); cout &lt;< "OUTER LEGS TOUCHED DOWN" &lt;< endl; - break; case outer_fwd: if ( (joint_ang [1][1] + joint_ang [2][1]) &lt; M_PI*.54*2) - // avg of angles state = outer_only; t_touchdown = el_time+air_time; // what will eventually <p> of angles] & d6 [hip offset] // output: J0 [frame 0 Jacobian] ///////////////////////////////////////////////////////////////////////// void calc_frame0_Jacobian (Column_vector & theta, double d6, Matrix & J0) - double s1,c1,s2,c2,s3,c3,d4,s5,c5,s6,c6; s1 = sin (theta [0]); c1 = cos (theta [0]); s2 = sin (theta [1]); c2 = cos (theta [1]); s3 = sin (theta <ref> [2] </ref>); c3 = cos (theta [2]); d4 = theta [3]; s5 = sin (theta [4]); c5 = cos (theta [4]); s6 = sin (theta [5]); c6 = cos (theta [5]); // calculate body-frame (frame 6) Jacobian, row by row Matrix J6 (6,6); // temp. variables double temp1 = s2*c6*c5*c3 + s2*c6*s5*s3 <p> offset] // output: J0 [frame 0 Jacobian] ///////////////////////////////////////////////////////////////////////// void calc_frame0_Jacobian (Column_vector & theta, double d6, Matrix & J0) - double s1,c1,s2,c2,s3,c3,d4,s5,c5,s6,c6; s1 = sin (theta [0]); c1 = cos (theta [0]); s2 = sin (theta [1]); c2 = cos (theta [1]); s3 = sin (theta <ref> [2] </ref>); c3 = cos (theta [2]); d4 = theta [3]; s5 = sin (theta [4]); c5 = cos (theta [4]); s6 = sin (theta [5]); c6 = cos (theta [5]); // calculate body-frame (frame 6) Jacobian, row by row Matrix J6 (6,6); // temp. variables double temp1 = s2*c6*c5*c3 + s2*c6*s5*s3 + s6*c2; double temp2 = <p> = c6*s2*c3*c5 + c6*s2*s3*s5 + c2*s6; RB0.elem <ref> [2] </ref>[1] = -s6*s2*c3*c5 - s6*s2*s3*s5 + c2*c6; RB0.elem [2][2] = s2*c3*s5 - s2*s3*c5; pB0.assign (3, 0.0); pB0 [0] = (c1*c2*s3-s1*c3)*d4 - (-c6*c5*c1*c2*c3 - c6*c5*s1*s3 - c6*s5*c1*c2*s3 + c6*s5*s1*c3 + pB0 [1] = (s1*c2*s3+c1*c3)*d4 - (c6*c5*s1*c2*c3 - c6*c5*c1*s3 + c6*s5*s1*c2*s3 + c6*s5*c1*c3 - pB0 [2] = (s2*s3)*d4 - s2*(-c3*s5+s3*c5)*d6 + - // init_state -- initialize the state of the system // inputs: [none] // outputs: [none] // globals: sets el_time,joint_ang [leg angles], body linear vel., // body ang. vel //////////////////////////////////////////////////////////////////////// void init_state (void) - Matrix junk; Column_vector offset (3); el_time = 0; // assign values <p> for leg 2 joint_ang <ref> [2] </ref>.assign (6,999.9); 141 joint_ang [2][0] = -M_PI_4; joint_ang [2][1] = M_PI*3/8 -.0001; joint_ang [2][2] = M_PI_2; joint_ang [2][3] = 1.62361; // slightly different joint_ang [2][4] = M_PI_2 + roll; joint_ang [2][5] = M_PI/8 - .0001 tilt; calc_body_matricies (2, junk, offset); foot_lin_pos [2].subtract (body_start,offset); //cout &lt;< foot_lin_pos [2] &lt;< " = position of foot 2" &lt;< endl; //cout &lt;< joint_ang [0] &lt;< endl; // joint velocities are used only to integrate joint angles /* joint_vel [0].assign (6, 0.0); joint_vel [1].assign (6, 0.0); joint_vel [2].assign (6, 0.0); */ body_ang_vel.assign (3, 0.0); body_linear_vel.assign (3, 0.0); body_linear_vel [0] = desired_speed*M_SQRT1_2; body_linear_vel <p> joint_vel [1].assign (6, 0.0); joint_vel <ref> [2] </ref>.assign (6, 0.0); */ body_ang_vel.assign (3, 0.0); body_linear_vel.assign (3, 0.0); body_linear_vel [0] = desired_speed*M_SQRT1_2; body_linear_vel [1] = -desired_speed*M_SQRT1_2; for (int i=0; i&lt;num_legs; ++i) - body_vel [i] = body_ang_vel [i]; body_vel [i+3] = body_linear_vel [i]; - state = inner_fwd; foot_up [0] = foot_up [1] = foot_up [2] = false; foot_slipping [0] = foot_slipping [1] = foot_slipping [2] = false; foot_linear_vel [0].assign (3, 0.0); foot_linear_vel [1].assign (3, 0.0); foot_linear_vel [2].assign (3, 0.0); - 142 APPENDIX D Dynamic Simulation Code This is the C++ code that simulates the dynamics of the triped robot. //----------------------------------------------------------- // plant.H mechanical simulation of <p> (3, 0.0); body_linear_vel.assign (3, 0.0); body_linear_vel [0] = desired_speed*M_SQRT1_2; body_linear_vel [1] = -desired_speed*M_SQRT1_2; for (int i=0; i&lt;num_legs; ++i) - body_vel [i] = body_ang_vel [i]; body_vel [i+3] = body_linear_vel [i]; - state = inner_fwd; foot_up [0] = foot_up [1] = foot_up <ref> [2] </ref> = false; foot_slipping [0] = foot_slipping [1] = foot_slipping [2] = false; foot_linear_vel [0].assign (3, 0.0); foot_linear_vel [1].assign (3, 0.0); foot_linear_vel [2].assign (3, 0.0); - 142 APPENDIX D Dynamic Simulation Code This is the C++ code that simulates the dynamics of the triped robot. //----------------------------------------------------------- // plant.H mechanical simulation of triped // by P. <p> of plant simulation // input: actuator torques: each vector contains the torqes for joints 4,5,&6 ///////////////////////////////////////////////////////////////////////// void iterate_plant (Column_vector actuator_torques [3]) - body_wrench.assign (6, 0.0); for (int leg=0; leg&lt;num_legs; ++leg) - 145 Column_vector joint_torques (6); // copy joint torqes, and apply torque limits joint_torques [0] = joint_torques [1] = joint_torques <ref> [2] </ref> = 0.0; joint_torques [3] = min (actuator_torques [leg][0],actuator4max); joint_torques [3] = max (joint_torques [3], -actuator4max); joint_torques [4] = min (actuator_torques [leg][1],actuator5max); joint_torques [4] = max (joint_torques [4], -actuator5max); joint_torques [5] = min (actuator_torques [leg][2],actuator6max); joint_torques [5] = max (joint_torques [5], -actuator6max); for (int actuator=3; actuator&lt;6; ++actuator) if (joint_torques [actuator] != <p> into force and torqe components, body_cm_force.assign (3,0.0); // set size body_cm_torque.assign (3,0.0); // set size for (int i=0; i&lt;3; ++i) - body_cm_torque [i] = body_wrench [i]; body_cm_force [i] = body_wrench [i+3]; - //cout &lt;< body_cm_force &lt;< " body force " &lt;< endl; //---------------------------------------------------- // add gravity to force vector body_cm_force <ref> [2] </ref> -= body_weight; //cout &lt;< body_cm_torque &lt;< " body torque at c.m." &lt;< endl; //cout &lt;< body_cm_force &lt;< " body force at c.m. after gravity" &lt;< endl; //------------------------------------------------------- // calculate actual body velocities, using the Newton and Euler eqn. <p> iterate_foot (short foot, Column_vector & wrench) - int i; // assume foot mass is trivial compared to body // so joint forces from this leg do not affect body Column_vector foot_force (3); 149 //foot_force.assign (3,0.0); // set size for (i=0; i&lt;3; ++i) - foot_force [i] = -wrench [i+3]; - foot_force <ref> [2] </ref> -= foot_weight; //cout &lt;< foot_force &lt;< " foot " &lt;< foot &lt;< " force " &lt;< endl; Column_vector foot_linear_accel (3); foot_linear_accel.multiply (foot_force,1/foot_mass); //cout &lt;< foot_linear_accel &lt;< " foot " &lt;< foot &lt;< " acceleration "; Column_vector delta_v (3); delta_v.multiply (foot_linear_accel,delta_t); foot_linear_vel [foot].add (foot_linear_vel [foot],delta_v); //cout &lt;< foot_linear_vel [foot] &lt;< "
Reference: [3] <author> D. Todd, </author> <title> Walking Machines: an Introduction to Legged Robots. </title> <address> 29 West 35 St., New York, NY, 10001: </address> <publisher> Chapman and Hall, </publisher> <year> 1985. </year> <note> first published by Kogan Page, London. </note>
Reference-contexts: Legs can use isolated footholds, and thus can use the best part of the terrain, while legs must traverse everything, thus being limited by the worst part of the terrain. Legs form an active suspension <ref> [3] </ref> which can decouple body motion from the roughness of terrain, thus offering a potentially smoother ride. When constructing bridges and harbors, it is advantageous to have a camera/manipulator platform underwater. <p> Many other attempts to develop a suitable mechanism were made over the next century, culminating in the Iron Mule Train <ref> [3, pages 15,17] </ref>, developed for the U.S. Army. It was tested on realistic terrain, the results confirming that mechanical linkages do not have the adaptability necessary for locomotion over uneven terrain. <p> Various theoretical issues, including gait, were addressed, and in 1962, they began working with General Electric on what was to become the well-known "GE Walking Truck". Having found mechanical linkages insufficient, they used a human operator to control the limbs via electro-hydraulic feedback loops <ref> [3, pages 15-16] </ref>. The vehicle was quite capable, but was exhausting to operate for more than a few minutes, showing that walking machines would need to do much of their detailed control without human intervention. <p> The issue of powered ankle joints merits further discussion. Torques on the body which can be imposed by ankle joints are limited by the size of the feet. Powered ankle joints impose a number of penalties. The joints and their actuators add complexity <ref> [3, page 101] </ref> to the system. Actively controlled joints generally increase design and manufacturing costs and decrease reliability. A desirable property of legs is that the weight and moment of inertia of the legs be minimized [3, page 65]. <p> The joints and their actuators add complexity [3, page 101] to the system. Actively controlled joints generally increase design and manufacturing costs and decrease reliability. A desirable property of legs is that the weight and moment of inertia of the legs be minimized <ref> [3, page 65] </ref>. This reduces the amount of power required to accelerate the leg and reduces the influence of the leg on body dynamics. <p> 116 &gt; beta4 := evalm (R4B &* vector ([0, 0, 1])); &gt; &gt; beta5 := evalm (crossprod (p5B,gamma5)); &gt; &gt; beta6 := evalm (crossprod (p6B,gamma6)); &gt; &gt; # &gt; J := matrix (6,6): &gt; J [1,1] := gamma1 [1]: &gt; J [2,1] := gamma1 [2]: &gt; J [3,1] := gamma1 <ref> [3] </ref>: &gt; J [4,1] := beta1 [1]: &gt; J [5,1] := beta1 [2]: &gt; J [6,1] := beta1 [3]: &gt; J [1,2] := gamma2 [1]: &gt; J [2,2] := gamma2 [2]: &gt; J [3,2] := gamma2 [3]: &gt; J [4,2] := beta2 [1]: &gt; J [5,2] := beta2 [2]: &gt; J <p> &gt; &gt; beta6 := evalm (crossprod (p6B,gamma6)); &gt; &gt; # &gt; J := matrix (6,6): &gt; J [1,1] := gamma1 [1]: &gt; J [2,1] := gamma1 [2]: &gt; J [3,1] := gamma1 <ref> [3] </ref>: &gt; J [4,1] := beta1 [1]: &gt; J [5,1] := beta1 [2]: &gt; J [6,1] := beta1 [3]: &gt; J [1,2] := gamma2 [1]: &gt; J [2,2] := gamma2 [2]: &gt; J [3,2] := gamma2 [3]: &gt; J [4,2] := beta2 [1]: &gt; J [5,2] := beta2 [2]: &gt; J [6,2] := beta2 [3]: &gt; J [1,3] := gamma3 [1]: &gt; J [2,3] := gamma3 [2]: &gt; J <p> := gamma1 [1]: &gt; J [2,1] := gamma1 [2]: &gt; J [3,1] := gamma1 <ref> [3] </ref>: &gt; J [4,1] := beta1 [1]: &gt; J [5,1] := beta1 [2]: &gt; J [6,1] := beta1 [3]: &gt; J [1,2] := gamma2 [1]: &gt; J [2,2] := gamma2 [2]: &gt; J [3,2] := gamma2 [3]: &gt; J [4,2] := beta2 [1]: &gt; J [5,2] := beta2 [2]: &gt; J [6,2] := beta2 [3]: &gt; J [1,3] := gamma3 [1]: &gt; J [2,3] := gamma3 [2]: &gt; J [3,3] := gamma3 [3]: &gt; J [4,3] := beta3 [1]: &gt; J [5,3] := beta3 [2]: &gt; J <p> := beta1 [1]: &gt; J [5,1] := beta1 [2]: &gt; J [6,1] := beta1 <ref> [3] </ref>: &gt; J [1,2] := gamma2 [1]: &gt; J [2,2] := gamma2 [2]: &gt; J [3,2] := gamma2 [3]: &gt; J [4,2] := beta2 [1]: &gt; J [5,2] := beta2 [2]: &gt; J [6,2] := beta2 [3]: &gt; J [1,3] := gamma3 [1]: &gt; J [2,3] := gamma3 [2]: &gt; J [3,3] := gamma3 [3]: &gt; J [4,3] := beta3 [1]: &gt; J [5,3] := beta3 [2]: &gt; J [6,3] := simplify (beta3 [3]): &gt; J [1,4] := gamma4 [1]: &gt; J [2,4] := gamma4 [2]: &gt; <p> := gamma2 [1]: &gt; J [2,2] := gamma2 [2]: &gt; J [3,2] := gamma2 <ref> [3] </ref>: &gt; J [4,2] := beta2 [1]: &gt; J [5,2] := beta2 [2]: &gt; J [6,2] := beta2 [3]: &gt; J [1,3] := gamma3 [1]: &gt; J [2,3] := gamma3 [2]: &gt; J [3,3] := gamma3 [3]: &gt; J [4,3] := beta3 [1]: &gt; J [5,3] := beta3 [2]: &gt; J [6,3] := simplify (beta3 [3]): &gt; J [1,4] := gamma4 [1]: &gt; J [2,4] := gamma4 [2]: &gt; J [3,4] := gamma4 [3]: &gt; J [4,4] := beta4 [1]: &gt; J [5,4] := beta4 [2]: &gt; <p> beta2 [1]: &gt; J [5,2] := beta2 [2]: &gt; J [6,2] := beta2 <ref> [3] </ref>: &gt; J [1,3] := gamma3 [1]: &gt; J [2,3] := gamma3 [2]: &gt; J [3,3] := gamma3 [3]: &gt; J [4,3] := beta3 [1]: &gt; J [5,3] := beta3 [2]: &gt; J [6,3] := simplify (beta3 [3]): &gt; J [1,4] := gamma4 [1]: &gt; J [2,4] := gamma4 [2]: &gt; J [3,4] := gamma4 [3]: &gt; J [4,4] := beta4 [1]: &gt; J [5,4] := beta4 [2]: &gt; J [6,4] := beta4 [3]: &gt; J [1,5] := gamma5 [1]: &gt; J [2,5] := gamma5 [2]: &gt; J <p> gamma3 [1]: &gt; J [2,3] := gamma3 [2]: &gt; J [3,3] := gamma3 <ref> [3] </ref>: &gt; J [4,3] := beta3 [1]: &gt; J [5,3] := beta3 [2]: &gt; J [6,3] := simplify (beta3 [3]): &gt; J [1,4] := gamma4 [1]: &gt; J [2,4] := gamma4 [2]: &gt; J [3,4] := gamma4 [3]: &gt; J [4,4] := beta4 [1]: &gt; J [5,4] := beta4 [2]: &gt; J [6,4] := beta4 [3]: &gt; J [1,5] := gamma5 [1]: &gt; J [2,5] := gamma5 [2]: &gt; J [3,5] := gamma5 [3]: &gt; J [4,5] := beta5 [1]: &gt; J [5,5] := beta5 [2]: &gt; J <p> beta3 [1]: &gt; J [5,3] := beta3 [2]: &gt; J [6,3] := simplify (beta3 <ref> [3] </ref>): &gt; J [1,4] := gamma4 [1]: &gt; J [2,4] := gamma4 [2]: &gt; J [3,4] := gamma4 [3]: &gt; J [4,4] := beta4 [1]: &gt; J [5,4] := beta4 [2]: &gt; J [6,4] := beta4 [3]: &gt; J [1,5] := gamma5 [1]: &gt; J [2,5] := gamma5 [2]: &gt; J [3,5] := gamma5 [3]: &gt; J [4,5] := beta5 [1]: &gt; J [5,5] := beta5 [2]: &gt; J [6,5] := beta5 [3]: &gt; J [1,6] := gamma6 [1]: &gt; J [2,6] := gamma6 [2]: &gt; J <p> := gamma4 [1]: &gt; J [2,4] := gamma4 [2]: &gt; J [3,4] := gamma4 <ref> [3] </ref>: &gt; J [4,4] := beta4 [1]: &gt; J [5,4] := beta4 [2]: &gt; J [6,4] := beta4 [3]: &gt; J [1,5] := gamma5 [1]: &gt; J [2,5] := gamma5 [2]: &gt; J [3,5] := gamma5 [3]: &gt; J [4,5] := beta5 [1]: &gt; J [5,5] := beta5 [2]: &gt; J [6,5] := beta5 [3]: &gt; J [1,6] := gamma6 [1]: &gt; J [2,6] := gamma6 [2]: &gt; J [3,6] := gamma6 [3]: &gt; J [4,6] := beta6 [1]: 117 &gt; J [5,6] := beta6 [2]: &gt; <p> := beta4 [1]: &gt; J [5,4] := beta4 [2]: &gt; J [6,4] := beta4 <ref> [3] </ref>: &gt; J [1,5] := gamma5 [1]: &gt; J [2,5] := gamma5 [2]: &gt; J [3,5] := gamma5 [3]: &gt; J [4,5] := beta5 [1]: &gt; J [5,5] := beta5 [2]: &gt; J [6,5] := beta5 [3]: &gt; J [1,6] := gamma6 [1]: &gt; J [2,6] := gamma6 [2]: &gt; J [3,6] := gamma6 [3]: &gt; J [4,6] := beta6 [1]: 117 &gt; J [5,6] := beta6 [2]: &gt; J [6,6] := beta6 [3]: &gt; J := evalm (J); &gt; [ %1 ; %2 ; sin ( <p> := gamma5 [1]: &gt; J [2,5] := gamma5 [2]: &gt; J [3,5] := gamma5 <ref> [3] </ref>: &gt; J [4,5] := beta5 [1]: &gt; J [5,5] := beta5 [2]: &gt; J [6,5] := beta5 [3]: &gt; J [1,6] := gamma6 [1]: &gt; J [2,6] := gamma6 [2]: &gt; J [3,6] := gamma6 [3]: &gt; J [4,6] := beta6 [1]: 117 &gt; J [5,6] := beta6 [2]: &gt; J [6,6] := beta6 [3]: &gt; J := evalm (J); &gt; [ %1 ; %2 ; sin ( 6 ) ; 0 ; sin ( 6 ) ; 0 ] [ %5 sin ( 2 ) <p> beta5 [1]: &gt; J [5,5] := beta5 [2]: &gt; J [6,5] := beta5 <ref> [3] </ref>: &gt; J [1,6] := gamma6 [1]: &gt; J [2,6] := gamma6 [2]: &gt; J [3,6] := gamma6 [3]: &gt; J [4,6] := beta6 [1]: 117 &gt; J [5,6] := beta6 [2]: &gt; J [6,6] := beta6 [3]: &gt; J := evalm (J); &gt; [ %1 ; %2 ; sin ( 6 ) ; 0 ; sin ( 6 ) ; 0 ] [ %5 sin ( 2 ) ; %6 ; 0 ; 0 ; 0 ; 1 ] sin ( 6 ) sin ( 5 ) <p> Douglas Reeder //---------------------------------------------------------- #include "matrix.H" extern const double hip_offset <ref> [3] </ref>; //const short False = 0; //const short True = 1; extern double el_time; extern double offset_x []; extern double offset_y []; extern double offset_z []; extern Column_vector body_pos; // position & orientation extern Matrix RBG; // body rotation matrix extern Column_vector pBG; // body position 3-vector extern Column_vector desired_accel; extern <p> extern Column_vector body_pos; // position & orientation extern Matrix RBG; // body rotation matrix extern Column_vector pBG; // body position 3-vector extern Column_vector desired_accel; extern Column_vector desired_vel; extern Column_vector desired_pos; enum State -inner_fwd,inner_only,outer_fwd,outer_only-; ///////////////////////////////////////////////////////////////////////// // function prototypes void init_state (void); void do_trig (void); void sequencer (void); void control_loop (Column_vector torqes <ref> [3] </ref>); //----------------------------------------------------------- // control.C - triped control software // by P. <p> pBG (3), body_start (3); // body position 3-vector ///////////////////////////////////////////////////////////////////// // function declarations (forward references) void calc_frame0_Jacobian (Column_vector & theta, double d6, Matrix & J0); void calc_body_matricies (int leg, Matrix & RB0, Column_vector & pB0); void do_state_machine (void); void place_foot (int leg, int rleg); void fwd_on_all (Column_vector & des_wrench, Column_vector torques <ref> [3] </ref>); void fwd_on_inner (Column_vector & des_wrench, Column_vector torques [3]); void fwd_on_outer (Column_vector & des_wrench, Column_vector torques [3]); void least_squares (Matrix & Kbd, Matrix & KbdT, 122 Column_vector & augmented_wrench, Column_vector & torque456); //////////////////////////////////////////////////////////////////////// // sequencer -- controls sequence of events // inputs: [none] // outputs: [none] // side effects: increments el_time, <p> ///////////////////////////////////////////////////////////////////// // function declarations (forward references) void calc_frame0_Jacobian (Column_vector & theta, double d6, Matrix & J0); void calc_body_matricies (int leg, Matrix & RB0, Column_vector & pB0); void do_state_machine (void); void place_foot (int leg, int rleg); void fwd_on_all (Column_vector & des_wrench, Column_vector torques <ref> [3] </ref>); void fwd_on_inner (Column_vector & des_wrench, Column_vector torques [3]); void fwd_on_outer (Column_vector & des_wrench, Column_vector torques [3]); void least_squares (Matrix & Kbd, Matrix & KbdT, 122 Column_vector & augmented_wrench, Column_vector & torque456); //////////////////////////////////////////////////////////////////////// // sequencer -- controls sequence of events // inputs: [none] // outputs: [none] // side effects: increments el_time, // when sequence completes, reinitializes sim. //////////////////////////////////////////////////////////////////////// void <p> (Column_vector & theta, double d6, Matrix & J0); void calc_body_matricies (int leg, Matrix & RB0, Column_vector & pB0); void do_state_machine (void); void place_foot (int leg, int rleg); void fwd_on_all (Column_vector & des_wrench, Column_vector torques <ref> [3] </ref>); void fwd_on_inner (Column_vector & des_wrench, Column_vector torques [3]); void fwd_on_outer (Column_vector & des_wrench, Column_vector torques [3]); void least_squares (Matrix & Kbd, Matrix & KbdT, 122 Column_vector & augmented_wrench, Column_vector & torque456); //////////////////////////////////////////////////////////////////////// // sequencer -- controls sequence of events // inputs: [none] // outputs: [none] // side effects: increments el_time, // when sequence completes, reinitializes sim. //////////////////////////////////////////////////////////////////////// void sequencer (void) - const double altitude = 1.75; <p> desired_pos.assign (6,0.0); desired_pos [0] = M_PI/2.0; desired_pos [2] = M_PI/2.0; for (int i=0; i&lt;num_legs; ++i) desired_pos [i+3] = body_start [i]; //desired_pos [1] = tilt; desired_vel.assign (6,0.0); desired_accel.assign (6,0.0); */ if (el_time&lt;turntime) - // walk forward desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos [1] = -M_PI_4; desired_pos [2] = M_PI_2; desired_pos <ref> [3] </ref> = body_start [0]+desired_speed*M_SQRT1_2*el_time; desired_pos [4] = body_start [1]-desired_speed*M_SQRT1_2*el_time; desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; 123 desired_vel.assign (6,0.0); desired_vel [3] = desired_speed*M_SQRT1_2; desired_vel [4] = -desired_speed*M_SQRT1_2; desired_accel.assign (6,0.0); - if (el_time&gt;=turntime) - // circular turn to left const double radius = 5; double <p> (6,0.0); */ if (el_time&lt;turntime) - // walk forward desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos [1] = -M_PI_4; desired_pos [2] = M_PI_2; desired_pos <ref> [3] </ref> = body_start [0]+desired_speed*M_SQRT1_2*el_time; desired_pos [4] = body_start [1]-desired_speed*M_SQRT1_2*el_time; desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; 123 desired_vel.assign (6,0.0); desired_vel [3] = desired_speed*M_SQRT1_2; desired_vel [4] = -desired_speed*M_SQRT1_2; desired_accel.assign (6,0.0); - if (el_time&gt;=turntime) - // circular turn to left const double radius = 5; double rho = (el_time-turntime)*desired_speed/radius - M_PI_4; desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos [1] = rho; // euler angle beta desired_pos [2] = M_PI_2; desired_pos [3] = body_start <p> (6,0.0); desired_vel <ref> [3] </ref> = desired_speed*M_SQRT1_2; desired_vel [4] = -desired_speed*M_SQRT1_2; desired_accel.assign (6,0.0); - if (el_time&gt;=turntime) - // circular turn to left const double radius = 5; double rho = (el_time-turntime)*desired_speed/radius - M_PI_4; desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos [1] = rho; // euler angle beta desired_pos [2] = M_PI_2; desired_pos [3] = body_start [0] + turntime*desired_speed*M_SQRT1_2 + radius*(sin (rho)+M_SQRT1_2); desired_pos [4] = body_start [1] - turntime*desired_speed*M_SQRT1_2 - radius*(cos (rho) - M_SQRT1_2); desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; desired_vel.assign (6,0.0); desired_vel [2] = desired_speed/radius; // rotate about z axis desired_vel [3] = desired_speed*cos (rho); <p> = M_PI_2; desired_pos <ref> [3] </ref> = body_start [0] + turntime*desired_speed*M_SQRT1_2 + radius*(sin (rho)+M_SQRT1_2); desired_pos [4] = body_start [1] - turntime*desired_speed*M_SQRT1_2 - radius*(cos (rho) - M_SQRT1_2); desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; desired_vel.assign (6,0.0); desired_vel [2] = desired_speed/radius; // rotate about z axis desired_vel [3] = desired_speed*cos (rho); desired_vel [4] = desired_speed*sin (rho); //cout &lt;< desired_vel &lt;< " = desired velocity" &lt;< endl; desired_accel.assign (6,0.0); desired_accel [3] = -desired_speed*sin (rho); desired_accel [4] = desired_speed*cos (rho); //cout &lt;< desired_accel &lt;< " = desired acceleration" &lt;< endl; - if (el_time&gt;timelimit) ; if (el_time&gt;(timelimit+freezetime)) - // reset simulation <p> - M_SQRT1_2); desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; desired_vel.assign (6,0.0); desired_vel [2] = desired_speed/radius; // rotate about z axis desired_vel <ref> [3] </ref> = desired_speed*cos (rho); desired_vel [4] = desired_speed*sin (rho); //cout &lt;< desired_vel &lt;< " = desired velocity" &lt;< endl; desired_accel.assign (6,0.0); desired_accel [3] = -desired_speed*sin (rho); desired_accel [4] = desired_speed*cos (rho); //cout &lt;< desired_accel &lt;< " = desired acceleration" &lt;< endl; - if (el_time&gt;timelimit) ; if (el_time&gt;(timelimit+freezetime)) - // reset simulation 124 init_state (); - el_time += delta_t; - // control_loop -- calculate a new set of desired joint torques // inputs: [none] <p> delta_t; - // control_loop -- calculate a new set of desired joint torques // inputs: [none] // outputs: [none] // globals: J [], Jinv [] (Jacobians) // side effect: calculates Jacobian for each leg (the plant simulation // _depends_ on this function updating the Jacobians ////////////////////////////////////////////////////////////////////////// void control_loop (Column_vector torques <ref> [3] </ref>) - do_state_machine (); //-------------------------------------------------------- // calculate Jacobian for each leg for (int leg=0; leg&lt;num_legs; ++leg) - calc_frame0_Jacobian (joint_ang [leg],hip_offset [leg],J [leg]); // numerically invert Jacobian, because the symbolic form inverse is too // complicated Jinv [leg].invert (J [leg]); if (Jinv [leg].get_status () != Matrix::ok) clog &lt;< "leg " &lt;< leg <p> *sin (theta2r)/sin (M_PI-place_angle); joint_ang [leg][4] = M_PI_2; joint_ang [leg][5] = -place_angle+joint_ang [rleg][5]+theta2r; calc_body_matricies (leg, junk, offset); foot_lin_pos [leg].subtract (pBG,offset); cout &lt;< foot_lin_pos [leg] &lt;< " = position of foot " &lt;< leg &lt;< endl; foot_linear_vel [leg].assign (3, 0.0); - // fwd_on_inner (); /////////////////////////////////////////////////////////////////////////// void fwd_on_inner (Column_vector & des_wrench, Column_vector torques <ref> [3] </ref>) - //cout &lt;< "moving forward on inner leg only" &lt;< endl; // Use only center leg (leg 0) to apply desired torqe // matrix K is the inverse transpose of the Jacobian // matrix Kbd is the right half of K Matrix Kbd (6,3, 0.0); Matrix KbdT (3,6, 0.0); for <p> " = torque456" &lt;< endl; least_squares (Kbd,KbdT,des_wrench,torques [0]); 132 //torques [1].assign (3, 0.0); //torques [2].assign (3, 0.0); torques [1][0] = torques [2][0] = -40; torques [1][1] = torques [2][1] = 0; torques [1][2] = torques [2][2] = -70; - // fwd_on_outer () /////////////////////////////////////////////////////////////////////////// void fwd_on_outer (Column_vector & des_wrench, Column_vector torques <ref> [3] </ref>) - //cout &lt;< "moving forward on outer legs only" &lt;< endl; // Use only outer legs (legs 1 and 2) to apply desired torqe // matrix K is the inverse transpose of the Jacobian // matrix Kbd is the right half of K Matrix Kbd (7,6, 0.0); Matrix KbdT (6,7, <p> (3,888.8); for (int i = 0; i&lt;3; ++i) - torques [1][i] = torque456 [i]; torques [2][i] = torque456 [i+3]; - torques [0][0] = -40; torques [0][1] = 0; torques [0][2] = -70; - // fwd_on_all (); // move forward on three legs /////////////////////////////////////////////////////////////////////////// void fwd_on_all (Column_vector & des_wrench, Column_vector torques <ref> [3] </ref>) - //cout &lt;< "moving forward on all legs" &lt;< endl; const int num_constraints = 9; Matrix Kbd (num_constraints, 9, 0.0); Matrix KbdT (9, num_constraints, 0.0); for (int i=0; i&lt;6; ++i) Kbd.elem [i][j] = Jinv [0].elem [j+3][i]; Kbd.elem [i][j+3] = Jinv [1].elem [j+3][i]; Kbd.elem [i][j+6] = Jinv [2].elem [j+3][i]; - Kbd.elem <p> [frame 0 Jacobian] ///////////////////////////////////////////////////////////////////////// void calc_frame0_Jacobian (Column_vector & theta, double d6, Matrix & J0) - double s1,c1,s2,c2,s3,c3,d4,s5,c5,s6,c6; s1 = sin (theta [0]); c1 = cos (theta [0]); s2 = sin (theta [1]); c2 = cos (theta [1]); s3 = sin (theta [2]); c3 = cos (theta [2]); d4 = theta <ref> [3] </ref>; s5 = sin (theta [4]); c5 = cos (theta [4]); s6 = sin (theta [5]); c6 = cos (theta [5]); // calculate body-frame (frame 6) Jacobian, row by row Matrix J6 (6,6); // temp. variables double temp1 = s2*c6*c5*c3 + s2*c6*s5*s3 + s6*c2; double temp2 = c6*c5*s3 - c6*s5*c3; double <p> // init_state -- initialize the state of the system // inputs: [none] // outputs: [none] // globals: sets el_time,joint_ang [leg angles], body linear vel., // body ang. vel //////////////////////////////////////////////////////////////////////// void init_state (void) - Matrix junk; Column_vector offset (3); el_time = 0; // assign values for leg 0 const double init_pos_foot0 <ref> [3] </ref> = --1.5, 0 , 0-; foot_lin_pos [0].assign (3,init_pos_foot0); joint_ang [0].assign (6,999.9); // set size of vector joint_ang [0][0] = -M_PI_4; joint_ang [0][1] = M_PI*5/8; joint_ang [0][2] = M_PI_2; joint_ang [0][3] = 1.6236; joint_ang [0][4] = M_PI_2 + roll; joint_ang [0][5] = -M_PI/8 tilt; // calculate body position calc_body_matricies (0, RBG, <p> Column_vector foot_lin_pos [num_legs]; // position only extern Column_vector foot_linear_vel [num_legs]; extern short foot_up [num_legs]; extern short foot_slipping [num_legs]; 143 // variables derived from state variables extern Matrix J [num_legs]; extern Matrix Jinv [num_legs]; // other global variables extern Column_vector body_wrench; extern Matrix body_inertia; // function prototypes void iterate_plant (Column_vector actuator_torques <ref> [3] </ref>); //------------------------------------------------------------ // plant.C mechanical simulation of triped // by P. <p> Column_vector body_cm_force (3); ///////////////////////////////////////////////////////////////////////// // function prototypes void integrate (Column_vector & body_ang_accel, Column_vector & body_linear_accel, Column_vector & body_velocity); void iterate_foot (short foot,Column_vector & wrench); ///////////////////////////////////////////////////////////////////////// // interate_plant do one iteration of plant simulation // input: actuator torques: each vector contains the torqes for joints 4,5,&6 ///////////////////////////////////////////////////////////////////////// void iterate_plant (Column_vector actuator_torques <ref> [3] </ref>) - body_wrench.assign (6, 0.0); for (int leg=0; leg&lt;num_legs; ++leg) - 145 Column_vector joint_torques (6); // copy joint torqes, and apply torque limits joint_torques [0] = joint_torques [1] = joint_torques [2] = 0.0; joint_torques [3] = min (actuator_torques [leg][0],actuator4max); joint_torques [3] = max (joint_torques [3], -actuator4max); joint_torques [4] = min (actuator_torques <p> input: actuator torques: each vector contains the torqes for joints 4,5,&6 ///////////////////////////////////////////////////////////////////////// void iterate_plant (Column_vector actuator_torques <ref> [3] </ref>) - body_wrench.assign (6, 0.0); for (int leg=0; leg&lt;num_legs; ++leg) - 145 Column_vector joint_torques (6); // copy joint torqes, and apply torque limits joint_torques [0] = joint_torques [1] = joint_torques [2] = 0.0; joint_torques [3] = min (actuator_torques [leg][0],actuator4max); joint_torques [3] = max (joint_torques [3], -actuator4max); joint_torques [4] = min (actuator_torques [leg][1],actuator5max); joint_torques [4] = max (joint_torques [4], -actuator5max); joint_torques [5] = min (actuator_torques [leg][2],actuator6max); joint_torques [5] = max (joint_torques [5], -actuator6max); for (int actuator=3; actuator&lt;6; ++actuator) if (joint_torques [actuator] != actuator_torques [leg][actuator-3]) clog &lt;< <p> the torqes for joints 4,5,&6 ///////////////////////////////////////////////////////////////////////// void iterate_plant (Column_vector actuator_torques <ref> [3] </ref>) - body_wrench.assign (6, 0.0); for (int leg=0; leg&lt;num_legs; ++leg) - 145 Column_vector joint_torques (6); // copy joint torqes, and apply torque limits joint_torques [0] = joint_torques [1] = joint_torques [2] = 0.0; joint_torques [3] = min (actuator_torques [leg][0],actuator4max); joint_torques [3] = max (joint_torques [3], -actuator4max); joint_torques [4] = min (actuator_torques [leg][1],actuator5max); joint_torques [4] = max (joint_torques [4], -actuator5max); joint_torques [5] = min (actuator_torques [leg][2],actuator6max); joint_torques [5] = max (joint_torques [5], -actuator6max); for (int actuator=3; actuator&lt;6; ++actuator) if (joint_torques [actuator] != actuator_torques [leg][actuator-3]) clog &lt;< "ACTUATOR " &lt;< (actuator+1) &lt;< " <p> 4,5,&6 ///////////////////////////////////////////////////////////////////////// void iterate_plant (Column_vector actuator_torques <ref> [3] </ref>) - body_wrench.assign (6, 0.0); for (int leg=0; leg&lt;num_legs; ++leg) - 145 Column_vector joint_torques (6); // copy joint torqes, and apply torque limits joint_torques [0] = joint_torques [1] = joint_torques [2] = 0.0; joint_torques [3] = min (actuator_torques [leg][0],actuator4max); joint_torques [3] = max (joint_torques [3], -actuator4max); joint_torques [4] = min (actuator_torques [leg][1],actuator5max); joint_torques [4] = max (joint_torques [4], -actuator5max); joint_torques [5] = min (actuator_torques [leg][2],actuator6max); joint_torques [5] = max (joint_torques [5], -actuator6max); for (int actuator=3; actuator&lt;6; ++actuator) if (joint_torques [actuator] != actuator_torques [leg][actuator-3]) clog &lt;< "ACTUATOR " &lt;< (actuator+1) &lt;< " MAXED, leg " &lt;<
Reference: [4] <author> J. Akizono, M. Iwasaki, T. Nemoto, and O.Asakura, </author> <title> "Development on walking robot for underwater inspection," </title> <booktitle> in Advanced Robotics 1989: Proceedings of the 4th Internation Conference on Advanced Robotics (K. </booktitle> <editor> J. Waldron, </editor> <publisher> ed.), </publisher> <pages> pp. 652-653, </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: When constructing bridges and harbors, it is advantageous to have a camera/manipulator platform underwater. Floating vehicles have trouble maintaining a fixed position, and wheeled or tracked vehicles stir up so much mud that cameras are useless <ref> [4, page 652] </ref>. Finally, legged vehicles have some advantages over wheeled vehicles in indoor 3 environments. Building interiors are designed to accommodate human locomotion, having fixtures such as stairs. Private homes are often ill-designed for wheeled vehicles, which limits the usefulness of wheelchairs and wheeled robots in the home. <p> M_PI/2.0; desired_pos [2] = M_PI/2.0; for (int i=0; i&lt;num_legs; ++i) desired_pos [i+3] = body_start [i]; //desired_pos [1] = tilt; desired_vel.assign (6,0.0); desired_accel.assign (6,0.0); */ if (el_time&lt;turntime) - // walk forward desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos [1] = -M_PI_4; desired_pos [2] = M_PI_2; desired_pos [3] = body_start [0]+desired_speed*M_SQRT1_2*el_time; desired_pos <ref> [4] </ref> = body_start [1]-desired_speed*M_SQRT1_2*el_time; desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; 123 desired_vel.assign (6,0.0); desired_vel [3] = desired_speed*M_SQRT1_2; desired_vel [4] = -desired_speed*M_SQRT1_2; desired_accel.assign (6,0.0); - if (el_time&gt;=turntime) - // circular turn to left const double radius = 5; double rho = (el_time-turntime)*desired_speed/radius - M_PI_4; <p> - // walk forward desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos [1] = -M_PI_4; desired_pos [2] = M_PI_2; desired_pos [3] = body_start [0]+desired_speed*M_SQRT1_2*el_time; desired_pos <ref> [4] </ref> = body_start [1]-desired_speed*M_SQRT1_2*el_time; desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; 123 desired_vel.assign (6,0.0); desired_vel [3] = desired_speed*M_SQRT1_2; desired_vel [4] = -desired_speed*M_SQRT1_2; desired_accel.assign (6,0.0); - if (el_time&gt;=turntime) - // circular turn to left const double radius = 5; double rho = (el_time-turntime)*desired_speed/radius - M_PI_4; desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos [1] = rho; // euler angle beta desired_pos [2] = M_PI_2; desired_pos [3] = body_start [0] + turntime*desired_speed*M_SQRT1_2 + <p> (6,0.0); - if (el_time&gt;=turntime) - // circular turn to left const double radius = 5; double rho = (el_time-turntime)*desired_speed/radius - M_PI_4; desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos [1] = rho; // euler angle beta desired_pos [2] = M_PI_2; desired_pos [3] = body_start [0] + turntime*desired_speed*M_SQRT1_2 + radius*(sin (rho)+M_SQRT1_2); desired_pos <ref> [4] </ref> = body_start [1] - turntime*desired_speed*M_SQRT1_2 - radius*(cos (rho) - M_SQRT1_2); desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; desired_vel.assign (6,0.0); desired_vel [2] = desired_speed/radius; // rotate about z axis desired_vel [3] = desired_speed*cos (rho); desired_vel [4] = desired_speed*sin (rho); //cout &lt;< desired_vel &lt;< " <p> body_start [0] + turntime*desired_speed*M_SQRT1_2 + radius*(sin (rho)+M_SQRT1_2); desired_pos <ref> [4] </ref> = body_start [1] - turntime*desired_speed*M_SQRT1_2 - radius*(cos (rho) - M_SQRT1_2); desired_pos [5] = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; desired_vel.assign (6,0.0); desired_vel [2] = desired_speed/radius; // rotate about z axis desired_vel [3] = desired_speed*cos (rho); desired_vel [4] = desired_speed*sin (rho); //cout &lt;< desired_vel &lt;< " = desired velocity" &lt;< endl; desired_accel.assign (6,0.0); desired_accel [3] = -desired_speed*sin (rho); desired_accel [4] = desired_speed*cos (rho); //cout &lt;< desired_accel &lt;< " = desired acceleration" &lt;< endl; - if (el_time&gt;timelimit) ; if (el_time&gt;(timelimit+freezetime)) - // reset simulation 124 init_state (); - el_time <p> altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; desired_vel.assign (6,0.0); desired_vel [2] = desired_speed/radius; // rotate about z axis desired_vel [3] = desired_speed*cos (rho); desired_vel <ref> [4] </ref> = desired_speed*sin (rho); //cout &lt;< desired_vel &lt;< " = desired velocity" &lt;< endl; desired_accel.assign (6,0.0); desired_accel [3] = -desired_speed*sin (rho); desired_accel [4] = desired_speed*cos (rho); //cout &lt;< desired_accel &lt;< " = desired acceleration" &lt;< endl; - if (el_time&gt;timelimit) ; if (el_time&gt;(timelimit+freezetime)) - // reset simulation 124 init_state (); - el_time += delta_t; - // control_loop -- calculate a new set of desired joint torques // inputs: [none] // outputs: [none] // globals: <p> calc_frame0_Jacobian (Column_vector & theta, double d6, Matrix & J0) - double s1,c1,s2,c2,s3,c3,d4,s5,c5,s6,c6; s1 = sin (theta [0]); c1 = cos (theta [0]); s2 = sin (theta [1]); c2 = cos (theta [1]); s3 = sin (theta [2]); c3 = cos (theta [2]); d4 = theta [3]; s5 = sin (theta <ref> [4] </ref>); c5 = cos (theta [4]); s6 = sin (theta [5]); c6 = cos (theta [5]); // calculate body-frame (frame 6) Jacobian, row by row Matrix J6 (6,6); // temp. variables double temp1 = s2*c6*c5*c3 + s2*c6*s5*s3 + s6*c2; double temp2 = c6*c5*s3 - c6*s5*c3; double temp3 = -s2*s6*c5*c3 - s2*s6*s5*s3 <p> d6, Matrix & J0) - double s1,c1,s2,c2,s3,c3,d4,s5,c5,s6,c6; s1 = sin (theta [0]); c1 = cos (theta [0]); s2 = sin (theta [1]); c2 = cos (theta [1]); s3 = sin (theta [2]); c3 = cos (theta [2]); d4 = theta [3]; s5 = sin (theta <ref> [4] </ref>); c5 = cos (theta [4]); s6 = sin (theta [5]); c6 = cos (theta [5]); // calculate body-frame (frame 6) Jacobian, row by row Matrix J6 (6,6); // temp. variables double temp1 = s2*c6*c5*c3 + s2*c6*s5*s3 + s6*c2; double temp2 = c6*c5*s3 - c6*s5*c3; double temp3 = -s2*s6*c5*c3 - s2*s6*s5*s3 + c6*c2; double temp4 = <p> iterate_plant (Column_vector actuator_torques [3]) - body_wrench.assign (6, 0.0); for (int leg=0; leg&lt;num_legs; ++leg) - 145 Column_vector joint_torques (6); // copy joint torqes, and apply torque limits joint_torques [0] = joint_torques [1] = joint_torques [2] = 0.0; joint_torques [3] = min (actuator_torques [leg][0],actuator4max); joint_torques [3] = max (joint_torques [3], -actuator4max); joint_torques <ref> [4] </ref> = min (actuator_torques [leg][1],actuator5max); joint_torques [4] = max (joint_torques [4], -actuator5max); joint_torques [5] = min (actuator_torques [leg][2],actuator6max); joint_torques [5] = max (joint_torques [5], -actuator6max); for (int actuator=3; actuator&lt;6; ++actuator) if (joint_torques [actuator] != actuator_torques [leg][actuator-3]) clog &lt;< "ACTUATOR " &lt;< (actuator+1) &lt;< " MAXED, leg " &lt;< leg &lt;< endl; <p> (6, 0.0); for (int leg=0; leg&lt;num_legs; ++leg) - 145 Column_vector joint_torques (6); // copy joint torqes, and apply torque limits joint_torques [0] = joint_torques [1] = joint_torques [2] = 0.0; joint_torques [3] = min (actuator_torques [leg][0],actuator4max); joint_torques [3] = max (joint_torques [3], -actuator4max); joint_torques <ref> [4] </ref> = min (actuator_torques [leg][1],actuator5max); joint_torques [4] = max (joint_torques [4], -actuator5max); joint_torques [5] = min (actuator_torques [leg][2],actuator6max); joint_torques [5] = max (joint_torques [5], -actuator6max); for (int actuator=3; actuator&lt;6; ++actuator) if (joint_torques [actuator] != actuator_torques [leg][actuator-3]) clog &lt;< "ACTUATOR " &lt;< (actuator+1) &lt;< " MAXED, leg " &lt;< leg &lt;< endl; //if (leg==0) cout &lt;< joint_torques &lt;< <p> leg=0; leg&lt;num_legs; ++leg) - 145 Column_vector joint_torques (6); // copy joint torqes, and apply torque limits joint_torques [0] = joint_torques [1] = joint_torques [2] = 0.0; joint_torques [3] = min (actuator_torques [leg][0],actuator4max); joint_torques [3] = max (joint_torques [3], -actuator4max); joint_torques <ref> [4] </ref> = min (actuator_torques [leg][1],actuator5max); joint_torques [4] = max (joint_torques [4], -actuator5max); joint_torques [5] = min (actuator_torques [leg][2],actuator6max); joint_torques [5] = max (joint_torques [5], -actuator6max); for (int actuator=3; actuator&lt;6; ++actuator) if (joint_torques [actuator] != actuator_torques [leg][actuator-3]) clog &lt;< "ACTUATOR " &lt;< (actuator+1) &lt;< " MAXED, leg " &lt;< leg &lt;< endl; //if (leg==0) cout &lt;< joint_torques &lt;< endl; Jinvtrans.transpose (Jinv [leg]);
Reference: [5] <author> T. Kato, A. Takanishi, H. Jishikawa, and I. Kato, </author> <title> "The realization of the quasi-daynamic walking by the biped walking machine," </title> <booktitle> in Fourth Symposium on Theory and Practice of Robots and Manipulators (A. </booktitle> <editor> Morecki, G. Bianchi, and K. Kedzior, eds.), </editor> <publisher> (Warsaw), </publisher> <pages> pp. 341-351, </pages> <publisher> Polish Scientific Publishers, </publisher> <year> 1983. </year>
Reference-contexts: Legged locomotion is an area of robotics where it is reasonably clear what is a workable approach and what is not. Furthermore, legged locomotion poses interesting challenges for the engineer in applied dynamics and control. Currently, robots with one [2, chapters 2-3], two <ref> [5] </ref>, four [6], six [7] and eight [8] legs are studied.[9] They divide naturally into two groups | one and two legged robots that dynamically balance, and robots with four or more legs that are basically statically stable, though they may use gaits that are dynamically stable. <p> for (int i=0; i&lt;num_legs; ++i) desired_pos [i+3] = body_start [i]; //desired_pos [1] = tilt; desired_vel.assign (6,0.0); desired_accel.assign (6,0.0); */ if (el_time&lt;turntime) - // walk forward desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos [1] = -M_PI_4; desired_pos [2] = M_PI_2; desired_pos [3] = body_start [0]+desired_speed*M_SQRT1_2*el_time; desired_pos [4] = body_start [1]-desired_speed*M_SQRT1_2*el_time; desired_pos <ref> [5] </ref> = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; 123 desired_vel.assign (6,0.0); desired_vel [3] = desired_speed*M_SQRT1_2; desired_vel [4] = -desired_speed*M_SQRT1_2; desired_accel.assign (6,0.0); - if (el_time&gt;=turntime) - // circular turn to left const double radius = 5; double rho = (el_time-turntime)*desired_speed/radius - M_PI_4; desired_pos.assign (6,0.0); desired_pos [0] = <p> radius = 5; double rho = (el_time-turntime)*desired_speed/radius - M_PI_4; desired_pos.assign (6,0.0); desired_pos [0] = M_PI_2; desired_pos [1] = rho; // euler angle beta desired_pos [2] = M_PI_2; desired_pos [3] = body_start [0] + turntime*desired_speed*M_SQRT1_2 + radius*(sin (rho)+M_SQRT1_2); desired_pos [4] = body_start [1] - turntime*desired_speed*M_SQRT1_2 - radius*(cos (rho) - M_SQRT1_2); desired_pos <ref> [5] </ref> = altitude; //cout &lt;< desired_pos &lt;< " = desired position" &lt;< endl; desired_vel.assign (6,0.0); desired_vel [2] = desired_speed/radius; // rotate about z axis desired_vel [3] = desired_speed*cos (rho); desired_vel [4] = desired_speed*sin (rho); //cout &lt;< desired_vel &lt;< " = desired velocity" &lt;< endl; desired_accel.assign (6,0.0); desired_accel [3] = -desired_speed*sin (rho); <p> double s1,c1,s2,c2,s3,c3,d4,s5,c5,s6,c6; s1 = sin (theta [0]); c1 = cos (theta [0]); s2 = sin (theta [1]); c2 = cos (theta [1]); s3 = sin (theta [2]); c3 = cos (theta [2]); d4 = theta [3]; s5 = sin (theta [4]); c5 = cos (theta [4]); s6 = sin (theta <ref> [5] </ref>); c6 = cos (theta [5]); // calculate body-frame (frame 6) Jacobian, row by row Matrix J6 (6,6); // temp. variables double temp1 = s2*c6*c5*c3 + s2*c6*s5*s3 + s6*c2; double temp2 = c6*c5*s3 - c6*s5*c3; double temp3 = -s2*s6*c5*c3 - s2*s6*s5*s3 + c6*c2; double temp4 = -s6*c5*s3 + s6*s5*c3; double temp5 <p> (theta [0]); c1 = cos (theta [0]); s2 = sin (theta [1]); c2 = cos (theta [1]); s3 = sin (theta [2]); c3 = cos (theta [2]); d4 = theta [3]; s5 = sin (theta [4]); c5 = cos (theta [4]); s6 = sin (theta <ref> [5] </ref>); c6 = cos (theta [5]); // calculate body-frame (frame 6) Jacobian, row by row Matrix J6 (6,6); // temp. variables double temp1 = s2*c6*c5*c3 + s2*c6*s5*s3 + s6*c2; double temp2 = c6*c5*s3 - c6*s5*c3; double temp3 = -s2*s6*c5*c3 - s2*s6*s5*s3 + c6*c2; double temp4 = -s6*c5*s3 + s6*s5*c3; double temp5 = -s5*c3 + c5*s3; double <p> - 145 Column_vector joint_torques (6); // copy joint torqes, and apply torque limits joint_torques [0] = joint_torques [1] = joint_torques [2] = 0.0; joint_torques [3] = min (actuator_torques [leg][0],actuator4max); joint_torques [3] = max (joint_torques [3], -actuator4max); joint_torques [4] = min (actuator_torques [leg][1],actuator5max); joint_torques [4] = max (joint_torques [4], -actuator5max); joint_torques <ref> [5] </ref> = min (actuator_torques [leg][2],actuator6max); joint_torques [5] = max (joint_torques [5], -actuator6max); for (int actuator=3; actuator&lt;6; ++actuator) if (joint_torques [actuator] != actuator_torques [leg][actuator-3]) clog &lt;< "ACTUATOR " &lt;< (actuator+1) &lt;< " MAXED, leg " &lt;< leg &lt;< endl; //if (leg==0) cout &lt;< joint_torques &lt;< endl; Jinvtrans.transpose (Jinv [leg]); //------------------------------------------------------- // Calculate <p> copy joint torqes, and apply torque limits joint_torques [0] = joint_torques [1] = joint_torques [2] = 0.0; joint_torques [3] = min (actuator_torques [leg][0],actuator4max); joint_torques [3] = max (joint_torques [3], -actuator4max); joint_torques [4] = min (actuator_torques [leg][1],actuator5max); joint_torques [4] = max (joint_torques [4], -actuator5max); joint_torques <ref> [5] </ref> = min (actuator_torques [leg][2],actuator6max); joint_torques [5] = max (joint_torques [5], -actuator6max); for (int actuator=3; actuator&lt;6; ++actuator) if (joint_torques [actuator] != actuator_torques [leg][actuator-3]) clog &lt;< "ACTUATOR " &lt;< (actuator+1) &lt;< " MAXED, leg " &lt;< leg &lt;< endl; //if (leg==0) cout &lt;< joint_torques &lt;< endl; Jinvtrans.transpose (Jinv [leg]); //------------------------------------------------------- // Calculate actual body wrench from the leg <p> apply torque limits joint_torques [0] = joint_torques [1] = joint_torques [2] = 0.0; joint_torques [3] = min (actuator_torques [leg][0],actuator4max); joint_torques [3] = max (joint_torques [3], -actuator4max); joint_torques [4] = min (actuator_torques [leg][1],actuator5max); joint_torques [4] = max (joint_torques [4], -actuator5max); joint_torques <ref> [5] </ref> = min (actuator_torques [leg][2],actuator6max); joint_torques [5] = max (joint_torques [5], -actuator6max); for (int actuator=3; actuator&lt;6; ++actuator) if (joint_torques [actuator] != actuator_torques [leg][actuator-3]) clog &lt;< "ACTUATOR " &lt;< (actuator+1) &lt;< " MAXED, leg " &lt;< leg &lt;< endl; //if (leg==0) cout &lt;< joint_torques &lt;< endl; Jinvtrans.transpose (Jinv [leg]); //------------------------------------------------------- // Calculate actual body wrench from the leg using Jacobians. // The
Reference: [6] <author> S. Hirose, F. Y, and K. H, </author> <title> "The gait control system of a quadruped walking robot," </title> <journal> Robotics, </journal> <volume> vol. 1, no. 4, </volume> <pages> pp. 289-323, </pages> <year> 1986. </year>
Reference-contexts: Legged locomotion is an area of robotics where it is reasonably clear what is a workable approach and what is not. Furthermore, legged locomotion poses interesting challenges for the engineer in applied dynamics and control. Currently, robots with one [2, chapters 2-3], two [5], four <ref> [6] </ref>, six [7] and eight [8] legs are studied.[9] They divide naturally into two groups | one and two legged robots that dynamically balance, and robots with four or more legs that are basically statically stable, though they may use gaits that are dynamically stable.
Reference: [7] <author> S. Song and K. Waldron, </author> <title> Machines that Walk: the Adaptive Suspension Vehicle. </title> <address> Cambridge, MA: </address> <publisher> The MIT Press, </publisher> <year> 1988. </year> <title> [8] anonymous, "Komatsu seabed robot," </title> <type> tech. rep., Komatsu, </type> <institution> Ltd., </institution> <address> Tokyo, Japan, </address> <year> 1982. </year>
Reference-contexts: Legged locomotion is an area of robotics where it is reasonably clear what is a workable approach and what is not. Furthermore, legged locomotion poses interesting challenges for the engineer in applied dynamics and control. Currently, robots with one [2, chapters 2-3], two [5], four [6], six <ref> [7] </ref> and eight [8] legs are studied.[9] They divide naturally into two groups | one and two legged robots that dynamically balance, and robots with four or more legs that are basically statically stable, though they may use gaits that are dynamically stable. <p> It had six legs, and was driven by a motorcycle engine via hydraulics [16]. The legs utilized pantographs to separate vertical and horizontal motion for greater energy efficiency. It was fully operational, demonstrating body attitude control, several gaits, and incorporating a laser range mapper <ref> [7] </ref>. Dante and Dante II were two robots built by a group at Carnegie-Mellon for NASA to explore active volcanos. Both were frame walkers, like the earlier Ko-matsu underwater octopod [8], having four legs attached to each of two frames. <p> The state of the art now permits dynamic analysis of legged robots, including inertial forces <ref> [7, chapter5] </ref>, even for robots with many legs. <p> These also require the use of a dynamic control system. Dynamic control has been perceived as being too difficult to implement in the past. However, legged robot research has now progressed to the point where dynamic control can be implemented even for robots which use many legs at once <ref> [7, chapter 5] </ref>. 2.4 Gait 2.4.1 Many-legged Robot Gaits A fair amount of research has been done on gaits for quadrupeds and hexapods. McGhee defines a periodic gait as one where each leg is raised and lowered once per cycle [9]. <p> They do not use the non-zero foot area as effectively as powered joints. Their usefulness is closely tied to leg motion patterns. They are best considered as a refinement of an existing point-foot design. In the Adaptive Suspension Vehicle (ASV) project <ref> [7] </ref>, time and resources were available for a thorough leg design. The ASV used passive ankle control that kept the feet parallel to the body. Since the ASV had six legs, it did not need to generate torques at the ankles. <p> Therefore good triped legs designs are likely to be similar to good quadruped and hexapod leg designs. Therefore, leg design is not considered in depth in this thesis. A good discussion of hexapod leg design is provided in <ref> [7, Chapters 6-7] </ref> An early leg design had seven DOF in the legs. All three legs telescope for one DOF. The outer legs have forward-and-back hip rotation for a second DOF each. The center leg has side-to-side hip rotation and forward-and-back hip rotation, giving the center leg 3 DOF.
Reference: [9] <author> R. </author> <title> McGhee, </title> <journal> Vehicular Legged Locomotion, </journal> <volume> vol. 1, ch. 7, </volume> <pages> pp. 259-284. </pages> <address> 36 Sherwood Place, Greenwich Connecticut 06836: </address> <publisher> Jai Press, Inc., </publisher> <year> 1985. </year> <editor> G. N. Saridis, ed., </editor> <address> ISBN 0-89232-399-X. </address>
Reference-contexts: McGhee defines a periodic gait as one where each leg is raised and lowered once per cycle <ref> [9] </ref>. An n-legged mobile (animal or robot) will have 2n leg raising and lowerings per cycle. McGhee defines a singular gait as one where two of these events occur simultaneously and a non-singular gait as one where no two of these events occur simultaneously.
Reference: [10] <author> E. </author> <title> Lecas, </title> <journal> "Huitieme recreation|la machine a marcher," Recreations Mathe-matiques, </journal> <volume> vol. 4, </volume> <pages> pp. 198-204, 1894. 151 </pages>
Reference-contexts: An overview of some methods for deriving the kinematics and dynamics of legged robots is in Section 2.5. 8 2.2 A Brief History of Legged Robot Research 2.2.1 Many-legged Robots Mechanical walking toys have been built since the Renaissance, and in 1850 Cheby-shev designed a linkage <ref> [10] </ref> to translate rotary motion into the motions necessary for a leg. Many other attempts to develop a suitable mechanism were made over the next century, culminating in the Iron Mule Train [3, pages 15,17], developed for the U.S. Army.
Reference: [11] <author> R. B. McGhee, C. A. Klein, and C. S. Chao, </author> <title> "Interactive computer control of a an adaptive walking machine," </title> <booktitle> in Proceedings of 1979 Midcon Conference, </booktitle> <address> Nov. 1979. Chicago. </address>
Reference: [12] <author> V. S. Gurfinkel, E. V. Gurfinkel, A. Y. Shneider, E. A. Devjanin, A. V. Lensky, and L. G. Shitilman, </author> <title> "Walking robot with supervisory control," </title> <journal> Mechanism and Machine Theory, </journal> <volume> vol. 16, </volume> <pages> pp. 31-36, </pages> <year> 1981. </year>
Reference-contexts: Since the effective motor inertia is n 2 I m , this resulted in the most of the motor's energy going to accelerating the motors. At about the same time, Gurfinkel and others in the USSR developed several similar machines <ref> [12] </ref>. The design of all of these walkers used static analysis to ensure stability, such as projecting the center of weight onto the support polygon the convex polygon formed from the centers of pressure of the feet. This requires the use of statically stable gaits.
Reference: [13] <author> M. Russel, </author> <title> "ODEX I: </title> <booktitle> the first functionoid," Robotics Age, </booktitle> <volume> vol. 5, </volume> <pages> pp. 12-18, </pages> <month> September/October </month> <year> 1983. </year>
Reference-contexts: This requires the use of statically stable gaits. Since then, a number of machines have been built, including the Odex I <ref> [13] </ref>, a radially symmetric hexapod with large foot workspaces, which was offered for commercial sale. MECHANT, in Finland [14], was tested for forestry use. The Carnegie-Mellon Ambler was a prototype Mars rover.
Reference: [14] <author> K. Hartikainen, A. Halme, H. Lehtine, and K. Kaskinen, "Mechant I: </author> <title> A six-legged walking machine for research purposes in outdoor environment," </title> <booktitle> in Proc. 1992 IEEE Int. Conf. on Robotics and Automation, </booktitle> <address> p. 163, </address> <year> 1992. </year>
Reference-contexts: This requires the use of statically stable gaits. Since then, a number of machines have been built, including the Odex I [13], a radially symmetric hexapod with large foot workspaces, which was offered for commercial sale. MECHANT, in Finland <ref> [14] </ref>, was tested for forestry use. The Carnegie-Mellon Ambler was a prototype Mars rover.
Reference: [15] <author> D. Pugh, E. Ribble, V. Vohnout, T. Bihari, and K. Waldron, </author> <title> "Technical description of the Adaptive Suspension Vehicle," </title> <journal> International Journal of Robotics Research, </journal> <volume> vol. 9, no. 2, </volume> <pages> pp. 24-42, </pages> <year> 1990. </year>
Reference-contexts: The Carnegie-Mellon Ambler was a prototype Mars rover. It used a novel leg arrangement with six legs in two stacks, each leg having a cylindrical working volume. 10 In the mid-80's the OSU Adaptive Suspension Vehicle (ASV) was built as an experimental prototype of a practical legged vehicle <ref> [15] </ref>. It had six legs, and was driven by a motorcycle engine via hydraulics [16]. The legs utilized pantographs to separate vertical and horizontal motion for greater energy efficiency. It was fully operational, demonstrating body attitude control, several gaits, and incorporating a laser range mapper [7].
Reference: [16] <author> S. Nair, R. Singh, K. J. Waldron, and V. J. Vohnout, </author> <title> "Power system of a multi-legged walking vehicle," </title> <booktitle> in Advanced Robotics 1989: Proceedings of the 4th Internation Conference on Advanced Robotics (K. </booktitle> <editor> J. Waldron, </editor> <publisher> ed.), </publisher> <pages> pp. 311-333, </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: It had six legs, and was driven by a motorcycle engine via hydraulics <ref> [16] </ref>. The legs utilized pantographs to separate vertical and horizontal motion for greater energy efficiency. It was fully operational, demonstrating body attitude control, several gaits, and incorporating a laser range mapper [7].
Reference: [17] <author> E. Muybridge, </author> <title> Animal Locomotion; an electro-photographic investigation of consectutive phases of animal movements. </title> <institution> University of Pennsylvania, </institution> <note> Dover edition titled "Muybridge's Complete Human and Animal Locomotion" ed., 1887. </note>
Reference-contexts: This started with the work of Muybridge <ref> [17] </ref>, who studied human and animal kinematics and gaits by photography. Kato, Ogo, Takanishi, and others built several bipeds that used a quasi-dynamic 11 gait, i.e. one which alternates periods of static stability with dynamic phases that are not statically stable.[5] [18].
Reference: [18] <author> K. Ogo, A. Ganse, and I. Kato, </author> <title> "Dynamic walking of biped walking machine aiming at completion of steady walking," </title> <booktitle> in Third Symposium on Theory and Practice of Robots and Manipulators (A. </booktitle> <editor> Morecki, G. Bianchi, and K. Kedzior, eds.), </editor> <publisher> (Amsterdam), Elsevier Scientific Publishing Co., </publisher> <year> 1980. </year>
Reference-contexts: This started with the work of Muybridge [17], who studied human and animal kinematics and gaits by photography. Kato, Ogo, Takanishi, and others built several bipeds that used a quasi-dynamic 11 gait, i.e. one which alternates periods of static stability with dynamic phases that are not statically stable.[5] <ref> [18] </ref>. The stilt biped of Miura and Shimoyama [19] was apparently the first to use dynamic stability at all times. Sutherland [20] introduced the notion of a virtual leg, two or more legs that move together, and can thus be analyzed as if they are a single leg.
Reference: [19] <author> H. Miura and I. Shimoyama, </author> <title> "Dynamic walk of a biped," </title> <journal> Robotics Research, </journal> <volume> vol. 3, </volume> <pages> pp. 60-74, </pages> <year> 1984. </year>
Reference-contexts: Kato, Ogo, Takanishi, and others built several bipeds that used a quasi-dynamic 11 gait, i.e. one which alternates periods of static stability with dynamic phases that are not statically stable.[5] [18]. The stilt biped of Miura and Shimoyama <ref> [19] </ref> was apparently the first to use dynamic stability at all times. Sutherland [20] introduced the notion of a virtual leg, two or more legs that move together, and can thus be analyzed as if they are a single leg.
Reference: [20] <author> I. E. Sutherland, </author> <title> A Walking Robot. </title> <address> Pittsburgh: The Marcian Chronicles, </address> <publisher> Inc., </publisher> <year> 1983. </year>
Reference-contexts: The stilt biped of Miura and Shimoyama [19] was apparently the first to use dynamic stability at all times. Sutherland <ref> [20] </ref> introduced the notion of a virtual leg, two or more legs that move together, and can thus be analyzed as if they are a single leg. Raibert, Hodgins, and others at MIT made seminal studies [2] of dynamically balancing one legged robots, in two and three dimensions. <p> The algorithm is difficult to implement with more than two legs, due to the difficulty in placing more than one or two legs close to the center of mass. 2.4.3 Virtual Legs and Virtual Biped Gaits Sutherland <ref> [20] </ref> introduced the concept of a virtual leg, a set of legs that are lifted and lowered together, and thus act like a single leg.
Reference: [21] <author> M. D. Berkemeir and R. S. Fearing, </author> <title> "Control of a two-link robot to achieve sliding and hopping gaits," </title> <booktitle> in Proc. IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pp. 286-291, </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: General principles such as symmetry of motion and decomposition of control should carry over to yaw-controlling, non-hopping (non-bounding) robots, but the algorithms do not appear to have direct application. Others have extended work on one-legged hoppers, such as Berkemeir and Fearing <ref> [21] </ref> and Helferty [22]. Tad McGeer at Simon Frazier University investigated passive bipeds that could walk down a slight slope under gravity power [23][24][25][26] This work has not received much notice, presumably because control issues have dominated energy efficiency concerns for most researchers.
Reference: [22] <author> J. J. Helferty, J. B. Collins, and M. Kam, </author> <title> "Neural network learning strategy for the control of a one-legged hopping machine," </title> <booktitle> in IEEE International Conference on Robotics and Automation - 1989, </booktitle> <volume> vol. 3, </volume> <pages> pp. 1604-1609, </pages> <year> 1989. </year> <month> 152 </month>
Reference-contexts: General principles such as symmetry of motion and decomposition of control should carry over to yaw-controlling, non-hopping (non-bounding) robots, but the algorithms do not appear to have direct application. Others have extended work on one-legged hoppers, such as Berkemeir and Fearing [21] and Helferty <ref> [22] </ref>. Tad McGeer at Simon Frazier University investigated passive bipeds that could walk down a slight slope under gravity power [23][24][25][26] This work has not received much notice, presumably because control issues have dominated energy efficiency concerns for most researchers. <p> The inverted pendulum model has been very popular. Much progress has been made in efficient algorithms [27] and available computing power has increased enormously. However, in the 1980's several groups turned to artificial neural nets <ref> [28, 22, 29] </ref>, genetic algorithms [30], fuzzy control, the "subsumption architecture"[31], "reflex control"[32] and other soft computation techniques which circumvent the need for exact kinematic and dynamic equations.
Reference: [23] <author> T. McGeer, </author> <title> "Passive dynamic walking," Rob. </title> <journal> Res., </journal> <volume> vol. 9, no. 2, </volume> <year> 1989. </year>
Reference: [24] <author> T. McGeer, </author> <title> "Stability and control of two-dimensional biped walking," </title> <type> Tech. Rep. CSS-IS TR 88-01, </type> <institution> Centre for Systems Science, SFU, Burnaby, B.C., </institution> <year> 1989. </year>
Reference: [25] <author> T. McGeer, </author> <title> "Passive bipedal running," </title> <year> 1989. </year>
Reference: [26] <author> T. McGeer, </author> <title> "Passive walking with knees," </title> <booktitle> in Proc. of 1990 IEEE Conf. on Robotics and Automation, </booktitle> <pages> pp. 1640-1645, </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference: [27] <author> D. E. Orin and W. W. Schrader, </author> <title> "Efficient computation of the Jacobian for robot manipulators," </title> <journal> International Journal of Robotics Research, </journal> <volume> vol. 3, </volume> <pages> pp. 66-75, </pages> <month> Winter </month> <year> 1984. </year>
Reference-contexts: For any realistic system, the equations involved are formidable, and many approximations and simplifications have been used. The inverted pendulum model has been very popular. Much progress has been made in efficient algorithms <ref> [27] </ref> and available computing power has increased enormously. However, in the 1980's several groups turned to artificial neural nets [28, 22, 29], genetic algorithms [30], fuzzy control, the "subsumption architecture"[31], "reflex control"[32] and other soft computation techniques which circumvent the need for exact kinematic and dynamic equations. <p> Common approaches include Newton-Euler, Lagrangian, Hamiltonian, and Kane's method [41, 42]. The approach chosen in this thesis is a Newton-Euler approach, as developed by Orin and Schrader <ref> [27] </ref>. A similar approach is presented in Craig.[43] The method iterates over a serial kinematic chain, to produce the Jacobian matrix, a multidimensional generalization of the derivative, which can be used for both kinematics and dynamics. <p> sin ( 3 ) d4 cos ( 6 ) sin ( 2 ) cos ( 3 ) cos ( 5 ) p BG is the position of the body in the ground reference frame. 109 APPENDIX B Derivation of the Jacobian Matrix The derivation was done using the Orin-Schrader method <ref> [27] </ref>. The derivation was done using Maple V.
Reference: [28] <author> A. W. Salatian, </author> <title> "Gait synthesis for a biped robot climbing sloping surfaces using neural networks," </title> <type> Master's thesis, </type> <institution> Ohio State University, Columbus Ohio, </institution> <year> 1991. </year>
Reference-contexts: The inverted pendulum model has been very popular. Much progress has been made in efficient algorithms [27] and available computing power has increased enormously. However, in the 1980's several groups turned to artificial neural nets <ref> [28, 22, 29] </ref>, genetic algorithms [30], fuzzy control, the "subsumption architecture"[31], "reflex control"[32] and other soft computation techniques which circumvent the need for exact kinematic and dynamic equations.
Reference: [29] <author> T. Hesselroth, K. Sarkar, P. van der Smagt, and K. Schulten, </author> <title> "Neural network control of a pneumatic robot arm," </title> <journal> IEEE Systems, Man, and Cybernetics (pending), </journal> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: The inverted pendulum model has been very popular. Much progress has been made in efficient algorithms [27] and available computing power has increased enormously. However, in the 1980's several groups turned to artificial neural nets <ref> [28, 22, 29] </ref>, genetic algorithms [30], fuzzy control, the "subsumption architecture"[31], "reflex control"[32] and other soft computation techniques which circumvent the need for exact kinematic and dynamic equations.
Reference: [30] <author> M. A. Lewis, A. H. Fagg, and A. Solidum, </author> <title> "Genetic programming approacd to the construction of a neural network for control of a walking robot," </title> <booktitle> in Proc. IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pp. 2618-2623, </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: The inverted pendulum model has been very popular. Much progress has been made in efficient algorithms [27] and available computing power has increased enormously. However, in the 1980's several groups turned to artificial neural nets [28, 22, 29], genetic algorithms <ref> [30] </ref>, fuzzy control, the "subsumption architecture"[31], "reflex control"[32] and other soft computation techniques which circumvent the need for exact kinematic and dynamic equations. The state of the art now permits dynamic analysis of legged robots, including inertial forces [7, chapter5], even for robots with many legs.
Reference: [31] <author> R. A. Brooks, </author> <title> "A robot that walks; emergent behaviors from a carefully evolved network," </title> <type> tech. rep., </type> <institution> M.I.T., </institution> <year> 1991. </year>
Reference: [32] <author> T. S. Wikman and W. S. Newman, </author> <title> "A fast, on-line collision avoidance method for a kinematically redundant manipulator based on reflex control," </title> <booktitle> in Proc. 1992 IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pp. 261-265, </pages> <month> May </month> <year> 1992. </year>
Reference: [33] <editor> Acton, Gilmer, Kroczinski, et al., </editor> <title> "Optimal utilization of vertical access robots in the shipbuliding industry," </title> <booktitle> in Proceedings of Robots 9, </booktitle> <volume> vol. 1, </volume> <pages> (Detroit), pp. </pages> <address> 5.30-5.42, </address> <year> 1985. </year>
Reference-contexts: A three-legged robot to weld and paint ship hulls <ref> [33] </ref> was built. It clung to steel ship hulls by electromagnets. The three legs were used as a tripod, alternating with the belly. International Robotic Technologies, a now-defunct company, built a three-legged skyscraper window-washing robot [34], but few details are known.
Reference: [34] <author> R. D. Klafter, </author> <title> Mobile Robots, </title> <booktitle> Research and Development, </booktitle> <address> p. 941. New York: </address> <publisher> Wiley, </publisher> <year> 1988. </year>
Reference-contexts: A three-legged robot to weld and paint ship hulls [33] was built. It clung to steel ship hulls by electromagnets. The three legs were used as a tripod, alternating with the belly. International Robotic Technologies, a now-defunct company, built a three-legged skyscraper window-washing robot <ref> [34] </ref>, but few details are known. Jim Brazell and others in the Georgia Tech Mechanical Engineering department 13 designed and built the SKITTER [35, 36], which was designed to be as simple as possible for high reliability transport on the Moon.
Reference: [35] <editor> J. Brazell, "A three-legged walker," </editor> <booktitle> in Lunar Bases and Space Activities of the 21st Century Symposium, </booktitle> <month> Apr. </month> <year> 1988. </year> <institution> Houston, TX. </institution> <note> [36] anonymous, ""Skitter" developed at Georgia Tech," Experimental Techniques, vol. 12, </note> <month> May </month> <year> 1988. </year> <month> 153 </month>
Reference-contexts: The three legs were used as a tripod, alternating with the belly. International Robotic Technologies, a now-defunct company, built a three-legged skyscraper window-washing robot [34], but few details are known. Jim Brazell and others in the Georgia Tech Mechanical Engineering department 13 designed and built the SKITTER <ref> [35, 36] </ref>, which was designed to be as simple as possible for high reliability transport on the Moon. The three legs were arranged radially, each having a one-DOF four position hip and one-DOF four position knee, thus giving each leg sixteen possible positions. Feet were point-contact.
Reference: [37] <author> A. Wells, </author> <title> "A study of three-legged robotics gaits." </title> <type> private communication, </type> <month> June </month> <year> 1988. </year>
Reference-contexts: This results in a lurching gait, which was deemed acceptable for the intended application. The gait is quasi-dynamic, like the biped of Kato, Ogo, Takanishi and others. Wells <ref> [37] </ref> examined possible gaits for a three-legged robot. He noted the existence of "whirling" gaits for tripeds with radially attached legs, which are similar to the "tumbling" gaits which Pai, Barman and Ralph noted for their spherically symmetrical "platonic beasts"[38].
Reference: [38] <author> D. K. Pai, R. A. Barman, and S. K. Ralph, "Platonic Beasts: </author> <title> a new family of multilimbed robots," </title> <booktitle> in Proc. 1994 IEEE Conf. on Robotics and Automation, </booktitle> <year> 1994. </year>
Reference: [39] <author> R. McGhee, </author> <title> "Some finite state aspects of legged locomotion," </title> <journal> Mathematical Biosciences, </journal> <volume> vol. 2, no. 1, </volume> <pages> pp. 67-84, </pages> <year> 1968. </year>
Reference-contexts: Let us assume each pattern of raising and lowering is considered a different gait. It follows that there are <ref> [39] </ref> N (n) = 2n non-singular gaits and that the total number of gaits [40] respectively for two, three, or four legs, are M (2) = 16 (2.2) M (4) = 63; 136 (2.4) 2.4.2 Biped Gaits Bipeds have two chief gaits: walking, where a foot does not leave the ground
Reference: [40] <author> S. H. Koozekanani and R. B. McGhee, </author> <title> "Occupancy problems with pairwise exclusion constraints an aspect of gait enumeration," </title> <journal> Journal of Cybernetics, </journal> <volume> vol. 2, no. 4, </volume> <pages> pp. 14-26, </pages> <year> 1972. </year>
Reference-contexts: Let us assume each pattern of raising and lowering is considered a different gait. It follows that there are [39] N (n) = 2n non-singular gaits and that the total number of gaits <ref> [40] </ref> respectively for two, three, or four legs, are M (2) = 16 (2.2) M (4) = 63; 136 (2.4) 2.4.2 Biped Gaits Bipeds have two chief gaits: walking, where a foot does not leave the ground before the other foot is placed, and running, where it does.
Reference: [41] <author> T. R. Kane and D. A. Levinson, </author> <title> Dynamics: theory and applications. McGraw-Hill series in mechanical engineering, </title> <publisher> McGraw-Hill, </publisher> <year> 1985. </year>
Reference-contexts: Common approaches include Newton-Euler, Lagrangian, Hamiltonian, and Kane's method <ref> [41, 42] </ref>. The approach chosen in this thesis is a Newton-Euler approach, as developed by Orin and Schrader [27].
Reference: [42] <author> T. R. Kane, </author> <title> "The use of Kane's dynamical equations in robotics," </title> <journal> International Journal of Robotics Research, </journal> <volume> vol. 2, no. 3, </volume> <pages> pp. 3-21, </pages> <year> 1983. </year>
Reference-contexts: Common approaches include Newton-Euler, Lagrangian, Hamiltonian, and Kane's method <ref> [41, 42] </ref>. The approach chosen in this thesis is a Newton-Euler approach, as developed by Orin and Schrader [27].
Reference: [43] <author> J. J. Craig, </author> <title> Introduction to Robotics: Mechanics and Control. </title> <booktitle> Addison-Wesley Series in Electrical and Computer Engineering: Control Engineering, </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <editor> second ed., </editor> <year> 1986. </year>
Reference-contexts: There are a number of closely related systems called Denavit-Hartenburg. This paper uses the slightly modified Denavit-Hartenburg parameters defined by Craig <ref> [43, pages 70-73] </ref>. Links are numbered from 0 to n, with link i connecting axis i with axis i + 1. Two non-intersecting, non-parallel lines in space have a unique perpendicular. The distance between the axes along this line is defined to be the link length a i . <p> R B 0 3 7 5 0 J () = 0 X B Singularities of the Jacobian At values of where the Jacobian becomes singular, the leg has lost one or more degrees of freedom in Cartesian space, i.e. there are one or more directions the body cannot be moved <ref> [43, page 173] </ref>. <p> In frame G, the x and y axes are horizontal, while z is vertical. When 1 = 0, the forward direction of the robot is the x G axis. For more on frames of reference and rotation matrices, see Craig <ref> [43, Chapter 2] </ref>. See section 4.3 of this thesis for converting rotation matrices to Euler angles and vice-versa. 46 next. <p> A matrix whose determinant is equal to zero is said to be singular. At values of fi where the Jacobian becomes singular, the leg has lost one or more degrees of freedom in Cartesian space, i.e. there are one or more directions the body cannot be moved <ref> [43, page 173] </ref>. It is important to know where the Jacobian becomes singular, as numerical operations near singularities are unreliable, and Cartesian control becomes unstable. Singularities of the Jacobian were found by setting the determinant of the Jacobian to zero and solving for the angles. <p> The details are given at the end of appendix B. If any of five conditions are true, the Jacobian is singular: 2 = 0, 2 = , 5 = 0, 5 = , and d 4 = 0. The 2 singularities are equivalent to the well-known roll-pitch-yaw wrist singularities <ref> [43, page175] </ref>, and happen when joint axis 1 and joint axis 3 are co-linear. The 5 singularities are similar, but involve 6 and 3 . The d 4 degeneracy is obvious, when the leg is of zero length. These are all workspace interior singularities [44]. <p> 7 7 7 7 7 7 7 5 When a leg is at rest or the mass of the leg itself can be neglected, the relation between the wrench that the leg exerts on the body, j F , to joint torques j t is given by the Jacobian transpose <ref> [43, page 179] </ref>: j t = G T where G j J is the Jacobian transpose of leg j in frame G. <p> Leg actuators are moved as necessary to achieve this. Navigation and task specification will give a trajectory in Cartesian space, which the robot must follow as closely as possible. A Cartesian control scheme outlined by Craig <ref> [43, pages 357-358] </ref> was the base of the control scheme implemented. It is diagrammed in figure 4.3. It is called a Cartesian control scheme because the differences are done in Cartesian space, not joint space. The inputs to this controller are the desired body position, velocity and accel eration.
Reference: [44] <author> K. J. Waldron, </author> <title> "Course notes for Ohio State University Mechanical Engineering course ME752: Mechanical Design of Robots and Manipulators." </title>
Reference-contexts: Ball screws can be back driven, but lead screws cannot. Hydraulic and pneumatic cylinders give linear motion, but can be connected to give rotary motion. The range of rotary motion is limited to somewhat less than 180 degrees. The effective maximum torque varies with the position of the actuator <ref> [44] </ref>. 35 Design Chosen The leg design problem for tripeds is essentially the same as the leg design problem for quadrupeds and hexapods. Therefore good triped legs designs are likely to be similar to good quadruped and hexapod leg designs. <p> The 5 singularities are similar, but involve 6 and 3 . The d 4 degeneracy is obvious, when the leg is of zero length. These are all workspace interior singularities <ref> [44] </ref>.
Reference: [45] <author> M. H. Raibert, </author> <title> "Running with symmetry," </title> <journal> International Journal of Robotics Research, </journal> <volume> vol. 5, </volume> <month> Winter </month> <year> 1986. </year>
Reference-contexts: The angle the leg makes with the vertical is given by q. The maximum absolute value of q, q max occurs at A and at B, assuming the step is symmetrical. Symmetry is sufficient but not necessary to produce no net acceleration on the body <ref> [45, section 6] </ref>[2, page 135]. The period T is the time necessary for the body to move from A to B.
Reference: [46] <author> S. Hirose, T. Masui, H. Kikuchi, Y. Fukuda, and Y. Umetani, </author> <title> "TITAN III: a quadruped walking vehicle," </title> <booktitle> in 2nd Int. Symp. of Robotics Research, </booktitle> <pages> pp. 247-253, </pages> <month> Aug. </month> <year> 1984. </year>
Reference-contexts: If the body position or velocity can be measured with sufficient accuracy, it would eliminate some of the computation and the associated propagation of errors in joint position and speed sensing. Another sensing requirement is implicit: an elevation map of the ground, for leg placement. Some robots <ref> [46] </ref> feel their way forward, using their legs as probes; this is unlikely to be usable for robots without static balance. The more sophisticated control discussed in the previous section requires knowledge of when the feet are on the ground.
Reference: [47] <author> D. W. Marhefka and D. E. Orin, </author> <title> XAnimate v1.0 User's Guide. </title> <institution> Department of Electrical Engineering, The Ohio State University, Columbus, OH 43210, </institution> <month> Aug. </month> <year> 1995. </year> <month> FTP://eeftp.eng.ohio-state.edu/pub/orin/. </month>
Reference-contexts: The control scheme described in section 4.8 was implemented in one code module. Another module performed a dynamic simulation of the plant, the leg-body system. The XAnimate <ref> [47] </ref> graphics package by Duane Marhefka and David Orin was used to generate a perspective view of the simulated robot. A sample screen is shown in figure 5.1.
Reference: [48] <author> Ji Young-Jun, </author> <booktitle> "C" Ro Goo Hyn Han Soo Chi Hae Suk (Numerical Analysis in C), </booktitle> <pages> pp. 101-105. </pages> <address> Seoul, Korea, telephone 011-822-463-2023: Nopikipi, </address> <year> 1994. </year> <note> ISBN 89-7588-004-4, in Korean. 154 </note>
Reference-contexts: Joint angle vectors are then used to calculate the Jacobians for the next iteration of simulation. Numerical inversion is used to get the inverses of the Jacobians, using matrix inversion code from <ref> [48] </ref>.
References-found: 46

