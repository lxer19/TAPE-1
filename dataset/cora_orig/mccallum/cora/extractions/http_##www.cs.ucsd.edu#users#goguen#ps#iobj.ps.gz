URL: http://www.cs.ucsd.edu/users/goguen/ps/iobj.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/goguen/new.html
Root-URL: http://www.cs.ucsd.edu
Title: Introducing OBJ  
Author: Joseph A. Goguen Timothy Winkler Jose Meseguer Kokichi Futatsugi and Jean-Pierre Jouannaud 
Date: 24 October 1993  
Abstract: This is an introduction to OBJ, describing its philosophy, its syntax, its history, and aspects of its semantics, both logical and operational. Many examples are given, using Release 2 of OBJ3, which provides many features not available in previous versions of OBJ. OBJ is a wide spectrum first-order functional language that is rigorously based upon equational logic. This semantic basis supports a declarative, specificational style, facilitates program verification, and allows OBJ to be used as a theorem prover. OBJ3 is based upon order sorted equational logic, which provides a notion of subsort that rigorously supports multiple inheritance, exception handling and overloading. OBJ3 also provides parameterised programming, which gives powerful support for design, verification, reuse, and maintenance. This approach uses two kinds of module: objects to encapsulate executable code, and in particular to define abstract data types by initial algebra semantics; and theories to specify both syntactic structure and semantic properties for modules and module interfaces. Each kind of module can be parameterised, where actual parameters are modules. For parameter instantiation, a view binds the formal entities in an interface theory to actual entities in a module, and also asserts that the target module satisfies the semantic requirements of the interface theory. Module expressions allow complex combinations of already defined modules, including sums, instantiations, and transformations; moreover, evaluating a module expression actually constructs the described software (sub)system from the given components. Default views can greatly reduce the effort of instantiating modules. We argue that first-order parameterised programming includes much of the power of higher-order programming. Although OBJ executable code normally consists of equations that are interpreted as rewrite rules, OBJ3 objects can also encapsulate Lisp code, e.g., to provide efficient built-in data types, or to augment the system with new capabilities; we describe the syntax of this facility, and provide some examples. In addition, OBJ provides rewriting modulo associative, commutative and/or identity equations, as well as user-definable evaluation strategies that allow lazy, eager, and mixed evaluation strategies on an operator-by-operator basis; memoisation is also available on an operator-by-operator basis. Also, OBJ3 supports the application of equations one at a time, either forwards or backwards; this is very useful for theorem proving applications. Finally, OBJ provides user-definable mixfix syntax, which supports the notational conventions of particular application domains.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Hitoshi Aida, Joseph Goguen, Sany Leinwand, Patrick Lincoln, Jose Meseguer, Babak Taheri, and Timothy Winkler. </author> <title> Simulation and performance estimation for the Rewrite Rule Machine. </title> <booktitle> In Proceedings, Fourth Symposium on the Frontiers of Massively Parallel Computation, </booktitle> <pages> pages 336-344. </pages> <publisher> IEEE, </publisher> <month> October </month> <year> 1992. </year>
Reference-contexts: In addition, OBJ is one of the languages for programming a massively parallel machine that executes rewrite rules directly <ref> [51, 128, 86, 59, 87, 2, 46, 1] </ref>; in fact, we believe that OBJ on such a machine could greatly out-perform a conventional language on a conventional machine, because of the direct concurrent execution of rewrite rules. <p> var A B C : Elt . [lnv] eq A -1 * A = e . endth open . op a : -&gt; Elt . *** first, prove the right inverse law: start a * a -1 . ***&gt; [0] (a * a -1) apply -.lid at term . ***&gt; <ref> [1] </ref> e * (a * a -1) apply -.lnv with A = (a -1) within term . ***&gt; [2] ((a -1) -1 * a -1) * (a * a -1) apply .las at term . ***&gt; [3] ((a -1 -1 * a -1)* a)* a -1 apply -.las with A = <p> term . ***&gt; [8] e *** we can now add the proven equation [rnv] eq (A * (A -1)) = e . *** next, we prove the right identity law: start a * e . ***&gt; [0] a * e apply -.lnv with A = a within term . ***&gt; <ref> [1] </ref> a *(a -1 * a) apply .las at term . ***&gt; [2] (a * a -1)* a apply .rnv within term . ***&gt; [3] e * a apply .lid at term . ***&gt; [4] a ***&gt; we can add the proven equation [rid] eq A * e = A .
Reference: [2] <author> Hitoshi Aida, Joseph Goguen, and Jose Meseguer. </author> <title> Compiling concurrent rewriting onto the rewrite rule machine. </title> <editor> In Stephane Kaplan and Misuhiro Okada, editors, </editor> <booktitle> Conditional and Typed Rewriting Systems, </booktitle> <pages> pages 320-332. </pages> <publisher> Springer, </publisher> <year> 1991. </year> <note> Lecture Notes in Computer Science, Volume 516; also, Technical Report SRI-CSL-90-03, </note> <institution> Computer Science Lab, SRI International, </institution> <month> February, </month> <year> 1990. </year>
Reference-contexts: In addition, OBJ is one of the languages for programming a massively parallel machine that executes rewrite rules directly <ref> [51, 128, 86, 59, 87, 2, 46, 1] </ref>; in fact, we believe that OBJ on such a machine could greatly out-perform a conventional language on a conventional machine, because of the direct concurrent execution of rewrite rules. <p> apply -G.1 at term . apply -G.2 with X = a at term . apply print at term . apply reduction at (2 1) . apply G.1 at () . apply X.3 at f2g . apply X.3 at f3,1,2g . apply G.2 at [2 .. 4] . apply G.1 at <ref> [2] </ref> . apply X.1 at f2,4g of [4] of (2 2) . apply X.1 at f2,4g of [4 .. 4] of (2 2) of top . <p> . op a : -&gt; Elt . *** first, prove the right inverse law: start a * a -1 . ***&gt; [0] (a * a -1) apply -.lid at term . ***&gt; [1] e * (a * a -1) apply -.lnv with A = (a -1) within term . ***&gt; <ref> [2] </ref> ((a -1) -1 * a -1) * (a * a -1) apply .las at term . ***&gt; [3] ((a -1 -1 * a -1)* a)* a -1 apply -.las with A = (a -1 -1) within term . ***&gt; [4] ((a -1 -1 * (a -1 * a)) * a <p> equation [rnv] eq (A * (A -1)) = e . *** next, we prove the right identity law: start a * e . ***&gt; [0] a * e apply -.lnv with A = a within term . ***&gt; [1] a *(a -1 * a) apply .las at term . ***&gt; <ref> [2] </ref> (a * a -1)* a apply .rnv within term . ***&gt; [3] e * a apply .lid at term . ***&gt; [4] a ***&gt; we can add the proven equation [rid] eq A * e = A . close This example can be simplified by assuming associativity of the group
Reference: [3] <author> Antonio Alencar and Joseph Goguen. </author> <title> OOZE: An object-oriented Z environment. </title> <editor> In Pierre America, editor, </editor> <booktitle> European Conference on Object Oriented Programming. Springer, 1991. Lecture Notes in Computer Science, </booktitle> <volume> Volume 512. </volume>
Reference-contexts: For example, OBJ3 has been used for building the 2OBJ3 metalogical framework theorem prover [63], the FOOPS object oriented specification and programming language [58, 68], and OOZE, which is an object oriented specification language influenced by some ideas in Z <ref> [3] </ref>. <p> as in Section 4.5 below. 18 In general, modules may have internal states; although this feature is not discussed in this paper, the reader can consult [54, 47] and [58] for further information about approaches to this important topic, which is being implemented in the FOOPS [58, 68] and OOZE <ref> [3] </ref> systems. In Maude [97, 93], the state, very simply, is given by a term. 33 4.1 Theories Theories are used to express properties of modules and module interfaces. <p> We hope that you will enjoy this! Also, OBJ3 seems to provide a very workable platform for implementing other system, and in particular, is being used at Oxford to implement the combined functional and object oriented system FOOPS [58], the object oriented specification language OOZE <ref> [3] </ref>, the combined logic and functional language Eqlog [55], and a generic (i.e., metalogical) theorem prover called 2OBJ [63]. FOOPS and OOZE support objects with states, and Eqlog has logical variables (here we mean "objects" in the sense of object oriented programming, rather than in the sense of OBJ). <p> -1 . ***&gt; [0] (a * a -1) apply -.lid at term . ***&gt; [1] e * (a * a -1) apply -.lnv with A = (a -1) within term . ***&gt; [2] ((a -1) -1 * a -1) * (a * a -1) apply .las at term . ***&gt; <ref> [3] </ref> ((a -1 -1 * a -1)* a)* a -1 apply -.las with A = (a -1 -1) within term . ***&gt; [4] ((a -1 -1 * (a -1 * a)) * a -1 apply .lnv within term . ***&gt; [5] (a -1 -1 * e) * a -1 apply -.las <p> we prove the right identity law: start a * e . ***&gt; [0] a * e apply -.lnv with A = a within term . ***&gt; [1] a *(a -1 * a) apply .las at term . ***&gt; [2] (a * a -1)* a apply .rnv within term . ***&gt; <ref> [3] </ref> e * a apply .lid at term . ***&gt; [4] a ***&gt; we can add the proven equation [rid] eq A * e = A . close This example can be simplified by assuming associativity of the group multiplication as an attribute: 70 th GROUPLA is sort Elt . op
Reference: [4] <author> Eugenio Battiston, Fiorella De Cindio, and Giancarlo Mauri. </author> <title> OBJSA net systems: a class of high-level nets having objects as domains. In Joseph Goguen, editor, Applications of Algebraic Specification Using OBJ. </title> <address> Cambridge, </address> <note> to appear 1993. </note>
Reference-contexts: OBJ is also being combined with Petri nets, thus allowing structured data in tokens <ref> [4] </ref>, and is being used to verify compilers for parallel programming languages in the ESPRIT sponsored PROCOS project [115]. <p> It only makes sense to use these once, and often they can be omitted. One of these is required if there is no other selector, but the selector () could be used instead. Selectors can be composed by separating them by of, as in f3,1,2g of <ref> [4] </ref> of (2 3 1) of [2 .. 5] of (1 1) of term Such a composition is interpreted like functional composition: the selection on the right is done first, then the second one on the result of that selection, and so on, until finally the selector on the left is <p> with X = a at term . apply print at term . apply reduction at (2 1) . apply G.1 at () . apply X.3 at f2g . apply X.3 at f3,1,2g . apply G.2 at [2 .. 4] . apply G.1 at [2] . apply X.1 at f2,4g of <ref> [4] </ref> of (2 2) . apply X.1 at f2,4g of [4 .. 4] of (2 2) of top . <p> -.lnv with A = (a -1) within term . ***&gt; [2] ((a -1) -1 * a -1) * (a * a -1) apply .las at term . ***&gt; [3] ((a -1 -1 * a -1)* a)* a -1 apply -.las with A = (a -1 -1) within term . ***&gt; <ref> [4] </ref> ((a -1 -1 * (a -1 * a)) * a -1 apply .lnv within term . ***&gt; [5] (a -1 -1 * e) * a -1 apply -.las at term . ***&gt; [6] a -1 -1 * (e * a -1) apply .lid within term . ***&gt; [7] a -1 <p> . ***&gt; [0] a * e apply -.lnv with A = a within term . ***&gt; [1] a *(a -1 * a) apply .las at term . ***&gt; [2] (a * a -1)* a apply .rnv within term . ***&gt; [3] e * a apply .lid at term . ***&gt; <ref> [4] </ref> a ***&gt; we can add the proven equation [rid] eq A * e = A . close This example can be simplified by assuming associativity of the group multiplication as an attribute: 70 th GROUPLA is sort Elt . op _*_ : Elt Elt -&gt; Elt [assoc] . op e
Reference: [5] <author> Jan Bergstra and John Tucker. </author> <title> Characterization of computable data types by means of a finite equational specification method. </title> <editor> In J.W. de Bakker and Jan van Leeuwen, editors, </editor> <booktitle> Automata, Languages and Programming, Seventh Colloquium, </booktitle> <pages> pages 76-90. </pages> <publisher> Springer, </publisher> <year> 1980. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 81. </volume>
Reference-contexts: Details of the mathematical and operational semantics of retracts, using order sorted algebra and order sorted term rewriting, are given in [50] and [60]. 13 This is an as yet unpublished theorem of Dr. Jose Meseguer; see <ref> [5, 95] </ref> for similar results about total computable functions. 14 Warning: Release 2 of OBJ3 does not allow qualified sort names in retracts within terms provided by the user. Now some code that illustrates retracts. <p> Although we cannot assume that all rule sets are terminating, rules that define total computable operators over total computable sets can always be chosen to be both Church-Rosser and terminating <ref> [5] </ref>; this includes the typical case of abstract data types. However, further functions defined over these structures can fail to have terminating rule sets, for example, if they implement procedures for problems that are only semi-decidable, such as full first-order theorem proving, higher-order unification, or combinator reduction 14 . <p> (a * a -1) apply .las at term . ***&gt; [3] ((a -1 -1 * a -1)* a)* a -1 apply -.las with A = (a -1 -1) within term . ***&gt; [4] ((a -1 -1 * (a -1 * a)) * a -1 apply .lnv within term . ***&gt; <ref> [5] </ref> (a -1 -1 * e) * a -1 apply -.las at term . ***&gt; [6] a -1 -1 * (e * a -1) apply .lid within term . ***&gt; [7] a -1 -1 * a -1 apply .lnv at term . ***&gt; [8] e *** we can now add the
Reference: [6] <author> Rod Burstall. </author> <title> Programming with modules as typed functional programming. </title> <booktitle> Proceedings, International Conference on Fifth Generation Computing Systems, </booktitle> <year> 1985. </year>
Reference-contexts: Instantiation of a parameterised module with an actual parameter, using a particular view, yields a new module. Module expressions describe complex interconnections of modules, potentially involving instantiation, addition, and renaming of modules. A useful insight (see <ref> [6] </ref>) is that programming in the large can be seen as a kind of functional programming, in which evaluating (what we call) a module expression is indeed a kind of expression evaluation; in particular, there are no variables, no assignments, and no effects, side or otherwise, just functions applied to arguments; <p> a -1)* a)* a -1 apply -.las with A = (a -1 -1) within term . ***&gt; [4] ((a -1 -1 * (a -1 * a)) * a -1 apply .lnv within term . ***&gt; [5] (a -1 -1 * e) * a -1 apply -.las at term . ***&gt; <ref> [6] </ref> a -1 -1 * (e * a -1) apply .lid within term . ***&gt; [7] a -1 -1 * a -1 apply .lnv at term . ***&gt; [8] e *** we can now add the proven equation [rnv] eq (A * (A -1)) = e . *** next, we prove
Reference: [7] <author> Rod Burstall and Joseph Goguen. </author> <title> Putting theories together to make specifications. </title> <editor> In Raj Reddy, editor, </editor> <booktitle> Proceedings, Fifth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 1045-1058. </pages> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <year> 1977. </year>
Reference-contexts: This first design also used ideas from Clear <ref> [7, 9] </ref> for parameterised modules. First implementations of OBJ were done from 1977 to 1979 at UCLA by Joseph Tardo and Joseph Goguen. OBJ0 [37] was based on unsorted equational logic, while OBJT used error algebras plus an "image" construct for parameterisation [124, 64]. <p> Earlier versions of OBJ had an image transformation with capabilities of renaming and instantiation; but because it did not use theories to describe interfaces, it now seems somewhat undisciplined, and has been abandoned, even though it can be given a respectable semantics using colimits [61]. Clear <ref> [7, 9] </ref> had a construction to enrich a given module, but this would be redundant in OBJ, because we need only import the given module into a new module, and then add the desired sorts, operators and equations. Let us now continue the lexicographic ordering example from the previous section. <p> . ***&gt; [4] ((a -1 -1 * (a -1 * a)) * a -1 apply .lnv within term . ***&gt; [5] (a -1 -1 * e) * a -1 apply -.las at term . ***&gt; [6] a -1 -1 * (e * a -1) apply .lid within term . ***&gt; <ref> [7] </ref> a -1 -1 * a -1 apply .lnv at term . ***&gt; [8] e *** we can now add the proven equation [rnv] eq (A * (A -1)) = e . *** next, we prove the right identity law: start a * e . ***&gt; [0] a * e apply
Reference: [8] <author> Rod Burstall and Joseph Goguen. </author> <title> The semantics of Clear, a specification language. </title> <editor> In Dines Bjorner, editor, </editor> <booktitle> Proceedings, 1979 Copenhagen Winter School on Abstract Software Specification, </booktitle> <pages> pages 292-332. </pages> <publisher> Springer, </publisher> <year> 1980. </year> <booktitle> Lecture Notes in Computer Science, Volume 86; based on unpublished notes handed out at the Symposium on Algebra and Applications, </booktitle> <institution> Stefan Banach Center, Warsaw, Poland, </institution> <year> 1978. </year>
Reference-contexts: sort, and the meanings of the attributes assoc, comm, idem, id: and 20 idr: (to the extent that these attributes are present), such that every equation in T is true of every model of M (thus, a view from one theory to another is called a "theory interpretation" in logic <ref> [8] </ref>). The mapping of sorts is expressed with the syntax sort S1 to S1' . sort S2 to S2' . ... and the mapping of operators is expressed with the syntax op o1 to o1' . ... Warning: The final blank and period are required. <p> -1 apply .lnv within term . ***&gt; [5] (a -1 -1 * e) * a -1 apply -.las at term . ***&gt; [6] a -1 -1 * (e * a -1) apply .lid within term . ***&gt; [7] a -1 -1 * a -1 apply .lnv at term . ***&gt; <ref> [8] </ref> e *** we can now add the proven equation [rnv] eq (A * (A -1)) = e . *** next, we prove the right identity law: start a * e . ***&gt; [0] a * e apply -.lnv with A = a within term . ***&gt; [1] a *(a -1
Reference: [9] <author> Rod Burstall and Joseph Goguen. </author> <title> An informal introduction to specifications using Clear. </title> <editor> In Robert Boyer and J Moore, editors, </editor> <booktitle> The Correctness Problem in Computer Science, </booktitle> <pages> pages 185-213. </pages> <publisher> Academic, </publisher> <year> 1981. </year> <title> Reprinted in Software Specification Techniques, </title> <editor> Narain Gehani and Andrew McGettrick, editors, </editor> <publisher> Addison-Wesley, </publisher> <year> 1985, </year> <pages> pages 363-390. </pages>
Reference-contexts: This first design also used ideas from Clear <ref> [7, 9] </ref> for parameterised modules. First implementations of OBJ were done from 1977 to 1979 at UCLA by Joseph Tardo and Joseph Goguen. OBJ0 [37] was based on unsorted equational logic, while OBJT used error algebras plus an "image" construct for parameterisation [124, 64]. <p> Earlier versions of OBJ had an image transformation with capabilities of renaming and instantiation; but because it did not use theories to describe interfaces, it now seems somewhat undisciplined, and has been abandoned, even though it can be given a respectable semantics using colimits [61]. Clear <ref> [7, 9] </ref> had a construction to enrich a given module, but this would be redundant in OBJ, because we need only import the given module into a new module, and then add the desired sorts, operators and equations. Let us now continue the lexicographic ordering example from the previous section.
Reference: [10] <author> Rod Burstall and Joseph Goguen. </author> <title> Algebras, theories and freeness: An introduction for computer scientists. </title> <editor> In Martin Wirsing and Gunther Schmidt, editors, </editor> <booktitle> Theoretical Foundations of Programming Methodology, </booktitle> <pages> pages 329-350. </pages> <publisher> Reidel, </publisher> <year> 1982. </year> <booktitle> Proceedings, 1981 Marktoberdorf NATO Summer School, NATO Advanced Study Institute Series, Volume C91. </booktitle>
Reference-contexts: The initial algebra approach [65, 95] takes the unique (up to isomorphism) initial algebra as the "standard," or "most representative" model of a set of equations (there may of course be many other models), i.e., as the representation-independent standard of comparison for correctness. It is shown in <ref> [10] </ref> (see also [95]) that an algebra is initial if and only if it satisfies the following properties: 12 We will see later that the denotation of an OBJ theory is a variety of algebras, that are not in general isomorphic to one another. 13 1. no junk: every element can
Reference: [11] <author> Rod Burstall and Butler Lampson. </author> <title> A kernel language for abstract data types and modules. </title> <editor> In Giles Kahn, David MacQueen, and Gordon Plotkin, editors, </editor> <booktitle> Proceedings, International Symposium on the Semantics of Data Types, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-50. </pages> <publisher> Springer, </publisher> <year> 1984. </year>
Reference-contexts: as a kind of functional programming, in which evaluating (what we call) a module expression is indeed a kind of expression evaluation; in particular, there are no variables, no assignments, and no effects, side or otherwise, just functions applied to arguments; this can provide a formal basis for software reuse <ref> [11] </ref>.
Reference: [12] <author> Rod Burstall, David MacQueen, and Donald Sannella. </author> <title> Hope: an experimental applicative language. </title> <booktitle> In Proceedings, First LISP Conference, </booktitle> <volume> volume 1, </volume> <pages> pages 136-143. </pages> <institution> Stanford University, </institution> <year> 1980. </year>
Reference-contexts: A survey as of 1993 appears in [49], along with some new generalisations. OBJ3 directly supports subsort polymorphism, which is operator overloading that is consistent under subsort restriction (this is further discussed in Section 2.2). By contrast, languages like ML [72], Hope <ref> [12] </ref> and Miranda [125] support parametric polymorphism, following ideas of Strachey [123] as further developed by Milner [99]. OBJ3's parameterised modules also provide a parametric capability, but instantiations are determined by views, rather than by unification; see Section 4.7 for further discussion.
Reference: [13] <author> Carlo Cavenathi, Marco De Zanet, and Giancarlo Mauri. MC-OBJ: </author> <title> a C interpreter for OBJ. </title> <journal> Note di Software, </journal> 36/37:16-26, October 1988. In Italian. 
Reference-contexts: Other implementations of OBJ1 include UMIST-OBJ from the University of Manchester Institute of Science and Technology [15], Abstract Pascal from the University of Manchester [85], and MC-OBJ from the University of Milan <ref> [13] </ref>; the first two are written in Pascal and the third in C. In addition, there is a Franz Lisp OBJ2 from Washington State University [119]. UMIST-OBJ is available as a proprietary software product from Gerrard Software, under the name ObjEx.
Reference: [14] <author> Thomas Cheatham. </author> <title> The introduction of definitional facilities into higher level programming languages. </title> <booktitle> In Proceedings, AFIPS Fall Joint Computer Conference, </booktitle> <pages> pages 623-637. </pages> <publisher> Spartan Books, </publisher> <year> 1966. </year>
Reference-contexts: Thus, users of OBJ can define any syntax they like for operators, including prefix, postfix, infix, and most generally, mixfix; this is similar to ECL <ref> [14] </ref>. Obviously, there are many opportunities for ambiguity in parsing such a syntax.
Reference: [15] <author> Derek Coleman, Robin Gallimore, and Victoria Stavridou. </author> <title> The design of a rewrite rule interpreter from algebraic specifications. </title> <journal> IEE Software Engineering Journal, </journal> <volume> July:95-104, </volume> <year> 1987. </year> <month> 97 </month>
Reference-contexts: programming languages in a way that directly yields an interpreter (see Appendix Section C.2, as well as [62] and some elegant work of Peter Mosses [100, 101]), specifying software systems (e.g., the GKS graphics kernel system [20], an Ada configuration manager [32], the MacIntosh QuickDraw program [106], and OBJ itself <ref> [15] </ref>), and hardware specification, simulation, and verification (see [120] and Section 4.8); some of these applications were done under an experiment sponsored by the British Alvey Project. <p> OBJ2 and OBJ3 can be seen as implementations of Clear, where the logic is chosen to be order sorted equational logic. Other implementations of OBJ1 include UMIST-OBJ from the University of Manchester Institute of Science and Technology <ref> [15] </ref>, Abstract Pascal from the University of Manchester [85], and MC-OBJ from the University of Milan [13]; the first two are written in Pascal and the third in C. In addition, there is a Franz Lisp OBJ2 from Washington State University [119].
Reference: [16] <author> Hubert Comon. </author> <title> Unification et Disunification: Theories et Applications. </title> <type> PhD thesis, </type> <institution> Universite de l'Institut Polytechnique de Grenoble, </institution> <year> 1988. </year>
Reference: [17] <author> Department of Defense. </author> <title> Reference manual for the Ada programming language. United States Government, </title> <type> Report ANSI/MIL-STD-1815A, </type> <year> 1983. </year>
Reference-contexts: Then one can construct new programs from old modules by instantiating parameters and transforming modules. Actual parameters are modules in this approach, and interface specifications include semantic as well as syntactic information. Ada <ref> [17] </ref> generic packages provide only part of what would be most useful.
Reference: [18] <author> Nachum Dershowitz and Jean-Pierre Jouannaud. </author> <title> Notations for rewriting. </title> <journal> Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> 43 </volume> <pages> 162-172, </pages> <year> 1990. </year>
Reference: [19] <author> Nachum Dershowitz and Jean-Pierre Jouannaud. </author> <title> Rewriting systems. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Volume B, </volume> <pages> pages 244-320. </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference-contexts: Note that an order sorted version of Knuth-Bendix is needed for OBJ3 [118]. Huet and Oppen give a nice survey of rewrite rule theory which develops some connections with general algebra [74]; Klop [82, 83] and Dershowitz and Jouannaud <ref> [19] </ref> have also written useful surveys of this area, that are more up to date. OSA foundations for the issues discussed above may be found in [96, 50, 81, 118].
Reference: [20] <author> David Duce. </author> <title> Concerning the compatibility of PHIGS and GKS. In Joseph Goguen, editor, Applications of Algebraic Specification using OBJ. </title> <address> Cambridge, </address> <note> to appear 1993. </note>
Reference-contexts: been used for many applications, including debugging algebraic specifications [61], rapid pro-totyping [53], defining programming languages in a way that directly yields an interpreter (see Appendix Section C.2, as well as [62] and some elegant work of Peter Mosses [100, 101]), specifying software systems (e.g., the GKS graphics kernel system <ref> [20] </ref>, an Ada configuration manager [32], the MacIntosh QuickDraw program [106], and OBJ itself [15]), and hardware specification, simulation, and verification (see [120] and Section 4.8); some of these applications were done under an experiment sponsored by the British Alvey Project.
Reference: [21] <author> Hartmut Ehrig and Bernd Mahr. </author> <title> Fundamentals of Algebraic Specification 1: Equations and Initial Semantics. </title> <publisher> Springer, </publisher> <year> 1985. </year> <journal> EATCS Monographs on Theoretical Computer Science, </journal> <volume> Volume 6. </volume>
Reference-contexts: In fact, there is no really satisfying way to define either rationals or stacks with (unconditional) many sorted algebra: [65] and <ref> [21] </ref> contain some examples which show just how awkward things can get, and [57] actually proves that certain kinds of specifications cannot be expressed at all in many sorted equational logic.
Reference: [22] <author> Kokichi Futatsugi. </author> <title> Hierarchical software development in HISP. </title> <editor> In T. Kitagawa, editor, </editor> <booktitle> Computer Science and Technologies 1982, </booktitle> <pages> pages 151-174. </pages> <address> OHMSA/North Holland, </address> <year> 1982. </year> <booktitle> Japan Annual Review in Electronics, Computer and Telecommunications Series. </booktitle>
Reference-contexts: Another influence on OBJ3's design and implementation was the HISP system <ref> [30, 31, 22] </ref>. The OBJ3 implementation was developed at SRI by Timothy Winkler, Jose Meseguer, Joseph Goguen, Claude and Helene Kirchner, and Aristide Megrelis. Release 2 of OBJ3 has been developed at SRI by Timothy Winkler, Patrick Lincoln, Jose Meseguer, and Joseph Goguen.
Reference: [23] <author> Kokichi Futatsugi. </author> <title> An overview of OBJ2. </title> <editor> In Kazuhiru Fuchi and Maurice Nivat, editors, </editor> <booktitle> Proceedings, France-Japan AI and CS Symposium. </booktitle> <publisher> ICOT, </publisher> <year> 1986. </year> <note> Also Information Processing Society of Japan, Technical Memorandum PL-86-6. </note>
Reference: [24] <author> Kokichi Futatsugi. </author> <title> Trends in formal specification methods based on algebraic specification techniques | from abstract data types to software processes: A personal perspective. </title> <booktitle> In Proceedings, International Conference Commemorating the 30th Anniversary of the Information Processing Society of Japan, </booktitle> <pages> pages 59-66. </pages> <booktitle> Information Processing Society of Japan, </booktitle> <year> 1990. </year>
Reference: [25] <author> Kokichi Futatsugi. </author> <title> Product-centered process description = algebraic specification of environment + SCRIPT. </title> <booktitle> In Proceedings, 6th International Software Process Workshop, </booktitle> <pages> pages 95-97. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference: [26] <author> Kokichi Futatsugi. </author> <title> Structuring and derivation in algebraic specification/programming languages. </title> <journal> Journal of Information Processing Society of Japan, </journal> <volume> 14(2) </volume> <pages> 153-163, </pages> <year> 1991. </year>
Reference-contexts: Here M may be either an object or another theory. 2. Write a module that realises the desired behaviour if the right modules are imported; write "stubs" (i.e., skeletal code) for the modules to be imported, and then elaborate them later (see <ref> [28, 29, 26] </ref>). One may be able to use the interface theories themselves as "stubs," because reductions can be executed over OBJ3 theories. 3. Write a parameterised module that realises the desired behaviour if its parameters are instantiated according to their interface theories.
Reference: [27] <author> Kokichi Futatsugi, Joseph Goguen, Jean-Pierre Jouannaud, and Jose Meseguer. </author> <title> Principles of OBJ2. </title> <editor> In Brian Reid, editor, </editor> <booktitle> Proceedings, Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 52-66. </pages> <institution> Association for Computing Machinery, </institution> <year> 1985. </year>
Reference-contexts: OBJ2 <ref> [27, 28] </ref> was implemented using parts of OBJ1 during 1984-85 at SRI by Kokichi Futatsugi and Jean-Pierre Jouannaud, following a design in which Jose Meseguer and Joseph Goguen also participated, based on order sorted algebra [36, 60, 50, 57, 118] rather than error algebra; also, OBJ2 provided Clear-like parameterised modules, theories, <p> Patrick Lincoln for much help with the routines for rewriting modulo equations used in Release 2 of OBJ3; Mr. Aristide Megrelis for his work on the OBJ3 parser. Much of this paper is based upon [39, 44, 67] and <ref> [27] </ref>. 2 Ob jects The most important OBJ unit is the object 3 , which encapsulates executable code. Syntactically, an object begins with the keyword obj and ends with endo 4 .
Reference: [28] <author> Kokichi Futatsugi, Joseph Goguen, Jose Meseguer, and Koji Okada. </author> <title> Parameterized programming in OBJ2. </title> <editor> In Robert Balzer, editor, </editor> <booktitle> Proceedings, Ninth International Conference on Software Engineering, </booktitle> <pages> pages 51-60. </pages> <publisher> IEEE Computer Society, </publisher> <month> March </month> <year> 1987. </year>
Reference-contexts: OBJ2 <ref> [27, 28] </ref> was implemented using parts of OBJ1 during 1984-85 at SRI by Kokichi Futatsugi and Jean-Pierre Jouannaud, following a design in which Jose Meseguer and Joseph Goguen also participated, based on order sorted algebra [36, 60, 50, 57, 118] rather than error algebra; also, OBJ2 provided Clear-like parameterised modules, theories, <p> One way to diminish these effects is to maximise the reuse of software, through the systematic use of what we call parameterised programming (see <ref> [39, 44, 41, 28, 29, 47, 61] </ref>). <p> Here M may be either an object or another theory. 2. Write a module that realises the desired behaviour if the right modules are imported; write "stubs" (i.e., skeletal code) for the modules to be imported, and then elaborate them later (see <ref> [28, 29, 26] </ref>). One may be able to use the interface theories themselves as "stubs," because reductions can be executed over OBJ3 theories. 3. Write a parameterised module that realises the desired behaviour if its parameters are instantiated according to their interface theories.
Reference: [29] <author> Kokichi Futatsugi, Joseph Goguen, Jose Meseguer, and Koji Okada. </author> <title> Parameterized programming and its application to rapid prototyping in OBJ2. </title> <editor> In Yoshihiro Matsumoto and Yutaka Ohno, editors, </editor> <booktitle> Japanese Perspectives on Software Engineering, </booktitle> <pages> pages 77-102. </pages> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: One way to diminish these effects is to maximise the reuse of software, through the systematic use of what we call parameterised programming (see <ref> [39, 44, 41, 28, 29, 47, 61] </ref>). <p> Here M may be either an object or another theory. 2. Write a module that realises the desired behaviour if the right modules are imported; write "stubs" (i.e., skeletal code) for the modules to be imported, and then elaborate them later (see <ref> [28, 29, 26] </ref>). One may be able to use the interface theories themselves as "stubs," because reductions can be executed over OBJ3 theories. 3. Write a parameterised module that realises the desired behaviour if its parameters are instantiated according to their interface theories.
Reference: [30] <author> Kokichi Futatsugi and Koji Okada. </author> <title> Specification writing as construction of hierarchically structured clusters of operators. </title> <booktitle> In Proceedings, 1980 IFIP Congress, </booktitle> <pages> pages 287-292. </pages> <publisher> IFIP, </publisher> <year> 1980. </year>
Reference-contexts: Another influence on OBJ3's design and implementation was the HISP system <ref> [30, 31, 22] </ref>. The OBJ3 implementation was developed at SRI by Timothy Winkler, Jose Meseguer, Joseph Goguen, Claude and Helene Kirchner, and Aristide Megrelis. Release 2 of OBJ3 has been developed at SRI by Timothy Winkler, Patrick Lincoln, Jose Meseguer, and Joseph Goguen.
Reference: [31] <author> Kokichi Futatsugi and Koji Okada. </author> <title> A hierarchical structurting method for functional software systems. </title> <booktitle> In Proceedings, 6th International Conference on Software Engineering, </booktitle> <pages> pages 393-402. </pages> <publisher> IEEE, </publisher> <year> 1982. </year>
Reference-contexts: Another influence on OBJ3's design and implementation was the HISP system <ref> [30, 31, 22] </ref>. The OBJ3 implementation was developed at SRI by Timothy Winkler, Jose Meseguer, Joseph Goguen, Claude and Helene Kirchner, and Aristide Megrelis. Release 2 of OBJ3 has been developed at SRI by Timothy Winkler, Patrick Lincoln, Jose Meseguer, and Joseph Goguen.
Reference: [32] <author> Christopher Paul Gerrard. </author> <title> The specification and controlled implementation of a configuration management tool using OBJ and Ada, 1988. Gerrard Software Limited. </title>
Reference-contexts: including debugging algebraic specifications [61], rapid pro-totyping [53], defining programming languages in a way that directly yields an interpreter (see Appendix Section C.2, as well as [62] and some elegant work of Peter Mosses [100, 101]), specifying software systems (e.g., the GKS graphics kernel system [20], an Ada configuration manager <ref> [32] </ref>, the MacIntosh QuickDraw program [106], and OBJ itself [15]), and hardware specification, simulation, and verification (see [120] and Section 4.8); some of these applications were done under an experiment sponsored by the British Alvey Project.
Reference: [33] <author> Martin Gogolla. </author> <title> Partially ordered sorts in algebraic specifications. </title> <editor> In Bruno Courcelle, editor, </editor> <booktitle> Proceedings, Ninth CAAP (Bordeaux), </booktitle> <pages> pages 139-153. </pages> <address> Cambridge, </address> <year> 1984. </year> <note> Also Forschungsbericht Nr. 169, </note> <institution> Universitat Dortmund, Abteilung Informatik, </institution> <year> 1983. </year>
Reference-contexts: Although this paper omits the technical details, OSA is a rigorous mathematical theory. OSA was originally suggested by Goguen in 1978 [36], and is further developed in [60] and [57]; some alternative approaches have been given by Gogolla <ref> [33, 34] </ref>, Mosses [102], Poigne [112, 113], Reynolds [114], Smolka et al. [117, 118], Wadge [126], and others. A survey as of 1993 appears in [49], along with some new generalisations.
Reference: [34] <author> Martin Gogolla. </author> <title> A final algebra semantics for errors and exceptions. </title> <editor> In Hans-Jorg Kreowski, editor, </editor> <booktitle> Recent Trends in Data Type Specification, </booktitle> <volume> volume Informatik-Fachberichte 116, </volume> <pages> pages 89-103. </pages> <publisher> Springer, </publisher> <year> 1985. </year> <booktitle> Selected papers from the Third Workshop on Theory and Applications of Abstract Data Types. </booktitle> <pages> 98 </pages>
Reference-contexts: Although this paper omits the technical details, OSA is a rigorous mathematical theory. OSA was originally suggested by Goguen in 1978 [36], and is further developed in [60] and [57]; some alternative approaches have been given by Gogolla <ref> [33, 34] </ref>, Mosses [102], Poigne [112, 113], Reynolds [114], Smolka et al. [117, 118], Wadge [126], and others. A survey as of 1993 appears in [49], along with some new generalisations.
Reference: [35] <author> Joseph Goguen. </author> <title> Abstract errors for abstract data types. </title> <editor> In Eric Neuhold, editor, </editor> <booktitle> Proceedings, First IFIP Working Conference on Formal Description of Programming Concepts, pages 21.1-21.32. </booktitle> <publisher> MIT, </publisher> <year> 1977. </year> <title> Also in Formal Description of Programming Concepts, </title> <editor> Peter Neuhold, Ed., </editor> <publisher> North-Holland, </publisher> <pages> pages 491-522, </pages> <year> 1979. </year>
Reference-contexts: In [52], OBJ3 is used for teaching the semantics of imperative programming languages; in fact, all of the proofs are actually executable OBJ3 programs. 1.1 A Brief History of OBJ OBJ was originally designed in 1976 by Goguen <ref> [35] </ref> as a language for "error algebras," an attempt to extend algebraic abstract data type theory to handle errors and partial functions in a simple, uniform way. This first design also used ideas from Clear [7, 9] for parameterised modules. <p> For some time, we have been exploring rigorous approaches that allow users to define their own exception conditions, error messages, and exception handling. OBJT and OBJ1 used error algebras <ref> [35] </ref>, which sometimes fail to have initial models [110]; however, the current approach based on OSA seems entirely satisfactory to us. As a simple example, let's consider the natural and rational numbers, with sorts Nat &lt; Rat.
Reference: [36] <author> Joseph Goguen. </author> <title> Order sorted algebra. </title> <type> Technical Report 14, </type> <institution> UCLA Computer Science Department, </institution> <year> 1978. </year> <title> Semantics and Theory of Computation Series. </title>
Reference-contexts: OBJ2 [27, 28] was implemented using parts of OBJ1 during 1984-85 at SRI by Kokichi Futatsugi and Jean-Pierre Jouannaud, following a design in which Jose Meseguer and Joseph Goguen also participated, based on order sorted algebra <ref> [36, 60, 50, 57, 118] </ref> rather than error algebra; also, OBJ2 provided Clear-like parameterised modules, theories, and views, although not in full generality. Another influence on OBJ3's design and implementation was the HISP system [30, 31, 22]. <p> Although this paper omits the technical details, OSA is a rigorous mathematical theory. OSA was originally suggested by Goguen in 1978 <ref> [36] </ref>, and is further developed in [60] and [57]; some alternative approaches have been given by Gogolla [33, 34], Mosses [102], Poigne [112, 113], Reynolds [114], Smolka et al. [117, 118], Wadge [126], and others. A survey as of 1993 appears in [49], along with some new generalisations.
Reference: [37] <author> Joseph Goguen. </author> <title> Some design principles and theory for OBJ-0, a language for expressing and executing algebraic specifications of programs. </title> <editor> In Edward Blum, Manfred Paul, and Satsoru Takasu, editors, </editor> <booktitle> Proceedings, Conference on Mathematical Studies of Information Processing, </booktitle> <pages> pages 425-473. </pages> <publisher> Springer, </publisher> <year> 1979. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 75. </volume>
Reference-contexts: This first design also used ideas from Clear [7, 9] for parameterised modules. First implementations of OBJ were done from 1977 to 1979 at UCLA by Joseph Tardo and Joseph Goguen. OBJ0 <ref> [37] </ref> was based on unsorted equational logic, while OBJT used error algebras plus an "image" construct for parameterisation [124, 64].
Reference: [38] <author> Joseph Goguen. </author> <title> How to prove algebraic inductive hypotheses without induction, with applications to the correctness of data type representations. </title> <editor> In Wolfgang Bibel and Robert Kowalski, editors, </editor> <booktitle> Proceedings, Fifth Conference on Automated Deduction, </booktitle> <pages> pages 356-373. </pages> <publisher> Springer, </publisher> <year> 1980. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 87. </volume>
Reference-contexts: For canonical systems (as defined in Section 2.4.4 below), the rewrite rule operational semantics agrees with initial algebra semantics, in the sense that the reduced forms constitute an initial algebra (this result was shown in <ref> [38] </ref>; see also [95, 127]). Because OBJ3 is based on order sorted algebra, it is important to note that this result easily extends to this context. OSA, and thus OBJ3, provides a completely general programming formalism, in the sense that any partial computable function can be defined 13 .
Reference: [39] <author> Joseph Goguen. </author> <title> Parameterized programming. </title> <journal> Transactions on Software Engineering, </journal> <volume> SE-10(5):528-543, </volume> <month> September </month> <year> 1984. </year>
Reference-contexts: Mr. Adolfo Socorro for help checking the details of OBJ3 syntax; Mr. Patrick Lincoln for much help with the routines for rewriting modulo equations used in Release 2 of OBJ3; Mr. Aristide Megrelis for his work on the OBJ3 parser. Much of this paper is based upon <ref> [39, 44, 67] </ref> and [27]. 2 Ob jects The most important OBJ unit is the object 3 , which encapsulates executable code. Syntactically, an object begins with the keyword obj and ends with endo 4 . <p> One way to diminish these effects is to maximise the reuse of software, through the systematic use of what we call parameterised programming (see <ref> [39, 44, 41, 28, 29, 47, 61] </ref>).
Reference: [40] <author> Joseph Goguen. </author> <title> Merged views, closed worlds and ordered sorts: Some novel database features in OBJ. </title> <editor> In Alex Borgida and Peter Buneman, editors, </editor> <booktitle> Workshop on Database Interfaces, </booktitle> <pages> pages 38-47. </pages> <institution> University of Pennsylvania, Computer Science Department, </institution> <year> 1985. </year> <note> This workshop took place in October, </note> <year> 1982. </year>
Reference-contexts: Hierarchical structure could also be used to reflect access properties of a physically distributed database, as suggested in <ref> [40] </ref>. The command show modules . shows a list of all modules in the current OBJ working context. If a module with an atomic name has been redefined, then it may appear more than once in the output from this command.
Reference: [41] <author> Joseph Goguen. </author> <title> Reusing and interconnecting software components. </title> <journal> Computer, </journal> <volume> 19(2) </volume> <pages> 16-28, </pages> <month> February </month> <year> 1986. </year> <note> Reprinted in Tutorial: Software Reusability, </note> <editor> Peter Freeman, editor, </editor> <publisher> IEEE Computer Society, </publisher> <year> 1987, </year> <pages> pages 251-263, </pages> <booktitle> and in Domain Analysis and Software Systems Modelling, </booktitle> <editor> Ruben Prieto-Daz and Guillermo Arango, editors, </editor> <publisher> IEEE Computer Society, </publisher> <year> 1991, </year> <pages> pages 125-137. </pages>
Reference-contexts: One way to diminish these effects is to maximise the reuse of software, through the systematic use of what we call parameterised programming (see <ref> [39, 44, 41, 28, 29, 47, 61] </ref>). <p> In particular, Ada generic packages provide no way to document the semantics of interfaces, although this feature can greatly improve the reliability of software reuse and can also help to retrieve the right module from a library, as discussed in <ref> [41] </ref>. Also, Ada provides only very weak facilities for combining modules. For example, only one level of module instantiation is possible at a time; that is, one cannot build F (G (A)), but rather one must first define B to be G (A), and then build F (B).
Reference: [42] <author> Joseph Goguen. </author> <title> Modular algebraic specification of some basic geometrical constructions. </title> <booktitle> Artificial Intelligence, </booktitle> <pages> pages 123-153, </pages> <year> 1988. </year> <note> Special Issue on Computational Geometry, edited by Deepak Kapur and Joseph Mundy; also, Report CSLI-87-87, </note> <institution> Center for the Study of Language and Information at Stanford University, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: We will see later that retracts can be used to handle rewrite rules that are not sort decreasing (see Section 2.3.4); also, equations with retracts on their lefthand sides are useful for defining "coercions" among various data types, and data with multiple representations, as explained in [57] and illustrated in <ref> [42] </ref> and [49]. Turning to the theory for a moment now, retracts are new operators r s;s 0 : s ! s 0 , one for each pair s; s 0 of sorts in the same connected component; these give an extension of the original signature provided by the user.
Reference: [43] <author> Joseph Goguen. </author> <title> OBJ as a theorem prover, with application to hardware verification. In V.P. </title> <editor> Sub-ramanyan and Graham Birtwhistle, editors, </editor> <booktitle> Current Trends in Hardware Verification and Automated Theorem Proving, </booktitle> <pages> pages 218-267. </pages> <publisher> Springer, </publisher> <year> 1989. </year> <note> Also Technical Report SRI-CSL-88-4R2, </note> <institution> SRI International, Computer Science Lab, </institution> <month> August </month> <year> 1988. </year>
Reference-contexts: OBJ3 is applied to theorem proving and hardware verification in <ref> [43] </ref> and [48], and some examples from [43] are given in Appendix Section C.4. 2OBJ, a metalogical framework for building theorem provers is described in [63]; its implementation is based on OBJ3. <p> OBJ3 is applied to theorem proving and hardware verification in <ref> [43] </ref> and [48], and some examples from [43] are given in Appendix Section C.4. 2OBJ, a metalogical framework for building theorem provers is described in [63]; its implementation is based on OBJ3. <p> For example, even if we didn't know that PROPC was canonical, we could still be certain that any term that reduces to true is a tautology. Thus, OBJ code can be used for theorem proving, as illustrated by the examples in <ref> [43] </ref> and [48], a sample from which is given in Section 4.8 below. <p> theorem proving technology could be used to verify that a given mapping really is a view, that is, that the semantic properties specified in the source theory are in fact satisfied by the target module; presumably, this could be done using OBJ itself as a theorem prover, using techniques from <ref> [43, 45] </ref>, or the 2OBJ system [63]. However, this often may not be worth the effort in practice, and non-verified views should be seen as documenting the programmer's intentions and beliefs about the semantic properties of modules. <p> But OBJ3 can not only assert the monoid property, it can even be used to prove that this property implies property (H), using methods described in <ref> [43, 45] </ref>. Many researchers have argued that it is much easier to use type inference for higher-order functions to get such declarations and instantiations automatically. <p> nil 1 -2 3) . ***&gt; should be: 0 1 4 9 reduce in MAP [(dbl_).FNS] : map (0 1 -2 3) . ***&gt; should be: 0 2 -4 6 reduce in MAP [(_*3).FNS] : map (0 1 -2 nil 3) . ***&gt; should be: 0 3 -6 9 In <ref> [43] </ref> there is a complete proof that the n th element of map (list) is f (e), where e is the n th element of list, using OBJ3 itself as a theorem prover. <p> noting that higher-order specifications can be implemented by higher-order rewriting [77]. 49 op t : -&gt; Time . op f0 : Time -&gt; Prop . endo make 2NOT is NOT [NOT [F]*(op f2 to f1)] endm reduce f2 (s s t) iff f0 (t) . ***&gt; should be: true See <ref> [43] </ref> for a precise statement of the theorem proved here, as well as a detailed justification that the given reduction really proves that theorem. Parameterised modules make this code much more readable than it would be otherwise. <p> Parameterised modules make this code much more readable than it would be otherwise. The same techniques seem effective for much more complex examples of hardware specification, simulation and verification, and many more examples are given in <ref> [43] </ref> and [45], along with supporting theory. <p> The required theorems are developed in <ref> [43] </ref>, from which the proof scores in this section were taken. [43] and [48] also contains some more complex proofs, including the verification of an OBJ-style parameterised module, and several hardware circuits. <p> The required theorems are developed in <ref> [43] </ref>, from which the proof scores in this section were taken. [43] and [48] also contains some more complex proofs, including the verification of an OBJ-style parameterised module, and several hardware circuits.
Reference: [44] <author> Joseph Goguen. </author> <title> Principles of parameterized programming. </title> <editor> In Ted Biggerstaff and Alan Perlis, editors, </editor> <booktitle> Software Reusability, Volume I: Concepts and Models, </booktitle> <pages> pages 159-225. </pages> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Mr. Adolfo Socorro for help checking the details of OBJ3 syntax; Mr. Patrick Lincoln for much help with the routines for rewriting modulo equations used in Release 2 of OBJ3; Mr. Aristide Megrelis for his work on the OBJ3 parser. Much of this paper is based upon <ref> [39, 44, 67] </ref> and [27]. 2 Ob jects The most important OBJ unit is the object 3 , which encapsulates executable code. Syntactically, an object begins with the keyword obj and ends with endo 4 . <p> One way to diminish these effects is to maximise the reuse of software, through the systematic use of what we call parameterised programming (see <ref> [39, 44, 41, 28, 29, 47, 61] </ref>). <p> The commands show psort [hModExp i] . and show psort . 21 Some further conventions for default views are described in <ref> [44] </ref>, but these are not implemented in Release 2 of OBJ3; also, the discussion in [44] does not reflect some improvements to OBJ3 made after that paper was written. 38 show the principal sort of a given module, or of the current module if none is given. <p> The commands show psort [hModExp i] . and show psort . 21 Some further conventions for default views are described in <ref> [44] </ref>, but these are not implemented in Release 2 of OBJ3; also, the discussion in [44] does not reflect some improvements to OBJ3 made after that paper was written. 38 show the principal sort of a given module, or of the current module if none is given. There are also conventions for omitting operator pairs from a view: 1. <p> The following is a non-default view of NAT as a MONOID, view NAT+ from MONOID to NAT is op _*_ to _+_ . endv where e to 0 could also be omitted by preservation of the identity attribute. It can be shown <ref> [44] </ref> that if is an abbreviation of each of two views and 0 , then = 0 . From this, it follows that there is at most one null view from any module to any other.
Reference: [45] <author> Joseph Goguen. </author> <title> Proving and rewriting. </title> <editor> In Helene Kirchner and Wolfgang Wechler, editors, </editor> <booktitle> Proceedings, Second International Conference on Algebraic and Logic Programming, </booktitle> <pages> pages 1-24. </pages> <publisher> Springer, </publisher> <year> 1990. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 463. </volume>
Reference-contexts: theorem proving technology could be used to verify that a given mapping really is a view, that is, that the semantic properties specified in the source theory are in fact satisfied by the target module; presumably, this could be done using OBJ itself as a theorem prover, using techniques from <ref> [43, 45] </ref>, or the 2OBJ system [63]. However, this often may not be worth the effort in practice, and non-verified views should be seen as documenting the programmer's intentions and beliefs about the semantic properties of modules. <p> But OBJ3 can not only assert the monoid property, it can even be used to prove that this property implies property (H), using methods described in <ref> [43, 45] </ref>. Many researchers have argued that it is much easier to use type inference for higher-order functions to get such declarations and instantiations automatically. <p> Parameterised modules make this code much more readable than it would be otherwise. The same techniques seem effective for much more complex examples of hardware specification, simulation and verification, and many more examples are given in [43] and <ref> [45] </ref>, along with supporting theory.
Reference: [46] <author> Joseph Goguen. </author> <title> Semantic specifications for the Rewrite Rule Machine. </title> <editor> In Aki Yonezawa and Takayasu Ito, editors, </editor> <booktitle> Concurrency: Theory, Language and Architecture, </booktitle> <pages> pages 216-234, </pages> <year> 1991. </year> <booktitle> Proceedings of a U.K.-Japan Workshop; Springer, Lecture Notes in Computer Science, </booktitle> <volume> Volume 491. </volume>
Reference-contexts: In addition, OBJ is one of the languages for programming a massively parallel machine that executes rewrite rules directly <ref> [51, 128, 86, 59, 87, 2, 46, 1] </ref>; in fact, we believe that OBJ on such a machine could greatly out-perform a conventional language on a conventional machine, because of the direct concurrent execution of rewrite rules.
Reference: [47] <author> Joseph Goguen. </author> <title> Types as theories. </title> <editor> In George Michael Reed, Andrew William Roscoe, and Ralph F. Wachter, editors, </editor> <booktitle> Topology and Category Theory in Computer Science, </booktitle> <pages> pages 357-390. </pages> <address> Oxford, </address> <year> 1991. </year> <booktitle> Proceedings of a Conference held at Oxford, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: One way to diminish these effects is to maximise the reuse of software, through the systematic use of what we call parameterised programming (see <ref> [39, 44, 41, 28, 29, 47, 61] </ref>). <p> next two subsections discuss theories and views, respectively. 17 In practice, the two kinds of list should use different notation, to avoid parse ambiguities, as in Section 4.5 below. 18 In general, modules may have internal states; although this feature is not discussed in this paper, the reader can consult <ref> [54, 47] </ref> and [58] for further information about approaches to this important topic, which is being implemented in the FOOPS [58, 68] and OOZE [3] systems.
Reference: [48] <author> Joseph Goguen. </author> <title> Theorem Proving and Algebra. </title> <publisher> MIT, </publisher> <year> 1994. </year>
Reference-contexts: OBJ3 is applied to theorem proving and hardware verification in [43] and <ref> [48] </ref>, and some examples from [43] are given in Appendix Section C.4. 2OBJ, a metalogical framework for building theorem provers is described in [63]; its implementation is based on OBJ3. <p> For example, even if we didn't know that PROPC was canonical, we could still be certain that any term that reduces to true is a tautology. Thus, OBJ code can be used for theorem proving, as illustrated by the examples in [43] and <ref> [48] </ref>, a sample from which is given in Section 4.8 below. <p> The required theorems are developed in [43], from which the proof scores in this section were taken. [43] and <ref> [48] </ref> also contains some more complex proofs, including the verification of an OBJ-style parameterised module, and several hardware circuits.
Reference: [49] <author> Joseph Goguen and Razvan Diaconescu. </author> <title> An oxford survey of order sorted algebra. </title> <note> Mathematical Structures in Computer Science, to appear. </note>
Reference-contexts: A survey as of 1993 appears in <ref> [49] </ref>, along with some new generalisations. OBJ3 directly supports subsort polymorphism, which is operator overloading that is consistent under subsort restriction (this is further discussed in Section 2.2). <p> see later that retracts can be used to handle rewrite rules that are not sort decreasing (see Section 2.3.4); also, equations with retracts on their lefthand sides are useful for defining "coercions" among various data types, and data with multiple representations, as explained in [57] and illustrated in [42] and <ref> [49] </ref>. Turning to the theory for a moment now, retracts are new operators r s;s 0 : s ! s 0 , one for each pair s; s 0 of sorts in the same connected component; these give an extension of the original signature provided by the user.
Reference: [50] <author> Joseph Goguen, Jean-Pierre Jouannaud, and Jose Meseguer. </author> <title> Operational semantics of order-sorted algebra. </title> <editor> In Wilfried Brauer, editor, </editor> <booktitle> Proceedings, 1985 International Conference on Automata, Languages and Programming. Springer, 1985. Lecture Notes in Computer Science, </booktitle> <volume> Volume 194. </volume> <pages> 99 </pages>
Reference-contexts: OBJ2 [27, 28] was implemented using parts of OBJ1 during 1984-85 at SRI by Kokichi Futatsugi and Jean-Pierre Jouannaud, following a design in which Jose Meseguer and Joseph Goguen also participated, based on order sorted algebra <ref> [36, 60, 50, 57, 118] </ref> rather than error algebra; also, OBJ2 provided Clear-like parameterised modules, theories, and views, although not in full generality. Another influence on OBJ3's design and implementation was the HISP system [30, 31, 22]. <p> The signature of a module consists of the sorts, subsort relation, and operators available in it, where each operator has a form, an arity, and a value sort. The papers <ref> [50] </ref>, [60], and [57] show that under a certain natural assumption on the signature, each order sorted term has a well defined least sort: a signature is regular if and only if for any operator f : w ! s and any w 0 w there is a least rank hw <p> The OBJ3 implementation uses the notation r:s&gt;s 0 for the operator r s;s 0 : s ! s 0 . Details of the mathematical and operational semantics of retracts, using order sorted algebra and order sorted term rewriting, are given in <ref> [50] </ref> and [60]. 13 This is an as yet unpublished theorem of Dr. Jose Meseguer; see [5, 95] for similar results about total computable functions. 14 Warning: Release 2 of OBJ3 does not allow qualified sort names in retracts within terms provided by the user. <p> Sort constraints <ref> [50, 57] </ref> are declarations of this kind. Release 2 of OBJ3 has syntax for a kind of sort constraint that restricts the domain of a multi-argument operator to arguments that satisfy some equational conditions. <p> OSA foundations for the issues discussed above may be found in <ref> [96, 50, 81, 118] </ref>. We have run many thousands of reductions on many hundreds of examples, often in dozens of variations, and we have hardly ever encountered problems with canonicity. <p> Warning: Because associative/commutative matching is an NP-complete problem, a uniformly fast implementation is impossible. The present implementation, based on work of Lincoln [88] extended to OSA along the lines of <ref> [50, 81] </ref>, is reasonably efficient, but cannot be expected to run quickly for really large problems; see also [78]. 2.4.2 Identity and Idempotence An identity attribute can be declared for a binary operator.
Reference: [51] <author> Joseph Goguen, Claude Kirchner, Jose Meseguer, and Timothy Winkler. </author> <title> OBJ as a language for concurrent programming. </title> <editor> In Steven Kartashev and Svetlana Kartashev, editors, </editor> <booktitle> Proceedings, Second International Supercomputing Conference, </booktitle> <volume> Volume I, </volume> <pages> pages 195-198. </pages> <publisher> International Supercomputing Institute Inc. </publisher> <address> (St. Petersburg FL), </address> <year> 1987. </year>
Reference-contexts: In addition, OBJ is one of the languages for programming a massively parallel machine that executes rewrite rules directly <ref> [51, 128, 86, 59, 87, 2, 46, 1] </ref>; in fact, we believe that OBJ on such a machine could greatly out-perform a conventional language on a conventional machine, because of the direct concurrent execution of rewrite rules.
Reference: [52] <author> Joseph Goguen and Grant Malcolm. </author> <title> Algebraic Semantics for Imperative Languages. </title> <type> Draft, </type> <institution> Programming Research Group, Oxford University, </institution> <year> 1992. </year>
Reference-contexts: OBJ3 is applied to theorem proving and hardware verification in [43] and [48], and some examples from [43] are given in Appendix Section C.4. 2OBJ, a metalogical framework for building theorem provers is described in [63]; its implementation is based on OBJ3. In <ref> [52] </ref>, OBJ3 is used for teaching the semantics of imperative programming languages; in fact, all of the proofs are actually executable OBJ3 programs. 1.1 A Brief History of OBJ OBJ was originally designed in 1976 by Goguen [35] as a language for "error algebras," an attempt to extend algebraic abstract data
Reference: [53] <author> Joseph Goguen and Jose Meseguer. </author> <title> Rapid prototyping in the OBJ executable specification language. </title> <journal> Software Engineering Notes, </journal> <volume> 7(5) </volume> <pages> 75-84, </pages> <month> December </month> <year> 1982. </year> <title> Proceedings of Rapid Prototyping Workshop. </title>
Reference-contexts: OBJ has been used for many applications, including debugging algebraic specifications [61], rapid pro-totyping <ref> [53] </ref>, defining programming languages in a way that directly yields an interpreter (see Appendix Section C.2, as well as [62] and some elegant work of Peter Mosses [100, 101]), specifying software systems (e.g., the GKS graphics kernel system [20], an Ada configuration manager [32], the MacIntosh QuickDraw program [106], and OBJ <p> f1g reduce s3 & s2 . ***&gt; should be: f1,2g reduce omega U s2 . ***&gt; should be: omega C.2 A Simple Programming Language It is generally rather straightforward to write specifications of programming languages in OBJ, as we hope the following example shows. (This example has been adapted from <ref> [53] </ref>; the first such use of OBJ occurs in [62].) This example is preceded by two standard generic modules, which are also used in some other examples below. obj LIST [X :: TRIV] is sorts List NeList . op nil : -&gt; List . subsorts Elt &lt; NeList &lt; List .
Reference: [54] <author> Joseph Goguen and Jose Meseguer. </author> <title> Universal realization, persistent interconnection and implementation of abstract modules. </title> <editor> In M. Nielsen and E.M. Schmidt, editors, </editor> <booktitle> Proceedings, 9th International Conference on Automata, Languages and Programming, </booktitle> <pages> pages 265-281. </pages> <publisher> Springer, </publisher> <year> 1982. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 140. </volume>
Reference-contexts: next two subsections discuss theories and views, respectively. 17 In practice, the two kinds of list should use different notation, to avoid parse ambiguities, as in Section 4.5 below. 18 In general, modules may have internal states; although this feature is not discussed in this paper, the reader can consult <ref> [54, 47] </ref> and [58] for further information about approaches to this important topic, which is being implemented in the FOOPS [58, 68] and OOZE [3] systems.
Reference: [55] <author> Joseph Goguen and Jose Meseguer. </author> <title> Eqlog: Equality, types, and generic modules for logic programming. </title> <editor> In Douglas DeGroot and Gary Lindstrom, editors, </editor> <booktitle> Logic Programming: Functions, Relations and Equations, </booktitle> <pages> pages 295-363. </pages> <publisher> Prentice-Hall, </publisher> <year> 1986. </year> <title> An earlier version appears in Journal of Logic Programming, </title> <journal> Volume 1, </journal> <volume> Number 2, </volume> <pages> pages 179-210, </pages> <month> September </month> <year> 1984. </year>
Reference-contexts: In addition, there is a Franz Lisp OBJ2 from Washington State University [119]. UMIST-OBJ is available as a proprietary software product from Gerrard Software, under the name ObjEx. The authors are exploring various extensions of OBJ, in the directions of logic (or relational) programming (the Eqlog system <ref> [55, 56] </ref>), object-oriented programming (the FOOPS system [58, 68]), concurrent systems programming and concurrent object-oriented programming (Maude [92, 93, 94, 91, 97], higher-order functional programming [77, 89], and LOTOS-style specification for communication protocols [107, 108]. <p> you will enjoy this! Also, OBJ3 seems to provide a very workable platform for implementing other system, and in particular, is being used at Oxford to implement the combined functional and object oriented system FOOPS [58], the object oriented specification language OOZE [3], the combined logic and functional language Eqlog <ref> [55] </ref>, and a generic (i.e., metalogical) theorem prover called 2OBJ [63]. FOOPS and OOZE support objects with states, and Eqlog has logical variables (here we mean "objects" in the sense of object oriented programming, rather than in the sense of OBJ).
Reference: [56] <author> Joseph Goguen and Jose Meseguer. </author> <title> Models and equality for logical programming. </title> <editor> In Hartmut Ehrig, Giorgio Levi, Robert Kowalski, and Ugo Montanari, editors, </editor> <booktitle> Proceedings, 1987 TAPSOFT, </booktitle> <pages> pages 1-22. </pages> <publisher> Springer, </publisher> <year> 1987. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 250. </volume>
Reference-contexts: In addition, there is a Franz Lisp OBJ2 from Washington State University [119]. UMIST-OBJ is available as a proprietary software product from Gerrard Software, under the name ObjEx. The authors are exploring various extensions of OBJ, in the directions of logic (or relational) programming (the Eqlog system <ref> [55, 56] </ref>), object-oriented programming (the FOOPS system [58, 68]), concurrent systems programming and concurrent object-oriented programming (Maude [92, 93, 94, 91, 97], higher-order functional programming [77, 89], and LOTOS-style specification for communication protocols [107, 108].
Reference: [57] <author> Joseph Goguen and Jose Meseguer. </author> <title> Order-sorted algebra solves the constructor selector, multiple representation and coercion problems. </title> <booktitle> In Proceedings, Second Symposium on Logic in Computer Science, </booktitle> <pages> pages 18-29. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1987. </year> <note> Also Report CSLI-87-92, </note> <institution> Center for the Study of Language and Information, Stanford University, </institution> <note> March 1987; revised version in Information and Computation, 103, </note> <year> 1993. </year>
Reference-contexts: OBJ2 [27, 28] was implemented using parts of OBJ1 during 1984-85 at SRI by Kokichi Futatsugi and Jean-Pierre Jouannaud, following a design in which Jose Meseguer and Joseph Goguen also participated, based on order sorted algebra <ref> [36, 60, 50, 57, 118] </ref> rather than error algebra; also, OBJ2 provided Clear-like parameterised modules, theories, and views, although not in full generality. Another influence on OBJ3's design and implementation was the HISP system [30, 31, 22]. <p> separate logically and intuitively distinct concepts; to enhance readability by documenting these distinctions; and, when the notion of subsort is added, to support multiple inheritance, overloading (a form of subsort polymorphism), coercions, multiple representations, and error handling, without the confusion, and lack of semantics, found in many programming languages (see <ref> [57] </ref> for a more detailed discussion of these issues). In particular, overloading can allow users to write simpler expressions, because context can often determine which possibility is intended. <p> In fact, there is no really satisfying way to define either rationals or stacks with (unconditional) many sorted algebra: [65] and [21] contain some examples which show just how awkward things can get, and <ref> [57] </ref> actually proves that certain kinds of specifications cannot be expressed at all in many sorted equational logic. OSA overcomes these obstacles with its subsorts and overloaded operators, and it allows functions to be total that would otherwise have to be partial, by restricting them to a subsort. <p> Although this paper omits the technical details, OSA is a rigorous mathematical theory. OSA was originally suggested by Goguen in 1978 [36], and is further developed in [60] and <ref> [57] </ref>; some alternative approaches have been given by Gogolla [33, 34], Mosses [102], Poigne [112, 113], Reynolds [114], Smolka et al. [117, 118], Wadge [126], and others. A survey as of 1993 appears in [49], along with some new generalisations. <p> The signature of a module consists of the sorts, subsort relation, and operators available in it, where each operator has a form, an arity, and a value sort. The papers [50], [60], and <ref> [57] </ref> show that under a certain natural assumption on the signature, each order sorted term has a well defined least sort: a signature is regular if and only if for any operator f : w ! s and any w 0 w there is a least rank hw 00 ; s <p> We will see later that retracts can be used to handle rewrite rules that are not sort decreasing (see Section 2.3.4); also, equations with retracts on their lefthand sides are useful for defining "coercions" among various data types, and data with multiple representations, as explained in <ref> [57] </ref> and illustrated in [42] and [49]. <p> Sort constraints <ref> [50, 57] </ref> are declarations of this kind. Release 2 of OBJ3 has syntax for a kind of sort constraint that restricts the domain of a multi-argument operator to arguments that satisfy some equational conditions.
Reference: [58] <author> Joseph Goguen and Jose Meseguer. </author> <title> Unifying functional, object-oriented and relational programming, with logical semantics. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-477. </pages> <publisher> MIT, </publisher> <year> 1987. </year> <journal> Preliminary version in SIGPLAN Notices, </journal> <volume> Volume 21, Number 10, </volume> <pages> pages 153-162, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: For example, OBJ3 has been used for building the 2OBJ3 metalogical framework theorem prover [63], the FOOPS object oriented specification and programming language <ref> [58, 68] </ref>, and OOZE, which is an object oriented specification language influenced by some ideas in Z [3]. <p> UMIST-OBJ is available as a proprietary software product from Gerrard Software, under the name ObjEx. The authors are exploring various extensions of OBJ, in the directions of logic (or relational) programming (the Eqlog system [55, 56]), object-oriented programming (the FOOPS system <ref> [58, 68] </ref>), concurrent systems programming and concurrent object-oriented programming (Maude [92, 93, 94, 91, 97], higher-order functional programming [77, 89], and LOTOS-style specification for communication protocols [107, 108]. <p> discuss theories and views, respectively. 17 In practice, the two kinds of list should use different notation, to avoid parse ambiguities, as in Section 4.5 below. 18 In general, modules may have internal states; although this feature is not discussed in this paper, the reader can consult [54, 47] and <ref> [58] </ref> for further information about approaches to this important topic, which is being implemented in the FOOPS [58, 68] and OOZE [3] systems. In Maude [97, 93], the state, very simply, is given by a term. 33 4.1 Theories Theories are used to express properties of modules and module interfaces. <p> to avoid parse ambiguities, as in Section 4.5 below. 18 In general, modules may have internal states; although this feature is not discussed in this paper, the reader can consult [54, 47] and [58] for further information about approaches to this important topic, which is being implemented in the FOOPS <ref> [58, 68] </ref> and OOZE [3] systems. In Maude [97, 93], the state, very simply, is given by a term. 33 4.1 Theories Theories are used to express properties of modules and module interfaces. <p> We hope that you will enjoy this! Also, OBJ3 seems to provide a very workable platform for implementing other system, and in particular, is being used at Oxford to implement the combined functional and object oriented system FOOPS <ref> [58] </ref>, the object oriented specification language OOZE [3], the combined logic and functional language Eqlog [55], and a generic (i.e., metalogical) theorem prover called 2OBJ [63]. <p> An alternative approach to object-oriented programming, supporting concurrent objects and general concurrent systems programming, is being developed at SRI in the language Maude [92, 97, 91] which uses rewriting logic [93] as a basis for very direct systems modeling. Someday, we may implement FOOPlog <ref> [58] </ref> or MaudeLog, which combine all three major emerging paradigms, the functional, logic, and object oriented. 2OBJ provides the full capabilities of a modern theorem proving environment, including a tactic language, and truth maintenance.
Reference: [59] <author> Joseph Goguen and Jose Meseguer. </author> <title> Software for the Rewrite Rule Machine. </title> <editor> In Hideo Aiso and Kazuhiro Fuchi, editors, </editor> <booktitle> Proceedings, International Conference on Fifth Generation Computer Systems 1988, </booktitle> <pages> pages 628-637. </pages> <institution> Institute for New Generation Computer Technology (ICOT), </institution> <year> 1988. </year>
Reference-contexts: In addition, OBJ is one of the languages for programming a massively parallel machine that executes rewrite rules directly <ref> [51, 128, 86, 59, 87, 2, 46, 1] </ref>; in fact, we believe that OBJ on such a machine could greatly out-perform a conventional language on a conventional machine, because of the direct concurrent execution of rewrite rules. <p> A more efficient version of this algorithm can be used to implement logic (i.e., relational) programming on the Rewrite Rule Machine; see <ref> [59, 87] </ref> for more detail. In this code, a term is either a variable (such as 'X) or else is of the form F [T], where F is an operator symbol (such as 'F) and T is a list of terms; a constant is of the form F [nil].
Reference: [60] <author> Joseph Goguen and Jose Meseguer. </author> <title> Order-sorted algebra I: Equational deduction for multiple inheritance, overloading, exceptions and partial operations. </title> <journal> Theoretical Computer Science, </journal> <volume> 105(2) </volume> <pages> 217-273, </pages> <year> 1992. </year> <note> Also, </note> <institution> Programming Research Group Technical Monograph PRG-80, Oxford University, Decem-ber 1989, and Technical Report SRI-CSL-89-10, SRI International, Computer Science Lab, </institution> <note> July 1989; originally given as lecture at Seminar on Types, Carnegie-Mellon University, June 1983; many draft versions exist, from as early as 1985. </note>
Reference-contexts: OBJ2 [27, 28] was implemented using parts of OBJ1 during 1984-85 at SRI by Kokichi Futatsugi and Jean-Pierre Jouannaud, following a design in which Jose Meseguer and Joseph Goguen also participated, based on order sorted algebra <ref> [36, 60, 50, 57, 118] </ref> rather than error algebra; also, OBJ2 provided Clear-like parameterised modules, theories, and views, although not in full generality. Another influence on OBJ3's design and implementation was the HISP system [30, 31, 22]. <p> Although this paper omits the technical details, OSA is a rigorous mathematical theory. OSA was originally suggested by Goguen in 1978 [36], and is further developed in <ref> [60] </ref> and [57]; some alternative approaches have been given by Gogolla [33, 34], Mosses [102], Poigne [112, 113], Reynolds [114], Smolka et al. [117, 118], Wadge [126], and others. A survey as of 1993 appears in [49], along with some new generalisations. <p> The signature of a module consists of the sorts, subsort relation, and operators available in it, where each operator has a form, an arity, and a value sort. The papers [50], <ref> [60] </ref>, and [57] show that under a certain natural assumption on the signature, each order sorted term has a well defined least sort: a signature is regular if and only if for any operator f : w ! s and any w 0 w there is a least rank hw 00 <p> For each r s;s 0 , a retract equation r s;s 0 (x) = x is also added, where x is a variable of sort s. Then (a slight extension of) the "conservative extension" theorem proved in <ref> [60] </ref> shows that under some mild assumptions, adding these operators and equations does not create any confusion among terms that do not involve retracts. The OBJ3 implementation uses the notation r:s&gt;s 0 for the operator r s;s 0 : s ! s 0 . <p> The OBJ3 implementation uses the notation r:s&gt;s 0 for the operator r s;s 0 : s ! s 0 . Details of the mathematical and operational semantics of retracts, using order sorted algebra and order sorted term rewriting, are given in [50] and <ref> [60] </ref>. 13 This is an as yet unpublished theorem of Dr. Jose Meseguer; see [5, 95] for similar results about total computable functions. 14 Warning: Release 2 of OBJ3 does not allow qualified sort names in retracts within terms provided by the user. Now some code that illustrates retracts. <p> use it produces the message Error: general sort constraint not currently handled (ignored) 2.3.4 More on the Operational Semantics This section gives an informal introduction to some delicate aspects of OBJ3's operational semantics; fuller treatments of order sorted rewriting, order sorted equational deduction, and retract equations can be found in <ref> [81, 60, 118] </ref>. The aim here is to familiarise OBJ3 users with the basic properties that equations should have for term reduction to behave properly. As already mentioned in Section 2.2, OBJ3 assumes that signatures are regular and coherent, and we maintain this assumption throughout this subsection. <p> type, the value sorts of such potentially non-terminating operators should be error supersorts; then retracts will be added when they are used as ordinary values in terms. 17 not a well-formed term! In fact, the second step of deduction is not allowed under the rules of order sorted equational deduction <ref> [60] </ref>, and is unsound in this precise sense. The problem is that while the deduction a = b is sound in itself, it becomes unsound in the context of the enclosing function symbol g. <p> If you prefer an editor that does not support shells, then it may be more convenient to use a shell script, and/or to redirect input and output. As a summary, OBJ3 definitions are assumed to have these properties: the signature should be regular and coherent <ref> [60] </ref> (coherence means that connected components of sorts must have tops); and the rule set for objects should be Church-Rosser, and if possible, terminating with respect to the given evaluation strategies.
Reference: [61] <author> Joseph Goguen, Jose Meseguer, and David Plaisted. </author> <title> Programming with parameterized abstract objects in OBJ. </title> <editor> In Domenico Ferrari, Mario Bolognani, and Joseph Goguen, editors, </editor> <booktitle> Theory and Practice of Software Technology, </booktitle> <pages> pages 163-193. </pages> <publisher> North-Holland, </publisher> <year> 1983. </year>
Reference-contexts: OBJ has been used for many applications, including debugging algebraic specifications <ref> [61] </ref>, rapid pro-totyping [53], defining programming languages in a way that directly yields an interpreter (see Appendix Section C.2, as well as [62] and some elegant work of Peter Mosses [100, 101]), specifying software systems (e.g., the GKS graphics kernel system [20], an Ada configuration manager [32], the MacIntosh QuickDraw program <p> SRI, based on theoretical and design work carried out with Joseph Goguen and Jose Meseguer; improvements of OBJ1 over OBJT included rewriting modulo associativity and/or commutativity, hash coded memo functions, the use of theories with loose semantics as well as objects with initial algebra semantics, and some convenient interactive features <ref> [61] </ref>. <p> The procedure is due to Hsiang [73], and makes crucial use of associative/commutative rewriting. The OBJ3 code for the object PROPC below evolved from OBJ1 code originally written by David Plaisted <ref> [61] </ref>. It reduces tautologuous propositional formulae, in the usual connectives (and, or, implies, not, xor (exclusive or) and iff) to the constant true, and reduces all other formulae to a canonical form (modulo the commutative and associative axioms) in the connectives xor, and, true and false. <p> One way to diminish these effects is to maximise the reuse of software, through the systematic use of what we call parameterised programming (see <ref> [39, 44, 41, 28, 29, 47, 61] </ref>). <p> LEXL [NATD] endm orders lists of NATs by the divisibility ordering on NATs, while make PHRASE is LEXL [QIDL] endm uses the lexicographic ordering on QIDL to give a lexicographic ordering on lists of identifiers, and thus (for example) on titles of books. (This example, which builds upon one from <ref> [61] </ref>, is continued in the following subsection.) Now consider the case where a view that is abbreviated to just a sort name occurs in a module, and the sort name used has been declared above it, in the same module. <p> Earlier versions of OBJ had an image transformation with capabilities of renaming and instantiation; but because it did not use theories to describe interfaces, it now seems somewhat undisciplined, and has been abandoned, even though it can be given a respectable semantics using colimits <ref> [61] </ref>. Clear [7, 9] had a construction to enrich a given module, but this would be redundant in OBJ, because we need only import the given module into a new module, and then add the desired sorts, operators and equations. <p> This code uses the propositional calculus decision procedure object (from Section 2.4.6), thus providing an excellent example of software reuse, because PROPC was written in OBJ1 by David Plaisted in 1982, years before we thought of using it for hardware verification <ref> [61] </ref>. Next, Time is defined for use in input and output streams, which are functions from Time to Prop. An interface theory WIRE is defined, and then a NOT gate using it.
Reference: [62] <author> Joseph Goguen and Kamran Parsaye-Ghomi. </author> <title> Algebraic denotational semantics using parameterized abstract modules. </title> <editor> In J. Diaz and I. Ramos, editors, </editor> <booktitle> Formalizing Programming Concepts, </booktitle> <pages> pages 292-309. </pages> <publisher> Springer, </publisher> <year> 1981. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 107. </volume>
Reference-contexts: OBJ has been used for many applications, including debugging algebraic specifications [61], rapid pro-totyping [53], defining programming languages in a way that directly yields an interpreter (see Appendix Section C.2, as well as <ref> [62] </ref> and some elegant work of Peter Mosses [100, 101]), specifying software systems (e.g., the GKS graphics kernel system [20], an Ada configuration manager [32], the MacIntosh QuickDraw program [106], and OBJ itself [15]), and hardware specification, simulation, and verification (see [120] and Section 4.8); some of these applications were done <p> f1,2g reduce omega U s2 . ***&gt; should be: omega C.2 A Simple Programming Language It is generally rather straightforward to write specifications of programming languages in OBJ, as we hope the following example shows. (This example has been adapted from [53]; the first such use of OBJ occurs in <ref> [62] </ref>.) This example is preceded by two standard generic modules, which are also used in some other examples below. obj LIST [X :: TRIV] is sorts List NeList . op nil : -&gt; List . subsorts Elt &lt; NeList &lt; List . op __ : List List -&gt; List [assoc id:
Reference: [63] <author> Joseph Goguen, Andrew Stevens, Keith Hobley, and Hendrik Hilberdink. 2OBJ, </author> <title> a metalogical framework based on equational logic. </title> <journal> Philosophical Transactions of the Royal Society, Series A, </journal> <volume> 339 </volume> <pages> 69-86, </pages> <year> 1992. </year> <title> Also in Mechanized Reasoning and Hardware Design, edited by C.A.R. Hoare and M.J.C. </title> <publisher> Gordon, Prentice-Hall, </publisher> <year> 1992, </year> <pages> pages 69-86. </pages>
Reference-contexts: For example, OBJ3 has been used for building the 2OBJ3 metalogical framework theorem prover <ref> [63] </ref>, the FOOPS object oriented specification and programming language [58, 68], and OOZE, which is an object oriented specification language influenced by some ideas in Z [3]. <p> OBJ3 is applied to theorem proving and hardware verification in [43] and [48], and some examples from [43] are given in Appendix Section C.4. 2OBJ, a metalogical framework for building theorem provers is described in <ref> [63] </ref>; its implementation is based on OBJ3. <p> Some more elaborate theorem proving examples are given in Appendix C.4. 2OBJ, a metalogical framework theorem proving system based on OBJ3, is described in <ref> [63] </ref>. 23 3 Module Hierarchies Conceptual clarity and ease of understanding are greatly facilitated by breaking a program into modules, each of which is mind-sized and has a natural purpose. This in turn greatly facilitates both debugging and reusability. <p> to verify that a given mapping really is a view, that is, that the semantic properties specified in the source theory are in fact satisfied by the target module; presumably, this could be done using OBJ itself as a theorem prover, using techniques from [43, 45], or the 2OBJ system <ref> [63] </ref>. However, this often may not be worth the effort in practice, and non-verified views should be seen as documenting the programmer's intentions and beliefs about the semantic properties of modules. <p> Parameterised modules make this code much more readable than it would be otherwise. The same techniques seem effective for much more complex examples of hardware specification, simulation and verification, and many more examples are given in [43] and [45], along with supporting theory. The application of 2OBJ <ref> [63] </ref> to hardware verification is described in [121] and [122]. 5 Applying Rules Release 2 of OBJ3 allows users to apply rules one at a time to a given term, either "forwards" or "backwards" (i.e., either replacing an instance of the lefthand side by the corresponding instance of the righthand side, <p> very workable platform for implementing other system, and in particular, is being used at Oxford to implement the combined functional and object oriented system FOOPS [58], the object oriented specification language OOZE [3], the combined logic and functional language Eqlog [55], and a generic (i.e., metalogical) theorem prover called 2OBJ <ref> [63] </ref>. FOOPS and OOZE support objects with states, and Eqlog has logical variables (here we mean "objects" in the sense of object oriented programming, rather than in the sense of OBJ).
Reference: [64] <author> Joseph Goguen and Joseph Tardo. </author> <title> An introduction to OBJ: A language for writing and testing software specifications. </title> <editor> In Marvin Zelkowitz, editor, </editor> <booktitle> Specification of Reliable Software, </booktitle> <pages> pages 170-189. </pages> <publisher> IEEE, </publisher> <year> 1979. </year> <title> Reprinted in Software Specification Techniques, </title> <editor> Nehan Gehani and Andrew McGettrick, editors, </editor> <publisher> Addison Wesley, </publisher> <year> 1985, </year> <pages> pages 391-420. 100 </pages>
Reference-contexts: First implementations of OBJ were done from 1977 to 1979 at UCLA by Joseph Tardo and Joseph Goguen. OBJ0 [37] was based on unsorted equational logic, while OBJT used error algebras plus an "image" construct for parameterisation <ref> [124, 64] </ref>.
Reference: [65] <author> Joseph Goguen, James Thatcher, and Eric Wagner. </author> <title> An initial algebra approach to the specification, correctness and implementation of abstract data types. </title> <type> Technical Report RC 6487, </type> <institution> IBM T.J. Watson Research Center, </institution> <month> October </month> <year> 1976. </year> <title> In Current Trends in Programming Methodology, IV, </title> <editor> Raymond Yeh, editor, </editor> <publisher> Prentice-Hall, </publisher> <year> 1978, </year> <pages> pages 80-149. </pages>
Reference-contexts: In fact, there is no really satisfying way to define either rationals or stacks with (unconditional) many sorted algebra: <ref> [65] </ref> and [21] contain some examples which show just how awkward things can get, and [57] actually proves that certain kinds of specifications cannot be expressed at all in many sorted equational logic. <p> The denotational semantics of OBJ is algebraic, as in the algebraic theory of abstract data types <ref> [66, 65, 129, 71] </ref>, and in particular, the denotation of an OBJ object is an algebra, a collection of sets with functions among them 12 . <p> The denotational semantics of OBJ is algebraic, as in the algebraic theory of abstract data types [66, 65, 129, 71], and in particular, the denotation of an OBJ object is an algebra, a collection of sets with functions among them 12 . The initial algebra approach <ref> [65, 95] </ref> takes the unique (up to isomorphism) initial algebra as the "standard," or "most representative" model of a set of equations (there may of course be many other models), i.e., as the representation-independent standard of comparison for correctness.
Reference: [66] <author> Joseph Goguen, James Thatcher, Eric Wagner, and Jesse Wright. </author> <title> Abstract data types as initial algebras and the correctness of data representations. </title> <editor> In Alan Klinger, editor, </editor> <booktitle> Computer Graphics, Pattern Recognition and Data Structure, </booktitle> <pages> pages 89-93. </pages> <publisher> IEEE, </publisher> <year> 1975. </year>
Reference-contexts: The denotational semantics of OBJ is algebraic, as in the algebraic theory of abstract data types <ref> [66, 65, 129, 71] </ref>, and in particular, the denotation of an OBJ object is an algebra, a collection of sets with functions among them 12 .
Reference: [67] <author> Joseph Goguen and Timothy Winkler. </author> <title> Introducing OBJ3. </title> <type> Technical Report SRI-CSL-88-9, </type> <institution> SRI International, Computer Science Lab, </institution> <month> August </month> <year> 1988. </year>
Reference-contexts: Mr. Adolfo Socorro for help checking the details of OBJ3 syntax; Mr. Patrick Lincoln for much help with the routines for rewriting modulo equations used in Release 2 of OBJ3; Mr. Aristide Megrelis for his work on the OBJ3 parser. Much of this paper is based upon <ref> [39, 44, 67] </ref> and [27]. 2 Ob jects The most important OBJ unit is the object 3 , which encapsulates executable code. Syntactically, an object begins with the keyword obj and ends with endo 4 .
Reference: [68] <author> Joseph Goguen and David Wolfram. </author> <title> On types and FOOPS. </title> <editor> In Robert Meersman, William Kent, and Samit Khosla, editors, </editor> <title> Object Oriented Databases: Analysis, </title> <booktitle> Design and Construction, </booktitle> <pages> pages 1-22. </pages> <publisher> North Holland, </publisher> <year> 1991. </year> <booktitle> Proceedings, IFIP TC2 Conference, </booktitle> <address> Windermere, UK, </address> <month> 2-6 July </month> <year> 1990. </year>
Reference-contexts: For example, OBJ3 has been used for building the 2OBJ3 metalogical framework theorem prover [63], the FOOPS object oriented specification and programming language <ref> [58, 68] </ref>, and OOZE, which is an object oriented specification language influenced by some ideas in Z [3]. <p> UMIST-OBJ is available as a proprietary software product from Gerrard Software, under the name ObjEx. The authors are exploring various extensions of OBJ, in the directions of logic (or relational) programming (the Eqlog system [55, 56]), object-oriented programming (the FOOPS system <ref> [58, 68] </ref>), concurrent systems programming and concurrent object-oriented programming (Maude [92, 93, 94, 91, 97], higher-order functional programming [77, 89], and LOTOS-style specification for communication protocols [107, 108]. <p> to avoid parse ambiguities, as in Section 4.5 below. 18 In general, modules may have internal states; although this feature is not discussed in this paper, the reader can consult [54, 47] and [58] for further information about approaches to this important topic, which is being implemented in the FOOPS <ref> [58, 68] </ref> and OOZE [3] systems. In Maude [97, 93], the state, very simply, is given by a term. 33 4.1 Theories Theories are used to express properties of modules and module interfaces.
Reference: [69] <author> Robert Goldblatt. </author> <title> Topoi, the Categorial Analysis of Logic. </title> <publisher> North-Holland, </publisher> <year> 1979. </year>
Reference-contexts: C.8 Categories and Coproducts This subsection presents the theories of categories and coproducts. Some familiarity with category theory may be needed to follow this example (e.g., sections 2.3 and 3.9 of <ref> [69] </ref>); on the other hand, the code may also provide a more concrete understanding of the categorical concepts.
Reference: [70] <author> Michael Gordon, Robin Milner, and Christopher Wadsworth. </author> <title> Edinburgh LCF. </title> <publisher> Springer, </publisher> <year> 1979. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 78. </volume>
Reference-contexts: discussed for combining modules; however, this is not supported in Release 2 of OBJ3. 4.7 Higher-Order Programming without Higher-Order Functions Higher-order logic seems useful in many areas, including the foundations of mathematics (e.g., type theory [90]), extracting programs from correctness proofs of algorithms, describing proof strategies (as in LCF tactics <ref> [70] </ref>), modeling traditional programming languages (as in Scott-Strachey semantics [116]), and studying the foundations of the programming process. One important advantage of higher-order programming over traditional imperative programming is its capability for structuring programs (see [75] for some cogent arguments and examples).
Reference: [71] <author> John Guttag. </author> <title> The Specification and Application to Programming of Abstract Data Types. </title> <type> PhD thesis, </type> <institution> University of Toronto, 1975. Computer Science Department, </institution> <note> Report CSRG-59. </note>
Reference-contexts: The denotational semantics of OBJ is algebraic, as in the algebraic theory of abstract data types <ref> [66, 65, 129, 71] </ref>, and in particular, the denotation of an OBJ object is an algebra, a collection of sets with functions among them 12 .
Reference: [72] <author> Robert Harper, David MacQueen, and Robin Milner. </author> <title> Standard ML. </title> <type> Technical Report ECS-LFCS-86-2, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <year> 1986. </year>
Reference-contexts: A survey as of 1993 appears in [49], along with some new generalisations. OBJ3 directly supports subsort polymorphism, which is operator overloading that is consistent under subsort restriction (this is further discussed in Section 2.2). By contrast, languages like ML <ref> [72] </ref>, Hope [12] and Miranda [125] support parametric polymorphism, following ideas of Strachey [123] as further developed by Milner [99]. OBJ3's parameterised modules also provide a parametric capability, but instantiations are determined by views, rather than by unification; see Section 4.7 for further discussion.
Reference: [73] <author> Jieh Hsiang. </author> <title> Refutational Theorem Proving using Term Rewriting Systems. </title> <type> PhD thesis, </type> <institution> University of Illinois at Champaign-Urbana, </institution> <year> 1981. </year>
Reference-contexts: The procedure is due to Hsiang <ref> [73] </ref>, and makes crucial use of associative/commutative rewriting. The OBJ3 code for the object PROPC below evolved from OBJ1 code originally written by David Plaisted [61]. <p> The module import modes extending and protecting are discussed in Section 3.1 below. The rules in this object have been shown by Hsiang <ref> [73] </ref> to be Church-Rosser and terminating modulo the commutative and associative axioms. obj PROPC is sort Prop . extending TRUTH . protecting QID . subsorts Id Bool &lt; Prop . *** constructors *** op _and_ : Prop Prop -&gt; Prop [assoc comm idem idr: true prec 2] . op _xor_ :
Reference: [74] <author> Gerard Huet and Derek Oppen. </author> <title> Equations and rewrite rules: A survey. In Ron Book, editor, Formal Language Theory: </title> <booktitle> Perspectives and Open Problems, </booktitle> <pages> pages 349-405. </pages> <publisher> Academic, </publisher> <year> 1980. </year>
Reference-contexts: Note that an order sorted version of Knuth-Bendix is needed for OBJ3 [118]. Huet and Oppen give a nice survey of rewrite rule theory which develops some connections with general algebra <ref> [74] </ref>; Klop [82, 83] and Dershowitz and Jouannaud [19] have also written useful surveys of this area, that are more up to date. OSA foundations for the issues discussed above may be found in [96, 50, 81, 118].
Reference: [75] <author> John Hughes. </author> <title> Why functional programming matters. </title> <type> Technical Report 16, </type> <institution> Programming Methodology Group, University of Goteborg, </institution> <month> November </month> <year> 1984. </year>
Reference-contexts: One important advantage of higher-order programming over traditional imperative programming is its capability for structuring programs (see <ref> [75] </ref> for some cogent arguments and examples). However, a language with sufficiently powerful parameterised modules does not need higher-order functions.
Reference: [76] <author> John Hughes. </author> <title> Abstract interpretations of first order polymorphic functions. </title> <editor> In Cordelia Hall, John Hughes, and John O'Donnell, editors, </editor> <booktitle> Proceedings of the 1988 Glasgow Workshop on Functional Programming, </booktitle> <pages> pages 68-86. </pages> <institution> Computing Science Department, University of Glasgow, </institution> <year> 1989. </year>
Reference-contexts: But because raw lazy evaluation is slow, lazy evaluation enthusiasts have built clever compilers that figure out when an "eager" (i.e., bottom-up or call-by-value) evaluation can be used with exactly the same result; this is called "strictness analysis" <ref> [103, 76] </ref>. OBJ3 is more flexible, because each operator can have its own evaluation strategy. Moreover, the OBJ3 programmer gets this flexibility with minimum effort, because OBJ3 determines a default strategy if none is explicitly given.
Reference: [77] <author> Jean-Pierre Jouannaud and Mitsuhiro Okada. </author> <title> Executable higher-order algebraic specification languages. </title> <booktitle> In Proceedings, 6th Symposium on Logic in Computer Science, </booktitle> <pages> pages 350-361. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: The authors are exploring various extensions of OBJ, in the directions of logic (or relational) programming (the Eqlog system [55, 56]), object-oriented programming (the FOOPS system [58, 68]), concurrent systems programming and concurrent object-oriented programming (Maude [92, 93, 94, 91, 97], higher-order functional programming <ref> [77, 89] </ref>, and LOTOS-style specification for communication protocols [107, 108]. <p> It is worth noting that higher-order specifications can be implemented by higher-order rewriting <ref> [77] </ref>. 49 op t : -&gt; Time . op f0 : Time -&gt; Prop . endo make 2NOT is NOT [NOT [F]*(op f2 to f1)] endm reduce f2 (s s t) iff f0 (t) . ***&gt; should be: true See [43] for a precise statement of the theorem proved here, as
Reference: [78] <author> Jean-Pierre Jouannoud and Claude Marche. </author> <title> Completion modulo associativity, commutativity and identity. </title> <editor> In Alfonso Miola, editor, </editor> <booktitle> Proceedings, DISCO '90, </booktitle> <pages> pages 111-120. </pages> <publisher> Springer, </publisher> <year> 1991. </year> <note> Lecture Notes in Computer Science, Volume 429; to appear in Theoretical Computer Science. </note>
Reference-contexts: Warning: Because associative/commutative matching is an NP-complete problem, a uniformly fast implementation is impossible. The present implementation, based on work of Lincoln [88] extended to OSA along the lines of [50, 81], is reasonably efficient, but cannot be expected to run quickly for really large problems; see also <ref> [78] </ref>. 2.4.2 Identity and Idempotence An identity attribute can be declared for a binary operator. <p> The issues involved in implementing rewriting modulo associativity and identity are surprising subtle, and it is likely that improvements on the techniques that we have used in OBJ3 could be found; see <ref> [80, 78] </ref> for further discussion. 3.2 Opening and Closing Modules A module can be temporarily enriched after it has been defined, by using the command open hModExp i . or, for the last module, just the command open .
Reference: [79] <author> H. Kaphengst and Horst Reichel. </author> <title> Initial algebraic semantics for non-context-free languages. </title> <editor> In Marek Karpinski, editor, </editor> <booktitle> Fundamentals of Computation Theory, </booktitle> <pages> pages 120-126. </pages> <publisher> Springer, </publisher> <year> 1977. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 56. </volume>
Reference-contexts: Algebraic specification languages sometimes use partial functions, which are simply undefined under exceptional conditions. Although this can be developed rigorously, as in <ref> [79] </ref>, it is unsatisfactory in practice because it does not allow error messages or error recovery. For some time, we have been exploring rigorous approaches that allow users to define their own exception conditions, error messages, and exception handling.
Reference: [80] <author> Claude Kirchner. </author> <title> Order sorted equational matching, </title> <note> 1988. In preparation. </note>
Reference-contexts: Warning: Although the current implementation of OBJ3 handles associative rewriting in part through special internal data structures, its way of dealing with subsorts may generate new "extension" equations from given equations that involve associative operators; see <ref> [80] </ref> for further details. In many cases, these new equations are not only unnecessary, but can also greatly slow down reduction. <p> The issues involved in implementing rewriting modulo associativity and identity are surprising subtle, and it is likely that improvements on the techniques that we have used in OBJ3 could be found; see <ref> [80, 78] </ref> for further discussion. 3.2 Opening and Closing Modules A module can be temporarily enriched after it has been defined, by using the command open hModExp i . or, for the last module, just the command open .
Reference: [81] <author> Claude Kirchner, Helene Kirchner, and Jose Meseguer. </author> <title> Operational semantics of OBJ3. </title> <editor> In T. Lepisto and Aarturo Salomaa, editors, </editor> <booktitle> Proceedings, 15th International Colloquium on Automata, Languages and Programming, </booktitle> <address> Tampere, Finland, </address> <month> July 11-15, </month> <year> 1988, </year> <pages> pages 287-301. </pages> <publisher> Springer, </publisher> <year> 1988. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 317. </volume>
Reference-contexts: Release 2 of OBJ3 has been developed at SRI by Timothy Winkler, Patrick Lincoln, Jose Meseguer, and Joseph Goguen. Although the syntax of OBJ3 is close to that of OBJ2, it has a different implementation based on a simpler approach to order sorted rewriting <ref> [81] </ref>, and it also provides much more sophisticated parameterised programming. OBJ2 and OBJ3 can be seen as implementations of Clear, where the logic is chosen to be order sorted equational logic. <p> use it produces the message Error: general sort constraint not currently handled (ignored) 2.3.4 More on the Operational Semantics This section gives an informal introduction to some delicate aspects of OBJ3's operational semantics; fuller treatments of order sorted rewriting, order sorted equational deduction, and retract equations can be found in <ref> [81, 60, 118] </ref>. The aim here is to familiarise OBJ3 users with the basic properties that equations should have for term reduction to behave properly. As already mentioned in Section 2.2, OBJ3 assumes that signatures are regular and coherent, and we maintain this assumption throughout this subsection. <p> OSA foundations for the issues discussed above may be found in <ref> [96, 50, 81, 118] </ref>. We have run many thousands of reductions on many hundreds of examples, often in dozens of variations, and we have hardly ever encountered problems with canonicity. <p> Therefore, not just the original rules, but also all of their "specialisations" to rules with variables having smaller sorts may have to be considered; see <ref> [81] </ref>. 2.4 Attributes It is natural and convenient to consider certain properties of an operator as attributes that are declared at the same time as its syntax. <p> Warning: Because associative/commutative matching is an NP-complete problem, a uniformly fast implementation is impossible. The present implementation, based on work of Lincoln [88] extended to OSA along the lines of <ref> [50, 81] </ref>, is reasonably efficient, but cannot be expected to run quickly for really large problems; see also [78]. 2.4.2 Identity and Idempotence An identity attribute can be declared for a binary operator.
Reference: [82] <author> Jan Willem Klop. </author> <title> Term rewriting systems: A tutorial. </title> <journal> Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> 32 </volume> <pages> 143-182, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Note that an order sorted version of Knuth-Bendix is needed for OBJ3 [118]. Huet and Oppen give a nice survey of rewrite rule theory which develops some connections with general algebra [74]; Klop <ref> [82, 83] </ref> and Dershowitz and Jouannaud [19] have also written useful surveys of this area, that are more up to date. OSA foundations for the issues discussed above may be found in [96, 50, 81, 118].
Reference: [83] <author> Jan Willem Klop. </author> <title> Term rewriting systems: from Church-Rosser to Knuth-Bendix and beyond. </title> <type> Technical Report CS-R9013, </type> <institution> Centre for Mathematics and Computer Science, </institution> <address> May 1990. Amsterdam, the Netherlands. </address> <month> 101 </month>
Reference-contexts: Note that an order sorted version of Knuth-Bendix is needed for OBJ3 [118]. Huet and Oppen give a nice survey of rewrite rule theory which develops some connections with general algebra [74]; Klop <ref> [82, 83] </ref> and Dershowitz and Jouannaud [19] have also written useful surveys of this area, that are more up to date. OSA foundations for the issues discussed above may be found in [96, 50, 81, 118].
Reference: [84] <author> Donald Knuth and Peter Bendix. </author> <title> Simple word problems in universal algebra. </title> <editor> In J. Leech, editor, </editor> <title> Computational Problems in Abstract Algebra. </title> <publisher> Pergamon, </publisher> <year> 1970. </year>
Reference-contexts: Another desirable property for a rule set is termination, in the technical sense that there are no infinite sequences of rewrite rule applications. A rule set that is terminating (in this sense) can be checked for the Church-Rosser property by the Knuth-Bendix algorithm <ref> [84] </ref>; a rule set that is both terminating and Church-Rosser is called canonical.
Reference: [85] <author> John T. Latham. </author> <title> Abstract Pascal: A tutorial introduction. </title> <type> Technical Report Version 2.1, </type> <institution> University of Manchester, Department of Computer Science, </institution> <year> 1987. </year>
Reference-contexts: OBJ2 and OBJ3 can be seen as implementations of Clear, where the logic is chosen to be order sorted equational logic. Other implementations of OBJ1 include UMIST-OBJ from the University of Manchester Institute of Science and Technology [15], Abstract Pascal from the University of Manchester <ref> [85] </ref>, and MC-OBJ from the University of Milan [13]; the first two are written in Pascal and the third in C. In addition, there is a Franz Lisp OBJ2 from Washington State University [119]. UMIST-OBJ is available as a proprietary software product from Gerrard Software, under the name ObjEx.
Reference: [86] <author> Sany Leinwand and Joseph Goguen. </author> <title> Architectural options for the Rewrite Rule Machine. </title> <editor> In Steven Kartashev and Svetlana Kartashev, editors, </editor> <booktitle> Proceedings, Second International Supercomputing Conference, </booktitle> <volume> Volume I, </volume> <pages> pages 63-70. </pages> <publisher> International Supercomputing Institute Inc. </publisher> <address> (St. Petersburg FL), </address> <year> 1987. </year>
Reference-contexts: In addition, OBJ is one of the languages for programming a massively parallel machine that executes rewrite rules directly <ref> [51, 128, 86, 59, 87, 2, 46, 1] </ref>; in fact, we believe that OBJ on such a machine could greatly out-perform a conventional language on a conventional machine, because of the direct concurrent execution of rewrite rules.
Reference: [87] <author> Sany Leinwand, Joseph Goguen, and Timothy Winkler. </author> <title> Cell and ensemble architecture of the Rewrite Rule Machine. </title> <editor> In Hideo Aiso and Kazuhiro Fuchi, editors, </editor> <booktitle> Proceedings, International Conference on Fifth Generation Computer Systems 1988, </booktitle> <pages> pages 869-878. </pages> <institution> Institute for New Generation Computer Technology (ICOT), </institution> <year> 1988. </year>
Reference-contexts: In addition, OBJ is one of the languages for programming a massively parallel machine that executes rewrite rules directly <ref> [51, 128, 86, 59, 87, 2, 46, 1] </ref>; in fact, we believe that OBJ on such a machine could greatly out-perform a conventional language on a conventional machine, because of the direct concurrent execution of rewrite rules. <p> A more efficient version of this algorithm can be used to implement logic (i.e., relational) programming on the Rewrite Rule Machine; see <ref> [59, 87] </ref> for more detail. In this code, a term is either a variable (such as 'X) or else is of the form F [T], where F is an operator symbol (such as 'F) and T is a list of terms; a constant is of the form F [nil].
Reference: [88] <author> Patrick Lincoln and Jim Christian. </author> <title> Adventures in associative-commutative unification. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 8 </volume> <pages> 217-240, </pages> <year> 1989. </year> <note> Also appears in Unification, edited by Claude Kirchner (Academic, </note> <year> 1990), </year> <pages> pages 393-416. </pages>
Reference-contexts: Warning: Because associative/commutative matching is an NP-complete problem, a uniformly fast implementation is impossible. The present implementation, based on work of Lincoln <ref> [88] </ref> extended to OSA along the lines of [50, 81], is reasonably efficient, but cannot be expected to run quickly for really large problems; see also [78]. 2.4.2 Identity and Idempotence An identity attribute can be declared for a binary operator.
Reference: [89] <author> Narciso Mart-Oliet and Jose Meseguer. </author> <title> Inclusions and subtypes. </title> <type> Technical Report SRI-CSL-90-16, </type> <institution> SRI International, Computer Science Lab, </institution> <month> December </month> <year> 1990. </year> <note> Submitted for publication. </note>
Reference-contexts: The authors are exploring various extensions of OBJ, in the directions of logic (or relational) programming (the Eqlog system [55, 56]), object-oriented programming (the FOOPS system [58, 68]), concurrent systems programming and concurrent object-oriented programming (Maude [92, 93, 94, 91, 97], higher-order functional programming <ref> [77, 89] </ref>, and LOTOS-style specification for communication protocols [107, 108]. <p> Also, it is much easier to compile and interpret first-order programs. It is worth noting that Poigne [111] has found some significant difficulties in combining subsorts and higher-order functions, and we hope to have been convincing that subsorts are very useful; however, see also <ref> [89] </ref> where significant progress has been made. Finally, note the experience of many programmers, and not just naive ones, that higher-order notation can be difficult to understand and to use.
Reference: [90] <author> Per Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In Logic, Methodology and Philosophy of Science VI, </booktitle> <pages> pages 153-175. </pages> <address> North-Holand, </address> <year> 1982. </year>
Reference-contexts: addition, it could be useful to combine views, using the same operators that we have discussed for combining modules; however, this is not supported in Release 2 of OBJ3. 4.7 Higher-Order Programming without Higher-Order Functions Higher-order logic seems useful in many areas, including the foundations of mathematics (e.g., type theory <ref> [90] </ref>), extracting programs from correctness proofs of algorithms, describing proof strategies (as in LCF tactics [70]), modeling traditional programming languages (as in Scott-Strachey semantics [116]), and studying the foundations of the programming process.
Reference: [91] <author> Jose Meseguer. </author> <title> A logical theory of concurrent objects. </title> <booktitle> In ECOOP-OOPSLA'90 Conference on Object-Oriented Programming, </booktitle> <address> Ottawa, Canada, </address> <month> October </month> <year> 1990, </year> <pages> pages 101-115. </pages> <publisher> ACM, </publisher> <year> 1990. </year>
Reference-contexts: The authors are exploring various extensions of OBJ, in the directions of logic (or relational) programming (the Eqlog system [55, 56]), object-oriented programming (the FOOPS system [58, 68]), concurrent systems programming and concurrent object-oriented programming (Maude <ref> [92, 93, 94, 91, 97] </ref>, higher-order functional programming [77, 89], and LOTOS-style specification for communication protocols [107, 108]. <p> An alternative approach to object-oriented programming, supporting concurrent objects and general concurrent systems programming, is being developed at SRI in the language Maude <ref> [92, 97, 91] </ref> which uses rewriting logic [93] as a basis for very direct systems modeling.
Reference: [92] <author> Jose Meseguer. </author> <title> Rewriting as a unified model of concurrency. </title> <booktitle> In Proceedings, Concur'90 Conference, Lecture Notes in Computer Science, </booktitle> <volume> Volume 458, </volume> <pages> pages 384-400, </pages> <address> Amsterdam, </address> <month> August </month> <year> 1990. </year> <pages> Springer. </pages>
Reference-contexts: The authors are exploring various extensions of OBJ, in the directions of logic (or relational) programming (the Eqlog system [55, 56]), object-oriented programming (the FOOPS system [58, 68]), concurrent systems programming and concurrent object-oriented programming (Maude <ref> [92, 93, 94, 91, 97] </ref>, higher-order functional programming [77, 89], and LOTOS-style specification for communication protocols [107, 108]. <p> An alternative approach to object-oriented programming, supporting concurrent objects and general concurrent systems programming, is being developed at SRI in the language Maude <ref> [92, 97, 91] </ref> which uses rewriting logic [93] as a basis for very direct systems modeling.
Reference: [93] <author> Jose Meseguer. </author> <title> Conditional rewriting logic as a unified model of concurrency. </title> <journal> Theoretical Computer Science, </journal> <volume> 96(1) </volume> <pages> 73-155, </pages> <year> 1992. </year>
Reference-contexts: The authors are exploring various extensions of OBJ, in the directions of logic (or relational) programming (the Eqlog system [55, 56]), object-oriented programming (the FOOPS system [58, 68]), concurrent systems programming and concurrent object-oriented programming (Maude <ref> [92, 93, 94, 91, 97] </ref>, higher-order functional programming [77, 89], and LOTOS-style specification for communication protocols [107, 108]. <p> In Maude <ref> [97, 93] </ref>, the state, very simply, is given by a term. 33 4.1 Theories Theories are used to express properties of modules and module interfaces. <p> An alternative approach to object-oriented programming, supporting concurrent objects and general concurrent systems programming, is being developed at SRI in the language Maude [92, 97, 91] which uses rewriting logic <ref> [93] </ref> as a basis for very direct systems modeling. Someday, we may implement FOOPlog [58] or MaudeLog, which combine all three major emerging paradigms, the functional, logic, and object oriented. 2OBJ provides the full capabilities of a modern theorem proving environment, including a tactic language, and truth maintenance.
Reference: [94] <author> Jose Meseguer. </author> <title> A logical theory of concurrent objects and its realization in the Maude language. </title> <editor> In Peter Wegner Gul Agha and Aki Yonezawa, editors, </editor> <booktitle> Research Directions in Object-Based Concurrency. </booktitle> <address> MIT, </address> <note> to appear 1993. Also, Technical Report SRI-CSL-92-08, </note> <month> July </month> <year> 1992. </year>
Reference-contexts: The authors are exploring various extensions of OBJ, in the directions of logic (or relational) programming (the Eqlog system [55, 56]), object-oriented programming (the FOOPS system [58, 68]), concurrent systems programming and concurrent object-oriented programming (Maude <ref> [92, 93, 94, 91, 97] </ref>, higher-order functional programming [77, 89], and LOTOS-style specification for communication protocols [107, 108].
Reference: [95] <author> Jose Meseguer and Joseph Goguen. Initiality, </author> <title> induction and computability. </title> <editor> In Maurice Nivat and John Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, </booktitle> <pages> pages 459-541. </pages> <address> Cambridge, </address> <year> 1985. </year>
Reference-contexts: The denotational semantics of OBJ is algebraic, as in the algebraic theory of abstract data types [66, 65, 129, 71], and in particular, the denotation of an OBJ object is an algebra, a collection of sets with functions among them 12 . The initial algebra approach <ref> [65, 95] </ref> takes the unique (up to isomorphism) initial algebra as the "standard," or "most representative" model of a set of equations (there may of course be many other models), i.e., as the representation-independent standard of comparison for correctness. <p> It is shown in [10] (see also <ref> [95] </ref>) that an algebra is initial if and only if it satisfies the following properties: 12 We will see later that the denotation of an OBJ theory is a variety of algebras, that are not in general isomorphic to one another. 13 1. no junk: every element can be named using <p> For canonical systems (as defined in Section 2.4.4 below), the rewrite rule operational semantics agrees with initial algebra semantics, in the sense that the reduced forms constitute an initial algebra (this result was shown in [38]; see also <ref> [95, 127] </ref>). Because OBJ3 is based on order sorted algebra, it is important to note that this result easily extends to this context. OSA, and thus OBJ3, provides a completely general programming formalism, in the sense that any partial computable function can be defined 13 . <p> Details of the mathematical and operational semantics of retracts, using order sorted algebra and order sorted term rewriting, are given in [50] and [60]. 13 This is an as yet unpublished theorem of Dr. Jose Meseguer; see <ref> [5, 95] </ref> for similar results about total computable functions. 14 Warning: Release 2 of OBJ3 does not allow qualified sort names in retracts within terms provided by the user. Now some code that illustrates retracts.
Reference: [96] <author> Jose Meseguer, Joseph Goguen, and Gert Smolka. </author> <title> Order-sorted unification. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 8 </volume> <pages> 383-413, </pages> <year> 1989. </year> <note> Preliminary version appeared as Report CSLI-87-86, </note> <institution> Center for the Study of Language and Information, Stanford University, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: OSA foundations for the issues discussed above may be found in <ref> [96, 50, 81, 118] </ref>. We have run many thousands of reductions on many hundreds of examples, often in dozens of variations, and we have hardly ever encountered problems with canonicity.
Reference: [97] <author> Jose Meseguer and Timothy Winkler. </author> <title> Parallel programming in Maude. </title> <editor> In Jean-Pierre Ban^atre and D. Le Metayer, editors, </editor> <booktitle> Research Directions in High-level Parallel Programming Languages, </booktitle> <pages> pages 253-293. </pages> <publisher> Springer, </publisher> <year> 1992. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 574. </volume>
Reference-contexts: The authors are exploring various extensions of OBJ, in the directions of logic (or relational) programming (the Eqlog system [55, 56]), object-oriented programming (the FOOPS system [58, 68]), concurrent systems programming and concurrent object-oriented programming (Maude <ref> [92, 93, 94, 91, 97] </ref>, higher-order functional programming [77, 89], and LOTOS-style specification for communication protocols [107, 108]. <p> In Maude <ref> [97, 93] </ref>, the state, very simply, is given by a term. 33 4.1 Theories Theories are used to express properties of modules and module interfaces. <p> An alternative approach to object-oriented programming, supporting concurrent objects and general concurrent systems programming, is being developed at SRI in the language Maude <ref> [92, 97, 91] </ref> which uses rewriting logic [93] as a basis for very direct systems modeling.
Reference: [98] <author> Donald Michie. </author> <title> `Memo' functions and machine learning. </title> <journal> Nature, </journal> <volume> 218 </volume> <pages> 19-22, </pages> <month> April </month> <year> 1968. </year>
Reference-contexts: The default strategies computed by the system are non-lazy. 2.4.5 Memoisation Giving an operator the memo attribute causes the results of evaluating a term headed by this operator to be saved; thus the work of reduction is not repeated if that term appears again <ref> [98] </ref>. In OBJ3, the user can give any operators that he wishes the memo attribute, and this is implemented efficiently by using hash tables.
Reference: [99] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17(3) </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: OBJ3 directly supports subsort polymorphism, which is operator overloading that is consistent under subsort restriction (this is further discussed in Section 2.2). By contrast, languages like ML [72], Hope [12] and Miranda [125] support parametric polymorphism, following ideas of Strachey [123] as further developed by Milner <ref> [99] </ref>. OBJ3's parameterised modules also provide a parametric capability, but instantiations are determined by views, rather than by unification; see Section 4.7 for further discussion.
Reference: [100] <author> Peter Mosses. </author> <title> Abstract semantic algebras! In Dines Bjorner, editor, </title> <booktitle> Formal Description of Programming Concepts II, </booktitle> <pages> pages 45-70. </pages> <publisher> IFIP, </publisher> <year> 1983. </year>
Reference-contexts: OBJ has been used for many applications, including debugging algebraic specifications [61], rapid pro-totyping [53], defining programming languages in a way that directly yields an interpreter (see Appendix Section C.2, as well as [62] and some elegant work of Peter Mosses <ref> [100, 101] </ref>), specifying software systems (e.g., the GKS graphics kernel system [20], an Ada configuration manager [32], the MacIntosh QuickDraw program [106], and OBJ itself [15]), and hardware specification, simulation, and verification (see [120] and Section 4.8); some of these applications were done under an experiment sponsored by the British Alvey
Reference: [101] <author> Peter Mosses. </author> <title> A basic semantic algebra. </title> <editor> In Giles Kahn, David MacQueen, and Gordon Plotkin, editors, </editor> <booktitle> Proceedings, International Symposium on the Semantics of Data Types, </booktitle> <pages> pages 87-107. </pages> <publisher> Springer, </publisher> <year> 1985. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 173. </volume>
Reference-contexts: OBJ has been used for many applications, including debugging algebraic specifications [61], rapid pro-totyping [53], defining programming languages in a way that directly yields an interpreter (see Appendix Section C.2, as well as [62] and some elegant work of Peter Mosses <ref> [100, 101] </ref>), specifying software systems (e.g., the GKS graphics kernel system [20], an Ada configuration manager [32], the MacIntosh QuickDraw program [106], and OBJ itself [15]), and hardware specification, simulation, and verification (see [120] and Section 4.8); some of these applications were done under an experiment sponsored by the British Alvey
Reference: [102] <author> Peter Mosses. </author> <title> Unified algebras and institutions. </title> <booktitle> In Proceedings, Fourth Annual Conference on Logic in Computer Science, </booktitle> <pages> pages 304-312. </pages> <publisher> IEEE, </publisher> <year> 1989. </year>
Reference-contexts: Although this paper omits the technical details, OSA is a rigorous mathematical theory. OSA was originally suggested by Goguen in 1978 [36], and is further developed in [60] and [57]; some alternative approaches have been given by Gogolla [33, 34], Mosses <ref> [102] </ref>, Poigne [112, 113], Reynolds [114], Smolka et al. [117, 118], Wadge [126], and others. A survey as of 1993 appears in [49], along with some new generalisations. OBJ3 directly supports subsort polymorphism, which is operator overloading that is consistent under subsort restriction (this is further discussed in Section 2.2).
Reference: [103] <author> Alan Mycroft. </author> <title> Abstract Interpretation and Optimising Transformations for Applicative Programs. </title> <type> PhD thesis, </type> <institution> University of Edingurgh, </institution> <year> 1981. </year> <month> 102 </month>
Reference-contexts: But because raw lazy evaluation is slow, lazy evaluation enthusiasts have built clever compilers that figure out when an "eager" (i.e., bottom-up or call-by-value) evaluation can be used with exactly the same result; this is called "strictness analysis" <ref> [103, 76] </ref>. OBJ3 is more flexible, because each operator can have its own evaluation strategy. Moreover, the OBJ3 programmer gets this flexibility with minimum effort, because OBJ3 determines a default strategy if none is explicitly given.
Reference: [104] <author> A. Nakagawa and Kokichi Futatsugi. </author> <title> Stepwise refinement process with modularity: An algebraic approach. </title> <booktitle> In Proceedings, 11th International Conference on Software Engineering, </booktitle> <pages> pages 166-177. </pages> <publisher> IEEE, </publisher> <year> 1989. </year>
Reference: [105] <author> A. Nakagawa and Kokichi Futatsugi. </author> <title> Software process a la algebra: OBJ for OBJ. </title> <booktitle> In Proceedings, 12th International Conference on Software Engineering, </booktitle> <pages> pages 12-32. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference: [106] <author> Ataru Nakagawa, Kokichi Futatsugi, S. Tomura, and T. Shimizu. </author> <title> Algebraic specification of MacIntosh's QuickDraw using OBJ2. </title> <type> Technical Report Draft, </type> <institution> ElectroTechnical Laboratory, Tsukuba Science City, </institution> <address> Japan, </address> <year> 1987. </year> <booktitle> In Proceedings, Tenth International Conference on Software Engineering, </booktitle> <address> Singapore, </address> <month> April </month> <year> 1988. </year>
Reference-contexts: rapid pro-totyping [53], defining programming languages in a way that directly yields an interpreter (see Appendix Section C.2, as well as [62] and some elegant work of Peter Mosses [100, 101]), specifying software systems (e.g., the GKS graphics kernel system [20], an Ada configuration manager [32], the MacIntosh QuickDraw program <ref> [106] </ref>, and OBJ itself [15]), and hardware specification, simulation, and verification (see [120] and Section 4.8); some of these applications were done under an experiment sponsored by the British Alvey Project.
Reference: [107] <author> Kazuhito Ohmaki, Kokichi Futatsugi, and Koichi Takahashi. </author> <title> A basic LOTOS simulator in OBJ. </title> <booktitle> In Proceedings, International Conference Commemorating the 30th Anniversary of the Information Processing Society of Japan, </booktitle> <pages> pages 497-504. </pages> <booktitle> Information Processing Society of Japan, </booktitle> <year> 1990. </year>
Reference-contexts: are exploring various extensions of OBJ, in the directions of logic (or relational) programming (the Eqlog system [55, 56]), object-oriented programming (the FOOPS system [58, 68]), concurrent systems programming and concurrent object-oriented programming (Maude [92, 93, 94, 91, 97], higher-order functional programming [77, 89], and LOTOS-style specification for communication protocols <ref> [107, 108] </ref>.
Reference: [108] <author> Kazuhito Ohmaki, Koichi Takahashi, and Kokichi Futatsugi. </author> <title> A LOTOS simulator in OBJ. </title> <booktitle> In Proceedings, FORTE'90: Third International Conference on Formal Description Techniques, </booktitle> <month> November </month> <year> 1990. </year>
Reference-contexts: are exploring various extensions of OBJ, in the directions of logic (or relational) programming (the Eqlog system [55, 56]), object-oriented programming (the FOOPS system [58, 68]), concurrent systems programming and concurrent object-oriented programming (Maude [92, 93, 94, 91, 97], higher-order functional programming [77, 89], and LOTOS-style specification for communication protocols <ref> [107, 108] </ref>.
Reference: [109] <author> Lawrence Paulson. </author> <title> Logic and Computation: Interactive Proof with Cambridge LCF. Cambridge, </title> <booktitle> 1987. Cambridge Tracts in Theoretical Computer Science, </booktitle> <volume> Volume 2. </volume>
Reference-contexts: The above two proofs show that we are entitled to use associative-commutative rewriting for +, and we do so below. It is interesting to contrast the above proofs with corresponding proofs due to Paulson in Cambridge LCF <ref> [109] </ref>. The LCF proofs are much more complex, in part because LCF functions are partial, and therefore must be proved total, whereas functions are automatically total (on their domain) in equational logic.
Reference: [110] <author> David Plaisted. </author> <title> An initial algebra semantics for error presentations. </title> <institution> SRI International, Computer Science Laboratory, </institution> <year> 1982. </year>
Reference-contexts: For some time, we have been exploring rigorous approaches that allow users to define their own exception conditions, error messages, and exception handling. OBJT and OBJ1 used error algebras [35], which sometimes fail to have initial models <ref> [110] </ref>; however, the current approach based on OSA seems entirely satisfactory to us. As a simple example, let's consider the natural and rational numbers, with sorts Nat &lt; Rat.
Reference: [111] <author> Axel Poigne. </author> <title> On semantic algebras: Higher order structures. </title> <institution> Informatik II, Universitat Dortmund, </institution> <year> 1983. </year>
Reference-contexts: The simplest case is first-order functions with first-order logic, and this is the case that parameterised programming focuses upon. Also, it is much easier to compile and interpret first-order programs. It is worth noting that Poigne <ref> [111] </ref> has found some significant difficulties in combining subsorts and higher-order functions, and we hope to have been convincing that subsorts are very useful; however, see also [89] where significant progress has been made.
Reference: [112] <author> Axel Poigne. </author> <title> Once more on order-sorted algebra. </title> <type> Technical Report Draft, </type> <institution> GMD, </institution> <year> 1990. </year>
Reference-contexts: Although this paper omits the technical details, OSA is a rigorous mathematical theory. OSA was originally suggested by Goguen in 1978 [36], and is further developed in [60] and [57]; some alternative approaches have been given by Gogolla [33, 34], Mosses [102], Poigne <ref> [112, 113] </ref>, Reynolds [114], Smolka et al. [117, 118], Wadge [126], and others. A survey as of 1993 appears in [49], along with some new generalisations. OBJ3 directly supports subsort polymorphism, which is operator overloading that is consistent under subsort restriction (this is further discussed in Section 2.2).
Reference: [113] <author> Axel Poigne. </author> <title> Parameterization for order-sorted algebraic specification. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 40(3) </volume> <pages> 229-268, </pages> <year> 1990. </year>
Reference-contexts: Although this paper omits the technical details, OSA is a rigorous mathematical theory. OSA was originally suggested by Goguen in 1978 [36], and is further developed in [60] and [57]; some alternative approaches have been given by Gogolla [33, 34], Mosses [102], Poigne <ref> [112, 113] </ref>, Reynolds [114], Smolka et al. [117, 118], Wadge [126], and others. A survey as of 1993 appears in [49], along with some new generalisations. OBJ3 directly supports subsort polymorphism, which is operator overloading that is consistent under subsort restriction (this is further discussed in Section 2.2).
Reference: [114] <author> John Reynolds. </author> <title> Using category theory to design implicit conversions and generic operators. </title> <editor> In Neal Jones, editor, </editor> <booktitle> Semantics Directed Compiler Generation, </booktitle> <pages> pages 211-258. </pages> <publisher> Springer, </publisher> <year> 1980. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 94. </volume>
Reference-contexts: Although this paper omits the technical details, OSA is a rigorous mathematical theory. OSA was originally suggested by Goguen in 1978 [36], and is further developed in [60] and [57]; some alternative approaches have been given by Gogolla [33, 34], Mosses [102], Poigne [112, 113], Reynolds <ref> [114] </ref>, Smolka et al. [117, 118], Wadge [126], and others. A survey as of 1993 appears in [49], along with some new generalisations. OBJ3 directly supports subsort polymorphism, which is operator overloading that is consistent under subsort restriction (this is further discussed in Section 2.2).
Reference: [115] <author> Augusto Sampaio. </author> <title> A comparative study of theorem provers: Proving correctness of compiling specifications. </title> <type> Technical Report PRG-TR-20-90, </type> <institution> Oxford University Computing Laboratory, </institution> <year> 1990. </year>
Reference-contexts: OBJ is also being combined with Petri nets, thus allowing structured data in tokens [4], and is being used to verify compilers for parallel programming languages in the ESPRIT sponsored PROCOS project <ref> [115] </ref>.
Reference: [116] <author> Dana Scott and Christopher Strachey. </author> <title> Towards a mathematical semantics for computer languages. </title> <booktitle> In Proceedings, 21st Symposium on Computers and Automata, </booktitle> <pages> pages 19-46. </pages> <institution> Polytechnic Institute of Brooklyn, </institution> <year> 1971. </year> <note> Also, </note> <institution> Programming Research Group Technical Monograph PRG-6, Oxford University. </institution>
Reference-contexts: in Release 2 of OBJ3. 4.7 Higher-Order Programming without Higher-Order Functions Higher-order logic seems useful in many areas, including the foundations of mathematics (e.g., type theory [90]), extracting programs from correctness proofs of algorithms, describing proof strategies (as in LCF tactics [70]), modeling traditional programming languages (as in Scott-Strachey semantics <ref> [116] </ref>), and studying the foundations of the programming process. One important advantage of higher-order programming over traditional imperative programming is its capability for structuring programs (see [75] for some cogent arguments and examples). However, a language with sufficiently powerful parameterised modules does not need higher-order functions.
Reference: [117] <author> Gert Smolka and Hassan At-Kaci. </author> <title> Inheritance hierarchies: Semantics and unification. </title> <type> Technical Report Report AI-057-87, </type> <institution> MCC, </institution> <year> 1987. </year> <note> In Journal of Symbolic Computation, </note> <year> 1988. </year>
Reference-contexts: OSA was originally suggested by Goguen in 1978 [36], and is further developed in [60] and [57]; some alternative approaches have been given by Gogolla [33, 34], Mosses [102], Poigne [112, 113], Reynolds [114], Smolka et al. <ref> [117, 118] </ref>, Wadge [126], and others. A survey as of 1993 appears in [49], along with some new generalisations. OBJ3 directly supports subsort polymorphism, which is operator overloading that is consistent under subsort restriction (this is further discussed in Section 2.2).
Reference: [118] <author> Gert Smolka, Werner Nutt, Joseph Goguen, and Jose Meseguer. </author> <title> Order-sorted equational computation. </title> <editor> In Maurice Nivat and Hassan At-Kaci, editors, </editor> <title> Resolution of Equations in Algebraic Structures, </title> <booktitle> Volume 2: Rewriting Techniques, </booktitle> <pages> pages 299-367. </pages> <publisher> Academic, </publisher> <year> 1989. </year> <title> Preliminary version in Proceedings, Colloquium on the Resolution of Equations in Algebraic Structures, held in Lakeway, </title> <address> Texas, </address> <month> May </month> <year> 1987, </year> <note> and SEKI Report SR-87-14, </note> <institution> Universitat Kaiserslautern, </institution> <month> December </month> <year> 1987. </year>
Reference-contexts: OBJ2 [27, 28] was implemented using parts of OBJ1 during 1984-85 at SRI by Kokichi Futatsugi and Jean-Pierre Jouannaud, following a design in which Jose Meseguer and Joseph Goguen also participated, based on order sorted algebra <ref> [36, 60, 50, 57, 118] </ref> rather than error algebra; also, OBJ2 provided Clear-like parameterised modules, theories, and views, although not in full generality. Another influence on OBJ3's design and implementation was the HISP system [30, 31, 22]. <p> OSA was originally suggested by Goguen in 1978 [36], and is further developed in [60] and [57]; some alternative approaches have been given by Gogolla [33, 34], Mosses [102], Poigne [112, 113], Reynolds [114], Smolka et al. <ref> [117, 118] </ref>, Wadge [126], and others. A survey as of 1993 appears in [49], along with some new generalisations. OBJ3 directly supports subsort polymorphism, which is operator overloading that is consistent under subsort restriction (this is further discussed in Section 2.2). <p> use it produces the message Error: general sort constraint not currently handled (ignored) 2.3.4 More on the Operational Semantics This section gives an informal introduction to some delicate aspects of OBJ3's operational semantics; fuller treatments of order sorted rewriting, order sorted equational deduction, and retract equations can be found in <ref> [81, 60, 118] </ref>. The aim here is to familiarise OBJ3 users with the basic properties that equations should have for term reduction to behave properly. As already mentioned in Section 2.2, OBJ3 assumes that signatures are regular and coherent, and we maintain this assumption throughout this subsection. <p> The Knuth-Bendix algorithm extends to a completion procedure that may produce a canonical rule set from one that is terminating. Note that an order sorted version of Knuth-Bendix is needed for OBJ3 <ref> [118] </ref>. Huet and Oppen give a nice survey of rewrite rule theory which develops some connections with general algebra [74]; Klop [82, 83] and Dershowitz and Jouannaud [19] have also written useful surveys of this area, that are more up to date. <p> OSA foundations for the issues discussed above may be found in <ref> [96, 50, 81, 118] </ref>. We have run many thousands of reductions on many hundreds of examples, often in dozens of variations, and we have hardly ever encountered problems with canonicity.
Reference: [119] <author> S. Sridhar. </author> <title> An implementation of OBJ2: An object-oriented language for abstract program specification. </title> <editor> In K.V. Nori, editor, </editor> <booktitle> Proceedings, Sixth Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 81-95. </pages> <publisher> Springer, </publisher> <year> 1986. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 241. </volume>
Reference-contexts: In addition, there is a Franz Lisp OBJ2 from Washington State University <ref> [119] </ref>. UMIST-OBJ is available as a proprietary software product from Gerrard Software, under the name ObjEx.
Reference: [120] <author> Victoria Stavridou. </author> <title> Specifying in OBJ, verifying in REVE, and some ideas about time. </title> <type> Technical Report Draft, </type> <institution> Department of Computer Science, University of Manchester, </institution> <year> 1987. </year>
Reference-contexts: an interpreter (see Appendix Section C.2, as well as [62] and some elegant work of Peter Mosses [100, 101]), specifying software systems (e.g., the GKS graphics kernel system [20], an Ada configuration manager [32], the MacIntosh QuickDraw program [106], and OBJ itself [15]), and hardware specification, simulation, and verification (see <ref> [120] </ref> and Section 4.8); some of these applications were done under an experiment sponsored by the British Alvey Project.
Reference: [121] <author> Victoria Stavridou, Joseph Goguen, Steven Eker, and Serge Aloneftis. FUNNEL: </author> <title> A CHDL with formal semantics. </title> <booktitle> In Proceedings, Advanced Research Workshop on Correct Hardware Design Methodologies, </booktitle> <pages> pages 117-144. </pages> <publisher> IEEE, </publisher> <year> 1991. </year> <note> Turin. 103 </note>
Reference-contexts: The same techniques seem effective for much more complex examples of hardware specification, simulation and verification, and many more examples are given in [43] and [45], along with supporting theory. The application of 2OBJ [63] to hardware verification is described in <ref> [121] </ref> and [122]. 5 Applying Rules Release 2 of OBJ3 allows users to apply rules one at a time to a given term, either "forwards" or "backwards" (i.e., either replacing an instance of the lefthand side by the corresponding instance of the righthand side, or else vice versa).
Reference: [122] <author> Victoria Stavridou, Joseph Goguen, Andrew Stevens, Steven Eker, Serge Aloneftis, and Keith Hobley. FUNNEL and 2OBJ: </author> <title> towards an integrated hardware design environment. In Theorem Provers in Circuit Design, </title> <journal> volume IFIP Transactions, </journal> <volume> A-10, </volume> <pages> pages 197-223. </pages> <publisher> North-Holland, </publisher> <year> 1992. </year>
Reference-contexts: The same techniques seem effective for much more complex examples of hardware specification, simulation and verification, and many more examples are given in [43] and [45], along with supporting theory. The application of 2OBJ [63] to hardware verification is described in [121] and <ref> [122] </ref>. 5 Applying Rules Release 2 of OBJ3 allows users to apply rules one at a time to a given term, either "forwards" or "backwards" (i.e., either replacing an instance of the lefthand side by the corresponding instance of the righthand side, or else vice versa).
Reference: [123] <author> Christopher Strachey. </author> <title> Fundamental concepts in programming languages. </title> <booktitle> Lecture Notes from International Summer School in Computer Programming, </booktitle> <address> Copenhagen, </address> <year> 1967. </year>
Reference-contexts: OBJ3 directly supports subsort polymorphism, which is operator overloading that is consistent under subsort restriction (this is further discussed in Section 2.2). By contrast, languages like ML [72], Hope [12] and Miranda [125] support parametric polymorphism, following ideas of Strachey <ref> [123] </ref> as further developed by Milner [99]. OBJ3's parameterised modules also provide a parametric capability, but instantiations are determined by views, rather than by unification; see Section 4.7 for further discussion.
Reference: [124] <author> Joseph Tardo. </author> <title> The Design, Specification and Implementation of OBJT: A Language for Writing and Testing Abstract Algebraic Program Specifications. </title> <type> PhD thesis, </type> <institution> UCLA, Computer Science Department, </institution> <year> 1981. </year>
Reference-contexts: First implementations of OBJ were done from 1977 to 1979 at UCLA by Joseph Tardo and Joseph Goguen. OBJ0 [37] was based on unsorted equational logic, while OBJT used error algebras plus an "image" construct for parameterisation <ref> [124, 64] </ref>.
Reference: [125] <author> David Turner. Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <editor> In Jean-Pierre Jouannaud, editor, </editor> <booktitle> Functional Programming Languages and Computer Architectures, </booktitle> <pages> pages 1-16. </pages> <publisher> Springer, </publisher> <year> 1985. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 201. </volume>
Reference-contexts: A survey as of 1993 appears in [49], along with some new generalisations. OBJ3 directly supports subsort polymorphism, which is operator overloading that is consistent under subsort restriction (this is further discussed in Section 2.2). By contrast, languages like ML [72], Hope [12] and Miranda <ref> [125] </ref> support parametric polymorphism, following ideas of Strachey [123] as further developed by Milner [99]. OBJ3's parameterised modules also provide a parametric capability, but instantiations are determined by views, rather than by unification; see Section 4.7 for further discussion.
Reference: [126] <author> William Wadge. </author> <title> Classified algebras. </title> <type> Technical Report 46, </type> <institution> University of Warwick, </institution> <month> October </month> <year> 1982. </year>
Reference-contexts: OSA was originally suggested by Goguen in 1978 [36], and is further developed in [60] and [57]; some alternative approaches have been given by Gogolla [33, 34], Mosses [102], Poigne [112, 113], Reynolds [114], Smolka et al. [117, 118], Wadge <ref> [126] </ref>, and others. A survey as of 1993 appears in [49], along with some new generalisations. OBJ3 directly supports subsort polymorphism, which is operator overloading that is consistent under subsort restriction (this is further discussed in Section 2.2).
Reference: [127] <author> Mitchell Wand. </author> <title> First-order identities as a defining language. </title> <journal> Acta Informatica, </journal> <volume> 14 </volume> <pages> 337-357, </pages> <year> 1980. </year> <type> Originally Report 29, </type> <institution> Computer Science Deptartment, Indiana University, </institution> <year> 1977. </year>
Reference-contexts: For canonical systems (as defined in Section 2.4.4 below), the rewrite rule operational semantics agrees with initial algebra semantics, in the sense that the reduced forms constitute an initial algebra (this result was shown in [38]; see also <ref> [95, 127] </ref>). Because OBJ3 is based on order sorted algebra, it is important to note that this result easily extends to this context. OSA, and thus OBJ3, provides a completely general programming formalism, in the sense that any partial computable function can be defined 13 .
Reference: [128] <author> Timothy Winkler, Sany Leinwand, and Joseph Goguen. </author> <title> Simulation of concurrent term rewriting. </title> <editor> In Steven Kartashev and Svetlana Kartashev, editors, </editor> <booktitle> Proceedings, Second International Supercomputing Conference, </booktitle> <volume> Volume I, </volume> <pages> pages 199-208. </pages> <publisher> International Supercomputing Institute Inc. </publisher> <address> (St. Petersburg FL), </address> <year> 1987. </year>
Reference-contexts: In addition, OBJ is one of the languages for programming a massively parallel machine that executes rewrite rules directly <ref> [51, 128, 86, 59, 87, 2, 46, 1] </ref>; in fact, we believe that OBJ on such a machine could greatly out-perform a conventional language on a conventional machine, because of the direct concurrent execution of rewrite rules.
Reference: [129] <author> Steven Zilles. </author> <title> Abstract specification of data types. </title> <type> Technical Report 119, </type> <institution> Computation Structures Group, Massachusetts Institute of Technology, </institution> <year> 1974. </year> <month> 104 </month>
Reference-contexts: The denotational semantics of OBJ is algebraic, as in the algebraic theory of abstract data types <ref> [66, 65, 129, 71] </ref>, and in particular, the denotation of an OBJ object is an algebra, a collection of sets with functions among them 12 .
References-found: 129

