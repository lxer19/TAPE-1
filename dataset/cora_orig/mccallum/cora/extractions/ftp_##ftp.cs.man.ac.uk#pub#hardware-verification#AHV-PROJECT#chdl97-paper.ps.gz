URL: ftp://ftp.cs.man.ac.uk/pub/hardware-verification/AHV-PROJECT/chdl97-paper.ps.gz
Refering-URL: http://www.cs.man.ac.uk/fmethods/projects/AHV-PROJECT/node18.html
Root-URL: http://www.cs.man.ac.uk
Email: email: fhoward,fellowsd,graham,alanwg@cs.man.ac.uk  
Phone: phone: (+44) 161-275-6248 fax: (+44) 161-275-6211  
Author: Barringer, Donal Fellows, Graham Gough, Alan Williams Howard Barringer 
Keyword: CHDL'97 Topics: Hardware Description Languages, Formal Methods, Design Systems and Tools.  
Address: Manchester, UK  MANCHESTER M13 9PL, UK  
Affiliation: Department of Computer Science, University of  Department of Computer Science, University of Manchester,  
Note: Submission to CHDL'97 Howard  correspondence: Professor  The University of Manchester acknowledges support from the Engineering and Physical Sciences Research Council via research grant GR/K42073.  
Abstract: Modelling of Asynchronous Micropipeline Systems Abstract We consider Sutherland's Micropipeline methodology for asynchronous hardware systems and highlight problems of design representation. The Rainbow hardware design framework supports such description, simulation and analysis of micropipeline systems. It provides a set of sub-languages each offering a different description style. Components described in the different languages can be fully integrated within a single design. The framework offers abstract design description and rapid simulation at a high level for early simulation and analysis. using Rainbow
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.D. Morison and A.S. Clarke. ELLA2000: </author> <title> A Language for Electronic System Design. </title> <publisher> McGraw-Hill, </publisher> <address> Maidenhead, Berkshire, England, </address> <year> 1993. </year>
Reference-contexts: Fast prototyping, early simulation and experimentation, and sophisticated design synthesis tools <ref> [1, 2] </ref> are available to the hardware engineer. However, most chip level digital systems developed have operated synchronously, using a global clocking strategy.
Reference: [2] <author> Louis Baker. </author> <title> VHDL Programming With Advanced Topices. </title> <publisher> Wiley, </publisher> <year> 1993. </year>
Reference-contexts: Fast prototyping, early simulation and experimentation, and sophisticated design synthesis tools <ref> [1, 2] </ref> are available to the hardware engineer. However, most chip level digital systems developed have operated synchronously, using a global clocking strategy.
Reference: [3] <author> S. Furber. </author> <title> Computing Without Clocks: Mi-cropipelining the ARM Processor. </title> <editor> In Graham Birtwistle and Al Davis, editors, </editor> <booktitle> Asynchronous Digital Circuit Design, </booktitle> <pages> pages 211262. </pages> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: For example, the AMULET Group at Manchester have been investigating the design of asynchronous code-compatible versions of the ARM processor <ref> [3] </ref>. The first version of the AMULET1 processor has offered performance only comparable to its synchronous counterpart. <p> We give instances of transition rules for the various basic elements used and then compose these using rules for pipe and parallel 3 . The following transition rules show how a full buffer can output its value to become empty, and vice versa 4 : B <ref> [3] </ref> ! B [] B [] ! B [8] We can also perform a `postponed' action, such as `(ch 1 !5)', where a process term indicates that it can potentially perform a particular transition, but it does not actually change state: B [5] ! B [5] The `Dup' process can produce <p> and in the second the input channel to the buffer has been renamed ch 6 . 11 B [5] ! B [5] (ch 1 ?5) = ch 2 !5 Pipe B [5] &gt;> Dup ! B [5] &gt;> Dup ch 3 !5 ch 2 ?5 = ch 5 !5 B <ref> [3] </ref> ! B [] Id j B [3] ! Id j B [] For the parallel operator, each component can evolve independently. For the pipe operator, the output (s) of the first component must match the input (s) of the following component. <p> to the buffer has been renamed ch 6 . 11 B [5] ! B [5] (ch 1 ?5) = ch 2 !5 Pipe B [5] &gt;> Dup ! B [5] &gt;> Dup ch 3 !5 ch 2 ?5 = ch 5 !5 B <ref> [3] </ref> ! B [] Id j B [3] ! Id j B [] For the parallel operator, each component can evolve independently. For the pipe operator, the output (s) of the first component must match the input (s) of the following component. <p> These separate stages can now be assembled, again using the pipe rule: B [5] &gt;> Dup ! B [5] &gt;> Dup ch 3 !5 ch 2 ?5 = ch 5 !5;ch 4 !3 Add ! Add ch 6 ?8 Pipe B [5] &gt;> Dup &gt;> (Id j B <ref> [3] </ref>) &gt;> Add &gt;> B [] &gt;> ! Therule has been applied several times, so that all of the components are `connected'. The effect of the transition is for the adder to compute the next Fibonacci number (5+3) and store this in buffer C, with buffer B emptying. <p> One of the values from the Dup element has been consumed, the second is ready to be written to buffer B in the next step. The two transitions for calculating the next Fibonacci number are as follows: B [5] &gt;> Dup &gt;> (Id j B <ref> [3] </ref>) &gt;> Add &gt;> B [] ! B [5] &gt;> Dup o 2 !5 &gt;> (Id j B []) &gt;> Add &gt;> B [8] ! B [] &gt;> Dup &gt;> (Id j B []) &gt;> Add &gt;> B [8] 5 Summary We have outlined the problems encountered in hardware design and
Reference: [4] <author> I. Sutherland. </author> <title> Micropipelines. </title> <journal> Communications of the ACM, </journal> <volume> 32(6), </volume> <month> June </month> <year> 1989. </year>
Reference-contexts: The renewed interest in asynchronous design has been supported by the emergence of novel design methodologies, in particular Sutherland's Micropipeline method <ref> [4] </ref>, which simplify somewhat the design process by defining reliable methods for circuit composition the AMULET design largely follows this style. <p> We then introduce Rainbow (section 3) and describe how designs are modelled. Section 3.1 then contains an example based on part of the AMULET1 processor. Finally the underlying semantics for Rainbow is outlined (section 4). 2 Micropipelines In his Turing Award Lecture <ref> [4] </ref>, Sutherland describes the Micropipeline approach for achieving modularity and composibility for asynchronous design elements. A micropipeline contains buffers which use a simple request/acknowledge handshake communication in order to transfer data from one buffer to the next. Stateless functional elements are introduced between buffer stages. <p> The buffer can now change the output value by accepting a new value on its input for storage. The key to this simple protocol is the bundled-data assumption <ref> [4] </ref>. This ensures that when a request is received, then the data value associated with the request is ready for consumption and that it will be maintained until an acknowledge is sent. <p> This consists of a datapath, with two buffers holding data values x and y. Data is input via d 0 and output via d 2 , transferring between the latches via d 1 . The remainder of the circuit shows the request/acknowledge control, which can be implemented via transition-signalling <ref> [4] </ref>. The exact value of the control signals is not important, only that they have changed. It is therefore only necessary to consider events in the control. Micropipeline components are constructed from basic control and data elements. <p> The latches then store data values, being controlled by the request/acknowledge events. Other low-level event control elements are described in <ref> [4] </ref>. Consider how the micropipeline outputs y and then moves x from buffer P to buffer Q. The signal 3 diagram in Figure 1 shows the ordering relation between events, with bullets indicating when event occur on the control wires.
Reference: [5] <author> K. van Berkel. </author> <title> Handshake Circuits: an Intermediary between Communicating Processes and VLSI. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology, </institution> <year> 1992. </year>
Reference-contexts: Although certain asynchronous design methods, such as Philip's Tangram system <ref> [5] </ref>, are also equipped design description languages, these have not yet emerged for micropipelines, especially for higher-level abstract description (however, a Tangram-like approach to micropipeline description is currently being investigated at Manchester). <p> become empty, and vice versa 4 : B [3] ! B [] B [] ! B [8] We can also perform a `postponed' action, such as `(ch 1 !5)', where a process term indicates that it can potentially perform a particular transition, but it does not actually change state: B <ref> [5] </ref> ! B [5] The `Dup' process can produce its outputs independently, storing the other unconsumed action for output later: Dup ! Dup ch 3 !5 Note that the input action is postponed and is therefore not consumed at this stage. <p> vice versa 4 : B [3] ! B [] B [] ! B [8] We can also perform a `postponed' action, such as `(ch 1 !5)', where a process term indicates that it can potentially perform a particular transition, but it does not actually change state: B <ref> [5] </ref> ! B [5] The `Dup' process can produce its outputs independently, storing the other unconsumed action for output later: Dup ! Dup ch 3 !5 Note that the input action is postponed and is therefore not consumed at this stage. <p> For example, in the first buffer transition, the output channel for the buffer has already been renamed ch 3 , and in the second the input channel to the buffer has been renamed ch 6 . 11 B <ref> [5] </ref> ! B [5] (ch 1 ?5) = ch 2 !5 Pipe B [5] &gt;> Dup ! B [5] &gt;> Dup ch 3 !5 ch 2 ?5 = ch 5 !5 B [3] ! B [] Id j B [3] ! Id j B [] For the parallel operator, each component <p> For example, in the first buffer transition, the output channel for the buffer has already been renamed ch 3 , and in the second the input channel to the buffer has been renamed ch 6 . 11 B <ref> [5] </ref> ! B [5] (ch 1 ?5) = ch 2 !5 Pipe B [5] &gt;> Dup ! B [5] &gt;> Dup ch 3 !5 ch 2 ?5 = ch 5 !5 B [3] ! B [] Id j B [3] ! Id j B [] For the parallel operator, each component can evolve independently. <p> example, in the first buffer transition, the output channel for the buffer has already been renamed ch 3 , and in the second the input channel to the buffer has been renamed ch 6 . 11 B <ref> [5] </ref> ! B [5] (ch 1 ?5) = ch 2 !5 Pipe B [5] &gt;> Dup ! B [5] &gt;> Dup ch 3 !5 ch 2 ?5 = ch 5 !5 B [3] ! B [] Id j B [3] ! Id j B [] For the parallel operator, each component can evolve independently. <p> transition, the output channel for the buffer has already been renamed ch 3 , and in the second the input channel to the buffer has been renamed ch 6 . 11 B <ref> [5] </ref> ! B [5] (ch 1 ?5) = ch 2 !5 Pipe B [5] &gt;> Dup ! B [5] &gt;> Dup ch 3 !5 ch 2 ?5 = ch 5 !5 B [3] ! B [] Id j B [3] ! Id j B [] For the parallel operator, each component can evolve independently. <p> For the pipe operator, the output (s) of the first component must match the input (s) of the following component. These separate stages can now be assembled, again using the pipe rule: B <ref> [5] </ref> &gt;> Dup ! B [5] &gt;> Dup ch 3 !5 ch 2 ?5 = ch 5 !5;ch 4 !3 Add ! Add ch 6 ?8 Pipe B [5] &gt;> Dup &gt;> (Id j B [3]) &gt;> Add &gt;> B [] &gt;> ! Therule has been applied several times, so that <p> For the pipe operator, the output (s) of the first component must match the input (s) of the following component. These separate stages can now be assembled, again using the pipe rule: B <ref> [5] </ref> &gt;> Dup ! B [5] &gt;> Dup ch 3 !5 ch 2 ?5 = ch 5 !5;ch 4 !3 Add ! Add ch 6 ?8 Pipe B [5] &gt;> Dup &gt;> (Id j B [3]) &gt;> Add &gt;> B [] &gt;> ! Therule has been applied several times, so that all of the components are <p> These separate stages can now be assembled, again using the pipe rule: B <ref> [5] </ref> &gt;> Dup ! B [5] &gt;> Dup ch 3 !5 ch 2 ?5 = ch 5 !5;ch 4 !3 Add ! Add ch 6 ?8 Pipe B [5] &gt;> Dup &gt;> (Id j B [3]) &gt;> Add &gt;> B [] &gt;> ! Therule has been applied several times, so that all of the components are `connected'. <p> One of the values from the Dup element has been consumed, the second is ready to be written to buffer B in the next step. The two transitions for calculating the next Fibonacci number are as follows: B <ref> [5] </ref> &gt;> Dup &gt;> (Id j B [3]) &gt;> Add &gt;> B [] ! B [5] &gt;> Dup o 2 !5 &gt;> (Id j B []) &gt;> Add &gt;> B [8] ! B [] &gt;> Dup &gt;> (Id j B []) &gt;> Add &gt;> B [8] 5 Summary We have outlined <p> The two transitions for calculating the next Fibonacci number are as follows: B <ref> [5] </ref> &gt;> Dup &gt;> (Id j B [3]) &gt;> Add &gt;> B [] ! B [5] &gt;> Dup o 2 !5 &gt;> (Id j B []) &gt;> Add &gt;> B [8] ! B [] &gt;> Dup &gt;> (Id j B []) &gt;> Add &gt;> B [8] 5 Summary We have outlined the problems encountered in hardware design and the potential benefits of adopting an asynchronous design
Reference: [6] <author> A.J. Martin. </author> <title> Programming in VLSI: From Communicating Process to Delay-Insensitive Circuits. In C.A.R. Hoare, editor, </title> <booktitle> Developments in Concur-rency and Communication, </booktitle> <pages> pages 164. </pages> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: In practice this means that a possibly data-dependent delay needs to be introduced so that a request signal is not sent until data is ready, having passed through any functional circuits connected to the buffer. If this assumption is satisfied then the resulting circuit elements are delay-insensitive <ref> [6] </ref>, so that it is easy to compose elements operating at different processing speeds and still achieve correct functioning.
Reference: [7] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking: An Approach to the State Explosion Problem. </title> <type> Technical Report CMU-CS-92-131, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: At present the only method available to the designer for performance estimation and deadlock detection is via intensive low-level simulation. At the research level, verification tools such as SMV <ref> [7] </ref> or Petri nets [8] are being developed and performance estimation techniques using timed process algebra have been investigated [9]. Let us now describe the operation of a micropipeline in more detail, in order to highlight the problems involved in design representation.
Reference: [8] <author> A. Yakovlev, V. Varshavsky, V. Marakhovsky, and A. Semenov. </author> <title> Designing an Asynchronous Pipeline Token Ring Interface. In Asynchronous Design Methodologies, </title> <institution> South Bank University, </institution> <address> London, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: At present the only method available to the designer for performance estimation and deadlock detection is via intensive low-level simulation. At the research level, verification tools such as SMV [7] or Petri nets <ref> [8] </ref> are being developed and performance estimation techniques using timed process algebra have been investigated [9]. Let us now describe the operation of a micropipeline in more detail, in order to highlight the problems involved in design representation. Figure 1 shows a two-stage micropipeline without any intermediate function. <p> The following transition rules show how a full buffer can output its value to become empty, and vice versa 4 : B [3] ! B [] B [] ! B <ref> [8] </ref> We can also perform a `postponed' action, such as `(ch 1 !5)', where a process term indicates that it can potentially perform a particular transition, but it does not actually change state: B [5] ! B [5] The `Dup' process can produce its outputs independently, storing the other unconsumed action <p> The two transitions for calculating the next Fibonacci number are as follows: B [5] &gt;> Dup &gt;> (Id j B [3]) &gt;> Add &gt;> B [] ! B [5] &gt;> Dup o 2 !5 &gt;> (Id j B []) &gt;> Add &gt;> B <ref> [8] </ref> ! B [] &gt;> Dup &gt;> (Id j B []) &gt;> Add &gt;> B [8] 5 Summary We have outlined the problems encountered in hardware design and the potential benefits of adopting an asynchronous design style in comparison to the traditional synchronous approach. <p> number are as follows: B [5] &gt;> Dup &gt;> (Id j B [3]) &gt;> Add &gt;> B [] ! B [5] &gt;> Dup o 2 !5 &gt;> (Id j B []) &gt;> Add &gt;> B <ref> [8] </ref> ! B [] &gt;> Dup &gt;> (Id j B []) &gt;> Add &gt;> B [8] 5 Summary We have outlined the problems encountered in hardware design and the potential benefits of adopting an asynchronous design style in comparison to the traditional synchronous approach. In particular, Suther-land's Micropipeline design methodology is considered.
Reference: [9] <author> Chris Tofts. </author> <title> Some Formal Musings on the Performance of Asynchronous Hardware. </title> <type> Technical Report UMCS-96-2-2, </type> <institution> Department of Computer Science, University of Manchester, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: At present the only method available to the designer for performance estimation and deadlock detection is via intensive low-level simulation. At the research level, verification tools such as SMV [7] or Petri nets [8] are being developed and performance estimation techniques using timed process algebra have been investigated <ref> [9] </ref>. Let us now describe the operation of a micropipeline in more detail, in order to highlight the problems involved in design representation. Figure 1 shows a two-stage micropipeline without any intermediate function. This consists of a datapath, with two buffers holding data values x and y.
Reference: [10] <author> Ying Liu. AMULET1: </author> <title> Specification and Verification in CCS. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Calgary, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: This relies of course on the values supplied by Dup being consumed independently. 2.1 Low-level Modelling of Micropipelines Formally based models of micropipelines usually capture the request/acknowledge control signalling between components, ignoring data as far as possible. This has been utilised with some success in <ref> [10] </ref> when constructing models of the AMULET1 processor using CCS. Having constructed these models, then the standard tools in the Concurrency Workbench [11] were used to check for deadlock.
Reference: [11] <author> R. Cleaveland, R. Parrow, and J. Steffen. </author> <title> The Concurrency Workbench: A Semantics Based Tool for the Verification of Concurrent Systems. </title> <type> Technical Report ECS-LRCS-89-83, </type> <institution> LFCS, University of Edinburgh, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: This has been utilised with some success in [10] when constructing models of the AMULET1 processor using CCS. Having constructed these models, then the standard tools in the Concurrency Workbench <ref> [11] </ref> were used to check for deadlock.
Reference: [12] <author> C. Tofts and Y. Liu and G. Birtwistle. </author> <title> State Space Reduction for Asynchronous Micropipelines. </title> <booktitle> In Proceedings of the Northern Formal Methods Workshop, </booktitle> <address> Ilkley, UK, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: This means that careful attention needs to be paid during construction of the model in order to control combinatorial explosion in the state-space of the composite CCS terms, by removing request/acknowledge interleavings <ref> [12] </ref>, applying similar ideas to those used in partial order state-space reduction [13]. 3 The Rainbow Approach Micropipeline modelling techniques such as CCS expose all of the internal operation of the request/acknowledge handshake, potentially leading to rapid growth in the state-space of the resulting terms.
Reference: [13] <author> Patrice Godefroid. </author> <title> Partial-Order Methods for the Verification of Concurrent Systems. </title> <booktitle> Number 1032 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: This means that careful attention needs to be paid during construction of the model in order to control combinatorial explosion in the state-space of the composite CCS terms, by removing request/acknowledge interleavings [12], applying similar ideas to those used in partial order state-space reduction <ref> [13] </ref>. 3 The Rainbow Approach Micropipeline modelling techniques such as CCS expose all of the internal operation of the request/acknowledge handshake, potentially leading to rapid growth in the state-space of the resulting terms.
Reference: [14] <author> Carlos Delgado Kloos. </author> <title> Semantics of Digital Circuits. </title> <booktitle> Number 285 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: A textual version of Green allows the designer to define complex data types and expressions in the usual way, as well as providing a dataflow network description constructs. It uses somewhat similar primitives to other dataflow languages <ref> [14] </ref>, including merge and split for dataflow control, arbitrate for (internal) non-deterministic stream merging, as well as buffers and pure functional units.
Reference: [15] <author> H. Barringer, D. Fellows, G.D. Gough, P. Jinks, B. Marsden, and A. Williams. </author> <title> Design and simulation in rainbow: A framework for asynchronous micropipeline circuits. </title> <booktitle> In Proceedings of the Eu-ropean Simulation Symposium (ESS'96), </booktitle> <address> Genoa, Italy, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Refer to <ref> [15] </ref> for more details of the Green editing and simulation tools. Alternatively, an equivalent textual version of Figure 3 can be given: green Fib (value a,b,c) = - chan ch. fun Add (x,y) = x+y. - &gt;> | Buf (b) - &gt;> Add () end.
Reference: [16] <author> N. Paver. </author> <title> The Design and Implementation of an Asynchronous Microprocessor. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Manchester, </institution> <year> 1994. </year>
Reference-contexts: For example, Figure 6 shows a typical diagram as used in the literature for AMULET1 <ref> [16] </ref>. MAR Arb Mux PC Store LSM Reg Inc To PC pipe To memory WriteA 4 Formal Semantics of Rainbow: APA APA is a process algebra designed for representing the behaviour of asynchronous systems described in Rainbow.
Reference: [17] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <address> Hemel Hempstead, Herts, England, </address> <year> 1989. </year>
Reference-contexts: MAR Arb Mux PC Store LSM Reg Inc To PC pipe To memory WriteA 4 Formal Semantics of Rainbow: APA APA is a process algebra designed for representing the behaviour of asynchronous systems described in Rainbow. It has some similarities to standard process algebras, such as CCS <ref> [17] </ref>, CSP [18] or LOTOS [19], using some familiar process operators and a semantics defined operationally using SOS-style transition rules. However, the composition operators have been designed to support bundled-data micropipeline communication the communication primitives involved use an Ada-like rendezvous, and their semantics resembles the Ada semantics presented in [20].
Reference: [18] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: MAR Arb Mux PC Store LSM Reg Inc To PC pipe To memory WriteA 4 Formal Semantics of Rainbow: APA APA is a process algebra designed for representing the behaviour of asynchronous systems described in Rainbow. It has some similarities to standard process algebras, such as CCS [17], CSP <ref> [18] </ref> or LOTOS [19], using some familiar process operators and a semantics defined operationally using SOS-style transition rules. However, the composition operators have been designed to support bundled-data micropipeline communication the communication primitives involved use an Ada-like rendezvous, and their semantics resembles the Ada semantics presented in [20].
Reference: [19] <author> T. Bolognesi and E. Brinksma. </author> <title> Introduction to the ISO Specification Language LOTOS. Computer Networks and ISDN Systems, </title> <address> 14(1):2559, </address> <year> 1987. </year>
Reference-contexts: It has some similarities to standard process algebras, such as CCS [17], CSP [18] or LOTOS <ref> [19] </ref>, using some familiar process operators and a semantics defined operationally using SOS-style transition rules. However, the composition operators have been designed to support bundled-data micropipeline communication the communication primitives involved use an Ada-like rendezvous, and their semantics resembles the Ada semantics presented in [20].
Reference: [20] <author> Wei Li. </author> <title> An Operational Semantics of Tasking and Exception Handling in Ada. </title> <type> Technical Report CSR-99-82, </type> <institution> University of Edinburgh, </institution> <month> Jan-uary </month> <year> 1982. </year>
Reference-contexts: However, the composition operators have been designed to support bundled-data micropipeline communication the communication primitives involved use an Ada-like rendezvous, and their semantics resembles the Ada semantics presented in <ref> [20] </ref>. APA supports value-passing and has richly-structured transition labels, similar to those used in our previous work on the hardware design language ELLA and EPA [21].
Reference: [21] <author> H. Barringer, G.D. Gough, B.Q. Monahan, and A. Williams. </author> <title> A Process Algebra Foundation for Reasoning about Core ELLA. </title> <journal> The Computer Journal, </journal> <note> 39(4):303324, 1996. Also see reports available on the World-Wide Web, URL: http://www.cs.man.ac.uk/fmethods/ projects/ella-project.html. 13 </note>
Reference-contexts: APA supports value-passing and has richly-structured transition labels, similar to those used in our previous work on the hardware design language ELLA and EPA <ref> [21] </ref>. For example, the action `(ch 4 ?5; ch 5 ?3 = ch 6 !8)' shows the values 5 and 3 being input on channels ch 4 and ch 5 respectively, with the simultaneous output on channel ch 6 of the value 8.
References-found: 21

