URL: http://www.cs.ucsb.edu/oocsb/self/papers/ecoop93b.ps.Z
Refering-URL: http://www.cs.ucsb.edu/oocsb/self/papers/oop-components.html
Root-URL: http://www.cs.ucsb.edu
Email: urs@cs.stanford.edu  
Title: Integrating Independently-Developed Components in Object-Oriented Languages  
Author: Urs Hlzle 
Address: Stanford University  
Affiliation: Computer Systems Laboratory  
Note: To appear in ECOOP 93 Proceedings, Springer Verlag Lecture Notes on Computer Science.  
Abstract: Object-oriented programming promises to increase programmer productivity through better reuse of existing code. However, reuse is not yet pervasive in todays object-oriented programs. Why is this so? We argue that one reason is that current programming languages and environments assume that components are perfectly coordinated. Yet in a world where programs are mostly composed out of reusable components, these components are not likely to be completely integrated because the sheer number of components would make global coordination impractical. Given that seemingly minor inconsistencies between individually designed components would exist, we examine how they can lead to integration problems with current programming language mechanisms. We discuss several reuse mechanisms that can adapt a component in place without requiring access to the components source code and without needing to re-typecheck it.
Abstract-found: 1
Intro-found: 1
Reference: [ADL91] <author> Rakesh Agrawal, Linda G. DeMichiel, and Bruce G. Lindsay. </author> <title> Static Type-Checking of Multi-Methods. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 113-128, </pages> <address> Phoenix, AZ, </address> <month> October </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(11), </note> <month> November </month> <year> 1991. </year>
Reference-contexts: In other words, though factory objects can solve some simple problems, they do not appear to scale well. 5.4 Multimethods Multimethods (also called generic methods) [DG87] are relatively new in statically-typed languages <ref> [ADL91, Cha92] </ref>. With multimethods, the message lookup may involve all arguments, not just the receiver. Since multimethods are dispatched on multiple arguments, they are not contained in a single class, and thus are in some sense independent of the class or type hierarchy (but see [Cha92]).
Reference: [AL90] <author> Pierre America and Frank van der Linden. </author> <title> A Parallel Object-Oriented Language with Inheritance and Subtyping. </title> <booktitle> In ECOOP/OOPSLA 90 Conference Proceedings, </booktitle> <pages> pp. 161-168, </pages> <address> Ottawa, Canada, </address> <month> October </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(10), </note> <month> October </month> <year> 1990. </year>
Reference-contexts: To solve the integration problem, we would like to view, for example, a SubA object as being of type Printable. This chapter discusses how typing mechanisms of existing languages can be employed to this end. 8 5.1 Implicit Subtyping Implicit subtyping, as used in some programming languages (e.g., POOL-I <ref> [AL90] </ref> and Emerald [RTK91]), can be very helpful in integrating different components. With implicit subtyping, the subtyping relationships need not be declared explicitly but are inferred by the system. In our example, Printable is a valid supertype of BaseA, and the system automatically detects this relationship.
Reference: [App92] <author> Apple Computer, </author> <title> Eastern Research and Technology. Dylan, an object-oriented dynamic language. </title> <institution> Apple Computer, Cupertino, </institution> <address> CA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: However, we are not aware of any language that allows dispatching of multime-thods on types. Finally, multimethods also could not solve our problem if the underlying language allowed the sealing of types <ref> [App92] </ref>. A sealed class cannot be subclassed, and a sealed type cannot be specialized further. Sealing would prevent the programmer from creating new generic methods that dispatched on a sealed class or type. Sealing has mainly been proposed for implementation reasons [App92] to allow the compiler generate better code, but also <p> if the underlying language allowed the sealing of types <ref> [App92] </ref>. A sealed class cannot be subclassed, and a sealed type cannot be specialized further. Sealing would prevent the programmer from creating new generic methods that dispatched on a sealed class or type. Sealing has mainly been proposed for implementation reasons [App92] to allow the compiler generate better code, but also as a software engineering mechanism to prevent internal classes from being subclassed [KM+87]. 6 Discussion Our study has led us to a surprising result: even our very simple example creates integration problems that cannot be solved easily with the language mechanisms
Reference: [BC90] <author> Gilad Bracha and William Cook. </author> <title> Mixin-Based Inheritance. </title> <booktitle> In ECOOP/ OOPSLA 90 Conference Proceedings, </booktitle> <pages> pp. 303-311, </pages> <address> Ottawa, Canada, </address> <month> October </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(10), </note> <month> October </month> <year> 1990. </year>
Reference-contexts: The idea is similar to wrappers, except that we create a new subtype for every component type instead of creating a wrapper type. The subtype mixes in <ref> [Moo86, BC90] </ref> the desired interface in addition to inheriting the component types interface.
Reference: [Ber90] <author> Lucy Berlin. </author> <title> When Objects Collide: Experiences with Reusing Multiple Class Hierarchies. </title> <booktitle> In ECOOP/OOPSLA 90 Conference Proceedings, </booktitle> <pages> pp. 181-193, </pages> <address> Ottawa, Canada, </address> <month> October </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(10), </note> <month> October </month> <year> 1990. </year> <month> 19 </month>
Reference-contexts: Writing reusable components and frameworks is hard [Deu83, OO88, OO90]. Furthermore, the few successful reusable components built so far (such as Interviews [LVC89] and ET++ [WGM88]) are relatively monolithic frameworks, and components are often hard to combine with other components <ref> [Ber90] </ref>. <p> Finally, components cannot be viewed in isolation: even if all components are internally consistent and well-designed, their combination may not be consistent <ref> [Ber90] </ref>. Programs are likely to combine many different components or component frameworks, making perfect harmony unlikely. However, it should be emphasized that we do not assume complete anarchy or lack of any standardization.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding Types, Data Abstraction, and Polymorphism. </title> <journal> Computing Surveys 17(4), </journal> <pages> pp, 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: Finally, we are concerned only with statically-typed languages using subtype polymorphism <ref> [CW85] </ref>, because these languages are so widely used and because static typing is often viewed as necessary for building reliable large systems (see, for example, [CC+89]).
Reference: [Cha92] <author> Craig Chambers. </author> <title> Object-Oriented Multimethods in Cecil. </title> <booktitle> In ECOOP 92 Proceedings, </booktitle> <pages> pp. 33-65, </pages> <address> Utrecht, The Netherlands, </address> <month> June </month> <year> 1992. </year> <note> Published as Springer Verlag LNCS 615, Berlin, Germany 1992. </note>
Reference-contexts: In other words, though factory objects can solve some simple problems, they do not appear to scale well. 5.4 Multimethods Multimethods (also called generic methods) [DG87] are relatively new in statically-typed languages <ref> [ADL91, Cha92] </ref>. With multimethods, the message lookup may involve all arguments, not just the receiver. Since multimethods are dispatched on multiple arguments, they are not contained in a single class, and thus are in some sense independent of the class or type hierarchy (but see [Cha92]). <p> With multimethods, the message lookup may involve all arguments, not just the receiver. Since multimethods are dispatched on multiple arguments, they are not contained in a single class, and thus are in some sense independent of the class or type hierarchy (but see <ref> [Cha92] </ref>). We can use this independence to modify a component without changing the component itself. For example, by defining a method print specialized for arguments of type BaseB we effectively add a print method to BaseB.
Reference: [Cha93a] <author> Craig Chambers. </author> <title> The Cecil LanguageSpecification and Rationale. </title> <type> Technical Report 93-03-05, </type> <institution> Computer Science Department, University of Washington, </institution> <address> Seattle 1993. </address>
Reference-contexts: Sandbergs descriptive classes [San86] are the first example of types that could be declared after the classes that were their subtypes. The usefulness of creating new super-classes for existing classes was discussed in detail by Pedersen [Ped89] and implemented in Cecil by Chambers <ref> [Cha93a] </ref>. Predicate classes [Cha93b] offer yet another way to extend objects, although this isnt their intended use. Opdyke [Opd92] defines a set of program restructuring operations (refactorings) that support the design, evolution and reuse of object-oriented application frameworks.
Reference: [Cha93b] <author> Craig Chambers. </author> <title> Predicate Classes. </title> <booktitle> In ECOOP 93 Conference Proceedings, </booktitle> <address> Kaiserslautern, Germany, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: Sandbergs descriptive classes [San86] are the first example of types that could be declared after the classes that were their subtypes. The usefulness of creating new super-classes for existing classes was discussed in detail by Pedersen [Ped89] and implemented in Cecil by Chambers [Cha93a]. Predicate classes <ref> [Cha93b] </ref> offer yet another way to extend objects, although this isnt their intended use. Opdyke [Opd92] defines a set of program restructuring operations (refactorings) that support the design, evolution and reuse of object-oriented application frameworks.
Reference: [CC+89] <author> Peter Canning, William Cook, Walter Hill, and Walter Olthoff. </author> <title> Interfaces in strongly-typed object-oriented programming. </title> <booktitle> In OOPSLA 89 Conference Proceedings, </booktitle> <pages> pp. 457-468, </pages> <address> New Orleans, LA, </address> <month> October </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October </month> <year> 1989. </year>
Reference-contexts: Finally, we are concerned only with statically-typed languages using subtype polymorphism [CW85], because these languages are so widely used and because static typing is often viewed as necessary for building reliable large systems (see, for example, <ref> [CC+89] </ref>). However, many of the problems we discuss also apply to dynamically-typed object-oriented languages (see section 5.1). 3 The Problem: Inconsistent Components Assume that we are writing an application using the components A, B, and C, each of them bought from a different vendor.
Reference: [Cox86] <author> Brad Cox. </author> <title> Object-Oriented Programming: An Evolutionary Approach. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA 1986. </address>
Reference-contexts: In the ideal scenario envisioned by the object-oriented community, future programs would be mostly composed out of preexisting components rather than rewritten from scratch: [Programmers will] produce reusable software components by assembling components of other programmers <ref> [Cox86] </ref>. Reusing existing, tested code simultaneously reduces the effort needed to create new applications and improves the quality of the resulting programs. <p> However, this ideal scenario has not yet become reality: today, many programs are still mostly written from scratch, and there are few commercially available building blocks that could be reused in new applications. Clearly, the envisioned market for software ICs <ref> [Cox86] </ref> has not materialized yet. Writing reusable components and frameworks is hard [Deu83, OO88, OO90]. Furthermore, the few successful reusable components built so far (such as Interviews [LVC89] and ET++ [WGM88]) are relatively monolithic frameworks, and components are often hard to combine with other components [Ber90].
Reference: [DG87] <author> Linda G. DeMichiel and Richard P. Gabriel. </author> <title> The Common Lisp Object System: An Overview. </title> <booktitle> In ECOOP 87 Conference Proceedings, </booktitle> <pages> pp. 223-233, </pages> <address> Paris, France, </address> <month> June </month> <year> 1987. </year> <note> Published as Springer Verlag LNCS 276, Berlin, Germany 1987. </note>
Reference-contexts: Furthermore, the order of changes to factory objects must be coordinated carefully so that no component overwrites the changes made previously by another component. In other words, though factory objects can solve some simple problems, they do not appear to scale well. 5.4 Multimethods Multimethods (also called generic methods) <ref> [DG87] </ref> are relatively new in statically-typed languages [ADL91, Cha92]. With multimethods, the message lookup may involve all arguments, not just the receiver.
Reference: [Deu83] <author> L. Peter Deutsch. </author> <title> Reusability in the Smalltalk-80 Programming System. </title> <booktitle> Proceedings of the Workshop on Reusability in Programming, p. </booktitle> <pages> 72-76. </pages> <address> Newport, RI, </address> <month> September </month> <year> 1983. </year>
Reference-contexts: Clearly, the envisioned market for software ICs [Cox86] has not materialized yet. Writing reusable components and frameworks is hard <ref> [Deu83, OO88, OO90] </ref>. Furthermore, the few successful reusable components built so far (such as Interviews [LVC89] and ET++ [WGM88]) are relatively monolithic frameworks, and components are often hard to combine with other components [Ber90].
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Ma 1990. </address>
Reference-contexts: However, pointer equality is commonly used in many other languages (e.g., C++ <ref> [ES90] </ref>). In such languages, functional wrappers require strict coding discipline, thereby introducing the possibility of programming errors. Also, functional wrappers can cause performance problems because a new wrapper object is allocated for every object returned by a component.
Reference: [Hor87] <author> Chris Horn. </author> <title> Conformance, Genericity, Inheritance and Enhancement. </title> <booktitle> In ECOOP 87 Conference Proceedings, </booktitle> <pages> pp. 223-233, </pages> <address> Paris, France, </address> <month> June </month> <year> 1987. </year> <note> Published as Springer Verlag LNCS 276, Berlin, Germany 1987. </note>
Reference-contexts: In essence, the extension checker would thus represent a type adaptation subsystem implemented within an extension hierarchies system. 7.3 Other Related Work A mechanism very similar to type adaptation (called enhancive types) was proposed by Horn <ref> [Hor87] </ref>. However, unlike type adaptation, enhancive types do not change types in place but instead allow a base type to be coerced into another type (the enhanced type) that offers additional operations implemented in terms of the base types public methods.
Reference: [HU92] <author> Urs Hlzle and David Ungar. </author> <title> The Case for Pure Object-Oriented Languages. </title> <booktitle> In Proceedings of the OOPSLA 92 Workshop on Object-Oriented Languages: The Next Generation. </booktitle> <address> Vancouver, Canada, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: For example, current compiled-code-oriented systems often use impure interfaces that expose implementation information in order to obtain better performance, thereby severely compromising reusability <ref> [HU92] </ref>. We wish to emphasize reuse in a broader sense, where reuse equals saved programming effort. Programming time is much more important than compilation time because the computational power needed for recompilation becomes cheaper and cheaper every year whereas the programmers time does not.
Reference: [JR92] <author> Paul Johnson and Ceri Rees. </author> <title> Reusability through Fine-grain Inheritance. </title> <journal> Soft-warePractice and Experience 22(12), </journal> <pages> pp. 1049-1068, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: For example, Johnson and Rees propose to improve reusability through fine-grain inheritance by methodically splitting up the explicit class hierarchy into small pieces so that reusers can pick the pieces from which they want to inherit <ref> [JR92] </ref>. But in the example they present, a simple List class is split up into a complex multiple-inheritance hierarchy involving 25 different classes, only one of which (List) is usually needed.
Reference: [KM+87] <author> B. B. Kristensen, O. L. Madsen, B. Mller-Pedersen and K. Nygaard. </author> <title> The BETA Programming Language. </title> <editor> In B. Shriver and P. Wegner (eds.), </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pp. 7-48. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA 1987. </address>
Reference-contexts: However, we are not aware of any popular object-oriented language that would allow this. In languages offering checked type narrowing (such as Eiffel [Mey91] and BETA <ref> [KM+87] </ref>), we cannot perform the narrowing because these operations check the objects true type (the creation type). That is, the narrowing tests if the object was created as a NewSubA object, not whether it conforms to BaseA SubA NewSubA BaseC SubC NewSubC BaseB SubB NewSubB Printable 10 the NewSubA type. <p> Sealing would prevent the programmer from creating new generic methods that dispatched on a sealed class or type. Sealing has mainly been proposed for implementation reasons [App92] to allow the compiler generate better code, but also as a software engineering mechanism to prevent internal classes from being subclassed <ref> [KM+87] </ref>. 6 Discussion Our study has led us to a surprising result: even our very simple example creates integration problems that cannot be solved easily with the language mechanisms present in current statically-typed object-oriented languages. Both traditional reuse mechanisms, composition and subtyping, do not fare well in our scenario.
Reference: [Lie88] <author> Henry Lieberman. </author> <title> Position Statement in the Panel on Varieties of Inheritance. </title> <booktitle> In Addendum to the OOPSLA 87 Proceedings, </booktitle> <address> p. </address> <note> 35. Published as SIGPLAN Notices 23(5), </note> <month> May </month> <year> 1988. </year>
Reference-contexts: The third premise follows from the desire for incremental change: Adding new code is good, changing old code is bad <ref> [Lie88] </ref>. It is motivated by pragmatic necessity: vendors may not be willing to make their source code available to clients, and even if source code is available, it is desirable not to change the source in order to stay compatible with future versions of the component.
Reference: [LVC89] <author> Mark A. Linton, John Vlissides, and Paul Calder. </author> <title> Composing user interfaces with Interviews. </title> <journal> IEEE Computer Magazine, </journal> <month> February </month> <year> 1989. </year> <month> 20 </month>
Reference-contexts: Clearly, the envisioned market for software ICs [Cox86] has not materialized yet. Writing reusable components and frameworks is hard [Deu83, OO88, OO90]. Furthermore, the few successful reusable components built so far (such as Interviews <ref> [LVC89] </ref> and ET++ [WGM88]) are relatively monolithic frameworks, and components are often hard to combine with other components [Ber90].
Reference: [Lin92] <author> Mark A. Linton. </author> <title> Encapsulating a C++ Library. </title> <booktitle> Proceedings of the 1992 Usenix C++ Conference, </booktitle> <pages> pp. 57-66, </pages> <address> Portland, OR, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: The idea is to introduce a level of indirection at every object creation. Instead of directly creating an object (obj = new SubA), every object is created via a call to a factory object (obj = factory-&gt;createSubA ()). Linton originally proposed this technique to better encapsulate the InterViews library <ref> [Lin92] </ref>, but it is also very useful to solve integration problems. If the factory object is exposed to the (re)user, we can replace the standard factory with our own version creating NewSubA objects rather than SubA objects.
Reference: [Mag91] <author> Boris Magnusson. </author> <title> Position statement during the ECOOP 91 Workshop on Types, </title> <address> Geneva, Switzerland, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: is not very popular: no major object-oriented language offers it, probably because it is often perceived as weakening type checking since it may establish a subtype relationship in cases where there is no semantic relationship (for example, Cowboy isnt a subtype of Drawable even though it has a draw method <ref> [Mag91] </ref>). Interestingly, with respect to the integration problems discussed here, dynamically-typed languages are quite similar to statically-typed languages with implicit subtyp-ing.
Reference: [MPN89] <author> Ole Lehrmann-Madsen, Birger Mller-Pedersen, and Kristen Nygaard. </author> <title> The BETA Programming LanguageA Scandinavian Approach to Object-Oriented Programming. </title> <booktitle> OOPSLA 89 Tutorial Notes, </booktitle> <address> New Orleans, LA, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: Thus, a system using type substitution could only partially solve the integration problems we encountered in this paper. The Mjlner BETA fragment system <ref> [MPN89] </ref> is a grammar-based programming environment designed to customize and assemble program fragments. A fragment is any sequence of terminal and nonterminal symbols derived from a nonterminal symbol. Fragments may define interfaces or implementations, and in principle one interface fragment could have several implementation fragments.
Reference: [Moo86] <author> David A. Moon. </author> <title> Object-Oriented programming with Flavors. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 1-8, </pages> <address> Portland, OR, </address> <month> October </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November </month> <year> 1986. </year>
Reference-contexts: The idea is similar to wrappers, except that we create a new subtype for every component type instead of creating a wrapper type. The subtype mixes in <ref> [Moo86, BC90] </ref> the desired interface in addition to inheriting the component types interface.
Reference: [Mey91] <author> Bertrand Meyer. </author> <title> EiffelThe Language. </title> <publisher> Prentice Hall, </publisher> <address> New York 1991. </address>
Reference-contexts: However, we are not aware of any popular object-oriented language that would allow this. In languages offering checked type narrowing (such as Eiffel <ref> [Mey91] </ref> and BETA [KM+87]), we cannot perform the narrowing because these operations check the objects true type (the creation type).
Reference: [OH92] <author> Harold Ossher and William Harrison. </author> <title> Combination of Inheritance Hierarchies. </title> <booktitle> In OOPSLA 92 Conference Proceedings, </booktitle> <pages> pp. 25-43, </pages> <address> Vancouver, Canada, </address> <month> October </month> <year> 1992. </year> <note> Published as SIGPLAN Notices 27(10), </note> <month> October </month> <year> 1992. </year>
Reference-contexts: More research is probably needed to investigate its practicality, but it appears that the implementation could leverage off already existing intermediate formats aimed at cross-architecture portability, such as the commercial ANDF format mentioned above. 7.2 Extension Hierarchies Ossher and Harrison have proposed a mechanism called extension hierarchies <ref> [OH92] </ref> that is similar to type adaptation. Even though their description emphasizes extension rather than adaptation, extension hierarchies seem well suited to solving the integration problem. The basic idea is to combine a base hierarchy (= component) with sparse extension hierarchies containing changes, additions, and deletions. <p> Also, extension hierarchies are a programming environment mechanism rather than a language mechanism. We believe that extension hierarchies hold much promise. While we do not agree with all aspects of the particular variation proposed in <ref> [OH92] </ref> (for example, the authors strictly avoid recompiling code after extensions are applied), extension hierarchies can 16 solve many integration problems in a straightforward way. In our example, we could define an extension for each component to insert the Printable supertype.
Reference: [OO88] <author> Panel: </author> <title> Experiences with reusability. </title> <booktitle> In OOPSLA 88 Conference Proceedings, </booktitle> <pages> pp. 371-376, </pages> <address> San Diego, CA, </address> <month> September </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(11), </note> <month> November </month> <year> 1988. </year>
Reference-contexts: Clearly, the envisioned market for software ICs [Cox86] has not materialized yet. Writing reusable components and frameworks is hard <ref> [Deu83, OO88, OO90] </ref>. Furthermore, the few successful reusable components built so far (such as Interviews [LVC89] and ET++ [WGM88]) are relatively monolithic frameworks, and components are often hard to combine with other components [Ber90].
Reference: [OO90] <author> Panel: </author> <title> Designing Reusable Designs: Experiences Designing Object-Oriented Frameworks. </title> <booktitle> In Addendum to the OOPSLA/ECOOP 90 Conference Proceedings, </booktitle> <pages> pp. 19-24, </pages> <address> Ottawa, Canada, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: Clearly, the envisioned market for software ICs [Cox86] has not materialized yet. Writing reusable components and frameworks is hard <ref> [Deu83, OO88, OO90] </ref>. Furthermore, the few successful reusable components built so far (such as Interviews [LVC89] and ET++ [WGM88]) are relatively monolithic frameworks, and components are often hard to combine with other components [Ber90]. <p> It is well known that reusable class hierarchies tend to be factored into smaller and smaller pieces with each design iteration because users discover new possibilities for reuse if certain behaviors are factored out <ref> [OO90] </ref>. Implicit subtyping allows the (re)user of a component to perform this refactoring without waiting for the component provider to do so, and without changing the component itself. The value of not having to explicitly name every possibly useful type becomes obvious as soon as one tries to name them.
Reference: [Opd92] <author> W. F. Opdyke. </author> <title> Refactoring Object-Oriented Frameworks. </title> <type> Ph. D. Thesis, </type> <institution> Department of Computer Science, University of Illinois, Urbana-Champaign 1992. </institution> <note> Published as Technical Report UIUCDCS-R-92-53097. </note>
Reference-contexts: The usefulness of creating new super-classes for existing classes was discussed in detail by Pedersen [Ped89] and implemented in Cecil by Chambers [Cha93a]. Predicate classes [Cha93b] offer yet another way to extend objects, although this isnt their intended use. Opdyke <ref> [Opd92] </ref> defines a set of program restructuring operations (refactorings) that support the design, evolution and reuse of object-oriented application frameworks. Although Opdyke discusses the refactorings in terms of source code changes, most of them could be performed on a sourceless intermediate code format.
Reference: [OSF91] <author> Open Systems Foundation. </author> <title> OSF Architecture-Neutral Distribution Format Rationale. Open Systems Foundation, </title> <month> June </month> <year> 1991. </year>
Reference-contexts: Adapting a component interface does not require access to the source code of the implementation. For example, a component could be distributed in an architecture-neutral intermediate format (such as ANDF <ref> [OSF91] </ref>) that contains all type information needed by a type adaptation system (but no source code) and could be translated into optimized machine code. In this intermediate form, the components implementation need not hardwire the exact storage layout or dispatching mechanisms like machine code would.
Reference: [Par72] <author> David Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Communications of the ACM, </journal> <volume> 15(12), </volume> <month> December </month> <year> 1972. </year>
Reference: [Ped89] <author> Claus H. Pedersen. </author> <title> Extending ordinary inheritance schemes to include generalization. </title> <booktitle> In OOPSLA 89 Conference Proceedings, </booktitle> <pages> pp. 407-417, </pages> <address> New Orleans, LA, </address> <month> October </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October </month> <year> 1989. </year>
Reference-contexts: Sandbergs descriptive classes [San86] are the first example of types that could be declared after the classes that were their subtypes. The usefulness of creating new super-classes for existing classes was discussed in detail by Pedersen <ref> [Ped89] </ref> and implemented in Cecil by Chambers [Cha93a]. Predicate classes [Cha93b] offer yet another way to extend objects, although this isnt their intended use. Opdyke [Opd92] defines a set of program restructuring operations (refactorings) that support the design, evolution and reuse of object-oriented application frameworks.
Reference: [PS90] <author> Jens Palsberg and Michael Schwartzbach. </author> <title> Type substitution for object-oriented programming. </title> <booktitle> In ECOOP/OOPSLA 90 Conference Proceedings, </booktitle> <pages> pp. 151-160, </pages> <address> Ottawa, Canada, </address> <month> October </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(10), </note> <month> October </month> <year> 1990. </year>
Reference-contexts: In such a system, the refactorings would be very similar to the modifications allowed by type adaptation. Palsberg and Schwartzbach have recognized a similar problem with traditional reuse mechanisms and have proposed a type substitution mechanism aimed at maximiz 17 ing code reuse <ref> [PS90] </ref>. However, for the scenario outlined here, their solution is both too general and too restricted: too general because in the presence of subtype polymor-phism it may require the re-typechecking of a components implementation, and too restricted because it does not allow adding new methods or renaming methods.
Reference: [RL89] <author> Rajendra K. Raj and Henry K. Levy. </author> <title> A Compositional Model for Software Reuse. </title> <journal> Computer Journal 32(4), </journal> <pages> pp. 312-322, </pages> <year> 1989. </year>
Reference-contexts: Extending the fragment system to incorporate type adaptation would be a promising area for future research. The prototype of the Jade programming environment for Emerald described by Raj <ref> [RL89] </ref> is similar to BETAs fragment system. A piece of code can be left partially unspecified, and the code pieces habitat describes the required interface of the unspecified parts.
Reference: [RTK91] <author> Rajendra K. Raj, Ewan Tempero, and Henry K. Levy. </author> <title> Emerald: A General-Purpose Programming Language. </title> <journal> SoftwarePractice and Experience 21(1), </journal> <pages> pp. 91-118, </pages> <month> January </month> <year> 1991. </year> <month> 21 </month>
Reference-contexts: This chapter discusses how typing mechanisms of existing languages can be employed to this end. 8 5.1 Implicit Subtyping Implicit subtyping, as used in some programming languages (e.g., POOL-I [AL90] and Emerald <ref> [RTK91] </ref>), can be very helpful in integrating different components. With implicit subtyping, the subtyping relationships need not be declared explicitly but are inferred by the system. In our example, Printable is a valid supertype of BaseA, and the system automatically detects this relationship.
Reference: [San86] <author> David Sandberg. </author> <title> An Alternative to Subclassing. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 424-428, </pages> <address> Portland, OR, </address> <month> October </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November </month> <year> 1986. </year>
Reference-contexts: Horns paper also discusses in more detail why the original methods of an enhanced type need not be re-typechecked. Unfortunately, the paper was couched in theoretical terms as an extension to constrained genericity, and the idea has largely been overlooked in programming language design. Sandbergs descriptive classes <ref> [San86] </ref> are the first example of types that could be declared after the classes that were their subtypes. The usefulness of creating new super-classes for existing classes was discussed in detail by Pedersen [Ped89] and implemented in Cecil by Chambers [Cha93a].
Reference: [Szy92] <author> Clemens Szypersky. </author> <title> Extensible Object-Orientation. </title> <booktitle> In Proceedings of the OOPSLA 92 Workshop on Object-Oriented Languages: The Next Generation. </booktitle> <address> Vancouver, Canada, </address> <month> October 18, </month> <year> 1992. </year>
Reference-contexts: Of course, reuse mechanisms must be practical in terms of the machine resources they require. But the overriding goal of reuse should be to increase programmer productivity, and we should not constrain our search for better reuse mechanisms a priori to mechanisms that preserve compiled-code reuse (see <ref> [Szy92] </ref> for a similar argument). This is not to say that compilation time isnt an important factor inuencing programming productivity. But even with todays hardware, a well-engineered compiler can compile several thousand lines of code per second [Tem90].
Reference: [Tem90] <author> Josef Templ. </author> <title> Compilation Speed of the SPARC Oberon Compiler. </title> <type> Personal communication, </type> <month> April </month> <year> 1990. </year>
Reference-contexts: This is not to say that compilation time isnt an important factor inuencing programming productivity. But even with todays hardware, a well-engineered compiler can compile several thousand lines of code per second <ref> [Tem90] </ref>.
Reference: [US87] <author> David Ungar and Randall B. Smith. </author> <title> SELFThe Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 227-242, </pages> <address> Orlando, FL, </address> <month> October </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December </month> <year> 1987. </year>
Reference-contexts: Therefore, wrappers are no longer transparent unless pointer equality is strictly avoided. This restriction is simple to enforce in pure object-oriented languages like SELF <ref> [US87] </ref> where equality is a user-defined operation rather than a pointer comparison, so that we can define equality of wrappers to be equality of the wrapped objects. However, pointer equality is commonly used in many other languages (e.g., C++ [ES90]).
Reference: [WGM88] <author> Andr Weinand, Erich Gamma, and Robert Marty. </author> <title> ET++An Object-Oriented Application Framework in C++. </title> <booktitle> In OOPSLA 88 Conference Proceedings, </booktitle> <pages> pp. 168-182, </pages> <address> San Diego, CA, </address> <month> October </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(11), </note> <month> November </month> <year> 1988. </year>
Reference-contexts: Clearly, the envisioned market for software ICs [Cox86] has not materialized yet. Writing reusable components and frameworks is hard [Deu83, OO88, OO90]. Furthermore, the few successful reusable components built so far (such as Interviews [LVC89] and ET++ <ref> [WGM88] </ref>) are relatively monolithic frameworks, and components are often hard to combine with other components [Ber90].
References-found: 40

