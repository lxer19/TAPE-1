URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3756/3756.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Title: Specification-based Testing of Reactive Software: A Case Study in Technology Transfer case study illustrates that
Author: Lalita Jategaonkar Jagadeesan Adam Porter Carlos Puchol J. Christopher Ramming and Lawrence G. Votta 
Note: The  
Date: February 28, 1997  
Abstract: We describe a case study in which we tried to transfer a specification-based testing system from research to practice. We did the case study in two steps: First we conducted a feasibility study in a laboratory setting to estimate the potential costs and benefits of using the system. Next we conducted a usability study, in an industrial setting, to determine whether it would be effective in practice. We also found that there is often a tension between the scope of the problem to be solved and the specificity of the solution. The greater the scope of the problem, the more general the formal method solution and, thus, the more customization that must be done to use it in a particular environment. We suggest that researchers limit the scope of the problems they try to solve to minimize the risk of technology transfer failure.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. J. Allen. </author> <title> Managing the Flow of Technology. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA., </address> <year> 1977. </year>
Reference-contexts: We argue that many of these articles are "outward-looking". That is, they suggest that the biggest barriers to transfer lie outside the technology itself. For example, Sam Redwine and William Riddle [25] claim that it takes about 20 years for technology to get into use. Tom Allen <ref> [1] </ref> suggests that social factors can lengthen or reduce this interval. We also hear that that practitioner's resist change and that they lack the required mathematical training to use formal methods [13]. Surely, these and other factors play important roles in technology transfer.
Reference: [2] <author> M. Ardis, J. Chaves, L. Jagadeesan, P. Mataga, C. Puchol, M. Staskauskas, and J. Von Olnhausen. </author> <title> A frame work for evaluating specification methods for reactive systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(6) </volume> <pages> 378-389, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: To conduct the study we developed a testbed of model systems to which we could apply our testing tools. Since we wanted the testbed to be as realistic as possible, we modeled it after the APS system described below. 4.1.1 The Automatic Protection Switching System As described in <ref> [2] </ref>, communication channels bridging switching systems need to interface to components manufactured by different vendors. In order to facilitate cooperation between components, standards have been established. One of the standards for maintaining connectivity is called "Automatic Protection Switching (APS)" [3]. <p> The output of the system consists of the state of the switch that selects the current communication line. As we described earlier, the requirements of the APS were formally specified as part of a formal methods case study by Ardis et al. <ref> [2] </ref>. We used this specification as the starting point for the following feasibility study. Like the original APS, the model used in the feasibility study is unidirectional and non-revertive, but has one protection line for every two working lines (i.e., 2+1 rather than the original 1+1).
Reference: [3] <author> Bellcore. </author> <title> Synchronous optical network (SONET) transport systems: Common generic criteria. </title> <type> Technical Report TR-NWT-000253, Issue 2, </type> <institution> Bellcore, </institution> <year> 1991. </year>
Reference-contexts: In order to facilitate cooperation between components, standards have been established. One of the standards for maintaining connectivity is called "Automatic Protection Switching (APS)" <ref> [3] </ref>. The idea is to provide more than one line for each communication channel (in switching systems, reliability is often provided by duplicating critical elements). If a line degrades or fails, a backup line, called the "protection line" is used instead.
Reference: [4] <author> G. Berry and G. Gonthier. </author> <title> The Esterel synchronous programming language: design, semantics, </title> <journal> imple mentation. Science of Computer Programming, </journal> <volume> 19 </volume> <pages> 87-152, </pages> <year> 1992. </year>
Reference-contexts: Specifically, applications must conform to the synchrony hypothesis <ref> [4] </ref>, which implies that applications must appear to operate in discrete "steps." The application receives a set of inputs (input signals), reacts to the inputs by computing and producing a set of outputs (output signals), and then quiesces, waiting for new inputs. <p> In our toolset, oracle state machines are constructed through the following chain of events. First, safety properties are specified by the system engineer using the temporal logic syntax described earlier [16]. Next, as an engineering convenience, our toolset automatically translates the temporal logic formulae into Esterel <ref> [4] </ref> programs. These programs express deterministic finite-state machines, which we extract easily by invoking the Esterel compiler. The resulting information is then automatically analyzed and eventually linked with the test harness and the application.
Reference: [5] <author> E. Brinksma. </author> <title> A theory for the derivation of tests. In Proceedings of the Symposium on Protocol Specification, Testing, and Verification, </title> <year> 1988. </year>
Reference-contexts: Many approaches to conformance testing have been proposed, corresponding to a variety of specification languages. For example, Gaudel [10] presents a framework for the testing of algebraic specifications. Brinksma et al. <ref> [5, 6] </ref> present a theory of testing based on labeled transition systems, and applications to the specification language LOTOS are shown in [6, 24]. 3 The Testing Framework And Tools 3.1 The Computation Model Our tools test reactive applications [11].
Reference: [6] <author> E. Brinksma, G. Scollo, and C. Steenbergen. </author> <title> LOTOS specifications, their implementations and their tests. In Proceedings of the Symposium on Protocol Specification, Testing, and Verification, </title> <year> 1986. </year>
Reference-contexts: Many approaches to conformance testing have been proposed, corresponding to a variety of specification languages. For example, Gaudel [10] presents a framework for the testing of algebraic specifications. Brinksma et al. <ref> [5, 6] </ref> present a theory of testing based on labeled transition systems, and applications to the specification language LOTOS are shown in [6, 24]. 3 The Testing Framework And Tools 3.1 The Computation Model Our tools test reactive applications [11]. <p> For example, Gaudel [10] presents a framework for the testing of algebraic specifications. Brinksma et al. [5, 6] present a theory of testing based on labeled transition systems, and applications to the specification language LOTOS are shown in <ref> [6, 24] </ref>. 3 The Testing Framework And Tools 3.1 The Computation Model Our tools test reactive applications [11].
Reference: [7] <author> E. Clarke and R. Kurshan. </author> <title> Computer-Aided Verification. </title> <journal> IEEE Spectrum 33(6), </journal> <pages> pages 61-67, </pages> <year> (1996). </year>
Reference-contexts: Our attempts to use it revealed several issues that must be addressed before we can transfer this technology to industrial software development. 4.4.1 Benefits Bridges the gap between formal verification and actual industrial applications. Formal verification techniques such as those based on model-checking <ref> [7] </ref> can be very useful as an aid to debugging applications. However, a significant limitation is that most formal verification systems analyze abstract models of the application, rather than the implementation itself. Thus, the abstract model must first be described typically using a manual process.
Reference: [8] <author> L. Dillon, G. Kutty, L. Moser, P. M. Melliar-Smith, and Y. Ramakrishna. </author> <title> A graphical interval logic for specifying concurrent systems. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 3(2) </volume> <pages> 131-165, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: This work was inspired by Dillon&Yu [9], who present a method for testing reactive software against specifications written in a version of temporal logic called Graphical Interval Logic <ref> [8] </ref>. Properties written in this logic are translated into FSM's whose language is the set of executions that violate the given property; the resulting FSM's are then used to generate test inputs. <p> Maintainability and evolution are important parts of any technology to be transferred to industrial settings. Graphical Interval Logic (GIL) <ref> [8, 9] </ref> offers a promising graphical alternative to standard text-based temporal specifications.
Reference: [9] <author> L. Dillon and Q. Yu. </author> <title> Oracles for checking temporal properties of concurrent systems. </title> <journal> Software Engineering Notes, </journal> <volume> 19(5) </volume> <pages> 140-153, </pages> <month> December </month> <year> 1994. </year> <booktitle> Proceedings of the 2nd ACM SIGSOFT Symposium on Foundations of Software Engineering. </booktitle>
Reference-contexts: We do not assume that specifications are complete; any well-formed temporal logic safety property can be tested. Most importantly, our approach completely eliminates human involvement in the selection of test data, the development of test harnesses, and the evaluation of test results. This work was inspired by Dillon&Yu <ref> [9] </ref>, who present a method for testing reactive software against specifications written in a version of temporal logic called Graphical Interval Logic [8]. <p> Maintainability and evolution are important parts of any technology to be transferred to industrial settings. Graphical Interval Logic (GIL) <ref> [8, 9] </ref> offers a promising graphical alternative to standard text-based temporal specifications. <p> Maintainability and evolution are important parts of any technology to be transferred to industrial settings. Graphical Interval Logic (GIL) [8, 9] offers a promising graphical alternative to standard text-based temporal specifications. Since our testing approach is based on that <ref> [9] </ref>, it would be useful to explore whether the use of GIL in place of our temporal logic language mitigates some of these problems of text-based specifications. 5 Conclusions To better understand the practical potential of these tools we conducted a two-part case study.
Reference: [10] <author> M. </author> <title> Gaudel. Testing can be formal, too. </title> <booktitle> In Proceedings of International Joint Conference on Theory and Practice of Software Development, Volume 915 of the Lecture Notes In Computer Science, </booktitle> <year> 1995. </year>
Reference-contexts: Our approach is a form of conformance testing - black-box testing for determining whether an implementation exhibits the behavior prescribed by its specification. Many approaches to conformance testing have been proposed, corresponding to a variety of specification languages. For example, Gaudel <ref> [10] </ref> presents a framework for the testing of algebraic specifications.
Reference: [11] <author> N. Halbwachs. </author> <title> Synchronous Programming of Reactive Systems. </title> <publisher> Kluwer Academic, </publisher> <year> 1993. </year> <month> 15 </month>
Reference-contexts: Brinksma et al. [5, 6] present a theory of testing based on labeled transition systems, and applications to the specification language LOTOS are shown in [6, 24]. 3 The Testing Framework And Tools 3.1 The Computation Model Our tools test reactive applications <ref> [11] </ref>. <p> Furthermore, we believe that introducing our approach into the current process may aid in making further progress in the transfer of formal methods. For example, once software developers become familiar with the the concepts introduced by our toolset, they may well decide to implement applications directly using synchronous formalisms <ref> [11] </ref> instead of the usual general purpose programming language. These formalisms have the advantage that they have a formal semantics which allows for automatic verification such as model-checking, and support code generation which ensures that the automatic verification is closely related to the actual implementations.
Reference: [12] <author> N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud. </author> <title> The synchronous data-flow programming language lustre. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9) </volume> <pages> 1305-1320, </pages> <year> 1991. </year>
Reference-contexts: Dillon and Yu indicate that they are currently developing tools to support this method, and that they will be integrated with Richardson's TAOS [26] test management system. Parissis&Ouabdesselam [23] present a technique for testing whether reactive software satisfies specifications written in Lustre <ref> [12] </ref>, a synchronous data-flow language that can also be viewed as a temporal logic. We have used standard temporal logic rather than Graphical Interval Logic or Lustre mainly to take advantage of some temporal logic tools that we had developed in the course of earlier work [16].
Reference: [13] <author> A. Hall. </author> <title> Seven myths of formal methods. </title> <journal> IEEE Software, </journal> <pages> pages 11-19, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Tom Allen [1] suggests that social factors can lengthen or reduce this interval. We also hear that that practitioner's resist change and that they lack the required mathematical training to use formal methods <ref> [13] </ref>. Surely, these and other factors play important roles in technology transfer. Nevertheless, we believe that even if all these issues disappeared, formal methods would still be difficult to put into practice. This is because there is a gap between the solutions offered by research and the needs of practitioners.
Reference: [14] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8:231 274, </volume> <year> 1987. </year>
Reference-contexts: They have constructors, destructors, and driver methods. Also, since some of the system design in the telecommunications industry is done using object-oriented CASE tools such as Real-Time Object-Oriented Modeling (ROOM)/ObjecTime [28] and O-Charts/O-MATE [15] an object-oriented extension of Statecharts <ref> [14] </ref>, there is a clear opportunity to create test-enabled applications in conjunction with these executable design tools. 13 This looks promising because these objects satisfy the synchrony hypothesis by design [28].
Reference: [15] <author> D. Harel and E. Gery. </author> <title> Executable object modeling with statecharts. </title> <booktitle> In Proceedings of the 18th International Symposium on Software Engineering, </booktitle> <pages> pages 246-257, </pages> <year> 1996. </year>
Reference-contexts: An interesting observation is that object-oriented designs naturally conform to our interface. They have constructors, destructors, and driver methods. Also, since some of the system design in the telecommunications industry is done using object-oriented CASE tools such as Real-Time Object-Oriented Modeling (ROOM)/ObjecTime [28] and O-Charts/O-MATE <ref> [15] </ref> an object-oriented extension of Statecharts [14], there is a clear opportunity to create test-enabled applications in conjunction with these executable design tools. 13 This looks promising because these objects satisfy the synchrony hypothesis by design [28].
Reference: [16] <author> L. Jagadeesan, C. Puchol, and J. Von Olnhausen. </author> <title> Safety property verification of Esterel programs and applications to telecommunications software. </title> <booktitle> In Proceedings of the 7th International Conference on Computer Aided Verification, Volume 939 of the Lecture Notes in Computer Science, </booktitle> <pages> pages 127-140, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: We have used standard temporal logic rather than Graphical Interval Logic or Lustre mainly to take advantage of some temporal logic tools that we had developed in the course of earlier work <ref> [16] </ref>. Richardson et al. [27] present an approach for deriving oracles from formal multi-paradigm specifications. Our approach is focused on temporal logic safety properties, and oracles are derived automatically. <p> In our toolset, oracle state machines are constructed through the following chain of events. First, safety properties are specified by the system engineer using the temporal logic syntax described earlier <ref> [16] </ref>. Next, as an engineering convenience, our toolset automatically translates the temporal logic formulae into Esterel [4] programs. These programs express deterministic finite-state machines, which we extract easily by invoking the Esterel compiler. The resulting information is then automatically analyzed and eventually linked with the test harness and the application.
Reference: [17] <author> L. Jagadeesan, C. Puchol, and J. Von Olnhausen. </author> <title> A formal approach to reactive systems software: A telecommunications application in Esterel. Formal Methods in System Design, </title> <type> 8(2), </type> <month> March </month> <year> 1996. </year>
Reference-contexts: Even when existing switch software is not compatible with our testing technique, it may still be possible to upgrade the software to satisfy the tool's requirements. For example, in a separate study <ref> [17] </ref>, we re-wrote part of the 5ESS software. This new system satisfied the synchrony hypothesis and would have met our testing tool's interface requirements. Provides a limited scope, but cost-effective testing strategy. We saw that this approach was excellent at finding problems involving rare scenarios.
Reference: [18] <author> L. Jangadeesan, C. Puchol, A. Porter, J. C. Ramming, , and L. G. Votta. </author> <title> Specification-based testing of reactive software: Tools and experiments. </title> <booktitle> In The Nineteenth International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1997. </year>
Reference-contexts: We realized that if we formally specified the code to be inspected, we might be able to create oracles and automatically test it. Therefore, we built a system to do this <ref> [18] </ref>. We soon realized that this system might be applicable in an industrial setting. We grabbed the nearest development manager and tried to sell our idea to her.
Reference: [19] <author> A. S. Lee. </author> <title> A scientific methodology for mis case studies. </title> <journal> MIS Quarterly, </journal> <pages> pages 33-50, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: Most of our previous empirical work involves controlled experiments of well-established technology. However, since this study involved new technology, we felt that a more descriptive, less controlled approach was needed <ref> [19] </ref>. Also it was important to find a good compromise between the cost to perform the study, the information learned, and the degree to which we intruded on the projects we would be working with. Therefore, we decided to perform a case study (See Figure 1).
Reference: [20] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems, Specification. </title> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: In our approach requirements are specified as a restricted class of temporal logic safety properties <ref> [20] </ref>. From these specifications we automatically generate finite state machines (FSMs) that accept the language of input-output traces that violate the safety properties. <p> Consequently, safety properties are sufficient to describe the intended behavior of most reactive systems. Temporal logic is a well-known formalism for specifying safety properties, and our specification language is based on its propositional linear-time variant <ref> [20] </ref>. The specifications used by our tool are written with a specially designed notation.
Reference: [21] <author> K. Martersteck and A. Spencer. </author> <title> Introduction to the 5ESS(TM) switching system. </title> <journal> AT&T Technical Journal, </journal> <volume> 64(6 part </volume> 2):1305-1314, July-August 1985. 
Reference-contexts: As you move from left to right these properties change as indicated. Reactive systems are also ubiquitous in the software for Lucent Technologies' 5ESS R fl telephone switching system <ref> [21] </ref>, which provides telecommunications services. Reactive systems are often safety-critical and must be thoroughly tested to ensure that they meet stringent requirements. Since the number of potential input sequences that a reactive system must handle is infinite, much testing is needed to establish confidence in the system.
Reference: [22] <author> J. Musa, A. Iannino, and K. Okumoto. </author> <title> Software Reliability: Measurement, Prediction, Application. </title> <publisher> McGraw Hill Book Company, </publisher> <year> 1987. </year> <note> See pages 227ff. </note>
Reference-contexts: Another enhancement to our tool that might be useful is to allow inputs to be selected with non-uniform weights. Sometimes testers may wish to exercise the systems in conditions closely approximating its intended use, for example, using notions of operational profiling <ref> [22] </ref>. Other times they may want to overload the system with a certain type or sequence of operations, for example, when performing stress-testing. Error Detection Effectiveness. One aspect of the tool's cost-benefits is that it is designed to ensure conformance to certain specifications.
Reference: [23] <author> O. Parissis and F. Ouabdesselam. </author> <title> Specification-based testing of synchronous software. </title> <booktitle> In Proceedings of the 4th ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <year> 1996. </year>
Reference-contexts: Dillon and Yu indicate that they are currently developing tools to support this method, and that they will be integrated with Richardson's TAOS [26] test management system. Parissis&Ouabdesselam <ref> [23] </ref> present a technique for testing whether reactive software satisfies specifications written in Lustre [12], a synchronous data-flow language that can also be viewed as a temporal logic.
Reference: [24] <author> D. Pitt and D. Freestone. </author> <title> The derivation of conformance tests from LOTOS specifications. </title> <journal> IEEE Transac tions on Software Engineering, </journal> <volume> 16(12) </volume> <pages> 1337-1343, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: For example, Gaudel [10] presents a framework for the testing of algebraic specifications. Brinksma et al. [5, 6] present a theory of testing based on labeled transition systems, and applications to the specification language LOTOS are shown in <ref> [6, 24] </ref>. 3 The Testing Framework And Tools 3.1 The Computation Model Our tools test reactive applications [11].
Reference: [25] <author> S. Redwine and W. Riddle. </author> <booktitle> Software technology maturation. In Proceedings of 8 th International Conference on Software Engineeering, </booktitle> <month> May </month> <year> 1985. </year>
Reference-contexts: This problem has been widely discussed and many articles have pointed out possible causes. We argue that many of these articles are "outward-looking". That is, they suggest that the biggest barriers to transfer lie outside the technology itself. For example, Sam Redwine and William Riddle <ref> [25] </ref> claim that it takes about 20 years for technology to get into use. Tom Allen [1] suggests that social factors can lengthen or reduce this interval. We also hear that that practitioner's resist change and that they lack the required mathematical training to use formal methods [13].
Reference: [26] <author> D. Richardson. TAOS: </author> <title> Testing with analysis and oracle support. </title> <booktitle> In Proceedings of the International Sym posium on Software Testing and Analysis, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: Dillon and Yu indicate that they are currently developing tools to support this method, and that they will be integrated with Richardson's TAOS <ref> [26] </ref> test management system. Parissis&Ouabdesselam [23] present a technique for testing whether reactive software satisfies specifications written in Lustre [12], a synchronous data-flow language that can also be viewed as a temporal logic.
Reference: [27] <author> D. Richardson, S. Aha, and T. O'Malley. </author> <title> Specification-based test oracles for reactive systems. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: We have used standard temporal logic rather than Graphical Interval Logic or Lustre mainly to take advantage of some temporal logic tools that we had developed in the course of earlier work [16]. Richardson et al. <ref> [27] </ref> present an approach for deriving oracles from formal multi-paradigm specifications. Our approach is focused on temporal logic safety properties, and oracles are derived automatically. Our approach is a form of conformance testing - black-box testing for determining whether an implementation exhibits the behavior prescribed by its specification. <p> We are currently exploring this connection. The Signal Mapping Problem. One difficult problem that arises in practice involves mapping specification names onto implementation names. This can be necessary when the specifications are written at a higher level of abstraction than the implementation. The work of Richardson et al <ref> [27] </ref> takes a significant step towards solving this problem, but more work is still needed in this direction. Tool Enhancements. Although our current tools are written in C, the test system is inherently language-independent.
Reference: [28] <author> B. Selic, G. Gullekson, and P. Ward. </author> <title> Real-Time Object Oriented Modeling. </title> <publisher> John Wiley and Sons, Inc., </publisher> <year> 1994. </year>
Reference-contexts: An interesting observation is that object-oriented designs naturally conform to our interface. They have constructors, destructors, and driver methods. Also, since some of the system design in the telecommunications industry is done using object-oriented CASE tools such as Real-Time Object-Oriented Modeling (ROOM)/ObjecTime <ref> [28] </ref> and O-Charts/O-MATE [15] an object-oriented extension of Statecharts [14], there is a clear opportunity to create test-enabled applications in conjunction with these executable design tools. 13 This looks promising because these objects satisfy the synchrony hypothesis by design [28]. <p> done using object-oriented CASE tools such as Real-Time Object-Oriented Modeling (ROOM)/ObjecTime <ref> [28] </ref> and O-Charts/O-MATE [15] an object-oriented extension of Statecharts [14], there is a clear opportunity to create test-enabled applications in conjunction with these executable design tools. 13 This looks promising because these objects satisfy the synchrony hypothesis by design [28]. The objects are essentially hierarchical finite-state machines, whose inputs are the external inputs to the system and the outputs from other objects. We are currently exploring this connection. The Signal Mapping Problem. One difficult problem that arises in practice involves mapping specification names onto implementation names.
Reference: [29] <author> L. Votta and A. Porter. </author> <title> Experimental software engineering: A report on the state of the art. </title> <booktitle> In The Seventeenth International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: Therefore, we decided to perform a case study (See Figure 1). We conducted the case study in two phases <ref> [29] </ref>. First, we ran a feasibility study in a laboratory setting. To do this we formally modeled the requirements of a small, but real, telephony application, asked several graduate students in computer science to implement them, and then tested the resulting applications using our system.
Reference: [30] <author> P. Wolper, M. Vardi, and A. Sistla. </author> <title> Reasoning about infinite computation paths. </title> <booktitle> In IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 185-194, </pages> <year> 1983. </year>
Reference-contexts: A portion of the interface functions (written in C) appears in Figure 4. 3.3.2 Oracle State Machines In order to generate test cases, our system uses the following important fact about safety properties <ref> [30] </ref>: For any safety property, there exists a finite-state machine whose language is the set of all possible finite executions that violate the property. We refer to these finite-state machines as oracles, and they are the mechanism by which an application's flaws are revealed.
Reference: [31] <author> Personal communication. Mary Zajac. </author> <month> 16 </month>
Reference-contexts: Provides a limited scope, but cost-effective testing strategy. We saw that this approach was excellent at finding problems involving rare scenarios. Since this is the most frequent root cause of problems detected in the field <ref> [31] </ref> (when the cost to repair defects is by far the greatest), the tool is very useful in these cases. The value of this tool depends on a tradeoff between machine expense and human expense.
References-found: 31

