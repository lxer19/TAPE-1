URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-239.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Title: Unshareable Dynamic Objects and How to Resolve a Conflict Between Encapsulation and Pointers  
Author: Naftaly H. Minsky 
Keyword: Category: research Topic areas: language design, architecture  
Note: Work supported by NSF grant No. CCR-9308773.  
Address: New-Brunswick, NJ 08903  
Affiliation: Computer Science Department Rutgers University  
Email: e-mail: minsky@cs.rutgers.edu  
Phone: Tel: (908) 445-2085;  
Date: January 1995  
Abstract: This paper introduces the concept of an unshareable dynamic object, i.e., an object that is created dynamically on the heap, and is guaranteed to have a unique and movable pointer leading to it. The use of such unshareable objects, whenever sharing is not required, is expected to fortify the concept of encapsulation, to make systems simpler and easier to reason about, and to make storage management safer and more efficient. We argue that unshareable objects can be implemented by means of few minor and virtually costless modifications in conventional OO languages, and we demonstrate this in detail for the Eiffel language. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H.G. Baker. </author> <title> 'use-once variables and linear objects | storage management, reflection and multi-threading. </title> <journal> ACM SIGPLAN Notices, </journal> <month> January </month> <year> 1995. </year> <title> 6 I owe the last observation to Yaron Minsky. </title> <type> 18 </type>
Reference-contexts: And the very possibility that an unshareable parameter can be unexpectedly consumed by a procedure may be devastating in this context. This particular difficulty is even more serious in Baker's proposal discussed below. The second related work has been recently reported in a very interesting paper by Baker <ref> [1] </ref>. Baker introduces a concept of linear objects, which are like our unshareable objects, but are handled differently. Linear objects are addressed by what Baker calls "use-once" variables, because every use of such a variable consumes its value.
Reference: [2] <author> L. Cardelli, J. Dinahue, L. Glassman, M. Kalsow Jordan, B., and G. Nel--son. </author> <type> Modula-3 report (revised). Technical Report 52, </type> <institution> Digital System Research Center, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: The reason is that the transfer of data from one place in a system to another is carried 1 Actually, even the hiding of such components is rarely, if ever, completely ensured, because of the unsafe features <ref> [2] </ref> that most languages have, such as the ability to use naked C-code in Eiffel and in C++. We ignore the effect of such unsafe features in this paper. 4 out, almost universally, by copy | the copy of pointers when dealing with dynamic objects.
Reference: [3] <author> Fischer A. E. and Grodzinsky F. S. </author> <title> An Anatomy of Programming Language. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: This is one reason why such aliasing is not recommended, another reason is that the order of binding determines which of the formal parameters will be nullified, and thus, eventually, the result of 3 This is an adaptation of the so called value-result parameter passing <ref> [3] </ref> 10 the computation.
Reference: [4] <author> Dougles E. Harms and Bruce W. Weide. </author> <title> Copying and swapping: Influences on the design of reusable software components. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 424-434, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: But there are deficiencies in both of these proposals, particularly for object-oriented programming (which, in fairness, was not the context in which these proposal were made.) The first of these efforts is by Harms and Weide <ref> [4] </ref>, who may have been the first to challenge the conventional use of copying as the primary mechanism for transferring data in programming. They proposed to replace all such transfers (i.e., assignment and parameter passing) with swaps, which would make all dynamic objects unshareable.
Reference: [5] <author> B. Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: This is a serious problem because invariants properties are the basis for meaningful modularization and for abstract data types. Yet, although this problem with encapsulation is not unknown (see <ref> [5] </ref> page 159, in par ticular) it is rarely discussed in literature, and has not been satisfactorily resolved so far. The lack of attention to this difficulty may be due to the fact that the second reputed benefit of encapsulation, i.e., with implementation transparency, is not effected by dynamic objects. <p> top item is thus moved into result last := last.next end; end -- class STACK 16 paradigm would replace this statement with a swap of values which, in par-ticular, will place the value of v1 into v2, violating the requirement that a variable should not hold instances of its superclasses <ref> [5] </ref>. Another problem with the scheme proposed by Harms and Weide is that it fails to protect unshareable parameters from being consumed by the procedure they are submitted to.
Reference: [6] <author> B. Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: Generally speaking, we propose that objects designated as unshareable be transferred by move rather than by copy. For the sake of specificity we couch our discussion in terms of the object-oriented language Eiffel <ref> [6] </ref>, describing in detail how unshareable objects can 2 be implemented by means of few minor, and virtually costless, modifications of this particular language.
Reference: [7] <author> N.H. Minsky. </author> <title> On the use of tokens in programming. </title> <type> Technical report, </type> <institution> Rutgers University, LCSR, </institution> <month> February </month> <year> 1995. </year> <note> (To be finished). </note>
Reference-contexts: Another impor-tant application of unshareable objects is discussed in <ref> [7] </ref>, where we show how such objects can be used to implement tokens | objects that, like the capabilities of operating systems, represent certain authority. Such un-shareable tokens can be utilized, in particular, for the control of sharing in software systems, when sharing is desirable.
Reference: [8] <author> R. Sethi. </author> <title> Programming Languages, Concepts and Constructions. </title> <publisher> Addi-son Wesley, </publisher> <year> 1989. </year> <month> 19 </month>
References-found: 8

