URL: http://griao.iro.umontreal.ca/research/papers/MDG_UMAN.ps.gz
Refering-URL: http://griao.iro.umontreal.ca/research/index_eng.html
Root-URL: http://www.iro.umontreal.ca
Email: mdgverif@iro.umontreal.ca  anon@iro.umontreal.ca  bouleric@iro.umontreal.ca  cerny@iro.umontreal.ca  fcorella@hprpcd.rose.hp.com  langevin@gmd.de  song@iro.umontreal.ca Sofiene Tahar: tahar@iro.umontreal.ca  xu@iro.umontreal.ca  zhouz@iro.umontreal.ca  
Title: MDG Tools (V1.0) Users Manual  MDG Tools (V1.0) Users Manual  Members in the group  
Author: Zijian Zhou and Nancy Boulerice Koty Dominique Anon: Nancy Boulerice: Eduard Cerny: Michel Langevin: Xiaoyu Song: Ying Xu: Zijian Zhou: 
Address: Francisco Corella:  
Web: http://www.iro.umontreal.ca/labs/lasso/research/mdgverif/mdgverif"_eng.html"  
Note: support:  
Date: June 1996 Page 1  
Pubnum: 25  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> F. Corella, Z. Zhou, X. Song, M. Langevin and E. Cerny. </author> <title> Multiway decision graphs for automated hardware verification. </title> <note> To appear in the journal Formal Methods in System Design. Available as IBM technical report RC19676. T.J. </note> <institution> Watson research center, IBM Research division, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: 1. Introduction RT (Register-Transfer) level hardware designs can be suitably represented by Multiway Decision Graphs (MDGs), a class of decision graphs that subsumes the class of ROBDDs (Reduced Ordered Binary Decision Graphs) while accommodating abstract sorts and uninterpreted function symbols <ref> [1] </ref>. In this document, we describe how to use the MDG tools - a prototype implemented in Prolog for the verification of RTL designs. The MDG tools are intended for Abstract State Machine (ASM) [1][2] verification rather than Finite State Machine (FSM) verification. <p> The MDG package implements manipulation algorithms for MDGs. The reachability analysis algorithm checks that an invariant holds in all the reachable states of an ASM using the abstract implicit enumeration technique <ref> [1] </ref>. Applications. Four applications for combinational and sequential hardware verification are provided: ASM state space exploration: reachability analysis for an ASM with an invariant which is always true. ASM safety property checking: reachability analysis for an ASM with a certain invariant. <p> In a Prolog-style declaration, [...] means a list and a string starting with an upper case character is a Prolog variable. Further references. This manual is not self-contained. Readers should refer to the references, especially <ref> [1] </ref> for terminology and techniques about Multiway Decision Graphs and reachability analysis of abstract state machines. To use the applications, though it is not necessary, some preliminary knowledge of Prolog is preferred. <p> The algebraic specification file defines sorts, function types and generic constants (see <ref> [1] </ref> for the logic) used in hardware descriptions. And if necessary, it also includes the rewrite rules which partially interpret the otherwise uninterpreted function symbols. The symbol order file provides the custom (user-defined) symbol order for all the variables and cross-operators which would appear in MDGs. <p> Example: abs_sort (wordn). It declares wordn is an abstract sort. 2. conc_sort (Sort, IndivCons) declares Sort as a concrete sort having list IndivCons as its enumer ation. Example: conc_sort (bool,[1,0]). bool is a concrete sort whose enumeration is given in the list <ref> [1, 0] </ref>, where 1 and 0 are treated as individual constants. 3. function (Func_symbol, Args_sorts, Target_sort) declares a function type. Func_symbol is the function symbol (also called as top symbol of the function). It can be an abstract function symbol or a cross-operator. <p> For sequential verification, the initial states are given by init_val/2. State variables which are initially dont cares need not be specified. In some circumstances, the initial states should be generalized in order to avoid the non-termination problem <ref> [1] </ref>. If this is the case, the initial value then has to be declared as variable using init_var/2. It is up to the user to decide which initial state value should be generalized. <p> For example, if a state variable s is of sort word2 whose enumeration is <ref> [0, 1, 2, 3] </ref> and it is encoded using 2 Boolean variables r1 and r2, then we declare one possible state encoding as: st_encode ([[r1, r2, s], [0, 0, 0], [0, 1, 1], [1, 0, 2], [1, 1, 3]]). 2.6 Manual Relation Partitioning File This file should always include the following <p> For example, if a state variable s is of sort word2 whose enumeration is [0, 1, 2, 3] and it is encoded using 2 Boolean variables r1 and r2, then we declare one possible state encoding as: st_encode ([[r1, r2, s], [0, 0, 0], <ref> [0, 1, 1] </ref>, [1, 0, 2], [1, 1, 3]]). 2.6 Manual Relation Partitioning File This file should always include the following standard head required by the Prolog system: :- multifile output_partition/2. :- multifile next_state_partition/2. :- multifile par_strategy/2. The par_strategy/2, output_partition/2 and next_state_partition/2 are declared as in Section 2.3. <p> For example, if a state variable s is of sort word2 whose enumeration is [0, 1, 2, 3] and it is encoded using 2 Boolean variables r1 and r2, then we declare one possible state encoding as: st_encode ([[r1, r2, s], [0, 0, 0], [0, 1, 1], <ref> [1, 0, 2] </ref>, [1, 1, 3]]). 2.6 Manual Relation Partitioning File This file should always include the following standard head required by the Prolog system: :- multifile output_partition/2. :- multifile next_state_partition/2. :- multifile par_strategy/2. The par_strategy/2, output_partition/2 and next_state_partition/2 are declared as in Section 2.3. <p> For example, if a state variable s is of sort word2 whose enumeration is [0, 1, 2, 3] and it is encoded using 2 Boolean variables r1 and r2, then we declare one possible state encoding as: st_encode ([[r1, r2, s], [0, 0, 0], [0, 1, 1], [1, 0, 2], <ref> [1, 1, 3] </ref>]). 2.6 Manual Relation Partitioning File This file should always include the following standard head required by the Prolog system: :- multifile output_partition/2. :- multifile next_state_partition/2. :- multifile par_strategy/2. The par_strategy/2, output_partition/2 and next_state_partition/2 are declared as in Section 2.3. <p> Port_Signal_pairs is a list of select number and input signal pairs. The select number should be within the enumeration of the sort Sort s . Input and Output must be of the same sort Sort. Example: The sort of signal select has an enumeration <ref> [0, 1, 2, 3] </ref>. component (mux1,mux (sel (select),inputs ([(0,x0),(1,x1),(3,x3)]),out put (y))). 4. Not gate: not (input (Input: bool), output (Output: bool)). Input and Output must be of Boolean sort. 5. <p> Generalizing the initial state amounts to supplying an invariant. In the general case, however, there is no guarantee that an invariant can be found to avoid non-termination. A more detailed discussion about non-termination can be found in <ref> [1] </ref>. 4.2 Controlling MDG Sizes 4.2.1 Symbol Ordering Symbol ordering is also a critical part for MDG based verification methods. The symbol ordering task can be dissembled into two parts according to the verification process.
Reference: [2] <author> F. Corella, M. Langevin, E. Cerny, Z. Zhouz and X. Song. </author> <title> State enumeration with abstract descriptions of state machines. </title> <booktitle> In Proceedings of IFIP Advanced Research Working Conference on Correct Hardware Design and Verification Methods (CHARME95). </booktitle> <address> Frankfurt, Ger-many. </address> <month> October, </month> <year> 1995. </year>
Reference-contexts: For example, if a state variable s is of sort word2 whose enumeration is <ref> [0, 1, 2, 3] </ref> and it is encoded using 2 Boolean variables r1 and r2, then we declare one possible state encoding as: st_encode ([[r1, r2, s], [0, 0, 0], [0, 1, 1], [1, 0, 2], [1, 1, 3]]). 2.6 Manual Relation Partitioning File This file should always include the following <p> For example, if a state variable s is of sort word2 whose enumeration is [0, 1, 2, 3] and it is encoded using 2 Boolean variables r1 and r2, then we declare one possible state encoding as: st_encode ([[r1, r2, s], [0, 0, 0], [0, 1, 1], <ref> [1, 0, 2] </ref>, [1, 1, 3]]). 2.6 Manual Relation Partitioning File This file should always include the following standard head required by the Prolog system: :- multifile output_partition/2. :- multifile next_state_partition/2. :- multifile par_strategy/2. The par_strategy/2, output_partition/2 and next_state_partition/2 are declared as in Section 2.3. <p> Port_Signal_pairs is a list of select number and input signal pairs. The select number should be within the enumeration of the sort Sort s . Input and Output must be of the same sort Sort. Example: The sort of signal select has an enumeration <ref> [0, 1, 2, 3] </ref>. component (mux1,mux (sel (select),inputs ([(0,x0),(1,x1),(3,x3)]),out put (y))). 4. Not gate: not (input (Input: bool), output (Output: bool)). Input and Output must be of Boolean sort. 5.
Reference: [3] <author> Z. Zhouz, X. Song, F. Corella, E. Cerny and M. Langevin. </author> <title> Partitioning transition relation automatically and efficiently. </title> <booktitle> In IEEE Proceedings of Fifth Great Lakes Symposium on VLSI (GLSVLSI95), </booktitle> <address> Buffalo, USA. </address> <month> March, </month> <year> 1995. </year>
Reference-contexts: Example: init_val (pc,init_pc). init_var (init_pc,wordn). It declares that init_pc is the initial value of pc and it is a variable of sort wordn. There are different kinds of strategies for representing transition relations <ref> [3] </ref>. Normally, we use partitioned transition relations. The user is provided with an interface to select the desired method to generate the partitioned transition relations. 7. par_strategy (OrdMethod, ParMethod) declares OrdMethod as the ordering strategy for individual relations and ParMethod as the partitioning strategy. <p> If OrdMethod=auto, the program uses the order generated by the heuristic ordering algorithm <ref> [3] </ref>. If OrdMethod=default, the program uses the order specified by next_state_partition/1 (to be explained below). If ParMethod=single, we use one partition block containing all the individual transition relations. If ParMethod=auto, the partition blocks are formed by the automatic grouping algorithm. If ParMethod=default, the partition blocks are as specified by next_state_partition/1 [3]. <p> <ref> [3] </ref>. If OrdMethod=default, the program uses the order specified by next_state_partition/1 (to be explained below). If ParMethod=single, we use one partition block containing all the individual transition relations. If ParMethod=auto, the partition blocks are formed by the automatic grouping algorithm. If ParMethod=default, the partition blocks are as specified by next_state_partition/1 [3]. 8. next_state_partition (Partitions) is a 3-level nested list. The inner most list gives a list of next state variables. The transition relation MDG containing all the variables in the list forms an individual transition relation. <p> For example, if a state variable s is of sort word2 whose enumeration is <ref> [0, 1, 2, 3] </ref> and it is encoded using 2 Boolean variables r1 and r2, then we declare one possible state encoding as: st_encode ([[r1, r2, s], [0, 0, 0], [0, 1, 1], [1, 0, 2], [1, 1, 3]]). 2.6 Manual Relation Partitioning File This file should always include the following <p> For example, if a state variable s is of sort word2 whose enumeration is [0, 1, 2, 3] and it is encoded using 2 Boolean variables r1 and r2, then we declare one possible state encoding as: st_encode ([[r1, r2, s], [0, 0, 0], [0, 1, 1], [1, 0, 2], <ref> [1, 1, 3] </ref>]). 2.6 Manual Relation Partitioning File This file should always include the following standard head required by the Prolog system: :- multifile output_partition/2. :- multifile next_state_partition/2. :- multifile par_strategy/2. The par_strategy/2, output_partition/2 and next_state_partition/2 are declared as in Section 2.3. <p> Port_Signal_pairs is a list of select number and input signal pairs. The select number should be within the enumeration of the sort Sort s . Input and Output must be of the same sort Sort. Example: The sort of signal select has an enumeration <ref> [0, 1, 2, 3] </ref>. component (mux1,mux (sel (select),inputs ([(0,x0),(1,x1),(3,x3)]),out put (y))). 4. Not gate: not (input (Input: bool), output (Output: bool)). Input and Output must be of Boolean sort. 5.
Reference: [4] <author> Z. Zhouz, X. Song, F. Corella, E. Cerny and M. Langevin. </author> <title> Description and verification of RTL designs using Multiway Decision Graphs. </title> <booktitle> In Proceedings of the Conference on Computer Hardware Description Languages and their applications (CHDL95). Chiba, </booktitle> <address> Japan. </address> <month> August, </month> <year> 1995. </year>
Reference-contexts: An MDG representing the invariant is obtained from the MDG representing the functionality of the combinational circuit by existentially quantifying the concrete inputs. The variables representing abstract inputs are left in the graph as implicitly quantified secondary variables <ref> [4] </ref>. For example, for the equivalence checking of two ASMs, we need to specify the equality of two corresponding signals as the invariant. This is expressed by the simple fork as shown in Figure 1 (a). The fork may yield different MDGs depending on the sort of the signals.
Reference: [5] <author> Z. Zhou. </author> <title> MDG Tools (V1.0) Developers Manual. </title> <month> December, </month> <year> 1995. </year> <note> MDG Tools (V1.0) Users Manual 25 June 1996 Page 20 </note>
References-found: 5

