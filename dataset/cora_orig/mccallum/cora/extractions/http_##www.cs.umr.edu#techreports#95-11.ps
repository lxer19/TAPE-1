URL: http://www.cs.umr.edu/techreports/95-11.ps
Refering-URL: http://www.cs.umr.edu/techreports/
Root-URL: 
Email: e-mail: faggies, ffg@cs.umr.edu  
Title: Wheels: An Automated Program Analysis Tool  
Author: Aggie Sun and Bruce McMillin 
Address: Rolla, MO 65401, USA  
Affiliation: Department of Computer Science University of Missouri-Rolla  
Date: March 20, 1996  
Pubnum: CSC 95-11  
Abstract: The understanding of program behavior is becoming vitally more important now that software is becoming an integral part of industry and everyday life. However, even the best documented code is often not sufficient enough to completely and correctly relay the actual program behavior. The problem lies beyond being familiar with the programming language and is hidden in the complex mathematics which govern the program's behavior. This behavior is not easily detected and varies from one program to the next. We propose a method for describing program behavior using two general properties of iterative programs: feasibility and progress. This method can be easily applied to trivial and simple code but an automated tool is required to generate the properties for more realistic code. Therefore, an automated program visualization tool was developed to illustrate the program's behavior in terms of the two properties proposed. Wheels take as input program code, reverse engineers the behavior by analyzing the code and then visually relays the extracted information back to the user allowing the user to gain a visual understanding of program behavior. The intent of this research is to use this understanding as 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Brown and J. Hershberger. </author> <title> Color and sound in algorithm animation. </title> <journal> IEEE Computer, </journal> <volume> 25 </volume> <pages> 52-63, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Recently, many researchers have begun exploiting the world of visualization. Much of the abstraction is better understood when it can be visualized in a graphical manner which is why visualization shows great promise in this area. <ref> [1] </ref> used animation to portray program behavior. Watching the algorithm as it progresses gives insight to the user as well as reassures that the algorithm is correct [9]. The drawback of this approach is that it is catered specifically to an algorithm.
Reference: [2] <author> M. Caplain. </author> <title> Finding invariant assertions for proving programs. </title> <booktitle> In Proceedings International Conference on Reliable Software, </booktitle> <pages> pages 165-171. </pages> <address> Los Angeles, CA, </address> <month> April 21-23 </month> <year> 1975. </year>
Reference-contexts: We use this knowledge to explore what causes a program (or mathematical system) to behave this way. Linear Algebra lends itself quite conveniently to solving this problem. In <ref> [2] </ref>, a program loop is transformed into a system of linear equations. Eigenvalue analysis is then used to find the invariants of the loop. We extend this idea and use the invariants to express the rate and direction of the progress property. <p> We will first derive the transformation for a section of straight line code. This derivation is similar to the one found in <ref> [2] </ref> for loop invariants. Let x 1 ; x 2 ; :::x n represent the program variables used and defined within these lines of code.
Reference: [3] <author> H. Chernoff. </author> <title> The use of faces to represent points in a k-dimensional space graphically. </title> <journal> Journal of the American Statistical Association, </journal> <volume> 68(342) </volume> <pages> 361-368, </pages> <month> June </month> <year> 1973. </year>
Reference-contexts: We did not want to impose new learning factors on top of trying to understand the program's expected behavior. 9 rotation spokes reflectors wheel tire width speed We chose to use a glyph representation similar to Chernoff faces <ref> [3] </ref> and SMILI [11] for the appearance of our tool. Glyphs are graphical objects which bind data to different attributes of the object, such as color, shape, size, etc.
Reference: [4] <author> L. Clarke. </author> <title> A system to generate test data and symbolically execute programs. </title> <journal> IEEE Trans. Software Engr., </journal> <volume> SE-2(3):215-222, </volume> <month> September </month> <year> 1976. </year>
Reference-contexts: Early in the 70's, flow charts were used to show control flow and program structure, but they did not give insight as to what type of generated results could be expected. Semantic and symbolic evaluations tried to extract meaning about a program's functionality [14], <ref> [4] </ref>. However, much of this meaning was hidden behind mathematical notation that distracted the user from the real meaning of the program. Recently, many researchers have begun exploiting the world of visualization.
Reference: [5] <author> P. Cousot and R. Cousot. </author> <title> Static determination of dynamic properties of programs. </title> <booktitle> In 2nd International Symposium on Programming, </booktitle> <pages> pages 106-130, </pages> <year> 1976. </year> <month> 19 </month>
Reference-contexts: Definition 3.2 [18] The polyhedron A is convex if the line defined by [x,y] is a subset of A whenever x; y 2 A. The shape of the polyhedron changes with respect to each assignment to a variable. When a loop is encountered, a widening technique by Cousot [6] <ref> [5] </ref> can be performed on the polyhedron to determine the outer rays of the polyhedron. The widening technique examines the outer most rays of the polyhedron after each iteration and replaces the current set of rays with the widest computed set.
Reference: [6] <author> P. Cousot and N. Halbwachs. </author> <title> Automatic discovery of linear restraints among variables of a program. </title> <booktitle> In Conference Record of the Fifth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-96, </pages> <month> January 23-25 </month> <year> 1978. </year>
Reference-contexts: The domains of each variable are projected into n-space such that each variable lies in one dimension. The cross product of the variable's domains mapped in n-space form a polyhedra. The operations of the program define the shape of the polyhedra as in <ref> [6] </ref>. The edges of the polyhedra in turn, define the set of constraints, or boundary, for the program's domain space. <p> Definition 3.2 [18] The polyhedron A is convex if the line defined by [x,y] is a subset of A whenever x; y 2 A. The shape of the polyhedron changes with respect to each assignment to a variable. When a loop is encountered, a widening technique by Cousot <ref> [6] </ref> [5] can be performed on the polyhedron to determine the outer rays of the polyhedron. The widening technique examines the outer most rays of the polyhedron after each iteration and replaces the current set of rays with the widest computed set.
Reference: [7] <author> S. S. Kapur D. R. Chand. </author> <title> An algorithm for convex polytopes. </title> <journal> Journal of the ACM, </journal> <volume> 17 </volume> <pages> 78-86, </pages> <month> January </month> <year> 1970. </year>
Reference-contexts: Since the union of a set of convex hulls is not necessary itself a convex hull, the convex hull of the resulting polyhedron must also be determined. The convex hull can be found using any of the following algorithms: <ref> [8, 7, 10] </ref>. The if-then-else construct can now be replaced by the constraints which define the minimal/maximal changes of each variable. This is known as collapsing the branching construct.
Reference: [8] <author> M. E. Dyer and L. G. Proll. </author> <title> An algorithm for determining all extreme points of a convex polytope. </title> <booktitle> In Mathematical Programming, </booktitle> <volume> volume 12, </volume> <pages> pages 81-96, </pages> <year> 1977. </year>
Reference-contexts: Since the union of a set of convex hulls is not necessary itself a convex hull, the convex hull of the resulting polyhedron must also be determined. The convex hull can be found using any of the following algorithms: <ref> [8, 7, 10] </ref>. The if-then-else construct can now be replaced by the constraints which define the minimal/maximal changes of each variable. This is known as collapsing the branching construct.
Reference: [9] <author> K. C. Cox G-C. Roman. </author> <title> A declarative approach to visualizing concurrent computations. </title> <booktitle> Computer, </booktitle> <pages> pages 25-36, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Watching the algorithm as it progresses gives insight to the user as well as reassures that the algorithm is correct <ref> [9] </ref>. The drawback of this approach is that it is catered specifically to an algorithm. The major differences between our tool and methods listed above are the types of properties depicted, and the generality of the representation.
Reference: [10] <author> R. L. Graham. </author> <title> An efficient algorithm for determining the convex hull of a planar set. </title> <journal> In Information Processing Letters, </journal> <volume> volume 1, </volume> <pages> pages 132-133, </pages> <year> 1972. </year>
Reference-contexts: Since the union of a set of convex hulls is not necessary itself a convex hull, the convex hull of the resulting polyhedron must also be determined. The convex hull can be found using any of the following algorithms: <ref> [8, 7, 10] </ref>. The if-then-else construct can now be replaced by the constraints which define the minimal/maximal changes of each variable. This is known as collapsing the branching construct.
Reference: [11] <author> R. Khanna and B. McMillin. </author> <title> Smili visualization of asynchronous massively parallel programs. </title> <journal> J. of Systems and Software, </journal> <volume> 19(3) </volume> <pages> 261-275, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: We did not want to impose new learning factors on top of trying to understand the program's expected behavior. 9 rotation spokes reflectors wheel tire width speed We chose to use a glyph representation similar to Chernoff faces [3] and SMILI <ref> [11] </ref> for the appearance of our tool. Glyphs are graphical objects which bind data to different attributes of the object, such as color, shape, size, etc.
Reference: [12] <author> T. Rajan M. Eisenstadt, J. Domingue and E. </author> <title> Motta. </title> <journal> Visual knowledge engineering. IEEE Trans. Software Engr., </journal> <volume> 16(10), </volume> <month> October </month> <year> 1990. </year>
Reference-contexts: This is in contrast to visual programming which focusses on the development of programs through graphical languages. <ref> [12] </ref> define nine key dimensions to enhance the effect of creating a more pleasant automated user-interface. This set of criteria is not exhaustive, but they do serve as a good guideline for what users prefer in a visual environment.
Reference: [13] <author> B. McMillin and L. Ni. </author> <title> Byzantine fault tolerance through application-oriented specification. </title> <booktitle> In Proceedings of the 11th International COMPSAC, </booktitle> <pages> pages 347-353. </pages> <address> Tokyo, JAPAN, </address> <month> October </month> <year> 1987. </year>
Reference-contexts: The major differences between our tool and methods listed above are the types of properties depicted, and the generality of the representation. Our approach is based on a common feature of iterative programs observed when studying application-based fault-tolerant methods <ref> [13] </ref>. We noticed that by defining the domain space and the rate of convergence, we were able to detect errors during run-time. If we are able to assert correctly during run-time whether or not a program is behaving correctly, then 2 this characteristic is worthy to take note of.
Reference: [14] <author> B. Elspas R.S. Boyer and K.N. Levitt. </author> <title> Select-a formal system for testing and debugging programs by symbolic execution. </title> <booktitle> In Int'l Conference on Reliable Software, </booktitle> <pages> pages 234-245. </pages> <address> Los Angeles, CA, </address> <month> April 21-23 </month> <year> 1975. </year>
Reference-contexts: Early in the 70's, flow charts were used to show control flow and program structure, but they did not give insight as to what type of generated results could be expected. Semantic and symbolic evaluations tried to extract meaning about a program's functionality <ref> [14] </ref>, [4]. However, much of this meaning was hidden behind mathematical notation that distracted the user from the real meaning of the program. Recently, many researchers have begun exploiting the world of visualization.
Reference: [15] <author> M. C. Nelson S.G. Eick and J. D. Schmidt. </author> <title> Graphical analysis of computer log files. </title> <journal> Communications of the ACM, </journal> <volume> 37(12) </volume> <pages> 50-56, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: interactions of the two properties feasibility and progress to find answers to questions such as: does the program converge, do the constraints move, is there a defined set of solutions? While traditional methods start with looking at the results and trace back to find the cause, our method similar to <ref> [15] </ref> begins with the relationships and looks for the result. Such knowledge of a program's behavior can therefore benefit many fields in computer science such as preventing or detecting software faults, verification, and testing.
Reference: [16] <author> Aggie Y. Sun. </author> <title> A declarative approach to generalizing the understanding of program behavior through program visualization. </title> <type> Master's thesis, </type> <institution> University of Missouri - Rolla, </institution> <year> 1996. </year>
Reference-contexts: In terms of feasibility, the program domains that corresponded with a pattern were more easily comprehendable. For example, if the domain gradual decreased, this was easier to recognize than the innuendos of the fluctuations. Further discussion of the results can be found in <ref> [16] </ref>. Validation To validate our tool, we chose to study the Jacobi Method, an iterative method with a known asymptotic convergence rate. We expected to see the solution converge to a single point according to the spectral radius. This is a known behavior for this algorithm.
Reference: [17] <author> C. Lassez T. Huynh and J. Lassez. </author> <title> Practical issues on the projection of polyhedral sets. </title> <type> Technical report, </type> <institution> IBM T. J. Watson Research Center, </institution> <year> 1990. </year>
Reference-contexts: The result is a new set of vertices where 8 x 2 V j x = x 0 . A convex hull is constructed from the set of points to reduce the number of vertices and constraints on the polyhedron. <ref> [17] </ref>. Definition 3.2 [18] The polyhedron A is convex if the line defined by [x,y] is a subset of A whenever x; y 2 A. The shape of the polyhedron changes with respect to each assignment to a variable.
Reference: [18] <author> M. M. Kovalev V. A. Yemelichev and M. K. Kravtsov. </author> <title> Polytopes, Graphs and Optimisation. </title> <publisher> Cambridge University Press, </publisher> <year> 1984. </year>
Reference-contexts: A variable is considered "live" if the value can be changed within the construct. Given a set of vertices corresponding to the domains of the program variables, Definition 1 shows how the set of vertices are transformed by an assignment statement. Definition 3.1 <ref> [18] </ref> Let x; y 2 R n , be two program variables and V be the set of vertices defining the polyhedron in n-space. The assignment to the variable x is: x 0 = f (x; y). <p> The result is a new set of vertices where 8 x 2 V j x = x 0 . A convex hull is constructed from the set of points to reduce the number of vertices and constraints on the polyhedron. [17]. Definition 3.2 <ref> [18] </ref> The polyhedron A is convex if the line defined by [x,y] is a subset of A whenever x; y 2 A. The shape of the polyhedron changes with respect to each assignment to a variable.
Reference: [19] <author> J. Eble W. Ribarsky, E. Ayers and S. Mukherjea. Glyphmaker: </author> <title> Creating customized visualizations of complex data. </title> <journal> Computer, </journal> <volume> 27 </volume> <pages> 57-64, </pages> <month> July </month> <year> 1994. </year> <month> 20 </month>
Reference-contexts: Glyphs are graphical objects which bind data to different attributes of the object, such as color, shape, size, etc. Glyphs are an effective representation because they allow the user to view and correlate several variables at once. <ref> [19] </ref> allows the user to create their own glyphs to visualize their application. We differ in that our objective is to visualize the same behavior in different applications, therefore, we use a standard glyph. The glyph that we chose is a representation of a wheel shown in Figure 1.
References-found: 19

