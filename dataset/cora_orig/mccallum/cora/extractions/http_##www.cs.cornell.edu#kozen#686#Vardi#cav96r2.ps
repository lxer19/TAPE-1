URL: http://www.cs.cornell.edu/kozen/686/Vardi/cav96r2.ps
Refering-URL: http://www.cs.cornell.edu/kozen/686/
Root-URL: 
Email: Email: ok@research.att.com  Email: vardi@cs.rice.edu,  
Phone: 2  
Title: Verification of Fair Transition Systems  
Author: Orna Kupferman and Moshe Y. Vardi 
Web: URL: http://www.cs.rice.edu/ vardi  
Address: 600 Mountain Avenue, Murray Hill, NJ 07974, U.S.A.  P.O. Box 1892, Houston, TX 77251-1892, U.S.A.  
Affiliation: 1 Bell Laboratories,  Rice University, Department of Computer Science,  
Abstract: In program verification, we check that an implementation meets its specification. Both the specification and the implementation describe the possible behaviors of the program, though at different levels of abstraction. We distinguish between two approaches to implementation of specifications. The first approach is trace-based implementation, where we require every computation of the implementation to correlate to some computation of the specification. The second approach is tree-based implementation, where we require every computation tree embodied in the implementation to correlate to some computation tree embodied in the specification. The two approaches to implementation are strongly related to the linear-time versus branching-time dichotomy in temporal logic. In this work we examine the trace-based and the tree-based approaches from a complexity-theoretic point of view. We consider and compare the complexity of verification of fair transition systems, modeling both the implementation and the specification, in the two approaches. We consider unconditional, weak, and strong fairness. For the trace-based approach, the corresponding problem is language containment. For the tree-based approach, the corresponding problem is fair simulation. We show that while both problems are PSPACE-complete, their complexities in terms of the size of the implementation do not coincide and the trace-based approach is more efficient. As the implementation is normally much bigger than the specification, we see this as an advantage of the trace-based approach. Our results are at variance with the known results for the case of transition systems with no fairness, where the tree-based approach is more efficient.
Abstract-found: 1
Intro-found: 1
Reference: [AL91] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction In program verification, we check that an implementation meets its specification. Both the specification and the implementation describe the possible behaviors of the program, but the implementation is more concrete than the specification, or, equivalently, the specification is more abstract than the implementation (cf. <ref> [AL91] </ref>). This basic notion of verification suggests a top-down method for design development. Starting with a highly abstract specification, we can construct a sequence of behavior descriptions. Each description refers to its predecessor as a specification, so it is less abstract than its predecessor. <p> Then, correct trace-based implementation is one in which every computation is also a computation of the specification, and correct tree-based implementation is one in which every embodied computation tree is also embodied in the specification. Numerous interpretations of correlation are suggested and studied in the literature <ref> [Hen85, Mil89, AL91] </ref>.
Reference: [ASB + 94] <author> A. Aziz, V. Singhal, F. Balarin, R. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <title> Equivalences for fair kripke structures. </title> <booktitle> In Proc. 21st Int. Colloquium on Automata, Languages and Programming, </booktitle> <address> Jerusalem, Israel, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: Then, we need the framework of fair transition systems. We consider unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) [LPS81, Eme90, MP92]. Within this framework, correct trace-based implementation corresponds to language containment and correct tree-based implementation corresponds to fair simulation <ref> [BBLS92, ASB + 94, GL94] </ref>. Hence, it is the complexity of these problems that should be examined when we compare the trace-based and the tree-based approaches. We present a uniform method and a simple algorithm for solving the language-containment problem for all the three types of fairness conditions.
Reference: [BBLS92] <author> S. Bensalem, A. Bouajjani, C. Loiseaux, and J. Sifakis. </author> <title> Property preserving simulations. </title> <booktitle> In Proc. 4th Workshop on Computer Aided Verification, volume 663 of Lecture Notes in Computer Science, </booktitle> <address> Montreal, June 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Then, we need the framework of fair transition systems. We consider unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) [LPS81, Eme90, MP92]. Within this framework, correct trace-based implementation corresponds to language containment and correct tree-based implementation corresponds to fair simulation <ref> [BBLS92, ASB + 94, GL94] </ref>. Hence, it is the complexity of these problems that should be examined when we compare the trace-based and the tree-based approaches. We present a uniform method and a simple algorithm for solving the language-containment problem for all the three types of fairness conditions.
Reference: [BGS92] <author> J. Balcazar, J. Gabarro, and M. Santha. </author> <title> Deciding bisimilarity is P-complete. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4(6) </volume> <pages> 638-648, </pages> <year> 1992. </year>
Reference-contexts: Within this framework, correct trace-based implementation corresponds to trace containment and correct tree-based implementation corresponds to simulation [Mil71]. Since simulation can be checked in polynomial time <ref> [Mil80, BGS92] </ref>, whereas the trace containment problem is PSPACE-complete [MS72] 3 , it seems that the tree-based approach is more efficient than the trace-based approach. This is reminiscent of the computational advantage of branching-time model checking over linear-time model checking [CES86, LP85, QS81, VW86]. <p> Hence, the output of ff on x is 1 iff S simulates S 0 . ut We note that our lower bound is different from the PTIME-hardness established for the bisimulation problem in <ref> [BGS92] </ref>. We consider simulation between two systems, one of them is fixed. Balcazar et al. consider bisimulation between the states of a single system, whose size is not fixed. 5 Discussion We have examined the trace-based and the tree-based approaches to implementation from a complexity-theoretic point of view.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <editor> In D. L. Dill, editor, </editor> <booktitle> Computer Aided Verification, Proc. 6th Int. Conference, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 142-155, </pages> <address> Stanford, June 1994. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: When we turn to consider the program complexity of model checking, which is the analogue to our implementation complexity, this is no longer true. The program complexity of model checking for both LTL and 8CTL ? is NLOGSPACE-complete <ref> [VW86, BVW94] </ref>. In contrast, we saw here that implementation is easier in the trace-based approach.
Reference: [CD88] <author> E.M. Clarke and I.A. Draghicescu. </author> <title> Expressibility results for linear-time and branching-time logics. In Proc. Workshop on Linear Time, Branching Time, and Partial Order in Logics and Models for Concurrency, </title> <booktitle> pages 428-437. Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: The two approaches to implementation are strongly related to the linear-time versus branching-time dichotomy in temporal logic [Pnu85]. The temporal-logic analogy to the strength of the tree-based approach is the expressiveness superiority of 8CTL ? , the universal fragment of CTL ? , over LTL <ref> [CD88] </ref>. Indeed, while a correct trace-based implementation is guaranteed to satisfy all the LTL formulas satisfied in the specification, a correct tree-based implementation is guaranteed to satisfy all the 8CTL ? formulas satisfied in the specification [GL94].
Reference: [CDK93] <author> E. M. Clarke, I. A. Draghicescu, and R. P. Kurshan. </author> <title> A unified approach for showing language containment and equivalence between various types of !-automata. </title> <journal> Information Processing Letters 46, </journal> <pages> pages 301-308, </pages> <year> (1993). </year>
Reference-contexts: Hence, it is the complexity of these problems that should be examined when we compare the trace-based and the tree-based approaches. We present a uniform method and a simple algorithm for solving the language-containment problem for all the three types of fairness conditions. Unlike <ref> [CDK93] </ref>, we consider the case where both the specification and the implementation are nondeterministic, as is appropriate in a hierarchical refinement framework. We prove that the problem is PSPACE-complete for all the three types.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: Since simulation can be checked in polynomial time [Mil80, BGS92], whereas the trace containment problem is PSPACE-complete [MS72] 3 , it seems that the tree-based approach is more efficient than the trace-based approach. This is reminiscent of the computational advantage of branching-time model checking over linear-time model checking <ref> [CES86, LP85, QS81, VW86] </ref>. Once, however, we want our implementations and specifications to describe behaviors that satisfy both liveness and safety properties, transition systems are too weak. Then, we need the framework of fair transition systems.
Reference: [Cho74] <author> Y. Choueka. </author> <title> Theories of automata on !-tapes: A simplified approach. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 8 </volume> <pages> 117-141, </pages> <year> 1974. </year>
Reference-contexts: Similarly, for all the three types of S 0 , going to S 0 U involves an at most exponential blow up. Thus, the size of the product of S U and S 0 U is exponential in the sizes of S and S 0 <ref> [Cho74] </ref> and checking it for nonemptiness can be done in space polynomial in their sizes [VW94]. Hardness in PSPACE follows from the known PSPACE lower bound for the case where both S and S 0 are unconditionally fair [Wol82].
Reference: [EL85] <author> E.A. Emerson and C.-L. Lei. </author> <title> Temporal model checking under generalized fairness constraints. </title> <booktitle> In Proc. 18th Hawaii International Conference on System Sciences, Hawaii, </booktitle> <year> 1985. </year>
Reference-contexts: The nonemptiness problem for strongly fair transition systems can be solved in polynomial time <ref> [EL85] </ref>. Given S and S 0 , we construct, as in the proof of Theorem 1, the unconditionally fair transition system S 0 U . Unlike the algorithm there, we do not translate the transition system S to an unconditionally fair system. <p> Trace-based implementations are part of the linear-time paradigm and correspond to LTL model checking. Tree-based implementations are part of the branching-time paradigm and correspond to 8CTL ? model checking. All the four problems are PSPACE-complete <ref> [SC85, EL85] </ref>. The model-checking algorithm of 8CTL ? uses as a subroutine the model-checking algorithm of LTL [EL85]. In a similar manner, our fair-simulation algorithm uses as a subroutine the language-containment algorithm. So, the implementation dichotomy and the temporal-logic dichotomy have a lot in common. <p> Tree-based implementations are part of the branching-time paradigm and correspond to 8CTL ? model checking. All the four problems are PSPACE-complete [SC85, EL85]. The model-checking algorithm of 8CTL ? uses as a subroutine the model-checking algorithm of LTL <ref> [EL85] </ref>. In a similar manner, our fair-simulation algorithm uses as a subroutine the language-containment algorithm. So, the implementation dichotomy and the temporal-logic dichotomy have a lot in common.
Reference: [Eme90] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <booktitle> Handbook of theoretical computer science, </booktitle> <pages> pages 997-1072, </pages> <year> 1990. </year>
Reference-contexts: Once, however, we want our implementations and specifications to describe behaviors that satisfy both liveness and safety properties, transition systems are too weak. Then, we need the framework of fair transition systems. We consider unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) <ref> [LPS81, Eme90, MP92] </ref>. Within this framework, correct trace-based implementation corresponds to language containment and correct tree-based implementation corresponds to fair simulation [BBLS92, ASB + 94, GL94]. Hence, it is the complexity of these problems that should be examined when we compare the trace-based and the tree-based approaches.
Reference: [GHR95] <author> R. Greenlaw, H.J. Hoover, and W.L. Ruzzo. </author> <title> Limits of parallel computation. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Also, if S 0 is fixed, we have only linearly many candidate relations to check. Hence, the problem is in PTIME. We prove hardness in PTIME by reducing the NAND Circuit Value Problem (NANDCV), proved to be PTIME-complete in <ref> [Gol77, GHR95] </ref>, to the problem of determining whether a transition system S simulates a fixed transition system S 0 .
Reference: [GL94] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: Indeed, while a correct trace-based implementation is guaranteed to satisfy all the LTL formulas satisfied in the specification, a correct tree-based implementation is guaranteed to satisfy all the 8CTL ? formulas satisfied in the specification <ref> [GL94] </ref>. In this work we examine the traced-based and the tree-based approaches from a complexity-theoretic point of view. <p> Then, we need the framework of fair transition systems. We consider unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) [LPS81, Eme90, MP92]. Within this framework, correct trace-based implementation corresponds to language containment and correct tree-based implementation corresponds to fair simulation <ref> [BBLS92, ASB + 94, GL94] </ref>. Hence, it is the complexity of these problems that should be examined when we compare the trace-based and the tree-based approaches. We present a uniform method and a simple algorithm for solving the language-containment problem for all the three types of fairness conditions.
Reference: [Gol77] <author> L.M. Goldschlager. </author> <title> The monotone and planar circuit value problems are log space complete for p. </title> <journal> SIGACT News, </journal> <volume> 9(2) </volume> <pages> 25-29, </pages> <year> 1977. </year>
Reference-contexts: Also, if S 0 is fixed, we have only linearly many candidate relations to check. Hence, the problem is in PTIME. We prove hardness in PTIME by reducing the NAND Circuit Value Problem (NANDCV), proved to be PTIME-complete in <ref> [Gol77, GHR95] </ref>, to the problem of determining whether a transition system S simulates a fixed transition system S 0 .
Reference: [Hen85] <author> M. Hennessy. </author> <title> Algebraic theory of Processes. </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1985. </year>
Reference-contexts: Then, correct trace-based implementation is one in which every computation is also a computation of the specification, and correct tree-based implementation is one in which every embodied computation tree is also embodied in the specification. Numerous interpretations of correlation are suggested and studied in the literature <ref> [Hen85, Mil89, AL91] </ref>.
Reference: [Kel76] <author> R.M. Keller. </author> <title> Formal verification of parallel programs. </title> <journal> Comm ACM, </journal> <volume> 19 </volume> <pages> 371-384, </pages> <year> 1976. </year>
Reference-contexts: Therefore, of particular interest to us is the implementation complexity of these problems; i.e., their complexity in terms of I, assuming S is fixed. We model specifications and implementations by transition systems <ref> [Kel76] </ref>. The systems are defined over the sets AP I and AP S of atomic propositions used in the implementation and specification, respectively. Thus, the alphabets of the systems are 2 AP I and 2 AP S . Recall that usually the implementation has more variables than the specification.
Reference: [Kur94] <author> R.P. Kurshan. </author> <title> Computer-Aided Verification of Coordinating Processesl. </title> <publisher> Princeton Univ. Press, </publisher> <year> 1994. </year>
Reference-contexts: Each description refers to its predecessor as a specification, so it is less abstract than its predecessor. The last description contains no abstractions, and constitutes the implementation. Hence the name hierarchical refinement for this methodology (cf. <ref> [LS84, LT87, Kur94] </ref>). We distinguish between two approaches to implementation of specifications. The first approach is trace-based implementation, where we require every computation of the implementation to correlate to some computation of the specification.
Reference: [LP85] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107, </pages> <address> New Orleans, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: Since simulation can be checked in polynomial time [Mil80, BGS92], whereas the trace containment problem is PSPACE-complete [MS72] 3 , it seems that the tree-based approach is more efficient than the trace-based approach. This is reminiscent of the computational advantage of branching-time model checking over linear-time model checking <ref> [CES86, LP85, QS81, VW86] </ref>. Once, however, we want our implementations and specifications to describe behaviors that satisfy both liveness and safety properties, transition systems are too weak. Then, we need the framework of fair transition systems.
Reference: [LPS81] <author> D. Lehman, A. Pnueli, and J. Stavi. Impartiality, </author> <title> justice, and fairness the ethic of concurrent termination. </title> <booktitle> In Proc. 8th Colloq. on Automata, Programming, and Languages (ICALP), volume 115 of Lecture Notes in Computer Science, </booktitle> <pages> pages 264-277. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1981. </year>
Reference-contexts: Once, however, we want our implementations and specifications to describe behaviors that satisfy both liveness and safety properties, transition systems are too weak. Then, we need the framework of fair transition systems. We consider unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) <ref> [LPS81, Eme90, MP92] </ref>. Within this framework, correct trace-based implementation corresponds to language containment and correct tree-based implementation corresponds to fair simulation [BBLS92, ASB + 94, GL94]. Hence, it is the complexity of these problems that should be examined when we compare the trace-based and the tree-based approaches.
Reference: [LS84] <author> S.S. Lam and A.U. Shankar. </author> <title> Protocol verification via projection. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 10 </volume> <pages> 325-342, </pages> <year> 1984. </year>
Reference-contexts: Each description refers to its predecessor as a specification, so it is less abstract than its predecessor. The last description contains no abstractions, and constitutes the implementation. Hence the name hierarchical refinement for this methodology (cf. <ref> [LS84, LT87, Kur94] </ref>). We distinguish between two approaches to implementation of specifications. The first approach is trace-based implementation, where we require every computation of the implementation to correlate to some computation of the specification.
Reference: [LT87] <author> N. A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proc. 6th ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 137-151, </pages> <year> 1987. </year>
Reference-contexts: Each description refers to its predecessor as a specification, so it is less abstract than its predecessor. The last description contains no abstractions, and constitutes the implementation. Hence the name hierarchical refinement for this methodology (cf. <ref> [LS84, LT87, Kur94] </ref>). We distinguish between two approaches to implementation of specifications. The first approach is trace-based implementation, where we require every computation of the implementation to correlate to some computation of the specification.
Reference: [Mil71] <author> R. Milner. </author> <title> An algebraic definition of simulation between programs. </title> <booktitle> In Proceedings of the 2nd International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 481-489, </pages> <month> September </month> <year> 1971. </year>
Reference-contexts: In other words, associating computations and computation trees of the implementation with these of the specification, we first projet them on AP S . Within this framework, correct trace-based implementation corresponds to trace containment and correct tree-based implementation corresponds to simulation <ref> [Mil71] </ref>. Since simulation can be checked in polynomial time [Mil80, BGS92], whereas the trace containment problem is PSPACE-complete [MS72] 3 , it seems that the tree-based approach is more efficient than the trace-based approach.
Reference: [Mil80] <author> R. Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year>
Reference-contexts: The tree-based approach is stronger in the following sense. If I is a correct tree-based implementation of the specification S, then I is also a correct trace-based implementation of S. As shown by Milner <ref> [Mil80] </ref>, the opposite direction is not true. The two approaches to implementation are strongly related to the linear-time versus branching-time dichotomy in temporal logic [Pnu85]. <p> Within this framework, correct trace-based implementation corresponds to trace containment and correct tree-based implementation corresponds to simulation [Mil71]. Since simulation can be checked in polynomial time <ref> [Mil80, BGS92] </ref>, whereas the trace containment problem is PSPACE-complete [MS72] 3 , it seems that the tree-based approach is more efficient than the trace-based approach. This is reminiscent of the computational advantage of branching-time model checking over linear-time model checking [CES86, LP85, QS81, VW86].
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrecny. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Clifs, </address> <year> 1989. </year>
Reference-contexts: Then, correct trace-based implementation is one in which every computation is also a computation of the specification, and correct tree-based implementation is one in which every embodied computation tree is also embodied in the specification. Numerous interpretations of correlation are suggested and studied in the literature <ref> [Hen85, Mil89, AL91] </ref>.
Reference: [Mil90] <author> R. Milner. </author> <title> Operational and algebraic semantics of concurrent processes. </title> <booktitle> Handbook of theoretical computer science, </booktitle> <pages> pages 1201-1242, </pages> <year> 1990. </year>
Reference-contexts: Our algorithm uses the language-containment algorithm as a subroutine. We prove that the problem is PSPACE-complete for all the three types. Like Milner's algorithm for checking simulation <ref> [Mil90] </ref>, our algorithm can be implemented as a calculation of a fixed-point expression, significantly improving its practicality. The running time of our algorithm is polynomial in the size of the implementation. <p> Thus, fixing S, the problem of checking a candidate relation H is in PTIME. Instead of guessing a relation H and checking it, we do a fixed-point computation as follows (cf. <ref> [Mil90] </ref>). Let H 0 = fhw; w 0 i : w 2 W; w 0 2 W 0 ; and L (w) = L (w 0 )g. Thus, H 0 is the maximal relation that satisfies condition (1) of fair simulation.
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Once, however, we want our implementations and specifications to describe behaviors that satisfy both liveness and safety properties, transition systems are too weak. Then, we need the framework of fair transition systems. We consider unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) <ref> [LPS81, Eme90, MP92] </ref>. Within this framework, correct trace-based implementation corresponds to language containment and correct tree-based implementation corresponds to fair simulation [BBLS92, ASB + 94, GL94]. Hence, it is the complexity of these problems that should be examined when we compare the trace-based and the tree-based approaches.
Reference: [MS72] <author> A.R. Meyer and L.J. Stockmeyer. </author> <title> The equivalence problem for regular expressions with squaring requires exponential time. </title> <booktitle> In Proc. 13th IEEE Symp. on Switching and Automata Theory, </booktitle> <pages> pages 125-129, </pages> <year> 1972. </year>
Reference-contexts: Within this framework, correct trace-based implementation corresponds to trace containment and correct tree-based implementation corresponds to simulation [Mil71]. Since simulation can be checked in polynomial time [Mil80, BGS92], whereas the trace containment problem is PSPACE-complete <ref> [MS72] </ref> 3 , it seems that the tree-based approach is more efficient than the trace-based approach. This is reminiscent of the computational advantage of branching-time model checking over linear-time model checking [CES86, LP85, QS81, VW86]. <p> For the case the implementation uses the strong fairness condition, we suggest an alternative algorithm that runs in time polynomial in the size of the implementation. We show that these algorithms are optimal; thus the implementation complexity of language containment 3 The reduction in <ref> [MS72] </ref> considers containment of languages defined by regular expressions and can be extended to consider trace containment. is NLOGSPACE-complete for implementations that use the unconditional or weak fairness conditions and is PTIME-complete for implementations that use the strong fairness condition. <p> The uni versality problem is to determine whether a given transition system is universal. Meyer and Stockmeyer proved that the problem of determining whether the language of an automaton over finite words is fl is PSPACE-complete <ref> [MS72] </ref>. We give here the details of the proof, easily adjusted to infinite words. Theorem 7. The universality problem is PSPACE-hard. Proof (sketch): We do a reduction from polynomial-space Turing machines.
Reference: [Pla84] <author> D.A. Plaisted. </author> <title> Complete problems in the first-order predicate claculus. </title> <journal> J. on Computer and System Sciences, </journal> <volume> 29(1) </volume> <pages> 8-35, </pages> <year> 1984. </year>
Reference-contexts: Thus, a propositional anti-Horn clause is either of the form p ! q 1 _ _ q n (an empty disjunction is equivalent to false) or of the form q 1 _ _ q n . As Propositional-Horn Satisfiability is PTIME-complete <ref> [Pla84] </ref>, then clearly, so is PAHS.
Reference: [Pnu85] <author> A. Pnueli. </author> <title> Linear and branching structures in the semantics and logics of reactive systems. </title> <booktitle> In Proc. 12th Int. Colloquium on Automata, Languages and Programming, </booktitle> <pages> pages 15-32. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: If I is a correct tree-based implementation of the specification S, then I is also a correct trace-based implementation of S. As shown by Milner [Mil80], the opposite direction is not true. The two approaches to implementation are strongly related to the linear-time versus branching-time dichotomy in temporal logic <ref> [Pnu85] </ref>. The temporal-logic analogy to the strength of the tree-based approach is the expressiveness superiority of 8CTL ? , the universal fragment of CTL ? , over LTL [CD88].
Reference: [QS81] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in Cesar. </title> <booktitle> In Proc. 5th Int'l Symp. on Programming, </booktitle> <volume> volume 137, </volume> <pages> pages 337-351. </pages> <note> Springer-Verlag, Lecture Notes in Computer Science, </note> <year> 1981. </year>
Reference-contexts: Since simulation can be checked in polynomial time [Mil80, BGS92], whereas the trace containment problem is PSPACE-complete [MS72] 3 , it seems that the tree-based approach is more efficient than the trace-based approach. This is reminiscent of the computational advantage of branching-time model checking over linear-time model checking <ref> [CES86, LP85, QS81, VW86] </ref>. Once, however, we want our implementations and specifications to describe behaviors that satisfy both liveness and safety properties, transition systems are too weak. Then, we need the framework of fair transition systems.
Reference: [Saf88] <author> S. Safra. </author> <title> On the complexity of omega-automata. </title> <booktitle> In Proceedings of the 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <address> White Plains, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: S (n; m) ! U (n2 O (m) ) [not hard, and will be proven in the full version]. This is how we perform step (2) for the three possible types of S 0 . 1. U (n) ! U (2 O (n log n) ) <ref> [Saf88] </ref>. 3. S (n; m) ! U (2 O (nm log (nm)) ) [Saf92]. For all the three types of S, going to S U involves an at most exponential blow up.
Reference: [Saf92] <author> S. Safra. </author> <title> Exponential determinization for !-automata with strong-fairness acceptance condition. </title> <booktitle> In Proceedings of the 24th ACM Symposium on Theory of Computing, </booktitle> <address> Victoria, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: This is how we perform step (2) for the three possible types of S 0 . 1. U (n) ! U (2 O (n log n) ) [Saf88]. 3. S (n; m) ! U (2 O (nm log (nm)) ) <ref> [Saf92] </ref>. For all the three types of S, going to S U involves an at most exponential blow up. Similarly, for all the three types of S 0 , going to S 0 U involves an at most exponential blow up.
Reference: [SC85] <author> A.P. Sistla and E.M. Clarke. </author> <title> The complexity of propositional linear temporal logic. </title> <journal> J. ACM, </journal> <volume> 32 </volume> <pages> 733-749, </pages> <year> 1985. </year>
Reference-contexts: Trace-based implementations are part of the linear-time paradigm and correspond to LTL model checking. Tree-based implementations are part of the branching-time paradigm and correspond to 8CTL ? model checking. All the four problems are PSPACE-complete <ref> [SC85, EL85] </ref>. The model-checking algorithm of 8CTL ? uses as a subroutine the model-checking algorithm of LTL [EL85]. In a similar manner, our fair-simulation algorithm uses as a subroutine the language-containment algorithm. So, the implementation dichotomy and the temporal-logic dichotomy have a lot in common.
Reference: [Tho90] <author> W. Thomas. </author> <title> Automata on infinite objects. </title> <booktitle> Handbook of theoretical computer science, </booktitle> <pages> pages 165-191, </pages> <year> 1990. </year>
Reference-contexts: It is easy to see is that fair transition systems are essentially a notational variant of automata on infinite words <ref> [Tho90] </ref>. Thus, we will be able to use freely results from the theory of such automata. In particular, the unconditional and the strong fairness conditions correspond to the B uchi and Streett acceptance conditions.
Reference: [VW86] <author> M.Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proceedings of the First Symposium on Logic in Computer Science, </booktitle> <pages> pages 322-331, </pages> <address> Cambridge, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: Since simulation can be checked in polynomial time [Mil80, BGS92], whereas the trace containment problem is PSPACE-complete [MS72] 3 , it seems that the tree-based approach is more efficient than the trace-based approach. This is reminiscent of the computational advantage of branching-time model checking over linear-time model checking <ref> [CES86, LP85, QS81, VW86] </ref>. Once, however, we want our implementations and specifications to describe behaviors that satisfy both liveness and safety properties, transition systems are too weak. Then, we need the framework of fair transition systems. <p> When we turn to consider the program complexity of model checking, which is the analogue to our implementation complexity, this is no longer true. The program complexity of model checking for both LTL and 8CTL ? is NLOGSPACE-complete <ref> [VW86, BVW94] </ref>. In contrast, we saw here that implementation is easier in the trace-based approach.
Reference: [VW94] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 1-37, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: To prove the latter, we show that the nonemptiness problem for fair transition systems with a strong fairness condition is PTIME-hard, which is most likely harder than the NLOGSPACE bounds known for the unconditional and weak fairness conditions <ref> [VW94] </ref>. We also present a uniform method and a simple algorithm for solving the fair-simulation problem for all the three types of fairness conditions. Our algorithm uses the language-containment algorithm as a subroutine. We prove that the problem is PSPACE-complete for all the three types. <p> Thus, the size of the product of S U and S 0 U is exponential in the sizes of S and S 0 [Cho74] and checking it for nonemptiness can be done in space polynomial in their sizes <ref> [VW94] </ref>. Hardness in PSPACE follows from the known PSPACE lower bound for the case where both S and S 0 are unconditionally fair [Wol82]. <p> Since we can solve the nonemptiness problem of a transition system by checking its containment in a fixed-size empty transition system, hardness in NLOGSPACE follows from the NLOGSPACE lower bound for the nonemptiness problem of unconditionally fair transition systems <ref> [VW94] </ref>. ut So, for the case where the implementation does not use the strong fairness condition, our language-containment algorithm requires space that is only logarithmic in the size of the implementation. Clearly, this is not the case when the implementation does use the strong fairness condition.
Reference: [Wol82] <author> P. Wolper. </author> <title> Synthesis of Communicating Processes from Temporal Logic Specifications. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1982. </year>
Reference-contexts: Hardness in PSPACE follows from the known PSPACE lower bound for the case where both S and S 0 are unconditionally fair <ref> [Wol82] </ref>. Since U (n) ! W (n; 1) and U (n) ! S (n; 1), we can not do better with weak or strong fairness. ut Recall that our main concern is the complexity in terms of the (much larger) implementation.
References-found: 37

