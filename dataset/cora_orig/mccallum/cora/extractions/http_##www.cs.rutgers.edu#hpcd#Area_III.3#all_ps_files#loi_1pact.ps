URL: http://www.cs.rutgers.edu/hpcd/Area_III.3/all_ps_files/loi_1pact.ps
Refering-URL: http://www.cs.rutgers.edu/hpcd/Area_III.3/all_html_files/pluspyr.html
Root-URL: http://www.cs.rutgers.edu
Title: A Simple Algorithm for the Generation of Efficient Loop Structures  
Author: M. Cosnard M. Loi 
Date: April 5, 1995  
Address: FRANCE, 69364  
Affiliation: Laboratoire de l'Informatique du Parallelisme CNRS, ENS Lyon Lyon,  
Abstract: Generating code to enumerate the integer points of a polyhedron is a key problem of the parallelizing compiler technology. For efficiency reasons we want to obtain loop bounds of the generated code that are as simple as possible and we would like to avoid executing iterations of outer loops for which no iterations of inner loops are executed. This paper describes a simple algorithm to build an adequate representation of the domain to enumerate, the Hierarchical Domain Descriptor (HDD). Starting from the HDD, generating such efficient loop structures is straightforward. In some particular but frequently occurring cases the HDD may also be used to count in a symbolic way the number of integer points contained in the domain.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Ancourt and F. Irigoin. </author> <title> Scanning polyhedra with DO loops. </title> <booktitle> In ACM SIGPLAN PPPP 91, </booktitle> <pages> pages 39-50, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Two closely related key problems in the parallelizing compiler technology are loop structures generation and counting the number of integer points contained in a parameterized polyhedron. Loop structures generation has been addressed in many recent papers <ref> [1, 3, 2, 4, 6, 5, 7, 9, 15, 8, 16] </ref>. <p> Chamski in [5] studies the computational cost of the loop nest generation process. A lot of recent works also deal with the problem of enumerating the points in the image of a polyhedron by a non unimodular transformation <ref> [1, 3, 2, 16] </ref>. Some researchers [8, 7, 15] have also proposed methods to enumerate the points in the union of such images. As far as we know only [6] and [15] have addressed the generation of efficient loop structures.
Reference: [2] <author> M. Barnett and C. Lengauer. </author> <title> Loop parallelization and unimodularity, Chapter 25. </title> <publisher> Masson, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Two closely related key problems in the parallelizing compiler technology are loop structures generation and counting the number of integer points contained in a parameterized polyhedron. Loop structures generation has been addressed in many recent papers <ref> [1, 3, 2, 4, 6, 5, 7, 9, 15, 8, 16] </ref>. <p> Chamski in [5] studies the computational cost of the loop nest generation process. A lot of recent works also deal with the problem of enumerating the points in the image of a polyhedron by a non unimodular transformation <ref> [1, 3, 2, 16] </ref>. Some researchers [8, 7, 15] have also proposed methods to enumerate the points in the union of such images. As far as we know only [6] and [15] have addressed the generation of efficient loop structures.
Reference: [3] <author> M. Barnett and C. Lengauer. </author> <title> Unimodularity considered non-essential. </title> <editor> In L. Bouge, M. Cosnard, Y. Robert, and D. Trystram, editors, </editor> <booktitle> CONPAR 92 - VAPP V, </booktitle> <pages> pages 659-664. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <note> LNCS 634. </note>
Reference-contexts: 1 Introduction Two closely related key problems in the parallelizing compiler technology are loop structures generation and counting the number of integer points contained in a parameterized polyhedron. Loop structures generation has been addressed in many recent papers <ref> [1, 3, 2, 4, 6, 5, 7, 9, 15, 8, 16] </ref>. <p> Chamski in [5] studies the computational cost of the loop nest generation process. A lot of recent works also deal with the problem of enumerating the points in the image of a polyhedron by a non unimodular transformation <ref> [1, 3, 2, 16] </ref>. Some researchers [8, 7, 15] have also proposed methods to enumerate the points in the union of such images. As far as we know only [6] and [15] have addressed the generation of efficient loop structures.
Reference: [4] <author> Z. Chamski. </author> <title> Environnement logiciel de programmation d'un accelerateur de calcul parallele. </title> <type> PhD thesis, </type> <institution> Universite Rennes I, Rennes, France, </institution> <year> 1993. </year>
Reference-contexts: 1 Introduction Two closely related key problems in the parallelizing compiler technology are loop structures generation and counting the number of integer points contained in a parameterized polyhedron. Loop structures generation has been addressed in many recent papers <ref> [1, 3, 2, 4, 6, 5, 7, 9, 15, 8, 16] </ref>.
Reference: [5] <author> Z. Chamski. </author> <title> Fast and efficient generation of loop bounds. </title> <booktitle> In ParCo93, </booktitle> <pages> pages 265-272, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Two closely related key problems in the parallelizing compiler technology are loop structures generation and counting the number of integer points contained in a parameterized polyhedron. Loop structures generation has been addressed in many recent papers <ref> [1, 3, 2, 4, 6, 5, 7, 9, 15, 8, 16] </ref>. <p> We have done some performance measurements both for our algorithm and for the sequential form of the perfect loop nest generation method based on the PIP algorithm used in <ref> [5] </ref>. For our applications, our approach leads to a speedup greater than ten. Section 2 presents some notations and basic definitions. Section 3 presents the HDD. Section 4 introduces some primitive operations which are used by the HDD construction algorithm which is presented in section 5. <p> Most of the proposed methods generate perfect loop nests with complex bounds involving the runtime evaluation of min and max functions. In [9] Collard et al. show that the PIP algorithm may be used to generate such loop nests. Chamski in <ref> [5] </ref> studies the computational cost of the loop nest generation process. A lot of recent works also deal with the problem of enumerating the points in the image of a polyhedron by a non unimodular transformation [1, 3, 2, 16].
Reference: [6] <author> Z. Chamski. </author> <title> Nested loop sequences: Towards efficient loop structures in automatic parallelization. </title> <booktitle> In 27 th Hawaii International Conference on System Sciences, volume II: Software Technology, </booktitle> <pages> pages 14-22, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction Two closely related key problems in the parallelizing compiler technology are loop structures generation and counting the number of integer points contained in a parameterized polyhedron. Loop structures generation has been addressed in many recent papers <ref> [1, 3, 2, 4, 6, 5, 7, 9, 15, 8, 16] </ref>. <p> It does not require a complex machinery, such as Parametric Integer Programming used by <ref> [6] </ref> or Presburger arithmetic used by [15]. The only primitive operation we need is a test determining whether there is an integer solution to an arbitrary set of linear inequalities. <p> Some researchers [8, 7, 15] have also proposed methods to enumerate the points in the union of such images. As far as we know only <ref> [6] </ref> and [15] have addressed the generation of efficient loop structures. Chamski's work The HDD is close to the tree used by Chamski [6] to construct Nested Loop Sequences (NLS). <p> Some researchers [8, 7, 15] have also proposed methods to enumerate the points in the union of such images. As far as we know only <ref> [6] </ref> and [15] have addressed the generation of efficient loop structures. Chamski's work The HDD is close to the tree used by Chamski [6] to construct Nested Loop Sequences (NLS). The NLS generated by his algorithm do not avoid executing iterations of outer loops for which no iterations of inner loops are executed. The main property of this loop structure is that all the loop bounds are simple. <p> Moreover, we expect our algorithm to be faster than the NLS generation algorithm because we use integer programming primitives which are far less expensive than the PIP algorithm [11] used in <ref> [6] </ref>. if L = U for I = L to U do S (K,I,J) endfor endfor else K = L for J = 0 to U do endfor endfor for K = L+1 to U do for J = K-I to U do endfor endfor for I = K to U
Reference: [7] <author> J.-F. Collard and P. Feautrier. </author> <title> Automatic generation of data parallel code. </title> <booktitle> In Proceeding of the Fourth International Workshop on Compilers for Parallel Computers, H.J. Sips editor, </booktitle> <pages> pages 321-332, </pages> <address> Delft, The Netherlands, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction Two closely related key problems in the parallelizing compiler technology are loop structures generation and counting the number of integer points contained in a parameterized polyhedron. Loop structures generation has been addressed in many recent papers <ref> [1, 3, 2, 4, 6, 5, 7, 9, 15, 8, 16] </ref>. <p> Chamski in [5] studies the computational cost of the loop nest generation process. A lot of recent works also deal with the problem of enumerating the points in the image of a polyhedron by a non unimodular transformation [1, 3, 2, 16]. Some researchers <ref> [8, 7, 15] </ref> have also proposed methods to enumerate the points in the union of such images. As far as we know only [6] and [15] have addressed the generation of efficient loop structures.
Reference: [8] <author> J.F. Collard. </author> <title> Code generation in automatic parallelizers. </title> <type> Technical Report 93-21, </type> <institution> LIP-CNRS-ENS LYON, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Two closely related key problems in the parallelizing compiler technology are loop structures generation and counting the number of integer points contained in a parameterized polyhedron. Loop structures generation has been addressed in many recent papers <ref> [1, 3, 2, 4, 6, 5, 7, 9, 15, 8, 16] </ref>. <p> Chamski in [5] studies the computational cost of the loop nest generation process. A lot of recent works also deal with the problem of enumerating the points in the image of a polyhedron by a non unimodular transformation [1, 3, 2, 16]. Some researchers <ref> [8, 7, 15] </ref> have also proposed methods to enumerate the points in the union of such images. As far as we know only [6] and [15] have addressed the generation of efficient loop structures.
Reference: [9] <author> J.F. Collard, P. Feautrier, and T. Risset. </author> <title> Construction of DO loops from systems of affine constraints. </title> <type> Technical Report 93-15, </type> <institution> LIP-CNRS-ENS LYON, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Two closely related key problems in the parallelizing compiler technology are loop structures generation and counting the number of integer points contained in a parameterized polyhedron. Loop structures generation has been addressed in many recent papers <ref> [1, 3, 2, 4, 6, 5, 7, 9, 15, 8, 16] </ref>. <p> Most of the proposed methods generate perfect loop nests with complex bounds involving the runtime evaluation of min and max functions. In <ref> [9] </ref> Collard et al. show that the PIP algorithm may be used to generate such loop nests. Chamski in [5] studies the computational cost of the loop nest generation process.
Reference: [10] <author> M. Cosnard and M. Loi. </author> <title> Automatic task graph generation techniques. </title> <booktitle> In 28 th Hawaii International Conference on System Sciences, volume II: Software Technology, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: It has been used in [23] in order to determine a processor allocation, in [23, 12] to perform loop scheduling, in [13] to estimate and enhance cache effectiveness and in <ref> [10] </ref> for building parameterized task graphs. This operation is often called iteration counting. Before generating loop structures or performing iteration counting we need to represent the iteration domain under consideration in an adequate way.
Reference: [11] <author> P. Feautrier. </author> <title> Parametric integer programing. </title> <journal> RAIRO Recherche Opera-tionelle, </journal> <volume> 22 </volume> <pages> 243-268, </pages> <year> 1988. </year>
Reference-contexts: The only primitive operation we need is a test determining whether there is an integer solution to an arbitrary set of linear inequalities. This functionality may be provided by the Omega test [18] (an extension of Fourier-Motzkin variable elimination) or by the dual simplex algorithm with Gomory cuts <ref> [17, 11] </ref>. Our algorithm has been imple mented in Common Lisp and amounts to about 700 lines of code. * The theoritical complexity of the algorithm is very high but we have found it to be efficient for our applications. <p> This functionality may be provided by the Omega test [18] (an extension of Fourier-Motzkin variable elimination) or by the dual simplex algorithm with Gomory cuts <ref> [17, 11] </ref>. <p> It is easy to see that the loop on k may iterate even when the loop on i does not. Moreover, we expect our algorithm to be faster than the NLS generation algorithm because we use integer programming primitives which are far less expensive than the PIP algorithm <ref> [11] </ref> used in [6]. if L = U for I = L to U do S (K,I,J) endfor endfor else K = L for J = 0 to U do endfor endfor for K = L+1 to U do for J = K-I to U do endfor endfor for I = <p> Our algorithm is simple and does not require a complex machinery. It has been implemented in Common Lisp and amounts to about 700 lines of code. This implementation is able to use both the Omega test [18] or the dual simplex algorithm with Gomory cuts <ref> [17, 11] </ref> as a basic kernel. The theoritical complexity of the algorithm is very high but we have found it to be efficient for our applications. Our future work will include performance comparison with other techniques.
Reference: [12] <author> M. R. Haghighat and C. D. Polychronopoulos. </author> <title> Symbolic analysis: A basis for parallelization, optimization, and scheduling of programs. </title> <booktitle> In Proceedings of the 6th Workshop on Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: inner loops are executed. fl This work was supported in part by the Eureka Eurotops project and the EEC Human Capital Mobility MAP project. y This work was supported in part by the Region Rhone-Alpes. 1 Counting the number of integer points contained in a polyhedron has been studied in <ref> [21, 22, 19, 12] </ref>. It has been used in [23] in order to determine a processor allocation, in [23, 12] to perform loop scheduling, in [13] to estimate and enhance cache effectiveness and in [10] for building parameterized task graphs. This operation is often called iteration counting. <p> It has been used in [23] in order to determine a processor allocation, in <ref> [23, 12] </ref> to perform loop scheduling, in [13] to estimate and enhance cache effectiveness and in [10] for building parameterized task graphs. This operation is often called iteration counting. Before generating loop structures or performing iteration counting we need to represent the iteration domain under consideration in an adequate way. <p> &lt;= 3 j + 5 -; if (0 &lt;= t1 && t1 &lt;= 20) then for (t2 = max (intDiv (t1-5+2,3),0)); t2 &lt;= intDiv (t1,4); t2++) - - endif - Counting the number of integer points contained in a polyhedron has been studied by Tawbi [21, 22], Haghighat and Polychronopoulos <ref> [12] </ref> and Pugh [19]. Tawbi [21, 22] proposes a polyhedron splitting method which differs from our algorithm because the lexicographical order is not preserved among the partitions. Moreover her algorithm produces many redundant constraints and makes no attempt to eliminate them.
Reference: [13] <author> J.Ferrante, V. Sarkar, and W. Trash. </author> <title> On estimating and enhancing cache effectiveness. </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: It has been used in [23] in order to determine a processor allocation, in [23, 12] to perform loop scheduling, in <ref> [13] </ref> to estimate and enhance cache effectiveness and in [10] for building parameterized task graphs. This operation is often called iteration counting. Before generating loop structures or performing iteration counting we need to represent the iteration domain under consideration in an adequate way.
Reference: [14] <author> W. Kelly, V. Maslov, W. Pugh, E. Rosser T. Shpeisman, and D. Wonnacott. </author> <title> The omega calculator and library, version 0.9. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, Univ. of Maryland, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: For example, the code generated from the HDD built in the previous section is shown in the left of figure 10. The right part of figure 10 shows the code generated by the Omega Calculator <ref> [14] </ref> for the same problem. However, two special cases should be paid attention: rational bounds and parameters. 6.1.1 Handling rational bounds The bounds labeling the HDD nodes are affine functions f : Z k 7! Q.
Reference: [15] <author> Wayne Kelly, William Pugh, and Evan Rosser. </author> <title> Code generation for multiple mappings. </title> <type> Technical Report CS-TR-3317, </type> <institution> Dept. of Computer Science, Univ. of Maryland, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Two closely related key problems in the parallelizing compiler technology are loop structures generation and counting the number of integer points contained in a parameterized polyhedron. Loop structures generation has been addressed in many recent papers <ref> [1, 3, 2, 4, 6, 5, 7, 9, 15, 8, 16] </ref>. <p> It does not require a complex machinery, such as Parametric Integer Programming used by [6] or Presburger arithmetic used by <ref> [15] </ref>. The only primitive operation we need is a test determining whether there is an integer solution to an arbitrary set of linear inequalities. <p> Chamski in [5] studies the computational cost of the loop nest generation process. A lot of recent works also deal with the problem of enumerating the points in the image of a polyhedron by a non unimodular transformation [1, 3, 2, 16]. Some researchers <ref> [8, 7, 15] </ref> have also proposed methods to enumerate the points in the union of such images. As far as we know only [6] and [15] have addressed the generation of efficient loop structures. <p> Some researchers [8, 7, 15] have also proposed methods to enumerate the points in the union of such images. As far as we know only [6] and <ref> [15] </ref> have addressed the generation of efficient loop structures. Chamski's work The HDD is close to the tree used by Chamski [6] to construct Nested Loop Sequences (NLS). <p> The algorithm for the simple mapping case proposed in <ref> [15] </ref> has the same goals as the method proposed in this paper: generating loop bounds that are as simple as possible and avoiding as much as possible executing iterations of outer loops for which no iterations of inner loops are executed. <p> But it requires a complex machinery, provided by the Omega Package <ref> [15] </ref>. Moreover, their method, as implemented in version 0.9 of the Omega Calculator, fails to simplify rational loop bounds. For example, for the polyhedron shown in figure 11 it is only able to generate the code of figure 16.
Reference: [16] <author> W. Li and K. Pingali. </author> <title> A singular loop tranformation framework based on non-singular matrices. </title> <booktitle> In Fith Annual Workshop on Programming Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 249-260, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Two closely related key problems in the parallelizing compiler technology are loop structures generation and counting the number of integer points contained in a parameterized polyhedron. Loop structures generation has been addressed in many recent papers <ref> [1, 3, 2, 4, 6, 5, 7, 9, 15, 8, 16] </ref>. <p> Chamski in [5] studies the computational cost of the loop nest generation process. A lot of recent works also deal with the problem of enumerating the points in the image of a polyhedron by a non unimodular transformation <ref> [1, 3, 2, 16] </ref>. Some researchers [8, 7, 15] have also proposed methods to enumerate the points in the union of such images. As far as we know only [6] and [15] have addressed the generation of efficient loop structures.
Reference: [17] <author> G. L. Nemhauser and L.A. Wolsey. </author> <title> Integer and combinatorial optimization. </title> <publisher> John Wiley & Sons, </publisher> <year> 1988. </year>
Reference-contexts: The only primitive operation we need is a test determining whether there is an integer solution to an arbitrary set of linear inequalities. This functionality may be provided by the Omega test [18] (an extension of Fourier-Motzkin variable elimination) or by the dual simplex algorithm with Gomory cuts <ref> [17, 11] </ref>. Our algorithm has been imple mented in Common Lisp and amounts to about 700 lines of code. * The theoritical complexity of the algorithm is very high but we have found it to be efficient for our applications. <p> Section 8 presents related work and compare the results of our algorithm to those obtained by previously known methods. Last, we conclude by presenting our future work. 2 Definitions and notations There are numerous mathematical works related to the material presented here. For an introduction see <ref> [20, 17] </ref>. In this paper, all vectors are surrounded by an arrow: ~x. <p> This functionality may be provided by the Omega test [18] (an extension of Fourier-Motzkin variable elimination) or by the dual simplex algorithm with Gomory cuts <ref> [17, 11] </ref>. <p> Our algorithm is simple and does not require a complex machinery. It has been implemented in Common Lisp and amounts to about 700 lines of code. This implementation is able to use both the Omega test [18] or the dual simplex algorithm with Gomory cuts <ref> [17, 11] </ref> as a basic kernel. The theoritical complexity of the algorithm is very high but we have found it to be efficient for our applications. Our future work will include performance comparison with other techniques.
Reference: [18] <author> William Pugh. </author> <title> The Omega test: a fast and practical integer programming algorithm for dependence analysis. </title> <journal> Comm. ACM, </journal> <volume> 8 </volume> <pages> 102-114, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: The only primitive operation we need is a test determining whether there is an integer solution to an arbitrary set of linear inequalities. This functionality may be provided by the Omega test <ref> [18] </ref> (an extension of Fourier-Motzkin variable elimination) or by the dual simplex algorithm with Gomory cuts [17, 11]. <p> This functionality may be provided by the Omega test <ref> [18] </ref> (an extension of Fourier-Motzkin variable elimination) or by the dual simplex algorithm with Gomory cuts [17, 11]. <p> Our algorithm is simple and does not require a complex machinery. It has been implemented in Common Lisp and amounts to about 700 lines of code. This implementation is able to use both the Omega test <ref> [18] </ref> or the dual simplex algorithm with Gomory cuts [17, 11] as a basic kernel. The theoritical complexity of the algorithm is very high but we have found it to be efficient for our applications. Our future work will include performance comparison with other techniques.
Reference: [19] <author> William Pugh. </author> <title> Counting Solutions to Presburger Formulas: How and Why. </title> <institution> Dept. of Computer Science. </institution> <type> Technical Report CS-TR-3234, </type> <institution> Univ. of Mary-land, </institution> <month> March </month> <year> 1994. </year> <booktitle> This paper will appear in the Proceedings of the 1994 ACM SIGPLAN Conference on Programming Language Design and Imple--mentation. </booktitle>
Reference-contexts: inner loops are executed. fl This work was supported in part by the Eureka Eurotops project and the EEC Human Capital Mobility MAP project. y This work was supported in part by the Region Rhone-Alpes. 1 Counting the number of integer points contained in a polyhedron has been studied in <ref> [21, 22, 19, 12] </ref>. It has been used in [23] in order to determine a processor allocation, in [23, 12] to perform loop scheduling, in [13] to estimate and enhance cache effectiveness and in [10] for building parameterized task graphs. This operation is often called iteration counting. <p> + 5 -; if (0 &lt;= t1 && t1 &lt;= 20) then for (t2 = max (intDiv (t1-5+2,3),0)); t2 &lt;= intDiv (t1,4); t2++) - - endif - Counting the number of integer points contained in a polyhedron has been studied by Tawbi [21, 22], Haghighat and Polychronopoulos [12] and Pugh <ref> [19] </ref>. Tawbi [21, 22] proposes a polyhedron splitting method which differs from our algorithm because the lexicographical order is not preserved among the partitions. Moreover her algorithm produces many redundant constraints and makes no attempt to eliminate them. For rational bounds she gives a method to compute average values. Pugh [19] <p> <ref> [19] </ref>. Tawbi [21, 22] proposes a polyhedron splitting method which differs from our algorithm because the lexicographical order is not preserved among the partitions. Moreover her algorithm produces many redundant constraints and makes no attempt to eliminate them. For rational bounds she gives a method to compute average values. Pugh [19] proposes elaborate techniques both for integer bounds and rational bounds. For rational bounds he gives methods computing symbolic answers when possible, average, lower and upper bound values and exact answers by splintering the problem. More general problems are also considered.
Reference: [20] <author> A. Schrijver. </author> <title> Theory of linear and integer programming. </title> <publisher> John Wiley & Sons, </publisher> <year> 1986. </year>
Reference-contexts: Section 8 presents related work and compare the results of our algorithm to those obtained by previously known methods. Last, we conclude by presenting our future work. 2 Definitions and notations There are numerous mathematical works related to the material presented here. For an introduction see <ref> [20, 17] </ref>. In this paper, all vectors are surrounded by an arrow: ~x.
Reference: [21] <author> N. Tawbi. </author> <title> Estimation des durees d'execution et allocation statique de pro-cesseurs. </title> <type> PhD thesis, </type> <institution> Universite Paris VI, Paris, France, </institution> <year> 1991. </year>
Reference-contexts: inner loops are executed. fl This work was supported in part by the Eureka Eurotops project and the EEC Human Capital Mobility MAP project. y This work was supported in part by the Region Rhone-Alpes. 1 Counting the number of integer points contained in a polyhedron has been studied in <ref> [21, 22, 19, 12] </ref>. It has been used in [23] in order to determine a processor allocation, in [23, 12] to perform loop scheduling, in [13] to estimate and enhance cache effectiveness and in [10] for building parameterized task graphs. This operation is often called iteration counting. <p> j &lt;= i && i &lt;= 3 j + 5 -; if (0 &lt;= t1 && t1 &lt;= 20) then for (t2 = max (intDiv (t1-5+2,3),0)); t2 &lt;= intDiv (t1,4); t2++) - - endif - Counting the number of integer points contained in a polyhedron has been studied by Tawbi <ref> [21, 22] </ref>, Haghighat and Polychronopoulos [12] and Pugh [19]. Tawbi [21, 22] proposes a polyhedron splitting method which differs from our algorithm because the lexicographical order is not preserved among the partitions. Moreover her algorithm produces many redundant constraints and makes no attempt to eliminate them. <p> -; if (0 &lt;= t1 && t1 &lt;= 20) then for (t2 = max (intDiv (t1-5+2,3),0)); t2 &lt;= intDiv (t1,4); t2++) - - endif - Counting the number of integer points contained in a polyhedron has been studied by Tawbi <ref> [21, 22] </ref>, Haghighat and Polychronopoulos [12] and Pugh [19]. Tawbi [21, 22] proposes a polyhedron splitting method which differs from our algorithm because the lexicographical order is not preserved among the partitions. Moreover her algorithm produces many redundant constraints and makes no attempt to eliminate them. For rational bounds she gives a method to compute average values.
Reference: [22] <author> N. Tawbi. </author> <title> Estimation of nested loop execution time by integer arithmetics in convex polyhedra. </title> <booktitle> In Proc. of the 1994 International Parallel Processing Symposium, </booktitle> <month> April </month> <year> 1994. </year>
Reference-contexts: inner loops are executed. fl This work was supported in part by the Eureka Eurotops project and the EEC Human Capital Mobility MAP project. y This work was supported in part by the Region Rhone-Alpes. 1 Counting the number of integer points contained in a polyhedron has been studied in <ref> [21, 22, 19, 12] </ref>. It has been used in [23] in order to determine a processor allocation, in [23, 12] to perform loop scheduling, in [13] to estimate and enhance cache effectiveness and in [10] for building parameterized task graphs. This operation is often called iteration counting. <p> Then the corresponding enumeration code is shown in figure 12 6.1.2 Handling parameters Parameters should be treated as outer indices when building the HDD. For example, let the input parameterized polyhedron be the one used in <ref> [22] </ref>: 8 &gt; &gt; &gt; &gt; : i; j; k 0 1 j i where n and m are parameters. We want to partition it according to the lexicographical order i; j; k. Our algorithm generates the HDD shown in the left part of figure 13. <p> j &lt;= i && i &lt;= 3 j + 5 -; if (0 &lt;= t1 && t1 &lt;= 20) then for (t2 = max (intDiv (t1-5+2,3),0)); t2 &lt;= intDiv (t1,4); t2++) - - endif - Counting the number of integer points contained in a polyhedron has been studied by Tawbi <ref> [21, 22] </ref>, Haghighat and Polychronopoulos [12] and Pugh [19]. Tawbi [21, 22] proposes a polyhedron splitting method which differs from our algorithm because the lexicographical order is not preserved among the partitions. Moreover her algorithm produces many redundant constraints and makes no attempt to eliminate them. <p> -; if (0 &lt;= t1 && t1 &lt;= 20) then for (t2 = max (intDiv (t1-5+2,3),0)); t2 &lt;= intDiv (t1,4); t2++) - - endif - Counting the number of integer points contained in a polyhedron has been studied by Tawbi <ref> [21, 22] </ref>, Haghighat and Polychronopoulos [12] and Pugh [19]. Tawbi [21, 22] proposes a polyhedron splitting method which differs from our algorithm because the lexicographical order is not preserved among the partitions. Moreover her algorithm produces many redundant constraints and makes no attempt to eliminate them. For rational bounds she gives a method to compute average values.
Reference: [23] <author> N. Tawbi and P. Feautrier. </author> <title> Processor allocation and loop scheduling on multiprocessor computers. </title> <booktitle> In Proceeding of the 1992 International Conference on Supercomputing, </booktitle> <pages> pages 63-71, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: It has been used in <ref> [23] </ref> in order to determine a processor allocation, in [23, 12] to perform loop scheduling, in [13] to estimate and enhance cache effectiveness and in [10] for building parameterized task graphs. This operation is often called iteration counting. <p> It has been used in [23] in order to determine a processor allocation, in <ref> [23, 12] </ref> to perform loop scheduling, in [13] to estimate and enhance cache effectiveness and in [10] for building parameterized task graphs. This operation is often called iteration counting. Before generating loop structures or performing iteration counting we need to represent the iteration domain under consideration in an adequate way.
References-found: 23

