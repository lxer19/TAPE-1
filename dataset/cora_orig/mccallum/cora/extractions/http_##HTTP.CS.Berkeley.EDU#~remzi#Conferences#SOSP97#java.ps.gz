URL: http://HTTP.CS.Berkeley.EDU/~remzi/Conferences/SOSP97/java.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/tom/590AT.html
Root-URL: 
Email: dwallach@cs.princeton.edu balfanz@cs.princeton.edu ddean@cs.princeton.edu felten@cs.princeton.edu  
Title: Extensible Security Architectures for Java  
Author: Dan S. Wallach Dirk Balfanz Drew Dean Edward W. Felten 
Affiliation: Department of Computer Science Princeton University  
Abstract: Technical Report 546-97, Department of Computer Science, Princeton University, April 1997. Abstract Mobile code technologies such as Java, JavaScript, and ActiveX generally limit all programs to a single security policy. However, software-based protection can allow for more flexible security models, with potentially significant performance improvements over traditional hardware-based solutions. We describe and analyze three implementation strategies for interposing flexible security policies in software-based security systems. Implementations exist for all three strategies: several vendors have adapted capabilities to Java, Netscape Communicator extended Java's stack introspection, and we built a type-hiding system as an add-on to Microsoft Internet Explorer. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> ANDERSON, T. E., LEVY, H. M., BERSHAD, B. N., AND LAZOWSKA, E. D. </author> <title> The interaction of architecture and operating system design. </title> <booktitle> In Proceedings of the Fourth ACM Symposium on Architectural Support for Programming Languages and Operating Systems (1991). </booktitle>
Reference-contexts: When the two objects are in different tasks, the call takes 230 sec; when the called object is in a dynamically linked library in the same task, the call takes only 0.2 sec a factor of 1000 difference. This ratio appears to be growing even larger in newer processors <ref> [31, 1] </ref>. The time difference would be acceptable if cross-domain calls were very rare. But modern software structures, especially in mobile code systems, are leading to tighter binding between domains.
Reference: [2] <author> BERSHAD, B. N., SAVAGE, S., PARDYAK, P., SIRER, E. G., FIUCZYNSKI, M., BECKER, D., EGGERS, S., AND CHAMBERS, C. </author> <title> Extensibility, safety, and performance in the SPIN operating system. </title> <booktitle> In Proceedings of 15th ACM Symposium on Operating Systems Principles (Dec. </booktitle> <year> 1995), </year> <pages> pp. 251 266. </pages>
Reference-contexts: The language-based protection model, exemplified by Java, can be traced back at least to the Burroughs B-5000 in 1961 [24] and is also used in current research operating systems such as SPIN <ref> [2] </ref>. By using a safe language, memory accesses can be controlled [27].
Reference: [3] <author> BERSTIS, V., TRUXAL, C. D., AND RANWEILER, J. G. </author> <title> System/38 addressing and authorization. In IBM System/38 Technical Developments, 2nd ed. </title> <institution> IBM, </institution> <month> July </month> <year> 1980, </year> <pages> pp. 5154. </pages>
Reference-contexts: Some systems, such as ICAP [14], make capabilities aware of who called them; they can know who they belong to and become useless to anyone else. The IBM System/38 <ref> [3] </ref> associates optional access control lists with its capabilities, accomplishing the same purpose. Other systems use hardware mechanisms to block the sharing of capabilities [21]. For Java, either technique would be problematic.
Reference: [4] <author> BIRRELL, A., NELSON, G., OWICKI, S., AND WOBBER, E. </author> <title> Network objects. </title> <booktitle> In Proceedings of 13th ACM Symposium on Operating Systems Principles (Dec. </booktitle> <year> 1993), </year> <pages> pp. 217230. </pages>
Reference-contexts: As mentioned in section 4.1, a capability system would require a new library API and thus completely break compatibility with traditional Java APIs. 4.10 Remote Calls Recent systems are beginning to offer convenient distributed programming in Java, using a distributed-objects model similar to that of SRC network objects <ref> [4] </ref> or CORBA [38]. It would be highly desirable for language based security schemes to easily extend to a distributed environment. A single security policy and implementation mechanism could deal naturally with both local and remote code. Capabilities extend quite naturally across a network.
Reference: [5] <author> BORENSTEIN, N. S. </author> <title> Email with a mind of its own: The Safe-Tcl language for enabled mail. </title> <booktitle> In IFIP International Working Conference on Upper Layer Protocols, Architectures and Applications (1994). </booktitle>
Reference-contexts: Language-based safety can use either dynamic type checking <ref> [33, 5] </ref> or static type checking (as is mostly the case in Java [8]). The major tradeoff is performance versus theoretical complexity. The static system should be faster, because it only checks safety once, before the program starts. <p> We can either remove an entity entirely from the name-space (thus causing mentioning its name to result in a runtime error), or we can cause its name to refer to a different entity which is compatible with the original. This technique is used in Safe-Tcl <ref> [5] </ref> to hide commands in an untrusted interpreter. Plan 9 [32] can similarly attach different programs and services to the filesystem viewed by an untrusted process. In an object-oriented language, classes represent resources we wish to control.
Reference: [6] <author> CLARK, D., AND WILSON, D. </author> <title> A comparison of commercial and military computer security policies. </title> <booktitle> In Proceedings of the 1987 IEEE Symposium on Security and Privacy (Oakland, </booktitle> <address> CA, </address> <month> May </month> <year> 1987). </year>
Reference-contexts: Traditionally, extensible reference monitors are built using trusted subsystems. For example, the utility to change a password must be trusted to safely edit the password database. For this to succeed, the system must provide for trusted subsystems, interposed between the password database and the users. Clark and Wilson <ref> [6] </ref> offer a particularly cogent argument in favor of the use of trusted subsystems and abstraction boundaries in the security of commercial systems. 3.1.1 Digital Signatures as Principals To implement any security policy, Java needs a notion of principal.
Reference: [7] <author> DEAN, D., FELTEN, E. W., AND WALLACH, D. S. </author> <title> Java security: From HotJava to Netscape and beyond. </title> <booktitle> In Proceedings of the 1996 IEEE Symposium on Security and Privacy (Oakland, </booktitle> <address> CA, </address> <month> May </month> <year> 1996), </year> <pages> pp. </pages> <year> 190200. </year>
Reference-contexts: In practice, this design proved insufficient. In addition to a number of security-related bugs in the first implementations <ref> [7] </ref>, many developers complained that the policy, applied equally to all applets, was too inflexible to implement many desirable real applications. The sandbox policy provides network access to exactly one machine, the origin of the applet, and provides no local filesystem access. <p> If one program can corrupt the shared state, it can then corrupt other programs which depend on it. This problem applies equally to all three Java-based systems. An example of this problem was Hopwood's interface attack <ref> [7] </ref>, which combined a bug in Java's interface mechanism with a shared public variable to ultimately break the type system, and thus circumvent system security. Addressing this issue is a prerequisite to deploying any flexible security mechanism above Java. We believe this is tractable but difficult.
Reference: [8] <author> DROSSOPOULOU, S., AND EISENBACH, S. </author> <booktitle> Is the Java type system sound? In Proceedings of the Fourth International Workshop on Foundations of Object-Oriented Languages (Paris, </booktitle> <month> Jan. </month> <year> 1997). </year>
Reference-contexts: Language-based safety can use either dynamic type checking [33, 5] or static type checking (as is mostly the case in Java <ref> [8] </ref>). The major tradeoff is performance versus theoretical complexity. The static system should be faster, because it only checks safety once, before the program starts.
Reference: [9] <author> ELECTRIC COMMUNITIES. </author> <title> The Electric Communities Trust Manager and Its Use to Secure Java, </title> <month> Sept. </month> <year> 1996. </year> <note> http://www.communities. com/company/papers/trust/. </note>
Reference-contexts: Unlike traditional operating systems, Web browsers must rely on software mechanisms for basic memory safety, both for portability and performance. However, there is no standard for constructing secure services above basic memory safety primitives. We explain three different strategies and their implementations in Java: several vendors <ref> [13, 9] </ref> have built capability systems, Netscape has extended Java's stack introspection, and we designed an add-on to Microsoft Internet Explorer which hides and renames Java types. <p> Electric Communities <ref> [9] </ref> and JavaSoft [13] 8 have implemented such systems. This section discusses general issues for implementing capabilities in Java, rather than specifics of the Electric Communities or JavaSoft implementations. <p> In the latter two cases, no deep changes are necessary to adapt the systems to a distributed environment. Actually building RPC systems using any of the mechanisms in Java is future work. Current Java RPC systems, with the possible exception of Electric Communities <ref> [9] </ref>, have no provisions for flexible security. 5 Conclusion Software-based protection systems are coming into common use, driven by their inherent advantages in both performance and portability. Software fault isolation, proof-carrying code, or language-based mechanisms can be used to guarantee memory-safety. Secure system services cannot be built without these mechanisms.
Reference: [10] <author> FABRY, R. S. </author> <title> Capability-based addressing. </title> <journal> Communications of the ACM 17, </journal> <month> 7 (July </month> <year> 1974), </year> <month> 403411. </month>
Reference-contexts: Such groupings allow a single dialog box to be presented to a user which does not burden the user with a long series of individual privilege decisions and their corresponding dialog boxes. 3.2 First Approach: Capabilities In many respects, Java provides an ideal way to implement a traditional capability system <ref> [10, 24, 20] </ref>. Electric Communities [9] and JavaSoft [13] 8 have implemented such systems. This section discusses general issues for implementing capabilities in Java, rather than specifics of the Electric Communities or JavaSoft implementations.
Reference: [11] <author> FLANAGAN, D. </author> <title> JavaScript: The Definitive Guide, 2nd ed. </title> <publisher> O'Reilly & Associates, Inc., </publisher> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: Active content can add simple animations to a page, but it can also transform the Web into a platform for writing and distributing programs. A variety of mobile code systems such as Java [16], JavaScript <ref> [11] </ref>, ActiveX [26], and Shockwave [35] make this possible. Users and developers love mobile code, but it raises serious security concerns. While code has been distributed over networks for years, the risks of attack have been manageable.
Reference: [12] <author> FREIER, A. O., KARLTON, P., AND KOCHER, P. C. </author> <title> The SSL Protocol: </title> <note> Version 3.0, </note> <month> Mar. </month> <year> 1996. </year> <title> Internet draft, </title> <address> ftp://ietf.cnri. reston.va.us/internet-drafts/ draftfreiersslversion3-01.txt. </address>
Reference-contexts: By themselves, net-worked capabilities offer no way to identify the remote caller. However, if the remote method invocation used a cryptographically authenticated channel (as provided by SSL <ref> [12] </ref> or Taos [42]), the remote identity may be useful. Gong [14] and van Doorn, et al. [40] describe implementations of this. In the case of stack introspection, the local stub for the RPC could be labeled with the remote principal (again, provided via SSL or Taos).
Reference: [13] <author> GOLDSTEIN, T. </author> <title> The Gateway Security Model in the Java Electronic Commerce Framework. </title> <type> JavaSoft, </type> <month> Nov. </month> <year> 1996. </year> <note> http://www.javasoft.com/ products/commerce/jecf_gateway.ps. </note>
Reference-contexts: Unlike traditional operating systems, Web browsers must rely on software mechanisms for basic memory safety, both for portability and performance. However, there is no standard for constructing secure services above basic memory safety primitives. We explain three different strategies and their implementations in Java: several vendors <ref> [13, 9] </ref> have built capability systems, Netscape has extended Java's stack introspection, and we designed an add-on to Microsoft Internet Explorer which hides and renames Java types. <p> Electric Communities [9] and JavaSoft <ref> [13] </ref> 8 have implemented such systems. This section discusses general issues for implementing capabilities in Java, rather than specifics of the Electric Communities or JavaSoft implementations.
Reference: [14] <author> GONG, L. </author> <title> A secure identity-based capability system. </title> <booktitle> In Proceedings of the 1989 IEEE Symposium on Security and Privacy (Oakland, </booktitle> <address> CA, </address> <month> May </month> <year> 1989), </year> <pages> pp. 5663. </pages>
Reference-contexts: Kain and Landwehr [20] propose a taxonomy for extensions and survey many systems which implement them. Fundamentally, extended capability systems must either place restrictions on how capabilities can be used, or must place restrictions on how capabilities can be shared. Some systems, such as ICAP <ref> [14] </ref>, make capabilities aware of who called them; they can know who they belong to and become useless to anyone else. The IBM System/38 [3] associates optional access control lists with its capabilities, accomplishing the same purpose. Other systems use hardware mechanisms to block the sharing of capabilities [21]. <p> Capabilities extend quite naturally across a network. If remote object references include an unguessable string of bits (i.e., 128 random bits), then a remote capability reference has all the security properties of a local capability <ref> [39, 14] </ref> (assuming all communication is suitable encrypted to prevent eavesdropping). Unfortunately, the confinement issues discussed in section 4.3 become even more problematic. If the capability is leaked to a third party, then the third party has just as much power to use the capability as its intended holder. <p> By themselves, net-worked capabilities offer no way to identify the remote caller. However, if the remote method invocation used a cryptographically authenticated channel (as provided by SSL [12] or Taos [42]), the remote identity may be useful. Gong <ref> [14] </ref> and van Doorn, et al. [40] describe implementations of this. In the case of stack introspection, the local stub for the RPC could be labeled with the remote principal (again, provided via SSL or Taos). The local stub can then enable privileges on behalf of its remote caller.
Reference: [15] <author> GONG, L. </author> <title> New security architectural directions for Java. </title> <booktitle> In Proceedings of IEEE COMPCON '97 (Feb. </booktitle> <year> 1997). </year>
Reference-contexts: The current Java class libraries already use a capability-style interface to represent open files and network connec 8 The Java Electronic Commerce Framework (JECF) uses a capability-style interface, extending the signed applet support in JDK 1.1. More information about JavaSoft's security architecture plans can be found in Gong <ref> [15] </ref>. 9 For example, the combination to open a safe represents a capability. The safe has no way to verify if the combination has been stolen; any person entering the correct combination can open the door.
Reference: [16] <author> GOSLING, J., JOY, B., AND STEELE, G. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: As Web applications have blossomed, developers have been constrained by the Web's static document model. Active content can add simple animations to a page, but it can also transform the Web into a platform for writing and distributing programs. A variety of mobile code systems such as Java <ref> [16] </ref>, JavaScript [11], ActiveX [26], and Shockwave [35] make this possible. Users and developers love mobile code, but it raises serious security concerns. While code has been distributed over networks for years, the risks of attack have been manageable.
Reference: [17] <author> HARDY, N. </author> <booktitle> KeyKOS architecture. ACM Operating Systems Review 19, </booktitle> <address> 4 (Oct. </address> <year> 1985), </year> <month> 825. </month>
Reference-contexts: This section discusses general issues for implementing capabilities in Java, rather than specifics of the Electric Communities or JavaSoft implementations. Dating back to the 1960's, hardware and software-based capability systems have often been seen as a good way to structure a secure operating system <ref> [17, 30, 39] </ref>. Fundamentally, a capability is an unforgeable pointer to a controlled system resource. To use a capability, a program must have been first explicitly given that capability, either as part of its initialization or as the result of calling another capability.
Reference: [18] <author> JAEGER, T., RUBIN, A. D., AND PRAKASH, A. </author> <title> Building systems that flexibly control downloaded executable content. </title> <booktitle> In Sixth USENIX Security Symposium Proceedings (San Jose, </booktitle> <address> CA, </address> <month> July </month> <year> 1996), </year> <pages> pp. 131148. </pages>
Reference: [19] <author> JONES, A. K., AND LISKOV, B. H. </author> <title> A language extension for controlling access to shared data. </title> <journal> IEEE Transactions on Software Engineering SE-2, </journal> <note> 4 (Dec. 1976), 277285. </note>
Reference: [20] <author> KAIN, R. Y., AND LANDWEHR, C. E. </author> <title> On access checking in capability-based systems. </title> <journal> IEEE Transactions on Software Engineering SE-13, </journal> <month> 2 (Feb. </month> <year> 1987), 202207. </year>
Reference-contexts: Such groupings allow a single dialog box to be presented to a user which does not burden the user with a long series of individual privilege decisions and their corresponding dialog boxes. 3.2 First Approach: Capabilities In many respects, Java provides an ideal way to implement a traditional capability system <ref> [10, 24, 20] </ref>. Electric Communities [9] and JavaSoft [13] 8 have implemented such systems. This section discusses general issues for implementing capabilities in Java, rather than specifics of the Electric Communities or JavaSoft implementations. <p> Thus, it may be impossible to ever trust a simple capability system. Likewise, mechanisms must be in place to revoke a capability after it is granted. Many extensions to capabilities have been proposed to address these concerns. Kain and Landwehr <ref> [20] </ref> propose a taxonomy for extensions and survey many systems which implement them. Fundamentally, extended capability systems must either place restrictions on how capabilities can be used, or must place restrictions on how capabilities can be shared.
Reference: [21] <author> KARGER, P. A., AND HERBERT, A. J. </author> <title> An augmented capability architecture to support lattice security and traceability of access. </title> <booktitle> In Proceedings of the 1984 IEEE Symposium on Security and Privacy (Oakland, </booktitle> <address> CA, </address> <month> May </month> <year> 1984), </year> <pages> pp. 212. </pages>
Reference-contexts: The IBM System/38 [3] associates optional access control lists with its capabilities, accomplishing the same purpose. Other systems use hardware mechanisms to block the sharing of capabilities <ref> [21] </ref>. For Java, either technique would be problematic. To make a capability aware of who is calling it, a certain level of introspection into the call stack must be available.
Reference: [22] <author> LAMPSON, B. W. </author> <title> Protection. </title> <booktitle> In Proceedings of the Fifth Princeton Symposium on Information Sciences and Systems (Princeton University, </booktitle> <month> Mar. </month> <year> 1971), </year> <pages> pp. </pages> <note> 437443. Reprinted in Operating Systems Review, 8(1):1824, </note> <month> Jan. </month> <year> 1974. </year>
Reference-contexts: Existing applets run without any modification. This security infrastructure can be decomposed into a number of different sections. Each Java class is annotated with the set of principals who signed it. The policy engine stores an access matrix <ref> [22] </ref>, identifying which principals may access which targets in the system. When code wishes to use a privilege, it must explicitly enable that privilege; if the policy engine permits the access, an annotation is recorded on the call-stack. <p> The engine will track the security preferences of the user (and administrator) and store these preferences in an access matrix <ref> [22] </ref>. In addition to the usual allowed and forbidden labels, a default blank label is also present. When code attempts to enable privileges for a target, the policy engine is consulted with that code's principals and the target in question.
Reference: [23] <author> LAMPSON, B. W. </author> <title> A note on the confinement problem. </title> <journal> Communications of the ACM 16, </journal> <month> 10 (Oct. </month> <year> 1973), </year> <month> 613615. </month>
Reference-contexts: However, an important issue is confinement of privileges <ref> [23] </ref>. It should not generally be possible for one program to delegate a privilege to another program (that right should also be mediated by the system). This is the fundamental flaw in an unmodified capability system; two programs which can communicate object references can share their capabilities without system mediation.
Reference: [24] <author> LEVY, H. M. </author> <title> Capability-Based Computer Systems. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: Research is underway to automate proof generation. One promising idea is to have the compiler for a safe language generate a proof of memory safety during the compilation process. The language-based protection model, exemplified by Java, can be traced back at least to the Burroughs B-5000 in 1961 <ref> [24] </ref> and is also used in current research operating systems such as SPIN [2]. By using a safe language, memory accesses can be controlled [27]. <p> Such groupings allow a single dialog box to be presented to a user which does not burden the user with a long series of individual privilege decisions and their corresponding dialog boxes. 3.2 First Approach: Capabilities In many respects, Java provides an ideal way to implement a traditional capability system <ref> [10, 24, 20] </ref>. Electric Communities [9] and JavaSoft [13] 8 have implemented such systems. This section discusses general issues for implementing capabilities in Java, rather than specifics of the Electric Communities or JavaSoft implementations. <p> A user program could load, store, and execute capabilities, but only the kernel could create a capability <ref> [24] </ref>. In Java, a capability is simply a reference to an object. Java's type safety prevents object references from being forged. It likewise blocks access to methods or member variables which are not labeled public.
Reference: [25] <author> LINDHOLM, T., AND YELLIN, F. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Java uses programming language mechanisms to enforce memory safety. It is a type-safe language, so the Java virtual machine (JVM) prevents programs from accessing memory or calling methods without authorization <ref> [25] </ref>. Existing JVM implementations enforce a simple sandbox security model, which prohibits untrusted code from using any sensitive system services. The sandbox model is easy to understand, but it blocks many useful kinds of programs from being written.
Reference: [26] <author> MICROSOFT CORPORATION. </author> <title> Proposal for Authenticating Code Via the Internet, </title> <month> Apr. </month> <year> 1996. </year> <note> http://www.microsoft.com/intdev/ security/authcode/. </note>
Reference-contexts: Active content can add simple animations to a page, but it can also transform the Web into a platform for writing and distributing programs. A variety of mobile code systems such as Java [16], JavaScript [11], ActiveX <ref> [26] </ref>, and Shockwave [35] make this possible. Users and developers love mobile code, but it raises serious security concerns. While code has been distributed over networks for years, the risks of attack have been manageable. <p> All three systems here can present the same fundamental interface to a user. When digitally signed mobile code arrives in the Web browser, the user can be queried whether they trust the signatory. Microsoft's Authenti-code <ref> [26] </ref> follows a shrink-wrap model once the software is installed, it has unrestricted access to the user's machine. The systems here can provide the user more fine-grained control over which privileges are granted.
Reference: [27] <author> MILNER, R., AND TOFTE, M. </author> <title> Commentary on Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: The language-based protection model, exemplified by Java, can be traced back at least to the Burroughs B-5000 in 1961 [24] and is also used in current research operating systems such as SPIN [2]. By using a safe language, memory accesses can be controlled <ref> [27] </ref>. If the language has a mechanism for enforcing abstraction boundaries (in Java, this means ensuring that private variables and methods 2 are not accessible outside their class), then the system can force control to flow through security checks before executing any dangerous code.
Reference: [28] <institution> NATIONAL COMPUTER SECURITY CENTER. Department of Defense Trusted Computer System Evaluation Criteria (The Orange Book). </institution> <year> 1985. </year>
Reference-contexts: In section 4, we will then compare these systems against a number of security-relevant criteria. 3.1 Common Underpinnings Security mechanisms can be defined by how they implement interposition: the ability to protect a component by interposing a reference monitor <ref> [28] </ref> through which all calls to the component must pass. The reference monitor either rejects each call, or passes it through to the protected component; the reference monitor can use whatever policy it likes to make the decision.
Reference: [29] <author> NECULA, G. C., AND LEE, P. </author> <title> Safe kernel extensions without run-time checking. </title> <booktitle> In Second Symposium on Operating Systems Design and Implementation (OSDI '96) Proceedings (Seattle, </booktitle> <address> WA, </address> <month> Oct. </month> <year> 1996), </year> <pages> pp. 229243. </pages>
Reference-contexts: Secure Services Most discussions of software protection in the OS community focus on memory protection: guaranteeing a program will not access memory or execute code for which it is not authorized. Software fault isolation [41], proof-carrying code <ref> [29] </ref>, and type-safe languages are three popular ways to ensure memory protection. 1.2.1 Software Memory Protection Lucco, et al., introduced software fault isolation [41] in 1993. They showed that memory accesses could be checked in software with a 530% slowdown. <p> By optimizing the placement of the dynamic checks, a perhaps acceptable slowdown is achieved in a software-only implementation. The theory is still the same as hardware-based protection: potentially dangerous operations are dynamically checked for safety before their execution. Necula and Lee introduced proof-carrying code <ref> [29] </ref> in 1996. Proof-carrying code eliminates the slowdown associated with software fault isolation by statically verifying a proof that a program respects an agreed upon security policy. After the proof is verified, the program can run at full speed.
Reference: [30] <author> NEUMANN, P. G., BOYER, R. S., FEIERTAG, R. J., LEVITT, K. N., AND ROBINSON, L. </author> <title> A provably secure operating system: The system, its applications, and proofs. </title> <type> Tech. Rep. </type> <institution> CSL-116, 2nd Ed., SRI International, </institution> <month> May </month> <year> 1980. </year>
Reference-contexts: This section discusses general issues for implementing capabilities in Java, rather than specifics of the Electric Communities or JavaSoft implementations. Dating back to the 1960's, hardware and software-based capability systems have often been seen as a good way to structure a secure operating system <ref> [17, 30, 39] </ref>. Fundamentally, a capability is an unforgeable pointer to a controlled system resource. To use a capability, a program must have been first explicitly given that capability, either as part of its initialization or as the result of calling another capability.
Reference: [31] <author> OUSTERHOUT, J. K. </author> <title> Why aren't operating systems getting faster as fast as hardware? In Proceedings of Summer 1990 USENIX Conference (June 1990), </title> <journal> pp. </journal> <volume> 247256. </volume>
Reference-contexts: When the two objects are in different tasks, the call takes 230 sec; when the called object is in a dynamically linked library in the same task, the call takes only 0.2 sec a factor of 1000 difference. This ratio appears to be growing even larger in newer processors <ref> [31, 1] </ref>. The time difference would be acceptable if cross-domain calls were very rare. But modern software structures, especially in mobile code systems, are leading to tighter binding between domains.
Reference: [32] <author> PIKE, R., PRESOTTO, D., THOMPSON, K., AND TRICKEY, H. </author> <title> Plan 9 from Bell Labs. </title> <booktitle> In Proceedings of the Summer 1990 UKUUG Conference (London, </booktitle> <month> July </month> <year> 1990), </year> <pages> pp. 19. </pages>
Reference-contexts: This technique is used in Safe-Tcl [5] to hide commands in an untrusted interpreter. Plan 9 <ref> [32] </ref> can similarly attach different programs and services to the filesystem viewed by an untrusted process. In an object-oriented language, classes represent resources we wish to control. For example, a FileSystem class may represent the filesystem and a Window class may represent graphics operations.
Reference: [33] <author> REES, J. A. </author> <title> A security kernel based on the lambda-calculus. </title> <type> Tech. Rep. </type> <institution> A.I. </institution> <note> Memo No. 1564, </note> <institution> Mas-sachusetts Institute of Technology, Artificial Intelligence Laboratory, </institution> <month> Mar. </month> <year> 1996. </year>
Reference-contexts: Language-based safety can use either dynamic type checking <ref> [33, 5] </ref> or static type checking (as is mostly the case in Java [8]). The major tradeoff is performance versus theoretical complexity. The static system should be faster, because it only checks safety once, before the program starts.
Reference: [34] <author> SALTZER, J. H., AND SCHROEDER, M. D. </author> <title> The protection of information in computer systems. </title> <booktitle> Proceedings of the IEEE 63, </booktitle> <address> 9 (Sept. </address> <year> 1975), </year> <month> 12781308. </month>
Reference-contexts: Thus, those classes may be allowed to see the real classes which are hidden from other applet classes. 4 Analysis Now that we have presented three systems, we need a set of criteria to evaluate them. This list is derived from Saltzer and Schroeder <ref> [34] </ref>. Economy of mechanism Designs which are smaller and simpler are easier to inspect and trust. Fail-safe defaults By default, access should be denied unless it is explicitly granted. Complete mediation Every access to every object should be checked.
Reference: [35] <author> SCHMITT, B. </author> <title> Shockwave Studio: Designing Multimedia for the Web. </title> <publisher> O'Reilly & Associates, Inc., </publisher> <month> Mar. </month> <year> 1997. </year>
Reference-contexts: Active content can add simple animations to a page, but it can also transform the Web into a platform for writing and distributing programs. A variety of mobile code systems such as Java [16], JavaScript [11], ActiveX [26], and Shockwave <ref> [35] </ref> make this possible. Users and developers love mobile code, but it raises serious security concerns. While code has been distributed over networks for years, the risks of attack have been manageable.
Reference: [36] <author> SCHROEDER, M. D., AND SALTZER, J. H. </author> <title> A hardware architecture for implementing protection rings. </title> <journal> Communications of the ACM 15, </journal> <month> 3 (Mar. </month> <year> 1972), </year> <month> 157170. </month>
Reference-contexts: with a discussion of appropriate environments in which to deploy each strategy. 1.1 The Advantages of Software Protection Historically, memory protection and privilege levels have been implemented in hardware: memory protection via base / limit registers, segments, or pages; and privilege levels via user / kernel mode bits or rings <ref> [36] </ref>. Recent mobile code systems, however, rely on software rather than hardware for protection. The switch to software mechanisms is being driven by two technological trends: portability and performance. Portability The first argument for software protection is portability.
Reference: [37] <author> SELTZER, M. I., ENDO, Y., SMALL, C., AND SMITH, K. A. </author> <title> Dealing with disaster: Surviving misbehaved kernel extensions. </title> <booktitle> In Proceedings of 2nd ACM Symposium on Operating Systems Design and Implementation (Oct. </booktitle> <year> 1996), </year> <pages> pp. 213227. </pages>
Reference-contexts: Seltzer, et al., studied some of the security problems involved in creating an extensible operating system <ref> [37] </ref>. They argue that memory protection is only part of the solution; the bulk of their paper is concerned with questions of how to provide secure services. Consider also the security flaws that have been found in UNIX.
Reference: [38] <editor> SIEGEL, J., Ed. </editor> <title> CORBA Fundamentals and Programming. </title> <publisher> John Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: mentioned in section 4.1, a capability system would require a new library API and thus completely break compatibility with traditional Java APIs. 4.10 Remote Calls Recent systems are beginning to offer convenient distributed programming in Java, using a distributed-objects model similar to that of SRC network objects [4] or CORBA <ref> [38] </ref>. It would be highly desirable for language based security schemes to easily extend to a distributed environment. A single security policy and implementation mechanism could deal naturally with both local and remote code. Capabilities extend quite naturally across a network.
Reference: [39] <author> TANENBAUM, A. S., MULLENDER, S. J., AND VAN RENESSE, R. </author> <title> Using sparse capabilities in a distributed operating system. </title> <booktitle> In 6th International Conference on Distributed Computing Systems (Cam-bridge, </booktitle> <address> MA, </address> <month> May </month> <year> 1986), </year> <pages> pp. 558563. </pages>
Reference-contexts: This section discusses general issues for implementing capabilities in Java, rather than specifics of the Electric Communities or JavaSoft implementations. Dating back to the 1960's, hardware and software-based capability systems have often been seen as a good way to structure a secure operating system <ref> [17, 30, 39] </ref>. Fundamentally, a capability is an unforgeable pointer to a controlled system resource. To use a capability, a program must have been first explicitly given that capability, either as part of its initialization or as the result of calling another capability. <p> Capabilities extend quite naturally across a network. If remote object references include an unguessable string of bits (i.e., 128 random bits), then a remote capability reference has all the security properties of a local capability <ref> [39, 14] </ref> (assuming all communication is suitable encrypted to prevent eavesdropping). Unfortunately, the confinement issues discussed in section 4.3 become even more problematic. If the capability is leaked to a third party, then the third party has just as much power to use the capability as its intended holder.
Reference: [40] <author> VAN DOORN, L., ABADI, M., BURROWS, M., AND WOBBER, E. </author> <title> Secure network objects. </title> <booktitle> In Proceedings of the 1996 IEEE Symposium on Security and Privacy (Oakland, </booktitle> <address> CA, </address> <month> May </month> <year> 1996). </year>
Reference-contexts: By themselves, net-worked capabilities offer no way to identify the remote caller. However, if the remote method invocation used a cryptographically authenticated channel (as provided by SSL [12] or Taos [42]), the remote identity may be useful. Gong [14] and van Doorn, et al. <ref> [40] </ref> describe implementations of this. In the case of stack introspection, the local stub for the RPC could be labeled with the remote principal (again, provided via SSL or Taos). The local stub can then enable privileges on behalf of its remote caller.
Reference: [41] <author> WAHBE, R., LUCCO, S., ANDERSON, T. E., AND GRAHAM, S. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings of the Fourteenth Symposium on Operating System Principles (1993). </booktitle>
Reference-contexts: Secure Services Most discussions of software protection in the OS community focus on memory protection: guaranteeing a program will not access memory or execute code for which it is not authorized. Software fault isolation <ref> [41] </ref>, proof-carrying code [29], and type-safe languages are three popular ways to ensure memory protection. 1.2.1 Software Memory Protection Lucco, et al., introduced software fault isolation [41] in 1993. They showed that memory accesses could be checked in software with a 530% slowdown. <p> Software fault isolation <ref> [41] </ref>, proof-carrying code [29], and type-safe languages are three popular ways to ensure memory protection. 1.2.1 Software Memory Protection Lucco, et al., introduced software fault isolation [41] in 1993. They showed that memory accesses could be checked in software with a 530% slowdown. A similar technique could be used to check the target address of every branch. By optimizing the placement of the dynamic checks, a perhaps acceptable slowdown is achieved in a software-only implementation.
Reference: [42] <author> WOBBER, E., ABADI, M., BURROWS, M., AND LAMPSON, B. </author> <title> Authentication in the Taos operating system. </title> <journal> ACM Transactions on Computer Systems 12, </journal> <month> 1 (Feb. </month> <year> 1994), </year> <pages> 332. 16 </pages>
Reference-contexts: By themselves, net-worked capabilities offer no way to identify the remote caller. However, if the remote method invocation used a cryptographically authenticated channel (as provided by SSL [12] or Taos <ref> [42] </ref>), the remote identity may be useful. Gong [14] and van Doorn, et al. [40] describe implementations of this. In the case of stack introspection, the local stub for the RPC could be labeled with the remote principal (again, provided via SSL or Taos).
References-found: 42

