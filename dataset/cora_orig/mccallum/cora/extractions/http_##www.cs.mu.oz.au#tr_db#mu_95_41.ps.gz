URL: http://www.cs.mu.oz.au/tr_db/mu_95_41.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: Inheritance Key Centre for Knowledge Based Systems, and the Cooperative Research Centre for Intelligent Decision
Author: Lobel Crnogorac Prof. Kotagiri Ramamohanarao Dr. Anand S. Rao 
Keyword: Key Words: concurrency, synchronization, object-orientation, reusability  
Note: Supported by an APA scholarship, the  Supported by an Australian Research Council grant, the  
Address: Parkville 3052 Australia  Parkville 3052 Australia  Level 6, 171 La Trobe Street, Melbourne Victoria 3000, Australia  7937  
Affiliation: Department of Computer Science The University of Melbourne  Department of Computer Science The University of Melbourne  Australian Artificial Intelligence Institute  
Pubnum: Anomaly  
Email: Email: lobel@cs.mu.oz.au  Email: rao@cs.mu.oz.au  Email: anand@aaii.oz.au  
Phone: Phone: +61 3 9287 9101 Fax: +61 3 9348 1184  Phone: +61 3 9287 9101 Fax: +61 3 9348 1184  Phone: +61 3 9663 7922 Fax: +61 3 9663  
Date: October 28, 1995  
Abstract: Inheritance anomaly is a well known problem in concurrent object-oriented programming. Much work has been done in this area recently, but the problem is far from solved. In this paper we propose a simple language construct that solves the inheritance anomaly. Our proposal involves the use of pre-conditions and post-actions in which synchronization constraints of objects are specified. Pre-conditions and post-actions framework is very powerful. Apart from being able to handle all the known anomalies it also facilitates incremental changes instead of re-definitions when inherited methods are specialized or generalized. Real-time-specification anomalies and anomalies in sequential object-oriented languages are also investigated. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mehmet Aksit, Jan Bosch, William van der Sterren, and Lodewijk Bergmans. </author> <title> Real-time specification inheritance anomalies and real-time filters. </title> <editor> In Mario Tokoro and Remo Pareschi, editors, ECOOP'94, </editor> <booktitle> Lecture Notes in Computer Science 821, </booktitle> <pages> pages 386-407, </pages> <address> Bologna, Italy, July 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: 1 Introduction Inheritance is one of the most important features of many object-oriented programming (OOP) languages. However, extending OOP with concurrency or real-time specifications has raised some problems. One of these problems is the inheritance anomaly <ref> [1, 6, 8, 9, 11] </ref>. Concurrent object-oriented programming (COOP) languages have to provide facilities for expressing synchronization constraints of objects. For example, the programmer needs to be able to express that writing into a full queue or reading from an empty queue is not allowed. <p> Inheritance anomaly is the conflict between concurrency and inheritance where extensive re-definitions of inherited methods are necessary in order to maintain the synchronization constraints of concurrent objects. Similar anomaly occurs when OOP is extended with real-time specifications <ref> [1] </ref>. Matsuoka and Yonezawa [8] have distinguished three kinds of inheritance anomalies in COOP languages: state-partitioning, state-modification and history-only-sensitiveness. The state-partitioning anomaly is the easiest one to solve. It can be successfully solved by the use of method guards [4]. <p> These anomalies were described by Aksit et:al: <ref> [1] </ref> who introduce the concept of real-time filters for solving them. The behaviour of real-time-specification anomalies is different from the synchronization anomalies because they appear only when specifications are actually changed in the subclass. <p> Synchronization anomalies can appear when a new method is introduced and the inherited methods have to be re-defined even though their behaviour hasn't been changed at all. The problems described in <ref> [1] </ref> arise when the real-time specifications are changed. A change of real-time constraints of a method in a subclass does not affect its functionality, so it is to be expected that re-definitions would not be required in the superclass. However, in most real-time specification languages such re-definitions would take place. <p> The maximum connection takes n times longer than in the class Switch, while the minimum connection time is increased. 13 The previous example shows that our framework can avoid unnecessary code re-definitions when real-time constraints are changed in the subclass. Real-time specifications as described in <ref> [1] </ref> are limited in their expressiveness. We are only able to specify the start and end times of methods. However, there are many real-life examples where we need to specify deadlines based on the state the object is in.
Reference: [2] <author> Pierre America. </author> <title> Inheritance and subtyping in a parallel object-oriented language. </title> <editor> In J. Bezivin, J.-M.Hullot, P.Cointe, and H.Lieberman, editors, ECOOP'87, </editor> <booktitle> Lecture Notes in Computer Science 276, </booktitle> <pages> pages 234-242, </pages> <address> Paris, France, June 1987. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Additional behaviour is usually introduced in the subclasses. Class inheritance is equivalent to subtyping (America <ref> [2] </ref>) in this definition. module inheritance is used for re-use and modification of messages previously defined in a superclass The HOS anomaly is placed under module inheritance in [9], rather than under class inheritance. Our proposal treats history-sensitive problems as class inheritance, which can always be programmed without any anomalies.
Reference: [3] <author> R.H. Campbell and A.N.Habermann. </author> <title> The specification of process synchronization by path expressions. </title> <booktitle> In Lecture Notes in Computer Science 16, </booktitle> <pages> pages 89-102. </pages> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: The expression super (Buffer.get) in method gget refers to the pre-condition block of the method get in the superclass Buffer. Another way of specifying conditions about the history of objects is by the well known path expressions <ref> [3] </ref>. To construct a path expression we can use the operator ; (denoting sequential execution) or the operator fl (denoting 0 or more occurrences).
Reference: [4] <author> D. Decouchant et. al. </author> <title> A synchronization mechanism for typed objects in a distributed system. </title> <booktitle> In Proc. 1988 ACM SIGPLAN Workshop on Object-Based Concurrent Programming, volume 24 of SIGPLAN Notices, </booktitle> <pages> pages 105-107. </pages> <publisher> ACM Press, </publisher> <month> April </month> <year> 1989. </year>
Reference-contexts: Similar anomaly occurs when OOP is extended with real-time specifications [1]. Matsuoka and Yonezawa [8] have distinguished three kinds of inheritance anomalies in COOP languages: state-partitioning, state-modification and history-only-sensitiveness. The state-partitioning anomaly is the easiest one to solve. It can be successfully solved by the use of method guards <ref> [4] </ref>. The other two anomalies have not been solved, only minimized in the previous proposals. It is important to note that the inheritance anomaly is language dependent. It depends on the particular synchronization scheme chosen to express the synchronization constraints.
Reference: [5] <author> Svend Frtlund. </author> <title> Inheritance of synchronization constraints in concurrent object-oriented programming languages. </title> <editor> In O. Lehrmann Madsen, editor, ECOOP'92, </editor> <booktitle> Lecture Notes in Computer Science 615, </booktitle> <pages> pages 185-196, </pages> <address> Utrecht, The Netherlands, June 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: However, the language should provide a clean, natural framework in which these code changes can be performed by incremental modification rather than total re-definition. Incremental modification would enable the code to be changed without being re-implemented from scratch in subclasses <ref> [5] </ref>. The framework employed for this purpose would be heavily influenced by the way these specializations are used in practice. It has been claimed that the natural way to specialize classes is by making the synchronization constraints more restrictive in the subclasses [5]. <p> changed without being re-implemented from scratch in subclasses <ref> [5] </ref>. The framework employed for this purpose would be heavily influenced by the way these specializations are used in practice. It has been claimed that the natural way to specialize classes is by making the synchronization constraints more restrictive in the subclasses [5]. On the other hand, the early proposals involving the enabled-sets [11] effectively make the synchronization constraints less restrictive in the subclasses. For example, in Rosette [11] methods can be incrementally added to the enabled-sets in the subclasses.
Reference: [6] <author> Dennis G. Kafura and Keung Hae Lee. </author> <title> Inheritance in Actor based concurrent object-oriented languages. </title> <booktitle> In ECOOP'89, </booktitle> <pages> pages 131-145. </pages> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Inheritance is one of the most important features of many object-oriented programming (OOP) languages. However, extending OOP with concurrency or real-time specifications has raised some problems. One of these problems is the inheritance anomaly <ref> [1, 6, 8, 9, 11] </ref>. Concurrent object-oriented programming (COOP) languages have to provide facilities for expressing synchronization constraints of objects. For example, the programmer needs to be able to express that writing into a full queue or reading from an empty queue is not allowed. <p> The other two anomalies have not been solved, only minimized in the previous proposals. It is important to note that the inheritance anomaly is language dependent. It depends on the particular synchronization scheme chosen to express the synchronization constraints. For example, if our chosen synchronization scheme is behaviour abstractions <ref> [6] </ref> then the state-partitioning anomaly can appear in programs. However, if we use method guards, the state-partitioning anomaly cannot appear. In this paper we re-visit the inheritance anomaly and look at its causes and consequences. <p> We have defined an object Buffer with methods put and get. In order to illustrate the anomaly we initially use a synchronization scheme similar to some of the early proposals <ref> [6, 11] </ref>. The synchronization scheme uses the keyword accept to specify the set of methods acceptable to the object. Method put is acceptable unless Buffer is full. Method get is acceptable unless Buffer is empty. <p> Sequential languages, like concurrent ones, also have objects that can only accept a subset of their messages at a particular time. We might think of a sequential OO language that uses a scheme similar to the next accept state scheme proposed by Kafura and Lee <ref> [6] </ref>. In this case adding a new subclass may cause re-definitions to the main function of the program. Example 14 Consider Example 1 written in a sequential OO language.
Reference: [7] <author> Cristina Videira Lopes and Karl J. Lieberherr. </author> <title> Abstracting process-to-function relations in concurrent object-oriented applications. </title> <editor> In Mario Tokoro and Remo Pareschi, editors, ECOOP'94, </editor> <booktitle> Lecture Notes in Computer Science 821, </booktitle> <pages> pages 81-99, </pages> <address> Bologna, Italy, July 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: All synchronization code is in pre-conditions and post-actions, cleanly separated from the functionality code. The need to clearly separate concurrency issues from the rest of the code has been previously pointed out in literature <ref> [7] </ref>. This makes code re-use easier. Pre-condition block is executed before the body and contains a conditional expression that has to evaluate to true in order for the method to be executed. Post-action block consists of a set of statements that are executed after the body.
Reference: [8] <author> S. Matsuoka and A. Yonezawa. </author> <title> Analysis of inheritance anomaly in object-oriented concurrent programming languages. </title> <editor> In Gul Agha, Peter Wegner, and Akinori Yonezawa, editors, </editor> <booktitle> Research Directions in Concurrent Object-Oriented Programming, chapter 1, </booktitle> <pages> pages 107-150. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction Inheritance is one of the most important features of many object-oriented programming (OOP) languages. However, extending OOP with concurrency or real-time specifications has raised some problems. One of these problems is the inheritance anomaly <ref> [1, 6, 8, 9, 11] </ref>. Concurrent object-oriented programming (COOP) languages have to provide facilities for expressing synchronization constraints of objects. For example, the programmer needs to be able to express that writing into a full queue or reading from an empty queue is not allowed. <p> Inheritance anomaly is the conflict between concurrency and inheritance where extensive re-definitions of inherited methods are necessary in order to maintain the synchronization constraints of concurrent objects. Similar anomaly occurs when OOP is extended with real-time specifications [1]. Matsuoka and Yonezawa <ref> [8] </ref> have distinguished three kinds of inheritance anomalies in COOP languages: state-partitioning, state-modification and history-only-sensitiveness. The state-partitioning anomaly is the easiest one to solve. It can be successfully solved by the use of method guards [4]. The other two anomalies have not been solved, only minimized in the previous proposals. <p> It usually occurs with mix-in inheritance when a subclass is defined by inheritance from two superclasses. Mixing-in of one class can introduce a finer-grained distinction for the set of states under which the methods from the other class can be invoked <ref> [8] </ref>. The code re-definitions are caused by the need to account for this finer-grained distinction of states. 1 3 The Constructs in Our Proposal Our proposal uses the notions of pre-conditions and post-actions. Every method definition consists of a block of pre-conditions, a body and a block of post-actions. <p> Example 2 This example shows that in our proposal the superclass code does not have to be changed at all after the addition of the new method get2. State-partitioning is the easiest kind of anomaly to solve. It has been solved before by the use of method guards <ref> [8] </ref>. In our proposal pre-conditions act as guards. 4.2 History Only Sensitiveness In COOP we often encounter situations that depend on history of an object. For example, we may introduce a method that can only be executed if another method has been executed twice. Matsuoka and Yonezawa [8] handle the history-sensitive <p> of method guards <ref> [8] </ref>. In our proposal pre-conditions act as guards. 4.2 History Only Sensitiveness In COOP we often encounter situations that depend on history of an object. For example, we may introduce a method that can only be executed if another method has been executed twice. Matsuoka and Yonezawa [8] handle the history-sensitive anomalies that depend only on the previously accepted message. Other proposals cannot avoid the anomaly at all. This is a serious deficiency because it greatly restricts the expressiveness of anomaly-free programs. <p> We define a subclass of Buffer, HistoryBuffer, with a new method gget. This method behaves exactly like get except that it cannot be invoked immediately after an invocation of put. This is the standard example of this type of 3 anomaly (see <ref> [8] </ref>). The synchronization scheme employed here uses method guards. The methods put and get which were inherited from the class Buffer had to be re-defined in the subclass in order to introduce the new variable after put. <p> Incremental modifications in subclasses would then not be required since they are performed by the system. This is similar to the use of construct all-except <ref> [8] </ref>. Note that in the previous example new pre-conditions involve the state variable locked. This means that the user has to know about state variables in class Lock. <p> Example 12 The above example illustrates a state-modification problem that can occur when the chosen synchronization scheme is not able to handle HOS. This example uses the method set framework described by Matsuoka and Yonezawa <ref> [8] </ref>. The code for the class LockBuffer is not available as it is a part of an executable library. We only know the specification of the class, i:e:, that lock1 locks all methods except put, get and get2, and that lock2 locks all methods except put. <p> This method returns the state of the object. We also wish to write the method get2. The ability to handle history-sensitiveness can be very helpful in dealing with state-modification problems. Note that this example cannot be handled by any of the previous proposals. Even first-classing of method sets in <ref> [8] </ref> cannot solve this problem. In this particular example we could differentiate between the states by adding the ability to compare the method sets. The method inquire would then compare the current method set with LOCK1 and LOCK2. <p> The anomaly appears because all the inherited methods have to take into account the new state attributes which usually means re-definition of their synchronization code. History-only-sensitiveness is a special case of this type of anomaly in which every state is appended with history information. Figure 5.1 (taken from <ref> [8] </ref>) illustrates what happens when the states are extended with an additional attribute locked. Every state splits into two distinct, new states depending on the value of the attribute. Figure 5.2 illustrates what happens when the states are extended with the history information about the previous two method invocations.
Reference: [9] <author> Jose Meseguer. </author> <title> Solving the inheritance anomaly in concurrent object-oriented programming. </title> <editor> In Oscar Nierstrasz, editor, ECOOP'93, </editor> <booktitle> Lecture Notes in Computer Science 707, </booktitle> <pages> pages 220-246, </pages> <address> Kaiserlautern, Germany, July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: 1 Introduction Inheritance is one of the most important features of many object-oriented programming (OOP) languages. However, extending OOP with concurrency or real-time specifications has raised some problems. One of these problems is the inheritance anomaly <ref> [1, 6, 8, 9, 11] </ref>. Concurrent object-oriented programming (COOP) languages have to provide facilities for expressing synchronization constraints of objects. For example, the programmer needs to be able to express that writing into a full queue or reading from an empty queue is not allowed. <p> The other case arises when the subclass changes the behaviour of the inherited methods. In this case some changes are obviously necessary, but they should be performed in a systematic way. The notion of class inheritance was discussed by Meseguer <ref> [9] </ref>. He distinguishes between two different uses of inheritance: class inheritance is used for taxonomic classification of objects in which the behaviour of messages in a superclass is never contradicted by their behaviour in a subclass. Additional behaviour is usually introduced in the subclasses. <p> Additional behaviour is usually introduced in the subclasses. Class inheritance is equivalent to subtyping (America [2]) in this definition. module inheritance is used for re-use and modification of messages previously defined in a superclass The HOS anomaly is placed under module inheritance in <ref> [9] </ref>, rather than under class inheritance. Our proposal treats history-sensitive problems as class inheritance, which can always be programmed without any anomalies. For instance, Example 3 doesn't modify the behaviour of put and get messages in the subclass. Hence, this example should fall within class inheritance.
Reference: [10] <author> Christian Neusius. </author> <title> Synchronizing actions. </title> <editor> In Pierre America, editor, ECOOP'91, </editor> <booktitle> Lecture Notes in Computer Science 512, </booktitle> <pages> pages 118-132, </pages> <address> Geneva, Switzerland, July 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The design of an efficient language incorporating these ideas will be the subject of our further research. A similar framework to ours has been proposed by Neusius <ref> [10] </ref>. Although Neusius also uses the notions of pre-conditions and post-actions there are many differences. His framework is intended for use with objects that support internal concurrency. Our proposal doesn't support internal concurrency. The history-sensitiveness and state-modification anomalies are not mentioned in [10] and post-actions are therefore not employed in their <p> framework to ours has been proposed by Neusius <ref> [10] </ref>. Although Neusius also uses the notions of pre-conditions and post-actions there are many differences. His framework is intended for use with objects that support internal concurrency. Our proposal doesn't support internal concurrency. The history-sensitiveness and state-modification anomalies are not mentioned in [10] and post-actions are therefore not employed in their solutions. The use of pre-conditions is similar to our proposal, but they cannot be incrementally modified.
Reference: [11] <author> Chris Tomlinson and Vineet Singh. </author> <title> Inheritance and synchronization with enabled-sets. </title> <booktitle> In OOPSLA '89, volume 24 of SIGPLAN Notices, </booktitle> <pages> pages 103-112. </pages> <publisher> ACM Press, </publisher> <month> October </month> <year> 1989. </year> <month> 15 </month>
Reference-contexts: 1 Introduction Inheritance is one of the most important features of many object-oriented programming (OOP) languages. However, extending OOP with concurrency or real-time specifications has raised some problems. One of these problems is the inheritance anomaly <ref> [1, 6, 8, 9, 11] </ref>. Concurrent object-oriented programming (COOP) languages have to provide facilities for expressing synchronization constraints of objects. For example, the programmer needs to be able to express that writing into a full queue or reading from an empty queue is not allowed. <p> We have defined an object Buffer with methods put and get. In order to illustrate the anomaly we initially use a synchronization scheme similar to some of the early proposals <ref> [6, 11] </ref>. The synchronization scheme uses the keyword accept to specify the set of methods acceptable to the object. Method put is acceptable unless Buffer is full. Method get is acceptable unless Buffer is empty. <p> It has been claimed that the natural way to specialize classes is by making the synchronization constraints more restrictive in the subclasses [5]. On the other hand, the early proposals involving the enabled-sets <ref> [11] </ref> effectively make the synchronization constraints less restrictive in the subclasses. For example, in Rosette [11] methods can be incrementally added to the enabled-sets in the subclasses. <p> It has been claimed that the natural way to specialize classes is by making the synchronization constraints more restrictive in the subclasses [5]. On the other hand, the early proposals involving the enabled-sets <ref> [11] </ref> effectively make the synchronization constraints less restrictive in the subclasses. For example, in Rosette [11] methods can be incrementally added to the enabled-sets in the subclasses. The addition of a method to an enabled-set increases the set of conditions under which that method can be accepted, thus making the synchronization constraints less restrictive. Our framework supports both views. <p> In order to be accepted a method needs to satisfy more conditions in the subclass than in the superclass. 5.2 Relaxation In some cases it is desirable to make the synchronization condition of a method less restrictive. This is the approach taken in Rosette <ref> [11] </ref>. We say that the synchronization condition is relaxed. There are two operators in our proposal that are used to relax the synchronization constraints. The _ operator stands for a disjunction of two conditions. Example 9 This example illustrates the implementation of a two-level lock to the bounded buffer class.
References-found: 11

