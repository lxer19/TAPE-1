URL: http://www.cs.berkeley.edu/~aiken/ftp/lics92.ps
Refering-URL: http://www.cs.berkeley.edu/~aiken/pubs.html
Root-URL: 
Email: email: lastname@almaden.ibm.com  
Phone: phone: 408/927-1876  fax: 408/927-2100  
Title: Solving Systems of Set Constraints (Extended Abstract)  
Author: Alexander Aiken Edward L. Wimmers 
Address: 650 Harry Rd. San Jose, CA 95120  or 927-1882  
Affiliation: IBM Almaden Research Center  
Abstract: Systems of set constraints are a natural formalism for many problems in program analysis. Set constraints are also a generalization of tree automata. We present an algorithm for solving systems of set constraints built from free variables, constructors, and the set operations of intersection, union, and complement. Furthermore, we show that all solutions of such systems can be finitely represented. 1 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken and B. Murphy. </author> <title> Implementing regular tree expressions. </title> <booktitle> In Proceedings of the 1991 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 427-447, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Combining these constraints, we can infer that v must be a floating-point number (i.e., v (Int [ Float) " :Int = Float). Set constraints have been used in program analysis and type inference algorithms for functional languages <ref> [1, 2, 10, 12, 14, 17] </ref> 2 , logic programming languages [8, 11], and imperative languages [9]. Solving a system of set constraints is central to each of these program analysis algorithms. <p> Presumably, 2 this is why equations of this form (ff = E (ff) with no negations) have been studied almost exclusively <ref> [1, 2, 8, 12] </ref>. However, when set complement is added to the language, even equations of this restricted form might not have solutions. For example, the equation ff = :ff has no solutions.
Reference: [2] <author> A. Aiken and B. Murphy. </author> <title> Static type inference in a dynamically typed language. </title> <booktitle> In Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 279-290, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Combining these constraints, we can infer that v must be a floating-point number (i.e., v (Int [ Float) " :Int = Float). Set constraints have been used in program analysis and type inference algorithms for functional languages <ref> [1, 2, 10, 12, 14, 17] </ref> 2 , logic programming languages [8, 11], and imperative languages [9]. Solving a system of set constraints is central to each of these program analysis algorithms. <p> Presumably, 2 this is why equations of this form (ff = E (ff) with no negations) have been studied almost exclusively <ref> [1, 2, 8, 12] </ref>. However, when set complement is added to the language, even equations of this restricted form might not have solutions. For example, the equation ff = :ff has no solutions.
Reference: [3] <author> J. A. Brzozowski and E. Leiss. </author> <title> On equations for regular languages, finite automata, and sequential networks. </title> <journal> Theoretical Computer Science, </journal> <volume> 10 </volume> <pages> 19-35, </pages> <year> 1980. </year>
Reference-contexts: These algorithms were developed either for an application in program analysis [7, 10, 12, 14] or in work on finite automata <ref> [3, 6, 13] </ref>. Mishra and Reddy [12] give a method for solving constraints between expressions without complement where all set unions are discriminative (i.e., if c (: : :) [ d (: : :) is an expression, then c 6= d). <p> In work on finite automata, Brzozowski and Leiss present an algorithm for solving equations between regular languages with free variables <ref> [3] </ref>. Since regular languages are equivalent to tree languages with only unary constructors, our algorithm can be regarded as the generalization of their work to constructors of arbitrary arity. A related line of work is program analysis methods based on extensions of tree automata other than set constraints [4, 5].
Reference: [4] <author> Gilberto File. </author> <title> Tree automata and logic programs. </title> <booktitle> In Second Annual Symposium on Theoretical Aspects of Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> Jan-uary </month> <year> 1985. </year> <note> Lecture Notes in Computer Science 182. </note>
Reference-contexts: Since regular languages are equivalent to tree languages with only unary constructors, our algorithm can be regarded as the generalization of their work to constructors of arbitrary arity. A related line of work is program analysis methods based on extensions of tree automata other than set constraints <ref> [4, 5] </ref>. The expressive power of these techniques is different than that of set constraints, but the exact relationship is as yet undetermined.
Reference: [5] <author> T. Fruwirth, E. Shapiro, M. Vardi, and E. Yardeni. </author> <title> Logic programs as types for logic programs. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 300-309, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Since regular languages are equivalent to tree languages with only unary constructors, our algorithm can be regarded as the generalization of their work to constructors of arbitrary arity. A related line of work is program analysis methods based on extensions of tree automata other than set constraints <ref> [4, 5] </ref>. The expressive power of these techniques is different than that of set constraints, but the exact relationship is as yet undetermined.
Reference: [6] <author> F. Gecseg and M. Steinby. </author> <title> Tree Automata. </title> <address> Acade-mei Kaido, Budapest, </address> <year> 1984. </year>
Reference-contexts: These algorithms were developed either for an application in program analysis [7, 10, 12, 14] or in work on finite automata <ref> [3, 6, 13] </ref>. Mishra and Reddy [12] give a method for solving constraints between expressions without complement where all set unions are discriminative (i.e., if c (: : :) [ d (: : :) is an expression, then c 6= d).
Reference: [7] <author> N. Heintze and J. Jaffar. </author> <title> A decision procedure for a class of set constraints. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 42-51, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: These algorithms were developed either for an application in program analysis <ref> [7, 10, 12, 14] </ref> or in work on finite automata [3, 6, 13]. <p> Mishra and Reddy [12] give a method for solving constraints between expressions without complement where all set unions are discriminative (i.e., if c (: : :) [ d (: : :) is an expression, then c 6= d). Heintze and Jaffar <ref> [7] </ref> give an algorithm for the class of definite constraints, which are of the form A B, where B contains no set operations and A contains no complement operations. Heintze and Jaffar also use projection functions, an additional set operation we do not consider.
Reference: [8] <author> N. Heintze and J. Jaffar. </author> <title> A finite presentation theorem for approximating logic programs. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 197-209, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Combining these constraints, we can infer that v must be a floating-point number (i.e., v (Int [ Float) " :Int = Float). Set constraints have been used in program analysis and type inference algorithms for functional languages [1, 2, 10, 12, 14, 17] 2 , logic programming languages <ref> [8, 11] </ref>, and imperative languages [9]. Solving a system of set constraints is central to each of these program analysis algorithms. Systems of set constraints can also define tree automata; in this case, the sets of terms are the language of a finite-state machine. <p> Presumably, 2 this is why equations of this form (ff = E (ff) with no negations) have been studied almost exclusively <ref> [1, 2, 8, 12] </ref>. However, when set complement is added to the language, even equations of this restricted form might not have solutions. For example, the equation ff = :ff has no solutions.
Reference: [9] <author> N. Heintze and J. Jaffar. </author> <title> Set-based program analysis. </title> <type> Draft manuscript, </type> <year> 1991. </year>
Reference-contexts: Set constraints have been used in program analysis and type inference algorithms for functional languages [1, 2, 10, 12, 14, 17] 2 , logic programming languages [8, 11], and imperative languages <ref> [9] </ref>. Solving a system of set constraints is central to each of these program analysis algorithms. Systems of set constraints can also define tree automata; in this case, the sets of terms are the language of a finite-state machine.
Reference: [10] <author> N. D. Jones and S. S. Muchnick. </author> <title> Flow analysis and optimization of LISP-like structures. </title> <booktitle> In Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 244-256, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: Combining these constraints, we can infer that v must be a floating-point number (i.e., v (Int [ Float) " :Int = Float). Set constraints have been used in program analysis and type inference algorithms for functional languages <ref> [1, 2, 10, 12, 14, 17] </ref> 2 , logic programming languages [8, 11], and imperative languages [9]. Solving a system of set constraints is central to each of these program analysis algorithms. <p> These algorithms were developed either for an application in program analysis <ref> [7, 10, 12, 14] </ref> or in work on finite automata [3, 6, 13]. <p> For every constructor f, a family of projection functions f 1 ; : : :; f a (f) is defined as follows: (f i (E); ) = fx i jf (x 1 ; : : : ; x a (f) ) 2 (E; )g Reynolds [14] and Jones and Muchnick <ref> [10] </ref> present algorithms for solving set constraints with projection functions, but without union or complement operations. In work on finite automata, Brzozowski and Leiss present an algorithm for solving equations between regular languages with free variables [3].
Reference: [11] <author> P. Mishra. </author> <title> Towards a theory of types in PRO-LOG. </title> <booktitle> In Proceedings of the First IEEE Symposium in Logic Programming, </booktitle> <pages> pages 289-298, </pages> <year> 1984. </year>
Reference-contexts: Combining these constraints, we can infer that v must be a floating-point number (i.e., v (Int [ Float) " :Int = Float). Set constraints have been used in program analysis and type inference algorithms for functional languages [1, 2, 10, 12, 14, 17] 2 , logic programming languages <ref> [8, 11] </ref>, and imperative languages [9]. Solving a system of set constraints is central to each of these program analysis algorithms. Systems of set constraints can also define tree automata; in this case, the sets of terms are the language of a finite-state machine.
Reference: [12] <author> P. Mishra and U. Reddy. </author> <title> Declaration-free type checking. </title> <booktitle> In Proceedings of the Twelfth Annual ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 7-21, </pages> <year> 1985. </year>
Reference-contexts: Combining these constraints, we can infer that v must be a floating-point number (i.e., v (Int [ Float) " :Int = Float). Set constraints have been used in program analysis and type inference algorithms for functional languages <ref> [1, 2, 10, 12, 14, 17] </ref> 2 , logic programming languages [8, 11], and imperative languages [9]. Solving a system of set constraints is central to each of these program analysis algorithms. <p> Presumably, 2 this is why equations of this form (ff = E (ff) with no negations) have been studied almost exclusively <ref> [1, 2, 8, 12] </ref>. However, when set complement is added to the language, even equations of this restricted form might not have solutions. For example, the equation ff = :ff has no solutions. <p> These algorithms were developed either for an application in program analysis <ref> [7, 10, 12, 14] </ref> or in work on finite automata [3, 6, 13]. <p> These algorithms were developed either for an application in program analysis [7, 10, 12, 14] or in work on finite automata [3, 6, 13]. Mishra and Reddy <ref> [12] </ref> give a method for solving constraints between expressions without complement where all set unions are discriminative (i.e., if c (: : :) [ d (: : :) is an expression, then c 6= d). <p> A Appendix This appendix includes proofs omitted from the body of the paper. A.1 Solved Form Systems The following proof of Lemma 5.4 is based on techniques in <ref> [12] </ref>. Proof: The function is monotonic in all set expression operations except for set complement. Let be any substitution for the variables V fff 1 ; : : :; ff n g. By assumption, the only negations appear on free variables.
Reference: [13] <author> M. O. Rabin. </author> <title> Decidability of second-order theories and automata on infinite trees. </title> <journal> Transactions of the American Mathematical Society, </journal> (141):1-35, 1969. 
Reference-contexts: These algorithms were developed either for an application in program analysis [7, 10, 12, 14] or in work on finite automata <ref> [3, 6, 13] </ref>. Mishra and Reddy [12] give a method for solving constraints between expressions without complement where all set unions are discriminative (i.e., if c (: : :) [ d (: : :) is an expression, then c 6= d).
Reference: [14] <author> J. C. Reynolds. </author> <title> Automatic Computation of Data Set Definitions, </title> <booktitle> pages 456-461. Information Processing 68. </booktitle> <publisher> North-Holland, </publisher> <year> 1969. </year>
Reference-contexts: Combining these constraints, we can infer that v must be a floating-point number (i.e., v (Int [ Float) " :Int = Float). Set constraints have been used in program analysis and type inference algorithms for functional languages <ref> [1, 2, 10, 12, 14, 17] </ref> 2 , logic programming languages [8, 11], and imperative languages [9]. Solving a system of set constraints is central to each of these program analysis algorithms. <p> These algorithms were developed either for an application in program analysis <ref> [7, 10, 12, 14] </ref> or in work on finite automata [3, 6, 13]. <p> For every constructor f, a family of projection functions f 1 ; : : :; f a (f) is defined as follows: (f i (E); ) = fx i jf (x 1 ; : : : ; x a (f) ) 2 (E; )g Reynolds <ref> [14] </ref> and Jones and Muchnick [10] present algorithms for solving set constraints with projection functions, but without union or complement operations. In work on finite automata, Brzozowski and Leiss present an algorithm for solving equations between regular languages with free variables [3].
Reference: [15] <author> H. Seidl. </author> <title> Deciding equivalence of finite tree automata. </title> <journal> SIAM Journal of Computing, </journal> <volume> 19(3) </volume> <pages> 424-437, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The exact complexity remains an open problem. Theorem 10.1 The consistency problem for systems of set constraints is EXPTIME-hard. Proof: [sketch] In <ref> [15] </ref> it is shown that determining whether two finite tree automata accept the same language is complete for EXPTIME. Finite tree automata are equivalent to solved-form systems of equations with no free variables.
Reference: [16] <author> G. Slutzki. </author> <title> Alternating tree automata. </title> <journal> Theoretical Computer Science, </journal> <volume> 41 </volume> <pages> 305-318, </pages> <year> 1985. </year>
Reference-contexts: Proof: In appendix A.1. 2 Solved form systems are essentially alternating tree automata <ref> [16] </ref>. Each variable on the left-hand side of an equation corresponds to an automaton state; the set operations of intersection and union correspond to the tree automata transitions of universal branching and existential branching respectively. Solved-form systems have one feature not found in tree automata: the possibility of unconstrained variables.
Reference: [17] <author> J. Young and P. O'Keefe. </author> <title> Experience with a type evaluator. </title> <editor> In D. Bjtrner, A. P. Ershov, and N. D. Jones, editors, </editor> <booktitle> Partial Evaluation and Mixed Computation, </booktitle> <pages> pages 573-581. </pages> <publisher> North-Holland, </publisher> <year> 1988. </year> <month> 12 </month>
Reference-contexts: Combining these constraints, we can infer that v must be a floating-point number (i.e., v (Int [ Float) " :Int = Float). Set constraints have been used in program analysis and type inference algorithms for functional languages <ref> [1, 2, 10, 12, 14, 17] </ref> 2 , logic programming languages [8, 11], and imperative languages [9]. Solving a system of set constraints is central to each of these program analysis algorithms. <p> In this paper we present an algorithm for solving systems of set constraints; this algorithm produces a finite representation of all the solutions of a system 2 In <ref> [17] </ref>, an ad hoc formalism equivalent to set constraints is used. 1 of set constraints. We show that the complexity of deciding whether or not a system of set constraints is consistent (i.e., has a solution) is in NEXPTIME and is EXPTIME-hard. The exact complexity of the problem remains open.
References-found: 17

