URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1996/tr-96-042.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1996.html
Root-URL: http://www.icsi.berkeley.edu
Title: Efficient Oblivious Parallel Sorting on the MasPar MP-1  
Author: Klaus Brockmann Rolf Wanka 
Note: Supported by DFG-Sonderforschungsbereich 376 "Massive Parallelitat". Accepted for presentation on the 30th Hawaii International Conference on System Sciences (HICSS), 1997.  
Address: I 1947 Center St. Suite 600 Berkeley, California 94704-1198  33095 Paderborn, Germany,  
Affiliation: INTERNATIONAL COMPUTER SCIENCE INSTITUTE  Heinz Nixdorf Institute, Paderborn University,  
Pubnum: TR-96-042  
Email: email: brockm@hni.uni-paderborn.de.  
Phone: (510) 643-9153 FAX (510) 643-7684  
Abstract: We address the problem of sorting a large number N of keys on a MasPar MP-1 parallel SIMD machine of moderate size P where the processing elements (PEs) are interconnected as a toroidal mesh and have 16KB local storage each. We present a comparative study of implementations of the following deterministic oblivious sorting methods: Bitonic Sort, Odd-Even Merge Sort, and FastSort. We successfully use the guarded split&merge operation introduced by Rub. The experiments and investigations in a simple, parameterized, analytical model show that, with this operation, from a certain ratio N=P upwards both Odd-Even Merge Sort and FastSort become faster on average than the up to the present fastest, sophisticated implementation of Bitonic Sort by Prins. Though it is not as efficient as Odd-Even Merge Sort, FastSort is to our knowledge the first method specially tailored to the mesh architecture that can be, when implemented, competitive on average with a mesh-adaptation of Bitonic Sort for large N=P . z International Computer Science Institute 1947 Center Street, Berkeley, CA 94704-1198, USA, email: wanka@icsi.berkeley.edu. Supported by DFG Leibniz Grant Me 872/6-1 and by EU ESPRIT Long Term Research Project 20244 (ALCOM-IT). On leave from Dept. of Mathematics and Computer Science, Pader-born University, 33095 Paderborn, Germany, email: wanka@uni-paderborn.de. 
Abstract-found: 1
Intro-found: 1
Reference: [Bat68] <author> Kenneth E. Batcher. </author> <title> Sorting networks and their applications. </title> <booktitle> In AFIPS Conference Proc. </booktitle> <volume> 32, </volume> <pages> pages 307-314, </pages> <year> 1968. </year> <month> 14 </month>
Reference-contexts: Comparative studies for MIMD machines can be found in [DCSM96, DGL + 94, WW96]. For N=P large, Samplesort [FM70] results in the fastest implementations. Prins [Pri90] has implemented Batcher's Bitonic Sort <ref> [Bat68] </ref> on a MasPar MP-1. This is the up to the present fastest known implementation of a deterministic oblivious sorting algorithm on such a machine. The other famous sorting circuit due to Batcher, Odd-Even Merge Sort [Bat68], has not been implemented so far. <p> Prins [Pri90] has implemented Batcher's Bitonic Sort <ref> [Bat68] </ref> on a MasPar MP-1. This is the up to the present fastest known implementation of a deterministic oblivious sorting algorithm on such a machine. The other famous sorting circuit due to Batcher, Odd-Even Merge Sort [Bat68], has not been implemented so far. Hightower et al. [HPR92] have 1 introduced a randomized method they call B-Flashsort that is related to Samplesort. <p> with no additonal copies of keys and which consists of three phases: a binary splitter search to determine which keys to exchange, exchanging the keys and storing them in-place in reverse order (such that the resulting sequences become bitonic), and finally using a sequential implementation of the Bitonic Merging network <ref> [Bat68] </ref> to locally merge the bitonic sequences to sorted ones. This would increase the time complexity of the sorting algorithms by a factor of log n but also would be a useful modification if there was no more local memory available in addition to the input sequences. Routing. <p> The algorithm was introduced as a sorting circuit by Batcher in 1968 <ref> [Bat68] </ref> (see Figure 2 (a) for the circuit with P = 8). According to the depth of that circuit, we get BS (P ) = 1 2 log P (log P + 1) as the number of S&M operations. 6 (a) - - - - - - length 8. <p> ffiffi ffiffi ffiffi ffi * ** ** ** ** ** ** ** ** * ffiffi measuredmeasured predictedpredicted ........................................... of the sophisticated implementation of Bitonic Sort by Prins [Pri90]. 4.2 Odd-Even Merge Sort Odd-Even Merge Sort (OEMS) was introduced as a sorting circuit in the above-mentioned paper by Batcher in 1968 <ref> [Bat68] </ref> (see Figure 2 (b) for the sorting circuit with P = 8).
Reference: [BLM + 91] <author> Guy E. Blelloch, Charles E. Leiserson, Bruce M. Maggs, C. Greg Plaxton, Stephen J. Smith, and Marco Zagha. </author> <title> A comparison of sorting algorithms for the Connection Machine CM-2. </title> <booktitle> In Proc. 3rd ACM Symposium on Parallel Algorithms and Architectures (SPAA), </booktitle> <pages> pages 3-16, </pages> <year> 1991. </year>
Reference-contexts: Note that we still call an algorithm oblivious when it replaces the conditional exchanges with split&merge operations. The split&merge operations are fixed, but their execution time may vary. Previous work. Blelloch et al. <ref> [BLM + 91] </ref> present a comparative study of a variety of implementations of parallel sorting algorithms on a Thinking Machines CM-2 consisting of 65536 one-bit PEs. Comparative studies for MIMD machines can be found in [DCSM96, DGL + 94, WW96]. For N=P large, Samplesort [FM70] results in the fastest implementations.
Reference: [Bro95] <author> Klaus Brockmann. </author> <title> Implementierung und Analyse paralleler Sortieralgorithmen auf einer MasPar MP-1 und ihre Einbindung in eine Anwendungsbibliothek. </title> <institution> Diplomarbeit, Paderborn University, </institution> <year> 1995. </year> <note> In German. </note>
Reference-contexts: Also it might be interesting to evaluate the performance of our implementations on the MasPar MP-2. In the first author's Diplomarbeit <ref> [Bro95] </ref>, implementations of further sorting circuits are treated: Shortperiodic methods, Shearsort and a combination of the Bitonic Merging network and Shearsort. This thesis as well as the source code of the algorithms can be downloaded from the WWW page http://wwwhni.uni-paderborn.de/cim/mitarb/brockm/ .
Reference: [CK90] <author> Bogdan S. Chlebus and Maciej Kukawka. </author> <title> A guide to sorting on the mesh-connected processor array. </title> <journal> Computers and Artificial Intelligence, </journal> <volume> 9 </volume> <pages> 599-610, </pages> <year> 1990. </year>
Reference-contexts: Rub proves [Rub95] for Odd-Even Merge Sort the phenomenon that, on average, nothing has to be exchanged in most of the split&merge operations, which leads to guarded split&merge operations. An overview of parallel mesh-sorting algorithms is given by Chlebus and Kukawka <ref> [CK90] </ref>. Unfortunately, implementations of these algorithms on meshes are slower than adaptations of Bitonic Sort. Contribution of this paper.
Reference: [DCSM96] <author> Andrea C. Dusseau, David E. Culler, Klaus E. Schauser, and Richard P. Martin. </author> <title> Fast parallel sorting under LogP: Experience with the CM-5. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 7 </volume> <pages> 791-805, </pages> <year> 1996. </year> <title> Preliminary version: Fast Parallel Sorting under LogP: From theory to practice. </title> <booktitle> In Portability and Performance for Parallel Processing, </booktitle> <pages> pp. 71-98, </pages> <year> 1994. </year>
Reference-contexts: Previous work. Blelloch et al. [BLM + 91] present a comparative study of a variety of implementations of parallel sorting algorithms on a Thinking Machines CM-2 consisting of 65536 one-bit PEs. Comparative studies for MIMD machines can be found in <ref> [DCSM96, DGL + 94, WW96] </ref>. For N=P large, Samplesort [FM70] results in the fastest implementations. Prins [Pri90] has implemented Batcher's Bitonic Sort [Bat68] on a MasPar MP-1. This is the up to the present fastest known implementation of a deterministic oblivious sorting algorithm on such a machine.
Reference: [DGL + 94] <author> Ralf Diekmann, Joern Gehring, Reinhard Luling, Burkhard Monien, Markus Nubel, and Rolf Wanka. </author> <title> Sorting large data sets on a massively parallel system. </title> <booktitle> In Proc. 6th IEEE Symposium on Parallel and Distributed Processing (SPDP), </booktitle> <pages> pages 2-9, </pages> <year> 1994. </year>
Reference-contexts: Previous work. Blelloch et al. [BLM + 91] present a comparative study of a variety of implementations of parallel sorting algorithms on a Thinking Machines CM-2 consisting of 65536 one-bit PEs. Comparative studies for MIMD machines can be found in <ref> [DCSM96, DGL + 94, WW96] </ref>. For N=P large, Samplesort [FM70] results in the fastest implementations. Prins [Pri90] has implemented Batcher's Bitonic Sort [Bat68] on a MasPar MP-1. This is the up to the present fastest known implementation of a deterministic oblivious sorting algorithm on such a machine.
Reference: [FM70] <author> W. D. Frazer and A. C. McKellar. Samplesort: </author> <title> A sampling approach to minimal storage tree sorting. </title> <journal> Journal of the ACM, </journal> <volume> 17 </volume> <pages> 496-507, </pages> <year> 1970. </year>
Reference-contexts: Previous work. Blelloch et al. [BLM + 91] present a comparative study of a variety of implementations of parallel sorting algorithms on a Thinking Machines CM-2 consisting of 65536 one-bit PEs. Comparative studies for MIMD machines can be found in [DCSM96, DGL + 94, WW96]. For N=P large, Samplesort <ref> [FM70] </ref> results in the fastest implementations. Prins [Pri90] has implemented Batcher's Bitonic Sort [Bat68] on a MasPar MP-1. This is the up to the present fastest known implementation of a deterministic oblivious sorting algorithm on such a machine.
Reference: [HPR92] <author> William L. Hightower, Jan F. Prins, and John H. Reif. </author> <title> Implementation of randomized sorting on large parallel machines. </title> <booktitle> In Proc. 4th ACM Symposium on Parallel Algorithms and Architectures (SPAA), </booktitle> <pages> pages 158-167, </pages> <year> 1992. </year>
Reference-contexts: This is the up to the present fastest known implementation of a deterministic oblivious sorting algorithm on such a machine. The other famous sorting circuit due to Batcher, Odd-Even Merge Sort [Bat68], has not been implemented so far. Hightower et al. <ref> [HPR92] </ref> have 1 introduced a randomized method they call B-Flashsort that is related to Samplesort. Here it can happen that some PEs eventually hold more than N=P keys so that the restriction of a small local memory leads to load-balancing phases during the sorting.
Reference: [Knu73] <author> Donald E. Knuth. </author> <title> The Art of Computer Programming, Volume 3: Sorting and Searching. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1973. </year>
Reference-contexts: 1 Introduction The problem. Sorting is one of the most investigated problems in computer science. In the area of parallel computing, sorting is also a classical topic. Its roots can be traced back to the Fifties <ref> [Knu73, p. 244] </ref>. Richards' bibliography [Ric86] covers the extensive literature until 1986. In many parallel algorithms, parallel sorting is one of the subroutines that determine the overall performance. <p> In this case, there is a need for efficient in-place sorting algorithms, i. e., algorithms that require additional storage per PE of size O (1) only. Appropriate algorithms working reasonably well in this case are those that are based on sorting circuits (comparator networks <ref> [Knu73] </ref>). Here, it is known ahead of time and independent of the sequence of inputs which pairs of PEs perform a conditional exchange during each time step. Such sorting algorithms are called oblivious . <p> Here, it is known ahead of time and independent of the sequence of inputs which pairs of PEs perform a conditional exchange during each time step. Such sorting algorithms are called oblivious . Because every PE stores more than one key, the comparators can be replaced by split&merge operations <ref> [Knu73, p. 241] </ref> (see Section 3). Note that we still call an algorithm oblivious when it replaces the conditional exchanges with split&merge operations. The split&merge operations are fixed, but their execution time may vary. Previous work. <p> This is the reason why Odd-Even Merge Sort is faster (for the considered number of keys) than other methods which are theoretically optimal, e. g., heapsort or mergesort <ref> [Knu73] </ref>. Because we have a SIMD machine, an implementation of quicksort is not reasonable, because all PEs have to wait for completing the slowest recursive call before they can resume. The number of comparators of Odd-Even Merge Sort is 1 4 n log n (log n 1) + n 1.
Reference: [Lei92] <author> F. Thomson Leighton. </author> <title> Introduction to Parallel Algorithms and Architectures: Arrays, Trees, Hypercubes. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference-contexts: E. g., it is used in applications like the computation of convex hulls, parallel data bases, and certain image-processing methods, to name a few. Many parallel sorting circuits and other sorting methods on networks are described in Leighton's book <ref> [Lei92] </ref>. One type of parallel computer is the SIMD (Single Instruction, Multiple Data) machine, in contrast to the MIMD (Multiple Instruction, Multiple Data) type of machines.
Reference: [Mas93a] <institution> MasPar Computer Corporation, Sunnyvale, California. </institution> <note> MasPar Parallel Application Language (MPL) Reference Manual, </note> <month> May </month> <year> 1993. </year>
Reference-contexts: In such a case, the execution of the S&M operation can be avoided. We achieve this by inserting an additional comparison after receiving the first key and applying a plural if-statement <ref> [Mas93a] </ref> on the result of the comparison to determine whether the condition mentioned is true or not. We say that the S&M operation is guarded . <p> These routing phases are implemented by using the Global 5 Router and an appropriate library function (namely, ss rsend) of the MasPar Programming Language (MPL) <ref> [Mas93a, Mas93b] </ref>. The runtime of this function is on average: t Routing (p) = (sf R (p 1:6 + 11:4) + 22:1) [s]; where p is the packet size in bytes and sf R the sequencing factor of Router communication.
Reference: [Mas93b] <institution> MasPar Computer Corporation, Sunnyvale, California. MasPar Parallel Application Language (MPL) User Guide, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: Thus, comparisons and memory movements are done by register operations and load/store instructions. Additionally, the algorithms make use of some instructions for loop control and address calculations. Execution times of all these instructions are given in detail in the original MasPar documentation <ref> [Mas93b] </ref>. Thus, and for brevity's sake, we will restrict ourselves to giving only the equations for the communication times of our 3 implementations. <p> These routing phases are implemented by using the Global 5 Router and an appropriate library function (namely, ss rsend) of the MasPar Programming Language (MPL) <ref> [Mas93a, Mas93b] </ref>. The runtime of this function is on average: t Routing (p) = (sf R (p 1:6 + 11:4) + 22:1) [s]; where p is the packet size in bytes and sf R the sequencing factor of Router communication.
Reference: [Pri90] <author> Jan F. Prins. </author> <title> Efficient bitonic sorting of large arrays on the MasPar MP-1. </title> <booktitle> In Proc. 3rd Symposium on Frontiers of Massively Parallel Processing, </booktitle> <pages> pages 59-64, </pages> <year> 1990. </year> <note> Expanded version: Technical Report TR91-041, </note> <institution> University of North Carolina at Chapel Hill, Dept. of Computer Science, </institution> <year> 1991. </year> <month> 15 </month>
Reference-contexts: Comparative studies for MIMD machines can be found in [DCSM96, DGL + 94, WW96]. For N=P large, Samplesort [FM70] results in the fastest implementations. Prins <ref> [Pri90] </ref> has implemented Batcher's Bitonic Sort [Bat68] on a MasPar MP-1. This is the up to the present fastest known implementation of a deterministic oblivious sorting algorithm on such a machine. The other famous sorting circuit due to Batcher, Odd-Even Merge Sort [Bat68], has not been implemented so far. <p> These algorithms are oblivious. Note that they do not rely on the representation of the keys (like, e. g., Radixsort). Guarded split&merge operations are used. Because Prins' source code is available, we can compare our implementations to the implementations done by Prins <ref> [Pri90] </ref> on the same machine. It turns out that, for certain values of N=P , Odd-Even Merge Sort and FastSort become faster on average than Prins' implementation of Bitonic Sort. <p> . .... . ... ... . .... . ... ... 22 22 22 22 22 22 22 2 ffiffi ffiffi ffiffi ffiffi ffiffi ffiffi ffiffi ffiffi ffi * ** ** ** ** ** ** ** ** * ffiffi measuredmeasured predictedpredicted ........................................... of the sophisticated implementation of Bitonic Sort by Prins <ref> [Pri90] </ref>. 4.2 Odd-Even Merge Sort Odd-Even Merge Sort (OEMS) was introduced as a sorting circuit in the above-mentioned paper by Batcher in 1968 [Bat68] (see Figure 2 (b) for the sorting circuit with P = 8). <p> In the experiments, it is faster than our implementation of Bitonic Sort, when N=P is larger than eight. It is even faster than the sophisticated implementation of Bitonic Sort by Prins <ref> [Pri90] </ref>, when N=P gets large enough (break-even point: N=P 100). 4.3 FastSort FastSort (FS) is introduced in [Wan94]. It is a recursive algorithm which sorts meshes of arbitrary dimension according to the snake-like indexing scheme.
Reference: [Ric86] <author> Dana Richards. </author> <title> Parallel sorting A bibliography. </title> <journal> SIGACT News, </journal> <volume> 18(1) </volume> <pages> 28-48, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction The problem. Sorting is one of the most investigated problems in computer science. In the area of parallel computing, sorting is also a classical topic. Its roots can be traced back to the Fifties [Knu73, p. 244]. Richards' bibliography <ref> [Ric86] </ref> covers the extensive literature until 1986. In many parallel algorithms, parallel sorting is one of the subroutines that determine the overall performance. E. g., it is used in applications like the computation of convex hulls, parallel data bases, and certain image-processing methods, to name a few.
Reference: [Rub95] <author> Christine Rub. </author> <title> On the average running time of odd-even merge sort. </title> <booktitle> In Proc. 12th Symposium on Theoretical Aspects of Computer Science (STACS), </booktitle> <pages> pages 491-502, </pages> <year> 1995. </year>
Reference-contexts: In a recent paper, Zheng et al. [ZCZ96] report on an implementation of an in-place sorting scheme dubbed ZZ-sort. Rub proves <ref> [Rub95] </ref> for Odd-Even Merge Sort the phenomenon that, on average, nothing has to be exchanged in most of the split&merge operations, which leads to guarded split&merge operations. An overview of parallel mesh-sorting algorithms is given by Chlebus and Kukawka [CK90]. <p> Thus, OEMS (P ) = 1 2 log P (log P + 1) in the worst case. Nevertheless, this algorithm was widely passed over in the context of parallel sorting on massively parallel processor networks because its communication structure is not as regular as that of Bitonic Sort. In <ref> [Rub95] </ref>, Rub investigates the average behavior of Odd-Even Merge Sort for large values of N=P . She proves the phenomenon that nothing happens during most of the S&M operations, i. e., the state of the network remains unchanged.
Reference: [Wan94] <author> Rolf Wanka. Paralleles Sortieren auf mehrdimensionalen Gittern. Ph. D. </author> <type> Thesis, </type> <institution> Paderborn University, </institution> <year> 1994. </year> <note> In German. </note>
Reference-contexts: In the experiments, it is faster than our implementation of Bitonic Sort, when N=P is larger than eight. It is even faster than the sophisticated implementation of Bitonic Sort by Prins [Pri90], when N=P gets large enough (break-even point: N=P 100). 4.3 FastSort FastSort (FS) is introduced in <ref> [Wan94] </ref>. It is a recursive algorithm which sorts meshes of arbitrary dimension according to the snake-like indexing scheme. The algorithm is based on Odd-Even Transposition Sort and makes use of some additional routing phases during which the contents of the mesh is rearranged in a specific manner. <p> Now we show how two sorted sub-meshes can be merged. A sequence (a 0 ; : : : ; a k1 ) is called 2-ordered if a i a i+2 , for all 0 i &lt; k 2. It is shown in <ref> [Wan94] </ref> that if a mesh is 2-ordered according to the snake-like indexing scheme, it suffices to apply a descending run of Odd-Even Transposition Sort on the arrays in all dimensions. Thus, routing the snakes of the two sub-meshes according to the shu*e permutation establishes the desired state (see Figure 6). <p> Thus, routing the snakes of the two sub-meshes according to the shu*e permutation establishes the desired state (see Figure 6). It is shown in <ref> [Wan94] </ref> that the two sorted submeshes b b r r b b r r mesh is 2-ordered b b r r b b r r b r b r b r b r b r b r b r b r B B J J @ @ Z Z b b
Reference: [WW96] <author> Alf Wachsmann and Rolf Wanka. </author> <title> Sorting on a massively parallel system using a library of basic primitives: Modeling and experimental results. </title> <type> Technical Report TR-RSFB-96-011, </type> <institution> Paderborn University, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: Previous work. Blelloch et al. [BLM + 91] present a comparative study of a variety of implementations of parallel sorting algorithms on a Thinking Machines CM-2 consisting of 65536 one-bit PEs. Comparative studies for MIMD machines can be found in <ref> [DCSM96, DGL + 94, WW96] </ref>. For N=P large, Samplesort [FM70] results in the fastest implementations. Prins [Pri90] has implemented Batcher's Bitonic Sort [Bat68] on a MasPar MP-1. This is the up to the present fastest known implementation of a deterministic oblivious sorting algorithm on such a machine. <p> Our implementation shows that Odd-Even Merge Sort with guarded split&merge operations results in very good runtimes on a SIMD machine, as well as it was shown on a MIMD machine <ref> [WW96] </ref>. Fastsort is an sorting algorithm for d-dimensional meshes. There is a trade-off between the number of split&merge operations (depending on d) and the time that is spent by routing keys.
Reference: [ZCZ96] <author> S.Q. Zheng, B. Calidas, and Yanjung Zhang. </author> <title> Efficient in-place sorting algorithms using feasible parallel machine models. </title> <booktitle> In Proc. 2nd International Symposium on Parallel Architectures, Algorithms, and Networks (I-SPAN), </booktitle> <pages> pages 15-21, </pages> <year> 1996. </year> <month> 16 </month>
Reference-contexts: Here it can happen that some PEs eventually hold more than N=P keys so that the restriction of a small local memory leads to load-balancing phases during the sorting. In a recent paper, Zheng et al. <ref> [ZCZ96] </ref> report on an implementation of an in-place sorting scheme dubbed ZZ-sort. Rub proves [Rub95] for Odd-Even Merge Sort the phenomenon that, on average, nothing has to be exchanged in most of the split&merge operations, which leads to guarded split&merge operations.
References-found: 18

