URL: http://www.cs.wustl.edu/cs/techreports/1995/wucs-95-17.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: 
Title: Formal Specification of a Dynamically Configurable Distributed System  
Author: Ram Sethuraman and Kenneth J. Goldman 
Address: Campus Box 1045 One Brookings Drive Saint Louis, MO 63130-4899  
Affiliation: Department of Computer Science Washington University  
Date: July 1995 (revised November 3, 1995)  
Pubnum: WUCS-95-17  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Kenneth Birman, Andre Schiper, and Pat Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The protocols can piggyback sequencing information in every message. The receiving protocols could use this information to decide whether to accept the message, or to buffer it till all the messages preceding it in the causal sequence are received. Causal delivery of messages is discussed in <ref> [1, 14] </ref>.
Reference: [2] <author> Jerome R. Cox, Jr., Mike Gaddis, and Jonathan S. Turner. </author> <title> Project Zeus: Design of a broadband network and its application on a university campus. </title> <journal> IEEE Network, </journal> <pages> pages 20-30, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: An undergraduate course in distributed application paradigms has been taught using Playground as the programming environment. Also, Playground has been used to implement a video-conferencing application on top of an ATM network <ref> [2] </ref> built at Washington University. The system is based on a new high-level approach to interprocess communication. Functional components of a concurrent system are written as encapsulated application programs that act upon local data structures, some of which may be published for external use.
Reference: [3] <author> Kenneth J. Goldman et al. </author> <note> http://www.cs.wustl.edu/cs/playground. 26 </note>
Reference-contexts: For the purposes of this paper, the Playground programming model is taken as "given." Information on related programming models and details about the Programmers' Playground goals, design, implementation may be found elsewhere <ref> [3, 5] </ref>. Playground provides a model of interprocess communication in which each application in a system has a presentation that consists of data structures that may be externally observed and/or manipulated by its environment.
Reference: [4] <author> Kenneth J. Goldman. </author> <title> Data interfaces as support for module migration. </title> <booktitle> In Proceedings of the Second International Workshop on Configurable Distributed Systems, </booktitle> <month> March </month> <year> 1994. </year> <note> Position paper, as invited panelist. </note>
Reference-contexts: The current version of Playground supports applications written in C++ on top of the Solaris operating system. Communication among modules is dynamically configured by end-users using graphics tools. Physical migration <ref> [4, 15] </ref> and end-user construction of direct-manipulation user interfaces for distributed applications [11] are also supported. An undergraduate course in distributed application paradigms has been taught using Playground as the programming environment.
Reference: [5] <author> Kenneth J. Goldman, Bala Swaminathan, Michael D. Anderson, T. Paul McCartney, and Ramachandran Sethuraman. </author> <title> The Programmers' Playground: I/O abstraction for user-configurable distributed applications. </title> <journal> IEEE Transactions on Software Engineering. </journal> <note> to appear. </note>
Reference-contexts: 1 Introduction The Programmers' Playground <ref> [5] </ref> is a software library and run-time system designed to support end-user construction of distributed multimedia applications. Design goals include the separation of communication from computation, dynamic reconfiguration, and the uniform treatment of discrete and continuous data types. <p> For the purposes of this paper, the Playground programming model is taken as "given." Information on related programming models and details about the Programmers' Playground goals, design, implementation may be found elsewhere <ref> [3, 5] </ref>. Playground provides a model of interprocess communication in which each application in a system has a presentation that consists of data structures that may be externally observed and/or manipulated by its environment.
Reference: [6] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, New Jersey, </address> <year> 1985. </year>
Reference-contexts: In addition, the model can be used for carrying out complexity analysis and for proving impossibility results. The I/O automaton model is significantly different from CCS [12] and CSP <ref> [6] </ref> in that input and output actions in the I/O automaton model are distinguished, and an I/O automaton cannot block an input action from occurring. In that sense, I/O automata are similar to I/O-systems [7, 8, 9].
Reference: [7] <author> Bengt Jonsson. </author> <title> A model and proof system for asynchronous networks. </title> <booktitle> In Proceedings of the 4th ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1985. </year>
Reference-contexts: The I/O automaton model is significantly different from CCS [12] and CSP [6] in that input and output actions in the I/O automaton model are distinguished, and an I/O automaton cannot block an input action from occurring. In that sense, I/O automata are similar to I/O-systems <ref> [7, 8, 9] </ref>. The following introduction to the model is adapted from [10], which explains the model in more detail, presents examples, and includes comparisons to other models.
Reference: [8] <author> Bengt Jonsson. </author> <title> Compositional specification and verification of distributed systems. </title> <type> Technical Report SICS/R-90/90010, </type> <institution> Swedish Institute of Computer Science, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: The I/O automaton model is significantly different from CCS [12] and CSP [6] in that input and output actions in the I/O automaton model are distinguished, and an I/O automaton cannot block an input action from occurring. In that sense, I/O automata are similar to I/O-systems <ref> [7, 8, 9] </ref>. The following introduction to the model is adapted from [10], which explains the model in more detail, presents examples, and includes comparisons to other models.
Reference: [9] <author> Bengt Jonsson. </author> <title> Simulations between specification of distributed systems. </title> <booktitle> In Proceedings of the 2nd International Conference on Concurrency Theory, </booktitle> <volume> LNCS 527, </volume> <pages> pages 346-360. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: The I/O automaton model is significantly different from CCS [12] and CSP [6] in that input and output actions in the I/O automaton model are distinguished, and an I/O automaton cannot block an input action from occurring. In that sense, I/O automata are similar to I/O-systems <ref> [7, 8, 9] </ref>. The following introduction to the model is adapted from [10], which explains the model in more detail, presents examples, and includes comparisons to other models.
Reference: [10] <author> Nancy A. Lynch and Mark R. Tuttle. </author> <title> An introduction to Input/Output Automata. </title> <journal> CWI-Quarterly, </journal> <volume> 2(3), </volume> <year> 1989. </year>
Reference-contexts: Relationships among these applications are specified by logical connections among their published data structures. Whenever an application updates published data, communication takes place implicitly according to the configuration of logical connections. The Playground programming model is based on ideas from the formal I/O automaton model of Lynch and Tuttle <ref> [10] </ref>, a natural model of distributed systems that fl This research was supported in part by the National Science Foundation under grant CCR-94-12711. 1 provides compositionality properties and a clear separation of input and output actions. <p> The paper concludes with a discussion of the utility of this formal framework for the study of additional communication and synchronization features that are envisioned for the Playground programming model and run-time system. 2 The I/O Automaton Model This section provides a brief overview of the I/O automaton model <ref> [10] </ref>. The model is both the basis for the Playground programming model and the formal framework we will use to describe the Playground semantics and implementation. <p> In that sense, I/O automata are similar to I/O-systems [7, 8, 9]. The following introduction to the model is adapted from <ref> [10] </ref>, which explains the model in more detail, presents examples, and includes comparisons to other models. Readers already familiar with the I/O automaton model may skip this section without loss of continuity. 2.1 I/O Automata I/O automata are best suited for modeling systems in which the components operate asynchronously. <p> When an execution of a system is projected onto any component, the result is an execution of that component. The same is true for schedules and behaviors. Other important compositionality results for I/O automata may be found in <ref> [10] </ref>. 2.3 Fairness We may think of each class in the partition of locally-controlled actions of an automaton as a separate "control thread" that is responsible for the actions in that class. <p> Informally, a module preserves a property P iff the module is not the first to violate P: as long as the environment only provides inputs such that the cumulative behavior satisfies P, the module will only perform outputs such that the cumulative behavior satisfies P. In <ref> [10] </ref>, it is shown that if each component of a composition preserves a property, then the composition preserves the property.
Reference: [11] <author> T. Paul McCartney and Kenneth Goldman. </author> <title> Visual specification of interprocess and intrapro-cess communication. </title> <booktitle> In Proceedings of the 10th International Symposium on Visual Languages, </booktitle> <pages> pages 80-87, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: The current version of Playground supports applications written in C++ on top of the Solaris operating system. Communication among modules is dynamically configured by end-users using graphics tools. Physical migration [4, 15] and end-user construction of direct-manipulation user interfaces for distributed applications <ref> [11] </ref> are also supported. An undergraduate course in distributed application paradigms has been taught using Playground as the programming environment. Also, Playground has been used to implement a video-conferencing application on top of an ATM network [2] built at Washington University.
Reference: [12] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: In addition, the model can be used for carrying out complexity analysis and for proving impossibility results. The I/O automaton model is significantly different from CCS <ref> [12] </ref> and CSP [6] in that input and output actions in the I/O automaton model are distinguished, and an I/O automaton cannot block an input action from occurring. In that sense, I/O automata are similar to I/O-systems [7, 8, 9].
Reference: [13] <author> Gruia-Catalin Roman and Kenneth C. Cox. </author> <title> A declarative approach to visualizing concurrent computations. </title> <journal> IEEE Computer, </journal> <volume> 22(10) </volume> <pages> 25-36, </pages> <month> October </month> <year> 1989. </year>
Reference: [14] <author> Bala Swaminathan and Kenneth J. Goldman. </author> <title> An incremental distributed algorithm for computing biconnected components. </title> <booktitle> In Proceedings of the 8th International Workshop on Distributed Algorithms, WDAG '94. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The protocols can piggyback sequencing information in every message. The receiving protocols could use this information to decide whether to accept the message, or to buffer it till all the messages preceding it in the causal sequence are received. Causal delivery of messages is discussed in <ref> [1, 14] </ref>.

References-found: 14

