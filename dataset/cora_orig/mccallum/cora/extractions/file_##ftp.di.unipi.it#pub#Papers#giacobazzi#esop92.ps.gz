URL: file://ftp.di.unipi.it/pub/Papers/giacobazzi/esop92.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: fgiaco,riccig@di.unipi.it  
Title: Detecting Determinate Computations by Bottom-up Abstract Interpretation  
Author: Roberto Giacobazzi Laura Ricci 
Address: Corso Italia 40, 56125 Pisa  
Affiliation: Dipartimento di Informatica Universita di Pisa  
Abstract: One of the most interesting characteristics of logic programs is the ability of expressing nondeterminism in an elegant and concise way. On the other hand, implementation of nondeterminism poses serious problems both in the sequential and in the concurrent case. If determinate computations are detected through a static analysis, a noticeable reduction of the execution time may be obtained. This work describes a static analysis to detect determinate computations. The analysis does not require the knowledge of the activating modes of the predicate and it derives determinacies which may be inferred from the success set of the program.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A General Framework for Semantics-based Bottom-up Abstract Interpretation of Logic Programs. </title> <type> Technical Report TR 12/91, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1991. </year> <note> To appear in ACM Transactions on Programming Languages and Systems. </note>
Reference-contexts: The definition of the analysis requires the investigation of the relation between the input values of a predicate and those returned by the refutation of the fl To appear in European Conference on Programming ESOP'92 predicate itself. Some recent proposals <ref> [1, 6, 8, 12] </ref> characterize such a relation through the notion of dependence. <p> We assume the reader familiar with the basic notions of abstract interpretation as defined in [3]. In the following an abstract interpretation supporting our analysis for definite logic programs is developed according to a bottom-up technique <ref> [1] </ref> based on an abstraction of the declarative and fixpoint semantics in [7]. 3 Abstract Domains This section introduces an analysis for ground and ground-deterministic dependences. <p> To make the analysis more concise we will return non-redundant dependences and we will approximate success patterns with their least upper bound, allowing in each ff interpretation at most one abstract atom per predicate symbol <ref> [1, 8] </ref>. <p> Moreover, since P red is finite and for each n-ary predicate symbol p 2 P red there always exists a finite set of abstract atoms in B ] P defined on p, it is easy to prove that (ffi ] ; ff ) is a finite lattice <ref> [1] </ref>. 3.2 Abstract Substitutions To develop an abstract interpretation based upon a declarative semantics, we also have to reconsider the substitution notion within the abstract framework [1]. <p> abstract atoms in B ] P defined on p, it is easy to prove that (ffi ] ; ff ) is a finite lattice <ref> [1] </ref>. 3.2 Abstract Substitutions To develop an abstract interpretation based upon a declarative semantics, we also have to reconsider the substitution notion within the abstract framework [1]. Given a finite set of variables V , we denote by Subst V the set of substitutions # defined on V for each V V . <p> Thus, since the preorder v can be defined between any homogeneous dependence representations, independently from the domain, an ordering relation can be defined by extending the ff on the domain of sets of abstract substitutions. It is easy to prove that <ref> [1] </ref> given a finite set of variables V n , ( V n ; ) is a finite lattice. 3.3 Galois Connections Let I 2 2 B P and p 2 P red. <p> The process replaces any labelled node (v; ng) 2 V ffmgu with (v; g) iff there exists a hyperarc e 2 E ffmgu such that Head (e) = v and 8v i 2 T ail (e) : (v i ; g) 2 V ffmgu <ref> [1] </ref>.
Reference: [2] <author> C. Berge. </author> <title> Graphs and Hypergraphs. </title> <publisher> North-Holland, </publisher> <year> 1973. </year>
Reference-contexts: Section 3 formally defines the abstract domains and abstract operators for the analysis and abstract fixpoint semantics for deterministic dependences analysis, Section 4 shows some significant examples, while Section 5 deals with some concluding remark. 2 Preliminaries We assume the reader familiar with the notions of lattice theory, hypergraph theory <ref> [2] </ref>, semantics of logic programs [7] and the basic concepts of logic programming [9]. In the following we will denote by S=fsg the set S where the element fsg has been removed.
Reference: [3] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Proc. Fourth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: It derives possibly non-ground atoms by means of a bottom-up inference rule which is based on unification, as in the top-down SLD resolution. We assume the reader familiar with the basic notions of abstract interpretation as defined in <ref> [3] </ref>. In the following an abstract interpretation supporting our analysis for definite logic programs is developed according to a bottom-up technique [1] based on an abstraction of the declarative and fixpoint semantics in [7]. 3 Abstract Domains This section introduces an analysis for ground and ground-deterministic dependences. <p> ] where ff (D) = fabs (I) j I 2 Dg, * fl : 2 ffi ] ! 2 (2 B P ) where fl (D ] ) = fI j 9I ] 2 D ] ^ abs (I) = I ] g, holds the conditions on the Galois insertion <ref> [3] </ref> between (2 (2 B P ) ; ) and (2 ffi ] ; ff ). 3.4 Abstract Unification (ff-mgu) The abstract most general unifier ff-mgu : B n P fiB P ! Subst ] V [ff ailg, takes two n-tuples of concrete and abstract atoms respectively and returns an abstract <p> Thus, by T ] correctness: ff (T P " !) ff T ] P " k (or equivalently <ref> [3] </ref> T P " ! fl (T ] 4 Applications In the following example [14] we show the overall analysis by describing the composition of the operators defined in Section 3.
Reference: [4] <author> S. Debray and D.S. Warren. </author> <title> Functional Computations in Logic Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11-3:451-481, </volume> <year> 1989. </year>
Reference-contexts: In several cases, the ability of logic programs to compute multiple bindings is not exploited: in this case a logic program has a determinate behaviour, i.e. it produces a single output value for a given query, or for a class of queries satisfying some properties. Recently, some analyses <ref> [6, 4, 11, 10, 12] </ref> have been proposed to statically detect when a computation is determinate. The knowledge of determinate computations, i.e. determinacies, supports optimization of the program execution time [5] end of bottom-up evaluators [10].
Reference: [5] <author> B. Demoen, P. VanRoy, and Y.D. Willems. </author> <title> Improving the Execution Speed of Compiled Prolog with Modes, Clause Selection and Determinism. </title> <editor> In H. Ehrig, R. Kowalski, G. Levi, and U. Montanari, editors, </editor> <booktitle> Proc. TAPSOFT 1987, volume 250 of Lecture Notes in Computer Science, </booktitle> <pages> pages 111-125. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: Recently, some analyses [6, 4, 11, 10, 12] have been proposed to statically detect when a computation is determinate. The knowledge of determinate computations, i.e. determinacies, supports optimization of the program execution time <ref> [5] </ref> end of bottom-up evaluators [10]. Even if the analysis to detect determinancies is related to the control features of the language implementation, we show that determinancies may be inferred by a bottom up analysis that does not require any knowledge of the type and activating modes of a predicate.
Reference: [6] <author> P. Deransart and J. Maluszynski. </author> <title> Relating Logic Programs and Attribute Grammars. </title> <journal> Journal of Logic Programming, </journal> <volume> 2 </volume> <pages> 119-156, </pages> <year> 1985. </year>
Reference-contexts: In several cases, the ability of logic programs to compute multiple bindings is not exploited: in this case a logic program has a determinate behaviour, i.e. it produces a single output value for a given query, or for a class of queries satisfying some properties. Recently, some analyses <ref> [6, 4, 11, 10, 12] </ref> have been proposed to statically detect when a computation is determinate. The knowledge of determinate computations, i.e. determinacies, supports optimization of the program execution time [5] end of bottom-up evaluators [10]. <p> The definition of the analysis requires the investigation of the relation between the input values of a predicate and those returned by the refutation of the fl To appear in European Conference on Programming ESOP'92 predicate itself. Some recent proposals <ref> [1, 6, 8, 12] </ref> characterize such a relation through the notion of dependence.
Reference: [7] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: abstract domains and abstract operators for the analysis and abstract fixpoint semantics for deterministic dependences analysis, Section 4 shows some significant examples, while Section 5 deals with some concluding remark. 2 Preliminaries We assume the reader familiar with the notions of lattice theory, hypergraph theory [2], semantics of logic programs <ref> [7] </ref> and the basic concepts of logic programming [9]. In the following we will denote by S=fsg the set S where the element fsg has been removed. <p> As a consequence 6 9E 0 fa; b; c; d; eg : fv 1 g ! E 0 G v 5 . The declarative semantics of logic programs in <ref> [7] </ref> is based on an extended Herbrand Universe containing also non-ground terms. It allows to declaratively characterize the ability of logic programs to compute answer substitutions (which are non-ground in general). Let us consider the set Cons of term constructors, and a denumerable set V ar of variables. <p> The Base of interpretations B P is Atoms= where extends to atoms in the obvious way. An interpretation I is any subset of B P . Standard results on model-theoretic and fixpoint semantics apply to the extended domains as well as in the ground case <ref> [7] </ref>. In particular, the fixpoint semantics for a logic program P (denoted as F (P )) is defined by means of an immediate consequences operator T P [7]. <p> Standard results on model-theoretic and fixpoint semantics apply to the extended domains as well as in the ground case <ref> [7] </ref>. In particular, the fixpoint semantics for a logic program P (denoted as F (P )) is defined by means of an immediate consequences operator T P [7]. It derives possibly non-ground atoms by means of a bottom-up inference rule which is based on unification, as in the top-down SLD resolution. We assume the reader familiar with the basic notions of abstract interpretation as defined in [3]. <p> We assume the reader familiar with the basic notions of abstract interpretation as defined in [3]. In the following an abstract interpretation supporting our analysis for definite logic programs is developed according to a bottom-up technique [1] based on an abstraction of the declarative and fixpoint semantics in <ref> [7] </ref>. 3 Abstract Domains This section introduces an analysis for ground and ground-deterministic dependences.
Reference: [8] <author> R. Giacobazzi and L. Ricci. </author> <title> Pipeline Optimizations in AND-Parallelism by Abstract Interpretation. </title> <editor> In D. H. D. Warren and P. Szeredi, editors, </editor> <booktitle> Proc. Seventh Int'l Conf. on Logic Programming, </booktitle> <pages> pages 291-305. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: The definition of the analysis requires the investigation of the relation between the input values of a predicate and those returned by the refutation of the fl To appear in European Conference on Programming ESOP'92 predicate itself. Some recent proposals <ref> [1, 6, 8, 12] </ref> characterize such a relation through the notion of dependence. <p> To make the analysis more concise we will return non-redundant dependences and we will approximate success patterns with their least upper bound, allowing in each ff interpretation at most one abstract atom per predicate symbol <ref> [1, 8] </ref>.
Reference: [9] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: and abstract fixpoint semantics for deterministic dependences analysis, Section 4 shows some significant examples, while Section 5 deals with some concluding remark. 2 Preliminaries We assume the reader familiar with the notions of lattice theory, hypergraph theory [2], semantics of logic programs [7] and the basic concepts of logic programming <ref> [9] </ref>. In the following we will denote by S=fsg the set S where the element fsg has been removed.
Reference: [10] <author> M.J. Maher and R. Ramakrishnan. </author> <title> Deja Vu in Fixpoints of Logic Programs. </title> <editor> In E. Lusk and R. Overbeck, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 963-980. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: In several cases, the ability of logic programs to compute multiple bindings is not exploited: in this case a logic program has a determinate behaviour, i.e. it produces a single output value for a given query, or for a class of queries satisfying some properties. Recently, some analyses <ref> [6, 4, 11, 10, 12] </ref> have been proposed to statically detect when a computation is determinate. The knowledge of determinate computations, i.e. determinacies, supports optimization of the program execution time [5] end of bottom-up evaluators [10]. <p> Recently, some analyses [6, 4, 11, 10, 12] have been proposed to statically detect when a computation is determinate. The knowledge of determinate computations, i.e. determinacies, supports optimization of the program execution time [5] end of bottom-up evaluators <ref> [10] </ref>. Even if the analysis to detect determinancies is related to the control features of the language implementation, we show that determinancies may be inferred by a bottom up analysis that does not require any knowledge of the type and activating modes of a predicate.
Reference: [11] <author> A.O. Mendelzon. </author> <title> Functional Dependencies in Logic Programs. </title> <booktitle> In Proc. of the Eleventh International Conference on Very Large Data Bases, </booktitle> <pages> pages 324-330, </pages> <year> 1985. </year>
Reference-contexts: In several cases, the ability of logic programs to compute multiple bindings is not exploited: in this case a logic program has a determinate behaviour, i.e. it produces a single output value for a given query, or for a class of queries satisfying some properties. Recently, some analyses <ref> [6, 4, 11, 10, 12] </ref> have been proposed to statically detect when a computation is determinate. The knowledge of determinate computations, i.e. determinacies, supports optimization of the program execution time [5] end of bottom-up evaluators [10]. <p> The ground dependence notion, introduced in the database framework <ref> [11] </ref>, has been extended in order to handle recursive clauses. Hence, the analysis returns significative results not only in the case of database programming, but also in other cases, such as programs manipulating recursive data structures.
Reference: [12] <author> L. Ricci. </author> <title> Compilation of Logic Programs for Massively Parallel Systems. </title> <type> PhD thesis, </type> <institution> Universita di Pisa, </institution> <month> Feb. </month> <year> 1990. </year> <pages> T.D. 3-90. </pages>
Reference-contexts: In several cases, the ability of logic programs to compute multiple bindings is not exploited: in this case a logic program has a determinate behaviour, i.e. it produces a single output value for a given query, or for a class of queries satisfying some properties. Recently, some analyses <ref> [6, 4, 11, 10, 12] </ref> have been proposed to statically detect when a computation is determinate. The knowledge of determinate computations, i.e. determinacies, supports optimization of the program execution time [5] end of bottom-up evaluators [10]. <p> The definition of the analysis requires the investigation of the relation between the input values of a predicate and those returned by the refutation of the fl To appear in European Conference on Programming ESOP'92 predicate itself. Some recent proposals <ref> [1, 6, 8, 12] </ref> characterize such a relation through the notion of dependence.
Reference: [13] <author> T. Sato and H. Tamaki. </author> <title> Enumeration of Success Patterns in Logic Programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 227-240, </pages> <year> 1984. </year>
Reference-contexts: With respect to [14], our proposal can detect both ground and ground deterministic dependences in a single step, and requires no knowledge of the types of the predicates nor of the activating modes of a predicate. Our abstract interpretation can be easily integrated with further analyses, such as depth-k <ref> [13] </ref>, type and general functional ones. By pairing our analysis with a term structure one (e.g. depth-k), dependences among subterms may be detected. Furthermore, it is possible to relax the ground dependences condition in order to obtain a more general analysis of functional dependences.
Reference: [14] <author> J. Zobel and P. </author> <title> Dart. On Logic Programs, Functional Dependencies, and Types. </title> <type> Technical report, </type> <institution> University of Melbourne, </institution> <year> 1990. </year>
Reference-contexts: Thus, by T ] correctness: ff (T P " !) ff T ] P " k (or equivalently [3] T P " ! fl (T ] 4 Applications In the following example <ref> [14] </ref> we show the overall analysis by describing the composition of the operators defined in Section 3. <p> We recall that determinacy is inferred with respect to arguments rather than to whole predicates. This means that a ground instance of a set of arguments may uniquely determine another set of arguments of a predicate, while producing multiple bindings for other arguments. With respect to <ref> [14] </ref>, our proposal can detect both ground and ground deterministic dependences in a single step, and requires no knowledge of the types of the predicates nor of the activating modes of a predicate.
References-found: 14

