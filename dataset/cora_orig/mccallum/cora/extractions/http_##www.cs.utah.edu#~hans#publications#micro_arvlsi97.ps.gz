URL: http://www.cs.utah.edu/~hans/publications/micro_arvlsi97.ps.gz
Refering-URL: http://www.cs.utah.edu/~hans/publications/publications.html
Root-URL: 
Email: fhans,ganeshg@cs.utah.edu  
Title: Asynchronous Microengines for Efficient High-level Control  
Author: Hans Jacobson and Ganesh Gopalakrishnan 
Note: 1: Introduction Supported in part by NSF MIP-9622587  
Address: Utah  
Affiliation: Department of Computer Science University of  
Abstract: Asynchronous (self-timed) circuits are quite natural for realizing control-intensive designs. Many such designs are of reactive nature and inherently complex due to complicated communication protocols. In these situations programmable controllers are preferable over hardwired controllers to allow design decisions to be bound late, help correct errors that may slip through the verification process, and even permit run-time modification of control algorithms to best suit the current situation. Virtually all recent work in asynchronous controller design focusses on generating hardwired controllers. In this paper, we propose an architecture for programmable asynchronous controllers in the form of a microprogrammed asynchronous "microengine". Architectures utilizing both two-phase and four-phase handshaking are proposed. The datapath structure of the asynchronous microengine is modular and easily extensible, facilitating changes during the design phase. We ensure high performance of the asynchronous microengine by exploiting concurrency between operations and employ efficient control structures. Initial results show that the proposed microengine can yield performance close to that offered by automated high-level synthesis tools targeting custom hardwired burst-mode machines for control. Designing reactive and control-intensive digital circuits, especially where multiple unsynchronized data inputs are involved, and where the computations and control decisions take variable amounts of time, is a challenging problem in many ways. If one uses the synchronous clocked design style, one has to do considerable timing analysis to ensure that all the clock-cycles are "optimally" filled in all control-flow situations, and/or adopt clock gating/skewing techniques that are not fully understood yet. These are well known to be hard problems. Furthermore, design changes even of a local nature can cause global ripple-effects of control schedule changes in order to regain optimality. Asynchronous (self-timed) circuits are quite natural for realizing circuits of this style, and encouraging results are being obtained by many, for example in designing communications components used in multiprocessors [2], hardware to network portable electronic devices [11], and audio-electronics hardware [16]. This paper addresses one shortcoming in the design spectrum of modern asynchronous controller realization methods, including the ones used in the above cited works: they are hardwired! Programmable control is often desired for several reasons. Many designs in this domain are very complex, often tending to be at the limits of our (human) design abilities. In these circumstances, it is good to have the flexibility to bind design decisions late. Our understanding of the debugging process in this domain is also incomplete, and hence one would like the ability to correct errors even after fabrication. These features are especially handy during prototying. Allowing run-time modifications of control algorithms may also offer performance benefits. Supporting families of component types, such as bus adaptor chips, may also be facilitated by programmability. Three 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Carter, J., Kuo, C.-C., and Kuramkote, R. </author> <title> A comparison of software and hardware synchronization mechanisms for distributed shared memory multiprocessors. </title> <type> Tech. Rep. </type> <institution> UUCS-96-011, University of Utah, </institution> <address> Salt Lake City, UT, USA, </address> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: Three fl Supported in part by NSF MIP-9622587 examples of systems realized using programmable control (but not using asynchronous control) are the S3MP processor [12] which uses a microprogram engine, the FLASH processor [10] which uses a processor-core, and the Utah Avalanche <ref> [1] </ref> processor which is expected to use one of these styles. The method proposed in this paper combines the advantages of programmability and self-timing.
Reference: [2] <author> Davis, A., Coates, B., and Stevens, K. </author> <title> The Post Office Experience: Designing a Large Asynchronous Chip. </title> <booktitle> In Proceedings of the Hawaiian International Conference on System Sciences, </booktitle> <volume> Volume 1 (Jan. </volume> <year> 1993), </year> <editor> T. Mudge, V. Milutinovic, and L. Hunter, </editor> <booktitle> Eds., </booktitle> <pages> pp. 409-418. </pages>
Reference-contexts: Asynchronous (self-timed) circuits are quite natural for realizing circuits of this style, and encouraging results are being obtained by many, for example in designing communications components used in multiprocessors <ref> [2] </ref>, hardware to network portable electronic devices [11], and audio-electronics hardware [16]. This paper addresses one shortcoming in the design spectrum of modern asynchronous controller realization methods, including the ones used in the above cited works: they are hardwired! Programmable control is often desired for several reasons. <p> Our design problem then reduces to one of designing request generation logic that offers low overhead and good scalability with regard to the number of datapath elements. For implementation of the request generation logic, burstmode <ref> [2, 14, 19] </ref> type of asynchronous state machines are used.
Reference: [3] <author> Gajski, D. </author> <title> Principles of Digital Design. </title> <publisher> Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: Sequential/Parallel Evaluation: Explicit acknowledging of completions by asynchronous datapaths allows a richer set of ways in which to sequence actions. For example, our approach allows several datapath functions to be computed sequentially (chained <ref> [3] </ref>) without having to fetch new microinstructions in between, or having to wait for the next clock edge after the chain is completed, as in a synchronous realization. The same functions may also be computed in a parallel or pipelined mode when throughput is more important than latency.
Reference: [4] <author> Hauck, S., Borriello, G., and Ebeling, C. Triptych: </author> <title> An fpga architecture with integrated logic and routing. </title> <booktitle> In Advanced Research in VLSI and Parallel Systems: Proceedings of the 1992 Brown/MIT Conference. </booktitle> <publisher> MIT Press, </publisher> <year> 1992, </year> <pages> pp. 26-43. </pages>
Reference-contexts: This reduces control overhead by allowing high concurrency between different parts of the microengine. Our method also allows maximum flexibility and low overhead even on small-scale designs. Another method to obtain programmable control in a self-timed design context is by using FPGAs such as Triptych <ref> [4] </ref>. However, these and other similar FPGA structures are configuration-time reprogrammable, but not (easily) run-time configurable. In addition, the area/time figures given in [4] suggests that it will not be as efficient for the class of circuits we have in mind for our microengine. 2 For example, an 8-bit adder in <p> Another method to obtain programmable control in a self-timed design context is by using FPGAs such as Triptych <ref> [4] </ref>. However, these and other similar FPGA structures are configuration-time reprogrammable, but not (easily) run-time configurable. In addition, the area/time figures given in [4] suggests that it will not be as efficient for the class of circuits we have in mind for our microengine. 2 For example, an 8-bit adder in Triptych has a 42nS delay and takes 40 routing and logic blocks (RLBs) while we our microengine can use a customized adder that
Reference: [5] <author> Hennessy, J., and Patterson, D. </author> <title> Computer Architecture A Quantitative Approach. </title> <publisher> Mor-gan Kaufmann Publishers, </publisher> <year> 1990. </year>
Reference-contexts: We solve this problem of branch prediction in our microengine by fetching the next microinstruction most likely to be executed, but not committing it before the address selection has been resolved. We provide a flexible branch prediction solution based on empirical data <ref> [5] </ref> according to which average branch probabilities favors a branch taken approach, and the importance of allowing the designer to easily change branch prediction strategy. Each branch can therefore be individually programmed to employ a taken or not taken branch prediction strategy.
Reference: [6] <author> Hwang, K. </author> <title> Computer Arithmetic: </title> <booktitle> Principles, Architecture, and Design. </booktitle> <publisher> Wiley, </publisher> <address> NY, </address> <year> 1979. </year>
Reference-contexts: So far two designs have been built using the presented microengine approach, an SRT divider <ref> [6] </ref>, and a CD player error decoder [8]. The error decoder circuit implements error-detection on the audio information recorded on Compact Discs using a syndrome computation algorithm.
Reference: [7] <author> Jacobson, H., and Gopalakrishnan, G. </author> <title> Asynchronous microengines for efficient high-level control. </title> <type> Tech. Rep. </type> <institution> UUCS-97-007, Department of Computer Science, University of Utah, </institution> <address> Salt Lake City, UT, USA, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: When done is true, after synchronizing with all acknowledges, an event is sent to the environment as an acknowledge that the microengine has completed the requested computation. The ECU then remains quiescent until a new request arrives from the environment. More details are given in <ref> [7] </ref>. Branch detection To control the program flow executed by the microengine, the current state of the datapath must be communicated back to the microengine's next address logic. <p> This results in a complex control structure internal to each datapath element that is dependent on the current mode of operation for completion detection and data latching. Additional problems with this approach are discussed in <ref> [7] </ref>. 3. Use of input registers only: Having only input registers suits well with parallel and sequential modes as well as in mixed modes of operation. <p> Timing assumptions not on critical paths or otherwise of less importance have been left out in this paper but are presented in full detail in <ref> [7] </ref>. All timing assumptions have single sided constraints and can always be satisfied by inserting appropriate delays. The following conventions are used in the timing diagrams of Figure 8. Figures 6 (a) and 7 (a) illustrate the architectures corresponding to these timing diagrams.
Reference: [8] <author> Kessels, J., van Berkel, K., Burgess, R., Roncken, M., and Schalij, F. </author> <title> An error decoder for the compact disc player as an example of VLSI programming. </title> <type> Tech. rep., </type> <institution> Philips Research Laboratories, Eindhoven, </institution> <address> The Netherlands, </address> <year> 1992. </year>
Reference-contexts: So far two designs have been built using the presented microengine approach, an SRT divider [6], and a CD player error decoder <ref> [8] </ref>. The error decoder circuit implements error-detection on the audio information recorded on Compact Discs using a syndrome computation algorithm. <p> This framework takes a high level description in Verilog+, a synthesizable subset of Verilog extended to handle channels, as input and targets customized interacting burstmode FSMs as control structure. The Verilog+ design specification of the error decoder is a faithful translation of the Tangram program presented in <ref> [8] </ref> which also enables us to compare the respective results obtained therein. Although the microengine design was implemented by hand, careful attention was given to ensure that the implementation correspond to what would easily be achievable using an automated synthesis tool. The Tangram implementation described in [8] which used dual rail <p> Tangram program presented in <ref> [8] </ref> which also enables us to compare the respective results obtained therein. Although the microengine design was implemented by hand, careful attention was given to ensure that the implementation correspond to what would easily be achievable using an automated synthesis tool. The Tangram implementation described in [8] which used dual rail logic and a 1.2 micron technology was reported to have an approximate worst case cycle time of 20 microseconds, each cycle decoding a sequence of 32 8-bit input words.
Reference: [9] <author> Kudva, P. </author> <title> Synthesis of Asynchronous Systems Targeting Finite State Machines. </title> <type> PhD thesis, </type> <institution> Computer Science Department, University of Utah, </institution> <year> 1995. </year>
Reference-contexts: To get an estimation of how efficient our microengine approach is compared to a custom control implementation using the same datapath structure, the error decoder was also implemented using our high level synthesis framework for asynchronous circuits, ACK <ref> [9] </ref>. This framework takes a high level description in Verilog+, a synthesizable subset of Verilog extended to handle channels, as input and targets customized interacting burstmode FSMs as control structure.
Reference: [10] <author> Kuskin, J., and et al., D. O. </author> <title> The Stanford FLASH multiprocessor. </title> <booktitle> In Proceedings of the 21st Annual International Symposium on Computer Architecture (May 1994), </booktitle> <pages> pp. 302-313. </pages>
Reference-contexts: Supporting families of component types, such as bus adaptor chips, may also be facilitated by programmability. Three fl Supported in part by NSF MIP-9622587 examples of systems realized using programmable control (but not using asynchronous control) are the S3MP processor [12] which uses a microprogram engine, the FLASH processor <ref> [10] </ref> which uses a processor-core, and the Utah Avalanche [1] processor which is expected to use one of these styles. The method proposed in this paper combines the advantages of programmability and self-timing.
Reference: [11] <author> Marshall, A., Coates, B., and Siegel, P. </author> <title> Designing an asynchronous communications chip. </title> <booktitle> IEEE Design & Test of Computers 11, 2 (1994), </booktitle> <pages> 8-21. </pages> <month> Summer. </month>
Reference-contexts: Asynchronous (self-timed) circuits are quite natural for realizing circuits of this style, and encouraging results are being obtained by many, for example in designing communications components used in multiprocessors [2], hardware to network portable electronic devices <ref> [11] </ref>, and audio-electronics hardware [16]. This paper addresses one shortcoming in the design spectrum of modern asynchronous controller realization methods, including the ones used in the above cited works: they are hardwired! Programmable control is often desired for several reasons.
Reference: [12] <author> Nowatzyk, A., Aybay, G., and Pong, F. </author> <booktitle> Design of the s3mp processor, </booktitle> <year> 1995. </year>
Reference-contexts: Supporting families of component types, such as bus adaptor chips, may also be facilitated by programmability. Three fl Supported in part by NSF MIP-9622587 examples of systems realized using programmable control (but not using asynchronous control) are the S3MP processor <ref> [12] </ref> which uses a microprogram engine, the FLASH processor [10] which uses a processor-core, and the Utah Avalanche [1] processor which is expected to use one of these styles. The method proposed in this paper combines the advantages of programmability and self-timing.
Reference: [13] <author> Nowick, S., Yun, K., Beerel, P., and Dooply, A. </author> <title> Speculative completion detection for the design of high-performance asynchronous dynamic adders. </title> <booktitle> In Proceedings of the 1997 International Symposium on Advanced Research in Asynchronous Circuits and Systems (Apr. </booktitle> <year> 1997), </year> <pages> pp. 210-223. </pages>
Reference-contexts: Average case completion: Asynchronous datapaths can take advantage of variable completion times due to input data and environmental conditions. Recent studies have shown up to 19% average latency reduction for random input data in 32 bit Brent-Kung adders using speculative completion detection <ref> [13] </ref> and 48% performance increase for a 32 bit differential equation solver [18] under normal operating conditions, compared to a worst case synchronous design.
Reference: [14] <author> Nowick, S. M. </author> <title> Automatic synthesis of burst-mode asynchronous controllers. </title> <type> PhD thesis, </type> <institution> Computer Systems Laboratory, Stanford University, </institution> <year> 1993. </year>
Reference-contexts: Our design problem then reduces to one of designing request generation logic that offers low overhead and good scalability with regard to the number of datapath elements. For implementation of the request generation logic, burstmode <ref> [2, 14, 19] </ref> type of asynchronous state machines are used.
Reference: [15] <author> Stevens, K. </author> <title> The soft controller: A self-timed microsequencer for distributed parallel architectures. </title> <type> Tech. rep., </type> <institution> Department of Computer Science, University of Utah, </institution> <month> Dec. </month> <year> 1984. </year> <note> [16] van Berkel, </note> <author> K., Burgess, R., Kessels, J., Roncken, M., Schalij, F., and Peeters, A. </author> <title> Asynchronous circuits for low power: A dcc error corrector. </title> <booktitle> IEEE Design & Test of Computers 11, 2 (1994), </booktitle> <pages> 22-31. </pages> <month> Summer. </month>
Reference-contexts: These advantages have sufficient impact on the ease of design as well as flexibility and performance after fabrication to motivate further exploration of asynchronous microengines. 1.2: Related work Asynchronous microengines were investigated around the 1980's <ref> [15] </ref>. We do not know of papers (if any) in this area since then. In the approach of [15], the microengine was coded with vertical microcode and used to drive a collection of slave controllers which together with the implementation technology, "structured tiling" called PPL, could introduce considerable control related overhead. <p> sufficient impact on the ease of design as well as flexibility and performance after fabrication to motivate further exploration of asynchronous microengines. 1.2: Related work Asynchronous microengines were investigated around the 1980's <ref> [15] </ref>. We do not know of papers (if any) in this area since then. In the approach of [15], the microengine was coded with vertical microcode and used to drive a collection of slave controllers which together with the implementation technology, "structured tiling" called PPL, could introduce considerable control related overhead.
Reference: [17] <author> Wilkes, M. </author> <title> The best way to design an automatic calculating machine., </title> <month> July </month> <year> 1951. </year>
Reference-contexts: The method proposed in this paper combines the advantages of programmability and self-timing. More specifically, the main contribution of this paper is the design and experimental evaluation of a fully asynchronous microprogrammed control organization <ref> [17] </ref>, a microengine, emphasizing simplicity, modularity, and high performance. We will also show that asynchronous design methods can be used advantageously in the design of microprogrammed control and datapath structures. This paper is organized as follows.
Reference: [18] <author> Yun, K., Beerel, P., Vakilotojar, V., Dooply, A., and Arceo, J. </author> <title> The design and verification of a high-performance low-control-overhead asynchronous differential equation solver. </title> <booktitle> In Proceedings of the 1997 International Symposium on Advanced Research in Asynchronous Circuits and Systems (Apr. </booktitle> <year> 1997), </year> <pages> pp. 140-153. </pages>
Reference-contexts: Recent studies have shown up to 19% average latency reduction for random input data in 32 bit Brent-Kung adders using speculative completion detection [13] and 48% performance increase for a 32 bit differential equation solver <ref> [18] </ref> under normal operating conditions, compared to a worst case synchronous design.
Reference: [19] <author> Yun, K. Y. </author> <title> Synthesis of asynchronous controllers for heterogeneous systems. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> Aug. </month> <year> 1994. </year> <month> 18 </month>
Reference-contexts: Our design problem then reduces to one of designing request generation logic that offers low overhead and good scalability with regard to the number of datapath elements. For implementation of the request generation logic, burstmode <ref> [2, 14, 19] </ref> type of asynchronous state machines are used. <p> Since this is true for both two and four phase protocols, the same request generation logic can be used in both cases. An abstract event based FSM and resulting complex gate implementation using the 3D synthesis tool <ref> [19] </ref> is illustrated in Figure 3 (a). The respective n and p transistor networks can then be decomposed into balanced tree structures of gates to simplify timing analysis.
References-found: 18

