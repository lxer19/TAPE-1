URL: http://www.cs.umn.edu/Research/Agassiz/Paper/gu.ppopp97.ps.Z
Refering-URL: http://www.cs.umn.edu/Research/Agassiz/agassiz_pubs.html
Root-URL: http://www.cs.umn.edu
Email: fgu,lig@cs.umn.edu glee@voyager1.eng.utsa.edu  
Title: Experience with Efficient Array Data Flow Analysis for Array Privatization  
Author: Junjie Gu Zhiyuan Li Gyungho Lee 
Address: 200 Union Street S.E. 6900 North Loop 1604 West Minneapolis, MN 55455 San Antonio, Texas 78249-0665  
Affiliation: Department of Computer Science Electrical Engineering, Division of Engineering University of Minnesota University of Texas San Antonio  
Abstract: Array data flow analysis is known to be crucial to the success of array privatization, one of the most important techniques for program parallelization. It is clear that array data flow analysis should be performed interprocedurally and symbolically, and that it often needs to handle the predicates represented by IF conditions. Unfortunately, such a powerful program analysis can be extremely time-consuming if not carefully designed. How to enhance the efficiency of this analysis to a practical level remains an issue largely untouched to date. This paper documents our experience with building a highly efficient array data flow analyzer which is based on guarded array regions and which runs faster, by one or two orders of magnitude, than other similarly powerful tools. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1986. </year>
Reference-contexts: It roughly consists of the phases of parsing, building a hierarchical supergraph (HSG) and the interprocedural scalar UD/DU chains <ref> [1] </ref>, performing conventional data dependence tests, array data flow analysis and other advanced analyses, and parallel code generation.
Reference: [2] <author> V. Balasundaram. </author> <title> A mechanism for keeping useful internal information in parallel programming tools: The data access descriptor. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 9 </volume> <pages> 154-170, </pages> <year> 1990. </year>
Reference-contexts: Generally, these approaches are intraprocedural and do not seem easily extended inter-procedurally. The other group analyzes a set of array elements instead of individual array elements. Early work uses regular sections [4, 13], convex regions [22, 23], data access descriptors <ref> [2] </ref>, etc. to summarize MOD/USE sets of array accesses. They are not array data flow analyses. Recently, array data flow analyses based on these sets were proposed (Gross and Steenkiste [10], Rosene [20], Li [14], Tu and Padua [25], Creusillet and Irigoin [6], and M. Hall et al. [12]).
Reference: [3] <author> W. Blume and R. Eigenmann. </author> <title> Symbolic analysis techniques needed for the effective parallelization of Perfect benchmarks. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, University of Illinois, </institution> <year> 1994. </year>
Reference-contexts: Related work will be briefly discussed in section 4. Finally, we conclude the paper. 2 Array data flow analysis: Effectiveness and efficiency The need for an array data flow analyzer which can analyze call effects, symbolic values, and IF conditions has been well documented previously <ref> [3, 11, 17] </ref>. For readers new to the field, we will briefly explain the issues through two simple examples. Figures 1 (a)&(b) show an example from ADM in the Perfect benchmark suite.
Reference: [4] <author> D. Callahan and K. Kennedy. </author> <title> Analysis of interprocedural side effects in a parallel programming environment. </title> <booktitle> In ACM SIGPLAN '86 Symp. Compiler Construction, </booktitle> <pages> pages 162-175, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Our basic unit of array reference representation is a regular array region, which is also called a bounded regular section [13]. It is a reduced form of the original regular sections proposed by Callahan and Kennedy <ref> [4] </ref>. (For simplicity, we refer to bounded regular sections as regular sections where this will cause no confusion.) On the other hand, we extend the original regular sections in the following ways to meet our needs in representing U E and M OD sets. <p> Slightly differently from the regular sections originally proposed by Callahan and Kennedy and later enhanced by Havlak <ref> [4, 13] </ref>, we use a list of GAR's or GARWD's to keep a precise summary set. Keeping a long list potentially can be inefficient, because the time complexity of set operations of two region lists with lengths n and m is in the order of (n m). <p> Generally, these approaches are intraprocedural and do not seem easily extended inter-procedurally. The other group analyzes a set of array elements instead of individual array elements. Early work uses regular sections <ref> [4, 13] </ref>, convex regions [22, 23], data access descriptors [2], etc. to summarize MOD/USE sets of array accesses. They are not array data flow analyses.
Reference: [5] <author> Lori A. Clarke and Debra J. Richardson. </author> <title> Applications of symbolic evaluation. </title> <journal> The Journal of Systems and Software, </journal> <volume> 5(1) </volume> <pages> 15-35, </pages> <year> 1985. </year>
Reference-contexts: These can be implemented rather efficiently. A canonical normal form is used to represent the predicates. Pattern-matching under a normal form is easier than under arbitrary forms. Both the conjunctive normal form (CNF) and the disjunctive normal form (DNF) have been widely used in program analysis <ref> [21, 5] </ref>. These cited works show that negation operations are expensive with both CNF and DNF. This fact was also confirmed by our previous experiments using CNF [11]. Negation operations occur not only due to ELSE branches, but also due to GAR and GARWD operations elsewhere.
Reference: [6] <author> Beatrice Creusillet and F. Irigoin. </author> <title> Interprocedural array region analyses. </title> <journal> Int. Journal of Parallel Programming, </journal> <volume> 24(6) </volume> <pages> 513-546, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: They are not array data flow analyses. Recently, array data flow analyses based on these sets were proposed (Gross and Steenkiste [10], Rosene [20], Li [14], Tu and Padua [25], Creusillet and Irigoin <ref> [6] </ref>, and M. Hall et al. [12]). Of these, ours is the only one using conditional regions (GAR's), even though some do handle IF conditions using other approaches. <p> Early work tried to use a single regular section or a single convex region to summarize one array. Obviously, a single set can potentially lose information, and it may be not useful in some cases. Tu and Padua [25], and Creusillet and Irigoin <ref> [6] </ref> seem to use a single regular section and a single convex region, respectively. M. Hall et al. [12] use a list of convex regions to summarize all the references of an array.
Reference: [7] <author> E. Duesterwald, R. Gupta, </author> <title> and M.L. Soffa. A practical data flow framework for array reference analysis and its use in optimizations. </title> <booktitle> In ACM SIGPLAN '93 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 68-77, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: This is usually done by solving a system of equalities and inequalities. Feautrier [9] calculates the source function to indicate detailed flow information. Maydan et al. [16, 17] simplify Feautrier's method by using a Last-Write-Tree (LWT). Duesterwald et al. <ref> [7] </ref> compute the dependence distance for each reaching definition within a loop. Pugh and Wonna-cott [19] use a set of constraints to describe array data flow problems and solve them basically by the Fourier-Motzkin variable elimination.
Reference: [8] <author> R. Eigenmann, J. Hoeflinger, and D. Padua. </author> <title> On the automatic parallelization of the perfect benchmarks. </title> <type> Technical Report TR 1392, </type> <institution> CSRD, University of Illinois at Urbana-Champaign, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: Only the Illinois Po-laris tool is known to demonstrate equal power <ref> [8] </ref>. This table also marks which loops require symbolic analysis, predicate analysis and interprocedural analysis, and privatizable arrays, respectively. Table 2 and Table 3 compare the efficiency of our analyzer with that of Polaris. Both Panorama and Polaris are compiled by the GNU gcc/g++ compiler.
Reference: [9] <author> Paul Feautrier. </author> <title> Dataflow analysis of array and scalar references. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 2(1) </volume> <pages> 23-53, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: One school of thought attempts to gather flow information for each array element and to acquire an exact array data flow analysis. This is usually done by solving a system of equalities and inequalities. Feautrier <ref> [9] </ref> calculates the source function to indicate detailed flow information. Maydan et al. [16, 17] simplify Feautrier's method by using a Last-Write-Tree (LWT). Duesterwald et al. [7] compute the dependence distance for each reaching definition within a loop.
Reference: [10] <author> T. Gross and P Steenkiste. </author> <title> Structured dataflow analysis for arrays and its use in an optimizing compiler. </title> <journal> Software - Practice and Experience, </journal> <volume> 20(2) </volume> <pages> 133-155, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: Early work uses regular sections [4, 13], convex regions [22, 23], data access descriptors [2], etc. to summarize MOD/USE sets of array accesses. They are not array data flow analyses. Recently, array data flow analyses based on these sets were proposed (Gross and Steenkiste <ref> [10] </ref>, Rosene [20], Li [14], Tu and Padua [25], Creusillet and Irigoin [6], and M. Hall et al. [12]). Of these, ours is the only one using conditional regions (GAR's), even though some do handle IF conditions using other approaches.
Reference: [11] <author> J. Gu, Z. Li, and G. Lee. </author> <title> Symbolic array dataflow analysis for array privatization and program parallelization. </title> <booktitle> In Supercomputing, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: Moreover, the predicates represented by IF conditions often need to be analyzed. The problem of array data flow analysis has been examined in various limited forms in the past (c.f. Related Works below). Recently, our group <ref> [11] </ref> and the Illinois Polaris group [24] have both proposed comprehensive frameworks for symbolic array data flow analysis which can handle IF conditions. <p> Related work will be briefly discussed in section 4. Finally, we conclude the paper. 2 Array data flow analysis: Effectiveness and efficiency The need for an array data flow analyzer which can analyze call effects, symbolic values, and IF conditions has been well documented previously <ref> [3, 11, 17] </ref>. For readers new to the field, we will briefly explain the issues through two simple examples. Figures 1 (a)&(b) show an example from ADM in the Perfect benchmark suite. <p> In addition, we annotate regular sections with predicates which affect the array references, resulting in a guarded array region (GAR). We presented these concepts in a previous paper <ref> [11] </ref>, and have since made some important improvements. <p> Also, if only one item in a range tuple (l : u : s), say u, is unknown, then we write the tuple as (l : unknown : s). Our previous work <ref> [11] </ref> uses a list of GAR's for both a M OD set and a U E set. Since then, we have improved the representation of a U E set by using a GAR with a difference list (GARWD). Its contribution to compiler efficiency will be discussed in section 3. <p> The general formula has been given in our previous work <ref> [11] </ref>. Here, we emphasize our new improvements. <p> n : 1] is valid if and only if both R 1 and R 2 are valid. * T 1 T 2 = [P 1 ^ P 2 ; R 1 R 2 ] [ [P 1 ^ P 2 ; R 1 ] As described in our previous paper <ref> [11] </ref>, the actual result of R 1 R 2 may be multiple regular array regions, making the actual result of T 1 T 2 potentially complex. However, as Figure 2 illustrates, difference operations can often be canceled by intersection and union operations. <p> Both the conjunctive normal form (CNF) and the disjunctive normal form (DNF) have been widely used in program analysis [21, 5]. These cited works show that negation operations are expensive with both CNF and DNF. This fact was also confirmed by our previous experiments using CNF <ref> [11] </ref>. Negation operations occur not only due to ELSE branches, but also due to GAR and GARWD operations elsewhere. Hence, we design a new normal form such that negation operations can often be avoided. We use a hierarchical approach to predicate handling. <p> Let us use the example in Figure 1 (c) to further illustrate this fact. A simplified control flow graph of the body of the outer loop is shown in Figure 7. (For more information about our control flow graph, please consult our paper <ref> [11] </ref>.) Suppose that each node has been summarized and that the summary results are listed below: M OD (1) = [T; (jlow : jup)]; U E (1) = ; M OD (2) = ;; U E (2) = ; M OD (3) = [T; (jmax)]; U E (3) = ; M <p> Keeping a long list potentially can be inefficient, because the time complexity of set operations of two region lists with lengths n and m is in the order of (n m). In our previous work <ref> [11] </ref>, we merged two regions whenever possible by adding conditions to the guards. This treatment guarantees that no invalid regions are created due to invalid inequalities in the region limits, and it also shortens the length of a region list.
Reference: [12] <author> M.W. Hall, B.R. Murphy, S.P. Amarasinghe, S.-W. Liao, and M.S. Lam. </author> <title> Interprocedural analysis for parallelization. </title> <booktitle> In Proceedings of the 8th Workshop on Languages and Compilers for Parallel Computing, </booktitle> <volume> No. 1033, </volume> <booktitle> In Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, Berlin, </publisher> <pages> pages 61-80, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: They are not array data flow analyses. Recently, array data flow analyses based on these sets were proposed (Gross and Steenkiste [10], Rosene [20], Li [14], Tu and Padua [25], Creusillet and Irigoin [6], and M. Hall et al. <ref> [12] </ref>). Of these, ours is the only one using conditional regions (GAR's), even though some do handle IF conditions using other approaches. Although the second group does not provide as many details about reaching-definitions as the first group, it handles complex program constructs better and can be easily performed interprocedurally. <p> Obviously, a single set can potentially lose information, and it may be not useful in some cases. Tu and Padua [25], and Creusillet and Irigoin [6] seem to use a single regular section and a single convex region, respectively. M. Hall et al. <ref> [12] </ref> use a list of convex regions to summarize all the references of an array. It is unclear if this representation is more precise than a list of regular sections, upon which our approach is based.
Reference: [13] <author> P. Havlak and K. Kennedy. </author> <title> An implementation of interpro-cedural bounded regular section analysis. </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 2(3) </volume> <pages> 350-360, </pages> <year> 1991. </year>
Reference-contexts: The M OD set is the set of array elements written within the program segment. Our basic unit of array reference representation is a regular array region, which is also called a bounded regular section <ref> [13] </ref>. <p> Slightly differently from the regular sections originally proposed by Callahan and Kennedy and later enhanced by Havlak <ref> [4, 13] </ref>, we use a list of GAR's or GARWD's to keep a precise summary set. Keeping a long list potentially can be inefficient, because the time complexity of set operations of two region lists with lengths n and m is in the order of (n m). <p> Generally, these approaches are intraprocedural and do not seem easily extended inter-procedurally. The other group analyzes a set of array elements instead of individual array elements. Early work uses regular sections <ref> [4, 13] </ref>, convex regions [22, 23], data access descriptors [2], etc. to summarize MOD/USE sets of array accesses. They are not array data flow analyses.
Reference: [14] <author> Z. Li. </author> <title> Array privatization for parallel execution of loops. </title> <booktitle> In ACM Int. Conf. on Supercomputing, </booktitle> <pages> pages 313-322, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Early work uses regular sections [4, 13], convex regions [22, 23], data access descriptors [2], etc. to summarize MOD/USE sets of array accesses. They are not array data flow analyses. Recently, array data flow analyses based on these sets were proposed (Gross and Steenkiste [10], Rosene [20], Li <ref> [14] </ref>, Tu and Padua [25], Creusillet and Irigoin [6], and M. Hall et al. [12]). Of these, ours is the only one using conditional regions (GAR's), even though some do handle IF conditions using other approaches.
Reference: [15] <author> Vadim Maslov. </author> <title> Lazy array data-flow dependence analysis. </title> <booktitle> In Proceedings of Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 331-325, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Duesterwald et al. [7] compute the dependence distance for each reaching definition within a loop. Pugh and Wonna-cott [19] use a set of constraints to describe array data flow problems and solve them basically by the Fourier-Motzkin variable elimination. Maslov <ref> [15] </ref>, as well as Pugh and Won-nacott [19], also extend the previous work in this category by handling certain IF conditions. Generally, these approaches are intraprocedural and do not seem easily extended inter-procedurally. The other group analyzes a set of array elements instead of individual array elements.
Reference: [16] <author> D.E. Maydan, S.P. Amarasinghe, and M.S. Lam. </author> <title> Array data-flow analysis and its use in array privatization. </title> <booktitle> In Proc. of the 20th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 2-15, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: One school of thought attempts to gather flow information for each array element and to acquire an exact array data flow analysis. This is usually done by solving a system of equalities and inequalities. Feautrier [9] calculates the source function to indicate detailed flow information. Maydan et al. <ref> [16, 17] </ref> simplify Feautrier's method by using a Last-Write-Tree (LWT). Duesterwald et al. [7] compute the dependence distance for each reaching definition within a loop. Pugh and Wonna-cott [19] use a set of constraints to describe array data flow problems and solve them basically by the Fourier-Motzkin variable elimination.
Reference: [17] <author> Dror E. Maydan. </author> <title> Accurate Analysis of Array References. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: Related work will be briefly discussed in section 4. Finally, we conclude the paper. 2 Array data flow analysis: Effectiveness and efficiency The need for an array data flow analyzer which can analyze call effects, symbolic values, and IF conditions has been well documented previously <ref> [3, 11, 17] </ref>. For readers new to the field, we will briefly explain the issues through two simple examples. Figures 1 (a)&(b) show an example from ADM in the Perfect benchmark suite. <p> One school of thought attempts to gather flow information for each array element and to acquire an exact array data flow analysis. This is usually done by solving a system of equalities and inequalities. Feautrier [9] calculates the source function to indicate detailed flow information. Maydan et al. <ref> [16, 17] </ref> simplify Feautrier's method by using a Last-Write-Tree (LWT). Duesterwald et al. [7] compute the dependence distance for each reaching definition within a loop. Pugh and Wonna-cott [19] use a set of constraints to describe array data flow problems and solve them basically by the Fourier-Motzkin variable elimination.
Reference: [18] <author> T. Nguyen, J. Gu, and Z. Li. </author> <title> An interprocedural paralleliz-ing compiler and its support for memory hierarchy research. </title> <booktitle> In Lecture Notes in Computer Science 1033: 8th Interna--tional Workshop on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 96-110, </pages> <address> Columbus, Ohio, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: In this paper, we leave out the general discussion on the short-cut computation illustrated above. 2.4 Effectiveness and efficiency We have implemented our array data flow analysis in a pro-totyping parallelizing compiler, Panorama, which is a multiple pass, source-to-source Fortran program analyzer <ref> [18] </ref>. It roughly consists of the phases of parsing, building a hierarchical supergraph (HSG) and the interprocedural scalar UD/DU chains [1], performing conventional data dependence tests, array data flow analysis and other advanced analyses, and parallel code generation.
Reference: [19] <author> William Pugh and David Wonnacott. </author> <title> An exact method for analysis of value-based array data dependences. </title> <booktitle> In Lecture Notes in Computer Science 768: Sixth Annual Workshop on Programming Languages and Compilers for Parallel Computing, </booktitle> <address> Portland, OR, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: Feautrier [9] calculates the source function to indicate detailed flow information. Maydan et al. [16, 17] simplify Feautrier's method by using a Last-Write-Tree (LWT). Duesterwald et al. [7] compute the dependence distance for each reaching definition within a loop. Pugh and Wonna-cott <ref> [19] </ref> use a set of constraints to describe array data flow problems and solve them basically by the Fourier-Motzkin variable elimination. Maslov [15], as well as Pugh and Won-nacott [19], also extend the previous work in this category by handling certain IF conditions. <p> Duesterwald et al. [7] compute the dependence distance for each reaching definition within a loop. Pugh and Wonna-cott <ref> [19] </ref> use a set of constraints to describe array data flow problems and solve them basically by the Fourier-Motzkin variable elimination. Maslov [15], as well as Pugh and Won-nacott [19], also extend the previous work in this category by handling certain IF conditions. Generally, these approaches are intraprocedural and do not seem easily extended inter-procedurally. The other group analyzes a set of array elements instead of individual array elements.
Reference: [20] <author> Carl Rosene. </author> <title> Incremental dependence analysis. </title> <type> Technical Report CRPC-TR90044, PhD thesis, </type> <institution> Computer Science Department, Rice University, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: Early work uses regular sections [4, 13], convex regions [22, 23], data access descriptors [2], etc. to summarize MOD/USE sets of array accesses. They are not array data flow analyses. Recently, array data flow analyses based on these sets were proposed (Gross and Steenkiste [10], Rosene <ref> [20] </ref>, Li [14], Tu and Padua [25], Creusillet and Irigoin [6], and M. Hall et al. [12]). Of these, ours is the only one using conditional regions (GAR's), even though some do handle IF conditions using other approaches.
Reference: [21] <author> Jr T.E. Cheatham, G.H. Holloway, and J.A. Townley. </author> <title> Symbolic evaluation and the analysis of programs. </title> <journal> IEEE Trans.on Software Engineering, </journal> <volume> 5(4) </volume> <pages> 402-417, </pages> <month> July </month> <year> 1979. </year>
Reference-contexts: These can be implemented rather efficiently. A canonical normal form is used to represent the predicates. Pattern-matching under a normal form is easier than under arbitrary forms. Both the conjunctive normal form (CNF) and the disjunctive normal form (DNF) have been widely used in program analysis <ref> [21, 5] </ref>. These cited works show that negation operations are expensive with both CNF and DNF. This fact was also confirmed by our previous experiments using CNF [11]. Negation operations occur not only due to ELSE branches, but also due to GAR and GARWD operations elsewhere.
Reference: [22] <author> R. Triolet, F. Irigoin, and P. Feautrier. </author> <title> Direct paralleliza-tion of CALL statments. </title> <booktitle> In ACM SIGPLAN'86 Sym. on Compiler Construction, </booktitle> <pages> pages 176-185, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Generally, these approaches are intraprocedural and do not seem easily extended inter-procedurally. The other group analyzes a set of array elements instead of individual array elements. Early work uses regular sections [4, 13], convex regions <ref> [22, 23] </ref>, data access descriptors [2], etc. to summarize MOD/USE sets of array accesses. They are not array data flow analyses. Recently, array data flow analyses based on these sets were proposed (Gross and Steenkiste [10], Rosene [20], Li [14], Tu and Padua [25], Creusillet and Irigoin [6], and M.
Reference: [23] <author> Remi Triolet. </author> <title> Interprocedural analysis for program restructuring with parafrase. </title> <type> Technical Report CSRD Rpt. </type> <institution> No.538, Center for Supercomputing Research and Development, University of Illinois at Urbana-Champaign, </institution> <month> December </month> <year> 1985. </year>
Reference-contexts: Generally, these approaches are intraprocedural and do not seem easily extended inter-procedurally. The other group analyzes a set of array elements instead of individual array elements. Early work uses regular sections [4, 13], convex regions <ref> [22, 23] </ref>, data access descriptors [2], etc. to summarize MOD/USE sets of array accesses. They are not array data flow analyses. Recently, array data flow analyses based on these sets were proposed (Gross and Steenkiste [10], Rosene [20], Li [14], Tu and Padua [25], Creusillet and Irigoin [6], and M.
Reference: [24] <author> P. Tu and D. Padua. </author> <title> Gated ssa-based demand-driven symbolic analysis for parallelizing compilers. </title> <booktitle> In International Conference on Supercomputing, </booktitle> <pages> pages 414-423, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Moreover, the predicates represented by IF conditions often need to be analyzed. The problem of array data flow analysis has been examined in various limited forms in the past (c.f. Related Works below). Recently, our group [11] and the Illinois Polaris group <ref> [24] </ref> have both proposed comprehensive frameworks for symbolic array data flow analysis which can handle IF conditions.
Reference: [25] <author> Peng Tu and David Padua. </author> <title> Automatic array privatization. </title> <booktitle> In Proceedings of Sixth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 500-521, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: They are not array data flow analyses. Recently, array data flow analyses based on these sets were proposed (Gross and Steenkiste [10], Rosene [20], Li [14], Tu and Padua <ref> [25] </ref>, Creusillet and Irigoin [6], and M. Hall et al. [12]). Of these, ours is the only one using conditional regions (GAR's), even though some do handle IF conditions using other approaches. <p> Early work tried to use a single regular section or a single convex region to summarize one array. Obviously, a single set can potentially lose information, and it may be not useful in some cases. Tu and Padua <ref> [25] </ref>, and Creusillet and Irigoin [6] seem to use a single regular section and a single convex region, respectively. M. Hall et al. [12] use a list of convex regions to summarize all the references of an array.
References-found: 25

