URL: http://www.csl.sri.com/~qian/acta91.ps.gz
Refering-URL: http://www.csl.sri.com/~qian/early-pubs.html
Root-URL: 
Title: The Expressive Power of The Bounded-Iteration Construct  
Author: Xiaolei Qian 
Address: Mountain Avenue, Murray Hill, NJ  
Note: This work was supported in part by Defense Advanced Research Projects Agency under Contract N39-84-C-0211 for Knowledge Based Management Systems and by Rome Air Development Center under Contract F30602-86-C-0026 for Knowledge-Based Software Assistant. An extended abstract of this work appeared in Proceedings of the Second International Workshop on Database Programming Languages, 1989, 411-421. Author's current address: AT&T Bell Laboratories, 600  
Date: November 22, 1994  07974.  
Affiliation: Department of Computer Science, Stanford University and Kestrel Institute  
Abstract: The bounded-iteration construct foreach x in Rjp do t od is very commonly used in database programming, due to the fact that database programs are dominated by data retrieval and manipulation tasks rather than by complex computations. Hence in database programming language design, it is important to understand the expressive power of the bounded-iteration construct and its relationship with other language constructs. We study the bounded-iteration construct within the context of a simple database programming language called the iterative transaction language. The language is shown to have NPTIME expressive power, and the deterministic subclass of it has PTIME expressive power, without any extra machineries or restrictions. We show that the bounded-iteration construct is essential for achieving this expressiveness, by characterizing its relationship with other constructs in the language. We also identify another natural subclass of iterative transactions called first-order transactions with exactly first-order expressive power. The complexity of first-order transactions in terms of nested iterations and intermediate states is connected further to the complexity of first-order updates in terms of quantification depth. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abiteboul, S., Vianu, V., </author> <note> "Equivalence and Optimization of Relational Transactions"; Journal of the ACM 35:1, </note> <year> 1988, </year> <pages> 70-120. </pages>
Reference-contexts: Such understanding helps avoid ad hoc choices and unnecessary limitations in language design. It also provides a formal basis for other aspects of database programming, such as transaction verification, optimization, and synthesis <ref> [1, 11, 13] </ref>. The above concern for balance is reflected in the continuous effort in searching for natural language constructs that express efficient classes of queries and updates (see [5] for a survey), in particular the class of PTIME computable queries and updates.
Reference: [2] <author> Abiteboul, S., Vianu, V., </author> <booktitle> "Fixpoint Extensions of First-Order Logic and Datalog-Like Languages"; Proceedings of the Fourth Symposium on Logic in Computer Science, </booktitle> <year> 1989, </year> <pages> 71-79. </pages>
Reference-contexts: In other words, without total orderings these classes of languages are strictly less powerful than PTIME. Although database domains all have built-in total orderings (e.g., the lexicographic ordering), the restriction at least indicates that these classes do not completely capture PTIME computability. Abiteboul and Vianu <ref> [2] </ref> recently studied three categories of database query and update languages: fixpoint extensions of first-order logic, extensions to datalog, and procedural languages with the while-looping construct and a with-new construct that is capable of inventing arbitrary domain values. <p> The nondeterministic nature of the bounded-iteration construct, just like the addition of witness operator to fixpoint logic and the assignment of nondeterministic rule firing semantics to datalog programs, is essential in achieving order-independence. As observed in <ref> [2] </ref>, the role of nondeter-minism in database languages deserves special attention. Order-independent PTIME database transformations are very naturally expressible with a nondeterministic language, because they are "inherently nondeterministic": their computation requires running through elements of input relations, but ordering does not matter.
Reference: [3] <author> Aho, A., Ullman, J., </author> <booktitle> "Universality of Data Retrieval Languages"; Proceedings of the Sixth ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1979, </year> <pages> 110-117. </pages>
Reference-contexts: Intuitively, the bounded-iteration construct is less complex than recursion, which on one hand restricts the expressiveness of transactions, but on the other hand reduces the complexity of computation and reasoning with transactions [11]. The bounded-iteration construct was first studied by Aho and Ullman <ref> [3] </ref>. They showed that, assuming the execution is parallel, the bounded-iteration construct has first-order expressive power. If the execution is not parallel however, then the construct is more powerful than first-order but they did not provide precise characterizations.
Reference: [4] <author> Chandra, A., </author> <booktitle> "Programming Primitives for Database Languages"; Proceedings of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1981, </year> <pages> 50-62. </pages>
Reference-contexts: A special case of bounded-iteration, called bounded-looping, where the dummy tuple variable cannot be referred to in the body of the iteration, is more expressive than fixpoint logic <ref> [4] </ref>. Query languages have been the subject of research ever since the introduction of the relational model [5]. The problem of finding natural language constructs that characterize exactly the PTIME expressive power was first investigated in [6]. <p> The example indicates that iterative transactions can compute fixpoints. In fact, it has been shown that a special case of iterative transactions, called bounded-looping, which are those iterative transactions where cursors cannot be referred to in the body of the iteration, is strictly more powerful than fixpoint logic <ref> [4] </ref>. Moreover, the transaction in Example 2 below computes a query that compares the sizes of two relations R 1 and R 2 . A restricted version of it, which tests if the two relations have equal size, is known to be not expressible with either bounded-looping or while-looping [5].
Reference: [5] <author> Chandra, A., </author> <booktitle> "Theory of Database Queries"; Proceedings of the Seventh ACM Symposium on Principles of Database Systems, </booktitle> <year> 1988, </year> <pages> 1-9. </pages>
Reference-contexts: Database programs differ from other types of computer programs in the sense that they are dominated by data retrieval and manipulation tasks rather than by complex computations. Just like the design of query languages has been focused on what sets of data can be retrieved <ref> [5] </ref>, the design of transaction languages should be focused on what updates can be performed. Another requirement of database programming is the ability to reason about the effect of program executions on the database semantics expressed as integrity constraints. <p> It also provides a formal basis for other aspects of database programming, such as transaction verification, optimization, and synthesis [1, 11, 13]. The above concern for balance is reflected in the continuous effort in searching for natural language constructs that express efficient classes of queries and updates (see <ref> [5] </ref> for a survey), in particular the class of PTIME computable queries and updates. The popularity of constructs such as bounded-iteration foreach x in Rjp do t od over constructs like recursion in database programming also indicates the importance of the above-mentioned balance. <p> A special case of bounded-iteration, called bounded-looping, where the dummy tuple variable cannot be referred to in the body of the iteration, is more expressive than fixpoint logic [4]. Query languages have been the subject of research ever since the introduction of the relational model <ref> [5] </ref>. The problem of finding natural language constructs that characterize exactly the PTIME expressive power was first investigated in [6]. Immerman 2 and Vardi discovered independently that fixpoint logic expresses the set of PTIME computable queries in databases equipped with total orderings [8, 16]. <p> Moreover, the transaction in Example 2 below computes a query that compares the sizes of two relations R 1 and R 2 . A restricted version of it, which tests if the two relations have equal size, is known to be not expressible with either bounded-looping or while-looping <ref> [5] </ref>. The example shows that iterative transactions can "count", at least up to any polynomial of the size of the database. Example 2 After executing the transaction below at state I, D 1 is nonempty if and only if jR 1 j &gt; jR 2 j at I.
Reference: [6] <author> Chandra, A., Harel, D., </author> <title> "Structure and Complexity of Relational Queries"; Journal of Computer and System Sciences 25, </title> <month> August </month> <year> 1982, </year> <pages> 99-128. </pages>
Reference-contexts: Query languages have been the subject of research ever since the introduction of the relational model [5]. The problem of finding natural language constructs that characterize exactly the PTIME expressive power was first investigated in <ref> [6] </ref>. Immerman 2 and Vardi discovered independently that fixpoint logic expresses the set of PTIME computable queries in databases equipped with total orderings [8, 16]. <p> The subset of (safe) prolog programs [14] without negation on defined relations was shown in [10] to also express PTIME computable queries on totally ordered databases. This result can be directly generalized to (safe) stratified logic programs. It was also shown in <ref> [6, 9] </ref> that the requirement for total orderings is necessary for these languages. In other words, without total orderings these classes of languages are strictly less powerful than PTIME. <p> Because relational algebra queries can always be flattened to a sequence of single operations by introducing temporary relations, it is obvious that to express first-order updates, first-order transactions with iteration depth no more than 2 suffice. From the strictness of the first-order hierarchy <ref> [6] </ref>, we may derive the strictness of the depth hierarchy of first-order transactions: Theorem 12 For every n &gt; 0, there exists a first-order transaction of depth n that is not equivalent to any first-order transactions of depth less than n.
Reference: [7] <author> Hull, R., Su, J., </author> <title> "Untyped Sets, Invention, </title> <booktitle> and Computable Queries"; Proceedings of the Eighth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1989, </year> <pages> 347-359. </pages>
Reference-contexts: If t is deterministic, then the update it computes becomes PTIME computable. We prove the other direction of the theorem by simulating order-independent Turing Machines with safe iterative transactions. An order-independent Turing Machine M is a Turing Machine that operates in two stages <ref> [7] </ref>. For any input relation I (which is a bag of non-blank tape symbols), M encodes I as a tape string in the first stage, and executes according to the transition relation in the second stage until a final state is reached.
Reference: [8] <author> Immerman, N., </author> <title> "Relational Queries Computable in Polynomial Time"; Information and Control 68, </title> <booktitle> 1986, </booktitle> <pages> 86-104. </pages>
Reference-contexts: The problem of finding natural language constructs that characterize exactly the PTIME expressive power was first investigated in [6]. Immerman 2 and Vardi discovered independently that fixpoint logic expresses the set of PTIME computable queries in databases equipped with total orderings <ref> [8, 16] </ref>. The subset of (safe) prolog programs [14] without negation on defined relations was shown in [10] to also express PTIME computable queries on totally ordered databases. This result can be directly generalized to (safe) stratified logic programs.
Reference: [9] <author> Kolaitis, P., </author> <title> "The Expressive Power of Stratified Logic Programs"; manuscript, </title> <year> 1987. </year>
Reference-contexts: The subset of (safe) prolog programs [14] without negation on defined relations was shown in [10] to also express PTIME computable queries on totally ordered databases. This result can be directly generalized to (safe) stratified logic programs. It was also shown in <ref> [6, 9] </ref> that the requirement for total orderings is necessary for these languages. In other words, without total orderings these classes of languages are strictly less powerful than PTIME.
Reference: [10] <author> Papadimitriou, C., </author> <title> "A Note on the Expressive Power of prolog"; Bulletin of the European Association for Theoretical Computer Science, </title> <month> June </month> <year> 1985, </year> <pages> 21-23. </pages>
Reference-contexts: Immerman 2 and Vardi discovered independently that fixpoint logic expresses the set of PTIME computable queries in databases equipped with total orderings [8, 16]. The subset of (safe) prolog programs [14] without negation on defined relations was shown in <ref> [10] </ref> to also express PTIME computable queries on totally ordered databases. This result can be directly generalized to (safe) stratified logic programs. It was also shown in [6, 9] that the requirement for total orderings is necessary for these languages.
Reference: [11] <author> Qian, X., </author> <title> "The Deductive Synthesis of Database Transactions"; PhD Dissertation, </title> <type> Technical Report STAN-CS-89-1291, </type> <institution> Department of Computer Science, Stanford University, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: Such understanding helps avoid ad hoc choices and unnecessary limitations in language design. It also provides a formal basis for other aspects of database programming, such as transaction verification, optimization, and synthesis <ref> [1, 11, 13] </ref>. The above concern for balance is reflected in the continuous effort in searching for natural language constructs that express efficient classes of queries and updates (see [5] for a survey), in particular the class of PTIME computable queries and updates. <p> Intuitively, the bounded-iteration construct is less complex than recursion, which on one hand restricts the expressiveness of transactions, but on the other hand reduces the complexity of computation and reasoning with transactions <ref> [11] </ref>. The bounded-iteration construct was first studied by Aho and Ullman [3]. They showed that, assuming the execution is parallel, the bounded-iteration construct has first-order expressive power. If the execution is not parallel however, then the construct is more powerful than first-order but they did not provide precise characterizations. <p> This paper supplies a formal basis for research in other aspects of database programming, such as transaction verification, optimization, and synthesis. We have applied the results here to establish complete proof systems for the verification and deductive synthesis of first-order transactions <ref> [11] </ref>. It could also serve as a guideline in designing database programming languages. Traditionally, language designers in 30 database applications have taken two approaches. One is to start with a general--purpose programming language, such as Modula-2, and add constructs specific to a database environment, such as the bounded iteration [12].
Reference: [12] <author> Schmidt, J.W., Eckhardt, H., Matthes, F., </author> <note> "DBPL Report"; DBPL-Memo 111-88, </note> <institution> Fachbereich Informatik, Johann Wolfgang Goethe-Universitat, Frankfurt, West Germany, </institution> <year> 1988. </year>
Reference-contexts: Almost all database programming languages proposed in the literature use some forms of the bounded-iteration construct as one of the control structures, including for example <ref> [12, 13] </ref>, and several recent commercial extensions of sql. Intuitively, the bounded-iteration construct is less complex than recursion, which on one hand restricts the expressiveness of transactions, but on the other hand reduces the complexity of computation and reasoning with transactions [11]. <p> It could also serve as a guideline in designing database programming languages. Traditionally, language designers in 30 database applications have taken two approaches. One is to start with a general--purpose programming language, such as Modula-2, and add constructs specific to a database environment, such as the bounded iteration <ref> [12] </ref>. For this approach, our results can be applied to justify the addition of new constructs, to gain better understanding of the effect of such addition, and to develop more efficient computation or reasoning techniques for them.
Reference: [13] <author> Sheard, T., Stemple, D., </author> <title> "Automatic Verification of Database Transaction Safety"; ACM Transactions on Database Systems 14:3, </title> <month> September </month> <year> 1989, </year> <pages> 322-368. </pages>
Reference-contexts: Such understanding helps avoid ad hoc choices and unnecessary limitations in language design. It also provides a formal basis for other aspects of database programming, such as transaction verification, optimization, and synthesis <ref> [1, 11, 13] </ref>. The above concern for balance is reflected in the continuous effort in searching for natural language constructs that express efficient classes of queries and updates (see [5] for a survey), in particular the class of PTIME computable queries and updates. <p> Almost all database programming languages proposed in the literature use some forms of the bounded-iteration construct as one of the control structures, including for example <ref> [12, 13] </ref>, and several recent commercial extensions of sql. Intuitively, the bounded-iteration construct is less complex than recursion, which on one hand restricts the expressiveness of transactions, but on the other hand reduces the complexity of computation and reasoning with transactions [11]. <p> Another approach is to start with a primitive set of data manipulation operations, such as insertion and deletion, and add more complex but well-understood constructs, such as the bounded iteration <ref> [13] </ref>. For this approach, our results can be utilized to generalize the types of database programs handled. For example, the update transactions in [13] can be immediately enlarged to the whole class of first-order transactions. <p> to start with a primitive set of data manipulation operations, such as insertion and deletion, and add more complex but well-understood constructs, such as the bounded iteration <ref> [13] </ref>. For this approach, our results can be utilized to generalize the types of database programs handled. For example, the update transactions in [13] can be immediately enlarged to the whole class of first-order transactions. The nature of database programming permits and demands less complex programming languages in order for us to simplify the tasks of data manipulation and formal reasoning.
Reference: [14] <author> Topor, R., Sonenberg, E., </author> <title> "On Domain Independent Databases"; Foundations of Deductive Databases and Logic Programming, </title> <editor> J. Minker (editor), </editor> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1988, </year> <pages> 217-240. </pages>
Reference-contexts: The problem of finding natural language constructs that characterize exactly the PTIME expressive power was first investigated in [6]. Immerman 2 and Vardi discovered independently that fixpoint logic expresses the set of PTIME computable queries in databases equipped with total orderings [8, 16]. The subset of (safe) prolog programs <ref> [14] </ref> without negation on defined relations was shown in [10] to also express PTIME computable queries on totally ordered databases. This result can be directly generalized to (safe) stratified logic programs. It was also shown in [6, 9] that the requirement for total orderings is necessary for these languages.
Reference: [15] <author> Ullman, J., </author> <title> Principles of Database and Knowledge-Base Systems, </title> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: Finally, Table 4 tells us that the parallel-execution semantics further removes write-write dependencies on loop relations. Definition 3 An iterative transaction t is safe if for any conditional-branch statement if p then t 1 else t 2 fi in t, p is a safe first-order boolean query <ref> [15] </ref>; and for any bounded-iteration statement foreach x in Rjp do u od in t, fvjR (v) ^ p [x=v]g is a safe first-order query. 3 10 Definition 4 An iterative transaction is deterministic if its semantics defines a mapping over states. <p> show that conditional branch, connectives, and quantifica-tions are redundant, we utilize the fact that every (safe) first-order update expressed by a first-order transaction can be expressed as a set of relational algebra queries, with a possibly infinite relation as the universe of elements when the first-order update is not safe <ref> [15] </ref>. Every relational algebra query can then be flattened to a sequence of relational algebra operations, each of which is expressible by a (safe) first-order transaction without conditional branch, connectives, or quantifications. 7 Hierarchy of First-Order Transactions There are even closer relationships between first-order updates and first-order transactions.
Reference: [16] <author> Vardi, M., </author> <booktitle> "The Complexity of Relational Query Languages"; Proceedings of the Fourteenth ACM Symposium on Theory of Computing, </booktitle> <year> 1982, </year> <pages> 137-146. 32 </pages>
Reference-contexts: The problem of finding natural language constructs that characterize exactly the PTIME expressive power was first investigated in [6]. Immerman 2 and Vardi discovered independently that fixpoint logic expresses the set of PTIME computable queries in databases equipped with total orderings <ref> [8, 16] </ref>. The subset of (safe) prolog programs [14] without negation on defined relations was shown in [10] to also express PTIME computable queries on totally ordered databases. This result can be directly generalized to (safe) stratified logic programs.
References-found: 16

