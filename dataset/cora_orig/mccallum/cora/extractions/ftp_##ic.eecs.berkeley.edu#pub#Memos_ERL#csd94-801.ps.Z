URL: ftp://ic.eecs.berkeley.edu/pub/Memos_ERL/csd94-801.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~vigyan/publications/index.html
Root-URL: http://www.cs.berkeley.edu
Title: Characterization of Contention in Real Relational Databases  
Author: Vigyan Singhal Alan Jay Smith 
Abstract: Report No. UCB/CSD 94/801 March 21, 1994 Computer Science Division (EECS) University of California Berkeley, California 94720 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agrawal, M. J. Carey, M. Livny. </author> <title> Concurrency Control Performance Modeling: Alternatives and Implications. </title> <journal> ACM Transactions on Database Systems, </journal> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: Another aspect of modeling Read and Write locks is Write-lock acquisition. The issue 9 here is whether Write locks are set on items to be updated when they are first read, or whether such items are Read-locked and later the Read locks are upgraded to Write. <ref> [1] </ref> has studied this assumption and concluded that there is a significant difference in performance between the two cases. Also, different locking algorithms are affected to different degrees by this assumption. User model The user model describes the arrival process of the user transactions at the system. <p> Some studies (for example, [29]) have assumed that Write locks are acquired directly. On the other hand, <ref> [1] </ref> has argued that assuming that Write locks are acquired directly (which they call no lock upgrades assumption) is incorrect, and that performance results are sensitive to this assumption. The no lock upgrades assumption leads to lower contention in both the blocking version and the restart version of locking algorithms. <p> By definition, the values of lockfraction lie between 0 and 1. Static locking is equivalent to assuming a lockfraction of 1 for all locks. On the other hand, assuming that locks are acquired uniformly over the transaction length means that the lockfraction is uniformly distributed over the interval <ref> [0; 1] </ref>. In Figure 5 we plot the distribution of lockfraction for Read and Write locks (the data for the plot appears in Appendix E). We also distinguish between index and data locks. Both the read and write lock acquisitions exhibit considerable skew relative to the uniform distribution assumption.
Reference: [2] <author> R. Bayer, M. Scholnick. </author> <title> Concurrency of Operations on B-trees. </title> <journal> Acta Informatica, </journal> <year> 1977. </year>
Reference-contexts: An example of this is access to B-tree locks where locks can be released and serializability can be maintained at the same time <ref> [2] </ref>. 2.2 Cursor locks We use the term Cursor locks to denote the Read locks which are unlocked before the end of transactions.
Reference: [3] <author> P. A. Bernstein, V. Hadzilacos, N. Goodman. </author> <title> Con-currency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1987. </year>
Reference: [4] <author> P. A. Bernstein, N. Goodman. </author> <title> Concurrency Control in Distributed Database Systems. </title> <journal> Computing Surveys, </journal> <month> June </month> <year> 1981. </year>
Reference: [5] <author> M. Blasgen, J. Gray, M. Mitoma, T. Price. </author> <title> The Convoy Phenomenon. </title> <journal> Operating Systems Review, </journal> <volume> 13(2), </volume> <month> Apr. </month> <year> 1979. </year>
Reference-contexts: A uniform distribution would equally distribute the contention equally over all items and would be the best for system performance. With an increase in skew of the distribution, the items locked more often tend to become bottlenecks (similar to the convoy phenomenon in <ref> [5] </ref>). The knowledge of the skew in real database systems should be useful for future modeling studies; here we present the actual pattern of distribution of all locks over the data and index items in the database.
Reference: [6] <author> W. J. Conover. </author> <title> Practical Nonparametric Statistics. </title> <publisher> John Wiley & Sons, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: -0.0003 0.0063 No Cursor-Read 61559 -0.0502 0.0079 Yes Index Cursor-Write 61559 -0.0269 0.0079 Yes Read-Write 61559 0.1789 0.0079 Yes Non-Root Cursor-Read 61500 -0.0501 0.0079 Yes Index Cursor-Write 61500 -0.0269 0.0079 Yes Read-Write 61500 0.1818 0.0079 Yes Table 3: Spearman test for checking independence between two different lock types. correlation test <ref> [6] </ref>. For each page we have measured three quantities| number of times it is Cursor locked, Read locked and Write locked. In Table 3 we show the measured correlation between all three pairs of these quantities.
Reference: [7] <author> M. J. Carey, S. Krishnamurthy, M. Livny. </author> <title> Load Control for Locking: the "Half and Half" Approach. </title> <booktitle> In Proc. of the 9th ACM Symp. on Principles of Database Systems, </booktitle> <address> Nashville, Tennessee, </address> <year> 1990. </year>
Reference-contexts: This would suggest a load control policy which is based solely on the number of active transactions, and ignores the number of transactions blocked for locks. Such a policy increases the MPL under high contention levels and is likely to make things worse. See <ref> [26, 7] </ref> for a discussion of load control policies. 4 Concurrency control modeling In this section we describe the generic concurrency control model used in most concur-rency control analyses, and note also the various assumptions made in such modeling.
Reference: [8] <author> M. J. Carey, M. Livny. </author> <title> Distributed Concurrency Control Performance: A Study of Algorithms, Distribution and Replication. </title> <booktitle> In Proc. of the 14th Intl. Conf. on Very Large Database Systems, </booktitle> <address> Los Angeles, California, </address> <year> 1988. </year>
Reference-contexts: The models also include the CPU service discipline, the number of CPUs for multiprocessors and the CPU configuration for distributed systems. With the growing interest in distributed database systems, varying the system model configuration and studying its effects on concurrency control performance has become a popular area of research <ref> [36, 8] </ref>. A few studies have not modeled the system resources at all. They assume that the rate of processing for an individual transaction remains constant independent of the multiprogramming level. This is equivalent to assuming infinite system resources.
Reference: [9] <author> M. J. Carey, M. Stonebraker. </author> <title> The Performance of Concurrency Control Algorithms for Database Management Systems. </title> <booktitle> In Proc. of the 10th Intl. Conf. on Very Large Database Systems, </booktitle> <address> Singapore, </address> <year> 1984. </year>
Reference-contexts: In concurrency control modeling studies, typically, a database is modeled as a collection of fixed size data items. Data items are grouped into granules to form units of access and concurrency control. With the exception of studies analyzing effects of granularity on concurrency control performance <ref> [9, 28] </ref>, one granule usually comprises one data item, and is the unit of I/O access or concurrency control. <p> Also, different locking algorithms are affected to different degrees by this assumption. User model The user model describes the arrival process of the user transactions at the system. The arrival process is generally modeled either as an open system <ref> [9] </ref> (invariably as an exponential inter-arrival distribution) or as a closed system [33] where the users circulate through the system and resubmit transactions after the previous ones are executed. The users' transactions may be batch-type (non-interactive) or interactive. <p> Given the wide swings between positive and negative correlations, assuming no correlation is probably a reasonable assumption for most studies. 6.3 Transaction classes Transaction classes refer to the different kinds of transaction applications running on the system. Most studies have used only one transaction class. <ref> [9] </ref> is one of the few studies that uses multiple transaction classes| a mix of short transactions with random access and higher probability of write with long transactions doing sequential access with a smaller probability of write.
Reference: [10] <author> C. J. Date. </author> <title> An Introduction to Database Systems, Vol. II. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1987. </year>
Reference-contexts: The locking behavior we have just described corresponds to isolation level 3 1 as described in <ref> [10] </ref>. The disadvantage of this 1 Isolation levels have been defined in [10] as the degrees of interference transactions can tolerate; higher levels provide higher isolation but lower concurrency. Level 1 means that transactions cannot update any uncommitted changes by other transactions. <p> The locking behavior we have just described corresponds to isolation level 3 1 as described in <ref> [10] </ref>. The disadvantage of this 1 Isolation levels have been defined in [10] as the degrees of interference transactions can tolerate; higher levels provide higher isolation but lower concurrency. Level 1 means that transactions cannot update any uncommitted changes by other transactions. Level 2 prevents transactions from reading any uncommitted changes. <p> Level 4 does not allow a transaction to change a record which another transaction has seen. 2 level is that it allows non-serializable behavior of transactions. As [13] has shown, two-phase locking (which corresponds to isolation level 4 of <ref> [10] </ref>)) is a necessary and sufficient condition for serializability if transactions are allowed to access data in any arbitrary order. However, in most applications, the access order to the data has some restrictions and releasing some locks before end of transaction may also be sufficient for serializability. <p> Update locks do not conflict with Read locks, but conflict with each other and with Write locks. The reason for having Update locks, instead of directly upgrading Read locks, is to avoid possible future deadlocks at the cost of higher contention <ref> [10] </ref>. The performance tradeoffs of Read locks vs Upgrade locks are not obvious and, to our knowledge, such tradeoffs have never been studied in the literature. Since the functionality provided by Update locks is identical to Read locks, for this report we have mapped all Update locks to Read locks.
Reference: [11] <author> A. Dan, D. M. Dias, P. S. Yu. </author> <title> The Effect of Skewed Data Access on Buffer Hits and Data Contention in a Data Sharing Environment. </title> <booktitle> In Proc. of the 16th Intl. Conf. on Very Large Database Systems, </booktitle> <address> Bris-bane, Australia, </address> <year> 1990. </year>
Reference-contexts: The access pattern of the data items has often been modeled as being uniform over the entire database. To model non-uniform access some models have used a 80-20 or a 50-5 <ref> [11] </ref> access behavior. Note that a b-c access behavior means that b% of the accesses go to c% of the data items.
Reference: [12] <author> C. J. Date, C. J. White. </author> <title> A Guide to DB2: A User's Guide to the IBM product IBM DATABASE 2 and its Major Companion Products, 4th Ed. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1993. </year>
Reference-contexts: The traces studied are trace segments containing contiguous trace information, without any breaks in the tracing period, collected from multiprocessor shared-memory (centralized) systems. The database management system at all three sites was DB2, IBM's relational database management system for IBM 3090 mainframes <ref> [12] </ref>. While these three traces may not completely represent the entire spectrum of transaction processing applications, our report still provides a good characterization of locking behavior in three very different transaction processing environments. To our knowledge, no other work in the published literature covers such a varied workload.
Reference: [13] <author> K. P. Eswaran, J. N. Gray, R. A. Lorie, I. L. Traiger. </author> <title> The Notions of Consistency and Predicate Locks in a Data Base System. </title> <journal> Communications of the ACM, </journal> <month> Nov. </month> <year> 1976. </year>
Reference-contexts: Level 3 does not allow a transaction to change a record on which another transaction holds a Read lock. Level 4 does not allow a transaction to change a record which another transaction has seen. 2 level is that it allows non-serializable behavior of transactions. As <ref> [13] </ref> has shown, two-phase locking (which corresponds to isolation level 4 of [10])) is a necessary and sufficient condition for serializability if transactions are allowed to access data in any arbitrary order.
Reference: [14] <author> P. A. Franaszek, J. T. Robinson, A. Thomasian. </author> <title> Wait Depth Limited Concurrency Control. </title> <booktitle> In Proc. of the 7th Intl. Conf. on Data Engineering, </booktitle> <address> Kobe, Japan, </address> <year> 1991. </year>
Reference: [15] <author> J. N. Gray, R. A. Lorie, G. R. Putzolu, I. L. Traiger. </author> <title> Granularity of Locks and degrees of Consistency in a Large Shared Data Base. In Modeling in Data Base Management Systems, </title> <publisher> Elsevier North-Holland, </publisher> <address> New York, </address> <year> 1976. </year>
Reference-contexts: In all cases, however, Write locks are never released before the end of transaction. This may be for two reasons| greater semantic consistency (otherwise transactions may see changes in data if they read the same data after they have written it) and also to avoid cascading aborts <ref> [15] </ref>. The locking behavior we have just described corresponds to isolation level 3 1 as described in [10]. The disadvantage of this 1 Isolation levels have been defined in [10] as the degrees of interference transactions can tolerate; higher levels provide higher isolation but lower concurrency.
Reference: [16] <author> T. Haerder, A. Reuter. </author> <title> Principles of Transaction-Oriented Database Recovery. </title> <journal> Computing Surveys, </journal> <month> Dec. </month> <year> 1983. </year>
Reference-contexts: We discuss the concept of transactions (as defined by <ref> [16] </ref>) in Appendix A. In there, we also describe the various alternatives one has in implementing concurrency control in databases| locking (with blocking, and with restarts), optimistic concurrency control (OCC) and timestamping.
Reference: [17] <author> P. Hawthorn, M. Stonebraker. </author> <title> Performance Analysis of a Relational Data Base Management System. </title> <booktitle> In Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <address> Boston, Massachusetts, </address> <year> 1979. </year>
Reference-contexts: There have been a few studies of database systems using traces. Some have addressed the issue of database buffer management e.g. [30, 27, 20] studied IMS, [34] studied a CODASYL system, and <ref> [17] </ref> has analyzed reference behavior in INGRES, a relational database system. These studies, however, have not looked at the issue of concurrency control. Studying concurrency control requires locking activity characteristics (both lock and unlock events), and information about transaction boundaries.
Reference: [18] <institution> IBM Corp. IBM Database 2: System Planning and Administration Guide, SC26-4085-3, IBM Corporation, </institution> <address> White Plains, New York, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: The description of the relevant hardware and software configurations of the three sites appears in Table 1. Two of the traces, bank and transport have been traced using the IBM DB2 GTF tracing facility <ref> [18] </ref>. The process of gathering these traces and a detailed description of the traced events appears in [35]. The phone trace has been gathered using a new and much more efficient tracing package [24], discussed further below.
Reference: [19] <author> T. Johnson, D. Shasha. </author> <title> A Framework for the Performance Analysis of Concurrent B-Tree Algorithms. </title> <booktitle> In Proc. of 9th Symposium on Principles of Database Systems, </booktitle> <year> 1990. </year>
Reference-contexts: Most concurrency control performance studies have ignored the contention for index locks, although some recent studies have considered this issue specifically <ref> [19, 31] </ref>. We do not know of any study which has considered the performance of both index and data locking simultaneously. Because of the high use of index locks, they have the potential to cause significant performance problems.
Reference: [20] <author> J. P. Kearns, S. DeFazio. </author> <title> Diversity in Database Reference Behavior. Performance Evaluation Review, </title> <month> May </month> <year> 1989. </year>
Reference-contexts: There have been a few studies of database systems using traces. Some have addressed the issue of database buffer management e.g. <ref> [30, 27, 20] </ref> studied IMS, [34] studied a CODASYL system, and [17] has analyzed reference behavior in INGRES, a relational database system. These studies, however, have not looked at the issue of concurrency control.
Reference: [21] <author> L. Kleinrock, </author> <title> Queueing Systems, Vols. I and II, </title> <address> Wi-ley, </address> <year> 1975. </year>
Reference-contexts: The modeling of transaction lengths is very important. While the mean of transaction lengths is an important parameter, the variation of the transaction lengths is also important, since it is well known in queueing systems that flow times increase with service time variance as well as mean <ref> [21] </ref>. System model The system model captures the relevant characteristics of the system design (both hardware and software), including the physical resources (CPUs and disks), their performance parameters, and their associated schedules.
Reference: [22] <author> H. T. Kung, J. T. Robinson. </author> <title> On Optimistic Methods for Concurrency Control. </title> <journal> ACM Transactions on Database Systems, </journal> <month> June </month> <year> 1981. </year>
Reference: [23] <author> H. J. Larson. </author> <title> Introduction to Probability Theory and Statistical Inference. </title> <publisher> John Wiley & Sons, </publisher> <address> New York, </address> <year> 1982. </year>
Reference-contexts: Since a few researchers have used exponential and gamma distributions to model transaction lengths, we have also plotted both the exponential fits and the gamma distribution function 2 fits. Both these fits 3 have been generated using the method of Maximum Likelihood <ref> [23] </ref>, using the equations derived in Appendix H. Our analysis of the statistical goodness of fit (in Appendix D) shows that both fits are poor.
Reference: [24] <institution> Ted Messenger, IBM Almaden Research Center. </institution> <type> Personal Communication, </type> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: We call them Cursor locks because usually the purpose of these locks is to guarantee the stability of the cursor pointer on the relation while data is being accessed from the relation <ref> [24] </ref>. These locks are held only while the object is being accessed. The non-Cursor locks are simply referred to as Read or Write locks. <p> The process of gathering these traces and a detailed description of the traced events appears in [35]. The phone trace has been gathered using a new and much more efficient tracing package <ref> [24] </ref>, discussed further below. The DB2 tracing facility is able to activate tracing for any subset of fourteen different event-classes, for example SQL events, I/O events, and Lock events. Each event class causes trace records to be logged for a number of different system events. <p> Although this may reflect on the system MPL, we have no reason to believe that it affects the mix of the transactions in the workload substantially. The phone trace has been logged using a very efficient new tracing package which incurs an overhead of about 2%-5% <ref> [24] </ref>. 6 In fact we have been told that the users of the database system did not perceive any change in the system performance. Clearly this eliminates the possibility of the second side-effect we just discussed. <p> Long transactions generally have a very dif 20 ferent nature than short transactions| they access data in a sequential fashion, usually run at a low priority, and are usually batch submissions <ref> [24] </ref>. All this shows that it may be very difficult to accurately model Cursor locktimes, without resorting to using trace-driven simulations.
Reference: [25] <author> R. J. T. Morris, W. S. Wong. </author> <title> Performance Analysis of Locking and Optimistic Concurrency Control Algorithms. Performance Evaluation, </title> <month> May </month> <year> 1985. </year>
Reference-contexts: For Cursor locks, both start and end points need to be known; for Read and Write locks, only start times are necessary, since both are released only at the end of the transaction. In the literature, locktimes have not been explicitly modeled. In the static locking studies <ref> [25] </ref> all locks were acquired the beginning of transactions and thus the locktimes are identical to transaction lengths. However, many researchers have argued that static locking models are unrealistic because at the start of a transaction one may not know which pages are going to be locked.
Reference: [26] <author> A. Moenkeberg, G. Weikum. </author> <title> Conflict-driven Load Control for the Avoidance of Data-Contention Thrashing. </title> <booktitle> In Proc. of the 7th Intl. Conf. on Data Engineering, </booktitle> <address> Kobe, Japan, </address> <year> 1991. </year> <month> 33 </month>
Reference-contexts: This would suggest a load control policy which is based solely on the number of active transactions, and ignores the number of transactions blocked for locks. Such a policy increases the MPL under high contention levels and is likely to make things worse. See <ref> [26, 7] </ref> for a discussion of load control policies. 4 Concurrency control modeling In this section we describe the generic concurrency control model used in most concur-rency control analyses, and note also the various assumptions made in such modeling.
Reference: [27] <author> J. Rodriguez-Rosell. </author> <title> Empirical Data Reference Be--havior in Data Base Systems. </title> <booktitle> IEEE Computer, </booktitle> <month> Nov. </month> <year> 1976. </year>
Reference-contexts: There have been a few studies of database systems using traces. Some have addressed the issue of database buffer management e.g. <ref> [30, 27, 20] </ref> studied IMS, [34] studied a CODASYL system, and [17] has analyzed reference behavior in INGRES, a relational database system. These studies, however, have not looked at the issue of concurrency control.
Reference: [28] <author> D. R. Ries, M. R. Stonebraker. </author> <title> Locking Granularity Revisited. </title> <journal> ACM Transactions on Database Systems, </journal> <month> June </month> <year> 1979. </year>
Reference-contexts: In concurrency control modeling studies, typically, a database is modeled as a collection of fixed size data items. Data items are grouped into granules to form units of access and concurrency control. With the exception of studies analyzing effects of granularity on concurrency control performance <ref> [9, 28] </ref>, one granule usually comprises one data item, and is the unit of I/O access or concurrency control.
Reference: [29] <author> I. K. Ryu, A. Thomasian. </author> <title> Analysis of Database Performance with Dynamic Locking. </title> <journal> Journal of the ACM, </journal> <month> July </month> <year> 1990. </year>
Reference-contexts: In the table, most Cursor-Write pairs have a significant negative correlation, which makes Cursor-Write contention less probable than for the independence assumption. 5.4 Write-lock assumption This "write lock" assumption addresses the issue of whether Write locks are acquired directly or are upgraded from Read locks. Some studies (for example, <ref> [29] </ref>) have assumed that Write locks are acquired directly. On the other hand, [1] has argued that assuming that Write locks are acquired directly (which they call no lock upgrades assumption) is incorrect, and that performance results are sensitive to this assumption.
Reference: [30] <author> A. J. Smith. </author> <title> Sequentiality and Prefetching in Data Base Systems. </title> <journal> ACM Transactions on Database Systems, </journal> <month> September </month> <year> 1978. </year>
Reference-contexts: There have been a few studies of database systems using traces. Some have addressed the issue of database buffer management e.g. <ref> [30, 27, 20] </ref> studied IMS, [34] studied a CODASYL system, and [17] has analyzed reference behavior in INGRES, a relational database system. These studies, however, have not looked at the issue of concurrency control.
Reference: [31] <author> V. Srinivasan, M. J. Carey. </author> <title> Performance of B-Tree Concurrency Control Algorithms. </title> <booktitle> In Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <address> Denver, Colorado, </address> <year> 1991. </year>
Reference-contexts: Most concurrency control performance studies have ignored the contention for index locks, although some recent studies have considered this issue specifically <ref> [19, 31] </ref>. We do not know of any study which has considered the performance of both index and data locking simultaneously. Because of the high use of index locks, they have the potential to cause significant performance problems. <p> To model non-uniform access some models have used a 80-20 or a 50-5 [11] access behavior. Note that a b-c access behavior means that b% of the accesses go to c% of the data items. Although concurrency control performance for indexes has been studied in isolation <ref> [31] </ref>, we don't know of a study that has analyzed the effects of index and data locking in the same framework.
Reference: [32] <author> A. Thomasian. </author> <title> Performance Limits of Two-Phase Locking. </title> <booktitle> In Proc. of the 7th Intl. Conf. on Data Engineering, </booktitle> <address> Kobe, Japan, </address> <year> 1991. </year>
Reference-contexts: Further, even the distribution of transaction lengths is important, since the system performance is sensitive to the second and third moments of transaction lengths <ref> [32] </ref>. This is because short transactions can be blocked for long periods by long transactions holding necessary locks. The transaction length distribution affects the relative performance of the various con-currency control schemes as well as their absolute performance.
Reference: [33] <author> Y. C. Tay, N. Goodman, R. Suri. </author> <title> Locking Performance in Centralized Databases. </title> <journal> ACM Transactions on Database Systems, </journal> <month> Dec. </month> <year> 1985. </year>
Reference-contexts: User model The user model describes the arrival process of the user transactions at the system. The arrival process is generally modeled either as an open system [9] (invariably as an exponential inter-arrival distribution) or as a closed system <ref> [33] </ref> where the users circulate through the system and resubmit transactions after the previous ones are executed. The users' transactions may be batch-type (non-interactive) or interactive.
Reference: [34] <author> A. I. Verkamo. </author> <title> Empirical Results on Locality in Database Referencing. </title> <booktitle> In Proc. of the ACM SIG-METRICS Conf., </booktitle> <address> Texas, Austin, </address> <year> 1985. </year>
Reference-contexts: There have been a few studies of database systems using traces. Some have addressed the issue of database buffer management e.g. [30, 27, 20] studied IMS, <ref> [34] </ref> studied a CODASYL system, and [17] has analyzed reference behavior in INGRES, a relational database system. These studies, however, have not looked at the issue of concurrency control. Studying concurrency control requires locking activity characteristics (both lock and unlock events), and information about transaction boundaries.
Reference: [35] <author> S. Viavant. </author> <title> Collection, Reduction and Analysis of DB2 Trace Data. M. S. </title> <type> Report, </type> <institution> University of Cali-fornia, Berkeley, California, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: Two of the traces, bank and transport have been traced using the IBM DB2 GTF tracing facility [18]. The process of gathering these traces and a detailed description of the traced events appears in <ref> [35] </ref>. The phone trace has been gathered using a new and much more efficient tracing package [24], discussed further below. The DB2 tracing facility is able to activate tracing for any subset of fourteen different event-classes, for example SQL events, I/O events, and Lock events. <p> In fact, lock-waits represent a performance index, an output, for concurrency control studies. We obtained bank and transport traces using the GTF tracing package, which imposes a substantial system overhead (of the order of 100%-200% is reported in <ref> [35] </ref>). GTF logs an enormous amount of information per trace entry, much of which (about 88% by volume) is not used for our analysis. This overhead may affect us in two ways. It may affect the validity of the durations of the transactions.
Reference: [36] <author> Y. Wang, L. A. Rowe. </author> <title> Cache Consistency and Con-currency Control in a Client/server DBMS Architecture. </title> <booktitle> In Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <address> Denver, Colorado, </address> <year> 1991. </year>
Reference-contexts: The models also include the CPU service discipline, the number of CPUs for multiprocessors and the CPU configuration for distributed systems. With the growing interest in distributed database systems, varying the system model configuration and studying its effects on concurrency control performance has become a popular area of research <ref> [36, 8] </ref>. A few studies have not modeled the system resources at all. They assume that the rate of processing for an individual transaction remains constant independent of the multiprogramming level. This is equivalent to assuming infinite system resources.
Reference: [37] <author> P. S. Yu, D. W. Cornell, D. M. Dias, A. Thomasian. </author> <title> On Coupling Partitioned Database Systems. </title> <booktitle> In Proc. of the 6th Ann. Symp. on Distributed Computing, </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: These studies, however, have not looked at the issue of concurrency control. Studying concurrency control requires locking activity characteristics (both lock and unlock events), and information about transaction boundaries. There has also been one group of researchers <ref> [38, 39, 37, 40] </ref> who have used locking traces from database systems for concurrency control studies. However, the thrust of their research has not been to do an extensive data characterization, and they have provided limited characterization of the transaction workloads they have used.
Reference: [38] <author> P. S. Yu, D. M. Dias, J. T. Robinson, B. R. Iyer, D. W. Cornell. </author> <title> Distributed Concurrency Control for Data Sharing. </title> <booktitle> In Proc. of the Conf. on Management and Performance Evaluation of Computer Systems, </booktitle> <year> 1985. </year>
Reference-contexts: These studies, however, have not looked at the issue of concurrency control. Studying concurrency control requires locking activity characteristics (both lock and unlock events), and information about transaction boundaries. There has also been one group of researchers <ref> [38, 39, 37, 40] </ref> who have used locking traces from database systems for concurrency control studies. However, the thrust of their research has not been to do an extensive data characterization, and they have provided limited characterization of the transaction workloads they have used.
Reference: [39] <author> P. S. Yu, D. M. Dias, J. T. Robinson, B. R. Iyer, D. W. Cornell. </author> <title> Modeling of Centralized Concurrency Control in a Multi-System Environment. </title> <booktitle> In Proc. of the ACM SIGMETRICS Conf., </booktitle> <address> Texas, Austin, </address> <year> 1985. </year>
Reference-contexts: These studies, however, have not looked at the issue of concurrency control. Studying concurrency control requires locking activity characteristics (both lock and unlock events), and information about transaction boundaries. There has also been one group of researchers <ref> [38, 39, 37, 40] </ref> who have used locking traces from database systems for concurrency control studies. However, the thrust of their research has not been to do an extensive data characterization, and they have provided limited characterization of the transaction workloads they have used.
Reference: [40] <author> P. S. Yu, D. M. Dias, J. T. Robinson, B. R. Iyer, D. W. Cornell. </author> <title> On Coupling Multi-Systems Through Data Sharing. </title> <booktitle> Proceedings of the IEEE, </booktitle> <month> May </month> <year> 1987. </year> <month> 34 </month>
Reference-contexts: These studies, however, have not looked at the issue of concurrency control. Studying concurrency control requires locking activity characteristics (both lock and unlock events), and information about transaction boundaries. There has also been one group of researchers <ref> [38, 39, 37, 40] </ref> who have used locking traces from database systems for concurrency control studies. However, the thrust of their research has not been to do an extensive data characterization, and they have provided limited characterization of the transaction workloads they have used.
References-found: 40

