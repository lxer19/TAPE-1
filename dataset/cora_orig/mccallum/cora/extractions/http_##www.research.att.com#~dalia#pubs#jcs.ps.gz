URL: http://www.research.att.com/~dalia/pubs/jcs.ps.gz
Refering-URL: http://www.research.att.com/~dalia/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fdalia,reiterg@research.att.com  
Title: A High-Throughput Secure Reliable Multicast Protocol  
Author: Dahlia Malkhi Michael Reiter 
Address: Murray Hill, New Jersey, USA  
Affiliation: AT&T Labs|Research,  
Abstract: A (secure) reliable multicast protocol enables a process to multicast a message to a group of processes in a way that ensures that all honest destination-group members receive the same message, even if some group members and the multicast initiator are maliciously faulty. Reliable multicast has been shown to be useful for building multiparty cryptographic protocols and secure distributed services. We present a high-throughput reliable multicast protocol that tolerates the malicious behavior of up to fewer than one-third of the group members. Our protocol achieves high-throughput using a novel technique for chaining multicasts, whereby the cost of ensuring agreement on each multicast message is amortized over many multicasts. This is coupled with a novel flow-control mechanism that yields low multicast latency. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Atkins, M. Graff, A. K. Lenstra, and P. C. Leyland. </author> <title> The magic words are squeamish ossifrage. </title> <booktitle> In Proceedings of Asiacrypt '94, </booktitle> <pages> pages 219-229, </pages> <year> 1994. </year>
Reference-contexts: These numbers are largely independent of the size of the message being signed, 1 A 300-bit RSA modulus should be secure for roughly an hour against an adversary with the computational resources used in the factorization of RSA-129 <ref> [1] </ref> (A. Odlyzko, private communication, May 1994).
Reference: [2] <author> D. Bayer, S. Haber and W.S. Stornetta. </author> <title> Improving the efficiency and reliability of digital time-stamping. </title> <journal> Journal of Cryptology 3(2) </journal> <pages> 99-111, </pages> <year> 1991. </year>
Reference-contexts: This method of chaining acknowledgements was influenced by prior work in benignly fault-tolerant systems, notably the Trans-Total [10] and Transis [5] systems. Chaining (or linking) was also used in <ref> [2] </ref> for timestamping documents by establishing their place among a sequence of similarly timestamped documents. The second principle behind our protocol is intended to limit the latency of multicasts given this chaining technique.
Reference: [3] <author> K. P. Birman. </author> <title> The process group approach to reliable distributed computing. </title> <journal> Communications of the ACM 36(12) </journal> <pages> 37-53, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: In particular, using techniques similar to those of [12], our protocol naturally extends to support a virtually synchronous communication environment, which has been shown to simplify the development of distributed programs <ref> [3] </ref>. These extensions also support more effective failure handling and garbage collection than we describe here. The rest of this paper is structured as follows. In Section 2 we describe our assumptions about the system. In Section 3 we describe the semantics of our protocol.
Reference: [4] <author> G. Bracha and S. Toueg. </author> <title> Asynchronous consensus and broadcast protocols. </title> <journal> Journal of the ACM 32(4) </journal> <pages> 824-840, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: The main contributions of this protocol are two mech-anisms for maximizing multicast throughput (i.e., deliveries per second) and for maintaining low multicast latency (i.e., the time between multicast initiation and its delivery). These mechanisms significantly improve the message complexity of previously known techniques for reliable multi-cast (e.g., <ref> [4, 12] </ref>) in the case of no failures, which should be the common case in most systems.
Reference: [5] <author> D. Dolev and D. Malki. </author> <title> The Transis approach to high availability cluster communication. </title> <journal> Communications of the ACM 39(4) </journal> <pages> 64-70, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: This method of chaining acknowledgements was influenced by prior work in benignly fault-tolerant systems, notably the Trans-Total [10] and Transis <ref> [5] </ref> systems. Chaining (or linking) was also used in [2] for timestamping documents by establishing their place among a sequence of similarly timestamped documents. The second principle behind our protocol is intended to limit the latency of multicasts given this chaining technique. <p> We nevertheless build another reliable multicast protocol over it in Section 5 that offers better performance when no failures occur. The chain multicast protocol takes its name from the technique of acknowledgement chaining that was developed in prior work on benignly fault-tolerant systems such as Trans-Total [10] and Transis <ref> [5] </ref>. We outline this technique in Section 4.1 and describe the protocol in Section 4.2. 4.1. Acknowledgement chaining The principle of acknowledgement chaining works by processes sending messages to the group of processes.
Reference: [6] <author> M. J. Fischer, N. A. Lynch, and M. S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM 32(2) </journal> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: This problem imposes an ordering requirement that is stronger than Source Order, i.e., that honest processes execute the same totally-ordered sequence of multicast deliveries. Due to their stronger properties, neither Byzantine agreement nor atomic multicast is solvable in asynchronous systems (implied by <ref> [6] </ref>), whereas reliable multicast is. 4. Chain multicast In this section, we describe a subprotocol that will be used in our reliable multicast protocol. This protocol, called chain multicast, provides an interface that enables a process to multicast a message to the processes.
Reference: [7] <author> M. K. Franklin and M. Yung. </author> <title> The varieties of secure distributed computation. </title> <booktitle> In Proceedings of Sequences II, Methods in Communications, Security and Computer Science, </booktitle> <pages> pages 392-417, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Reliable multicast has been shown to be useful for constructing multiparty cryptographic protocols that enable systems to operate correctly despite the malicious (Byzantine) behavior of some components <ref> [7] </ref>.
Reference: [8] <author> J. B. Lacy, D. P. Mitchell and W. M. </author> <title> Schell. </title> <booktitle> CryptoLib: Cryptography in software. In Proceedings of the 4th USENIX Security Workshop, </booktitle> <pages> pages 1-17, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: In today's computing environments, signature generation is a costly operation that is typically an order of magnitude slower than authenticated message transmission for most reasonable message sizes. For instance, the generation of an RSA [16] signature on a 75 MHz Sparcstation 20 using the CryptoLib software package <ref> [8] </ref> ranges from roughly 12 milliseconds (ms) for a (insecure) 300-bit RSA modulus, 1 to roughly 33ms for a (somewhat more secure) 512-bit modulus.
Reference: [9] <author> L. Lamport, R. Shostak, and M. Pease. </author> <title> The Byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems 4(3) </journal> <pages> 328-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: The above semantics distinguish the problem we are attempting to solve from other problems studied in the scientific literature on secure and fault-tolerant distributed computing. In particular, our specification is weaker than the well-studied problem of Byzantine agreement <ref> [9] </ref>.
Reference: [10] <author> P. M. Melliar-Smith, L. E. Moser, and V. Agrawala. </author> <title> Broadcast protocols for distributed systems. </title> <journal> IEEE Transactions on Parallel and Distributed Systems 1(1) </journal> <pages> 17-25, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: This method of chaining acknowledgements was influenced by prior work in benignly fault-tolerant systems, notably the Trans-Total <ref> [10] </ref> and Transis [5] systems. Chaining (or linking) was also used in [2] for timestamping documents by establishing their place among a sequence of similarly timestamped documents. The second principle behind our protocol is intended to limit the latency of multicasts given this chaining technique. <p> We nevertheless build another reliable multicast protocol over it in Section 5 that offers better performance when no failures occur. The chain multicast protocol takes its name from the technique of acknowledgement chaining that was developed in prior work on benignly fault-tolerant systems such as Trans-Total <ref> [10] </ref> and Transis [5]. We outline this technique in Section 4.1 and describe the protocol in Section 4.2. 4.1. Acknowledgement chaining The principle of acknowledgement chaining works by processes sending messages to the group of processes.
Reference: [11] <author> L. E. Moser and P. M. Melliar-Smith. </author> <title> Total ordering algorithms for asynchronous Byzantine systems. </title> <booktitle> In Proceedings of the 9th International Workshop on Distributed Algorithms (Lecture Notes in Computer Science 972), </booktitle> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: In contrast, reliable multicast does not require honest processes to R-deliver messages from a faulty process. Reliable multicast is also weaker than atomic (totally-ordered) multicast (e.g., <ref> [11, 12, 13] </ref>). This problem imposes an ordering requirement that is stronger than Source Order, i.e., that honest processes execute the same totally-ordered sequence of multicast deliveries.
Reference: [12] <author> M. K. Reiter. </author> <title> Secure agreement protocols: Reliable and atomic group multicast in Rampart. </title> <booktitle> In Proceedings of the 2nd ACM Conference on Computer and Communications Security, </booktitle> <pages> pages 68-80, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: The main contributions of this protocol are two mech-anisms for maximizing multicast throughput (i.e., deliveries per second) and for maintaining low multicast latency (i.e., the time between multicast initiation and its delivery). These mechanisms significantly improve the message complexity of previously known techniques for reliable multi-cast (e.g., <ref> [4, 12] </ref>) in the case of no failures, which should be the common case in most systems. <p> It is possible, however, to use known techniques to extend our protocol to operate in a dynamic environment in which processes may leave or join the set of destination processes and in which processes may fail and recover. In particular, using techniques similar to those of <ref> [12] </ref>, our protocol naturally extends to support a virtually synchronous communication environment, which has been shown to simplify the development of distributed programs [3]. These extensions also support more effective failure handling and garbage collection than we describe here. The rest of this paper is structured as follows. <p> In contrast, reliable multicast does not require honest processes to R-deliver messages from a faulty process. Reliable multicast is also weaker than atomic (totally-ordered) multicast (e.g., <ref> [11, 12, 13] </ref>). This problem imposes an ordering requirement that is stronger than Source Order, i.e., that honest processes execute the same totally-ordered sequence of multicast deliveries. <p> For more robust treatment of garbage collection, our protocol can be extended by known techniques for removing failed processes from the configuration (e.g., <ref> [12] </ref>). These extensions, however, are beyond the scope of this paper. 4.4 Proof of correctness We now prove that the chain multicast protocol above satisfies Integrity, Agreement, Validity and Source Order (with R-mcast and R-deliver replaced with C-mcast and C-deliver, respectively).
Reference: [13] <author> M. K. Reiter. </author> <title> The Rampart toolkit for building high-integrity services. </title> <booktitle> In Theory and Practice in Distributed Systems (Lecture Notes in Computer Science 938), </booktitle> <pages> pages 99-110, </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: In addition, while here we present our protocol in a way that allows multicasts only from the processes p 0 ; : : : ; p n1 , it is possible to extend the protocol to allow multicasts from outside the destination group (e.g., in the manner of <ref> [13] </ref>). The above semantics distinguish the problem we are attempting to solve from other problems studied in the scientific literature on secure and fault-tolerant distributed computing. In particular, our specification is weaker than the well-studied problem of Byzantine agreement [9]. <p> In contrast, reliable multicast does not require honest processes to R-deliver messages from a faulty process. Reliable multicast is also weaker than atomic (totally-ordered) multicast (e.g., <ref> [11, 12, 13] </ref>). This problem imposes an ordering requirement that is stronger than Source Order, i.e., that honest processes execute the same totally-ordered sequence of multicast deliveries. <p> Odlyzko, private communication, May 1994). A 300-bit modulus should therefore be used in our protocol only if it is changed frequently, as in <ref> [13] </ref>. 10 but still compare poorly to the roughly 1.5ms required for a 2 kilobyte message transmission over a 10Mbit/s Ethernet authenticated using (very secure) message authentication codes on such a platform.
Reference: [14] <author> M. K. Reiter, M. K. Franklin, J. B. Lacy, and R. N. Wright. </author> <title> The key management service. </title> <booktitle> In Proceedings of the 3rd ACM Conference on Computer and Communications Security, </booktitle> <pages> pages 38-47, </pages> <month> March </month> <year> 1996. </year> <note> Revised version to appear in Journal of Computer Security. 13 </note>
Reference-contexts: Reliable multicast has been shown to be useful for constructing multiparty cryptographic protocols that enable systems to operate correctly despite the malicious (Byzantine) behavior of some components [7]. Practical examples of this can be found in , a distributed, penetration-tolerant key management service that we are developing at AT&T <ref> [14] </ref>. makes use of distributed computations to perform key backup, recovery, and other functions in a way that ensures the correctness and availability of these functions, while hiding sensitive information from any sufficiently small coalition of penetrated servers.
Reference: [15] <author> R. L. Rivest. </author> <title> RFC 1321: The MD5 message digest algorithm. </title> <institution> Internet Activities Board, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Thus, for all practical purposes, the digest D (x) uniquely identifies x, and we assume this for the remainder of the paper. Several efficient message digest functions have been proposed (e.g., MD5 <ref> [15] </ref>). B can be viewed as acknowledgements of other messages, i.e., if D (M 0 ) 2 B (and p is honest) then p has received M 0 , and we say that p (directly) acknowledges M 0 .
Reference: [16] <author> R. L. Rivest, A. Shamir, and L. Adleman. </author> <title> A method for obtaining digital signatures and public-key cryptosystems. </title> <journal> Communications of the ACM 21(2) </journal> <pages> 120-126, </pages> <month> February </month> <year> 1978. </year>
Reference-contexts: The novel mechanisms by which we achieve high performance in our protocol are based on two principles. The factor limiting performance in previous, practical reliable multicast protocols is the cost of computing digital signatures (e.g., using RSA <ref> [16] </ref>) on message acknowledgements. Our first principle thus attempts to amortize the cost of computing a digital signature over many multicasts by a technique called acknowledgement chaining. <p> Each process p possesses a private key known only to itself, with which it can digitally sign sets of messages (e.g., <ref> [16] </ref>). A set B signed by p is denoted fBg p . We often use fM g p as an abbreviation for fBg p where M 2 B, i.e., for the signature of a set containing M . <p> In today's computing environments, signature generation is a costly operation that is typically an order of magnitude slower than authenticated message transmission for most reasonable message sizes. For instance, the generation of an RSA <ref> [16] </ref> signature on a 75 MHz Sparcstation 20 using the CryptoLib software package [8] ranges from roughly 12 milliseconds (ms) for a (insecure) 300-bit RSA modulus, 1 to roughly 33ms for a (somewhat more secure) 512-bit modulus.
Reference: [17] <author> V. L. Voydock and S. T. Kent. </author> <title> Security mechanisms in high-level network protocols. </title> <journal> ACM Computing Surveys 15(2) </journal> <pages> 135-171, </pages> <month> June </month> <year> 1983. </year> <month> 14 </month>
Reference-contexts: However, communication is asynchronous, in the sense that there is no known finite bound on message transmission times. The communication channel between each pair of processes is authenticated and protects the integrity of communication (e.g., using well-known cryptographic techniques <ref> [17] </ref>), so that a receiver can tell the channel on which a message is received. Each process p possesses a private key known only to itself, with which it can digitally sign sets of messages (e.g., [16]). A set B signed by p is denoted fBg p .
References-found: 17

