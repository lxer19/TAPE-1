URL: http://www.csl.sri.com/~qian/aas97.ps.gz
Refering-URL: http://www.csl.sri.com/~qian/pubs.html
Root-URL: 
Email: qian@csl.sri.com goldberg@kestrel.edu  
Title: Bounds Analysis by Abstract Interpretation  
Author: Xiaolei Qian Allen Goldberg 
Affiliation: Computer Science Laboratory Kestrel Institute SRI International  
Abstract: A major decision faced by compilers for very-high-level languages is the construction of efficient low-level representations of high-level data abstractions. To support this decision making, compilers have to determine the symbolic bounds and sizes on program variables. We develop a program analysis technique based on abstract interpretation, which performs a variety of bounds analysis of set-theoretic data abstractions automatically and effectively. The technique is easily extensible to other high-level data abstractions, and readily incorporable into compilers for very-high-level languages. Categories and Subject Descriptions: D.1.2[Programming Techniques]: Automatic Programming; D.3.3[Programming Languages]: Language Constructs and Features|Data types and structures; F.3.1[Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs|Mechanical verification General Terms: Algorithms, Design, Languages, Verification Additional Key Words and Phrases: Abstract Interpretation, Bounds Analysis, Compilers, Data Abstraction, Data Refinement, Very-High-Level Languages fl Supported in part by the U.S. Air Force Rome Laboratory under contract F30602-86-C-0026.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ammarguellat, Z., Harrison III, W., </author> <title> "Automatic Recognition of Induction Variables and Recurrence Relations by Abstract Interpretation"; Proceedings of the ACM SIG-PLAN'90 Conference on Programming Language Design and Implementation, </title> <month> June </month> <year> 1990, </year> <pages> 283-295. </pages>
Reference-contexts: It has been applied to applicative languages to perform a variety of analysis tasks, such as strictness analysis in functional programs and mode analysis in logic programs [9]. An example of abstract interpretation applied to imperative languages is given in <ref> [1] </ref>, where induction variables and recurrence relations in 2 loops can be automatically recognized. We develop a program analysis technique that computes the symbolic bounds of set-theoretic data abstractions automatically and effectively. Abstract interpretation [3] is applied to construct a deductive semantics of programs.
Reference: [2] <author> Cousot, P., </author> <title> "Semantic Foundations of Program Analysis"; Program Flow Analysis: Theory and Applications, </title> <editor> S.S. Muchnick and N.D. Jones (editors), </editor> <publisher> Prentice-Hall, </publisher> <year> 1981, </year> <pages> 303-342. </pages>
Reference-contexts: Techniques similar to data flow analysis were developed there for setl, which start from an initial collection of plausible (i.e., typable) relationships and iteratively eliminate those that might be false. Abstract interpretation <ref> [2, 3] </ref> was originally proposed as a general framework for semantically correct program analysis. It has been applied to applicative languages to perform a variety of analysis tasks, such as strictness analysis in functional programs and mode analysis in logic programs [9].
Reference: [3] <author> Cousot, P., Cousot, R., </author> <title> "Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction of Approximations of Fixpoints"; Proceedings of the Fourth ACM Symposium on Principles of Programming Languages, </title> <month> January </month> <year> 1977, </year> <pages> 238-252. </pages>
Reference-contexts: Techniques similar to data flow analysis were developed there for setl, which start from an initial collection of plausible (i.e., typable) relationships and iteratively eliminate those that might be false. Abstract interpretation <ref> [2, 3] </ref> was originally proposed as a general framework for semantically correct program analysis. It has been applied to applicative languages to perform a variety of analysis tasks, such as strictness analysis in functional programs and mode analysis in logic programs [9]. <p> An example of abstract interpretation applied to imperative languages is given in [1], where induction variables and recurrence relations in 2 loops can be automatically recognized. We develop a program analysis technique that computes the symbolic bounds of set-theoretic data abstractions automatically and effectively. Abstract interpretation <ref> [3] </ref> is applied to construct a deductive semantics of programs. Concrete contexts are abstracted into collections of simple facts about program points called bound assertions, and the abstract interpretation serves as a specialized theorem prover or fact gatherer [11] which computes global bounds information. <p> MinEls is the set of unscheduled jobs whose predecessors have all been scheduled. Finally, result is a sequence that accumulates the (partial) schedule. The directed graph representation of the program is shown in Figure 4. 6 3 Semantics Following the Cousots <ref> [3] </ref>, we define the semantic domain Value as the collection of values that program variables can take on; the semantic domain Id g as the collection of program variables in function g; the semantic domain Exp g as the collection of expressions in g, called g-expressions; the semantic domain Environment g <p> An abstract interpretation of g consists of a lattice of abstract contexts over V with bottom f g, and an interpretation function. It is correct if it approximates the static semantics or concrete interpretation of g. According to the Cousots <ref> [3] </ref>, this amounts to the construction of two functions ff and fl such that (ff; fl) forms an adjoined pair of functions: ff ffi fl = identity and fl ffi ff w identity. The abstraction function ff maps concrete contexts to abstract contexts. <p> n g )[f 1 == h ] is contained in = g (c; n g )[f 2 == h ]. 2 However, the least fixpoint of abstract interpretation might not be computable, because the functionals defined by the system of recursive definitions of Section 6.1 are in general not continuous <ref> [3] </ref>. An iterative method can be used to compute an approximation of the least fixpoint, starting with = g (c; n g ) being f g for abstract g-context c and function node n g .
Reference: [4] <author> Goldberg, A., Kotik, G., </author> <title> "Knowledge-Based Programming: An Overview of Data Structure Selection and Control Structure Refinement"; Technical Report KES.U.83.7, </title> <institution> Kestrel Institute, </institution> <month> November </month> <year> 1983. </year>
Reference-contexts: For example, a set can be implemented by a variety of representations|arrays, lists, bit-vectors, hash tables, etc.. A major decision faced by compilers for very-high-level languages is data structure selection, which concerns the construction of efficient low-level representations of high-level data abstractions <ref> [4, 7, 10] </ref>. The most widely used data abstractions in program specifications are the class of set-theoretic data abstractions, such as sets, sequences, and maps.
Reference: [5] <author> Goldberg, A., Smith, D., </author> <title> "Towards a Performance Estimation Assistant"; Technical Report KES.U.86.10, </title> <institution> Kestrel Institute, </institution> <month> November </month> <year> 1986. </year>
Reference-contexts: To properly determine the most efficient representation, an estimate on the relative frequency of operations is needed. Since looping constructs in common programming languages often control the frequency of loop executions by traversing composite data structures, determining bounds on these data structures also provides a basis for frequency estimation <ref> [5] </ref>. The importance of inclusion and membership relationships to automatic data structure selection in very-high-level languages was first recognized by Schwartz [12].
Reference: [6] <author> Hoare, C., </author> <title> "An Axiomatic Basis for Computer Programming"; Communications of the ACM 12:10, </title> <booktitle> 1969, </booktitle> <pages> 576-583. </pages>
Reference-contexts: For a syntactic construct s and a bound assertion p, the abstract interpretation derives a post-condition of p over s <ref> [6] </ref>. Based on the abstract interpretation, we show how various types of bounds analysis can be performed that are of interest to data structure selection. The paper is organized as follows. The syntax and semantics of our programming language are given in Sections 2 and 3 respectively. <p> The interpretation for assignment statements needs further explanation. According to Hoare Logic <ref> [6] </ref>, p is true after v e if p [e=v] is true before the assignment. Assuming that p is true before the assignment, then it is true after the assignment if p ! p [e=v] is true before the assignment.
Reference: [7] <author> Low, J., Rovner, P., </author> <booktitle> "Techniques for the Automatic Selection of Data Structures"; Proceedings of the Third ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1976, </year> <pages> 58-67. </pages>
Reference-contexts: For example, a set can be implemented by a variety of representations|arrays, lists, bit-vectors, hash tables, etc.. A major decision faced by compilers for very-high-level languages is data structure selection, which concerns the construction of efficient low-level representations of high-level data abstractions <ref> [4, 7, 10] </ref>. The most widely used data abstractions in program specifications are the class of set-theoretic data abstractions, such as sets, sequences, and maps.
Reference: [8] <author> Manna, Z., Waldinger, R., </author> <title> The Logical Basis for Computer Programming, Vol.2: Deductive Systems, </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: The canonicalization is achieved by applying the boolean sim-plification rules in, for example, <ref> [8] </ref> and the following transformation rules repeatedly until no rules are applicable: range seq ([ ]) =) f g domain (fj jg) =) f g range (fj jg) =) f g notempty (f g) =) false notempty (t 1 with t 2 ) =) true notempty (t 1 [ t 2
Reference: [9] <editor> Abramsky, S., Hankin, C. (editors), </editor> <title> Abstract Interpretation of Declarative Languages, </title> <publisher> Ellis Horwood Limited, </publisher> <year> 1987. </year>
Reference-contexts: Abstract interpretation [2, 3] was originally proposed as a general framework for semantically correct program analysis. It has been applied to applicative languages to perform a variety of analysis tasks, such as strictness analysis in functional programs and mode analysis in logic programs <ref> [9] </ref>. An example of abstract interpretation applied to imperative languages is given in [1], where induction variables and recurrence relations in 2 loops can be automatically recognized. We develop a program analysis technique that computes the symbolic bounds of set-theoretic data abstractions automatically and effectively.
Reference: [10] <author> Schonberg, E., Schwartz, J., Sharir, M., </author> <title> "An Automatic Technique for the Selection of Data Representations in SETL Programs"; ACM Transactions on Programming Languages and Systems 3:2, </title> <month> April </month> <year> 1981, </year> <pages> 126-143. </pages>
Reference-contexts: For example, a set can be implemented by a variety of representations|arrays, lists, bit-vectors, hash tables, etc.. A major decision faced by compilers for very-high-level languages is data structure selection, which concerns the construction of efficient low-level representations of high-level data abstractions <ref> [4, 7, 10] </ref>. The most widely used data abstractions in program specifications are the class of set-theoretic data abstractions, such as sets, sequences, and maps. <p> As an example, if a sequence variable is bounded by a fixed integer subrange throughout its lifetime, then an array implementation would replace O (n) membership tests by constant-time array index arithmetic. The setl optimizing compiler <ref> [10] </ref> introduced an important representation technique called basing, which allows constant-time pointer access to components of composite objects in a program.
Reference: [11] <author> Schwartz, J., </author> <title> "Optimization of Very High Level Languages|I: Value Transmission and Its Corollaries"; Computer Languages 1, </title> <booktitle> 1975, </booktitle> <pages> 161-194. </pages>
Reference-contexts: Abstract interpretation [3] is applied to construct a deductive semantics of programs. Concrete contexts are abstracted into collections of simple facts about program points called bound assertions, and the abstract interpretation serves as a specialized theorem prover or fact gatherer <ref> [11] </ref> which computes global bounds information. For a syntactic construct s and a bound assertion p, the abstract interpretation derives a post-condition of p over s [6].
Reference: [12] <author> Schwartz, J., </author> <title> "Optimization of Very High Level Languages|II: Deducing Relationships of Inclusion and Membership"; Computer Languages 1, </title> <booktitle> 1975, </booktitle> <pages> 197-218. 26 </pages>
Reference-contexts: The importance of inclusion and membership relationships to automatic data structure selection in very-high-level languages was first recognized by Schwartz <ref> [12] </ref>. Techniques similar to data flow analysis were developed there for setl, which start from an initial collection of plausible (i.e., typable) relationships and iteratively eliminate those that might be false. Abstract interpretation [2, 3] was originally proposed as a general framework for semantically correct program analysis. <p> The abstract interpretation is kept compu-tationally tractable by restricting ourselves to reasoning with bound assertions. Compared with the approach in <ref> [12] </ref>, our approach does not require that all plausible inclusion and membership assertions be generated, and intra-function analysis is syntax-directed rather than iteratively approximated. The technique is easily extensible to other high-level data abstractions, and readily incorporable into compilers for very-high-level languages.
References-found: 12

