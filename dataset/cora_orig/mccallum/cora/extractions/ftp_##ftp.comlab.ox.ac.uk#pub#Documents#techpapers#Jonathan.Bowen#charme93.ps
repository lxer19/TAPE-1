URL: ftp://ftp.comlab.ox.ac.uk/pub/Documents/techpapers/Jonathan.Bowen/charme93.ps
Refering-URL: http://www.comlab.ox.ac.uk/archive/occam.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: fJifeng.He,Ian.Page,Jonathan.Boweng@comlab.ox.ac.uk  
Title: Towards a Provably Correct Hardware Implementation of Occam  
Author: He Jifeng Ian Page and Jonathan Bowen 
Address: 11 Keble Road, Oxford OX1 3QD, England  
Affiliation: Oxford University Computing Laboratory, Programming Research Group  
Abstract: This paper shows how to compile a program written in a subset of occam into a normal form suitable for further processing into a netlist of components which may be loaded into a Field-Programmable Gate Array (FPGA). A simple state-machine model is adopted for specifying the behaviour of a synchronous circuit where the observable includes the state of the control path and the data path of the circuit. We identify the behaviour of a circuit with a program consisting of a very restricted subset of occam. Algebraic laws are used to facilitate the transformation from a program into a normal form. The compiling specification is presented as a set of theorems that must be proved correct with respect to these laws. A rapid prototype compiler in the form of a logic program may be implemented from these theorems.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J.P. Bowen, </author> <title> From programs to object code using logic and logic programming, </title> <editor> in R. Giegerich and S.L. Graham (eds.), </editor> <title> Code Generation Concepts, Tools, Techniques, </title> <publisher> Springer-Verlag, Workshops in Computer Science, </publisher> <pages> pp. 173-192, </pages> <year> 1992. </year>
Reference-contexts: Thus it is feasible to prototype them as a logic program <ref> [1] </ref>. However, to produce an executable compiler, it is necessary to constructively generate each of the constructs of the language. This is relatively easy for the sequential aspects of the language.
Reference: 2. <editor> J.P. Bowen (ed.), </editor> <title> Towards Verified Systems, Elsevier, Real-Time Safety Critical Systems Series, </title> <note> 1993. In preparation. </note>
Reference-contexts: 1 Introduction The development of systems containing software and hardware requires many levels of abstraction from requirements, through design and compilation to the underlying hardware itself. For confidence in the overall design, each level must be related and its correctness demonstrated <ref> [2, 3] </ref>. This is especially important in safety-critical systems where mistakes could cost lives [4]. Reduction in the overall complexity of the system is a key to increasing its likelyhood of correctness.
Reference: 3. <author> J.P. Bowen, M. Franzle, E.-R. </author> <title> Olderog and A.P. Ravn, Developing correct systems, </title> <booktitle> Proc. 5th Euromicro Workshop on Real-Time Systems, Oulu, </booktitle> <address> Finland, 22-24 June 1993. </address> <publisher> IEEE Press, </publisher> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: 1 Introduction The development of systems containing software and hardware requires many levels of abstraction from requirements, through design and compilation to the underlying hardware itself. For confidence in the overall design, each level must be related and its correctness demonstrated <ref> [2, 3] </ref>. This is especially important in safety-critical systems where mistakes could cost lives [4]. Reduction in the overall complexity of the system is a key to increasing its likelyhood of correctness.
Reference: 4. <author> J.P. Bowen and V. Stavridou, </author> <title> Formal methods and software safety, </title> <editor> in H. Frey (ed.), </editor> <booktitle> Safety of Computer Control Systems 1992 (SAFECOMP'92), </booktitle> <publisher> Pergamon Press, </publisher> <pages> pp. 93-98, </pages> <year> 1992. </year>
Reference-contexts: For confidence in the overall design, each level must be related and its correctness demonstrated [2, 3]. This is especially important in safety-critical systems where mistakes could cost lives <ref> [4] </ref>. Reduction in the overall complexity of the system is a key to increasing its likelyhood of correctness. One way to do this is to compile high-level programs directly into hardware, thus spanning several levels of abstraction at a stroke.
Reference: 5. <author> G.M. Brown, </author> <title> Towards truly delay-insensitive circuit realizations of process algebras, </title> <editor> in G. Jones and M. Sheeran (eds.), </editor> <title> Designing Correct Circuits, </title> <publisher> Springer-Verlag, Workshops in Computing, </publisher> <pages> pp. 120-131, </pages> <year> 1991. </year>
Reference-contexts: A project at Cornell University aims to produce a multipass compiler through several levels of abstraction, but with much the same goal in mind [18]. Brown has suggested the possibility of compiling CSP or occam into asynchronous delay-insensitive circuits <ref> [5] </ref>. Further work on a process algebra called Joy has produced encouraging results [27]. Another working example of a `silicon compiler' that synthesizes asynchronous circuits is [26].
Reference: 6. <author> T.P. Clement and K.-K. Lau (eds.), </author> <title> Logic Program Synthesis and Transformation, </title> <publisher> Springer-Verlag, Workshops in Computing, </publisher> <year> 1992. </year>
Reference-contexts: The fact that logic (and other) programs can be considered as representing predicates [14] is a great help in producing a provably correct compiler. Logic program synthesis and transformation is a very active topic of research <ref> [6] </ref> and application of these results is likely to increase the confidence in and efficiency of the prototype hardware compiler.
Reference: 7. <author> W.F. Clocksin and C.S. Mellish, </author> <title> Programming in Prolog, </title> <publisher> Springer-Verlag, 3rd edition, </publisher> <year> 1987. </year>
Reference-contexts: However, to produce an executable compiler, it is necessary to constructively generate each of the constructs of the language. This is relatively easy for the sequential aspects of the language. Theorems 1 to 3 may be transliterated very directly into a language such as Prolog <ref> [7] </ref>: Clause 1: Skip. skip &lt;= n (S,S,[],[],[]). Clause 2: Stop. stop &lt;= n (S,F,[S],[S-&gt;S],[S-&gt;v]) :- -S"=F-. Clause 3: Assignment. v:=E &lt;= n (S,F,[S],[S-&gt;F],[S-&gt;E]) :- -S"=F-. Constraints are encoded in curly brackets -. . . for clarity.
Reference: 8. <author> G.V. Collis and E.J. Kappos, </author> <title> Occam as a hardware description language, </title> <journal> Software Engineering Journal, </journal> <volume> 2(6), </volume> <pages> 213-219, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Here we show how to compile programs written in a subset of occam [17] (a particularly convenient language for the description of hardware because of its parallel programming constructs <ref> [8] </ref>) into a form suitable for implementation directly in hardware via a series of provably correct transformations. Crucial to our method is the use of normal form occam programs which refine the semantics of the user program and yet provide a representation close to the desired hardware.
Reference: 9. <author> He Jifeng and J.P. Bowen, </author> <title> Time interval semantics and implementation of a real-time programming language, </title> <booktitle> Proc. 4th Euromicro Workshop on Real-Time Systems, </booktitle> <publisher> IEEE Press, </publisher> <pages> pp. 110-115, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Q = (skip n ; P ) &lt; b &gt; (skip n ; Q ) In a similar way we define b fl n P = X : (P ; X ) &lt; b &gt; skip n Further algebraic laws relating to real-time programming language aspects may be found in <ref> [9] </ref>. 3 Normal Form Implementation of Occam Normal form programs are a bridge between programs in a subset of occam and hardware implementations of them.
Reference: 10. <author> He Jifeng and J.P. Bowen, </author> <title> Specification, Verification and Prototyping of an Optimized Compiler, </title> <type> Draft, </type> <institution> Oxford University Computing Laboratory, </institution> <year> 1992. </year> <note> Submitted for publication. </note>
Reference-contexts: The split could be automated to some extent, although human guidance may well be desirable as well. An advantage of the approach is that new compilation strategies, such as optimizations, may be included as new theorems, without affecting existing theorems <ref> [10] </ref>. The ultimate aim is to provide a good interface with the engineer. We see hardware compilation becoming increasingly important over the next decade. Currently FPGAs are mostly used for the implementation of glue logic.
Reference: 11. <author> He Jifeng, I. Page and J.P. Bowen, </author> <title> A Provably Correct Hardware Implementation of Occam, ESPRIT ProCoS project document [OU HJF 9/5], </title> <type> Draft, </type> <institution> Oxford University Computing Laboratory, UK, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: This section lists some example algebraic laws relating to normal form reduction selected from <ref> [11] </ref>. For simplicity we assume that all expressions always deliver a value. Law 1: Refinement. <p> However they are presented in the report on which this paper is based <ref> [11] </ref>, for those who are interested in the full language. 4 Rapid Prototype Compiler The compiling theorems shown here may easily be transformed into Horn clauses. Thus it is feasible to prototype them as a logic program [1]. <p> We have shown some of the algebraic laws and theorems for transforming a user program into normal form. In processing synchronous communications, we have also extended the programming language by introducing the notation of state-based parallel which mimics the true concurrency of the underlying digit circuits <ref> [11] </ref>. It is possible to develop a hardware simulation program for the netlist interpretation of normal form programs.
Reference: 12. <author> C.A.R. Hoare (ed.), </author> <title> Developments in Concurrency and Communication, </title> <type> Addison-Wesley, </type> <institution> University of Texas at Austin Year of Programming Series, </institution> <year> 1990. </year>
Reference: 13. <author> C.A.R. Hoare, </author> <title> Refinement algebra proves correctness of compiling specifications, in C.C. </title> <editor> Morgan and J.C.P. Woodcock (eds.), </editor> <booktitle> 3rd Refinement Workshop, </booktitle> <publisher> Springer-Verlag, Workshops in Computing, </publisher> <pages> pp. 33-48, </pages> <year> 1991. </year>
Reference-contexts: A particularly simple and elegant timing calculus results which enables our programs to meet real-time guarantees. 1.1 Background This work builds upon previous results on provably correct compilation <ref> [13, 15, 16] </ref>. There is a strong relationship between our method and that used by Hoare in software compilation. However, our method handles communication and parallel composition and preserves true concurrency in the implementations.
Reference: 14. <author> C.A.R. Hoare, </author> <title> Programs are predicates, </title> <editor> in ICOT (ed.), </editor> <booktitle> Proc. International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo, Japan, </address> <pages> pp. 211-218, </pages> <month> 1-5 June </month> <year> 1992. </year>
Reference-contexts: The fact that logic (and other) programs can be considered as representing predicates <ref> [14] </ref> is a great help in producing a provably correct compiler. Logic program synthesis and transformation is a very active topic of research [6] and application of these results is likely to increase the confidence in and efficiency of the prototype hardware compiler.
Reference: 15. <author> C.A.R. Hoare, He Jifeng, J.P. Bowen and P.K. Pandya, </author> <title> An algebraic approach to verifiable compiling specification and prototyping of the ProCoS level 0 programming language, </title> <booktitle> ESPRIT '90 Conference Proceedings, </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <pages> pp. 804-818, </pages> <year> 1990. </year>
Reference-contexts: A particularly simple and elegant timing calculus results which enables our programs to meet real-time guarantees. 1.1 Background This work builds upon previous results on provably correct compilation <ref> [13, 15, 16] </ref>. There is a strong relationship between our method and that used by Hoare in software compilation. However, our method handles communication and parallel composition and preserves true concurrency in the implementations. <p> Instrumental in our success for this study is the use of a simple normal form, which we have developed as an extension of some earlier work dealing with compiling specification in the ProCoS project <ref> [15, 16] </ref>. Our experience with this study is that while it was very difficult to establish the link between the event-based parallel paradigm and the state-based parallel one, the use of algebraic laws has aided this process.
Reference: 16. <author> C.A.R. Hoare, He Jifeng and A. Sampaio, </author> <title> Normal form approach to compiler design, </title> <journal> Acta Informatica, </journal> <note> 1993. To appear. </note>
Reference-contexts: A particularly simple and elegant timing calculus results which enables our programs to meet real-time guarantees. 1.1 Background This work builds upon previous results on provably correct compilation <ref> [13, 15, 16] </ref>. There is a strong relationship between our method and that used by Hoare in software compilation. However, our method handles communication and parallel composition and preserves true concurrency in the implementations. <p> Instrumental in our success for this study is the use of a simple normal form, which we have developed as an extension of some earlier work dealing with compiling specification in the ProCoS project <ref> [15, 16] </ref>. Our experience with this study is that while it was very difficult to establish the link between the event-based parallel paradigm and the state-based parallel one, the use of algebraic laws has aided this process.
Reference: 17. <author> Inmos Ltd., </author> <title> Occam 2 Reference Manual, </title> <publisher> Prentice Hall International Series in Computer Science, </publisher> <year> 1988. </year>
Reference-contexts: One way to do this is to compile high-level programs directly into hardware, thus spanning several levels of abstraction at a stroke. Here we show how to compile programs written in a subset of occam <ref> [17] </ref> (a particularly convenient language for the description of hardware because of its parallel programming constructs [8]) into a form suitable for implementation directly in hardware via a series of provably correct transformations. <p> Our language is a subset of occam <ref> [17] </ref> from which local declarations have been excluded. Furthermore we do not consider skip-guarded alternatives. This subset is sufficient to illustrate our compiling method. 2.1 Syntax For clarity of exposition and algebraic manipulation, the syntax of our language does not follow that of occam.
Reference: 18. <author> M.E. Leeser et al., BEDROC91: </author> <title> The Cornell Hardware Synthesis Project, </title> <type> Technical Report EE-CEG-91-9, </type> <institution> School of Electrical Engineering, Cornell University, </institution> <address> Ithaca, New York, USA, </address> <year> 1991. </year>
Reference-contexts: Martin has developed a method of compiling a concurrent program into a circuits using semantic-preserving program transformations [19]. A project at Cornell University aims to produce a multipass compiler through several levels of abstraction, but with much the same goal in mind <ref> [18] </ref>. Brown has suggested the possibility of compiling CSP or occam into asynchronous delay-insensitive circuits [5]. Further work on a process algebra called Joy has produced encouraging results [27]. Another working example of a `silicon compiler' that synthesizes asynchronous circuits is [26].
Reference: 19. <author> A.J. Martin, </author> <title> Programming in VLSI: from communicating processes into delay-insensitive circuits, </title> <note> chapter 1, in [12]. </note>
Reference-contexts: Related work has shown that an occam program can be implemented as a set of special-purpose computers (one per process), each with just sufficient resources and microcode [20]. Martin has developed a method of compiling a concurrent program into a circuits using semantic-preserving program transformations <ref> [19] </ref>. A project at Cornell University aims to produce a multipass compiler through several levels of abstraction, but with much the same goal in mind [18]. Brown has suggested the possibility of compiling CSP or occam into asynchronous delay-insensitive circuits [5].
Reference: 20. <author> D. </author> <month> May, </month> <title> Compiling Occam into silicon, </title> <note> chapter 3, in [12]. </note>
Reference-contexts: However, our method handles communication and parallel composition and preserves true concurrency in the implementations. Related work has shown that an occam program can be implemented as a set of special-purpose computers (one per process), each with just sufficient resources and microcode <ref> [20] </ref>. Martin has developed a method of compiling a concurrent program into a circuits using semantic-preserving program transformations [19]. A project at Cornell University aims to produce a multipass compiler through several levels of abstraction, but with much the same goal in mind [18].
Reference: 21. <author> J. Paakki, </author> <title> Prolog in practical compiler writing, </title> <journal> The Computer Journal, </journal> <volume> 34(1), </volume> <pages> 64-72, </pages> <year> 1991. </year>
Reference-contexts: Logic program synthesis and transformation is a very active topic of research [6] and application of these results is likely to increase the confidence in and efficiency of the prototype hardware compiler. Prolog has been shown to be relatively efficient for compilation <ref> [21] </ref> and has even been used successfully in the compilation of the VHDL hardware description language [24]. 5 Mapping Normal Form into Hardware There are a number of ways in which a normal form program can be mapped into hardware.
Reference: 22. <author> I. Page and W. Luk, </author> <title> Compiling Occam into field-programmable gate arrays. </title> <editor> in W. Moore and W. Luk (eds.), FPGAs, </editor> <publisher> Abingdon EE&CS Books, </publisher> <address> 15 Harcourt Way, Abingdon OX14 1NV, UK, </address> <pages> pp. 271-283, </pages> <year> 1991. </year>
Reference-contexts: Currently, we use FPGAs which can be dynamically reconfig--ured by software <ref> [22, 28] </ref>. This enables us to build hardware implementations of modest-sized programs entirely by a software process. <p> Another working example of a `silicon compiler' that synthesizes asynchronous circuits is [26]. Page has developed a prototype compiler in the functional language Standard ML which converts an occam-like language, somewhat more expressive than the one presented here, to a netlist <ref> [22] </ref>. This has been successfully applied to the control of a robot arm, amongst other applications. After further processing by vendor software, the netlist can be loaded into a Xilinx FPGA [28]. <p> However we plan to produce a fuller compiler based on proven theorems for hardware compilation. We feel that this is tractable since an unverified hardware compiler for the majority of occam, including all the constructs presented here, has already been produced in Standard ML <ref> [22] </ref>, and is proving very successful in the practical production of netlist descriptions for FPGAs. The fact that logic (and other) programs can be considered as representing predicates [14] is a great help in producing a provably correct compiler.
Reference: 23. <institution> Quintus Prolog Sun 4 User Manual, Release 2.5, Quintus Computer Systems, Inc., Mountain View, California, USA, </institution> <year> 1990. </year>
Reference-contexts: Without the disjointness constraints on variables, free (uninstantiated) variables will be returned. To satisfy the disjointness constraints, it is simply necessary to instantiate these to different values. Many versions of Prolog (e.g., Quintus <ref> [23] </ref>) provide a built-in clause to do just this. Using this technique avoids the otherwise very computationally expensive problem of checking the disjointness constraints. This results in a usable compiler in practice, at least for experimental purposes.
Reference: 24. <author> P.B. Reintjes, </author> <title> A set of tools for VHDL design, </title> <editor> in K. Furukawa (ed.), </editor> <booktitle> Logic Programming: Proc. 8th International Conference, </booktitle> <publisher> The MIT Press, </publisher> <pages> pp. 549-562, </pages> <year> 1991. </year>
Reference-contexts: Prolog has been shown to be relatively efficient for compilation [21] and has even been used successfully in the compilation of the VHDL hardware description language <ref> [24] </ref>. 5 Mapping Normal Form into Hardware There are a number of ways in which a normal form program can be mapped into hardware. We have been using Xilinx FPGA chips to implement globally synchronous circuits which directly mimic the normal form programs.
Reference: 25. <author> A.W. </author> <title> Roscoe and C.A.R. Hoare, Laws of Occam programming, </title> <journal> Theoretical Computer Science, </journal> <volume> 60, </volume> <pages> 177-229, </pages> <year> 1988. </year>
Reference-contexts: In particular, no program variable can be shared by two concurrently executed processes if either of them can possibly modify it, and furthermore parallel processes can share neither input channels nor output channels. 2.2 Algebraic Laws The basic laws defining occam programs are given in <ref> [25] </ref>. This section lists some example algebraic laws relating to normal form reduction selected from [11]. For simplicity we assume that all expressions always deliver a value. Law 1: Refinement.
Reference: 26. <author> C.H. van Berkel, J. Kessels, M. Roncken, R.W.J.J. Saeijs and F. Schalij, </author> <title> The VLSI-programming language Tangram and its translation into handshake circuits, </title> <booktitle> Proc. European Design Automation Conference, </booktitle> <year> 1991. </year>
Reference-contexts: Brown has suggested the possibility of compiling CSP or occam into asynchronous delay-insensitive circuits [5]. Further work on a process algebra called Joy has produced encouraging results [27]. Another working example of a `silicon compiler' that synthesizes asynchronous circuits is <ref> [26] </ref>. Page has developed a prototype compiler in the functional language Standard ML which converts an occam-like language, somewhat more expressive than the one presented here, to a netlist [22]. This has been successfully applied to the control of a robot arm, amongst other applications.
Reference: 27. <author> S. Weber, B. Bloom and G. Brown, </author> <title> Compiling Joy into silicon, </title> <editor> in T. Knight and J. Savage (eds.), </editor> <booktitle> Advanced Research in VLSI and Parallel Systems, </booktitle> <publisher> The MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Brown has suggested the possibility of compiling CSP or occam into asynchronous delay-insensitive circuits [5]. Further work on a process algebra called Joy has produced encouraging results <ref> [27] </ref>. Another working example of a `silicon compiler' that synthesizes asynchronous circuits is [26]. Page has developed a prototype compiler in the functional language Standard ML which converts an occam-like language, somewhat more expressive than the one presented here, to a netlist [22].
Reference: 28. <author> Xilinx Inc., </author> <title> The Programmable Gate Array Data Book, </title> <address> San Jose, California, USA, </address> <year> 1991. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Currently, we use FPGAs which can be dynamically reconfig--ured by software <ref> [22, 28] </ref>. This enables us to build hardware implementations of modest-sized programs entirely by a software process. <p> This has been successfully applied to the control of a robot arm, amongst other applications. After further processing by vendor software, the netlist can be loaded into a Xilinx FPGA <ref> [28] </ref>.
References-found: 28

