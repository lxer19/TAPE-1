URL: ftp://ftp.cs.helsinki.fi/pub/Reports/by_Project/Vital/Cooperation_of_KBS_Development_Environments_and_CASE_Environments.ps.gz
Refering-URL: http://www.cs.helsinki.fi/~verkamo/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Cooperation of KBS Development Environments and CASE Environments  
Author: A. Inkeri Verkamo 
Address: P.O.Box 26 (Teollisuuskatu 23), FIN-00014 Helsinki, Finland  
Affiliation: University of Helsinki, Department of Computer Science  
Abstract: We compare the process of knowledge based system development to the software engineering approach of the more traditional application development. In Proceedings of the Sixth International Conference on Software Engineering and Knowledge Engineering, June 1994, pages 358 -- 365. Many similarities can be identified in the process structures. The most important differences are in the knowledge acquisition and conceptual modelling of the KBS which have no direct counterpart in the traditional software life cycle. We also study the cooperation of the KBS development environment and ordinary CASE tools. We develop a scheme to support this cooperation. The method is based on transformations between KBS development tools and the repository supporting the CASE toolset. For the case where no repository is available, the scheme can be modified to use transformations between each KBS development tool and the corresponding CASE tool. Since the phase structures of a KBS project and a SE project are fairly similar, the interface may be relatively simple. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andersen Consulting. </author> <title> FOUNDATION Design, Analyze Application Requirements, </title> <note> Version 2.0, </note> <year> 1993. </year>
Reference-contexts: The tool includes capabilities for presenting coarse level (GDM) models as well as more refined models that include domain data and knowledge as well as problem solving behavior. The CASE tool chosen is Foundation Design of An-dersen Consulting <ref> [1] </ref>. However, the characteristics of these particular tools are fairly similar to any of the advanced tools that are used for conceptual modelling or design in the KBS or CASE life cycle.
Reference: [2] <author> Barry W. Boehm. </author> <title> A spiral model of software development and enhancement. </title> <journal> Computer, </journal> <volume> 21(5):61 - 72, </volume> <month> May </month> <year> 1988. </year>
Reference-contexts: These documents should similarly be considered in a KBS project. In the SE world, this document-driven or code-driven approach to software development is recommended if the development process is well established. However, in the case of innovative projects, a risk-driven approach is more appropriate <ref> [2] </ref>, to reduce the potential losses in case of an unsuccessful project, and also to emphasize the quality of all factors affecting the development process. <p> Prototypes are further useful for exploring the range of acceptable solutions [13]: a prototype is built to represent certain essential, possibly high-risk parts of the system, in order to minimize the potential costs involved if the plans turn out being infeasible or impractical <ref> [2] </ref>. Defining what the customer actually wants is one of the goals of prototyping, but the feasibility and robustness of the solution and the performance effects are at least as im portant. This way of using prototypes has usually not been suggested for KBS development.
Reference: [3] <author> John H. Boose. </author> <title> A survey of knowledge acquisition techniques and tools. </title> <journal> Knowledge Acquisition, </journal> <volume> 1(1):3 - 37, </volume> <month> March </month> <year> 1989. </year>
Reference-contexts: Efficient reuse requires tools for arranging, searching and manipulating reusable elements. Knowledge acquisition methods are either heuristic classification methods or constructive problem solving methods using synthesis. Typical examples of KBS development tools for knowledge acquisition are lad--dering grid, card sort, repertory grid, machine learning tools, and protocol editors <ref> [3] </ref>. As similar support is not available in CASE development environments, exporting knowledge acquired by KBS tools might prove to be useful to all software development [4].
Reference: [4] <author> Alexander Borgida, Sol Greenspan, and John Mylopoulos. </author> <title> Knowledge representation as the basis for requirements specification. </title> <journal> Computer, </journal> <volume> 18(4):82 - 91, </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: For the requirements specification vs. knowledge modelling phases of the KBS life cycle, even iterative development is hardly enough: these phases will have to be performed in parallel, since the requirements are tightly coupled with application specific knowledge <ref> [4] </ref>. In a waterfall type process model the project is seen as a group of activities producing a number of process products or deliverables. The four basic process products of a KBS project are the requirements document, the conceptual model, the design document, and the executable code. <p> Typical examples of KBS development tools for knowledge acquisition are lad--dering grid, card sort, repertory grid, machine learning tools, and protocol editors [3]. As similar support is not available in CASE development environments, exporting knowledge acquired by KBS tools might prove to be useful to all software development <ref> [4] </ref>. The results of the knowledge acquisition phase are presented as a conceptual model which is a model of the expertise required to perform the task. Such a conceptual model can be viewed as consisting of three components: domain data, domain knowledge, and problem solving behavior [18].
Reference: [5] <author> Debra Cameron. </author> <title> IBM's AD/Cycle and Repository. </title> <type> Technical report, </type> <institution> Computer Technology Research, </institution> <year> 1990. </year>
Reference-contexts: Several standards for CASE repositories have been suggested. These include Portable Common Tools Environment (PCTE) adopted by ECMA [7], Information Resource Dictionary System (IRDS) approved by ISO and ANSI [12], as well as several industry standards, e.g., the repository within AD/Cycle of IBM <ref> [5] </ref>, and CDD/Repository of DEC [6]. Transferring information between KBS tools and CASE tools typically requires transformation from one representation to another.
Reference: [6] <institution> Digital Equipment Corporation. Digital's Distributed Repository, </institution> <year> 1991. </year>
Reference-contexts: Several standards for CASE repositories have been suggested. These include Portable Common Tools Environment (PCTE) adopted by ECMA [7], Information Resource Dictionary System (IRDS) approved by ISO and ANSI [12], as well as several industry standards, e.g., the repository within AD/Cycle of IBM [5], and CDD/Repository of DEC <ref> [6] </ref>. Transferring information between KBS tools and CASE tools typically requires transformation from one representation to another. If the CASE environment uses a repository, all the representations available for the CASE tools are stored in the repository and are manipulated by the repository tools (Figure 3a).
Reference: [7] <author> ECMA European Computer Manufacturers Association. </author> <title> Portable Common Tool Environment (PCTE), Abstract Specification, </title> <month> December </month> <year> 1990. </year>
Reference-contexts: The interface routines enable efficient transportation of knowledge from one representation to another. Several standards for CASE repositories have been suggested. These include Portable Common Tools Environment (PCTE) adopted by ECMA <ref> [7] </ref>, Information Resource Dictionary System (IRDS) approved by ISO and ANSI [12], as well as several industry standards, e.g., the repository within AD/Cycle of IBM [5], and CDD/Repository of DEC [6]. Transferring information between KBS tools and CASE tools typically requires transformation from one representation to another.
Reference: [8] <author> Martin D. Fraser, Kuldeep Kumar, and Vi-jayk Vaishnavi. </author> <title> Informal and formal requirements specification languages: Binding the gap. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(5):454 - 466, </volume> <month> May </month> <year> 1991. </year>
Reference-contexts: Even when informal languages are used in the beginning of the requirements specification phase, transportation from informal to formal representations at a later stage should be considered (see, e.g., <ref> [8] </ref>). 4 Knowledge acquisition and mod elling Acquiring and defining the knowledge of the application domain and the problem solving behavior is the task that most notably makes a difference between a KBS project and a SE project.
Reference: [9] <editor> Allen Goldberg. </editor> <booktitle> Reusing software developments. In Proceedings of the 4th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 107 - 119, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: A similar idea of high level reuse could be applied in all phases of KBS development. The entire development process could be built on reusing models of development and modifying them to suit the needs of the particular application domain <ref> [9] </ref>. A reuse-driven approach to software development results in higher reliability and productivity. Efficient reuse requires tools for arranging, searching and manipulating reusable elements. Knowledge acquisition methods are either heuristic classification methods or constructive problem solving methods using synthesis.
Reference: [10] <author> Sol Greenspan. </author> <title> On the role of domain knowledge in knowledge-based approaches to software development. </title> <booktitle> In Proceedings of International Workshop on the Software Process and Software Environments, </booktitle> <pages> pages 61 - 65, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: The conceptual modelling phase is the most essential point where information transfer between KBS and CASE tools is needed (Figure 2). The domain knowledge acquired and modelled using KBS tools can be used as a basis for further development using CASE tools <ref> [10] </ref>. tools. There are some other situations where the two environments need to cooperate.
Reference: [11] <author> R. Gupta and E Horowitz, </author> <title> editors. Object-Oriented Databases with Applications to CASE, Networks and VLSI CAD. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: A natural platform for the repository is a database management system. Since the elements often have a complex stucture involving both textual and graphical information and rules for consistency and validation, an object-oriented database system seems well suited for the implementation of repositories <ref> [11] </ref>. The repository is used both within the development of one application (one project) and as the effective "memory" of the entire enterprise.
Reference: [12] <author> ISO International Organization for Standardization. </author> <title> Information Resource Dictionary System (IRDS) Framework, </title> <year> 1990. </year>
Reference-contexts: The interface routines enable efficient transportation of knowledge from one representation to another. Several standards for CASE repositories have been suggested. These include Portable Common Tools Environment (PCTE) adopted by ECMA [7], Information Resource Dictionary System (IRDS) approved by ISO and ANSI <ref> [12] </ref>, as well as several industry standards, e.g., the repository within AD/Cycle of IBM [5], and CDD/Repository of DEC [6]. Transferring information between KBS tools and CASE tools typically requires transformation from one representation to another.
Reference: [13] <author> Luqi and Winston Royce. </author> <title> Status report: Computer-aided prototyping. </title> <journal> IEEE Software, </journal> <volume> 9(6):77 - 81, </volume> <month> November </month> <year> 1992. </year>
Reference-contexts: For a risk-driven approach, more appropriate process models may be based on evolutionary development or pro-totyping. Prototyping is used as a means to resolve various types of risks and specifically to evaluate the accuracy of the problem formulation <ref> [13] </ref>. This is the way prototypes are typically used within the knowledge acquisition phase of a KBS project. Prototypes may be the easiest way to find out how the application is supposed to interact with the environment. <p> This is the approach often used in SE projects for specifying the user interface requirements: even a simple prototype may greatly help in determining what the user actually wants to do with the system. Prototypes are further useful for exploring the range of acceptable solutions <ref> [13] </ref>: a prototype is built to represent certain essential, possibly high-risk parts of the system, in order to minimize the potential costs involved if the plans turn out being infeasible or impractical [2]. <p> This way of using prototypes has usually not been suggested for KBS development. Efficient pro-totyping environments may produce graphical visual-isations of the behavior of the application or support execution of partial descriptions <ref> [13] </ref>. The following comparison of KBS development tools and CASE tools is structured along the phase structure of a KBS project.
Reference: [14] <author> Sandra Marcus, Jeffrey Stout, and John McDer-mott. </author> <title> VT: An expert elevator designer that uses knowledge-based backtracking. </title> <journal> AI Magazine, </journal> <volume> 9(1):95 - 111, </volume> <month> March </month> <year> 1987. </year>
Reference-contexts: However, the characteristics of these particular tools are fairly similar to any of the advanced tools that are used for conceptual modelling or design in the KBS or CASE life cycle. The problem that we focus on in our example is the Sisyphus II elevator design problem introduced in <ref> [14, 22] </ref>. The Sisyphus II problem involves a KBS for configuring an elevator system and includes customer demands and constraints. It is solved using a propose-and-revise strategy: an initial design model is produced and repeatedly modified until all constraints are satisfied. <p> Some of the constraints (such as safety regulations) are strict, while some can be fixed; some fixes may be more desirable than others. For more detailed presentation of the Sisyphus II problem, see <ref> [14, 22] </ref>. The conceptual model presented in Figure 4 is a reprint of the model presented in [15]. This model is the result of several refinement steps up to the point where each task (ellipse) of the model is an inference that cannot be refined without using domain specific information.
Reference: [15] <author> Enrico Motta, Kieron O'Hara, Nigel Shadbolt, Arthur Stutt, and Zdenek Zdrahal. </author> <title> A VITAL solution to the Sisyphus II elevator design problem. </title> <type> Technical report, </type> <institution> Esprit Project P5365 Vital, </institution> <year> 1993. </year>
Reference-contexts: The KBS tool that we used is the OCML (Operationalizable Conceptual Modelling Language) tool of VITAL <ref> [15] </ref>. The tool includes capabilities for presenting coarse level (GDM) models as well as more refined models that include domain data and knowledge as well as problem solving behavior. The CASE tool chosen is Foundation Design of An-dersen Consulting [1]. <p> For more detailed presentation of the Sisyphus II problem, see [14, 22]. The conceptual model presented in Figure 4 is a reprint of the model presented in <ref> [15] </ref>. This model is the result of several refinement steps up to the point where each task (ellipse) of the model is an inference that cannot be refined without using domain specific information. It is therefore the final GDM of the solution [15]. <p> is a reprint of the model presented in <ref> [15] </ref>. This model is the result of several refinement steps up to the point where each task (ellipse) of the model is an inference that cannot be refined without using domain specific information. It is therefore the final GDM of the solution [15]. The model in Figure 4 contains only tasks (or processes) and data collections and does not involve control or timing. <p> This is an example of a simple transformation between the environments: each object in the source model has a distinct corre elevator problem <ref> [15] </ref>. spondent in the resulting model. The model in Figure 4 contains embedded iteration, as the steps Propose, Evaluate, Classify, and Revise are repeated until a satisfactory result is found or the process fails. The model is refined by introducing control to describe this iteration [15]. <p> a distinct corre elevator problem <ref> [15] </ref>. spondent in the resulting model. The model in Figure 4 contains embedded iteration, as the steps Propose, Evaluate, Classify, and Revise are repeated until a satisfactory result is found or the process fails. The model is refined by introducing control to describe this iteration [15]. Each subtask is then further refined until an appropriate level of detail is achieved. The same tool can be used for refinement. must exist some constraint violations in the elevator model that are fixable (by changing some parameter values).
Reference: [16] <author> Roger S. Pressman. </author> <title> Software Engineering: a Practitioner's Approach. </title> <publisher> McGraw-Hill, </publisher> <year> 1992. </year>
Reference-contexts: Typical examples of such environments are Foundation of Andersen Consulting, Software through Pictures of Interactive Development Environments, and Application Development Workbench of Knowl-edgeWare (for more information on integrated CASE environments, see, e.g., <ref> [16] </ref>). In addition to phase specific tools, a CASE environment contains tools to handle planning and management functions of the project, such as estimating and assessing resources and schedules, and controlling changes. <p> When this type of requirements are essential some additional techniques or extensions of the previous techniques are available (e.g., software performance engineering [19], state diagrams, and real-time data flow diagrams <ref> [16] </ref>. If requirement specifications are presented using informal languages they tend to be both incomplete and ambiguous. For more precision, formal languages should be used. Rigorous use of a formal specification language also supports the verification and validation of the requirements.
Reference: [17] <author> W. W. </author> <title> Royce. Managing the development of large software systems: Concepts and techniques. </title> <booktitle> In Proceedings of WESCON, </booktitle> <month> August </month> <year> 1970. </year>
Reference-contexts: They differ in the way they manage the phases of the life cycle, and in the amount of overlapping and iteration of phases that they permit. KBS development is typically seen as a sequential process, very much like the classical waterfall model for software development <ref> [17] </ref>. Presumably, minor iteration between consecutive phases is expected, but the movement is mainly in one direction. In SE projects, a strict waterfall model is currently considered unrealistic (see, e.g., [23]): it doesn't represent the way software projects are actually run, nor the way efficient software projects should be run.
Reference: [18] <author> Nigel Shadbolt, Enrico Motta, and Alain Rouge. </author> <title> Constructing knowledge-based systems. </title> <journal> IEEE Software, </journal> <volume> 10(6):34 - 39, </volume> <month> November </month> <year> 1993. </year>
Reference-contexts: Some projects aiming at building tools or entire environments for KBS development are already under way (e.g., KADS and KADS II [20], and VITAL <ref> [18] </ref>). The purpose of this study is to compare the tools contained in such a KBS development environment to a collection of typical CASE tools, in order to define the most essential similarities and differences of the tools, and to show how their coexistence could add functionalities to both environments. <p> Most of the tools specific for KBS development are knowledge acquisition tools. Knowledge acquisition can be supported by gener-alised directive models (GDM) <ref> [18] </ref>. GDMs are general models describing problem-solving strategies. Since GDMs are domain independent, a library of GDMs is a useful way of reusing high level models across application domains. <p> The results of the knowledge acquisition phase are presented as a conceptual model which is a model of the expertise required to perform the task. Such a conceptual model can be viewed as consisting of three components: domain data, domain knowledge, and problem solving behavior <ref> [18] </ref>. The first two components are closely related to the data modelling concepts that are used within the information engineering approach to software development, e.g., entity-relationship modelling. The tools that are used for representing ER-models and other data-driven designs in CASE environments are suitable for treating these components.
Reference: [19] <author> Connie U. Smith. </author> <title> Performance Engineering of Software Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: However, they are not well suited for describing non-functional requirements, such as performance re quirements, or time constraints and dependencies of the functions. When this type of requirements are essential some additional techniques or extensions of the previous techniques are available (e.g., software performance engineering <ref> [19] </ref>, state diagrams, and real-time data flow diagrams [16]. If requirement specifications are presented using informal languages they tend to be both incomplete and ambiguous. For more precision, formal languages should be used. Rigorous use of a formal specification language also supports the verification and validation of the requirements.
Reference: [20] <author> B. J. Wielinga, A. Th. Schreiber, and J. A. Breuker. KADS: </author> <title> A modelling approach to knowledge engineering. </title> <journal> Knowledge Acquisition, </journal> <volume> 4(1):5 - 53, </volume> <year> 1992. </year>
Reference-contexts: There is a need of systematic support for the development of KBSs, similar to what is already available for more conventional application design, e.g., data management applications. Some projects aiming at building tools or entire environments for KBS development are already under way (e.g., KADS and KADS II <ref> [20] </ref>, and VITAL [18]).
Reference: [21] <author> Jeannette M. Wing. </author> <title> A specifier's introduction to formal methods. </title> <journal> Computer, </journal> <volume> 23(9):8 - 24, </volume> <month> Septem-ber </month> <year> 1990. </year>
Reference-contexts: Rigorous use of a formal specification language also supports the verification and validation of the requirements. Several formal specification languages have been around for ten or twenty years, and there are automated or semi-automated tools available to support them (for a survey, see <ref> [21] </ref>).
Reference: [22] <author> Gregg R. Yost. </author> <title> Configuring elevator systems. </title> <type> Draft, </type> <institution> AI Research Group, Digital Equipment Corporation, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: However, the characteristics of these particular tools are fairly similar to any of the advanced tools that are used for conceptual modelling or design in the KBS or CASE life cycle. The problem that we focus on in our example is the Sisyphus II elevator design problem introduced in <ref> [14, 22] </ref>. The Sisyphus II problem involves a KBS for configuring an elevator system and includes customer demands and constraints. It is solved using a propose-and-revise strategy: an initial design model is produced and repeatedly modified until all constraints are satisfied. <p> Some of the constraints (such as safety regulations) are strict, while some can be fixed; some fixes may be more desirable than others. For more detailed presentation of the Sisyphus II problem, see <ref> [14, 22] </ref>. The conceptual model presented in Figure 4 is a reprint of the model presented in [15]. This model is the result of several refinement steps up to the point where each task (ellipse) of the model is an inference that cannot be refined without using domain specific information.
Reference: [23] <author> Edward Yourdon. </author> <title> Decline and Fall of the American Programmer. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: KBS development is typically seen as a sequential process, very much like the classical waterfall model for software development [17]. Presumably, minor iteration between consecutive phases is expected, but the movement is mainly in one direction. In SE projects, a strict waterfall model is currently considered unrealistic (see, e.g., <ref> [23] </ref>): it doesn't represent the way software projects are actually run, nor the way efficient software projects should be run. In reality, there is a strong need for iteration during several phases.
References-found: 23

