URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/133.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/
Root-URL: http://www.cs.wisc.edu
Email: rama@watson.ibm.com  
Phone: phone: 914-784-7351  
Title: Data Flow Frequency Analysis [delatex wc shows a word count of 4969 (excluding Appendix) and
Author: G. Ramalingam 
Date: October 20, 1995  
Address: P.O. Box 704, Yorktown Heights, NY, 10598, USA  
Affiliation: IBM T.J. Watson Research Center,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> F.E. Allen and J. Cocke. </author> <title> A program data flow analysis procedure. </title> <journal> Commun. of the ACM, </journal> <volume> 19(3) </volume> <pages> 137-147, </pages> <month> March </month> <year> 1976. </year>
Reference-contexts: For our purposes, it would be more efficient to adapt the various elimination-based dataflow analysis algorithms to solve this problem. (See [19] for a survey of elimination algorithms.) These algorithms are often linear or almost-linear in the size of the graph. (The Allen-Cocke interval analysis algorithm <ref> [1] </ref>, for example, is linear for reducible flow graphs whose loop nesting depth is bounded by a constant. Tarjan's algorithm [22] is almost-linear for all reducible flow graphs.
Reference: [2] <author> D.F. Bacon and P.F. Sweeney. </author> <title> Eliminating c++ virtual function calls: Virtual semantics, virtually free. </title> <note> Submitted to this conference., </note> <month> October </month> <year> 1995. </year>
Reference-contexts: This paper presents a theoretical foundation, as well as algorithms, for computing the frequency of dataflow facts. More work, however, remains to be done. Consider the type analysis problem that arises in the above-mentioned cloning optimization. There do exist simple, but effective, type analysis algorithms (for C++; see <ref> [2] </ref>) that fall into the FBS framework. Other, more powerful, type analysis algorithms [13, 14, 4], however, are not even distributive. The results in this paper do not apply to such algorithms.
Reference: [3] <author> T. Ball and J.R. Larus. </author> <title> Optimally profiling and tracing programs. </title> <booktitle> In Conference Record of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 59-70, </pages> <year> 1992. </year>
Reference-contexts: The probability that a certain branch in the program will be taken at run time can be estimated either statically or using profiling information <ref> [15, 23, 3] </ref>. In this paper, we show how the frequency or probability of dataflow facts can be computed for a large class of dataflow problems, a class we call finite bi-distributive subset (FBS) problems, once every edge in the control-flow graph is annotated with a probability. <p> This paper explores the possibility of computing such information statically once every branch out of a conditional node is labelled with a value that indicates the probability that that branch is taken. The probability labelling itself may be computed using simple heuristics, profiling tools, or static analysis. <ref> [15, 23, 3] </ref>. Even when the labelling is computed using profiling tools, it is certainly more convenient to have to gather only this simple data at run-time, rather than having to gather, at run-time, specialized information that varies from one analysis problem to another.
Reference: [4] <author> Paul Carini, Michael Hind, and Harini Srinivasan. </author> <title> Type analysis algorithm for C++. </title> <type> Technical report, </type> <institution> IBM Thomas J. Watson Research Center, </institution> <year> 1995. </year>
Reference-contexts: More work, however, remains to be done. Consider the type analysis problem that arises in the above-mentioned cloning optimization. There do exist simple, but effective, type analysis algorithms (for C++; see [2]) that fall into the FBS framework. Other, more powerful, type analysis algorithms <ref> [13, 14, 4] </ref>, however, are not even distributive. The results in this paper do not apply to such algorithms.
Reference: [5] <author> T.H. Cormen, C.E. Leiserson, and R.L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: In fact, they reveal that just as dataflow analysis reduces to reachability in the exploded graph, the problem we are interested in reduces to a simple algebraic path problem (see <ref> [7, 5] </ref>) over the exploded graph | namely the algebraic path problem over the closed semiring (&lt; + ; +; :; fl ; 0; 1) whose closure operator fl is defined by: ff fl = i=0 1 if ff 1 (This algebraic path problem is known as the Markov chain problem
Reference: [6] <author> J. Dean, C. Chambers, and D. Grove. </author> <title> Selective specialization for object-oriented languages. </title> <booktitle> In Pro--ceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 93-102, </pages> <year> 1995. </year>
Reference-contexts: a procedure p can be obtained by applying M (SLVP (r p ; u)) to the solution for r p . 9 7 Conclusion This work was originally motivated by procedure cloning | an optimization that generates specializations of procedures for specific subtypes of the types of their formal parameters <ref> [6] </ref>. More efficient code can be generated for the specialized versions than for the unspecialized version because the types of the arguments are more precisely known. However, it is necessary to be selective about which specializations are generated to avoid code explosion.
Reference: [7] <author> M. Gondran and M. Minoux. </author> <title> Graphs and Algorithms. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: In fact, they reveal that just as dataflow analysis reduces to reachability in the exploded graph, the problem we are interested in reduces to a simple algebraic path problem (see <ref> [7, 5] </ref>) over the exploded graph | namely the algebraic path problem over the closed semiring (&lt; + ; +; :; fl ; 0; 1) whose closure operator fl is defined by: ff fl = i=0 1 if ff 1 (This algebraic path problem is known as the Markov chain problem
Reference: [8] <author> S. Graham and M. Wegman. </author> <title> A fast and usually linear algorithm for global data flow analysis. </title> <journal> J. ACM, </journal> <volume> 23 </volume> <pages> 172-202, </pages> <year> 1976. </year>
Reference: [9] <author> J.B. Kam and J.D. Ullman. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> J. ACM, </journal> <volume> 23 </volume> <pages> 158-171, </pages> <year> 1976. </year>
Reference-contexts: every edge e, then the sum-over-all-paths values G form a fixed point of the set of equations Q. (That is, the assignment &lt; x u := G (u) &gt; satisfies the collection of equations Q.) Proof See Appendix. 2 We now establish a result similar to Kam and Ullman's result <ref> [9, 10] </ref> relating MOP and MFP. In the following theorem, the ordering on &lt; D fl + is the ordering induced by the usual arithmetic ordering on &lt; + .
Reference: [10] <author> J.B. Kam and J.D. Ullman. </author> <title> Monotone data flow analysis frameworks. </title> <journal> Acta Informatica, </journal> <volume> 7 </volume> <pages> 305-317, </pages> <year> 1977. </year>
Reference-contexts: every edge e, then the sum-over-all-paths values G form a fixed point of the set of equations Q. (That is, the assignment &lt; x u := G (u) &gt; satisfies the collection of equations Q.) Proof See Appendix. 2 We now establish a result similar to Kam and Ullman's result <ref> [9, 10] </ref> relating MOP and MFP. In the following theorem, the ordering on &lt; D fl + is the ordering induced by the usual arithmetic ordering on &lt; + .
Reference: [11] <author> G. Kildall. </author> <title> A unified approach to global program optimization. </title> <booktitle> In Conference Record of the First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 194-206, </pages> <address> New York, NY, 1973. </address> <publisher> ACM. </publisher>
Reference-contexts: In Section 6 we show how to extend the results to handle procedures. Section 7 presents our conclusion. 2 Preliminary Material We first review the lattice-theoretic framework for dataflow analysis developed by Kildall <ref> [11] </ref>. 1 Due to features such as inheritance subtyping a single expression may evaluate to values of several different types at run time even in a statically-typed language like C++.
Reference: [12] <author> J. Knoop and B. Steffen. </author> <title> The interprocedural coincidence theorem. </title> <editor> In U. Kastens and P. Pfahler, editors, </editor> <booktitle> Proceedings of the Fourth International Conference on Compiler Construction, Lecture Notes in Computer Science Vol. </booktitle> <volume> 641, </volume> <pages> pages 125-140. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: A precise interprocedural dataflow analysis algorithm computes the "meet-over-all-valid-paths" solution, as opposed to the "meet-over-all-paths" solution <ref> [21, 12] </ref>.
Reference: [13] <author> Hemant D. Pande and Barbara G. Ryder. </author> <title> Static type determination for C++. </title> <booktitle> In Proceedings of the Sixth Usenix C++ Technical Conference, </booktitle> <pages> pages 85-97, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: More work, however, remains to be done. Consider the type analysis problem that arises in the above-mentioned cloning optimization. There do exist simple, but effective, type analysis algorithms (for C++; see [2]) that fall into the FBS framework. Other, more powerful, type analysis algorithms <ref> [13, 14, 4] </ref>, however, are not even distributive. The results in this paper do not apply to such algorithms.
Reference: [14] <author> Hemant D. Pande and Barbara G. Ryder. </author> <title> Static type determination and aliasing for C++. </title> <type> Technical Report LCSR-TR-250, </type> <institution> Department of Computer Science, Rutgers University, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: More work, however, remains to be done. Consider the type analysis problem that arises in the above-mentioned cloning optimization. There do exist simple, but effective, type analysis algorithms (for C++; see [2]) that fall into the FBS framework. Other, more powerful, type analysis algorithms <ref> [13, 14, 4] </ref>, however, are not even distributive. The results in this paper do not apply to such algorithms.
Reference: [15] <author> J.R.C. Patterson. </author> <title> Accurate static branch prediction by value range propagation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 67-78, </pages> <year> 1995. </year>
Reference-contexts: The probability that a certain branch in the program will be taken at run time can be estimated either statically or using profiling information <ref> [15, 23, 3] </ref>. In this paper, we show how the frequency or probability of dataflow facts can be computed for a large class of dataflow problems, a class we call finite bi-distributive subset (FBS) problems, once every edge in the control-flow graph is annotated with a probability. <p> This paper explores the possibility of computing such information statically once every branch out of a conditional node is labelled with a value that indicates the probability that that branch is taken. The probability labelling itself may be computed using simple heuristics, profiling tools, or static analysis. <ref> [15, 23, 3] </ref>. Even when the labelling is computed using profiling tools, it is certainly more convenient to have to gather only this simple data at run-time, rather than having to gather, at run-time, specialized information that varies from one analysis problem to another. <p> A couple of recent papers have utilized estimates of the "probability" of specific "facts" for program optimization. Proebsting and Fischer [16] outline a register allocation algorithm that utilizes estimates of the probability of a register-allocated variable remaining in the register at a subsequent use of the variable. Patterson <ref> [15] </ref> computes the probability of various variables having various values and utilizes this information for branch prediction, which has applications to several optimizations such as instruction scheduling. These papers, however, present no results relating the quantities computed to any formally defined quantity (such as a sum-over-all-path quantity).
Reference: [16] <author> T. Proebsting and C. Fischer. </author> <title> Probabilistic register allocation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 300-310, </pages> <year> 1992. </year>
Reference-contexts: A couple of recent papers have utilized estimates of the "probability" of specific "facts" for program optimization. Proebsting and Fischer <ref> [16] </ref> outline a register allocation algorithm that utilizes estimates of the probability of a register-allocated variable remaining in the register at a subsequent use of the variable.
Reference: [17] <author> C.V. Ramamoorthy. </author> <title> Discrete markov analysis of computer programs. </title> <booktitle> In Proceedings of the ACM 20th National Conference, </booktitle> <pages> pages 386-391, </pages> <year> 1965. </year>
Reference-contexts: The problem of computing the expected frequency of execution of the various statements in a program, given a control-flow graph whose edges are labelled with a probability, has been studied previously <ref> [17, 23] </ref>. We are not aware of any previous work in generalizing these techniques to general dataflow analysis problems. We provide a theoretical foundation for dataflow frequency analysis and outline algorithms for the problem. The paper is organized as follows. <p> The problem of computing the expected frequency of execution of the various statements in a program, given a control-flow graph whose edges are labelled with a probability, has been studied previously <ref> [17, 23] </ref>. A couple of recent papers have utilized estimates of the "probability" of specific "facts" for program optimization. Proebsting and Fischer [16] outline a register allocation algorithm that utilizes estimates of the probability of a register-allocated variable remaining in the register at a subsequent use of the variable.
Reference: [18] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reachability. </title> <booktitle> In Conference Record of the Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <year> 1995. </year>
Reference-contexts: This class of dataflow analysis problems is more general than the class of separable problems (also known as gen/kill or bit-vector problems) but less general than the class of finite distributive subset problems introduced by Reps et al <ref> [18] </ref>. The problem of computing the expected frequency of execution of the various statements in a program, given a control-flow graph whose edges are labelled with a probability, has been studied previously [17, 23]. <p> the powerset 2 D of a finite set D, F 2 D ! d 2 D , the set of distributive functions from 2 D to 2 D , and the meet operation is set union. (This is essentially the intraprocedural version of the framework introduced by Reps et al. <ref> [18] </ref>. Analysis problems over 2 D whose meet operation is set intersection can be transformed into a set union problem by considering its dual, as noted in [18].) Essentially, D is a (finite) set of facts that may or may not hold true at various program points and the problem is <p> D , and the meet operation is set union. (This is essentially the intraprocedural version of the framework introduced by Reps et al. <ref> [18] </ref>. Analysis problems over 2 D whose meet operation is set intersection can be transformed into a set union problem by considering its dual, as noted in [18].) Essentially, D is a (finite) set of facts that may or may not hold true at various program points and the problem is to determine which facts hold true at each program point. <p> The function t fl is essentially the representation relation of t defined by Reps et al. (See <ref> [18] </ref>.) The representation relation of t , denoted by R t , is a binary relation on D fl . <p> The structure of the resulting set of equations is better understood by considering the exploded control-flow graph introduced by Reps et al. <ref> [18] </ref>.
Reference: [19] <author> B. Ryder and M. Paull. </author> <title> Elimination algorithms for data flow analysis. </title> <journal> ACM Computing Surveys, </journal> <volume> 18(3), </volume> <month> September </month> <year> 1986. </year>
Reference-contexts: For our purposes, it would be more efficient to adapt the various elimination-based dataflow analysis algorithms to solve this problem. (See <ref> [19] </ref> for a survey of elimination algorithms.) These algorithms are often linear or almost-linear in the size of the graph. (The Allen-Cocke interval analysis algorithm [1], for example, is linear for reducible flow graphs whose loop nesting depth is bounded by a constant.
Reference: [20] <author> M. Sagiv, T. Reps, and S. Horwitz. </author> <title> Precise interprocedural dataflow analysis with applications to constant propagation. </title> <booktitle> In Proceedings of FASE '95: Colloquium on Formal Approaches in Software Engineering, </booktitle> <pages> pages 651-665, </pages> <year> 1995. </year>
Reference: [21] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 189-233. </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: A precise interprocedural dataflow analysis algorithm computes the "meet-over-all-valid-paths" solution, as opposed to the "meet-over-all-paths" solution <ref> [21, 12] </ref>.
Reference: [22] <author> R.E. Tarjan. </author> <title> Fast algorithms for solving path problems. </title> <journal> J. ACM, </journal> <volume> 28 </volume> <pages> 594-614, </pages> <year> 1981. </year>
Reference-contexts: Tarjan's algorithm <ref> [22] </ref> is almost-linear for all reducible flow graphs. These algorithms for work for arbitrary graphs as well, but their complexity can be higher for irreducible graphs.) We can apply the elimination algorithms to either the original graph or the exploded graph. <p> The analysis of each control-flow graph, however, cannot be done as before (in the intraprocedural case), since the edges of the representation relation of the summary edges are labelled with symbolic variables instead of real values. Instead, we perform the analysis using an adaptation of Tarjan's generalized path algorithm <ref> [22] </ref>. This algorithm performs the elimination symbolically and computes a (symbolic) regular expression (i.e., an expression containing the operators +, :, and fl ) for each vertex u in the procedure p.
Reference: [23] <author> T.A. Wagner, V. Maverick, S.L. Graham, and M.A. Harrison. </author> <title> Accurate static estimators for program optimization. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 85-96, </pages> <year> 1994. </year> <month> 11 </month>
Reference-contexts: The probability that a certain branch in the program will be taken at run time can be estimated either statically or using profiling information <ref> [15, 23, 3] </ref>. In this paper, we show how the frequency or probability of dataflow facts can be computed for a large class of dataflow problems, a class we call finite bi-distributive subset (FBS) problems, once every edge in the control-flow graph is annotated with a probability. <p> The problem of computing the expected frequency of execution of the various statements in a program, given a control-flow graph whose edges are labelled with a probability, has been studied previously <ref> [17, 23] </ref>. We are not aware of any previous work in generalizing these techniques to general dataflow analysis problems. We provide a theoretical foundation for dataflow frequency analysis and outline algorithms for the problem. The paper is organized as follows. <p> One possibility we will discuss in the full paper is that of first computing just the expected execution frequency of the procedures, which can be done using just elimination techniques <ref> [23] </ref>. <p> This paper explores the possibility of computing such information statically once every branch out of a conditional node is labelled with a value that indicates the probability that that branch is taken. The probability labelling itself may be computed using simple heuristics, profiling tools, or static analysis. <ref> [15, 23, 3] </ref>. Even when the labelling is computed using profiling tools, it is certainly more convenient to have to gather only this simple data at run-time, rather than having to gather, at run-time, specialized information that varies from one analysis problem to another. <p> The problem of computing the expected frequency of execution of the various statements in a program, given a control-flow graph whose edges are labelled with a probability, has been studied previously <ref> [17, 23] </ref>. A couple of recent papers have utilized estimates of the "probability" of specific "facts" for program optimization. Proebsting and Fischer [16] outline a register allocation algorithm that utilizes estimates of the probability of a register-allocated variable remaining in the register at a subsequent use of the variable.
References-found: 23

