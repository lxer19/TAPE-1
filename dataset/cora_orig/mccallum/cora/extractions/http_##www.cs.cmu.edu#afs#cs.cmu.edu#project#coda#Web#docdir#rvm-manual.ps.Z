URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/coda/Web/docdir/rvm-manual.ps.Z
Refering-URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/coda/Web/docs-coda.html
Root-URL: 
Title: RVM Recoverable Virtual Memory  
Author: Henry H. Mashburn Mahadev Satyanarayanan 
Note: RVM Release 1.3  
Date: 29 June 1994  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: RVM provides an unstructured recoverable virtual memory. The recoverable storage is represented by Unix files or disk partitions that applications can map at page granularity into the address space of a process. Simple, non-nested atomic transactions guarantee permanence of changes to recoverable storage across system crashes. Applications can schedule transaction logging actions to enhance performance. The design stresses simplicity, ease of use, and high performance. Unix compatibility is standard, while optional Mach-specific extensions are supported for additional flexibility and performance. RVM has been extensively used in the clients and servers of the Coda File System, and in This research was supported by the Defense Advanced Research Projects Agency (Avionics Lab, Wright Research and Development Center, Aeronautical Systems Division (AFSC), U.S. Air Force, Wright-Patterson AFB, Ohio, 45433-6543 under Contract F33615-90-C-1465, ARPA Order No. 7597). The views and conclusions in this document are those of the authors and do not represent the official policies of the funding agency or Carnegie Mellon University. the Venari system.
Abstract-found: 1
Intro-found: 1
Reference: [Bernstein 87] <author> Philip A. Bernstein, Vassos Hadzilacos, Nathan Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference: [Camelot 91] <author> Jeffery L. Eppinger, Lily B. Mummert, Alfred Z. Spector (editors). Camelot and Avalon, </author> <title> A Distributed Transaction Facility. </title> <publisher> Morgan Kaufman, </publisher> <address> San Mateo, CA 94403, </address> <year> 1991. </year>
Reference-contexts: Other services can be provided by libraries and servers that use RVM, or by application-specific functions. Much of the motivation for building RVM has come from experience with Camelot <ref> [Camelot 91] </ref>, a large, full-featured transaction system. While Camelot is much more capable than RVM, it was discovered in building CODA [Coda 90], a high-availability file system, that most of the benefit of transactions was gained by using only a fraction of Camelot's facilities. <p> In this case, a quick commit is preferred to the guarantee of permanence provided by flushing. This is sometimes called a "lazy" commit <ref> [Camelot 91] </ref>. Permanence can be insured at a later time by any transaction doing a commit with flush, or by the application directly invoking the rvm_flush function.
Reference: [Coda 90] <author> Satyanarayanan, M., Kistler, J.J., Kumar, P., Okasaki, M.E., Siegel, </author> <title> E.H., Steere, D.C. Coda: A Highly Available File System for a Distributed Workstation Environment. </title> <journal> IEEE Transactions on Computers 39(4), </journal> <month> April, </month> <year> 1990. </year>
Reference-contexts: Much of the motivation for building RVM has come from experience with Camelot [Camelot 91], a large, full-featured transaction system. While Camelot is much more capable than RVM, it was discovered in building CODA <ref> [Coda 90] </ref>, a high-availability file system, that most of the benefit of transactions was gained by using only a fraction of Camelot's facilities. RVM is an experiment to discover the minimum transaction processing functionality useful in building complex applications such as file servers and other non-database systems. 1.1.
Reference: [Cooper 88] <author> Eric C. Cooper and Richard P. Draves. </author> <title> C Threads. </title> <institution> CMU-CS-88-154, School of Computer Science, Carnegie-Mellon University, </institution> <address> Pittsburgh, PA 15213, </address> <year> 1988. </year>
Reference-contexts: The log management utility rvmutl can print the log to show the application's transaction history, and has been a useful debugging tool. 2.3. Concurrency in RVM Applications have the option of using threads provided by the C Threads <ref> [Cooper 88] </ref> programming package. The application is responsible for protecting access to its data structures by concurrent threads, but can otherwise use RVM functions freely, with RVM synchronizing access to its internal structures. <p> In building the application, the choice of Unix or Mach libraries must be made. If the application is using threads, Mach must be used, and the application must also link the C Threads library and the safe version of the C library (see <ref> [Cooper 88] </ref>, p. 13). The Unix library will run on Mach/Unix, but will be strictly synchronous so threads must not be used in the application.
Reference: [Gray 86] <author> Jim Gray. </author> <title> Why do Computers Stop and What Can Be Done About It? 5th IEEE Symposium on Distributed Software and Database Systems. </title> <publisher> IEEE, </publisher> <year> 1986, </year> <pages> pages 3-12. </pages>
Reference-contexts: 1. Introduction RVM, a recoverable virtual memory system, is a mechanism to support persistent virtual memory in the face of system crashes. The current state of affairs is that software rather than hardware is limiting factor is systems reliability <ref> [Gray 86] </ref>, and so RVM is intended to assist in building more robust software. RVM's principal reliability criterion is to provide permanence of committed changes and integrity of data over operating system crashes. The fatal nature of these all-too-frequent events often leaves data structures in a shambles.
Reference: [Hagmann 87] <author> Robert Hagmann. </author> <title> Reimplementing the Cedar File System Using Logging and Group Commit. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, pages 155 - 162. Special Interest Group on Operating Systems, Association for Computing Machinery, </booktitle> <year> 1987. </year>
Reference-contexts: Alternatively, dispersing data copies in the address space can give some protection from local media errors without resorting to mirrored storage. Since only local damage is the usual failure mode, dispersed copies are not likely to be damaged simultaneously (see <ref> [Hagmann 87] </ref>). 2.1.2.
Reference: [MACH 90] <author> Robert V. Baron, David Black, William Bolosky, Jonathan Chew, Richard P. Draves, David B. Golub, Richard F. Rashid, Avadis Tevanian, Jr., Michael Wayne Young. </author> <title> MACH Kernel Interface Manual School of Computer Science, </title> <institution> Carnegie-Mellon University, </institution> <address> Pittsburgh, PA 15213, </address> <year> 1990. </year>
Reference-contexts: Applications can supply external pagers for special cases, but great care must be taken to coordinate with RVM's log truncation mechanism which updates the data file. A thorough knowledge of the Mach external pager interface (see <ref> [MACH 90] </ref>), and RVM internals will be required. Mach applications can also use the Unix copy-on-map method. The choice of method is a mapping option that is made when the first region of a segment is mapped, and can be different for each segment.
Reference: [Quick Fit 88] <author> Charles B. Weinstock and William A. Wulf. </author> <title> Quick Fit, An Efficient Algorithm for Heap Storage Allocation. </title> <journal> SIGPlan Notices 23(10), </journal> <month> October, </month> <year> 1988. </year>
Reference-contexts: Steere 6.1. Introduction to RDS The Recoverable Dynamic Storage (RDS) library provides a heap similar to that of the C library, although with persistence, for RVM segments. Additional provisions for convenient initialization and reloading of the heap after shutdown or crash are included. RDS uses the Quick Fit method <ref> [Quick Fit 88] </ref> for allocation. In this method, separate free lists are maintained for a specified number of sizes. Most programs tend to repeatedly allocate a small number of distinct sized blocks.

References-found: 8

