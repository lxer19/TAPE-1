URL: http://www.cs.mu.oz.au/tr_db/mu_95_06.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Phone: 1  
Title: Implementation and development Issues for the Linear Logic Programming Language Lygon  
Author: Michael Winikoff James Harland 
Address: Parkville, Victoria 3052 Australia  
Affiliation: Department of Computer Science The University of Melbourne  Department of Computer Science, University of Melbourne 2 Department of Computer Science, Royal Melbourne Institute of Technology  
Pubnum: Technical Report 95/6  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J.-M. Andreoli. </author> <title> Logic Programming with Focusing Proofs in Linear Logic. </title> <journal> Journal of Logic and Computation Volume 2, </journal> <volume> Number 3, </volume> <year> 1992. </year>
Reference-contexts: The correspondence between the concrete and abstract syntax is ) * N ) & ( ) -&gt; ? ) neg The interpreter's strategy for selecting the next formula to be reduced is based on the notion of synchronous and asynchronous formulae <ref> [1] </ref>. A formula is described as (a)synchronous if its top connective is (a)synchronous. Asynchronous formulae 7 are those that, due to the permutability properties of linear logic, can be selected and committed to without loss of completeness. That is, no backtracking over the choice of formula will be necessary.
Reference: [2] <author> J.-M. Andreoli and R. Pareschi. </author> <title> Linear Objects: Logical Processes with Built-in Inheritance. </title> <booktitle> Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 496-510, </pages> <address> Jerusalem, </address> <month> June, </month> <year> 1990. </year>
Reference-contexts: As a result, logic programming languages based on linear logic contain a variety of constructs which are not present in (pure) Prolog, thus providing novel and interesting extensions to the language. There have been various proposals for linear logic programming languages, including LO! <ref> [2] </ref>, Lolli [7] and ACL [8]. In this paper we describe the implementation of the language Lygon, which is based on the proof-theoretic analysis of [4]. This analysis identifies a fragment of linear logic for which the search strategy of goal-directed, or uniform, proofs is complete. <p> Succeeded. Lygon ((? neg p (a)) @ (? neg p (b))) # (p (a) * p (b)). Failed. 6.2.4 Other applications The semantics of N suggests that Lygon has potential to be applied to concurrent applications. This aspect of linear logic programming has been explored by [8] and <ref> [2] </ref>. Further discussion of applications of Lygon and a Bin Packing example can be found in [5].
Reference: [3] <author> J.-Y. Girard. </author> <title> Linear Logic. </title> <booktitle> Theoretical Computer Science Volume 50, </booktitle> <pages> pages 1-102, </pages> <year> 1987. </year>
Reference-contexts: Hence we pass the "excess" resource q to the other conjunct, and hence 3 A full introduction to linear logic is beyond the scope of this paper | see <ref> [3, 10] </ref>, amongst others, for more details. attempt to find a proof of q ` q, which is clearly provable, and without any resources remaining unused. Hence we conclude that the original sequent is provable. This may appear to be a simple enough technique. <p> For similar reasons, the courses are joined together with O, rather than . The internal and external choices are also, of course, swapped. There is far more to linear logic than can be discussed in this paper; for a more complete introduction see the papers <ref> [3, 10] </ref>, among others. 3 Linear Logic Programming As far as logic programming languages are concerned, it should be clear that linear logic provides scope for a significant extension to the features of languages such as Prolog.
Reference: [4] <author> J.A. Harland, </author> <title> D.J. Pym. A Uniform Proof-theoretic Investigation of Linear Logic Programming. </title> <journal> Journal of Logic and Computation, </journal> <volume> Volume 4, Number 2, </volume> <pages> pages 175-207, </pages> <month> April, </month> <year> 1994. </year>
Reference-contexts: There have been various proposals for linear logic programming languages, including LO! [2], Lolli [7] and ACL [8]. In this paper we describe the implementation of the language Lygon, which is based on the proof-theoretic analysis of <ref> [4] </ref>. This analysis identifies a fragment of linear logic for which the search strategy of goal-directed, or uniform, proofs is complete. This strategy forms the conceptual starting point of an implementation of the language. <p> This seems to correspond to the way that logic programs execute, in that a program is written to specify what computations are to be performed, but the overall shape of the derivation is very much determined by what goal is asked. It is shown in <ref> [4] </ref> that there is a large fragment of linear logic for which goal-directed proofs are complete, and hence forms a logic programming language, following the methodology of [9]. <p> A fuller description of these features than is possible in this paper may be found in [5]. Having found the appropriate fragment of linear logic, it then remains to determine how to implement an interpreter for the language. Whilst the notion of a resolution proof was used in <ref> [4] </ref> as a specialisation of the sequent calculus to definite formulae, there remains a significant amount of non-determinism. <p> A logic programming language is then a class of formulae for which such proofs completely characterize logical consequence [9]. An analysis along these lines for linear logic was given in <ref> [4] </ref>. <p> In <ref> [4] </ref> it is shown how the rules of the sequent calculus may be specialized for this class of formulae, and we refer to such proofs as resolution proofs.
Reference: [5] <author> J.A. Harland, </author> <title> D.J. Pym. A Note on the Implementation and Applications of Linear Logic Programming Languages. </title> <booktitle> Proceedings of the Seventeenth Annual Computer Science Conference, </booktitle> <pages> pages 647-658, </pages> <address> Christchurch, </address> <month> January, </month> <year> 1994. </year>
Reference-contexts: Such features include global variables, a mutual exclusion operator, a notion of state and various constructs for manipulating clauses. A fuller description of these features than is possible in this paper may be found in <ref> [5] </ref>. Having found the appropriate fragment of linear logic, it then remains to determine how to implement an interpreter for the language. Whilst the notion of a resolution proof was used in [4] as a specialisation of the sequent calculus to definite formulae, there remains a significant amount of non-determinism. <p> Whilst this method is technically sound, it is conceptually more complex than the lazy sequential one, and arguably less useful. As discussed in [7] and <ref> [5] </ref>, the lazy sequential technique is very useful for introducing a notion of state to logic programming languages, in that the excess resources passed from one state to another may be seen as a state resulting from one sub-computation, and passed to another. <p> This technique has some very useful applications, such as natural language parsing, updates and bin-packing programs <ref> [7, 5] </ref>. In this paper, we describe an implementation of Lygon which addresses these and other problems. In particular, this implementation uses the lazy sequential technique to deal with multiplicative rules. A recurrent theme throughout this exercise has been the principle of making the proof search process deterministic. <p> Failed. 6.2.4 Other applications The semantics of N suggests that Lygon has potential to be applied to concurrent applications. This aspect of linear logic programming has been explored by [8] and [2]. Further discussion of applications of Lygon and a Bin Packing example can be found in <ref> [5] </ref>.
Reference: [6] <author> M. Winikoff, J. Harland. </author> <title> Deterministic Resource Management for the Linear Logic Programming Language Lygon. </title> <type> Technical Report 94/23. </type> <institution> Department of Computer Science, the University of Melbourne. </institution> <year> 1994. </year>
Reference-contexts: The modified rules are too long to be given here and appear in appendix B. Note that these rules have been superseded. The current version of the rules can be found in <ref> [6] </ref> 5 . Whilst this isn't a complete list of the issues involved in the implementation they indicate those most specific to Lygon. 6 Examples As with other declarative languages, the formalism behind the language is only half the story.
Reference: [7] <author> J. Hodas, D. Miller. </author> <title> Logic Programming in a Fragment of Intuitionistic Linear Logic: Extended Abstract. </title> <booktitle> Proceedings of the Symposium on Logic in Computer Science, </booktitle> <pages> pages 32-42, </pages> <address> Amsterdam, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: As a result, logic programming languages based on linear logic contain a variety of constructs which are not present in (pure) Prolog, thus providing novel and interesting extensions to the language. There have been various proposals for linear logic programming languages, including LO! [2], Lolli <ref> [7] </ref> and ACL [8]. In this paper we describe the implementation of the language Lygon, which is based on the proof-theoretic analysis of [4]. This analysis identifies a fragment of linear logic for which the search strategy of goal-directed, or uniform, proofs is complete. <p> A better way to solve the problem of splitting the program is to do it lazily and sequentially, which is the approach taken in Lolli <ref> [7] </ref>. Using this method, the entire program is passed to the first conjunct, which uses whatever resources are necessary, and passes any excess resources to the second conjunct. <p> Whilst this method is technically sound, it is conceptually more complex than the lazy sequential one, and arguably less useful. As discussed in <ref> [7] </ref> and [5], the lazy sequential technique is very useful for introducing a notion of state to logic programming languages, in that the excess resources passed from one state to another may be seen as a state resulting from one sub-computation, and passed to another. <p> This technique has some very useful applications, such as natural language parsing, updates and bin-packing programs <ref> [7, 5] </ref>. In this paper, we describe an implementation of Lygon which addresses these and other problems. In particular, this implementation uses the lazy sequential technique to deal with multiplicative rules. A recurrent theme throughout this exercise has been the principle of making the proof search process deterministic. <p> This aspect of linear logic programming has been explored by [8] and [2]. Further discussion of applications of Lygon and a Bin Packing example can be found in [5]. In addition work on the application of Lolli to natural language processing carries over to Lygon <ref> [7] </ref>. 7 Conclusions and Further Work Lygon's origins were in a proof-theoretic analysis of goal-directed provability in linear logic, and hence the task of the implementor is to find a deterministic way to search for proofs in a certain fragment of linear logic.
Reference: [8] <author> N. Kobayash, A. Yonezawa. </author> <title> ACL A Concurrent Linear Logic Programming Paradigm. </title> <booktitle> Proceedings of the International Logic Programming Symposium, </booktitle> <pages> pages 279-294, </pages> <address> Vancouver, </address> <month> October, </month> <year> 1993. </year>
Reference-contexts: As a result, logic programming languages based on linear logic contain a variety of constructs which are not present in (pure) Prolog, thus providing novel and interesting extensions to the language. There have been various proposals for linear logic programming languages, including LO! [2], Lolli [7] and ACL <ref> [8] </ref>. In this paper we describe the implementation of the language Lygon, which is based on the proof-theoretic analysis of [4]. This analysis identifies a fragment of linear logic for which the search strategy of goal-directed, or uniform, proofs is complete. <p> Succeeded. Lygon ((? neg p (a)) @ (? neg p (b))) # (p (a) * p (b)). Failed. 6.2.4 Other applications The semantics of N suggests that Lygon has potential to be applied to concurrent applications. This aspect of linear logic programming has been explored by <ref> [8] </ref> and [2]. Further discussion of applications of Lygon and a Bin Packing example can be found in [5].
Reference: [9] <author> D. Miller, G. Nadathur, F. Pfenning, A. Scedrov. </author> <title> Uniform Proofs as a Foundation for Logic Programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> Volume 51, </volume> <pages> pages 125-157, </pages> <year> 1991. </year>
Reference-contexts: It is shown in [4] that there is a large fragment of linear logic for which goal-directed proofs are complete, and hence forms a logic programming language, following the methodology of <ref> [9] </ref>. This may be thought of as using a particular method of proof search, which appears to be particularly applicable to computational tasks, to determine a class of formulae (known as definite formulae) which may be used as a logic programming language. <p> A logic programming language is then a class of formulae for which such proofs completely characterize logical consequence <ref> [9] </ref>. An analysis along these lines for linear logic was given in [4].
Reference: [10] <author> A. Scedrov. </author> <title> A Brief Guide to Linear Logic. </title> <booktitle> in Current Trends in Theoretical Computer Science. </booktitle> <editor> G. Rozenberg and A. Salolmaa (eds.), </editor> <publisher> World Scientific, </publisher> <year> 1993. </year>
Reference-contexts: Hence we pass the "excess" resource q to the other conjunct, and hence 3 A full introduction to linear logic is beyond the scope of this paper | see <ref> [3, 10] </ref>, amongst others, for more details. attempt to find a proof of q ` q, which is clearly provable, and without any resources remaining unused. Hence we conclude that the original sequent is provable. This may appear to be a simple enough technique. <p> For similar reasons, the courses are joined together with O, rather than . The internal and external choices are also, of course, swapped. There is far more to linear logic than can be discussed in this paper; for a more complete introduction see the papers <ref> [3, 10] </ref>, among others. 3 Linear Logic Programming As far as logic programming languages are concerned, it should be clear that linear logic provides scope for a significant extension to the features of languages such as Prolog.
References-found: 10

