URL: http://www.cs.iastate.edu/tech-reports/TR94-02b.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: The Direct Execution of SPECS-C++: A Model-Based Specification Languagefor C++ Classes TR94-02b  
Author: Tim Wahls, Albert L. Baker and Gary T. Leavens 
Address: 226 Atanasoff Ames, IA 50011  
Affiliation: Iowa State University of Science and Technology Department of Computer Science  
Date: November 18, 1994  
Abstract-found: 0
Intro-found: 1
Reference: [BL90] <author> V. Berzins and Luqi. </author> <title> Languages for Specification, Design, and Prototyping. </title> <editor> In P. A. Ng and R. T. Yeh, editors, </editor> <booktitle> Modern Software Engineering: Foundations and Current Perspective, chapter 4, </booktitle> <pages> pages 83 - 118. </pages> <publisher> Van Nostrand Reinhold, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Typically, either the specifier must provide the algorithms needed for executing the specification <ref> [LL91, BL90, ZS86, LB89] </ref>, or execution is based on translating the specification to Prolog [TC89, WE92, DKC90].
Reference: [BM93] <author> Paulo Borba and Silvio Meira. </author> <title> From VDM Specifications to Functional Prototypes. </title> <journal> The Journal of Systems and Software, </journal> <volume> 21(3):267 - 278, </volume> <month> June </month> <year> 1993. </year>
Reference-contexts: This technique of evaluating quantifiers with reductions is common in the literature <ref> [BM93] </ref>. In the executable subset, set comprehensions must be of the form: -F (x) | (BP (x)) /" P where BP (x) and P are used in precisely the same manner as they were in the definitions of the executable quantified assertions.
Reference: [BMR93] <author> Alex Borgida, John Mylopoulos, and Raymond Reiter. </author> ... <title> And Nothing Else Changes: The Frame Problem in Procedure Specifications. </title> <booktitle> In Proceedings Fifteenth International Conference on Software Engineering, </booktitle> <address> Baltimore, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: However, additional frame axioms are often required, as member function specifications don't always completely specify all post-state values. While extra explicit frame axioms can be included in the post-condition, doing so leads to large and unreadable specifications, along with a number of other problems <ref> [BMR93] </ref>. The technique used in executing SPECS-C++ is to embed default frame axioms in the specification language. This is demonstrated in the section on evaluating constraints into post-state values (Section 3.2.3). For sets, the default frame axiom is to find a minimal set satisfying the post-condition.
Reference: [CDD + 90] <author> D. Carrington, D. Duke, R. Duke, P. King, G. A. Rose, and G. Smith. Object-Z: </author> <title> An Object-Oriented Extension to Z. </title> <editor> In S. Vuong, editor, </editor> <booktitle> Formal Description Techniques, II (FORTE'89), </booktitle> <pages> pages 281-296. </pages> <publisher> Elsevier Science Publishers (North-Holland), </publisher> <year> 1990. </year>
Reference-contexts: We are also unsure of the usefulness of errors reported by the reduction algorithm in debugging the specification that the graph was derived from. Another work with some relation to our own is the structural mapping from Object-Z <ref> [CDD + 90] </ref> to C++ of Rafsanjani et. al. [RC93]. This mapping is an informal guideline for producing C++ implementations from Object-Z specifications. Object-Z classes are mapped to C++ classes, operations to virtual member functions, and so on.
Reference: [DKC90] <author> A.J.J. Dick, P.J. Krause, and J. Cozens. </author> <title> Computer Aided Transformation of Z into Pro-log. </title> <editor> In J.E. Nicholls, editor, </editor> <booktitle> Z User Workshop, Oxford 1989, Workshops in Computing, </booktitle> <pages> pages 71-85. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Typically, either the specifier must provide the algorithms needed for executing the specification [LL91, BL90, ZS86, LB89], or execution is based on translating the specification to Prolog <ref> [TC89, WE92, DKC90] </ref>. In the former case, the specifier is forced to work in an impoverished specification language that is often almost indistinguishable from modern functional programming languages, and the algorithmic information that must be provided is a potential source of implementation bias [Jon90].
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: The technique is described in the context of the specification language SPECS-C++, which is a VDM-like language specialized for specifying C++ <ref> [ES90, Str91] </ref> classes. However, our execution technique is not tied to any special feature of SPECS-C++, and so would work as well for VDM specifications as it does for those written in SPECS-C++. An informal description of SPECS-C++ is presented in the next section.
Reference: [GHG + 93] <author> John V. Guttag, James J. Horning, S. J. Garland, K. D. Jones, A. Modet, and J. M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: These public member functions correspond to the exported operations of a VDM module, and are specified using pre- and post-conditions, much like implicit VDM specifications. However, the precise meaning of a class specification is different than the meaning of a VDM module, because SPECS-C++ is an interface specification language <ref> [GHW85, GHG + 93, Lam89] </ref> for C++. <p> The fase3 approach is very similar to that taken in the Larch <ref> [GHW85, GHG + 93] </ref> family of specification languages, as it is two-tiered, consisting of the fase3 shared language and the bf fase3/C++ interface language for C++. The shared language is where most specification occurs, and so where interesting execution occurs as well.
Reference: [GHW85] <author> John V. Guttag, James J. Horning, and Jeannette M. Wing. </author> <title> The Larch Family of Specification Languages. </title> <journal> IEEE Software, </journal> <volume> 2(4), </volume> <month> September </month> <year> 1985. </year>
Reference-contexts: These public member functions correspond to the exported operations of a VDM module, and are specified using pre- and post-conditions, much like implicit VDM specifications. However, the precise meaning of a class specification is different than the meaning of a VDM module, because SPECS-C++ is an interface specification language <ref> [GHW85, GHG + 93, Lam89] </ref> for C++. <p> The fase3 approach is very similar to that taken in the Larch <ref> [GHW85, GHG + 93] </ref> family of specification languages, as it is two-tiered, consisting of the fase3 shared language and the bf fase3/C++ interface language for C++. The shared language is where most specification occurs, and so where interesting execution occurs as well.
Reference: [GMP92] <author> David Guaspari, Carla Marceau, and Wolfgang Polak. </author> <title> Formal Verification of Ada Programs. </title> <editor> In Ursala Martin and Jeanete M. Wing, editors, </editor> <booktitle> First International Workshop on Larch, Dedham 1992, </booktitle> <pages> pages 104-141. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The interface and the meaning are both part of the specification that must be matched by the implementation. As in Larch/Ada <ref> [GMP92] </ref> and LM3 [Jon92], SPECS-C++ specifications are embedded in implementation code. A SPECS-C++ specification is placed in specially formatted comments within a C++ header file. This automatically makes the interfaces match, and avoids redundancy.
Reference: [Hay87] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Thus it is not surprising that many executable specification languages have been developed. Unfortunately, these languages almost always force the specifier to work at a much lower level of abstraction than is normally employed in writing specifications in non-executable model-based specification languages, such as VDM [Jon90] and Z <ref> [Hay87, Spi88, Spi89, Spi92] </ref>. Typically, either the specifier must provide the algorithms needed for executing the specification [LL91, BL90, ZS86, LB89], or execution is based on translating the specification to Prolog [TC89, WE92, DKC90].
Reference: [Hen86] <author> Peter Henderson. </author> <title> Functional Programming, Formal Specification, and Rapid Prototyp-ing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(2), </volume> <month> February </month> <year> 1986. </year>
Reference-contexts: Even some specifications that use quantifiers are executable. EPROL is part of the EPROS system, which provides tool support for evolutionary and functionality prototyping and for building the user interface to the prototype. Similarly, the me too specification language <ref> [Hen86] </ref> executes much the same subset of VDM by embedding specifications in LISP. The UK's National Physical Laboratory has developed a syntax-directed editor for entering VDM specifications with a mode called SMLVIEW [O'N92a, O'N92b] that displays the VDM specification entered compiled into Standard ML (SML) [Pau91] code.
Reference: [HI86] <author> Sharam Hekmatpour and Darrel C. Ince. </author> <title> A Formal Specification-Based Prototyping System. </title> <editor> In D. Barnes and P. Brown, editors, </editor> <booktitle> Software Engineering 86, </booktitle> <pages> pages 317 - 335. </pages> <publisher> Peter Peregrinus Ltd., </publisher> <address> London, UK, </address> <year> 1986. </year>
Reference-contexts: A number of existing executable specification languages/techniques allow the execution of implicit specifications | that is, specifications that do not explicitly provide the necessary algorithms. We first briefly describe several of these languages, and then discuss some of the limitations that these languages share. The EPROL specification language <ref> [HI88, HI86] </ref> makes a fairly large subset of VDM executable by compiling specifications to LISP. Even some specifications that use quantifiers are executable. EPROL is part of the EPROS system, which provides tool support for evolutionary and functionality prototyping and for building the user interface to the prototype.
Reference: [HI88] <author> Sharam Hekmatpour and Darrel C. Ince. </author> <title> Software Prototyping, Formal Methods, and VDM. </title> <publisher> Addison-Wesley, </publisher> <address> Wokingham, England, </address> <year> 1988. </year>
Reference-contexts: A number of existing executable specification languages/techniques allow the execution of implicit specifications | that is, specifications that do not explicitly provide the necessary algorithms. We first briefly describe several of these languages, and then discuss some of the limitations that these languages share. The EPROL specification language <ref> [HI88, HI86] </ref> makes a fairly large subset of VDM executable by compiling specifications to LISP. Even some specifications that use quantifiers are executable. EPROL is part of the EPROS system, which provides tool support for evolutionary and functionality prototyping and for building the user interface to the prototype.
Reference: [Jon90] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, 1990. 19 </note>
Reference-contexts: Thus it is not surprising that many executable specification languages have been developed. Unfortunately, these languages almost always force the specifier to work at a much lower level of abstraction than is normally employed in writing specifications in non-executable model-based specification languages, such as VDM <ref> [Jon90] </ref> and Z [Hay87, Spi88, Spi89, Spi92]. Typically, either the specifier must provide the algorithms needed for executing the specification [LL91, BL90, ZS86, LB89], or execution is based on translating the specification to Prolog [TC89, WE92, DKC90]. <p> In the former case, the specifier is forced to work in an impoverished specification language that is often almost indistinguishable from modern functional programming languages, and the algorithmic information that must be provided is a potential source of implementation bias <ref> [Jon90] </ref>. If the specification is translated to Prolog, the person using the executable specification is exposed to the inefficiency and non-logical features of Prolog (cut, dependence on order of clauses). Such fl Wahls's work is supported by a fellowship provided by IBM Rochester.
Reference: [Jon92] <author> K. D. Jones. </author> <title> A Semantics for Larch/Modula-3 Interface Language. </title> <editor> In Ursala Martin and Jeanete M. Wing, editors, </editor> <booktitle> First International Workshop on Larch, Dedham 1992, </booktitle> <pages> pages 142-158. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The interface and the meaning are both part of the specification that must be matched by the implementation. As in Larch/Ada [GMP92] and LM3 <ref> [Jon92] </ref>, SPECS-C++ specifications are embedded in implementation code. A SPECS-C++ specification is placed in specially formatted comments within a C++ header file. This automatically makes the interfaces match, and avoids redundancy.
Reference: [KK93] <author> Samuel Kamin and Tim Kraus. </author> <title> Executable Specifications of C++ Classes. </title> <note> submitted for publication, </note> <year> 1993. </year>
Reference-contexts: However, this problem does seem reasonably tractable, and so this is an area for further research. 15 5 Related Work The most closely related work is the fase3/C++ language of Kamin and Kraus <ref> [KK93, Kra88] </ref>, as it is a (mostly) executable interface specification language for C++ classes.
Reference: [Kra88] <author> Tim Kraus. </author> <title> The FASE3 System for Executable Data Type Specification. </title> <type> Master's thesis, </type> <institution> University of Illinois, Urbana, Illinois, </institution> <year> 1988. </year> <type> Technical Report 87-1789. </type>
Reference-contexts: However, this problem does seem reasonably tractable, and so this is an area for further research. 15 5 Related Work The most closely related work is the fase3/C++ language of Kamin and Kraus <ref> [KK93, Kra88] </ref>, as it is a (mostly) executable interface specification language for C++ classes.
Reference: [Lam89] <author> Leslie Lamport. </author> <title> A Simple Approach to Specifying Concurrent Systems. </title> <journal> Communications of the ACM, </journal> <volume> 32(1) </volume> <pages> 32-45, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: These public member functions correspond to the exported operations of a VDM module, and are specified using pre- and post-conditions, much like implicit VDM specifications. However, the precise meaning of a class specification is different than the meaning of a VDM module, because SPECS-C++ is an interface specification language <ref> [GHW85, GHG + 93, Lam89] </ref> for C++.
Reference: [LB89] <author> J. Leszczylowski and J.M. Bieman. PROSPER: </author> <title> A Language for Specification by Pro-totyping. </title> <journal> Computer Languages, </journal> <volume> 14(3) </volume> <pages> 165-180, </pages> <year> 1989. </year>
Reference-contexts: Typically, either the specifier must provide the algorithms needed for executing the specification <ref> [LL91, BL90, ZS86, LB89] </ref>, or execution is based on translating the specification to Prolog [TC89, WE92, DKC90].
Reference: [Lea93] <author> Gary T. Leavens. </author> <title> Inheritance of Interface Specifications (Extended Abstract). </title> <type> Technical Report 93-23, </type> <institution> Iowa State University, Department of Computer Science, </institution> <month> September </month> <year> 1993. </year> <booktitle> Appears in the Workshop on Interface Definition Languages, </booktitle> <address> WIDL '94. </address> <note> Available by anonymous ftp from ftp.cs.iastate.edu or by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: The syntax and semantics used are similar to C++, so that a class specified as a derived class inherits the abstract data members and (the specifications of the) member functions of its base (super) class <ref> [Lea93] </ref>. We plan to add specification inheritance to the SPECS-C++ interpreter, and so to the executable subset of SPECS-C++. Even in its unfinished state, the SPECS-C++ interpreter can already be used in two important ways. The first is that it provides a formal semantics for a large subset of SPECS-C++.
Reference: [Lel88] <author> Wm Leler. </author> <title> Constraint Programming Languages. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas-sachusetts, </address> <year> 1988. </year>
Reference-contexts: For example, x' &lt; 3 or !(x' = 3) do give some information about the post-state value of x, but both are satisfied by an infinite number of post-state values. One possible extension of the work presented here is to use constraint-satisfaction techniques <ref> [Lel88] </ref> both for gleaning more information from these kinds of expressions and for generalizing what can represent 11 a post-state value in a constraint. Set comprehensions, abstract function references, and calls to member functions are constructive if they contain no occurrences of primed identifiers. <p> They limit the possible post-state values that can be constructed. As these limits are checked when the nonconstructive portion of the post-condition is evaluated, the evaluation technique already utilizes such assertions as well as can be expected in the absence of constraint-satisfaction techniques such as those discussed in <ref> [Lel88] </ref>. * Post-state values used as arguments to abstract function references and member functions calls in post-conditions. Assertions like someabsfun (foo') do not help in constructing the post-state value for foo, at least as far as the work described here is concerned.
Reference: [LL91] <author> Peter Gorm Larsen and Poul Btgh Lassen. </author> <title> An Executable Subset of Meta-IV with Loose Specification. In VDM '91: Formal Software Development Methods. VDM Europe, </title> <publisher> Springer-Verlag, </publisher> <month> March </month> <year> 1991. </year>
Reference-contexts: Typically, either the specifier must provide the algorithms needed for executing the specification <ref> [LL91, BL90, ZS86, LB89] </ref>, or execution is based on translating the specification to Prolog [TC89, WE92, DKC90].
Reference: [O'N92a] <author> Guy O'Neill. </author> <title> Automatic Translation of VDM Specifications into Standard ML Programs. </title> <type> Technical Report DITC 196/92, </type> <institution> National Physical Laboratory, Teddington, </institution> <address> Middlesex TW11 OLW, United Kingdom, </address> <month> February </month> <year> 1992. </year>
Reference-contexts: Similarly, the me too specification language [Hen86] executes much the same subset of VDM by embedding specifications in LISP. The UK's National Physical Laboratory has developed a syntax-directed editor for entering VDM specifications with a mode called SMLVIEW <ref> [O'N92a, O'N92b] </ref> that displays the VDM specification entered compiled into Standard ML (SML) [Pau91] code. <p> In the case of SMLVIEW, these limitations can be seen in the description of the subset of VDM that can be executed (see Appendix J of <ref> [O'N92a] </ref>). Although the authors have been unable to locate any similar characterization of the subset of VDM that EPROL or me too can execute, the example specifications that have been published also exhibit these same limitations.
Reference: [O'N92b] <author> Guy O'Neill. </author> <title> Automatic Translation of VDM Specifications into Standard ML Programs. </title> <journal> The Computer Journal, </journal> <volume> 35(6) </volume> <pages> 623-624, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Similarly, the me too specification language [Hen86] executes much the same subset of VDM by embedding specifications in LISP. The UK's National Physical Laboratory has developed a syntax-directed editor for entering VDM specifications with a mode called SMLVIEW <ref> [O'N92a, O'N92b] </ref> that displays the VDM specification entered compiled into Standard ML (SML) [Pau91] code.
Reference: [Pau91] <author> L. C. Paulson. </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press, </publisher> <address> Cam-bridge, </address> <year> 1991. </year>
Reference-contexts: The UK's National Physical Laboratory has developed a syntax-directed editor for entering VDM specifications with a mode called SMLVIEW [O'N92a, O'N92b] that displays the VDM specification entered compiled into Standard ML (SML) <ref> [Pau91] </ref> code. The translation scheme is apparently fairly direct, so the VDM specification must be somewhat close to an SML program for this translation to work, and the subset of VDM that can be translated is relatively small. <p> We have a literate 2 Standard ML (SML) <ref> [Pau91] </ref> implementation of an interpreter for a subset of SPECS-C++. This SML implementation should be thought of as a prototype and a demonstration of the feasibility of the execution technique, as it uses an abstract syntax for SPECS-C++ that is too cumbersome for actually writing specifications.
Reference: [Ram91] <author> Norman Ramsey. </author> <title> Literate Programming Tools Need Not Be Complex. </title> <type> Technical Report CS-TR-351-91, </type> <institution> Princeton University, </institution> <year> 1991. </year>
Reference-contexts: The next section describes the executable subset of SPECS-C++ and the execution technique used in the SML implementation. In the interest of brevity, no SML code is presented, but is available in [WBL94]. 2 The interpreter is being developed with the aid of the literate programming tool Noweb <ref> [Ram91] </ref>.
Reference: [RC93] <author> G-H. B. Rafsanjani and S. J. Colwill. </author> <title> From Object-Z to C ++ : A Structural Mapping. </title> <editor> In J. P. Bowen and J. E. Nicholls, editors, </editor> <booktitle> Z User Workshop, London 1992, Workshops in Computing, </booktitle> <pages> pages 166-179. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: We are also unsure of the usefulness of errors reported by the reduction algorithm in debugging the specification that the graph was derived from. Another work with some relation to our own is the structural mapping from Object-Z [CDD + 90] to C++ of Rafsanjani et. al. <ref> [RC93] </ref>. This mapping is an informal guideline for producing C++ implementations from Object-Z specifications. Object-Z classes are mapped to C++ classes, operations to virtual member functions, and so on.
Reference: [Spi88] <author> J. M. Spivey. </author> <title> Understanding Z: A Specification Language and its Formal Semantics. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1988. </year>
Reference-contexts: Thus it is not surprising that many executable specification languages have been developed. Unfortunately, these languages almost always force the specifier to work at a much lower level of abstraction than is normally employed in writing specifications in non-executable model-based specification languages, such as VDM [Jon90] and Z <ref> [Hay87, Spi88, Spi89, Spi92] </ref>. Typically, either the specifier must provide the algorithms needed for executing the specification [LL91, BL90, ZS86, LB89], or execution is based on translating the specification to Prolog [TC89, WE92, DKC90].
Reference: [Spi89] <author> J. M. Spivey. </author> <title> An Introduction to Z and Formal Specifications. </title> <journal> Software Engineering Journal, </journal> <month> January </month> <year> 1989. </year>
Reference-contexts: Thus it is not surprising that many executable specification languages have been developed. Unfortunately, these languages almost always force the specifier to work at a much lower level of abstraction than is normally employed in writing specifications in non-executable model-based specification languages, such as VDM [Jon90] and Z <ref> [Hay87, Spi88, Spi89, Spi92] </ref>. Typically, either the specifier must provide the algorithms needed for executing the specification [LL91, BL90, ZS86, LB89], or execution is based on translating the specification to Prolog [TC89, WE92, DKC90].
Reference: [Spi92] <author> J. M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <note> second edition, 1992. ISBN 013983768X. 20 </note>
Reference-contexts: Thus it is not surprising that many executable specification languages have been developed. Unfortunately, these languages almost always force the specifier to work at a much lower level of abstraction than is normally employed in writing specifications in non-executable model-based specification languages, such as VDM [Jon90] and Z <ref> [Hay87, Spi88, Spi89, Spi92] </ref>. Typically, either the specifier must provide the algorithms needed for executing the specification [LL91, BL90, ZS86, LB89], or execution is based on translating the specification to Prolog [TC89, WE92, DKC90].
Reference: [Str91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas--sachusetts, </address> <note> second edition, </note> <year> 1991. </year>
Reference-contexts: The technique is described in the context of the specification language SPECS-C++, which is a VDM-like language specialized for specifying C++ <ref> [ES90, Str91] </ref> classes. However, our execution technique is not tied to any special feature of SPECS-C++, and so would work as well for VDM specifications as it does for those written in SPECS-C++. An informal description of SPECS-C++ is presented in the next section. <p> Two major extensions of the interpreter are planned. These extensions will add constructs for dealing with SPECS-C++ abstractions of C++ objects and for specification inheritance. In C++, "An object is a region of storage" <ref> [Str91] </ref>. Equivalently, an object may be thought of as a cell in memory, or a value and its address. In SPECS-C++, we are concerned with distinguishing between objects and values because objects can be mutated and aliased, while values cannot.
Reference: [TC89] <author> R.B. Terwilliger and R.H. Campbell. </author> <title> PLEASE: Executable Specifications for Incremental Software Development. </title> <journal> Journal of Systems and Software, </journal> <volume> 10(2), </volume> <month> September </month> <year> 1989. </year>
Reference-contexts: Typically, either the specifier must provide the algorithms needed for executing the specification [LL91, BL90, ZS86, LB89], or execution is based on translating the specification to Prolog <ref> [TC89, WE92, DKC90] </ref>. In the former case, the specifier is forced to work in an impoverished specification language that is often almost indistinguishable from modern functional programming languages, and the algorithmic information that must be provided is a potential source of implementation bias [Jon90].
Reference: [WBL93] <author> Tim Wahls, Albert L. Baker, and Gary T. Leavens. </author> <title> An Executable Semantics for a Formalized Data Flow Diagram Specification Language. </title> <type> Technical Report TR93-27, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa 50011, </institution> <note> Novem-ber 1993. available by anonymous ftp from ftp.cs.iastate.edu and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: Secondly, this work provides an executable subset of SPECS-C++, and the means to execute specifications written in the subset. Thus, a specification can serve as a prototype of the finished system. Some of the advantages for the specifier and client are <ref> [WBL93] </ref>: 1. Validating specifications. The specifier can now test and debug a specification in much the same way that a programmer would validate a program. This pushes validation into the specification stage of the software development process. 2. Understanding formal specifications.
Reference: [WBL94] <author> Tim Wahls, Albert L. Baker, and Gary T. Leavens. </author> <title> The Direct Execution of SPECS-C++: A Model-Based Specification Language for C++ Classes. </title> <type> Technical Report TR94-02, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa 50011, </institution> <month> February </month> <year> 1994. </year> <note> available by anonymous ftp from ftp.cs.iastate.edu and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: The next section describes the executable subset of SPECS-C++ and the execution technique used in the SML implementation. In the interest of brevity, no SML code is presented, but is available in <ref> [WBL94] </ref>. 2 The interpreter is being developed with the aid of the literate programming tool Noweb [Ram91].
Reference: [WE92] <author> M.M. West and B.M. Eaglestone. </author> <title> Software development: two approaches to animation of Z specifications using Prolog. </title> <journal> Software Engineering Journal, </journal> <volume> 7(4) </volume> <pages> 264-276, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Typically, either the specifier must provide the algorithms needed for executing the specification [LL91, BL90, ZS86, LB89], or execution is based on translating the specification to Prolog <ref> [TC89, WE92, DKC90] </ref>. In the former case, the specifier is forced to work in an impoverished specification language that is often almost indistinguishable from modern functional programming languages, and the algorithmic information that must be provided is a potential source of implementation bias [Jon90].
Reference: [ZS86] <author> P. Zave and W. Schell. </author> <title> Salient Features of an Executable Specification Language and Its Environment. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(2):312 - 325, </volume> <month> February </month> <year> 1986. </year>
Reference-contexts: Typically, either the specifier must provide the algorithms needed for executing the specification <ref> [LL91, BL90, ZS86, LB89] </ref>, or execution is based on translating the specification to Prolog [TC89, WE92, DKC90].
References-found: 36

