URL: http://pertsserver.cs.uiuc.edu/papers/LiRDTBSSHS93.ps
Refering-URL: http://pertsserver.cs.uiuc.edu/papers/
Root-URL: http://www.cs.uiuc.edu
Title: PERTS: A Prototyping Environment for Real-Time Systems  
Author: Jane W. S. Liu Juan-Luis Redondo Zhong Deng Too-Seng Tia Riccardo Bettati Ami Silberman Matthew Storch Rhan Ha Wei-Kuan Shih 
Keyword: Prototyping tools, schedulability analysis, validation  
Note: May 1, 1993  
Address: Urbana, Illinois 61801  
Affiliation: Department of Computer Science University of Illinois  
Email: Email address: janeliu@cs.uiuc.edu  
Phone: Phone: (217) 333-0135  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Van Tilborg, A. M. and G. M. Koob, </author> <title> Foundations of Real-Time Computing: Scheduling and Resource Management, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference: 2. <author> Van Tilborg, A. M. and G. M. Koob, </author> <title> Foundations of Real-Time Computing: Formal Methods and Specifications, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference: 3. <author> Liu, J. W. S., K. J. Lin, W. K. Shih, A. C. Yu, J. Y. Chung, and W. Zhao, </author> <title> ``Algorithms for Scheduling Imprecise Computations,'' </title> <booktitle> IEEE Computer, </booktitle> <month> May </month> <year> 1991, </year> <pages> pp. 58-68. </pages>
Reference: 4. <author> Liu, J. W. S., K. J. Lin, and C. L. Liu, </author> <title> ``Imprecise Computations: A Means to Provide Scheduling Flexibility and Enhance Dependability,'' in Readings on Real-Time Systems, Edited by Y. </title> <editor> Lee and M. Krishna, </editor> <publisher> IEEE Press. </publisher>
Reference: 5. <author> Tokuda, H. and C. W. Mercer, </author> <title> ``A Real-Time Tool Set for the ARTS Kernel,'' </title> <booktitle> Proceedings of the 9th IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1988. </year>
Reference-contexts: These systems all attempt to reduce the complexity in real-time system development. The advanced algorithms and tools available in PERTS distinguish it from the other systems. The PERTS schedulability analysis system has the capability of Scheduler 1-2-3 <ref> [5] </ref> but will be more versatile and powerful.
Reference: 6. <author> Luqi, </author> <title> ``Software Evolution Through Rapid Prototyping,'' </title> <booktitle> IEEE Computer, </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: PERTS differs from most real-time system prototyping and development tools, and complements them, both in capabilities and intended use. Many such systems provide an integrated environment with a full range of tools for requirement tracing, program construction, software reuse, etc. The experimental system CAPS <ref> [6] </ref> is an example. PERTS is not designed to be a substitute for CAPS or other computer-aided software prototyping systems. Rather, PERTS focuses on providing rigorous tools and system building blocks that are not available in these systems. The rest of the paper is organized as follows.
Reference: 7. <author> Liu, C. L. and J. W. Layland, </author> <title> ``Scheduling Algorithms for Multiprogramming in a Hard-Real-Time Environment,'' </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> Vol. 20, No. 1, </volume> <pages> pp. 46-61, </pages> <month> January </month> <year> 1973, </year>
Reference-contexts: In a system built in the framework of the periodic-task model, tasks are statically bound to processors. When the tasks on each processor are scheduled according to a priority-driven algorithm that assigns fixed priorities to tasks (such as the rate-monotonic algorithm <ref> [7] </ref>), and are synchronized according to a resource access control protocol that controls priority inversion and prevents deadlocks (such as the priority-ceiling protocol [10-13]), there is a set of necessary and sufficient conditions which allows us to determine whether a set of tasks is schedulable. <p> For example, if tasks are scheduled according to a fixed-priority-driven algorithm, it is not necessary for jobs in periodic tasks to be released periodically. A schedulability test based on known schedulability conditions assumes that the job being analyzed is released at a worst-case instant (known as a critical instant <ref> [7] </ref>). Consequently, jitters that delay the release times of jobs but do not increase the incremental demand for processor time will not invalidate the conclusion that all periodic tasks are schedulable. It is also not necessary for the jobs to execute for exactly their worst-case execution times. <p> BASIC SCHEDULABILITY ANALYZER This section describes the functionality of the basic schedulability analyzer and its window-based user interface. This system of tools is implemented in C++ and runs under X-window. (A detailed description of its features can be found in [23].) Currently, the rate-monotonic (RM) algorithm <ref> [7] </ref>, deadline-monotonic (DM) algorithm [8] and earlist-deadline-first algorithm [7] are supported. The supported resource access control protocols include the non-preemptive critical section approach (NPC) [9], the basic priority-inheritance protocol (PI), priority-ceiling protocol (PCP) [10,13] and the stack-based protocol (SBP) [14]. <p> This system of tools is implemented in C++ and runs under X-window. (A detailed description of its features can be found in [23].) Currently, the rate-monotonic (RM) algorithm <ref> [7] </ref>, deadline-monotonic (DM) algorithm [8] and earlist-deadline-first algorithm [7] are supported. The supported resource access control protocols include the non-preemptive critical section approach (NPC) [9], the basic priority-inheritance protocol (PI), priority-ceiling protocol (PCP) [10,13] and the stack-based protocol (SBP) [14]. The priority-ceiling protocol has been extended to handle multiple units of resources.
Reference: 8. <author> Leung, J. and J. Whitehead, </author> <title> ``On the Complexity of Fixed-Priority Scheduling of Periodic, Real-Time Tasks,'' Performance Evaluation, </title> <booktitle> 2, </booktitle> <pages> pp. 237-250, </pages> <year> 1982. </year> <month> 31 </month>
Reference-contexts: This system of tools is implemented in C++ and runs under X-window. (A detailed description of its features can be found in [23].) Currently, the rate-monotonic (RM) algorithm [7], deadline-monotonic (DM) algorithm <ref> [8] </ref> and earlist-deadline-first algorithm [7] are supported. The supported resource access control protocols include the non-preemptive critical section approach (NPC) [9], the basic priority-inheritance protocol (PI), priority-ceiling protocol (PCP) [10,13] and the stack-based protocol (SBP) [14]. The priority-ceiling protocol has been extended to handle multiple units of resources.
Reference: 9. <author> Mok, A. K., </author> <title> ``Fundamental Design Problems of Distributed Systems for Hard Real-Time Environment,'' </title> <type> Ph.D. Thesis, </type> <institution> MIT, </institution> <year> 1983. </year>
Reference-contexts: The supported resource access control protocols include the non-preemptive critical section approach (NPC) <ref> [9] </ref>, the basic priority-inheritance protocol (PI), priority-ceiling protocol (PCP) [10,13] and the stack-based protocol (SBP) [14]. The priority-ceiling protocol has been extended to handle multiple units of resources.
Reference: 10. <author> Rajkumar, R., L. Sha and J. P. Lehoczky, </author> <title> ``Real-Time Synchronization of Multiprocessors,'' </title> <booktitle> Proceedings of the 9th Real-Time Systems Symposium, </booktitle> <pages> pp. 259-269, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: In this way, the user can easily do ``what-if'' analyses of different configurations. 4.2. Analysis of Multiprocessor Systems The PERTS schedulability analyzer supports two different and complementary models of multiprocessor systems: the multiprocessor model described in <ref> [10] </ref> and the end-to-end scheduling model described in [27]. In the multiprocessor model, the node on which a resource resides is called its manager. <p> For example, if the system uses the multiprocessor priority-ceiling protocol to control access to global resources, the Blocking buttons in Figure 8 (a) and (b) allow the user to select among four factors: Local Blocking, Global Blocking, Remote Blocking and Deferred Blocking <ref> [10] </ref>. The selection of one of the factors initiates a dialogue that helps the user to understand how much time this factor contributes to the total worst-case blocking time of the selected task.
Reference: 11. <author> Sprunt, B., L. Sha, and J. P. Lehoczky, </author> <title> ``Aperiodic Task Scheduling for Hard Real-Time Systems,'' </title> <journal> Journal of Real-Time Systems, </journal> <pages> pp. 27-60, </pages> <year> 1989. </year>
Reference: 12. <author> Lehoczky, J. P., L. Sha and Y. Ding, </author> <title> ``The Rate Monotone Scheduling Algorithm: Exact Characterization and Average Case Behavior,'' </title> <booktitle> Proceedings of the 10th Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1989. </year>
Reference: 13. <author> Sha, L., R. Rajkumar and J. P. Lehoczky, </author> <title> ``Priority-Inheritance Protocols: An Approach to Real-Time Synchronization,'' </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(9), </volume> <pages> pp. 1175-1185, </pages> <month> September </month> <year> 1990. </year>
Reference: 14. <author> Baker, T. P., </author> <title> ``A Stack-Based Allocation Policy for Real-time Processes,'' </title> <booktitle> Proceedings of IEEE 11th Real-Time Systems Symposium, </booktitle> <pages> pp. 191-200, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Similarly, a reasonably tight sufficient condition exists based on which we can conclude whether the given set of tasks are schedulable according to the earliest-deadline-first algorithm and the stack-based protocol <ref> [14] </ref>. These conditions, called schedulability conditions, are summarized in [23]. They constitute the theoretical basis for the basic schedulability analyzer described in Section 4. We call a test to determine whether all jobs meet their deadlines when scheduled according to a given scheduling algorithm a schedulability test. <p> The supported resource access control protocols include the non-preemptive critical section approach (NPC) [9], the basic priority-inheritance protocol (PI), priority-ceiling protocol (PCP) [10,13] and the stack-based protocol (SBP) <ref> [14] </ref>. The priority-ceiling protocol has been extended to handle multiple units of resources. Aperiodic tasks can be scheduled according to a variety of approaches, including pure or persistant polling (PP), deferrable server (DS) and sporadic server (SS). <p> The height of the bar represents the value of the lefthand side of the inequality. The value of the righthand side is represented by the dashed horizontal line; the displayed value is for i equals to 3. (If the earliest-deadline-first algorithm were used together with SBP <ref> [14] </ref>, the righthand side of the inequality would be 1.) If the bar does not exceed this line, the task T i is surely schedulable.
Reference: 15. <author> Chen, M. I. </author> <title> ``Schedulability Analysis of Resource Access Control Protocols in Real-Time Systems,'' </title> <type> Ph.D. thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1991. </year>
Reference: 16. <author> Gillies, D. and J. W. S. Liu, </author> <title> ``The Complexity of AND/OR Scheduling,'' </title> <booktitle> Proceedings of the 2nd IEEE Conference on Parallel and Distributed Processing, </booktitle> <address> Dallas, Texas, </address> <month> December </month> <year> 1990, </year> <pages> pp. 394-401. </pages>
Reference-contexts: For example, the in-type of a job tells us whether the job is an AND node, which becomes ready for execution only when all of its immediate predecessors are complete, or an OR node, which becomes ready when some of its immediate predecessors are complete <ref> [16] </ref>. The out-type of a job specifies how many of its immediate successors must execute and whether the result of the job's execution has any bearing on which immediate successors execute [17].
Reference: 17. <author> Kim, T., C. L. Liu and J. W. S. Liu, </author> <title> "A Scheduling Algorithm for Conditional Resource Sharing," </title> <booktitle> Proceedings of the IEEE International Conference on Computer-Aided-Design, </booktitle> <month> November </month> <year> 1991, </year> <pages> pp. 84-87. </pages>
Reference-contexts: The out-type of a job specifies how many of its immediate successors must execute and whether the result of the job's execution has any bearing on which immediate successors execute <ref> [17] </ref>. On the other hand, the volume of communication data and the temporal distances [18] between jobs are parameters of the edges connecting them. Similarly, each resource (type) is defined by a set of parameters.
Reference: 18. <author> Han, C. C. and K. J. Lin, </author> <title> ``Scheduling Distance-Constrained Real-Time Tasks,'' </title> <booktitle> Proceedings of the 13th IEEE Real-Time Systems Symposium, </booktitle> <address> Pheonix, Arizona, </address> <month> December </month> <year> 1992. </year>
Reference-contexts: The out-type of a job specifies how many of its immediate successors must execute and whether the result of the job's execution has any bearing on which immediate successors execute [17]. On the other hand, the volume of communication data and the temporal distances <ref> [18] </ref> between jobs are parameters of the edges connecting them. Similarly, each resource (type) is defined by a set of parameters. Some parameters of a resource specify the constraints governing its usage, such as whether it is preemptable, whether it is reusable, etc.
Reference: 19. <author> Silberman, A., </author> <title> ``Task Graph Model,'' in ``RTM: an Object-Oriented, Data-Driven Real-Time Environment,'' </title> <type> Ph.D. </type> <note> thesis in preparation. </note>
Reference-contexts: A resource access control protocol governs the accesses of jobs to resources and resolves conflicts among them. Task and Resource Graphs More specifically, a PERTS task graph is essentially an extended precedence graph as described briefly in the Appendix; its features are fully described in <ref> [19] </ref>. Each job in a task system is represented by a node in the task graph that represents the system. Edges in a task graph are directed; they represent data, temporal and control dependencies between jobs.
Reference: 20. <author> Shih W. K. and J. W. S. Liu, </author> <title> ``On-Line Scheduling of Imprecise Computations to Minimize Total Error,'' </title> <booktitle> Proceedings of the 13th IEEE Real-Time Systems Symposium, Phoenix, Arizona, </booktitle> <pages> pp. 280-289, </pages> <month> December </month> <year> 1992. </year>
Reference: 21. <author> Grimshaw, A., J. W. S. Liu and A. Silberman, </author> <title> ``Real-Time Mentat Programming Language and Architecture,'' </title> <booktitle> Proceedings of the 7th IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <address> Charlottesville, Virginia, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: There is also a preprocessor that automatically extracts task graphs from annotated C++ programs. The preprocessor is based on the one for the RTM (Real-Time Mentat) language <ref> [21] </ref>. This language is an extended C++; the extensions are interpretated in PERTS as annotations. Some of the annotations 9 allow the user to identify the granules of computation that are to be handled by the operating system as jobs.
Reference: 22. <author> Graham, R. L., </author> <title> ``Bounds on multiprocessing timing anomalies,'' </title> <journal> SIAM J. Appl. Math., </journal> <volume> vol. 17, </volume> <pages> pp. 263-269, </pages> <year> 1969. </year>
Reference-contexts: Graham has shown that the completion time of a set of jobs can be later when more processors are used to execute them and when jobs have shorter execution times and fewer dependencies <ref> [22] </ref>. <p> Some usable theoretical results do exist. For example, a well-known result is the worst-case bound of 2 - 1/m on the response time of a set of jobs with identical release times when the jobs are dynamically scheduled on m processors <ref> [22] </ref>. This bound can be used as a sufficient schedulability condition in a way analogous to the worst-case schedulable bounds based on the periodic-task model.
Reference: 23. <author> Redondo, J. L., </author> <title> ``Schedulability Analyzer Tool,'' </title> <type> Technical Report No. </type> <institution> UIUCDCS-R-93-1791, Department of Computer Science, University of Illinois, </institution> <month> February </month> <year> 1993. </year> <month> 32 </month>
Reference-contexts: Similarly, a reasonably tight sufficient condition exists based on which we can conclude whether the given set of tasks are schedulable according to the earliest-deadline-first algorithm and the stack-based protocol [14]. These conditions, called schedulability conditions, are summarized in <ref> [23] </ref>. They constitute the theoretical basis for the basic schedulability analyzer described in Section 4. We call a test to determine whether all jobs meet their deadlines when scheduled according to a given scheduling algorithm a schedulability test. <p> BASIC SCHEDULABILITY ANALYZER This section describes the functionality of the basic schedulability analyzer and its window-based user interface. This system of tools is implemented in C++ and runs under X-window. (A detailed description of its features can be found in <ref> [23] </ref>.) Currently, the rate-monotonic (RM) algorithm [7], deadline-monotonic (DM) algorithm [8] and earlist-deadline-first algorithm [7] are supported. The supported resource access control protocols include the non-preemptive critical section approach (NPC) [9], the basic priority-inheritance protocol (PI), priority-ceiling protocol (PCP) [10,13] and the stack-based protocol (SBP) [14]. <p> Their deadlines can be 15 figures 5 and 6 16 guaranteed only when their worst-case execution times and minimum interarrival times are known. The analyzer creates a sporadic server for each aperiodic task with a hard deadline based on these worst-case values, following the rules described in <ref> [23] </ref>. This initial mapping is summarized by the window shown in Figure 6. The window has three panels. The first panel contains a description of the periodic servers.
Reference: 24. <author> Kenny, K.B. and K. J. Lin, </author> <title> ``Measuring and Analyzing the Performances of Real-Time Programs,'' </title> <journal> IEEE Software, </journal> <month> September </month> <year> 1991. </year>
Reference-contexts: We will port some of the existing timing analysis and measurement tools and use them as a starting point. Determining execution time has traditionally been attacked in two ways: through analyzing the code of a job (e.g., [25,26]) and by measuring the actual execution time of a job (e.g. <ref> [24] </ref>). The benefit of analyzing the code is that it is possible to determine the path through the job that leads to the longest execution time. The problem still remains to compute the execution time of straight-line code, which is difficult if not impossible to do on complex modern processors.
Reference: 25. <author> Park, C. Y., </author> <title> ``Predicting Deterministic Execution Times of Real-Time Programs,'' </title> <type> Technical Report No. </type> <institution> 92-08-02, Department of Computer Science and Engineering, University of Washington, </institution> <month> August </month> <year> 1992. </year>
Reference: 26. <author> Baker, T. P. and D. B. Whalley, </author> <title> ``A Retargetable Technique for Predicting Execution Time,'' </title> <booktitle> Proceedings of the 13th IEEE Real-Time Systems Symposium, Phoenix, Arizona, </booktitle> <pages> pp. 64-77, </pages> <month> December </month> <year> 1992. </year>
Reference: 27. <author> Bettati, R. and J. W. S. Liu, </author> <title> ``End-to-End Scheduling to Meet Deadlines in Distributed Systems,'' </title> <booktitle> Proceedings of the 12th International Conference on Distributed Computing Systems, </booktitle> <address> Yokohama, Japan, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: In this way, the user can easily do ``what-if'' analyses of different configurations. 4.2. Analysis of Multiprocessor Systems The PERTS schedulability analyzer supports two different and complementary models of multiprocessor systems: the multiprocessor model described in [10] and the end-to-end scheduling model described in <ref> [27] </ref>. In the multiprocessor model, the node on which a resource resides is called its manager. A resource is global if it is required and accessed by tasks assigned to nodes different from its 23 manager; it is local if it is only required by tasks assigned to its manager.
Reference: 28. <author> Storch, M. F. and J. W. S. Liu, </author> <title> ``Heuristic Algorithms for Periodic Job Assignment,'' </title> <booktitle> Proceedings of IEEE Workshop on Parallel and Distributed Real-Time Systems, </booktitle> <address> Newport Beach, CA, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: The task (resource) is removed from the panel and assigned to the node. The dialogue also supports automatic task assignment. The Bind option provided in the System menu allows the user to select one of the available strategies, which currently include the heuristic and enumerative algorithms described in <ref> [28] </ref>. The cost/benefit criteria used by these algorithms, as well as most other existing algorithms, are appropriate for the end-to-end scheduling model but are not ideal for the multiprocessor model.
Reference: 29. <author> Liu, J. W. S. and C. L. Liu, </author> <title> ``Performance Analysis of Multiprocessor Systems Containing Functional Dedicated Processors,'' </title> <journal> Acta Informatica, </journal> <volume> 10, </volume> <pages> pp. 95-104, </pages> <year> 1978. </year>

References-found: 29

